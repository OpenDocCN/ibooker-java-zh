# 第十一章。数据库性能最佳实践

本章调查了由 Java 驱动的数据库应用程序的性能。访问数据库的应用程序受非 Java 性能问题的影响：如果数据库受 I/O 限制，或者执行需要全表扫描的 SQL 查询（因为缺少索引），那么无论多少 Java 调优或应用编码都无法解决性能问题。在处理数据库技术时，准备好从其他来源学习如何调优和编程数据库。

这并不意味着使用数据库的应用程序的性能对 JVM 和所使用的 Java 技术下的事物不敏感。相反，为了良好的性能，有必要确保数据库和应用程序都正确调优并执行最佳代码。

本章首先从 JDBC 驱动程序开始，因为这些驱动程序会影响与关系数据库对话的数据框架。许多框架都会抽象出 JDBC 的细节，包括 JPA 和 Spring 数据模块。

# 样例数据库

本章的示例使用了一个样例数据库设置，用于存储 256 个股票实体在一年期间的数据。该年有 261 个工作日。

单个股票的价格存储在名为 STOCKPRICE 的表中，该表具有股票符号和日期的主键。该表中有 66,816 行（256 × 261）。

每支股票都有一组五个相关的期权，这些期权也是按日定价的。STOCKOPTIONPRICE 表保存了具有符号、日期和表示期权号码的整数的数据，该表中有 334,080 行（256 × 261 × 5）。

# JDBC

本章介绍了从 JPA 版本 2.*x*的角度来看数据库性能。然而，JPA 在内部使用 JDBC，并且许多开发人员仍然直接向 JDBC API 编写应用程序，因此重要的是要查看 JDBC 的最重要性能方面。即使是使用 JPA（或类似于 Spring Data 的其他数据库框架）的应用程序，了解 JDBC 性能也将有助于从框架中获得更好的性能。

## JDBC 驱动程序

JDBC 驱动程序是数据库应用程序性能的最重要因素。数据库配备了各自的 JDBC 驱动程序，并且大多数流行的数据库都有备用的 JDBC 驱动程序可用。这些备用驱动程序通常被认为提供更好的性能。

不可能裁决所有数据库驱动程序的性能声明，但在评估驱动程序时需要考虑以下几点。

### 工作执行地点

JDBC 驱动程序可以编写以在 Java 应用程序（数据库客户端）中执行更多工作，或者在数据库服务器上执行更多工作。最好的例子是 Oracle 数据库的轻量和重量驱动程序。*轻量驱动程序* 的设计使其在 Java 应用程序内占用的空间相对较小：它依赖于数据库服务器执行更多处理。*重量驱动程序* 则相反：它从数据库卸载工作，但需要在 Java 客户端上进行更多处理和占用更多内存。大多数数据库都可以做出这种权衡。

竞争性声明对于哪种模型提供更好性能存在分歧。事实是，这两种模型都没有固有优势——提供最佳性能的驱动程序取决于其运行环境的具体情况。例如，如果一个应用主机是一台小型双核机器连接到一个巨大而经过调整的数据库，那么应用主机的 CPU 在数据库承受任何重要负载之前可能会饱和。在这种情况下，轻量驱动程序将提供更好的性能。相反，如果一个企业有 100 个部门访问单个 HR 数据库，则如果保留数据库资源并且客户端部署了重量驱动程序，则将获得最佳性能。^(1)

在涉及 JDBC 驱动程序时，任何性能声明都值得怀疑：很容易选择一款适合特定环境的驱动程序，并展示它优于另一家供应商在完全相同设置下表现不佳的驱动程序。像往常一样，在您自己的环境中进行测试，并确保该环境与您将要部署的环境相匹配。

### JDBC 驱动程序类型

JDBC 驱动程序有四种类型（1–4）。目前广泛使用的驱动程序类型是类型 2（使用本地代码）和类型 4（纯 Java）。

类型 1 驱动程序提供了 ODBC 和 JBDC 之间的桥梁。如果应用程序必须使用 ODBC 与数据库通信，则必须使用此驱动程序。类型 1 驱动程序通常性能较差；只有在必须通过 ODBC 协议与传统数据库通信时才会选择它。

类型 3 驱动程序与类型 4 驱动程序一样，完全由 Java 编写，但它们设计用于一种特定架构，其中一个中间件（有时，尽管通常不是应用服务器）提供中介翻译。在此架构中，一个 JDBC 客户端（通常是一个独立程序，尽管理论上可以是应用服务器）向中间件发送 JDBC 协议，中间件将请求翻译成数据库特定协议，并将请求转发到数据库（并对响应执行反向翻译）。

在某些情况下，这种架构是必需的：中间件可以位于网络的去军事化区域（DMZ），并为与数据库的连接提供额外的安全性。从性能的角度来看，存在潜在的优势和劣势。中间件可以自由缓存数据库信息，从而减轻数据库的负担（使其更快），并更早地将数据返回给客户端（减少请求的延迟）。但是，如果没有进行缓存，性能将会受到影响，因为现在需要执行两个往返网络请求来执行数据库操作。在理想情况下，这些将会达到平衡（或者缓存将更快）。

但实际情况是，这种架构实际上并没有被广泛采纳。通常更容易将服务器本身放在中间层（包括需要时放在 DMZ 中）。服务器然后可以执行数据库操作，但无需为客户端提供 JDBC 接口：最好是提供 servlet 接口、Web 服务接口等，将客户端与数据库的任何知识隔离开来。

这留下了 Type 2 和 Type 4 驱动器，两者都非常受欢迎，也没有一个在性能上有固有的优势。

Type 2 驱动器使用本地库访问数据库。这些驱动器在某些数据库供应商中很受欢迎，因为它们允许 Java 驱动器利用多年来用于编写其他程序访问数据库的 C 库的工作。由于依赖本地库，部署更加困难：数据库供应商必须为驱动器提供特定平台的本地库，并且 Java 应用程序必须设置环境变量来使用该库。尽管如此，考虑到供应商已经投入到 C 库的工作，Type 2 驱动器往往表现非常出色。

Type 4 驱动器是纯 Java 驱动器，实现了数据库供应商为访问其数据库定义的协议。因为它们完全由 Java 编写，所以部署非常简单：应用程序只需将一个 JAR 文件添加到其类路径中。Type 4 驱动器通常与 type 2 驱动器一样性能良好，因为它们都使用相同的协议。从供应商的角度来看，Type 4 驱动器可能是额外的编码工作，但从用户的角度来看，它们通常是最容易使用的。

不要将驱动程序类型（2 或 4）与前面讨论的驱动程序被视为厚或薄混为一谈。确实，Type 2 驱动器倾向于较厚，而 Type 4 驱动器倾向于较薄，但这不是必须的。最终，Type 2 或 Type 4 驱动器哪个更好取决于环境和具体的驱动程序。没有一种先验方法可以知道哪种表现更好。

# 快速总结

+   花些时间评估应用程序最适合的 JDBC 驱动器。

+   最佳驱动程序通常会根据特定的部署情况而异。同一应用程序可能在一个部署中使用一种 JDBC 驱动程序，在另一个部署中使用不同的 JDBC 驱动程序。

+   如果可以选择，应避免使用 ODBC 和类型 1 的 JDBC 驱动程序。

## JDBC 连接池

数据库连接的建立非常耗时，因此在 Java 中，JDBC 连接是另一个应该重复使用的典型对象。

在大多数服务器环境中，所有 JDBC 连接都来自服务器的连接池。在具有 JPA 的 Java SE 环境中，大多数 JPA 提供程序将透明地使用连接池，并且您可以在*persistence.xml*文件中配置连接池。在独立的 Java SE 环境中，连接必须由应用程序管理。为了处理最后一种情况，可以使用许多来源提供的几个连接池库之一。但通常情况下，对于独立应用程序中的每个线程，更容易创建一个连接并将其存储在线程本地变量中。

通常情况下，重要的是在池化对象占用的内存和池化操作会触发的额外 GC 量之间达到正确的平衡。这一点尤为重要，因为我们将在下一节中检查的准备语句缓存存在。

在这种情况下，达到正确的平衡也适用于数据库。每个连接到数据库都需要数据库资源（除了应用程序中持有的内存）。随着连接被添加到数据库中，数据库需要更多资源：它将为 JDBC 驱动程序使用的每个准备语句分配额外的内存。如果应用程序服务器有太多打开的连接，可能会对数据库性能造成不利影响。

连接池的一般经验法则是每个应用程序线程一个连接。在服务器上，首先将线程池的大小和连接池的大小设置为相同。在独立应用程序中，根据应用程序创建的线程数量设置连接池的大小。通常情况下，这将提供最佳性能：程序中的任何线程都不必等待数据库连接可用，而且数据库通常有足够的资源来处理应用程序施加的负载。

然而，如果数据库成为瓶颈，这个规则可能会适得其反。连接过多到一个容量不足的数据库，是将负载注入繁忙系统降低性能的另一个例子。在这种情况下，使用连接池来控制发送到容量不足数据库的工作量是提高性能的方法。应用程序线程可能需要等待空闲连接，但如果不过度负担数据库，系统的总吞吐量将会最大化。

# 快速摘要

+   连接是昂贵的初始化对象；它们在 Java 中经常被池化——要么在 JDBC 驱动程序本身内，要么在 JPA 和其他框架内。

+   与其他对象池一样，调整连接池以避免对垃圾收集器产生不利影响非常重要。在这种情况下，还需要调整连接池以避免对数据库性能产生不利影响。

## 预处理语句和语句池

在大多数情况下，代码应该使用`PreparedStatement`而不是`Statement`进行 JDBC 调用。这有助于性能：预处理语句允许数据库重复使用正在执行的 SQL 的信息。这样可以节省数据库在后续执行预处理语句时的工作量。预处理语句还具有安全性和编程优势，特别是在指定调用参数时。

这里的关键词是*重用*：预处理语句的第一次使用需要更多时间来执行，因为它必须设置和保存信息。如果语句仅被使用一次，那么这些工作将被浪费；在这种情况下最好使用常规语句。

当只有少量数据库调用时，`Statement`接口将使应用程序更快完成。但即使是面向批处理的程序也可能对同几条 SQL 语句进行数百或数千次的 JDBC 调用；本章的后续示例将使用批处理程序将其 400,896 条记录加载到数据库中。具有许多 JDBC 调用的批处理程序——以及将服务于许多请求的服务器——最好使用`PreparedStatement`接口（数据库框架将自动执行此操作）。

当预处理语句对象被重复使用时，它们提供性能优势——即池化时。为了正确池化，必须考虑两件事：JDBC 连接池和 JDBC 驱动程序配置。^(2) 这些配置选项适用于任何直接或通过框架使用 JDBC 的程序。

### 设置语句池

准备好的语句池是基于每个连接操作的。如果程序中的一个线程从池中取出一个 JDBC 连接，并在该连接上使用一个准备好的语句，那么与该语句相关的信息仅对该连接有效。使用第二个连接的第二个线程最终将建立第二个语句池的实例。最终，每个连接对象将在应用程序中拥有自己的所有准备好的语句的池（假设它们在应用程序的生命周期内都被使用）。

这也是独立的 JDBC 应用程序应该使用连接池的一个原因。这也意味着连接池的大小对 JDBC 和 JPA 程序都很重要。特别是在程序的早期执行阶段，当尚未使用特定准备好的语句的连接被使用时，第一个请求会稍微慢一些。

连接池的大小也很重要，因为它正在缓存那些准备好的语句，这些语句占用堆空间（通常是大量的堆空间）。在这种情况下，对象重用当然是一件好事，但你必须意识到这些可重用对象占用了多少空间，并确保它不会对 GC 时间产生负面影响。

### 管理语句池

关于准备好的语句池的第二个考虑是哪段代码实际上将创建和管理该池。这是通过使用`ConnectionPoolDataSource`类的`setMaxStatements()`方法来启用或禁用语句池来完成的。如果传递给`setMaxStatements()`方法的值为 0，则禁用语句池。该接口明确不定义语句池应该发生在何处——无论是在 JDBC 驱动程序中还是在另一层，比如应用服务器中。对于某些需要额外配置的 JDBC 驱动程序来说，这单一接口是不够的。

因此，在编写直接使用 JDBC 调用的 Java SE 应用程序时，我们有两个选择：要么配置 JDBC 驱动程序以创建和管理语句池，要么在应用程序代码中创建和管理池。在使用框架时，语句池通常由框架管理。

棘手的问题在于在这个领域中不存在标准。一些 JDBC 驱动程序根本不提供池语句的机制；它们期望仅在执行语句池的应用服务器中使用，并且希望提供一个更简单的驱动程序。一些应用服务器不提供和管理池；它们期望 JDBC 驱动程序处理该任务，并且不希望复杂化其代码。这两种观点都有其优点（尽管一个不提供语句池的 JDBC 驱动程序会给独立应用程序的开发者带来负担）。最终，你将不得不筛选这个景观，并确保语句池在某处被创建。

由于没有标准，您可能会遇到这样一种情况：JDBC 驱动程序和数据层框架都能够管理准备好的语句池。在这种情况下，重要的是只配置其中一个来执行此操作。从性能的角度来看，更好的选择将再次取决于驱动程序和服务器的确切组合。作为一般规则，您可以期望 JDBC 驱动程序执行更好的语句池。由于驱动程序（通常）是针对特定数据库的，因此可以预期它会为该数据库进行更好的优化，而不像更通用的应用服务器代码那样。

要为特定的 JDBC 驱动程序启用语句池（或缓存），请参阅该驱动程序的文档。在许多情况下，您只需设置驱动程序，以便 `maxStatements` 属性设置为所需的值（即语句池的大小）。其他驱动程序可能需要其他设置：例如，Oracle JDBC 驱动程序要求设置特定属性以告知其是否使用隐式或显式语句缓存，并且 MySQL 驱动程序要求您设置一个属性以启用语句缓存。

# 快速总结

+   Java 应用程序通常会重复执行相同的 SQL 语句。在这些情况下，重用准备好的语句将显著提高性能。

+   准备好的语句必须基于每个连接进行池化。大多数 JDBC 驱动程序和数据框架可以自动执行此操作。

+   准备好的语句可能会消耗大量堆内存。必须仔细调整语句池的大小，以防止过多的非常大的对象引发 GC 问题。

## 事务

应用程序具有最终决定如何处理事务的正确性要求。需要可重复读语义的事务将比仅需要读取已提交语义的事务慢，但是对于不能容忍非可重复读的应用程序来说，了解这一点并没有太大的实际好处。因此，虽然本节讨论了如何为应用程序使用最不具侵入性的隔离语义，但是不要让速度的愿望克服应用程序的正确性。

数据库事务有两个性能惩罚。首先，数据库设置和提交事务需要时间。这涉及确保对数据库的更改完全存储在磁盘上，数据库事务日志是一致的等等。其次，在数据库事务期间，常常会为特定数据集（不一定是行，但我将在此处使用它作为示例）获取锁。如果两个事务竞争对同一数据库行的锁定，应用程序的可扩展性将会受到影响。从 Java 的角度来看，这与第九章中关于有争议和无争议锁定的讨论完全类似。

为了实现最佳性能，考虑这两个问题：如何编写事务使得事务本身高效，以及如何在事务期间在数据库上持有锁，以便整个应用程序可以扩展。

### JDBC 事务控制

JDBC 和 JPA 应用程序中均存在事务，但 JPA 以不同的方式管理事务（这些细节将在本章后面讨论）。对于 JDBC，事务的开始和结束取决于如何使用 Connection 对象。

在基本的 JDBC 使用中，连接具有自动提交模式（通过`setAutoCommit()`方法设置）。如果自动提交被打开（对于大多数 JDBC 驱动程序来说，这是默认的），JDBC 程序中的每个语句都是其自身的事务。在这种情况下，程序不需要执行任何操作来提交事务（事实上，如果调用`commit()`方法，性能通常会受到影响）。

如果关闭了自动提交，当连接对象的第一次调用（例如通过调用`executeQuery()`方法）时，事务会隐式开始。事务将持续到调用`commit()`方法（或`rollback()`方法）。在下次数据库调用时，连接将开始新的事务。

提交事务的成本很高，因此一个目标是尽可能多地在一个事务中执行工作。不幸的是，这个原则与另一个目标完全对立：因为事务可能持有锁，所以事务应该尽可能短暂。这里肯定存在一个平衡点，而找到这个平衡将取决于应用程序及其锁定需求。下一节将详细讨论事务隔离和锁定，首先让我们看看优化事务处理本身的选项。

考虑一些插入数据到数据库供股票应用程序使用的示例代码。对于每天的有效数据，必须向 STOCKPRICE 表插入一行数据，并向 STOCKOPTIONPRICE 表插入五行数据。一个完成这些操作的基本循环如下所示：

```java
try (Connection c = DriverManager.getConnection(URL, p)) {
    try (PreparedStatement ps = c.prepareStatement(insertStockSQL);
         PreparedStatement ps2 = c.prepareStatement(insertOptionSQL)) {
        for (StockPrice sp : stockPrices) {
            String symbol = sp.getSymbol();
            ps.clearParameters();
            ps.setBigDecimal(1, sp.getClosingPrice());
	    ... set other parameters ...
            ps.executeUpdate();
            for (int j = 0; j < 5; j++) {
                ps2.clearParameters();
                ps2.setBigDecimal(1,
                    sp.getClosingPrice().multiply(
                        new BigDecimal(1 + j / 100.)));
                ... set other parameters ...
                ps2.executeUpdate();
            }
        }
    }
}
```

在完整的代码中，价格预先计算到`stockPrices`数组中。如果该数组表示 2019 年的数据，这个循环将通过第一次调用`executeUpdate()`方法向 STOCKPRICE 表中插入 261 行，并通过`for`循环向 STOCKOPTIONPRICE 表中插入 1,305 行。在默认的自动提交模式下，这意味着 1,566 个单独的事务，这将是非常昂贵的。

如果禁用自动提交模式并在循环结束时执行显式提交，将实现更好的性能：

```java
try (Connection c = DriverManager.getConnection(URL, p)) {
    c.setAutoCommit(false);
    try (PreparedStatement ps = c.prepareStatement(insertStockSQL);
         PreparedStatement ps2 = c.prepareStatement(insertOptionSQL)) {
        ... same code as before ....
    }
    c.commit();
}
```

从逻辑上讲，这也可能是有道理的：数据库最终将具有整年的数据或者没有数据。

如果此循环为多个股票重复进行，则可以选择一次性提交所有数据或一次性提交一个符号的所有数据：

```java
try (Connection c = DriverManager.getConnection(URL, p)) {
    c.setAutoCommit(false);
    String lastSymbol = null;
    try (PreparedStatement ps = c.prepareStatement(insertStockSQL);
         PreparedStatement ps2 = c.prepareStatement(insertOptionSQL)) {
        for (StockPrice sp : stockPrices) {
	    String symbol = sp.getSymbol();
	    if (lastSymbol != null && !symbol.equals(lastSymbol)) {
		// We are processing a new symbol; commit the previous symbol
	        c.commit();
	    }
	}
    }
    c.commit();
}
```

将所有数据一次性提交提供了最快的性能。然而，在这个例子中，应用程序语义可能要求每年的数据都单独提交。有时，其他要求可能会干扰到尝试获得最佳性能的努力。

在前述代码中每次执行 `executeUpdate()` 方法时，都会向数据库发出远程调用并执行相应的工作。此外，在进行更新时会发生锁定（至少可以确保另一个事务不能在相同的符号和日期上插入记录）。在这种情况下，通过批量插入可以进一步优化事务处理。当插入被批处理时，JDBC 驱动程序会将它们保持，直到批次完成；然后所有语句一起通过远程 JDBC 调用传输。

这里是批处理的实现方式：

```java
try (Connection c = DriverManager.getConnection(URL, p)) {
    try (PreparedStatement ps = c.prepareStatement(insertStockSQL);
         PreparedStatement ps2 = c.prepareStatement(insertOptionSQL)) {
        for (StockPrice sp : stockPrices) {
            String symbol = sp.getSymbol();
            ps.clearParameters();
            ps.setBigDecimal(1, sp.getClosingPrice());
	    ... set other parameters ...
            ps.addBatch();
            for (int j = 0; j < 5; j++) {
                ps2.clearParameters();
                ps2.setBigDecimal(1,
                    sp.getClosingPrice().multiply(
                        new BigDecimal(1 + j / 100.)));
                ... set other parameters ...
                ps2.addBatch();
            }
        }
	ps.executeBatch();
	ps2.executeBatch();
    }
}
```

代码同样可以选择按每支股票的方式执行每个批处理（类似于我们在每个股票符号更改后提交的方式）。某些 JDBC 驱动程序对它们可以批处理的语句数量有限制（并且批次在应用程序中会消耗内存），因此即使在整个操作结束时数据被提交，批次可能仍然需要更频繁地执行。

这些优化可以大幅提升性能。表 11-1 显示了为 256 支股票插入一年数据所需的时间（共计 400,896 次插入）。

表 11-1\. 插入 256 支股票数据所需的秒数

| 编程模式 | 所需时间 | 数据库调用 | 数据库提交 |
| --- | --- | --- | --- |
| 启用自动提交，无批处理 | 537 ± 2 秒 | 400,896 | 400,896 |
| 每支股票 1 提交 | 57 ± 4 秒 | 400,896 | 256 |
| 所有数据 1 批次/1 提交 | 56 ± 14 秒 | 400,448 | 1 |
| 每支股票 1 批次/每提交 1 次 | 4.6 ± 2 秒 | 256 | 256 |
| 每支股票 1 批次/1 提交 | 3.9 ± 0.7 秒 | 256 | 1 |
| 全部数据 1 批次/1 提交 | 3.8 ± 1 秒 | 1 | 1 |

这张表中有一个有趣的事实并不立即显而易见：第 1 行和第 2 行的区别在于自动提交已关闭，并且代码在每个 `while` 循环结束时显式调用了 `commit()` 方法。第 1 行和第 4 行之间的区别在于语句被批量处理，但是自动提交仍然是启用状态。一个批次被视为一个事务，这就是为什么数据库调用和提交之间存在一对一的对应关系（并且消除超过 400,000 次调用可以带来显著的加速）。

值得注意的是，提交数据的调用次数从 400,896 次到 256 次之间的差异是数量级的差别，但是在 1 次和 256 次提交之间的差异并不显著（即第 2 行和第 3 行之间的差异，或第 5 行和第 6 行之间的差异）。提交数据的速度足够快，以至于当调用次数为 256 次时，额外开销只是噪音；但当调用次数达到 400,896 次时，这些开销将累积起来。^(3)

### 事务隔离和锁定

影响事务性能的第二个因素涉及数据库的可伸缩性，因为事务内的数据被锁定。锁定保护数据完整性；在数据库术语中，它允许一个事务与其他事务隔离。JDBC 和 JPA 支持数据库的四种主要事务隔离模式，尽管它们在实现方式上有所不同。

隔离模式在此简要介绍，尽管正确选择隔离模式并非 Java 特定问题，建议查阅数据库编程书籍以获取更多信息。

这里是基本的事务隔离模式（按从昂贵到廉价的顺序）：

TRANSACTION_SERIALIZABLE

这是最昂贵的事务模式；它要求事务期间访问的所有数据都被锁定。这适用于通过主键访问的数据和通过`WHERE`子句访问的数据——当存在`WHERE`子句时，表被锁定，以使不能添加满足子句的新记录至事务结束。序列化事务每次发出查询时都将看到相同的数据。

TRANSACTION_REPEATABLE_READ

这要求事务期间所有访问的数据都被锁定。然而，其他事务可以随时向表中插入新行。这种模式可能导致*幻读*：重新执行带有`WHERE`子句的查询时，事务可能会获得不同的数据。

TRANSACTION_READ_COMMITTED

此模式仅锁定事务期间写入的行。这导致*不可重复读*：事务中某一时间点读取的数据可能与事务中另一时间点读取的数据不同。

TRANSACTION_READ_UNCOMMITTED

这是最经济的事务模式。不涉及锁定，因此一个事务可以读取另一个事务中已写入但未提交的数据。这称为*脏读*；问题在于第一个事务可能会回滚（意味着写入实际上没有发生），因此第二个事务操作的是不正确的数据。

数据库以事务隔离的默认模式运行：MySQL 默认使用`TRANSACTION_REPEATABLE_READ`；Oracle 和 IBM Db2 默认使用`TRANSACTION_READ_COMMITTED`；等等。这里有很多特定于数据库的变体。Db2 将其默认事务模式称为`CS`（代表*游标稳定性*），并为其他三种 JDBC 模式使用了不同的名称。Oracle 不支持`TRANSACTION_READ_UNCOMMITTED`和`TRANSACTION_REPEATABLE_READ`这两种模式。

当执行 JDBC 语句时，它使用数据库的默认隔离模式。另外，可以调用 JDBC 连接上的 `setTransaction()` 方法来让数据库提供必要的事务隔离级别（如果数据库不支持给定级别，则 JDBC 驱动程序将抛出异常或者悄悄地将隔离级别升级为它支持的下一个最严格的级别）。

对于简单的 JDBC 程序，这就足够了。更常见的做法是——尤其是在与 JPA 结合使用时——程序可能需要在事务中混合使用数据的隔离级别。在一个查询我的员工信息以便最终给我加薪的应用程序中，必须保护对我的员工记录的访问：该数据需要被视为 `TRANSACTION_REPEATABLE_READ`。但该事务还可能访问其他表中的数据，比如保存我的办公室 ID 的表。在事务期间锁定那些数据没有真正的理由，因此对该行的访问肯定可以作为 `TRANSACTION_READ_COMMITTED` 运行（甚至可能更低）。

JPA 允许您按照每个实体的基础指定锁定级别（当然，实体至少通常是数据库中的一行）。因为正确设置这些锁定级别可能很困难，所以使用 JPA 比在 JDBC 语句中执行锁定要容易得多。尽管如此，在 JDBC 应用程序中使用不同的锁定级别是可能的，它使用与 JPA 相同的悲观和乐观锁定语义（如果您不熟悉这些语义，这个例子应该是一个很好的介绍）。

在 JDBC 层面，基本的方法是将连接的隔离级别设置为 `TRANSACTION_READ_UNCOMMITTED`，然后仅在事务期间显式锁定需要锁定的数据：

```java
try (Connection c = DriverManager.getConnection(URL, p)) {
    c.setAutoCommit(false);
    c.setTransactionIsolation(TRANSACTION_READ_UNCOMMITTED);
    try (PreparedStatement ps1 = c.prepareStatement(
        "SELECT * FROM employee WHERE e_id = ? FOR UPDATE")) {
        ... process info from ps1 ...
    }
    try (PreparedStatement ps2 = c.prepareStatement(
           "SELECT * FROM office WHERE office_id = ?")) {
        ... process info from ps2 ...
    }
    c.commit();
}
```

`ps1` 语句在员工数据表上建立了显式锁定：在此事务期间，其他事务将无法访问该行。实现这一目标的 SQL 语法是非标准的。您必须查阅数据库供应商的文档，了解如何实现所需的锁定级别，但常见的语法是包含 `FOR UPDATE` 子句。这种类型的锁定称为 *悲观锁定*。它积极地阻止其他事务访问相关数据。

通过使用乐观锁定，锁定性能通常可以得到改善。如果数据访问没有竞争，这将是一个显著的性能提升。然而，如果数据甚至有轻微的竞争，编程会变得更加困难。

在数据库中，乐观并发是通过版本列实现的。当从行中选择数据时，选择必须包括所需数据以及版本列。要选择关于我的信息，我可以执行以下 SQL：

```java
SELECT first_name, last_name, version FROM employee WHERE e_id = 5058;
```

这个查询将返回我的姓名（斯科特和奥克斯），以及当前版本号（比如，1012）。当完成交易时，事务会更新版本列：

```java
UPDATE employee SET version = 1013 WHERE e_id = 5058 AND version = 1012;
```

如果涉及的行需要可重复读或串行化语义，即使在事务期间仅读取数据，也必须执行此更新——这些隔离级别要求锁定事务中使用的只读数据。对于读提交语义，只有在行中的其他数据也更新时，才需要更新版本列。

根据此方案，如果两个事务同时使用我的员工记录，每个事务将读取版本号 1012。首个完成的事务将成功将版本号更新为 1013 并继续。第二个事务将无法更新员工记录——不再存在版本号为 1012 的记录，因此 SQL 更新语句将失败。该事务将收到异常并回滚。

这突显了数据库中乐观锁定与 Java 原子基元之间的主要区别：在数据库编程中，当事务收到异常时，不能透明地重试。如果您直接编程到 JDBC，则`commit()`方法将获得`SQLException`；在 JPA 中，当事务提交时，应用程序将获得`OptimisticLockException`。

根据您的角度不同，这或许是好事，也或许是坏事。在第九章中，我们讨论了使用 CAS 基础特性的原子实用程序的性能，以避免显式同步。这些实用程序基本上使用乐观并发性，具有无限的自动重试。在高度竞争的情况下，性能会受到影响，因为大量重试会消耗大量 CPU 资源，尽管在实践中这通常不是问题。在数据库中，情况要严重得多，因为在事务中执行的代码比简单增加内存位置中的值要复杂得多。在数据库中重试失败的乐观事务可能导致无休止的重试螺旋，这种潜力要远远大于在内存中的情况。此外，自动确定要重试的操作（或操作）通常是不可行的。

因此，不透明地重试是一件好事（而且通常是唯一可能的解决方案），但另一方面，这意味着应用现在负责处理异常。应用程序可以选择重试事务（也许只重试一次或两次），可以选择提示用户获取不同的数据，或者可以简单地通知用户操作失败。没有一种适合所有情况的答案。

乐观锁定在两个源之间几乎不会发生碰撞时效果最佳。想象一个联合支票账户：我丈夫和我在同一时间可能在城市的不同地方从我们的支票账户中取款，有一点点可能性会导致乐观锁定异常。即使确实发生了这种情况，要求其中一个再试一次也不会太繁重，现在乐观锁定异常的几率几乎为零（或者我希望如此；我们不要讨论我们多频繁地进行 ATM 取款）。将这种情况与涉及样本股票应用程序的情况进行对比。在现实世界中，这些数据更新频率如此之高，以至于乐观锁定将是适得其反的。事实上，由于变化量巨大，实际股票应用程序在可能的情况下经常不使用锁定，尽管实际交易更新可能需要一些锁定。

# 快速总结

+   事务以两种方式影响应用程序的速度：事务提交的成本很高，并且与事务相关的锁定可能阻止数据库扩展。

+   这两个效果是对立的：等待提交事务的时间过长会增加持有事务相关锁定的时间。特别是对于使用更严格语义的事务，应该更倾向于更频繁地提交而不是保持锁定更长时间。

+   为了在 JDBC 中对事务进行精细控制，使用默认的 `TRANSACTION_READ_UNCOMMITTED` 级别，并根据需要显式锁定数据。

## 结果集处理

典型的数据库应用程序将处理一系列数据。例如，股票应用程序处理个股的价格历史。该历史通过单个 `SELECT` 语句加载：

```java
SELECT * FROM stockprice WHERE symbol = 'TPKS' AND
	pricedate >= '2019-01-01' AND pricedate <= '2019-12-31';
```

该语句返回了 261 行数据。如果还需要股票的期权价格，则执行类似的查询，将检索到五倍数量的数据。检索示例数据库中所有数据（涵盖一年的 256 只股票）的 SQL 将检索到 400,896 行数据：

```java
SELECT * FROM stockprice s, stockoptionprice o WHERE
	o.symbol = s.symbol AND s.pricedate >= '2019-01-01'
	AND s.pricedate <= '2019-12-31';
```

要使用这些数据，代码必须滚动浏览结果集：

```java
try (PreparedStatement ps = c.prepareStatement(...)) {
    try (ResultSet rs = ps.executeQuery()) {
        while (rs.next()) {
            ... read the current row ...
        }
    }
}
```

这里的问题是 400,896 行数据的数据存放在哪里。如果在 `executeQuery()` 调用期间返回整个数据集，应用程序将在其堆中拥有非常大的活动数据块，可能导致 GC 和其他问题。相反，如果从 `next()` 方法调用返回了一行数据，则应用程序与数据库之间将发生大量来回的流量，因为结果集正在处理中。

通常情况下，这里没有正确的答案；在某些情况下，将大部分数据保留在数据库中，并根据需要检索数据可能更有效率，而在其他情况下，当执行查询时一次性加载所有数据可能更有效率。为了控制这一点，在`PreparedStatement`对象上使用`setFetchSize()`方法，让 JDBC 驱动程序知道每次应传输多少行数据。

这个默认值因 JDBC 驱动程序而异；例如，在 Oracle 的 JDBC 驱动程序中，默认值为 10。当在先前显示的循环中调用`executeQuery()`方法时，数据库将返回 10 行数据，并由 JDBC 驱动程序在内部缓冲。前 10 次调用`next()`方法将处理这些缓冲行中的一行。第 11 次调用将返回数据库以检索另外 10 行数据，依此类推。

虽然值会有所不同，但是 JDBC 驱动程序通常会将默认的 fetch size 设置为一个相当小的数值。这种方法在大多数情况下是合理的；特别是在应用程序内部不太可能导致任何内存问题时更为合理。如果`next()`方法的性能（或结果集上第一个 getter 方法的性能）偶尔特别慢，请考虑增加 fetch size。

# 快速总结

+   处理查询中大量数据的应用程序应考虑更改数据的 fetch size。

+   在应用程序中加载过多数据（增加垃圾收集器的压力）与频繁地从数据库检索一组数据之间存在权衡。

# JPA

JPA 的性能直接受底层 JDBC 驱动程序性能的影响，大多数关于 JDBC 驱动程序的性能考虑也适用于 JPA。JPA 还有额外的性能考虑。

JPA 通过修改实体类的字节码实现了许多性能增强。在大多数服务器框架中，这是透明进行的。在 Java SE 环境中，确保字节码处理设置正确非常重要。否则，JPA 应用程序的性能将无法预测：预期按需加载的字段可能被急切加载，保存到数据库的数据可能是冗余的，应该在 JPA 缓存中的数据可能需要重新从数据库获取，等等。

没有 JPA 定义的方法来处理字节码。通常，这是作为编译的一部分来完成——在实体类编译完成之后（并在加载到 JAR 文件或 JVM 运行之前），它们会通过一个实现特定的后处理器“增强”字节码，生成一个带有所需优化的改变后的类文件。例如，Hibernate 通过 Maven 或 Gradle 插件在编译过程中完成此操作。

一些 JPA 实现还提供了一种在类加载到 JVM 时动态增强字节码的方法。这需要在 JVM 中运行一个代理，当类加载时被通知；代理介入类加载并在类被用于定义之前修改字节。代理在应用程序的命令行中指定；例如，对于 EclipseLink，你包括 `-javaagent:path_to/eclipselink.jar` 参数。

## 优化 JPA 写入

在 JDBC 中，我们研究了两个关键的性能技术：重用准备好的语句和批量执行更新。可以通过 JPA 完成这两种优化，但其实现方式取决于所使用的 JPA 实现；在 JPA API 内部没有调用来完成这些操作。对于 Java SE，这些优化通常需要在应用程序的 *persistence.xml* 文件中设置特定的属性。

例如，使用 JPA EclipseLink 参考实现，可以通过在 *persistence.xml* 文件中添加以下属性来启用语句重用：

```java
      <property name="eclipselink.jdbc.cache-statements" value="true" />
```

注意，这可以在 EclipseLink 实现中实现语句重用。如果 JDBC 驱动能够提供语句池，则通常更倾向于在驱动程序中启用语句缓存，并且不在 JPA 配置中设置此属性。

JPA 参考实现中的语句批处理是通过添加以下属性实现的：

```java
      <property name="eclipselink.jdbc.batch-writing" value="JDBC" />
      <property name="eclipselink.jdbc.batch-writing.size" value="10000" />
```

JDBC 驱动程序无法自动实现语句批处理，因此在所有情况下设置此属性非常有用。批处理大小可以通过两种方式控制：首先，可以设置 `size` 属性，就像本例中所做的那样。其次，应用程序可以周期性地调用实体管理器的 `flush()` 方法，这将导致所有批处理语句立即执行。

表 11-2 显示了语句重用和批处理对创建和写入数据库的股票实体的影响。

表 11-2\. 通过 JPA 插入 256 只股票所需的秒数

| 编程模式 | 所需时间 |
| --- | --- |
| 无批处理，无语句池 | 83 ± 3 秒 |
| 无批处理，语句池 | 64 ± 5 秒 |
| 批处理，无语句池 | 10 ± 0.4 秒 |
| 批处理，语句池 | 10 ± 0.3 秒 |

# 快速总结

+   JPA 应用程序和 JDBC 应用程序一样，可以通过限制向数据库的写入调用次数来获益（可能需要权衡事务锁的持有）。

+   语句缓存可以在 JPA 层或 JDBC 层实现。首先应该先探索在 JDBC 层进行缓存。

+   批处理 JPA 更新可以通过声明方式（在 *persistence.xml* 文件中）或者通过调用 `flush()` 方法来编程实现。

## 优化 JPA 读取

优化 JPA 从数据库中读取数据的时间和方式比看起来要复杂得多，因为 JPA 将缓存数据，希望可以用来满足将来的请求。这通常对性能是一个好事，但这意味着 JPA 生成的用于读取数据的 SQL 看起来可能并不是最优的。数据检索被优化以满足 JPA 缓存的需求，而不是为了正在进行的特定请求而优化。

缓存的详细信息将在下一节中介绍。现在，让我们看一下如何将数据库读取优化应用于 JPA 的基本方法。JPA 从数据库中读取数据有三种情况：当调用`EntityManager`的`find()`方法时，当执行 JPA 查询时，以及当代码使用现有实体的关系导航到新实体时。在股票类中，后一种情况意味着在`Stock`实体上调用`getOptions()`方法。

调用`find()`方法是最简单的情况：只涉及单行数据，并且（至少）从数据库中读取了该单行数据。唯一可以控制的是检索的数据量。JPA 可以仅检索行中的一些字段，也可以检索整行，或者可以预提取与正在检索的行相关的其他实体。这些优化同样适用于查询。

有两种可能的路径可供选择：读取更少的数据（因为数据不会被需要）或一次性读取更多数据（因为将来绝对需要该数据）。

### 读取更少的数据

要读取更少的数据，请指定所讨论的字段是按需加载的。当检索实体时，带有延迟注解的字段将被排除在用于加载数据的 SQL 之外。如果该字段的 getter 被执行，这将意味着另一次访问数据库以检索该数据片段。

很少使用该注解来简单列出基本类型的简单列，但是如果实体包含基于大型 BLOB 或 CLOB 的对象，请考虑使用它：

```java
@Lob
@Column(name = "IMAGEDATA")
@Basic(fetch = FetchType.LAZY)
private byte[] imageData;
```

在这种情况下，实体映射到存储二进制图像数据的表中。二进制数据很大，本例假设除非需要，否则不应加载。在这种情况下不加载不必要的数据有两个目的：当检索实体时，这样做可以使 SQL 更快，并且节省大量内存，从而减少 GC 压力。

还要注意，延迟注解最终只是对 JPA 实现的提示。JPA 实现可以自由地要求数据库急切地提供该数据。

另一方面，也许应该预加载其他数据，例如，当获取一个实体时，应该返回其他（相关的）实体的数据。这称为*急切加载*，并且具有类似的注解：

```java
@OneToMany(mappedBy="stock", fetch=FetchType.EAGER)
private Collection<StockOptionPriceImpl> optionsPrices;
```

默认情况下，如果关系类型是`@OneToOne`或`@ManyToOne`（因此可以对它们应用相反的优化：如果它们几乎从不使用，则标记它们为`FetchType.LAZY`），则相关实体已经被急切地获取。

这也只是对 JPA 实现的一个提示，但它基本上表示每次检索股票价格时，确保还检索所有相关的期权价格。在这里要注意：关于急切关系获取的一个常见期望是它将在生成的 SQL 中使用`JOIN`。在典型的 JPA 提供程序中，情况并非如此：它们将发出一个 SQL 查询来获取主对象，然后发出一个或多个 SQL 命令来获取任何其他相关对象。从一个简单的`find()`方法中，对此没有控制：如果需要一个`JOIN`语句，您将不得不使用一个查询并将`JOIN`编程到查询中。

### 在查询中使用 JOIN

JPA 查询语言（JPQL）不允许您指定要检索的对象的字段。接下来看一个 JPQL 查询：

```java
Query q = em.createQuery("SELECT s FROM StockPriceImpl s");
```

那个查询将始终产生这个 SQL 语句：

```java
SELECT <enumerated list of non-LAZY fields> FROM StockPriceTable
```

如果要在生成的 SQL 中检索较少的字段，您除了将它们标记为 lazy 之外别无选择。同样，对于标记为 lazy 的字段，在查询中获取它们也没有真正的选择。

如果实体之间存在关系，则可以在 JPQL 查询中显式加入实体，这将一次检索初始实体及其相关实体。例如，在股票实体中，可以发出以下查询：

```java
Query q = em.createQuery("SELECT s FROM StockOptionImpl s " +
			 "JOIN FETCH s.optionsPrices");
```

这将导致类似于这样的 SQL 语句：

```java
SELECT t1.<fields>, t0.<fields> FROM StockOptionPrice t0, StockPrice t1
WHERE ((t0.SYMBOL = t1.SYMBOL) AND (t0.PRICEDATE = t1.PRICEDATE))
```

在 JPA 提供程序之间确切的 SQL 将有所不同（此示例来自 EclipseLink），但这是一般过程。

无论实体关系是否被注释为急切或懒惰，联接获取都是有效的。如果在懒惰关系上发出连接，则仍然会从数据库中检索满足查询的懒惰注释实体，如果稍后使用这些实体，则不需要额外的数据库访问。

当使用 join fetch 的查询返回的所有数据都将被使用时，join fetch 通常会显著提高性能。但是，join fetch 也会以意想不到的方式与 JPA 缓存交互。示例在“JPA 缓存”中显示；在编写使用 join fetch 的自定义查询之前，请确保您了解这些影响。

### 批处理和查询

JPA 查询被处理为像 JDBC 查询一样产生一个结果集：JPA 实现可以选择一次性获取所有结果，当应用程序遍历查询结果时一次获取一个结果，或者一次获取少量结果（类似于 JDBC 中的抓取大小工作原理）。

没有标准方法来控制这一点，但 JPA 供应商有专有的机制来设置抓取大小。在 EclipseLink 中，查询上的一个提示指定了抓取大小：

```java
q.setHint("eclipselink.JDBC_FETCH_SIZE", "100000");
```

Hibernate 提供了一个定制的`@BatchSize`注解。

如果正在处理非常大的数据集，则代码可能需要浏览查询返回的列表。这与数据在网页上如何显示有自然的关系：显示数据的子集（例如 100 行），以及用于浏览数据的上一页和下一页链接（页面）。

这是通过在查询上设置一个范围来实现的：

```java
Query q = em.createNamedQuery("selectAll");
query.setFirstResult(101);
query.setMaxResults(100);
List<? implements StockPrice>  = q.getResultList();
```

这返回一个适合在 Web 应用程序的第二页上显示的列表：项目 101-200\. 仅检索所需数据范围将比检索 200 行并丢弃前 100 行更有效。

请注意，此示例使用了命名查询（`createNamedQuery()` 方法），而不是临时查询（`createQuery()` 方法）。在许多 JPA 实现中，命名查询更快：JPA 实现几乎总是使用带绑定参数的预编译语句，利用语句缓存池。虽然 JPA 实现可以使用类似的逻辑处理未命名的临时查询，但实现起来更加困难，JPA 实现可能简单地默认创建新的语句（即`Statement`对象）每次执行。

# 快速总结

+   JPA 可以执行多种优化以限制（或增加）单次操作中读取的数据量。

+   不经常使用的大字段（例如 BLOBs）应该在 JPA 实体中懒惰地加载。

+   当 JPA 实体之间存在关系时，相关项的数据可以被急切地或懒惰地加载。选择取决于应用程序的需求。

+   在急切加载关系时，可以使用命名查询来发出使用 `JOIN` 语句的单个 SQL 语句。请注意，这会影响 JPA 缓存；这并不总是最佳选择（如下一节所讨论的）。

+   通过命名查询读取数据通常比普通查询快，因为 JPA 实现更容易使用 `PreparedStatement` 来处理命名查询。

## JPA 缓存

Java 的一个经典与性能相关的用例是为客户端提供一个中间层，该中间层从后端数据库资源缓存数据。Java 中间层执行架构上有用的功能（例如防止客户端直接访问数据库）。从性能角度来看，在 Java 中间层缓存经常使用的数据可以极大地加快响应时间。

JPA 被设计以考虑这种架构。JPA 中存在两种缓存：每个实体管理器实例都是其自己的缓存：它将在事务期间检索的数据本地缓存。它还将在事务期间写入的数据本地缓存；只有在事务提交时才将数据发送到数据库。程序可能有许多实体管理器实例，每个执行不同的事务，并且每个具有自己的本地缓存。（特别是，注入到 Java 服务器中的实体管理器是不同的实例。）

当实体管理器提交事务时，所有本地缓存中的数据可以合并到全局缓存中。全局缓存在应用程序中的所有实体管理器之间共享。全局缓存也称为*第二级缓存 (L2 缓存)*或*二级缓存*；实体管理器中的缓存称为*第一级 (L1)*或*L1 缓存*。

在实体管理器事务缓存（L1 缓存）中很少有调整空间，并且所有 JPA 实现都启用了 L1 缓存。L2 缓存不同：大多数 JPA 实现提供了 L2 缓存，但并非所有实现都默认启用它（例如，Hibernate 不启用，但 EclipseLink 启用）。一旦启用，调整和使用 L2 缓存的方式可以显著影响性能。

JPA 缓存仅在通过其主键访问的实体上运行，即从 `find()` 方法调用或访问（或急切加载）相关实体检索的项目。当实体管理器尝试通过其主键或关系映射查找对象时，它可以查看 L2 缓存，并在那里找到对象时返回它们，从而节省了对数据库的访问。

通过查询检索的项目不存储在 L2 缓存中。一些 JPA 实现确实具有特定于供应商的机制来缓存查询的结果，但只有在重新执行完全相同的查询时才重复使用这些结果。即使 JPA 实现支持查询缓存，实体本身也不存储在 L2 缓存中，并且不能在后续调用 `find()` 方法时返回。

L2 缓存、查询和对象加载之间的连接以多种方式影响性能。为了检查它们，将使用基于以下循环的代码：

```java
EntityManager em = emf.createEntityManager();
Query q = em.createNamedQuery(queryName);
List<StockPrice> l = q.getResultList(); ![1](img/1.png)
for (StockPrice sp : l) {
    ... process sp ...
    if (processOptions) {
        Collection<? extends StockOptionPrice> options = sp.getOptions(); ![2](img/2.png)
        for (StockOptionPrice sop : options) {
	    ... process sop ...
        }
    }
}
em.close();
```

![1](img/#co_database_performance_best_practices_CO1-1)

SQL 调用站点 1

![2](img/#co_database_performance_best_practices_CO1-2)

SQL 调用站点 2

由于 L2 缓存，第一次执行此循环时将以一种方式执行，而在后续执行中将以另一种（通常更快）方式执行。具体的性能差异取决于查询和实体关系的各种细节。接下来的几个小节详细解释了结果。

此示例中的差异在某些情况下基于不同的 JPA 配置，但也因为某些测试在不遍历 `Stock` 和 `StockOptions` 类之间的关系时执行。在那些没有遍历关系的测试中，循环中的 `processOptions` 值为 `false`；实际上只使用了 `StockPrice` 对象。

### 默认缓存（延迟加载）

在示例代码中，股票价格通过命名查询加载。在默认情况下，执行此简单查询以加载股票数据：

```java
@NamedQuery(name="findAll",
    query="SELECT s FROM StockPriceImpl s ORDER BY s.id.symbol")
```

`StockPrice` 类与 `StockOptionPrice` 类具有 `@OneToMany` 关系，使用 `optionsPrices` 实例变量：

```java
@OneToMany(mappedBy="stock")
private Collection<StockOptionPrice> optionsPrices;
```

默认情况下，`@OneToMany` 关系是惰性加载的。表 11-3 显示了执行此循环所需的时间。

表 11-3\. 默认配置下读取 256 只股票数据所需秒数

| 测试案例 | 第一次执行 | 后续执行 |
| --- | --- | --- |
| 惰性关系 | 22.7 ± 2 秒（66,817 次 SQL 调用） | 1.1 ± 0.7 秒（1 次 SQL 调用） |
| 惰性关系，无遍历 | 2.0 ± 0.3 秒（1 次 SQL 调用） | 1.0 ± 0.02 秒（1 次 SQL 调用） |

在此场景中第一次执行包含 256 只股票一年数据的示例循环时，JPA 代码在调用 `executeQuery()` 方法时执行一条 SQL 语句。该语句在代码清单中的 SQL 调用站点 1 执行。

当代码循环遍历股票并访问每个期权价格集合时，JPA 将发出 SQL 语句来检索与特定实体相关联的所有期权（即一次检索一只股票/日期组合的整个集合）。这发生在 SQL 调用站点 2，并导致执行期间发出 66,816 个独立的 `SELECT` 语句（261 天 × 256 只股票），总共 66,817 次调用。

该示例第一次执行循环几乎需要 23 秒。下次执行相同代码时，只需略多于 1 秒。这是因为第二次执行循环时，唯一执行的 SQL 是命名查询。通过关系检索的实体仍在 L2 缓存中，因此在这种情况下不需要数据库调用。（请记住，L2 缓存仅适用于从关系或查找操作加载的实体。因此，股票期权实体可以在 L2 缓存中找到，但股票价格——因为它们是从查询加载的——不会出现在 L2 缓存中，必须重新加载。）

表 11-3 的第二行表示不访问关系中的每个期权的代码（即 `processOptions` 变量为 `false` 的情况）。在这种情况下，代码速度显著加快：第一次循环迭代花费 2 秒，后续迭代只需 1 秒。（这两种情况的性能差异是由编译器的预热期造成的。虽然第一个示例中并不明显，但也发生了预热。）

### 缓存与急切加载

在接下来的两个实验中，重新定义了股票价格与期权价格之间的关系，以便急切地加载期权价格。

当所有数据都被使用时（即表 11-3 和 11-4 的第一行），急切加载和延迟加载的性能基本相同。但当关系数据实际上没有被使用时（每个表的第二行），延迟加载的情况节省了一些时间——特别是在循环的第一次执行时。由于在后续迭代中急切加载的代码不会重新加载数据，而是从 L2 缓存中加载数据，因此后续执行的循环并不节省时间。

表 11-4\. 读取 256 只股票数据所需的时间（急切加载）

| 测试用例 | 第一次执行 | 后续执行 |
| --- | --- | --- |
| 急切关系 | 23 ± 1.0 秒（66,817 次 SQL 调用） | 1.0 ± 0.8 秒（1 次 SQL 调用） |
| 急切关系，无遍历 | 23 ± 1.3 秒（66,817 次 SQL 调用） | 1.0 ± 0.5 秒（1 次 SQL 调用） |

### 加入抓取和缓存

如前一节所讨论的，查询可以编写成显式使用`JOIN`语句：

```java
@NamedQuery(name="findAll",
    query="SELECT s FROM StockPriceEagerLazyImpl s " +
    "JOIN FETCH s.optionsPrices ORDER BY s.id.symbol")
```

使用该命名查询（完整遍历）会在 Table 11-5 中给出数据的结果。

表 11-5\. 读取 256 只股票数据所需的时间（`JOIN`查询）

| 测试用例 | 第一次执行 | 后续执行 |
| --- | --- | --- |
| 默认配置 | 22.7 ± 2 秒（66,817 次 SQL 调用） | 1.1 ± 0.7 秒（1 次 SQL 调用） |
| 加入抓取 | 9.0 ± 0.3 秒（1 次 SQL 调用） | 5.6 ± 0.4 秒（1 次 SQL 调用） |
| 带查询缓存的加入抓取 | 5.8 ± 0.2 秒（1 次 SQL 调用） | 0.001 ± 0.0001 秒（0 次 SQL 调用） |

第一次执行带有`JOIN`查询的循环会带来很大的性能优势：仅需 9 秒。这是仅发出一次 SQL 请求而不是 66,817 次的结果。

不幸的是，下次执行代码时仍然需要那个 SQL 语句，因为查询结果不在 L2 缓存中。例如的后续执行需要 5.6 秒——因为执行的 SQL 语句中有 `JOIN` 语句，并且正在检索超过 400,000 行的数据。

如果 JPA 提供程序实现了查询缓存，则明显是使用它的好时机。如果在代码的第二次执行过程中不需要 SQL 语句，则后续执行仅需 1 毫秒。请注意，查询缓存仅在每次执行查询时使用的参数完全相同时才有效。

### 避免查询

如果实体从未通过查询检索，所有实体都可以在初始预热期后通过 L2 缓存访问。可以通过加载所有实体来预热 L2 缓存，稍微修改之前的示例代码如下：

```java
EntityManager em = emf.createEntityManager();
ArrayList<String> allSymbols = ... all valid symbols ...;
ArrayList<Date> allDates = ... all valid dates...;
for (String symbol : allSymbols) {
    for (Date date = allDates) {
        StockPrice sp =
            em.find(StockPriceImpl.class, new StockPricePK(symbol, date);
	... process sp ...
        if (processOptions) {
    	    Collection<? extends StockOptionPrice> options = sp.getOptions();
	    ... process options ...
	}
    }
}
```

执行此代码的结果在 Table 11-6 中给出。

表 11-6\. 读取 256 只股票数据所需的时间（使用 L2 缓存）

| 测试用例 | 第一次执行 | 后续执行 |
| --- | --- | --- |
| 默认配置 | 22.7 ± 2 秒（66,817 次 SQL 调用） | 1.1 ± 0.7 秒（1 次 SQL 调用） |
| 无查询 | 35 ± 3 秒（133,632 条 SQL 调用） | 0.28 ± 0.3 秒（0 条 SQL 调用） |

这个循环的第一次执行需要 133,632 条 SQL 语句：66,816 条用于调用 `find()` 方法，另外 66,816 条用于调用 `getOptions()` 方法。由于所有实体都在 L2 缓存中，且不需要发出 SQL 语句，因此代码的后续执行非常快速。

请记住，示例数据库包括每个日期和符号对应的五个期权价格，或者一年数据中 256 只股票共 334,080 个期权价格。当通过关系访问特定符号和日期的五只股票期权时，它们可以一次性全部检索出来。这就是为什么只需要 66,816 条 SQL 语句来加载所有期权价格数据。即使从这些 SQL 语句返回了多行，JPA 仍然能够缓存实体——这与执行查询不同。如果通过迭代实体来预热 L2 缓存，请不要逐个迭代相关实体——而是通过简单访问关系来做到这一点。

当优化代码时，您必须考虑缓存（特别是 L2 缓存）的影响。即使您认为您可以比 JPA 生成更好的 SQL（因此应使用复杂的命名查询），请确保在缓存起作用之后该代码是值得的。即使看起来使用简单的命名查询加载数据会更快，也要考虑如果这些实体通过调用 `find()` 方法加载到 L2 缓存中会发生什么。

### 调整 JPA 缓存大小

与所有对象复用的情况一样，JPA 缓存存在潜在的性能缺陷：如果缓存消耗过多内存，将导致 GC 压力。这可能需要调整缓存大小或者控制实体保持缓存的模式。不幸的是，这些不是标准选项，因此您必须根据您使用的 JPA 提供程序执行这些调整。

JPA 实现通常提供了设置缓存大小的选项，可以是全局的，也可以是每个实体的。后者显然更灵活，但也需要更多工作来确定每个实体的最佳大小。另一种方法是 JPA 实现使用软引用和/或弱引用来管理 L2 缓存。例如，EclipseLink 提供了五种缓存类型（还有一些已弃用的类型），基于软引用和弱引用的各种组合。虽然这种方法可能比确定每个实体的最佳大小更容易，但仍然需要一些规划：特别是请回忆第 第七章 弱引用在任何 GC 操作中都不会真正存活，因此作为缓存的选择有所疑问。

如果使用基于软引用或弱引用的缓存，则应用程序的性能还取决于堆中发生的其他事情。 本节的示例都使用了一个大堆，以便在应用程序中缓存 400,896 个实体对象不会导致垃圾收集器出现问题。 当存在大型 JPA L2 缓存时，调整堆非常重要以获得良好的性能。

# 快速总结

+   JPA L2 缓存将自动为应用程序缓存实体。

+   L2 缓存不缓存通过查询检索的实体。 这意味着从长远来看，完全避免查询可能是有利的。

+   除非所使用的 JPA 实现支持查询缓存，否则使用 `JOIN` 查询通常会对性能产生负面影响，因为它绕过了 L2 缓存。

# Spring 数据

尽管 JDBC 和 JPA 是 Java 平台的标准部分，但其他第三方 Java API 和框架管理数据库访问。 NoSQL 供应商都有自己的 API 来访问其数据库，各种框架通过与 JPA 不同的抽象提供数据库访问。

其中最广泛使用的是 Spring Data，这是一个包含关系型和 NoSQL 数据库访问模块的集合。 这个框架包含几个模块，包括以下内容：

Spring Data JDBC

这被设计为 JPA 的简单替代方案。 它提供与 JPA 类似的实体映射，但没有缓存、延迟加载或脏实体跟踪。 它建立在标准 JDBC 驱动程序之上，因此得到了广泛支持。 这意味着您可以在 Spring 代码中跟踪本章的性能方面：确保对重复调用使用预编译语句，实现必要的接口以支持 Spring 批处理语句模型，并/或直接使用连接对象以更改自动提交语义。

Spring Data JPA

这被设计为标准 JPA 的封装。 其一个重要优势是减少开发人员需要编写的样板代码量（这对开发者的性能有好处，但实际上并不影响我们讨论的性能）。 因为它包装了标准 JPA，本章提到的 JPA 性能方面仍然适用：设置急切加载与延迟加载，批量更新和插入，以及所有 L2 缓存仍然适用。

Spring Data 用于 NoSQL

Spring 具有各种 NoSQL（和类似 NoSQL 的）技术的连接器，包括 MongoDB、Cassandra、Couchbase 和 Redis。 这在某种程度上简化了 NoSQL 访问，因为访问存储的技术是相同的，尽管设置和初始化方面仍有差异。

Spring 数据 R2DBC

Spring Data R2DBC，在第十章提到，允许异步访问 Postgres、H2 和 Microsoft SQL Server 数据库。它遵循典型的 Spring Data 编程模型，而不是直接使用 JDBC，因此类似于 Spring Data JDBC：通过仓库中的简单实体进行访问，尽管没有 JPA 的缓存、延迟加载和其他特性。

# 摘要

正确调优 JDBC 和 JPA 对数据库的访问是影响中间层应用性能的最重要方法之一。请记住以下最佳实践：

+   通过适当配置 JDBC 或 JPA 配置，尽可能进行批量读写。

+   优化应用程序发出的 SQL。对于 JDBC 应用程序，这是一个关于基本标准 SQL 命令的问题。对于 JPA 应用程序，请务必考虑 L2 缓存的参与。

+   尽可能减少锁定。当数据不太可能争用时，请使用乐观锁定；当数据争用时，请使用悲观锁定。

+   确保使用准备好的语句池。

+   确保使用适当大小的连接池。

+   设置适当的事务范围：它应尽可能大，而不会因事务持有的锁而对应用的可扩展性产生负面影响。

^(1) 在实际部署中，您可能更喜欢扩展数据库，但这通常很困难。

^(2) 数据库供应商通常将语句池称为*语句缓存*。

^(3) 在本书的第一版中，当测试运行在 Oracle 11g 上时，情况也不一样；行 2 和 3 之间以及行 5 和 6 之间有明显差异。这些测试是在具有其自身改进的 Oracle 18c 上运行的。
