# 第一章：介绍

本书讨论了 Java 性能的艺术和科学。

这个说法的科学部分并不令人惊讶；关于性能的讨论涉及大量的数字、测量和分析。大多数性能工程师背景都是科学，应用科学严谨性是实现最大性能的关键部分之一。

艺术部分是什么呢？性能调优既是一部分艺术，又是一部分科学的概念并不新鲜，但在性能讨论中很少得到明确的承认。部分原因是“艺术”的概念与我们的训练相抵触。但对一些人来说看起来像艺术的东西，实质上基于深厚的知识和经验。据说魔术与高度先进的技术是无法区分的，确实，对于圆桌骑士来说，手机看起来就像是魔法一样。同样地，一名优秀的性能工程师所产生的工作可能看起来像艺术，但这种艺术实际上是深知识、经验和直觉的应用。

这本书无法帮助你在经验和直觉方面，但它可以提供深刻的知识——通过长期应用知识来帮助你发展成为一名优秀的 Java 性能工程师所需的技能。目标是让你深入了解 Java 平台的性能方面。

这些知识分为两大类。第一类是 Java 虚拟机（JVM）本身的性能：JVM 的配置方式影响程序性能的许多方面。其他语言有经验的开发者可能会觉得需要进行调优有些烦人，尽管事实上调优 JVM 完全类似于编译 C++程序时的测试和选择编译器标志，或者为 PHP 编码者在*php.ini*文件中设置适当的变量等等。

第二个方面是理解 Java 平台的特性如何影响性能。在这里，“平台”一词的使用很重要：一些特性（例如线程和同步）是语言的一部分，而一些特性（例如字符串处理）则是标准 Java API 的一部分。尽管 Java 语言和 Java API 之间有重要的区别，在这种情况下它们将被类似地对待。本书涵盖了平台的这两个方面。

JVM 的性能在很大程度上取决于调优标志，而平台的性能更多地取决于在应用程序代码中使用最佳实践。长期以来，这些被认为是不同的专业领域：开发者编写代码，性能组测试并推荐性能问题的修复。这从未是一个特别有用的区分 —— 任何与 Java 工作的人都应该同样擅长理解代码在 JVM 中的行为以及哪些调优可能有助于其性能。随着项目转向 DevOps 模型，这种区分开始变得不那么严格。对整个领域的了解才能使你的工作具有艺术的氛围。

# 简要概述

但首先：第二章讨论了测试 Java 应用程序的一般方法论，包括 Java 基准测试的陷阱。由于性能分析需要了解应用程序的操作，第三章概述了一些可用于监视 Java 应用程序的工具。

现在是深入探讨性能的时候了，首先专注于常见的调优方面：即时编译（第四章）和垃圾回收（第五章和第六章）。其余章节则侧重于 Java 平台各部分的最佳实践使用：Java 堆内存使用（第七章）、本地内存使用（第八章）、线程性能（第九章）、Java 服务器技术（第十章）、数据库访问（第十一章）以及 Java SE API 的通用技巧（第十二章）。

附录 A 列出了本书讨论的所有调优标志，以及它们在哪些章节中进行了交叉引用。

# 平台与约定

虽然本书关注于 Java 的性能，但该性能将受到几个因素的影响：Java 本身的版本，当然，以及它运行在的硬件和软件平台。

## Java 平台

本书涵盖了 Oracle HotSpot Java 虚拟机（JVM）和 Java 开发工具包（JDK）的性能，分别针对版本 8 和 11。这也被称为 Java 标准版（SE）。Java 运行环境（JRE）是 JDK 的子集，仅包含 JVM，但由于 JDK 中的工具对性能分析至关重要，本书将重点介绍 JDK。实际上，这意味着它还涵盖了从该技术的 OpenJDK 代码库衍生出的平台，包括由 [AdoptOpenJDK 项目](http://adoptopenjdk.net) 发布的 JVM。严格来说，Oracle 二进制文件需要许可证才能用于生产，而 AdoptOpenJDK 二进制文件则带有开源许可证。对于我们的目的，我们将认为这两个版本是同一件事情，我们将称之为 *JDK* 或 *Java 平台*。¹

这些版本已经经历了各种错误修复版本。在我撰写本文时，Java 8 的当前版本是 jdk8u222（版本 222），Java 11 的当前版本是 11.0.5。重要的是至少使用这些版本（如果不是更高版本），特别是在 Java 8 的情况下。Java 8 的早期版本（大约到 jdk8u60）不包含本书中讨论的许多重要性能增强和功能（特别是垃圾收集和 G1 垃圾收集器方面）。

选择这些 JDK 版本是因为它们来自 Oracle 的长期支持（LTS）。Java 社区可以自由发展自己的支持模型，但到目前为止，他们一直在遵循 Oracle 的模式。因此，这些发布版本将会得到支持，并且将在相当长的时间内可用：通过 AdoptOpenJDK 至少支持到 2023 年的 Java 8（稍后通过扩展的 Oracle 支持合同），以及至少支持到 2022 年的 Java 11。预计下一个长期支持版本将在 2021 年底发布。

对于临时发布版本，显然 Java 11 的讨论包括最初在 Java 9 或 Java 10 中首次提供的功能，尽管这些版本都不受 Oracle 和整个社区的支持。事实上，当讨论这些功能时，我的描述可能有些不够准确；可能会让人觉得我在说功能 X 和 Y 最初是在 Java 11 中包含的，但实际上它们可能在 Java 9 或 10 中就已经存在了。Java 11 是第一个包含这些功能的 LTS 版本，这才是重要的部分：由于 Java 9 和 10 并未被使用，功能首次出现的时间并不重要。同样，尽管在本书发布时 Java 13 将会发布，但对 Java 12 或 Java 13 的涵盖范围不是很广。您可以在生产中使用这些版本，但仅限于六个月，之后您将需要升级到新版本（所以当您阅读本书时，Java 12 已不再受支持，如果 Java 13 受支持，它将很快被 Java 14 替代）。我们将简要介绍一些这些临时发布版本的功能，但由于这些版本不太可能在大多数环境中投入生产，因此重点仍然放在 Java 8 和 11 上。

还有其他可用的 Java 语言规范实现，包括开源实现的分支。AdoptOpenJDK 提供了其中一个（Eclipse OpenJ9），其他供应商也提供了其他实现。尽管所有这些平台都必须通过兼容性测试才能使用 Java 名称，但这种兼容性并不总是延伸到本书讨论的主题。调整标志尤其如此。所有 JVM 实现都有一个或多个垃圾收集器，但调整每个供应商的 GC 实现的标志是产品特定的。因此，虽然本书的概念适用于任何 Java 实现，但具体的标志和建议仅适用于 HotSpot JVM。

上述警告适用于 HotSpot JVM 的早期版本 —— 从一个版本到另一个版本，标志及其默认值可能会发生变化。本文讨论的标志适用于 Java 8（具体来说是版本 222）和 11（具体来说是 11.0.5）。稍后的版本可能会轻微更改部分信息。请始终查阅发布说明以获取重要更改信息。

在 API 级别上，不同的 JVM 实现要兼容得多，尽管即便如此，在 Oracle HotSpot Java 平台和其他平台中实现特定类的方式之间可能仍存在细微差异。这些类必须在功能上等效，但实际实现可能会有所变化。幸运的是，这种情况并不经常发生，而且不太可能对性能造成重大影响。

在本书的剩余部分中，术语*Java*和*JVM*应理解为特指 Oracle HotSpot 实现。严格来说，说“JVM 在首次执行时不会编译代码”是错误的；一些 Java 实现在首次执行时确实会编译代码。但使用这种简写比继续写（和阅读）“Oracle HotSpot JVM…”要简单得多。

### JVM 调整标志

除了一些例外，JVM 接受两种类型的标志：布尔标志和需要参数的标志。

布尔标志使用以下语法：`-XX:+`*`FlagName`* 启用标志，`-XX:-`*`FlagName`* 禁用标志。

需要参数的标志使用以下语法：`-XX:`*`FlagName`*=*`something`*，表示将 `FlagName` 的值设置为 `something`。在文本中，标志的值通常用表示任意值的 something 表示。例如，`-XX:NewRatio=`*`N`* 意味着 `NewRatio` 标志可以设置为任意值 *`N`*（*`N`* 的含义是讨论的重点）。

每个标志的默认值在引入标志时讨论。该默认值通常基于 JVM 运行的平台以及 JVM 的其他命令行参数的组合。如果有疑问，“基本 VM 信息”显示如何使用 `-XX:+PrintFlagsFinal` 标志（默认为 `false`）来确定在特定环境中特定命令行下特定标志的默认值。根据环境自动调整标志的过程称为*人体工程学*。

从 Oracle 和 AdoptOpenJDK 网站下载的 JVM 称为 JVM 的*产品构建*。当 JVM 从源代码构建时，可以产生许多构建：调试构建，开发者构建等。这些构建通常具有附加功能。特别是，开发者构建包含了更大量的调整标志集，使开发者可以实验 JVM 使用的各种算法的最微小操作。这些标志通常不在本书中考虑。

## 硬件平台

当本书的第一版出版时，硬件环境看起来与今天不同。多核机器很受欢迎，但 32 位平台和单 CPU 平台仍然在广泛使用。今天正在使用的其他平台——虚拟机和软件容器——正在崭露头角。以下是这些平台如何影响本书主题的概述。

### 多核硬件

今天几乎所有的机器都有多个执行核心，对 JVM（以及任何其他程序）而言，这些核心看起来像多个 CPU。通常，每个核心都启用了超线程。*超线程*是英特尔首选的术语，虽然 AMD（和其他公司）使用术语*同时多线程*，一些芯片制造商则称之为核心内的硬件线程。这些都是同一回事，我们将这项技术称为超线程。

从性能的角度来看，机器的重要性在于其核心数。让我们以一个基本的四核机器为例：每个核心（大部分情况下）可以独立处理，因此一个有四个核心的机器可以实现比单核心机器高四倍的吞吐量。（当然，这取决于软件的其他因素。）

在大多数情况下，每个核心将包含两个硬件线程或超线程。这些线程不是彼此独立的：核心一次只能运行其中一个。通常情况下，线程会停滞：例如，它需要从主存中加载一个值，这个过程可能需要几个周期。在单线程核心中，线程在这一点上停滞，这些 CPU 周期就浪费了。在双线程核心中，核心可以切换并执行另一个线程的指令。

因此，我们启用超线程的四核机器看起来可以同时执行来自八个线程的指令（即使在技术上，每个 CPU 周期只能执行四条指令）。对操作系统来说——因此对 Java 和其他应用程序来说——这台机器看起来有八个 CPU。但是所有这些 CPU 在性能上并不相等。如果我们运行一个 CPU 密集型任务，它将使用一个核心；第二个 CPU 密集型任务将使用第二个核心；依此类推，最多四个：我们可以运行四个独立的 CPU 密集型任务并获得四倍的吞吐量提升。

如果我们添加第五个任务，它只有在其他任务之一停滞时才能运行，平均情况下这种情况发生的概率在 20%到 40%之间。每增加一个额外的任务都面临相同的挑战。因此，添加第五个任务只会增加大约 30%的性能；最终，这八个 CPU 将给我们提供约五到六倍于单个核心（无超线程）的性能。

您将在几个部分看到这个例子。垃圾收集非常依赖 CPU，因此第五章展示了超线程如何影响垃圾收集算法的并行化。第九章总结了如何充分利用 Java 的线程设施，您也将在那里看到超线程核心扩展的例子。

### 软件容器

近年来 Java 部署中最大的变化是它们现在经常部署在软件容器中。当然，这种变化不仅限于 Java，它是云计算推动的行业趋势。

这里有两个重要的容器。首先是虚拟机，它在虚拟机运行的硬件子集上设置了操作系统的完全隔离副本。这是云计算的基础：你的云计算供应商有一个带有非常大机器的数据中心。这些机器可能有 128 个核心，尽管由于成本效益的原因，它们可能更小。从虚拟机的角度来看，这并不重要：虚拟机被授予对硬件子集的访问。因此，给定的虚拟机可能有两个核心（并且四个 CPU，因为它们通常是超线程的）和 16 GB 内存。

从 Java 的角度（以及其他应用程序的角度），这个虚拟机与一个具有两个核心和 16 GB 内存的常规机器是无法区分的。为了调优和性能目的，你只需以相同的方式考虑它。

第二个需要注意的容器是 Docker 容器。运行在 Docker 容器中的 Java 进程并不一定知道它在这样一个容器中（尽管可以通过检查找出），但 Docker 容器只是一个进程（可能有资源限制）在运行中的操作系统内。因此，它与其他进程在 CPU 和内存使用方面的隔离有所不同。正如你将看到的，Java 处理这一点在早期 Java 8 版本（直至更新 192）与后来的 Java 8 版本（以及所有 Java 11 版本）之间有所不同。

默认情况下，Docker 容器可以自由使用机器的所有资源：它可以使用机器上所有可用的 CPU 和所有可用的内存。如果我们只想要使用 Docker 来简化在机器上部署我们的单个应用程序（因此该机器将仅运行该 Docker 容器），那没问题。但通常我们希望在一台机器上部署多个 Docker 容器并限制每个容器的资源。实际上，考虑到我们有四核心的机器和 16 GB 内存，我们可能希望运行两个 Docker 容器，每个容器仅访问两个核心和 8 GB 内存。

配置 Docker 完成这一点相对简单，但在 Java 层面可能会出现复杂情况。根据运行 JVM 的机器的大小，许多 Java 资源会自动配置（或者根据人体工程学）。这包括默认堆大小和垃圾回收器使用的线程数，详细解释在第五章中，以及一些线程池设置，在第九章中提到。

如果你正在运行 Java 8 的最新版本（更新版本 192 或更高）或 Java 11，JVM 会如你所希望地处理这个问题：如果你将 Docker 容器限制为仅使用两个核心，基于机器 CPU 计数的人体工程学设置的值将基于 Docker 容器的限制。类似地，默认情况下基于机器上内存量的堆和其他设置将基于给定给 Docker 容器的任何内存限制。

在早期的 Java 8 版本中，JVM 对容器强制执行的任何限制都没有了解：当它检查环境以找出可用的内存量，以便计算其默认堆大小时，它将看到机器上的所有内存（而不是我们希望的 Docker 容器允许使用的内存量）。类似地，当它检查可用于调整垃圾收集器的 CPU 数量时，它将看到机器上的所有 CPU，而不是分配给 Docker 容器的 CPU 数量。因此，JVM 将运行不够优化：它会启动过多的线程，并设置过大的堆。拥有过多的线程会导致一些性能下降，但这里真正的问题是内存：堆的最大大小可能会大于分配给 Docker 容器的内存。当堆增长到该大小时，Docker 容器（以及 JVM）将被终止。

在早期的 Java 8 版本中，你可以手动设置内存和 CPU 使用的适当值。当我们遇到这些调整时，我会指出哪些需要针对这种情况进行调整，但最好的方法是直接升级到更新的 Java 8 版本（或 Java 11）。

Docker 容器对 Java 提出了一个额外的挑战：Java 配备了一套丰富的工具用于诊断性能问题。这些工具通常在 Docker 容器中不可用。我们将在第三章中更详细地讨论这个问题。

# 完整的性能故事

本书专注于如何最佳利用 JVM 和 Java 平台 API，以使程序运行更快，但许多外部影响会影响性能。这些影响偶尔会在讨论中出现，但因为它们不特定于 Java，所以并未详细讨论。JVM 和 Java 平台的性能只是快速性能的一小部分。

本节介绍了至少与本书涵盖的 Java 调优主题同等重要的外部影响因素。本书基于 Java 知识的方法与这些影响互补，但其中许多超出了我们讨论的范围。

## 编写更好的算法

Java 的许多细节会影响应用程序的性能，并讨论了许多调优标志。但并没有神奇的`-XX:+RunReallyFast`选项。

最终，应用程序的性能取决于编写的质量。如果程序循环遍历数组中的所有元素，JVM 将优化它执行数组边界检查的方式，使得循环运行更快，并且它可能展开循环操作以提供额外的加速。但是，如果循环的目的是查找特定项，世界上没有任何优化可以使基于数组的代码像使用哈希映射的不同版本一样快。

当涉及到快速性能时，一个良好的算法是最重要的事情。

## 写更少的代码

我们中的一些人为了赚钱编写程序，一些人为了乐趣，一些人为了回馈社区，但我们所有人都在编写程序（或者参与团队编写程序）。通过修剪代码来感觉自己在项目中做出贡献很难，有些经理仍然通过开发者编写的代码量来评估开发者。

我明白这一点，但这里的矛盾在于一个小而精良的程序将比一个大而精良的程序运行得更快。这对所有的计算机程序通常都是正确的，特别是适用于 Java 程序。需要编译的代码越多，程序启动运行的时间就越长。需要分配和丢弃的对象越多，垃圾收集器需要做的工作就越多。分配和保留的对象越多，垃圾收集周期就越长。需要从磁盘加载到 JVM 中的类越多，程序启动的时间就越长。执行的代码越多，它就越不可能适应机器上的硬件缓存。执行的代码越多，执行时间就越长。

我认为这是“千刀万剐”的原则。开发者会争辩说他们只是添加一个非常小的功能，并且这几乎不需要时间（特别是如果该功能没有被使用）。然后同一项目中的其他开发者也会做同样的主张，突然间性能就退步了几个百分点。这个周期在下一个版本中重复，现在程序性能已经退步了 10%。在过程中的几次，性能测试可能会达到某个资源阈值——内存使用的临界点、代码缓存溢出等等。在这些情况下，定期的性能测试将捕获到特定条件，性能团队可以修复看似重大的退化。但随着小的退化逐渐增加，修复它们将变得越来越困难。

我并不主张您永远不应该向产品添加新功能或新代码；显然增强程序会带来好处。但要意识到您正在做出的权衡，并且在可能时简化流程。

## 哦，继续，过早优化吧

通常认为唐纳德·克努特(Donald Knuth)创造了“过早优化”(premature optimization)一词，开发人员经常使用这个词来声称他们的代码性能并不重要，如果性能确实重要，那么我们在运行代码之前就不会知道。如果你还没有见过完整的引用，那么就是这样：“我们应该忘记小效率，大约有 97%的时间；过早优化是所有邪恶的根源。”（3）

这句格言的要点是，最终，你应该编写简洁、直接、易于阅读和理解的代码。在这种情况下，“优化”的理解是指采用复杂的算法和设计更改来复杂化程序结构，但提供更好的性能。这些类型的优化确实最好在程序的性能分析显示从中获得了巨大好处时再进行。

然而，在这种情况下，“优化”并不意味着避免已知对性能有害的代码结构。每一行代码都涉及一种选择，如果你在两种简单、直接的编程方式之间进行选择，选择更高效的一种。

在某个层面上，经验丰富的 Java 开发人员已经很好地理解了这一点（这是他们随着时间学会的艺术的一个例子）。考虑以下代码：

```java
log.log(Level.FINE, "I am here, and the value of X is "
        + calcX() + " and Y is " + calcY());
```

此代码进行了字符串拼接，这可能是不必要的，因为只有在设置了非常高的日志记录级别时才会记录消息。如果消息未打印，则还将不必要地调用`calcX()`和`calcY()`方法。有经验的 Java 开发人员会本能地拒绝这种做法；一些集成开发环境甚至会标记代码并建议修改它。（不过工具并不完美：NetBeans 集成开发环境会标记字符串拼接，但建议的改进仍保留了不需要的方法调用。）

这样写日志记录代码会更好：

```java
if (log.isLoggable(Level.FINE)) {
    log.log(Level.FINE,
            "I am here, and the value of X is {} and Y is {}",
            new Object[]{calcX(), calcY()});
}
```

这避免了字符串拼接（消息格式不一定更有效，但更干净），并且除非启用了日志记录，否则不会调用方法或分配对象数组。

以这种方式编写代码仍然干净且易于阅读；它并没有比编写原始代码需要更多的工作量。好吧，好吧，它需要多输入一些按键和额外的逻辑行。但这并不是应该避免的过早优化类型；这是好程序员学会做出的选择。

不要让来自先驱英雄的脱离上下文的教条阻止你思考你正在编写的代码。本书中将在其他章节中看到类似的例子，包括第九章，在该章节中讨论了处理对象向量的看似无害的循环构造的性能问题。

## 不妨另寻他路：数据库总是瓶颈。

如果你正在开发没有使用外部资源的独立 Java 应用程序，那么该应用程序的性能（大多数情况下）是唯一重要的。一旦添加了外部资源（例如数据库），两个程序的性能都变得重要起来。在一个分布式环境中——例如具有 Java REST 服务器、负载均衡器、数据库和后端企业信息系统——Java 服务器的性能可能是性能问题中最不重要的部分。

这不是一本关于整体系统性能的书。在这样的环境中，必须采取有条不紊的方法来处理系统的所有方面。必须测量和分析系统各部分的 CPU 使用率、I/O 延迟和吞吐量；只有这样，我们才能确定哪个组件导致了性能瓶颈。有关该主题的优秀资源可供使用，并且这些方法和工具并不专门针对 Java。我假设你已经进行了分析，并确定了需要改进的是你环境中的 Java 组件。

另一方面，不要忽视初始分析。如果数据库是瓶颈（提示：确实是），调整访问数据库的 Java 应用程序对整体性能毫无帮助。事实上，这可能适得其反。一般而言，当负载增加到一个负载过重的系统中时，该系统的性能变得更糟。如果在 Java 应用程序中做出了使其更有效的改变——这只会增加已经超负荷的数据库的负载——总体性能实际上可能会下降。危险就在于得出错误的结论，即不应该使用特定的 JVM 改进。

这个原则——在一个性能不佳的系统组件上增加负载会使整个系统变慢——并不局限于数据库。当负载增加到一个 CPU 密集型的服务器上，或者更多线程开始访问已经有线程在等待的锁，或者任何其他情况时，都会应用这个原则。一个仅涉及 JVM 的极端示例显示在第九章中。

## 优化常见情况

很诱人——特别是考虑到“千刀万剐”的综合症——将所有性能方面视为同等重要。但我们应该专注于常见用例场景。这个原则以几种方式体现：

+   通过对代码进行分析并专注于在分析中占用最多时间的操作来优化代码。但是，请注意，这并不意味着只查看分析中的叶子方法（参见第三章）。

+   将奥卡姆剃刀应用于诊断性能问题。性能问题的最简单解释是最可信的原因：新代码中的性能 bug 比机器上的配置问题更有可能，后者比 JVM 或操作系统的 bug 更有可能。晦涩的操作系统或 JVM bug 确实存在，随着排除更可信的性能问题的原因，可能发现某些测试用例不知何故触发了这种潜在 bug。但不要首先考虑不太可能的情况。

+   为应用程序的最常见操作编写简单算法。例如，一个程序估算一个数学公式，用户可以选择是否在 10%误差范围内得到答案，或者 1%误差范围。如果大多数用户满意于 10%的误差范围，优化该代码路径——即使这意味着减慢提供 1%误差范围的代码。

# 概要

Java 具有使其可能从 Java 应用程序中获得最佳性能的特性和工具。本书将帮助您理解如何最好地利用 JVM 的所有特性，以便获得快速运行的程序。

然而，在许多情况下，请记住 JVM 只是整体性能图景中的一小部分。在 Java 环境中，数据库和其他后端系统的性能至少与 JVM 的性能一样重要。本书不关注该级别的性能分析——假定已经进行了尽职调查，以确保 Java 环境的组件是系统中重要的瓶颈。

然而，JVM 与系统其他领域的交互同样重要——无论是直接的（例如，进行最佳的数据库调用方式）还是间接的（例如，优化共享大型系统多个组件的应用程序的本地内存使用）。本书中的信息应该有助于解决沿这些线路的性能问题。

¹ 很少情况下，这两者之间存在差异；例如，AdoptOpenJDK 版本的 Java 在 JDK 11 中包含新的垃圾收集器。当发生这些差异时，我会指出这些差异。

² 在 Docker 中，可以为 CPU 限制指定分数值。Java 将所有分数值都向上舍入到下一个最高整数。

³ 谁最初说过这句话，唐纳德·克努斯还是托尼·霍尔之间存在一些争议，但它出现在克努斯的一篇名为“带有 `goto` 语句的结构化编程”的文章中。在上下文中，这是一个优化代码的论据，即使需要像 `goto` 语句这样的不优雅解决方案。
