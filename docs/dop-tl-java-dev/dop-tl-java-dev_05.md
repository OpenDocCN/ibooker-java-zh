# 第五章。持续集成

Melissa McKay

> 始终犯新错误。
> 
> Esther Dyson

回到第二章时，你学到了源代码控制和常见代码库的价值。在你组织和确定了源代码控制解决方案后，你需要采取更多步骤，以达到一个最终结果，让你的用户可以享受到你交付的软件的完美用户体验。

想象一下，作为个体开发者，你将如何推进软件通过整个软件开发生命周期。确定特定功能或软件 bug 修复的验收标准后，你会继续添加实际的代码行和相关的单元测试到代码库中。然后，你会编译并运行所有的单元测试，以确保你的新代码按照你的预期工作（或者至少是根据你的单元测试定义的），并且不会破坏已知的现有功能。在发现所有测试通过后，你将构建和打包应用程序，并在质量保证（QA）环境中进行集成测试的功能验证。最后，在测试套件给出绿灯的情况下，你将向生产环境交付和/或部署软件。

如果你有任何开发经验，你就像我一样知道，软件很少会如此顺利地落实。当你开始与开发团队一起工作的较大项目时，严格实施理想的工作流程会显得太过简单化。会引入多种复杂因素，可能会干扰软件交付生命周期的进程，打乱你的计划。本章讨论了持续集成及相关的最佳实践和工具集如何帮助你避免或减轻软件开发项目在交付过程中常遇到的最常见障碍和头痛问题。

# 采用持续集成

*持续集成*（CI）通常被描述为频繁地将多个贡献者的代码变更集成到项目的主源代码库中。实际上，这个定义本身有点模糊。在这个上下文中，“频繁”是指多频繁？集成的确切含义是什么？仅仅协调将代码变更推送到源代码库是否足够？最重要的是，这个过程解决了什么问题——你应该采纳这种实践有什么好处？

CI 的概念已经存在了相当长的时间了。[根据马丁·福勒的说法](https://oreil.ly/3sYHE)，*持续集成* 这个术语源自肯特·贝克的极限编程开发过程，作为其最初的 12 项实践之一。在 DevOps 社区中，这个术语现在和面包上的黄油一样普遍。但它的实施方式可能因团队和项目而异。如果不彻底理解原始意图或放弃最佳实践，其益处可能是时有时无。

看到我们对 CI 的理解随时间而变化是很有趣的。现在我们谈论它的方式与贝克最初引入它来解决并发开发问题时大不相同。我们今天面临的问题更多地是保持定期和频繁的构建的效率，同时尽量减少错误，而最初，CI 及其衍生的构建工具的普及更多地是为了在开发完成后使项目能够 *完整* 构建。而不是仅在团队完成所有编码之后才尝试组装项目，CI 要求改变思维方式——在开发过程中定期构建。

如今，CI 的目的是通过定期和频繁的构建尽快地识别开发周期中的错误和兼容性问题。CI 的基本前提是，如果开发人员经常集成变更，就可以更早地发现错误，并减少在寻找问题引入的时间和地点上的浪费。错误被发现的时间越长，它在周围代码库中变得根深蒂固的潜力就越大。

从开发的角度来看，找到、捕捉和修复错误比从已经移动到交付管道后阶段的代码层中提取错误要容易得多。直到最新的验收阶段甚至直接发布的错误，直接转化为更多的修复开销和较少用于新功能开发的时间。在生产环境中修复错误的情况下，在许多情况下，现在要求在包括和记录修复的新版本中补丁现有部署。这从本质上减少了团队用于开发新功能的可用时间。

重要的是要理解，实施持续集成解决方案*并不*等同于永远没有任何错误的软件。用这样一个明确的标准来判断持续集成的实施是否值得是愚蠢的。一个更有价值的指标可能是持续集成捕获的错误或兼容性问题的数量。就像疫苗在大规模人群中从未百分之百有效一样，持续集成只是在软件中提供了另一层保护，以便从发布中过滤掉最明显的错误。持续集成本身永远不会取代软件开发最佳实践的众所周知的好处，这些最佳实践属于最初的设计和开发步骤。然而，随着时间的推移，它将为软件提供一个更好的安全网，因为软件会被多个开发人员反复处理和调整。马丁·福勒这样描述：“持续集成并不能消除错误，但确实能够显著地帮助找到并移除它们。”

我在一家小公司实习时的第一次持续集成经验，该公司采用极限编程（XP）的软件开发方法，其中持续集成是一个重要方面。我们没有使用所有最新和最伟大的 DevOps 工具的非常花哨的系统。我们拥有的是一个共享的代码仓库，以及一个位于办公室小壁橱中的单一构建服务器。

当我首次加入开发团队时，并不知道构建服务器上设置了扬声器，如果从源代码控制进行的新检出导致构建失败或任何自动化测试失败，它就会发出紧急警报声。我们是一个相对年轻的团队，所以我们的持续集成的这一部分大多是戏谑，但猜猜谁学会了*非常*快速地在将代码推送到主代码仓库之前验证项目是否成功构建并通过单元测试？

直至今天，我感到非常幸运能以这种方式接触到这种实践。这种简单性突显了持续集成的最重要方面。我想指出这种简单设置的三个副产品：

代码集成通常是定期的，很少复杂化。

我的团队同意遵循 XP 实践，鼓励尽可能频繁地集成[每隔几个小时](https://oreil.ly/0A7P9)。比特定时间间隔更重要的是在任何给定时间点需要集成的代码量。在计划和拆分实际开发工作时，我们专注于创建小而可完成的任务，始终从[可能最简单的事情开始](https://oreil.ly/Scb94)。通过*可完成*，我指的是开发任务完成后，可以将其集成到主代码仓库中，并期望该结果能够成功构建并通过所有单元测试。将代码更新组织成尽可能小的包的这种做法，使得定期和频繁地将代码集成到主源代码仓库成为一种正常且不值一提的活动。很少有大量时间花费在大规模集成工作上。

构建和测试失败相对较容易排查。

因为项目在常规间隔时间内构建并运行自动化测试，所以很容易看出从哪里开始排查任何失败。自上次成功构建以来，可能只有少量代码被修改，如果问题无法立即识别和解决，我们将从最新的合并开始，并按需向后工作以恢复干净的构建。

由集成引入的错误和兼容性问题，通过 CI 系统立即修复。

警报器发出的巨大声响让*每个人*都知道需要解决一个无法忽视的问题。因为我们的 CI 系统在构建或测试失败时会暂停进度，所以每个人都会全力以赴找出问题所在以及如何解决问题。团队的沟通、协调和合作都处于最佳状态，因为除非问题解决，否则没有人能够继续前进。大多数情况下，可以通过分析最近的合并简单地确定有问题的代码，并将修复责任分配给该开发者或开发者组。有时，由于多个最近的合并引发了兼容性问题，影响了看似无关的系统其他部分，因此需要与整个团队讨论。这些情况需要我们的团队从整体上重新评估正在进行的代码更改，然后共同决定最佳行动方案。

这三个因素是我们的 CI 解决方案成功的关键。您可能已经了解到这三个因素都暗示了健康的代码库和健康的开发团队的先决条件。没有这些因素，CI 解决方案的初始实施无疑会更加困难。然而，实施 CI 解决方案将反过来对代码库产生积极影响，并且采取第一步将带来一定程度的收益，这将非常值得努力。

一个有效的 CI 解决方案远不止是简单地协调代码对共享仓库的贡献，并遵循在约定频率上集成的命令。以下部分将为您介绍完整、实用的 CI 解决方案的基本要素，这将有助于减轻和加速软件开发过程。

# 声明式地编写您的构建

不   不论您的项目处于何种状态——无论是全新项目、遗留项目、小型个人库还是大型多模块项目——在实施 CI 解决方案时，您的第一个任务应该是*编写构建脚本*。拥有一致且可重复的流程，可以自动化的流程，将有助于避免由于依赖管理不当、在创建可分发包时忘记包含所需资源或无意间忽略构建步骤等导致的构建排列组合的痛苦。

编写构建脚本时，通过脚本化你的构建可以节省大量时间。你的项目*构建生命周期*（构建项目所需的所有离散步骤）随着时间的推移可以变得更加复杂，特别是当你消耗更多依赖、包含各种资源、添加模块和测试时。你可能还需要根据预期的部署环境不同方式构建项目。例如，你可能需要在开发或 QA 环境中启用调试能力，但在构建用于发布到生产环境的版本时禁用调试，并防止测试类被包含在可分发包中。手动执行构建 Java 项目所需的所有步骤，包括考虑每个环境的配置差异，是人为错误的温床。第一次忽略构建更新的依赖项等步骤，并因此不得不重复构建一个庞大的多模块项目以纠正你的错误时，你会意识到构建脚本的价值。

无论你选择哪种工具或框架来编写你的构建脚本，都要注意使用*声明性*方法而不是*命令式*方法。这里简要提醒一下这些术语的含义：

命令式的

定义一个包含实施细节的确切过程

声明性的

定义一个没有实施细节的动作

换句话说，保持你的构建脚本专注于*需要*做的事情，而不是如何做。这将有助于保持你的脚本易于理解、可维护、可测试和可扩展，鼓励在其他项目或模块中重复使用。为了实现这一点，你可能需要建立或遵循一个已知的约定，或者编写插件或其他从你的构建脚本引用的外部代码，提供实施细节。一些构建工具更倾向于采用声明性方法而不是其他方法。这通常是在灵活性与遵循约定之间权衡的结果。

Java 生态系统有几个成熟的构建工具可用，所以如果你目前手动使用`javac`编译你的项目并将类文件打包成 JAR 或其他包类型，我会感到惊讶。你很可能已经有了某种构建流程和脚本，但在极少数情况下，如果你没有，你正在启动一个全新的 Java 项目，或者你希望改进现有的脚本以利用最佳实践，本节总结了 Java 生态系统中几种最常见的构建工具/框架及其开箱即用的功能。

首先，重要的是绘制你的构建过程图，确定你需要从构建脚本中获得的东西以获得最大的效益。要构建一个 Java 项目，至少需要指定以下内容：

Java 版本

编译项目所需的 Java 版本

源代码目录路径

项目的源代码目录

目标目录路径

预期编译类文件放置的目录

需要的依赖项的名称、位置和版本

定位和收集项目所需的任何依赖项所需的元数据

有了这些信息，您应该能够执行以下步骤来执行最小的构建过程：

1.  收集所有必需的依赖项。

1.  编译代码。

1.  运行测试。

1.  打包您的应用程序。

展示如何将您的构建过程调整为构建脚本的最佳方式是通过示例。以下示例演示了使用三种最常见的构建工具来脚本化为简单的 Hello World Java 应用程序描述的最小构建过程。这些示例无论如何都不会探索这些工具中可用的所有功能。它们只是作为一个速成课程，帮助您开始理解现有的构建脚本或编写您的第一个构建脚本以从完整的 CI 解决方案中获益。

在评估构建工具时，请记住您的项目完成构建所需的实际过程。您的项目可能需要脚本化其他未在此处显示的步骤，并且一个构建工具可能比另一个更适合完成这些步骤。选择的工具应帮助您以编程方式定义和加速项目所需的构建过程，而不是随意迫使您修改流程以适应工具的要求。话虽如此，当您了解工具的功能时，请反思您的流程，并注意会为您的团队带来好处的变化。这在已建立的项目中尤为重要。不论出于何种善意，对流程的更改对开发团队来说可能是痛苦的。只有在有意识地、明确理解变更原因和显著好处的情况下才应该进行这些更改。

## 使用 Apache Ant 进行构建

*Apache Ant* 是一个由 Apache 软件基金会发布的开源项目，根据 Apache 许可证发布。根据[Apache Ant 文档](https://ant.apache.org)，其名称是 Another Neat Tool 的缩写，最初是 Tomcat 代码库的一部分，由 James Duncan Davidson 编写，用于构建 Tomcat。它的第一个初始版本发布于 2000 年。

Apache Ant 是一个用 Java 编写的构建工具，提供了在 XML 文件中描述构建过程的声明性步骤的方式。这是我在我的 Java 生涯中接触的第一个构建工具，尽管 Ant 今天面临激烈的竞争，但它仍然是一个活跃的项目，并经常与其他工具结合使用。

示例 5-1 是我创建并使用 Ant 1.10.8 执行的一个简单的 Ant 构建文件。

##### 示例 5-1\. Ant 构建脚本 (build.xml)

```java
<project name="my-app" basedir="." default="package"> ![1](img/1.png)

    <property name="version" value="1.0-SNAPSHOT"/> ![2](img/2.png)
    <property name="finalName" value="${ant.project.name}-${version}"/>
    <property name="src.dir" value="src/main/java"/>
    <property name="build.dir" value="target"/>
    <property name="output.dir" value="${build.dir}/classes"/>
    <property name="test.src.dir" value="src/test/java"/>
    <property name="test.output.dir" value="${build.dir}/test-classes"/>
    <property name="lib.dir" value="lib"/>

    <path id="classpath"> ![3](img/3.png)
        <fileset dir="${lib.dir}" includes="**/*.jar"/>
    </path>

    <target name="clean">
        <delete dir="${build.dir}"/>
    </target>

    <target name="compile" depends="clean"> ![4](img/4.png)
        <mkdir dir="${output.dir}"/>
        <javac srcdir="${src.dir}"
               destdir="${output.dir}"
               target="11" source="11"
               classpathref="classpath"
               includeantruntime="false"/>
    </target>

    <target name="compile-test">
        <mkdir dir="${test.output.dir}"/>
        <javac srcdir="${test.src.dir}"
               destdir="${test.output.dir}"
               target="11" source="11"
               classpathref="classpath"
               includeantruntime="false"/>
    </target>

    <target name="test" depends="compile-test"> ![5](img/5.png)
        <junit printsummary="yes" fork="true">
            <classpath>
                <path refid="classpath"/>
                <pathelement location="${output.dir}"/>
                <pathelement location="${test.output.dir}"/>
            </classpath>

            <batchtest>
                <fileset dir="${test.src.dir}" includes="**/*Test.java"/>
            </batchtest>
        </junit>
    </target>

    <target name="package" depends="compile,test"> ![6](img/6.png)
        <mkdir dir="${build.dir}"/>
        <jar jarfile="${build.dir}/${finalName}.jar"
              basedir="${output.dir}"/>
    </target>

</project>
```

![1](img/#co_continuous_integration_CO1-1)

可以将项目的 `default` 属性值设置为在没有目标的情况下调用 Ant 时要运行的默认目标的名称。对于这个项目，不带任何参数运行 `ant` 命令将运行 *package* 目标。

![2](img/#co_continuous_integration_CO1-2)

Property 元素是硬编码的不可变值，可以在构建脚本的其余部分多次使用。使用它们有助于提高可读性和可维护性。

![3](img/#co_continuous_integration_CO1-3)

此路径元素是我选择用来管理此项目所需依赖项位置的方式。在这种情况下，*junit*和*hamcrest-core* JAR 包都手动放置在这里配置的目录中。这种技术意味着依赖项将与项目一起提交到源代码控制中。尽管这在本例中很简单，但这并不是推荐的做法。第六章详细讨论了包管理。

![4](img/#co_continuous_integration_CO1-4)

`compile`目标负责编译源代码（本项目指定 Java 11），并将生成的类文件放置在配置的位置。此目标依赖于*clean*目标，这意味着将首先运行 clean 目标，以确保编译的类文件是新鲜的，而不是旧构建中遗留下来的。

![5](img/#co_continuous_integration_CO1-5)

`test`目标配置了 JUnit Ant 任务，该任务将运行所有可用的单元测试并将结果打印到屏幕上。

![6](img/#co_continuous_integration_CO1-6)

`package`目标将组装并放置最终的 JAR 文件在配置的位置。

执行一行命令`ant package`将接管我们的 Java 项目，编译它，运行单元测试，然后为我们组装一个 JAR 文件。Ant 灵活且功能丰富，满足我们脚本化最小构建的目标。XML 配置文件是记录项目构建生命周期的清晰简洁方式。单独使用 Ant 在依赖管理方面存在不足。但是，像[Apache Ivy](https://oreil.ly/7t5v5)这样的工具已被开发用来扩展此功能以适用于 Ant。

## 使用 Apache Maven 构建

根据[Apache Maven 项目文档](https://oreil.ly/CziRT)，*maven*是意第绪语中的一个词，意为*知识的积累者*。与 Apache Ant 类似，Maven 也是 Apache 软件基金会的一个开源项目。它起初是对 Jakarta turbine 项目构建的改进，该项目为每个子项目使用了各种 Ant 配置。它于 2004 年首次正式发布。

与 Apache Ant 类似，Maven 使用 XML 文档（POM 文件）来描述和管理 Java 项目。该文档记录了项目的信息，包括项目的唯一标识符、所需的编译器版本、配置属性值以及所有必需依赖项及其版本的元数据。Maven 最强大的功能之一是其依赖管理和使用存储库与其他项目共享依赖项的能力。

Maven 在提供一种统一的项目管理和文档化方法上依赖于约定，这可以轻松地跨所有使用 Maven 的项目进行扩展。期望将项目以特定方式布置在文件系统上。为了保持脚本声明性，定制实现需要构建自定义插件。虽然可以对预期的默认值进行广泛定制，但如果符合预期的项目结构，Maven 就可以无需大量配置即可开箱即用。

示例 5-2 是我使用 Maven 3.6.3 配置的适用于我的 Java 11 环境的简单 POM 文件。

##### 示例 5-2\. Maven POM 文件（pom.xml）

```java
<?xml version="1.0" encoding="UTF-8"?>

<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation=
            "http://maven.apache.org/POM/4.0.0
            http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>

  <groupId>com.mycompany.app</groupId> ![1](img/1.png)
  <artifactId>my-app</artifactId>
  <version>1.0-SNAPSHOT</version>

  <name>my-app</name>
  <!-- FIXME change it to the project's website -->
  <url>http://www.example.com</url>

  <properties> ![2](img/2.png)
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    <maven.compiler.release>11</maven.compiler.release>
  </properties>

  <dependencies> ![3](img/3.png)
    <dependency>
      <groupId>junit</groupId>
      <artifactId>junit</artifactId>
      <version>4.11</version>
      <scope>test</scope>
    </dependency>
  </dependencies>

  <build> ![4](img/4.png)
    <pluginManagement>
      <plugins>
        <plugin> ![5](img/5.png)
          <artifactId>maven-compiler-plugin</artifactId>
          <version>3.8.0</version>
        </plugin>
      </plugins>
    </pluginManagement>
  </build>
</project>
```

![1](img/#co_continuous_integration_CO2-1)

每个项目都由其配置的 `groupId`、`artifactId` 和 `version` 唯一标识。

![2](img/#co_continuous_integration_CO2-2)

属性是硬编码的值，可能在 POM 文件中的多个地方使用。它们可以是自定义属性，也可以是插件或目标使用的内置属性。

![3](img/#co_continuous_integration_CO2-3)

在 `dependencies` 块中，识别项目的所有直接依赖项。该项目依赖于 JUnit 运行单元测试，因此在此处指定了 *junit* 依赖项。JUnit 本身又依赖于 *hamcrest-core*，但 Maven 足够智能，可以在此处包含它而无需在此处包含它。默认情况下，Maven 将从 Maven 中央拉取这些依赖项。

![4](img/#co_continuous_integration_CO2-4)

`build` 块是配置插件的地方。除非有配置要覆盖，否则不需要此块。

![5](img/#co_continuous_integration_CO2-5)

所有生命周期阶段都存在默认的插件绑定，但在这种情况下，我想要配置 `maven-compiler-plugin` 来使用 Java 版本 11，而不是默认版本。控制此插件的属性是 `properties` 块中的 `maven​.com⁠piler.release`。此配置可以放在 `plugins` 块中，但将其移动到 `properties` 块以更好地向文件顶部显示更有意义。此属性替换了在使用较旧版本的 Java 时通常看到的 `maven.compiler.source` 和 `maven.compiler.target`。

###### 警告

锁定所有 Maven 插件版本是个好主意，以避免使用 Maven 默认值。特别要注意当使用较旧版本的 Maven 和 Java 版本 9 或更高版本时，根据 Maven 的配置构建脚本的说明。您的 Maven 安装的默认插件版本可能与较新版本的 Java 不兼容。

由于对约定的强烈依赖，这个 Maven 构建脚本非常简洁。有了这个小小的 POM 文件，我可以执行 `mvn package` 来编译、运行测试并组装一个 JAR 文件，所有这些都使用默认设置。如果你花时间使用 Maven，你很快就会意识到它不仅仅是一个构建工具，而且充满了强大的功能。对于刚接触 Maven 的人来说，它的潜在复杂性可能会让人感到不知所措。此时，[Apache Maven 项目](https://oreil.ly/CziRT) 的文档包含了非常好的资源，包括 [Maven in 5 Minutes](https://oreil.ly/dkxa6) 指南。如果你对 Maven 不熟悉，我强烈推荐从这些资源开始学习。

###### 提示

尽管 [Apache Maven Ant 插件](https://oreil.ly/DOg5K) 不再维护，但仍然可以从 Maven POM 文件生成一个 Ant 构建文件。这样做将帮助你体会 Maven 的约定和默认设置所带来的一切！在与你的 *pom.xml* 文件相同的目录中，使用 `mvn ant:ant` 命令调用 Maven 插件。

## 使用 Gradle 进行构建

*Gradle* 是一个根据 Apache 2.0 许可发布的开源构建工具。Gradle 的创始人 Hans Dockter 在 [Gradle 论坛中解释](https://oreil.ly/1mEwy)，他最初的想法是将项目命名为带有 *C* 的 Cradle。最终他决定使用带有 *G* 的 Gradle，因为它使用 Apache Groovy 作为领域特定语言（DSL）。Gradle 1.0 于 2012 年发布，因此与 Apache Ant 和 Apache Maven 相比，Gradle 是新进者。

Gradle 与 Maven 和 Ant 最大的区别之一是，Gradle 构建脚本不是基于 XML 的。相反，Gradle 构建脚本可以用 Groovy 或 Kotlin DSL 编写。与 Maven 类似，Gradle 也利用约定，但比 Maven 更灵活。[Gradle 文档](https://oreil.ly/Vvhch) 强调了该工具的灵活性，并包括了如何轻松定制你的构建的说明。

###### 提示

Gradle 在 [将 Maven 构建迁移到 Gradle](https://oreil.ly/RqR1s) 方面有广泛的在线文档。你可以从现有的 Maven POM 文件生成一个 Gradle 构建文件。

示例 5-3 是一个简单的 Gradle 构建文件，我从上一节的 示例 5-2 的内容生成的。

##### 示例 5-3\. Gradle 构建脚本（build.gradle）

```java
/*
 * This file was generated by the Gradle 'init' task.
 */

plugins {
    id 'java' ![1](img/1.png)
    id 'maven-publish'
}

repositories { ![2](img/2.png)
    mavenLocal()
    maven {
        url = uri('https://repo.maven.apache.org/maven2')
    }
}

dependencies {
    testImplementation 'junit:junit:4.11' ![3](img/3.png)
}

group = 'com.mycompany.app'
version = '1.0-SNAPSHOT'
description = 'my-app'
sourceCompatibility = '11' ![4](img/4.png)

publishing {
    publications {
        maven(MavenPublication) {
            from(components.java)
        }
    }
}

tasks.withType(JavaCompile) { ![5](img/5.png)
    options.encoding = 'UTF-8'
}
```

![1](img/#co_continuous_integration_CO3-1)

Gradle 插件通过将它们的 *插件 ID* 添加到 `plugins` 块来应用。`java` 插件是 Gradle 核心插件，为 Java 项目提供编译、测试、打包以及其他功能。

![2](img/#co_continuous_integration_CO3-2)

依赖项的仓库在 `repositories` 块中提供。使用这些设置来解析依赖项。

![3](img/#co_continuous_integration_CO3-3)

Gradle 处理依赖项的方式类似于 Maven。我们的单元测试需要 JUnit 依赖项，因此它被包含在 `dependencies` 块中。

![4](img/#co_continuous_integration_CO3-4)

`sourceCompatibility` 配置设置由 `java` 插件提供，并映射到 `javac` 的 `source` 选项。还有一个 `targetCompatibility` 配置设置。其默认值是 `sourceCompatibility` 的值，因此没有必要将其添加到构建脚本中。

![5](img/#co_continuous_integration_CO3-5)

Gradle 的灵活性允许我为 Java 编译器添加显式编码设置。`java` 插件提供的一个任务称为 `compileJava`，其类型为 `Java​Com⁠piler`。此代码块在这个编译任务上设置了编码属性。

这个 Gradle 构建脚本允许我通过执行单个命令 `gradle build` 来编译、运行测试并组装项目的 JAR 文件。由于 Gradle 构建基于众所周知的约定，因此构建脚本仅包含区分构建所需的内容，有助于保持其小巧和可维护性。这个简单的脚本展示了 Gradle 的强大和灵活性，特别适用于具有较复杂构建过程的 Java 项目。在这种情况下，投入时间去理解用于定制的 Gradle DSL 是非常值得的。

这三种用于构建 Java 项目的工具各有优劣。选择一个工具应基于项目需求、团队经验和所需的灵活性。无论你如何选择和使用构建脚本，以及选择任何工具，都将极大地提高你的效率。构建 Java 项目是一个重复的过程，包含许多步骤，容易出现人为错误，但非常适合自动化。将项目构建简化为单个命令可节省新开发人员的上手时间，在本地开发环境中增加开发任务的效率，并为构建自动化铺平道路，这是有效 CI 解决方案的重要组成部分。

# 持续构建

代码集成失败最明显的迹象是构建失败。因此，项目应经常构建，以尽早检测和解决任何问题。事实上，*对主线代码库的每一次贡献都应期望能够成功编译并通过所有单元测试*。

###### 注意

当提及将代码合并到主干源代码库后构建项目时，我故意使用*contribution*一词，而不是*commit*或*check-in*。这仅是因为您的开发团队可能已同意遵循多个开发流程（都是有效的），在其中一些流程中，*contribution*到主干可能是一个分支的合并或拉取请求的合并——两者都可能包含一个或多个提交。

以下是使用测试驱动开发的典型开发者工作流程：

1.  从源代码控制中检出最新的代码到本地工作空间。

1.  构建并运行项目的所有测试，以确保开始时处于干净状态。（应该有一个构建脚本来完成此操作。参见“声明式地编写您的构建”。）

1.  编写新功能或错误修复的代码和相关单元测试。

1.  运行新的单元测试，确保它们通过。

1.  构建并运行项目的*所有*单元测试，确保新代码在与现有代码集成时不会产生负面影响。（再次强调，使用构建脚本完成此操作。）

1.  将新代码与新测试一同提交到代码库。

此流程旨在在代码离开您的本地开发工作空间之前防止问题（包括引入错误或功能丢失）。但是，在此工作流程期间可能会出现问题，这些问题会在今后带来痛苦。一些问题是由于人类本性的现实而引起的，而另一些则是因为无论进行多少先进的规划努力，几乎不可能防止由并行开发引入的每一个潜在不兼容性。不要误会；我*并不*是说这个过程是错误的，应该完全丢弃。相反，本节解释了自动化的持续集成实施如何帮助减轻可能在此工作流程中出现的问题，并增强您作为开发者的效率和生产力。

对于开发人员来说，仅在自己的本地环境中成功构建项目是不够的。即使每个开发人员都严格遵守约定的流程，并且只有在所有测试通过后才提交代码更改，您也不应仅依赖于此。最简单的原因是，开发人员可能没有来自主干的最新更改（当许多开发人员在同一个代码库中工作时，这种情况更有可能发生）。这可能导致在代码合并后才发现的不兼容性。

有时，测试问题可能只在其他人尝试在他们自己的本地开发环境中构建或运行测试时才会显露出来。例如，不止一次，我尴尬地忘记了提交我创建的新文件或资源到代码库中。这意味着接下来收集这些更改的开发人员将遭受要么立即构建失败，要么测试失败的烦恼。我见过的另一个问题是，代码写成只在特定环境或特定操作系统中才能工作。

我们都会有不好的日子，即使在最理想的情况下，这些问题有时也会悄悄溜走。但与其让破碎的构建像病毒一样在团队中蔓延，不如采取策略来帮助减轻这类集成问题。最常见的方法是使用自动构建服务器或 CI 服务器。这些服务器由负责执行完整构建（包括运行测试）并在代码更改提交后报告构建结果的开发团队共享使用。

您可能熟悉的流行 CI 服务器包括 Jenkins、CircleCI、TeamCity、Bamboo 和 GitLab。还有一些新选项正在涌现，如 JFrog Pipelines，有些比其他服务器具有更多的功能和能力，但主要目标是通过经常构建并在出现问题时报告来为共享代码库中的代码更改建立一个裁判。利用 CI 服务器自动运行构建的目的是确保定期进行构建，早期发现任何集成问题。

# 自动化测试

除了在开发过程中运行单个测试（通常在 IDE 内部），开发人员在将新代码提交到代码库之前，应该有一种快速运行完整自动化测试套件的方法。

在“声明性地编写您的构建脚本”中概述的最小构建过程包括自动运行单元测试的步骤。每个构建脚本示例都包括这个单元测试步骤。这并非偶然。事实上，您构建的这一部分对于健康的 CI 解决方案至关重要，并值得花费相当多的时间和注意力。CI 的主要目的之一是尽可能早地在开发过程中捕捉集成问题的能力。

单元测试本身不会揭示每一个问题 —— 这是不现实的期望。但编写一组强大的单元测试是早期检测最明显问题的最佳预防性方法之一。因为甚至可以在正式质量保证的第一个阶段之前运行单元测试，所以它们是开发周期中非常有价值的一部分。它们是您可以采取的第一套安全措施，以确保您的软件在生产环境中的正确行为。

这一部分不会详细说明如何在 Java 中编写单元测试。我假设你理解并接受它们的重要性，你的项目有单元测试，并且你使用了一个能够自动运行它们的框架，比如 JUnit 或 TestNG。如果你没有，立即停下来为你的项目编写一个简单的单元测试，以便在构建过程中自动运行，以便在你的 CI 解决方案中扩展这一步骤。然后，安排时间与你的开发团队坐下来，策划你将如何编写和维护单元测试。

Java 生态系统中有许多测试工具可用，本节不旨在对它们进行详尽的比较或推荐其中一种。相反，我讨论测试自动化应该如何融入你的 CI 流程，你的测试套件应该追求的特性，以及在 CI 环境中如何避免常见的陷阱，这些陷阱会影响你的效率。

# 监控和维护测试

将最新的代码检出到你的本地开发工作空间是相当简单的。编译和运行所有的单元测试也很简单。但随着你添加更多的模块，你的项目变得越来越复杂，进行完整的构建并运行所有的测试将会花费更多的时间。你的开发过程越长，其他代码更改就越有可能在你之前引入到主干线上。

为了防止潜在的中断，你将不得不检出最新的更改并重新运行所有的测试——这不是一个非常高效的过程。沮丧可能会导致开发人员采取捷径，跳过运行测试的步骤，以便在主干代码被更改之前提交代码。显然，这是一个很容易导致主干代码更频繁出现问题的泥潭，从而减慢整个团队的速度。

维护测试需要时间，这个时间应该定期纳入到开发进度中。就像你的代码库的其余部分一样，测试需要随着时间的推移进行改进和调整。当它们变得过时时，它们应该被移除。当它们失败时，它们应该被修复。经常在浏览各种代码库时，我会遇到被注释掉的测试用例。这发生的原因有几种；没有一种是好的。有时只是因为一个团队时间紧迫，感到需要强行通过一个构建过程以满足截止日期，并承诺稍后再次审查测试。有时，是因为一个特定的测试用例不一致地失败，这被称为*flaky*测试。这可能是由于竞争条件或测试错误地期望为静态的动态值。

无论哪种情况，操控测试不运行都是一种危险的做法，表明开发团队存在更大的问题。需要重新审视优先事项。不处理过时或脆弱的测试，甚至更糟的是根本不编写测试，会削弱项目的防护措施，也违背了你精心设计的持续集成流程的初衷。

有时候测试不运行是因为确定它们耗时过长。利用你的持续集成服务器定期记录测试运行时间，并确定可接受的阈值。随着项目的增长，如果构建时间超出可接受的阈值，就要停下来检查你的测试。寻找过时的测试、重复的测试以及可以并行运行的测试。考虑你希望构建服务器多频繁运行（潜在地在每次代码变更后），每秒钟都很重要。

# 摘要

本章介绍了持续集成作为开发团队的一项基本实践。随着时间的推移，开发的工具不断发展，帮助我们提高了在构建软件项目方面的效率。自动触发构建以及自动运行测试有助于开发人员更好地专注于编码，并在开发过程中更早地捕获错误代码。人们很容易想当然地享受自动化节省的工作量，但理解底层的细节尤为重要，特别是在涉及到你的测试套件时。不要让维护不良的测试削弱持续集成系统带来的好处。
