# 前言

你好，我是邓肯和纳特。当你阅读这篇前言时，你可能正在考虑是否值得投入时间来阅读本书的其余部分。那么让我们来直接谈谈：

> 这本书不会教你如何在 Kotlin 中编写计算机程序。

我们开始写一本书，本来是打算的，但很快就明白 Kotlin 是一门庞大的语言，所以这本书将需要比我们期望的更长时间来写。在这个领域已经有一些很棒的书籍，我们不喜欢和这些优秀作品竞争。

相反，我们决定通过专注于将 Kotlin 教给 Java 开发人员来简化我们的生活，这基于我们开展的一个名为“重构到 Kotlin”的研讨会。这通过转换现有代码来教授 Kotlin 语言，并且（根据我们的营销材料）专为希望利用现有知识加速 Kotlin 采用的 Java 团队设计。

我们开始写*那本*书，但很快就清楚 Kotlin *依然*是一门庞大的语言，所以我们会*仍然*花很长时间来写。我们还发现，有动力和经验丰富的 Java 开发人员可以很快掌握 Kotlin 的大部分内容。对于我们的目标读者来说，逐个研究语言特性显得有些居高临下，他们可能一看就会欣然接受并采用。所以我们放弃了那个想法，结果是：

> 这本书不会教你 Kotlin 语言。

那么为什么你应该阅读它呢？因为我们写了这本书，这是我们在首次采用 Kotlin 时希望能使用的书籍。我们是经验丰富的程序员，深知 Java 和 Java 生态系统。我们希望你也是。和我们一样，你可能在许多其他语言中有经验。你已经学会了 Kotlin 的基础知识，并且意识到要充分利用这门语言，你需要不同的系统设计方式。你已经发现在 Java 中繁琐的一些事情在 Kotlin 中要简单得多，而一些特性，比如检查异常，在 Kotlin 中根本不存在。你不想最终只是用 Kotlin 语法写 Java 代码。

或许你对此非常关注。也许你在技术领导岗位上，或者已成功说服你的团队采用 Kotlin。你可能已经花了一些政治资本将 Kotlin 引入项目中。现在你需要确保过渡顺利进行。

也许你负责一个 Java 代码库，并且希望确保引入 Kotlin 不会使其现有的关键业务代码不稳定。或者你正在从零开始启动一个 Kotlin 项目，但意识到你的设计直觉更容易转向 Java 和对象，而不是 Kotlin 和函数。

如果您和我们一样，正处于这种情况，那么您来对地方了。本书将帮助您调整思维和设计，以利用 Kotlin 的优势。然而，仅此还不够，因为您有现有的代码需要维护和增强。因此，我们还展示了如何使用内置于 IntelliJ IDE 的自动重构工具，逐步安全地从 Java 迁移到 Kotlin 语法和 Kotlin 思维。

# 本书的组织方式

本书讨论的是如何从 Java 过渡到 Kotlin，主要集中在代码上，但也涉及到项目和组织。每章都涉及此过渡的一个方面，探讨了一些典型 Java 项目的方面，在这个过程中可以改进。它们以*Java Way* to *Kotlin Way*的模式命名，我们建议您更喜欢后者而不是前者。也许 Kotlin 使得一种在 Java 中困难的方法更容易，或者 Kotlin 阻止了一个在 Java 中常见的方法，以指导设计朝着更少出错、更简洁和更易于工具处理的方向发展。

我们不仅*建议*您采用 Kotlin 的方式；章节还展示了如何进行转换。不是简单地重写 Java，而是通过逐步重构它到 Kotlin 的方式，这样做是安全的，并且允许我们维护混合语言的代码库。

# 我们如何选择这些主题的？

我们首先分析了 Java 和 Kotlin 开发者对各自语言的使用，并进行了采访，以确定差异和混淆的领域。这得到了对 33,459 个开源 Java 和 Kotlin 代码库的机器学习分析的支持。这些被标记为一种到另一种形式的候选项，然后根据频率和开发者痛苦指数对它们进行了排名，以确定哪些应该被选中。最后，我们按照…

…没错，我们不能对您说谎。

事实是我们开始选择我们想写的主题，并且我们认为这些主题将是有趣且富有信息的。第十五章，*封装集合到类型别名*，第九章，*多到单表达式函数*，和第二十章，*执行 I/O 到传递数据*是这些章节的典型代表。我们还寻找 Kotlin 和 Java 的谷粒明显不同的地方，因为这些地方是我们通过问为什么学到最多的地方。这导致了像第四章，*Optional 到 Nullable*，第六章，*Java 到 Kotlin 集合*，和第八章，*静态方法到顶层函数*这样的章节的产生。

当我们写这些章节时，其他主题也呈现出来并被添加到列表中。特别是在为某章节写重构步骤时，我们经常发现自己在修改代码，觉得这些修改值得成为独立章节。第十三章，《从流到可迭代对象到序列》，第十章，《函数到扩展函数》，以及第十一章，《方法到属性》就是这些例子。

这个过程的结果绝不是穷尽的。如果你已经浏览过目录或索引，会发现一些重要的主题未被涵盖。以协程为例：这段话是对这个重要主题唯一的提及，因为我们发现它们并没有改变我们编写服务器端代码的方式，所以我们不打算写它们。还有一些主题，如果有空间和时间的话，我们本来也想涵盖，包括：构建器、领域特定语言、反射、依赖注入框架、事务……清单可以继续列下去！

我们希望我们所写的内容能够引起您的兴趣。这本书主要是战术书而非战略书，侧重于我们可以在战壕里赢得的小战役，而不是整个师的指挥下可能取得的成就。随着更大的主题逐渐显现，我们会尝试将它们联系起来，并在最终章节第二十三章，《继续旅程》中汇聚一切，讨论我们在写作过程中学到的东西。

# 复杂性

我们应该如何评价软件的内部质量呢？假设它做到了我们的客户希望或需要的功能，我们怎样比较两种潜在的实现，或者决定一个变更是使其更好还是更差？你们作者选择的答案是复杂性。其他条件相同的情况下，我们更青睐于能够产生可预测行为的简单设计。

当然，在某种程度上，简单和复杂是取决于观察者的视角。我们的作者确实有稍微不同的个人偏好，因此有时会对某种实现方式的优劣持不同意见。在这种情况下，我们有时会在相关章节中探讨替代方案。然而，我们都坚信函数式编程结合面向对象的消息传递能够降低系统复杂性的强大威力。

多年来，Java 一直朝这个方向发展。Scala 朝着函数式编程迈进，但远离面向对象。我们发现 Kotlin 的特性让我们能够以一种方式混合函数式和面向对象编程，从而降低复杂性并发挥普通开发者的最佳潜力。

# 完美代码

关于凡人的问题，我们应该谈谈代码质量。当将代码提交到书中时，很难不去追求完美。我们知道你将根据这里的代码来评判我们，像许多开发者一样，我们自己的自尊与我们所产生的工作质量紧密相连。

与此同时，我们是工程师而不是艺术家。我们的工作是为我们的客户平衡范围、进度和成本。除了当它影响到这三个更高价值之一时，没有人真正关心代码的质量。

因此，在我们的示例中，我们试图展示真实的生产代码。起点有时不像我们想要的那样好；毕竟，我们正在试图展示改进它们的方法。通常，重构会使事情变得更糟，然后再变得更好，因此绝对不要通过一章中间的代码来判断我们。到了一章的末尾，我们的目标是有足够好的代码，但不要太完美，以至于我们被指责浪费客户的钱。

尽管如此，我们有一个政策，即即使我们已经涵盖了我们打算阐明的主题，我们也会采取具有成本效益的变化来整理，而且我们不止一次地发明了一个主题，并写了一章内容，只是为了让代码处于我们满意的状态。最终，我们既是艺术家，也是工程师。

# 代码格式化

我们的代码遵循（我们对）Java 和 Kotlin 标准编码约定的解释，尽可能地。

对于打印的代码示例，实际的行长要比我们这些天在 IDE 中通常使用的 120 个字符短得多，因此我们不得不经常分割行以使代码适应页面宽度。我们的生产代码可能会在一行上有四五个参数或参数；在本书中，我们通常只有一个。通过为页面格式化示例，我们已经喜欢上了更垂直的风格。我们发现 Kotlin 自然似乎想要占用比 Java 更多的垂直空间，但即使是 Java 的可读性也通过更短的行、更多的换行和更多的视觉对齐而得到了改进。当然，在 IDE 中横向滚动几乎和在书中一样不方便，我们的配对会话因减少滚动和增加并排窗口而得到改善。每个参数一行也极大地改善了代码版本之间的差异。我们希望至少你不会觉得阅读起来太痛苦，如果你不觉得，那么请尝试为自己的代码尝试一下。

我们有时会隐藏与讨论无关的代码。以三个点的省略号开头的行表示，出于清晰或简洁的原因，我们省略了一些代码。例如：

```java
fun Money(amount: String, currency: Currency) =
    Money(BigDecimal(amount), currency)

... and other convenience overloads
```

# 本书中使用的约定

本书使用以下排版约定：

*斜体*

表示新术语、URL、电子邮件地址、文件名和文件扩展名。

`等宽字体`

用于程序清单，以及段落内部引用程序元素，如变量或函数名、数据库、数据类型、环境变量、语句和关键字。

###### 小贴士

这个元素表示一个提示或建议。

###### 注意

这个元素表示一般说明。

###### 警告

这个元素表示警告或注意事项。

# 使用代码示例

本书中的大部分代码示例（来自重构部分的示例）都可以在线访问 GitHub。参考文献立即在代码后面，像这样：

```java
class TableReaderAcceptanceTests {
    @Test
    fun test() {
    }
}
```

[示例 0.1 [table-reader.1:src/test/java/travelator/tablereader/TableReaderAcceptanceTests.kt]](https://java-to-kotlin.dev/code.html?ref=0.1&show=file) [(差异)](https://java-to-kotlin.dev/code.html?ref=0.1&show=diff)

如果您在设备上阅读本书，则引用应该是指向 GitHub 上该版本文件的超链接。在真正的纸张上，您可以随心所欲地点击；但是什么也不会发生，抱歉。但是，如果您取得示例编号，例如在这种情况下是*0.1*，并将其输入到[本书网站上的表单](https://java-to-kotlin.dev/code.html)，它会显示带您到同一位置的链接。

在 Git 中，不同的代码示例（有时跨越多个章节）会在单独的分支上演变。这些步骤都被标记了，*table-reader.1*就是这种情况下的标记。GitHub 链接指向了具有该标记的代码，因此您可以查看显示的文件（此处为*src/test/java/travelator/tablereader/TableReaderAcceptanceTests.kt*）以及该版本中的其他示例。您还可以选择其他标签以查看不同的版本，以及选择不同的分支以查看不同的示例。为了更快地导航，您可以克隆存储库，打开它在 IntelliJ 中，并使用 Git 工具窗口切换分支和版本。

###### 警告

代码示例并不是真实的！代码库可以构建并通过测试，但它是虚构的。有些地方示例不正确地连接起来，有些地方如果您窥视幕后，您会看到我们在摇晃杆杆。我们试图保持诚实，但更愿意发货！

如果您有技术问题或者在使用代码示例时遇到问题，请访问[本书网站](https://java-to-kotlin.dev)或发送电子邮件至*bookquestions@oreilly.com*。

本书旨在帮助您完成工作任务。一般情况下，如果本书提供了示例代码，您可以在自己的程序和文档中使用它。除非您复制了代码的大部分内容，否则您无需联系我们以获得许可。例如，编写一个使用本书中几个代码块的程序不需要许可。出售或分发 O'Reilly 图书的示例代码需要许可。通过引用本书并引用示例代码来回答问题不需要许可。将本书中大量示例代码合并到您产品的文档中需要许可。

我们感谢，但通常不要求署名。署名通常包括标题、作者、出版商和 ISBN 号。例如：“*Java to Kotlin* by Duncan McGregor and Nat Pryce (O’Reilly). Copyright 2021 Duncan McGregor and Nat Pryce, 978-1-492-08227-9。”

如果您认为您使用的代码示例超出了公平使用范围或上述授权，请随时通过*permissions@oreilly.com*联系我们。


# 致谢

感谢 Hadi Hariri 建议 O’Reilly 我们应该写一本书，以及 Zan McQuade 相信他。感谢我们的编辑 Sarah Grey，她不得不忍受后果，以及 Kerin Forsyth 和 Kate Galloway 整理一切并实际将其出版。

许多朋友和同事，以及一些可爱的陌生人，审阅了从早期的不协调到令人心驰神往的几乎完成的草稿。感谢 Yana Afanasyeva、Jack Bolles、David Denton、Bruce Eckel、Dmitry Kandalov、Kevin Peel、James Richardson、Ivan Sanchez、Jordan Stewart、Robert Stoll、Christoph Sturm、Łukasz Wycisk 和 Daniel Zappold，以及我们的技术审阅者 Uberto Barbini、James Harmon、Mark Maynard 和 Augusto Rodriguez。我们非常感谢你们的建议、鼓励和坦率。

极限编程彻底改变了软件编写的方式 — 我们都应感谢沃德·坎宁安（Ward Cunningham）和肯特·贝克（Kent Beck）。同时也要感谢马丁·福勒（Martin Fowler），如果没有他，这本书可能就不会写出来了。在英国，极限星期二俱乐部自 1999 年以来一直在这些思想上进行创新，并吸引了一群开发者。我们很幸运能与这个团体的许多才华横溢的成员共事并从中学习。如果你有问题，如果没有其他人能帮助你，如果你能找到他们，也许你可以雇佣他们。

## 邓肯的部分

我不认为我的妻子会理解我以何为生，也没有机会让她读完这本书，但她可能会读到这里。所以感谢你，乔·麦格雷戈（Jo McGregor），容忍我写作而不是陪伴你，并且在我与你共度时光时谈论写作。没有你的支持和鼓励，我无法完成这本书。同时也要感谢我们的两个出色儿子，卡勒姆（Callum）和阿利斯泰尔（Alistair），你们让我们感到无比骄傲。

感谢维基·肯尼什（Vickie Kennish）在我们的 COVID 封锁期间对成为作家母亲的事情极为关注，并在我们的散步中检查进展。我已故的父亲约翰（John）肯定会更随意一些，但肯定会向他的朋友们吹嘘这本书。同样已去但未被遗忘的是我们美丽的猫咪 Sweet Pea，它在大部分写作过程中陪伴着我，但在完成前不久去世了。

罗宾·赫利韦尔（Robin Helliwell）的友谊和支持是我成年后生活中的一贯支持。同样，还有我的姐姐露西·希尔（Lucy Seal）以及许多其他无法逐一列出的家庭成员。在我的职业生涯中，除了那些提供反馈的人，还要感谢艾伦·戴克（Alan Dyke）、理查德·凯尔（Richard Care）和加雷斯·西尔维斯特·布拉德利（Gareth Sylvester-Bradley），他们的支持和帮助远远超出了职责范围。

## Nat 的部分

当我告诉我的妻子拉曼（Lamaan）我打算再写一本书时，她的第一反应并不是恐惧。为此，以及她始终不断的鼓励，我要多谢她。

向我姐姐罗伊斯·普赖斯（Lois Pryce）和姐夫奥斯汀·文斯（Austin Vince）致敬，他们的摩托车之旅、书籍和电影激发了本书中使用的陆地旅行规划应用程序的示例代码。

最后感谢奥利弗（Oliver）和亚历克斯（Alex）。现在书已经完成，我再次可以为音乐和游戏编程提供咨询服务了。
