# 第十九章：抛出到返回

> Java 使用已检查和未检查的异常来表示和处理错误。Kotlin 支持异常，但并不像 Java 那样在语言中内置已检查的异常。为什么 Kotlin 拒绝了 Java 的方法，我们应该使用什么代替呢？

您不需要长时间为计算机编写程序才会发现事情会出错…

…以 *如此多* 的方式。

在他们的职业生涯早期，您的作者倾向于忽略错误。至少在项目早期，我们经常仍然这样做。但随着系统的增长，我们学会了故障如何影响应用程序，并开始添加处理代码——起初是零散的，后来是根据经验制定的某种策略。在这方面，我们的错误处理与我们软件设计的其他方面一样发展。有时我们从一开始就设计，利用我们对类似系统的经验；其他时候，我们允许软件编写教导我们它需要什么。

在没有更明确的策略的情况下，大多数系统默认在出现问题时引发异常，并在某个外部级别捕获和记录这些异常。在这种情况下，命令行实用程序将只是退出，希望提供足够的信息给用户以纠正问题并重试。服务器应用程序或具有事件循环的 GUI 通常只会中止当前交互并继续下一个。

通常这只是对我们用户的不良体验，但有时错误会损坏系统的持久状态，因此更正初始问题并重试是无效的。这是“关闭并重新启动”的明智建议的源头。我们的系统主要在安全状态下启动，因此重新启动后重试应该成功。如果不行，嗯，您可能曾经处于重新安装操作系统的情况——这是删除受损持久状态的终极方法。

如果错误没有得到很好的管理，但尽管如此系统变得成功，由于错误导致的损坏的诊断和修复可能会占用整个团队的所有时间。这对于软件项目来说并不是一个好的位置。问我们是怎么知道的！

因此，我们不希望出现错误，因为它们会让我们的用户感到烦恼，并且可能导致需要花费大量精力才能修复的损坏，如果我们可以修复的话。我们看到了什么样的错误呢？

程序出错的原因有很多。当我们说 *程序* 时，我们也指的是函数、方法、过程——我们调用的任何代码。当我们说 *出错* 时，我们指的是未能完成我们期望它们完成的工作。

导致此故障的原因包括：

+   有时程序需要与其他系统通信，但通信在某种程度上失败了。

+   我们经常没有为软件提供执行其工作所需的正确输入。

+   显然，一些程序员会犯错误：甚至会指示他们的计算机取消引用空引用或读取超出集合末尾的内容！

+   我们运行的环境由于某种原因而失败；例如，它可能耗尽内存或无法加载类。

有些失败情况不属于这些类别，但大多数情况下是适用的。

这似乎不是一个太长的列表，然而作为一个行业，我们在可靠性方面并不享有很好的声誉。错误处理似乎很难。为什么呢？

首先，我们经常不知道操作是否会失败，以及如果失败的话会是怎样的失败。如果我们知道，那么处理错误的知识可能在离问题检测点很远的代码中。然后检测错误的代码和从错误中恢复的代码很难与正常路径分离，因此很难测试。再加上错误可能使我们的系统陷入无法恢复的状态，我们最终面临的情况是，大多数开发者宁愿抱有乐观期望，而不愿承担艰苦的工作并且最终还是会出错。

艰苦的工作 *和* 容易出错？计算机不是应该解放我们，从事这些苦活使我们能专注于有趣的创造性工作吗？是的，它们确实应该，因此我们将通过编程语言如何使程序员的工作更安全更简单的角度来关注错误处理。

# 异常之前的错误处理

大多数错误处理如今都基于异常，但在某些情况下仍然可以使用其他技术。我们将首先看看这些技术的优缺点。缺点将告诉我们为什么异常现在占据主导地位；而优点则可能在异常不适用时为我们提供选择。

忽略错误

我们可以忽略错误。要么失败的例程不做任何事情来引起调用者的注意，要么调用者根本不去检查。

这可能导致持久数据的损坏和静默地未能完成任务，所以在大多数情况下，我们需要有更高的要求。

仅仅崩溃

一些程序在检测到错误时会直接退出。

结合错误重启的监控程序和仔细编码以防止持久状态的破坏，这是一种经过考验的战略，可能是适当的。抛出异常来中止操作是将这种技术应用于过程而不是整个程序的表现。

返回一个特殊值

返回一个特殊值来表示错误可以是一种有用的技术。例如，当在列表中找不到项时，函数可以返回`-1`而不是索引。

当所有返回值都是函数的有效结果时，此技术无法使用。它也可能很危险，因为调用者必须了解（并记住）约定。如果我们尝试通过减去它们的索引来计算列表中两个项之间的距离，当其中一个找不到并返回`-1`时，除非我们明确处理特殊情况，否则我们的计算将是错误的。我们不能依赖类型检查器来帮助我们避免错误。

在发生错误时返回特殊值的一个特殊情况是返回 null。在大多数语言中，这样做非常危险，因为如果调用者没有显式检查 null，那么使用结果将抛出`NullPointerException`，这可能比初始问题更严重。不过，在 Kotlin 中，类型检查强制调用者处理 null，这使得这种技术是安全和有效的。

设置全局标志

返回特殊值的一个问题是很难表明发生了几种可能的错误之一。为了解决这个问题，我们可以将特殊值与设置全局变量结合起来。当检测到特殊值时，调用者可以读取`errno`，例如，以确定问题所在。

这种技术在 C 语言中很流行，但在很大程度上被基于异常的错误处理所取代。

返回状态码

另一种在异常出现之前的技术是返回状态码。当函数不返回值（完全是副作用）或以其他方式返回值，通常通过改变传递的引用参数时，可以使用这种技术。

调用特殊函数

当出现错误时调用特殊函数有时是一个好策略。通常，错误函数作为参数传递给被调用的函数。如果检测到问题，则调用错误函数，并将表示错误的值作为参数传递。有时，错误函数可以通过其返回值来表示失败的操作是否应重试或中止。另一种技术是让错误函数提供应由被调用函数返回的值。

这种技术是错误处理中应用策略模式的一个例子。即使异常可用，它在特定情况下也是一个有用的工具。

# 异常处理与异常

所有这些技术都存在一个缺点，即调用代码能够在更大或更小程度上忽略错误的发生。

异常解决了这个问题。在错误发生时，操作会自动中止，并且调用者显式处理异常。如果调用者没有处理它，异常将继续传播到调用栈的更深层，直到有地方处理它；如果没有处理异常，线程将终止。

# Java 和 Checked Exceptions

当 Java 发布时，异常相对较新，语言设计者决定在这一领域进行创新。他们使方法可能引发的异常成为其签名的一部分。这样，调用者可以知道，例如，一个方法可能因为它正在读取的网络资源不再可用而失败。如果一个方法声明它可能以这种方式失败，那么调用该方法的每个调用者都必须处理该失败（通过指定在`catch`块中如何处理）或声明它也可能因相同的异常而失败。这确保了程序员考虑到这些错误的可能性。这些异常称为*检查异常*，因为编译器检查它们是否已处理（或重新声明为调用方法抛出）。

检查异常设计用于当程序员可能合理地找到一种恢复方法时：例如重试数据库写入或重新打开套接字。语言设计者确定了另外两种类型：错误和运行时异常。

错误

`java.lang.Error`的子类专门用于严重到 JVM 无法保证运行时正确功能的故障。可能是无法加载类，或者系统内存耗尽。这些情况可能发生在程序执行的任何时刻，因此可能导致任何函数执行失败。由于任何方法都可能以这种方式失败，所以在每个方法签名中包含它们是没有价值的，因此不需要声明`Error`。

运行时异常

`RuntimeException`的子类代表其他错误。其意图是这些错误应该保留给程序员错误造成的问题，例如访问空引用或尝试读取集合的边界外。在这两种情况下，程序员本可以更加谨慎。尽管如此，每一行代码都可能存在程序员错误，因此`RuntimeExceptions`也免除了必须声明的义务。

这种方案迫使开发人员处理可能因 I/O 错误或其他超出其控制范围的事物（检查异常）而失败的操作，允许经济有效的防御性编程。在另一极端，如果抛出`Error`，最好的默认方法是尽快退出进程，以免对持久状态造成更多损害。

`RuntimeException`是一个折中的情况。如果它们代表了程序员的错误，我们可能应该假设我们刚刚证明了我们并不真正知道我们的程序正在做什么，并中止当前操作或整个应用程序。否则，我们可能会尝试恢复，特别是如果我们的系统已被设计为限制对持久状态可能造成的损害。

你的作者们确实非常喜欢检查异常，但似乎他们是少数派，因为多年来 Java 中的检查异常已经不受欢迎。从一开始，检查异常就受到奇怪的决定的影响，使得未检查的`RuntimeException`成为否定其他检查异常的`Exception`的子类，因此那些想要处理所有检查异常的代码发现自己也在捕获未检查的异常，隐藏了编程错误。它们也没有因为 Java API 的不一致而得到帮助。以从字符串中提取数据为例：`URL`构造函数`URL(String)`抛出*检查*的`MalformedURLException`，而`Integer.parseInt(String)`抛出*未检查*的`NumberFormatException`。

混淆对于使用哪种类型的异常的困惑加剧了，不久之后，大多数 Java 库声明的唯一检查异常都是`IOExceptions`。即使是数据库库如 Hibernate，明确在网络上传输并且明确会遭遇`IOExceptions`的情况下，也只会抛出`RuntimeExceptions`。

一旦你的代码中有相当一部分使用了未检查异常，情况就不妙了。无法依赖于检查异常来警示你函数可能失败的方式。相反，你只能采取一些战术性的防御编程和老旧技术，将其投入生产，查看日志中记录的错误，并添加代码来处理那些看起来不太合适的情况。

Java 8 引入 lambda 函数是检查异常的最后一击。决定在支持 lambda 的函数式接口的签名中不声明异常类型，因此这些异常无法传播。这并非是无法克服的问题，但公正地说，你的作者们也可能在这里放弃。然而，结果是，旧的标准 Java API 声明了检查异常（特别是`IOException`），而新的标准 API（特别是 streams）迫使开发者否认它们。

# Kotlin 与异常

Kotlin 支持异常，因为它运行在 JVM 上，并且异常是平台内置的。尽管如此，Kotlin 并没有特别处理检查异常，因为 Java 在这方面已经败北了，并且与 Java 一样，它们难以与高阶函数协调。Kotlin 能够大部分忽略检查异常，因为它们不是 JVM 的特性，而是 Java 编译器的特性。编译器确实在字节码中记录了方法声明的检查异常（以便进行检查），但 JVM 本身并不关心。

结果是，当涉及错误处理时，默认情况下，Kotlin 程序与大多数 Java 程序一样既不好也不坏。

这个例外是，正如我们早些时候观察到的那样，Kotlin 可以使用`null`来指示错误，因此调用者将不得不考虑到`null`的可能性。例如，在运行时中有`<T> Iterable<T>.firstOrNull(): T?`。不过，值得注意的是，运行时也定义了`first()`，如果集合为空则会抛出`NoSuchElementException`。

# 超越异常：函数式错误处理

静态类型的函数式编程语言通常不接受异常，而是倾向于另一种基于*Either Types*的错误处理技术。我们很快会看到 Either Type 是什么，但为什么函数式编程人员不喜欢异常呢？

函数式编程的一个显著特征是*引用透明性*。当一个表达式是引用透明的时候，我们可以安全地用其评估结果替换它。所以如果我们写下：

```java
val secondsIn24hours = 60 * 60 * 24
```

然后我们可以用`3600`替换`60 * 60`，或者用`1440`替换`60 * 24`而不影响结果。事实上，编译器可以决定为我们用`86400`替换整个表达式，而（除非我们检查字节码或使用调试器）我们不会知道这一点。

相比之下：

```java
secondsIn(today())
```

不是引用透明的，因为`today()`的结果与昨天不同，并且任何一天都可能增加一秒。因此，`secondsIn(today())`的值可能因调用时间不同而异，并且我们不能每次使用它时都用相同的值替换表达式。

这与我们在第七章中看到的概念相同。“Calculations”是引用透明的；“Actions”不是。

为什么我们应该关心呢？因为引用透明性大大简化了对程序行为的推理，这反过来会减少错误并提供更多重构和优化的机会。如果我们希望实现这些目标（至少我们不希望出现更多错误和减少机会），那么我们应该追求引用透明性。

这与错误处理有什么关系？让我们回到我们的`Integer.​par⁠seInt(String)`示例中来看看。对于给定的有效输入，`parseInt`将始终返回相同的值，因此它可以是引用透明的。然而，在`String`不表示整数的情况下，`parseInt`会抛出异常而不是返回结果。我们无法用异常替换函数调用的结果，因为表达式的类型是`Int`，而`Exception`不是`Int`。异常破坏了引用透明性。

如果我们不使用异常，而是回到使用特殊值来表示错误的旧技巧，我们将具有引用透明性，因为该错误值可以替换表达式。在 Kotlin 中，`null`在这里非常适合，因此我们可以定义`parseInt`返回`Int?`。但是如果我们需要知道第一个不是数字的字符是什么呢？我们可以通过异常传达这些信息，但不能在返回类型为`Int?`中。

我们能否找到一种方法，让我们的函数返回*要么*`Int`，要么它失败的方式？

如他们所说，答案就在问题中。我们定义了一个类型`Either`，它可以同时持有两种类型中的一种：

```java
sealed class Either<out L, out R>

data class Left<out L>(val l: L) : Either<L, Nothing>()

data class Right<out R>(val r: R) : Either<Nothing, R>()
```

在 Kotlin 中，密封类（第十八章）非常适合这种情况，因为我们可以定义自己的子类型，但其他人无法访问。

当`Either`用于错误处理时，约定是`Right`用于结果，`Left`用于错误。如果我们遵循这个约定，我们可以定义：

```java
fun parseInt(s: String): Either<String, Int> = try {
    Right(Integer.parseInt(s))
} catch (exception: Exception) {
    Left(exception.message ?: "No message")
}
```

我们如何使用这个？正如我们在第十八章中看到的，`when`表达式和智能转换非常适合让我们编写如下代码：

```java
val result: Either<String, Int> = parseInt(readLine() ?: "")
when (result) {
    is Right -> println("Your number was ${result.r}")
    is Left -> println("I couldn't read your number because ${result.l}")
}
```

通过返回`Either`，我们强制客户端处理可能失败的情况。这在功能形式上具有一些检查异常的优势。为了采纳这种风格，我们使得所有在 Java 中声明会抛出检查异常的函数返回`Either`。调用者可以解开成功的部分并对其进行操作，或者传递任何失败：

```java
fun doubleString(s: String): Either<String, Int> {
    val result: Either<String, Int> = parseInt(s)
    return when (result) {
        is Right -> Right(2 * result.r)
        is Left -> result
    }
}
```

尽管使用`when`来解开`Either`是合乎逻辑的，但也很冗长。这种模式经常出现，因此我们定义`map`如下：

```java
inline fun <L, R1, R2> Either<L, R1>.map(f: (R1) -> R2): Either<L, R2> =
    when (this) {
        is Right -> Right(f(this.r))
        is Left -> this
    }
```

这使我们可以将前面的函数写成：

```java
fun doubleString(s: String): Either<String, Int> = parseInt(s).map { 2 * it }
```

为什么那个函数叫做`map`而不是`invokeUnlessLeft`？嗯，如果你眯起眼睛，你可能能看出它和`List.map`有些相似。它将一个函数应用于容器的内容，并将结果放入另一个容器中。对于`Either`来说，`map`仅在是`Right`（非错误）时应用该函数；否则，它保持不变传递`Left`。

练习那种眯眼看的技能，因为我们现在要定义：

```java
inline fun <L, R1, R2> Either<L, R1>.flatMap(
    f: (R1) -> Either<L, R2>
): Either<L, R2> =
    when (this) {
        is Right -> f(this.r)
        is Left -> this
    }
```

这将解开我们的值并使用它来调用一个可能失败的函数（因为它返回`Either`）。我们能对此做些什么呢？好吧，假设我们想要从`Reader`中读取并打印结果的两倍。我们可以定义一个`readLine`的包装器，它返回`Either`而不是用异常失败：

```java
fun BufferedReader.eitherReadLine(): Either<String, String> =
    try {
        val line = this.readLine()
        if (line == null)
            Left("No more lines")
        else
            Right(line)
    } catch (x: IOException) {
        Left(x.message ?: "No message")
    }
```

这允许我们使用`flatMap`将`eitherReadLine`和`doubleString`组合起来：

```java
fun doubleNextLine(reader: BufferedReader): Either<String, Int> =
    reader.eitherReadLine().flatMap { doubleString(it) }
```

如果`eitherReadLine`失败，此代码将返回一个带有失败的`Left`；否则，它将返回`doubleString`的结果，该结果本身可能是一个带有最终`Int`结果的`Left`或`Right`。通过这种方式，一系列`map`和/或`flatMap`调用就像一系列表达式，可能会抛出异常；第一个失败会中止其余的计算。

如果你来自面向对象的背景，这种风格确实需要一些时间来适应。根据我们的经验，再多的阅读也不会有帮助；你只需认真开始以这种方式编写代码，直到它变得不那么陌生。我们将通过在后续的示例中与你合作来分享你的痛苦。

# Kotlin 中的错误处理

现在我们知道了开放给我们的错误处理选项，我们在 Kotlin 项目中应该使用哪种，以及如何迁移我们的 Java 代码？

像往常一样，这要看情况而定。

使用可空类型来表示失败非常有效，前提是你不需要传达失败原因的任何信息。

使用异常作为默认策略不会导致你被解雇。然而，缺乏类型检查使得很难明确哪些代码会失败，这反过来使得构建可靠系统变得困难。更加让人难堪的是，你将失去参考透明性的好处，这样一来，重构和修复不可靠系统就更加困难了。

我们更倾向于从那些在 Java 中会抛出已检查异常的操作中返回`Either`类型，无论是因为 I/O 问题，还是像`parseInt`一样，它们无法为所有输入提供结果。这使我们可以将异常保留给更为恶劣的问题。对于不可恢复的程序错误，仍然适用`Errors`：在这种情况下，我们应设计我们的系统，使得程序退出并由其他进程重新启动。`RuntimeExceptions`在我们作为程序员犯错误时仍然是很好的信号：例如`IndexOutOfBounds`等情况。如果我们精心设计了我们的系统，它应该能够处理这些问题并处理不会遇到同样问题的其他输入。

你应该选择哪种`Either`类型？在撰写本文时，内置的 Kotlin `Result`类型是一个令人沮丧的占位符，它只是一种挑逗并且会妨碍进展。它专为协程设计，受限于`Exception`（实际上是`Throwable`）作为其错误值，并且如果你将其用作属性类型，IntelliJ 会抱怨。如果它没有发布在`kotlin`包中，这就合理了。然而，它确实发布在那里，所以如果你尝试使用一个更有用的名为`Result`的类型，你会得到奇怪的错误消息，直到你记住编译器假设`Result`指的是你不应该使用的`kotlin.Result`类型。

还有许多其他的结果类型可用，但是在本书中我们将使用 [Result4k](https://oreil.ly/F5Y4M)，这不是巧合，它是由 Nat 编写的。与我们之前介绍的通用 `Either` 类型相比，Result4k 定义了 `Result<SuccessType, FailureType>`，具有子类型 `Success` 和 `Failure`，而不是 `Left` 和 `Right`。由于它专门用于表示错误，Result4k 通过将成功类型作为泛型参数的第一个来反转 `Either` 惯例。它还可以提供诸如 `onFailure` 和 `recover` 等操作，在 `Either` 上是不合理的。在重构时，我们将看到其中的一些操作。

# 将异常重构为错误

现在我们知道了可用的错误处理选项，让我们重构一些 Java 代码到 Kotlin，逐步转换错误处理。

Travelator 中有一个 HTTP 端点，允许客户端应用注册一个 `Customer`：

```java
public class CustomerRegistrationHandler {

    private final IRegisterCustomers registration;
    private final ObjectMapper objectMapper = new ObjectMapper();

    public CustomerRegistrationHandler(IRegisterCustomers registration) {
        this.registration = registration;
    }

    public Response handle(Request request) {
        try {
            RegistrationData data = objectMapper.readValue(
                request.getBody(),
                RegistrationData.class
            );
            Customer customer = registration.register(data);
            return new Response(HTTP_CREATED,
                objectMapper.writeValueAsString(customer)
            );
        } catch (JsonProcessingException x) {
            return new Response(HTTP_BAD_REQUEST);
        } catch (ExcludedException x) {
            return new Response(HTTP_FORBIDDEN);
        } catch (DuplicateException x) {
            return new Response(HTTP_CONFLICT);
        } catch (Exception x) {
            return new Response(HTTP_INTERNAL_ERROR);
        }
    }
}
```

[示例 19.1 [errors.0:src/main/java/travelator/handlers/CustomerRegistrationHandler.java]](https://java-to-kotlin.dev/code.html?ref=19.1&show=file) [(diff)](https://java-to-kotlin.dev/code.html?ref=19.1&show=diff)

`CustomerRegistrationHandler` 的工作是从请求体中提取数据，将其传递给 `registration` 进行处理，并返回一个 JSON 表示的 `Customer` 或适当的错误状态码响应。

`CustomerRegistration` 实现了业务规则，即潜在客户应该经过 `ExclusionList` 的审核。我们不希望允许已知的不良分子注册并滥用我们的服务，因此我们在这一点上拒绝他们：

```java
public class CustomerRegistration implements IRegisterCustomers {

    private final ExclusionList exclusionList;
    private final Customers customers;

    public CustomerRegistration(
        Customers customers,
        ExclusionList exclusionList
    ) {
        this.exclusionList = exclusionList;
        this.customers = customers;
    }

    public Customer register(RegistrationData data)
        throws ExcludedException, DuplicateException {
        if (exclusionList.exclude(data)) {
            throw new ExcludedException();
        } else {
            return customers.add(data.name, data.email);
        }
    }
}
```

[示例 19.2 [errors.0:src/main/java/travelator/CustomerRegistration.java]](https://java-to-kotlin.dev/code.html?ref=19.2&show=file) [(diff)](https://java-to-kotlin.dev/code.html?ref=19.2&show=diff)

查看 `register` 方法的 `throws` 子句。它告诉我们，这个方法可能因为明确的排除而失败，但也可能因为 `customers.add` 导致 `DuplicateException` 失败。这是 `Customers` 接口：

```java
public interface Customers {

    Customer add(String name, String email) throws DuplicateException;

    Optional<Customer> find(String id);
}
```

[示例 19.3 [errors.0:src/main/java/travelator/Customers.java]](https://java-to-kotlin.dev/code.html?ref=19.3&show=file) [(diff)](https://java-to-kotlin.dev/code.html?ref=19.3&show=diff)

最后，`Customer` 是另一个值类型。在这里它转换为 Kotlin 后的样子：

```java
data class Customer(
    val id: String,
    val name: String,
    val email: String
)
```

[示例 19.4 [errors.1:src/main/java/travelator/Customer.kt]](https://java-to-kotlin.dev/code.html?ref=19.4&show=file) [(diff)](https://java-to-kotlin.dev/code.html?ref=19.4&show=diff)

这是你们作者的典型 Java 风格。它表达了可能发生的事情，如检查的 `ExcludedException` 和 `DuplicateException`，这些都在 `handle` 的顶层捕获，然后作为 HTTP 状态码报告给调用者。你的风格可能是使用未检查的异常，在这种情况下，这段代码的写法会类似，但方法签名中不包括异常。

我们看不到与将`Customer`持久化到`Customers::add`失败相关的任何检查异常。这个方法将通过网络与数据库通信，但显然我们的查询代码在某个点上吞掉了`IOException`并替换为`RuntimeException`。这些异常将传播到`Customer​Regis⁠tration::register`的顶层，被`CustomerRegistrationHandler`捕获，并作为`HTTP_INTERNAL_ERROR`（500）传递回客户端。很遗憾我们没有记录关于这些零散`RuntimeException`的任何信息，因为它们可能揭示系统性连接问题或者在一些低级代码中隐藏着频繁的`NullPointer​Excep⁠tion`。在此期间，有人应该解决这个问题，但与此同时，至少我们在本书中展示了一个较短的示例。

## 我们的转换策略

如果我们仅将此代码转换为 Kotlin，我们将失去检查异常提供的优势，无法告诉我们可能出现什么问题以及我们在哪里处理了这些问题。因此，在转换过程中，我们将使用 Result4k 替换基于异常的错误处理功能性替代方案。

在这个例子中，我们将从最底层开始，逐步向上工作，保持更高级别的工作，直到那些当前表达为检查异常的可预测错误案例不再使用异常。与此同时，我们必须注意，JVM 中几乎任何指令都可能失败，因此我们需要防范这些运行时问题。

## 从底层开始

如果我们将`Customers`转换为 Kotlin，我们得到：

```java
interface Customers {

    @Throws(DuplicateException::class) ![1](img/1.png)
    fun add(name: String, email: String): Customer

    fun find(id: String): Optional<Customer>
}
```

[示例 19.5 [errors.3:src/main/java/travelator/Customers.kt]](https://java-to-kotlin.dev/code.html?ref=19.5&show=file) [(差异)](https://java-to-kotlin.dev/code.html?ref=19.5&show=diff)

![1](img/#co_introduction_CO42-1)

虽然 Kotlin 没有检查异常，但`@Throws`注解允许通过将异常添加到方法的字节码签名中与 Java 代码进行互操作。如果没有它，一个 Java 实现的`Customers`如果抛出`DuplicateException`将无法实现该方法。更糟的是，调用接口上的方法的 Java 代码将无法捕获异常或声明它被传递，因为 Java 代码处理编译器无法看到的检查异常将是一个编译错误。

我们的策略是在接口中添加`Customers::add`的一个版本，该版本不会抛出异常，而是返回`Result<Customer, DuplicateException>`。如果我们从头开始，我们不会将`DuplicateException`作为错误类型使用，但在这里它让我们可以轻松地与 Java 进行交互。目前我们会保留当前的抛出版本，以免破坏现有的调用者。然后，当我们可以时，我们将转换这些调用者以使用`Result`版本，然后删除旧版本。没错，这是我们的老朋友“扩展和收缩重构”。

我们应该如何称呼像`Customers::add`但返回`Result`的方法？我们不能再命名为`add`，因为两者具有相同的参数，所以暂时称其为`addToo`。如果新方法委托给`add`，我们可以将其作为默认方法，以便所有实现都可以使用：

```java
interface Customers {

    @Throws(DuplicateException::class)
    fun add(name: String, email: String): Customer

    fun addToo(name:String, email:String)
        : Result<Customer, DuplicateException> =
        try {
            Success(add(name, email))
        } catch (x: DuplicateException) {
            Failure(x)
        }

    fun find(id: String): Optional<Customer>
}
```

[示例 19.6 [errors.5:src/main/java/travelator/Customers.kt]](https://java-to-kotlin.dev/code.html?ref=19.6&show=file) [(差异)](https://java-to-kotlin.dev/code.html?ref=19.6&show=diff)

现在我们既有异常版本又有结果版本的方法，我们可以迁移调用异常版本的调用者。虽然我们可以从 Java 中使用 Result4k，但从 Kotlin 更加方便。因此，让我们来看看`CustomerRegistration`（调用`add`的地方）：

```java
public class CustomerRegistration implements IRegisterCustomers {

    private final ExclusionList exclusionList;
    private final Customers customers;

    public CustomerRegistration(
        Customers customers,
        ExclusionList exclusionList
    ) {
        this.exclusionList = exclusionList;
        this.customers = customers;
    }

    public Customer register(RegistrationData data)
        throws ExcludedException, DuplicateException {
        if (exclusionList.exclude(data)) {
            throw new ExcludedException();
        } else {
            return customers.add(data.name, data.email);
        }
    }
}
```

[示例 19.7 [errors.5:src/main/java/travelator/CustomerRegistration.java]](https://java-to-kotlin.dev/code.html?ref=19.7&show=file) [(差异)](https://java-to-kotlin.dev/code.html?ref=19.7&show=diff)

将其转换为 Kotlin 如下：

```java
class CustomerRegistration(
    private val customers: Customers,
    private val exclusionList: ExclusionList
) : IRegisterCustomers {

    @Throws(ExcludedException::class, DuplicateException::class)
    override fun register(data: RegistrationData): Customer {
        return if (exclusionList.exclude(data)) {
            throw ExcludedException()
        } else {
            customers.add(data.name, data.email)
        }
    }

}
```

[示例 19.8 [errors.6:src/main/java/travelator/CustomerRegistration.kt]](https://java-to-kotlin.dev/code.html?ref=19.8&show=file) [(差异)](https://java-to-kotlin.dev/code.html?ref=19.8&show=diff)

那个`customers.add`表达式就是可能抛出`DuplicateException`的表达式。我们将其替换为调用`addToo`，但保持行为不变。因此，我们将`result`作为局部变量提取出来：

```java
@Throws(ExcludedException::class, DuplicateException::class)
override fun register(data: RegistrationData): Customer {
    return if (exclusionList.exclude(data)) {
        throw ExcludedException()
    } else {
        val result = customers.add(data.name, data.email)
        result
    }
}
```

[示例 19.9 [errors.7:src/main/java/travelator/CustomerRegistration.kt]](https://java-to-kotlin.dev/code.html?ref=19.9&show=file) [(差异)](https://java-to-kotlin.dev/code.html?ref=19.9&show=diff)

如果我们现在调用`addToo`而不是`add`，它将不再抛出异常，但异常将在`Result`中返回。但这暂时无法编译：

```java
@Throws(ExcludedException::class, DuplicateException::class)
override fun register(data: RegistrationData): Customer {
    return if (exclusionList.exclude(data)) {
        throw ExcludedException()
    } else {
        val result: Result<Customer, DuplicateException> =
            customers.addToo(data.name, data.email)
        result ![1](img/1.png)
    }
}
```

[示例 19.10 [errors.8:src/main/java/travelator/CustomerRegistration.kt]](https://java-to-kotlin.dev/code.html?ref=19.10&show=file) [(差异)](https://java-to-kotlin.dev/code.html?ref=19.10&show=diff)

![1](img/#co_introduction_CO43-1)

`类型不匹配。要求：Customer 实际：Result<Customer,` `Duplicate​Excep⁠tion>`

我们有一个`Result`，所以我们需要解开它。当它是`Success`时，我们希望返回包装的值；当是`Failure`时，抛出包装的`DuplicateException`（以保持`register`的当前行为）：

```java
@Throws(ExcludedException::class, DuplicateException::class)
override fun register(data: RegistrationData): Customer {
    return if (exclusionList.exclude(data)) {
        throw ExcludedException()
    } else {
        val result: Result<Customer, DuplicateException> =
            customers.addToo(data.name, data.email)
        when (result) {
            is Success<Customer> ->
                result.value
            is Failure<DuplicateException> ->
                throw result.reason
        }
    }
}
```

[示例 19.11 [errors.9:src/main/java/travelator/CustomerRegistration.kt]](https://java-to-kotlin.dev/code.html?ref=19.11&show=file) [(差异)](https://java-to-kotlin.dev/code.html?ref=19.11&show=diff)

恰巧的是，当错误类型是`Exception`时，Result4k 有一个函数来简化此情况：`Result::orThrow`：

```java
@Throws(ExcludedException::class, DuplicateException::class)
override fun register(data: RegistrationData): Customer {
    return if (exclusionList.exclude(data)) {
        throw ExcludedException()
    } else {
        val result: Result<Customer, DuplicateException> =
            customers.addToo(data.name, data.email)
        result.orThrow()
    }
}
```

[示例 19.12 [errors.10:src/main/java/travelator/CustomerRegistration.kt]](https://java-to-kotlin.dev/code.html?ref=19.12&show=file) [(差异)](https://java-to-kotlin.dev/code.html?ref=19.12&show=diff)

现在我们可以内联以回到更简洁的形式：

```java
@Throws(ExcludedException::class, DuplicateException::class)
override fun register(data: RegistrationData): Customer {
    return if (exclusionList.exclude(data)) {
        throw ExcludedException()
    } else {
        customers.addToo(data.name, data.email).orThrow()
    }
}
```

[示例 19.13 [errors.11:src/main/java/travelator/CustomerRegistration.kt]](https://java-to-kotlin.dev/code.html?ref=19.13&show=file) [(diff)](https://java-to-kotlin.dev/code.html?ref=19.13&show=diff)

最后，嵌套过多让人感到困惑，所以让我们通过使用“用‘when’替换‘if’”、“用‘when’表达式替换 return”和“从所有‘when’条目中删除大括号”来简化它。Alt-Enter 一切！

```java
@Throws(ExcludedException::class, DuplicateException::class)
override fun register(data: RegistrationData): Customer {
    when {
        exclusionList.exclude(data) -> throw ExcludedException()
        else -> return customers.addToo(data.name, data.email).orThrow()
    }
}
```

[示例 19.14 [errors.12:src/main/java/travelator/CustomerRegistration.kt]](https://java-to-kotlin.dev/code.html?ref=19.14&show=file) [(diff)](https://java-to-kotlin.dev/code.html?ref=19.14&show=diff)

卓越的。我们用结果类型替换了异常的一种用法；让我们稍作休息。

## 合同

准备好再开始了吗？好的。

我们现在必须选择是深度优先还是广度优先。深度优先会解决`CustomerRegistration::register`的调用者；广度优先会先修复`Customers::add`的其他调用者，以便我们可以删除它。恰好，我们的示例代码没有`add`的其他调用者，所以广度优先不是一个选项，我们可以继续扩展和收缩的合同阶段。

我们目前有两个`Customers::add`的实现。一个是与数据库交互的生产实现，另一个是测试实现。我们的代码现在通过我们添加到接口的`Customers::addToo`的默认实现来调用它们。我们想要删除`add`实现，因此我们需要直接实现`addToo`。让我们看一下（不是线程安全的）测试版本：

```java
public class InMemoryCustomers implements Customers {

    private final List<Customer> list = new ArrayList<>();
    private int id = 0;

    @Override
    public Customer add(String name, String email) throws DuplicateException {
        if (list.stream().anyMatch( item -> item.getEmail().equals(email)))
            throw new DuplicateException(
                "customer with email " + email + " already exists"
            );
        int newId = id++;
        Customer result = new Customer(Integer.toString(newId), name, email);
        list.add(result);
        return result;
    }

    @Override
    public Optional<Customer> find(String id) {
        return list.stream()
            .filter(customer -> customer.getId().equals(id))
            .findFirst();
    }

    // for test
    public void add(Customer customer) {
        list.add(customer);
    }

    public int size() {
        return list.size();
    }
}
```

[示例 19.15 [errors.12:src/test/java/travelator/InMemoryCustomers.java]](https://java-to-kotlin.dev/code.html?ref=19.15&show=file) [(diff)](https://java-to-kotlin.dev/code.html?ref=19.15&show=diff)

在这里实现`addToo`的最简单方法可能就是复制`add`并修复它，将我们抛出的地方返回`Failure`，将快乐路径返回`Success`：

```java
@SuppressWarnings("unchecked")
@Override
public Result<Customer, DuplicateException> addToo(
    String name, String email
) {
    if (list.stream().anyMatch( item -> item.getEmail().equals(email)))
        return new Failure<>(
            new DuplicateException(
                "customer with email " + email + " already exists"
            )
        );
    int newId = id++;
    Customer result = new Customer(Integer.toString(newId), name, email);
    list.add(result);
    return new Success<Customer>(result);
}
```

[示例 19.16 [errors.13:src/test/java/travelator/InMemoryCustomers.java]](https://java-to-kotlin.dev/code.html?ref=19.16&show=file) [(diff)](https://java-to-kotlin.dev/code.html?ref=19.16&show=diff)

我们也可以使用这种策略将`addToo`添加到`Customers`的生产实现中；我们将跳过细节。完成后，我们可以从实现和接口中删除未使用的`add`，然后将`addToo`重命名为`add`，留下： 

```java
interface Customers {

    fun add(name:String, email:String): Result<Customer, DuplicateException>

    fun find(id: String): Optional<Customer>
}
```

[示例 19.17 [errors.14:src/main/java/travelator/Customers.kt]](https://java-to-kotlin.dev/code.html?ref=19.17&show=file) [(diff)](https://java-to-kotlin.dev/code.html?ref=19.17&show=diff)

`Customers`的客户现在又开始调用`add`，尽管是返回`Result`的版本，而不是声明受检异常：

```java
class CustomerRegistration(
    private val customers: Customers,
    private val exclusionList: ExclusionList
) : IRegisterCustomers {

    @Throws(ExcludedException::class, DuplicateException::class)
    override fun register(data: RegistrationData): Customer {
        when {
            exclusionList.exclude(data) -> throw ExcludedException()
            else -> return customers.add(data.name, data.email).orThrow()
        }
    }
}
```

[示例 19.18 [errors.14:src/main/java/travelator/CustomerRegistration.kt]](https://java-to-kotlin.dev/code.html?ref=19.18&show=file) [(diff)](https://java-to-kotlin.dev/code.html?ref=19.18&show=diff)

我们将 `InMemoryCustomers` 保留为 Java 仅仅是为了演示我们可以从旧代码返回 `Result4k` 类型，但我们无法抵制转换，因为现在代码有许多类型为 `Not annotated [X] overrides @NotNull [X]` 的警告。

转换后，包括从流操作到 Kotlin 集合操作的移动（第十三章），我们有：

```java
class InMemoryCustomers : Customers {

    private val list: MutableList<Customer> = ArrayList()
    private var id = 0

    override fun add(name: String, email: String)
        : Result<Customer, DuplicateException> =
        when {
            list.any { it.email == email } -> Failure(
                DuplicateException(
                    "customer with email $email already exists"
                )
            )
            else -> {
                val result = Customer(id++.toString(), name, email)
                list.add(result)
                Success(result)
            }
        }

    override fun find(id: String): Optional<Customer> =
        list.firstOrNull { it.id == id }.toOptional()

    // for test
    fun add(customer: Customer) {
        list.add(customer)
    }

    fun size(): Int = list.size
}
```

[示例 19.19 [errors.15:src/test/java/travelator/InMemoryCustomers.kt]](https://java-to-kotlin.dev/code.html?ref=19.19&show=file) [(diff)](https://java-to-kotlin.dev/code.html?ref=19.19&show=diff)

让我们回顾一下我们现在的状态。`Customers` 现在是 Kotlin，`add` 返回 `Result` 而不是抛出 `DuplicateException`：

```java
interface Customers {

    fun add(name:String, email:String): Result<Customer, DuplicateException>

    fun find(id: String): Optional<Customer>
}
```

[示例 19.20 [errors.15:src/main/java/travelator/Customers.kt]](https://java-to-kotlin.dev/code.html?ref=19.20&show=file) [(diff)](https://java-to-kotlin.dev/code.html?ref=19.20&show=diff)

`IRegisterCustomers` 仍然是 Java，并且仍然会抛出两种类型的异常：

```java
public interface IRegisterCustomers {
    Customer register(RegistrationData data)
        throws ExcludedException, DuplicateException;
}
```

[示例 19.21 [errors.15:src/main/java/travelator/IRegisterCustomers.java]](https://java-to-kotlin.dev/code.html?ref=19.21&show=file) [(diff)](https://java-to-kotlin.dev/code.html?ref=19.21&show=diff)

`CustomerRegistration` 现在是 Kotlin，我们现在在 `Result.Error` 和 `DuplicateException` 之间进行 thunk 操作，使用 `orThrow`：

```java
class CustomerRegistration(
    private val customers: Customers,
    private val exclusionList: ExclusionList
) : IRegisterCustomers {

    @Throws(ExcludedException::class, DuplicateException::class)
    override fun register(data: RegistrationData): Customer {
        when {
            exclusionList.exclude(data) -> throw ExcludedException()
            else -> return customers.add(data.name, data.email).orThrow()
        }
    }
}
```

[示例 19.22 [errors.15:src/main/java/travelator/CustomerRegistration.kt]](https://java-to-kotlin.dev/code.html?ref=19.22&show=file) [(diff)](https://java-to-kotlin.dev/code.html?ref=19.22&show=diff)

我们已经将交互的整个层次转换为使用结果类型，并可以继续到下一个阶段。

## 走出去

如果我们要像处理 `Customers` 的 `IRegisterCustomers::register` 一样遵循相同的模式——提供异常抛出和错误返回之间的适配器的默认实现——我们将不得不解决一个函数可能由于两个原因失败的结果表达的问题。这是因为 `register` 目前声明同时抛出 `ExcludedException` 和 `DuplicateException` 检查异常。在代码中，我们希望得到类似 `Result<Customer, Either​<Exclu⁠dedException, DuplicateException>>` 的东西。

我们*可以*使用通用的 `Either` 类型，但这只能作为一种策略，这和 Java 不同，我们声明异常的顺序不重要，`Either<Exclu⁠ded​Excep⁠tion, DuplicateException>` 不同于 `Either<DuplicateException, ExcludedException>`。`Either` 最多只是令人困惑的东西，如果我们有超过两个异常，情况将变得更糟：`OneOf<ExcludedException, Duplicate​Ex⁠cep⁠tion, SomeOtherProblem>` 简直糟透了。

另一个选择是提升到这两个异常的共同超类，并将返回类型声明为 `Result<Customer, Exception>`。这不符合通信测试：我们无法查看签名并获取任何关于我们期望的错误类型的线索。

相反，我们在这里的最佳策略不是试图用现有类型来表达错误，而是映射到一个新类型。

由于“异常”和“错误”都是负载过重的术语，我们选择了`RegistrationProblem`，其子类型有`Excluded`（不携带额外信息，因此可以是一个`object`）和`Duplicate`（携带原始`DuplicateException`的任何消息）：

```java
sealed class RegistrationProblem

object Excluded : RegistrationProblem()

data class Duplicate(
    val message: String?
) : RegistrationProblem()
```

[示例 19.23 [errors.16:src/main/java/travelator/IRegisterCustomers.kt]](https://java-to-kotlin.dev/code.html?ref=19.23&show=file) [(diff)](https://java-to-kotlin.dev/code.html?ref=19.23&show=diff)

通过将`RegistrationProblem`定义为密封类，我们在编译时知道哪些子类可能存在，因此知道必须处理的错误，这非常类似于方法的检查异常签名。

当我们遵循先前的模式时，我们可以在接口中添加`registerToo`的默认实现，并使用返回`Result<Customer, RegistrationProblem>`：

```java
interface IRegisterCustomers {

    @Throws(ExcludedException::class, DuplicateException::class)
    fun register(data: RegistrationData): Customer

    fun registerToo(data: RegistrationData):
        Result<Customer, RegistrationProblem> =
        try {
            Success(register(data))
        } catch (x: ExcludedException) {
            Failure(Excluded)
        } catch (x: DuplicateException) {
            Failure(Duplicate(x.message))
        }
}
```

[示例 19.24 [errors.16:src/main/java/travelator/IRegisterCustomers.kt]](https://java-to-kotlin.dev/code.html?ref=19.24&show=file) [(diff)](https://java-to-kotlin.dev/code.html?ref=19.24&show=diff)

现在我们可以将`register`的调用者迁移到`registerToo`。我们将从`Customer​Regis⁠trationHandler`开始，首先将其转换为 Kotlin：

```java
class CustomerRegistrationHandler(
    private val registration: IRegisterCustomers
) {
    private val objectMapper = ObjectMapper()

    fun handle(request: Request): Response {
        return try {
            val data = objectMapper.readValue(
                request.body,
                RegistrationData::class.java
            )
            val customer = registration.register(data)
            Response(
                HTTP_CREATED,
                objectMapper.writeValueAsString(customer)
            )
        } catch (x: JsonProcessingException) {
            Response(HTTP_BAD_REQUEST)
        } catch (x: ExcludedException) {
            Response(HTTP_FORBIDDEN)
        } catch (x: DuplicateException) {
            Response(HTTP_CONFLICT)
        } catch (x: Exception) {
            Response(HTTP_INTERNAL_ERROR)
        }
    }
}
```

[示例 19.25 [errors.17:src/main/java/travelator/handlers/CustomerRegistrationHandler.kt]](https://java-to-kotlin.dev/code.html?ref=19.25&show=file) [(diff)](https://java-to-kotlin.dev/code.html?ref=19.25&show=diff)

现在，就像之前一样，我们转而调用新方法（`registerToo`）而不是旧方法（`register`），并使用`when`表达式解释返回类型：

```java
class CustomerRegistrationHandler(
    private val registration: IRegisterCustomers
) {
    private val objectMapper = ObjectMapper()

    fun handle(request: Request): Response {
        return try {
            val data = objectMapper.readValue(
                request.body,
                RegistrationData::class.java
            )
            val customerResult = registration.registerToo(data)
            when (customerResult) {
                is Success -> Response(
                    HTTP_CREATED,
                    objectMapper.writeValueAsString(customerResult.value)
                )
                is Failure -> customerResult.reason.toResponse()

            }
        } catch (x: JsonProcessingException) {
            Response(HTTP_BAD_REQUEST)
        } catch (x: ExcludedException) {
            Response(HTTP_FORBIDDEN)
        } catch (x: DuplicateException) {
            Response(HTTP_CONFLICT)
        } catch (x: Exception) {
            Response(HTTP_INTERNAL_ERROR)
        }
    }
}

private fun RegistrationProblem.toResponse() = when (this) {
    is Duplicate -> Response(HTTP_CONFLICT)
    is Excluded -> Response(HTTP_FORBIDDEN)
}
```

[示例 19.26 [errors.18:src/main/java/travelator/handlers/CustomerRegistrationHandler.kt]](https://java-to-kotlin.dev/code.html?ref=19.26&show=file) [(diff)](https://java-to-kotlin.dev/code.html?ref=19.26&show=diff)

最后，我们可以删除不必要的异常情况，并使用`map`和`recover`简化错误情况。`Result::recover`是一个 Result4k 的扩展函数，如果是`Success`则解包结果，否则返回映射失败的`reason`的结果：

```java
fun handle(request: Request): Response =
    try {
        val data = objectMapper.readValue(
            request.body,
            RegistrationData::class.java
        )
        registration.registerToo(data)
            .map { value ->
                Response(
                    HTTP_CREATED,
                    objectMapper.writeValueAsString(value)
                )
            }
            .recover { reason -> reason.toResponse() }
    } catch (x: JsonProcessingException) {
        Response(HTTP_BAD_REQUEST)
    } catch (x: Exception) {
        Response(HTTP_INTERNAL_ERROR)
    }
```

[示例 19.27 [errors.19:src/main/java/travelator/handlers/CustomerRegistrationHandler.kt]](https://java-to-kotlin.dev/code.html?ref=19.27&show=file) [(diff)](https://java-to-kotlin.dev/code.html?ref=19.27&show=diff)

请注意，这段代码仍然不是无异常的。首先，`ObjectMapper`仍然可以抛出`JSONProcessingException`。这是 Java（实际上大多数 Kotlin）API 的现实，但代码是安全的且表达清晰，因为抛出和捕获在同一个方法中。其次，我们仍然需要考虑可能从任何地方抛出的其他`RuntimeException`，例如`NullPointerException`等。这些异常可能已经跨越了函数边界并最终泄漏到这里，在这里的顶级全捕捉中返回`HTTP_INTERNAL_ERROR`。现实情况是，我们仍然可能会遇到*意外*的异常，但*预期的*失败情况现在由`Results`表示并在我们的代码中传达。

# 更多修复

现在我们可以承认，`RegistrationHandlerTests`在几步之前就已经出问题了。通常我们会立即修复它们，但那样会打断我们的解释。

问题在于这些测试是模拟测试，期望调用`IRegister.register`，但我们现在却调用了`registerToo`。例如：

```java
public class CustomerRegistrationHandlerTests {

    final IRegisterCustomers registration =
        mock(IRegisterCustomers.class);
    final CustomerRegistrationHandler handler =
        new CustomerRegistrationHandler(registration);

    final String fredBody = toJson(
        "{ 'name' : 'fred', 'email' : 'fred@bedrock.com' }"
    );
    final RegistrationData fredData =
        new RegistrationData("fred", "fred@bedrock.com");

    @Test
    public void returns_Created_with_body_on_success()
        throws DuplicateException, ExcludedException {
        when(registration.register(fredData))
            .thenReturn(
                new Customer("0", fredData.name, fredData.email)
            );

        String expectedBody = toJson(
            "{'id':'0','name':'fred','email':'fred@bedrock.com'}"
        );
        assertEquals(
            new Response(HTTP_CREATED, expectedBody),
            handler.handle(new Request(fredBody))
        );
    }

    @Test
    public void returns_Conflict_for_duplicate()
        throws DuplicateException, ExcludedException {

        when(registration.register(fredData))
            .thenThrow(
                new DuplicateException("deliberate")
            );

        assertEquals(
            new Response(HTTP_CONFLICT),
            handler.handle(new Request(fredBody))
        );
    }
    ...

    private String toJson(String jsonIsh) {
        return jsonIsh.replace('\'', '"');
    }
}
```

[示例 19.28 [errors.20:src/test/java/travelator/handlers/CustomerRegistrationHandlerTests.java]](https://java-to-kotlin.dev/code.html?ref=19.28&show=file) [(diff)](https://java-to-kotlin.dev/code.html?ref=19.28&show=diff)

为了修复测试，我们需要将调用`register`改为调用`registerToo`，后者返回`Result<Customer, RegistrationProblem>`或抛出异常：

```java
@Test
public void returns_Created_with_body_on_success() {

    when(registration.registerToo(fredData))
        .thenReturn(new Success<>(
            new Customer("0", fredData.name, fredData.email)
        ));

    String expectedBody = toJson(
        "{'id':'0','name':'fred','email':'fred@bedrock.com'}"
    );
    assertEquals(
        new Response(HTTP_CREATED, expectedBody),
        handler.handle(new Request(fredBody))
    );
}

@Test
public void returns_Conflict_for_duplicate() {

    when(registration.registerToo(fredData))
        .thenReturn(new Failure<>(
            new Duplicate("deliberate")
        ));

    assertEquals(
        new Response(HTTP_CONFLICT),
        handler.handle(new Request(fredBody))
    );
}
    ...
```

[示例 19.29 [errors.21:src/test/java/travelator/handlers/CustomerRegistrationHandlerTests.java]](https://java-to-kotlin.dev/code.html?ref=19.29&show=file) [(diff)](https://java-to-kotlin.dev/code.html?ref=19.29&show=diff)

现在我们的测试变得更简单了，因为我们不再需要选择`thenReturn`或`thenThrow`，而是总是使用`thenReturn`进行模拟，分别返回`Success`或`Failure`。

现在我们的测试再次通过了，我们可以返回到生产代码并直接实现`CustomerRegistration::registerToo`。如果没有更聪明的想法，我们可以通过复制`register`方法并调整错误处理来做到这一点。我们使用`Result::mapFailure`（Result4k 的一部分）将`DuplicateException`转换为`Duplicate`：

```java
class CustomerRegistration(
    private val customers: Customers,
    private val exclusionList: ExclusionList
) : IRegisterCustomers {

    @Throws(ExcludedException::class, DuplicateException::class)
    override fun register(data: RegistrationData): Customer {
        when {
            exclusionList.exclude(data) -> throw ExcludedException()
            else -> return customers.add(data.name, data.email).orThrow()
        }
    }

    override fun registerToo(
        data: RegistrationData
    ): Result<Customer, RegistrationProblem> {
        return when {
            exclusionList.exclude(data) -> Failure(Excluded)
            else -> customers.add(data.name, data.email)
                .mapFailure { exception: DuplicateException -> ![1](img/1.png)
                    Duplicate(exception.message)
                }
        }
    }
}
```

[示例 19.30 [errors.22:src/main/java/travelator/CustomerRegistration.kt]](https://java-to-kotlin.dev/code.html?ref=19.30&show=file) [(diff)](https://java-to-kotlin.dev/code.html?ref=19.30&show=diff)

![1](img/#co_introduction_CO44-1)

请注意，在`mapFailure`中我们显式指定了 lambda 参数的类型。正如我们后面将看到的，这样做可以在我们将`add`的返回类型更改为不同的失败类型时，强制我们更改处理方式。

这里有两个问题。首先，`registerToo`没有测试代码；其次，我们由于复制`register`来创建`registerToo`而导致重复逻辑。我们可以通过将`register`实现为`registerToo`的调用来解决这两个问题，这与我们在`Customers`中所做的相反：

```java
class CustomerRegistration(
    private val customers: Customers,
    private val exclusionList: ExclusionList
) : IRegisterCustomers {

    @Throws(ExcludedException::class, DuplicateException::class)
    override fun register(data: RegistrationData): Customer =
        registerToo(data).recover { error ->  ![1](img/1.png)
            when (error) {
                is Excluded -> throw ExcludedException()
                is Duplicate -> throw DuplicateException(error.message)
        }
    }

    override fun registerToo(
        data: RegistrationData
    ): Result<Customer, RegistrationProblem> {
        return when {
            exclusionList.exclude(data) -> Failure(Excluded)
            else -> customers.add(data.name, data.email)
                .mapFailure { exception: DuplicateException ->
                    Duplicate(exception.message)
                }
        }
    }
}
```

[示例 19.31 [errors.23:src/main/java/travelator/CustomerRegistration.kt]](https://java-to-kotlin.dev/code.html?ref=19.31&show=file) [(diff)](https://java-to-kotlin.dev/code.html?ref=19.31&show=diff)

![1](img/#co_introduction_CO45-1)

委托给`registerToo`并处理`Error`类型。

现在我们的`CustomerRegistrationTests`，工作于`register`的调用者，将为我们测试`registerToo`：

```java
public class CustomerRegistrationTests {

    InMemoryCustomers customers = new InMemoryCustomers();
    Set<String> excluded = Set.of(
        "cruella@hellhall.co.uk"
    );
    CustomerRegistration registration = new CustomerRegistration(customers,
        (registrationData) -> excluded.contains(registrationData.email)
    );

    @Test
    public void adds_a_customer_when_not_excluded()
        throws DuplicateException, ExcludedException {
        assertEquals(Optional.empty(), customers.find("0"));

        Customer added = registration.register(
            new RegistrationData("fred flintstone", "fred@bedrock.com")
        );
        assertEquals(
            new Customer("0", "fred flintstone", "fred@bedrock.com"),
            added
        );
        assertEquals(added, customers.find("0").orElseThrow());
    }

    @Test
    public void throws_DuplicateException_when_email_address_exists() {
        customers.add(new Customer("0", "fred flintstone", "fred@bedrock.com"));
        assertEquals(1, customers.size());

        assertThrows(DuplicateException.class,
            () -> registration.register(
                new RegistrationData("another name", "fred@bedrock.com")
            )
        );
        assertEquals(1, customers.size());
    }

    ...
}
```

[示例 19.32 [errors.23:src/test/java/travelator/CustomerRegistrationTests.java]](https://java-to-kotlin.dev/code.html?ref=19.32&show=file) [(diff)](https://java-to-kotlin.dev/code.html?ref=19.32&show=diff)

在我们从 Java 迁移到 Kotlin 和错误类型时，保留`register`和`registerToo`是一个不错的方式。然而，在这种情况下，测试实际上是`register`的最后调用者，所以让我们将它们转换为调用`registerToo`。我们可以花时间展示如何在 Java 中使用 Result4k，但我们对这个示例已经厌倦了，所以我们将把测试用例转换为 Kotlin，然后让它们调用`register`，并说上一些不朽的话：“这是我之前制作的一个例子”：

```java
@Test
fun `adds a customer when not excluded`() {
    assertEquals(Optional.empty<Any>(), customers.find("0"))
    val added = registration.registerToo(
        RegistrationData("fred flintstone", "fred@bedrock.com")
    ).valueOrNull()
    assertEquals(
        Customer("0", "fred flintstone", "fred@bedrock.com"),
        added
    )
    assertEquals(added, customers.find("0").orElseThrow())
}

@Test
fun `returns Duplicate when email address exists`() {
    customers.add(Customer("0", "fred flintstone", "fred@bedrock.com"))
    assertEquals(1, customers.size())
    val failure = registration.registerToo(
        RegistrationData("another name", "fred@bedrock.com")
    ).failureOrNull()
    assertEquals(
        Duplicate("customer with email fred@bedrock.com already exists"),
        failure
    )
    assertEquals(1, customers.size())
}

    ...
```

[示例 19.33 [errors.24:src/test/java/travelator/CustomerRegistrationTests.kt]](https://java-to-kotlin.dev/code.html?ref=19.33&show=file) [(diff)](https://java-to-kotlin.dev/code.html?ref=19.33&show=diff)

现在我们没有`register`的调用者了，我们终于可以删除它，并将`registerToo`重命名为`register`，最终得到无异常的 Kotlin：

```java
interface IRegisterCustomers {
    fun register(data: RegistrationData):
        Result<Customer, RegistrationProblem>
}

sealed class RegistrationProblem

object Excluded : RegistrationProblem()

data class Duplicate(
    val message: String?
) : RegistrationProblem()
```

[示例 19.34 [errors.25:src/main/java/travelator/IRegisterCustomers.kt]](https://java-to-kotlin.dev/code.html?ref=19.34&show=file) [(diff)](https://java-to-kotlin.dev/code.html?ref=19.34&show=diff)

```java
interface Customers {

    fun add(name:String, email:String): Result<Customer, DuplicateException>

    fun find(id: String): Optional<Customer>
}
```

[示例 19.35 [errors.25:src/main/java/travelator/Customers.kt]](https://java-to-kotlin.dev/code.html?ref=19.35&show=file) [(diff)](https://java-to-kotlin.dev/code.html?ref=19.35&show=diff)

嗯，因为那个`DuplicateException`，并不完全是无异常的。它实际上不再从任何地方*抛出*，只是被创建并放入了一个`Failure`中。我们可以通过将类重命名为`DuplicateCustomerProblem`并停止它继承`Exception`来解决这个问题，或者重用`RegistrationProblem`的现有`Duplicate`子类。哪个更好呢？

# 层次

如果我们从层次角度来思考，`Customers`位于比`Registration`更低的层次，后者依赖于它。因此，`Customers`不应该依赖于更高级别的`RegistrationPro⁠blem`。我们可以尝试反转依赖关系，使`RegistrationProblem`的`Duplicate`子类成为在存储库层声明的`DuplicateCustomerPro⁠blem`的子类型（甚至仅是相同类型）。这在这里可以工作，但如果`Customers::add`需要声明另一种可能失败的方式，这可能是一个死胡同。例如，如果我们想在我们的结果中显示数据库通信可能会失败，我们不能（或者不应该）将其作为`DuplicateCustomerProblem`的子类型。因此，我们将再次面临在单个结果中表达多个错误类型的问题。

让我们跟踪一下。如果 `Customers::add` 需要声明不止一种可能失败的方式——我们之前的 `DuplicateCustomerProblem` 和我们的新 `DatabaseCustomer​Pro⁠blem`——我们将引入一个封闭的 `CustomersProblem` 作为错误类型，并使这两个已知问题成为其唯一的子类：

```java
interface Customers {

    fun add(name:String, email:String): Result<Customer, CustomersProblem>

    fun find(id: String): Optional<Customer>
}

sealed class CustomersProblem

data class DuplicateCustomerProblem(val message: String): CustomersProblem()

data class DatabaseCustomerProblem(val message: String): CustomersProblem()
```

[示例 19.36 [errors.27:src/main/java/travelator/Customers.kt]](https://java-to-kotlin.dev/code.html?ref=19.36&show=file) [(差异)](https://java-to-kotlin.dev/code.html?ref=19.36&show=diff)

`CustomerRegistration` 调用 `Customers::add` 并仅处理 `mapFailure` 中的 `DuplicateCustomerProblem` ：

```java
class CustomerRegistration(
    private val customers: Customers,
    private val exclusionList: ExclusionList
) : IRegisterCustomers {

    override fun register(
        data: RegistrationData
    ): Result<Customer, RegistrationProblem> {
        return when {
            exclusionList.exclude(data) -> Failure(Excluded)
            else -> customers.add(data.name, data.email)
                .mapFailure { duplicate: DuplicateCustomerProblem ->
                    Duplicate(duplicate.message)
                }
        }
    }
}
```

[示例 19.37 [errors.26:src/main/java/travelator/CustomerRegistration.kt]](https://java-to-kotlin.dev/code.html?ref=19.37&show=file) [(差异)](https://java-to-kotlin.dev/code.html?ref=19.37&show=diff)

现在这不再编译，因为失败的类型现在是 `CustomersProblem` 基类。您可以看到我们正在获得已检查异常的好处：代码正在传达它可以失败的方式，并强制我们处理这些情况。

现在 `Customers::add` 承认它可能以一种新颖的方式失败，`register` 也被迫处理事实。它决定将这一知识传递给其调用者（好吧，我们替它决定），通过添加现有 `RegistrationProblem` 封闭类的新 `DatabaseProblem` 子类型：

```java
sealed class RegistrationProblem

object Excluded : RegistrationProblem()

data class Duplicate(val message: String) : RegistrationProblem()

data class DatabaseProblem(val message: String) : RegistrationProblem()
```

[示例 19.38 [errors.27:src/main/java/travelator/IRegisterCustomers.kt]](https://java-to-kotlin.dev/code.html?ref=19.38&show=file) [(差异)](https://java-to-kotlin.dev/code.html?ref=19.38&show=diff)

现在我们可以通过转换 `add` 可能失败的方式（`DuplicateCustomerProblem` 和 `DatabaseCustomerProblem`）以及 `register` 可能失败的方式（分别是 `Duplicate` 和 `DatabaseProblem`）来修复 `register`。现在 `map​Fai⁠lure` 的选择已经清晰：

```java
override fun register(
    data: RegistrationData
): Result<Customer, RegistrationProblem> {
    return when {
        exclusionList.exclude(data) -> Failure(Excluded)
        else -> customers.add(data.name, data.email)
            .mapFailure { problem: CustomersProblem ->
                when (problem) {
                    is DuplicateCustomerProblem ->
                        Duplicate(problem.message)
                    is DatabaseCustomerProblem ->
                        DatabaseProblem(problem.message)
                }
            }
    }
}
```

[示例 19.39 [errors.27:src/main/java/travelator/CustomerRegistration.kt]](https://java-to-kotlin.dev/code.html?ref=19.39&show=file) [(差异)](https://java-to-kotlin.dev/code.html?ref=19.39&show=diff)

最后，因为我们已经扩展了 `RegistrationProblem` 封闭层次结构，编译器现在通过编译 `CustomerRegistrationHandler` 来强迫我们考虑 `DatabaseProblem` 在上一层中的影响。

```java
private fun RegistrationProblem.toResponse() = when (this) {
    is Duplicate -> Response(HTTP_CONFLICT)
    is Excluded -> Response(HTTP_FORBIDDEN)
    is DatabaseProblem -> Response(HTTP_INTERNAL_ERROR) ![1](img/1.png)
}
```

[示例 19.40 [errors.27:src/main/java/travelator/handlers/CustomerRegistrationHandler.kt]](https://java-to-kotlin.dev/code.html?ref=19.40&show=file) [(差异)](https://java-to-kotlin.dev/code.html?ref=19.40&show=diff)

![1](img/#co_introduction_CO46-1)

我们必须添加一个 `DatabaseProblem` 案例以使 `when` 表达式编译通过。

因为 `CustomerRegistrationHandler` 是此交互的入口点，我们的工作现在已经完成。

# 继续前进

这是一个很长的章节，但其长度与其重要性成比例。

您的 Java 项目可能已经宣告了异常破产，没有系统地使用已检查的异常。在这种情况下，Kotlin 将一切视为未检查异常的政策将是合适的。

如果你依赖于受检异常并希望转换为 Kotlin，或者希望在转换过程中提升错误处理能力，那么使用结果类型是最佳策略。当操作可能以多种方式失败时，我们可以使用密封类来列举失败模式，尽管这会导致不能在多个层次中传播相同类型。当我们有多个层次时，事情会变得繁琐，但至少不容易出错。

我们或许应该（*maybe should*）撰写一本完整的关于错误处理的书籍，但与此同时，你可以跟随邓肯在[他的博客](https://oreil.ly/kfvAn)中的探索之旅。除了这里涵盖的材料外，这还展示了如何减少因为它们是[部分函数](https://oreil.ly/8RoO4)而会失败的函数的数量。

减少我们的函数可能失败的数量是很重要的，因为受错误影响的代码与我们在第七章，“从操作到计算”中看到的行为非常相似。操作会污染它们的调用者：默认情况下，调用操作的代码本身也成为操作。同样，调用可能失败的代码的代码本身也可能失败。我们可以通过尽可能将它们移动到系统入口点附近来减少两者的影响，以便它们污染的代码最少。

在本章中，我们简要提到了当错误发生时使我们的代码健壮的方法。操作在这里也是一个问题，因为它们会影响我们系统的状态。当两个事物需要更新时，第一个操作写入，但第二个操作由于在调用之前发生错误而没有执行时，状态可能会被损坏。严格区分操作和计算的差异是制作健壮软件的关键。

我们将在第二十一章，“从值到异常”中回顾错误处理。
