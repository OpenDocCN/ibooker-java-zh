## 附录 C. 从这里开始去哪里

你现在已经有了一些在 Java 中编写函数式程序的经验。你将把学到的东西应用到日常 Java 编程中的程度取决于你自己。试图做到 100% 函数式可能对许多 Java 程序员来说太多了一些。例如，使用完全函数式的 I/O，可能不是每个读者都希望在他们的生产代码中做的事情。但如果你想在专业项目中采用函数式编程范式，你有选择。

### C.1\. 选择一门新语言

第一个选择是你要使用的语言。通常，选择不同的（更友好的函数式语言）并不是一个选项。但有时是。我们只是触及了这个主题的表面，有了合适的工具，你可以走得更远。选择一种函数式语言可能看起来很复杂，但实际上并不复杂。如果你选择了一个在该领域更强大的语言，切换到另一种语言才会变得有趣。如果你已经阅读了这本书并想更进一步，你不会对弱类型语言感兴趣。所以你有三种可能的选择：Haskell、Scala 和 Kotlin（或者可能是第四种，Frege）。

#### C.1.1\. Haskell

Haskell 是函数式编程的事实标准语言。Haskell 是一种强类型、惰性函数式语言，拥有几乎所有有抱负的函数式程序员可能梦想拥有的特性，以及许多你一开始难以理解的更复杂特性。大多数关于函数式编程的现代文章和书籍都使用 Haskell 作为示例。此外，它们使用的是 Haskell 的特定版本：格拉斯哥 Haskell 编译器（GHC）。

无论你是否能选择你喜欢的语言，如果你在一个团队工作或者必须使用遗留代码，这通常是不可能的，学习 Haskell 将是有益的。当你使用 Java 编写函数式程序时，你经常不得不与语言本身作斗争。使用 Haskell，你将不得不与之作斗争来编写命令式程序。学习 Haskell 将训练你的思维进入一种只有其他语言无法做到的函数式思维。即使你继续使用 Java，用 Haskell 原型化函数也是非常有益的。

对于 Java 程序员来说，Haskell 的主要问题在于一切都是新的。你将无法使用你习惯的任何常规 Java 工具（除了代码编辑器）或你习惯的众多库。当然，有很多 Haskell 库，但你将不得不从头开始学习一切，包括如何查找、下载和管理它们，如何构建你的程序，如何处理文档，以及其他所有事情。

#### C.1.2\. Scala

另一个解决方案是切换到 Scala。Scala 不是一个严格的功能性语言。使用 Scala，你可以以命令式和函数式风格编写程序。切换到 Scala 很容易，因为你可以用类似 Java 的设计编写 Scala 程序，就像 Java 首次出现时，可以像编写 C 程序一样编写 Java 程序。当然，这不是最好的方法，我们许多在 Java 中的问题都源于这种 C 遗产。随着越来越多的 Java 程序员转向 Scala，我们将看到越来越多的命令式程序用这种语言编写。

因此，在 Scala 中编写函数式程序是一种纪律，但几乎没有什么缺失（如果你使用一些高级函数库）。巨大的优势是，你将能够重用你大部分已知的知识。你可以在 Eclipse、NetBeans 或 IntelliJ 中编写 Scala 程序。尽管 Scala 有自己的构建工具（sbt），但你也可以使用 Gradle 构建 Scala 程序，甚至可以使用 Maven 或 Ant（尽管没有人会想这样做？）。此外，你可以在 Scala 程序中使用所有现有的 Java 库。（当然，Scala 库也可以从 Java 中使用。）这些特性使得 Scala 成为处理遗留 Java 代码和工具时的一个很好的首选。

#### C.1.3\. Kotlin

Kotlin 是由 IntelliJ IDE 的出版商 JetBrains 设计的一种新语言，IntelliJ IDE 是 Java 以及许多其他语言的最佳 IDE。Kotlin 是 Java 应该成为的样子。它拥有许多功能友好的特性，例如函数类型（允许你编写 `(A) -> (B) -> C` 而不是 `Function<A, Function<B, C>>`），数据类（自动生成构造函数、访问器以及 `equals` 和 `hashCode` 方法），以及隐式方法调用（允许你以 `f(x)` 的形式调用函数，而不是更冗长的 Java 语法 `f.apply(x)`）。此外，Kotlin 与 Java 完全兼容，可以在同一个项目中混合使用 Java 和 Kotlin。由于（目前）没有什么完美的事物，Kotlin 没有功能集合（意味着不可变、持久和共享数据的集合），但它使用特殊的机制——*扩展函数*——来使用 Java 标准集合。实际上，它允许以实例方法的方式调用静态方法，并使用 `this` 引用来引用“扩展”的实例。Kotlin 与 Java 的集成如此紧密，以至于你可以从向 Java 项目添加 Kotlin 类开始。你只需修改你的构建系统以添加 Kotlin 编译即可。对于开发来说，甚至这也不是必需的，因为 IntelliJ 允许透明地编译和运行混合的 Java/Kotlin 项目。截至本文撰写时，Kotlin 的版本是 1.0.5，因此在未来会有很多变化。版本 1.1 正在测试中，你应该在阅读本文时就可以使用。如果你对 Java 生态系统中的函数式编程感兴趣，这真的是你应该关注的事情。

#### C.1.4\. Frege

另一个有潜力的解决方案是弗雷格语言（以德国数学家和哲学家戈特洛布·弗雷格的名字命名，发音类似于“frey-guh”）。弗雷格是一种非常年轻的语言，可能还不够成熟，不适合用于生产代码，但它正在快速发展，并可能成为 JVM 上纯函数式编程的首选语言。弗雷格实际上是“JVM 上的 Haskell”。它与 Haskell 尽可能接近，同时保留了使用所有现有 Java 库的可能性。因为它可以与 Java 混合（就像 Scala 一样），所以它是一个很好的平滑过渡选择。而且，如果你决定学习 Haskell 或 Kotlin 作为原型设计语言，为什么不也使用弗雷格呢？你可以在[`github.com/Frege/fregeandhttp://fregepl.blogspot.fr/`](https://github.com/Frege/fregeandhttp://fregepl.blogspot.fr/)找到更多关于弗雷格的信息。

#### C.1.5. 动态类型函数式语言怎么样？

动态类型函数式语言与之前的语言不同，因为它们不是依赖于类型系统来帮助程序员编写正确的程序，而是让程序员摆脱类型的束缚，允许他们编写类型错误的程序，这些程序可以编译。

为了让这种语言听起来像是一种好处，这类语言通常被称为“动态类型语言”。众所周知，动态类型比静态类型更好，所以这应该是一个质量特性。不幸的是，与 Java、Haskell 或 Scala 等“强类型”语言相比，这些语言最好被称为“弱类型”语言。这并不是说弱类型语言不好。它们只是有一个非常重要的区别：如果你与类型搞混，编译器通常不会警告你。程序只会在运行时崩溃。这是一个选择。你自己看看吧。

### C.2. Staying with Java

你可以选择坚持使用 Java。为了从学习函数式范式过渡到将其应用于 Java 生产代码，你需要一个 Java 函数式库。你可以使用你在阅读这本书时开发的库，但你需要意识到维护一个库是一项巨大的任务。如果你是唯一的用户，这可能是最好的选择，因为你可以根据你的需求定制库。每次你发现一个可以抽象到库中的新函数时，你都可以自由地这样做。但如果你在一个团队中工作，那就另当别论了。你必须照顾到每个人的需求，小心不要破坏任何东西，并且始终保持向后兼容。这是一项非常繁重的工作。

另一个选择是使用由许多人开发和测试的现有开源库。你不会拥有添加所需新功能的相同自由度，但你很快就能变得高效。而且，如果你真的需要新功能，你可以自己添加并提议给社区。

#### C.2.1. 函数式 Java

函数式 Java 是早期使用至今的开源 Java 函数式库之一。它早于 Java 8，最初是用匿名类来表示函数编写的。如果你旨在成为一名极端的函数式程序员，这无疑是一个好事。即使你不是，使用它并查看其编码方式也是一种非常有益的经历。然而，请注意，文档很少。你将不得不自己弄清楚如何使用它，尽管这本书中学到的知识将大大帮助你。

还要注意，这个库是由许多伟大的函数式程序员开发的，其中一些人现在将他们的兴趣转向了更友好的函数式语言。你可以在本网站上找到更多信息：[`www.functionaljava.org/`](http://www.functionaljava.org/).

#### C.2.2\. Javaslang

Javaslang 是一个较新的、不那么极端的 Java 函数式库。它有更好的文档，包括基本示例，尽管文档只有一页（大页）。在这里，你在这本书中学到的知识在使用 Javaslang 时将非常有帮助。正如我所说，Javaslang 的方法不那么极端，这可能使其更容易过渡，尤其是对于对函数式范式兴趣各异的团队。有一点小问题，尽管它有流，但这些流也面临着 Java 8 流的一个相同问题：它们没有懒折叠。然而，问题声明有计划实现它们。另一方面，它提供了一个可用的模式匹配机制。你可以在[`javaslang.io/`](http://javaslang.io/)找到有关这个库的信息。

#### C.2.3\. Cyclops

Cyclops 被描述为“强大的、轻量级的和模块化的 JDK 8 扩展”，但它不仅仅是这样。实际上，它是 Java 的完整函数式库，并提供了利用标准 Java 数据类型以使其真正可用的额外支持。例如，它向标准 Java 集合添加了函数式方法，并且还提供了类似于你在本书中开发的不可变持久集合。Cyclops 还提供了 Java 8 `Stream`接口缺失的方法，如`takeWhile`和`dropWhile`。Cyclops 充满了有趣的东西，如可重放流、记忆化、跳跃、模式匹配、元组等。它可能拥有所有可用 Java 函数式库中最好的文档。最后，它被设计成与其他库（如 Functional Java 或 Javaslang 或 Guava）协同工作。Cyclops 可以在[`github.com/aol/cyclops`](https://github.com/aol/cyclops)找到。

#### C.2.4\. 其他函数式库

曾经还有其他 Java 函数式库，例如 Fun4j、LambdaJ、op4j 和 Apache Commons Functor。所有这些库都在 Java 8 之前出现，并且自 Java 8 发布以来都没有进化，这使它们大多变得过时。

Guava 库之所以持续发展，是因为它不仅仅是一个函数式库，而是一个包含函数在内的库。但 Guava 的函数式特性并没有太多发展，现在已经过时了。

### C.3. 进一步阅读

如果你想了解更多关于函数式编程的信息，你可以在互联网上找到很多资源。关于函数式编程的文章和书籍已经有很多，但关于 Java 函数式编程的却不多。然而，你可能找到一些关于通用函数式编程的文章，这些文章以“函数式语言”为例，因为许多概念都适用于 Java。

这里是一个可能感兴趣的文献列表，但不全面：

+   John Hughes, “为什么函数式编程很重要,” 来自“函数式编程研究主题”，D. Turner 编著（Addison-Wesley，1990 年), [`mng.bz/qp3B`](http://mng.bz/qp3B)。这篇文章非常有趣，主要讨论了高阶函数和惰性，并解释了为什么这些特性对于编写更好、更安全的程序至关重要。

+   Philip Walder,“免费定理！” (格拉斯哥大学，1989 年), [`mng.bz/my25`](http://mng.bz/my25)。这篇文章比较难读，但如果你想知道强大的类型系统作为程序员能为你提供什么，那么这份努力是值得的。

+   Chris Okasaki, “纯函数式数据结构” (论文，卡内基梅隆大学计算机科学学院，1996 年), [`mng.bz/8Gz4`](http://mng.bz/8Gz4). 这篇更容易阅读的大学论文讲述了如何构建纯函数式数据结构。示例是用标准 ML 编写的，这是一种函数式语言。Okasaki 基于这篇论文写了一本书，这本书更容易阅读，并且有 Haskell 语言的示例。如果你对函数式（不可变和持久）数据结构感兴趣，这本书是你必须阅读的。

+   Kimball Germane 和 Matthew Might, “删除：红黑树的诅咒,” *《函数式编程杂志》* 24, 4 (2014): 423–433, [`mng.bz/yl57`](http://mng.bz/yl57)。这篇论文补充了 Okasaki 关于函数式红黑树的介绍。在他的书中，Okasaki 没有给出从该结构中删除元素的实现，而是将其留作读者的练习。这篇文章就是关于那个实现的。

+   Graham Hutton, “关于折叠的普遍性和表达性的教程,” *《函数式编程杂志》* 9, 4 (1999): 355–372, [`mng.bz/me7Z`](http://mng.bz/me7Z). 这是最有趣的关于函数式编程的文章之一，而且非常易于阅读。如果你想要全面理解折叠，这是一篇必读的文章。

+   Ralf Hinze 和 Ross Patterson, “指针树：一种简单通用的数据结构,” [`mng.bz/AYZS`](http://mng.bz/AYZS)。这篇文章介绍了一种非常有趣的函数式数据结构，它允许以良好的性能进行所有类型的访问和操作，尽管它并不像标题所说的那么简单。在 Java 中实现它是一个有价值的挑战。（有几种已知的实现。）
