# 第七章：编程和文档约定

本章解释了许多重要且有用的 Java 编程和文档约定。它涵盖了：

+   一般的命名和大小写约定

+   可移植性提示和约定

+   `javadoc` 文档注释语法和约定

# 命名和大小写约定

以下广泛采用的命名约定适用于 Java 中的模块、包、引用类型、方法、字段和常量。由于这些约定几乎被普遍遵循，并且因为它们影响你所定义的类的公共 API，你应该也要采用它们：

模块

由于从 Java 9 开始，模块是 Java 应用程序的首选分发单元，所以当命名它们时应特别小心。

模块名必须是全局唯一的——模块系统基本上是以此假设为前提的。由于模块实际上是超级包（或者包的聚合），模块名应与分组到模块中的包名密切相关。一个推荐的做法是将包分组到模块中，并使用包的 *根名称* 作为模块名。例如，如果一个应用程序的所有包都位于 `com.mycompany.*` 下，则 `com.mycompany` 是你的模块的一个好名字。

包

通常习惯确保你公开可见的包名是唯一的。一种常见的做法是用你拥有的互联网域名的倒置名称作为前缀（例如，`com.oreilly.javanutshell`）。

现在对这个约定的严格遵循已经不像以前那样严格了，一些项目仅仅采用一个简单、可识别且唯一的前缀。所有包名应该是小写的。

类

类型名应该以大写字母开头，并使用驼峰命名法（例如，`String`）。这通常被称为 *帕斯卡命名法*。如果一个类名由多个单词组成，每个单词应该以大写字母开头（例如，`StringBuffer`）。如果类型名或类型名中的一个词是一个首字母缩写词，那么首字母缩写词可以用全大写字母来书写（例如，`URL`，`HTMLParser`）。

因为类和枚举类型被设计用来表示对象，所以你应该选择名词作为类名（例如，`Thread`，`Teapot`，`FormatConverter`）。

枚举类型是具有有限实例数量的类的特殊情况。除非是非常特殊的情况，它们应该被命名为名词。`enum` 类型定义的常量通常也是按照下面的常量规则写成全大写字母。

接口

Java 程序员通常以以下两种方式使用接口：要么传达一个类具有额外的、补充的方面或行为；要么指示该类是接口的一个可能的实现，而对于这个接口有多种有效的实现选择。

当一个接口用于提供关于实现它的类的附加信息时，通常选择一个形容词作为接口名称（例如 `Runnable`，`Cloneable`，`Serializable`）。

当一个接口旨在更像一个抽象超类时，使用名词作为名称（例如，`Document`，`FileNameMap`，`Collection`）。按照惯例，不要通过名称表明它是一个接口（即不要使用 `IDocument` 或 `DocumentInterface`）。

方法

方法名始终以小写字母开头。如果名称包含多个单词，则从第二个单词开始每个单词的首字母大写（例如，`insert()`，`insertObject()`，`insertObjectAt()`）。这通常被称为*驼峰命名法*。

方法名称通常选择使第一个单词为动词。方法名称可以尽可能长以清晰表达其目的，但在可能的情况下选择简洁的名称。避免过于通用的方法名称，如 `performAction()`，`go()`，或可怕的 `doIt()`。

字段和常量

非常量字段名称遵循与方法名称相同的大写规范。应选择最能描述字段用途或值的名称。不鼓励使用前缀来指示字段的类型或可见性。

如果一个字段是 `static final` 常量，则应使用全大写字母编写。如果常量的名称包含多个单词，则应使用下划线分隔这些单词（例如，`MAX_VALUE`）。

参数

方法参数遵循与非常量字段相同的大写规范。方法参数的名称出现在方法的文档中，因此应选择能够尽可能清楚地表明参数用途的名称。尽量将参数名称保持为单个单词，并且在使用时保持一致。例如，如果一个 `WidgetProcessor` 类定义了许多接受 `Widget` 对象作为第一个参数的方法，则将该参数命名为 `widget`。

局部变量

局部变量名称是实现细节，从不在类外部可见。尽管如此，选择良好的名称可以使您的代码更易于阅读、理解和维护。通常，变量的命名遵循与方法和字段相同的约定。

除了特定类型名称的约定外，还有关于您应在名称中使用哪些字符的约定。Java 允许在任何标识符中使用 `$` 字符，但按照惯例，其使用应保留给源代码处理器生成的合成名称。例如，Java 编译器用它来使内部类工作。不应在您创建的任何名称中使用 `$` 字符。

Java 允许名称使用来自整个 Unicode 字符集的任何字母数字字符。虽然这对于非英语系程序员来说可能很方便，但 Unicode 的使用从未真正普及，这种用法非常罕见。

# 实用命名

我们赋予构造物的名称非常重要。命名是将我们的抽象设计传达给同行的关键过程。将软件设计从一个人的头脑转移到另一个人的头脑的过程很难——在许多情况下，比将我们的设计从头脑转移到将执行它的机器更难。

因此，我们必须尽一切努力确保这一过程得以简化。名称是这一过程的关键。在审查代码时（所有代码都应该经过审查），特别注意已选择的名称：

+   类型的名称是否反映了这些类型的目的？

+   每个方法是否确切地执行其名称所暗示的操作？理想情况下，既不多也不少？

+   名称是否足够描述性？是否可以使用更具体的名称？

+   这些名称是否适合描述它们所描述的领域？

+   名称是否在整个领域中保持一致？

+   名称是否混合了隐喻？

+   名称是否重复使用了软件工程中的常见术语？

+   布尔返回方法的名称是否包括否定？这些通常需要更多注意力才能理解（例如，`notEnabled()` vs. `enabled()`）。

在软件中，混合隐喻很常见，尤其是在应用程序发布了几个版本之后。一个系统最初完全合理地使用称为`Receptionist`（用于处理传入连接）、`Scribe`（用于持久化订单）和`Auditor`（用于检查和调解订单）的组件，很容易在后续版本中以一个称为`Watchdog`的类结束，用于重新启动进程。这并不是很糟糕，但它打破了先前存在的人们职称的已建立模式。

还有一点非常重要，那就是要意识到软件随时间变化很多。发布第 1 版时非常适当的名称可能到第 4 版时已经非常误导。应该注意的是，随着系统的重心和意图的变化，名称应该与代码一起进行重构。现代 IDE 对全局搜索和替换符号没有问题，因此在不再有用时没有必要固守过时的隐喻。

最后要注意的一点是：过于严格地解释这些指南可能会导致开发人员产生一些非常奇怪的命名结构。有许多优秀的描述，说明了将这些约定推向极端可能导致的一些荒谬行为。

换句话说，这里描述的约定并非强制性的。在绝大多数情况下，遵循它们将使您的代码更易于阅读和维护。但是，如果因为更易于阅读和理解而偏离这些指南，也不必害怕。

> 宁可违反这些规则，也不要说出任何显得十分粗野的话。
> 
> 乔治·奥威尔

最重要的是，您应该对您编写的代码预期的寿命有所了解。银行中的风险计算系统可能有十年或更长的寿命，而初创公司的原型可能仅在几周内相关。因此，需要相应地进行文档编写 - 代码越长时间活跃，其文档和命名就需要越好。

# Java 文档注释

Java 代码中的大多数普通注释解释了该代码的实现细节。相比之下，Java 语言规范定义了一种特殊类型的注释，称为*文档注释*，用于记录您代码的 API。

文档注释是普通的多行注释，以`/**`开头（而不是通常的`/*`），以`*/`结尾。文档注释出现在类型或成员定义之前，包含该类型或成员的文档。文档可以包括简单的 HTML 格式化标记和其他特殊关键字，提供额外的信息。

编译器会忽略文档注释，但可以通过`javadoc`程序提取并自动转换为在线 HTML 文档（请参阅第十三章以获取有关`javadoc`的更多信息）。

这里是一个包含适当文档注释的示例类：

```java
/**
 * This immutable class represents <i>complex numbers</i>.
 *
 * @author David Flanagan
 * @version 1.0
 */
public class Complex {
    /**
 * Holds the real part of this complex number.
 * @see #y
 */
    protected double x;

    /**
 * Holds the imaginary part of this complex number.
 * @see #x
 */
    protected double y;

    /**
 * Creates a new Complex object that represents the complex number
 * x+yi.
 * @param x The real part of the complex number.
 * @param y The imaginary part of the complex number.
 */
    public Complex(double x, double y) {
        this.x = x;
        this.y = y;
    }

    /**
 * Adds two Complex objects and produces a third object that
 * represents their sum.
 * @param c1 A Complex object
 * @param c2 Another Complex object
 * @return  A new Complex object that represents the sum of
 *          <code>c1</code> and <code>c2</code>.
 * @exception java.lang.NullPointerException
 *            If either argument is <code>null</code>.
 */
    public static Complex add(Complex c1, Complex c2) {
        return new Complex(c1.x + c2.x, c1.y + c2.y);
    }
}
```

## 文档注释的结构

文档注释的正文应以对被记录的类型或成员的一句摘要开始。这句话可能会单独显示为摘要文档，因此应编写得能够独立存在。初始句子后面可以跟随任意数量的其他句子和段落，详细描述类、接口、方法或字段。

在描述性段落之后，文档注释可以包含任意数量的其他段落，每个段落以特殊的文档注释标签开头，例如`@author`、`@param`或`@returns`。这些标记段落为`javadoc`程序以标准方式显示提供了有关类、接口、方法或字段的具体信息。文档注释标签的完整集合将在下一节中列出。

文档注释中的描述材料可以包含简单的 HTML 标记，如用于强调的`<i>`；用于类、方法和字段名称的`<code>`；以及用于多行代码示例的`<pre>`。它还可以包含`<p>`标记以将描述分隔成单独的段落，以及`<ul>`、`<li>`和相关标记以显示项目符号列表和类似结构。但请记住，您编写的材料嵌入在更大、更复杂的 HTML 文档中。因此，文档注释不应包含可能干扰更大文档结构的主要结构 HTML 标记，如`<h2>`或`<hr>`。

避免在文档注释中使用 `<a>` 标签来包含超链接或交叉引用。相反，请使用特殊的 `{@link}` 文档注释标签，与其他文档注释标签不同，它可以出现在文档注释的任何位置。正如在下一节所述，`{@link}` 标签允许您指定到其他类、接口、方法和字段的超链接，而无需了解 `javadoc` 使用的 HTML 结构约定和文件名。

如果要在文档注释中包含图像，请将图像文件放置在源代码目录的 *doc-files* 子目录中。将图像命名为与类相同，并带有整数后缀。例如，名为 `Circle` 类文档注释中的第二个图像可以使用以下 HTML 标签包含：

```java
<img src="doc-files/Circle-2.gif">
```

因为文档注释的行被嵌入在 Java 注释中，每行注释的开头空格和星号 (`*`) 在处理之前都会被去除。因此，您不需要担心星号出现在生成的文档中，也不需要担心注释的缩进会影响使用 `<pre>` 标签包含在注释中的代码示例的缩进。

## 文档注释标签

`javadoc` 程序识别一些特殊标签，每个标签以 `@` 字符开头。这些文档注释标签允许您以标准化的方式将特定信息编码到您的注释中，并允许 `javadoc` 选择适合该信息的输出格式。例如，`@param` 标签允许您指定方法的单个参数的名称和含义。`javadoc` 可以提取此信息并使用 HTML `<dl>` 列表、HTML `<table>` 或其他适合的方式显示它。

下面是`javadoc`所识别的文档注释标签；一个文档注释应按照这里列出的顺序使用这些标签：

`@author` *`name`*

添加一个包含指定名称的“Author:”条目。这个标签应该用于每个类或接口的定义，但不能用于单独的方法和字段。如果一个类有多个作者，可以在相邻的行上使用多个 `@author` 标签。例如：

```java
@author David Flanagan
@author Ben Evans
@author Jason Clark
```

按照时间顺序列出作者，首先是原始作者。如果作者未知，您可以使用“未署名”。除非指定了 `-author` 命令行参数，否则 `javadoc` 不会输出作者信息。

`@version` *`text`*

插入一个包含指定文本的“Version:”条目。例如：

```java
@version 1.32, 08/26/04
```

这个标签应该包含在每个类和接口的文档注释中，但不能用于单独的方法和字段。这个标签通常与版本控制系统（如 git、Perforce 或 SVN）的自动版本编号功能一起使用。除非指定了 `-version` 命令行参数，否则`javadoc`不会在生成的文档中输出版本信息。

`@param` *`parameter-name`* *`description`*

将指定的参数及其描述添加到当前方法的“Parameters:”部分。方法或构造函数的文档注释必须包含方法期望的每个参数的一个`@param`标记。这些标记应按方法指定的参数顺序出现。此标记仅可用于方法和构造函数的注释。

鼓励您在可能的情况下使用短语和句子片段，以保持描述的简洁性。但是，如果一个参数需要详细的文档，描述可以换行并包含尽可能多的文本。为了在源代码形式中的可读性，考虑使用空格来对齐描述。例如：

```java
@param o      the object to insert
@param index  the position to insert it at
```

`@return` *`description`*

插入一个包含指定描述的“Returns:”部分。除非方法返回`void`或是构造函数，否则该标记应出现在每个方法的文档注释中。描述可以尽可能长，但考虑使用句子片段以保持简短。例如：

```java
@return <code>true</code> if the insertion is successful, or
        <code>false</code> if the list already contains the object.
```

`@exception` *`full-classname description`*

添加一个包含指定异常名称和描述的“Throws:”条目。方法或构造函数的文档注释应该为其`throws`子句中出现的每个已检查异常包含一个`@exception`标记。例如：

```java
@exception java.io.FileNotFoundException
           If the specified file could not be found
```

当方法可能抛出用户可能希望捕获的未检查异常（即`RuntimeException`的子类）时，可以选择使用`@exception`标记。如果方法可能抛出多个异常，请在相邻的行上使用多个`@exception`标记，并按字母顺序列出异常。描述可以简短或长到足以描述异常的重要性。此标记仅可用于方法和构造函数的注释。`@throws`标记是`@exception`的同义词。

`@throws` *`full-classname description`*

此标记是`@exception`的同义词。

`@see` *`reference`*

添加一个包含指定引用的“See Also:”条目。此标记可以出现在任何类型的文档注释中。*`reference`*的语法在 “交叉引用在文档注释中” 中有解释。

`@deprecated` *`explanation`*

该标记指定以下类型或成员已被弃用，应避免使用。`javadoc`在文档中添加一个突出显示的“Deprecated”条目，并包含指定的*`explanation`*文本。此文本应指明类或成员被弃用的时间，如果可能的话，建议替换类或成员，并包含指向其的链接。例如：

```java
@deprecated As of Version 3.0, this method is replaced
            by {@link #setColor}.
```

`@deprecated`标记是`javac`忽略所有注释的一般规则的例外情况。当此标记出现时，编译器会在生成的类文件中记录此过时信息。这使得它能够为依赖于过时特性的其他类发出警告。

`@since` *`version`*

指定类型或成员添加到 API 的时间。此标签应跟随版本号或其他版本规范。例如：

```java
@since JNUT 3.0
```

每个类型的文档注释都应包括一个 `@since` 标签，而在类型的初始发布之后添加的任何成员应在其文档注释中具有 `@since` 标签。

`@serial` *`描述`*

从技术上讲，类序列化的方式是其公共 API 的一部分。如果你编写了一个希望被序列化的类，你应该使用 `@serial` 和相关标签来记录其序列化格式，这些标签列在下面。对于任何作为 `Serializable` 类序列化状态的一部分的字段，`@serial` 应该出现在其文档注释中。

对于使用默认序列化机制的类，这意味着所有非声明为 `transient` 的字段，包括声明为 `private` 的字段。*`描述`* 应为序列化对象中字段及其目的的简要描述。

你也可以在类和包级别使用 `@serial` 标签来指定是否为类或包生成“序列化形式页面”。语法是：

```java
@serial include
@serial exclude
```

`@serialField` *`名称 类型 描述`*

可序列化类可以通过在名为 `serialPersistentFields` 的字段中声明 `ObjectStreamField` 对象的数组来定义其序列化格式。对于这样的类，`serialPersistentFields` 的文档注释应包括数组每个元素的 `@serialField` 标签。每个标签指定了类序列化状态中特定字段的名称、类型和描述。

`@serialData` *`描述`*

可序列化类可以定义 `writeObject()` 方法来写入除了默认序列化机制之外的数据。`Externalizable` 类定义 `writeExternal()` 方法来负责将对象的完整状态写入序列化流。应该在这些 `writeObject()` 和 `writeExternal()` 方法的文档注释中使用 `@serialData` 标签，而 *`描述`* 则应该描述方法使用的序列化格式。

## 内联文档注释标签

除了前面列出的标签外，`javadoc` 还支持几个内联标签，它们可以出现在文档注释中的 HTML 文本任何位置。由于这些标签直接出现在 HTML 文本的流中，它们需要使用大括号作为定界符，以将标记文本与 HTML 文本分隔开。支持的内联标签包括：

`{@link` *`引用`* `}`

`{@link}` 标签类似于 `@see` 标签，不同之处在于它会在行内插入链接，而不是将链接放在特定的“See Also:”部分中。 `{@link}` 标签可以出现在文档注释中的任何 HTML 文本位置。换句话说，它可以出现在类、接口、方法或字段的初始描述以及与 `@param`、`@returns`、`@exception` 和 `@deprecated` 标签相关联的描述中。 `{@link}` 标签的 *`reference`* 使用下面 “Cross-References in Doc Comments” 中描述的语法。例如：

```java
@param regexp The regular expression to search for. This string
              argument must follow the syntax rules described for
              {@link java.util.regex.Pattern}.
```

`{@linkplain` *`reference`* `}`

`{@linkplain}` 标签与 `{@link}` 标签类似，不同之处在于链接的文本使用正常字体而不是 `{@link}` 标签使用的代码字体。当 *`reference`* 同时包含要链接到的 *`feature`* 和指定要在链接中显示的 *`label`* 时，这是最有用的。更多关于 *`reference`* 参数中 *`feature`* 和 *`label`* 部分的信息，请参见 “Cross-References in Doc Comments”。

`{@inheritDoc}`

当一个方法覆盖超类中的方法或实现接口中的方法时，可以省略文档注释，`javadoc` 会自动从被覆盖或实现的方法继承文档。可以使用 `{@inheritDoc}` 标签来继承单个标签的文本。此标签还允许继承和增强注释的描述性文本。要继承单个标签，请像这样使用它：

```java
@param index {@inheritDoc}
@return {@inheritDoc}
```

`{@docRoot}`

此内联标签不带参数，将替换为生成文档的根目录的引用。它在引用外部文件（如图像或版权声明）的超链接中非常有用：

```java
<img src="{@docroot}/images/logo.gif">
This is <a href="{@docRoot}/legal.xhtml">Copyrighted</a> material.
```

`{@literal` *`text`* `}`

此内联标签以文本的形式显示 *`text`*，逐字显示其中的 HTML 并忽略其中可能包含的 `javadoc` 标签。它不保留空格格式，但在 `<pre>` 标签内使用时非常有用。

`{@code` *`text`* `}`

此标签类似于 `{@literal}` 标签，但以代码字体显示 *`text`* 的文字。相当于：

```java
&lt;code&gt;{@literal <replaceable>text</replaceable>}&lt;/code&gt;
```

`{@value}`

`{@value}` 标签不带参数，用于文档注释中的 `static final` 字段中，将替换为该字段的常量值。

`{@value` *`reference`* `}`

此 `{@value}` 标签的变体包括对 `static final` 字段的 *`reference`* 引用，并替换为该字段的常量值。

## 文档注释中的交叉引用

`@see` 标签和内联标签 `{@link}`、`{@linkplain}` 和 `{@value}` 都编码了对某些其他文档源的交叉引用，通常是对某些其他类型或成员的文档注释的引用。

*`reference`*可以采用三种不同的形式。如果以引号字符开头，则视为书籍名称或其他印刷资源的名称，并按原样显示。如果*`reference`*以<字符开头，则视为任意 HTML 超链接，使用`<a>`标签，并将超链接插入输出文档中。`@see`标签的此形式可以插入到其他在线文档中，例如程序员指南或用户手册。

如果*`reference`*不是引号括起的字符串或超链接，则预期其具有以下形式：

```java
*`feature`* [*`label`*]

```

在这种情况下，`javadoc`输出由*`label`*指定的文本，并将其编码为指定*`feature`*的超链接。如果通常省略*`label`*，`javadoc`将使用指定*`feature`*的名称。

*`feature`*可以引用包、类型或类型成员，采用以下形式之一：

*`pkgname`*

对命名包的引用。例如：

```java
@see java.lang.reflect
```

*`pkgname`*.*`typename`*

对使用其完整包名指定的类、接口、枚举类型或注解类型的引用。例如：

```java
@see java.util.List
```

*`typename`*

对未指定其包名的类型的引用。例如：

```java
@see List
```

`javadoc`通过搜索当前包和导入类列表来解析此引用，以找到具有此名称的类。

*`typename`* `#` *`methodname`*

对指定类型中命名方法或构造函数的引用。例如：

```java
@see java.io.InputStream#reset
@see InputStream#close
```

如果类型没有指定其包名，则按照*`typename`*描述的方式解析。如果方法重载或类定义了同名字段，则此语法存在歧义。

*`typename`* `#` *`methodname`* `(` *`paramtypes`* `)`

对方法或构造函数的引用，其参数类型明确指定。在交叉引用重载方法时很有用。例如：

```java
@see InputStream#read(byte[], int, int)
```

`#` *`methodname`*

对当前类或接口中的非重载方法或构造函数的引用，或者对当前类或接口的包含类、超类或超接口中的一个方法的引用。使用这种简洁形式来引用同一类中的其他方法。例如：

```java
@see #setBackgroundColor
```

`#` *`methodname`* `(` *`paramtypes`* `)`

对当前类或接口或其超类或包含类中方法或构造函数的引用。此形式适用于重载方法，因为它明确列出了方法参数的类型。例如：

```java
@see #setPosition(int, int)
```

*`typename`* `#` *`fieldname`*

对指定类中命名字段的引用。例如：

```java
@see java.io.BufferedInputStream#buf
```

如果类型没有指定其包名，则按照*`typename`*描述的方式解析。

`#` *`fieldname`*

对当前类型或其包含类、超类或超接口中的字段的引用。例如：

```java
@see #x
```

## 包的文档注释

Java 源代码中类、接口、方法、构造函数和字段的文档注释出现在其定义之前。`javadoc` 也可以读取并显示包的摘要文档。由于包在目录中定义，而不是在单个源代码文件中，因此 `javadoc` 在包含该包类的源代码目录中查找名为 *package.xhtml* 的文件以获取包文档。

*package.xhtml* 文件应包含包的简单 HTML 文档。它还可以包含 `@see`、`@link`、`@deprecated` 和 `@since` 标签。因为 *package.xhtml* 不是 Java 源代码文件，所以其中的文档应为 HTML，并且不应为 Java 注释（即不应该包含在 `/**` 和 `*/` 字符之间）。最后，在 *package.xhtml* 中出现的任何 `@see` 和 `@link` 标签都必须使用完全限定的类名。

除了为每个包定义 *package.xhtml* 文件外，还可以通过在这些包的源树中定义 *overview.xhtml* 文件来为一组包提供高级文档。当对该源树运行 `javadoc` 时，它将使用 *overview.xhtml* 作为显示的最高级概述。

# 文档生成器

用于生成 HTML 文档的 `javadoc` 工具基于标准 API。自 Java 9 以来，此标准接口已通过模块 `jdk.javadoc` 提供，并且通常使用此 API 的工具称为 *doclets*（其中 `javadoc` 被称为标准文档生成器）。

Java 9 发布还包括标准文档生成器的主要升级。特别是自 Java 10 起，默认生成现代 HTML5。这允许其他改进，例如实现 [WAI-ARIA 标准](https://oreil.ly/4Slwr) 以提高可访问性。该标准使视觉或其他障碍的人能够使用屏幕阅读器等工具访问 `javadoc` 输出。

###### 注意

`javadoc` 还已经增强以理解新的平台模块，因此构成 API 的语义含义（以及应该记录的内容）现在与模块化 Java 定义对齐。

标准文档生成器现在在生成文档时还会自动索引代码，并在 JavaScript 中创建客户端索引。生成的网页具有搜索功能，允许开发人员轻松找到一些常见的程序组件，例如：

+   模块

+   包

+   类型和成员

+   方法参数类型

开发人员还可以使用 `@index` 内联 `javadoc` 标签添加搜索术语或短语。

# 便携程序的约定

Java 最早的口号之一是“一次编写，到处运行”。这强调了 Java 使编写便携程序变得容易，但仍然可能编写不会自动在任何 Java 平台上成功运行的 Java 程序。以下提示有助于避免可移植性问题：

本地方法

可移植的 Java 代码可以使用核心 Java API 中的任何方法，包括作为`native`方法实现的方法。但是，可移植的代码不得定义自己的 native 方法。由于其本质，native 方法必须适应每个新平台，因此直接违反了 Java“一次编写，到处运行”的承诺。

`Runtime.exec()`方法

在可移植代码中，几乎不允许调用`Runtime.exec()`方法来生成一个进程并在本地系统上执行外部命令。这是因为无法保证要执行的本地操作系统命令在所有平台上都存在或行为相同。

在可移植代码中，唯一允许使用`Runtime.exec()`的时候是用户可以指定要运行的命令，可以通过在运行时输入命令或在配置文件或首选项对话框中指定命令来实现。

如果程序员希望控制外部进程，则应通过 Java 9 引入的增强的`ProcessHandle`功能而不是使用`Runtime.exec()`和解析输出来实现。这并非完全可移植，但至少可以减少控制外部进程所需的特定于平台的逻辑量。

`System.getenv()`方法

使用`System.getenv()`在本质上是不可移植的。不同的操作系统具有不同的大小写约定（例如，Windows 不区分大小写，而 Unix 系统则不同）。此外，环境中常见的值在操作系统和组织之间有很大的差异。如果良好记录，使用`System.getenv()`来参数化应用程序所期望的特定值是可以接受的；这在容器化应用程序中经常这样做。但是，访问更广泛的环境可能会产生不兼容的行为。

未记录的类

可移植的 Java 代码必须仅使用作为 Java 平台文档的一部分记录的类和接口。大多数 Java 实现都附带有作为实现的一部分但不属于 Java 平台规范的额外未记录的公共类。

模块系统防止程序使用和依赖这些实现类，但即使在 Java 17 中增加了更多限制，仍然可以通过使用反射来绕过此保护（尽管允许反射的确切运行时开关在最近的版本中已经改变；请参阅第十二章了解更多详情）。

但是，这样做是不可移植的，因为实现类不能保证存在于所有 Java 实现或所有平台上，并且它们可能会在未来版本中更改或消失。即使你对可移植性不是很在意，使用未记录的类也可能会大大复杂化未来 JDK 版本的升级。

特别需要注意的是 `sun.misc.Unsafe` 类，它提供了许多“不安全”方法，开发者可以利用这些方法绕过 Java 平台的关键限制。无论何种情况下，开发者都不应直接使用 `Unsafe` 类。

实现特定的特性

可移植的代码不能依赖于特定于单个实现的特性。例如，在 Java 的早期年份，Microsoft 发布了一个包含许多额外方法的 Java 运行时系统版本，这些方法不属于规范定义的 Java 平台。任何依赖此类扩展的程序显然无法在其他平台上移植。

实现特定的 bug

正如可移植的代码不得依赖于特定于实现的特性，它也不得依赖于特定于实现的 bug。如果类或方法的行为与规范所述的不同，可移植程序不能依赖于这种行为，因为它可能在不同的平台上有所不同，并且将来的版本可能会修复该 bug，从而阻碍 JDK 的升级。

实现特定的行为

有时不同平台和不同实现会呈现不同的行为，所有这些行为都符合 Java 规范的要求。可移植的代码不能依赖于任何特定的行为。例如，Java 规范没有指示相同优先级的线程是否共享 CPU，或者一个长时间运行的线程是否可以饿死同一优先级的另一个线程。如果应用程序假定其中一种行为，可能无法在所有平台上正确运行。

定义系统类

可移植的 Java 代码永远不会尝试在系统或标准扩展包中定义类。这样做违反了这些包的保护边界，并暴露了包可见的实现细节，即使在模块系统不禁止的情况下，也是如此。

硬编码的文件名

可移植程序不包含硬编码的文件或目录名。这是因为不同的平台有着显著不同的文件系统组织和不同的目录分隔符字符。如果需要处理文件或目录，应该让用户指定文件名，或者至少指定基本目录，在运行时、配置文件或程序的命令行参数中进行规范。在将文件或目录名称连接到目录名称时，应使用 `File()` 构造函数、`File.separator` 常量或 `Path.of()` 方法。

行分隔符

不同系统使用不同字符或字符序列作为行分隔符。不要在程序中硬编码 `\n`、`\r` 或 `\r\n` 作为行分隔符。相反，使用 `PrintStream` 或 `PrintWriter` 的 `println()` 方法，该方法会自动以适合平台的行分隔符终止行，或使用 `line.separator` 系统属性的值。您还可以使用 `java.util.Formatter` 及其相关类的 `printf()` 和 `format()` 方法中的 “%n” 格式字符串。

# 摘要

在本章中，我们看到了关于命名 Java 代码部分的标准约定。虽然语言允许超出这些约定的许多内容，但遵循这些约定的代码将更容易让其他人阅读和理解。

良好的文档是创建可维护系统的核心。`javadoc` 工具允许我们在代码中编写大部分文档，保持文档与代码的关联性。各种文档标签可生成清晰一致的文档。

JVM 的吸引力之一是它在许多操作系统和硬件类型上的广泛安装基础。然而，如果您在几个方面不注意，可能会损害应用程序的可移植性，因此本章回顾了围绕其中最典型的障碍的指导方针以避免出错。

接下来，我们将看一下 Java 标准库中最常用的部分之一：集合。
