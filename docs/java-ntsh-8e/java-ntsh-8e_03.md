# 第二章。从基础开始的 Java 语法

本章内容较为密集，但应提供 Java 语法的全面介绍。主要面向对该语言新手，但具有一定编程经验的读者。对于没有任何编程经验的决心新手，也可能会发现它有用。如果你已经了解 Java，你会发现它是一个有用的语言参考。本章还包括一些将 Java 与 JavaScript、C 和 C++进行比较的内容，以帮助那些来自这些语言的程序员。

本章从 Java 语法的最低级别开始，逐步构建并移向越来越高层次的结构，来记录 Java 程序的语法。涵盖内容包括：

+   用于编写 Java 程序的字符及其编码方式。

+   Java 程序中包含的字面值、标识符和其他标记。

+   Java 可以操作的数据类型。

+   Java 中用于将单个标记组合成较大表达式的运算符。

+   语句，将表达式和其他语句分组形成 Java 代码的逻辑块。

+   方法，是可以被其他 Java 代码调用的命名 Java 语句集合。

+   类，是方法和字段的集合。类是 Java 中的中心程序元素，并且构成面向对象编程的基础。第三章完全专注于讨论类和对象。

+   包，是相关类的集合。

+   Java 程序由一个或多个相互作用的类组成，这些类可以来自一个或多个包。

大多数编程语言的语法都很复杂，Java 也不例外。一般而言，不可能在不涉及尚未讨论的其他元素的情况下记录语言的所有元素。例如，不可能真正有意义地解释 Java 支持的运算符和语句而不涉及对象。但也不可能在不涉及语言的运算符和语句的情况下彻底记录对象。因此，学习 Java 或任何语言的过程是一个迭代的过程。

# 自上而下的 Java 程序

在我们开始自底向上探索 Java 语法之前，让我们来了解一下 Java 程序的概述。Java 程序由一个或多个 Java 源代码文件或*编译单元*组成。在本章末尾附近，我们描述了 Java 文件的结构，并解释了如何编译和运行 Java 程序。每个编译单元以一个可选的`package`声明开头，后跟零个或多个`import`声明。这些声明指定了编译单元将定义名称的命名空间以及编译单元从中导入名称的命名空间。我们将在本章后面再次看到`package`和`import`，详见“包和 Java 命名空间”。

可选的`package`和`import`声明后面可以跟零个或多个引用类型定义。我们将在第三章和第四章中详细介绍可能的引用类型，但现在需要注意的是，这些类型通常是`class`或`interface`定义之一。

在引用类型的定义中，我们将遇到*成员*，例如*字段*、*方法*和*构造函数*。方法是最重要的成员类型。方法是由*语句*组成的 Java 代码块。

通过定义这些基本术语，让我们从底层向上探索 Java 程序，通过检查*词法标记*的基本语法单元开始。

# 词法结构

本节解释了 Java 程序的词法结构。它从编写 Java 程序的 Unicode 字符集讨论开始。然后，它涵盖了组成 Java 程序的标记，解释了注释、标识符、保留字、字面量等内容。

## Unicode 字符集

Java 程序使用 Unicode 编写。您可以在 Java 程序的任何地方使用 Unicode 字符，包括注释和标识符（如变量名）。与仅对英语有用的 7 位 ASCII 字符集以及仅对主要西欧语言有用的 8 位 ISO Latin-1 字符集不同，Unicode 字符集可以表示几乎全球所有通用的书面语言。

###### 提示

如果您不使用支持 Unicode 的文本编辑器，或者不想强迫查看或编辑您代码的其他程序员使用支持 Unicode 的编辑器，您可以使用特殊的 Unicode 转义序列`\u*xxxx*`将 Unicode 字符嵌入到 Java 程序中——即反斜杠和小写 u，后跟四个十六进制字符。例如，`\u0020`是空格字符，`\u03c0`是π字符。

Java 在确保其 Unicode 支持一流的情况下投入了大量时间和工程努力。如果您的业务应用程序需要处理全球用户，特别是非西方市场的用户，那么 Java 平台是一个很好的选择。此外，Java 还支持多种编码和字符集，以便与不支持 Unicode 的非 Java 应用程序进行交互。

## 大小写敏感性和空白字符

Java 是大小写敏感的语言。它的关键字以小写形式编写并且必须始终使用。也就是说，`While`和`WHILE`与`while`关键字不同。同样，如果您在程序中声明了一个名为`i`的变量，您不能将其称为`I`。

###### 提示

总的来说，依赖大小写敏感性来区分标识符是一个糟糕的主意。标识符越相似，代码的可读性和理解难度就越大。不要在自己的代码中使用它，特别是不要给一个关键字相同但大小写不同的标识符。

Java 忽略空格、制表符、换行符和其他空白字符，除非它们出现在引号字符和字符串字面值内。程序员通常使用空白字符来格式化和缩进他们的代码以便于阅读，但这不会像 Python 中的缩进那样影响程序的行为。您将在本书的代码示例中看到常见的缩进约定。

## 注释

注释是为程序的人类读者而设计的自然语言文本。它们被 Java 编译器忽略。Java 支持三种类型的注释。第一种类型是单行注释，以字符 `//` 开始，并延续至当前行的结尾。例如：

```java
int i = 0;   // Initialize the loop variable
```

第二种类型的注释是多行注释。它以字符 `/*` 开始，并在任意行数后续续，直到字符 `*/`。`javac` 忽略 `/*` 和 `*/` 之间的任何文本。虽然这种注释风格通常用于多行注释，但也可以用于单行注释。这种类型的注释不能嵌套（即一个 `/* */` 注释不能出现在另一个注释内）。编程人员在编写多行注释时经常使用额外的 `*` 字符来使注释突出显示。这是一个典型的多行注释示例：

```java
/*
 * First, establish a connection to the server.
 * If the connection attempt fails, quit right away.
 */
```

第三种类型的注释是第二种的特例。如果一个注释以 `/**` 开头，它被视为特殊的*文档注释*。与常规的多行注释类似，文档注释以 `*/` 结尾，不能嵌套。当你编写一个希望其他程序员使用的 Java 类时，提供文档注释以将关于类及其每个方法的文档直接嵌入源代码中。一个名为 `javadoc` 的程序会提取这些注释并处理它们以创建类的在线文档。文档注释可以包含 HTML 标签，并且可以使用 `javadoc` 理解的额外语法。例如：

```java
/**
 * Upload a file to a web server.
 *
 * @param file The file to upload.
 * @return <tt>true</tt> on success,
 *         <tt>false</tt> on failure.
 * @author David Flanagan
 */
```

更多关于文档注释语法的信息请参见第七章，更多关于 `javadoc` 程序的信息请参见第十三章。

注释可以出现在 Java 程序的任何标记之间，但不能出现在标记内部。特别是，注释不能出现在双引号字符串字面值内。字符串字面值内的注释简单地成为该字符串的字面部分。

## 保留字

下列单词在 Java 中是保留的（它们是语言的语法的一部分，不能用于变量名、类名等）：

```java
abstract   const      final        int         public        throw
assert     continue   finally      interface   return        throws
boolean    default    float        long        short         transient
break      do         for          native      static        true
byte       double     goto         new         strictfp      try
case       else       if           null        super         void
catch      enum       implements   package     switch        volatile
char       extends    import       private     synchronized  while
class      false      instanceof   protected   this
_ (underscore)
```

其中，`true`、`false` 和 `null` 在技术上是字面值。

请注意 `const` 和 `goto` 虽然被保留但实际上在语言中并未使用，而 `interface` 有一个额外的变体形式——`@interface`，用于定义称为注解的类型。一些保留字（特别是 `final` 和 `default`）根据上下文有多种含义。

还有其他一些关键字不是通常的保留字，被称为*上下文关键字*。

```java
exports      opens      requires     uses
module       permits    sealed       var
non-sealed   provides   to           with
open         record     transitive   yield
```

`var`表示应该进行类型推断的局部变量。在定义类时使用`sealed`、`non-sealed`和`record`，我们将在第三章中遇到。`yield`出现在稍后本章中将遇到的`switch`表达式中，而其他上下文关键字涉及模块，其语法和用法在第十二章中有详细介绍。

###### 警告

尽管允许使用上下文关键字作为变量名，但不建议这样做。`var var = "var";`可能是一个有效的语句，但是这是一个应该引起怀疑的有效语句。

## 标识符

*标识符*只是 Java 程序中某部分（如类、类内方法或方法内声明的变量）的名称。标识符可以任意长度，并且可以包含来自整个 Unicode 字符集的字母和数字。标识符不能以数字开头。

一般情况下，标识符不能包含标点符号字符。例外包括美元符号（`$`）以及其他 Unicode 货币符号，如`£`和`¥`。

###### 提示

货币符号用于自动生成的源代码，例如`javac`生成的代码。通过避免在您自己的标识符中使用货币符号，您就不必担心与自动生成的标识符发生冲突。

ASCII 下划线（`_`）也值得特别提及。最初，下划线可以自由地用作标识符或其一部分。然而，在包括 Java 17 在内的最新版本中，下划线不能作为标识符使用。

下划线字符仍然可以出现在 Java 标识符中，但不能再单独作为完整的标识符合法存在。这是为了支持即将推出的语言特性，其中下划线将获得新的特殊语法意义。

通常的 Java 约定是使用*驼峰命名法*命名变量。这意味着变量的第一个字母应小写，但标识符中其他单词的第一个字母应大写。

正式地说，标识符的起始和内部允许的字符由`java.lang.Character`类的`isJavaIdentifierStart()`和`isJavaIdentifierPart()`方法定义。

以下是合法标识符的示例：

```java
i    x1    theCurrentTime    current    獺
```

特别注意 UTF-8 标识符的例子，`獺`。这是表示“水獭”的汉字字符，作为 Java 标识符完全合法。在主要由西方人编写的程序中使用非 ASCII 标识符是不寻常的，但有时会见到。

## 字面量

字面量是源代码中直接表示常量值的源字符序列。它们包括整数和浮点数、单引号内的单个字符、双引号内的字符序列，以及保留字`true`、`false`和`null`。例如，以下都是字面量：

```java
1    1.0    '1'    1L    "one"    true    false    null
```

表达数字、字符和字符串字面值的语法在“原始数据类型”中详细说明。

## 标点符号

Java 还使用一些标点符号字符作为标记。Java 语言规范将这些字符（有些是任意的）分为两类，分隔符和操作符。这 12 种分隔符包括：

| `( )` | `{ }` | `[ ]` |  |
| --- | --- | --- | --- |
| `...` | `@` | `::` |  |
| `;` | `,` | `.` |  |

操作符包括：

| `+` | `—` | `*` | `/` | `%` | `&` | `&#124;` | `^` | `<<` | `>>` | `>>>` |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| `+=` | `-=` | `*=` | `/=` | `%=` | `&=` | `&#124;=` | `^=` | `<<=` | `>>=` | `>>>=` |
| `=` | `==` | `!=` | `<` | `<=` | `>` | `>=` |  |  |  |  |
| `!` | `~` | `&&` | &#124;&#124; | `++` | `--` | `?` | `:` | `->` |  |  |

我们会在全书中看到分隔符，并且会在“表达式和操作符”中单独介绍每个操作符。

# 原始数据类型

Java 支持八种基本数据类型，称为*原始类型*，如表 2-1 所述。原始类型包括布尔类型、字符类型、四种整数类型和两种浮点类型。这四种整数类型和两种浮点类型在表示它们的位数和因此它们可以表示的数字范围上有所不同。请注意，这些类型的大小是 Java 语言中的概念大小。由于填充、对齐等原因，不同的 JVM 实现可能使用更多的实际空间来保存这些值。

表 2-1\. Java 原始数据类型

| 类型 | 包含 | 默认 | 大小 | 范围 |
| --- | --- | --- | --- | --- |
| `boolean` | `true` or `false` | `false` | 1 位 | NA |
| `char` | Unicode 字符 | `\u0000` | 16 位 | `\u0000` 到 `\uFFFF` |
| `byte` | 有符号整数 | 0 | 8 位 | –128 到 127 |
| `short` | 有符号整数 | 0 | 16 位 | –32768 到 32767 |
| `int` | 有符号整数 | 0 | 32 位 | –2147483648 到 2147483647 |
| `long` | 有符号整数 | 0 | 64 位 | –9223372036854775808 到 9223372036854775807 |
| `float` | IEEE 754 浮点数 | 0.0 | 32 位 | 1.4E–45 到 3.4028235E+38 |
| `double` | IEEE 754 浮点数 | 0.0 | 64 位 | 4.9E–324 到 1.7976931348623157E+308 |

下一节总结了这些原始数据类型。除了这些原始类型外，Java 还支持称为引用类型的非原始类型，这些类型在“引用类型”中介绍。

## 布尔类型

`boolean` 类型代表真值。这种类型只有两个可能的值，表示两个布尔状态：开启或关闭，是或否，真或假。Java 保留了 `true` 和 `false` 用于表示这两个布尔值。

从其他语言（特别是 JavaScript、Python 或 C）转到 Java 的程序员应该注意，Java 对其布尔值要求比其他语言严格得多；特别是，`boolean`既不是整数类型也不是对象类型，不兼容的值不能用于`boolean`的位置。换句话说，在 Java 中不能像以下示例中那样使用捷径：

```java
Object o = new Object();
int i = 1;

if (o) {     // Invalid!
  while(i) {
    //...
  }
}
```

Java 要求您通过明确声明想要的比较来编写更清晰的代码：

```java
if (o != null) {
  while(i != 0) {
    // ...
  }
}
```

## 字符类型

`char` 类型表示 Unicode 字符。Java 在表示字符方面有着略微独特的方法—`javac`接受输入时将标识符和字面值作为 UTF-8（一种可变宽度编码）。然而，在内部，Java 以固定宽度编码表示字符—​在 Java 9 之前是 16 位编码，在 Java 9 及以后可能是 ISO-8859-1（一种用于西欧语言的 8 位编码，也称为 Latin-1）。

外部和内部表示之间的区别通常不需要开发人员关注。在大多数情况下，只需记住这条规则即可：要在 Java 程序中包含字符字面值，只需将其放在单引号（撇号）之间：

```java
char c = 'A';
```

当然，您可以使用 `\u` Unicode 转义序列将 Unicode 字符作为字符字面值。此外，Java 还支持许多其他转义序列，使得表示常用的非打印 ASCII 字符（如 `newline`）以及转义某些在 Java 中具有特殊含义的标点字符变得更加容易。例如：

```java
char tab = '\t', nul = '\000', aleph = '\u05D0', backslash = '\\';
```

表 2-2 列出了可以在 `char` 字面值中使用的转义字符。这些字符也可以用于字符串字面值，这将在下一节中介绍。

表 2-2\. Java 转义字符

| 转义序列 | 字符值 |
| --- | --- |
| `\b` | 退格符 |
| `\t` | 水平制表符 |
| `\n` | 换行符 |
| `\f` | 换页符 |
| `\r` | 回车符 |
| `\`" | 双引号 |
| `\`' | 单引号 |
| `\\` | 反斜杠 |
| `\*xxx*` | 使用编码为 *`xxx`* 的 Latin-1 字符，其中 *`xxx`* 是一个在 000 到 377 之间的八进制（基数为 8）数字。形式 *`\x`* 和 *`\xx`* 也是合法的，如 *`\0`*，但不建议使用，因为它们可能在字符串常量中引起困扰，后面跟随的是普通数字。一般不推荐此形式，而是更倾向于使用 `\uXXXX` 形式。 |
| `\u*xxxx*` | 使用编码为 *`xxxx`* 的 Unicode 字符，其中 *`xxxx`* 是四位十六进制数字。Unicode 转义可以出现在 Java 程序的任何位置，不仅限于字符和字符串字面值中。 |

`char`值可以与各种整数类型相互转换，`char`数据类型是 16 位整数类型。但与`byte`、`short`、`int`和`long`不同，`char`是无符号类型，只能接收 0 到 65535 范围内的值。`Character`类定义了一些有用的静态方法，用于处理字符，包括`isDigit()`、`isJavaLetter()`、`isLowerCase()`和`toUpperCase()`。

Java 语言及其`char`类型是以 Unicode 为基础设计的。然而，Unicode 标准在不断发展，每个新版本的 Java 都会采用新版本的 Unicode。Java 11 使用 Unicode 10.0.0，Java 17 使用 Unicode 13.0。

近期 Unicode 版本的复杂之处在于引入了一些字符，其编码或*代码点*不适合 16 位。这些补充字符大多是罕见使用的汉字，占用 21 位，无法用单个`char`值表示。相反，您必须使用一个`int`值来保存补充字符的代码点，或者使用所谓的“代理对”来编码成两个`char`值。

除非您经常编写使用亚洲语言的程序，否则不太可能遇到任何补充字符。如果您预计要处理不适合`char`的字符，已向`Character`、`String`及相关类添加了方法，用于使用`int`代码点处理文本。

### 字符串字面量

除了`char`类型外，Java 还有一种用于处理文本字符串的数据类型（通常简称为*字符串*）。`String`类型是一个类，而不是语言的基本类型之一。然而，由于字符串被广泛使用，Java 确实有语法可以在程序中直接包含字符串值。`String`字面量由双引号中的任意文本组成（与`char`字面量的单引号相对）。例如：

```java
"Hello World"
"'This' is a string!"
```

Java 的最新版本还引入了一种称为*文本块*的多行字符串字面量语法。文本块以`"""`和换行符开头，当看到另一个`"""`序列时结束。这些由`javac`编译器完全处理，并且在字节码中与普通`"`字符串字面量相同。

```java
"""
Multi-line text blocks
Can use "double quotes" without escaping
"""
```

字符串字面量可以包含任何作为`char`字面量出现的转义序列（参见表 2-2）。使用`\\"`序列在标准`String`字面量中包含双引号。文本块允许使用这些转义序列，但在换行符或双引号时不需要它们。

因为`String`是引用类型，字符串字面量将在本章后面的“字符串字面量”中详细描述。第九章详细介绍了在 Java 中处理`String`对象的一些方法。

## 整数类型

Java 中的整数类型是`byte`、`short`、`int`和`long`。如表 2-1 所示，这四种类型仅在位数和因此在每种类型可以表示的数字范围方面有所不同。所有整数类型都表示有符号数；与 C 和 C++中的`unsigned`关键字不同。

对于每种类型的字面量，它们的写法与你期望的完全相同：一系列十进制数字，可选地以减号开头。^(1)这些字面量中的数字可以用下划线(`_`)分隔以提高可读性。以下是一些合法的整数字面量：

```java
0
1
123
9_000
-42000
```

整数字面量是 32 位值（因此被视为 Java 类型`int`），除非它们以字符`L`或`l`结尾，此时它们是 64 位值（并被理解为 Java 类型`long`）：

```java
1234        // An int value
1234L       // A long value
0xffL       // Another long value
```

整数字面量也可以用十六进制、二进制或八进制表示法表示。以`0x`或`0X`开头的字面量被视为十六进制数，使用字母`A`到`F`（或`a`到`f`）作为基数为 16 的数字所需的额外数字。

二进制整数字面量以`0b`开头，当然，只能包含数字 1 或 0。二进制字面量中使用下划线分隔符是非常常见的，因为二进制字面量可以非常长。

Java 还支持八进制（基数为 8）整数字面量。这些字面量以前导`0`开头，不能包括数字 8 或 9。它们并不经常使用，除非需要，应该避免使用。合法的十六进制、二进制和八进制字面量包括：

```java
0xff              // Decimal 255, expressed in hexadecimal
0377              // The same number, expressed in octal (base 8)
0b0010_1111       // Decimal 47, expressed in binary
0xCAFEBABE        // A magic number used to identify Java class files
```

当超出给定整数类型的范围时，Java 中的整数运算永远不会产生溢出或下溢。相反，数字会简单地循环。例如，让我们看一个溢出的例子：

```java
byte b1 = 127, b2 = 1;        // Largest byte is 127
byte sum = (byte)(b1 + b2);   // Sum wraps to -128, the smallest byte
```

以及相应的下溢行为：

```java
byte b3 = -128, b4 = 5;        // Smallest byte is -128
byte sum2 = (byte)(b3 - b4);   // Sum wraps to a large byte value, 123
```

当发生这种情况时，Java 编译器和 Java 解释器都不会以任何方式警告你。在进行整数运算时，你必须确保所使用的类型对你打算的目的具有足够的范围。整数除以零和模零是非法的，并导致抛出`ArithmeticException`。（我们很快将在“已检查和未检查的异常”中详细了解更多异常）。

每种整数类型都有一个对应的包装类：`Byte`、`Short`、`Integer`和`Long`。每个这些类都定义了`MIN_VALUE`和`MAX_VALUE`常量来描述该类型的范围。每个类还提供了一个静态的`valueOf()`方法，强烈建议使用该方法从原始值创建包装类的实例。虽然包装类具有接受原始类型的普通构造函数，但它们已被弃用，应避免使用。包装类还定义了一些有用的静态方法，如`Byte.parseByte()`和`Integer.parseInt()`，用于将字符串转换为整数值。

## 浮点类型

在 Java 中，实数由`float`和`double`数据类型表示。如表 2-1 所示，`float`是 32 位单精度浮点值，而`double`是 64 位双精度浮点值。这两种类型都遵循 IEEE 754-1985 标准，该标准指定了数字的格式以及数字的算术行为。

浮点值可以直接作为 Java 程序中的可选数字字符串包含，后面跟着小数点和另一个数字字符串。以下是一些示例：

```java
123.45
0.0
.01
```

浮点文字面量还可以使用指数或科学表示法，其中一个数字后跟着字母`e`或`E`（指数），然后是另一个数字。第二个数字表示第一个数字乘以的 10 的幂。例如：

```java
1.2345E02    // 1.2345 * 10² or 123.45
1e-6         // 1 * 10^-6 or 0.000001
6.02e23      // Avogadro's Number: 6.02 * 10²³
```

浮点文字面量默认为`double`值。要在程序中直接包含`float`值，请在数字后面跟上`f`或`F`：

```java
double d = 6.02E23;
float f = 6.02e23f;
```

浮点文字面量不能用十六进制、二进制或八进制表示。

除了表示普通数字外，`float`和`double`类型还可以表示四个特殊值：正无穷大、负无穷大、零和 NaN。当浮点计算产生超出`float`或`double`可表示范围的值时，会得到无穷大值。

当浮点计算下溢到`float`或`double`的可表示范围时，将得到零值。

###### 注意

我们可以想象重复地将双精度值`1.0`除以`2.0`（例如，在`while`循环中）。在数学上，无论我们进行多少次除法，结果永远不会变成零。然而，在浮点表示中，经过足够多的除法之后，结果最终会变得非常小，以至于与零几乎无法区分。

Java 浮点类型区分正零和负零，具体取决于下溢发生的方向。实际上，正零和负零的行为几乎相同。最后，最后一个特殊浮点值是 NaN，表示“不是一个数字”。当执行非法浮点操作（例如 0.0/0.0）时，将得到 NaN 值。以下是导致这些特殊值的语句示例：

```java
double inf = 1.0/0.0;             // Infinity
double neginf = -1.0/0.0;         // Negative infinity
double negzero = -1.0/inf;        // Negative zero
double NaN = 0.0/0.0;             // Not a Number
```

`float`和`double`原始类型有相应的类，名为`Float`和`Double`。每个类定义了以下有用的常量：`MIN_VALUE`、`MAX_VALUE`、`NEGATIVE_INFINITY`、`POSITIVE_INFINITY`和`NaN`。与整数包装类类似，浮点包装类也有一个用于构造实例的静态`valueOf()`方法。

###### 注意

Java 浮点类型可以处理溢出到无穷大和下溢到零以及具有特殊 NaN 值的情况。这意味着浮点算术永远不会抛出异常，即使执行非法操作，如零除以零或对负数取平方根。

无限浮点值的行为如预期。例如，将任何有限值加或减无穷大将得到无穷大。负零的行为与正零几乎相同，事实上，`==`等号操作符报告负零等于正零。区分负零和正常零的一种方法是通过除以它来进行：`1.0/0.0`得到正无穷大，但`1.0`除以负零得到负无穷大。最后，因为 NaN 不是一个数字，`==`操作符表明它与任何其他数字（包括自身）都不相等！

```java
double NaN = 0.0/0.0;             // Not a Number
NaN == NaN;                       // false
Double.isNaN(NaN);                // true
```

要检查`float`或`double`值是否为 NaN，必须使用`Float.isNaN()`和`Double.isNaN()`方法。

## 原始类型转换

Java 允许在整数值和浮点值之间进行转换。此外，因为 Unicode 编码中的每个字符对应一个数字，`char`值可以在整数和浮点类型之间转换。事实上，`boolean`是 Java 中唯一不能转换为其他原始类型或从其他原始类型转换的类型。

有两种基本类型的转换。*扩展转换*是指将一种类型的值转换为更宽的类型，即具有更大合法值范围的类型。例如，当你将`int`字面量分配给`double`变量或`char`字面量分配给`int`变量时，Java 会自动执行扩展转换。

然而，窄化转换是另一回事。*窄化转换*是指将值转换为不比其宽的类型。窄化转换并不总是安全的：例如，将整数值 13 转换为`byte`是合理的，但将 13000 转换为`byte`是不合理的，因为`byte`只能保存在-128 到 127 之间的数字。由于在窄化转换中可能丢失数据，即使要转换的值实际上可以适合指定类型的更窄范围，`javac`也会在尝试任何窄化转换时发出警告：

```java
int i = 13;
// byte b = i;    // Incompatible types: possible lossy conversion
                  // from int to byte
```

唯一的例外是，如果字面量在变量的范围内，可以将整数字面量（`int`值）分配给`byte`或`short`变量。

```java
byte b = 13;
```

如果需要执行窄化转换并且确信不会丢失数据或精度，可以使用称为*强制转换*的语言结构强制 Java 执行转换。通过在要转换的值之前在括号中放置所需类型的名称来执行转换。例如：

```java
int i = 13;
byte b = (byte) i;   // Force the int to be converted to a byte
i = (int) 13.456;    // Force this double literal to the int 13
```

原始类型的强制转换通常用于将浮点值转换为整数。这样做时，浮点值的小数部分会被简单截断（即浮点值向零舍入，而不是向最接近的整数舍入）。静态方法`Math.round()`、`Math.floor()`和`Math.ceil()`执行其他类型的舍入。

`char` 类型在大多数情况下像整数类型，因此 `char` 值可以在需要 `int` 或 `long` 值的任何地方使用。然而，请记住，`char` 类型是 *无符号* 的，因此它与 `short` 类型行为不同，即使两者都是 16 位宽度：

```java
short s = (short) 0xffff; // These bits represent the number -1
char c = '\uffff';        // The same bits, as a Unicode character
int i1 = s;               // Converting the short to an int yields -1
int i2 = c;               // Converting the char to an int yields 65535
```

表格 2-3（#javanut8-CHP-2-TABLE-3）显示了哪些基本类型可以转换为哪些其他类型以及转换的执行方式。表中的字母 N 表示无法执行转换。字母 Y 表示这是一种自动扩展转换，因此 Java 会自动隐式执行。字母 C 表示这是一种缩小转换，需要显式转换。

最后，Y* 表示转换为自动扩展转换，但在转换过程中可能会丢失一些最低有效位数。当你将 `int` 或 `long` 转换为浮点类型时会发生这种情况——详细信息请参见表格。浮点类型的范围比整数类型更大，因此任何 `int` 或 `long` 都可以被表示为 `float` 或 `double`。然而，浮点类型是数字的近似值，不能始终保存与整数类型一样多的有效位数（详见第九章关于浮点数的详细信息）。

表 2-3\. Java 基本类型转换

|   | 转换为: |   |   |   |   |   |   |   |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 从以下类型转换: | `boolean` | `byte` | `short` | `char` | `int` | `long` | `float` | `double` |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| `boolean` | - | N | N | N | N | N | N | N |
| `byte` | N | - | Y | C | Y | Y | Y | Y |
| `short` | N | C | - | C | Y | Y | Y | Y |
| `char` | N | C | C | - | Y | Y | Y | Y |
| `int` | N | C | C | C | - | Y | Y* | Y |
| `long` | N | C | C | C | C | - | Y* | Y* |
| `float` | N | C | C | C | C | C | - | Y |
| `double` | N | C | C | C | C | C | C | - |

# 表达式和运算符

到目前为止，在本章中，我们已经了解了 Java 程序可以操作的基本类型，并看到如何将基本值作为 *字面值* 包含在 Java 程序中。我们还使用了 *变量* 作为表示或保存值的符号名称。这些字面值和变量是构成 Java 程序的标记。

*表达式* 是 Java 程序中的下一个更高级的结构。Java 解释器 *评估* 表达式以计算其值。最简单的表达式称为 *主表达式*，由字面值和变量组成。因此，例如以下都是表达式：

```java
1.7         // A floating-point literal
true        // A Boolean literal
sum         // A variable
```

当 Java 解释器评估字面表达式时，结果值是字面本身。当解释器评估变量表达式时，结果值是变量中存储的值。

主要表达式并不是很有趣。通过使用*运算符*来组合主要表达式可以创建更复杂的表达式。例如，以下表达式使用赋值运算符将两个主要表达式——一个变量和一个浮点数文字——组合成一个赋值表达式：

```java
sum = 1.7
```

但是运算符不仅与主要表达式一起使用；它们还可以与任何复杂程度的表达式一起使用。以下都是合法的表达式：

```java
sum = 1 + 2 + 3 * 1.2 + (4 + 8)/3.0
sum/Math.sqrt(3.0 * 1.234)
(int)(sum + 33)
```

## 运算符摘要

编程语言中可以编写的表达式种类完全取决于您可用的运算符集合。Java 拥有丰富的运算符，但要有效地使用它们，您必须理解两个重要的概念：*优先级*和*结合性*。这些概念以及运算符本身将在以下章节中更详细地解释。

### 优先级

表格 2-4 的 P 列指定了每个运算符的*优先级*。优先级指定了操作执行的顺序。具有更高优先级的操作会在具有较低优先级的操作之前执行。例如，考虑这个表达式：

```java
a + b * c
```

乘法运算符的优先级高于加法运算符，因此`a`加上`b`和`c`的乘积，正如我们从初等数学中期望的那样。运算符优先级可以被视为运算符与其操作数绑定得有多紧密的度量。数字越高，绑定得越紧。

通过使用明确指定操作顺序的括号，可以覆盖默认的运算符优先级。前述表达式可以被重写为指定加法应在乘法之前执行：

```java
(a + b) * c
```

Java 中的默认运算符优先级是为了与 C 兼容而选择的；C 的设计者选择了这种优先级，以便大多数表达式可以自然地写成而不需要括号。只有少数常见的 Java 习语需要括号。例如：

```java
// Class cast combined with member access
((Integer) o).intValue();

// Assignment combined with comparison
while((line = in.readLine()) != null) { ... }

// Bitwise operators combined with comparison
if ((flags & (PUBLIC | PROTECTED)) != 0) { ... }
```

### 结合性

结合性是运算符的一个属性，定义了如何评估本来会产生歧义的表达式。当表达式涉及多个具有相同优先级的运算符时，这一点尤为重要。

大多数运算符都是从左到右结合的，这意味着操作是从左到右执行的。然而，赋值和一元运算符具有从右到左的结合性。表格 2-4 的 A 列指定了每个运算符或运算符组的结合性。值 L 表示从左到右，值 R 表示从右到左。

加法运算符都是从左到右结合的，因此表达式`a+b-c`从左到右进行评估：`(a+b)-c`。一元运算符和赋值运算符从右到左进行评估。考虑这个复杂表达式：

```java
a = b += c = -~d
```

这被如下评估：

```java
a = (b += (c = -(~d)))
```

操作符的结合性与操作符优先级一样，为表达式的默认评估顺序建立了一个默认顺序。可以通过使用括号来覆盖这个默认顺序。然而，在 Java 中，默认的操作符结合性被选择为产生自然的表达式语法。

### 操作符总结表

表格 2-4 总结了 Java 中可用的操作符。表格中的 P 和 A 列指定了每组相关操作符的优先级和结合性。表格按优先级从高到低排序。在需要时，可以将此表格作为操作符（尤其是它们的优先级）的快速参考。

表 2-4\. Java 操作符

| P | A | 操作符 | 操作数类型 | 执行的操作 |
| --- | --- | --- | --- | --- |
| --- | --- | --- | --- | --- |
| 16 | L | . | object, member | 对象成员访问 |
|  |  | `[ ]` | array, int | 数组元素访问 |
|  |  | `( *args* )` | method, arglist | Method invocation |
|  |  | `++`, `--` | variable | 后增量，后减量 |
| 15 | R | `++`, `--` | variable | 前增量，前减量 |
|  |  | `+`, `-` | number | 一元加，一元减 |
|  |  | `~` | integer | 位取反 |
|  |  | `!` | boolean | Boolean NOT |
| 14 | R | `new` | class, arglist | 对象创建 |
|  |  | `( *type* )` | type, any | 强制类型转换 |
| 13 | L | `*`, `/`, `%` | number, number | 乘法，除法，求余 |
| 12 | L | `+`, `-` | number, number | 加法，减法 |
|  |  | `+` | string, any | 字符串连接 |
| 11 | L | `<<` | integer, integer | 左移 |
|  |  | `>>` | integer, integer | 带符号右移 |
|  |  | `>>>` | integer, integer | 无符号右移 |
| 10 | L | `<`, `<=` | number, number | 小于，小于等于 |
|  |  | `>`, `>=` | number, number | 大于，大于等于 |
|  |  | `instanceof` | reference, type | Type comparison |
| 9 | L | `==` | primitive, primitive | 等于（具有相同的值） |
|  |  | `!=` | primitive, primitive | 不等于（具有不同的值） |
|  |  | `==` | reference, reference | 等于（引用同一对象） |
|  |  | `!=` | reference, reference | 不等于（引用不同对象） |
| 8 | L | `&` | integer, integer | 位与 |
|  |  | `&` | boolean, boolean | 布尔与 |
| 7 | L | `^` | integer, integer | 位异或 |
|  |  | `^` | boolean, boolean | 布尔异或 |
| 6 | L | `ǀ` | integer, integer | 位或 |
|  |  | `ǀ` | boolean, boolean | 布尔或 |
| 5 | L | `&&` | boolean, boolean | 条件与 |
| 4 | L | `ǀǀ` | boolean, boolean | 条件或 |
| 3 | R | `? :` | boolean, any | 条件（三元）操作符 |
| 2 | R | `=` | variable, any | 赋值 |
|  |  | `*=`, `/=`, `%=`, | variable, any | Assignment with operation |
|  |  | `+=`, `-=`, `<<=`, |  |  |
|  |  | `>>=`, `>>>=`, |  |  |
|  |  | `&=`, `^=`, `ǀ=` |  |  |
| 1 | R | `→` | arglist, method body | lambda expression |

### 操作数的数量和类型

表格 2-4 的第四列指定了每个运算符期望的操作数的数量和类型。有些运算符仅作用于一个操作数；这些被称为一元运算符。例如，一元减号运算符改变单个数字的符号：

```java
-n             // The unary minus operator
```

大多数运算符都是二元运算符，操作两个操作数的值。减号`–`运算符实际上有两种形式：

```java
a – b          // The subtraction operator is a binary operator
```

Java 还定义了一个三元运算符，通常称为条件运算符。它类似于表达式中的`if`语句。它的三个操作数由问号和冒号分隔；第二和第三个操作数必须可以转换为相同的类型：

```java
x > y ? x : y  // Ternary expression; evaluates to larger of x and y
```

除了期望特定数量的操作数外，每个运算符还期望特定类型的操作数。表中的第四列列出了操作数类型。该列中使用的一些代码需要进一步解释：

数字

整数、浮点值或字符（即任何原始类型，除了`boolean`）。自动拆箱（参见“装箱和拆箱转换”）意味着这些类型的包装类（如`Character`、`Integer`和`Double`）也可以在此上下文中使用。

整数

`byte`、`short`、`int`、`long`或`char`值（数组访问操作符`[ ]`不允许`long`值）。使用自动拆箱，也可以允许`Byte`、`Short`、`Integer`、`Long`和`Character`值。

引用

一个对象或数组。

变量

变量或其他任何可以分配值的内容，如数组元素。

### 返回类型

就像每个运算符期望其操作数具有特定的类型一样，每个运算符也产生特定类型的值。算术、递增和递减、位和移位运算符中，如果至少有一个操作数是`double`，则返回`double`。如果至少有一个操作数是`float`，则返回`float`。如果至少有一个操作数是`long`，则返回`long`。否则，返回`int`，即使两个操作数都是比`int`更窄的`byte`、`short`或`char`类型。

比较、相等和布尔运算符始终返回`boolean`值。每个赋值运算符返回其分配的值，该值与表达式左侧的变量兼容。条件运算符返回其第二或第三个参数的值（这两个参数必须可以转换为相同的类型）。

### 副作用

每个运算符基于一个或多个操作数的值计算一个值。然而，一些运算符除了基本计算外，还有*副作用*。如果一个表达式包含副作用，评估它会改变 Java 程序的状态，因此再次评估表达式可能会产生不同的结果。

例如，`++`增量运算符具有增加变量的副作用。表达式`++a`增加变量`a`并返回新增后的值。如果再次评估此表达式，则值将不同。各种赋值运算符也具有副作用。例如，表达式`a*=2`也可以写为`a=a*2`。表达式的值是`a`乘以 2 的值，但表达式具有将该值存储回`a`的副作用。

方法调用运算符`()`如果调用的方法具有副作用，则具有副作用。例如`Math.sqrt()`等一些方法仅计算并返回值，没有任何副作用。通常情况下，方法确实具有副作用。最后，`new`运算符具有创建新对象的深远副作用。

### 评估顺序

当 Java 解释器评估表达式时，它根据表达式中括号的顺序、运算符的优先级和运算符的结合性执行各种操作。然而，在执行任何操作之前，解释器首先评估运算符的操作数。（但是，`&&`、`||`和`?`运算符除外，它们并不总是评估所有操作数。）解释器总是按从左到右的顺序评估操作数。如果操作数中有包含副作用的表达式，则这很重要。例如，考虑以下代码：

```java
int a = 2;
int v = ++a + ++a * ++a;
```

虽然乘法在加法之前执行，但`+`运算符的操作数首先被评估。因为`++`的操作数都是`++a`，它们被评估为`3`和`4`，因此表达式评估为`3 + 4 * 5`，即`23`。

## 算术运算符

算术运算符可用于整数、浮点数，甚至字符（即它们可以用于除`boolean`以外的任何基本类型）。如果操作数中有任一操作数是浮点数，则使用浮点数算术；否则，使用整数算术。这很重要，因为整数算术和浮点数算术在执行除法的方式以及处理下溢和上溢的方式等方面有所不同。算术运算符包括：

*加法* (`+`)

`+`运算符添加两个数字。正如我们将很快看到的，`+`运算符也可以用于连接字符串。如果`+`的任一操作数是字符串，则另一个操作数也将转换为字符串。当您希望将加法与连接结合时，请务必使用括号。例如：

```java
System.out.println("Total: " + 3 + 4);   // Prints "Total: 34", not 7!
```

`+`运算符也可以作为一元运算符使用，表示正数，例如`+42`。

*减法* (`-`)

当`-`运算符用作二元运算符时，它将其第二个操作数从第一个操作数中减去。例如，`7-3`的结果为`4`。`-`运算符还可以执行一元否定。

*乘法* (`*`)

`*`运算符将其两个操作数相乘。例如，`7*3`的结果为`21`。

*除法* (`/`)

`/`运算符将其第一个操作数除以第二个操作数。如果两个操作数都是整数，则结果是整数，并且任何余数都会丢失。但是，如果任一操作数是浮点值，则结果是浮点值。当你除以零时，整数除法会抛出`ArithmeticException`。然而，对于浮点数计算，除以零会简单地产生一个无限的结果或`NaN`：

```java
7/3          // Evaluates to 2
7/3.0f       // Evaluates to 2.333333f
7/0          // Throws an ArithmeticException
7/0.0        // Evaluates to positive infinity
0.0/0.0      // Evaluates to NaN
```

*模运算*（`%`）

`%`运算符计算第一个操作数除以第二个操作数的余数（即，当第一个操作数被第二个操作数整除时的余数）。例如，`7%3`为`1`。结果的符号与第一个操作数的符号相同。虽然模运算符通常用于整数操作数，但它也适用于浮点值。例如，`4.3%2.1`评估为`0.1`。当你操作整数时，尝试计算模零的值会导致`ArithmeticException`。当你使用浮点值时，任何值模`0.0`都会评估为`NaN`，正如无穷大模任何值一样。

*一元减号*（`-`）

当`-`运算符用作一元运算符时——即在单个操作数之前时——它执行一元否定。换句话说，它将正值转换为等效的负值，反之亦然。

## 字符串连接运算符

除了添加数字外，`+`运算符（以及相关的`+=`运算符）还可以连接或拼接字符串。如果`+`的任一操作数是字符串，则运算符会将另一个操作数转换为字符串。例如：

```java
// Prints "Quotient: 2.3333333"
System.out.println("Quotient: " + 7/3.0f);
```

因此，在将任何附加表达式与字符串连接时，务必将其放在括号中。如果不这样做，加法运算符将被解释为连接运算符。

Java 为所有基本类型提供了内置的字符串转换。对象通过调用其`toString()`方法转换为字符串。一些类定义了自定义的`toString()`方法，以便可以轻松地将该类的对象转换为字符串。但遗憾的是，并非所有类在转换为字符串时都返回友好的结果。例如，数组的内置`toString()`并不返回其内容的有用字符串表示，而仅返回有关数组对象本身的信息。

## 递增和递减运算符

`++`运算符递增其单个操作数，该操作数必须是变量、数组的元素或对象的字段，递增量为 1。此运算符的行为取决于其相对于操作数的位置。当用于操作数之前时，称为*前递增*运算符，它递增操作数并评估为递增后的值。当用于操作数之后时，称为*后递增*运算符，它递增其操作数但评估为递增前的值。

例如，以下代码将`i`和`j`都设置为 2：

```java
i = 1;
j = ++i;
```

但是，这些行将`i`设置为 2，`j`设置为 1：

```java
i = 1;
j = i++;
```

同样地，`--`运算符将其单个数值操作数递减 1。与`++`运算符类似，`--`的行为取决于其相对于操作数的位置。当在操作数之前使用时，它会递减操作数并返回递减后的值。当在操作数之后使用时，它会递减操作数但返回*未递减*的值。

表达式`x++`和`x--`分别等同于`x = x + 1`和`x = x - 1`，但是当你使用增量和减量运算符时，`x`只计算一次。如果`x`本身是一个具有副作用的表达式，这将产生很大的不同。例如，这两个表达式并不等同，因为第二种形式会使`i`增加两次：

```java
a[i++]++;             // Increments an element of an array

// Adds 1 to an array element and stores new value in another element
a[i++] = a[i++] + 1;
```

这些运算符，无论是前缀还是后缀形式，最常用于增加或减少控制循环计数器。然而，越来越多的程序员更喜欢避免使用增量和减量运算符，而是更喜欢使用显式的代码。这种观点是由于历史上由于操作符的错误使用而导致的大量 bug。

## 比较运算符

比较运算符包括测试值是否相等或不等的相等运算符和与有序类型（数字和字符）一起使用的关系运算符。这两种类型的运算符产生一个`boolean`结果，因此它们通常与`if`语句、三元条件运算符或`while`和`for`循环一起使用，以进行分支和循环决策。例如：

```java
if (o != null) ...;           // The not equals operator
while(i < a.length) ...;      // The less than operator
```

Java 提供以下相等运算符：

*等于* (`==`)

`==`运算符在其两个操作数相等时求值为`true`，否则为`false`。对于原始操作数，它测试操作数值本身是否相同。然而，对于引用类型的操作数，它测试操作数是否引用同一个对象或数组。换句话说，它不测试两个不同的对象或数组的相等性。特别地，请注意，你不能使用此运算符测试两个不同的字符串是否相等。

###### 警告

如果你通过`==`比较字符串，可能会看到结果表明它正常工作。这是 Java 内部字符串缓存的副作用，称为*interning*。比较字符串（或任何其他引用类型）的唯一可靠方法是使用`equals()`方法。

对于基本包装类也是一样的，所以`new Integer(1) != new Integer(1)`，而推荐的`Integer.valueOf(1) == Integer.valueOf(1)`则相等。显然，任何非原始类型的等式比较都应该使用`equals()`方法。关于对象等式的更多讨论可以在`equals()`中找到。

如果使用`==`比较两个不同类型的数值或字符操作数，窄操作数在比较之前会被转换为宽操作数的类型。例如，当你比较一个`short`和一个`float`时，`short`会先转换为`float`再进行比较。对于浮点数，特殊的负零值与常规的正零值相等。此外，特殊的`NaN`（不是一个数字）值不等于任何其他数字，包括自身。要测试浮点数值是否为`NaN`，可以使用`Float.isNan()`或`Double.isNan()`方法。

*不等于* (`!=`)

`!=`运算符与`==`运算符正好相反。如果其两个基本操作数具有不同的值，或者其两个引用操作数引用不同的对象或数组，则评估为`true`。否则，评估为`false`。

关系运算符可以用于数字和字符，但不能用于`boolean`值、对象或数组，因为这些类型没有顺序。

Java 提供以下关系运算符：

*小于* (`<`)

如果第一个操作数小于第二个，则评估为`true`。

*小于或等于* (`<=`)

如果第一个操作数小于或等于第二个，则评估为`true`。

*大于* (`>`)

如果第一个操作数大于第二个，则评估为`true`。

*大于或等于* (`>=`)

如果第一个操作数大于或等于第二个，则评估为`true`。

## 布尔运算符

正如我们刚刚看到的，比较运算符比较它们的操作数，并产生一个`boolean`结果，通常用于分支和循环语句。为了使基于条件的分支和循环决策更有趣，而不仅仅是单个比较，你可以使用布尔（或逻辑）运算符将多个比较表达式组合成一个单一的、更复杂的表达式。布尔运算符要求其操作数为`boolean`值，并评估为`boolean`值。这些运算符包括：

*条件与* (`&&`)

此运算符对其操作数执行布尔 AND 操作。如果且仅当其两个操作数都为`true`时，评估为`true`。如果其中一个或两个操作数为`false`，则评估为`false`。例如：

```java
if (x < 10 && y > 3) ... // If both comparisons are true
```

此运算符（以及所有布尔运算符，除了一元`!`运算符外）的优先级低于比较运算符。因此，像刚刚显示的代码行是完全合法的。但是，一些程序员喜欢使用括号来显式地指定评估顺序：

```java
if ((x < 10) && (y > 3)) ...
```

你应该使用你觉得阅读更容易的风格。

这个运算符称为条件 AND，因为它有条件地评估其第二个操作数。如果第一个操作数评估为`false`，则表达式的值为`false`，无论第二个操作数的值如何。因此，为了提高效率，Java 解释器采取了一种捷径，并跳过第二个操作数。不能保证评估第二个操作数，因此在使用具有副作用的表达式与此运算符时必须小心。另一方面，此运算符的条件性质允许我们编写如下的 Java 表达式：

```java
if (data != null && i < data.length && data[i] != -1)
    ...
```

此表达式中的第二个和第三个比较如果第一个或第二个比较结果为`false`将导致错误。幸运的是，由于`&&`运算符的条件行为，我们不必担心这个问题。

*条件或* (`||`)

这个运算符在其两个`boolean`操作数上执行布尔 OR 操作。如果其任一或两个操作数为`true`，则评估为`true`。如果两个操作数都为`false`，则评估为`false`。与`&&`运算符类似，`||`运算符并不总是评估其第二个操作数。如果第一个操作数评估为`true`，则表达式的值为`true`，无论第二个操作数的值如何。因此，在这种情况下，该运算符简单地跳过第二个操作数。

*布尔非* (`!`)

此一元运算符改变其操作数的`boolean`值。如果应用于`true`值，则评估为`false`，如果应用于`false`值，则评估为`true`。在这些表达式中很有用：

```java
if (!found) ...          // found is a boolean declared somewhere
while (!c.isEmpty()) ... // The isEmpty() method returns a boolean
```

因为`!`是一元运算符，具有很高的优先级，并且通常必须与括号一起使用：

```java
if (!(x > y && y > z))
```

*布尔与* (`&`)

当与`boolean`操作数一起使用时，`&`运算符的行为类似于`&&`运算符，但始终评估两个操作数，而不管第一个操作数的值如何。然而，此运算符几乎总是作为整数操作数的位运算符使用，因此许多 Java 程序员甚至不会认识其在`boolean`操作数中作为合法 Java 代码的使用。

*布尔或* (`|`)

这个运算符在其两个`boolean`操作数上执行布尔 OR 操作。它与`||`运算符类似，但始终评估两个操作数，即使第一个操作数为`true`。`|`运算符几乎总是用作整数操作数的位运算符；在`boolean`操作数中很少见到其使用。

*布尔异或* (`^`)

当与`boolean`操作数一起使用时，此运算符计算其操作数的异或（XOR）。如果两个操作数中恰好一个为`true`，则评估为`true`。换句话说，如果两个操作数都为`false`或者两个操作数都为`true`，则评估为`false`。与`&&`和`||`运算符不同，此运算符必须始终评估两个操作数。`^`运算符在整数操作数中作为位运算符使用得更为常见。对于`boolean`操作数，此运算符等同于`!=`运算符。

## 位运算符和移位运算符

位与移位运算符是操作整数值中构成其个别位的低级运算符。位运算符在现代 Java 中不常用，除非进行低级工作（例如网络编程）。它们用于测试和设置值中的单个标志位。要理解它们的行为，您必须理解用于表示负整数的二进制（基数 2）数和两补码格式。

你不能将这些运算符与浮点、`boolean`、数组或对象操作数一起使用。当与`boolean`操作数一起使用时，`&`、`|`和`^`运算符执行不同的操作，如前一节所述。

如果位运算符的任一参数是`long`，则结果是`long`。否则，结果是`int`。如果位移运算符的左操作数是`long`，则结果是`long`；否则，结果是`int`。这些运算符是：

*位取反*（`~`）

一元`~`运算符称为位取反或位 NOT 运算符。它反转其单个操作数的每个位，将 1 转换为 0，将 0 转换为 1。例如：

```java
byte b = ~12;           // ~00001100 =  => 11110011 or -13 decimal
flags = flags & ~f;     // Clear flag f in a set of flags
```

*位与*（`&`）

该运算符通过对其两个整数操作数的各自位执行布尔 AND 运算来结合它们。只有在两个操作数中的相应位都设置时，结果才具有一个位设置。例如：

```java
10 & 7                   // 00001010 & 00000111 =  => 00000010 or 2
if ((flags & f) != 0)    // Test whether flag f is set
```

当使用`boolean`操作数时，`&`是之前描述的不常用的布尔 AND 运算符。

*位或*（`|`）

该运算符通过对其两个整数操作数的各自位执行布尔 OR 运算来结合它们。如果相应位在一个或两个操作数中被设置，则结果有一个位设置。仅在两个相应操作数位都为零时，它具有零位。例如：

```java
10 | 7                   // 00001010 | 00000111 =  => 00001111 or 15
flags = flags | f;       // Set flag f
```

当与`boolean`操作数一起使用时，`|`是之前描述的不常用的布尔 OR 运算符。

*位异或*（`^`）

该运算符通过对其各自位执行布尔异或（exclusive OR）操作来结合其两个整数操作数的位。如果两个操作数中的对应位不同，则结果具有一个位设置。如果对应的操作数位都是 1 或都是 0，则结果位为 0。例如：

```java
10 ^ 7               // 00001010 ^ 00000111 =  => 00001101 or 13
```

当与`boolean`操作数一起使用时，`^`是很少使用的布尔 XOR 运算符。

*左移*（`<<`）

`<<`运算符将左操作数的位左移右操作数指定的位数。左操作数的高阶位将丢失，并且从右侧移入零位。将整数左移*n*位等效于将该数字乘以 2^(*n*)。例如：

```java
10 << 1    // 0b00001010 << 1 = 00010100 = 20 = 10*2
7 << 3     // 0b00000111 << 3 = 00111000 = 56 = 7*8
-1 << 2    // 0xFFFFFFFF << 2 = 0xFFFFFFFC = -4 = -1*4
           // 0xFFFF_FFFC == 0b1111_1111_1111_1111_1111_1111_1111_1100
```

如果左操作数是`long`，则右操作数应在 0 到 63 之间。否则，左操作数被视为`int`，右操作数应在 0 到 31 之间。如果超出这些范围，则可能会看到这些运算符的不直观的包装行为。

*有符号右移*（`>>`）

`>>` 运算符将左操作数的位向右移动右操作数指定的位数。左操作数的低位位移并丢失。位于左操作数中的高位位移相同于原始左操作数的高位位。换句话说，如果左操作数为正，则将 0 移入高位位。如果左操作数为负，则移入的是 1。这种技术称为*符号扩展*；它用于保留左操作数的符号。例如：

```java
10 >> 1      // 00001010 >> 1 = 00000101 = 5 = 10/2
27 >> 3      // 00011011 >> 3 = 00000011 = 3 = 27/8
-50 >> 2     // 11001110 >> 2 = 11110011 = -13 != -50/4
```

如果左操作数为正，右操作数为 *n*，则 `>>` 运算符与整数除法相同除以 2^(*n*)。

*无符号右移* (`>>>`)

此运算符类似于 `>>` 运算符，但它总是将零移入结果的高阶位，而不管左操作数的符号如何。这种技术称为*零扩展*；当左操作数被视为无符号值时（尽管 Java 整数类型都是有符号的），这是适当的。以下是示例：

```java
0xff >>> 4    // 11111111 >>> 4 = 00001111 = 15  = 255/16
-50 >>> 2     // 0xFFFFFFCE >>> 2 = 0x3FFFFFF3 = 1073741811
```

## 赋值运算符

赋值运算符将值存储或分配到计算机的一部分内存中--通常称为*存储位置*。左操作数必须评估为适当的局部变量，数组元素或对象字段。

###### 注意

赋值表达式的左操作数有时被称为 `*lvalue*`。在 Java 中，它必须引用一些可赋值的存储（即可写入的内存）。

右操作数（`*rvalue*`）可以是与变量兼容的任何类型的值。赋值表达式的评估结果是分配给变量的值。然而，更重要的是，该表达式具有实际执行分配的副作用—将 `rvalue` 存储在 `lvalue` 中。

###### 提示

与所有其他二进制运算符不同，赋值运算符是右关联的，这意味着 `a=b=c` 中的赋值是从右向左执行的，如下所示： `a=(b=c)`。

基本赋值运算符是 `=`。不要将其与相等运算符 `==` 混淆。为了区分这两个运算符，我们建议将 `=` 读作“被赋予值”。

除了这个简单的赋值运算符之外，Java 还定义了另外 11 个将赋值与 5 个算术运算符和 6 个位和移位运算符结合的运算符。例如，`+=` 运算符读取左变量的值，将右操作数的值添加到它中，作为副作用将总和存储回左变量，并返回总和作为表达式的值。因此，表达式 `x+=2` 几乎与 `x=x+2` 相同。这两个表达式之间的区别在于当您使用 `+=` 运算符时，左操作数只被评估一次。当该操作数具有副作用时，这是有区别的。考虑以下两个不等式：

```java
a[i++] += 2;
a[i++] = a[i++] + 2;
```

这些组合赋值运算符的一般形式是：

```java
lvalue op= rvalue
```

这与以下内容等效（除非在 `lvalue` 中存在副作用）：

```java
lvalue = lvalue op rvalue
```

可用的运算符有：

```java
+=    -=    *=    /=    %=    // Arithmetic operators plus assignment

&=    |=    ^=                // Bitwise operators plus assignment

<<=   >>=   >>>=              // Shift operators plus assignment
```

最常用的运算符是 `+=` 和 `-=`，尽管 `&=` 和 `|=` 在处理布尔值或位标志时也很有用。例如：

```java
i += 2;          // Increment a loop counter by 2
c -= 5;          // Decrement a counter by 5
flags |= f;      // Set a flag f in an integer set of flags
flags &= ~f;     // Clear a flag f in an integer set of flags
```

## 条件运算符

条件运算符 `?`: 是从 C 语言继承过来的一个有些晦涩的三元（三操作数）运算符。它允许你在表达式中嵌入条件判断。你可以将它视为`if/else`语句的运算符版本。条件运算符的第一和第二操作数之间用问号 (`?`) 分隔，第二和第三操作数之间用冒号 (`:`) 分隔。第一操作数必须求值为布尔值。第二和第三操作数可以是任何类型，但它们必须可转换为相同的类型。

条件运算符首先评估其第一个操作数。如果它为 `true`，则运算符评估其第二个操作数并将其用作表达式的值。另一方面，如果第一个操作数为 `false`，则条件运算符评估并返回其第三个操作数。条件运算符永远不会同时评估其第二和第三个操作数，因此在使用具有副作用的表达式时要小心。此运算符的示例有：

```java
int max = (x > y) ? x : y;
String name = (value != null) ? value : "unknown";
```

注意，`?`: 运算符的优先级低于除赋值运算符之外的所有其他运算符，因此通常不需要在此运算符的操作数周围使用括号。然而，许多程序员发现如果将第一个操作数放在括号内，条件表达式更易于阅读。这一点尤其重要，因为条件 `if` 语句总是将其条件表达式写在括号内。

## instanceof 运算符

`instanceof` 运算符与对象和 Java 类型系统的操作密切相关。如果这是您第一次了解 Java，可能最好先略过这个定义，等您对 Java 的对象有了较好的理解后再回到这部分。

`instanceof` 要求其左操作数为对象或数组值，右操作数为引用类型的名称。在其基本形式中，如果对象或数组是指定类型的*实例*，则它评估为 `true`；否则返回 `false`。如果左操作数为 `null`，`instanceof` 总是评估为 `false`。如果 `instanceof` 表达式评估为 `true`，这意味着您可以安全地将左操作数强制转换并赋值给右操作数类型的变量。

`instanceof` 运算符只能与引用类型和对象一起使用，不能与基本类型和值一起使用。`instanceof` 的示例有：

```java
// True: all strings are instances of String
"string" instanceof String
// True: strings are also instances of Object
"" instanceof Object
// False: null is never an instance of anything
null instanceof String

Object o = new int[] {1,2,3};
o instanceof int[]   // True: the array value is an int array
o instanceof byte[]  // False: the array value is not a byte array
o instanceof Object  // True: all arrays are instances of Object

// Use instanceof to make sure that it is safe to cast an object
if (object instanceof Account) {
   Account a = (Account) object;
}
```

在 Java 17 中，`instanceof` 有一个被称为*模式匹配*的扩展形式。上面最后的示例展示了一个常见的模式检查 `instanceof`，然后在条件中将其转换为类型。使用模式匹配，我们可以一次性地表达这一切，包括引用类型后面的变量。如果 `instanceof` 看到类型兼容，变量将被赋予转换后的对象。

```java
if (object instanceof Account a) {
   // variable a is available in this scope
}
```

这种模式匹配是 Java 中的一个最新添加。预计未来的版本将在整个语言中提供更多此类便利功能。

历史上，鼓励使用 `instanceof` 以支持其他更面向对象的解决方案，我们将在 Chapter 5 中看到。然而，Java 对模式匹配的日益采用正在改变对这个运算符的态度。在通过 API 接收不可预测格式的数据的常见情况下，`instanceof` 尤其适合，并且这些天通常是一种务实的选择，而不是最后的手段。

## 特殊运算符

Java 有六种语言构造，有时被认为是运算符，有时被认为仅仅是基本语言语法的一部分。这些“运算符”在 Table 2-4 中列出，以显示它们相对于其他真正运算符的优先级。这些语言构造的使用在本书的其他地方有详细说明，但在这里简要描述，以便您能够在代码示例中识别它们：

*成员访问*（`.`）

一个*对象*是一组操作数据和操作该数据的方法的集合；对象的数据字段和方法称为其成员。点（.）运算符用于访问这些成员。如果 `o` 是一个求值为对象引用（或类名）的表达式，并且 `f` 是类的字段名，则 `o.f` 求值为该字段包含的值。如果 `m` 是一个方法名，则 `o.m` 引用该方法并允许使用稍后显示的 `()` 运算符调用它。

*数组元素访问*（`[]`）

一个*数组*是值的编号列表。数组的每个元素可以通过其编号或*索引*引用。`[]` 运算符允许您引用数组的单个元素。如果 `a` 是一个数组，并且 `i` 是一个求值为 `int` 的表达式，则 `a[i]` 引用数组 `a` 的一个元素。与处理整数值的其他运算符不同，此运算符将数组索引值限制为 `int` 类型或更窄。

*方法调用*（`()`）

*方法*是一组命名的 Java 代码，可以通过在方法名后跟随零个或多个逗号分隔的表达式括在括号中来运行或*调用*。这些表达式的值是方法的*参数*。方法处理这些参数并可选择返回一个值，该值成为方法调用表达式的值。如果`o.m`是一个不带参数的方法，则可以使用`o.m()`来调用该方法。例如，如果方法期望三个参数，则可以使用表达式`o.m(x,y,z)`来调用它。`o`称为方法的*接收者* —— 如果`o`是一个对象，则称其为*接收对象*。在 Java 解释器调用方法之前，它会评估要传递给方法的每个参数。这些表达式将按从左到右的顺序进行评估（如果其中任何一个参数具有副作用，则这一点很重要）。

*Lambda 表达式* (`->`)

*Lambda 表达式*是一个匿名的可执行 Java 代码集合，本质上是一个方法体。它由一个方法参数列表（零个或多个逗号分隔的表达式括在括号中）后跟 lambda*箭头*运算符，然后是一段 Java 代码块组成。如果代码块只包含单个语句，则可以省略通常用于标识块边界的大括号。如果 lambda 只接受一个参数，则可以省略参数周围的括号。

*对象创建* (`new`)

在 Java 中，对象是使用`new`运算符创建的，后面跟着要创建的对象类型和用括号括起的要传递给对象*构造函数*的参数列表。构造函数是一个特殊的代码块，用于初始化新创建的对象，因此对象创建语法类似于 Java 方法调用语法。例如：

```java
new ArrayList<String>();
new Account("Jason", 0.0, 42);
```

*数组创建* (`new`)

数组是对象的一种特殊情况，它们也是使用`new`运算符创建的，但语法略有不同。关键字后跟要创建的数组类型和用方括号括起的数组大小 —— 例如，`new int[5]`。在某些情况下，还可以使用*数组字面值*语法创建数组。

*类型转换或强制转换* (`()`)

正如我们已经看到的，括号也可以用作运算符来执行类型转换或强制转换。此运算符的第一个操作数是要转换的类型；它位于括号之间。第二个操作数是要转换的值；它跟在括号后面。例如：

```java
(byte) 28          // An integer literal cast to a byte type
(int) (x + 3.14f)  // A floating-point sum value cast to an integer
(String)h.get(k)   // A generic object cast to a string
```

# 语句

*语句*是 Java 语言中执行的基本单元 —— 它表达了程序员的单一意图。与表达式不同，Java 语句没有值。语句通常包含表达式和操作符（特别是赋值操作符），并且通常执行引起的副作用。

Java 定义的许多语句是流程控制语句，例如条件语句和循环语句，可以以明确定义的方式改变默认的线性执行顺序。表 2-5 总结了 Java 定义的语句。

表 2-5\. Java 语句

| 语句 | 用途 | 语法 |
| --- | --- | --- |
| *表达式* | 副作用 | *`variable`* `=` *`expr`* `;` *`expr`* `++;` *`method`* `();` `new` *`Type`* `( );` |
| *复合* | 组合语句 | `{` *`statements`* `}` |
| *空* | 什么也不做 | `;` |
| *带标签的* | 命名语句 | *`label`* : *`statement`* |
| *变量* | 声明变量 | `[final]` *`type`* *`name`* `[=` *`value`* `]` `[`, *`name`* `[=` *`value`* `]] …;` |
| `if` | 条件 | `if (` *`expr`* `)` *`statement`* `[ else` *`statement`* `]` |
| `switch` | 条件 | `switch (` *`expr`* `) {` `[ case` *`expr`* : *`statements`* `] …` `[ default`: *`statements`* `]` `}` |
| `switch` | 条件表达式 | `switch (` *`expr`* `) {` `[ case` *`expr`* `, [` *`expr`* `…] ->` *`expr`* `;] …` `[ default ->` *`expr`* `;]` `}` |
| `while` | 循环 | `while (` *`expr`* `)` *`statement`* |
| `do` | 循环 | `do` *`statement`* `while (` *`expr`* `);` |
| `for` | 简化循环 | `for (` *`init`* `;` *`test`* `;` *`increment`* `)` *`statement`* |
| *foreach* | 集合迭代 | `for (` *`variable`* : *`iterable`* `)` *`statement`* |
| `break` | 退出循环 | `break [` *`label`* `] ;` |
| `continue` | 重新开始循环 | `continue [` *`label`* `] ;` |
| `return` | 结束方法 | `return [` *`expr`* `] ;` |
| `synchronized` | 临界区 | `synchronized (` *`expr`* `) {` *`statements`* `}` |
| `throw` | 抛出异常 | `throw` *`expr`* `;` |
| `try` | 处理异常 | `try {` *`statements`* `}` `[ catch (` *`type`* *`name`* `) {` *`statements`* `} ] …` `[ finally {` *`statements`* `} ]` |
| `try` | 处理异常，关闭资源 | `try ([` *`variable`* `=` *`expr`* `]) {` *`statements`* `}` `[ catch (` *`type`* *`name`* `) {` *`statements`* `} ] …` `[ finally {` *`statements`* `} ]` |
| `assert` | 验证不变性 | `assert` *`invariant`* `[` *`error`* ]; |

## 表达式语句

正如我们在本章前面看到的那样，Java 的某些类型的表达式具有副作用。换句话说，它们不仅仅评估为某个值；它们还以某种方式改变程序状态。您可以使用具有副作用的任何表达式作为语句，只需在分号后面跟随它即可。表达式语句的合法类型包括赋值、增量和减量、方法调用和对象创建。例如：

```java
a = 1;                             // Assignment
x *= 2;                            // Assignment with operation
i++;                               // Post-increment
--c;                               // Pre-decrement
System.out.println("statement");   // Method invocation
```

## 复合语句

*复合语句* 是任意数量和类型的语句在花括号内组合在一起。您可以在 Java 语法所需的任何位置使用复合语句作为语句：

```java
for(int i = 0; i < 10; i++) {
   a[i]++;           // Body of this loop is a compound statement.
   b[i]--;           // It consists of two expression statements
}                    // within curly braces.
```

## 空语句

Java 中的*空语句*写为一个单分号。空语句不做任何事情，但语法偶尔会有用。例如，您可以在`for`循环中使用它来指示一个空的循环体：

```java
for(int i = 0; i < 10; a[i++]++)  // Increment array elements
     /* empty */;                 // Loop body is empty statement
```

## 标记语句

*标记语句*简单地说就是给一个语句起了一个名字，方法是在其前面加上标识符和冒号。标签由`break`和`continue`语句使用。例如：

```java
rowLoop: for(int r = 0; r < rows.length; r++) {        // Labeled loop
   colLoop: for(int c = 0; c < columns.length; c++) {  // Another one
     break rowLoop;                                    // Use a label
   }
}
```

## 本地变量声明语句

*局部变量*，通常简称为变量，是一个在方法或复合语句中定义的用于存储值的位置的符号名称。所有变量在使用前必须声明；这通过变量声明语句完成。因为 Java 是一种静态类型语言，所以变量声明指定变量的类型，只有该类型的值可以存储在变量中。

在其最简单的形式中，变量声明指定变量的类型和名称：

```java
int counter;
String s;
```

变量声明还可以包括一个*初始化器*，这是一个指定变量初始值的表达式。例如：

```java
int i = 0;
String s = readLine();
int[] data = {x+1, x+2, x+3}; // Array initializers are discussed later
```

Java 编译器不允许使用未初始化的局部变量，所以通常方便将变量声明和初始化结合为一个语句。初始化器表达式不必是编译器可以评估的文字值或常量表达式；它可以是在程序运行时计算值的任意复杂表达式。

如果变量有一个初始化器，那么程序员可以使用特殊的语法要求编译器自动计算类型，如果可能的话：

```java
var i = 0;          // type of i inferred as int
var s = readLine(); // type of s inferred as String
```

这可能是一种有用的语法，但可能更难阅读。例如，我们的第二个例子需要您知道`readLine()`的返回类型是`String`，才能知道`var`将推断为何种类型。因此，在文本中，我们只在初始化器使类型完全冗余时在示例中使用`var`。当您学习 Java 语言时，这可能是一个合理的政策，因为您熟悉 Java 类型系统时需要遵循这个政策。

单变量声明语句可以声明和初始化多个变量，但所有变量必须是显式声明类型相同的。变量名称和可选的初始化器用逗号分隔：

```java
int i, j, k;
float x = 1.0f, y = 1.0f;
String question = "Really Quit?", response;
```

变量声明语句可以以`final`关键字开头。这个修饰符指定了一旦为变量定义了初始值，那么该值就永远不允许更改：

```java
final String greeting = getLocalLanguageGreeting();
```

我们稍后会更详细地讨论`final`关键字，特别是在谈论类的设计和编程的不可变风格时。

Java 变量声明语句可以出现在 Java 代码的任何地方；它们不限于方法或代码块的开头。局部变量声明也可以与`for`循环的*初始化*部分集成，我们将很快讨论。

局部变量只能在定义它们的方法或代码块内部使用。这称为它们的*作用域*或*词法作用域*：

```java
void method() {            // A method definition
   int i = 0;              // Declare variable i
   while (i < 10) {        // i is in scope here
     int j = 0;            // Declare j; the scope of j begins here
     i++;                  // i is in scope here; increment it
   }                       // j is no longer in scope;
   System.out.println(i);  // i is still in scope here
}                          // The scope of i ends here
```

## if/else 语句

`if`语句是一个基本的控制语句，允许 Java 进行决策，更准确地说，有条件地执行语句。`if`语句有一个关联的表达式和语句。如果表达式求值为`true`，解释器将执行语句。如果表达式求值为`false`，解释器将跳过该语句。

###### 注

Java 允许表达式是包装类型`Boolean`而不是基本类型`boolean`。在这种情况下，包装对象将自动取消装箱。

以下是一个示例`if`语句：

```java
if (username == null)         // If username is null,
   username = "John Doe";     // use a default value
```

尽管它们看起来是多余的，但是表达式周围的括号是`if`语句语法的必需部分。正如我们已经看到的，被花括号括起来的语句块本身就是一个语句，所以我们也可以编写如下形式的`if`语句：

```java
if ((address == null) || (address.equals(""))) {
   address = "[undefined]";
   System.out.println("WARNING: no address specified.");
}
```

`if`语句可以包括一个可选的`else`关键字，后面跟着第二个语句。在这种形式的语句中，表达式被求值，如果它是`true`，则执行第一个语句。否则，执行第二个语句。例如：

```java
if (username != null)
   System.out.println("Hello " + username);
else {
   username = askQuestion("What is your name?");
   System.out.println("Hello " + username + ". Welcome!");
}
```

当使用嵌套的`if/else`语句时，需要谨慎确保`else`子句与适当的`if`语句配对。考虑以下行：

```java
if (i == j)
   if (j == k)
     System.out.println("i equals k");
else
   System.out.println("i doesn't equal j");    // WRONG!!
```

在此示例中，内部`if`语句形成了外部`if`语句语法允许的单个语句。不幸的是，不清楚（除了缩进给出的提示之外）`else`与哪个`if`配对。在这个例子中，缩进提示是错误的。规则是这样的：这样的`else`子句与最近的`if`语句关联。正确缩进后，此代码如下所示：

```java
if (i == j)
   if (j == k)
     System.out.println("i equals k");
   else
     System.out.println("i doesn't equal j");    // WRONG!!
```

这是合法的代码，但显然不是程序员所想要的。在使用嵌套`if`语句时，应该使用花括号使您的代码更易于阅读。以下是编写代码的更好方法：

```java
if (i == j) {
   if (j == k)
     System.out.println("i equals k");
}
else {
   System.out.println("i doesn't equal j");
}
```

### else if 子句

`if/else`语句用于测试条件并选择要执行的两个语句或代码块之间的选择。但是，当您需要在几个代码块之间进行选择时呢？这通常使用`else` `if`子句来完成，这并不是真正的新语法，而是标准`if/else`语句的一种常见习惯用法。它看起来像这样：

```java
if (n == 1) {
    // Execute code block #1
}
else if (n == 2) {
    // Execute code block #2
}
else if (n == 3) {
    // Execute code block #3
}
else {
    // If all else fails, execute block #4
}
```

这段代码并没有什么特别之处。它只是一系列`if`语句，每个`if`语句都是上一条语句的`else`子句的一部分。使用`else` `if`习语比完全嵌套形式更可取，并且更易读：

```java
if (n == 1) {
   // Execute code block #1
}
else {
   if (n == 2) {
     // Execute code block #2
   }
   else {
     if (n == 3) {
       // Execute code block #3
     }
     else {
       // If all else fails, execute block #4
     }
   }
}
```

## switch 语句

`if`语句会导致程序执行流程的分支。您可以使用多个`if`语句，如前一节所示，执行多路分支。然而，并非总是最佳解决方案，特别是当所有分支都依赖于单个变量的值时。

在这种情况下，重复的`if`语句可能会严重影响可读性，特别是如果代码经过了重构或具有多层嵌套的`if`。

更好的解决方案是使用`switch`语句，这是从 C 编程语言继承而来的。然而，请注意，此语句的语法并不像 Java 的其他部分那样优雅。没有重新审视这一特性的设计被普遍认为是一个错误，这在最近的版本中部分得到了纠正，引入了我们将在稍后讨论的`switch`表达式形式。然而，该替代格式不会抹去语言中长期存在的`switch`语句的历史，因此理解它是有益的。

###### 注意

`switch`语句以一个表达式开始，其类型为`int`、`short`、`char`、`byte`（或它们的包装类型）、`String`或枚举（详见第四章关于枚举类型的更多信息）。

此表达式后跟着一个带有多个入口点的代码块，这些入口点对应于表达式可能的值。例如，以下`switch`语句等效于前一节中显示的重复`if`和`else/if`语句：

```java
switch(n) {
   case 1:                         // Start here if n == 1
     // Execute code block #1
     break;                        // Stop here
   case 2:                         // Start here if n == 2
     // Execute code block #2
     break;                        // Stop here
   case 3:                         // Start here if n == 3
     // Execute code block #3
     break;                        // Stop here
   default:                        // If all else fails...
     // Execute code block #4
     break;                        // Stop here
}
```

正如您从示例中看到的那样，`switch`语句中的各个入口点要么用关键字`case`标记，后面跟着一个整数值和一个冒号，要么用特殊的`default`关键字标记，后面跟着一个冒号。当`switch`语句执行时，解释器计算括号中表达式的值，然后查找与该值匹配的`case`标签。如果找到匹配的标签，解释器将从`case`标签后的第一条语句开始执行代码块。如果没有找到具有匹配值的`case`标签，则解释器将从特殊的`default:`标签后的第一条语句开始执行。或者，如果没有`default:`标签，则解释器完全跳过`switch`语句的主体。

在前面的代码中，在每个`case`结尾处使用了`break`关键字，请注意。`break`语句将在本章后面进行解释，但在此示例中，它使解释器退出`switch`语句的主体。`switch`语句中的`case`子句仅指定所需代码的起始点。各个`case`不是独立的代码块，并且它们没有任何隐含的结束点。

###### 警告

您必须显式指定每个 `case` 的结束，使用 `break` 或相关语句。在缺少 `break` 语句的情况下，`switch` 语句从匹配的 `case` 标签后的第一个语句开始执行代码，并继续执行语句，直到达到块的末尾。控制流会 *fall through* 到下一个 `case` 标签并继续执行，而不是退出块。

在罕见情况下，编写这样的代码是有用的，从一个 `case` 标签穿透到下一个 `case` 标签，但 99% 的情况下，您应该小心地结束每个 `case` 和 `default` 部分，使得 `switch` 语句停止执行。通常使用 `break` 语句，但也可以使用 `return` 和 `throw` 语句。

由于默认的 fall-through 特性，一个 `switch` 语句可以有多个标记相同语句的 `case` 子句。考虑下面方法中的 `switch` 语句：

```java
boolean parseYesOrNoResponse(char response) {
   switch(response) {
     case 'y':
     case 'Y': return true;
     case 'n':
     case 'N': return false;
     default:
       throw new IllegalArgumentException("Response must be Y or N");
   }
}
```

`switch` 语句及其 `case` 标签有一些重要限制。首先，与 `switch` 语句关联的表达式必须具有适当的类型 —— `byte`、`char`、`short`、`int`（或它们的包装类）、枚举类型或 `String`。不支持浮点型和 `boolean` 类型，即使 `long` 是整数类型也不支持。其次，与每个 `case` 标签关联的值必须是编译器可以评估的常量值或常量表达式。例如，`case` 标签不能包含涉及变量或方法调用的运行时表达式。第三，`case` 标签的值必须在用于 `switch` 表达式的数据类型的范围内。最后，不能有两个或更多具有相同值的 `case` 标签或一个以上的 `default` 标签是不合法的。

考虑到所有这些注意事项，让我们看看新的 `switch` 表达式如何提供更清晰的体验。

## `switch` 表达式

经典 `switch` 语句的一个常见问题是捕获变量值时产生的问题。

```java
Boolean yesOrNo = null;
switch(input) {
    case "y":
    case "Y":
        yesOrNo = true;
        break;
    case "n":
    case "N":
        yesOrNo = false;
        break;
    default:
        throw new IllegalArgumentException("Response must be Y or N");
}
```

变量在 `switch` 后仍然可用，必须在语句外声明并赋予初始值。然后，每个 `case` 必须确保设置变量。但是，我们没有保证，在比这个简单示例更多分支的代码中，很容易忽略并引入错误。

`switch` 表达式明确设计用于解决这些及其他缺陷。正如其名称所示，它是一个 *表达式* —— 是语言中语法上较复杂的表达式之一，并因此产生一个值。

```java
boolean yesOrNo = switch(input) {
    case "y" -> true;
    case "Y" -> true;
    case "N" -> false;
    case "n" -> false;
    default -> throw new IllegalArgumentException("Y or N");
};
```

就像 `switch` 语句一样，每个 `case` 在此处评估输入与其值。在 `->` 之后，您提供整个 `switch` 表达式的结果值。在此示例中，我们将其分配给我们的变量 `yesOrNo`，这不再需要是可空包装类型。

我们这里编写的代码隐藏了`switch`表达式为我们提供的保护之一。如果我们移除`default`子句，编译器会报错，因为表达式不能始终完全评估。

```java
boolean yesOrNo = switch(input) {
    case "y" -> true;
    case "Y" -> true;
    case "N" -> false;
    case "n" -> false;
};

// Compiler error:
//   the switch expression does not cover all possible input values
```

Switch 表达式不像语句形式那样会掉落到下一个`case`。为了支持多个值评估为相同结果，每个`case`可以接受逗号分隔的值列表，而不仅仅是单个值。

```java
boolean yesOrNo = switch(input) {
    case "y", "Y" -> true;
    case "n", "N" -> false;
    default -> throw new IllegalArgumentException("Y or N");
};
```

我们的期望结果并非总是可以表示为单个值或方法调用。为了支持这一点，花括号可以引入一个语句。但是，该语句必须以`yield`结束以退出带有值的`switch`，或者使用`return`离开整个封闭方法。

```java
boolean yesOrNo = switch(input) {
    case "y", "Y" -> { System.out.println("Got it"); yield true; }
    case "n", "N" -> { System.out.println("Nope"); yield false; }
    default -> throw new IllegalArgumentException("Y or N");
};
```

实际上，如果我们不使用`switch`表达式的结果，甚至可以仅用于副作用的语法，具有改进的分支检查和安全性。

```java
switch(input) {
    case "y", "Y" -> System.out.println("Sure");
    case "n", "N" -> System.out.println("Nope");
    default -> throw new IllegalArgumentException("Y or N");
}
```

## `while`语句

`while`语句是一个基本语句，允许 Java 执行重复的操作——换句话说，它是 Java 的主要*循环结构*之一。它的语法如下：

```java
while (*`expression`*)
  *`statement`*

```

`while`语句首先评估*`expression`*，该表达式必须返回`boolean`或`Boolean`值。如果值为`false`，解释器跳过循环关联的*`statement`*，并移动到程序的下一条语句。然而，如果值为`true`，则执行循环体形成的*`statement`*，并重新评估*`expression`*。再次，如果*`expression`*的值为`false`，解释器继续执行程序的下一条语句；否则，它再次执行*`statement`*。这个循环在*`expression`*保持`true`（即直到它评估为`false`）时继续，此时`while`语句结束，解释器继续执行程序的下一条语句。您可以使用语法`while(true)`创建无限循环。

这里是一个打印数字 0 到 9 的示例`while`循环：

```java
int count = 0;
while (count < 10) {
   System.out.println(count);
   count++;
}
```

正如您所看到的，变量`count`在这个示例中从 0 开始，并且每次循环体运行时都会递增。一旦循环执行了 10 次，表达式变为`false`（即`count`不再小于 10），`while`语句结束，Java 解释器可以转到程序中的下一条语句。大多数循环都有像`count`这样的计数器变量。变量名`i`、`j`和`k`通常用作循环计数器，尽管如果使您的代码更易于理解，您应该使用更具描述性的名称。

## `do`语句

`do`循环与`while`循环非常相似，不同之处在于循环表达式在循环体底部测试，而不是在顶部测试。这意味着循环体至少会执行一次。语法如下：

```java
do
   *`statement`*
while (*`expression`*);

```

注意`do`循环与更普通的`while`循环之间的一些区别。首先，`do`循环需要`do`关键字标记循环的开始和`while`关键字标记结束并引入循环条件。此外，与`while`循环不同，`do`循环以分号结束。这是因为`do`循环以循环条件结束，而不仅仅是以标记循环体结束的花括号结束。以下的`do`循环打印了与前述`while`循环相同的输出：

```java
int count = 0;
do {
   System.out.println(count);
   count++;
} while(count < 10);
```

`do`循环比它的`while`表兄弟要少见得多，因为实际上很少遇到您确信总是希望至少执行一次循环的情况。

## `for`语句

`for`语句提供了一个循环结构，通常比`while`和`do`循环更方便。`for`语句利用了一种常见的循环模式。大多数循环都有一个计数器或某种状态变量，在循环开始前初始化，在测试后确定是否执行循环体，并在循环体结束前以某种方式递增或更新。*`initialize`*、*`test`*和*`update`*步骤是循环变量的三个关键操作，而`for`语句使这三个步骤成为循环语法的显式部分：

```java
for(*`initialize`*; *`test`*; *`update`*) {
    *`statement`*
}

```

这个`for`循环基本上等同于以下的`while`循环：

```java
*`initialize`*;
while (*`test`*) {
   *`statement`*;
   *`update`*;
}

```

将*`initialize`*、*`test`*和*`update`*表达式放在`for`循环的顶部使得理解循环正在做什么特别容易，并且防止像忘记初始化或更新循环变量这样的错误。解释器会丢弃*`initialize`*和*`update`*表达式的值，因此为了有用，这些表达式必须具有副作用。*`initialize`*通常是赋值表达式，而*`update`*通常是增量、减量或其他一些赋值。

下面的`for`循环打印出 0 到 9 的数字，就像之前的`while`和`do`循环所做的那样：

```java
int count;
for(count = 0 ; count < 10 ; count++)
   System.out.println(count);
```

注意这种语法如何将关于循环变量的所有重要信息放在一行上，使得循环执行过程非常清晰。将*`update`*表达式放在`for`语句本身中也简化了循环体到一个单一语句；我们甚至不需要使用花括号来生成语句块。

`for`循环支持一些额外的语法，使其更加方便使用。因为许多循环仅在循环内部使用它们的循环变量，所以`for`循环允许*`initialize`*表达式是一个完整的变量声明，因此该变量的作用域仅限于循环体内部，在外部不可见。例如：

```java
for(int count = 0 ; count < 10 ; count++)
   System.out.println(count);
```

此外，`for`循环的语法不限于只写使用单个变量的循环。`for`循环的*`initialize`*和*`update`*表达式都可以使用逗号来分隔多个初始化和更新表达式。例如：

```java
for(int i = 0, j = 10 ; i < 10 ; i++, j--)
     sum += i * j;
```

尽管到目前为止所有的示例都是计数数字，但`for`循环并不局限于计数数字的循环。例如，你可以使用`for`循环来遍历链表的元素：

```java
for(Node n = listHead; n != null; n = n.nextNode())
   process(n);
```

`for`循环的*`initialize`*、*`test`*和*`update`*表达式都是可选的；只有分号用于分隔表达式是必需的。如果省略了*`test`*表达式，则假定为`true`。因此，你可以将一个无限循环写成`for(;;)`。

## foreach 语句

Java 的`for`循环适用于原始类型，但对处理对象集合来说过于笨拙。相反，另一种称为*foreach*循环的替代语法用于处理需要遍历的对象集合。

foreach 循环使用关键字`for`后跟一个开括号，一个变量声明（没有初始化器），一个冒号，一个表达式，一个闭括号，最后是组成循环体的语句（或块）：

```java
for( *`declaration`* : *`expression`* )
     *`statement`*

```

尽管其名称如此，foreach 循环并没有关键字`foreach`——相反，通常将冒号读作“in”——例如“foreach name in studentNames.”。

对于`while`、`do`和`for`循环，我们展示了一个打印 10 个数字的例子。foreach 循环也可以做到，但它需要一个要遍历的集合。为了循环 10 次（打印出 10 个数字），我们需要一个包含 10 个元素的数组或其他集合。下面是我们可以使用的代码：

```java
// These are the numbers we want to print
int[] primes = new int[] { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29 };
// This is the loop that prints them
for(int n : primes)
     System.out.println(n);
```

### foreach 无法做到的事情

foreach 与`while`、`for`或`do`循环不同，因为它隐藏了循环计数器或`Iterator`。这是一个非常强大的想法，当我们讨论 lambda 表达式时会看到，但是有些算法用 foreach 循环表达起来并不自然。

例如，假设你想将数组的元素打印为逗号分隔的列表。为此，你需要在数组的每个元素后打印一个逗号，除了最后一个元素之外，或者等效地，在数组的每个元素之前打印一个逗号。使用传统的`for`循环，代码可能如下所示：

```java
for(int i = 0; i < words.length; i++) {
     if (i > 0) System.out.print(", ");
     System.out.print(words[i]);
}
```

这是一个非常直接的任务，但你在不保留额外状态的情况下简单地无法使用 foreach 完成。问题在于 foreach 循环不提供循环计数器或其他方式来告诉你是第一次迭代、最后一次迭代还是中间某个迭代。

###### 注意

当你使用 foreach 来遍历集合元素时，存在类似的问题。正如在数组上进行 foreach 循环时无法获取当前元素的数组索引一样，在集合上进行 foreach 循环时也无法获取正在用于枚举集合元素的`Iterator`对象。

这里有一些你不能在 foreach 风格循环中做的事情：

+   反向迭代数组或 `List` 的元素。

+   使用单个循环计数器访问两个不同数组的相同编号元素。

+   使用调用其 `get()` 方法而不是调用其迭代器来遍历 `List` 的元素。

## `break` 语句

`break` 语句会导致 Java 解释器立即跳过包含语句的末尾。我们已经看到 `break` 语句与 `switch` 语句一起使用。`break` 语句通常简单地写为关键字 `break` 后跟一个分号：

```java
break;
```

在这种形式下，它会导致 Java 解释器立即退出最内层的包含的 `while`、`do`、`for` 或 `switch` 语句。例如：

```java
for(int i = 0; i < data.length; i++) {
    if (data[i] == target) {  // When we find what we're looking for,
        index = i;              // remember where we found it
        break;                  // and stop looking!
    }
}   // The Java interpreter goes here after executing break
```

`break` 语句也可以跟随包含的标记语句的名称。在这种形式下，`break` 会导致 Java 解释器立即退出命名的块，该块可以是任何类型的语句，而不仅仅是循环或 `switch`。例如：

```java
TESTFORNULL: if (data != null) {
   for(int row = 0; row < numrows; row++) {
     for(int col = 0; col < numcols; col++) {
       if (data[row][col] == null)
         break TESTFORNULL;           // treat the array as undefined.
     }
   }
}  // Java interpreter goes here after executing break TESTFORNULL
```

## `continue` 语句

虽然 `break` 语句退出循环，但 `continue` 语句结束当前循环迭代并开始下一个迭代。`continue` 在其未标记和标记形式中，只能在 `while`、`do` 或 `for` 循环内使用。未带标记时，`continue` 导致最内层循环开始新的迭代。当使用包含循环名称的标签时，它导致命名循环开始新的迭代。例如：

```java
for(int i = 0; i < data.length; i++) {  // Loop through data.
   if (data[i] == -1)                   // If a data value is missing,
     continue;                          // skip to the next iteration.
   process(data[i]);                    // Process the data value.
}
```

`while`、`do` 和 `for` 循环在 `continue` 启动新迭代的方式上略有不同：

+   对于 `while` 循环，Java 解释器简单地返回到循环的顶部，重新测试循环条件，如果评估为 `true`，则再次执行循环体。

+   对于 `do` 循环，解释器跳到循环的底部，检查循环条件以决定是否执行循环的另一个迭代。

+   对于 `for` 循环，解释器跳到循环的顶部，首先评估 *`update`* 表达式，然后评估 *`test`* 表达式以决定是否再次循环。从这些例子中可以看出，带有 `continue` 语句的 `for` 循环的行为与之前介绍的“基本等效”的 `while` 循环的行为不同；*`update`* 在 `for` 循环中被评估，但在等效的 `while` 循环中却不是。

## `return` 语句

`return` 语句告诉 Java 解释器停止执行当前方法。如果方法声明要返回一个值，则 `return` 语句后必须跟表达式。表达式的值成为方法的返回值。例如，以下方法计算并返回一个数字的平方：

```java
double square(double x) {      // A method to compute x squared
   return x * x;               // Compute and return a value
}
```

有些方法声明为`void`，表示它们不返回任何值。Java 解释器通过逐一执行它们的语句直到方法结束来运行这些方法。执行完最后一个语句后，解释器会隐式返回。然而，有时`void`方法必须在到达最后一个语句之前显式返回。在这种情况下，它可以使用`return`语句本身，不带任何表达式。例如，以下方法打印但不返回其参数的平方根。如果参数是负数，则打印之前返回而不打印任何内容：

```java
// A method to print square root of x
void printSquareRoot(double x) {
   if (x < 0) return;                // If x is negative, return
   System.out.println(Math.sqrt(x)); // Print the square root of x
}                                    // Method end: return implicitly
```

## 同步语句

Java 一直为多线程编程提供支持。我们稍后会详细介绍这一点（特别是在“Java 对并发的支持”中）；然而，请注意，编写正确的并发代码很难且有许多微妙之处。

特别是在处理多个线程时，通常需要注意防止多个线程同时修改对象的方式，这可能会破坏对象的状态。Java 提供了`synchronized`语句来帮助程序员防止这种破坏。语法是：

```java
synchronized ( *`expression`* ) {
   *`statements`*
}

```

*`expression`* 是必须求值为对象（包括数组）的表达式。*`statements`* 构成可能会造成损害的部分的代码，并且必须用大括号括起来。

###### 注意

在 Java 中，对象状态（即数据）的保护是并发原语的主要关注点。这与其他一些语言不同，其他语言更关注对*临界区*（即代码）的排除。

在执行语句块之前，Java 解释器首先获取由*`expression`*指定的对象或数组的独占锁。它在运行完块后释放锁。当一个线程持有对象的锁时，其他线程无法获取该锁。

除了块形式外，`synchronized`在 Java 中还可以作为方法修饰符使用。当应用于方法时，该关键字表示整个方法被视为`synchronized`。

对于`synchronized`实例方法，Java 获取类实例的独占锁。（类方法和实例方法在第三章中有详细讨论。）它可以被视为覆盖整个方法的`synchronized (this) { ... }`块。

`static synchronized` 方法（类方法）会导致 Java 在执行该方法之前获取类（技术上对应于类型的类对象）的独占锁。

## 抛出语句

*异常* 是指示发生了某种异常条件或错误的信号。*抛出*异常是为了信号异常条件。*捕获*异常是为了处理它，采取必要的措施以从中恢复。

在 Java 中，`throw`语句用于抛出异常：

```java
throw *`expression`*;

```

*`expression`* 必须评估为描述发生的异常或错误的异常对象。稍后我们将更详细地讨论异常的类型；现在你只需要知道，异常：

+   由对象表示

+   其类型是 `Exception` 的子类

+   在 Java 语法中具有稍微专门化的角色

+   可以是两种不同类型：*checked* 或 *unchecked*

下面是一个抛出异常的示例代码：

```java
public static double factorial(int x) {
   if (x < 0)
     throw new IllegalArgumentException("x must be >= 0");
   double fact;
   for(fact=1.0; x > 1; fact *= x, x--)
     /* empty */ ;          // Note use of the empty statement
   return fact;
}
```

当 Java 解释器执行 `throw` 语句时，它立即停止正常的程序执行，并开始寻找能够捕获或处理异常的异常处理程序。异常处理程序使用 `try/catch/finally` 语句编写，下一节将对此进行描述。Java 解释器首先查看包含代码块，看看是否有相关联的异常处理程序。如果有，则退出该代码块，并开始运行与该代码块相关联的异常处理代码。运行完异常处理程序后，解释器继续执行跟在处理程序代码之后的语句。

如果包含代码块没有适当的异常处理程序，则解释器检查方法中的下一个更高的包含代码块。这将继续，直到找到处理程序。如果方法中没有可以处理 `throw` 语句抛出的异常的异常处理程序，则解释器停止运行当前方法，并返回给调用者。现在解释器开始在调用方法的代码块中寻找异常处理程序。通过这种方式，异常沿着 Java 方法的词法结构向上传播，沿着 Java 解释器的调用堆栈向上传播。如果异常从未被捕获，则它一直传播到程序的 `main()` 方法。如果在该方法中未处理它，则 Java 解释器打印错误消息，打印堆栈跟踪以指示异常发生的位置，然后退出。

## `try/catch/finally` 语句

Java 有两种略有不同的异常处理机制。经典形式是 `try/catch/finally` 语句。此语句的 `try` 子句建立了一个用于异常处理的代码块。这个 `try` 块后面是零个或多个 `catch` 子句，每个 `catch` 子句是一组语句块，用于处理特定的异常。每个 `catch` 块可以处理多个不同的异常—为了指示一个 `catch` 块应该处理多个异常，我们使用 `|` 符号分隔不同的异常。`catch` 子句后面是一个可选的 `finally` 块，其中包含保证执行的清理代码，无论 `try` 块中发生了什么。

以下代码说明了 `try/catch/finally` 语句的语法和目的：

```java
try {
   // Normally this code runs from the top of the block to the bottom
   // without problems. But it can sometimes throw an exception,
   // either directly with a throw statement or indirectly by calling
   // a method that throws an exception.
}
catch (SomeException e1) {
   // This block contains statements that handle an exception object
   // of type SomeException or a subclass of that type. Statements in
   // this block can refer to that exception object by the name e1.
}
catch (AnotherException | YetAnotherException e2) {
   // This block contains statements that handle an exception of
   // type AnotherException or YetAnotherException, or a subclass of
   // either of those types. Statements in this block refer to the
   // exception object they receive by the name e2.
}
finally {
   // This block contains statements that are always executed
   // after we leave the try clause, regardless of whether we leave it:
   //   1) normally, after reaching the bottom of the block;
   //   2) because of a break, continue, or return statement;
   //   3) with an exception that is handled by a catch clause above;
   //   4) with an uncaught exception that has not been handled.
   // If the try clause calls System.exit(), however, the interpreter
   // exits before the finally clause can be run.
}
```

### try

`try`子句简单地建立一个代码块，要么处理其异常，要么在任何情况下终止时运行特殊的清理代码。`try`子句本身不执行任何有趣的操作；是`catch`和`finally`子句执行异常处理和清理操作。

### 捕获

一个`try`块后面可以跟随零个或多个`catch`子句，这些子句指定处理各种类型异常的代码。每个`catch`子句声明一个参数，指定该子句可以处理的异常类型（可能使用特殊的`|`语法来表示`catch`块可以处理多种类型的异常），并且为该子句提供一个名称，用于引用它当前正在处理的异常对象。`catch`块希望处理的任何类型必须是`Throwable`的某个子类。

当抛出异常时，Java 解释器会查找一个带有与异常对象类型相匹配或超类匹配的`catch`子句。解释器调用它找到的第一个这样的`catch`子句。`catch`块内的代码应采取必要的操作来处理异常情况。例如，如果异常是`java.io.FileNotFoundException`，你可以通过要求用户检查拼写并重试来处理它。

并非每个可能的异常都需要有一个`catch`子句；在某些情况下，正确的响应是允许异常传播并被调用方法捕获。在其他情况下，比如由`NullPointerException`信号的编程错误，正确的响应可能并不是捕获异常，而是允许其传播，并让 Java 解释器输出堆栈跟踪和错误消息。

### 最终

`finally`子句通常用于在`try`子句中的代码之后进行清理（例如关闭文件和关闭网络连接）。`finally`子句非常有用，因为它保证在执行`try`块的任何部分之后执行，无论`try`块中的代码如何完成。实际上，`try`子句退出而不允许执行`finally`子句的唯一方法是调用`System.exit()`方法，这将导致 Java 解释器停止运行。

在正常情况下，控制流程到达`try`块的末尾，然后继续执行`finally`块，执行任何必要的清理工作。如果控制流程因为`return`、`continue`或`break`语句离开`try`块，那么在转移到新目的地之前将执行`finally`块。

如果在`try`块中发生异常，并且有相关的`catch`块来处理异常，则控制首先转移到`catch`块，然后再到`finally`块。如果没有局部`catch`块来处理异常，则控制首先转移到`finally`块，然后传播到最近的能处理异常的包含`catch`子句。

如果`finally`块本身使用`return`、`continue`、`break`或`throw`语句转移控制，或通过调用抛出异常的方法，挂起的控制转移将被放弃，并处理这种新的转移。例如，如果`finally`子句抛出异常，则该异常将替换正在被抛出的任何异常。如果`finally`子句发出`return`语句，则方法会正常返回，即使已经抛出异常且尚未处理。

`try`和`finally`可以一起使用，不带异常或任何`catch`子句。在这种情况下，`finally`块只是保证执行的清理代码，无论`try`子句中有任何`break`、`continue`或`return`语句。

## **尝试使用资源语句**

`try`块的标准形式非常通用，但在编写`catch`和`finally`块时，需要开发人员在操作需要在不再需要时清理或关闭的资源时特别小心。

Java 提供了一种非常有用的机制来自动关闭需要清理的资源。这就是*try-with-resources*（TWR），或称为尝试资源。我们在“经典 Java I/O”中详细讨论了 TWR，但为了完整起见，让我们现在介绍一下语法。以下示例展示了如何使用`FileInputStream`类打开文件（这会生成一个需要清理的对象）：

```java
try (InputStream is = new FileInputStream("/Users/ben/details.txt")) {
  // ... process the file
}
```

这种新形式的`try`接受的参数都是需要清理的对象，^(2)这些对象的作用域限于此`try`块，然后无论如何退出此块，它们都会自动清理。开发人员不需要编写任何`catch`或`finally`块——Java 编译器会自动插入正确的清理代码。

所有涉及资源的新代码都应以 TWR 风格编写——这比手动编写`catch`块容易出错得多，并且不会遭受像最终化技术（详见“终结”）那样的问题。

## **断言语句**

`assert`语句是在 Java 代码中验证设计假设的一种尝试。*断言*由`assert`关键字后跟程序员认为应始终评估为`true`的布尔表达式组成。默认情况下，断言是禁用的，而`assert`语句实际上不执行任何操作。

可以将断言作为调试工具启用，但是当这样做时，`assert` 语句会评估表达式。如果它确实是 `true`，`assert` 不会执行任何操作。另一方面，如果表达式评估为 `false`，断言将失败，并且 `assert` 语句将抛出一个 `java.lang.AssertionError`。

###### 提示

除了核心的 JDK 库之外，`assert` 语句几乎*极少*被使用。事实证明，它对于测试大多数应用程序来说过于不灵活，并且普通开发人员很少使用它。相反，开发者使用普通的测试库，比如 JUnit。

`assert` 语句可以包含一个可选的第二表达式，用冒号与第一个表达式分隔。当启用断言并且第一个表达式评估为 `false` 时，第二个表达式的值将作为错误代码或错误消息，并传递给 `AssertionError()` 构造函数。语句的完整语法是：

```java
assert *`assertion`*;

```

或者：

```java
assert *`assertion`* : *`errorcode`*;

```

要有效地使用断言，您还必须了解一些细节。首先，请记住，您的程序通常会禁用断言并且仅在某些时候启用断言。这意味着您应该小心，不要编写包含副作用的断言表达式。

###### 警告

您不应该从自己的代码中抛出 `AssertionError`，因为它可能会在平台的将来版本中产生意外的结果。

如果抛出 `AssertionError`，则表明程序员的某些假设不成立。这意味着代码正在超出其设计的参数范围，并且不能期望其能正常工作。简而言之，没有合理的方式可以从 `AssertionError` 中恢复，您不应尝试捕获它（除非您仅在顶层捕获它，以便以更用户友好的方式显示错误）。

### 启用断言

为了效率，每次执行代码时测试断言是没有意义的 — `assert` 语句编码了应始终为真的假设。因此，默认情况下禁用断言，`assert` 语句没有任何效果。但是，断言代码仍然编译在类文件中，因此始终可以为诊断或调试目的启用它们。您可以使用 Java 解释器的命令行参数启用断言，要么全面启用，要么选择性启用。

要在所有类中除系统类外启用断言，请使用 `-ea` 参数。要在系统类中启用断言，请使用 `-esa`。要在特定类内启用断言，请使用 `-ea` 后跟一个冒号和类名：

```java
java -ea:com.example.sorters.MergeSort com.example.sorters.Test
```

要为包及其所有子包中的所有类启用断言，请在 `-ea` 参数后跟一个冒号，包名称和三个点：

```java
java -ea:com.example.sorters... com.example.sorters.Test
```

您可以以相同的方式禁用断言，使用 `-da` 参数。例如，要在一个包中全面启用断言，然后在特定类或子包中禁用它们，请使用：

```java
java -ea:com.example.sorters... -da:com.example.sorters.QuickSort
java -ea:com.example.sorters... -da:com.example.sorters.plugins..
```

最后，可以控制是否在类加载时启用或禁用断言。如果你在程序中使用自定义类加载器（有关自定义类加载的详细信息，请参见第十一章）并想启用断言，可能会对这些方法感兴趣。

# 方法

*方法*是一个由 Java 语句组成的命名序列，可以被其他 Java 代码调用。当调用一个方法时，会传递零个或多个值，称为*参数*。该方法执行一些计算，且可选择地返回一个值。正如前面在“表达式与运算符”中描述的，方法调用是一个由 Java 解释器评估的表达式。然而，由于方法调用可能有副作用，它们也可以用作表达式语句。本节不讨论方法调用，而是描述如何定义方法。

## 定义方法

你已经知道如何定义方法的主体；它只是一个任意的语句序列，括在花括号内。方法更有趣的是它的*签名*。（3）。签名指定：

+   方法的名称

+   方法使用的参数的数量、顺序、类型和名称

+   方法返回值的类型

+   方法可能抛出的已检查异常（签名也可以列出未检查异常，但不是必需的）

+   提供关于方法的额外信息的各种方法修饰符

方法签名定义了在调用方法之前你需要知道的所有信息。它是方法*规范*，定义了方法的 API。要使用 Java 平台的在线 API 参考，你需要知道如何阅读方法签名。而且，编写 Java 程序时，你需要知道如何定义你自己的方法，每个方法都以方法签名开始。

方法签名如下所示：

```java
*`modifiers` `type` `name`* (*`paramlist`*) [ throws exceptions ]

```

方法签名（方法规范）后是方法体（方法实现），它只是一个由 Java 语句组成的序列，括在花括号内。如果方法是*抽象的*（参见第三章），则省略实现，方法体用一个分号替换。

方法的签名也可能包括类型变量声明——此类方法被称为*泛型方法*。泛型方法和类型变量在第四章中讨论。

下面是一些示例方法定义，方法签名后面是方法体：

```java
// This method is passed an array of strings and has no return value.
// All Java programs have an entry point with this name and signature.
public static void main(String[] args) {
     if (args.length > 0) System.out.println("Hello " + args[0]);
     else System.out.println("Hello world");
}

// This method is passed two double arguments and returns a double.
static double distanceFromOrigin(double x, double y) {
     return Math.sqrt(x*x + y*y);
}

// This method is abstract which means it has no body.
// Note that it may throw exceptions when invoked.
protected abstract String readText(File f, String encoding)
    throws FileNotFoundException, UnsupportedEncodingException;
```

*`修饰符`*是零个或多个特殊的修饰符关键字，由空格分隔。例如，一个方法可能使用`public`和`static`修饰符声明。允许的修饰符及其含义在下一节中描述。

方法签名中的*`type`*指定方法的返回类型。如果方法不返回值，*`type`*必须是`void`。如果方法声明具有非`void`返回类型，则必须包含一个返回语句，该语句返回声明类型的值（或可转换为其的值）。

*构造函数*是一段代码块，类似于方法，用于初始化新创建的对象。正如我们将在第三章中看到的，构造函数的定义方式与方法非常相似，只是它们的签名不包括这个*`type`*规范，并且必须与类名相同。

方法的*`name`*遵循其修饰符和类型的规范。方法名像变量名一样是 Java 标识符，并且像所有 Java 标识符一样，可以包含由 Unicode 字符集表示的任何语言中的字母。定义具有相同名称的多个方法通常是合法且非常有用的，只要每个方法的版本具有不同的参数列表。定义具有相同名称的多个方法称为*方法重载*。

###### 提示

不同于其他一些语言，Java 没有匿名方法。相反，Java 8 引入了 lambda 表达式，它们类似于匿名方法，但 Java 运行时会自动将它们转换为适当命名的方法——详见“Lambda Expressions”了解更多细节。

例如，我们已经见过的`System.out.println()`方法是一个重载方法。同名的一个方法打印一个字符串，同名的其他方法打印各种基本类型的值。Java 编译器根据传递给方法的参数类型决定调用哪个方法。

当你定义一个方法时，方法名后总是跟着方法的参数列表，参数列表必须用括号括起来。参数列表定义了零个或多个传递给方法的参数。如果有参数规范，每个规范包括类型和名称，并且规范之间用逗号分隔（如果有多个参数）。当调用一个方法时，传递给它的参数值必须与该方法签名行中指定的参数的数量、类型和顺序匹配。传递的值不需要与签名中指定的类型完全相同，但必须可以在不进行强制转换的情况下转换为这些类型。

###### 注意

当一个 Java 方法不希望有参数时，其参数列表仅为`()`，而不是`(void)`。Java 不将`void`视为一种类型——特别是 C 和 C++ 程序员应该注意。

Java 允许程序员定义和调用接受可变数量参数的方法，使用一种俗称为*varargs*的语法。有关 varargs 的详细信息稍后在本章中讨论。

方法签名的最后一部分是`throws`子句，用于列出方法可以抛出的*受检异常*。受检异常是一类必须在方法的`throws`子句中列出的异常类。

如果一个方法使用`throw`语句抛出一个受检异常，那么该方法必须声明它可以抛出该异常。在调用某个抛出受检异常的其他方法且调用方法没有明确捕获该异常的情况下，方法必须声明它可以抛出异常。

如果一个方法可能抛出一个或多个受检异常，它会通过在参数列表之后放置`throws`关键字并跟随异常类的名称来指定这一点。如果一个方法不会抛出任何受检异常，则不使用`throws`关键字。如果一个方法抛出多种类型的受检异常，使用逗号将异常类的名称分开。稍后详细介绍。

## 方法修饰符

方法的修饰符由零个或多个修饰符关键字组成，例如`public`、`static`或`abstract`。以下是允许的修饰符及其含义列表：

`abstract`

`abstract`方法是没有实现的规范。方法的大括号和 Java 语句通常组成方法体的部分被替换为一个分号。包含`abstract`方法的类本身必须声明为`abstract`。这样的类是不完整的，不能被实例化（参见第三章）。

`default`

`default`方法只能在接口上定义。实现接口的所有类都会接收默认方法，除非它们直接覆盖它。在第三章中详细探讨了在类中实现接口。

`final`

`final`方法不能被子类重写或隐藏，这使得它适合进行编译器优化，这对于普通方法来说是不可能的。所有`private`方法都隐式地是`final`的，同样，所有声明为`final`的类的方法也是`final`的。

`native`

`native`修饰符指定方法实现是用某些“本地”语言编写的，比如 C，并且是外部提供给 Java 程序的。与`abstract`方法类似，`native`方法没有方法体：大括号被分号替代。

`public`, `protected`, `private`

这些访问修饰符指定方法是否以及在哪里可以在定义它的类的外部使用。这些非常重要的修饰符在第三章中有详细解释。

`static`

声明为`static`的方法是与类本身关联的*类方法*，而不是与类的实例关联的（我们在第三章中详细讨论这一点）。

`strictfp`

这个笨拙命名、很少使用的修饰符中的`fp`代表“浮点”。出于性能原因，在 Java 1.2 中，当使用某些浮点加速硬件时，语言允许对严格的 IEEE-754 标准进行微小的偏离。添加了`strictfp`关键字以强制 Java 严格遵守该标准。这些硬件考虑多年来已不再相关，因此 Java 17 将默认返回 IEEE 标准。使用`strictfp`关键字将会发出警告，因为它已不再必要。

`synchronized`

`synchronized`修饰符使方法具有线程安全性。在线程调用`synchronized`方法之前，它必须获取方法类（对于静态方法）或类的相关实例（对于非静态方法）的锁定。这可以防止两个线程同时执行该方法。

`synchronized`修饰符是一个实现细节（因为方法可以以其他方式使自己线程安全），并不是方法规范或 API 的正式部分。良好的文档明确指定方法是否线程安全；在处理多线程程序时，不应依赖于`synchronized`关键字的存在或缺失。

###### 提示

注解是一个有趣的特例（详见第四章关于注解的更多内容）——它们可以被看作是方法修饰符和额外补充类型信息之间的一种中间形式。

## Checked 和 Unchecked Exceptions

Java 的异常处理方案区分为两种类型的异常，称为*checked*和*unchecked*异常。

区分 checked 和 unchecked 异常与异常可能被抛出的情况有关。Checked 异常发生在特定而明确定义的情况下，并且应用程序可能能够部分或完全恢复。

例如，考虑一些可能在几个可能的目录中找到其配置文件的代码。如果尝试从不存在的目录中打开文件，则会抛出`FileNotFoundException`。在我们的例子中，我们希望捕获此异常并继续尝试文件的下一个可能位置。换句话说，虽然文件不存在是一个异常情况，但这是一个我们可以恢复的情况，并且是一种可以理解和预见的失败。

另一方面，在 Java 环境中，存在一组无法轻易预测或预见的失败，原因可能是运行时条件或滥用库代码。例如，无法有效预测`OutOfMemoryError`，而且任何使用对象或数组的方法，如果传递了无效的`null`参数，都可能抛出`NullPointerException`。

这些是未检查的异常——基本上任何方法都可能在任何时候抛出未检查的异常。它们是 Java 环境版本的墨菲定律：“任何可能出错的事情，最终都会出错。” 由于它们的完全不可预测性，从未检查的异常中恢复通常非常困难，甚至是不可能的。

要确定异常是已检查还是未检查的，记住异常是 `Throwable` 对象，这些对象分为两大类，由 `Error` 和 `Exception` 子类指定。任何 `Error` 类型的异常对象都是未检查的。还有一个名为 `RuntimeException` 的 `Exception` 子类——任何 `RuntimeException` 子类也都是未检查的异常。所有其他异常都是已检查的异常。

### 处理已检查的异常

Java 对处理已检查和未检查的异常有不同的规则。如果你编写一个会抛出已检查异常的方法，你必须在方法签名中使用 `throws` 子句来声明异常。Java 编译器会检查你是否在方法签名中声明了它们，如果没有声明就会产生编译错误（这就是它们被称为“已检查的异常”的原因）。

即使你自己从不抛出已检查的异常，有时你也必须使用 `throws` 子句来声明已检查的异常。如果你的方法调用了一个可能抛出已检查异常的方法，你必须要么包含处理异常的代码来处理该异常，要么使用 `throws` 来声明你的方法也可以抛出该异常。

例如，以下方法尝试估算网页的大小——它使用标准的 `java.net` 库和类 `URL`（我们将在第十章中了解到这些内容）来联系网页。它使用可能抛出各种类型的 `java.io.IOException` 对象的方法和构造函数，因此它使用 `throws` 子句声明了这一事实：

```java
public static estimateHomepageSize(String host) throws IOException {
    URL url = new URL("htp://"+ host +"/");
    try (InputStream in = url.openStream()) {
        return in.available();
    }
}
```

实际上，前面的代码有一个错误：我们拼错了协议说明符——*htp://* 并不存在这样的协议。所以，`estimateHomepageSize()` 方法将始终失败并抛出 `MalformedURLException`。

你怎么知道你正在调用的方法是否会抛出已检查的异常？你可以查看它的方法签名来找出。或者，如果你调用了必须处理或声明异常的方法，Java 编译器会告诉你（通过报告编译错误）。

## 可变长度的参数列表

方法可以声明接受和被调用时传递可变数量的参数。这样的方法通常称为 *varargs* 方法。 “print formatted” 方法 `System.out.printf()` 以及相关的 `String` 的 `format()` 方法使用 varargs，`java.lang.reflect` 的 Reflection API 中的一些重要方法也是如此。

要声明一个可变长度的参数列表，请在方法的最后一个参数的类型后面跟着省略号（`...`），表示这个最后一个参数可以重复零次或更多次。例如：

```java
public static int max(int first, int... rest) {
    /* body omitted for now */
}
```

可变参数方法由编译器纯粹处理。它们通过将可变数量的参数转换为数组来运作。对于 Java 运行时而言，`max()`方法与此方法无异：

```java
public static int max(int first, int[] rest) {
    /* body omitted for now */
}
```

要将可变参数签名转换为“真实”签名，只需将`...`替换为`[ ]`。请记住，参数列表中只能出现一个省略号，并且它只能出现在列表中的最后一个参数上。

让我们稍微详细说明一下`max()`的示例：

```java
public static int max(int first, int... rest) {
    int max = first;
    for(int i : rest) { // legal because rest is actually an array
        if (i > max) max = i;
    }
    return max;
}
```

这个`max()`方法声明了两个参数。第一个参数是一个普通的`int`值。然而，第二个参数可以重复零次或多次。以下所有调用`max()`方法的方式都是合法的：

```java
max(0)
max(1, 2)
max(16, 8, 4, 2, 1)
```

因为可变参数方法被编译为期望一个参数数组的方法，调用这些方法被编译为包括创建和初始化这样一个数组的代码。因此，调用`max(1,2,3)`被编译为这样：

```java
max(1, new int[] { 2, 3 })
```

实际上，如果您已经将方法参数存储在数组中，您可以合法地以这种方式将它们传递给方法，而不是逐个写出它们。您可以将任何`...`参数视为已声明为数组。然而，反之则不成立：只有当方法实际上使用省略号声明为可变参数方法时，您才能使用可变参数方法调用语法。

# 类和对象介绍

现在我们已经介绍了操作符、表达式、语句和方法，我们终于可以讨论类了。*类*是一个命名的字段集合，其中包含存储数据值和操作这些值的方法。类只是 Java 支持的五种引用类型之一，但它们是最重要的类型。类在单独的章节中有详细的文档说明（第三章）。然而，我们在这里介绍它们，是因为它们是方法之后的下一个更高级别的语法，以及本章的其余部分需要对类的概念有基本的熟悉，以及定义类、实例化类和使用生成的*对象*的基本语法。

类最重要的一点是它们定义了新的数据类型。例如，您可以定义一个名为`Account`的类来表示一个持有余额的银行账户。该类将定义字段来存储数据项，如余额（可能表示为`double`）、账户持有人的姓名和地址（作为`String`实例），以及操作账户的方法。`Account`类就是一个新的数据类型。

在讨论数据类型时，区分数据类型本身和数据类型表示的值是很重要的。`char`是一个数据类型：它表示 Unicode 字符。但是`char`值表示一个具体的字符。类是一种数据类型；一个类的值称为*对象*。我们使用类名是因为每个类定义了一种对象的类型（或种类、类别、类）。`Account`类是一个表示银行账户的数据类型，而`Account`对象表示一个具体的账户。正如你可以想象的那样，类和它们的对象是紧密联系的。接下来的章节中，我们将讨论这两者。

## 定义一个类

这里是我们讨论过的`Account`类的一个可能定义：

```java
/** Represents a customer bank account */
public class Account {
     public String name;
     public double balance;
     public int accountId;

     // A constructor that initializes the fields
     public Account(String name, double openingBalance, int id) {
         this.name = name;
         this.balance = openingBalance;
         this.accountId = id;
     }
}
```

此类定义存储在名为*Account.java*的文件中，并编译为名为*Account.class*的文件，可供 Java 程序和其他类使用。这里提供类定义是为了完整性和提供上下文，但不要期望立即理解所有细节；第三章大部分内容专注于类定义的主题。

请记住，在 Java 程序中，你不必定义每个想要使用的类。Java 平台包含成千上万的预定义类，保证在运行给定版本 Java 的每台计算机上都可用。

## 创建对象

现在我们已经将`Account`类定义为一个新的数据类型，我们可以使用以下行来声明一个变量，以保存`Account`对象：

```java
Account a;
```

声明一个变量来持有`Account`对象并不会创建对象本身。要实际创建一个对象，你必须使用`new`操作符。这个关键字后面跟着对象的类（即其类型）和一个可选的参数列表在括号中。这些参数被传递给类的构造函数，构造函数初始化新对象的内部字段：

```java
// Declare variable a and store a reference to new Account object
Account a = new Account("Jason Clark", 0.0, 42);

// Create some other objects as well
// An object that represents the current time
LocalDateTime d = new LocalDateTime();

// A HashSet object to hold a set of strings
Set<String> words = new HashSet<>();
```

在 Java 中，`new`关键字是创建对象最常见的方式。还有几种方式也值得一提。首先，符合特定标准的类非常重要，Java 为这些类型的对象创建定义了特殊的字面语法（如我们稍后在本节讨论）。其次，Java 支持一种机制，允许程序加载类并动态创建这些类的实例。详细信息请参见第十一章。最后，对象也可以通过反序列化来创建。已经保存其状态（通常是到文件）的对象可以使用`java.io.ObjectInputStream`类重新创建。

## 使用对象

现在我们已经看到如何定义类并通过创建对象进行实例化，我们需要查看允许我们使用这些对象的 Java 语法。请记住，一个类定义了一组字段和方法。每个对象都有它自己的这些字段的副本，并且可以访问这些方法。我们使用点字符（.）来访问对象的命名字段和方法。例如：

```java
Account a = new Account("Jason", 0.0, 42);  // Create an object

double b  = a.balance;                 // Read a field of the object
a.balance = a.balance + 10.0;          // Set the value of a field

String s  = a.toString();              // Access a method of the object
```

当在面向对象的语言中编程时，这种语法非常常见，Java 也不例外。特别要注意，表达式`a.toString()`。这告诉 Java 编译器查找一个名为`toString`的方法（该方法由`Account`的父类`Object`定义），并使用该方法在对象`a`上执行计算。我们将在第三章中详细讨论此操作的细节。

## 对象字面量

在我们讨论原始类型时，我们看到每个原始类型都有一个文字语法，用于将该类型的值文字地包含到程序的文本中。Java 还定义了几种特殊引用类型的文字语法，如下所述。

### 字符串字面量

`String`类将文本表示为字符串。因为程序通常通过书面文字与用户进行交流，所以在任何编程语言中，操作文本字符串的能力非常重要。在 Java 中，字符串是对象；用于表示文本的数据类型是`String`类。现代 Java 程序通常使用比其他任何数据类型都更多的字符串数据。

因此，由于字符串是如此基础的数据类型，Java 允许您以两种格式之一直接在程序中包含文本。传统字符串放置在双引号（`"`）字符之间，或者可以在三个双引号字符序列（`"""`）之间使用较新的文本块形式。

传统的双引号字符串看起来像这样：

```java
String name = "David";
System.out.println("Hello, " + name);
```

不要将包围字符串字面量的双引号字符与包围`char`字面量的单引号（或撇号）字符混淆。

任何一种形式的字符串字面量都可以包含`char`字面量可以使用的任何转义序列（见表 2-2）。传统的双引号字符串需要转义序列来嵌入双引号字符或换行符。它们还必须在我们的 Java 代码中是单行的。例如：

```java
String story = "\t\"How can you stand it?\" he asked sarcastically.\n";
```

文本块的主要用途而不是传统字符串是表示多行字符串。文本块以`"""`开头，后跟换行符，并在遇到结尾的`"""`时结束。

除了支持多行字符串外，文本块还允许我们在不转义的情况下使用双引号。这通常使得文本块在阅读时更加容易，特别是在我们的 Java 代码中表达另一种编程语言（如 SQL 或 HTML）时。

```java
String html = """
 <html>
 <body class="main-body">
 ...
 </body>
 </html>""";
System.out.println(html);
```

从这段代码的输出中可以看出文本块关于缩进的另一个有趣事实。上述内容在输出的第一列中打印`<html>`，没有前导空格。

编译器找到文本块各行中的最小缩进，并从每行中剥离相同数量的前导空格。如果不希望这样做，闭合的`"""`的放置位置也参与选择缩进。我们可以通过以下方式保留完整的空白：

```java
String html = """
 <html>
 <body class="main-body">
 ...
 </body>
 </html>
""";  // As smallest indent (0), this leaves the text block as written

System.out.println(html);
```

在 Java 引入文本块之前，通常使用`+`将字符串字面量拆分为更易读的部分。与现有的许多代码库一样，如果您的字符串不应包含换行符，这仍然是一种有效的技术。

```java
// This is illegal
// Traditional string literals cannot break across lines.
String x = "This is a test of the
 emergency broadcast system";

// Common before text blocks
// Still useful if avoiding newlines in the text
String s = "This is a test of the " +
           "emergency broadcast system";
```

当您的程序编译时，无论是传统文字块还是文字块，文字都会被连接起来，而不是在运行时，因此您不必担心任何性能损失的问题。

### 类型字面量

支持其特殊对象文字语法的第二类是名为`Class`的类。`Class`类的实例表示 Java 数据类型，并包含有关所引用类型的元数据。要在 Java 程序中直接包含`Class`对象，请在任何数据类型的名称后跟`.class`。例如：

```java
Class<?> typeInt = int.class;
Class<?> typeIntArray = int[].class;
Class<?> typeAccount = Account.class;
```

### 空引用

`null`关键字是一个特殊的字面量值，它是对空值的引用，或者说是引用的缺失。`null`值之所以独特，是因为它是每种引用类型的成员。您可以将`null`赋给任何引用类型的变量。例如：

```java
String s = null;
Account a = null;
```

## Lambda 表达式

Java 8 引入了一个重要的新功能——*lambda 表达式*。这些是非常常见的编程语言构造，特别是在被称为*函数式编程语言*的语言家族中广泛使用（例如，Lisp，Haskell 和 OCaml）。Lambda 的强大和灵活性远远超出了仅仅在函数式语言中，它们几乎可以在所有现代编程语言中找到应用。

Lambda 表达式的语法如下：

```java
( *`paramlist`* ) -> { *`statements`* }

```

一个简单而非常传统的例子：

```java
Runnable r = () -> System.out.println("Hello World");
```

当 lambda 表达式用作值时，它会自动转换为正确类型的新对象，以便放入变量中。这种自动转换和*类型推断*对于 Java 的 lambda 表达式方法至关重要。不幸的是，它依赖于对 Java 类型系统作为整体的正确理解。"嵌套类型"提供了对 lambda 表达式的更详细解释——因此，现在简单地认识 lambda 的语法就足够了。

一个稍微复杂的例子：

```java
ActionListener listener = (e) -> {
  System.out.println("Event fired at: "+ e.getWhen());
  System.out.println("Event command: "+ e.getActionCommand());
};
```

# 数组

*数组*是一种特殊类型的对象，它保存零个或多个原始值或引用。这些值保存在数组的*元素*中，这些元素是由其位置或*索引*引用的未命名变量。数组的类型由其*元素类型*所特征化，并且数组的所有元素都必须是该类型的。

数组元素从零开始编号，有效索引范围从零到元素数量减一。例如，索引为 1 的数组元素是数组中的*第二*个元素。数组的元素数量是其*length*。数组的长度在创建数组时指定，且永远不会改变（不像 Java 集合，在第八章中我们将会看到）。

数组的元素类型可以是任何有效的 Java 类型，包括数组类型。这意味着 Java 支持数组的数组，提供了一种多维数组的能力。Java 不支持某些语言中的矩阵式多维数组。

尽管 Java 的集合 API 在第八章中得到了全面的覆盖，通常比基本数组更灵活和功能丰富，但数组在整个平台上仍然很常见，值得了解其详细使用细节。

## 数组类型

数组类型是引用类型，就像类一样。数组的实例是对象，就像类的实例一样。^(4) 与类不同，数组类型不必被定义。只需在元素类型后面放置方括号即可。例如，以下代码声明了三个数组类型的变量：

```java
byte b;                        // byte is a primitive type
byte[] arrayOfBytes;           // byte[] is an array of byte values
byte[][] arrayOfArrayOfBytes;  // byte[][] is an array of byte[]
String[] strings;              // String[] is an array of strings
```

数组的长度不是数组类型的一部分。例如，不可能声明一个期望恰好有四个`int`值的数组的方法。如果方法参数是`int[]`类型，调用者可以传递包括零在内的任意数量的元素的数组。

数组类型不是类，但数组实例是对象。这意味着数组继承了`java.lang.Object`的方法。数组实现了`Cloneable`接口，并重写了`clone()`方法以确保数组始终可以被克隆，并且`clone()`永远不会抛出`CloneNotSupportedException`异常。数组还实现了`Serializable`接口，因此如果其元素类型可以序列化，任何数组都可以被序列化。最后，所有数组都有一个名为`length`的`public final int`字段，指定数组中元素的数量。

### 数组类型扩展转换

因为数组扩展了`Object`并实现了`Cloneable`和`Serializable`接口，任何数组类型都可以扩展到这三种类型中的任何一种。但某些数组类型也可以扩展到其他数组类型。如果数组的元素类型是引用类型`T`，并且`T`可以分配给类型`S`，则数组类型`T[]`可以分配给数组类型`S[]`。请注意，对于给定原始类型的数组，没有此类扩展转换。例如，以下代码行展示了合法的数组扩展转换示例：

```java
String[] arrayOfStrings;      // Created elsewhere
int[][] arrayOfArraysOfInt;   // Created elsewhere

// String is assignable to Object,
// so String[] is assignable to Object[]
Object[] oa = arrayOfStrings;

// String implements Comparable, so a String[] can
// be considered a Comparable[]
Comparable[] ca = arrayOfStrings;

// An int[] is an Object, so int[][] is assignable to Object[]
Object[] oa2 = arrayOfArraysOfInt;

// All arrays are cloneable, serializable Objects
Object o = arrayOfStrings;
Cloneable c = arrayOfArraysOfInt;
Serializable s = arrayOfArraysOfInt[0];
```

这种将数组类型扩展到另一个数组类型的能力意味着数组的编译时类型并不总是与其运行时类型相同。

###### 提示

这种扩展称为*数组协变性*，正如我们将在“有界类型参数”中看到的，根据现代标准，它被视为历史遗留和误操作，因为它暴露了编译时和运行时类型之间的不匹配。

编译器通常必须在将引用值存储到数组元素之前插入运行时检查，以确保值的运行时类型与数组元素的运行时类型匹配。如果运行时检查失败，则抛出`ArrayStoreException`。

### C 兼容性语法

正如我们所见，通过在元素类型后放置方括号，您可以简单地编写数组类型。但是，为了与 C 和 C++兼容，Java 还支持变量声明中的另一种语法：方括号可以放置在变量名称后，而不是或者除了元素类型之外。这适用于局部变量、字段和方法参数。例如：

```java
// This line declares local variables of type int, int[] and int[][]
int justOne, arrayOfThem[], arrayOfArrays[][];

// These three lines declare fields of the same array type:
public String[][] aas1;   // Preferred Java syntax
public String aas2[][];   // C syntax
public String[] aas3[];   // Confusing hybrid syntax

// This method signature includes two parameters with the same type
public static double dotProduct(double[] x, double y[]) { ... }
```

###### 提示

这种兼容性语法非常罕见，不建议使用。

## 创建和初始化数组

要在 Java 中创建数组值，您使用`new`关键字，就像创建对象一样。数组类型没有构造函数，但在创建数组时必须指定长度。将所需的数组大小指定为方括号内的非负整数：

```java
// Create a new array to hold 1024 bytes
byte[] buffer = new byte[1024];
// Create an array of 50 references to strings
String[] lines = new String[50];
```

当使用此语法创建数组时，每个数组元素都会自动初始化为类字段使用的相同默认值：布尔元素为`false`，字符元素为`\u0000`，整数元素为`0`，浮点数元素为`0.0`，引用类型的元素为`null`。

数组创建表达式也可用于创建和初始化数组的多维数组。这种语法稍微复杂，并且在本节后面有详细解释。

### 数组初始化器

要创建一个数组并在单个表达式中初始化其元素，省略数组长度，然后在方括号后跟随用逗号分隔的表达式列表，这些表达式在花括号内。每个表达式的类型必须可分配给数组元素类型，当然，所创建的数组的长度等于表达式的数量。在列表中的最后一个表达式后面包含尾逗号是合法的但不是必需的。例如：

```java
String[] greetings = new String[] { "Hello", "Hi", "Howdy" };
int[] smallPrimes = new int[] { 2, 3, 5, 7, 11, 13, 17, 19, };
```

请注意，此语法允许创建、初始化和使用数组，而无需将其分配给变量。在某种意义上，这些数组创建表达式是匿名数组字面量。以下是示例：

```java
// Call a method, passing an anonymous array literal that
// contains two strings
String response = askQuestion("Do you want to quit?",
                               new String[] {"Yes", "No"});

// Call another method with an anonymous array (of anonymous objects)
double d = sumAccounts(new Account[] { new Account("1st", 100.0, 1),
                                       new Account("2nd", 200.0, 2),
                                       new Account("3rd", 300.0, 3) });
```

当数组初始化器是变量声明的一部分时，您可以省略`new`关键字、元素类型并在花括号内列出所需的数组元素：

```java
String[] greetings = { "Hello", "Hi", "Howdy" };
int[] powersOfTwo = {1, 2, 4, 8, 16, 32, 64, 128};
```

在程序运行时创建和初始化数组文字，而不是在编译程序时。考虑以下数组文字：

```java
int[] perfectNumbers = {6, 28};
```

这被编译成等同于 Java 字节码的内容：

```java
int[] perfectNumbers = new int[2];
perfectNumbers[0] = 6;
perfectNumbers[1] = 28;
```

Java 在运行时执行所有数组初始化的事实具有一个重要的推论。这意味着数组初始化器中的表达式可以在运行时计算，而不必是编译时常量。例如：

```java
Account[] accounts = { findAccountById(1), findAccountById(2) };
```

## 使用数组

一旦数组被创建，您就可以开始使用它了。以下各节解释了对数组元素的基本访问，并涵盖了数组使用的常见习惯用法，例如遍历数组元素和复制数组或数组的一部分。

### 访问数组元素

数组的元素是变量。当数组元素出现在表达式中时，它会评估为元素中保存的值。当数组元素出现在赋值运算符的左侧时，会将新值存储到该元素中。然而，与普通变量不同，数组元素没有名称，只有一个数字。数组元素使用方括号表示法进行访问。如果`a`是一个评估为数组引用的表达式，那么您可以通过`a[i]`进行数组索引，并引用特定元素，其中`i`是一个整数字面值或一个评估为`int`的表达式。例如：

```java
// Create an array of two strings
String[] responses = new String[2];
responses[0] = "Yes";  // Set the first element of the array
responses[1] = "No";   // Set the second element of the array

// Now read these array elements
System.out.println(question + " (" + responses[0] + "/" +
                   responses[1] + " ): ");

// Both the array reference and the array index may be more complex
double datum = data.getMatrix()[data.row() * data.numColumns() +
                   data.column()];
```

数组索引表达式必须是`int`类型，或者可以扩展为`int`的类型：`byte`，`short`，甚至`char`。显然，使用`boolean`，`float`或`double`值索引数组是不合法的。请记住，数组的`length`字段是一个`int`，并且数组的元素不得超过`Integer.MAX_VALUE`。使用`long`类型的表达式对数组进行索引会生成编译时错误，即使该表达式在运行时的值在`int`范围内也是如此。

### 数组边界

请记住，数组`a`的第一个元素是`a[0]`，第二个元素是`a[1]`，最后一个元素是`a[a.length-1]`。

关于数组的一个常见 bug 是使用太小的索引（负索引）或太大的索引（大于或等于数组`长度`）。在像 C 或 C++这样的语言中，访问数组开始之前或结束之后的元素会产生不可预测的行为，这种行为可能会因调用方式和平台而异。这样的 bug 可能并不总是被捕获到，如果发生故障，则可能会在稍后的某个时间发生。虽然在 Java 中编写有错误的数组索引代码同样容易，但 Java 通过在运行时检查每次数组访问来保证可预测的结果。如果数组索引太小或太大，Java 会立即抛出一个`ArrayIndexOutOfBoundsException`。

### 迭代数组

常见的做法是编写循环，按顺序遍历数组的每个元素，以执行某些操作。这通常使用`for`循环来完成。例如，以下代码计算整数数组的总和：

```java
int[] primes = { 2, 3, 5, 7, 11, 13, 17, 19, 23 };
int sumOfPrimes = 0;
for(int i = 0; i < primes.length; i++)
    sumOfPrimes += primes[i];
```

此`for`循环的结构是惯用的，您将经常看到它。Java 还具有我们已经遇到的 foreach 语法。求和代码可以简洁地重写为：

```java
for(int p : primes) sumOfPrimes += p;
```

### 复制数组

所有数组类型都实现了 `Cloneable` 接口，可以通过调用其 `clone()` 方法进行复制。需要注意的是，需要将返回值强制转换为适当的数组类型，但数组的 `clone()` 方法保证不会抛出 `CloneNotSupportedException`：

```java
int[] data = { 1, 2, 3 };
int[] copy = data.clone();
```

`clone()` 方法生成一个浅拷贝。如果数组的元素类型是引用类型，则只复制引用，而不是引用对象本身。由于是浅拷贝，任何数组都可以被克隆，即使元素类型本身不是 `Cloneable`。

有时你只是想将一个现有数组的元素复制到另一个现有数组中。`System.arraycopy()` 方法旨在高效地完成此操作，并且可以假定 Java VM 实现会使用基础硬件上的高速块复制操作执行此方法。

`arraycopy()` 是一个简单的函数，唯一难以使用的地方在于需要记住五个参数。首先，传递要复制元素的源数组。其次，传递该数组中起始元素的索引。作为第三和第四个参数，传递目标数组和目标索引。最后，作为第五个参数，指定要复制的元素数量。

`arraycopy()` 即使在同一数组内进行重叠复制也能正确工作。例如，如果你从数组 `a` 中“删除”了索引为 `0` 的元素，并希望将索引在 `1` 到 `n` 之间的元素向下移动一个位置，使它们占据索引 `0` 到 `n-1`，你可以这样做：

```java
System.arraycopy(a, 1, a, 0, n);
```

### 数组工具

`java.util.Arrays` 类包含许多用于处理数组的静态实用方法。大多数这些方法都有重载版本，用于每种基本类型的数组以及对象数组的另一个版本。

`sort()` 和 `binarySearch()` 方法特别适用于对数组进行排序和搜索。`equals()` 方法允许你比较两个数组的内容。当你希望将数组内容转换为字符串（例如用于调试或记录输出）时，`toString()` 方法非常有用。如果你可以接受分配新数组而不是将其复制到现有数组中，`copyOf()` 是我们之前看到的 `arraycopy()` 的一个有用的替代方法。

`Arrays` 类还包括 `deepEquals()`、`deepHashCode()` 和 `deepToString()` 方法，适用于多维数组并能正确工作。

## 多维数组

正如我们所见，数组类型写作元素类型后跟一对方括号。`char` 类型的数组是 `char[]`，`char` 数组的数组是 `char[][]`。当数组的元素本身是数组时，我们称该数组为 *多维数组*。为了处理多维数组，你需要了解一些额外的细节。

想象一下，你想使用多维数组来表示一个乘法表：

```java
int[][] products;      // A multiplication table
```

每对方括号表示一个维度，因此这是一个二维数组。要访问这个二维数组中的单个`int`元素，必须指定两个索引值，一个用于每个维度。假设该数组实际上被初始化为一个乘法表，那么存储在任何给定元素处的`int`值将是两个索引的乘积。也就是说，`products[2][4]`将是 8，而`products[3][7]`将是 21。

要创建一个新的多维数组，使用`new`关键字并指定数组的两个维度的大小。例如：

```java
int[][] products = new int[10][10];
```

在某些语言中，像这样的数组会创建为 100 个`int`值的单个块。但 Java 不是这样工作的。这行代码执行三件事：

+   声明一个名为`products`的变量，用于保存一个`int`数组的数组。

+   创建一个包含 10 个元素的数组，用于保存 10 个`int`数组。

+   创建 10 个新数组，每个数组都是一个包含 10 个`int`元素的数组。它将这 10 个新数组分配给初始数组的元素。每个这 10 个新数组的每个`int`元素的默认值都是 0。

换句话说，前一行代码相当于以下代码：

```java
int[][] products = new int[10][]; // An array to hold 10 int[] values
for(int i = 0; i < 10; i++)      // Loop 10 times...
    products[i] = new int[10];   // ...and create 10 arrays
```

`new`关键字自动为您执行此附加初始化。它也适用于超过两个维度的数组：

```java
float[][][] globalTemperatureData = new float[360][180][100];
```

当使用`new`创建多维数组时，您不必为数组的所有维度指定大小，只需指定最左边的维度或维度。例如，以下两行是合法的：

```java
float[][][] globalTemperatureData = new float[360][][];
float[][][] globalTemperatureData = new float[360][180][];
```

第一行创建一个单维数组，其中每个数组元素可以容纳一个`float[][]`。第二行创建一个二维数组，其中每个数组元素是一个`float[]`。然而，如果只为某些维度指定了大小，则这些维度必须是最左边的。以下行不合法：

```java
float[][][] globalTemperatureData = new float[360][][100];  // Error!
float[][][] globalTemperatureData = new float[][180][100];  // Error!
```

像一维数组一样，可以使用数组初始化器初始化多维数组。只需使用嵌套的花括号来嵌套数组。例如，我们可以像这样声明、创建和初始化一个 5×5 的乘法表：

```java
int[][] products = { {0, 0, 0, 0, 0},
                     {0, 1, 2, 3, 4},
                     {0, 2, 4, 6, 8},
                     {0, 3, 6, 9, 12},
                     {0, 4, 8, 12, 16} };
```

或者，如果要使用多维数组而不声明变量，可以使用匿名初始化器语法：

```java
boolean response = bilingualQuestion(question, new String[][] {
                                                   { "Yes", "No" },
                                                   { "Oui", "Non" }});
```

当使用`new`关键字创建多维数组时，通常最好使用*矩形*数组：即每个维度的所有数组值都具有相同的大小。

# 引用类型

现在我们已经讨论了数组并引入了类和对象，我们可以转向对*引用类型*的更一般描述。类和数组是 Java 的五种引用类型之一。类在前面介绍过，并且详细介绍了*接口*，在第三章中进行了详细介绍。枚举类型和注解类型是在第四章中引入的引用类型。

本节不涵盖任何特定引用类型的具体语法，而是解释引用类型的一般行为，并说明它们与 Java 的原始类型的区别。在本节中，“对象”一词指的是任何引用类型的值或实例，包括数组。

## 引用类型与原始类型

引用类型和对象与原始类型及其原始值有很大的不同：

Java 语言定义了八种原始类型，程序员不能定义新的原始类型。

引用类型是用户定义的，因此它们的数量是无限的。例如，程序可以定义一个名为`Account`的类，并使用这种新定义类型的对象来存储和跟踪用户的银行账户。

原始类型表示单个值。

引用类型是聚合类型，可以持有零个或多个原始值或对象。例如，我们假设的`Account`类可能持有一个用于余额的数值，以及用于账户所有者的标识符。`char[]`和`Account[]`数组类型是聚合类型，因为它们持有一系列原始`char`值或`Account`对象。

原始类型需要 1 到 8 字节的内存。

当原始值存储在变量中或传递给方法时，计算机会复制持有值的字节。另一方面，对象可能需要更多内存。对象的存储空间在对象创建时动态分配在堆上，并且当对象不再需要时，此存储空间会自动进行“垃圾收集”。

###### 提示

当对象被分配给变量或传递给方法时，并不会复制表示对象的内存。相反，只会存储对该内存的引用在变量中或传递给方法。

在 Java 中，引用完全是不透明的，引用的表示是 Java 运行时的实现细节。然而，如果你是 C 程序员，可以安全地将引用想象为指针或内存地址。请记住，Java 程序不能以任何方式操作引用。

与 C 和 C++中的指针不同，Java 中的引用不能转换为或从整数转换，并且不能递增或递减。C 和 C++程序员还应注意，Java 不支持`&`取地址运算符或`*`和`->`解引用运算符。

## 操纵对象和引用副本

以下代码操作一个原始的`int`值：

```java
int x = 42;
int y = x;
```

执行这些行之后，变量`y`包含了变量`x`中持有值的副本。在 Java 虚拟机内部，有两个独立的 32 位整数 42 的副本。

现在想象一下，如果我们运行相同的基本代码，但使用引用类型而不是原始类型会发生什么：

```java
Account a = new Account("Jason", 0.0, 42);
Account b = a;
```

代码运行后，变量`b`保存了变量`a`中保存的引用的副本。在虚拟机中仍然只有一个`Account`对象的拷贝，但现在有两个引用指向该对象。这有一些重要的含义。假设前两行代码后面跟着这段代码：

```java
System.out.println(a.balance);  // Print out balance of a: 0.0
b.balance = 13.0;               // Now change balance of b
System.out.println(a.balance);  // Print a's balance again: 13.0
```

因为变量`a`和`b`保存对同一对象的引用，因此可以使用任一变量来对对象进行更改，并且这些更改也会通过另一个变量可见。由于数组是一种对象，因此对数组也会发生同样的情况，如下面的代码所示：

```java
// greet holds an array reference
char[] greet = { 'h','e','l','l','o' };
char[] cuss = greet;             // cuss holds the same reference
cuss[4] = '!';                   // Use reference to change an element
System.out.println(greet);       // Prints "hell!"
```

在将参数传递给方法时，原始类型和引用类型之间的行为也存在类似的差异。考虑以下方法：

```java
void changePrimitive(int x) {
    while(x > 0) {
        System.out.println(x--);
    }
}
```

当调用此方法时，方法会获得用于调用方法的参数的私有副本，该参数保存在参数`x`中。方法中的代码将`x`用作循环计数器，并将其递减到零。由于`x`是原始类型，方法有自己的私有副本，因此这是完全合理的操作。

另一方面，考虑如果修改方法使参数成为引用类型会发生什么：

```java
void changeReference(Account b) {
    while (b.balance > 0) {
        System.out.println(b.balance--);
    }
}
```

当调用此方法时，会传递一个对`Account`对象的私有引用副本，并可以使用此引用来改变`Account`对象。例如，考虑：

```java
Account a = new Account("Jason", 3.0, 42);  // Account balance: 3.0
changeReference(a);             // Prints 3,2,1 and modifies the Account
System.out.println(a.balance);  // The balance of a is now 0!
```

当调用`changeReference()`方法时，会传递变量`a`中保存的引用的副本给方法。现在变量`a`和方法参数`b`都保存着指向同一对象的引用。方法可以使用它的引用来改变对象的内容。但请注意，它不能改变变量`a`的内容。换句话说，方法可以彻底改变`Account`对象，但不能改变变量`a`引用该对象的事实。

## 比较对象

我们已经看到，原始类型和引用类型在赋值给变量、传递给方法和复制时存在显著差异。这些类型在比较相等性时也存在差异。当与原始值一起使用时，等号操作符（`==`）简单地测试两个值是否相同（即它们是否具有完全相同的位）。然而，与引用类型一起使用时，`==`比较的是引用，而不是实际对象。换句话说，`==`测试两个引用是否引用同一对象；它不测试两个对象是否具有相同的内容。以下是一个例子：

```java
String letter = "o";
String s = "hello";              // These two String objects
String t = "hell" + letter;      // contain exactly the same text.
if (s == t) System.out.println("equal"); // But they are not equal!

byte[] a = { 1, 2, 3 };
// A copy with identical content.
byte[] b = (byte[]) a.clone();
if (a == b) System.out.println("equal"); // But they are not equal!
```

当使用引用类型时，请记住有两种相等性：引用相等性和对象相等性。重要的是要区分这两种相等性。在谈论引用相等性时，一种方法是使用“相同”这个词，而在谈论拥有相同内容的两个不同对象时，使用“相等”。要测试两个非相同对象的相等性，将其中一个传递给另一个的`equals()`方法即可：

```java
String letter = "o";
String s = "hello";              // These two String objects
String t = "hell" + letter;      // contain exactly the same text.
if (s.equals(t)) {               // And the equals() method
    System.out.println("equal"); // tells us so.
}
```

所有对象都继承了一个`equals()`方法（来自`Object`），但默认实现只是使用`==`来测试引用的身份，而不是内容的相等性。想要允许对象比较相等性的类可以定义自己版本的`equals()`方法。我们的`Account`类没有这样做，但`String`类做了，正如代码示例中所示。你可以在数组上调用`equals()`方法，但它与使用`==`运算符相同，因为数组始终继承默认的`equals()`方法，该方法比较引用而不是数组内容。你可以使用`java.util.Arrays.equals()`便捷方法来比较数组的相等性。

## 装箱和拆箱转换

原始类型和引用类型行为大不相同。有时将原始值视为对象是有用的，因此 Java 平台为每个原始类型包括一个*包装类*。`Boolean`、`Byte`、`Short`、`Character`、`Integer`、`Long`、`Float`和`Double`是不可变的、终态的类，它们的每个实例都持有单个原始值。当你想要在诸如`java.util.List`之类的集合中存储原始值时，通常使用这些包装类：

```java
// Create a List-of-Integer collection
List<Integer> numbers = new ArrayList<>();
// Store a wrapped primitive
numbers.add(Integer.valueOf(-1));
// Extract the primitive value
int i = numbers.get(0).intValue();
```

Java 允许称为装箱和拆箱转换的类型转换。装箱转换将原始值转换为其对应的包装对象，而拆箱转换则相反。你可以在变量赋值或将值传递给方法时显式指定装箱或拆箱转换，但这是不必要的，因为当你将值分配给变量或将值传递给方法时，这些转换会自动进行。此外，如果在 Java 运算符或语句期望原始值时使用包装对象，则拆箱转换也是自动的。由于 Java 自动执行装箱和拆箱，这种语言特性通常称为*自动装箱*。

这里是一些自动装箱和拆箱转换的示例：

```java
Integer i = 0;   // int literal 0 boxed to an Integer object
Number n = 0.0f; // float literal boxed to Float and widened to Number
Integer i = 1;   // this is a boxing conversion
int j = i;       // i is unboxed here
i++;             // i is unboxed, incremented, and then boxed up again
Integer k = i+2; // i is unboxed and the sum is boxed up again
i = null;
j = i;           // unboxing here throws a NullPointerException
```

自动装箱使得处理集合变得更加容易。让我们看一个使用 Java 的*泛型*（我们将在“Java 泛型”中详细了解的语言特性）的示例，它允许我们限制可以放入列表和其他集合的类型：

```java
List<Integer> numbers = new ArrayList<>(); // Create a List of Integer
numbers.add(-1);                           // Box int to Integer
int i = numbers.get(0);                    // Unbox Integer to int
```

# 包和 Java 命名空间

*包*是一组命名的类、接口和其他引用类型。包用于组织相关类并为其包含的类定义命名空间。

Java 平台的核心类位于以`java`开头的包中。例如，语言的最基本类位于`java.lang`包中。各种实用类位于`java.util`中。输入和输出类位于`java.io`中，网络类位于`java.net`中。一些包含子包，如`java.lang.reflect`和`java.util.regex`。Oracle（或最初的 Sun）标准化的 Java 平台扩展通常具有以`javax`开头的包名。其中一些扩展，如`javax.swing`及其众多子包，后来被纳入核心平台。最后，Java 平台还包括几个“认可标准”，这些标准有以标准化组织名称命名的包，如`org.w3c`和`org.omg`。

每个类都有一个简单名称，在其定义中给出，以及一个完全限定名，其中包括其所属包的名称。例如，`String`类属于`java.lang`包，因此其完全限定名为`java.lang.String`。

本节解释了如何将自己的类和接口放入包中，以及如何选择不会与其他包名冲突的包名。接下来，它解释了如何选择性地导入类型名称或静态成员到命名空间，以便您不必为每个使用的类或接口输入包名。

## 包声明

要指定类所属的包，您使用一个`package`声明。如果出现`package`关键字，则必须是 Java 代码中的第一个标记（即除注释和空格外的第一件事）。关键字后面应跟所需包的名称和一个分号。考虑一个以此指令开头的 Java 文件：

```java
package org.apache.commons.net;
```

此文件定义的所有类都属于包`org.apache.commons.net`。

如果在 Java 文件中没有`package`指令，那么该文件中定义的所有类都属于一个未命名的默认包。在这种情况下，类的限定名和非限定名是相同的。

###### 提示

命名冲突的可能性意味着不应使用默认包。随着项目变得更加复杂，冲突几乎是不可避免的——最好从一开始就创建包。

## 全局唯一包名

包的重要功能之一是分隔 Java 命名空间，防止类之间的名称冲突。例如，只有它们的包名使得`java.util.List`和`java.awt.List`类不同。但为了使此机制生效，包名必须是唯一的。作为 Java 的开发者，Oracle 控制着所有以`java`、`javax`和`sun`开头的包名。

一个常见的方案是使用您的域名，将其元素反转，作为所有包名称的前缀。例如，Apache 项目作为 Apache Commons 项目的一部分生产了一个网络库。Commons 项目可以在 [*http://commons.apache.org*](http://commons.apache.org) 找到，因此用于网络库的包名称是 `org.apache.commons.net`。

请注意，这些包命名规则主要适用于 API 开发人员。如果其他程序员将使用您开发的类以及未知的其他类，则确保您的包名称在全球范围内是唯一的非常重要。另一方面，如果您正在开发一个 Java 应用程序，并且不会释放任何类供他人重用，那么您知道您的应用程序将部署的完整类集，并且无需担心意外的命名冲突。在这种情况下，您可以选择一个适合自己方便而不是全局唯一性的包命名方案。一个常见的方法是使用应用程序名称作为主要包名称（可以有其下的子包）。

## 导入类型

在 Java 代码中引用类或接口时，默认情况下必须使用类型的完全限定名称，包括包名称。如果您编写用于操作文件并且需要使用 `java.io` 包中的 `File` 类的代码，则必须输入 `java.io.File`。此规则有三个例外：

+   `java.lang` 包中的类型非常重要且常用，因此它们可以始终通过其简单名称引用。

+   类型 `p.T` 中的代码可以通过其简单名称引用包 `p` 中定义的其他类型。

+   使用 `import` 声明导入命名空间的类型可以通过其简单名称引用。

前两个例外被称为“自动导入”。`java.lang` 中的类型和当前包中的类型被“导入”到命名空间中，以便可以在不使用其包名称的情况下使用它们。快速输入不在 `java.lang` 或当前包中的常用类型的包名称会变得乏味，因此还可以明确地从其他包中导入类型到命名空间中。使用 `import` 声明完成此操作。

在 Java 文件中，`import` 声明必须出现在 `package` 声明（如果有的话）之后，任何类型定义之前的开头。您可以在文件中使用任意数量的 `import` 声明。一个 `import` 声明适用于文件中的所有类型定义（但不适用于其后的任何 `import` 声明）。

`import` 声明有两种形式。要将单个类型导入命名空间，请在 `import` 关键字后跟类型名称和分号：

```java
import java.io.File;    // Now we can type File instead of java.io.File
```

这被称为“单类型导入”声明。

另一种`import`声明形式是“按需类型`import`”。在此形式中，您指定包的名称，后跟`.*`字符，以指示可以使用该包中的任何类型而无需其包名称。因此，如果您想要除`File`类之外的`java.io`包中的几个其他类，您可以简单地导入整个包：

```java
import java.io.*;   // Use simple names for all classes in java.io
```

此按需`import`语法不适用于子包。如果我导入`java.util`包，我仍然必须通过其完全限定名或导入来引用`java.util.zip.ZipInputStream`类。

使用按需类型`import`声明与为包中的每个类型显式编写单个类型`import`声明并不相同。它更像是针对代码中*实际使用的*包中每个类型的显式单个类型`import`。这就是称为“按需”的原因；类型在使用时导入。

### 命名冲突和遮蔽

`import`声明对 Java 编程非常宝贵。然而，它们确实使我们面临命名冲突的可能性。考虑`java.util`和`java.awt`包。两者都包含名为`List`的类型。

`java.util.List`是一个重要且常用的接口。`java.awt`包含许多在客户端应用程序中常用的重要类型，但`java.awt.List`已过时，不是这些重要类型之一。在同一个 Java 文件中导入`java.util.List`和`java.awt.List`是非法的。以下单个类型`import`声明会产生编译错误：

```java
import java.util.List;
import java.awt.List;
```

使用两个包的按需类型导入是合法的：

```java
import java.util.*;  // For collections and other utilities.
import java.awt.*;   // For fonts, colors, and graphics.
```

然而，如果您确实尝试使用类型`List`，则会出现困难。此类型可以从任一包中“按需”导入，并且任何尝试将`List`作为未限定类型名称使用都会产生编译错误。在这种情况下的解决方法是明确指定您想要的包名称。

因为`java.util.List`比`java.awt.List`更常用，将这两个按需类型`import`声明与单个类型`import`声明结合起来以消除我们在说`List`时的歧义是有用的：

```java
import java.util.*;    // For collections and other utilities.
import java.awt.*;     // For fonts, colors, and graphics.
import java.util.List; // To disambiguate from java.awt.List
```

有了这些`import`声明，我们可以使用`List`来表示`java.util.List`接口。如果我们确实需要使用`java.awt.List`类，只要包括其包名称，我们仍然可以这样做。在`java.util`和`java.awt`之间没有其他命名冲突，并且在使用时，它们的类型将被“按需”导入而无需包名称。

## 导入静态成员

除了类型，您还可以使用关键字`import static`导入类型的静态成员。（静态成员在第三章中有解释。如果您对它们还不熟悉，可以稍后再回到本节。）与类型`import`声明类似，这些静态`import`声明有两种形式：单个静态成员`import`和按需静态成员`import`。例如，假设您正在编写一个向`System.out`发送大量输出的文本程序。在这种情况下，您可以使用单个静态成员`import`来节省输入：

```java
import static java.lang.System.out;
```

然后，您可以使用`out.println()`代替`System.out.println()`。或者假设您正在编写一个使用许多`Math`类的三角和其他函数的程序。在这种明显专注于数值方法的程序中，反复输入类名`Math`并没有增加代码的清晰度；它只是妨碍了代码的编写。在这种情况下，按需静态成员`import`可能是合适的：

```java
import static java.lang.Math.*
```

使用此`import`声明，您可以自由地编写像`sqrt(abs(sin(x)))`这样简洁的表达式，而无需为每个静态方法名称添加类名`Math`的前缀。

另一个`import static`声明的重要用途是将常量的名称导入到您的代码中。这在枚举类型中特别有效（参见第四章）。例如，假设您希望在编写的代码中使用此枚举类型的值：

```java
package climate.temperate;
enum Seasons { WINTER, SPRING, SUMMER, AUTUMN };
```

您可以导入类型`climate.temperate.Seasons`，然后使用类型名称前缀常量：`Seasons.SPRING`。为了更简洁的代码，您可以直接导入枚举值本身：

```java
import static climate.temperate.Seasons.*;
```

对于常量，使用静态成员`import`声明通常比实现定义常量的接口更好。

### 静态成员导入和重载方法

静态`import`声明导入的是一个*名称*，而不是具有该名称的任何特定成员。因为 Java 允许方法重载并允许类型具有相同名称的字段和方法，单个静态成员`import`声明实际上可能导入多个成员。考虑以下代码：

```java
import static java.util.Arrays.sort;
```

此声明将名称`sort`导入命名空间，而不是`java.util.Arrays`定义的 19 个`sort()`方法中的任何一个。如果您使用导入的名称`sort`调用方法，则编译器将查看方法参数的类型以确定您指的是哪个方法。

即使是合法的，也可以从两个或更多不同类型中导入具有相同名称的静态方法，只要这些方法都具有不同的签名。这里有一个自然的例子：

```java
import static java.util.Arrays.sort;
import static java.util.Collections.sort;
```

你可能会期望这段代码会导致语法错误。事实上，它不会，因为`Collections`类定义的`sort()`方法的签名与`Arrays`类定义的所有`sort()`方法的签名不同。当你在代码中使用“sort”这个名字时，编译器会查看参数的类型来确定你是指哪一个 21 个可能的导入方法中的哪一个。

# Java 源文件结构

本章带我们从 Java 语法的最小元素到最大的元素，从单个字符和标记到运算符、表达式、语句和方法，再到类和包。从实际角度来看，您最常处理的 Java 程序结构单元是 Java 文件。Java 文件是 Java 代码中可以被 Java 编译器编译的最小单元。一个 Java 文件由以下内容组成：

+   一个可选的`package`指令

+   零个或多个`import`或`import static`指令

+   一个或多个类型定义

这些元素当然可以与注释交替出现，但它们必须按照这个顺序出现。这就是一个 Java 文件的全部内容。所有 Java 语句（除了`package`和`import`指令，这些不是真正的语句，以及我们将在第十二章中讨论的专用模块描述符）必须出现在方法中，所有方法必须出现在类型定义中。

一个名为`module-info.java`的特殊 Java 文件仅用于声明我们在模块化 Java 应用程序中的包的结构和可见性。这些更高级的技术和语法在第十二章中有详细介绍。

Java 文件有一些其他重要的限制。首先，每个文件最多只能包含一个顶级`public`类。一个`public`类是为其他包中的类使用而设计的。一个类可以包含任意数量的`public`嵌套或内部类。我们将在第三章中更多地了解`public`修饰符和嵌套类。

第二个限制涉及 Java 文件的文件名。如果一个 Java 文件包含一个`public`类，文件名必须与类名相同，后缀为*.java*。因此，如果`Account`定义为一个`public`类，它的源代码必须出现在名为*Account.java*的文件中。无论你的类是否`public`，良好的编程习惯是每个文件只定义一个类，并给文件起一个与类名相同的名字。

当 Java 文件编译时，它定义的每个类都会编译成一个单独的*class*文件，其中包含 Java 字节码，由 Java 虚拟机执行。类文件的名称与其定义的类名称相同，并附加扩展名*.class*。因此，如果文件*Account.java*定义了一个名为`Account`的类，Java 编译器将其编译为名为*Account.class*的文件。在大多数系统上，类文件存储在与其包名称对应的目录中。例如，类`com.davidflanagan.examples.Account`由类文件*com/davidflanagan/examples/Account.class*定义。

Java 运行时知道标准系统类的类文件位于何处，并且可以根据需要加载它们。当解释器运行一个想要使用名为`com.davidflanagan.examples.Account`的类的程序时，它知道该类的代码位于名为*com/davidflanagan/examples/*的目录中，并且默认情况下会在当前目录中查找该名称的子目录。为了告诉解释器查找除当前目录以外的位置，您必须在调用解释器时使用`-classpath`选项或设置`CLASSPATH`环境变量。有关详细信息，请参阅 Java 可执行文件*java*的文档，位于第十三章中。

# 定义和运行 Java 程序

一个 Java 程序由一组互动的类定义组成。但并非每个 Java 类或 Java 文件都定义了一个程序。要创建一个程序，您必须定义一个具有以下签名的特殊方法的类：

```java
public static void main(String[] args)
```

这个`main()`方法是程序的主入口点。Java 解释器从这里开始运行。此方法接收一个字符串数组并且不返回任何值。当`main()`方法返回时，Java 解释器退出（除非`main()`创建了单独的线程，在这种情况下，解释器会等待所有这些线程退出）。

要运行 Java 程序，您运行 Java 可执行文件*java*，指定包含`main()`方法的类的完全限定名称。请注意，您指定类的名称，而不是包含该类的类文件的名称。您在命令行上指定的任何其他参数都将作为其`String[]`参数传递给`main()`方法。您可能还需要指定`-classpath`选项（或`-cp`）以告知解释器程序所需的类的查找位置。考虑以下命令：

```java
java -classpath /opt/Jude com.davidflanagan.jude.Jude datafile.jude
```

`java`是运行 Java 解释器的命令。`-classpath /opt/Jude`告诉解释器在哪里查找*.class*文件。`com.davidflanagan.jude.Jude`是要运行的程序的名称（即定义了`main()`方法的类的名称）。最后，`datafile.jude`是作为`String`对象数组的单个元素传递给`main()`方法的字符串。

运行程序有一种更简单的方法。如果程序及其所有辅助类（除了那些属于 Java 平台的类）已经被正确打包在一个 Java 归档（JAR）文件中，您只需指定 JAR 文件的名称即可运行该程序。在下一个示例中，我们展示如何启动日志分析器：

```java
java -jar /usr/local/log-analyzer/log-analyzer.jar
```

一些操作系统可以自动执行 JAR 文件。在这些系统上，您可以简单地说：

```java
/usr/local/log-analyzer/log-analyzer.jar
```

Java 17 还引入了直接对源文件运行 `java` 的能力，类似于 Python 等脚本语言。您仍然必须定义一个与文件名匹配的类和一个 `main()` 方法，然后可以执行以下程序：

```java
java MyClass.java
```

查看第十三章 获取有关如何执行 Java 程序的更多详细信息。

# 摘要

在本章中，我们介绍了 Java 语言的基本语法。由于编程语言语法的相互关联性，如果您现在感觉还没有完全掌握语言的所有语法，这是完全可以的。通过实践，我们才能掌握任何语言，无论是人类语言还是计算机语言。

值得注意的是，语法的某些部分比其他部分更常用。例如，`strictfp` 和 `assert` 关键字几乎不被使用。与其试图掌握 Java 语法的每个方面，不如开始掌握 Java 核心方面的技能，然后再回到可能仍然困扰您的语法细节。考虑到这一点，让我们继续下一章，讨论 Java 中的类和对象，以及 Java 面向对象编程的基础知识。

^(1) 技术上来说，减号是一个操作符，作用于字面量本身，而不是字面量的一部分。

^(2) 技术上来说，它们都必须实现`AutoCloseable`接口。

^(3) 在 Java 语言规范中，“签名”一词有一个技术上的含义，与此处使用的含义略有不同。本书使用了方法签名的较少正式的定义。

^(4) 在数组的讨论中存在术语难度。与类及其实例不同，我们用“数组”一词来表示数组类型和数组实例。实际上，从上下文中通常可以清楚地知道是讨论类型还是值。
