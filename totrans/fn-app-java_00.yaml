- en: Preface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A mind that is stretched by a new experience can never go back to its old dimensions.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Oliver Wendell Holmes Jr.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Developing software is quite a complex endeavor. As Java developers, we usually
    try to tame this complexity with object-oriented programming (OOP) as a metaphor
    to represent the things we are developing, such as data structures, and use a
    primarily imperative-focused coding style to handle our program’s state. Although
    OOP is a well-known and battle-tested approach to developing sensible software,
    not every problem is a good match for it. We might introduce a certain amount
    of unnecessary complexity by forcing OOP principles on every problem instead of
    using more appropriate tools and paradigms also available to us. The functional
    programming (FP) paradigm offers an alternative approach to solving problems.
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming isn’t a new idea. In fact, it’s even older than object-oriented
    programming! It first appeared in the early years of computing, in the 1950s,
    in the *Lisp*⁠^([1](preface01.xhtml#idm45115267496480)) programming language and
    has been used quite commonly in academia and niche fields. In recent years, however,
    there has been an increasing interest in functional paradigms.
  prefs: []
  type: TYPE_NORMAL
- en: Many new functional languages emerged, and non-functional languages are including
    functional features to various degrees. The ideas and concepts behind FP are now
    adopted in almost every mainstream multi-paradigm and general-purpose language,
    allowing us to use some form of functional programming regardless of the context
    and chosen language. Nothing stops us from taking the best parts of FP and augmenting
    our existing way of programming and software development tools — and that’s what
    this book is about!
  prefs: []
  type: TYPE_NORMAL
- en: In this book, you’ll learn the fundamentals of functional programming and how
    to apply this knowledge to your daily work using Java.
  prefs: []
  type: TYPE_NORMAL
- en: New Hardware Needs a New Way of Thinking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hardware is evolving in a new direction. For quite some time, single-core performance
    improvements haven’t been as significant as with each previous processor generation.
    *Moore’s law*⁠^([2](preface01.xhtml#idm45115253372352)) seems to slow down, but
    such a slowdown doesn’t mean that hardware isn’t improving anymore. But instead
    of primarily focussing on single-core performance and even higher GHz numbers,
    the manufacturers favor more and more cores.^([3](preface01.xhtml#idm45115268991152))
    So, for modern workloads to reap all the benefits of new hardware that favors
    more cores rather than faster ones, we need to adopt techniques that can use more
    cores to its advantage without compromising productivity or introducing additional
    complexity.
  prefs: []
  type: TYPE_NORMAL
- en: Scaling your software *horizontally* through parallelism isn’t an easy task
    in OOP. Not every problem is a good fit for parallelism. More painters might paint
    a room faster, but you can’t speed up pregnancy by involving more people. If the
    problem consists of serial or interdependent tasks, concurrency is preferable
    to parallelism. But parallelism really shines if a problem breaks down into smaller,
    non-related sub-problems. That’s where functional programming comes in. The stateless
    and immutable nature of idiomatic FP provides all the tools necessary to build
    small, reliable, reusable, and higher-quality tasks that elegantly fit into parallel
    and concurrent environments.
  prefs: []
  type: TYPE_NORMAL
- en: Adopting a functional mindset adds another set of tools to your toolbelt that
    will allow you to tackle your daily development problems in a new way and scale
    your code easier and safer than before.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s look at why Java can be a good choice for functional programming.
  prefs: []
  type: TYPE_NORMAL
- en: Java can be Functional, too
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many programming languages out there that are great for functional
    programming. [*Haskell*](https://www.haskell.org) is a favorite if you prefer
    a *pure* functional language with almost no support for an imperative coding style.
    [*Elixir*](https://elixir-lang.org/) is another exciting option that leverages
    the [*Erlang VM*](https://www.erlang.org/)^([4](preface01.xhtml#idm45115261275136)).
    However, you don’t have to leave the vast JVM ecosystem behind to find FP-capable
    languages. [*Scala*](https://www.scala-lang.org/) shines in combining OOP and
    FP paradigms into a concise, high-level language. Another popular choice, [*Clojure*](https://clojure.org/),
    was designed from the ground up as a functional language with a dynamic type system
    at heart.
  prefs: []
  type: TYPE_NORMAL
- en: In a perfect world, you’d have the luxury of choosing the perfect functional
    language for your next project. In reality, you might not have a choice at all
    about what language to use, and you’ll have to play the cards you’re dealt.
  prefs: []
  type: TYPE_NORMAL
- en: As a Java developer, you’d use Java, which was historically seen as not ideal
    for functional programming. Before we continue, though, I need to stress that
    you can implement most functional principles in Java, regardless of deeply integrated
    language level support^([5](preface01.xhtml#idm45115272990288)). Still, the resulting
    code won’t be as concise and easy to reason with as it would in other languages
    that allow a functional approach in the first place. This caveat scares many developers
    away from even trying to apply functional principles to Java, despite the fact
    that it might have provided a more productive approach or better overall solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the past, many people thought of Java as a slow-moving behemoth, a “too
    big to become extinct” enterprise language, like a more modern version of COBOL
    or [Fortran](https://fortran-lang.org/). And in my opinion, that’s partially true,
    at least in the past. The pace didn’t pick up until Java 9 and the shortened release
    timeframes^([6](preface01.xhtml#idm45115273019824)). It took Java five years to
    go from version 6 to 7 (2006-2011). And even though there were significant new
    features, like [`try-with-resources`](https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.xhtml),
    none of them were “ground-breaking.” The few and slow changes in the past led
    to projects and developers not adopting the “latest and greatest” Java Development
    Kit (JDK) and missing out on many language improvements. Three years later, in
    2014, the next version, Java 8, was released. This time, it introduced one of
    the most significant changes to Java’s future: *lambda expressions*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A better foundation for functional programming had finally arrived in arguably
    the most prominent object-oriented programming language of the world, changing
    the language and its idioms significantly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The addition of lambda expressions was monumental in making it possible to finally
    use functional programming in Java as an integrated language and runtime feature.
    Not only that, but a whole new world of ideas and concepts was made available
    to Java developers. Many of the JDK’s new features, like Streams, the `Optional`
    type, or `CompletableFuture`, are only possible in such a concise and straightforward
    way thanks to language-level lambda expressions and Java’s other functional additions.
  prefs: []
  type: TYPE_NORMAL
- en: These new idioms and new ways of doing things with FP in Java may seem strange
    and might not come naturally, especially if you’re primarily accustomed to OOP.
    Throughout this book, I’ll show you how to develop a mindset that’ll help you
    apply FP principles to your code and how to make it better without needing to
    go “fully functional.”
  prefs: []
  type: TYPE_NORMAL
- en: Why I Wrote This Book
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After using another multi-purpose language with excellent functional programming
    support — [*Swift*](https://www.swift.org/) — and seeing the benefits first-hand,
    I gradually introduced more and more functional principles in my Java-based projects,
    too. Thanks to lambda expressions and all the other features introduced in Java
    8 and later, all the tools necessary were readily available. But after using these
    tools more frequently and discussing them with my colleagues, I realized something:
    *How* to use lambdas, Streams, and all the other functional goodies provided by
    Java is easy to grasp. But without a deeper understanding of *why* and *when*
    you should use them — and when not to — you won’t unlock their full potential,
    and it will just be “new wine in old wineskins.”'
  prefs: []
  type: TYPE_NORMAL
- en: So I decided to write this book to highlight the different concepts that make
    a language *functional*, and how you can incorporate them into your Java code,
    either with the tools provided by the JDK or by creating them yourself. A functional
    approach to your Java code will most likely challenge the status quo and go against
    *best practices* you were using before. But by embracing a more functional way
    of doing things, like *immutability* and *pure functions*, you will be able to
    write more concise, more reasonable, and future-proof code that is less prone
    to bugs.
  prefs: []
  type: TYPE_NORMAL
- en: Who Should Read This Book
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This book is for you if you are curious about functional programming and want
    to know what all the fuss is about and apply it to your Java code. You might already
    be using some functional Java types but desire a more profound knowledge of why
    and how to apply them more effectively.
  prefs: []
  type: TYPE_NORMAL
- en: There is no need to be an expert on OOP, but the book is not a beginner’s guide
    to Java or OOP. You should already be familiar with the Java standard library.
    No prior knowledge of functional programming is required. Every concept is introduced
    with an explanation and examples.
  prefs: []
  type: TYPE_NORMAL
- en: The book covers Java 17 as the latest Long-Term-Support (LTS) version available
    at publication. Knowing that many developers need to support projects with earlier
    versions, the general baseline will be the previous LTS, Java 11. But even if
    you’re stuck on Java 8, many of the discussed topics are relevant, too. Although,
    some chapters will rely on newer features, like *Records*, which were introduced
    in Java 14.
  prefs: []
  type: TYPE_NORMAL
- en: This book might not be for you if you are looking for a compartmentalized, recipe-style
    book presenting “ready-to-implement” solutions. Its main intention is to introduce
    functional concepts and idioms and teach you how to incorporate them into your
    Java code.
  prefs: []
  type: TYPE_NORMAL
- en: What You Will Learn
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By the end of this book, you will have a fundamental knowledge of functional
    programming and its underlying concepts and how to apply this knowledge to your
    daily work. Every Java functional type will be at your disposal, and you will
    be able to build anything missing from the JDK by yourself, if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will learn about the concepts and importance of:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Composition*: Build modular and easy composable blocks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Expressiveness*: Write more concise code that clearly expresses its intent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Safer code*: Safer data structures without side effects that don’t need to
    deal with race conditions or locks, which are hard to use without introducing
    bugs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Modularity*: Break down larger projects into more easily manageable modules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Maintainability*: Smaller functional blocks with less interconnection make
    changes and refactoring safer without breaking other parts of your code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Data manipulation*: Build efficient data manipulation pipelines with less
    complexity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Performance*: Immutability and predictability allow scaling horizontally with
    parallelism without much thought about it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even without going *fully functional*, your code will benefit from the concepts
    and idioms presented in this book. And not only your Java code. You will tackle
    development challenges with a functional mindset, improving your programming regardless
    of the used language or paradigm.
  prefs: []
  type: TYPE_NORMAL
- en: What About Android?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It’s hard to talk about Java without bringing up Android as well. Even though
    you can write Android applications in Java, the underlying API and runtime aren’t
    the same. So, what does this mean for adopting a functional approach to Java for
    Android apps? To better understand that, we first need to look at what makes Java
    for Android different from “normal” Java.
  prefs: []
  type: TYPE_NORMAL
- en: 'Android doesn’t run Java bytecode directly on a minimalistic JVM optimized
    for smaller devices, like [Java Platform Micro Edition](https://www.oracle.com/java/technologies/javameoverview.xhtml).
    Instead, the bytecode gets recompiled. The *Dex-compiler* creates *Dalvik bytecode*,
    which is then run on a specialized runtime: the *Android Runtime* (ART), and previously
    on the *Dalvik virtual machine*⁠^([7](preface01.xhtml#idm45115254361520)).'
  prefs: []
  type: TYPE_NORMAL
- en: Recompiling Java bytecode to *Dalvik bytecode* allows the devices to run highly
    optimized code, getting the most out of their hardware constraints. For you as
    a developer, however, that means that even though your code looks and feels like
    Java on the surface — most of the public API is identical --⁠, there isn’t a feature
    parity between the JDK and Android SDK you can rely on. For example, the cornerstones
    of this book — *lambda expressions* and *Streams* — were among the missing features
    in Android for a long time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Android Gradle plugin started supporting some of the missing functional
    features (lambda expressions, method references, default and static interface
    methods) with version 3.0.0 by using so-called *desugaring*: the compiler uses
    bytecode transformations to replicate a feature *behind the scenes* without supporting
    the new syntax or providing an implementation in the runtime itself. The next
    major version, 4.0.0, added even more functional features: Streams, Optionals,
    and the `java.util.function` package. That allows you to benefit from the functional
    paradigms and tools discussed in this book, even as an Android developer.'
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Even though most of the JDK’s functional features are available on Android too,
    they are not verbatim copies^([8](preface01.xhtml#idm45115253306592)) and might
    have different performance characteristics and edge-cases. The available features
    are listed in the [official documentation on the Java 8+ support](https://developer.android.com/studio/write/java8-support).
  prefs: []
  type: TYPE_NORMAL
- en: A Functional Approach to Android
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In 2019, [Kotlin](https://kotlinlang.org) replaced Java as the preferred language
    for Android developers. It’s a multi-platform language that mainly targets the
    JVM but also compiles to JavaScript and multiple native platforms, too^([9](preface01.xhtml#idm45115253702896)).
    It aims to be a “modern and more concise” Java, fixing many of Java’s debatable
    shortcomings and cruft accumulated over the years due to backward compatibility,
    without forgoing all the frameworks and libraries available to Java. And it’s
    100% interoperable: you can easily mix Java and Kotlin in the same project.'
  prefs: []
  type: TYPE_NORMAL
- en: One obvious advantage of Kotlin over Java is that many functional concepts and
    idioms are integral to the language itself. Still, as a different language, Kotlin
    has its own idioms and best practices that differ from Java’s. The generated bytecode
    might differ, too, like how to generate lambdas^([10](preface01.xhtml#idm45115253442784)).
    The most significant advantage of Kotlin is its attempt to create a more concise
    and predictable language compared to Java. And just like you can be more functional
    in Java without going *fully functional*, you can use Kotlin-only features without
    going *full Kotlin* in your Android projects, too. By mixing Java and Kotlin,
    you can pick the best features from both languages.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that this book’s primary focus is the Java language and the JDK.
    Still, most of the ideas behind what you will learn are transferrable to Android,
    even if you use Kotlin. But there won’t be any special considerations for Android
    or Kotlin throughout the book.
  prefs: []
  type: TYPE_NORMAL
- en: Navigating This Book
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This book consists of two different parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Part I](part01.xhtml#_01-part-1), *Functional Basics*, introduces the history
    and core concepts of functional programming, how Java implements these concepts,
    and what types are already available to us as developers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Part II](part02.xhtml#_02-part-2), *A Functional Approach*, is a topic-based
    deep-dive through the more generalized programming concepts and how to augment
    them with functional principles and the newly available tools. Certain features,
    like *Records* and *Streams*, are highlighted with extended examples and use cases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading the chapters in their respective order will let you get the most out
    of them because they usually build on each other. But feel free to skim for the
    bits that might interest you and jump around. Any necessary connections are cross-referenced
    to fill in any blanks if needed.
  prefs: []
  type: TYPE_NORMAL
- en: Conventions Used in This Book
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following typographical conventions are used in this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Italic*'
  prefs: []
  type: TYPE_NORMAL
- en: Indicates new terms, URLs, email addresses, filenames, and file extensions.
  prefs: []
  type: TYPE_NORMAL
- en: '`Constant width`'
  prefs: []
  type: TYPE_NORMAL
- en: Used for program listings, as well as within paragraphs, to refer to program
    elements such as variable or function names, databases, data types, environment
    variables, statements, and keywords.
  prefs: []
  type: TYPE_NORMAL
- en: '**`Constant width bold`**'
  prefs: []
  type: TYPE_NORMAL
- en: Shows commands or other text that should be typed literally by the user.
  prefs: []
  type: TYPE_NORMAL
- en: '*`Constant width italic`*'
  prefs: []
  type: TYPE_NORMAL
- en: Shows text that should be replaced with user-supplied values or by values determined
    by context.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This element signifies a tip or suggestion.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This element signifies a general note.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This element indicates a warning or caution.
  prefs: []
  type: TYPE_NORMAL
- en: Using Code Examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The source code for the book is available on GitHub: [*https://github.com/benweidig/a-functional-approach-to-java*](https://github.com/benweidig/a-functional-approach-to-java).
    Besides compilable Java code, there are also *JShell* scripts available to run
    the code more easily. See the [README.md](https://github.com/benweidig/a-functional-approach-to-java/README.md)
    for instructions on how to use them.'
  prefs: []
  type: TYPE_NORMAL
- en: If you have a technical question or a problem using the code examples, please
    send email to [*bookquestions@oreilly.com*](mailto:bookquestions@oreilly.com).
  prefs: []
  type: TYPE_NORMAL
- en: This book is here to help you get your job done. In general, if example code
    is offered with this book, you may use it in your programs and documentation.
    You do not need to contact us for permission unless you’re reproducing a significant
    portion of the code. For example, writing a program that uses several chunks of
    code from this book does not require permission. Selling or distributing examples
    from O’Reilly books does require permission. Answering a question by citing this
    book and quoting example code does not require permission. Incorporating a significant
    amount of example code from this book into your product’s documentation does require
    permission.
  prefs: []
  type: TYPE_NORMAL
- en: 'We appreciate, but generally do not require, attribution. An attribution usually
    includes the title, author, publisher, and ISBN. For example: “*A Functional Approach
    to Java* by Ben Weidig (O’Reilly). Copyright 2023 Ben Weidig, 978-1-098-10992-9.”'
  prefs: []
  type: TYPE_NORMAL
- en: If you feel your use of code examples falls outside fair use or the permission
    given above, feel free to contact us at [*permissions@oreilly.com*](mailto:permissions@oreilly.com).
  prefs: []
  type: TYPE_NORMAL
- en: O’Reilly Online Learning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: For more than 40 years, [*O’Reilly Media*](https://oreilly.com) has provided
    technology and business training, knowledge, and insight to help companies succeed.
  prefs: []
  type: TYPE_NORMAL
- en: Our unique network of experts and innovators share their knowledge and expertise
    through books, articles, and our online learning platform. O’Reilly’s online learning
    platform gives you on-demand access to live training courses, in-depth learning
    paths, interactive coding environments, and a vast collection of text and video
    from O’Reilly and 200+ other publishers. For more information, visit [*https://oreilly.com*](https://oreilly.com).
  prefs: []
  type: TYPE_NORMAL
- en: 'Please address comments and questions concerning this book to the publisher:'
  prefs: []
  type: TYPE_NORMAL
- en: O’Reilly Media, Inc.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1005 Gravenstein Highway North
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sebastopol, CA 95472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 800-998-9938 (in the United States or Canada)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 707-829-0515 (international or local)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 707-829-0104 (fax)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have a web page for this book, where we list errata, examples, and any additional
    information. You can access this page at [*https://oreil.ly/functional-approach-to-java-1e*](https://oreil.ly/functional-approach-to-java-1e).
  prefs: []
  type: TYPE_NORMAL
- en: Email [*bookquestions@oreilly.com*](mailto:bookquestions@oreilly.com) to comment
    or ask technical questions about this book.
  prefs: []
  type: TYPE_NORMAL
- en: For news and information about our books and courses, visit [*https://oreilly.com*](https://oreilly.com).
  prefs: []
  type: TYPE_NORMAL
- en: 'Find us on LinkedIn: [*https://linkedin.com/company/oreilly-media*](https://linkedin.com/company/oreilly-media)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow us on Twitter: [*https://twitter.com/oreillymedia*](https://twitter.com/oreillymedia)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Watch us on YouTube: [*https://www.youtube.com/oreillymedia*](https://www.youtube.com/oreillymedia)'
  prefs: []
  type: TYPE_NORMAL
- en: Acknowledgments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This book is for Alexander Neumer, the best mentor I could’ve wished for in
    my early career. Without him, I wouldn’t be the developer I am today.
  prefs: []
  type: TYPE_NORMAL
- en: I want especially like to thank Zan McQuade for her encouragement and for proposing
    to aggregate my ramblings about functional Java into a book in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: 'The technical reviewers deserve special thanks, too: Dean Wampler, Venkat Subramaniam,
    Thiago H. de Paula Figueiredo, and A.N.M. Bazlur Rahman. Their support, suggestions,
    and sometimes harsh critique throughout the different stages of the book made
    it better than I could have done it all by myself.'
  prefs: []
  type: TYPE_NORMAL
- en: I would also like to thank Felix Gonschorek and Benjamin Quenzer, the two friends
    and colleagues that “suffered” with me from the beginning and provided invaluable
    feedback up to the end.
  prefs: []
  type: TYPE_NORMAL
- en: Last but not least, I want to thank my Acquisitions Editor Brian Guerin and
    everyone at O’Reilly. My Editor Rita Fernando, who always found a way to polish
    a few rough edges and get the best out of what I wrote. Ashley Stussy, the Production
    Editor that made all my layout requests possible. Nick and Theresa from the O’Reilly
    Tools Team, who patiently helped me through any Asciidoc issues that arose. And
    all the other ones involved behind the scenes. Thank you!
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](preface01.xhtml#idm45115267496480-marker)) Originally specified in 1958,
    *Lisp* is the second-oldest high-level programming language still in common use.
    It also builds the foundation of a variety of programming languages, like [*Emacs
    Lisp*](https://www.gnu.org/software/emacs/manual/html_node/elisp/index.xhtml),
    or the functional JVM language [*Clojure*](https://clojure.org/).
  prefs: []
  type: TYPE_NORMAL
- en: '^([2](preface01.xhtml#idm45115253372352-marker)) *Moore’s law* was coined in
    1965 as the observation of transistor counts doubling every two years and, therefore,
    the performance per core available to us. Edwards, Chris. 2021\. “Moore’s Law:
    What Comes Next?” [Communications of the ACM, February 2021, Vol. 64 No. 2, 12–14](https://doi.org/10.1145/3440992)'
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](preface01.xhtml#idm45115268991152-marker)) Thompson, N. C., and Svenja
    Spanuth. 2021\. “The decline of computers as a general-purpose technology.” [*Communications
    of the ACM*, Vol. 64, No. 3, 64-72](https://doi.org/10.1145/3430936).
  prefs: []
  type: TYPE_NORMAL
- en: ^([4](preface01.xhtml#idm45115261275136-marker)) [*Erlang*](https://www.erlang.org/)
    is a functional and concurrency-oriented programming language that is known for
    building low-latency, distributed, and fault-tolerant systems.
  prefs: []
  type: TYPE_NORMAL
- en: ^([5](preface01.xhtml#idm45115272990288-marker)) Dean Wampler shows in his book
    [“Functional Programming for Java Developers”](http://oreilly.com/catalog/9781449311032/)
    quite detailed how to implement and facilitate the missing functional programming
    features in Java all by yourself. He showed many techniques that weren’t easily
    feasible before version 8\. But now, many of the shortcomings and gaps in the
    JDK are closed up, and it provides many of the tools necessary to incorporate
    FP concisely and more straightforwardly.
  prefs: []
  type: TYPE_NORMAL
- en: ^([6](preface01.xhtml#idm45115273019824-marker)) Oracle introduced a faster
    [release schedule](https://www.oracle.com/java/technologies/java-se-support-roadmap.xhtml)
    for Java with the release of version 9\. Instead of releasing infrequently, there’s
    now a fixed release cadence of six months. To meet such a tight schedule, not
    every release is considered “long-term-support”, in favor of releasing features
    faster than before.
  prefs: []
  type: TYPE_NORMAL
- en: ^([7](preface01.xhtml#idm45115254361520-marker)) The Android Open Source project
    provides [a good overview](https://source.android.com/devices/tech/dalvik) of
    the features and the reasoning behind Android’s runtime.
  prefs: []
  type: TYPE_NORMAL
- en: ^([8](preface01.xhtml#idm45115253306592-marker)) Jack Wharton, a well-known
    Android developer, provides a [detailed insight](https://jakewharton.com/androids-java-8-support/)
    on how Android desugars modern Java code.
  prefs: []
  type: TYPE_NORMAL
- en: ^([9](preface01.xhtml#idm45115253702896-marker)) See the official Kotlin documentation
    for [an overview of supported platforms](https://kotlinlang.org/docs/multiplatform-dsl-reference.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: ^([10](preface01.xhtml#idm45115253442784-marker)) Each lambda compiles to an
    anonymous class extending `kotlin.jvm.internal.FunctionImpl`, as explained in
    the [function type specs](https://github.com/JetBrains/kotlin/blob/aabc00f53faa72f7c070c2512e655abffad37597/spec-docs/function-types.md).
  prefs: []
  type: TYPE_NORMAL
