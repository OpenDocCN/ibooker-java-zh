<html><head></head><body>
<div id="sbo-rt-content"><section data-nutshell-tab="Java Collections" data-pdf-bookmark="Chapter 8. Working with Java Collections" data-type="chapter" epub:type="chapter"><div class="chapter" id="javanut8-CHP-8">
<h1><span class="label">Chapter 8. </span>Working with Java Collections</h1>
<p><a data-primary="collections" data-type="indexterm" id="ix_ch08-asciidoc0"/>This chapter introduces Java’s interpretation of fundamental data
structures, known as the Java Collections. These abstractions are core
to many (if not most) programming types and form an essential part of
any programmer’s basic toolkit. Accordingly, this is one of the most
important chapters of the entire book and provides a toolkit that is
essential to virtually all Java programmers.</p>
<p>In this chapter, we will introduce the fundamental interfaces and the
type hierarchy, show how to use them, and discuss aspects of their
overall design. Both the “classic” approach to handling the collections
and the newer approach (using the Streams API and the lambda expressions
functionality introduced in Java 8) will be covered.</p>
<section data-pdf-bookmark="Introduction to Collections API" data-type="sect1"><div class="sect1" id="idm45927726629664">
<h1>Introduction to Collections API</h1>
<p><a data-primary="collections" data-secondary="basics" data-type="indexterm" id="ix_ch08-asciidoc1"/>The Java Collections are a set of generic interfaces that describe the
most common forms of data structure. Java ships with several
implementations of each of the classic data structures, and because the
types are represented as interfaces, it is very possible for development
teams to develop their own, specialized implementations of the
interfaces for use in their own projects.</p>
<p>The Java Collections define two fundamental types of data structures. A
<code>Collection</code> is a grouping of objects, while a <code>Map</code> is a set of
mappings, or associations, between objects. The basic layout of the Java
Collections is shown in <a data-type="xref" href="#javanut8-CHP-8-FIG-1">Figure 8-1</a>.</p>
<p>Within this basic description, a <code>Set</code> is a type of <code>Collection</code> with no
duplicates, and a <code>List</code> is a <code>Collection</code> in which the elements are
ordered (but may contain <span class="keep-together">duplicates</span>).</p>
<figure><div class="figure" id="javanut8-CHP-8-FIG-1">
<img alt="JN7 0801" height="309" src="assets/jns8_0801.png" width="600"/>
<h6><span class="label">Figure 8-1. </span>Collections classes and inheritance</h6>
</div></figure>
<p><code>SortedSet</code> and <code>SortedMap</code> are specialized sets and maps that maintain
their elements in a sorted order.</p>
<p><a data-primary="java.util package" data-secondary="Set implementations" data-type="indexterm" id="idm45927726618320"/><code>Collection</code>, <code>Set</code>, <code>List</code>, <code>Map</code>, <code>SortedSet</code>, and <code>SortedMap</code> are all
interfaces, but the <code>java.util</code> package also defines various concrete
implementations, such as lists based on arrays and linked lists, and
maps and sets based on hash tables or binary trees. Other important
interfaces are <code>Iterator</code> and <code>Iterable</code>, which allow you to loop
through the objects in a collection, as we will see later on.</p>
<section data-pdf-bookmark="The Collection Interface" data-type="sect2"><div class="sect2" id="idm45927726613216">
<h2>The Collection Interface</h2>
<p><a data-primary="Collection interface" data-type="indexterm" id="ix_ch08-asciidoc2"/><a data-primary="collections" data-secondary="Collection interface" data-type="indexterm" id="ix_ch08-asciidoc3"/><code>Collection&lt;E&gt;</code> is a parameterized interface that represents a generalized grouping of objects of type <code>E</code>. We can create a collection of any kind of reference type.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>To work properly with the expectations of collections, you must take care when
defining <code>hashCode()</code> and <code>equals()</code> methods on your classes, as discussed in
<a data-type="xref" href="ch05.xhtml#javanut8-CHP-5">Chapter 5</a>.</p>
</div>
<p>Methods are defined for adding and removing objects from the group, testing an object for membership in the group, and iterating through all elements in the group.
Additional methods return the elements of the group as an array and return the size of the collection.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The grouping within a <code>Collection</code> may or may not allow duplicate
elements and may or may not impose an ordering on the elements.</p>
</div>
<p>The Java Collections Framework provides <code>Collection</code> because it defines
the features shared by all common forms of data structure. The JDK
ships <code>Set</code>, <code>List</code>, and <code>Queue</code> as subinterfaces of <code>Collection</code>.</p>
<p>The following code illustrates the operations you can perform on
<code>Collection</code> objects:</p>
<pre data-code-language="java" data-type="programlisting"><code class="c1">// Create some collections to work with.</code><code class="w"/>
<code class="n">Collection</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code><code class="w"> </code><code class="n">c</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">HashSet</code><code class="o">&lt;&gt;</code><code class="p">();</code><code class="w">  </code><code class="c1">// An empty set</code><code class="w"/>

<code class="c1">// We'll see these utility methods later. Be aware that there are</code><code class="w"/>
<code class="c1">// some subtleties to watch out for when using them</code><code class="w"/>
<code class="n">Collection</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code><code class="w"> </code><code class="n">d</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Arrays</code><code class="p">.</code><code class="na">asList</code><code class="p">(</code><code class="s">"one"</code><code class="p">,</code><code class="w"> </code><code class="s">"two"</code><code class="p">);</code><code class="w"/>
<code class="n">Collection</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code><code class="w"> </code><code class="n">e</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Collections</code><code class="p">.</code><code class="na">singleton</code><code class="p">(</code><code class="s">"three"</code><code class="p">);</code><code class="w"/>

<code class="c1">// Add elements to a collection. These methods return true</code><code class="w"/>
<code class="c1">// if the collection changes, which is useful with Sets that</code><code class="w"/>
<code class="c1">// don't allow duplicates.</code><code class="w"/>
<code class="n">c</code><code class="p">.</code><code class="na">add</code><code class="p">(</code><code class="s">"zero"</code><code class="p">);</code><code class="w">           </code><code class="c1">// Add a single element</code><code class="w"/>
<code class="n">c</code><code class="p">.</code><code class="na">addAll</code><code class="p">(</code><code class="n">d</code><code class="p">);</code><code class="w">             </code><code class="c1">// Add all of the elements in d</code><code class="w"/>

<code class="c1">// Copy a collection: most implementations have a copy constructor</code><code class="w"/>
<code class="n">Collection</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code><code class="w"> </code><code class="n">copy</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">ArrayList</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code><code class="p">(</code><code class="n">c</code><code class="p">);</code><code class="w"/>

<code class="c1">// Remove elements from a collection.</code><code class="w"/>
<code class="c1">// All but clear return true if the collection changes.</code><code class="w"/>
<code class="n">c</code><code class="p">.</code><code class="na">remove</code><code class="p">(</code><code class="s">"zero"</code><code class="p">);</code><code class="w">        </code><code class="c1">// Remove a single element</code><code class="w"/>
<code class="n">c</code><code class="p">.</code><code class="na">removeAll</code><code class="p">(</code><code class="n">e</code><code class="p">);</code><code class="w">          </code><code class="c1">// Remove a collection of elements</code><code class="w"/>
<code class="n">c</code><code class="p">.</code><code class="na">retainAll</code><code class="p">(</code><code class="n">d</code><code class="p">);</code><code class="w">          </code><code class="c1">// Remove all elements that are not in d</code><code class="w"/>
<code class="n">c</code><code class="p">.</code><code class="na">clear</code><code class="p">();</code><code class="w">               </code><code class="c1">// Remove all elements from the collection</code><code class="w"/>

<code class="c1">// Querying collection size</code><code class="w"/>
<code class="kt">boolean</code><code class="w"> </code><code class="n">b</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">c</code><code class="p">.</code><code class="na">isEmpty</code><code class="p">();</code><code class="w"> </code><code class="c1">// c is now empty, so true</code><code class="w"/>
<code class="kt">int</code><code class="w"> </code><code class="n">s</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">c</code><code class="p">.</code><code class="na">size</code><code class="p">();</code><code class="w">        </code><code class="c1">// Size of c is now 0.</code><code class="w"/>

<code class="c1">// Restore collection from the copy we made</code><code class="w"/>
<code class="n">c</code><code class="p">.</code><code class="na">addAll</code><code class="p">(</code><code class="n">copy</code><code class="p">);</code><code class="w"/>

<code class="c1">// Test membership in the collection. Membership is based on</code><code class="w"/>
<code class="c1">// the equals method, not the == operator.</code><code class="w"/>
<code class="n">b</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">c</code><code class="p">.</code><code class="na">contains</code><code class="p">(</code><code class="s">"zero"</code><code class="p">);</code><code class="w">  </code><code class="c1">// true</code><code class="w"/>
<code class="n">b</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">c</code><code class="p">.</code><code class="na">containsAll</code><code class="p">(</code><code class="n">d</code><code class="p">);</code><code class="w">    </code><code class="c1">// true</code><code class="w"/>

<code class="c1">// Most Collection implementations have a useful toString()  method</code><code class="w"/>
<code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="n">c</code><code class="p">);</code><code class="w"/>

<code class="c1">// Obtain an array of collection elements.  If the iterator guarantees</code><code class="w"/>
<code class="c1">// an order, this array has the same order. The Object array is a new</code><code class="w"/>
<code class="c1">// instance, containing references to the same objects as the original</code><code class="w"/>
<code class="c1">// collection `c` (aka a shallow copy).</code><code class="w"/>
<code class="n">Object</code><code class="o">[]</code><code class="w"> </code><code class="n">elements</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">c</code><code class="p">.</code><code class="na">toArray</code><code class="p">();</code><code class="w"/>

<code class="c1">// If we want the elements in a String[], we must pass one in</code><code class="w"/>
<code class="n">String</code><code class="o">[]</code><code class="w"> </code><code class="n">strings</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">c</code><code class="p">.</code><code class="na">toArray</code><code class="p">(</code><code class="k">new</code><code class="w"> </code><code class="n">String</code><code class="o">[</code><code class="n">c</code><code class="p">.</code><code class="na">size</code><code class="p">()</code><code class="o">]</code><code class="p">);</code><code class="w"/>

<code class="c1">// Or we can pass an empty String[] just to specify the type and</code><code class="w"/>
<code class="c1">// the toArray method will allocate an array for us</code><code class="w"/>
<code class="n">strings</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">c</code><code class="p">.</code><code class="na">toArray</code><code class="p">(</code><code class="k">new</code><code class="w"> </code><code class="n">String</code><code class="o">[</code><code class="mi">0</code><code class="o">]</code><code class="p">);</code><code class="w"/></pre>
<p>Remember that you can use any of the methods shown here with any <code>Set</code>,
<code>List</code>, or <code>Queue</code>. These subinterfaces may impose membership
restrictions or ordering constraints on the elements of the collection
but still provide the same basic methods.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Methods such as <code>addAll()</code>, <code>retainAll()</code>, <code>clear()</code>, and <code>remove()</code> that
alter the collection were conceived of as optional parts of the API.
Unfortunately, they were specified a long time ago, when the received
wisdom was to indicate the absence of an optional method by throwing
<code>UnsupportedOperationException</code>. Accordingly, some implementations
(notably read-only forms) may throw this unchecked exception.</p>
</div>
<p><code>Collection</code>, <code>Map</code>, and their subinterfaces do <em>not</em> extend the interfaces
<code>Cloneable</code> or <code>Serializable</code>. All of the collection and
map implementation classes provided in the Java Collections Framework,
however, do implement these interfaces.</p>
<p>Some collection implementations place restrictions on the elements that
they can contain. An implementation might prohibit <code>null</code> as an element,
for example. And <code>EnumSet</code> restricts membership to the values of a
specified enumerated type.</p>
<p>Attempting to add a prohibited element to a collection always throws an
unchecked exception such as <code>NullPointerException</code> or
<code>ClassCastException</code>. Checking whether a collection contains a
prohibited element may also throw such an exception, or it may simply
return <code>false</code>.<a data-startref="ix_ch08-asciidoc3" data-type="indexterm" id="idm45927726491152"/><a data-startref="ix_ch08-asciidoc2" data-type="indexterm" id="idm45927726490416"/></p>
</div></section>
<section data-pdf-bookmark="The Set Interface" data-type="sect2"><div class="sect2" id="idm45927726612624">
<h2>The Set Interface</h2>
<p><a data-primary="collections" data-secondary="Set interface" data-type="indexterm" id="ix_ch08-asciidoc4"/><a data-primary="Set interface" data-type="indexterm" id="ix_ch08-asciidoc5"/>A <em>set</em> is a collection of objects that does not allow duplicates: it
may not contain two references to the same object, two references to
<code>null</code>, or references to two objects <code>a</code> and <code>b</code> such that
<code>a.equals(b)</code>. Most general-purpose <code>Set</code> implementations impose no
ordering on the elements of the set, but ordered sets are not prohibited
(see <code>SortedSet</code> and <code>LinkedHashSet</code>). Sets are further distinguished
from ordered collections like lists by the general expectation that they
have an efficient <code>contains</code> method that runs in constant or
logarithmic time.</p>
<p><code>Set</code> defines no methods of its own beyond those defined by
<code>Collection</code> but places additional restrictions on some methods. The
<code>add()</code> and <code>addAll()</code> methods of a <code>Set</code> are required to enforce the
no-duplicates rules: they may not add an element to the <code>Set</code> if the set
already contains that element. Recall that the <code>add()</code> and <code>addAll()</code>
methods defined by the <code>Collection</code> interface return <code>true</code> if the call
resulted in a change to the collection and <code>false</code> if it did not. This
return value is relevant for <code>Set</code> objects because the no-duplicates
restriction means that adding an element does not always result in a
change to the set.</p>
<p><a data-type="xref" href="#javanut8-CHP-8-TABLE-2">Table 8-1</a> lists the implementations of the
<code>Set</code> interface and summarizes their internal representation, ordering
characteristics, member restrictions, and the performance of the basic
<code>add()</code>, <code>remove()</code>, and <code>contains</code> operations as well as iteration
performance. <a data-primary="CopyOnWriteArraySet class" data-type="indexterm" id="idm45927726472752"/><a data-primary="java.util.concurrent" data-type="indexterm" id="idm45927726472032"/>Note that <code>CopyOnWriteArraySet</code> is in the
<code>java.util.concurrent</code> package; all the other implementations are part
of <code>java.util</code>. Also note that <code>java.util.BitSet</code> is not a <code>Set</code>
implementation. This legacy class is useful as a compact and efficient
list of <code>boolean</code> values but is not part of the Java Collections
Framework.</p>
<div class="landscape">
<table id="javanut8-CHP-8-TABLE-2">
<caption><span class="label">Table 8-1. </span>Set implementations</caption>
<thead>
<tr>
<th>Class</th>
<th>Internal representation</th>
<th>Since</th>
<th>Element order</th>
<th>Member
restrictions</th>
<th>Basic operations</th>
<th>Iteration performance</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td><p><code>HashSet</code></p></td>
<td><p>Hashtable</p></td>
<td><p>1.2</p></td>
<td><p>None</p></td>
<td><p>None</p></td>
<td><p>O(1)</p></td>
<td><p>O(capacity)</p></td>
<td><p>Best
general-purpose implementation</p></td>
</tr>
<tr>
<td><p><code>LinkedHashSet</code></p></td>
<td><p>Linked hashtable</p></td>
<td><p>1.2</p></td>
<td><p>Insertion order</p></td>
<td><p>None</p></td>
<td><p>O(1)</p></td>
<td><p>O(n)</p></td>
<td><p>Preserves insertion order</p></td>
</tr>
<tr>
<td><p><code>EnumSet</code></p></td>
<td><p>Bit fields</p></td>
<td><p>5.0</p></td>
<td><p>Enum declaration</p></td>
<td><p>Enum values</p></td>
<td><p>O(1)</p></td>
<td><p>O(n)</p></td>
<td><p>Holds non-<code>null</code> enum values only</p></td>
</tr>
<tr>
<td><p><code>TreeSet</code></p></td>
<td><p>Red-black tree</p></td>
<td><p>1.2</p></td>
<td><p>Sorted ascending</p></td>
<td><p>Comparable</p></td>
<td><p>O(log(n))</p></td>
<td><p>O(n)</p></td>
<td><p><code>Comparable</code> elements or <code>Comparator</code></p></td>
</tr>
<tr>
<td><p><code>CopyOnWriteArraySet</code></p></td>
<td><p>Array</p></td>
<td><p>5.0</p></td>
<td><p>Insertion order</p></td>
<td><p>None</p></td>
<td><p>O(n)</p></td>
<td><p>O(n)</p></td>
<td><p>Threadsafe without synchronized methods</p></td>
</tr>
</tbody>
</table>
</div>
<p>The <code>TreeSet</code> implementation uses a red-black tree data structure to
maintain a set that is iterated in ascending order according to the
natural ordering of <code>Comparable</code> objects or according to an ordering
specified by a <code>Comparator</code> object. <a data-primary="SortedSet interface" data-type="indexterm" id="idm45927726172704"/><a data-primary="TreeSet class" data-type="indexterm" id="idm45927726171968"/><code>TreeSet</code> actually implements the
<code>SortedSet</code> interface, which is a subinterface of <code>Set</code>.</p>
<p>The <code>SortedSet</code> interface offers several interesting methods that take
advantage of its sorted nature. The following code illustrates:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code><code class="w"> </code><code class="kd">static</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">testSortedSet</code><code class="p">(</code><code class="n">String</code><code class="o">[]</code><code class="w"> </code><code class="n">args</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="c1">// Create a SortedSet</code><code class="w"/>
<code class="w">    </code><code class="n">SortedSet</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code><code class="w"> </code><code class="n">s</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">TreeSet</code><code class="o">&lt;&gt;</code><code class="p">(</code><code class="n">Arrays</code><code class="p">.</code><code class="na">asList</code><code class="p">(</code><code class="n">args</code><code class="p">));</code><code class="w"/>

<code class="w">    </code><code class="c1">// Iterate set: elements are automatically sorted</code><code class="w"/>
<code class="w">    </code><code class="k">for</code><code class="w"> </code><code class="p">(</code><code class="n">String</code><code class="w"> </code><code class="n">word</code><code class="w"> </code><code class="p">:</code><code class="w"> </code><code class="n">s</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="n">word</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>

<code class="w">    </code><code class="c1">// Special elements</code><code class="w"/>
<code class="w">    </code><code class="n">String</code><code class="w"> </code><code class="n">first</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">s</code><code class="p">.</code><code class="na">first</code><code class="p">();</code><code class="w">  </code><code class="c1">// First element</code><code class="w"/>
<code class="w">    </code><code class="n">String</code><code class="w"> </code><code class="n">last</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">s</code><code class="p">.</code><code class="na">last</code><code class="p">();</code><code class="w">    </code><code class="c1">// Last element</code><code class="w"/>

<code class="w">    </code><code class="c1">// all elements but first</code><code class="w"/>
<code class="w">    </code><code class="n">SortedSet</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code><code class="w"> </code><code class="n">tail</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">s</code><code class="p">.</code><code class="na">tailSet</code><code class="p">(</code><code class="n">first</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="sc">'\0'</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="n">tail</code><code class="p">);</code><code class="w"/>

<code class="w">    </code><code class="c1">// all elements but last</code><code class="w"/>
<code class="w">    </code><code class="n">SortedSet</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code><code class="w"> </code><code class="n">head</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">s</code><code class="p">.</code><code class="na">headSet</code><code class="p">(</code><code class="n">last</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="n">head</code><code class="p">);</code><code class="w"/>

<code class="w">    </code><code class="n">SortedSet</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code><code class="w"> </code><code class="n">middle</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">s</code><code class="p">.</code><code class="na">subSet</code><code class="p">(</code><code class="n">first</code><code class="o">+</code><code class="sc">'\0'</code><code class="p">,</code><code class="w"> </code><code class="n">last</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="n">middle</code><code class="p">);</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>The addition of <code>\0</code> characters is needed because the <code>tailSet()</code> and
related methods use the <em>successor</em> of an element, which for strings is
the string value with a <code>NULL</code> character (ASCII code 0) appended.</p>
</div>
<p>From Java 9 onward, the API has also been upgraded with a helper static method on the <code>Set</code> interface, like this:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">Set</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code><code class="w"> </code><code class="n">set</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Set</code><code class="p">.</code><code class="na">of</code><code class="p">(</code><code class="s">"Hello"</code><code class="p">,</code><code class="w"> </code><code class="s">"World"</code><code class="p">);</code><code class="w"/></pre>
<p>This API has several overloads that each take a fixed number of arguments, and also a varargs overload.
The latter is used for the case where arbitrarily many elements are wanted in the set and falls back to the standard varargs mechanism (marshaling the elements into an array before the call).
It’s worth noting as well that the set returned by <code>Set.of</code> is immutable and
will throw an <code>UnsupportedOperationException</code> on further attempts to add or
remove from it after instantiation.<a data-startref="ix_ch08-asciidoc5" data-type="indexterm" id="idm45927725884640"/><a data-startref="ix_ch08-asciidoc4" data-type="indexterm" id="idm45927725884032"/></p>
</div></section>
<section data-pdf-bookmark="The List Interface" data-type="sect2"><div class="sect2" id="idm45927726489152">
<h2>The List Interface</h2>
<p><a data-primary="collections" data-secondary="List interface" data-type="indexterm" id="ix_ch08-asciidoc6"/><a data-primary="List interface" data-type="indexterm" id="ix_ch08-asciidoc7"/>A <code>List</code> is an ordered collection of objects. <a data-primary="indexes" data-secondary="list" data-type="indexterm" id="idm45927725879024"/>Each element of a list
has a position in the list, and the <code>List</code> interface defines methods to
query or set the element at a particular position, or <em>index</em>. In this
respect, a <code>List</code> is like an array whose size changes as needed to
accommodate the number of elements it contains. Unlike sets, lists allow
duplicate elements.</p>
<p>In addition to its index-based <code>get()</code> and <code>set()</code> methods, the <code>List</code>
interface defines methods to add or remove an element at a particular
index and also defines methods to return the index of the first or last
occurrence of a particular value in the list. The <code>add()</code> and <code>remove()</code>
methods inherited from <code>Collection</code> are defined to append to the list
and to remove the first occurrence of the specified value from the list.
The inherited <code>addAll()</code> appends all elements in the specified
collection to the end of the list, and another version inserts the
elements at a specified index. The <code>retainAll()</code> and <code>removeAll()</code>
methods behave as they do for any <code>Collection</code>, retaining or removing
multiple occurrences of the same value, if needed.</p>
<p>The <code>List</code> interface doesn’t define methods that operate on a range of
list indexes. <a data-primary="subList()" data-type="indexterm" id="idm45927725870592"/>Instead, it defines a single <code>subList()</code> method that
returns a <code>List</code> object that represents just the specified range of the
original list. The sublist is backed by the parent list, and any changes
made to the sublist are immediately visible in the parent list. Examples of <code>subList()</code> and the other basic <code>List</code> manipulation methods follow:</p>
<pre data-code-language="java" data-type="programlisting"><code class="c1">// Create lists to work with</code><code class="w"/>
<code class="n">List</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code><code class="w"> </code><code class="n">l</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">ArrayList</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code><code class="p">(</code><code class="n">Arrays</code><code class="p">.</code><code class="na">asList</code><code class="p">(</code><code class="n">args</code><code class="p">));</code><code class="w"/>
<code class="n">List</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code><code class="w"> </code><code class="n">words</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Arrays</code><code class="p">.</code><code class="na">asList</code><code class="p">(</code><code class="s">"hello"</code><code class="p">,</code><code class="w"> </code><code class="s">"world"</code><code class="p">);</code><code class="w"/>
<code class="n">List</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code><code class="w"> </code><code class="n">words2</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">List</code><code class="p">.</code><code class="na">of</code><code class="p">(</code><code class="s">"hello"</code><code class="p">,</code><code class="w"> </code><code class="s">"world"</code><code class="p">);</code><code class="w"/>

<code class="c1">// Querying and setting elements by index</code><code class="w"/>
<code class="n">String</code><code class="w"> </code><code class="n">first</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">l</code><code class="p">.</code><code class="na">get</code><code class="p">(</code><code class="mi">0</code><code class="p">);</code><code class="w">             </code><code class="c1">// First element of list</code><code class="w"/>
<code class="n">String</code><code class="w"> </code><code class="n">last</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">l</code><code class="p">.</code><code class="na">get</code><code class="p">(</code><code class="n">l</code><code class="p">.</code><code class="na">size</code><code class="p">()</code><code class="w"> </code><code class="o">-</code><code class="w"> </code><code class="mi">1</code><code class="p">);</code><code class="w">   </code><code class="c1">// Last element of list</code><code class="w"/>
<code class="n">l</code><code class="p">.</code><code class="na">set</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="n">last</code><code class="p">);</code><code class="w">                      </code><code class="c1">// The last shall be first</code><code class="w"/>

<code class="c1">// Adding and inserting elements.  add  can append or insert</code><code class="w"/>
<code class="n">l</code><code class="p">.</code><code class="na">add</code><code class="p">(</code><code class="n">first</code><code class="p">);</code><code class="w">       </code><code class="c1">// Append the first word at end of list</code><code class="w"/>
<code class="n">l</code><code class="p">.</code><code class="na">add</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="n">first</code><code class="p">);</code><code class="w">    </code><code class="c1">// Insert first at the start of the list again</code><code class="w"/>
<code class="n">l</code><code class="p">.</code><code class="na">addAll</code><code class="p">(</code><code class="n">words</code><code class="p">);</code><code class="w">    </code><code class="c1">// Append a collection at the end of the list</code><code class="w"/>
<code class="n">l</code><code class="p">.</code><code class="na">addAll</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="n">words</code><code class="p">);</code><code class="w"> </code><code class="c1">// Insert collection after first word</code><code class="w"/>

<code class="c1">// Sublists: backed by the original list</code><code class="w"/>
<code class="n">List</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code><code class="w"> </code><code class="n">sub</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">l</code><code class="p">.</code><code class="na">subList</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code><code class="mi">3</code><code class="p">);</code><code class="w">  </code><code class="c1">// second and third elements</code><code class="w"/>
<code class="n">sub</code><code class="p">.</code><code class="na">set</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="s">"hi"</code><code class="p">);</code><code class="w">                   </code><code class="c1">// modifies 2nd element of l</code><code class="w"/>

<code class="c1">// Sublists can restrict operations to a subrange of backing list</code><code class="w"/>
<code class="n">String</code><code class="w"> </code><code class="n">s</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Collections</code><code class="p">.</code><code class="na">min</code><code class="p">(</code><code class="n">l</code><code class="p">.</code><code class="na">subList</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code><code class="mi">4</code><code class="p">));</code><code class="w"/>
<code class="n">Collections</code><code class="p">.</code><code class="na">sort</code><code class="p">(</code><code class="n">l</code><code class="p">.</code><code class="na">subList</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code><code class="mi">4</code><code class="p">));</code><code class="w"/>

<code class="c1">// Independent copies of a sublist don't affect the parent list.</code><code class="w"/>
<code class="n">List</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code><code class="w"> </code><code class="n">subcopy</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">ArrayList</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code><code class="p">(</code><code class="n">l</code><code class="p">.</code><code class="na">subList</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code><code class="mi">3</code><code class="p">));</code><code class="w"/>
<code class="n">subcopy</code><code class="p">.</code><code class="na">clear</code><code class="p">();</code><code class="w"/>

<code class="c1">// Searching lists</code><code class="w"/>
<code class="kt">int</code><code class="w"> </code><code class="n">p</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">l</code><code class="p">.</code><code class="na">indexOf</code><code class="p">(</code><code class="n">last</code><code class="p">);</code><code class="w">  </code><code class="c1">// Where does the last word appear?</code><code class="w"/>
<code class="n">p</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">l</code><code class="p">.</code><code class="na">lastIndexOf</code><code class="p">(</code><code class="n">last</code><code class="p">);</code><code class="w">  </code><code class="c1">// Search backward</code><code class="w"/>

<code class="c1">// Print the index of all occurrences of last in l.  Note subList</code><code class="w"/>
<code class="kt">int</code><code class="w"> </code><code class="n">n</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">l</code><code class="p">.</code><code class="na">size</code><code class="p">();</code><code class="w"/>
<code class="n">p</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"/>
<code class="k">while</code><code class="w"> </code><code class="p">(</code><code class="n">p</code><code class="w"> </code><code class="o">&lt;</code><code class="w"> </code><code class="n">n</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="c1">// Get a view of the list that includes only the elements we</code><code class="w"/>
<code class="w">    </code><code class="c1">// haven't searched yet.</code><code class="w"/>
<code class="w">    </code><code class="n">List</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code><code class="w"> </code><code class="n">list</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">l</code><code class="p">.</code><code class="na">subList</code><code class="p">(</code><code class="n">p</code><code class="p">,</code><code class="w"> </code><code class="n">n</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="kt">int</code><code class="w"> </code><code class="n">q</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">list</code><code class="p">.</code><code class="na">indexOf</code><code class="p">(</code><code class="n">last</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="n">q</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="o">-</code><code class="mi">1</code><code class="p">)</code><code class="w"> </code><code class="k">break</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">printf</code><code class="p">(</code><code class="s">"Found '%s' at index %d%n"</code><code class="p">,</code><code class="w"> </code><code class="n">last</code><code class="p">,</code><code class="w"> </code><code class="n">p</code><code class="o">+</code><code class="n">q</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="n">p</code><code class="w"> </code><code class="o">+=</code><code class="w"> </code><code class="n">q</code><code class="o">+</code><code class="mi">1</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="c1">// Removing elements from a list</code><code class="w"/>
<code class="n">l</code><code class="p">.</code><code class="na">remove</code><code class="p">(</code><code class="n">last</code><code class="p">);</code><code class="w">         </code><code class="c1">// Remove first occurrence of the element</code><code class="w"/>
<code class="n">l</code><code class="p">.</code><code class="na">remove</code><code class="p">(</code><code class="mi">0</code><code class="p">);</code><code class="w">            </code><code class="c1">// Remove element at specified index</code><code class="w"/>
<code class="n">l</code><code class="p">.</code><code class="na">subList</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code><code class="mi">2</code><code class="p">).</code><code class="na">clear</code><code class="p">();</code><code class="w"> </code><code class="c1">// Remove a range of elements using subList</code><code class="w"/>
<code class="n">l</code><code class="p">.</code><code class="na">retainAll</code><code class="p">(</code><code class="n">words</code><code class="p">);</code><code class="w">     </code><code class="c1">// Remove all but elements in words</code><code class="w"/>
<code class="n">l</code><code class="p">.</code><code class="na">removeAll</code><code class="p">(</code><code class="n">words</code><code class="p">);</code><code class="w">     </code><code class="c1">// Remove all occurrences of elements in words</code><code class="w"/>
<code class="n">l</code><code class="p">.</code><code class="na">clear</code><code class="p">();</code><code class="w">              </code><code class="c1">// Remove everything</code><code class="w"/></pre>
<section data-pdf-bookmark="Foreach loops and iteration" data-type="sect3"><div class="sect3" id="idm45927725475536">
<h3>Foreach loops and iteration</h3>
<p><a data-primary="foreach loops" data-type="indexterm" id="ix_ch08-asciidoc8"/><a data-primary="iteration" data-secondary="lists" data-type="indexterm" id="ix_ch08-asciidoc9"/><a data-primary="List interface" data-secondary="foreach loops and iteration" data-type="indexterm" id="ix_ch08-asciidoc10"/>One very important way of working with collections is to process each
element in turn, an approach known as <em>iteration</em>. This is an older way
of looking at data structures, but it is still very useful (especially for
small collections of data) and is easy to understand. This approach
fits naturally with the <code>for</code> loop, as shown in this bit of code, and is
easiest to illustrate using a <code>List</code>:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">List</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code><code class="w"> </code><code class="n">c</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">ArrayList</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code><code class="p">();</code><code class="w"/>
<code class="c1">// ... add some Strings to c</code><code class="w"/>

<code class="k">for</code><code class="p">(</code><code class="n">String</code><code class="w"> </code><code class="n">word</code><code class="w"> </code><code class="p">:</code><code class="w"> </code><code class="n">c</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="n">word</code><code class="p">);</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>The sense of the code should be clear—it takes the elements of <code>c</code> one
at a time and uses them as a variable in the loop body. More formally,
it iterates through the elements of an array or collection (or any
object that implements <code>java.lang.Iterable</code>). On each iteration it
assigns an element of the array or <code>Iterable</code> object to the loop
variable you declare and then executes the loop body, which typically
uses the loop variable to operate on the element. No loop counter or
<code>Iterator</code> object is involved; the loop performs the iteration
automatically, and you need not concern yourself with correct
initialization or termination of the loop.</p>
<p>This type of <code>for</code> loop is often referred to as a <em>foreach loop</em>.
Let’s see how it works. The following bit of code shows a rewritten (and
equivalent) <code>for</code> loop, with the method calls explicitly shown:</p>
<pre data-code-language="java" data-type="programlisting"><code class="c1">// Iteration with a for loop</code><code class="w"/>
<code class="k">for</code><code class="p">(</code><code class="n">Iterator</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">c</code><code class="p">.</code><code class="na">iterator</code><code class="p">();</code><code class="w"> </code><code class="n">i</code><code class="p">.</code><code class="na">hasNext</code><code class="p">();)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="n">i</code><code class="p">.</code><code class="na">next</code><code class="p">());</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>The <code>Iterator</code> object, <code>i</code>, is produced from the collection and used
to step through the collection one item at a time. It can also be used
with <code>while</code> loops:</p>
<pre data-code-language="java" data-type="programlisting"><code class="c1">// Iterate through collection elements with a while loop.</code><code class="w"/>
<code class="c1">// Some implementations (such as lists) guarantee an order of iteration</code><code class="w"/>
<code class="c1">// Others make no guarantees.</code><code class="w"/>
<code class="n">Iterator</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code><code class="w"> </code><code class="n">iterator</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">c</code><code class="p">.</code><code class="na">iterator</code><code class="p">();</code><code class="w"/>
<code class="k">while</code><code class="w"> </code><code class="p">(</code><code class="n">iterator</code><code class="p">.</code><code class="na">hasNext</code><code class="p">())</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="n">iterator</code><code class="p">.</code><code class="na">next</code><code class="p">());</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>Here are some more things you should know about the syntax of the
foreach loop:</p>
<ul>
<li>
<p><a data-primary="java.lang.Iterable" data-type="indexterm" id="idm45927725112416"/>As noted earlier, <em><code>expression</code></em> must be either an array or an object
that implements the <code>java.lang.Iterable</code> interface. This type must be
known at compile time so that the compiler can generate appropriate
looping code.</p>
</li>
<li>
<p><a data-primary="Iterable interface" data-type="indexterm" id="idm45927725109760"/>The type of the array or <code>Iterable</code> elements must be
assignment-compatible with the type of the variable declared in the
<em><code>declaration</code></em>. If you use an <code>Iterable</code> object that is not
parameterized with an element type, the variable must be declared as an
<code>Object</code>.</p>
</li>
<li>
<p>The <em><code>declaration</code></em> usually consists of just a type and a variable
name, but it may include a <code>final</code> modifier and any appropriate
annotations (see <a data-type="xref" href="ch04.xhtml#javanut8-CHP-4">Chapter 4</a>). Using <code>final</code>
prevents the loop variable from taking on any value other than the array
or collection element the loop assigns it and serves to emphasize that
the array or collection cannot be altered through the loop variable.</p>
</li>
<li>
<p>The loop variable of the foreach loop must be declared as part of the
loop, with both a type and a variable name. You cannot use a variable
declared outside the loop as you can with the <code>for</code> loop.</p>
</li>
</ul>
<p><a data-primary="java.util.Iterator" data-type="indexterm" id="idm45927725057472"/>To understand in detail how the foreach loop works with collections, we
need to consider two interfaces, <code>java.util.Iterator</code> and
<code>java.lang.Iterable</code>:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code><code class="w"> </code><code class="kd">interface</code> <code class="nc">Iterator</code><code class="o">&lt;</code><code class="n">E</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">     </code><code class="kt">boolean</code><code class="w"> </code><code class="nf">hasNext</code><code class="p">();</code><code class="w"/>
<code class="w">     </code><code class="n">E</code><code class="w"> </code><code class="nf">next</code><code class="p">();</code><code class="w"/>
<code class="w">     </code><code class="kt">void</code><code class="w"> </code><code class="nf">remove</code><code class="p">();</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p><code>Iterator</code> defines a way to iterate through the elements of a collection
or other data structure. It works like this: while there are more
elements in the collection (<code>hasNext()</code> returns <code>true</code>), call <code>next</code> to
obtain the next element of the collection. Ordered collections, such as
lists, typically have iterators that guarantee they’ll return
elements in order. <a data-primary="next()" data-type="indexterm" id="idm45927725000176"/>Unordered collections like <code>Set</code> simply guarantee
that repeated calls to <code>next()</code> return all elements of the set without
omissions or duplications, but they do not specify an ordering.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>The <code>next()</code> method of <code>Iterator</code> performs two functions—it advances
through the collection and also returns the element of the
collection that we have just moved past. This combination of operations can cause problems when you are programming in a functional
or immutable style, as it mutates the underlying collection.</p>
</div>
<p><a data-primary="Iterable interface" data-type="indexterm" id="idm45927725026304"/>The <code>Iterable</code> interface was introduced to make the foreach loop work.
A class implements this interface to advertise that it is able
to provide an <code>Iterator</code> to anyone interested:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code><code class="w"> </code><code class="kd">interface</code> <code class="nc">Iterable</code><code class="o">&lt;</code><code class="n">E</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">     </code><code class="n">java</code><code class="p">.</code><code class="na">util</code><code class="p">.</code><code class="na">Iterator</code><code class="o">&lt;</code><code class="n">E</code><code class="o">&gt;</code><code class="w"> </code><code class="nf">iterator</code><code class="p">();</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p><a data-primary="iterator()" data-type="indexterm" id="idm45927724974576"/>If an object is <code>Iterable&lt;E&gt;</code>, that means that it has an
<code>iterator()</code> method that returns an <code>Iterator&lt;E&gt;</code>, which has a <code>next()</code>
method that returns an object of 
<span class="keep-together">type <code>E</code></span>.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>If you use the foreach loop with an <code>Iterable&lt;E&gt;</code>, the loop
variable must be of type <code>E</code> or a superclass or interface.</p>
</div>
<p>For example, to iterate through the elements of a <code>List&lt;String&gt;</code>, the
variable must be declared <code>String</code> or its superclass <code>Object</code>, or one of
the interfaces it implements: <code>CharSequence</code>, <code>Comparable</code>, or
<code>Serializable</code>.</p>
<p><a data-primary="ConcurrentModificationException" data-type="indexterm" id="idm45927724961152"/>A common pitfall with iterators regards modification. If the collection is
modified while iteration is in process, it may throw an error of the type
<code>ConcurrentModificationException</code>.</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">List</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code><code class="w"> </code><code class="n">l</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">ArrayList</code><code class="o">&lt;&gt;</code><code class="p">(</code><code class="n">List</code><code class="p">.</code><code class="na">of</code><code class="p">(</code><code class="s">"one"</code><code class="p">,</code><code class="w"> </code><code class="s">"two"</code><code class="p">,</code><code class="w"> </code><code class="s">"three"</code><code class="p">));</code><code class="w"/>
<code class="k">for</code><code class="w"> </code><code class="p">(</code><code class="n">String</code><code class="w"> </code><code class="n">x</code><code class="w"> </code><code class="p">:</code><code class="w"> </code><code class="n">l</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="n">x</code><code class="p">.</code><code class="na">equals</code><code class="p">(</code><code class="s">"one"</code><code class="p">))</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="n">l</code><code class="p">.</code><code class="na">remove</code><code class="p">(</code><code class="s">"one"</code><code class="p">);</code><code class="w">  </code><code class="c1">// throws ConcurrentModificationException</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>Avoiding this exception requires rethinking your algorithm so it doesn’t modify the
collection. This can often be accomplished by working against a local copy
instead of the original collection. The newer <code>Stream</code> APIs for collections also
provide a lot of useful helpers for these situations.<a data-startref="ix_ch08-asciidoc10" data-type="indexterm" id="idm45927724858432"/><a data-startref="ix_ch08-asciidoc9" data-type="indexterm" id="idm45927724857824"/><a data-startref="ix_ch08-asciidoc8" data-type="indexterm" id="idm45927724857184"/></p>
</div></section>
<section data-pdf-bookmark="Random access to Lists" data-type="sect3"><div class="sect3" id="idm45927725474624">
<h3>Random access to Lists</h3>
<p><a data-primary="List interface" data-secondary="random access to lists" data-type="indexterm" id="idm45927724855456"/>A general expectation of <code>List</code> implementations is that they can be
efficiently iterated, typically in time proportional to the size of the
list. Lists do not all provide efficient random access to the elements
at any index, however. <a data-primary="LinkedList class" data-type="indexterm" id="idm45927724853744"/>Sequential-access lists, such as the <code>LinkedList</code>
class, provide efficient insertion and deletion operations at the
expense of random-access performance. <a data-primary="RandomAccess interface" data-type="indexterm" id="idm45927724852400"/>Implementations that provide
efficient random access implement the <code>RandomAccess</code> marker interface,
and you can test for this interface with <code>instanceof</code> if you need to
ensure efficient list manipulations:</p>
<pre data-code-language="java" data-type="programlisting"><code class="c1">// Arbitrary list we're passed to manipulate</code><code class="w"/>
<code class="n">List</code><code class="o">&lt;?&gt;</code><code class="w"> </code><code class="n">l</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">...;</code><code class="w"/>

<code class="c1">// Ensure we can do efficient random access.  If not, use a copy</code><code class="w"/>
<code class="c1">// constructor to make a random-access copy of the list before</code><code class="w"/>
<code class="c1">// manipulating it.</code><code class="w"/>
<code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="o">!</code><code class="p">(</code><code class="n">l</code><code class="w"> </code><code class="k">instanceof</code><code class="w"> </code><code class="n">RandomAccess</code><code class="p">))</code><code class="w"> </code><code class="n">l</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">ArrayList</code><code class="o">&lt;?&gt;</code><code class="p">(</code><code class="n">l</code><code class="p">);</code><code class="w"/></pre>
<p>The <code>Iterator</code> returned by the <code>iterator()</code> method of a <code>List</code> iterates
the list elements in the order they occur in the list. <code>List</code>
implements <code>Iterable</code>, and lists can be iterated with a foreach loop
just as any other collection can.</p>
<p>To iterate just a portion of a list, you can use the <code>subList()</code> method
to create a sublist view:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">List</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code><code class="w"> </code><code class="n">words</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">...;</code><code class="w">  </code><code class="c1">// Get a list to iterate</code><code class="w"/>

<code class="c1">// Iterate just all elements of the list but the first</code><code class="w"/>
<code class="k">for</code><code class="p">(</code><code class="n">String</code><code class="w"> </code><code class="n">word</code><code class="w"> </code><code class="p">:</code><code class="w"> </code><code class="n">words</code><code class="p">.</code><code class="na">subList</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="n">words</code><code class="p">.</code><code class="na">size</code><code class="p">()))</code><code class="w"/>
<code class="w">    </code><code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="n">word</code><code class="p">);</code><code class="w"/></pre>
<p><a data-type="xref" href="#javanut8-CHP-8-TABLE-3">Table 8-2</a> summarizes the five
general-purpose <code>List</code> implementations in the Java platform. <code>Vector</code>
and <code>Stack</code> are legacy implementations and should not be used.
<a data-primary="CopyOnWriteArrayList class" data-type="indexterm" id="idm45927724725008"/><code>CopyOnWriteArrayList</code> is part of the <code>java.util.concurrent</code> package
and is only really suitable for multithreaded use cases.<a data-startref="ix_ch08-asciidoc7" data-type="indexterm" id="idm45927724723056"/><a data-startref="ix_ch08-asciidoc6" data-type="indexterm" id="idm45927724722352"/></p>
<table id="javanut8-CHP-8-TABLE-3">
<caption><span class="label">Table 8-2. </span>List implementations</caption>
<thead>
<tr>
<th>Class</th>
<th>Representation</th>
<th>Since</th>
<th>Random access</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td><p><code>ArrayList</code></p></td>
<td><p>Array</p></td>
<td><p>1.2</p></td>
<td><p>Yes</p></td>
<td><p>Best all-around implementation</p></td>
</tr>
<tr>
<td><p><code>LinkedList</code></p></td>
<td><p>Double-linked list</p></td>
<td><p>1.2</p></td>
<td><p>No</p></td>
<td><p>More efficient insertion and
deletion in middle of list</p></td>
</tr>
<tr>
<td><p><span class="keep-together"><code>CopyOnWriteArrayList</code></span></p></td>
<td><p>Array</p></td>
<td><p>5.0</p></td>
<td><p>Yes</p></td>
<td><p>Threadsafe; fast traversal,
slow modification</p></td>
</tr>
<tr>
<td><p><code>Vector</code></p></td>
<td><p>Array</p></td>
<td><p>1.0</p></td>
<td><p>Yes</p></td>
<td><p>Legacy class; synchronized methods. Do not
use.</p></td>
</tr>
<tr>
<td><p><code>Stack</code></p></td>
<td><p>Array</p></td>
<td><p>1.0</p></td>
<td><p>Yes</p></td>
<td><p>Extends <code>Vector</code>; adds <code>push()</code>, <code>pop()</code>,
<code>peek()</code>. Legacy; use <code>Deque</code> instead.</p></td>
</tr>
</tbody>
</table>
</div></section>
</div></section>
<section data-pdf-bookmark="The Map Interface" data-type="sect2"><div class="sect2" id="idm45927724659568">
<h2>The Map Interface</h2>
<p><a data-primary="collections" data-secondary="Map interface" data-type="indexterm" id="ix_ch08-asciidoc11"/><a data-primary="Map interface" data-type="indexterm" id="ix_ch08-asciidoc12"/>A <em>map</em> is a set of <em>key</em> objects and a mapping from each member of
that set to a <em>value</em> object. The <code>Map</code> interface defines an API for
defining and querying mappings. <code>Map</code> is part of the Java Collections
Framework, but it does not extend the <code>Collection</code> interface, so a <code>Map</code>
is a little-c collection, not a big-C <code>Collection</code>. <code>Map</code> is a
parameterized type with two type variables, <code>Map&lt;K, V&gt;</code>. Type variable <code>K</code> represents
the type of keys held by the map, and type variable <code>V</code> represents the
type of the values that the keys are mapped to. A mapping from <code>String</code>
keys to <code>Integer</code> values, for example, can be represented with a
<code>Map&lt;String,Integer&gt;</code>.</p>
<p>The most important <code>Map</code> methods are <code>put()</code>, which defines a key/value
pair in the map; <code>get()</code>, which queries the value associated with a
specified key; and <code>remove()</code>, which removes the specified key and its
associated value from the map. The general performance expectation for
<code>Map</code> implementations is that these three basic methods are quite
efficient: they should run in constant time and certainly no
worse than in logarithmic time.</p>
<p><a data-primary="collection views" data-type="indexterm" id="idm45927724645872"/>An important feature of <code>Map</code> is its support for “collection views.”
These can be summarized as:</p>
<ul>
<li>
<p>A <code>Map</code> is not a <span class="keep-together"><code>Collection</code></span></p>
</li>
<li>
<p>The keys of a <code>Map</code> can be viewed as a <code>Set</code></p>
</li>
<li>
<p>The values can be viewed as a <code>Collection</code></p>
</li>
<li>
<p><a data-primary="Map.Entry interface" data-type="indexterm" id="idm45927724638912"/>The mappings can be viewed as a <code>Set</code> of <code>Map.Entry</code> objects.</p>
</li>
</ul>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><code>Map.Entry</code> is a nested interface defined within <code>Map</code>: it simply
represents a single key/value pair.</p>
</div>
<p>The following sample code shows the <code>get()</code>, <code>put()</code>, <code>remove()</code>, and
other methods of a <code>Map</code> and demonstrates some common uses of the
collection views of a <code>Map</code>:</p>
<pre class="pre" data-code-language="java" data-type="programlisting"><code class="c1">// New, empty map</code><code class="w"/>
<code class="n">Map</code><code class="o">&lt;</code><code class="n">String</code><code class="p">,</code><code class="n">Integer</code><code class="o">&gt;</code><code class="w"> </code><code class="n">m</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">HashMap</code><code class="o">&lt;&gt;</code><code class="p">();</code><code class="w"/>

<code class="c1">// Immutable Map containing a single key/value pair</code><code class="w"/>
<code class="n">Map</code><code class="o">&lt;</code><code class="n">String</code><code class="p">,</code><code class="n">Integer</code><code class="o">&gt;</code><code class="w"> </code><code class="n">singleton</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Collections</code><code class="p">.</code><code class="na">singletonMap</code><code class="p">(</code><code class="s">"test"</code><code class="p">,</code><code class="w"> </code><code class="o">-</code><code class="mi">1</code><code class="p">);</code><code class="w"/>

<code class="c1">// Note this rarely used syntax to explicitly specify the parameter</code><code class="w"/>
<code class="c1">// types of the generic emptyMap method. The returned map is immutable</code><code class="w"/>
<code class="n">Map</code><code class="o">&lt;</code><code class="n">String</code><code class="p">,</code><code class="n">Integer</code><code class="o">&gt;</code><code class="w"> </code><code class="n">empty</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Collections</code><code class="p">.</code><code class="o">&lt;</code><code class="n">String</code><code class="p">,</code><code class="n">Integer</code><code class="o">&gt;</code><code class="n">emptyMap</code><code class="p">();</code><code class="w"/>

<code class="c1">// Populate the map using the put method to define mappings</code><code class="w"/>
<code class="c1">// from array elements to the index at which each element appears</code><code class="w"/>
<code class="n">String</code><code class="o">[]</code><code class="w"> </code><code class="n">words</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="s">"this"</code><code class="p">,</code><code class="w"> </code><code class="s">"is"</code><code class="p">,</code><code class="w"> </code><code class="s">"a"</code><code class="p">,</code><code class="w"> </code><code class="s">"test"</code><code class="w"> </code><code class="p">};</code><code class="w"/>
<code class="k">for</code><code class="p">(</code><code class="kt">int</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="o">&lt;</code><code class="w"> </code><code class="n">words</code><code class="p">.</code><code class="na">length</code><code class="p">;</code><code class="w"> </code><code class="n">i</code><code class="o">++</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">m</code><code class="p">.</code><code class="na">put</code><code class="p">(</code><code class="n">words</code><code class="o">[</code><code class="n">i</code><code class="o">]</code><code class="p">,</code><code class="w"> </code><code class="n">i</code><code class="p">);</code><code class="w">  </code><code class="c1">// Note autoboxing of int to Integer</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="c1">// Each key must map to a single value. But keys may map to the</code><code class="w"/>
<code class="c1">// same value</code><code class="w"/>
<code class="k">for</code><code class="p">(</code><code class="kt">int</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="o">&lt;</code><code class="w"> </code><code class="n">words</code><code class="p">.</code><code class="na">length</code><code class="p">;</code><code class="w"> </code><code class="n">i</code><code class="o">++</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">m</code><code class="p">.</code><code class="na">put</code><code class="p">(</code><code class="n">words</code><code class="o">[</code><code class="n">i</code><code class="o">]</code><code class="p">.</code><code class="na">toUpperCase</code><code class="p">(),</code><code class="w"> </code><code class="n">i</code><code class="p">);</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="c1">// The putAll() method copies mappings from another Map</code><code class="w"/>
<code class="n">m</code><code class="p">.</code><code class="na">putAll</code><code class="p">(</code><code class="n">singleton</code><code class="p">);</code><code class="w"/>

<code class="c1">// Query the mappings with the get()  method</code><code class="w"/>
<code class="k">for</code><code class="p">(</code><code class="kt">int</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="o">&lt;</code><code class="w"> </code><code class="n">words</code><code class="p">.</code><code class="na">length</code><code class="p">;</code><code class="w"> </code><code class="n">i</code><code class="o">++</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="n">m</code><code class="p">.</code><code class="na">get</code><code class="p">(</code><code class="n">words</code><code class="o">[</code><code class="n">i</code><code class="o">]</code><code class="p">)</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="n">i</code><code class="p">)</code><code class="w"> </code><code class="k">throw</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">AssertionError</code><code class="p">();</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="c1">// Key and value membership testing</code><code class="w"/>
<code class="n">m</code><code class="p">.</code><code class="na">containsKey</code><code class="p">(</code><code class="n">words</code><code class="o">[</code><code class="mi">0</code><code class="o">]</code><code class="p">);</code><code class="w">        </code><code class="c1">// true</code><code class="w"/>
<code class="n">m</code><code class="p">.</code><code class="na">containsValue</code><code class="p">(</code><code class="n">words</code><code class="p">.</code><code class="na">length</code><code class="p">);</code><code class="w">  </code><code class="c1">// false</code><code class="w"/>

<code class="c1">// Map keys, values, and entries can be viewed as collections</code><code class="w"/>
<code class="n">Set</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code><code class="w"> </code><code class="n">keys</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">m</code><code class="p">.</code><code class="na">keySet</code><code class="p">();</code><code class="w"/>
<code class="n">Collection</code><code class="o">&lt;</code><code class="n">Integer</code><code class="o">&gt;</code><code class="w"> </code><code class="n">values</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">m</code><code class="p">.</code><code class="na">values</code><code class="p">();</code><code class="w"/>
<code class="n">Set</code><code class="o">&lt;</code><code class="n">Map</code><code class="p">.</code><code class="na">Entry</code><code class="o">&lt;</code><code class="n">String</code><code class="p">,</code><code class="n">Integer</code><code class="o">&gt;&gt;</code><code class="w"> </code><code class="n">entries</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">m</code><code class="p">.</code><code class="na">entrySet</code><code class="p">();</code><code class="w"/>

<code class="c1">// The Map and its collection views typically have useful</code><code class="w"/>
<code class="c1">// toString  methods</code><code class="w"/>
<code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">printf</code><code class="p">(</code><code class="s">"Map: %s%nKeys: %s%nValues: %s%nEntries: %s%n"</code><code class="p">,</code><code class="w"/>
<code class="w">                  </code><code class="n">m</code><code class="p">,</code><code class="w"> </code><code class="n">keys</code><code class="p">,</code><code class="w"> </code><code class="n">values</code><code class="p">,</code><code class="w"> </code><code class="n">entries</code><code class="p">);</code><code class="w"/>

<code class="c1">// These collections can be iterated.</code><code class="w"/>
<code class="c1">// Most maps have an undefined iteration order (but see SortedMap)</code><code class="w"/>
<code class="k">for</code><code class="p">(</code><code class="n">String</code><code class="w"> </code><code class="n">key</code><code class="w"> </code><code class="p">:</code><code class="w"> </code><code class="n">m</code><code class="p">.</code><code class="na">keySet</code><code class="p">())</code><code class="w"> </code><code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="n">key</code><code class="p">);</code><code class="w"/>
<code class="k">for</code><code class="p">(</code><code class="n">Integer</code><code class="w"> </code><code class="n">value</code><code class="p">:</code><code class="w"> </code><code class="n">m</code><code class="p">.</code><code class="na">values</code><code class="p">())</code><code class="w"> </code><code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="n">value</code><code class="p">);</code><code class="w"/>

<code class="c1">// The Map.Entry&lt;K,V&gt; type represents a single key/value pair in a map</code><code class="w"/>
<code class="k">for</code><code class="p">(</code><code class="n">Map</code><code class="p">.</code><code class="na">Entry</code><code class="o">&lt;</code><code class="n">String</code><code class="p">,</code><code class="n">Integer</code><code class="o">&gt;</code><code class="w"> </code><code class="n">pair</code><code class="w"> </code><code class="p">:</code><code class="w"> </code><code class="n">m</code><code class="p">.</code><code class="na">entrySet</code><code class="p">())</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="c1">// Print out mappings</code><code class="w"/>
<code class="w">    </code><code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">printf</code><code class="p">(</code><code class="s">"'%s' ==&gt; %d%n"</code><code class="p">,</code><code class="w"> </code><code class="n">pair</code><code class="p">.</code><code class="na">getKey</code><code class="p">(),</code><code class="w"> </code><code class="n">pair</code><code class="p">.</code><code class="na">getValue</code><code class="p">());</code><code class="w"/>
<code class="w">    </code><code class="c1">// And increment the value of each Entry</code><code class="w"/>
<code class="w">    </code><code class="n">pair</code><code class="p">.</code><code class="na">setValue</code><code class="p">(</code><code class="n">pair</code><code class="p">.</code><code class="na">getValue</code><code class="p">()</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="mi">1</code><code class="p">);</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="c1">// Removing mappings</code><code class="w"/>
<code class="n">m</code><code class="p">.</code><code class="na">put</code><code class="p">(</code><code class="s">"testing"</code><code class="p">,</code><code class="w"> </code><code class="kc">null</code><code class="p">);</code><code class="w">   </code><code class="c1">// Mapping to null can "erase" a mapping:</code><code class="w"/>
<code class="n">m</code><code class="p">.</code><code class="na">get</code><code class="p">(</code><code class="s">"testing"</code><code class="p">);</code><code class="w">         </code><code class="c1">// Returns null</code><code class="w"/>
<code class="n">m</code><code class="p">.</code><code class="na">containsKey</code><code class="p">(</code><code class="s">"testing"</code><code class="p">);</code><code class="w"> </code><code class="c1">// Returns true: mapping still exists</code><code class="w"/>
<code class="n">m</code><code class="p">.</code><code class="na">remove</code><code class="p">(</code><code class="s">"testing"</code><code class="p">);</code><code class="w">      </code><code class="c1">// Deletes the mapping altogether</code><code class="w"/>
<code class="n">m</code><code class="p">.</code><code class="na">get</code><code class="p">(</code><code class="s">"testing"</code><code class="p">);</code><code class="w">         </code><code class="c1">// Still returns null</code><code class="w"/>
<code class="n">m</code><code class="p">.</code><code class="na">containsKey</code><code class="p">(</code><code class="s">"testing"</code><code class="p">);</code><code class="w"> </code><code class="c1">// Now returns false.</code><code class="w"/>

<code class="c1">// Deletions may also be made via the collection views of a map.</code><code class="w"/>
<code class="c1">// Additions to the map may not be made this way, however.</code><code class="w"/>
<code class="n">m</code><code class="p">.</code><code class="na">keySet</code><code class="p">().</code><code class="na">remove</code><code class="p">(</code><code class="n">words</code><code class="o">[</code><code class="mi">0</code><code class="o">]</code><code class="p">);</code><code class="w">  </code><code class="c1">// Same as m.remove(words[0]);</code><code class="w"/>

<code class="c1">// Removes one mapping to the value 2 - usually inefficient and of</code><code class="w"/>
<code class="c1">// limited use</code><code class="w"/>
<code class="n">m</code><code class="p">.</code><code class="na">values</code><code class="p">().</code><code class="na">remove</code><code class="p">(</code><code class="mi">2</code><code class="p">);</code><code class="w"/>
<code class="c1">// Remove all mappings to 4</code><code class="w"/>
<code class="n">m</code><code class="p">.</code><code class="na">values</code><code class="p">().</code><code class="na">removeAll</code><code class="p">(</code><code class="n">Collections</code><code class="p">.</code><code class="na">singleton</code><code class="p">(</code><code class="mi">4</code><code class="p">));</code><code class="w"/>
<code class="c1">// Keep only mappings to 2 &amp; 3</code><code class="w"/>
<code class="n">m</code><code class="p">.</code><code class="na">values</code><code class="p">().</code><code class="na">retainAll</code><code class="p">(</code><code class="n">Arrays</code><code class="p">.</code><code class="na">asList</code><code class="p">(</code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="mi">3</code><code class="p">));</code><code class="w"/>

<code class="c1">// Deletions can also be done via iterators</code><code class="w"/>
<code class="n">Iterator</code><code class="o">&lt;</code><code class="n">Map</code><code class="p">.</code><code class="na">Entry</code><code class="o">&lt;</code><code class="n">String</code><code class="p">,</code><code class="n">Integer</code><code class="o">&gt;&gt;</code><code class="w"> </code><code class="n">iter</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">m</code><code class="p">.</code><code class="na">entrySet</code><code class="p">().</code><code class="na">iterator</code><code class="p">();</code><code class="w"/>
<code class="k">while</code><code class="p">(</code><code class="n">iter</code><code class="p">.</code><code class="na">hasNext</code><code class="p">())</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">Map</code><code class="p">.</code><code class="na">Entry</code><code class="o">&lt;</code><code class="n">String</code><code class="p">,</code><code class="n">Integer</code><code class="o">&gt;</code><code class="w"> </code><code class="n">e</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">iter</code><code class="p">.</code><code class="na">next</code><code class="p">();</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="n">e</code><code class="p">.</code><code class="na">getValue</code><code class="p">()</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="mi">2</code><code class="p">)</code><code class="w"> </code><code class="n">iter</code><code class="p">.</code><code class="na">remove</code><code class="p">();</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="c1">// Find values that appear in both of two maps.  In general, addAll()</code><code class="w"/>
<code class="c1">// and retainAll() with keySet() and values() allow union and</code><code class="w"/>
<code class="c1">// intersection</code><code class="w"/>
<code class="n">Set</code><code class="o">&lt;</code><code class="n">Integer</code><code class="o">&gt;</code><code class="w"> </code><code class="n">v</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">HashSet</code><code class="o">&lt;&gt;</code><code class="p">(</code><code class="n">m</code><code class="p">.</code><code class="na">values</code><code class="p">());</code><code class="w"/>
<code class="n">v</code><code class="p">.</code><code class="na">retainAll</code><code class="p">(</code><code class="n">singleton</code><code class="p">.</code><code class="na">values</code><code class="p">());</code><code class="w"/>

<code class="c1">// Miscellaneous methods</code><code class="w"/>
<code class="n">m</code><code class="p">.</code><code class="na">clear</code><code class="p">();</code><code class="w">                </code><code class="c1">// Deletes all mappings</code><code class="w"/>
<code class="n">m</code><code class="p">.</code><code class="na">size</code><code class="p">();</code><code class="w">                 </code><code class="c1">// Returns number of mappings: currently 0</code><code class="w"/>
<code class="n">m</code><code class="p">.</code><code class="na">isEmpty</code><code class="p">();</code><code class="w">              </code><code class="c1">// Returns true</code><code class="w"/>
<code class="n">m</code><code class="p">.</code><code class="na">equals</code><code class="p">(</code><code class="n">empty</code><code class="p">);</code><code class="w">          </code><code class="c1">// true: Maps implementations override equals</code><code class="w"/></pre>
<p>With the arrival of Java 9, the <code>Map</code> interface also has been enhanced with factory methods for spinning up collections easily:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">Map</code><code class="o">&lt;</code><code class="n">String</code><code class="p">,</code><code class="w"> </code><code class="n">Double</code><code class="o">&gt;</code><code class="w"> </code><code class="n">cities</code><code class="w"> </code><code class="o">=</code><code class="w"/>
<code class="w">        </code><code class="n">Map</code><code class="p">.</code><code class="na">of</code><code class="p">(</code><code class="w"/>
<code class="w">          </code><code class="s">"Barcelona"</code><code class="p">,</code><code class="w"> </code><code class="mf">22.5</code><code class="p">,</code><code class="w"/>
<code class="w">          </code><code class="s">"New York"</code><code class="p">,</code><code class="w"> </code><code class="mf">28.3</code><code class="p">);</code><code class="w"/></pre>
<p>The situation is a little more complicated as compared to <code>Set</code> and <code>List</code>, as the <code>Map</code> type has both keys and values, and Java does not allow more than one varargs parameter in a method declaration.
The solution is to have fixed argument size overloads, up to 10 entries and also to provide a new static method, <code>entry()</code>, that will construct an object to represent the key/value pair.</p>
<p>The code can then be written to use the varargs form like this:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">Map</code><code class="o">&lt;</code><code class="n">String</code><code class="p">,</code><code class="w"> </code><code class="n">Double</code><code class="o">&gt;</code><code class="w"> </code><code class="n">cities</code><code class="w"> </code><code class="o">=</code><code class="w"/>
<code class="w">        </code><code class="n">Map</code><code class="p">.</code><code class="na">ofEntries</code><code class="p">(</code><code class="w"/>
<code class="w">          </code><code class="n">entry</code><code class="p">(</code><code class="s">"Barcelona"</code><code class="p">,</code><code class="w"> </code><code class="mf">22.5</code><code class="p">),</code><code class="w"/>
<code class="w">          </code><code class="n">entry</code><code class="p">(</code><code class="s">"New York"</code><code class="p">,</code><code class="w"> </code><code class="mf">28.3</code><code class="p">));</code><code class="w"/></pre>
<p>Note that the method name has to be different from <code>of()</code> due to the difference in type of the arguments—this is now a varargs method in <code>Map.Entry</code>.</p>
<p>The <code>Map</code> interface includes a variety of general-purpose and
special-purpose implementations, which are summarized in
<a data-type="xref" href="#javanut8-CHP-8-TABLE-4">Table 8-3</a>. As always, complete details are
in the JDK’s documentation and javadoc. <a data-primary="java.util package" data-secondary="Map interface implementations" data-type="indexterm" id="idm45927723738432"/><a data-primary="java.util.concurrent" data-secondary="Map implementations" data-type="indexterm" id="idm45927723737520"/>All classes in
<a data-type="xref" href="#javanut8-CHP-8-TABLE-4">Table 8-3</a> are in the <code>java.util</code> package
except <code>ConcurrentHashMap</code> and <code>ConcurrentSkipListMap</code>, which are
part of <code>java.util.concurrent</code>.</p>
<table id="javanut8-CHP-8-TABLE-4">
<caption><span class="label">Table 8-3. </span>Map implementations</caption>
<thead>
<tr>
<th>Class</th>
<th>Representation</th>
<th>Since</th>
<th>Null keys</th>
<th>Null values</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td><p><code>HashMap</code></p></td>
<td><p>Hashtable</p></td>
<td><p>1.2</p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
<td><p>General-purpose implementation</p></td>
</tr>
<tr>
<td><p><code>C⁠o⁠n⁠c⁠u⁠r⁠r⁠e⁠n⁠t​H⁠a⁠s⁠h⁠M⁠a⁠p</code></p></td>
<td><p>Hashtable</p></td>
<td><p>5.0</p></td>
<td><p>No</p></td>
<td><p>No</p></td>
<td><p>General-purpose threadsafe
implementation; see <code>ConcurrentMap</code> interface</p></td>
</tr>
<tr>
<td><p><code>ConcurrentSkipListMap</code></p></td>
<td><p>Hashtable</p></td>
<td><p>6.0</p></td>
<td><p>No</p></td>
<td><p>No</p></td>
<td><p>Specialized threadsafe
implementation; see <code>ConcurrentNavigableMap</code> interface</p></td>
</tr>
<tr>
<td><p><code>EnumMap</code></p></td>
<td><p>Array</p></td>
<td><p>5.0</p></td>
<td><p>No</p></td>
<td><p>Yes</p></td>
<td><p>Keys are instances of an enum</p></td>
</tr>
<tr>
<td><p><code>LinkedHashMap</code></p></td>
<td><p>Hashtable plus list</p></td>
<td><p>1.4</p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
<td><p>Preserves
insertion or access order</p></td>
</tr>
<tr>
<td><p><code>TreeMap</code></p></td>
<td><p>Red-black tree</p></td>
<td><p>1.2</p></td>
<td><p>No</p></td>
<td><p>Yes</p></td>
<td><p>Sorts by key value. Operations
are O(log(n)). See <code>SortedMap</code> interface.</p></td>
</tr>
<tr>
<td><p><code>IdentityHashMap</code></p></td>
<td><p>Hashtable</p></td>
<td><p>1.4</p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
<td><p>Compares with <code>==</code> instead
of <code>equals()</code></p></td>
</tr>
<tr>
<td><p><code>WeakHashMap</code></p></td>
<td><p>Hashtable</p></td>
<td><p>1.2</p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
<td><p>Doesn’t prevent garbage
collection of keys</p></td>
</tr>
<tr>
<td><p><code>Hashtable</code></p></td>
<td><p>Hashtable</p></td>
<td><p>1.0</p></td>
<td><p>No</p></td>
<td><p>No</p></td>
<td><p>Legacy class; synchronized
methods. Do not use.</p></td>
</tr>
<tr>
<td><p><code>Properties</code></p></td>
<td><p>Hashtable</p></td>
<td><p>1.0</p></td>
<td><p>No</p></td>
<td><p>No</p></td>
<td><p>Extends <code>Hashtable</code> with <code>String</code>
methods</p></td>
</tr>
</tbody>
</table>
<p><a data-primary="ConcurrentHashMap class" data-type="indexterm" id="idm45927723582464"/><a data-primary="ConcurrentMap interface" data-type="indexterm" id="idm45927723581424"/><a data-primary="ConcurrentSkipListMap class" data-type="indexterm" id="idm45927723580784"/>The <code>ConcurrentHashMap</code> and <code>ConcurrentSkipListMap</code> classes of the
<code>java.util.concurrent</code> package implement the <code>ConcurrentMap</code>
interface of the same package. <code>ConcurrentMap</code> extends <code>Map</code> and
defines some additional atomic operations that are important in
multithreaded programming. <a data-primary="putIfAbsent()" data-type="indexterm" id="idm45927723577280"/>For example, the <code>putIfAbsent()</code> method is
like <code>put()</code> but adds the key/value pair to the map only if the key is
not already mapped.</p>
<p><a data-primary="TreeMap class" data-type="indexterm" id="idm45927723575584"/><code>TreeMap</code> implements the <code>SortedMap</code> interface, which extends <code>Map</code> to
add methods that take advantage of the sorted nature of the map.
<a data-primary="SortedMap interface" data-type="indexterm" id="idm45927723573264"/><code>SortedMap</code> is quite similar to the <code>SortedSet</code> interface. The
<code>firstKey()</code> and <code>lastKey()</code> methods return the first and last keys in
the <code>keySet()</code>. And <code>headMap()</code>, <code>tailMap()</code>, and <code>subMap()</code> return a
restricted range of the original map.<a data-startref="ix_ch08-asciidoc12" data-type="indexterm" id="idm45927723568976"/><a data-startref="ix_ch08-asciidoc11" data-type="indexterm" id="idm45927723568272"/></p>
</div></section>
<section data-pdf-bookmark="The Queue and BlockingQueue Interfaces" data-type="sect2"><div class="sect2" id="idm45927724659104">
<h2>The Queue and BlockingQueue Interfaces</h2>
<p><a data-primary="BlockingQueue interface" data-type="indexterm" id="ix_ch08-asciidoc13"/><a data-primary="collections" data-secondary="BlockingQueue interface" data-type="indexterm" id="ix_ch08-asciidoc14"/><a data-primary="collections" data-secondary="Queue interface" data-type="indexterm" id="ix_ch08-asciidoc15"/><a data-primary="Queue interface" data-type="indexterm" id="ix_ch08-asciidoc16"/>A <em>queue</em> is an ordered collection of elements with methods for
extracting elements, in order, from the <em>head</em> of the queue. <a data-primary="FIFO (first-in, first-out) queues" data-type="indexterm" id="idm45927723561008"/><a data-primary="first-in, first-out (FIFO) queues" data-type="indexterm" id="idm45927723560304"/><a data-primary="last in, first-out (LIFO) queues" data-type="indexterm" id="idm45927723559664"/><a data-primary="LIFO (last in, first-out) queues" data-type="indexterm" id="idm45927723559024"/>Queue
implementations are commonly based on insertion order as in first-in,
first-out (FIFO) queues or last-in, first-out (LIFO) queues.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>LIFO queues are also known as stacks, and Java provides a <code>Stack</code>
class, but its use is strongly discouraged—instead, use implementations of
the <code>Deque</code> interface.</p>
</div>
<p><a data-primary="priority queues" data-type="indexterm" id="idm45927723556064"/>Other orderings are also possible: a <em>priority queue</em> orders its
elements according to an external <code>Comparator</code> object or according to
the natural ordering of <code>Comparable</code> elements. Unlike a <code>Set</code>, <code>Queue</code>
implementations typically allow duplicate elements. Unlike <code>List</code>, the
<code>Queue</code> interface does not define methods for manipulating queue
elements at arbitrary positions. Only the element at the head of the
queue is 
<span class="keep-together">available</span> for examination. It is common for <code>Queue</code>
implementations to have a fixed capacity: when a queue is full, it is
not possible to add more elements. Similarly, when a queue is empty, it
is not possible to remove any more elements. Because full and empty
conditions are a normal part of many queue-based algorithms, the <code>Queue</code>
interface defines methods that signal these conditions with return
values rather than by throwing exceptions. Specifically, the <code>peek()</code>
and <code>poll()</code> methods return <code>null</code> to indicate that the queue is empty.
For this reason, most <code>Queue</code> implementations do not allow <code>null</code>
elements.</p>
<p><a data-primary="blocking queue, defined" data-type="indexterm" id="idm45927723548512"/>A <em>blocking queue</em> is a type of queue that defines blocking <code>put()</code>
and <code>take()</code> methods. The <code>put()</code> method adds an element to the queue,
waiting, if necessary, until there is space in the queue for the
element. And the <code>take()</code> method removes an element from the head of the
queue, waiting, if necessary, until there is an element to remove.
<a data-primary="java.util.concurrent" data-secondary="BlockingQueue interface" data-type="indexterm" id="idm45927723545088"/>Blocking queues are an important part of many multithreaded algorithms,
and the <code>BlockingQueue</code> interface (which extends <code>Queue</code>) is defined as
part of the <code>java.util.concurrent</code> package.</p>
<p>Queues are not nearly as commonly used as sets, lists, and maps, except
perhaps in certain multithreaded programming styles. In lieu of example
code here, we’ll try to clarify the different possible queue insertion
and removal operations.</p>
</div></section>
<section data-pdf-bookmark="Adding Elements to Queues" data-type="sect2"><div class="sect2" id="idm45927723542352">
<h2>Adding Elements to Queues</h2>
<dl>
<dt><code>add()</code></dt>
<dd>
<p><a data-primary="BlockingQueue interface" data-secondary="adding elements to queues" data-type="indexterm" id="idm45927723539648"/><a data-primary="Queue interface" data-secondary="adding elements to queues" data-type="indexterm" id="idm45927723538704"/>This <code>Collection</code> method simply adds an element in the normal way. In
bounded queues, this method may throw an exception if the queue is
full.</p>
</dd>
<dt><code>offer()</code></dt>
<dd>
<p>This <code>Queue</code> method is like <code>add()</code> but returns <code>false</code> instead of
throwing an exception if the element cannot be added because a bounded
queue is full.</p>
<p><code>BlockingQueue</code> defines a timeout version of <code>offer()</code> that waits up
to a specified amount of time for space to become available in a full
queue. Like the basic version of the method, it returns <code>true</code> if the
element was inserted and <code>false</code> otherwise.</p>
</dd>
<dt><code>put()</code></dt>
<dd>
<p>This <code>BlockingQueue</code> method blocks: if the element cannot be inserted
because the queue is full, <code>put()</code> waits until some other thread
removes an element from the queue and space becomes available for the
new element.</p>
</dd>
</dl>
</div></section>
<section data-pdf-bookmark="Removing Elements from Queues" data-type="sect2"><div class="sect2" id="idm45927723529200">
<h2>Removing Elements from Queues</h2>
<dl>
<dt><code>remove()</code></dt>
<dd>
<p><a data-primary="BlockingQueue interface" data-secondary="removing elements from queues" data-type="indexterm" id="idm45927723526592"/><a data-primary="Queue interface" data-secondary="removing elements from queues" data-type="indexterm" id="idm45927723525424"/>In addition to the <code>Collection.remove()</code> method, which removes a
specified element from the queue, the <code>Queue</code> interface defines a
no-argument version of <code>remove()</code> that removes and returns the element
at the head of the queue. If the queue is empty, this method throws a
<code>NoSuchElementException</code>.</p>
</dd>
<dt><code>poll()</code></dt>
<dd>
<p>This <code>Queue</code> method removes and returns the element at the head of the
queue, like <code>remove()</code> does, but returns <code>null</code> if the queue is empty
instead of throwing an exception.</p>
<p><code>BlockingQueue</code> defines a timeout version of <code>poll()</code> that waits up to
a specified amount of time for an element to be added to an empty
queue.</p>
</dd>
<dt><code>take()</code></dt>
<dd>
<p>This <code>BlockingQueue</code> method removes and returns the element at the
head of the queue. If the queue is empty, it blocks until some other
thread adds an element to the queue.</p>
</dd>
<dt><code>drainTo()</code></dt>
<dd>
<p>This <code>BlockingQueue</code> method removes all available elements from the
queue and adds them to a specified <code>Collection</code>. It does not block to
wait for elements to be added to the queue. A variant of the method
accepts a maximum number of elements to drain.</p>
</dd>
</dl>
<section data-pdf-bookmark="Querying" data-type="sect3"><div class="sect3" id="idm45927723513568">
<h3>Querying</h3>
<p><a data-primary="BlockingQueue interface" data-secondary="querying of elements in queues" data-type="indexterm" id="idm45927723512192"/><a data-primary="queries" data-secondary="elements in queues" data-type="indexterm" id="idm45927723511248"/><a data-primary="Queue interface" data-secondary="querying of elements in queues" data-type="indexterm" id="idm45927723510304"/>In this context, querying refers to examining the element at the head
without removing it from the queue.</p>
<dl>
<dt><code>element()</code></dt>
<dd>
<p>This <code>Queue</code> method returns the element at the head of the queue but
does not remove that element from the queue. It throws <code>NoSuchElementException</code> if the queue is empty.</p>
</dd>
<dt><code>peek()</code></dt>
<dd>
<p>This <code>Queue</code> method is like <code>element</code> but returns <code>null</code> if the queue
is empty.</p>
</dd>
</dl>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>When using queues, it is usually a good idea to pick one particular
style of how to deal with a failure. For example, if you want
operations to block until they succeed, then choose <code>put()</code> and
<code>take()</code>. If you want to examine the return code of a method to see if
the queue operation succeeded, then <code>offer()</code> and <code>poll()</code> are appropriate choices.</p>
</div>
<p><a data-primary="LinkedList class" data-type="indexterm" id="idm45927723500080"/>The <code>LinkedList</code> class also implements <code>Queue</code>. It provides unbounded
FIFO ordering, and insertion and removal operations require constant
time. <code>LinkedList</code> allows <code>null</code> elements, although their use is
discouraged when the list is being used as a queue.</p>
<p>There are two other <code>Queue</code> implementations in the <code>java.util</code> package.
<a data-primary="PriorityQueue" data-type="indexterm" id="idm45927723495904"/><code>PriorityQueue</code> orders its elements according to a <code>Comparator</code> or
orders <code>Comparable</code> elements according to the order defined by their
<code>compareTo()</code> methods. The head of a <code>PriorityQueue</code> is always the
smallest element according to the defined ordering. <a data-primary="ArrayDeque class" data-type="indexterm" id="idm45927723493024"/>Finally,
<code>ArrayDeque</code> is a double-ended queue implementation. It is often used
when a stack implementation is needed.</p>
<p>The <code>java.util.concurrent</code> package also contains a number of
<code>BlockingQueue</code> implementations, which are designed for use in
multithreaded programing style; advanced versions that can remove the
need for synchronized methods are <span class="keep-together">available</span>.</p>
<p>A full discussion of <code>java.util.concurrent</code> is unfortunately outside the scope of this book.
The interested reader should refer to <em>Java Concurrency in Practice</em> by Brian Goetz et al. (Addison-Wesley, 2006).<a data-startref="ix_ch08-asciidoc16" data-type="indexterm" id="idm45927723488256"/><a data-startref="ix_ch08-asciidoc15" data-type="indexterm" id="idm45927723487584"/><a data-startref="ix_ch08-asciidoc14" data-type="indexterm" id="idm45927723486912"/><a data-startref="ix_ch08-asciidoc13" data-type="indexterm" id="idm45927723486240"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Utility Methods" data-type="sect2"><div class="sect2" id="idm45927723485184">
<h2>Utility Methods</h2>
<p><a data-primary="collections" data-secondary="utility methods" data-type="indexterm" id="ix_ch08-asciidoc17"/>The <code>java.util.Collections</code> class is home to quite a few static utility
methods designed for use with collections. <a data-primary="java.util.Collections" data-secondary="wrapper methods" data-type="indexterm" id="idm45927723481520"/><a data-primary="wrapper collections" data-type="indexterm" id="idm45927723480544"/>One important group of these
methods is the collection <em>wrapper</em> methods: they return a
special-purpose collection wrapped around a collection you specify. The
purpose of the wrapper collection is to wrap additional functionality
around a collection that does not provide it itself. Wrappers exist to
provide thread-safety, write protection, and runtime type checking.
Wrapper collections are always <em>backed by</em> the original collection,
which means that the methods of the wrapper simply dispatch to the
equivalent methods of the wrapped collection. This means that changes
made to the collection through the wrapper are visible through the
wrapped collection and vice versa.</p>
<p>The first set of wrapper methods provides threadsafe wrappers around
collections. Except for the legacy classes <code>Vector</code> and <code>Hashtable</code>, the
collection implementations in <code>java.util</code> do not have <code>synchronized</code>
methods and are not protected against concurrent access by multiple
threads. If you need threadsafe collections and don’t mind the
additional overhead of synchronization, create them with code like this:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">List</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code><code class="w"> </code><code class="n">list</code><code class="w"> </code><code class="o">=</code><code class="w"/>
<code class="w">    </code><code class="n">Collections</code><code class="p">.</code><code class="na">synchronizedList</code><code class="p">(</code><code class="k">new</code><code class="w"> </code><code class="n">ArrayList</code><code class="o">&lt;&gt;</code><code class="p">());</code><code class="w"/>
<code class="n">Set</code><code class="o">&lt;</code><code class="n">Integer</code><code class="o">&gt;</code><code class="w"> </code><code class="n">set</code><code class="w"> </code><code class="o">=</code><code class="w"/>
<code class="w">    </code><code class="n">Collections</code><code class="p">.</code><code class="na">synchronizedSet</code><code class="p">(</code><code class="k">new</code><code class="w"> </code><code class="n">HashSet</code><code class="o">&lt;&gt;</code><code class="p">());</code><code class="w"/>
<code class="n">Map</code><code class="o">&lt;</code><code class="n">String</code><code class="p">,</code><code class="n">Integer</code><code class="o">&gt;</code><code class="w"> </code><code class="n">map</code><code class="w"> </code><code class="o">=</code><code class="w"/>
<code class="w">    </code><code class="n">Collections</code><code class="p">.</code><code class="na">synchronizedMap</code><code class="p">(</code><code class="k">new</code><code class="w"> </code><code class="n">HashMap</code><code class="o">&lt;&gt;</code><code class="p">());</code><code class="w"/></pre>
<p>A second set of wrapper methods provides collection objects through
which the underlying collection cannot be modified. They return a
read-only view of a collection: an <code>UnsupportedOperationException</code> will result from changing the collection’s content. These wrappers
are useful when you must pass a collection to a method that must not be
allowed to modify or mutate the content of the collection in any way:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">List</code><code class="o">&lt;</code><code class="n">Integer</code><code class="o">&gt;</code><code class="w"> </code><code class="n">primes</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">ArrayList</code><code class="o">&lt;&gt;</code><code class="p">();</code><code class="w"/>
<code class="n">List</code><code class="o">&lt;</code><code class="n">Integer</code><code class="o">&gt;</code><code class="w"> </code><code class="n">readonly</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Collections</code><code class="p">.</code><code class="na">unmodifiableList</code><code class="p">(</code><code class="n">primes</code><code class="p">);</code><code class="w"/>
<code class="c1">// We can modify the list through primes</code><code class="w"/>
<code class="n">primes</code><code class="p">.</code><code class="na">addAll</code><code class="p">(</code><code class="n">Arrays</code><code class="p">.</code><code class="na">asList</code><code class="p">(</code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="mi">3</code><code class="p">,</code><code class="w"> </code><code class="mi">5</code><code class="p">,</code><code class="w"> </code><code class="mi">7</code><code class="p">,</code><code class="w"> </code><code class="mi">11</code><code class="p">,</code><code class="w"> </code><code class="mi">13</code><code class="p">,</code><code class="w"> </code><code class="mi">17</code><code class="p">,</code><code class="w"> </code><code class="mi">19</code><code class="p">));</code><code class="w"/>
<code class="c1">// But we can't modify through the read-only wrapper</code><code class="w"/>
<code class="n">readonly</code><code class="p">.</code><code class="na">add</code><code class="p">(</code><code class="mi">23</code><code class="p">);</code><code class="w">  </code><code class="c1">// UnsupportedOperationException</code><code class="w"/></pre>
<p>The <code>java.util.Collections</code> class also defines methods to operate on
collections. Some of the most notable are methods to sort and search the
elements of <span class="keep-together">collections</span>:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">Collections</code><code class="p">.</code><code class="na">sort</code><code class="p">(</code><code class="n">list</code><code class="p">);</code><code class="w"/>
<code class="c1">// list must be sorted first</code><code class="w"/>
<code class="kt">int</code><code class="w"> </code><code class="n">pos</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Collections</code><code class="p">.</code><code class="na">binarySearch</code><code class="p">(</code><code class="n">list</code><code class="p">,</code><code class="w"> </code><code class="s">"key"</code><code class="p">);</code><code class="w"/></pre>
<p>Here are some other interesting <code>Collections</code> methods:</p>
<pre data-code-language="java" data-type="programlisting"><code class="c1">// Copy list2 into list1, overwriting list1</code><code class="w"/>
<code class="n">Collections</code><code class="p">.</code><code class="na">copy</code><code class="p">(</code><code class="n">list1</code><code class="p">,</code><code class="w"> </code><code class="n">list2</code><code class="p">);</code><code class="w"/>
<code class="c1">// Fill list with Object o</code><code class="w"/>
<code class="n">Collections</code><code class="p">.</code><code class="na">fill</code><code class="p">(</code><code class="n">list</code><code class="p">,</code><code class="w"> </code><code class="n">o</code><code class="p">);</code><code class="w"/>
<code class="c1">// Find the largest element in Collection c</code><code class="w"/>
<code class="n">Collections</code><code class="p">.</code><code class="na">max</code><code class="p">(</code><code class="n">c</code><code class="p">);</code><code class="w"/>
<code class="c1">// Find the smallest element in Collection c</code><code class="w"/>
<code class="n">Collections</code><code class="p">.</code><code class="na">min</code><code class="p">(</code><code class="n">c</code><code class="p">);</code><code class="w"/>

<code class="n">Collections</code><code class="p">.</code><code class="na">reverse</code><code class="p">(</code><code class="n">list</code><code class="p">);</code><code class="w">      </code><code class="c1">// Reverse list</code><code class="w"/>
<code class="n">Collections</code><code class="p">.</code><code class="na">shuffle</code><code class="p">(</code><code class="n">list</code><code class="p">);</code><code class="w">      </code><code class="c1">// Mix up list</code><code class="w"/></pre>
<p>It is a good idea to familiarize yourself fully with the utility methods
in <code>Collections</code> and <code>Arrays</code>, as they can save you from writing your own
implementation of a common task.</p>
<section data-pdf-bookmark="Special-case collections" data-type="sect3"><div class="sect3" id="idm45927723128656">
<h3>Special-case collections</h3>
<p><a data-primary="collections" data-secondary="special-case collections" data-type="indexterm" id="idm45927723178800"/><a data-primary="empty collections, Collections class methods for" data-type="indexterm" id="idm45927723177632"/><a data-primary="java.util.Collections" data-secondary="special-case collections" data-type="indexterm" id="idm45927723176992"/><a data-primary="singleton pattern" data-secondary="Collections class methods for" data-type="indexterm" id="idm45927723176080"/>In addition to its wrapper methods, the <code>java.util.Collections</code> class
also defines utility methods for creating immutable collection
instances that contain a single element and other methods for creating
empty collections. <code>singleton()</code>, <code>singletonList()</code>, and
<code>singletonMap()</code> return immutable <code>Set</code>, <code>List</code>, and <code>Map</code> objects that
contain a single specified object or a single key/value pair. These
methods are useful when you need to pass a single object to a method
that expects a collection.</p>
<p>The <code>Collections</code> class also includes methods that return empty
collections. If you are writing a method that returns a collection, it
is usually best to handle the no-values-to-return case by returning an
empty collection instead of a special-case value like <code>null</code>:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">Set</code><code class="o">&lt;</code><code class="n">Integer</code><code class="o">&gt;</code><code class="w"> </code><code class="n">si</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Collections</code><code class="p">.</code><code class="na">emptySet</code><code class="p">();</code><code class="w"/>
<code class="n">List</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code><code class="w"> </code><code class="n">ss</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Collections</code><code class="p">.</code><code class="na">emptyList</code><code class="p">();</code><code class="w"/>
<code class="n">Map</code><code class="o">&lt;</code><code class="n">String</code><code class="p">,</code><code class="w"> </code><code class="n">Integer</code><code class="o">&gt;</code><code class="w"> </code><code class="n">m</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Collections</code><code class="p">.</code><code class="na">emptyMap</code><code class="p">();</code><code class="w"/></pre>
<p><a data-primary="Java 9" data-primary-sortas="Java 09" data-secondary="special-case collections" data-type="indexterm" id="idm45927723098832"/>Since Java 9, though, these methods are frequently replaced by the <code>of()</code>
methods on the <code>Set</code>, <code>List</code> and <code>Map</code> interfaces.</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">Set</code><code class="o">&lt;</code><code class="n">Integer</code><code class="o">&gt;</code><code class="w"> </code><code class="n">si</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Set</code><code class="p">.</code><code class="na">of</code><code class="p">();</code><code class="w"/>
<code class="n">List</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code><code class="w"> </code><code class="n">ss</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">List</code><code class="p">.</code><code class="na">of</code><code class="p">();</code><code class="w"/>
<code class="n">Map</code><code class="o">&lt;</code><code class="n">String</code><code class="p">,</code><code class="w"> </code><code class="n">Integer</code><code class="o">&gt;</code><code class="w"> </code><code class="n">m</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Map</code><code class="p">.</code><code class="na">of</code><code class="p">();</code><code class="w"/></pre>
<p>These return immutable versions of their type and may also take elements
through the same method.</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">Set</code><code class="o">&lt;</code><code class="n">Integer</code><code class="o">&gt;</code><code class="w"> </code><code class="n">si</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Set</code><code class="p">.</code><code class="na">of</code><code class="p">(</code><code class="mi">1</code><code class="p">);</code><code class="w"/>
<code class="n">List</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code><code class="w"> </code><code class="n">ss</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">List</code><code class="p">.</code><code class="na">of</code><code class="p">(</code><code class="s">"string"</code><code class="p">);</code><code class="w"/>
<code class="n">Map</code><code class="o">&lt;</code><code class="n">String</code><code class="p">,</code><code class="w"> </code><code class="n">Integer</code><code class="o">&gt;</code><code class="w"> </code><code class="n">m</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Map</code><code class="p">.</code><code class="na">of</code><code class="p">(</code><code class="s">"one"</code><code class="p">,</code><code class="w"> </code><code class="mi">1</code><code class="p">);</code><code class="w"/></pre>
<p>Finally, <code>nCopies()</code> returns an immutable <code>List</code> that contains a
specified number of copies of a single specified object:<a data-startref="ix_ch08-asciidoc17" data-type="indexterm" id="idm45927722901968"/></p>
<pre data-code-language="java" data-type="programlisting"><code class="n">List</code><code class="o">&lt;</code><code class="n">Integer</code><code class="o">&gt;</code><code class="w"> </code><code class="n">tenzeros</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Collections</code><code class="p">.</code><code class="na">nCopies</code><code class="p">(</code><code class="mi">10</code><code class="p">,</code><code class="w"> </code><code class="mi">0</code><code class="p">);</code><code class="w"/></pre>
</div></section>
</div></section>
<section data-pdf-bookmark="Arrays and Helper Methods" data-type="sect2"><div class="sect2" id="idm45927723179456">
<h2>Arrays and Helper Methods</h2>
<p><a data-primary="arrays" data-secondary="converting to/from objects" data-type="indexterm" id="ix_ch08-asciidoc18"/><a data-primary="arrays" data-secondary="Java Collections and" data-type="indexterm" id="ix_ch08-asciidoc19"/><a data-primary="collections" data-secondary="arrays and helper methods" data-type="indexterm" id="ix_ch08-asciidoc20"/><a data-primary="objects" data-secondary="converting to/from arrays" data-type="indexterm" id="ix_ch08-asciidoc21"/>Arrays of objects and collections serve similar purposes. It is
possible to convert from one to the other:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">String</code><code class="o">[]</code><code class="w"> </code><code class="n">a</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="s">"this"</code><code class="p">,</code><code class="w"> </code><code class="s">"is"</code><code class="p">,</code><code class="w"> </code><code class="s">"a"</code><code class="p">,</code><code class="w"> </code><code class="s">"test"</code><code class="w"> </code><code class="p">};</code><code class="w">  </code><code class="c1">// An array</code><code class="w"/>
<code class="c1">// View array as an ungrowable list</code><code class="w"/>
<code class="n">List</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code><code class="w"> </code><code class="n">l</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Arrays</code><code class="p">.</code><code class="na">asList</code><code class="p">(</code><code class="n">a</code><code class="p">);</code><code class="w"/>
<code class="c1">// Make a growable copy of the view</code><code class="w"/>
<code class="n">List</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code><code class="w"> </code><code class="n">m</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">ArrayList</code><code class="o">&lt;&gt;</code><code class="p">(</code><code class="n">l</code><code class="p">);</code><code class="w"/>

<code class="c1">// asList() is a varargs method so we can do this, too:</code><code class="w"/>
<code class="n">Set</code><code class="o">&lt;</code><code class="n">Character</code><code class="o">&gt;</code><code class="w"> </code><code class="n">abc</code><code class="w"> </code><code class="o">=</code><code class="w"/>
<code class="w">    </code><code class="k">new</code><code class="w"> </code><code class="n">HashSet</code><code class="o">&lt;</code><code class="n">Character</code><code class="o">&gt;</code><code class="p">(</code><code class="n">Arrays</code><code class="p">.</code><code class="na">asList</code><code class="p">(</code><code class="sc">'a'</code><code class="p">,</code><code class="w"> </code><code class="sc">'b'</code><code class="p">,</code><code class="w"> </code><code class="sc">'c'</code><code class="p">));</code><code class="w"/>

<code class="c1">// Collection defines a toArray method. The no-args version creates</code><code class="w"/>
<code class="c1">// an Object[] array, copies collection elements to it and returns it</code><code class="w"/>
<code class="c1">// Get set elements as an array</code><code class="w"/>
<code class="n">Object</code><code class="o">[]</code><code class="w"> </code><code class="n">members</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">set</code><code class="p">.</code><code class="na">toArray</code><code class="p">();</code><code class="w"/>
<code class="c1">// Get list elements as an array</code><code class="w"/>
<code class="n">Object</code><code class="o">[]</code><code class="w"> </code><code class="n">items</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">list</code><code class="p">.</code><code class="na">toArray</code><code class="p">();</code><code class="w"/>
<code class="c1">// Get map key objects as an array</code><code class="w"/>
<code class="n">Object</code><code class="o">[]</code><code class="w"> </code><code class="n">keys</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">map</code><code class="p">.</code><code class="na">keySet</code><code class="p">().</code><code class="na">toArray</code><code class="p">();</code><code class="w"/>
<code class="c1">// Get map value objects as an array</code><code class="w"/>
<code class="n">Object</code><code class="o">[]</code><code class="w"> </code><code class="n">values</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">map</code><code class="p">.</code><code class="na">values</code><code class="p">().</code><code class="na">toArray</code><code class="p">();</code><code class="w"/>

<code class="c1">// If you want the return value to be something other than Object[],</code><code class="w"/>
<code class="c1">// pass in an array of the appropriate type. If the array is not</code><code class="w"/>
<code class="c1">// big enough, another one of the same type will be allocated.</code><code class="w"/>
<code class="c1">// If the array is too big, the collection elements copied to it</code><code class="w"/>
<code class="c1">// will be null-filled</code><code class="w"/>
<code class="n">String</code><code class="o">[]</code><code class="w"> </code><code class="n">c</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">l</code><code class="p">.</code><code class="na">toArray</code><code class="p">(</code><code class="k">new</code><code class="w"> </code><code class="n">String</code><code class="o">[</code><code class="mi">0</code><code class="o">]</code><code class="p">);</code><code class="w"/></pre>
<p>In addition, there are a number of useful helper methods for working
with Java’s arrays, which are included here for completeness.</p>
<p><a data-primary="arrayCopy()" data-type="indexterm" id="idm45927722591824"/><a data-primary="java.lang.System" data-type="indexterm" id="idm45927722591216"/>The <code>java.lang.System</code> class defines an <code>arraycopy()</code> method that is
useful for copying specified elements in one array to a specified
position in a second array. The second array must be the same type as
the first, and it can even be the same array:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kt">char</code><code class="o">[]</code><code class="w"> </code><code class="n">text</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">"Now is the time"</code><code class="p">.</code><code class="na">toCharArray</code><code class="p">();</code><code class="w"/>
<code class="kt">char</code><code class="o">[]</code><code class="w"> </code><code class="n">copy</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="kt">char</code><code class="o">[</code><code class="mi">100</code><code class="o">]</code><code class="p">;</code><code class="w"/>
<code class="c1">// Copy 10 characters from element 4 of text into copy,</code><code class="w"/>
<code class="c1">// starting at copy[0]</code><code class="w"/>
<code class="n">System</code><code class="p">.</code><code class="na">arraycopy</code><code class="p">(</code><code class="n">text</code><code class="p">,</code><code class="w"> </code><code class="mi">4</code><code class="p">,</code><code class="w"> </code><code class="n">copy</code><code class="p">,</code><code class="w"> </code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="mi">10</code><code class="p">);</code><code class="w"/>

<code class="c1">// Move some of the text to later elements, making room for</code><code class="w"/>
<code class="c1">// insertions If target and source are the same, this will involve</code><code class="w"/>
<code class="c1">// copying to a temporary array</code><code class="w"/>
<code class="n">System</code><code class="p">.</code><code class="na">arraycopy</code><code class="p">(</code><code class="n">copy</code><code class="p">,</code><code class="w"> </code><code class="mi">3</code><code class="p">,</code><code class="w"> </code><code class="n">copy</code><code class="p">,</code><code class="w"> </code><code class="mi">6</code><code class="p">,</code><code class="w"> </code><code class="mi">7</code><code class="p">);</code><code class="w"/></pre>
<p>There are also a number of useful static methods defined on the
<code>Arrays</code> class:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kt">int</code><code class="o">[]</code><code class="w"> </code><code class="n">intarray</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="kt">int</code><code class="o">[]</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="mi">10</code><code class="p">,</code><code class="w"> </code><code class="mi">5</code><code class="p">,</code><code class="w"> </code><code class="mi">7</code><code class="p">,</code><code class="w"> </code><code class="o">-</code><code class="mi">3</code><code class="w"> </code><code class="p">};</code><code class="w"> </code><code class="c1">// An array of integers</code><code class="w"/>
<code class="n">Arrays</code><code class="p">.</code><code class="na">sort</code><code class="p">(</code><code class="n">intarray</code><code class="p">);</code><code class="w">                       </code><code class="c1">// Sort it in place</code><code class="w"/>
<code class="c1">// Value 7 is found at index 2</code><code class="w"/>
<code class="kt">int</code><code class="w"> </code><code class="n">pos</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Arrays</code><code class="p">.</code><code class="na">binarySearch</code><code class="p">(</code><code class="n">intarray</code><code class="p">,</code><code class="w"> </code><code class="mi">7</code><code class="p">);</code><code class="w"/>
<code class="c1">// Not found: negative return value</code><code class="w"/>
<code class="n">pos</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Arrays</code><code class="p">.</code><code class="na">binarySearch</code><code class="p">(</code><code class="n">intarray</code><code class="p">,</code><code class="w"> </code><code class="mi">12</code><code class="p">);</code><code class="w"/>

<code class="c1">// Arrays of objects can be sorted and searched too</code><code class="w"/>
<code class="n">String</code><code class="o">[]</code><code class="w"> </code><code class="n">strarray</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">String</code><code class="o">[]</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="s">"now"</code><code class="p">,</code><code class="w"> </code><code class="s">"is"</code><code class="p">,</code><code class="w"> </code><code class="s">"the"</code><code class="p">,</code><code class="w"> </code><code class="s">"time"</code><code class="w"> </code><code class="p">};</code><code class="w"/>
<code class="n">Arrays</code><code class="p">.</code><code class="na">sort</code><code class="p">(</code><code class="n">strarray</code><code class="p">);</code><code class="w">   </code><code class="c1">// sorted to: { "is", "now", "the", "time" }</code><code class="w"/>

<code class="c1">// Arrays.equals compares all elements of two arrays</code><code class="w"/>
<code class="n">String</code><code class="o">[]</code><code class="w"> </code><code class="n">clone</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">(</code><code class="n">String</code><code class="o">[]</code><code class="p">)</code><code class="w"> </code><code class="n">strarray</code><code class="p">.</code><code class="na">clone</code><code class="p">();</code><code class="w"/>
<code class="kt">boolean</code><code class="w"> </code><code class="n">b1</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Arrays</code><code class="p">.</code><code class="na">equals</code><code class="p">(</code><code class="n">strarray</code><code class="p">,</code><code class="w"> </code><code class="n">clone</code><code class="p">);</code><code class="w">  </code><code class="c1">// Yes, they're equal</code><code class="w"/>

<code class="c1">// Arrays.fill  initializes array elements</code><code class="w"/>
<code class="c1">// An empty array; elements set to 0</code><code class="w"/>
<code class="kt">byte</code><code class="o">[]</code><code class="w"> </code><code class="n">data</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="kt">byte</code><code class="o">[</code><code class="mi">100</code><code class="o">]</code><code class="p">;</code><code class="w"/>
<code class="c1">// Set them all to -1</code><code class="w"/>
<code class="n">Arrays</code><code class="p">.</code><code class="na">fill</code><code class="p">(</code><code class="n">data</code><code class="p">,</code><code class="w"> </code><code class="p">(</code><code class="kt">byte</code><code class="p">)</code><code class="w"> </code><code class="o">-</code><code class="mi">1</code><code class="p">);</code><code class="w"/>
<code class="c1">// Set elements 5, 6, 7, 8, 9 to -2</code><code class="w"/>
<code class="n">Arrays</code><code class="p">.</code><code class="na">fill</code><code class="p">(</code><code class="n">data</code><code class="p">,</code><code class="w"> </code><code class="mi">5</code><code class="p">,</code><code class="w"> </code><code class="mi">10</code><code class="p">,</code><code class="w"> </code><code class="p">(</code><code class="kt">byte</code><code class="p">)</code><code class="w"> </code><code class="o">-</code><code class="mi">2</code><code class="p">);</code><code class="w"/>

<code class="c1">// Creates a new array with elements copied into it</code><code class="w"/>
<code class="kt">int</code><code class="o">[]</code><code class="w"> </code><code class="n">copied</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Arrays</code><code class="p">.</code><code class="na">copyOf</code><code class="p">(</code><code class="k">new</code><code class="w"> </code><code class="kt">int</code><code class="o">[]</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="mi">3</code><code class="w"> </code><code class="p">},</code><code class="w"> </code><code class="mi">2</code><code class="p">);</code><code class="w"/></pre>
<p>Arrays can be treated and manipulated as objects in Java. Given an
arbitrary object <code>o</code>, you can use code such as the following to find out
if the object is an array and, if so, what type of array it is<a data-startref="ix_ch08-asciidoc21" data-type="indexterm" id="idm45927722219440"/><a data-startref="ix_ch08-asciidoc20" data-type="indexterm" id="idm45927722218832"/><a data-startref="ix_ch08-asciidoc19" data-type="indexterm" id="idm45927722218192"/><a data-startref="ix_ch08-asciidoc18" data-type="indexterm" id="idm45927722320896"/>:<a data-startref="ix_ch08-asciidoc1" data-type="indexterm" id="idm45927722320096"/></p>
<pre data-code-language="java" data-type="programlisting"><code class="n">Class</code><code class="w"> </code><code class="n">type</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">o</code><code class="p">.</code><code class="na">getClass</code><code class="p">();</code><code class="w"/>
<code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="n">type</code><code class="p">.</code><code class="na">isArray</code><code class="p">())</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="n">Class</code><code class="w"> </code><code class="n">elementType</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">type</code><code class="p">.</code><code class="na">getComponentType</code><code class="p">();</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
</div></section>
</div></section>
<section class="pagebreak-before less_space" data-pdf-bookmark="Java Streams and Lambda Expressions" data-type="sect1"><div class="sect1" id="idm45927722875568">
<h1>Java Streams and Lambda Expressions</h1>
<p><a data-primary="Java Streams" data-type="indexterm" id="ix_ch08-asciidoc22"/><a data-primary="Java Streams" data-secondary="lambda expressions and" data-type="indexterm" id="ix_ch08-asciidoc23"/><a data-primary="lambda expressions" data-secondary="Java Streams and" data-type="indexterm" id="ix_ch08-asciidoc24"/>One <a data-primary="Java 8" data-primary-sortas="Java 08" data-secondary="Streams" data-type="indexterm" id="idm45927722158352"/>of the major reasons for introducing lambda expressions in Java 8
was to facilitate the overhaul of the Collections API to allow more
modern programming styles to be used by Java developers. Until the
release of Java 8, the handling of data structures in Java looked a
little bit dated.
Many languages now support a programming style that allows collections to be treated as a whole, rather than requiring them to be broken apart and iterated over.</p>
<p>In fact, many Java developers had taken to using alternative data
structures libraries to achieve some of the expressivity and
productivity they felt was lacking in the Collections API.
The key to upgrading the APIs was to introduce new classes and methods that would accept lambda expressions as parameters—to define <em>what</em> needed to be done, rather than precisely <em>how</em>.
This is a conception of programming that comes from the functional style.</p>
<p><a data-primary="functional collections" data-seealso="Java Streams" data-type="indexterm" id="idm45927722155472"/>The introduction of the functional collections—which are called <em>Java Streams</em> to make clear their divergence from the older collections approach—is an important step forward.
A stream can be created from a collection simply by calling the <code>stream()</code> method on an existing collection.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><a data-primary="default methods" data-secondary="collections and" data-type="indexterm" id="idm45927722152688"/>The desire to add new methods to existing interfaces was directly
responsible for the new language feature referred to as <em>default
methods</em> (see <a data-type="xref" href="ch04.xhtml#javanut8-CHP-4-SECT-1.7">“Default Methods”</a> for more
details). Without this new mechanism, older implementations of the
Collections interfaces would fail to compile under Java 8 and would
fail to link if loaded into a Java 8 runtime.</p>
</div>
<p>However, the arrival of the Streams API does not erase history.
The Collections API is deeply embedded in the Java world, and it is not functional.
Java’s commitment to backward compatibility and to a rigid language grammar means that the Collections will never go away.
Java code, even when written in a functional style, will never be entirely free of boilerplate and will never have the concise syntax that we see in languages such as Haskell or Scala.</p>
<p>This is part of the inevitable trade-off in language design—Java has retrofitted functional capabilities on top of an imperative design and base.
This is not the same as designing for functional programming from the ground up.
A more important question is: Are the functional capabilities supplied from Java 8 onward what working programmers need to build their applications?</p>
<p>The rapid adoption of Java 8 over previous versions and the community reaction seem to indicate that the new features have been a success and have provided what the ecosystem was looking for.</p>
<p>In this section, we will introduce the use of Java streams and lambda expressions in the Java Collections.
For a fuller treatment, see <a class="orm:hideurl" href="http://shop.oreilly.com/product/0636920030713.do"><em>Java 8 Lambdas</em></a> by Richard Warburton (O’Reilly).</p>
<section data-pdf-bookmark="Functional Approaches" data-type="sect2"><div class="sect2" id="idm45927722121392">
<h2>Functional Approaches</h2>
<p><a data-primary="functional programming" data-secondary="key patterns" data-type="indexterm" id="ix_ch08-asciidoc25"/><a data-primary="Java Streams" data-secondary="functional approaches" data-type="indexterm" id="ix_ch08-asciidoc26"/>The approach that Java 8 Streams wished to enable was derived from functional
programming languages and styles. We met some of these key patterns in
<a data-type="xref" href="ch04.xhtml#javanut8-CHP-4-SECT-4.3">“Functional Programming”</a>—let’s reintroduce them and
look at some examples of each.</p>
<section data-pdf-bookmark="Filter" data-type="sect3"><div class="sect3" id="idm45927722116832">
<h3>Filter</h3>
<p>The filter idiom applies a piece of code returning either
true or false (known as a predicate) to each element in a collection. A new
collection is built consisting of the elements that “passed the test” (i.e.,
the bit of code returned <code>true</code> when applied to the element).</p>
<p>For example, let’s look at some code to work with a collection of cats
and pick out the tigers:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">List</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code><code class="w"> </code><code class="n">cats</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">List</code><code class="p">.</code><code class="na">of</code><code class="p">(</code><code class="s">"tiger"</code><code class="p">,</code><code class="w"> </code><code class="s">"cat"</code><code class="p">,</code><code class="w"> </code><code class="s">"TIGER"</code><code class="p">,</code><code class="w"> </code><code class="s">"leopard"</code><code class="p">);</code><code class="w"/>
<code class="n">String</code><code class="w"> </code><code class="n">search</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">"tiger"</code><code class="p">;</code><code class="w"/>
<code class="n">String</code><code class="w"> </code><code class="n">tigers</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">cats</code><code class="p">.</code><code class="na">stream</code><code class="p">()</code><code class="w"/>
<code class="w">                    </code><code class="p">.</code><code class="na">filter</code><code class="p">(</code><code class="n">s</code><code class="w"> </code><code class="o">-&gt;</code><code class="w"> </code><code class="n">s</code><code class="p">.</code><code class="na">equalsIgnoreCase</code><code class="p">(</code><code class="n">search</code><code class="p">))</code><code class="w"/>
<code class="w">                    </code><code class="p">.</code><code class="na">collect</code><code class="p">(</code><code class="n">Collectors</code><code class="p">.</code><code class="na">joining</code><code class="p">(</code><code class="s">", "</code><code class="p">));</code><code class="w"/>
<code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="n">tigers</code><code class="p">);</code><code class="w"/></pre>
<p><a data-primary="filter()" data-secondary="in Java 8" data-secondary-sortas="Java 8" data-type="indexterm" id="idm45927722110768"/>The key piece is the call to <code>filter()</code>, which takes a lambda
expression. The lambda takes in a string and returns a Boolean value.
This is applied over the whole collection <code>cats</code>, and a new collection
is created, which contains only tigers (however they were capitalized).</p>
<p><a data-primary="filter()" data-secondary="Predicate interface" data-type="indexterm" id="idm45927722030512"/><a data-primary="Predicate interface" data-type="indexterm" id="idm45927722029536"/>The <code>filter()</code> method takes in an instance of the <code>Predicate</code>
interface, from the package <code>java.util.function</code>. This is a
functional interface, with only a single nondefault method, and so is a
perfect fit for a lambda expression.</p>
<p><a data-primary="collect()" data-type="indexterm" id="idm45927722027200"/>Note the final call to <code>collect()</code>; this is an essential part of the
API and is used to “gather up” the results at the end of the lambda
operations. We’ll discuss it in more detail in the next section.</p>
<p><code>Predicate</code> has some other very useful default methods, such as for
constructing combined predicates by using logic operations. <a data-primary="or()" data-type="indexterm" id="idm45927722025120"/>For example,
if the tigers want to admit leopards into their group, this can be
represented by using the <code>or()</code> method:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">Predicate</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code><code class="w"> </code><code class="n">p</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">s</code><code class="w"> </code><code class="o">-&gt;</code><code class="w"> </code><code class="n">s</code><code class="p">.</code><code class="na">equalsIgnoreCase</code><code class="p">(</code><code class="n">search</code><code class="p">);</code><code class="w"/>
<code class="n">Predicate</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code><code class="w"> </code><code class="n">combined</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">p</code><code class="p">.</code><code class="na">or</code><code class="p">(</code><code class="n">s</code><code class="w"> </code><code class="o">-&gt;</code><code class="w"> </code><code class="n">s</code><code class="p">.</code><code class="na">equals</code><code class="p">(</code><code class="s">"leopard"</code><code class="p">));</code><code class="w"/>
<code class="n">String</code><code class="w"> </code><code class="n">pride</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">cats</code><code class="p">.</code><code class="na">stream</code><code class="p">()</code><code class="w"/>
<code class="w">                   </code><code class="p">.</code><code class="na">filter</code><code class="p">(</code><code class="n">combined</code><code class="p">)</code><code class="w"/>
<code class="w">                   </code><code class="p">.</code><code class="na">collect</code><code class="p">(</code><code class="n">Collectors</code><code class="p">.</code><code class="na">joining</code><code class="p">(</code><code class="s">", "</code><code class="p">));</code><code class="w"/>
<code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="n">pride</code><code class="p">);</code><code class="w"/></pre>
<p>Note that it’s much clearer if the <code>Predicate&lt;String&gt;</code> object <code>p</code> is explicitly created, so that the defaulted <code>or()</code> method can be called on it and the second lambda expression (which will also be automatically converted to a <code>Predicate&lt;String&gt;</code>) passed to it.</p>
</div></section>
<section data-pdf-bookmark="Map" data-type="sect3"><div class="sect3" id="idm45927722116208">
<h3>Map</h3>
<p><a data-primary="java.util.function" data-type="indexterm" id="idm45927721934560"/><a data-primary="map()" data-type="indexterm" id="idm45927721933696"/>The map idiom makes use of the interface <code>Function&lt;T, R&gt;</code>
in the package <code>java.util.function</code>.
<a data-primary="apply()" data-type="indexterm" id="idm45927721932064"/>Like <code>Predicate&lt;T&gt;</code>, this is a functional interface and so only has one nondefaulted method, <code>apply()</code>.
The map idiom is about transforming one stream into a new stream, where the new
stream potentially has different types and values than the original. This shows up in the API as the fact that <code>Function&lt;T, R&gt;</code> has two separate type parameters.
The name of the type parameter <code>R</code> indicates that this represents the return type of the function.</p>
<p>Let’s look at a code example that uses <code>map()</code>:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">List</code><code class="o">&lt;</code><code class="n">Integer</code><code class="o">&gt;</code><code class="w"> </code><code class="n">namesLength</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">cats</code><code class="p">.</code><code class="na">stream</code><code class="p">()</code><code class="w"/>
<code class="w">                </code><code class="p">.</code><code class="na">map</code><code class="p">(</code><code class="n">String</code><code class="p">::</code><code class="n">length</code><code class="p">)</code><code class="w"/>
<code class="w">                </code><code class="p">.</code><code class="na">toList</code><code class="p">();</code><code class="w"/>
<code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="n">namesLength</code><code class="p">);</code><code class="w"/></pre>
<p>This is called upon the previous <code>cats</code> variable (which is a <code>Stream&lt;String&gt;</code>)
and applies the function <code>String::length</code> (a method reference) to each string in
turn. The result is a new stream—but of <code>Integer</code> this time. We turn that stream
into a <code>List</code> with the <code>toList()</code> method. Note that unlike the collections API,
the <code>map()</code> method does not mutate the stream in place but returns a new value.
This is key to the functional style as used here.</p>
</div></section>
<section data-pdf-bookmark="forEach" data-type="sect3"><div class="sect3" id="idm45927721850496">
<h3>forEach</h3>
<p><a data-primary="forEach()" data-type="indexterm" id="idm45927721810304"/>The map and filter idioms are used to create one collection from
another. In languages that are strongly functional, this would be
combined with requiring that the original collection was not affected by
the body of the lambda as it touched each element. In computer science
terms, this means that the lambda body should be “side effect free.”</p>
<p>In Java, of course, we often need to deal with mutable data, so the Streams API provides a way to mutate elements as the collection is traversed—the <code>forEach()</code> method. This takes an argument of type <code>Consumer&lt;T&gt;</code>, which is a functional interface that is expected to operate by side effects (although whether it actually mutates the data or not is of lesser importance).
This means that the signature of lambdas that can be converted to <code>Consumer&lt;T&gt;</code> is <code>(T t) → void</code>.
Let’s look at a quick example of <code>forEach()</code>:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">List</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code><code class="w"> </code><code class="n">pets</code><code class="w"> </code><code class="o">=</code><code class="w"/>
<code class="w">  </code><code class="n">List</code><code class="p">.</code><code class="na">of</code><code class="p">(</code><code class="s">"dog"</code><code class="p">,</code><code class="w"> </code><code class="s">"cat"</code><code class="p">,</code><code class="w"> </code><code class="s">"fish"</code><code class="p">,</code><code class="w"> </code><code class="s">"iguana"</code><code class="p">,</code><code class="w"> </code><code class="s">"ferret"</code><code class="p">);</code><code class="w"/>
<code class="n">pets</code><code class="p">.</code><code class="na">stream</code><code class="p">().</code><code class="na">forEach</code><code class="p">(</code><code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">::</code><code class="n">println</code><code class="p">);</code><code class="w"/></pre>
<p>In this example, we are simply printing out each member of the
collection. However, we’re doing so by using a special kind of method
reference as a lambda expression. <a data-primary="bound method reference" data-type="indexterm" id="idm45927721744128"/>This type of method reference is
called a <em>bound method reference</em>, as it involves a specific object (in
this case, the object <code>System.out</code>, which is a static public field of
<code>System</code>). This is equivalent to the lambda expression:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">s</code><code class="w"> </code><code class="o">-&gt;</code><code class="w"> </code><code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="n">s</code><code class="p">);</code><code class="w"/></pre>
<p>This is of course eligible for conversion to an instance of a type that
implements <code>Consumer&lt;? super String&gt;</code> as required by the method
signature.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>Nothing prevents a <code>map()</code> or <code>filter()</code> call from mutating elements. It
is only a convention that they must not mutate, but it’s one that every Java
programmer should adhere to.</p>
</div>
<p>There’s one final functional technique that we should look at before we
move on. This is the practice of aggregating a collection down to a
single value, and it’s the subject of our next section.</p>
</div></section>
<section data-pdf-bookmark="Reduce" data-type="sect3"><div class="sect3" id="idm45927721713040">
<h3>Reduce</h3>
<p><a data-primary="reduce()" data-type="indexterm" id="idm45927721711440"/>Let’s look at the <code>reduce()</code> method. This implements the reduce idiom,
which is really a family of similar and related operations, some
referred to as fold, or aggregation, operations.</p>
<p>In Java, <code>reduce()</code> takes two arguments. These are the initial value,
which is often called the identity (or zero), and a function to apply
step by step. This function is of type <code>BinaryOperator&lt;T&gt;</code>, which is
another functional interface that takes in two arguments of the same
type and returns another value of that type. This second argument to
<code>reduce()</code> is a two-argument lambda. <code>reduce()</code> is defined in the
<code>javadoc</code> like this:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">T</code><code class="w"> </code><code class="nf">reduce</code><code class="p">(</code><code class="n">T</code><code class="w"> </code><code class="n">identity</code><code class="p">,</code><code class="w"> </code><code class="n">BinaryOperator</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="w"> </code><code class="n">aggregator</code><code class="p">);</code><code class="w"/></pre>
<p>The easy way to think about the second argument to <code>reduce()</code> is that it
creates a “running total” as it runs over the stream. It starts by
combining the identity with the first element of the stream to produce
the first result, then combines that result with the second element of
the stream, and so on.</p>
<p>It can help to imagine that the implementation of <code>reduce()</code> works a bit
like this:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code><code class="w"> </code><code class="n">T</code><code class="w"> </code><code class="nf">reduce</code><code class="p">(</code><code class="n">T</code><code class="w"> </code><code class="n">identity</code><code class="p">,</code><code class="w"> </code><code class="n">BinaryOperator</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="w"> </code><code class="n">aggregator</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">T</code><code class="w"> </code><code class="n">runningTotal</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">identity</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="k">for</code><code class="w"> </code><code class="p">(</code><code class="n">T</code><code class="w"> </code><code class="n">element</code><code class="w"> </code><code class="p">:</code><code class="w"> </code><code class="n">myStream</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="n">runningTotal</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">aggregator</code><code class="p">.</code><code class="na">apply</code><code class="p">(</code><code class="n">runningTotal</code><code class="p">,</code><code class="w"> </code><code class="n">element</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>

<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="n">runningTotal</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>In practice, implementations of <code>reduce()</code> can be more sophisticated
than these and can even execute in parallel if the data structure and
operations are amenable to this.</p>
</div>
<p>Let’s look at a quick example of a <code>reduce()</code> and calculate the sum of
some primes:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kt">double</code><code class="w"> </code><code class="n">sumPrimes</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">List</code><code class="p">.</code><code class="na">of</code><code class="p">(</code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="mi">3</code><code class="p">,</code><code class="w"> </code><code class="mi">5</code><code class="p">,</code><code class="w"> </code><code class="mi">7</code><code class="p">,</code><code class="w"> </code><code class="mi">11</code><code class="p">,</code><code class="w"> </code><code class="mi">13</code><code class="p">,</code><code class="w"> </code><code class="mi">17</code><code class="p">,</code><code class="w"> </code><code class="mi">19</code><code class="p">,</code><code class="w"> </code><code class="mi">23</code><code class="p">)</code><code class="w"/>
<code class="w">        </code><code class="p">.</code><code class="na">stream</code><code class="p">()</code><code class="w"/>
<code class="w">        </code><code class="p">.</code><code class="na">reduce</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="p">(</code><code class="n">x</code><code class="p">,</code><code class="w"> </code><code class="n">y</code><code class="p">)</code><code class="w"> </code><code class="o">-&gt;</code><code class="w"> </code><code class="n">x</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">y</code><code class="p">);</code><code class="w"/>
<code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="s">"Sum of some primes: "</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">sumPrimes</code><code class="p">);</code><code class="w"/></pre>
<p>In all of the examples we’ve met in this section, you may have noticed
the presence of a <code>stream()</code> method call on the <code>List</code> instance. This
is part of the evolution of Java Collections—it was originally chosen
partly out of necessity but has proved to be an excellent abstraction.
Let’s move on to discuss the Streams API in more detail.<a data-startref="ix_ch08-asciidoc26" data-type="indexterm" id="idm45927721503280"/><a data-startref="ix_ch08-asciidoc25" data-type="indexterm" id="idm45927721448896"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="The Streams API" data-type="sect2"><div class="sect2" id="idm45927721712416">
<h2>The Streams API</h2>
<p><a data-primary="Java Streams" data-secondary="introduction of Streams API" data-type="indexterm" id="ix_ch08-asciidoc27"/><a data-primary="Streams API" data-seealso="Java Streams" data-type="indexterm" id="ix_ch08-asciidoc28"/>The fundamental issue that caused the Java library designers to introduce the Streams API was the large number of implementations of the core collections interfaces present in the wild.
As these implementations predate Java 8 and lambdas, they would not have any of the methods corresponding to the new functional operations.
Worse still, as method names such as <code>map()</code> and <code>filter()</code> have never been part of the interface of the Collections, implementations may already have methods with those names.</p>
<p>To work around this problem, a new abstraction called a <code>Stream</code> was introduced.
<a data-primary="stream()" data-type="indexterm" id="idm45927721418640"/>The idea is that a <code>Stream</code> object can be generated from a collection object via the <code>stream()</code> method.
This <code>Stream</code> type, being new and under the control of the library designers, is then guaranteed to be free of collisions.
This then mitigates the risk of clash, as only Collections implementations that contained a <code>stream()</code> method would be affected.</p>
<p>A <code>Stream</code> object plays a similar role to an <code>Iterator</code> in the new approach to collections code.
The overall idea is for the developer to build up a sequence (or “pipeline”) of operations (such as <code>map</code>, <code>filter</code>, or <code>reduce</code>) that need to be applied to the collection as a whole.
The actual content of the operations will usually be expressed as a
lambda expression for each operation.</p>
<p>At the end of the pipeline, the results usually need to be gathered up, or
“materialized,” either as a new collection or another value.
This is done either by using a <code>Collector</code> or by finishing the pipeline with a “terminal method” such as <code>reduce()</code> that returns an actual value, rather than another stream.
Overall, the new approach to collections looks like
this:</p>
<pre data-code-language="java" data-type="programlisting"><code class="w">        </code><code class="n">stream</code><code class="p">()</code><code class="w">   </code><code class="n">filter</code><code class="p">()</code><code class="w">   </code><code class="n">map</code><code class="p">()</code><code class="w">   </code><code class="n">collect</code><code class="p">()</code><code class="w"/>
<code class="n">Collection</code><code class="w"> </code><code class="o">-&gt;</code><code class="w"> </code><code class="n">Stream</code><code class="w"> </code><code class="o">-&gt;</code><code class="w"> </code><code class="n">Stream</code><code class="w"> </code><code class="o">-&gt;</code><code class="w"> </code><code class="n">Stream</code><code class="w"> </code><code class="o">-&gt;</code><code class="w"> </code><code class="n">Collection</code><code class="w"/></pre>
<p>The <code>Stream</code> class behaves as a sequence of elements that are accessed
one at a time (although there are some types of streams that support
parallel access and can be used to process larger collections in a
naturally multithreaded way). In a similar way to an <code>Iterator</code>, the
<code>Stream</code> is used to take each item in turn.</p>
<p>As is usual for generic classes in Java, <code>Stream</code> is parameterized by a
reference type. However, in many cases, we actually want streams of
primitive types, especially ints and doubles. We cannot have
<code>Stream&lt;int&gt;</code>, so instead in <code>java.util.stream</code> there are special
(nongeneric) classes such as <code>IntStream</code> and <code>DoubleStream</code>. These are
known as <em>primitive specializations</em> of the <code>Stream</code> class and have
APIs that are very similar to the general <code>Stream</code> methods, except that
they use primitives where <span class="keep-together">appropriate</span>.</p>
<section data-pdf-bookmark="Lazy evaluation" data-type="sect3"><div class="sect3" id="idm45927721350304">
<h3>Lazy evaluation</h3>
<p><a data-primary="Java Streams" data-secondary="lazy evaluation" data-type="indexterm" id="idm45927721348864"/><a data-primary="lazy evaluation" data-type="indexterm" id="idm45927721347952"/>In fact, streams are more general than iterators (or even collections),
as streams do not manage storage for data. In earlier versions of Java,
there was always a presumption that all of the elements of a collection
existed (usually in memory). It was possible to work around this in a
limited way by insisting on the use of iterators everywhere, as well as by
having the iterators construct elements on the fly. However, this was
neither very convenient nor that common.</p>
<p>By contrast, streams are an abstraction for managing data, rather than
being concerned with the details of storage. This makes it possible to
handle more subtle data structures than just finite collections. For
example, infinite streams can easily be represented by the <code>Stream</code>
interface, and they can be used as a way, for example, to handle the set of
all square numbers. Let’s see how we could accomplish this using a
<code>Stream</code>:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code><code class="w"> </code><code class="kd">class</code> <code class="nc">SquareGenerator</code><code class="w"> </code><code class="kd">implements</code><code class="w"> </code><code class="n">IntSupplier</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">private</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="n">current</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">1</code><code class="p">;</code><code class="w"/>

<code class="w">    </code><code class="nd">@Override</code><code class="w"/>
<code class="w">    </code><code class="kd">public</code><code class="w"> </code><code class="kd">synchronized</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="nf">getAsInt</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="kt">int</code><code class="w"> </code><code class="n">thisResult</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">current</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="n">current</code><code class="p">;</code><code class="w"/>
<code class="w">        </code><code class="n">current</code><code class="o">++</code><code class="p">;</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="n">thisResult</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="n">IntStream</code><code class="w"> </code><code class="n">squares</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">IntStream</code><code class="p">.</code><code class="na">generate</code><code class="p">(</code><code class="k">new</code><code class="w"> </code><code class="n">SquareGenerator</code><code class="p">());</code><code class="w"/>
<code class="n">PrimitiveIterator</code><code class="p">.</code><code class="na">OfInt</code><code class="w"> </code><code class="n">stepThrough</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">squares</code><code class="p">.</code><code class="na">iterator</code><code class="p">();</code><code class="w"/>
<code class="k">for</code><code class="w"> </code><code class="p">(</code><code class="kt">int</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="o">&lt;</code><code class="w"> </code><code class="mi">10</code><code class="p">;</code><code class="w"> </code><code class="n">i</code><code class="o">++</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="n">stepThrough</code><code class="p">.</code><code class="na">nextInt</code><code class="p">());</code><code class="w"/>
<code class="p">}</code><code class="w"/>
<code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="s">"First iterator done..."</code><code class="p">);</code><code class="w"/>

<code class="c1">// We can go on as long as we like...</code><code class="w"/>
<code class="k">for</code><code class="w"> </code><code class="p">(</code><code class="kt">int</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="o">&lt;</code><code class="w"> </code><code class="mi">10</code><code class="p">;</code><code class="w"> </code><code class="n">i</code><code class="o">++</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="n">stepThrough</code><code class="p">.</code><code class="na">nextInt</code><code class="p">());</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>Because our list of possible values is infinite, we must adopt a model in which
elements do not all exist ahead of time. Essentially, a bit of code must return
the next element as we demand it. The key technique used to accomplish
this is <em>lazy evaluation</em>.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Lazy evaluation is a big change for Java, as until JDK 8 the value of an
expression was always computed as soon as it was assigned to a variable
(or passed into a method). <a data-primary="eager evaluation" data-type="indexterm" id="idm45927721341632"/>This familiar model, where values are
computed immediately, is called “eager evaluation” and it is the
default behavior for evaluation of expressions in most mainstream
programming languages.</p>
</div>
<p>We can see this lazy evaluation in action in our example above if we modify
<code><span class="keep-together">getAsInt()</span></code>
slightly to provide output actively when it is called:</p>
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="nd">@Override</code><code class="w"/>
<code class="w">    </code><code class="kd">public</code><code class="w"> </code><code class="kd">synchronized</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="nf">getAsInt</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="kt">int</code><code class="w"> </code><code class="n">thisResult</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">current</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="n">current</code><code class="p">;</code><code class="w"/>
<code class="w">        </code><code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">print</code><code class="p">(</code><code class="n">String</code><code class="p">.</code><code class="na">format</code><code class="p">(</code><code class="s">"%d... "</code><code class="p">,</code><code class="w"> </code><code class="n">thisResult</code><code class="p">));</code><code class="w"/>
<code class="w">        </code><code class="n">current</code><code class="o">++</code><code class="p">;</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="n">thisResult</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/></pre>
<p>When this modified program is run, we’ll see output that shows each <code>getAsInt()</code>
call immediately followed by the use of that value in the <code>for</code> loop:</p>
<pre data-type="programlisting">1... 1
4... 4
9... 9
16... 16
25... 25
36... 36
49... 49
64... 64
81... 81
100... 100
First iterator done...
121... 121
...</pre>
<p>One significant consequence of modeling the infinite stream is that
methods like <code>collect()</code> won’t work. This is because we can’t
materialize the whole stream to a collection (we would run out of memory
before we created the infinite amount of objects we would need).</p>
<p>Even when a stream isn’t infinite, it’s important to recognize what parts of the
evaluation are lazy. For instance, the following code that tries to show us
diagnostic information during a <code>map</code> operation doesn’t actually yield any
output:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">List</code><code class="p">.</code><code class="na">of</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="mi">3</code><code class="p">,</code><code class="w"> </code><code class="mi">4</code><code class="p">,</code><code class="w"> </code><code class="mi">5</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">.</code><code class="na">stream</code><code class="p">()</code><code class="w"/>
<code class="w">    </code><code class="p">.</code><code class="na">map</code><code class="p">((</code><code class="n">i</code><code class="p">)</code><code class="w"> </code><code class="o">-</code><code class="w"> </code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="n">i</code><code class="p">);</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="n">i</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="p">});</code><code class="w"/></pre>
<p>Only once we provide a terminal action such as <code>collect()</code> or <code>toList()</code>
is our <code>map()</code> lambda actually executed.</p>
<p>Recognizing which intermediate results are lazy in their evaluation is a topic
Java developers should be mindful of when working with the Stream API. The more
complicated implementation details, though, fall to library writers rather than
users of streams.</p>
<p>While the combination of <code>filter</code>, <code>map</code>, and <code>reduce</code> can accomplish almost any
stream-related task we’re after, it isn’t always the most convenient API. There are a
wide variety of additional methods that build on top of these primitives to give
us a richer vocabulary to work with stream.</p>
</div></section>
<section data-pdf-bookmark="Further filtering" data-type="sect3"><div class="sect3" id="idm45927721349712">
<h3>Further filtering</h3>
<p><a data-primary="filter()" data-secondary="Stream interface" data-type="indexterm" id="idm45927720924272"/><a data-primary="Java Streams" data-secondary="filtering" data-type="indexterm" id="idm45927720923296"/>A common place where working with streams benefits from more elaborate methods
is filtering. A number of methods on the <code>Stream</code> interface allow more
expressive descriptions of how we want to trim our streams for consumption:</p>
<pre data-code-language="java" data-type="programlisting"><code class="c1">// Distinct elements only</code><code class="w"/>
<code class="n">Stream</code><code class="p">.</code><code class="na">of</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="mi">3</code><code class="p">,</code><code class="w"> </code><code class="mi">4</code><code class="p">)</code><code class="w"/>
<code class="w">      </code><code class="p">.</code><code class="na">distinct</code><code class="p">();</code><code class="w"/>
<code class="c1">// Results in  [1, 2, 3, 4]</code><code class="w"/>

<code class="c1">// Ignores items until predicate matches, then returns remainder</code><code class="w"/>
<code class="c1">// Note that later elements aren't required to match the predicate.</code><code class="w"/>
<code class="n">Stream</code><code class="p">.</code><code class="na">of</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="mi">3</code><code class="p">,</code><code class="w"> </code><code class="mi">4</code><code class="p">,</code><code class="w"> </code><code class="mi">5</code><code class="p">,</code><code class="w"> </code><code class="mi">3</code><code class="p">)</code><code class="w"/>
<code class="w">      </code><code class="p">.</code><code class="na">dropWhile</code><code class="p">((</code><code class="n">i</code><code class="p">)</code><code class="w"> </code><code class="o">-&gt;</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="o">&lt;</code><code class="w"> </code><code class="mi">4</code><code class="p">);</code><code class="w"/>
<code class="c1">// Results in [4, 5, 3]</code><code class="w"/>

<code class="c1">// Returns items from the stream until the predicate stops matching.</code><code class="w"/>
<code class="c1">// Note that later elements matching the predicate aren't returned.</code><code class="w"/>
<code class="n">Stream</code><code class="p">.</code><code class="na">of</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="mi">3</code><code class="p">,</code><code class="w"> </code><code class="mi">4</code><code class="p">,</code><code class="w"> </code><code class="mi">3</code><code class="p">)</code><code class="w"/>
<code class="w">      </code><code class="p">.</code><code class="na">takeWhile</code><code class="p">((</code><code class="n">i</code><code class="p">)</code><code class="w"> </code><code class="o">-&gt;</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="o">&lt;</code><code class="w"> </code><code class="mi">4</code><code class="p">);</code><code class="w"/>
<code class="c1">// Results in [1, 2, 3]</code><code class="w"/>

<code class="c1">// Skips the first N items in the stream</code><code class="w"/>
<code class="n">Stream</code><code class="p">.</code><code class="na">of</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="mi">3</code><code class="p">,</code><code class="w"> </code><code class="mi">4</code><code class="p">,</code><code class="w"> </code><code class="mi">5</code><code class="p">)</code><code class="w"/>
<code class="w">      </code><code class="p">.</code><code class="na">skip</code><code class="p">(</code><code class="mi">2</code><code class="p">);</code><code class="w"/>
<code class="c1">// Results in [3, 4, 5]</code><code class="w"/>

<code class="c1">// Limits items taken from stream to an exact value</code><code class="w"/>
<code class="c1">// Useful with infinite streams to set boundaries</code><code class="w"/>
<code class="n">Stream</code><code class="p">.</code><code class="na">of</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="mi">3</code><code class="p">,</code><code class="w"> </code><code class="mi">4</code><code class="p">,</code><code class="w"> </code><code class="mi">5</code><code class="p">)</code><code class="w"/>
<code class="w">      </code><code class="p">.</code><code class="na">limit</code><code class="p">(</code><code class="mi">3</code><code class="p">);</code><code class="w"/>
<code class="c1">// Results in [1, 2, 3]</code><code class="w"/></pre>
</div></section>
<section data-pdf-bookmark="Matching in streams" data-type="sect3"><div class="sect3" id="idm45927720677616">
<h3>Matching in streams</h3>
<p><a data-primary="Java Streams" data-secondary="matching" data-type="indexterm" id="idm45927720676608"/>Another typical operation is to ask questions of an entire stream of elements,
such as whether all (or none) match a given predicate, or alternatively if
there’s any single element that matches:</p>
<pre data-code-language="java" data-type="programlisting"><code class="c1">// Are all the items odd?</code><code class="w"/>
<code class="n">Stream</code><code class="p">.</code><code class="na">of</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">3</code><code class="p">,</code><code class="w"> </code><code class="mi">5</code><code class="p">)</code><code class="w"/>
<code class="w">      </code><code class="p">.</code><code class="na">allMatch</code><code class="p">((</code><code class="n">i</code><code class="p">)</code><code class="w"> </code><code class="o">-&gt;</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="o">%</code><code class="w"> </code><code class="mi">2</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="mi">1</code><code class="p">);</code><code class="w"/>
<code class="c1">// Returns true</code><code class="w"/>

<code class="c1">// Are none of the items even?</code><code class="w"/>
<code class="n">Stream</code><code class="p">.</code><code class="na">of</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">3</code><code class="p">,</code><code class="w"> </code><code class="mi">5</code><code class="p">)</code><code class="w"/>
<code class="w">      </code><code class="p">.</code><code class="na">noneMatch</code><code class="p">((</code><code class="n">i</code><code class="p">)</code><code class="w"> </code><code class="o">-&gt;</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="o">%</code><code class="w"> </code><code class="mi">2</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="mi">0</code><code class="p">);</code><code class="w"/>
<code class="c1">// Returns true</code><code class="w"/>

<code class="c1">// Is at least one item even?</code><code class="w"/>
<code class="n">Stream</code><code class="p">.</code><code class="na">of</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">3</code><code class="p">,</code><code class="w"> </code><code class="mi">5</code><code class="p">,</code><code class="w"> </code><code class="mi">6</code><code class="p">)</code><code class="w"/>
<code class="w">      </code><code class="p">.</code><code class="na">anyMatch</code><code class="p">((</code><code class="n">i</code><code class="p">)</code><code class="w"> </code><code class="o">-&gt;</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="o">%</code><code class="w"> </code><code class="mi">2</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="mi">0</code><code class="p">);</code><code class="w"/>
<code class="c1">// Returns true</code><code class="w"/></pre>
</div></section>
<section data-pdf-bookmark="Flattening" data-type="sect3"><div class="sect3" id="idm45927720770560">
<h3>Flattening</h3>
<p><a data-primary="flattening" data-type="indexterm" id="idm45927720632560"/><a data-primary="Java Streams" data-secondary="flattening" data-type="indexterm" id="idm45927720631856"/>Once we’ve started down the path of modeling our data as streams, it’s not
unusual to find yet another layer of streams beneath. For instance, if we’re
processing multiple lines of text and wanted to gather the set of words
from the entire block, we might reach first for code like this:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">var</code><code class="w"> </code><code class="n">lines</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Stream</code><code class="p">.</code><code class="na">of</code><code class="p">(</code><code class="w"/>
<code class="w">    </code><code class="s">"For Brutus is an honourable man"</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="s">"Give me your hands if we be friends and Robin shall restore amends"</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="s">"Misery acquaints a man with strange bedfellows"</code><code class="p">);</code><code class="w"/>

<code class="n">lines</code><code class="p">.</code><code class="na">map</code><code class="p">((</code><code class="n">s</code><code class="p">)</code><code class="w"> </code><code class="o">-&gt;</code><code class="w"> </code><code class="n">s</code><code class="p">.</code><code class="na">split</code><code class="p">(</code><code class="s">" +"</code><code class="p">));</code><code class="w"/>
<code class="c1">// Returns Stream.of(new String[] { "For", "Brutus",...},</code><code class="w"/>
<code class="c1">//                   new String[] { "Give", "me", "your", ... },</code><code class="w"/>
<code class="c1">//                   new String[] { "Misery", "acquaints", "a", ... },</code><code class="w"/></pre>
<p>This isn’t quite the plain word list we’re after, though. We have an extra
layer of nesting, a <code>Stream&lt;String[]&gt;</code> instead of <code>Stream&lt;String&gt;</code>.</p>
<p><a data-primary="flatMap()" data-type="indexterm" id="idm45927720451040"/>The <code>flatMap()</code> method is designed for exactly these situations. For each
element in our original stream, the lambda provided to <code>flatMap()</code> returns not an
individual value but another <code>Stream</code>. Then <code>flatMap()</code> gathers those multiple
streams and joins them, flattening to a single stream of the contained type.</p>
<p>In our example <code>split()</code> gives us arrays, which we can trivially convert to
streams. From there, <code>flatMap()</code> will do the work of turning those multiple
streams into the single stream of words we were after:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">lines</code><code class="p">.</code><code class="na">flatMap</code><code class="p">((</code><code class="n">s</code><code class="p">)</code><code class="w"> </code><code class="o">-&gt;</code><code class="w"> </code><code class="n">Arrays</code><code class="p">.</code><code class="na">stream</code><code class="p">(</code><code class="n">s</code><code class="p">.</code><code class="na">split</code><code class="p">(</code><code class="s">" +"</code><code class="p">)));</code><code class="w"/>
<code class="c1">// Returns Stream.of("For", "Brutus", "is", "an", ...)</code><code class="w"/></pre>
</div></section>
<section data-pdf-bookmark="From Streams to Collections" data-type="sect3"><div class="sect3" id="idm45927720396096">
<h3>From Streams to Collections</h3>
<p><a data-primary="Java Streams" data-secondary="transforming to nonstream collection" data-type="indexterm" id="idm45927720424640"/>Defining a separate <code>Stream</code> interface was a pragmatic way to enable newer
styles of development with Java while not breaking existing code. However,
sometimes you still need the standard Java Collections, whether to pass to
another API or for functionality that isn’t present in streams. For the most
common cases of returning a simple <code>List</code> or array of elements, the methods are
provided directly on the <code>Stream</code> interface:</p>
<pre data-code-language="java" data-type="programlisting"><code class="c1">// Immutable list returned</code><code class="w"/>
<code class="n">List</code><code class="o">&lt;</code><code class="n">Integer</code><code class="o">&gt;</code><code class="w"> </code><code class="n">list</code><code class="w"> </code><code class="o">=</code><code class="w"/>
<code class="w">    </code><code class="n">Stream</code><code class="p">.</code><code class="na">of</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="mi">3</code><code class="p">,</code><code class="w"> </code><code class="mi">4</code><code class="p">,</code><code class="w"> </code><code class="mi">5</code><code class="p">).</code><code class="na">toList</code><code class="p">();</code><code class="w"/>

<code class="c1">// Note the return type is `Object[]`</code><code class="w"/>
<code class="n">Object</code><code class="o">[]</code><code class="w"> </code><code class="n">array</code><code class="w"> </code><code class="o">=</code><code class="w"/>
<code class="w">    </code><code class="n">Stream</code><code class="p">.</code><code class="na">of</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="mi">3</code><code class="p">,</code><code class="w"> </code><code class="mi">4</code><code class="p">,</code><code class="w"> </code><code class="mi">5</code><code class="p">).</code><code class="na">toArray</code><code class="p">();</code><code class="w"/></pre>
<p><a data-primary="collect()" data-type="indexterm" id="idm45927720322048"/>Transforming a stream into a nonstream collection or other object is primarily
performed through the <code>collect()</code> method. This method receives an instance of
the <code>Collector</code> interface, allowing for a world of possible ways to gather up
our stream results without adding to the <code>Stream</code> interface itself.</p>
<p>Standard implementations for a variety of collectors are available on the
<code>Collectors</code> class as static methods. For instance, we can turn our stream into
any of our normal collection types:</p>
<pre data-code-language="java" data-type="programlisting"><code class="c1">// In earlier versions of Java, Stream#toList() didn't exist</code><code class="w"/>
<code class="c1">// This was the commonly used approach so you'll still see it often</code><code class="w"/>
<code class="n">List</code><code class="o">&lt;</code><code class="n">Integer</code><code class="o">&gt;</code><code class="w"> </code><code class="n">list</code><code class="w"> </code><code class="o">=</code><code class="w"/>
<code class="w">    </code><code class="n">Stream</code><code class="p">.</code><code class="na">of</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code><code class="mi">2</code><code class="p">,</code><code class="mi">3</code><code class="p">,</code><code class="mi">4</code><code class="p">,</code><code class="mi">5</code><code class="p">)</code><code class="w"/>
<code class="w">          </code><code class="p">.</code><code class="na">collect</code><code class="p">(</code><code class="n">Collectors</code><code class="p">.</code><code class="na">toList</code><code class="p">());</code><code class="w"/>

<code class="c1">// Create a standard Set (no duplicates)</code><code class="w"/>
<code class="n">Set</code><code class="o">&lt;</code><code class="n">Integer</code><code class="o">&gt;</code><code class="w"> </code><code class="n">set</code><code class="w"> </code><code class="o">=</code><code class="w"/>
<code class="w">    </code><code class="n">Stream</code><code class="p">.</code><code class="na">of</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code><code class="mi">2</code><code class="p">,</code><code class="mi">3</code><code class="p">,</code><code class="mi">4</code><code class="p">,</code><code class="mi">5</code><code class="p">)</code><code class="w"/>
<code class="w">          </code><code class="p">.</code><code class="na">collect</code><code class="p">(</code><code class="n">Collectors</code><code class="p">.</code><code class="na">toSet</code><code class="p">());</code><code class="w"/>

<code class="c1">// For Collection types that don't have a specific method, we can</code><code class="w"/>
<code class="c1">// use toCollection with a function that creates our empty instance</code><code class="w"/>
<code class="c1">// Each item will be added to that collection</code><code class="w"/>
<code class="n">TreeSet</code><code class="o">&lt;</code><code class="n">Integer</code><code class="o">&gt;</code><code class="w"> </code><code class="n">collection</code><code class="w"> </code><code class="o">=</code><code class="w"/>
<code class="w">    </code><code class="n">Stream</code><code class="p">.</code><code class="na">of</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code><code class="mi">2</code><code class="p">,</code><code class="mi">3</code><code class="p">,</code><code class="mi">4</code><code class="p">,</code><code class="mi">5</code><code class="p">)</code><code class="w"/>
<code class="w">          </code><code class="p">.</code><code class="na">collect</code><code class="p">(</code><code class="n">Collectors</code><code class="p">.</code><code class="na">toCollection</code><code class="p">(</code><code class="n">TreeSet</code><code class="p">::</code><code class="k">new</code><code class="p">));</code><code class="w"/>

<code class="c1">// When creating maps we must provide two functions</code><code class="w"/>
<code class="c1">// The first constructs the key for each element, the second the value</code><code class="w"/>
<code class="c1">// Here, each int is its own key and the value is its toString()</code><code class="w"/>
<code class="n">Map</code><code class="o">&lt;</code><code class="n">Integer</code><code class="p">,</code><code class="w"> </code><code class="n">String</code><code class="o">&gt;</code><code class="w"> </code><code class="n">map</code><code class="w"> </code><code class="o">=</code><code class="w"/>
<code class="w">    </code><code class="n">Stream</code><code class="p">.</code><code class="na">of</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code><code class="mi">2</code><code class="p">,</code><code class="mi">3</code><code class="p">,</code><code class="mi">4</code><code class="p">,</code><code class="mi">5</code><code class="p">)</code><code class="w"/>
<code class="w">          </code><code class="p">.</code><code class="na">collect</code><code class="p">(</code><code class="n">Collectors</code><code class="p">.</code><code class="na">toMap</code><code class="p">(</code><code class="w"/>
<code class="w">                      </code><code class="p">(</code><code class="n">i</code><code class="p">)</code><code class="w"> </code><code class="o">-&gt;</code><code class="w"> </code><code class="n">i</code><code class="p">,</code><code class="w"/>
<code class="w">                      </code><code class="n">Object</code><code class="p">::</code><code class="n">toString</code><code class="p">));</code><code class="w"/></pre>
<p>Unlike <code>Stream#toList()</code>, all of these options return a modifiable version of
their collection type. <code>Collectors</code> also provides specific methods if you want
to return an unmodifiable or immutable version. They follow a naming convention
<code>toUnmodifiableX()</code> where <code>X</code> is the collection type as seen above.</p>
<p>A final variation on gathering collections is when you want to group the
elements by some property. In this example, we want to group the
numbers by their first digit:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">Map</code><code class="o">&lt;</code><code class="n">Character</code><code class="p">,</code><code class="w"> </code><code class="n">List</code><code class="o">&lt;</code><code class="n">Integer</code><code class="o">&gt;&gt;</code><code class="w"> </code><code class="n">grouped</code><code class="w"> </code><code class="o">=</code><code class="w"/>
<code class="w">        </code><code class="n">Stream</code><code class="p">.</code><code class="na">of</code><code class="p">(</code><code class="mi">10</code><code class="p">,</code><code class="w"> </code><code class="mi">11</code><code class="p">,</code><code class="w"> </code><code class="mi">12</code><code class="p">,</code><code class="w"> </code><code class="mi">20</code><code class="p">,</code><code class="w"> </code><code class="mi">30</code><code class="p">)</code><code class="w"/>
<code class="w">                </code><code class="p">.</code><code class="na">collect</code><code class="p">(</code><code class="n">Collectors</code><code class="p">.</code><code class="na">groupingBy</code><code class="p">((</code><code class="n">i</code><code class="p">)</code><code class="w"> </code><code class="o">-&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">                    </code><code class="k">return</code><code class="w"> </code><code class="n">i</code><code class="p">.</code><code class="na">toString</code><code class="p">().</code><code class="na">charAt</code><code class="p">(</code><code class="mi">0</code><code class="p">);</code><code class="w"/>
<code class="w">                </code><code class="p">}));</code><code class="w"/>
<code class="c1">// Returns map with {"1"=[10, 11, 12], "2"=[20], "3"=[30]}</code><code class="w"/></pre>
</div></section>
<section data-pdf-bookmark="From Streams to values" data-type="sect3"><div class="sect3" id="idm45927720196128">
<h3>From Streams to values</h3>
<p><a data-primary="Java Streams" data-secondary="transforming to values" data-type="indexterm" id="idm45927720021616"/><a data-primary="values, transforming streams to" data-type="indexterm" id="idm45927720020640"/>We don’t always want to retrieve collections from our streams—sometimes we need
a single value, much like the <code>reduce()</code> method gave us.</p>
<p><code>Stream</code> has a few built-in methods for the most common values we might want
from our stream:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">var</code><code class="w"> </code><code class="n">count</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Stream</code><code class="p">.</code><code class="na">of</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code><code class="mi">2</code><code class="p">,</code><code class="mi">3</code><code class="p">).</code><code class="na">count</code><code class="p">();</code><code class="w"/>
<code class="kd">var</code><code class="w"> </code><code class="n">max</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Stream</code><code class="p">.</code><code class="na">of</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code><code class="mi">2</code><code class="p">,</code><code class="mi">3</code><code class="p">).</code><code class="na">max</code><code class="p">(</code><code class="n">Integer</code><code class="p">::</code><code class="n">compareTo</code><code class="p">);</code><code class="w"/>
<code class="kd">var</code><code class="w"> </code><code class="n">min</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Stream</code><code class="p">.</code><code class="na">of</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code><code class="mi">2</code><code class="p">,</code><code class="mi">3</code><code class="p">).</code><code class="na">min</code><code class="p">(</code><code class="n">Integer</code><code class="p">::</code><code class="n">compareTo</code><code class="p">);</code><code class="w"/></pre>
<p>The <code>collect()</code> method isn’t limited to returning collection types either. A
wide variety of result gathering methods are available from <code>Collectors</code> to aid
in common calculations, particularly on streams of numbers. These methods all
require a function for turning the incoming item from the stream to a number,
which allows it to be easily used with objects as well as primitive values:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">var</code><code class="w"> </code><code class="n">average</code><code class="w"> </code><code class="o">=</code><code class="w"/>
<code class="w">    </code><code class="n">Stream</code><code class="p">.</code><code class="na">of</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code><code class="mi">2</code><code class="p">,</code><code class="mi">3</code><code class="p">)</code><code class="w"/>
<code class="w">          </code><code class="p">.</code><code class="na">collect</code><code class="p">(</code><code class="n">Collectors</code><code class="p">.</code><code class="na">averagingInt</code><code class="p">(</code><code class="n">Integer</code><code class="p">::</code><code class="n">intValue</code><code class="p">));</code><code class="w"/>

<code class="kd">var</code><code class="w"> </code><code class="n">sum</code><code class="w"> </code><code class="o">=</code><code class="w"/>
<code class="w">    </code><code class="n">Stream</code><code class="p">.</code><code class="na">of</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code><code class="mi">2</code><code class="p">,</code><code class="mi">3</code><code class="p">)</code><code class="w"/>
<code class="w">          </code><code class="p">.</code><code class="na">collect</code><code class="p">(</code><code class="n">Collectors</code><code class="p">.</code><code class="na">summingInt</code><code class="p">(</code><code class="n">Integer</code><code class="p">::</code><code class="n">intValue</code><code class="p">));</code><code class="w"/>

<code class="kd">var</code><code class="w"> </code><code class="n">summary</code><code class="w"> </code><code class="o">=</code><code class="w"/>
<code class="w">    </code><code class="n">Stream</code><code class="p">.</code><code class="na">of</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code><code class="mi">2</code><code class="p">,</code><code class="mi">3</code><code class="p">)</code><code class="w"/>
<code class="w">          </code><code class="p">.</code><code class="na">collect</code><code class="p">(</code><code class="n">Collectors</code><code class="p">.</code><code class="na">summarizingInt</code><code class="p">(</code><code class="n">Integer</code><code class="p">::</code><code class="n">intValue</code><code class="p">));</code><code class="w"/>
<code class="c1">// IntSummaryStatistics{count=3, sum=6, min=1, average=2.0, max=3}</code><code class="w"/></pre>
<p>Similar methods are available for long and double types in addition to integers.</p>
<p>A final way of getting a result from a stream helps us with strings. A
classic issue is turning a series of smaller strings into one larger delimited
string. Streams make this quite simple.</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">var</code><code class="w"> </code><code class="n">words</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Stream</code><code class="p">.</code><code class="na">of</code><code class="p">(</code><code class="s">"This"</code><code class="p">,</code><code class="w"> </code><code class="s">"is"</code><code class="p">,</code><code class="w"> </code><code class="s">"some"</code><code class="p">,</code><code class="w"> </code><code class="s">"text"</code><code class="p">);</code><code class="w"/>
<code class="kd">var</code><code class="w"> </code><code class="n">csv</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">words</code><code class="p">.</code><code class="na">collect</code><code class="p">(</code><code class="n">Collectors</code><code class="p">.</code><code class="na">joining</code><code class="p">(</code><code class="s">", "</code><code class="p">));</code><code class="w"/>
<code class="c1">// Returns string "This, is, some, text"</code><code class="w"/></pre>
</div></section>
<section data-pdf-bookmark="Streams utility default methods" data-type="sect3"><div class="sect3" id="idm45927719721392">
<h3>Streams utility default methods</h3>
<p><a data-primary="Java Streams" data-secondary="default methods" data-type="indexterm" id="idm45927719681808"/>Java Streams took the opportunity to introduce a number of new methods to
the Java Collections libraries. Using default methods, it was possible to add
new methods to the Collections without breaking backward compatibility.</p>
<p><a data-primary="scaffold methods" data-type="indexterm" id="idm45927719680480"/>Some of these methods are <em>scaffold methods</em> for
creating Streams from our existing collections.
These include methods such as <code>Collection::stream</code>,
<code>Collection::parallelStream</code>, and <code>Collection::spliterator</code> (which has
specialized forms <code>List::spliterator</code> and <code>Set::spliterator</code>).</p>
<p>Other methods provide shortcuts to functionality that existed elsewhere in previous versions. For instance, <code>List::sort</code> method essentially delegates to
the more cumbersome version already available on the <code>Collections</code> class:</p>
<pre data-code-language="java" data-type="programlisting"><code class="c1">// Essentially just forwards to the helper method in Collections</code><code class="w"/>
<code class="kd">public</code><code class="w"> </code><code class="k">default</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">sort</code><code class="p">(</code><code class="n">Comparator</code><code class="o">&lt;?</code><code class="w"> </code><code class="kd">super</code><code class="w"> </code><code class="n">E</code><code class="o">&gt;</code><code class="w"> </code><code class="n">c</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">Collections</code><code class="p">.</code><code class="o">&lt;</code><code class="n">E</code><code class="o">&gt;</code><code class="n">sort</code><code class="p">(</code><code class="k">this</code><code class="p">,</code><code class="w"> </code><code class="n">c</code><code class="p">);</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>The remaining methods provide additional functional techniques using the
interfaces of <code>java.util.function</code>:</p>
<dl>
<dt><code>Collection::removeIf</code></dt>
<dd>
<p>This method takes a <code>Predicate</code> and iterates internally over the
collection, removing any elements that satisfy the predicate object.</p>
</dd>
<dt><code>Map::forEach</code></dt>
<dd>
<p>The single argument to this method is a lambda expression that takes
two arguments (one of the key’s type and one of the value’s type) and
returns <code>void</code>. This is converted to an instance of <code>BiConsumer</code> and applied to each key/value pair in the map.</p>
</dd>
<dt><code>Map::computeIfAbsent</code></dt>
<dd>
<p>This takes a key and a lambda expression that maps the key type to the
value type. If the specified key (first parameter) is not present in
the map, then it computes a default value by using the lambda expression
and puts it in the map.<a data-startref="ix_ch08-asciidoc28" data-type="indexterm" id="idm45927719629936"/><a data-startref="ix_ch08-asciidoc27" data-type="indexterm" id="idm45927719629232"/></p>
</dd>
</dl>
<p>(See also <code>Map::computeIfPresent</code>, <code>Map::compute</code>, and <code>Map::merge</code>.)<a data-startref="ix_ch08-asciidoc24" data-type="indexterm" id="idm45927719626832"/><a data-startref="ix_ch08-asciidoc23" data-type="indexterm" id="idm45927719626096"/><a data-startref="ix_ch08-asciidoc22" data-type="indexterm" id="idm45927719625424"/></p>
</div></section>
</div></section>
</div></section>
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="idm45927722162960">
<h1>Summary</h1>
<p>In this chapter, we’ve met the Java Collections libraries and seen
how to start working with Java’s implementations of fundamental and
classic data structures. We’ve met the general <code>Collection</code> interface,
as well as <code>List</code>, <code>Set</code>, and <code>Map</code>. We’ve seen the original, iterative
way of handling collections and introduced the new Java Streams style,
based on ideas from fundamental programming. In the Streams API, we’ve seen how
the new approach is more general and can express more subtle programming
concepts than the classic approach.</p>
<p>We’ve only scratched the surface—the Streams API is a fundamental shift in how Java code is written and architected.
There are inherent design limitations in how far the ideals of functional programming can be implemented in Java.
Having said that, the possibility that Streams represents “just enough functional programming” is compelling.<a data-startref="ix_ch08-asciidoc0" data-type="indexterm" id="idm45927719592160"/></p>
<p>Let’s move on. In the next chapter, we’ll continue looking at data, and
common tasks like text processing, handling numeric data, and Java 8’s
new date and time libraries.</p>
</div></section>
</div></section></div></body></html>