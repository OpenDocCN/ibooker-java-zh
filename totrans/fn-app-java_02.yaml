- en: Chapter 1\. An Introduction to Functional Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章。函数式编程简介
- en: To better understand how to incorporate a more functional programming style
    in Java, you first need to understand what it means for a language to be functional
    and what its foundational concepts are.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 要更好地理解如何在Java中加入更多函数式编程风格，首先需要理解语言被视为函数式的含义以及其基本概念。
- en: This chapter will explore the roots of functional programming needed to incorporate
    a more functional programming style into your workflow.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将探讨需要将更多函数式编程风格融入工作流程的函数式编程根源。
- en: What Makes A Language Functional?
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何谓函数式语言？
- en: Programming Paradigms — like object-oriented, functional, or procedural — are
    synthetic overall concepts that classify languages and provide ways to structure
    your programs in a specific style and use different approaches to solving problems.
    Like most paradigms, functional programming doesn’t have a single agreed-upon
    definition, and many turf wars are fought about what defines a language as *actually*
    functional. Instead of giving my own definition, I will go over different aspects
    of what makes a language functional.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 编程范式 — 如面向对象、函数式或过程化 — 是对语言进行分类并提供在特定风格中结构化程序以及使用不同方法解决问题的综合概念。像大多数范式一样，函数式编程没有一个统一的定义，人们对是否语言*实际上*是函数式进行了许多争论。与其给出我自己的定义，我将讨论构成语言函数式的不同方面。
- en: 'A language is considered functional when there’s a way to express computations
    by creating and combining abstract functions. This concept is rooted in the formal
    mathematical system *Lambda Calculus*, invented by the logician Alonzo Church
    in the 1930s.^([1](ch01.xhtml#idm45115253643376)) It’s a system to express computations
    with abstract functions and how to apply variables to them. The name “lambda calculus”
    came from the Greek letter “lambda” chosen for its symbol: <math alttext="lamda"><mi>λ</mi></math>
    .'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个语言可以通过创建和组合抽象函数来表达计算时，它被认为是函数式的。这个概念源于20世纪30年代逻辑学家阿隆佐·丘奇发明的形式化数学系统*Lambda
    Calculus*。^([1](ch01.xhtml#idm45115253643376)) 它是一个用抽象函数表达计算及如何将变量应用于它们的系统。名称“lambda
    calculus”选自希腊字母“lambda”，因其符号而选择：<math alttext="lamda"><mi>λ</mi></math> 。
- en: 'As an object-oriented developer, you are used to *imperative* programming:
    by defining a series of statements, you are telling the computer *what* to do
    to accomplish a particular task with a sequence of *statements*.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 作为面向对象开发者，你习惯于*命令式*编程：通过定义一系列语句，告诉计算机*如何*通过一系列*语句*完成特定任务。
- en: For a programming language to be considered functional, a *declarative* style
    to express the logic of computations without describing their actual control flow
    needs to be achievable. In such a declarative programming style, you describe
    the outcome and *how* your program should work with *expressions*, not *what*
    it should do with *statements*.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 编程语言要被认为是函数式的，需要能够以*声明式*风格表达计算逻辑，而不描述其实际的控制流。在这样的声明式编程风格中，你描述的是结果以及*程序*应该如何工作，而不是*语句*应该做什么。
- en: 'In Java, an *expression* is a sequence of operators, operands, and method invocations
    that define a computation and evaluate to a single value:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，*表达式*是由操作符、操作数和方法调用组成的序列，定义了一个计算并且求值为单一值：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Statements*, on the other hand, are actions taken by your code, to form a
    complete unit of execution, including method invocations without a return value.
    Any time you assign or change the value of a variable, call a `void` method, or
    use control-flow constructs like `if`/`else`, you’re using statements. Usually,
    they’re intermixed with expressions:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*语句*，另一方面，是代码执行的动作，形成一个完整的执行单元，包括没有返回值的方法调用。每当你分配或更改变量的值，调用一个`void`方法，或使用像`if`/`else`这样的控制流构造时，你正在使用语句。通常它们与表达式混合使用：'
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[![1](assets/1.png)](#co_an_introduction_to__span_class__keep_together__functional_programming__span__CO1-1)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_an_introduction_to__span_class__keep_together__functional_programming__span__CO1-1)'
- en: Assigns an initial value to a variable, introducing state into the program.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 将初始值分配给变量，引入状态到程序中。
- en: '[![2](assets/2.png)](#co_an_introduction_to__span_class__keep_together__functional_programming__span__CO1-2)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_an_introduction_to__span_class__keep_together__functional_programming__span__CO1-2)'
- en: The function call `findTreasure(6)` is a functional expression, but the assignment
    of `newTreasuresFound` is a statement.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 函数调用`findTreasure(6)`是一个函数式表达式，但`newTreasuresFound`的赋值则是一个语句。
- en: '[![3](assets/3.png)](#co_an_introduction_to__span_class__keep_together__functional_programming__span__CO1-3)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_an_introduction_to__span_class__keep_together__functional_programming__span__CO1-3)'
- en: The reassignment of `totalTreasure` is a statement using the result of the expression
    on the right-hand side.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`totalTreasure` 的重新分配是使用右侧表达式的结果作为语句。'
- en: '[![4](assets/4.png)](#co_an_introduction_to__span_class__keep_together__functional_programming__span__CO1-4)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_an_introduction_to__span_class__keep_together__functional_programming__span__CO1-4)'
- en: The control-flow statement `if`/`else` conveys what action should be taken based
    on the result of the expression `(treasureCounter > 10)`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 控制流语句`if`/`else`根据表达式`(treasureCounter > 10)`的结果传达应采取的操作。
- en: '[![5](assets/5.png)](#co_an_introduction_to__span_class__keep_together__functional_programming__span__CO1-5)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_an_introduction_to__span_class__keep_together__functional_programming__span__CO1-5)'
- en: Printing to `System.out` is a statement because there’s no result returned from
    the call.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 将内容打印到`System.out`是一种语句，因为调用没有返回结果。
- en: The primary distinction between expressions and statements is whether or not
    a value is returned. In a general-purpose, multi-paradigm language like Java,
    the lines between them are often up for debate and can quickly blur.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式和语句的主要区别在于是否返回值。在像 Java 这样的通用多范式语言中，它们之间的界限经常是有争议的，并且很快就会变得模糊。
- en: Functional Programming Concepts
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式编程概念
- en: Since functional programming is based primarily on abstract functions, its many
    concepts that form the paradigm can focus on “what to solve” in a declarative
    style, in contrast to the imperative “how to solve” approach.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 由于函数式编程主要基于抽象函数，其构成范式的许多概念可以以声明式风格集中于“如何解决”的方法，与命令式的“如何解决”方法形成对比。
- en: We will go through the most common and significant aspects that functional programming
    uses at its foundation. These aren’t exclusive to the functional paradigm, though.
    Many of the ideas behind them apply to other programming paradigms as well.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将深入探讨函数式编程在其基础上使用的最常见和重要的方面。尽管这些并不专属于函数范式。但这些背后的许多思想也适用于其他编程范式。
- en: Pure Functions and Referential Transparency
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 纯函数和引用透明性
- en: 'Functional programming categorizes functions into two categories: *pure* and
    *impure*.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程将函数分为两类：*纯*和*不纯*。
- en: '*Pure functions* have two elemental guarantees:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*纯函数*具有两个基本保证：'
- en: The *same* input will *always* create the same output
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*相同*的输入将*总是*生成相同的输出。'
- en: The return value of a *pure* function must solely depend on its input arguments.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*纯*函数的返回值必须完全依赖于其输入参数。'
- en: They are self-contained without any kind of side effect
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 它们是自包含的，没有任何副作用
- en: The code cannot affect the global state, like changing argument values or using
    any I/O.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 代码不能影响全局状态，比如更改参数值或使用任何 I/O。
- en: 'These two guarantees allow *pure functions* to be safe to use in any environment,
    even in a parallel fashion. The following code shows a method being a *pure function*
    that accepts an argument without affecting anything outside of its context:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个保证允许*纯函数*在任何环境中都能安全使用，甚至可以并行执行。以下代码展示了一个方法作为*纯函数*，接受参数但不会影响其上下文之外的任何东西：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Functions violating either of the two guarantees are considered *impure*. The
    following code is an example of an *impure function*, as it uses the current time
    for its logic:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 违反这两个保证的函数被认为是*不纯*的。以下代码是一个*不纯函数*的例子，因为它使用当前时间来执行其逻辑：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The signifier “pure” and “impure” are rather unfortunate names because of the
    connotation they might invoke. *Impure functions* aren’t inferior to *pure functions*
    in general. They are just used in different ways depending on the coding style
    and paradigm you want to adhere to.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 符号“纯”和“不纯”可能会因其可能激起的内涵而不太合适。*不纯函数*在一般情况下并不比*纯函数*差。它们只是根据您想要遵循的编码风格和范式而采用不同的方式使用。
- en: Another aspect of side-effect-free *expressions* or *pure functions* is their
    deterministic nature, which makes them *referentially transparent*. That means
    you can replace them with their respective evaluated result for any further invocations
    without changing the behavior of your program.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*表达式*或*纯函数*无副作用的另一个方面是它们的确定性特性，这使它们*引用透明*。这意味着您可以将它们替换为其评估结果，而不会改变程序的行为。'
- en: 'Abstract Function:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象函数：
- en: <math alttext="StartLayout 1st Row 1st Column f left-parenthesis x right-parenthesis
    2nd Column equals x asterisk x EndLayout" display="block"><mtable displaystyle="true"><mtr><mtd
    columnalign="right"><mrow><mi>f</mi> <mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <mi>x</mi> <mo>*</mo> <mi>x</mi></mrow></mtd></mtr></mtable></math>
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartLayout 1st Row 1st Column f left-parenthesis x right-parenthesis
    2nd Column equals x asterisk x EndLayout" display="block"><mtable displaystyle="true"><mtr><mtd
    columnalign="right"><mrow><mi>f</mi> <mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <mi>x</mi> <mo>*</mo> <mi>x</mi></mrow></mtd></mtr></mtable></math>
- en: 'Replacing Evaluated Expressions:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 替换评估表达式：
- en: <math alttext="StartLayout 1st Row 1st Column r e s u l t 2nd Column equals
    f left-parenthesis 5 right-parenthesis plus f left-parenthesis 5 right-parenthesis
    2nd Row 1st Column Blank 2nd Column equals 25 plus f left-parenthesis 5 right-parenthesis
    3rd Row 1st Column Blank 2nd Column equals f left-parenthesis 5 right-parenthesis
    plus f left-parenthesis 5 right-parenthesis 4th Row 1st Column Blank 2nd Column
    equals 25 plus 25 EndLayout" display="block"><mtable displaystyle="true"><mtr><mtd
    columnalign="right"><mrow><mi>r</mi> <mi>e</mi> <mi>s</mi> <mi>u</mi> <mi>l</mi>
    <mi>t</mi></mrow></mtd> <mtd columnalign="left"><mrow><mo>=</mo> <mi>f</mi> <mo>(</mo>
    <mn>5</mn> <mo>)</mo> <mo>+</mo> <mi>f</mi> <mo>(</mo> <mn>5</mn> <mo>)</mo></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><mo>=</mo> <mn>25</mn> <mo>+</mo> <mi>f</mi>
    <mo>(</mo> <mn>5</mn> <mo>)</mo></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mrow><mo>=</mo>
    <mi>f</mi> <mo>(</mo> <mn>5</mn> <mo>)</mo> <mo>+</mo> <mi>f</mi> <mo>(</mo> <mn>5</mn>
    <mo>)</mo></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mrow><mo>=</mo> <mn>25</mn>
    <mo>+</mo> <mn>25</mn></mrow></mtd></mtr></mtable></math>
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartLayout 1st Row 1st Column r e s u l t 2nd Column equals
    f left-parenthesis 5 right-parenthesis plus f left-parenthesis 5 right-parenthesis
    2nd Row 1st Column Blank 2nd Column equals 25 plus f left-parenthesis 5 right-parenthesis
    3rd Row 1st Column Blank 2nd Column equals f left-parenthesis 5 right-parenthesis
    plus f left-parenthesis 5 right-parenthesis 4th Row 1st Column Blank 2nd Column
    equals 25 plus 25 EndLayout" display="block"><mtable displaystyle="true"><mtr><mtd
    columnalign="right"><mrow><mi>r</mi> <mi>e</mi> <mi>s</mi> <mi>u</mi> <mi>l</mi>
    <mi>t</mi></mrow></mtd> <mtd columnalign="left"><mrow><mo>=</mo> <mi>f</mi> <mo>(</mo>
    <mn>5</mn> <mo>)</mo> <mo>+</mo> <mi>f</mi> <mo>(</mo> <mn>5</mn> <mo>)</mo></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><mo>=</mo> <mn>25</mn> <mo>+</mo> <mi>f</mi>
    <mo>(</mo> <mn>5</mn> <mo>)</mo></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mrow><mo>=</mo>
    <mi>f</mi> <mo>(</mo> <mn>5</mn> <mo>)</mo> <mo>+</mo> <mi>f</mi> <mo>(</mo> <mn>5</mn>
    <mo>)</mo></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mrow><mo>=</mo> <mn>25</mn>
    <mo>+</mo> <mn>25</mn></mrow></mtd></mtr></mtable></math>
- en: All these variants are equal and won’t change your program. Purity and referential
    transparency go hand-in-hand and give you a powerful tool because it’s easier
    to understand and reason with your code.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些变体是相等的，不会改变你的程序。纯度和引用透明度是相辅相成的，给你提供了一个强大的工具，因为理解和推理你的代码更容易。
- en: Immutability
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不可变性
- en: Object-oriented code is usually based around a mutable program state. Objects
    can and will usually change after their creation, using *setters*. But mutating
    data structures can create unexpected side effects. Mutability isn’t restricted
    to data structures and OOP, though. A local variable in a method might be mutable,
    too, and can lead to problems in its context as much as a changing field of an
    object.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象的代码通常基于可变的程序状态。对象可以并且通常会在创建后发生变化，使用 *setters*。但是，改变数据结构可能会产生意外的副作用。然而，可变性不仅限于数据结构和面向对象编程。方法中的局部变量也可能是可变的，并且可能会导致与对象的变化字段一样的问题。
- en: With *immutability*, data structures can no longer change after their initialization.
    By never changing, they are always consistent, side-effect free, predictable,
    and easier to reason with. Like *pure functions*, their usage is safe in concurrent
    and parallel environments without the usual issues of unsynchronized access or
    out-of-scope state changes.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 *不可变性*，数据结构在初始化后就无法再更改。通过永远不变化，它们始终一致，无副作用，可预测，并且更容易推理。与 *纯函数* 一样，在并发和并行环境中使用它们是安全的，而不会出现通常的未同步访问或超出范围状态更改的问题。
- en: If data structures never change after initialization, a program would not be
    very useful. That’s why you need to create a new and updated version containing
    the mutated state instead of changing the data structure directly.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据结构在初始化后从不改变，那么程序就不会很有用。这就是为什么你需要创建一个新的更新版本，包含了变异状态，而不是直接改变数据结构。
- en: Creating new data structures for every change can be a chore and quite inefficient
    due to copying the data every time. Many programming languages employ “structure
    sharing” to provide efficient copy mechanisms to minimize the inefficiencies of
    requiring new data structures for every change. This way, different instances
    of data structures share immutable data between them. [Chapter 4](ch04.xhtml#_02-data-structures)
    will explain in more detail why the advantages of having side-effect-free data
    structures outweigh the extra work that might be necessary.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为每个更改创建新的数据结构可能会很麻烦，而且由于每次复制数据而变得相当低效。许多编程语言采用“结构共享”来提供高效的复制机制，以最小化要求每次更改都需要新数据结构的低效性。这样，不同实例的数据结构之间共享不可变数据。[第 4 章](ch04.xhtml#_02-data-structures)将更详细地解释为什么具有无副作用的数据结构的优点胜过可能需要的额外工作。
- en: Recursion
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 递归
- en: '*Recursion* is a problem-solving technique that solves a problem by partially
    solving problems of the same form, and combining the partial results to finally
    solve the original problem. In layperson’s terms, recursive functions call themselves,
    but with a slight change in their input arguments, until they reach an end condition
    and return an actual value. [Chapter 12](ch12.xhtml#_02-recursion) will go into
    the finer details of recursion.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*递归* 是一种解决问题的技术，通过部分解决相同形式的问题，并将部分结果组合起来最终解决原始问题。简而言之，递归函数会调用自身，但其输入参数略有变化，直到达到结束条件并返回实际值。[第 12 章](ch12.xhtml#_02-recursion)将详细讨论递归的细节。'
- en: A simple example is calculating a factorial, the product of all positive integers
    less than or equal to the input parameter. Instead of calculating the value with
    an intermediate state, the function calls itself with a decremented input variable,
    as illustrated in [Figure 1-1](#_01-an-introduction_recursion_factorial).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的例子是计算阶乘，即小于或等于输入参数的所有正整数的乘积。函数不是使用中间状态计算值，而是使用递减的输入变量调用自身，如[图 1-1](#_01-an-introduction_recursion_factorial)所示。
- en: '![Calculating a factorial with recursion](assets/afaj_0101.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![使用递归计算阶乘](assets/afaj_0101.png)'
- en: Figure 1-1\. Calculating a factorial with recursion
  id: totrans-53
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1-1。使用递归计算阶乘
- en: Pure functional programming often prefers using recursion instead of loops or
    iterators. Some of them, like [Haskell](https://www.haskell.org), go a step further
    and don’t have loops like `for` or `while` at all.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数式编程通常更喜欢使用递归而不是循环或迭代器。其中一些，如[Haskell](https://www.haskell.org)，更进一步，根本没有`for`或`while`循环。
- en: The repeated function calls can be inefficient and even dangerous due to the
    risk of the stack overflowing. That’s why many functional languages utilize optimizations
    like “unrolling” recursion into loops or *tail-call optimization* to reduce the
    required stack frames. Java doesn’t support any of these optimization techniques,
    which I’ll talk more about in [Chapter 12](ch12.xhtml#_02-recursion).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 反复调用函数可能效率低下，甚至有可能由于堆栈溢出的风险而变得危险。这就是为什么许多函数式语言利用像“展开”递归成循环或*尾递归优化*之类的优化技术来减少所需的堆栈帧。Java
    不支持这些优化技术中的任何一种，我将在[第 12 章](ch12.xhtml#_02-recursion)中详细讨论。
- en: First-Class and Higher-Order Functions
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 头等和高阶函数
- en: Many of the previously discussed concepts don’t have to be available as deeply
    integrated language features to support a more functional programming style in
    your code. The concepts of first-class and higher-order functions, however, are
    absolute must-haves.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 先前讨论的许多概念不必作为深度集成的语言特性出现，以支持在代码中更加函数式的编程风格。然而，头等和高阶函数的概念是绝对必不可少的。
- en: For functions to be so-called “first-class citizens,” they must observe all
    the properties inherent to other entities of the language. They need to be assignable
    to variables and be used as arguments and return values in other functions and
    expressions.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 要使函数成为所谓的“头等公民”，它们必须遵守语言的其他实体固有的所有属性。它们需要能够分配给变量，并在其他函数和表达式中作为参数和返回值使用。
- en: '*Higher-order* functions use this *first-class* citizenship to accept functions
    as arguments or to return a function as their result, or both. This is an essential
    property for the next concept, *functional composition*.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*高阶*函数使用这种*头等公民*身份来接受函数作为参数或将函数作为它们的结果返回，或者两者兼而有之。这是下一个概念*函数组合*的重要特性。'
- en: Functional Composition
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数组合
- en: '*Pure functions* can be combined to create more complex expressions. In mathematical
    terms, this means that the two functions <math alttext="f left-parenthesis x right-parenthesis"><mrow><mi>f</mi>
    <mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></math> and <math alttext="g left-parenthesis
    x right-parenthesis"><mrow><mi>g</mi> <mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></math>
    can be combined to a function <math alttext="h left-parenthesis x right-parenthesis
    equals g left-parenthesis f left-parenthesis x right-parenthesis right-parenthesis"><mrow><mi>h</mi>
    <mo>(</mo> <mi>x</mi> <mo>)</mo> <mo>=</mo> <mi>g</mi> <mo>(</mo> <mi>f</mi> <mo>(</mo>
    <mi>x</mi> <mo>)</mo> <mo>)</mo></mrow></math> , as seen in [Figure 1-2](#_01-an-introduction_functional-composition_overview).'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*纯函数*可以组合以创建更复杂的表达式。在数学术语中，这意味着两个函数 <math alttext="f left-parenthesis x right-parenthesis"><mrow><mi>f</mi>
    <mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></math> 和 <math alttext="g left-parenthesis
    x right-parenthesis"><mrow><mi>g</mi> <mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></math>
    可以组合成一个函数 <math alttext="h left-parenthesis x right-parenthesis equals g left-parenthesis
    f left-parenthesis x right-parenthesis right-parenthesis"><mrow><mi>h</mi> <mo>(</mo>
    <mi>x</mi> <mo>)</mo> <mo>=</mo> <mi>g</mi> <mo>(</mo> <mi>f</mi> <mo>(</mo> <mi>x</mi>
    <mo>)</mo> <mo>)</mo></mrow></math> ，如[图 1-2](#_01-an-introduction_functional-composition_overview)所示。'
- en: '![Composing function f and g to a new function h](assets/afaj_0102.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![将函数 f 和 g 组合成新函数 h](assets/afaj_0102.png)'
- en: Figure 1-2\. Composing functions
  id: totrans-63
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1-2\. 组合函数
- en: This way, functions can be small and on point as possible, and therefore, easier
    to reuse. To create a more complex and complete task, such functions can be quickly
    composed as needed.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，函数可以尽可能地小而精确，因此更易于重用。为了创建更复杂和完整的任务，此类函数可以根据需要快速组合。
- en: Currying
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 柯里化
- en: Function *currying* means converting a function from taking multiple arguments
    into a sequence of functions that each take only a single argument.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 函数*柯里化*意味着将一个接受多个参数的函数转换为一系列每个只接受单个参数的函数。
- en: Note
  id: totrans-67
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'The currying technique borrows its name from the mathematician and logician
    Haskell Brook Curry (1900-1982). He’s not only the namesake of the functional
    technique called *currying*, he also has three different programming languages
    named after him: [Haskell](https://www.haskell.org/), [Brook](http://graphics.stanford.edu/projects/brookgpu/),
    and [Curry](http://curry-lang.org/).'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 柯里化技术借用了数学家和逻辑学家 Haskell Brook Curry（1900-1982）的名字。他不仅是被称为*柯里化*的函数技术的名字来源，还有三种不同的编程语言以他的名字命名：[Haskell](https://www.haskell.org/)、[Brook](http://graphics.stanford.edu/projects/brookgpu/)
    和 [Curry](http://curry-lang.org/)。
- en: 'Imagine a function that accepts three arguments. It can be curried as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个接受三个参数的函数。可以如下柯里化它：
- en: 'Initial function:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 初始函数：
- en: <math alttext="StartLayout 1st Row 1st Column x 2nd Column equals f left-parenthesis
    a comma b comma c right-parenthesis EndLayout" display="block"><mtable displaystyle="true"><mtr><mtd
    columnalign="right"><mi>x</mi></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <mi>f</mi> <mo>(</mo> <mi>a</mi> <mo>,</mo> <mi>b</mi> <mo>,</mo> <mi>c</mi> <mo>)</mo></mrow></mtd></mtr></mtable></math>
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartLayout 1st Row 1st Column x 2nd Column equals f left-parenthesis
    a comma b comma c right-parenthesis EndLayout" display="block"><mtable displaystyle="true"><mtr><mtd
    columnalign="right"><mi>x</mi></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <mi>f</mi> <mo>(</mo> <mi>a</mi> <mo>,</mo> <mi>b</mi> <mo>,</mo> <mi>c</mi> <mo>)</mo></mrow></mtd></mtr></mtable></math>
- en: 'Curried functions:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 柯里化函数：
- en: <math alttext="StartLayout 1st Row 1st Column h 2nd Column equals g left-parenthesis
    a right-parenthesis 2nd Row 1st Column i 2nd Column equals h left-parenthesis
    b right-parenthesis 3rd Row 1st Column x 2nd Column equals i left-parenthesis
    c right-parenthesis EndLayout" display="block"><mtable displaystyle="true"><mtr><mtd
    columnalign="right"><mi>h</mi></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <mi>g</mi> <mo>(</mo> <mi>a</mi> <mo>)</mo></mrow></mtd></mtr> <mtr><mtd columnalign="right"><mi>i</mi></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <mi>h</mi> <mo>(</mo> <mi>b</mi> <mo>)</mo></mrow></mtd></mtr>
    <mtr><mtd columnalign="right"><mi>x</mi></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <mi>i</mi> <mo>(</mo> <mi>c</mi> <mo>)</mo></mrow></mtd></mtr></mtable></math>
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartLayout 1st Row 1st Column h 2nd Column equals g left-parenthesis
    a right-parenthesis 2nd Row 1st Column i 2nd Column equals h left-parenthesis
    b right-parenthesis 3rd Row 1st Column x 2nd Column equals i left-parenthesis
    c right-parenthesis EndLayout" display="block"><mtable displaystyle="true"><mtr><mtd
    columnalign="right"><mi>h</mi></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <mi>g</mi> <mo>(</mo> <mi>a</mi> <mo>)</mo></mrow></mtd></mtr> <mtr><mtd columnalign="right"><mi>i</mi></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <mi>h</mi> <mo>(</mo> <mi>b</mi> <mo>)</mo></mrow></mtd></mtr>
    <mtr><mtd columnalign="right"><mi>x</mi></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <mi>i</mi> <mo>(</mo> <mi>c</mi> <mo>)</mo></mrow></mtd></mtr></mtable></math>
- en: 'Sequence of curried functions:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一系列柯里化函数：
- en: <math alttext="StartLayout 1st Row 1st Column x 2nd Column equals g left-parenthesis
    a right-parenthesis left-parenthesis b right-parenthesis left-parenthesis c right-parenthesis
    EndLayout" display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mi>x</mi></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <mi>g</mi> <mo>(</mo> <mi>a</mi> <mo>)</mo>
    <mo>(</mo> <mi>b</mi> <mo>)</mo> <mo>(</mo> <mi>c</mi> <mo>)</mo></mrow></mtd></mtr></mtable></math>
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartLayout 1st Row 1st Column x 2nd Column equals g left-parenthesis
    a right-parenthesis left-parenthesis b right-parenthesis left-parenthesis c right-parenthesis
    EndLayout" display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mi>x</mi></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <mi>g</mi> <mo>(</mo> <mi>a</mi> <mo>)</mo>
    <mo>(</mo> <mi>b</mi> <mo>)</mo> <mo>(</mo> <mi>c</mi> <mo>)</mo></mrow></mtd></mtr></mtable></math>
- en: Some functional programming languages reflect the general concept of *currying*
    in their type definitions like Haskell as follows.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一些功能性编程语言在其类型定义中反映了*柯里化*的一般概念，如Haskell如下所示。
- en: '[PRE4]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[![1](assets/1.png)](#co_an_introduction_to__span_class__keep_together__functional_programming__span__CO2-1)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_an_introduction_to__span_class__keep_together__functional_programming__span__CO2-1)'
- en: The function `add` is declared to accept an `Integer` and returns another function
    accepting another `Integer`, which itself returns an `Integer`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`add`被声明为接受一个`Integer`并返回另一个接受另一个`Integer`的函数，其本身返回一个`Integer`。
- en: '[![2](assets/2.png)](#co_an_introduction_to__span_class__keep_together__functional_programming__span__CO2-2)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_an_introduction_to__span_class__keep_together__functional_programming__span__CO2-2)'
- en: 'The actual definition reflects the declaration: two input parameters and the
    result of the body as return value.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的定义反映了声明：两个输入参数和主体的结果作为返回值。
- en: At first glance, the concept can feel weird and foreign to an OO or imperative
    developer, like many principles based on mathematics. Still, it perfectly conveys
    how a function with more than one argument is representable as a function of functions,
    and that’s an essential realization to support the next concept.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，这个概念可能对面向对象或命令式开发者感觉奇怪和陌生，就像许多基于数学的原则一样。但它完美地传达了一个多参数函数如何可以表示为函数的函数，这是支持下一个概念的重要认识。
- en: Partial Function Application
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部分函数应用
- en: '*Partial function application* is the process of creating a new function by
    providing not all arguments to an existing one. It’s often conflated with *currying*,
    but a call to a partially applied function returns a result and not another function
    of a currying chain.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*部分函数应用*是通过为现有函数提供不完整的参数来创建新函数的过程。它经常与*柯里化*混淆，但对部分应用的函数的调用返回一个结果，而不是柯里化链中的另一个函数。'
- en: 'The currying example from the previous section can be partially applied to
    create a more specific function:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 前一节的柯里化示例可以部分应用以创建更具体的函数：
- en: '[PRE5]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[![1](assets/1.png)](#co_an_introduction_to__span_class__keep_together__functional_programming__span__CO3-1)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_an_introduction_to__span_class__keep_together__functional_programming__span__CO3-1)'
- en: The `add` function is declared as before, accepting two arguments.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`add`与之前一样声明，接受两个参数。
- en: '[![2](assets/2.png)](#co_an_introduction_to__span_class__keep_together__functional_programming__span__CO3-2)'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_an_introduction_to__span_class__keep_together__functional_programming__span__CO3-2)'
- en: Calling the function `add` with only a value for the first argument `x` return
    as partially applied function of type `Integer → Integer`, which is bound to the
    name `add3`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 调用函数`add`仅为第一个参数`x`的值返回类型为`Integer → Integer`的部分应用函数，其绑定到名称`add3`。
- en: '[![3](assets/3.png)](#co_an_introduction_to__span_class__keep_together__functional_programming__span__CO3-3)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_an_introduction_to__span_class__keep_together__functional_programming__span__CO3-3)'
- en: The call `add3 5` is equivalent to `add 3 5`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`add3 5`等同于`add 3 5`。
- en: With partial application, you can create new, less verbose functions on the
    fly or specialized functions from a more generic pool to match your code’s current
    context and requirements.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 通过部分应用，您可以即时创建新的更简洁的函数或从更通用的池中创建专门的函数以匹配代码当前的上下文和要求。
- en: Lazy Evaluation
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 惰性求值
- en: '*Lazy evaluation* is an evaluation strategy that delays the evaluation of an
    expression until its result is literally needed by separating the concerns of
    how you create an expression from whether or when you actually use it. It’s also
    another concept not rooted in or restricted to functional programming but a must-have
    for using other functional concepts and techniques.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*惰性求值*是一种评估策略，它延迟对表达式的评估，直到其结果确实被需要，通过将创建表达式的方式与实际使用它的时间或方式分开。这也是另一个不仅根植于功能性编程，而且是使用其他功能性概念和技术的必备概念。'
- en: Many non-functional languages, including Java, are primarily *strict* — or *eagerly* — evaluated,
    meaning an expression evaluates immediately. Those languages still have a few
    lazy constructs, like control-flow statements such as `if`-`else`-statements or
    loops, or logical short-circuit operators. Immediately evaluating both branches
    of an `if`-`else` construct or all possible loop iterations wouldn’t make much
    sense, would it? So instead, only the branches and iterations absolutely required
    are evaluated during runtime.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Laziness enables certain constructs that aren’t possible otherwise, like infinite
    data structures or more efficient implementations of some algorithms. It also
    works very well with *referential transparency*. If there is no difference between
    an expression and its result, you can delay the evaluation without consequences
    to the result. Delayed evaluation might still impact the program’s performance
    because you might not know the precise time of evaluation.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 11](ch11.xhtml#_02-lazy-evaluation) I will discuss how to achieve
    a lazy approach in Java with the tools at your disposal, and how to create your
    own.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of Functional Programming
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After going through the most common and essential concepts of functional programming,
    you can see how they are reflected in the advantages that a more functional approach
    provides:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Simplicity
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Without mutable state and side effects, your functions tend to be smaller, doing
    “just what they are supposed to do.”
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Consistency
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Immutable data structures are reliable and consistent. No more worries about
    unexpected or unintended program state.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: (Mathematical) Correctness
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Simpler code with consistent data structures will automatically lead to “more
    correct” code with a smaller bug surface. The “purer” your code, the easier it
    will be to reason with, leading to simpler debugging and testing.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Safer Concurrency
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Concurrency is one of the most challenging tasks to do right in “classical”
    Java. Functional concepts allow you to eliminate many headaches and gain safer
    parallel processing (almost) for free.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Modularity
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Small and independent functions lead to simpler reusability and modularity.
    Combined with functional composition and partial application, you have powerful
    tools to build more complex tasks out of these smaller parts easily.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Testability
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Many of the functional concepts, like pure functions, referential transparency,
    immutability, and the separation of concerns make testing and verification easier.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Disadvantages of Functional Programming
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While functional programming has many advantages, it’s also essential to know
    its possible pitfalls.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Learning curve
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: The advanced mathematical terminology and concepts that functional programming
    is based on can be quite intimidating. To augment your Java code, though, you
    definitely don’t need to know that “a monad is just a monoid in the category of
    endofunctors.^([2](ch01.xhtml#idm45115257000512))" Nevertheless, you’re confronted
    with new and often unfamiliar terms and concepts.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程所基于的高级数学术语和概念可能会让人望而生畏。然而，要增强你的 Java 代码，你绝对不需要知道“一个单子只是一个自函子类别中的幺半群^([2](ch01.xhtml#idm45115257000512))”然而，你会面对新的、通常是陌生的术语和概念。
- en: Higher Level of Abstraction
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 更高的抽象水平
- en: Where OOP uses objects to model its abstraction, FP uses a higher level of abstraction
    to represent its data structures, making them quite elegant but often harder to
    recognize.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: OOP 使用对象来建模其抽象，而 FP 使用更高级别的抽象来表示其数据结构，使它们变得相当优雅，但通常更难以识别。
- en: Dealing with State
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 处理状态
- en: Handling state isn’t an easy task, regardless of the chosen paradigm. Even though
    FP’s immutable approach eliminates a lot of possible bug surfaces, it also makes
    it harder to mutate data structures if they actually need to change, especially
    if you’re accustomed to having setters in your OO code.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 处理状态并非易事，无论选择何种范式。即使 FP 的不可变方法消除了许多可能的错误表面，但如果实际上需要更改数据结构，则更难以变异，特别是如果你习惯于在你的
    OO 代码中有 setter。
- en: Performance Implications
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 性能影响
- en: Functional programming is easier and safer to use in concurrent environments.
    This doesn’t mean, however, that it’s inherently faster compared to other paradigms,
    especially in a single-threaded context. Despite their many benefits, many functional
    techniques, like immutability or recursion, can suffer from the required overhead.
    That’s why many Functional programming languages utilize a plethora of optimizations
    to mitigate, like specialized data structures that minimize copying, or compiler
    optimizations for techniques like recursion^([3](ch01.xhtml#idm45115256994976)).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在并发环境中，函数式编程更易于使用且更安全。然而，这并不意味着与其他范式相比它本质上更快，特别是在单线程环境中。尽管有许多好处，但许多函数式技术，如不可变性或递归，可能会因所需的开销而受到影响。这就是为什么许多函数式编程语言利用大量优化来减轻负担，比如最小化复制的专用数据结构，或者用于递归等技术的编译器优化^([3](ch01.xhtml#idm45115256994976))。
- en: Optimal Problem Context
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳问题背景
- en: Not all problem contexts are a good fit for a functional approach. Domains like
    high-performance computing (HPC), I/O heavy problems, or low-level systems and
    embedded controllers, where you need fine-grained control over things like data
    locality and explicit memory management, don’t mix well with functional programming.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有问题背景都适合采用函数式方法。高性能计算（HPC）、I/O 密集问题或低级系统和嵌入式控制器等领域，需要对诸如数据局部性和显式内存管理等事物进行精细控制，与函数式编程不太相容。
- en: As programmers, we must find the balance between the advantages and disadvantages
    of any paradigm and programming approach. That’s why this book shows you how to
    pick the best parts of Java’s functional evolution and utilize them to augment
    your object-oriented Java code.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 作为程序员，我们必须在任何范式和编程方法的优势和劣势之间找到平衡。这就是为什么这本书向你展示如何选择 Java 函数式进化的最佳部分，并利用它们来增强你的面向对象的
    Java 代码。
- en: Takeaways
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 收获
- en: Functional programming is built on the mathematical principle of lambda calculus.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式编程是建立在 lambda 演算的数学原理之上的。
- en: A declarative coding style based on expressions instead of statements is essential
    for functional programming.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于表达式而不是语句的声明式编码风格对函数式编程至关重要。
- en: Many programming concepts feel inherently functional, but they are not an absolute
    requirement to make a language or your code “functional.” Even non-functional
    code benefits from their underlying ideas and overall mindset.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多编程概念在本质上都感觉像是函数式的，但这并不是使语言或代码“函数式”的绝对要求。即使非函数式代码也从它们的基本思想和整体思维中受益。
- en: Purity, consistency, and simplicity are essential properties to apply to your
    code to gain the most out of a functional approach.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纯度、一致性和简单性是将这些属性应用到你的代码中以获得函数式方法最大优势的关键。
- en: Trade-offs might be necessary between the functional concepts and their real-world
    application. Their advantages usually outweigh them, though, or can at least be
    mitigated in some form.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式概念和它们在现实世界中的应用之间可能需要权衡。它们的优势通常会超过劣势，或者至少可以以某种形式加以减轻。
- en: ^([1](ch01.xhtml#idm45115253643376-marker)) Church, Alonzo. 1936\. “An unsolvable
    problem of elementary number theory.” [American journal of mathematics, Vol. 58,
    345-363.](https://doi.org/10.2307/2268571)
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch01.xhtml#idm45115253643376-marker)) Church, Alonzo. 1936\. “初等数论中的一个不可解问题。”《美国数学杂志》,
    Vol. 58, 345-363.](https://doi.org/10.2307/2268571)
- en: ^([2](ch01.xhtml#idm45115257000512-marker)) James Iry used this phrase in his
    humorous blog post [“A Brief, Incomplete, and Mostly Wrong History of Programming
    Languages”](http://james-iry.blogspot.com/2009/05/brief-incomplete-and-mostly-wrong.xhtml)
    to illustrate Haskell’s complexity. It’s also a good example of how you don’t
    need to know all the underlying mathematical details of a programming technique
    to reap its benefits. But, if you really want to know what it means, see Saunders
    Mac Lane’s book, *Categories for the Working Mathematician* (Springer, 1998),
    where the phrase used initially.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch01.xhtml#idm45115257000512-marker)) James Iry 在他幽默的博客文章[“编程语言简史：简洁、不完整且大部分错误”](http://james-iry.blogspot.com/2009/05/brief-incomplete-and-mostly-wrong.xhtml)中使用这个短语，来说明
    Haskell 的复杂性。这也是一个很好的例子，说明你不需要了解编程技术背后的所有数学细节就能享受其带来的好处。但如果你真的想知道它的含义，可以参考 Saunders
    Mac Lane 的书籍，《工作数学家的范畴》（Springer, 1998），这本书最初使用了这个短语。
- en: '^([3](ch01.xhtml#idm45115256994976-marker)) The Java Magazine article [“Curly
    Braces #6: Recursion and tail-call optimization”](https://blogs.oracle.com/javamagazine/post/curly-braces-java-recursion-tail-call-optimization)
    provides a great overview about the importance of tail-call optimization in recursive
    code.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '^([3](ch01.xhtml#idm45115256994976-marker)) 《Java Magazine》的文章[“花括号 #6：递归与尾调用优化”](https://blogs.oracle.com/javamagazine/post/curly-braces-java-recursion-tail-call-optimization)详细介绍了递归代码中尾调用优化的重要性。'
