- en: Chapter 1\. An Introduction to Functional Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To better understand how to incorporate a more functional programming style
    in Java, you first need to understand what it means for a language to be functional
    and what its foundational concepts are.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will explore the roots of functional programming needed to incorporate
    a more functional programming style into your workflow.
  prefs: []
  type: TYPE_NORMAL
- en: What Makes A Language Functional?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Programming Paradigms — like object-oriented, functional, or procedural — are
    synthetic overall concepts that classify languages and provide ways to structure
    your programs in a specific style and use different approaches to solving problems.
    Like most paradigms, functional programming doesn’t have a single agreed-upon
    definition, and many turf wars are fought about what defines a language as *actually*
    functional. Instead of giving my own definition, I will go over different aspects
    of what makes a language functional.
  prefs: []
  type: TYPE_NORMAL
- en: 'A language is considered functional when there’s a way to express computations
    by creating and combining abstract functions. This concept is rooted in the formal
    mathematical system *Lambda Calculus*, invented by the logician Alonzo Church
    in the 1930s.^([1](ch01.xhtml#idm45115253643376)) It’s a system to express computations
    with abstract functions and how to apply variables to them. The name “lambda calculus”
    came from the Greek letter “lambda” chosen for its symbol: <math alttext="lamda"><mi>λ</mi></math>
    .'
  prefs: []
  type: TYPE_NORMAL
- en: 'As an object-oriented developer, you are used to *imperative* programming:
    by defining a series of statements, you are telling the computer *what* to do
    to accomplish a particular task with a sequence of *statements*.'
  prefs: []
  type: TYPE_NORMAL
- en: For a programming language to be considered functional, a *declarative* style
    to express the logic of computations without describing their actual control flow
    needs to be achievable. In such a declarative programming style, you describe
    the outcome and *how* your program should work with *expressions*, not *what*
    it should do with *statements*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java, an *expression* is a sequence of operators, operands, and method invocations
    that define a computation and evaluate to a single value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '*Statements*, on the other hand, are actions taken by your code, to form a
    complete unit of execution, including method invocations without a return value.
    Any time you assign or change the value of a variable, call a `void` method, or
    use control-flow constructs like `if`/`else`, you’re using statements. Usually,
    they’re intermixed with expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_an_introduction_to__span_class__keep_together__functional_programming__span__CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Assigns an initial value to a variable, introducing state into the program.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_an_introduction_to__span_class__keep_together__functional_programming__span__CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The function call `findTreasure(6)` is a functional expression, but the assignment
    of `newTreasuresFound` is a statement.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_an_introduction_to__span_class__keep_together__functional_programming__span__CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The reassignment of `totalTreasure` is a statement using the result of the expression
    on the right-hand side.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_an_introduction_to__span_class__keep_together__functional_programming__span__CO1-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The control-flow statement `if`/`else` conveys what action should be taken based
    on the result of the expression `(treasureCounter > 10)`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_an_introduction_to__span_class__keep_together__functional_programming__span__CO1-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Printing to `System.out` is a statement because there’s no result returned from
    the call.
  prefs: []
  type: TYPE_NORMAL
- en: The primary distinction between expressions and statements is whether or not
    a value is returned. In a general-purpose, multi-paradigm language like Java,
    the lines between them are often up for debate and can quickly blur.
  prefs: []
  type: TYPE_NORMAL
- en: Functional Programming Concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since functional programming is based primarily on abstract functions, its many
    concepts that form the paradigm can focus on “what to solve” in a declarative
    style, in contrast to the imperative “how to solve” approach.
  prefs: []
  type: TYPE_NORMAL
- en: We will go through the most common and significant aspects that functional programming
    uses at its foundation. These aren’t exclusive to the functional paradigm, though.
    Many of the ideas behind them apply to other programming paradigms as well.
  prefs: []
  type: TYPE_NORMAL
- en: Pure Functions and Referential Transparency
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Functional programming categorizes functions into two categories: *pure* and
    *impure*.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Pure functions* have two elemental guarantees:'
  prefs: []
  type: TYPE_NORMAL
- en: The *same* input will *always* create the same output
  prefs: []
  type: TYPE_NORMAL
- en: The return value of a *pure* function must solely depend on its input arguments.
  prefs: []
  type: TYPE_NORMAL
- en: They are self-contained without any kind of side effect
  prefs: []
  type: TYPE_NORMAL
- en: The code cannot affect the global state, like changing argument values or using
    any I/O.
  prefs: []
  type: TYPE_NORMAL
- en: 'These two guarantees allow *pure functions* to be safe to use in any environment,
    even in a parallel fashion. The following code shows a method being a *pure function*
    that accepts an argument without affecting anything outside of its context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Functions violating either of the two guarantees are considered *impure*. The
    following code is an example of an *impure function*, as it uses the current time
    for its logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The signifier “pure” and “impure” are rather unfortunate names because of the
    connotation they might invoke. *Impure functions* aren’t inferior to *pure functions*
    in general. They are just used in different ways depending on the coding style
    and paradigm you want to adhere to.
  prefs: []
  type: TYPE_NORMAL
- en: Another aspect of side-effect-free *expressions* or *pure functions* is their
    deterministic nature, which makes them *referentially transparent*. That means
    you can replace them with their respective evaluated result for any further invocations
    without changing the behavior of your program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Abstract Function:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartLayout 1st Row 1st Column f left-parenthesis x right-parenthesis
    2nd Column equals x asterisk x EndLayout" display="block"><mtable displaystyle="true"><mtr><mtd
    columnalign="right"><mrow><mi>f</mi> <mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <mi>x</mi> <mo>*</mo> <mi>x</mi></mrow></mtd></mtr></mtable></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Replacing Evaluated Expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartLayout 1st Row 1st Column r e s u l t 2nd Column equals
    f left-parenthesis 5 right-parenthesis plus f left-parenthesis 5 right-parenthesis
    2nd Row 1st Column Blank 2nd Column equals 25 plus f left-parenthesis 5 right-parenthesis
    3rd Row 1st Column Blank 2nd Column equals f left-parenthesis 5 right-parenthesis
    plus f left-parenthesis 5 right-parenthesis 4th Row 1st Column Blank 2nd Column
    equals 25 plus 25 EndLayout" display="block"><mtable displaystyle="true"><mtr><mtd
    columnalign="right"><mrow><mi>r</mi> <mi>e</mi> <mi>s</mi> <mi>u</mi> <mi>l</mi>
    <mi>t</mi></mrow></mtd> <mtd columnalign="left"><mrow><mo>=</mo> <mi>f</mi> <mo>(</mo>
    <mn>5</mn> <mo>)</mo> <mo>+</mo> <mi>f</mi> <mo>(</mo> <mn>5</mn> <mo>)</mo></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><mo>=</mo> <mn>25</mn> <mo>+</mo> <mi>f</mi>
    <mo>(</mo> <mn>5</mn> <mo>)</mo></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mrow><mo>=</mo>
    <mi>f</mi> <mo>(</mo> <mn>5</mn> <mo>)</mo> <mo>+</mo> <mi>f</mi> <mo>(</mo> <mn>5</mn>
    <mo>)</mo></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mrow><mo>=</mo> <mn>25</mn>
    <mo>+</mo> <mn>25</mn></mrow></mtd></mtr></mtable></math>
  prefs: []
  type: TYPE_NORMAL
- en: All these variants are equal and won’t change your program. Purity and referential
    transparency go hand-in-hand and give you a powerful tool because it’s easier
    to understand and reason with your code.
  prefs: []
  type: TYPE_NORMAL
- en: Immutability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Object-oriented code is usually based around a mutable program state. Objects
    can and will usually change after their creation, using *setters*. But mutating
    data structures can create unexpected side effects. Mutability isn’t restricted
    to data structures and OOP, though. A local variable in a method might be mutable,
    too, and can lead to problems in its context as much as a changing field of an
    object.
  prefs: []
  type: TYPE_NORMAL
- en: With *immutability*, data structures can no longer change after their initialization.
    By never changing, they are always consistent, side-effect free, predictable,
    and easier to reason with. Like *pure functions*, their usage is safe in concurrent
    and parallel environments without the usual issues of unsynchronized access or
    out-of-scope state changes.
  prefs: []
  type: TYPE_NORMAL
- en: If data structures never change after initialization, a program would not be
    very useful. That’s why you need to create a new and updated version containing
    the mutated state instead of changing the data structure directly.
  prefs: []
  type: TYPE_NORMAL
- en: Creating new data structures for every change can be a chore and quite inefficient
    due to copying the data every time. Many programming languages employ “structure
    sharing” to provide efficient copy mechanisms to minimize the inefficiencies of
    requiring new data structures for every change. This way, different instances
    of data structures share immutable data between them. [Chapter 4](ch04.xhtml#_02-data-structures)
    will explain in more detail why the advantages of having side-effect-free data
    structures outweigh the extra work that might be necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Recursion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Recursion* is a problem-solving technique that solves a problem by partially
    solving problems of the same form, and combining the partial results to finally
    solve the original problem. In layperson’s terms, recursive functions call themselves,
    but with a slight change in their input arguments, until they reach an end condition
    and return an actual value. [Chapter 12](ch12.xhtml#_02-recursion) will go into
    the finer details of recursion.'
  prefs: []
  type: TYPE_NORMAL
- en: A simple example is calculating a factorial, the product of all positive integers
    less than or equal to the input parameter. Instead of calculating the value with
    an intermediate state, the function calls itself with a decremented input variable,
    as illustrated in [Figure 1-1](#_01-an-introduction_recursion_factorial).
  prefs: []
  type: TYPE_NORMAL
- en: '![Calculating a factorial with recursion](assets/afaj_0101.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1-1\. Calculating a factorial with recursion
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Pure functional programming often prefers using recursion instead of loops or
    iterators. Some of them, like [Haskell](https://www.haskell.org), go a step further
    and don’t have loops like `for` or `while` at all.
  prefs: []
  type: TYPE_NORMAL
- en: The repeated function calls can be inefficient and even dangerous due to the
    risk of the stack overflowing. That’s why many functional languages utilize optimizations
    like “unrolling” recursion into loops or *tail-call optimization* to reduce the
    required stack frames. Java doesn’t support any of these optimization techniques,
    which I’ll talk more about in [Chapter 12](ch12.xhtml#_02-recursion).
  prefs: []
  type: TYPE_NORMAL
- en: First-Class and Higher-Order Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many of the previously discussed concepts don’t have to be available as deeply
    integrated language features to support a more functional programming style in
    your code. The concepts of first-class and higher-order functions, however, are
    absolute must-haves.
  prefs: []
  type: TYPE_NORMAL
- en: For functions to be so-called “first-class citizens,” they must observe all
    the properties inherent to other entities of the language. They need to be assignable
    to variables and be used as arguments and return values in other functions and
    expressions.
  prefs: []
  type: TYPE_NORMAL
- en: '*Higher-order* functions use this *first-class* citizenship to accept functions
    as arguments or to return a function as their result, or both. This is an essential
    property for the next concept, *functional composition*.'
  prefs: []
  type: TYPE_NORMAL
- en: Functional Composition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Pure functions* can be combined to create more complex expressions. In mathematical
    terms, this means that the two functions <math alttext="f left-parenthesis x right-parenthesis"><mrow><mi>f</mi>
    <mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></math> and <math alttext="g left-parenthesis
    x right-parenthesis"><mrow><mi>g</mi> <mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></math>
    can be combined to a function <math alttext="h left-parenthesis x right-parenthesis
    equals g left-parenthesis f left-parenthesis x right-parenthesis right-parenthesis"><mrow><mi>h</mi>
    <mo>(</mo> <mi>x</mi> <mo>)</mo> <mo>=</mo> <mi>g</mi> <mo>(</mo> <mi>f</mi> <mo>(</mo>
    <mi>x</mi> <mo>)</mo> <mo>)</mo></mrow></math> , as seen in [Figure 1-2](#_01-an-introduction_functional-composition_overview).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Composing function f and g to a new function h](assets/afaj_0102.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1-2\. Composing functions
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This way, functions can be small and on point as possible, and therefore, easier
    to reuse. To create a more complex and complete task, such functions can be quickly
    composed as needed.
  prefs: []
  type: TYPE_NORMAL
- en: Currying
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Function *currying* means converting a function from taking multiple arguments
    into a sequence of functions that each take only a single argument.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The currying technique borrows its name from the mathematician and logician
    Haskell Brook Curry (1900-1982). He’s not only the namesake of the functional
    technique called *currying*, he also has three different programming languages
    named after him: [Haskell](https://www.haskell.org/), [Brook](http://graphics.stanford.edu/projects/brookgpu/),
    and [Curry](http://curry-lang.org/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine a function that accepts three arguments. It can be curried as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Initial function:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartLayout 1st Row 1st Column x 2nd Column equals f left-parenthesis
    a comma b comma c right-parenthesis EndLayout" display="block"><mtable displaystyle="true"><mtr><mtd
    columnalign="right"><mi>x</mi></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <mi>f</mi> <mo>(</mo> <mi>a</mi> <mo>,</mo> <mi>b</mi> <mo>,</mo> <mi>c</mi> <mo>)</mo></mrow></mtd></mtr></mtable></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Curried functions:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartLayout 1st Row 1st Column h 2nd Column equals g left-parenthesis
    a right-parenthesis 2nd Row 1st Column i 2nd Column equals h left-parenthesis
    b right-parenthesis 3rd Row 1st Column x 2nd Column equals i left-parenthesis
    c right-parenthesis EndLayout" display="block"><mtable displaystyle="true"><mtr><mtd
    columnalign="right"><mi>h</mi></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <mi>g</mi> <mo>(</mo> <mi>a</mi> <mo>)</mo></mrow></mtd></mtr> <mtr><mtd columnalign="right"><mi>i</mi></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <mi>h</mi> <mo>(</mo> <mi>b</mi> <mo>)</mo></mrow></mtd></mtr>
    <mtr><mtd columnalign="right"><mi>x</mi></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <mi>i</mi> <mo>(</mo> <mi>c</mi> <mo>)</mo></mrow></mtd></mtr></mtable></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Sequence of curried functions:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartLayout 1st Row 1st Column x 2nd Column equals g left-parenthesis
    a right-parenthesis left-parenthesis b right-parenthesis left-parenthesis c right-parenthesis
    EndLayout" display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mi>x</mi></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <mi>g</mi> <mo>(</mo> <mi>a</mi> <mo>)</mo>
    <mo>(</mo> <mi>b</mi> <mo>)</mo> <mo>(</mo> <mi>c</mi> <mo>)</mo></mrow></mtd></mtr></mtable></math>
  prefs: []
  type: TYPE_NORMAL
- en: Some functional programming languages reflect the general concept of *currying*
    in their type definitions like Haskell as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_an_introduction_to__span_class__keep_together__functional_programming__span__CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The function `add` is declared to accept an `Integer` and returns another function
    accepting another `Integer`, which itself returns an `Integer`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_an_introduction_to__span_class__keep_together__functional_programming__span__CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The actual definition reflects the declaration: two input parameters and the
    result of the body as return value.'
  prefs: []
  type: TYPE_NORMAL
- en: At first glance, the concept can feel weird and foreign to an OO or imperative
    developer, like many principles based on mathematics. Still, it perfectly conveys
    how a function with more than one argument is representable as a function of functions,
    and that’s an essential realization to support the next concept.
  prefs: []
  type: TYPE_NORMAL
- en: Partial Function Application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Partial function application* is the process of creating a new function by
    providing not all arguments to an existing one. It’s often conflated with *currying*,
    but a call to a partially applied function returns a result and not another function
    of a currying chain.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The currying example from the previous section can be partially applied to
    create a more specific function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_an_introduction_to__span_class__keep_together__functional_programming__span__CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The `add` function is declared as before, accepting two arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_an_introduction_to__span_class__keep_together__functional_programming__span__CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Calling the function `add` with only a value for the first argument `x` return
    as partially applied function of type `Integer → Integer`, which is bound to the
    name `add3`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_an_introduction_to__span_class__keep_together__functional_programming__span__CO3-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The call `add3 5` is equivalent to `add 3 5`.
  prefs: []
  type: TYPE_NORMAL
- en: With partial application, you can create new, less verbose functions on the
    fly or specialized functions from a more generic pool to match your code’s current
    context and requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Lazy Evaluation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Lazy evaluation* is an evaluation strategy that delays the evaluation of an
    expression until its result is literally needed by separating the concerns of
    how you create an expression from whether or when you actually use it. It’s also
    another concept not rooted in or restricted to functional programming but a must-have
    for using other functional concepts and techniques.'
  prefs: []
  type: TYPE_NORMAL
- en: Many non-functional languages, including Java, are primarily *strict* — or *eagerly* — evaluated,
    meaning an expression evaluates immediately. Those languages still have a few
    lazy constructs, like control-flow statements such as `if`-`else`-statements or
    loops, or logical short-circuit operators. Immediately evaluating both branches
    of an `if`-`else` construct or all possible loop iterations wouldn’t make much
    sense, would it? So instead, only the branches and iterations absolutely required
    are evaluated during runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Laziness enables certain constructs that aren’t possible otherwise, like infinite
    data structures or more efficient implementations of some algorithms. It also
    works very well with *referential transparency*. If there is no difference between
    an expression and its result, you can delay the evaluation without consequences
    to the result. Delayed evaluation might still impact the program’s performance
    because you might not know the precise time of evaluation.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 11](ch11.xhtml#_02-lazy-evaluation) I will discuss how to achieve
    a lazy approach in Java with the tools at your disposal, and how to create your
    own.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of Functional Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After going through the most common and essential concepts of functional programming,
    you can see how they are reflected in the advantages that a more functional approach
    provides:'
  prefs: []
  type: TYPE_NORMAL
- en: Simplicity
  prefs: []
  type: TYPE_NORMAL
- en: Without mutable state and side effects, your functions tend to be smaller, doing
    “just what they are supposed to do.”
  prefs: []
  type: TYPE_NORMAL
- en: Consistency
  prefs: []
  type: TYPE_NORMAL
- en: Immutable data structures are reliable and consistent. No more worries about
    unexpected or unintended program state.
  prefs: []
  type: TYPE_NORMAL
- en: (Mathematical) Correctness
  prefs: []
  type: TYPE_NORMAL
- en: Simpler code with consistent data structures will automatically lead to “more
    correct” code with a smaller bug surface. The “purer” your code, the easier it
    will be to reason with, leading to simpler debugging and testing.
  prefs: []
  type: TYPE_NORMAL
- en: Safer Concurrency
  prefs: []
  type: TYPE_NORMAL
- en: Concurrency is one of the most challenging tasks to do right in “classical”
    Java. Functional concepts allow you to eliminate many headaches and gain safer
    parallel processing (almost) for free.
  prefs: []
  type: TYPE_NORMAL
- en: Modularity
  prefs: []
  type: TYPE_NORMAL
- en: Small and independent functions lead to simpler reusability and modularity.
    Combined with functional composition and partial application, you have powerful
    tools to build more complex tasks out of these smaller parts easily.
  prefs: []
  type: TYPE_NORMAL
- en: Testability
  prefs: []
  type: TYPE_NORMAL
- en: Many of the functional concepts, like pure functions, referential transparency,
    immutability, and the separation of concerns make testing and verification easier.
  prefs: []
  type: TYPE_NORMAL
- en: Disadvantages of Functional Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While functional programming has many advantages, it’s also essential to know
    its possible pitfalls.
  prefs: []
  type: TYPE_NORMAL
- en: Learning curve
  prefs: []
  type: TYPE_NORMAL
- en: The advanced mathematical terminology and concepts that functional programming
    is based on can be quite intimidating. To augment your Java code, though, you
    definitely don’t need to know that “a monad is just a monoid in the category of
    endofunctors.^([2](ch01.xhtml#idm45115257000512))" Nevertheless, you’re confronted
    with new and often unfamiliar terms and concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Higher Level of Abstraction
  prefs: []
  type: TYPE_NORMAL
- en: Where OOP uses objects to model its abstraction, FP uses a higher level of abstraction
    to represent its data structures, making them quite elegant but often harder to
    recognize.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with State
  prefs: []
  type: TYPE_NORMAL
- en: Handling state isn’t an easy task, regardless of the chosen paradigm. Even though
    FP’s immutable approach eliminates a lot of possible bug surfaces, it also makes
    it harder to mutate data structures if they actually need to change, especially
    if you’re accustomed to having setters in your OO code.
  prefs: []
  type: TYPE_NORMAL
- en: Performance Implications
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming is easier and safer to use in concurrent environments.
    This doesn’t mean, however, that it’s inherently faster compared to other paradigms,
    especially in a single-threaded context. Despite their many benefits, many functional
    techniques, like immutability or recursion, can suffer from the required overhead.
    That’s why many Functional programming languages utilize a plethora of optimizations
    to mitigate, like specialized data structures that minimize copying, or compiler
    optimizations for techniques like recursion^([3](ch01.xhtml#idm45115256994976)).
  prefs: []
  type: TYPE_NORMAL
- en: Optimal Problem Context
  prefs: []
  type: TYPE_NORMAL
- en: Not all problem contexts are a good fit for a functional approach. Domains like
    high-performance computing (HPC), I/O heavy problems, or low-level systems and
    embedded controllers, where you need fine-grained control over things like data
    locality and explicit memory management, don’t mix well with functional programming.
  prefs: []
  type: TYPE_NORMAL
- en: As programmers, we must find the balance between the advantages and disadvantages
    of any paradigm and programming approach. That’s why this book shows you how to
    pick the best parts of Java’s functional evolution and utilize them to augment
    your object-oriented Java code.
  prefs: []
  type: TYPE_NORMAL
- en: Takeaways
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functional programming is built on the mathematical principle of lambda calculus.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A declarative coding style based on expressions instead of statements is essential
    for functional programming.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many programming concepts feel inherently functional, but they are not an absolute
    requirement to make a language or your code “functional.” Even non-functional
    code benefits from their underlying ideas and overall mindset.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Purity, consistency, and simplicity are essential properties to apply to your
    code to gain the most out of a functional approach.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trade-offs might be necessary between the functional concepts and their real-world
    application. Their advantages usually outweigh them, though, or can at least be
    mitigated in some form.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ^([1](ch01.xhtml#idm45115253643376-marker)) Church, Alonzo. 1936\. “An unsolvable
    problem of elementary number theory.” [American journal of mathematics, Vol. 58,
    345-363.](https://doi.org/10.2307/2268571)
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch01.xhtml#idm45115257000512-marker)) James Iry used this phrase in his
    humorous blog post [“A Brief, Incomplete, and Mostly Wrong History of Programming
    Languages”](http://james-iry.blogspot.com/2009/05/brief-incomplete-and-mostly-wrong.xhtml)
    to illustrate Haskell’s complexity. It’s also a good example of how you don’t
    need to know all the underlying mathematical details of a programming technique
    to reap its benefits. But, if you really want to know what it means, see Saunders
    Mac Lane’s book, *Categories for the Working Mathematician* (Springer, 1998),
    where the phrase used initially.
  prefs: []
  type: TYPE_NORMAL
- en: '^([3](ch01.xhtml#idm45115256994976-marker)) The Java Magazine article [“Curly
    Braces #6: Recursion and tail-call optimization”](https://blogs.oracle.com/javamagazine/post/curly-braces-java-recursion-tail-call-optimization)
    provides a great overview about the importance of tail-call optimization in recursive
    code.'
  prefs: []
  type: TYPE_NORMAL
