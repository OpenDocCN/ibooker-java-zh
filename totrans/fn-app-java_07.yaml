- en: Chapter 5\. Working With Records
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Java 14 introduced a new type of data structure as a preview^([1](ch05.xhtml#idm45115246956000))
    feature, which was finalized two releases later: *Records*. They are not just
    another typical Java type or technique you can use. Instead, Records are a completely
    new language feature providing you with a simple but feature-rich data aggregator
    with minimal boilerplate.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Data Aggregation Types
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From a general point-of-view, *data aggregation* is the process of gathering
    data from multiple sources and assembling it in a format that better serves the
    intended purpose and more preferable usage. Maybe the most well-known kind of
    data aggregation type is *tuples*.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Tuples
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Mathematically speaking, a tuple is a “finite ordered sequence of elements.”
    In terms of programming languages, a tuple is a data structure aggregating multiple
    values or objects.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two kinds of tuples. *Structural* tuples rely only on the order of
    the contained elements and are therefore only accessible by their indices, as
    seen in the following Python code:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Nominal* tuples don’t use an index to access their data, but they use component
    names instead, as seen in the following Swift code:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In order to demonstrate what Records have to offer, you’ll first have a look
    at how to go from a classical POJO to an immutable one, and then I’ll show you
    how to replicate the same functionality with a Record instead.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: A Simple POJO
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, let’s take a look at the “pre-Record” state of data aggregation in Java
    to better grasp what Records have to offer. As an example, we create a simple
    “user” type as a “classic” POJO, evolve it to an “immutable” POJO, and finally,
    a Record. It will be a simple type, with a username, an activity state, a last-login
    timestamp, and the “usual” boilerplate that comes along in typical Java code,
    as seen in [Example 5-1](#_02-data-structures_records_user-pojo-like).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-1\. Simple User POJO
  id: totrans-13
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[![1](assets/1.png)](#co_working_with_records_CO1-1)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Constructors aren’t strictly necessary but are added for convenience. If any
    constructor with arguments exists, an explicit “empty” constructor should be added,
    too.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_working_with_records_CO1-3)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: POJOs usually have getters instead of public fields.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_working_with_records_CO1-4)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: The first variant of the `User` type is still mutable due to its setter methods.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_working_with_records_CO1-9)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Both `hashCode` and `equals` require dedicated implementations that depend on
    the actual structure of the type. Any changes to the type require both methods
    to adapt.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_working_with_records_CO1-10)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: The `toString` method is another convenience addition that isn’t explicitly
    needed. Just like the previous methods, it has to be updated every time the type
    changes.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Including the empty lines and curly braces, that’s ~75 lines for just holding
    three data fields. No wonder one of the most common complaints about Java is its
    verbosity, and “too much ceremony” to do *standard* things!
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 包括空行和大括号，仅仅用于保存三个数据字段就有大约75行。难怪Java最常见的抱怨之一是其冗长性，以及完成*标准*任务时“过于繁琐”的感觉！
- en: Now, let’s convert it into an immutable POJO.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将其转换为一个不可变的POJO。
- en: From POJO to Immutability
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从POJO到不可变性
- en: Making the `User` POJO immutable reduces the required boilerplate slightly because
    you no longer need any setter methods, as shown in [Example 5-2](#_02-data-structures_records_user-pojo-like_immutable).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 使`User` POJO不可变会稍微减少所需的样板代码，因为您不再需要任何setter方法，正如[示例5-2](#_02-data-structures_records_user-pojo-like_immutable)中所示。
- en: Example 5-2\. Simple immutable User type
  id: totrans-29
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例5-2\. 简单的不可变用户类型
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[![1](assets/1.png)](#co_working_with_records_CO2-1)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_working_with_records_CO2-1)'
- en: Without “setters”, the fields can be declared `final`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 没有“setters”，字段可以声明为`final`。
- en: '[![2](assets/2.png)](#co_working_with_records_CO2-2)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_working_with_records_CO2-2)'
- en: Only a full “pass-through” constructor is possible because the fields must be
    set on object creation.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 仅可能存在一个完全的“传递”构造函数，因为字段必须在对象创建时设置。
- en: '[![3](assets/3.png)](#co_working_with_records_CO2-3)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_working_with_records_CO2-3)'
- en: The “getters” remain unchanged from the mutable variant.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: “getters”与可变变体保持不变。
- en: '[![4](assets/4.png)](#co_working_with_records_CO2-6)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_working_with_records_CO2-6)'
- en: The supporting methods are also unchanged compared to the previous implementation.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 与先前的实现相比，支持方法也未更改。
- en: By making the type immutable yourself, only the code of the setters and the
    empty constructor could be removed; everything else is still there. That’s still
    quite a lot of code for holding three fields with not much additional functionality.
    Of course, we could remove more of the “ceremony” and use a simple class with
    three `public final` fields and a constructor. Depending on your requirements,
    that might be “just enough.” The additional functionality, however, like equality
    comparison, and a correct `hashCode` so it can be used in a `Set` or `HashMap`,
    or a sensible `toString` output, are all desirable features.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使类型本身不可变，只需删除setter和空构造函数的代码；其他所有内容仍然存在。对于仅包含三个`public final`字段和一个构造函数的类，这仍然是相当多的代码。当然，根据您的需求，这可能是“恰到好处”的选择。然而，额外的功能，如相等比较、正确的`hashCode`以便在`Set`或`HashMap`中使用，或合理的`toString`输出，都是值得拥有的功能。
- en: From POJO to Record
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从POJO到Record
- en: 'Finally, let’s take a look at a more general, less ceremonial, but still feature-rich
    solution using a Record instead:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看一下使用Record的更通用、不那么繁琐但功能丰富的解决方案：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: That’s it.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是这样。
- en: The `User` Record has the same features as the immutable POJO. How it does so
    much with so little code will be explained in detail in the upcoming sections.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`User` Record具有与不可变POJO相同的功能。如何用如此少的代码实现如此多的功能将在接下来的章节中详细解释。'
- en: Records to the Rescue
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录来解救
- en: Records are a way to define plain *data aggregator types* that access their
    data components by name in the vein of *nominal tuples*. Like nominal tuples,
    Records aggregate an ordered sequence of values and provide access via names instead
    of indices. Their data is shallowly immutable and transparently accessible. The
    typical boilerplate of other data classes is significantly reduced by generating
    accessors and data-driven methods like `equals` and `hashCode`. Even though the
    final version of [JEP 395](https://openjdk.java.net/jeps/395) explicitly states
    that “war on boilerplate” is a non-goal, it’s still a happy coincidence many developers
    will appreciate.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Records是定义纯粹*数据聚合器类型*的一种方式，它们通过名称访问其数据组件，类似于*命名元组*。与命名元组一样，Records聚合有序序列的值，并通过名称而不是索引提供访问。它们的数据是浅不可变的，并且透明地可访问。通过生成访问器和数据驱动方法如`equals`和`hashCode`显著减少了其他数据类的典型样板。尽管[JEP
    395的最终版本](https://openjdk.java.net/jeps/395)明确指出“反对样板代码”不是目标，但许多开发人员仍将其视为一个令人满意的巧合。
- en: Being “plain” data aggregator types, there are some missing features compared
    to other options. This chapter will cover each missing feature and how to mitigate
    them, transforming Records into a more flexible solution for your data aggregation
    needs.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 作为“plain”数据聚合器类型，与其他选项相比确实缺少一些功能。本章将覆盖每个缺失的功能以及如何缓解它们，将Records转变为更灵活的解决方案，以满足您的数据聚合需求。
- en: 'As seen in the previous section, Records use a new keyword — `record` — to
    delimit them from other classes and enums. The data components are declared like
    a constructor or method arguments directly after the Record’s name:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一节所示，Records使用一个新关键字 — `record` — 来将它们与其他类和枚举分隔开来。数据组件直接在Record名称后的一对括号中声明，类似于构造函数或方法参数：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The general syntax for Records breaks down into two parts: a *header* defining
    the same properties as other types, plus its components and an optional *body*
    to support additional constructors and methods.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 记录的一般语法分为两部分：一个*标头*定义了与其他类型相同的属性，以及其组件和一个可选的*主体*，以支持额外的构造函数和方法。
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The header is similar to a `class` or `interface` header and consists of multiple
    parts:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 标头类似于`class`或`interface`的标头，由多个部分组成：
- en: Visibility
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 可见性
- en: Like a `class`, `enum`, or `interface` definition, a Record supports Java’s
    visibility keywords (`public`, `private`, `protected`).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 与`class`、`enum`或`interface`定义类似，Record支持Java的可见性关键字（`public`、`private`、`protected`）。
- en: The record keyword
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 记录关键字
- en: The keyword `record` distinguishes the header from the other type declarations
    `class`, `enum`, and `interface`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字`record`将标头与其他类型声明`class`、`enum`和`interface`区分开来。
- en: Name
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 名称
- en: Naming rules are identical to any other identifier, as defined in the *Java
    Language Specification*⁠^([2](ch05.xhtml#idm45115245303760)).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 命名规则与《Java语言规范》中定义的任何其他标识符相同，如*Java语言规范*⁠^([2](ch05.xhtml#idm45115245303760))所述。
- en: Generic types
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '[泛型类型](https://example.org/generic_types)'
- en: Generic types are supported as with other type declarations in Java.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型类型与Java中的其他类型声明一样受支持。
- en: Data components
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 数据组件
- en: The name is followed by a pair of parentheses containing the components of the
    Record. Each one translates into a `private final` field and a `public` accessor
    method behind the scenes. The components list also represents the constructor
    of the Record.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 名称后跟着一对括号，其中包含Record的组件。每个组件在幕后转换为一个`private final`字段和一个`public`访问器方法。组件列表还表示Record的构造函数。
- en: Body
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 主体
- en: A typical Java body, like any other `class` or `interface`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的Java主体，与任何其他`class`或`interface`类似。
- en: An effectively single line of code will be translated by the compiler to a class
    similar to [Example 5-2](#_02-data-structures_records_user-pojo-like_immutable)
    from the previous section. It extends `java.lang.Record` explicitly rather than
    `java.lang.Object` implicitly, just like enums do with `java.lang.Enum`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将一行代码有效地转换为与上一节中的[示例 5-2](#_02-data-structures_records_user-pojo-like_immutable)类似的类。它明确扩展了`java.lang.Record`而不是隐式地扩展`java.lang.Object`，就像枚举与`java.lang.Enum`一样。
- en: Behind The Scenes
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 背后的幕后
- en: The generated class behind any Record gives you quite a lot of functionality
    without writing any additional code. It’s time to take a deeper look at what’s
    actually happening behind-the-scenes.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 任何Record后面生成的类都会为您提供相当多的功能，而无需编写任何额外的代码。现在是时候深入了解实际发生的事情了。
- en: The JDK includes the command `javap`, which disassembles `.class` files and
    allows you to see the Java corresponding Java code for the bytecode. This way,
    it’s easy to compare the actual difference between the POJO and Record version
    of the `User` type from [“Data Aggregation Types”](#_02-records_data-aggregation-types).
    The combined and cleaned-up output for both variants is shown in [Example 5-3](#_02-data-structures_records_user-javap).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: JDK包括命令`javap`，用于反汇编`.class`文件，并允许您查看字节码的Java对应Java代码。通过这种方式，很容易比较[“数据聚合类型”](#_02-records_data-aggregation-types)中的`User`类型的POJO和Record版本之间的实际差异。两个变体的组合和清理后的输出显示在[示例 5-3](#_02-data-structures_records_user-javap)中。
- en: Example 5-3\. Disassembled User.class POJO versus Record
  id: totrans-69
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-3\. Disassembled User.class POJO versus Record
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see, the resulting classes are identical functionality-wise, only
    the naming of the accessor methods differ. But where did all those methods come
    from? Well, that’s the “magic” of Records, giving you a full-fledged data aggregation
    type without writing more code as absolutely needed.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，生成的类在功能上是相同的，只是访问器方法的命名不同。那么所有这些方法都来自哪里呢？嗯，这就是Records的“魔法”，让您获得了一个完整的数据聚合类型，而无需写更多的绝对必要的代码。
- en: Record Features
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记录功能
- en: 'Records are transparent data aggregators with specific guaranteed properties
    and well-defined behavior by automagically^([3](ch05.xhtml#idm45115245005648))
    providing functionality without needing to repeatedly write the following trivial
    boilerplate implementations:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Records是透明的数据聚合器，具有特定的保证属性和明确定义的行为，通过自动^([3](ch05.xhtml#idm45115245005648))提供功能，无需重复编写以下琐碎的样板实现：
- en: Component accessors
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[组件访问器](https://example.org/component_accessors)'
- en: Three types of constructors
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三种类型的构造函数
- en: Object identity and description methods
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象标识和描述方法
- en: That’s a lot of functionality without requiring any additional code besides
    the Record declaration. Any missing pieces can be done by augmenting or overriding
    these features as necessary.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 除了记录声明之外，这需要大量的功能而不需要任何额外的代码。任何缺失的部分都可以通过根据需要增加或重写这些功能来完成。
- en: Let’s check out Record’s automatic features and how other typical Java features,
    like generics, annotations, and reflection, fit in.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看Record的自动特性以及其他典型的Java特性，比如泛型、注解和反射是如何适配的。
- en: Component Accessors
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 组件访问器
- en: 'All Record components are stored in `private` fields. Inside a Record, its
    fields are directly accessible. “From the outside,” you need to access them through
    the generated `public` accessor methods. The accessor method names correspond
    to their component name without the typical “getter” prefix `get`, as shown in
    the following code example:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 所有记录组件都存储在`private`字段中。在记录内部，其字段可以直接访问。从“外部”访问它们需要通过生成的`public`访问器方法。访问器方法的名称与其组件名称对应，不带典型的“getter”前缀`get`，就像以下代码示例中所示：
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The accessor methods return the corresponding field’s value as-is. Though you
    can override them, as shown in the following code, I wouldn’t recommend it.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 访问器方法按原样返回对应字段的值。虽然可以重写它们，就像下面的代码所示，但我不建议这样做。
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Records are supposed to be *immutable* data holders, so making decisions while
    accessing its data could be considered a code smell. The creation of a Record
    defines its data, and that’s where any validation or other logic should affect
    the data, as you will learn in the next section.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 记录应该是*不可变*的数据持有者，因此在访问其数据时做出决策可能被视为代码异味。记录的创建定义了其数据，这就是任何验证或其他逻辑应该影响数据的地方，正如您将在下一节中了解的那样。
- en: Canonical, Compact, and Custom Constructors
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 规范、紧凑和自定义构造函数
- en: 'A constructor identical to the Record’s components definition is automatically
    available, called the *canonical* constructor. The Record’s components are assigned
    to the corresponding fields “as-is.” Like component accessors, the canonical constructor
    is overridable to validate input, like `null`-checks, or even manipulate data
    if necessary:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 与记录组件定义相同的构造函数会自动可用，称为*规范*构造函数。记录的组件被直接分配给相应的字段“原样”。与组件访问器一样，规范构造函数可重写以验证输入，如`null`检查，甚至在必要时操作数据：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: That’s a lot of additional lines for two actual `null`-checks, including redeclaration
    of the constructor signature and assigning the components to the invisible fields.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行两个实际的`null`检查，包括重新声明构造函数签名并将组件分配给不可见字段，这是相当多的额外代码行。
- en: Thankfully, a specialized *compact* form, shown in the following code example,
    is available, and it doesn’t force you to repeat any boilerplate if you don’t
    need it.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，还提供了一种专门的*紧凑*形式，如下面的代码示例所示，并且如果不需要，它不会强制您重复任何样板代码。
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[![1](assets/1.png)](#co_working_with_records_CO3-1)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_working_with_records_CO3-1)'
- en: The constructor omits all arguments, including the parentheses.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数省略了所有参数，包括括号。
- en: '[![2](assets/2.png)](#co_working_with_records_CO3-2)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_working_with_records_CO3-2)'
- en: Field assignments aren’t allowed in the compact canonical constructor, but you
    can customize or normalize data before it’s assigned.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在紧凑的规范构造函数中不允许字段分配，但可以在分配之前自定义或标准化数据。
- en: '[![3](assets/3.png)](#co_working_with_records_CO3-3)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_working_with_records_CO3-3)'
- en: The components will be assigned to their respective fields automatically.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 组件将自动分配给其各自的字段。
- en: At first, the syntax might look unusual because it omits all arguments, including
    the parentheses. This way, though, it’s clearly distinguishable from an argument-less
    constructor.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然语法可能看起来不寻常，因为它省略了所有参数，包括括号。不过，这样做可以清楚地区分它与无参数构造函数。
- en: The compact constructor is the perfect place to put any validation, as I will
    show you in [“Record Validation and Data Scrubbing”](#_02-records_validation).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 紧凑的构造函数是放置任何验证的理想位置，正如我将在[“记录验证和数据清理”](#_02-records_validation)中展示的那样。
- en: Like with classes, you can declare additional constructors, but any custom constructor
    must start with an explicit invocation of the canonical constructor as its first
    statement. That’s quite a restrictive requirement compared to classes, which it
    is. Still, this requirement serves an essential feature I’m going to discuss in
    [“Component Default Values and Convenience Constructors”](#_02-records_default-values).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 与类一样，你可以声明额外的构造函数，但任何自定义构造函数必须以显式调用规范构造函数作为其第一条语句。相比于类，这是一个相当严格的要求。然而，这一要求对我即将讨论的一个重要特性至关重要，详情请见[“组件默认值和便捷构造函数”](#_02-records_default-values)。
- en: Object Identity and Description
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对象标识和描述
- en: Records provide a “standard” implementation for the object identity methods
    `int hashCode()` and `boolean equals(Object)` based on data equality. Without
    an explicit implementation of the two object identity methods, you don’t have
    to worry about updating your code if the Record’s component change. Two instances
    of a Record type are considered equal if the data of their components are equal.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 记录提供了基于数据相等性的对象标识方法`int hashCode()`和`boolean equals(Object)`的“标准”实现。如果没有显式实现这两个对象标识方法，当记录的组件发生变化时，您无需担心更新代码。如果两个Record类型的实例的组件数据相等，则它们被视为相等。
- en: 'The object description method `String toString()` is auto-generated from the
    components, too, giving you a sensible default output, for example:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 对象描述方法`String toString()`也是从组件自动生成的，为您提供了一个合理的默认输出，例如：
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The object identity and description methods are overridable, too, like component
    accessors and constructors.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 对象标识和描述方法也是可重写的，就像组件访问器和构造函数一样。
- en: Generics
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通用类型
- en: 'Records also support generics, which follow the “usual” rules:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 记录也支持通用类型，遵循“通常”的规则：
- en: '[PRE13]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Personally, I would advise against overusing generic Records. Using more specific
    Records that more closely match the domain model they represent gives you more
    expressiveness and reduces accidental misuse.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 就个人而言，我建议避免滥用通用Records。使用更具体的Records更接近于它们所代表的领域模型，可以提供更多的表现力，并减少意外误用的可能性。
- en: Annotations
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注解
- en: 'Annotations behave a little differently than you might expect if used on a
    Record’s components:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用于记录的组件上，注解的行为与您预期的有些不同：
- en: '[PRE14]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: At first glance, `username` looks like a parameter, so a sensible conclusion
    would be that only annotations with `ElementType.PARAMETER` should be possible^([4](ch05.xhtml#idm45115244379264)).
    But with Records and their automagically generated fields and component accessors,
    some special considerations must be made. To support annotating these features,
    any annotations with the targets `FIELD`, `PARAMETER`, or `METHOD`, are propagated
    to the corresponding locations if applied to a component.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，`username`看起来像是一个参数，因此一个明智的结论是只有具有`ElementType.PARAMETER`目标的注解才可能存在^([4](ch05.xhtml#idm45115244379264))。但是对于Records及其自动生成的字段和组件访问器，必须考虑一些特殊情况。为了支持对这些特性进行注解，如果应用于组件，则任何具有`FIELD`、`PARAMETER`或`METHOD`目标的注解将传播到相应的位置。
- en: In addition to the existing targets, the new target `ElementType.RECORD_COMPONENT`
    was introduced for more fine-grained annotation control in Records.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 除了现有的目标外，还引入了新的目标`ElementType.RECORD_COMPONENT`，用于在记录中实现更精细的注解控制。
- en: Reflection
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 反射
- en: To complement Java’s reflection capabilities, Java 16 added the `getRecordComponents`
    method to `java.lang.Class`.. In the case of a Record-based type, the call gives
    you an array of `java.lang.reflect.RecordComponent` objects, or `null` for any
    other type of `Class`. The components are returned in the same order that they
    are declared in the record header, allowing you to look up the canonical constructor
    via `getDeclaredConstructor()` on a Record’s class.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了补充Java的反射能力，Java 16添加了`getRecordComponents`方法到`java.lang.Class`中。对于基于Record的类型，该调用将返回一个数组，其中包含`java.lang.reflect.RecordComponent`对象，对于其他类型的`Class`则返回`null`。这些组件按照在记录头中声明的顺序返回，允许您通过在Record类上调用`getDeclaredConstructor()`来查找规范构造函数。
- en: You will find some reflection-based examples in the book’s [code repository](https://github.com/benweidig/a-functional-approach-to-java).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在书籍的[代码存储库](https://github.com/benweidig/a-functional-approach-to-java)中找到一些基于反射的示例。
- en: Missing Features
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缺失的功能
- en: 'Records are precisely what they are supposed to be: *plain, transparent, shallowly
    immutable data-aggregators*. They provide a plethora of features without writing
    any line of code except their definition. Compared to other available data aggregators,
    they lack some features you might be used to, such as:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Records 正是它们应该是的：*简单的、透明的、浅不可变的数据聚合器*。它们提供了大量功能，而无需编写除了它们的定义之外的任何代码。与其他可用的数据聚合器相比，它们缺少一些你可能习惯的功能，比如：
- en: Additional State
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 附加状态
- en: Inheritance
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承
- en: (Simple) default values
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (简单的) 默认值
- en: Step-by-step creation
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逐步创建
- en: This section shows you what features are “missing in action” and how to mitigate
    them if possible.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将向你展示哪些功能是“失踪”的，以及如何在可能的情况下加以缓解。
- en: Additional State
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 附加状态
- en: Allowing any additional opaque state is an obvious omission from records. They
    are supposed to be *data-aggregators* representing a transparent state. That’s
    why any additional field added to its body results in a compiler error.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 允许任何附加的不透明状态是 Records 显而易见的遗漏。它们应该是*数据聚合器*，代表着一个透明的状态。这就是为什么向其主体添加任何附加字段都会导致编译器错误。
- en: Tip
  id: totrans-126
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: If you require more fields than what’s possible with a Record’s components alone,
    Records might not be the data structure your looking for.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要的字段超过了 Record 组件本身所能提供的可能性，那么 Records 可能不是你要找的数据结构。
- en: 'For some scenarios at least, you could add *derived* state that’s based on
    the existing components, by adding methods to the Records:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 对于至少一些场景，你可以添加基于现有组件的*派生*状态，通过向 Records 添加方法：
- en: '[PRE15]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Methods can be added because they don’t introduce additional state like a field.
    They have access to `private` fields, guaranteeing verbatim data access even if
    the component accessor is overridden. Which to choose — field or accessor — depends
    on how you design your Record and your personal preference.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 可以添加方法，因为它们不会引入像字段一样的附加状态。它们可以访问 `private` 字段，即使组件访问器被重写，也能保证逐字数据访问。选择哪种 — 字段还是访问器 — 取决于你如何设计你的
    Record 以及你个人的偏好。
- en: Inheritance
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 继承
- en: Records are `final` types that already extend `java.lang.Record` behind-the-scenes,
    as previously seen in [Example 5-3](#_02-data-structures_records_user-javap).
    Because Java doesn’t allow inheriting more than one type, Records can’t use inheritance.
    That doesn’t mean they can’t implement any interfaces, though. With interfaces,
    you can define Record templates and share common functionality with `default`
    methods.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Records 是 `final` 类型，它们在幕后已经扩展了 `java.lang.Record`，就像之前在 [示例 5-3](#_02-data-structures_records_user-javap)
    中看到的那样。因为 Java 不允许继承多个类型，所以 Records 不能使用继承。但这并不意味着它们不能实现任何接口。通过接口，你可以定义 Record
    模板，并使用 `default` 方法共享公共功能。
- en: '[Example 5-4](#_02-data-structures_records_inheritance) shows how to create
    Records for multiple shapes with the common concept of an origin and a surface
    area.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 5-4](#_02-data-structures_records_inheritance) 展示了如何为具有公共概念的多个形状创建 Records，即原点和表面积。'
- en: Example 5-4\. Using interfaces with Records as templates
  id: totrans-134
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-4\. 使用接口作为 Records 模板
- en: '[PRE16]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[![1](assets/1.png)](#co_working_with_records_CO4-1)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_working_with_records_CO4-1)'
- en: The interface defines the components of an implementing record as simple methods
    with the correct names
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 该接口将实现记录的组件定义为具有正确名称的简单方法
- en: '[![2](assets/2.png)](#co_working_with_records_CO4-3)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_working_with_records_CO4-3)'
- en: Shared functionality is added with `default` methods.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 共享功能是通过 `default` 方法添加的。
- en: '[![3](assets/3.png)](#co_working_with_records_CO4-4)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_working_with_records_CO4-4)'
- en: Method signatures in interfaces must not interfere with any implementing record
    type.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 接口中的方法签名不得与任何实现记录类型相冲突。
- en: Sharing behavior with interfaces and `default` methods is a straightforward
    approach, as long as all implementees share the interface contract. Interfaces
    can provide a few left-out pieces of the missing inheritance, and it might be
    tempting to create intricate hierarchies and interdependencies between records.
    But structuring your record types this way will create cohesion between them that’s
    not in the original spirit of Records to be simple data aggregators defined by
    their state. The example is over-engineered to illustrate the possibilities of
    multiple interfaces better. In the real world, you would most likely make `Origin`
    a Record, too, and use composition and additional constructors to achieve the
    same functionality.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 与接口和`default`方法共享行为是一种简单的方法，只要所有实现者共享接口合同。接口可以为缺失继承的几个部分提供补充，可能会引人创建复杂的记录层次结构和互相依赖。但是以这种方式构造记录类型将会产生它们之间的内聚性，并不符合记录作为简单数据聚合器定义的原始精神。此示例是为了更好地说明多个接口可能性而过度工程化的。在现实世界中，您很可能也会将`Origin`作为记录，并使用组合和额外的构造函数来实现相同的功能。
- en: Component Default Values and Convenience Constructors
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 组件默认值和便捷构造函数
- en: 'Unlike many other languages, Java doesn’t support default values for any constructor
    or method arguments. Records only provide their canonical constructor with all
    components automatically, which can become unwieldy, especially in the case of
    composed data structures:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 不同于许多其他语言，Java不支持任何构造函数或方法参数的默认值。记录只提供其带有所有组件的标准构造函数，这可能会变得笨重，特别是在组合数据结构的情况下：
- en: '[PRE17]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Additional constructors give you an easy way to have sensible default values:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 附加构造函数提供了一个简便的方法来获取合理的默认值：
- en: '[PRE18]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[![1](assets/1.png)](#co_working_with_records_CO5-1)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_working_with_records_CO5-1)'
- en: The first additional constructor mimics the components of `Origin` to provide
    a more convenient way to create a `Rectangle`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个附加构造函数模仿`Origin`的组件，以提供创建`Rectangle`的更便捷方式。
- en: '[![2](assets/2.png)](#co_working_with_records_CO5-2)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_working_with_records_CO5-2)'
- en: The second one is a convenience constructor by removing the necessity of providing
    an `Origin`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个便捷构造函数通过删除提供`Origin`的必要性来实现。
- en: 'Due to Java’s naming semantics, not all combinations for default values might
    be possible, like `Rectangle(int x, float width, float height)` has an identical
    signature to `Rectangle(int y, float width, float height)`. In this case, using
    `static` factory methods allows you to create any combination you require:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Java的命名语义，不是所有默认值组合都可能存在，比如`Rectangle(int x, float width, float height)`与`Rectangle(int
    y, float width, float height)`具有相同的签名。在这种情况下，使用`static`工厂方法允许您创建所需的任何组合：
- en: '[PRE19]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Using `static` Factory methods is a more expressive alternative to custom constructors
    and the only resort with overlapping signatures.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`static`工厂方法是自定义构造函数的更具表现力的替代方案，并且是重叠签名的唯一选择。
- en: 'In the case of argument-less constructors, a constant makes more sense:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 对于无参数构造函数，使用常量更有意义：
- en: '[PRE20]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: First, your code is more expressive with meaningful names for constants. Second,
    only a single instance is created, which is constant anywhere because the underlying
    data structure is immutable.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您的代码通过常量的有意义名称更具表现力。其次，只创建一个单一实例，因为底层数据结构是不可变的，所以在任何地方都是常量。
- en: Step-by-Step Creation
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 逐步创建
- en: One of the advantages of immutable data structures is the lack of “half-initialized”
    objects. Still, not every data structure is initializable all at once. Instead
    of using a mutable data structure in such a case, you can use the *builder pattern*
    to get a mutable intermediate variable that’s used to create an eventually immutable
    final result. Even though the builder pattern was incepted as a solution to recurring
    object creation problems in object-oriented programming, it’s also highly beneficial
    for creating immutable data structures in a more functional Java environment.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变数据结构的一个优点是缺乏“半初始化”的对象。然而，并非每个数据结构都能一次初始化。在这种情况下，您可以使用*构建器模式*来获取一个可变的中间变量，用于创建最终不可变的结果。尽管构建器模式起源于解决面向对象编程中重复对象创建问题的解决方案，但在更功能化的Java环境中，它对于创建不可变数据结构也是非常有益的。
- en: By separating the construction of the data structure from its representation,
    the data structure itself can be as simple as possible, making the pattern an
    excellent match for Records. Any required logic, or validation, is encapsulated
    into a (multistep-)builder.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将数据结构的构建与其表示分离，数据结构本身可以尽可能简单，使模式与 Records 完美匹配。任何必需的逻辑或验证都封装到一个（多步骤的）构建器中。
- en: The previously used `User` Record can be complemented by a simple builder, as
    shown in [Example 5-5](#_02-data-structures_records_builder).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 之前使用的 `User` 记录可以通过一个简单的构建器进行补充，如 [Example 5-5](#_02-data-structures_records_builder)
    所示。
- en: Example 5-5\. User Builder
  id: totrans-162
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-5\. 用户构建器
- en: '[PRE21]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[![1](assets/1.png)](#co_working_with_records_CO6-1)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_working_with_records_CO6-1)'
- en: Explicit default values are possible, reducing the required code for creation.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 显式默认值是可能的，减少了创建所需的代码。
- en: '[![2](assets/2.png)](#co_working_with_records_CO6-2)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_working_with_records_CO6-2)'
- en: Field that can be changed during building need setter-like methods.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建期间可以更改的字段需要类似 setter 的方法。
- en: '[![3](assets/3.png)](#co_working_with_records_CO6-3)'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_working_with_records_CO6-3)'
- en: Validation logic is bound to the specific setter-like method and not accumulated
    in any constructor.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 验证逻辑绑定到特定的 setter 类型方法，而不是在任何构造函数中累积。
- en: '[![4](assets/4.png)](#co_working_with_records_CO6-4)'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_working_with_records_CO6-4)'
- en: Returning `this` creates a fluent API for the builder.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 `this` 创建了一个流畅的构建器 API。
- en: '[![5](assets/5.png)](#co_working_with_records_CO6-5)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_working_with_records_CO6-5)'
- en: '`Optional` fields can use their explicit types, and only change into an `Optional`
    during `build()`.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`Optional` 字段可以使用它们的显式类型，并且仅在 `build()` 期间更改为 `Optional`。'
- en: '[![6](assets/6.png)](#co_working_with_records_CO6-6)'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_working_with_records_CO6-6)'
- en: If you’re done building, calling `build()` will create the actual immutable
    `User` record. Usually, the builder should validate its state if necessary.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果构建完成，调用 `build()` 将创建实际的不可变 `User` 记录。通常，构建器应根据需要验证其状态。
- en: '[![7](assets/7.png)](#co_working_with_records_CO6-7)'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_working_with_records_CO6-7)'
- en: The build process is fluent, and you can pass the builder around like any other
    variable.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 构建过程流畅，您可以像处理任何其他变量一样传递构建器。
- en: '[![8](assets/8.png)](#co_working_with_records_CO6-8)'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '[![8](assets/8.png)](#co_working_with_records_CO6-8)'
- en: Finally, create the immutable object by calling `build()`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过调用 `build()` 创建不可变对象。
- en: It’s sensible to increase the adhesion between the type and its builder by placing
    the builder class directly in the corresponding type as a `static` nested class,
    as seen in [Example 5-6](#_02-data-structures_records_builder-nested).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 将构建器类直接放置在相应类型中作为 `static` 嵌套类，可以增强类型与其构建器之间的黏合度，如在 [Example 5-6](#_02-data-structures_records_builder-nested)
    中所示。
- en: Example 5-6\. Nested Builder
  id: totrans-181
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-6\. 嵌套构建器
- en: '[PRE22]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: It might seem non-sensical to use a Record to achieve simplicity and immutability
    but still introduce the complexity of a builder. Why not use a full-fledged bean
    instead? Because even with the complexity of the builder, the concerns of creating
    and using the data are separate. The Record is still usable without the builder,
    but the builder provides an additional and flexible way to create a Record instance.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 使用记录来实现简单性和不可变性似乎是没有意义的，但仍然引入了构建器的复杂性。为什么不使用一个完整的 bean 呢？因为即使有构建器的复杂性，创建和使用数据的关注点是分开的。即使没有构建器，记录仍然可用，但构建器提供了创建记录实例的额外灵活方式。
- en: Use-Cases and Common Practices
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用例和常见实践
- en: Records save you a lot of boilerplate code, and with a few additions, you can
    supercharge them into an even more flexible and versatile tool.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Records 节省了大量样板代码，只需稍作增加，即可将它们升级为更加灵活和多功能的工具。
- en: Record Validation and Data Scrubbing
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记录验证和数据清理
- en: 'As shown in [“Canonical, Compact, and Custom Constructors”](#_01-immutables_records_custom-compact-constructor),
    Records support a *compact constructor* that behaves differently from a *normal*
    constructor. You have access to all components of the canonical constructor, but
    it doesn’t have any arguments. It gives you a location to put any *additional*
    code required for the initialization process without needing to assign the components
    yourself. That makes it the perfect place to put any validation and data-scrubbing
    logic:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如在 [“规范、紧凑和自定义构造函数”](#_01-immutables_records_custom-compact-constructor) 中所示，Records
    支持与 *普通* 构造函数行为不同的 *紧凑构造函数*。您可以访问规范构造函数的所有组件，但它没有任何参数。它为初始化过程中需要放置的任何 *附加* 代码提供了一个位置，而无需自行分配组件。这使得它成为放置任何验证和数据清理逻辑的理想位置：
- en: '[PRE23]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Throwing exceptions is one way to go. Another option is to *scrub* the data
    and adjust component values with sensible alternatives to form a valid Record:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 抛出异常是一种选择。另一种选项是*清洗*数据，并使用合理的替代方案调整组件值，以形成有效的记录：
- en: '[PRE24]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Moving a certain degree of logic, like the normalization of out-of-range values,
    directly into a Record gives you more consistent data representations, regardless
    of the initial data. Another approach is requiring such data scrubbing beforehand
    and restricting a Record to do only *hard* validation by throwing a proper exception.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 将某些逻辑（例如越界值的归一化）直接移入记录中可以提供更一致的数据表示，不受初始数据的影响。另一种方法是要求事先进行此类数据清洗，并通过抛出适当的异常来限制记录仅进行*严格*验证。
- en: Increasing Immutability
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 增加不可变性
- en: In [“Immutable Collections”](ch04.xhtml#_02-data-structures_immutable-collections)
    you learned about the problem with shallow immutability in collections. A shallowly
    immutable data structure has an immutable reference, but the data it refers to
    is still mutable. The same underlying problems of unexpected changes must also
    be considered with non-inherently immutable Record components. An easy way to
    minimize any changes in Record components is by trying to increase the level of
    immutability by copying or rewrapping them.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在[“不可变集合”](ch04.xhtml#_02-data-structures_immutable-collections)中，您了解到集合中浅不可变性的问题。浅不可变数据结构具有不可变引用，但其引用的数据仍可变。必须考虑到与非固有不可变记录组件相同的意外更改问题。通过尝试通过复制或重新包装来增加不可变性的级别是减少记录组件中任何更改的简单方法。
- en: 'You can use the canonical constructor to create immutable copies of a component:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用规范构造函数创建组件的不可变副本：
- en: '[PRE25]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The call to `Collections.unmodifiableList` creates a memory-wise lean but unmodifiable
    view of the original `List`. This prevents changes to the Record’s component but
    can’t control changes to the underlying `List` via the original reference. A greater
    level of immutability can be achieved by using the Java 10+ method `List.copy(Collection<?
    extends E> coll)` to create a deep copy independent from the original reference.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`Collections.unmodifiableList`创建了原始`List`的内存节省但不可修改的视图。这可以防止对记录组件的更改，但无法通过原始引用控制对底层`List`的更改。通过使用Java
    10+的方法`List.copy(Collection<? extends E> coll)`可以实现更高级别的不可变性，创建与原始引用独立的深层副本。
- en: Creating Modified Copies
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建修改副本
- en: Even though the declaration of Records is as minimal as it gets, creating a
    slightly modified copy is a DIY job without any help from the JDK.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 即使记录的声明尽可能简化，创建稍作修改的副本仍然需要您自己动手，而无需依赖JDK的任何帮助。
- en: 'There are multiple approaches to creating modified copies if you don’t want
    to do it completely manually:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不想完全手动执行，创建修改副本有多种方法：
- en: Wither methods
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Wither 方法
- en: Builder pattern
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建器模式
- en: Tool-assisted
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工具辅助
- en: Reflection
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反射
- en: Wither Methods
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Wither 方法
- en: '*Wither methods* follow the name scheme `with[componentName]([Type] value)`.
    They’re similar to setters, but return a new instance instead of modifying the
    current one:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '*Wither 方法* 遵循命名方案 `with[componentName]([Type] value)`。它们类似于设置器，但返回一个新实例而不是修改当前实例：'
- en: '[PRE26]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'A nested Record is a handy way to separate the modification logic from the
    actual Record:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套记录是将修改逻辑与实际记录分离的便捷方式：
- en: '[PRE27]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The original Record only has one additional method, and all mutator/copy methods
    are encapsulated in the `With` type.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 原始记录只有一个额外的方法，并且所有的变异器/复制方法都封装在`With`类型中。
- en: The most obvious downside of wither-methods, like default values in [“Component
    Default Values and Convenience Constructors”](#_02-records_default-values), is
    the requirement to write a method for each component. Restricting your code to
    the most common scenarios is sensible, and only add new methods as required.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 像[“组件默认值和便捷构造函数”](#_02-records_default-values)中的默认值一样，wither 方法的最明显缺点是需要为每个组件编写一个方法。将代码限制在最常见的场景中是明智的，只在需要时添加新方法。
- en: Builder Pattern
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建器模式
- en: 'The builder pattern, as introduced in [“Step-by-Step Creation”](#_01-immutables_step-by-step),
    also allows for easier change management if you add a copy-constructor. Such a
    constructor allows you to initialize the builder with an existing record, make
    the appropriate changes, and create a new record, shown as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 构建器模式，如在[“逐步创建”](#_01-immutables_step-by-step)中介绍的，还允许更容易地管理更改。这样的构造函数允许您使用现有记录初始化构建器，进行适当的更改，并创建一个新的记录，如下所示：
- en: '[PRE28]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This approach shares the same problem as “wither” methods: strong cohesion
    between the components and code needed to create Record copies, making refactoring
    harder. To mitigate, you can use a tool-assisted approach.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法与“wither”方法存在相同的问题：组件之间和创建记录副本所需的代码之间存在强烈的凝聚性，使得重构变得更加困难。为了缓解这一问题，你可以使用辅助工具方法。
- en: Tool-Assisted Builder
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 工具辅助生成器
- en: 'Instead of updating your Record builder classes each time a Record changes,
    you could use an annotation processor to do the work for you. A tool like [RecordBuilder](https://github.com/randgalt/record-builder)
    generates a flexible builder for any Record and all you have to do is add a single
    annotation:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是每次记录更改时更新记录生成器类，你可以使用注解处理器来为你完成这项工作。像[RecordBuilder](https://github.com/randgalt/record-builder)这样的工具会为任何记录生成灵活的生成器，你只需添加一个单一的注解：
- en: '[PRE29]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Any change to the Record’s components will automatically be available in the
    generated builder. A “wither"-based approach is also possible but requires your
    Record to implement an additionally generated interface:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 对记录组件的任何更改将自动在生成的生成器中生效。还可以使用基于“wither”的方法，但需要你的记录实现一个额外生成的接口：
- en: '[PRE30]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Even though using an external tool to complement your Records, or any code,
    can save you a lot of typing, it also comes with some downsides. Depending on
    a tool for an essential part of your project that won’t work without it, creates
    a hard-to-break cohesion between them. Any bugs, security problems, or breaking
    changes may affect your code in unforeseen ways, often without the possibility
    of fixing it yourself. Annotation processors integrate themselves into your build
    tools, making them now interrelated, too. So make sure you evaluate such dependencies
    thoroughly^([7](ch05.xhtml#idm45115241795328)) before adding them to your projects.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管使用外部工具来补充你的记录或任何代码可以节省大量输入，但也存在一些缺点。依赖于一个必不可少的项目部分的工具，会在它们之间形成难以打破的凝聚性。任何错误、安全问题或破坏性变更都可能以无法预料的方式影响你的代码，通常没有可能自行修复。注解处理器集成到你的构建工具中，使它们现在也相互关联。因此，请确保在将它们添加到你的项目之前对这些依赖进行彻底评估^([7](ch05.xhtml#idm45115241795328))。
- en: Records as Local Nominal Tuples
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记录作为本地名义元组
- en: 'One type of construct prevalent in many functional programming languages is
    missing in Java: *dynamic tuples*. Programming languages usually use those as
    dynamic data aggregators without requiring an explicitly defined type. Java Records
    are simple data aggregators and can be considered *nominal tuples* in a sense.
    The most significant difference to most tuple implementations is that their contained
    data is held together by an umbrella type due to the Java type system. Records
    aren’t as flexible or interchangeable as other languages’ tuple implementations.
    Still, you can use them as localized *on-the-fly* data aggregators, thanks to
    an addition to Records in Java 15: *local Records*.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 许多函数式编程语言中普遍存在一种构造类型在 Java 中缺失：*动态元组*。编程语言通常使用这些作为动态数据聚合器，而无需显式定义类型。Java 记录是简单的数据聚合器，并且在某种意义上可以被视为*名义元组*。与大多数元组实现最显著的不同之处在于，由于
    Java 类型系统，它们所包含的数据由一个整体类型组合在一起。记录不像其他语言的元组实现那样灵活或可互换。但由于 Java 15 中对记录的一个补充，你可以将其用作本地*即时*数据聚合器：*本地记录*。
- en: 'Contextually localized Records simplify and formalize data processing and bundle
    up functionality. Imagine you have a list of music album titles of the 90s, grouped
    by year as a `Map<Integer, List<String>>`, shown as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在上下文中本地化记录简化和规范化数据处理，并打包功能。想象一下，你有一个90年代的音乐专辑标题列表，按年份分组为`Map<Integer, List<String>>`，如下所示：
- en: '[PRE31]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Working with such a nested and unspecific data structure is quite a hassle.
    Iterating Maps requires using the `entrySet()` method, which returns `Map.Entry<Integer,
    List<String>>` instances in this case. Working with the entries might give you
    access to all the data, but not in an expressive way.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 处理这样的嵌套和不具体的数据结构相当麻烦。迭代 Maps 需要使用`entrySet()`方法，在这种情况下返回`Map.Entry<Integer,
    List<String>>`实例。处理这些条目可能会让你访问所有数据，但表达方式不够直观。
- en: The following code uses a Stream pipeline to create a filter method for the
    music album titles. Even without reading [Chapter 6](ch06.xhtml#_02-data-processing),
    which will explain Streams in detail, most of the code should be straightforward,
    but I’ll guide you through it.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码使用流管道为音乐专辑标题创建了一个过滤方法。即使没有阅读[第6章](ch06.xhtml#_02-data-processing)，该章将详细介绍流，大部分代码也应该很容易理解，但我会指导你完成。
- en: '[PRE32]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[![1](assets/1.png)](#co_working_with_records_CO7-1)'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_working_with_records_CO7-1)'
- en: Filter the entries for albums that are at least the minimum year.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤至少是最小年份的专辑条目。
- en: '[![2](assets/2.png)](#co_working_with_records_CO7-2)'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_working_with_records_CO7-2)'
- en: Sort the title lists by their respective years.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 按其相应年份对标题列表进行排序。
- en: '[![3](assets/3.png)](#co_working_with_records_CO7-3)'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_working_with_records_CO7-3)'
- en: Transform the entry to its actual value.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 将条目转换为其实际值。
- en: '[![4](assets/4.png)](#co_working_with_records_CO7-4)'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_working_with_records_CO7-4)'
- en: The `flatMap` call helps to “flatten” the `List<String>` elements containing
    a year’S titles to singular elements in the pipeline.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`flatMap`调用帮助“展平”包含年份''S标题的`List<String>`元素到管道中的单一元素。'
- en: '[![5](assets/5.png)](#co_working_with_records_CO7-5)'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_working_with_records_CO7-5)'
- en: Collect the elements to a `List<String>`
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 将元素收集到`List<String>`中
- en: Each Stream operation has to deal with `getKey()` or `getValue()` instead of
    expressive names representing the actual data in its context. That’s why introducing
    a local Record as an intermediate type allows you to regain expressiveness in
    complex data processing tasks, like Stream pipelines, but any data processing
    can benefit from more expressiveness. You can even move parts of the logic into
    the Record to use method references or single calls for each operation.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 每个流操作都必须处理`getKey()`或`getValue()`，而不是在其上下文中表示实际数据的具有表达性的名称。这就是为什么引入本地 Record
    作为中间类型允许您在复杂的数据处理任务（如流管道）中恢复表达能力的原因，但任何数据处理都可以从更多的表达性中受益。您甚至可以将部分逻辑移到 Record 中，以便为每个操作使用方法引用或单个调用。
- en: 'Think about the form of the data you *have*, and how it *should* be represented,
    and design your Record accordingly. Next, you should refactor complex data processing
    tasks into Record methods. Possible candidates are:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑你*拥有*数据的形式，以及它*应该*如何表示，然后相应地设计你的 Record。接下来，你应该将复杂的数据处理任务重构为 Record 方法。可能的候选者包括：
- en: Creating the Record from a `Map.Entry` instance.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`Map.Entry`实例创建 Record。
- en: Filtering by year
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按年份筛选
- en: Sorting by year.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按年份排序。
- en: 'The following Record code shows implementations of these tasks:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的 Record 代码展示了这些任务的实现：
- en: '[PRE33]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[![1](assets/1.png)](#co_working_with_records_CO8-1)'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_working_with_records_CO8-1)'
- en: The Record components reflect how you want to access the data with more expressive
    names.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: Record 组件反映了你希望如何使用更具表达性的名称访问数据。
- en: '[![2](assets/2.png)](#co_working_with_records_CO8-2)'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_working_with_records_CO8-2)'
- en: An additional constructor allows using a method reference to create new instances.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 另外的构造方法允许使用方法引用来创建新实例。
- en: '[![3](assets/3.png)](#co_working_with_records_CO8-3)'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_working_with_records_CO8-3)'
- en: If a task depends on an out-of-scope variable, it should be defined as `static`
    helpers.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任务依赖于超出范围的变量，则应定义为`static`辅助程序。
- en: '[![4](assets/4.png)](#co_working_with_records_CO8-4)'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_working_with_records_CO8-4)'
- en: Sorting should be done either by creating a `static` helper method returning
    a `Comparator`, or your Record could implement the `Comparable` interface instead
    if only a single sort needs to be supported.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 排序应通过创建返回 `Comparator` 的`static`辅助方法来完成，或者如果只需要支持单一排序，则你的 Record 可以实现`Comparable`接口。
- en: The Record `AlbumsPerYear` is specifically designed for the Stream pipeline
    of the `filterAlbums` method and should only be available in its scope. The local
    context confines the record, denying it access to surrounding variables. All nested
    records are implicitly `static` to prevent state leaking into it through the surrounding
    class. [Example 5-7](#_02-records_localized-records-final-example) shows how the
    Record lives in the method and how the Record improves the overall code.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: Record `AlbumsPerYear`专门为`filterAlbums`方法的流管道设计，并且只应在其作用域内可用。本地上下文限制了 Record，阻止它通过周围类中的状态泄漏。所有嵌套的
    Record 都是隐式`static`的，以防止状态通过周围类泄漏到其中。[示例 5-7](#_02-records_localized-records-final-example)展示了
    Record 如何存在于方法中，以及 Record 如何改进整体代码。
- en: Example 5-7\. Stream pipeline with localized Record
  id: totrans-254
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-7\. 本地化 Record 的流管道
- en: '[PRE34]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[![1](assets/1.png)](#co_working_with_records_CO9-1)'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_working_with_records_CO9-1)'
- en: The localized Record is directly declared in the method, restricting its scope.
    I didn’t repeat the actual implementation for readability reasons.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 本地化 Record 直接在方法中声明，限制了其作用域。出于可读性考虑，我没有重复实际的实现。
- en: '[![2](assets/2.png)](#co_working_with_records_CO9-2)'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_working_with_records_CO9-2)'
- en: The first operation of the Stream pipeline is to transform the `Map.Entry` instance
    into the local Record type.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 流管道的第一个操作是将`Map.Entry`实例转换为本地 Record 类型。
- en: '[![3](assets/3.png)](#co_working_with_records_CO9-3)'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_working_with_records_CO9-3)'
- en: Each subsequent operation uses an expressive method of the localized Record,
    either directly or as a method reference, instead of an explicit lambda expression.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 每个后续操作使用本地记录的表达式方法，可以直接使用，也可以作为方法引用使用，而不是显式的lambda表达式。
- en: '[![4](assets/4.png)](#co_working_with_records_CO9-6)'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_working_with_records_CO9-6)'
- en: Some operations are harder to refactor, like `flatMap`, because the overall
    processing logic of the Stream dictates their use.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 有些操作很难重构，比如 `flatMap`，因为流的整体处理逻辑决定了它们的使用。
- en: As you can see, using a local Record is an excellent way to improve the ergonomics
    and expressiveness of a declarative Stream pipeline without exposing the type
    outside of its apparent scope.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，使用本地记录是改善声明性流水线的人机工程学和表现力的极好方法，而不会暴露类型超出其明显范围。
- en: Better Optional Data Handling
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更好的可选数据处理
- en: Dealing with optional data and possible `null` values is the bane of every Java
    developer. One option is using the Bean Validation API, as shown in [“Record Validation
    and Data Scrubbing”](#_02-records_validation), and annotating each component with
    `@NonNull` and `@Nullable`, although this approach requires a dependency. If you
    want to stay within the JDK, Java 8 eased the pain of `null`-handling by introducing
    the `Optional<T>` type, which you will learn more about in [Chapter 9](ch09.xhtml#_02-optionals).
    For now, all you need to know is that it’s a container type for possible `null`-values,
    so even if the value is `null`, you can still interact with the container without
    causing a `NullPointerException`.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 处理可选数据和可能的 `null` 值是每个Java开发人员的苦恼。一种选择是使用Bean验证API，如 [“记录验证和数据清洗”](#_02-records_validation)
    中所示，并用 `@NonNull` 和 `@Nullable` 注解每个组件，尽管这种方法需要依赖。如果你想留在JDK内部，Java 8通过引入 `Optional<T>`
    类型来简化了 `null` 处理的痛苦，你将在 [第9章](ch09.xhtml#_02-optionals) 中详细了解它。现在，你只需要知道它是一种可能包含
    `null` 值的容器类型，因此即使值是 `null`，你仍然可以与容器交互，而不会引发 `NullPointerException`。
- en: 'The `Optional` type clearly signifies that a component is optional, but it
    requires a little more code than just changing the type to be an effective tool.
    Let’s add an optional group to our `User` type example from earlier in this chapter:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '`Optional` 类型清楚地表示一个组件是可选的，但它需要比仅仅更改类型更多的代码才能成为一个有效的工具。让我们在本章早些时候的 `User` 类型示例中添加一个可选组：'
- en: '[PRE35]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Even though an `Optional<String>` is used to store the user’s group, you still
    have to deal with the possibility of receiving `null` for the container itself.
    A better option would be accepting `null` for the value itself but still having
    an `Optional<String>` component. With Records reflecting their definition with
    their accessors 1:1, two additional steps are necessary to make Records safe and
    more convenient to use with optional components.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 即使使用 `Optional<String>` 存储用户的组，你仍然必须处理可能为整个容器接收到 `null` 的可能性。更好的选择是接受值本身为 `null`，但仍然具有
    `Optional<String>` 组件。随着记录反映它们的定义及其访问器1:1的定义，为了更安全和更方便地使用具有可选组件的记录，还需要进行两个额外的步骤。
- en: Ensure non-null Container
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 确保非空容器
- en: 'The first step to making Records safer and more convenient to use with optional
    components is to ensure that the `Optional<String>` won’t be `null` and, therefore,
    ruin the idea behind having it. The easiest way is to validate it with a compact
    constructor:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 要使记录更安全和更方便使用可选组件的第一步是确保 `Optional<String>` 不会为 `null`，从而破坏它的设计理念。最简单的方法是使用紧凑的构造函数验证它：
- en: '[PRE36]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The most apparent problem is averted by moving a possible `NullPointerException`
    from using the component accessor to the moment of creating the Record itself,
    making it safer to use.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 最明显的问题是通过将可能的 `NullPointerException` 从组件访问器移到创建记录本身的时刻来避免，从而使其更安全地使用。
- en: Add Convenience Constructors
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加便利构造函数
- en: 'The second thing to make Records safer and more convenient to use is providing
    additional constructors with non-optional arguments and creating the container
    type yourself:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 使记录更安全和更方便使用的第二步是提供带有非可选参数的额外构造函数，并自己创建容器类型：
- en: '[PRE37]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Code completion will show both constructors, indicating the optionality of the
    `group` component.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 代码完成将显示两个构造函数，指示 `group` 组件的可选性。
- en: The combination of validation at Record creations and a convenience constructor
    gives flexibility to the creator of a Record and safer use to anyone consuming
    it.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在记录创建时进行验证，并提供便利的构造函数，既给记录的创建者带来了灵活性，也让任何消费者能够更安全地使用它。
- en: Serializing Evolving Records
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 序列化不断发展的记录
- en: Records, like classes, are automatically serializable if they implement the
    empty marker interface `java.io.Serializable`. The serialization process of Records
    follows a more flexible and safer serialization strategy compared to classes,
    though, without requiring any additional code.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未显式提及，Records 与类一样，如果实现了空标记接口`java.io.Serializable`，则会自动可序列化。与类相比，Records
    的序列化过程遵循更灵活和更安全的策略，无需任何额外的代码。
- en: Note
  id: totrans-281
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The full serialization process consists of *serialization* (converting an object
    to a byte stream) and *deserialization* (reading an object from a byte stream).
    If not explicitly mentioned, serialization describes the whole process, not only
    the first aspect.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的序列化过程包括*序列化*（将对象转换为字节流）和*反序列化*（从字节流中读取对象）。如果没有明确提到，序列化描述的是整个过程，而不仅仅是第一个方面。
- en: Serialization of ordinary, non-Record objects relies heavily on costly^([8](ch05.xhtml#idm45115240641328))
    reflection to access their private state. This process is customizable by implementing
    the `private` methods `readObject` and `writeObject` in a type. These two methods
    aren’t provided by any interface but are still part of the [Java Object Serialization
    Specification](https://docs.oracle.com/en/java/javase/17/docs/specs/serialization/serial-arch.xhtml).
    They’re hard to get right and have led to many exploits in the past^([9](ch05.xhtml#idm45115240638480)).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 对于普通的非 Record 对象，序列化依赖于昂贵的^([8](ch05.xhtml#idm45115240641328)) 反射来访问它们的私有状态。这个过程可以通过在类型中实现`private`方法`readObject`和`writeObject`进行定制。这两个方法没有由任何接口提供，但仍然属于[Java对象序列化规范](https://docs.oracle.com/en/java/javase/17/docs/specs/serialization/serial-arch.xhtml)的一部分。它们难以正确实现，并且过去已经导致了许多漏洞^([9](ch05.xhtml#idm45115240638480))。
- en: 'Records are only defined by their immutable state, represented by their components.
    Without any code being able to affect the state after creation, the serialization
    process is quite simple:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: Record 仅由其不可变状态定义，由其组件表示。在创建后没有任何代码能够影响状态的情况下，序列化过程非常简单：
- en: Serialization is based solely on the Record’s components.
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序列化仅基于 Record 的组件。
- en: Deserialization only requires the canonical constructor, not reflection.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反序列化只需要使用规范构造函数，而不需要反射。
- en: Once the JVM derives the serialized form of a Record, a matching instantiator
    can be cached. Customizing that process isn’t possible, which actually leads to
    a safer serialization process by giving the JVM back control of the Record’s serialized
    representation. This allows any Record type to evolve further by adding new components
    and still successfully deserializing from previously serialized data. Any unknown
    component encountered during deserialization without a value present will automatically
    use its *default value* (e.g., `null` for object-based types, `false` for `boolean`,
    etc.).
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 JVM 推导出 Record 的序列化形式，匹配的实例化程序就可以被缓存。无法定制这个过程，这实际上通过让 JVM 重新控制 Record 的序列化表示来实现更安全的序列化过程。这允许任何
    Record 类型通过添加新组件继续演变，并且仍然可以成功地从之前序列化的数据中反序列化。在反序列化过程中遇到的任何未知组件，如果没有提供值，将自动使用其*默认值*（例如，对象类型为`null`，`boolean`类型为`false`等）。
- en: Warning
  id: totrans-288
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Be aware that the code examples for serialization won’t work as expected when
    using JShell. The internal class names won’t be identical after replacing the
    Record definition, so the types won’t match.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在使用 JShell 时，序列化的代码示例不会按预期工作。替换 Record 定义后，内部类名称将不会相同，因此类型将无法匹配。
- en: 'Let’s say you have a two-dimensional `record Point(float x, float y)` that
    you want to serialize. The following code doesn’t hold any surprises:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个二维的`record Point(float x, float y)`需要进行序列化。以下代码不会带来任何意外：
- en: '[PRE38]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: As requirements change, you need to include the third dimension to the Record,
    `z`, as shown in the following code.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 随着需求变化，你需要将 Record 添加第三个维度 `z`，如下面的代码所示。
- en: '[PRE39]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: What will happen if you try to deserialize the `point.data` file into the changed
    Record? Let’s find out!
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 如果尝试将`point.data`文件反序列化为已更改的 Record，会发生什么？我们来看看吧！
- en: '[PRE40]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: It just works.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 它只是起作用。
- en: The new component, that’s missing from the serialized representation in `points.data`
    and therefore can’t provide a value for the Record’s canonical constructor, is
    initialized with the corresponding default value for its type, in this case, `0`
    (zero) for an `int`.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 新组件，在`points.data`的序列化表示中缺失，因此无法为 Record 的规范构造函数提供值，将会使用其类型的相应默认值进行初始化，在这种情况下，为`int`类型，初始化为`0`（零）。
- en: As mentioned in [“Records”](ch04.xhtml#_02-data-structures_records), Records
    are effectively nominal tuples, making them solely based on their components’
    names and types, not their exact order. That’s why even changing the components’
    order won’t break its deserialization capabilities.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [“Records”](ch04.xhtml#_02-data-structures_records) 所述，Records 实际上是名义上的元组，仅基于其组件的名称和类型，而不是其确切的顺序。这就是为什么即使改变组件的顺序也不会破坏其反序列化能力。
- en: '[PRE41]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Removing components is also possible, as any missing component is ignored during
    deserialization.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 移除组件也是可能的，因为在反序列化过程中会忽略任何缺失的组件。
- en: One general caveat exists, though.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，还存在一个普遍的警告。
- en: 'From the viewpoint of a single Record, they’re solely defined by their components.
    For the Java serialization process, though, the type of what’s serialized is relevant,
    too. That’s why even if two Records have identical components, they’re not interchangeable.
    You will encounter a `ClassCastException` if you try to deserialize into another
    type with identical components:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 从单个 Record 的视角来看，它们仅由它们的组件定义。然而，对于 Java 序列化过程，被序列化的类型也很重要。这就是为什么即使两个 Records
    有相同的组件，它们也不能互换。如果尝试将其反序列化为具有相同组件的其他类型，则会遇到 `ClassCastException`：
- en: '[PRE42]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The incompatibility of serializing different types with identical components
    is a side-effect of the “simpler but safer” serialization process used by Records.
    Without the possibility of manually affecting the serialization process like in
    traditional Java objects, you might need to migrate already serialized data. The
    most straightforward approach would be deserializing the old data into the old
    type, converting it to the new type, and serializing it as the new type.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 不同类型的序列化不兼容性是 Records 使用的 “更简单但更安全” 序列化过程的副作用。由于不能像传统 Java 对象那样手动影响序列化过程，您可能需要迁移已经序列化的数据。最直接的方法是将旧数据反序列化为旧类型，将其转换为新类型，并将其序列化为新类型。
- en: Record Pattern Matching (Java 19+)
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记录模式匹配 (Java 19+)
- en: 'Even though this book is targeted at Java 11 while trying to be helpful with
    a few newer additions, I want to tell you about an upcoming feature still in development
    at the time of writing: *Record-based pattern matching* ([JEP 405](https://openjdk.java.net/jeps/405)).'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 即使本书针对的是 Java 11，并试图帮助理解一些新添加的功能，我还是想告诉你一个在写作时仍在开发中的即将推出的功能：*基于记录的模式匹配* ([JEP
    405](https://openjdk.java.net/jeps/405))。
- en: Note
  id: totrans-307
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: JDK preview features are new features of the Java language, JVM, or the Java
    API that are fully specified, implemented, and yet impermanent. The general idea
    is to gather feedback on real-world use so that the feature might become permanent
    in a future release.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: JDK 预览功能是 Java 语言、JVM 或 Java API 的新功能，完全指定、实现但是暂时的。一般的想法是收集实际使用的反馈，以便该功能可能在将来的版本中成为永久性的。
- en: 'Java 16 introduced pattern matching for the `instanceof` operator^([10](ch05.xhtml#idm45115240119152)),
    removing the necessity of a cast after using the operator:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: Java 16 引入了 `instanceof` 操作符的模式匹配^([10](ch05.xhtml#idm45115240119152))，在使用操作符后不再需要强制转换：
- en: '[PRE43]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Java 17 and 18 expanded on the idea by enabling pattern matching for the `switch`
    expressions^([11](ch05.xhtml#idm45115240034992)) as a preview feature:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: Java 17 和 18 扩展了这个想法，通过启用 `switch` 表达式的模式匹配作为预览功能^([11](ch05.xhtml#idm45115240034992))：
- en: '[PRE44]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Java 19+ includes both these features for Records, too, including destructuring^([12](ch05.xhtml#idm45115239984864)),
    which means a Record’s components are directly available as variables in the scope:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: Java 19+ 也包括了这些 Records 的功能，包括解构^([12](ch05.xhtml#idm45115239984864))，这意味着 Record
    的组件可以直接作为变量在作用域中使用：
- en: '[PRE45]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: As you can see, Records are still evolving with exciting new features like pattern
    matching improving their feature set, making it a more versatile and flexible
    data aggregator type that simplifies your code.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，Records 仍在演变，具有像模式匹配这样的新功能，这些功能增强了其功能集，使其成为一种更多才多艺、灵活的数据聚合类型，简化了你的代码。
- en: Final Thoughts on Records
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于 Records 的最终想法
- en: Java’s new data aggregator type, Records, provides a great deal of simplicity
    with as little code as possible. It’s achieved by adhering to specific rules and
    restrictions, which might seem arbitrary and confining initially, but it gives
    you safer and more consistent use. Records aren’t supposed to be a “one-size-fits-all”
    solution for data storage and state to completely replace all POJOs or other pre-existing
    data-aggregator types. They’re merely providing a new option fitting for a more
    functional and immutable approach.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: Java的新数据聚合类型Records通过尽可能少的代码提供了极大的简化。这是通过遵循特定的规则和限制来实现的，这些规则和限制最初可能看起来是武断和约束的，但它确实提供了更安全和一致的使用方式。Records并不打算成为“一刀切”解决方案，完全替代所有POJOs或其他现有的数据聚合类型。它们仅仅提供了一个适合更功能化和不可变方法的新选项。
- en: The available feature set was chosen deliberately to create a new type of state
    representation, and *only* state. The simplicity of defining a new Record discourages
    the reuse of an abstraction type just because it might be more convenient than
    creating a new and more fitting one.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的功能集是有意选择的，以创建一种新类型的状态表示，*仅限于*状态。定义新记录的简单性不鼓励重用抽象类型，仅仅因为它可能比创建新的更合适的类型更方便。
- en: Records might not be as flexible as POJOs or custom types. But flexibility usually
    means more complexity, which often increases bug surface. The best way to deal
    with complexity is to reduce its surface as much as possible, and Records give
    you a lot of safe functionality “for free” and won’t break as easily if their
    components evolve.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 记录可能不像POJOs或自定义类型那样灵活。但灵活性通常意味着更多复杂性，这往往会增加错误的可能性。处理复杂性的最佳方式是尽量减少其表面，并且如果记录的组件发生变化，它们不容易被破坏。
- en: Takeaways
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 要点
- en: Records are transparent data aggregator types solely defined by their components.
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录（Records）是由它们的组件定义的透明数据聚合类型。
- en: Most features you’re used to from classes, like implementing interfaces, generics,
    or annotations, are usable with Records, too.
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数类特有的功能，如实现接口、泛型或注解，也可以在Records中使用。
- en: The typical boilerplate for a canonical constructor, component accessors, object
    identity, and object description is available in any Record type without additional
    code. If necessary, you can override each one of them.
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何记录类型都可以获得规范构造函数、组件访问器、对象标识和对象描述的典型样板代码，而无需额外的代码。如有必要，您可以覆盖每一个。
- en: Records have certain restrictions to ensure their safe and simplistic use. Many
    of the missing features — at least compared to more flexible solutions like POJOs
    or JavaBeans — can be retrofitted with either JDK-only code or tools like annotation
    processing.
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录具有某些限制，以确保其安全和简单的使用。与POJOs或JavaBeans等更灵活的解决方案相比，许多缺失的功能可以通过仅限于JDK的代码或注解处理工具来补充。
- en: Adhering to common practices like validation and a systematic approach to modified
    copies creates a consistent user experience.
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遵循诸如验证和系统化修改副本的常见做法，可以创建一致的用户体验。
- en: Records provide a safer and more flexible serialization solution than their
    class-based brethren.
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录提供了比基于类的兄弟更安全和更灵活的序列化解决方案。
- en: ^([1](ch05.xhtml#idm45115246956000-marker)) A JDK preview feature is a feature
    whose design, specification, and implementation are complete, but is not permanent.
    It’s supposed to gather feedback from the community to evolve further. Such a
    feature may exist in a different form or not at all in future releases.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch05.xhtml#idm45115246956000-marker)) JDK预览功能是设计、规范和实现完备，但不是永久性的功能。它旨在从社区中收集反馈以进一步发展。这样的功能可能在未来的版本中以不同的形式存在或完全不存在。
- en: ^([2](ch05.xhtml#idm45115245303760-marker)) See the Java Language Specification
    [chapter 3.8](https://docs.oracle.com/javase/specs/jls/se16/html/jls-3.xhtml#jls-3.8)
    for the definition of valid Java identifier.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch05.xhtml#idm45115245303760-marker)) 参见Java语言规范 [章节 3.8](https://docs.oracle.com/javase/specs/jls/se16/html/jls-3.xhtml#jls-3.8)，了解有效Java标识符的定义。
- en: ^([3](ch05.xhtml#idm45115245005648-marker)) The word “automagically” describes
    an automatic process that’s hidden from the user and therefore magic-like. Records
    provide their automatic features without additional tools like annotation processors
    or extra compiler plugins.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch05.xhtml#idm45115245005648-marker)) “自动魔法”一词描述了一种自动过程，对用户隐藏，因此类似于魔法。Records提供它们的自动功能，无需额外的工具如注解处理器或额外的编译器插件。
- en: ^([4](ch05.xhtml#idm45115244379264-marker)) To learn more about annotations
    in general and how to use them, you should check out my article [Java Annotations
    Explained](https://belief-driven-design.com/4f54e6e6c3f/).
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch05.xhtml#idm45115244379264-marker)) 要了解更多关于注解的一般信息以及如何使用它们，你应该查看我的文章[Java
    注解解析](https://belief-driven-design.com/4f54e6e6c3f/)。
- en: '^([5](ch05.xhtml#idm45115243333328-marker)) Gamma, E., Helm, R., Johnson, R.,
    & Vlissides, J. (1994). Design patterns: Elements of reusable object-oriented
    software. Addison Wesley.'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '^([5](ch05.xhtml#idm45115243333328-marker)) Gamma, E., Helm, R., Johnson, R.,
    & Vlissides, J. (1994). Design patterns: Elements of reusable object-oriented
    software. Addison Wesley.'
- en: ^([6](ch05.xhtml#idm45115243331312-marker)) The *single responsibility principle*
    is the first of the *SOLID* principles for object-oriented programming. Its five
    principles intend to make OO designs more flexible, maintainable, and straightforward.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch05.xhtml#idm45115243331312-marker)) *单一责任原则* 是面向对象编程中 *SOLID* 原则的第一个。其五个原则旨在使
    OO 设计更灵活、可维护和简单。
- en: ^([7](ch05.xhtml#idm45115241795328-marker)) I’ve written an article about how
    to evaluate dependenices on my [personal blog](https://belief-driven-design.com/e3e769e891b/).
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: ^([7](ch05.xhtml#idm45115241795328-marker)) 我在我的[个人博客](https://belief-driven-design.com/e3e769e891b/)上写了一篇关于如何评估依赖关系的文章。
- en: ^([8](ch05.xhtml#idm45115240641328-marker)) The word “cost” regarding reflection
    is associated with the incurred performance overhead and exposure to security
    problems. Reflection uses dynamically resolved type information, which prevents
    the JVM to utilize all its possible optimizations. Consequently, reflection has
    slower performance than their non-reflective counterparts.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: ^([8](ch05.xhtml#idm45115240641328-marker)) 关于反射的“成本”一词与产生的性能开销和暴露于安全问题有关。反射使用动态解析的类型信息，这导致
    JVM 无法利用其所有可能的优化。因此，反射比它们的非反射对应物具有更慢的性能。
- en: '^([9](ch05.xhtml#idm45115240638480-marker)) The method `readObject` can execute
    arbitrary code instead of simply reading the object. Some related CVEs: [CVE-2019-6503](https://nvd.nist.gov/vuln/detail/CVE-2019-6503),
    [CVE-2019-12630](https://nvd.nist.gov/vuln/detail/CVE-2019-12630), [CVE-2018-1851](https://nvd.nist.gov/vuln/detail/CVE-2018-1851).'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: ^([9](ch05.xhtml#idm45115240638480-marker)) 方法`readObject`可以执行任意代码，而不仅仅是读取对象。一些相关的
    CVE 包括：[CVE-2019-6503](https://nvd.nist.gov/vuln/detail/CVE-2019-6503)，[CVE-2019-12630](https://nvd.nist.gov/vuln/detail/CVE-2019-12630)，[CVE-2018-1851](https://nvd.nist.gov/vuln/detail/CVE-2018-1851)。
- en: ^([10](ch05.xhtml#idm45115240119152-marker)) The extension of the `instanceof`
    operator to support *pattern matching* is summarized in [JEP 394](https://openjdk.java.net/jeps/394).
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: ^([10](ch05.xhtml#idm45115240119152-marker)) 将`instanceof`运算符扩展为支持 *模式匹配* 的概述在
    [JEP 394](https://openjdk.java.net/jeps/394) 中。
- en: ^([11](ch05.xhtml#idm45115240034992-marker)) Pattern Matching for `switch` is
    summarized in [JEP 406](https://openjdk.java.net/jeps/406) and [JEP 430](https://openjdk.java.net/jeps/420).
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: ^([11](ch05.xhtml#idm45115240034992-marker)) `switch` 的模式匹配总结在 [JEP 406](https://openjdk.java.net/jeps/406)
    和 [JEP 430](https://openjdk.java.net/jeps/420) 中。
- en: ^([12](ch05.xhtml#idm45115239984864-marker)) Pattern Matching for Records is
    summarized in [JEP 405](https://openjdk.java.net/jeps/405)
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: ^([12](ch05.xhtml#idm45115239984864-marker)) 记录的模式匹配总结在 [JEP 405](https://openjdk.java.net/jeps/405)
    中。
