- en: Chapter 5\. Working With Records
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Java 14 introduced a new type of data structure as a preview^([1](ch05.xhtml#idm45115246956000))
    feature, which was finalized two releases later: *Records*. They are not just
    another typical Java type or technique you can use. Instead, Records are a completely
    new language feature providing you with a simple but feature-rich data aggregator
    with minimal boilerplate.'
  prefs: []
  type: TYPE_NORMAL
- en: Data Aggregation Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From a general point-of-view, *data aggregation* is the process of gathering
    data from multiple sources and assembling it in a format that better serves the
    intended purpose and more preferable usage. Maybe the most well-known kind of
    data aggregation type is *tuples*.
  prefs: []
  type: TYPE_NORMAL
- en: Tuples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Mathematically speaking, a tuple is a “finite ordered sequence of elements.”
    In terms of programming languages, a tuple is a data structure aggregating multiple
    values or objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two kinds of tuples. *Structural* tuples rely only on the order of
    the contained elements and are therefore only accessible by their indices, as
    seen in the following Python code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '*Nominal* tuples don’t use an index to access their data, but they use component
    names instead, as seen in the following Swift code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In order to demonstrate what Records have to offer, you’ll first have a look
    at how to go from a classical POJO to an immutable one, and then I’ll show you
    how to replicate the same functionality with a Record instead.
  prefs: []
  type: TYPE_NORMAL
- en: A Simple POJO
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, let’s take a look at the “pre-Record” state of data aggregation in Java
    to better grasp what Records have to offer. As an example, we create a simple
    “user” type as a “classic” POJO, evolve it to an “immutable” POJO, and finally,
    a Record. It will be a simple type, with a username, an activity state, a last-login
    timestamp, and the “usual” boilerplate that comes along in typical Java code,
    as seen in [Example 5-1](#_02-data-structures_records_user-pojo-like).
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-1\. Simple User POJO
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_working_with_records_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Constructors aren’t strictly necessary but are added for convenience. If any
    constructor with arguments exists, an explicit “empty” constructor should be added,
    too.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_working_with_records_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: POJOs usually have getters instead of public fields.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_working_with_records_CO1-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The first variant of the `User` type is still mutable due to its setter methods.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_working_with_records_CO1-9)'
  prefs: []
  type: TYPE_NORMAL
- en: Both `hashCode` and `equals` require dedicated implementations that depend on
    the actual structure of the type. Any changes to the type require both methods
    to adapt.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_working_with_records_CO1-10)'
  prefs: []
  type: TYPE_NORMAL
- en: The `toString` method is another convenience addition that isn’t explicitly
    needed. Just like the previous methods, it has to be updated every time the type
    changes.
  prefs: []
  type: TYPE_NORMAL
- en: Including the empty lines and curly braces, that’s ~75 lines for just holding
    three data fields. No wonder one of the most common complaints about Java is its
    verbosity, and “too much ceremony” to do *standard* things!
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s convert it into an immutable POJO.
  prefs: []
  type: TYPE_NORMAL
- en: From POJO to Immutability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Making the `User` POJO immutable reduces the required boilerplate slightly because
    you no longer need any setter methods, as shown in [Example 5-2](#_02-data-structures_records_user-pojo-like_immutable).
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-2\. Simple immutable User type
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_working_with_records_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Without “setters”, the fields can be declared `final`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_working_with_records_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Only a full “pass-through” constructor is possible because the fields must be
    set on object creation.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_working_with_records_CO2-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The “getters” remain unchanged from the mutable variant.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_working_with_records_CO2-6)'
  prefs: []
  type: TYPE_NORMAL
- en: The supporting methods are also unchanged compared to the previous implementation.
  prefs: []
  type: TYPE_NORMAL
- en: By making the type immutable yourself, only the code of the setters and the
    empty constructor could be removed; everything else is still there. That’s still
    quite a lot of code for holding three fields with not much additional functionality.
    Of course, we could remove more of the “ceremony” and use a simple class with
    three `public final` fields and a constructor. Depending on your requirements,
    that might be “just enough.” The additional functionality, however, like equality
    comparison, and a correct `hashCode` so it can be used in a `Set` or `HashMap`,
    or a sensible `toString` output, are all desirable features.
  prefs: []
  type: TYPE_NORMAL
- en: From POJO to Record
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Finally, let’s take a look at a more general, less ceremonial, but still feature-rich
    solution using a Record instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: That’s it.
  prefs: []
  type: TYPE_NORMAL
- en: The `User` Record has the same features as the immutable POJO. How it does so
    much with so little code will be explained in detail in the upcoming sections.
  prefs: []
  type: TYPE_NORMAL
- en: Records to the Rescue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Records are a way to define plain *data aggregator types* that access their
    data components by name in the vein of *nominal tuples*. Like nominal tuples,
    Records aggregate an ordered sequence of values and provide access via names instead
    of indices. Their data is shallowly immutable and transparently accessible. The
    typical boilerplate of other data classes is significantly reduced by generating
    accessors and data-driven methods like `equals` and `hashCode`. Even though the
    final version of [JEP 395](https://openjdk.java.net/jeps/395) explicitly states
    that “war on boilerplate” is a non-goal, it’s still a happy coincidence many developers
    will appreciate.
  prefs: []
  type: TYPE_NORMAL
- en: Being “plain” data aggregator types, there are some missing features compared
    to other options. This chapter will cover each missing feature and how to mitigate
    them, transforming Records into a more flexible solution for your data aggregation
    needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'As seen in the previous section, Records use a new keyword — `record` — to
    delimit them from other classes and enums. The data components are declared like
    a constructor or method arguments directly after the Record’s name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The general syntax for Records breaks down into two parts: a *header* defining
    the same properties as other types, plus its components and an optional *body*
    to support additional constructors and methods.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The header is similar to a `class` or `interface` header and consists of multiple
    parts:'
  prefs: []
  type: TYPE_NORMAL
- en: Visibility
  prefs: []
  type: TYPE_NORMAL
- en: Like a `class`, `enum`, or `interface` definition, a Record supports Java’s
    visibility keywords (`public`, `private`, `protected`).
  prefs: []
  type: TYPE_NORMAL
- en: The record keyword
  prefs: []
  type: TYPE_NORMAL
- en: The keyword `record` distinguishes the header from the other type declarations
    `class`, `enum`, and `interface`.
  prefs: []
  type: TYPE_NORMAL
- en: Name
  prefs: []
  type: TYPE_NORMAL
- en: Naming rules are identical to any other identifier, as defined in the *Java
    Language Specification*⁠^([2](ch05.xhtml#idm45115245303760)).
  prefs: []
  type: TYPE_NORMAL
- en: Generic types
  prefs: []
  type: TYPE_NORMAL
- en: Generic types are supported as with other type declarations in Java.
  prefs: []
  type: TYPE_NORMAL
- en: Data components
  prefs: []
  type: TYPE_NORMAL
- en: The name is followed by a pair of parentheses containing the components of the
    Record. Each one translates into a `private final` field and a `public` accessor
    method behind the scenes. The components list also represents the constructor
    of the Record.
  prefs: []
  type: TYPE_NORMAL
- en: Body
  prefs: []
  type: TYPE_NORMAL
- en: A typical Java body, like any other `class` or `interface`.
  prefs: []
  type: TYPE_NORMAL
- en: An effectively single line of code will be translated by the compiler to a class
    similar to [Example 5-2](#_02-data-structures_records_user-pojo-like_immutable)
    from the previous section. It extends `java.lang.Record` explicitly rather than
    `java.lang.Object` implicitly, just like enums do with `java.lang.Enum`.
  prefs: []
  type: TYPE_NORMAL
- en: Behind The Scenes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The generated class behind any Record gives you quite a lot of functionality
    without writing any additional code. It’s time to take a deeper look at what’s
    actually happening behind-the-scenes.
  prefs: []
  type: TYPE_NORMAL
- en: The JDK includes the command `javap`, which disassembles `.class` files and
    allows you to see the Java corresponding Java code for the bytecode. This way,
    it’s easy to compare the actual difference between the POJO and Record version
    of the `User` type from [“Data Aggregation Types”](#_02-records_data-aggregation-types).
    The combined and cleaned-up output for both variants is shown in [Example 5-3](#_02-data-structures_records_user-javap).
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-3\. Disassembled User.class POJO versus Record
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the resulting classes are identical functionality-wise, only
    the naming of the accessor methods differ. But where did all those methods come
    from? Well, that’s the “magic” of Records, giving you a full-fledged data aggregation
    type without writing more code as absolutely needed.
  prefs: []
  type: TYPE_NORMAL
- en: Record Features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Records are transparent data aggregators with specific guaranteed properties
    and well-defined behavior by automagically^([3](ch05.xhtml#idm45115245005648))
    providing functionality without needing to repeatedly write the following trivial
    boilerplate implementations:'
  prefs: []
  type: TYPE_NORMAL
- en: Component accessors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Three types of constructors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object identity and description methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That’s a lot of functionality without requiring any additional code besides
    the Record declaration. Any missing pieces can be done by augmenting or overriding
    these features as necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s check out Record’s automatic features and how other typical Java features,
    like generics, annotations, and reflection, fit in.
  prefs: []
  type: TYPE_NORMAL
- en: Component Accessors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'All Record components are stored in `private` fields. Inside a Record, its
    fields are directly accessible. “From the outside,” you need to access them through
    the generated `public` accessor methods. The accessor method names correspond
    to their component name without the typical “getter” prefix `get`, as shown in
    the following code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The accessor methods return the corresponding field’s value as-is. Though you
    can override them, as shown in the following code, I wouldn’t recommend it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Records are supposed to be *immutable* data holders, so making decisions while
    accessing its data could be considered a code smell. The creation of a Record
    defines its data, and that’s where any validation or other logic should affect
    the data, as you will learn in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Canonical, Compact, and Custom Constructors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A constructor identical to the Record’s components definition is automatically
    available, called the *canonical* constructor. The Record’s components are assigned
    to the corresponding fields “as-is.” Like component accessors, the canonical constructor
    is overridable to validate input, like `null`-checks, or even manipulate data
    if necessary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: That’s a lot of additional lines for two actual `null`-checks, including redeclaration
    of the constructor signature and assigning the components to the invisible fields.
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, a specialized *compact* form, shown in the following code example,
    is available, and it doesn’t force you to repeat any boilerplate if you don’t
    need it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_working_with_records_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The constructor omits all arguments, including the parentheses.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_working_with_records_CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Field assignments aren’t allowed in the compact canonical constructor, but you
    can customize or normalize data before it’s assigned.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_working_with_records_CO3-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The components will be assigned to their respective fields automatically.
  prefs: []
  type: TYPE_NORMAL
- en: At first, the syntax might look unusual because it omits all arguments, including
    the parentheses. This way, though, it’s clearly distinguishable from an argument-less
    constructor.
  prefs: []
  type: TYPE_NORMAL
- en: The compact constructor is the perfect place to put any validation, as I will
    show you in [“Record Validation and Data Scrubbing”](#_02-records_validation).
  prefs: []
  type: TYPE_NORMAL
- en: Like with classes, you can declare additional constructors, but any custom constructor
    must start with an explicit invocation of the canonical constructor as its first
    statement. That’s quite a restrictive requirement compared to classes, which it
    is. Still, this requirement serves an essential feature I’m going to discuss in
    [“Component Default Values and Convenience Constructors”](#_02-records_default-values).
  prefs: []
  type: TYPE_NORMAL
- en: Object Identity and Description
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Records provide a “standard” implementation for the object identity methods
    `int hashCode()` and `boolean equals(Object)` based on data equality. Without
    an explicit implementation of the two object identity methods, you don’t have
    to worry about updating your code if the Record’s component change. Two instances
    of a Record type are considered equal if the data of their components are equal.
  prefs: []
  type: TYPE_NORMAL
- en: 'The object description method `String toString()` is auto-generated from the
    components, too, giving you a sensible default output, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The object identity and description methods are overridable, too, like component
    accessors and constructors.
  prefs: []
  type: TYPE_NORMAL
- en: Generics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Records also support generics, which follow the “usual” rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Personally, I would advise against overusing generic Records. Using more specific
    Records that more closely match the domain model they represent gives you more
    expressiveness and reduces accidental misuse.
  prefs: []
  type: TYPE_NORMAL
- en: Annotations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Annotations behave a little differently than you might expect if used on a
    Record’s components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: At first glance, `username` looks like a parameter, so a sensible conclusion
    would be that only annotations with `ElementType.PARAMETER` should be possible^([4](ch05.xhtml#idm45115244379264)).
    But with Records and their automagically generated fields and component accessors,
    some special considerations must be made. To support annotating these features,
    any annotations with the targets `FIELD`, `PARAMETER`, or `METHOD`, are propagated
    to the corresponding locations if applied to a component.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the existing targets, the new target `ElementType.RECORD_COMPONENT`
    was introduced for more fine-grained annotation control in Records.
  prefs: []
  type: TYPE_NORMAL
- en: Reflection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To complement Java’s reflection capabilities, Java 16 added the `getRecordComponents`
    method to `java.lang.Class`.. In the case of a Record-based type, the call gives
    you an array of `java.lang.reflect.RecordComponent` objects, or `null` for any
    other type of `Class`. The components are returned in the same order that they
    are declared in the record header, allowing you to look up the canonical constructor
    via `getDeclaredConstructor()` on a Record’s class.
  prefs: []
  type: TYPE_NORMAL
- en: You will find some reflection-based examples in the book’s [code repository](https://github.com/benweidig/a-functional-approach-to-java).
  prefs: []
  type: TYPE_NORMAL
- en: Missing Features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Records are precisely what they are supposed to be: *plain, transparent, shallowly
    immutable data-aggregators*. They provide a plethora of features without writing
    any line of code except their definition. Compared to other available data aggregators,
    they lack some features you might be used to, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Additional State
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (Simple) default values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Step-by-step creation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This section shows you what features are “missing in action” and how to mitigate
    them if possible.
  prefs: []
  type: TYPE_NORMAL
- en: Additional State
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Allowing any additional opaque state is an obvious omission from records. They
    are supposed to be *data-aggregators* representing a transparent state. That’s
    why any additional field added to its body results in a compiler error.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you require more fields than what’s possible with a Record’s components alone,
    Records might not be the data structure your looking for.
  prefs: []
  type: TYPE_NORMAL
- en: 'For some scenarios at least, you could add *derived* state that’s based on
    the existing components, by adding methods to the Records:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Methods can be added because they don’t introduce additional state like a field.
    They have access to `private` fields, guaranteeing verbatim data access even if
    the component accessor is overridden. Which to choose — field or accessor — depends
    on how you design your Record and your personal preference.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Records are `final` types that already extend `java.lang.Record` behind-the-scenes,
    as previously seen in [Example 5-3](#_02-data-structures_records_user-javap).
    Because Java doesn’t allow inheriting more than one type, Records can’t use inheritance.
    That doesn’t mean they can’t implement any interfaces, though. With interfaces,
    you can define Record templates and share common functionality with `default`
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 5-4](#_02-data-structures_records_inheritance) shows how to create
    Records for multiple shapes with the common concept of an origin and a surface
    area.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-4\. Using interfaces with Records as templates
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_working_with_records_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The interface defines the components of an implementing record as simple methods
    with the correct names
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_working_with_records_CO4-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Shared functionality is added with `default` methods.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_working_with_records_CO4-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Method signatures in interfaces must not interfere with any implementing record
    type.
  prefs: []
  type: TYPE_NORMAL
- en: Sharing behavior with interfaces and `default` methods is a straightforward
    approach, as long as all implementees share the interface contract. Interfaces
    can provide a few left-out pieces of the missing inheritance, and it might be
    tempting to create intricate hierarchies and interdependencies between records.
    But structuring your record types this way will create cohesion between them that’s
    not in the original spirit of Records to be simple data aggregators defined by
    their state. The example is over-engineered to illustrate the possibilities of
    multiple interfaces better. In the real world, you would most likely make `Origin`
    a Record, too, and use composition and additional constructors to achieve the
    same functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Component Default Values and Convenience Constructors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Unlike many other languages, Java doesn’t support default values for any constructor
    or method arguments. Records only provide their canonical constructor with all
    components automatically, which can become unwieldy, especially in the case of
    composed data structures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Additional constructors give you an easy way to have sensible default values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_working_with_records_CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The first additional constructor mimics the components of `Origin` to provide
    a more convenient way to create a `Rectangle`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_working_with_records_CO5-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The second one is a convenience constructor by removing the necessity of providing
    an `Origin`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Due to Java’s naming semantics, not all combinations for default values might
    be possible, like `Rectangle(int x, float width, float height)` has an identical
    signature to `Rectangle(int y, float width, float height)`. In this case, using
    `static` factory methods allows you to create any combination you require:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Using `static` Factory methods is a more expressive alternative to custom constructors
    and the only resort with overlapping signatures.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of argument-less constructors, a constant makes more sense:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: First, your code is more expressive with meaningful names for constants. Second,
    only a single instance is created, which is constant anywhere because the underlying
    data structure is immutable.
  prefs: []
  type: TYPE_NORMAL
- en: Step-by-Step Creation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the advantages of immutable data structures is the lack of “half-initialized”
    objects. Still, not every data structure is initializable all at once. Instead
    of using a mutable data structure in such a case, you can use the *builder pattern*
    to get a mutable intermediate variable that’s used to create an eventually immutable
    final result. Even though the builder pattern was incepted as a solution to recurring
    object creation problems in object-oriented programming, it’s also highly beneficial
    for creating immutable data structures in a more functional Java environment.
  prefs: []
  type: TYPE_NORMAL
- en: By separating the construction of the data structure from its representation,
    the data structure itself can be as simple as possible, making the pattern an
    excellent match for Records. Any required logic, or validation, is encapsulated
    into a (multistep-)builder.
  prefs: []
  type: TYPE_NORMAL
- en: The previously used `User` Record can be complemented by a simple builder, as
    shown in [Example 5-5](#_02-data-structures_records_builder).
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-5\. User Builder
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_working_with_records_CO6-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Explicit default values are possible, reducing the required code for creation.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_working_with_records_CO6-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Field that can be changed during building need setter-like methods.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_working_with_records_CO6-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Validation logic is bound to the specific setter-like method and not accumulated
    in any constructor.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_working_with_records_CO6-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Returning `this` creates a fluent API for the builder.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_working_with_records_CO6-5)'
  prefs: []
  type: TYPE_NORMAL
- en: '`Optional` fields can use their explicit types, and only change into an `Optional`
    during `build()`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_working_with_records_CO6-6)'
  prefs: []
  type: TYPE_NORMAL
- en: If you’re done building, calling `build()` will create the actual immutable
    `User` record. Usually, the builder should validate its state if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](assets/7.png)](#co_working_with_records_CO6-7)'
  prefs: []
  type: TYPE_NORMAL
- en: The build process is fluent, and you can pass the builder around like any other
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[![8](assets/8.png)](#co_working_with_records_CO6-8)'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, create the immutable object by calling `build()`.
  prefs: []
  type: TYPE_NORMAL
- en: It’s sensible to increase the adhesion between the type and its builder by placing
    the builder class directly in the corresponding type as a `static` nested class,
    as seen in [Example 5-6](#_02-data-structures_records_builder-nested).
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-6\. Nested Builder
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: It might seem non-sensical to use a Record to achieve simplicity and immutability
    but still introduce the complexity of a builder. Why not use a full-fledged bean
    instead? Because even with the complexity of the builder, the concerns of creating
    and using the data are separate. The Record is still usable without the builder,
    but the builder provides an additional and flexible way to create a Record instance.
  prefs: []
  type: TYPE_NORMAL
- en: Use-Cases and Common Practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Records save you a lot of boilerplate code, and with a few additions, you can
    supercharge them into an even more flexible and versatile tool.
  prefs: []
  type: TYPE_NORMAL
- en: Record Validation and Data Scrubbing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As shown in [“Canonical, Compact, and Custom Constructors”](#_01-immutables_records_custom-compact-constructor),
    Records support a *compact constructor* that behaves differently from a *normal*
    constructor. You have access to all components of the canonical constructor, but
    it doesn’t have any arguments. It gives you a location to put any *additional*
    code required for the initialization process without needing to assign the components
    yourself. That makes it the perfect place to put any validation and data-scrubbing
    logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Throwing exceptions is one way to go. Another option is to *scrub* the data
    and adjust component values with sensible alternatives to form a valid Record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Moving a certain degree of logic, like the normalization of out-of-range values,
    directly into a Record gives you more consistent data representations, regardless
    of the initial data. Another approach is requiring such data scrubbing beforehand
    and restricting a Record to do only *hard* validation by throwing a proper exception.
  prefs: []
  type: TYPE_NORMAL
- en: Increasing Immutability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [“Immutable Collections”](ch04.xhtml#_02-data-structures_immutable-collections)
    you learned about the problem with shallow immutability in collections. A shallowly
    immutable data structure has an immutable reference, but the data it refers to
    is still mutable. The same underlying problems of unexpected changes must also
    be considered with non-inherently immutable Record components. An easy way to
    minimize any changes in Record components is by trying to increase the level of
    immutability by copying or rewrapping them.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the canonical constructor to create immutable copies of a component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The call to `Collections.unmodifiableList` creates a memory-wise lean but unmodifiable
    view of the original `List`. This prevents changes to the Record’s component but
    can’t control changes to the underlying `List` via the original reference. A greater
    level of immutability can be achieved by using the Java 10+ method `List.copy(Collection<?
    extends E> coll)` to create a deep copy independent from the original reference.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Modified Copies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Even though the declaration of Records is as minimal as it gets, creating a
    slightly modified copy is a DIY job without any help from the JDK.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are multiple approaches to creating modified copies if you don’t want
    to do it completely manually:'
  prefs: []
  type: TYPE_NORMAL
- en: Wither methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Builder pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tool-assisted
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reflection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wither Methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Wither methods* follow the name scheme `with[componentName]([Type] value)`.
    They’re similar to setters, but return a new instance instead of modifying the
    current one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'A nested Record is a handy way to separate the modification logic from the
    actual Record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The original Record only has one additional method, and all mutator/copy methods
    are encapsulated in the `With` type.
  prefs: []
  type: TYPE_NORMAL
- en: The most obvious downside of wither-methods, like default values in [“Component
    Default Values and Convenience Constructors”](#_02-records_default-values), is
    the requirement to write a method for each component. Restricting your code to
    the most common scenarios is sensible, and only add new methods as required.
  prefs: []
  type: TYPE_NORMAL
- en: Builder Pattern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The builder pattern, as introduced in [“Step-by-Step Creation”](#_01-immutables_step-by-step),
    also allows for easier change management if you add a copy-constructor. Such a
    constructor allows you to initialize the builder with an existing record, make
    the appropriate changes, and create a new record, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This approach shares the same problem as “wither” methods: strong cohesion
    between the components and code needed to create Record copies, making refactoring
    harder. To mitigate, you can use a tool-assisted approach.'
  prefs: []
  type: TYPE_NORMAL
- en: Tool-Assisted Builder
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Instead of updating your Record builder classes each time a Record changes,
    you could use an annotation processor to do the work for you. A tool like [RecordBuilder](https://github.com/randgalt/record-builder)
    generates a flexible builder for any Record and all you have to do is add a single
    annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Any change to the Record’s components will automatically be available in the
    generated builder. A “wither"-based approach is also possible but requires your
    Record to implement an additionally generated interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Even though using an external tool to complement your Records, or any code,
    can save you a lot of typing, it also comes with some downsides. Depending on
    a tool for an essential part of your project that won’t work without it, creates
    a hard-to-break cohesion between them. Any bugs, security problems, or breaking
    changes may affect your code in unforeseen ways, often without the possibility
    of fixing it yourself. Annotation processors integrate themselves into your build
    tools, making them now interrelated, too. So make sure you evaluate such dependencies
    thoroughly^([7](ch05.xhtml#idm45115241795328)) before adding them to your projects.
  prefs: []
  type: TYPE_NORMAL
- en: Records as Local Nominal Tuples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One type of construct prevalent in many functional programming languages is
    missing in Java: *dynamic tuples*. Programming languages usually use those as
    dynamic data aggregators without requiring an explicitly defined type. Java Records
    are simple data aggregators and can be considered *nominal tuples* in a sense.
    The most significant difference to most tuple implementations is that their contained
    data is held together by an umbrella type due to the Java type system. Records
    aren’t as flexible or interchangeable as other languages’ tuple implementations.
    Still, you can use them as localized *on-the-fly* data aggregators, thanks to
    an addition to Records in Java 15: *local Records*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Contextually localized Records simplify and formalize data processing and bundle
    up functionality. Imagine you have a list of music album titles of the 90s, grouped
    by year as a `Map<Integer, List<String>>`, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Working with such a nested and unspecific data structure is quite a hassle.
    Iterating Maps requires using the `entrySet()` method, which returns `Map.Entry<Integer,
    List<String>>` instances in this case. Working with the entries might give you
    access to all the data, but not in an expressive way.
  prefs: []
  type: TYPE_NORMAL
- en: The following code uses a Stream pipeline to create a filter method for the
    music album titles. Even without reading [Chapter 6](ch06.xhtml#_02-data-processing),
    which will explain Streams in detail, most of the code should be straightforward,
    but I’ll guide you through it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_working_with_records_CO7-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Filter the entries for albums that are at least the minimum year.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_working_with_records_CO7-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Sort the title lists by their respective years.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_working_with_records_CO7-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Transform the entry to its actual value.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_working_with_records_CO7-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The `flatMap` call helps to “flatten” the `List<String>` elements containing
    a year’S titles to singular elements in the pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_working_with_records_CO7-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Collect the elements to a `List<String>`
  prefs: []
  type: TYPE_NORMAL
- en: Each Stream operation has to deal with `getKey()` or `getValue()` instead of
    expressive names representing the actual data in its context. That’s why introducing
    a local Record as an intermediate type allows you to regain expressiveness in
    complex data processing tasks, like Stream pipelines, but any data processing
    can benefit from more expressiveness. You can even move parts of the logic into
    the Record to use method references or single calls for each operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Think about the form of the data you *have*, and how it *should* be represented,
    and design your Record accordingly. Next, you should refactor complex data processing
    tasks into Record methods. Possible candidates are:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Record from a `Map.Entry` instance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering by year
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sorting by year.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following Record code shows implementations of these tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_working_with_records_CO8-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The Record components reflect how you want to access the data with more expressive
    names.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_working_with_records_CO8-2)'
  prefs: []
  type: TYPE_NORMAL
- en: An additional constructor allows using a method reference to create new instances.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_working_with_records_CO8-3)'
  prefs: []
  type: TYPE_NORMAL
- en: If a task depends on an out-of-scope variable, it should be defined as `static`
    helpers.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_working_with_records_CO8-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Sorting should be done either by creating a `static` helper method returning
    a `Comparator`, or your Record could implement the `Comparable` interface instead
    if only a single sort needs to be supported.
  prefs: []
  type: TYPE_NORMAL
- en: The Record `AlbumsPerYear` is specifically designed for the Stream pipeline
    of the `filterAlbums` method and should only be available in its scope. The local
    context confines the record, denying it access to surrounding variables. All nested
    records are implicitly `static` to prevent state leaking into it through the surrounding
    class. [Example 5-7](#_02-records_localized-records-final-example) shows how the
    Record lives in the method and how the Record improves the overall code.
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-7\. Stream pipeline with localized Record
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_working_with_records_CO9-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The localized Record is directly declared in the method, restricting its scope.
    I didn’t repeat the actual implementation for readability reasons.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_working_with_records_CO9-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The first operation of the Stream pipeline is to transform the `Map.Entry` instance
    into the local Record type.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_working_with_records_CO9-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Each subsequent operation uses an expressive method of the localized Record,
    either directly or as a method reference, instead of an explicit lambda expression.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_working_with_records_CO9-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Some operations are harder to refactor, like `flatMap`, because the overall
    processing logic of the Stream dictates their use.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, using a local Record is an excellent way to improve the ergonomics
    and expressiveness of a declarative Stream pipeline without exposing the type
    outside of its apparent scope.
  prefs: []
  type: TYPE_NORMAL
- en: Better Optional Data Handling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Dealing with optional data and possible `null` values is the bane of every Java
    developer. One option is using the Bean Validation API, as shown in [“Record Validation
    and Data Scrubbing”](#_02-records_validation), and annotating each component with
    `@NonNull` and `@Nullable`, although this approach requires a dependency. If you
    want to stay within the JDK, Java 8 eased the pain of `null`-handling by introducing
    the `Optional<T>` type, which you will learn more about in [Chapter 9](ch09.xhtml#_02-optionals).
    For now, all you need to know is that it’s a container type for possible `null`-values,
    so even if the value is `null`, you can still interact with the container without
    causing a `NullPointerException`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Optional` type clearly signifies that a component is optional, but it
    requires a little more code than just changing the type to be an effective tool.
    Let’s add an optional group to our `User` type example from earlier in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Even though an `Optional<String>` is used to store the user’s group, you still
    have to deal with the possibility of receiving `null` for the container itself.
    A better option would be accepting `null` for the value itself but still having
    an `Optional<String>` component. With Records reflecting their definition with
    their accessors 1:1, two additional steps are necessary to make Records safe and
    more convenient to use with optional components.
  prefs: []
  type: TYPE_NORMAL
- en: Ensure non-null Container
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first step to making Records safer and more convenient to use with optional
    components is to ensure that the `Optional<String>` won’t be `null` and, therefore,
    ruin the idea behind having it. The easiest way is to validate it with a compact
    constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The most apparent problem is averted by moving a possible `NullPointerException`
    from using the component accessor to the moment of creating the Record itself,
    making it safer to use.
  prefs: []
  type: TYPE_NORMAL
- en: Add Convenience Constructors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The second thing to make Records safer and more convenient to use is providing
    additional constructors with non-optional arguments and creating the container
    type yourself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Code completion will show both constructors, indicating the optionality of the
    `group` component.
  prefs: []
  type: TYPE_NORMAL
- en: The combination of validation at Record creations and a convenience constructor
    gives flexibility to the creator of a Record and safer use to anyone consuming
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Serializing Evolving Records
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Records, like classes, are automatically serializable if they implement the
    empty marker interface `java.io.Serializable`. The serialization process of Records
    follows a more flexible and safer serialization strategy compared to classes,
    though, without requiring any additional code.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The full serialization process consists of *serialization* (converting an object
    to a byte stream) and *deserialization* (reading an object from a byte stream).
    If not explicitly mentioned, serialization describes the whole process, not only
    the first aspect.
  prefs: []
  type: TYPE_NORMAL
- en: Serialization of ordinary, non-Record objects relies heavily on costly^([8](ch05.xhtml#idm45115240641328))
    reflection to access their private state. This process is customizable by implementing
    the `private` methods `readObject` and `writeObject` in a type. These two methods
    aren’t provided by any interface but are still part of the [Java Object Serialization
    Specification](https://docs.oracle.com/en/java/javase/17/docs/specs/serialization/serial-arch.xhtml).
    They’re hard to get right and have led to many exploits in the past^([9](ch05.xhtml#idm45115240638480)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Records are only defined by their immutable state, represented by their components.
    Without any code being able to affect the state after creation, the serialization
    process is quite simple:'
  prefs: []
  type: TYPE_NORMAL
- en: Serialization is based solely on the Record’s components.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deserialization only requires the canonical constructor, not reflection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the JVM derives the serialized form of a Record, a matching instantiator
    can be cached. Customizing that process isn’t possible, which actually leads to
    a safer serialization process by giving the JVM back control of the Record’s serialized
    representation. This allows any Record type to evolve further by adding new components
    and still successfully deserializing from previously serialized data. Any unknown
    component encountered during deserialization without a value present will automatically
    use its *default value* (e.g., `null` for object-based types, `false` for `boolean`,
    etc.).
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Be aware that the code examples for serialization won’t work as expected when
    using JShell. The internal class names won’t be identical after replacing the
    Record definition, so the types won’t match.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say you have a two-dimensional `record Point(float x, float y)` that
    you want to serialize. The following code doesn’t hold any surprises:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: As requirements change, you need to include the third dimension to the Record,
    `z`, as shown in the following code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: What will happen if you try to deserialize the `point.data` file into the changed
    Record? Let’s find out!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: It just works.
  prefs: []
  type: TYPE_NORMAL
- en: The new component, that’s missing from the serialized representation in `points.data`
    and therefore can’t provide a value for the Record’s canonical constructor, is
    initialized with the corresponding default value for its type, in this case, `0`
    (zero) for an `int`.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned in [“Records”](ch04.xhtml#_02-data-structures_records), Records
    are effectively nominal tuples, making them solely based on their components’
    names and types, not their exact order. That’s why even changing the components’
    order won’t break its deserialization capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Removing components is also possible, as any missing component is ignored during
    deserialization.
  prefs: []
  type: TYPE_NORMAL
- en: One general caveat exists, though.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the viewpoint of a single Record, they’re solely defined by their components.
    For the Java serialization process, though, the type of what’s serialized is relevant,
    too. That’s why even if two Records have identical components, they’re not interchangeable.
    You will encounter a `ClassCastException` if you try to deserialize into another
    type with identical components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The incompatibility of serializing different types with identical components
    is a side-effect of the “simpler but safer” serialization process used by Records.
    Without the possibility of manually affecting the serialization process like in
    traditional Java objects, you might need to migrate already serialized data. The
    most straightforward approach would be deserializing the old data into the old
    type, converting it to the new type, and serializing it as the new type.
  prefs: []
  type: TYPE_NORMAL
- en: Record Pattern Matching (Java 19+)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Even though this book is targeted at Java 11 while trying to be helpful with
    a few newer additions, I want to tell you about an upcoming feature still in development
    at the time of writing: *Record-based pattern matching* ([JEP 405](https://openjdk.java.net/jeps/405)).'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: JDK preview features are new features of the Java language, JVM, or the Java
    API that are fully specified, implemented, and yet impermanent. The general idea
    is to gather feedback on real-world use so that the feature might become permanent
    in a future release.
  prefs: []
  type: TYPE_NORMAL
- en: 'Java 16 introduced pattern matching for the `instanceof` operator^([10](ch05.xhtml#idm45115240119152)),
    removing the necessity of a cast after using the operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Java 17 and 18 expanded on the idea by enabling pattern matching for the `switch`
    expressions^([11](ch05.xhtml#idm45115240034992)) as a preview feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Java 19+ includes both these features for Records, too, including destructuring^([12](ch05.xhtml#idm45115239984864)),
    which means a Record’s components are directly available as variables in the scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, Records are still evolving with exciting new features like pattern
    matching improving their feature set, making it a more versatile and flexible
    data aggregator type that simplifies your code.
  prefs: []
  type: TYPE_NORMAL
- en: Final Thoughts on Records
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java’s new data aggregator type, Records, provides a great deal of simplicity
    with as little code as possible. It’s achieved by adhering to specific rules and
    restrictions, which might seem arbitrary and confining initially, but it gives
    you safer and more consistent use. Records aren’t supposed to be a “one-size-fits-all”
    solution for data storage and state to completely replace all POJOs or other pre-existing
    data-aggregator types. They’re merely providing a new option fitting for a more
    functional and immutable approach.
  prefs: []
  type: TYPE_NORMAL
- en: The available feature set was chosen deliberately to create a new type of state
    representation, and *only* state. The simplicity of defining a new Record discourages
    the reuse of an abstraction type just because it might be more convenient than
    creating a new and more fitting one.
  prefs: []
  type: TYPE_NORMAL
- en: Records might not be as flexible as POJOs or custom types. But flexibility usually
    means more complexity, which often increases bug surface. The best way to deal
    with complexity is to reduce its surface as much as possible, and Records give
    you a lot of safe functionality “for free” and won’t break as easily if their
    components evolve.
  prefs: []
  type: TYPE_NORMAL
- en: Takeaways
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Records are transparent data aggregator types solely defined by their components.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most features you’re used to from classes, like implementing interfaces, generics,
    or annotations, are usable with Records, too.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The typical boilerplate for a canonical constructor, component accessors, object
    identity, and object description is available in any Record type without additional
    code. If necessary, you can override each one of them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Records have certain restrictions to ensure their safe and simplistic use. Many
    of the missing features — at least compared to more flexible solutions like POJOs
    or JavaBeans — can be retrofitted with either JDK-only code or tools like annotation
    processing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adhering to common practices like validation and a systematic approach to modified
    copies creates a consistent user experience.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Records provide a safer and more flexible serialization solution than their
    class-based brethren.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ^([1](ch05.xhtml#idm45115246956000-marker)) A JDK preview feature is a feature
    whose design, specification, and implementation are complete, but is not permanent.
    It’s supposed to gather feedback from the community to evolve further. Such a
    feature may exist in a different form or not at all in future releases.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch05.xhtml#idm45115245303760-marker)) See the Java Language Specification
    [chapter 3.8](https://docs.oracle.com/javase/specs/jls/se16/html/jls-3.xhtml#jls-3.8)
    for the definition of valid Java identifier.
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch05.xhtml#idm45115245005648-marker)) The word “automagically” describes
    an automatic process that’s hidden from the user and therefore magic-like. Records
    provide their automatic features without additional tools like annotation processors
    or extra compiler plugins.
  prefs: []
  type: TYPE_NORMAL
- en: ^([4](ch05.xhtml#idm45115244379264-marker)) To learn more about annotations
    in general and how to use them, you should check out my article [Java Annotations
    Explained](https://belief-driven-design.com/4f54e6e6c3f/).
  prefs: []
  type: TYPE_NORMAL
- en: '^([5](ch05.xhtml#idm45115243333328-marker)) Gamma, E., Helm, R., Johnson, R.,
    & Vlissides, J. (1994). Design patterns: Elements of reusable object-oriented
    software. Addison Wesley.'
  prefs: []
  type: TYPE_NORMAL
- en: ^([6](ch05.xhtml#idm45115243331312-marker)) The *single responsibility principle*
    is the first of the *SOLID* principles for object-oriented programming. Its five
    principles intend to make OO designs more flexible, maintainable, and straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: ^([7](ch05.xhtml#idm45115241795328-marker)) I’ve written an article about how
    to evaluate dependenices on my [personal blog](https://belief-driven-design.com/e3e769e891b/).
  prefs: []
  type: TYPE_NORMAL
- en: ^([8](ch05.xhtml#idm45115240641328-marker)) The word “cost” regarding reflection
    is associated with the incurred performance overhead and exposure to security
    problems. Reflection uses dynamically resolved type information, which prevents
    the JVM to utilize all its possible optimizations. Consequently, reflection has
    slower performance than their non-reflective counterparts.
  prefs: []
  type: TYPE_NORMAL
- en: '^([9](ch05.xhtml#idm45115240638480-marker)) The method `readObject` can execute
    arbitrary code instead of simply reading the object. Some related CVEs: [CVE-2019-6503](https://nvd.nist.gov/vuln/detail/CVE-2019-6503),
    [CVE-2019-12630](https://nvd.nist.gov/vuln/detail/CVE-2019-12630), [CVE-2018-1851](https://nvd.nist.gov/vuln/detail/CVE-2018-1851).'
  prefs: []
  type: TYPE_NORMAL
- en: ^([10](ch05.xhtml#idm45115240119152-marker)) The extension of the `instanceof`
    operator to support *pattern matching* is summarized in [JEP 394](https://openjdk.java.net/jeps/394).
  prefs: []
  type: TYPE_NORMAL
- en: ^([11](ch05.xhtml#idm45115240034992-marker)) Pattern Matching for `switch` is
    summarized in [JEP 406](https://openjdk.java.net/jeps/406) and [JEP 430](https://openjdk.java.net/jeps/420).
  prefs: []
  type: TYPE_NORMAL
- en: ^([12](ch05.xhtml#idm45115239984864-marker)) Pattern Matching for Records is
    summarized in [JEP 405](https://openjdk.java.net/jeps/405)
  prefs: []
  type: TYPE_NORMAL
