<html><head></head><body><section data-pdf-bookmark="Chapter 5. Building Serverless Applications" data-type="chapter" epub:type="chapter"><div class="chapter" id="ch05">&#13;
<h1><span class="label">Chapter 5. </span>Building Serverless Applications</h1>&#13;
&#13;
&#13;
<p>So<a data-primary="serverless applications" data-secondary="overview of" data-type="indexterm" id="idm46222420790056"/> far we’ve talked a lot about Lambda functions—how to program them, how to package and deploy them, how to process input and output, etc.&#13;
One important aspect to Lambda, however, that we haven’t covered much so far, is that Lambda functions are rarely invoked directly from code we write in a different system.&#13;
Instead, for the <em>vast majority</em> of usages of Lambda, we configure an <em>event source</em>, or <em>trigger</em>, that is <em>another AWS service</em>, and let AWS invoke our Lambda function for us.</p>&#13;
&#13;
<p>We looked at a couple of examples of this in <a data-type="xref" href="ch01.html#what_does_a_lambda_application_look_like">“What Does a Lambda Application Look Like?”</a>:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>To implement an HTTP API, we configure AWS API Gateway as the event source.</p>&#13;
</li>&#13;
<li>&#13;
<p>To implement file processing, we configure S3 as the event source.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>There are many different AWS services that directly integrate with Lambda, and even more that integrate indirectly.&#13;
This means that we can build <em>serverless applications</em>, using Lambda as the compute platform, that can perform a vast range of tasks.</p>&#13;
&#13;
<p>In this chapter, we look at how to tie event sources to Lambda and then explore how to build specific types of application with this technique.&#13;
Along the way, you’ll learn more about how to architect, build, package, and deploy Lambda-based&#13;
applications, building on our knowledge from the previous chapter.</p>&#13;
&#13;
<p>If you haven’t done so already, you’ll likely want to download the <a href="https://oreil.ly/8DQe_">example source code</a> before trying any of the examples in this chapter.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Lambda Event Sources" data-type="sect1"><div class="sect1" id="event-sources">&#13;
<h1>Lambda Event Sources</h1>&#13;
&#13;
<p>As<a data-primary="event sources" data-secondary="purpose of" data-type="indexterm" id="idm46222420726520"/><a data-primary="serverless applications" data-secondary="Lambda event sources" data-type="indexterm" id="SAevent05"/> you just learned, the typical usage pattern for Lambda is to tie a function to an event source.&#13;
In this section, we describe the workflow to follow when you build a Lambda function to integrate with a particular upstream service.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Writing Code to Work with Input and Output for Event Sources" data-type="sect2"><div class="sect2" id="code-for-event-sources">&#13;
<h2>Writing Code to Work with Input and Output for Event Sources</h2>&#13;
&#13;
<p>When<a data-primary="event sources" data-secondary="writing code to work with I/O" data-type="indexterm" id="ESio05"/><a data-primary="input/output" data-secondary="writing event source code to work with" data-type="indexterm" id="IOevent05"/> programming a Lambda function to respond to a particular event source, the first thing you’ll typically want to do is understand the format of events that your Lambda function will receive.</p>&#13;
&#13;
<p>The<a data-primary="sam local generate-event command" data-type="indexterm" id="idm46222420771208"/> SAM CLI tool that we’ve already used has an interesting command to help with this exercise—<code>sam local generate-event</code>.&#13;
If you run this command, <code>sam</code> lists all the services it can generate stub events for, which you can then examine and use to drive your code. For example, part of the output for <code>sam local generate-event</code> looks like this:</p>&#13;
&#13;
<pre data-type="programlisting">Commands:&#13;
  alexa-skills-kit&#13;
  alexa-smart-home&#13;
  apigateway&#13;
  batch&#13;
  cloudformation&#13;
  cloudfront&#13;
  cloudwatch&#13;
  codecommit&#13;
  codepipeline</pre>&#13;
&#13;
<p>Let’s say we’re interested in building a serverless HTTP API.&#13;
In this case, we use AWS<a data-primary="API Gateway" data-secondary="as upstream event source" data-type="indexterm" id="idm46222420777544"/> API Gateway as our upstream event source.&#13;
If we run <code>sam local generate-event apigateway</code> the output includes the following:</p>&#13;
&#13;
<pre data-type="programlisting">Commands:&#13;
  authorizer  Generates an Amazon API Gateway Authorizer Event&#13;
  aws-proxy   Generates an Amazon API Gateway AWS Proxy Event</pre>&#13;
&#13;
<p>It turns out that API Gateway can integrate with Lambda in multiple ways.&#13;
The one we typically want from this list is the aws-proxy event, where API Gateway acts as a proxy server in front of a Lambda function, so let’s give that a try.</p>&#13;
&#13;
<pre data-type="programlisting">$ sam local generate-event apigateway aws-proxy&#13;
&#13;
{&#13;
  "body": "eyJ0ZXN0IjoiYm9keSJ9",&#13;
  "resource": "/{proxy+}",&#13;
  "path": "/path/to/resource",&#13;
  "httpMethod": "POST",&#13;
  "isBase64Encoded": true,&#13;
  "queryStringParameters": {&#13;
    "foo": "bar"&#13;
  },&#13;
  ....</pre>&#13;
&#13;
<p>This JSON object is a fully baked sample of a typical event a Lambda function receives from API Gateway.&#13;
In other words, when you set up API Gateway as a trigger for your Lambda function, the event argument that is passed to the Lambda function has this structure.</p>&#13;
&#13;
<p>This sample event doesn’t necessarily help you with the <em>semantics</em> of the integration with API Gateway, but it does give you the shape of the event that your Lambda function receives, which in turn gives you a solid start to writing your code.&#13;
You can use this JSON object as inspiration, or you can take it a step further and actually embed it in a test—more on that in <a data-type="xref" href="ch06.html#ch06">Chapter 6</a>!</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46222420783448">&#13;
<h5>Using the AWS Toolkit</h5>&#13;
<p>We<a data-primary="AWS Toolkit" data-type="indexterm" id="idm46222420781880"/> focus in this book on using the SAM CLI tool to provide various interactions with AWS’s serverless services.&#13;
However, AWS also provides some IDE plug-ins for this purpose, for Jetbrains IntelliJ, Eclipse, VS Code, and more.</p>&#13;
&#13;
<p>The IntelliJ Toolkit pictured in <a data-type="xref" href="#intellij-tools">Figure 5-1</a> is introduced on <a href="https://aws.amazon.com/intellij">its own page</a> on the AWS website.&#13;
It offers a good number of features for Lambda developers.</p>&#13;
&#13;
<figure><div class="figure" id="intellij-tools">&#13;
<img alt="images/ch05_image01.png" src="assets/awsl_0501.png"/>&#13;
<h6><span class="label">Figure 5-1. </span>AWS IntelliJ Toolkit</h6>&#13;
</div></figure>&#13;
&#13;
<p>At the time of this writing, we think that most of these features have a few restrictions that limit its use, but it is worth exploring, and for some of you it might fit well in your workflow.</p>&#13;
&#13;
<p>One feature that we particularly like is the <em>Run (Invoke) the Remote Version of a Function</em> tool. There’s a couple of reasons we like this:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>It offers the same event templates offered by <code>sam local generate-event</code> (see <a data-type="xref" href="#intellij-tools">Figure 5-1</a>).</p>&#13;
</li>&#13;
<li>&#13;
<p>It provides quick access to Lambda logs as you invoke the function running on AWS—this can occasionally be a frustrating thing to do otherwise.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>The Toolkit also offers features to build and deploy Lambda functions/serverless applications, but there are some restrictions here on how your code can be packaged.&#13;
At the time of writing, for example, the Toolkit doesn’t support our recommended workflow for multimodule projects, which we explore later in this chapter.</p>&#13;
&#13;
<p>Finally, the Toolkit enables local debugging of a Lambda function within a “platform-like” environment, which can be useful to an extent, but again you’ll need to be able to work in the constraints of how the tool packages applications.</p>&#13;
</div></aside>&#13;
&#13;
<p>Because you now know the format of the data that your Lambda function receives, you are able to create a handler signature to process this format.&#13;
Remember <a data-type="xref" href="ch03.html#pojos_and_ecosystem_types">“POJOs and Ecosystem Types”</a>? That’s going to come into play now.</p>&#13;
&#13;
<p>One option you have in setting up your handler is to create your own POJO input type that fits the structure of the inbound event but only creates fields for the properties you care about.&#13;
For instance, if you cared only about the <code>path</code> and <code>queryStringParameters</code> properties of the aws-proxy event, you could create a POJO as follows:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kn">package</code> <code class="n">book</code><code class="o">.</code><code class="na">api</code><code class="o">;</code>&#13;
&#13;
<code class="kn">import</code> <code class="nn">java.util.Map</code><code class="o">;</code>&#13;
&#13;
<code class="kd">public</code> <code class="kd">class</code> <code class="nc">APIGatewayEvent</code> <code class="o">{</code>&#13;
  <code class="kd">public</code> <code class="n">String</code> <code class="n">path</code><code class="o">;</code>&#13;
  <code class="kd">public</code> <code class="n">Map</code><code class="o">&lt;</code><code class="n">String</code><code class="o">,</code> <code class="n">String</code><code class="o">&gt;</code> <code class="n">queryStringParameters</code><code class="o">;</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p>A<a data-primary="AWS Lambda Java Events Library" data-type="indexterm" id="idm46222420560360"/> second option is to use a library of types that AWS provides in a Java library precisely for this purpose—the “AWS Lambda Java Events Library.”&#13;
If you use this library, refer to the <a href="https://oreil.ly/5DMvp">documentation</a> and<a data-primary="Maven" data-secondary="Maven Central" data-type="indexterm" id="idm46222420553944"/> look to find the latest versions in <a href="https://oreil.ly/8WvbA">Maven Central</a>.</p>&#13;
&#13;
<p>If<a data-primary="aws-proxy events" data-type="indexterm" id="idm46222420551512"/> you want to use this library to handle aws-proxy events, then you need to first include a library in your Maven dependencies. Add the <code>&lt;dependencies&gt;</code> section to the root of your <em>pom.xml</em> file if it isn’t already there. Otherwise, add this <code>&lt;dependency&gt;</code> subsection to the preexisting <code>&lt;dependencies&gt;</code> section:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;dependencies&gt;</code>&#13;
  <code class="nt">&lt;dependency&gt;</code>&#13;
    <code class="nt">&lt;groupId&gt;</code>com.amazonaws<code class="nt">&lt;/groupId&gt;</code>&#13;
    <code class="nt">&lt;artifactId&gt;</code>aws-lambda-java-events<code class="nt">&lt;/artifactId&gt;</code>&#13;
    <code class="nt">&lt;version&gt;</code>2.2.6<code class="nt">&lt;/version&gt;</code>&#13;
  <code class="nt">&lt;/dependency&gt;</code>&#13;
<code class="nt">&lt;/dependencies&gt;</code></pre>&#13;
&#13;
<p>With that update made, we can use the <a href="https://oreil.ly/S1y95"><code>APIGatewayProxyRequestEvent</code> class</a> as our input POJO.</p>&#13;
&#13;
<p>Now we have a class to represent the event that our Lambda function is going to receive. Next, let’s look at how to perform the same activity for the event that will be our function’s response. As you know from <a data-type="xref" href="ch03.html#input-output">“Input, Output”</a>, this is where POJOs come into play again.</p>&#13;
&#13;
<p>The SAM CLI can’t help us this time, so alternatively you can look up the <a href="https://oreil.ly/RnyUg">AWS documentation</a> to find valid output event structures and generate your own output POJO type, or you can use the AWS Lambda Java Events Library again.&#13;
This time, use the <code>APIGatewayProxyResponseEvent</code> class if responding to an API Gateway proxy event (see <a data-type="xref" href="#api-gateway-proxy-events">“API Gateway Proxy Events”</a>).</p>&#13;
&#13;
<p>Let’s say that you want to build your own POJO class and want to return just an HTTP Status code and a <code>body</code> in the HTTP response. In that case, your POJO might look as follows:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kn">package</code> <code class="n">book</code><code class="o">.</code><code class="na">api</code><code class="o">;</code>&#13;
&#13;
<code class="kd">public</code> <code class="kd">class</code> <code class="nc">APIGatewayResponse</code> <code class="o">{</code>&#13;
  <code class="kd">public</code> <code class="kd">final</code> <code class="kt">int</code> <code class="n">statusCode</code><code class="o">;</code>&#13;
  <code class="kd">public</code> <code class="kd">final</code> <code class="n">String</code> <code class="n">body</code><code class="o">;</code>&#13;
&#13;
  <code class="kd">public</code> <code class="nf">APIGatewayResponse</code><code class="o">(</code><code class="kt">int</code> <code class="n">statusCode</code><code class="o">,</code> <code class="n">String</code> <code class="n">body</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="k">this</code><code class="o">.</code><code class="na">statusCode</code> <code class="o">=</code> <code class="n">statusCode</code><code class="o">;</code>&#13;
    <code class="k">this</code><code class="o">.</code><code class="na">body</code> <code class="o">=</code> <code class="n">body</code><code class="o">;</code>&#13;
  <code class="o">}</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p>Whether you use the AWS-provided POJO types or code them yourself is not a particularly clear-cut choice.&#13;
At the present time, we default to using the AWS library for a couple of reasons:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>While in the past the library has lagged behind significantly with what’s actually available in the Lambda platform, these days AWS does a decent job keeping it up-to-date.</p>&#13;
</li>&#13;
<li>&#13;
<p>Similarly, this library used to bring in a huge number of SDK dependencies, and so would significantly increase the size of your artifact.&#13;
This is much improved now, and the base JAR (which is sufficient for quite a few event sources, including API Gateway and SNS) is less than 100KB.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>That said, coding your own POJOs is a perfectly reasonable approach—it means your deployed artifact will be even smaller, it reduces the number of library dependencies your code has (including transitive dependencies), and it adds a succinctness to your code, aiding maintainability later.&#13;
In this chapter, we give examples of both approaches.</p>&#13;
&#13;
<p>Once your basic Lambda function is coded, it’s time to move on to the next step—configuring the event source for deployment.<a data-primary="" data-startref="ESio05" data-type="indexterm" id="idm46222420431768"/><a data-primary="" data-startref="IOevent05" data-type="indexterm" id="idm46222420430792"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Configuring a Lambda Event Source" data-type="sect2"><div class="sect2" id="idm46222420763112">&#13;
<h2>Configuring a Lambda Event Source</h2>&#13;
&#13;
<p>Just<a data-primary="event sources" data-secondary="configuring Lambda event sources" data-type="indexterm" id="idm46222420428696"/> as there are multiple ways of deploying and configuring a Lambda function (remember that long list of deployment tools from <a data-type="xref" href="ch04.html#lambda-deployment-tools">“Deploy”</a>?), there are multiple ways of configuring an event source.&#13;
However, since in this book we are using SAM to deploy our code, it makes sense, as much as possible, to use SAM to configure our event sources too.</p>&#13;
&#13;
<p>Let’s continue our API Gateway example.&#13;
The simplest way of defining an API Gateway event source in SAM is to update your Lambda function definition in your <em><span class="keep-together">template.yaml</span></em> as follows:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">HelloAPIWorldLambda</code><code class="p">:</code>&#13;
  <code class="nt">Type</code><code class="p">:</code> <code class="l-Scalar-Plain">AWS::Serverless::Function</code>&#13;
  <code class="nt">Properties</code><code class="p">:</code>&#13;
    <code class="nt">Runtime</code><code class="p">:</code> <code class="l-Scalar-Plain">java8</code>&#13;
    <code class="nt">MemorySize</code><code class="p">:</code> <code class="l-Scalar-Plain">512</code>&#13;
    <code class="nt">Handler</code><code class="p">:</code> <code class="l-Scalar-Plain">book.HelloWorldAPI::handler</code>&#13;
    <code class="nt">CodeUri</code><code class="p">:</code> <code class="l-Scalar-Plain">target/lambda.zip</code>&#13;
    <code class="nt">Events</code><code class="p">:</code>&#13;
      <code class="nt">MyApi</code><code class="p">:</code>&#13;
        <code class="nt">Type</code><code class="p">:</code> <code class="l-Scalar-Plain">Api</code>&#13;
        <code class="nt">Properties</code><code class="p">:</code>&#13;
          <code class="nt">Path</code><code class="p">:</code> <code class="l-Scalar-Plain">/foo</code>&#13;
          <code class="nt">Method</code><code class="p">:</code> <code class="l-Scalar-Plain">get</code></pre>&#13;
&#13;
<p>Take<a data-primary="Events key" data-type="indexterm" id="idm46222420308920"/> a look at the <code>Events</code> key—that’s where the magic happens.&#13;
What SAM does in this case is create a whole bunch of resources, including a globally accessible API endpoint (which we get to later in the chapter), but part of what it also does is configure API Gateway to trigger your Lambda function.</p>&#13;
&#13;
<p>SAM can directly configure <a href="https://oreil.ly/s_4W2">many different event sources</a>.&#13;
However, if it doesn’t do enough for your requirements, you can always drop down to lower-level CloudFormation resources.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Understanding Different Event Source Semantics" data-type="sect2"><div class="sect2" id="idm46222420350424">&#13;
<h2>Understanding Different Event Source Semantics</h2>&#13;
&#13;
<p>Back<a data-primary="event sources" data-secondary="synchronous event sources" data-type="indexterm" id="idm46222420348760"/><a data-primary="event sources" data-secondary="asynchronous event sources" data-type="indexterm" id="idm46222420347736"/><a data-primary="event sources" data-secondary="event source semantics" data-type="indexterm" id="idm46222420346776"/> in <a data-type="xref" href="ch01.html#ch01">Chapter 1</a> we described that Lambda functions can be invoked in two ways—synchronously and asynchronously—and showed how those different invocation types were used in different scenarios.</p>&#13;
&#13;
<p>Unsurprisingly, that<a data-primary="synchronous event sources" data-secondary="polling and" data-type="indexterm" id="idm46222420344296"/><a data-primary="asynchronous event sources" data-secondary="polling and" data-type="indexterm" id="idm46222420343272"/> means there are at least two different kinds of event source—those, like API Gateway, that invoke a Lambda function synchronously and wait for the reply (“synchronous event sources”), and others that invoke a Lambda function asynchronously, and don’t wait for the reply (“asynchronous event sources”).</p>&#13;
&#13;
<p>In the case of the former group, your Lambda function needs to return the appropriate type of response, just like we did with the API Gateway earlier. For the latter group, your handler function can have a return type of <code>void</code>, showing that you don’t return a response.</p>&#13;
&#13;
<p>It<a data-primary="Simple Que Service (SQS)" data-secondary="Lambda handler event for" data-type="indexterm" id="idm46222420340328"/><a data-primary="SQS" data-see="Simple Que Service (SQS)" data-type="indexterm" id="idm46222420339288"/> would be convenient to say, in fact, that <em>all</em> event sources fit into one of these two kinds, but unfortunately there’s a slight complication—there’s a third kind, and that’s Stream/queue event sources, such as:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Kinesis Data Streams</p>&#13;
</li>&#13;
<li>&#13;
<p>DynamoDB Streams</p>&#13;
</li>&#13;
<li>&#13;
<p>Simple Queue Service (SQS)</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>In<a data-primary="polling" data-type="indexterm" id="idm46222420334040"/> all three of these cases, we configure the Lambda <em>platform</em> to reach out to the upstream service to <em>poll</em> for events, as opposed to all the other event sources where we configure a Lambda trigger directly from the upstream service to <em>push</em> events to Lambda.</p>&#13;
&#13;
<p>This<a data-primary="event sources" data-secondary="stream/queue event sources" data-type="indexterm" id="idm46222420331240"/><a data-primary="stream/queue event sources" data-secondary="Lambda Handler programming model and" data-type="indexterm" id="idm46222420330168"/> reversal for stream/queue sources has no impact on the Lambda handler programming model—the method signature is precisely the same.&#13;
For example, here is the format of a Lambda handler event for SQS (note the array of <code>Records</code>):</p>&#13;
&#13;
<pre data-code-language="json" data-type="programlisting"><code class="p">{</code>&#13;
  <code class="nt">"Records"</code><code class="p">:</code> <code class="p">[</code>&#13;
    <code class="p">{</code>&#13;
      <code class="nt">"messageId"</code><code class="p">:</code> <code class="s2">"19dd0b57-b21e-4ac1-bd88-01bbb068cb78"</code><code class="p">,</code>&#13;
      <code class="nt">"receiptHandle"</code><code class="p">:</code> <code class="s2">"MessageReceiptHandle"</code><code class="p">,</code>&#13;
      <code class="nt">"body"</code><code class="p">:</code> <code class="s2">"Hello from SQS!"</code><code class="p">,</code>&#13;
      <code class="nt">"attributes"</code><code class="p">:</code> <code class="p">{</code>&#13;
        <code class="nt">"ApproximateReceiveCount"</code><code class="p">:</code> <code class="s2">"1"</code><code class="p">,</code>&#13;
        <code class="nt">"SentTimestamp"</code><code class="p">:</code> <code class="s2">"1523232000000"</code><code class="p">,</code>&#13;
        <code class="nt">"SenderId"</code><code class="p">:</code> <code class="s2">"123456789012"</code><code class="p">,</code>&#13;
        <code class="nt">"ApproximateFirstReceiveTimestamp"</code><code class="p">:</code> <code class="s2">"1523232000001"</code>&#13;
      <code class="p">},</code>&#13;
      <code class="nt">"messageAttributes"</code><code class="p">:</code> <code class="p">{},</code>&#13;
      <code class="nt">"md5OfBody"</code><code class="p">:</code> <code class="s2">"7b270e59b47ff90a553787216d55d91d"</code><code class="p">,</code>&#13;
      <code class="nt">"eventSource"</code><code class="p">:</code> <code class="s2">"aws:sqs"</code><code class="p">,</code>&#13;
      <code class="nt">"eventSourceARN"</code><code class="p">:</code> <code class="s2">"arn:aws:sqs:us-east-1:123456789012:MyQueue"</code><code class="p">,</code>&#13;
      <code class="nt">"awsRegion"</code><code class="p">:</code> <code class="s2">"us-east-1"</code>&#13;
    <code class="p">}</code>&#13;
  <code class="p">]</code>&#13;
<code class="p">}</code></pre>&#13;
<table id="lambda-event-source-types">&#13;
<caption><span class="label">Table 5-1. </span>Lambda event source types</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Event Source Type</th>&#13;
<th>Event Sources</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p>Synchronous</p></td>&#13;
<td><div>&#13;
<p>API Gateway,&#13;
 Amazon CloudFront (Lambda@Edge),&#13;
 Elastic Load Balancing (Application Load Balancer),&#13;
 Cognito,&#13;
 Lex,&#13;
 Alexa,&#13;
 Kinesis Data Firehose</p></div></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Asynchronous</p></td>&#13;
<td><div>&#13;
<p>S3,&#13;
 SNS,&#13;
 Amazon SES,&#13;
 CloudFormation,&#13;
 CloudWatch Logs,&#13;
 CloudWatch Events,&#13;
 CodeCommit,&#13;
 Config</p></div></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Stream/Queue</p></td>&#13;
<td><div>&#13;
<p>Kinesis Data Streams,&#13;
 DynamoDB Streams,&#13;
 Simple Queue Service (SQS)</p></div></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>Stream/queue event sources are also a little different when it comes to error handling (see <a data-type="xref" href="ch08.html#error-handling">“Error Handling”</a>). But for now, we know enough about event sources to explore a couple of detailed examples.&#13;
Let’s dig into our serverless HTTP API.<a data-primary="" data-startref="SAevent05" data-type="indexterm" id="idm46222420231896"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Example: Building a Serverless API" data-type="sect1"><div class="sect1" id="serverless-api-example">&#13;
<h1>Example: Building a Serverless API</h1>&#13;
&#13;
<p>In <a data-type="xref" href="ch01.html#ch01">Chapter 1</a>, we<a data-primary="serverless applications" data-secondary="building serverless APIs" data-type="indexterm" id="SAbuildapi05"/> briefly discussed how Lambda can be used as part of a web API.&#13;
In this section, we will show how this is built.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Behavior" data-type="sect2"><div class="sect2" id="idm46222420226616">&#13;
<h2>Behavior</h2>&#13;
&#13;
<p>This<a data-primary="serverless APIs, building" data-secondary="application behavior" data-type="indexterm" id="idm46222420225080"/> application allows a client to upload weather data to an API, and then allows other clients to retrieve that data (<a data-type="xref" href="#web-api-again">Figure 5-2</a>).</p>&#13;
&#13;
<figure><div class="figure" id="web-api-again">&#13;
<img alt="images/ch01_image05.png" src="assets/awsl_0105.png"/>&#13;
<h6><span class="label">Figure 5-2. </span>Web API using AWS Lambda</h6>&#13;
</div></figure>&#13;
&#13;
<p>The write path consists of making an HTTP POST request to the endpoint <code>/events</code>, with the following JSON data structure in the <code>body</code> of the request:</p>&#13;
&#13;
<pre data-code-language="json" data-type="programlisting"><code class="p">{</code>&#13;
  <code class="nt">"locationName"</code><code class="p">:</code><code class="s2">"Brooklyn, NY"</code><code class="p">,</code>&#13;
  <code class="nt">"temperature"</code><code class="p">:</code><code class="mi">91</code><code class="p">,</code>&#13;
  <code class="nt">"timestamp"</code><code class="p">:</code><code class="mi">1564428897</code><code class="p">,</code>&#13;
  <code class="nt">"latitude"</code><code class="p">:</code> <code class="mf">40.70</code><code class="p">,</code>&#13;
  <code class="nt">"longitude"</code><code class="p">:</code> <code class="mf">-73.99</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The read path consists of making a GET request to the endpoint <code>/locations</code>, which returns the latest weather data for each location that we’ve saved data for.&#13;
The format of this data is a JSON list of objects in the same format as the write path.&#13;
An optional query string parameter <code>limit</code> can be added to the GET request to specify a maximum number of records to return.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Architecture" data-type="sect2"><div class="sect2" id="idm46222420194904">&#13;
<h2>Architecture</h2>&#13;
&#13;
<p>We<a data-primary="serverless APIs, building" data-secondary="application architecture" data-type="indexterm" id="idm46222420193560"/> use AWS API Gateway to implement all of the HTTP elements of this application. The read path and write path are implemented using two different Lambda functions. These are triggered by API Gateway. We store our data in a<a data-primary="DynamoDB" data-secondary="benefits of" data-type="indexterm" id="idm46222420192248"/> DynamoDB table. DynamoDB<a data-primary="NoSQL databases" data-type="indexterm" id="idm46222420191176"/> is Amazon’s “NoSQL” database service. It’s a great fit for many serverless systems because:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>It offers the same “lightweight operations” model as Lambda—we configure the table structure we want and Amazon handles all runtime considerations.</p>&#13;
</li>&#13;
<li>&#13;
<p>It can be used in a full “on-demand” scaling mode<a data-primary="scaling" data-secondary="auto-scaling feature" data-type="indexterm" id="idm46222420188136"/><a data-primary="auto-scaling" data-secondary="DynamoDB and" data-type="indexterm" id="idm46222420187160"/> that scales up and down in reaction to actual usage, just like Lambda does.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Because DynamoDB is a NoSQL technology, it isn’t the right choice for all applications, but it’s definitely a quick way to get started.</p>&#13;
&#13;
<p>For our DynamoDB table in this example, we declare a primary key named <code>locationName</code> and use “on-demand” capacity control.</p>&#13;
&#13;
<p>We treat all of these resources—an API Gateway definition, two Lambda functions, and a DynamoDB table as one unified “serverless application.”&#13;
We treat the code, configuration, and infrastructure definitions as one, collectively deployed, unit.&#13;
This is not a particularly new idea just for serverless, though—encapsulating a database within a service is a fairly common idea of microservice architecture.</p>&#13;
&#13;
<p>Apart from adding a useful grouping, using the idea of a serverless application also helps solve a concern that some people have when they consider how many Lambda functions they might have in their organization—it’s tough enough herding hundreds of microservices, but a company may end up with thousands or tens of thousands of Lambda functions.&#13;
How can we manage all of those functions?&#13;
By namespaceing functions within a serverless application, and by tagging or locating the deployed versions of those applications by their environment/stage, we can start bringing some order to the chaos. This concept of a serverless application is not just a design-time consideration—AWS actually supports it directly (see <a data-type="xref" href="#ch05-deployment">“Deployment”</a>).</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="api-gateway-http-apis">&#13;
<h5>Which Flavor of API Gateway?</h5>&#13;
<p>AWS API Gateway<a data-primary="API Gateway" data-secondary="versions of" data-type="indexterm" id="idm46222420179464"/><a data-primary="REST (representational state transfer)" data-type="indexterm" id="idm46222420178456"/> was launched in July 2015, using the terminology of a “REST API” very much at its core (REST referring to the <a href="https://oreil.ly/FdDze">“representational state transfer”</a> style of building applications).&#13;
Over the years since its launch, AWS has added a lot of features to API Gateway—security, request and response mapping, rate limiting, and more.</p>&#13;
&#13;
<p>At the time of writing, AWS has just launched, currently as a beta release, <a href="https://oreil.ly/fOd1n"><em>API Gateway HTTP APIs</em></a>.&#13;
This is a different “flavor” of API Gateway that doesn’t have as many features as the “REST API” version—it’s missing things like rate limiting and request/response mapping, for instance—but it does come with approximately 70% cost savings and better (lower latency) performance.&#13;
Also note that while AWS names this “HTTP APIs,” the “traditional” REST APIs variant still implements the HTTP protocol.&#13;
AWS’s choice of names for various things still continues to baffle us.</p>&#13;
&#13;
<p>The reason that AWS has introduced HTTP APIs is that it has found that many customers don’t use most of the features of API Gateway.&#13;
Many people instead just want a simple way of exposing Lambda functions to the public internet, with a minimum amount of complexity.&#13;
HTTP APIs gives these people that, with a nice reduction in cost.</p>&#13;
&#13;
<p>Looking at the beta version of HTTP APIs, we see that from a programming model point of view very little is different versus REST APIs.&#13;
The changes are mostly architectural—what the service can and can’t do—but that of course has an impact on what code you may need to write.&#13;
For example, the current version of HTTP APIs doesn’t support custom/Lambda authorizers, but instead you could implement this feature within your Lambda handler code.</p>&#13;
&#13;
<p>It also appears that, if you’re using SAM at least, there’s not very much different for the deployment template of a REST API versus an HTTP API—for simple use cases at least, but remember, that’s what the HTTP API variant is built for.</p>&#13;
&#13;
<p>In this book, we <em>only</em> use the REST API version of API Gateway.&#13;
We recommend you:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Don’t use an HTTP API if it’s still in beta.</p>&#13;
</li>&#13;
<li>&#13;
<p>Otherwise, use an HTTP API if its limited feature set is sufficient for your needs, knowing that you can migrate to the full REST API version later if necessary.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>AWS goes into more detail on this choice in the <a href="https://oreil.ly/GmksV">API Gateway documentation</a>.</p>&#13;
</div></aside>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Lambda Code" data-type="sect2"><div class="sect2" id="idm46222420180968">&#13;
<h2>Lambda Code</h2>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>At this point in the book we don’t discuss error checking or testing—we’ve done that for clarity of example. Don’t worry—both of these important subjects are addressed later in the book!</p>&#13;
</div>&#13;
&#13;
<p>We<a data-primary="serverless APIs, building" data-secondary="Lambda code" data-type="indexterm" id="idm46222420110408"/> mentioned earlier that one of the first things you need to do when implementing an application using Lambda is to understand the format of the events that your Lambda function will receive, and the format of the response your Lambda function should return (if any).</p>&#13;
&#13;
<p>We already examined the API Gateway proxy types earlier.&#13;
In this weather API, we write our own classes for POJO serialization and deserialization, rather than using the AWS-supplied library. Examples&#13;
<a href="#EX5-1">5-1</a> and <a href="#EX5-2">5-2</a> are sufficient for our needs for both Lambda functions.</p>&#13;
<div data-type="example" id="EX5-1">&#13;
<h5><span class="label">Example 5-1. </span>For deserializing API requests</h5>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kn">package</code> <code class="n">book</code><code class="o">.</code><code class="na">api</code><code class="o">;</code>&#13;
&#13;
<code class="kn">import</code> <code class="nn">java.util.HashMap</code><code class="o">;</code>&#13;
<code class="kn">import</code> <code class="nn">java.util.Map</code><code class="o">;</code>&#13;
&#13;
<code class="kd">public</code> <code class="kd">class</code> <code class="nc">ApiGatewayRequest</code> <code class="o">{</code>&#13;
  <code class="kd">public</code> <code class="n">String</code> <code class="n">body</code><code class="o">;</code>&#13;
  <code class="kd">public</code> <code class="n">Map</code><code class="o">&lt;</code><code class="n">String</code><code class="o">,</code> <code class="n">String</code><code class="o">&gt;</code> <code class="n">queryStringParameters</code> <code class="o">=</code> <code class="k">new</code> <code class="n">HashMap</code><code class="o">&lt;&gt;();</code>&#13;
<code class="o">}</code></pre></div>&#13;
<div data-type="example" id="EX5-2">&#13;
<h5><span class="label">Example 5-2. </span>For serializing API responses</h5>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kn">package</code> <code class="n">book</code><code class="o">.</code><code class="na">api</code><code class="o">;</code>&#13;
&#13;
<code class="kd">public</code> <code class="kd">class</code> <code class="nc">ApiGatewayResponse</code> <code class="o">{</code>&#13;
  <code class="kd">public</code> <code class="n">Integer</code> <code class="n">statusCode</code><code class="o">;</code>&#13;
  <code class="kd">public</code> <code class="n">String</code> <code class="n">body</code><code class="o">;</code>&#13;
&#13;
  <code class="kd">public</code> <code class="nf">ApiGatewayResponse</code><code class="o">(</code><code class="n">Integer</code> <code class="n">statusCode</code><code class="o">,</code> <code class="n">String</code> <code class="n">body</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="k">this</code><code class="o">.</code><code class="na">statusCode</code> <code class="o">=</code> <code class="n">statusCode</code><code class="o">;</code>&#13;
    <code class="k">this</code><code class="o">.</code><code class="na">body</code> <code class="o">=</code> <code class="n">body</code><code class="o">;</code>&#13;
  <code class="o">}</code>&#13;
<code class="o">}</code></pre></div>&#13;
&#13;
<p>We wouldn’t actually recommend this approach in general—see earlier about whether or not to use the AWS POJO type library (<a data-type="xref" href="#code-for-event-sources">“Writing Code to Work with Input and Output for Event Sources”</a>)—but we wanted to show examples of both approaches.&#13;
The second example in this chapter uses the AWS Library.&#13;
When you build your own production implementation of an HTTP API with Lambda, you can substitute the <code>APIGatewayProxyRequestEvent</code> and <code>APIGatewayProxyResponseEvent</code> classes in the <code>com.amazonaws.services.lambda.runtime.events</code> package for these DIY classes.</p>&#13;
&#13;
<p>Now let’s look in detail at the code necessary to implement this application. We start with the write path.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="api-gateway-proxy-events">&#13;
<h5>API Gateway Proxy Events</h5>&#13;
<p>You<a data-primary="API Gateway" data-secondary="Integration versus Proxy events" data-type="indexterm" id="idm46222419992280"/><a data-primary="proxy integration" data-type="indexterm" id="idm46222419991208"/> may have noticed that we keep using phrases like <em>API Gateway proxy</em> throughout this chapter.&#13;
This is because there are two different ways of triggering Lambda from API Gateway for HTTP requests.</p>&#13;
&#13;
<p>API Gateway <a href="https://oreil.ly/kaTa0">Lambda proxy integration</a> is the type we use in this serverless API example.&#13;
<em>Integration</em> is the API Gateway term for connecting to a backend service—which can be Lambda, or other types of service too.&#13;
A Lambda proxy integration is an integration where API Gateway converts the whole original HTTP request into a JSON form, passes this to the Lambda function, and then converts the Lambda’s JSON response into an HTTP response.&#13;
The <em>proxy</em> here means that API Gateway isn’t doing any custom mapping to the request or response.</p>&#13;
&#13;
<p>API Gateway <a href="https://oreil.ly/niw8d">“Lambda custom integrations”</a>, on the other hand, have specific mapping templates for both the request path and the response path.&#13;
This is done by giving API Gateway these mapping templates when the API is configured.&#13;
With this type of integration, the structure of the JSON that is passed to the backing Lambda function will depend on the contents of the mapping template, which is why you don’t see an option for these types of events in <code>sam local generate-event</code>.</p>&#13;
&#13;
<p>The benefit of Lambda custom integrations is that the event objects passed to, and returned from, the Lambda function are significantly less complicated, and in fact the Lambda function doesn’t need to understand the details of the HTTP protocol at all.&#13;
For example, the status code can be set in the response template, and the Lambda function doesn’t need to know its 200 s from its <a href="https://oreil.ly/Iy3fi">418 s</a>.</p>&#13;
&#13;
<p>The drawback of Lambda custom integrations is that all that logic that does need to know about HTTP requests and responses has to go into a <a href="https://oreil.ly/d1NlX">Velocity template</a>—these are brittle and tricky to develop and unit test.</p>&#13;
&#13;
<p>These drawbacks are so significant that we recommend in almost all circumstances that you use the “Lambda proxy” integration type when integrating Lambda with API Gateway.&#13;
If necessary, you can pull some of the HTTP request/response wrangling into shared code to reduce the burden on individual Lambda functions, but either way it’s typically a lot easier and cleaner to define that in code, rather than in mapping templates.</p>&#13;
&#13;
<p>Two further quick points about using API Gateway with Lambda.&#13;
We’re only going to mention them here so that you’re aware of them:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>API Gateway has another meaning of the word proxy, and that’s when it’s used in the phrase <em>proxy resource</em>.&#13;
Here <em>proxy</em> is used to say that the path that is being defined is partly or wholly a wildcard, e.g. <em>/foo/{<code>proxy</code>}</em> will map both the request paths <code>/foo/sheep</code> and <code>/foo/cheese</code> to the same integration.&#13;
You may use proxy <em>resources</em> combined with proxy <em>integrations</em> but you aren’t required to.</p>&#13;
</li>&#13;
<li>&#13;
<p>API Gateway has another way it can call Lambda—for authorizing requests <em>before</em> passing to a backend resource (which may itself be any of the API Gateway integration types).&#13;
You’ll see that referred to by the “authorizer” event source type when calling <code>sam local generate-event apigateway</code> with no other arguments.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>For more information about using API Gateway and Lambda in this way, see <a href="https://oreil.ly/PWoi_">the AWS documentation</a>.</p>&#13;
</div></aside>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Uploading weather data with WeatherEventLambda" data-type="sect3"><div class="sect3" id="idm46222419993720">&#13;
<h3>Uploading weather data with WeatherEventLambda</h3>&#13;
&#13;
<p>We<a data-primary="serverless APIs, building" data-secondary="uploading data" data-type="indexterm" id="SABupload05"/> know that the rough skeleton of our code to process uploaded data is going to be the following:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kn">package</code> <code class="n">book</code><code class="o">.</code><code class="na">api</code><code class="o">;</code>&#13;
&#13;
<code class="kd">public</code> <code class="kd">class</code> <code class="nc">WeatherEventLambda</code> <code class="o">{</code>&#13;
  <code class="kd">public</code> <code class="n">ApiGatewayResponse</code> <code class="nf">handler</code><code class="o">(</code><code class="n">ApiGatewayRequest</code> <code class="n">request</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="c1">// process request</code>&#13;
&#13;
    <code class="c1">// send response</code>&#13;
    <code class="k">return</code> <code class="k">new</code> <code class="nf">ApiGatewayResponse</code><code class="o">(</code><code class="mi">200</code><code class="o">,</code> <code class="o">..).;</code>&#13;
  <code class="o">}</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p>The first thing we need to do is capture the input of our event.&#13;
Lambda deserialization starts this work for us, and the structure of the <code>ApiGatewayRequest</code> object that is passed to our function is as follows:</p>&#13;
&#13;
<pre data-code-language="json" data-type="programlisting"><code class="p">{</code>&#13;
  <code class="nt">"body"</code><code class="p">:</code> <code class="s2">"{\"locationName\":\"Brooklyn, NY\", \"temperature\":91,..."</code><code class="p">,</code>&#13;
  <code class="nt">"queryStringParameters"</code><code class="p">:</code> <code class="p">{}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>We don’t care about the <code>queryStringParameters</code> field in this Lambda function—that will be used in the querying function—so we can ignore that for now.</p>&#13;
&#13;
<p>That <code>body</code> field, though, is a little tricky—the JSON object uploaded by the client is still serialized as a string value.&#13;
That’s because Lambda only deserialized the event that API Gateway created; it also can’t deserialize the “next level in” of the weather data.</p>&#13;
&#13;
<p>No matter, we can perform our own deserialization for <code>body</code>, and one way we can do that is to use the <a href="https://github.com/FasterXML/jackson">Jackson library</a>.</p>&#13;
&#13;
<p>Once we’ve deserialized the weather data, we’re ready to save it to the database.&#13;
<a data-type="xref" href="#EX5-3">Example 5-3</a> shows the full code for the Lambda function—you may also want to open up the example code in the <em>chapter5-api</em> directory.</p>&#13;
<div data-type="example" id="EX5-3">&#13;
<h5><span class="label">Example 5-3. </span>WeatherEventLambda handler class</h5>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kn">package</code> <code class="n">book</code><code class="o">.</code><code class="na">api</code><code class="o">;</code>&#13;
&#13;
<code class="kn">import</code> <code class="nn">com.amazonaws.services.dynamodbv2.AmazonDynamoDBClientBuilder</code><code class="o">;</code>&#13;
<code class="kn">import</code> <code class="nn">com.amazonaws.services.dynamodbv2.document.DynamoDB</code><code class="o">;</code>&#13;
<code class="kn">import</code> <code class="nn">com.amazonaws.services.dynamodbv2.document.Item</code><code class="o">;</code>&#13;
<code class="kn">import</code> <code class="nn">com.amazonaws.services.dynamodbv2.document.Table</code><code class="o">;</code>&#13;
<code class="kn">import</code> <code class="nn">com.fasterxml.jackson.databind.DeserializationFeature</code><code class="o">;</code>&#13;
<code class="kn">import</code> <code class="nn">com.fasterxml.jackson.databind.ObjectMapper</code><code class="o">;</code>&#13;
&#13;
<code class="kn">import</code> <code class="nn">java.io.IOException</code><code class="o">;</code>&#13;
&#13;
<code class="kd">public</code> <code class="kd">class</code> <code class="nc">WeatherEventLambda</code> <code class="o">{</code>&#13;
  <code class="kd">private</code> <code class="kd">final</code> <code class="n">ObjectMapper</code> <code class="n">objectMapper</code> <code class="o">=</code>&#13;
      <code class="k">new</code> <code class="nf">ObjectMapper</code><code class="o">()</code>&#13;
          <code class="o">.</code><code class="na">configure</code><code class="o">(</code>&#13;
              <code class="n">DeserializationFeature</code><code class="o">.</code><code class="na">FAIL_ON_UNKNOWN_PROPERTIES</code><code class="o">,</code>&#13;
              <code class="kc">false</code><code class="o">);</code>&#13;
  <code class="kd">private</code> <code class="kd">final</code> <code class="n">DynamoDB</code> <code class="n">dynamoDB</code> <code class="o">=</code> <code class="k">new</code> <code class="n">DynamoDB</code><code class="o">(</code>&#13;
      <code class="n">AmazonDynamoDBClientBuilder</code><code class="o">.</code><code class="na">defaultClient</code><code class="o">());</code>&#13;
  <code class="kd">private</code> <code class="kd">final</code> <code class="n">String</code> <code class="n">tableName</code> <code class="o">=</code> <code class="n">System</code><code class="o">.</code><code class="na">getenv</code><code class="o">(</code><code class="s">"LOCATIONS_TABLE"</code><code class="o">);</code>&#13;
&#13;
  <code class="kd">public</code> <code class="n">ApiGatewayResponse</code> <code class="nf">handler</code><code class="o">(</code><code class="n">ApiGatewayRequest</code> <code class="n">request</code><code class="o">)</code>&#13;
    <code class="kd">throws</code> <code class="n">IOException</code> <code class="o">{</code>&#13;
&#13;
    <code class="kd">final</code> <code class="n">WeatherEvent</code> <code class="n">weatherEvent</code> <code class="o">=</code> <code class="n">objectMapper</code><code class="o">.</code><code class="na">readValue</code><code class="o">(</code>&#13;
        <code class="n">request</code><code class="o">.</code><code class="na">body</code><code class="o">,</code>&#13;
        <code class="n">WeatherEvent</code><code class="o">.</code><code class="na">class</code><code class="o">);</code>&#13;
&#13;
    <code class="kd">final</code> <code class="n">Table</code> <code class="n">table</code> <code class="o">=</code> <code class="n">dynamoDB</code><code class="o">.</code><code class="na">getTable</code><code class="o">(</code><code class="n">tableName</code><code class="o">);</code>&#13;
    <code class="kd">final</code> <code class="n">Item</code> <code class="n">item</code> <code class="o">=</code> <code class="k">new</code> <code class="n">Item</code><code class="o">()</code>&#13;
        <code class="o">.</code><code class="na">withPrimaryKey</code><code class="o">(</code><code class="s">"locationName"</code><code class="o">,</code> <code class="n">weatherEvent</code><code class="o">.</code><code class="na">locationName</code><code class="o">)</code>&#13;
        <code class="o">.</code><code class="na">withDouble</code><code class="o">(</code><code class="s">"temperature"</code><code class="o">,</code> <code class="n">weatherEvent</code><code class="o">.</code><code class="na">temperature</code><code class="o">)</code>&#13;
        <code class="o">.</code><code class="na">withLong</code><code class="o">(</code><code class="s">"timestamp"</code><code class="o">,</code> <code class="n">weatherEvent</code><code class="o">.</code><code class="na">timestamp</code><code class="o">)</code>&#13;
        <code class="o">.</code><code class="na">withDouble</code><code class="o">(</code><code class="s">"longitude"</code><code class="o">,</code> <code class="n">weatherEvent</code><code class="o">.</code><code class="na">longitude</code><code class="o">)</code>&#13;
        <code class="o">.</code><code class="na">withDouble</code><code class="o">(</code><code class="s">"latitude"</code><code class="o">,</code> <code class="n">weatherEvent</code><code class="o">.</code><code class="na">latitude</code><code class="o">);</code>&#13;
    <code class="n">table</code><code class="o">.</code><code class="na">putItem</code><code class="o">(</code><code class="n">item</code><code class="o">);</code>&#13;
&#13;
    <code class="k">return</code> <code class="k">new</code> <code class="nf">ApiGatewayResponse</code><code class="o">(</code><code class="mi">200</code><code class="o">,</code> <code class="n">weatherEvent</code><code class="o">.</code><code class="na">locationName</code><code class="o">);</code>&#13;
  <code class="o">}</code>&#13;
<code class="o">}</code></pre></div>&#13;
&#13;
<p>First you can see we create a few instance variables outside of the handler function.&#13;
We talk about why we do that in <a data-type="xref" href="ch08.html#lambda-scaling">“Scaling”</a>, but the summary is that the Lambda platform typically uses the same instance of a Lambda function several times (although never concurrently), so we can optimize performance a little by only creating certain things once for the lifetime of the Lambda function instance.</p>&#13;
&#13;
<p>The first instance variable is Jackson’s <code>ObjectMapper</code>, and the second is the DynamoDB SDK.&#13;
The third and final instance variable is the table name within DynamoDB that we want to use.&#13;
The precise value of that comes from our infrastructure template, so we use an environment variable to configure our Lambda function, just as we discussed in <a data-type="xref" href="ch03.html#environment-variables">“Environment Variables”</a>.</p>&#13;
&#13;
<p>The remainder of the class is our Lambda handler function.&#13;
First of all, you can see the signature, with the types that you’d expect given the event source that we’re dealing with.&#13;
One slight addition here, though, is that our Lambda handler declares that it may throw an exception—this is completely valid, and we discuss error handling more in <a data-type="xref" href="ch08.html#error-handling">“Error Handling”</a>.</p>&#13;
&#13;
<p>The first line of the handler deserializes the weather event embedded within the <code>body</code> field of the original HTTP request.&#13;
<code>WeatherEvent</code> is defined in <a data-type="xref" href="#EX5-4">Example 5-4</a> in its own class.</p>&#13;
<div data-type="example" id="EX5-4">&#13;
<h5><span class="label">Example 5-4. </span>WeatherEvent class</h5>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kn">package</code> <code class="n">book</code><code class="o">.</code><code class="na">api</code><code class="o">;</code>&#13;
&#13;
<code class="kd">public</code> <code class="kd">class</code> <code class="nc">WeatherEvent</code> <code class="o">{</code>&#13;
  <code class="kd">public</code> <code class="n">String</code> <code class="n">locationName</code><code class="o">;</code>&#13;
  <code class="kd">public</code> <code class="n">Double</code> <code class="n">temperature</code><code class="o">;</code>&#13;
  <code class="kd">public</code> <code class="n">Long</code> <code class="n">timestamp</code><code class="o">;</code>&#13;
  <code class="kd">public</code> <code class="n">Double</code> <code class="n">longitude</code><code class="o">;</code>&#13;
  <code class="kd">public</code> <code class="n">Double</code> <code class="n">latitude</code><code class="o">;</code>&#13;
&#13;
  <code class="kd">public</code> <code class="nf">WeatherEvent</code><code class="o">()</code> <code class="o">{</code>&#13;
  <code class="o">}</code>&#13;
&#13;
  <code class="kd">public</code> <code class="nf">WeatherEvent</code><code class="o">(</code><code class="n">String</code> <code class="n">locationName</code><code class="o">,</code> <code class="n">Double</code> <code class="n">temperature</code><code class="o">,</code>&#13;
            <code class="n">Long</code> <code class="n">timestamp</code><code class="o">,</code> <code class="n">Double</code> <code class="n">longitude</code><code class="o">,</code> <code class="n">Double</code> <code class="n">latitude</code><code class="o">)</code> <code class="o">{</code>&#13;
&#13;
    <code class="k">this</code><code class="o">.</code><code class="na">locationName</code> <code class="o">=</code> <code class="n">locationName</code><code class="o">;</code>&#13;
    <code class="k">this</code><code class="o">.</code><code class="na">temperature</code> <code class="o">=</code> <code class="n">temperature</code><code class="o">;</code>&#13;
    <code class="k">this</code><code class="o">.</code><code class="na">timestamp</code> <code class="o">=</code> <code class="n">timestamp</code><code class="o">;</code>&#13;
    <code class="k">this</code><code class="o">.</code><code class="na">longitude</code> <code class="o">=</code> <code class="n">longitude</code><code class="o">;</code>&#13;
    <code class="k">this</code><code class="o">.</code><code class="na">latitude</code> <code class="o">=</code> <code class="n">latitude</code><code class="o">;</code>&#13;
  <code class="o">}</code>&#13;
<code class="o">}</code></pre></div>&#13;
&#13;
<p>In this case, Jackson uses the no-argument constructor, and populates the fields of the object based on the value passed in the <code>body</code> field of the original Lambda event.</p>&#13;
&#13;
<p>Now we’ve captured our full weather event, we can save this to the database.&#13;
We’re not going to go into detail of how to use DynamoDB here, but you can see from the code that:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>We use the environment variable of the table name to connect to our desired table.</p>&#13;
</li>&#13;
<li>&#13;
<p>We<a data-primary="DynamoDB" data-secondary="Document model" data-type="indexterm" id="idm46222419611416"/> use the DynamoDB Java SDK’s “Document model” to save data to the table, using the location name as the primary key.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Finally, we need to return a response.&#13;
Since we got this far, we assume (for now!) that everything worked successfully, in which case returning an HTTP 200 (“OK”) response is the right thing to do, and to make it clearer to the client what we actually did, we return the location name that was saved.</p>&#13;
&#13;
<p>That’s all the code that we need to handle the write path of our API. Now let’s look at the read path.<a data-primary="" data-startref="SABupload05" data-type="indexterm" id="idm46222419608632"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Reading weather data with WeatherQueryLambda" data-type="sect3"><div class="sect3" id="idm46222419971944">&#13;
<h3>Reading weather data with WeatherQueryLambda</h3>&#13;
&#13;
<p>As<a data-primary="serverless APIs, building" data-secondary="reading data" data-type="indexterm" id="idm46222419606456"/> you’d expect, <code>WeatherQueryLambda</code> is similar to <code>WeatherEventLambda</code>, but reversed. <a data-type="xref" href="#EX5-5">Example 5-5</a> shows the code.</p>&#13;
<div data-type="example" id="EX5-5">&#13;
<h5><span class="label">Example 5-5. </span>WeatherQueryLambda handler class</h5>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kn">package</code> <code class="n">book</code><code class="o">.</code><code class="na">api</code><code class="o">;</code>&#13;
&#13;
<code class="kn">import</code> <code class="nn">com.amazonaws.services.dynamodbv2.AmazonDynamoDB</code><code class="o">;</code>&#13;
<code class="kn">import</code> <code class="nn">com.amazonaws.services.dynamodbv2.AmazonDynamoDBClientBuilder</code><code class="o">;</code>&#13;
<code class="kn">import</code> <code class="nn">com.amazonaws.services.dynamodbv2.model.ScanRequest</code><code class="o">;</code>&#13;
<code class="kn">import</code> <code class="nn">com.amazonaws.services.dynamodbv2.model.ScanResult</code><code class="o">;</code>&#13;
<code class="kn">import</code> <code class="nn">com.fasterxml.jackson.databind.ObjectMapper</code><code class="o">;</code>&#13;
&#13;
<code class="kn">import</code> <code class="nn">java.io.IOException</code><code class="o">;</code>&#13;
<code class="kn">import</code> <code class="nn">java.util.List</code><code class="o">;</code>&#13;
<code class="kn">import</code> <code class="nn">java.util.stream.Collectors</code><code class="o">;</code>&#13;
&#13;
<code class="kd">public</code> <code class="kd">class</code> <code class="nc">WeatherQueryLambda</code> <code class="o">{</code>&#13;
  <code class="kd">private</code> <code class="kd">final</code> <code class="n">ObjectMapper</code> <code class="n">objectMapper</code> <code class="o">=</code> <code class="k">new</code> <code class="n">ObjectMapper</code><code class="o">();</code>&#13;
  <code class="kd">private</code> <code class="kd">final</code> <code class="n">AmazonDynamoDB</code> <code class="n">dynamoDB</code> <code class="o">=</code>&#13;
      <code class="n">AmazonDynamoDBClientBuilder</code><code class="o">.</code><code class="na">defaultClient</code><code class="o">();</code>&#13;
  <code class="kd">private</code> <code class="kd">final</code> <code class="n">String</code> <code class="n">tableName</code> <code class="o">=</code> <code class="n">System</code><code class="o">.</code><code class="na">getenv</code><code class="o">(</code><code class="s">"LOCATIONS_TABLE"</code><code class="o">);</code>&#13;
&#13;
  <code class="kd">private</code> <code class="kd">static</code> <code class="kd">final</code> <code class="n">String</code> <code class="n">DEFAULT_LIMIT</code> <code class="o">=</code> <code class="s">"50"</code><code class="o">;</code>&#13;
&#13;
  <code class="kd">public</code> <code class="n">ApiGatewayResponse</code> <code class="nf">handler</code><code class="o">(</code><code class="n">ApiGatewayRequest</code> <code class="n">request</code><code class="o">)</code>&#13;
    <code class="kd">throws</code> <code class="n">IOException</code> <code class="o">{</code>&#13;
&#13;
    <code class="kd">final</code> <code class="n">String</code> <code class="n">limitParam</code> <code class="o">=</code> <code class="n">request</code><code class="o">.</code><code class="na">queryStringParameters</code> <code class="o">==</code> <code class="kc">null</code>&#13;
        <code class="o">?</code> <code class="n">DEFAULT_LIMIT</code>&#13;
        <code class="o">:</code> <code class="n">request</code><code class="o">.</code><code class="na">queryStringParameters</code><code class="o">.</code><code class="na">getOrDefault</code><code class="o">(</code>&#13;
            <code class="s">"limit"</code><code class="o">,</code> <code class="n">DEFAULT_LIMIT</code><code class="o">);</code>&#13;
    <code class="kd">final</code> <code class="kt">int</code> <code class="n">limit</code> <code class="o">=</code> <code class="n">Integer</code><code class="o">.</code><code class="na">parseInt</code><code class="o">(</code><code class="n">limitParam</code><code class="o">);</code>&#13;
&#13;
    <code class="kd">final</code> <code class="n">ScanRequest</code> <code class="n">scanRequest</code> <code class="o">=</code> <code class="k">new</code> <code class="n">ScanRequest</code><code class="o">()</code>&#13;
        <code class="o">.</code><code class="na">withTableName</code><code class="o">(</code><code class="n">tableName</code><code class="o">)</code>&#13;
        <code class="o">.</code><code class="na">withLimit</code><code class="o">(</code><code class="n">limit</code><code class="o">);</code>&#13;
    <code class="kd">final</code> <code class="n">ScanResult</code> <code class="n">scanResult</code> <code class="o">=</code> <code class="n">dynamoDB</code><code class="o">.</code><code class="na">scan</code><code class="o">(</code><code class="n">scanRequest</code><code class="o">);</code>&#13;
&#13;
    <code class="kd">final</code> <code class="n">List</code><code class="o">&lt;</code><code class="n">WeatherEvent</code><code class="o">&gt;</code> <code class="n">events</code> <code class="o">=</code> <code class="n">scanResult</code><code class="o">.</code><code class="na">getItems</code><code class="o">().</code><code class="na">stream</code><code class="o">()</code>&#13;
        <code class="o">.</code><code class="na">map</code><code class="o">(</code><code class="n">item</code> <code class="o">-&gt;</code> <code class="k">new</code> <code class="n">WeatherEvent</code><code class="o">(</code>&#13;
            <code class="n">item</code><code class="o">.</code><code class="na">get</code><code class="o">(</code><code class="s">"locationName"</code><code class="o">).</code><code class="na">getS</code><code class="o">(),</code>&#13;
            <code class="n">Double</code><code class="o">.</code><code class="na">parseDouble</code><code class="o">(</code><code class="n">item</code><code class="o">.</code><code class="na">get</code><code class="o">(</code><code class="s">"temperature"</code><code class="o">).</code><code class="na">getN</code><code class="o">()),</code>&#13;
            <code class="n">Long</code><code class="o">.</code><code class="na">parseLong</code><code class="o">(</code><code class="n">item</code><code class="o">.</code><code class="na">get</code><code class="o">(</code><code class="s">"timestamp"</code><code class="o">).</code><code class="na">getN</code><code class="o">()),</code>&#13;
            <code class="n">Double</code><code class="o">.</code><code class="na">parseDouble</code><code class="o">(</code><code class="n">item</code><code class="o">.</code><code class="na">get</code><code class="o">(</code><code class="s">"longitude"</code><code class="o">).</code><code class="na">getN</code><code class="o">()),</code>&#13;
            <code class="n">Double</code><code class="o">.</code><code class="na">parseDouble</code><code class="o">(</code><code class="n">item</code><code class="o">.</code><code class="na">get</code><code class="o">(</code><code class="s">"latitude"</code><code class="o">).</code><code class="na">getN</code><code class="o">())</code>&#13;
        <code class="o">))</code>&#13;
        <code class="o">.</code><code class="na">collect</code><code class="o">(</code><code class="n">Collectors</code><code class="o">.</code><code class="na">toList</code><code class="o">());</code>&#13;
&#13;
    <code class="kd">final</code> <code class="n">String</code> <code class="n">json</code> <code class="o">=</code> <code class="n">objectMapper</code><code class="o">.</code><code class="na">writeValueAsString</code><code class="o">(</code><code class="n">events</code><code class="o">);</code>&#13;
&#13;
    <code class="k">return</code> <code class="k">new</code> <code class="nf">ApiGatewayResponse</code><code class="o">(</code><code class="mi">200</code><code class="o">,</code> <code class="n">json</code><code class="o">);</code>&#13;
  <code class="o">}</code>&#13;
<code class="o">}</code></pre></div>&#13;
&#13;
<p>We see a similar set of instance variables.&#13;
The DynamoDB one is slightly different because of the DynamoDB SDK’s API, but the Jackson one is the same, and again we capture the environment variable that specifies the table name.</p>&#13;
&#13;
<p>In the <code>WeatherEventLambda</code> handler, we cared about the input event’s <code>body</code> field.&#13;
This time we care about the <code>queryStringParameters</code> field, and specifically the <code>limit</code> parameter, if it’s set.&#13;
If it is set, we use it. Otherwise, we default to 50 as the maximum number of records we want to retrieve from DynamoDB.</p>&#13;
&#13;
<p>The next couple of statements read the data from DynamoDB, and after those, we convert the DynamoDB results back into <code>WeatherEvent</code> objects. With the weather events captured, we use Jackson again to create a JSON string response to return to the client.</p>&#13;
&#13;
<p>Finally, we send our API response—again setting 200 OK as the status code, but this time putting the useful response in the <code>body</code> field.</p>&#13;
&#13;
<p>And that’s it for code! With very little code, even with the verbosity of Java, we have a full HTTP API that reads and writes values to a database. But, of course, our code isn’t all there is to defining the app. As we saw in <a data-type="xref" href="ch04.html#ch04">Chapter 4</a>, we also need to build and package our code.&#13;
And we actually need to define our infrastructure too.</p>&#13;
<aside class="less_space" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="serverless-without-lambda">&#13;
<h5>Serverless Without Lambda</h5>&#13;
<p>Even<a data-primary="serverless APIs, building" data-secondary="without using Lambda" data-type="indexterm" id="idm46222419128696"/> though there is very little code in this serverless API example, the entire application as it stands could actually be implemented with zero lines of code.&#13;
This is not some strange wizardry, but in fact is due to another type of API Gateway integration.</p>&#13;
&#13;
<p>As we mentioned earlier, API Gateway can integrate with Lambda (in two different ways). That said, it can also integrate with any other HTTP application, acting more like a traditional reverse proxy, or it can also integrate directly with another AWS service.&#13;
In either of these other cases, you supply mapping templates to map requests to the underlying service and map responses from the underlying service.</p>&#13;
&#13;
<p>With this capability, we could implement our weather API by integrating API Gateway directly with DynamoDB, mapping between HTTP formats and the underlying storage format using mapping templates.&#13;
This is described further on <a href="https://oreil.ly/CNtzT">AWS’s blog</a>. With this solution, no Lambda functions are required, and therefore no code is required.</p>&#13;
&#13;
<p>An immediate follow-on question to this is, “Just because you can directly integrate API Gateway with a AWS Service, does it mean you should?”&#13;
There are differing opinions on this in the serverless community.&#13;
One school of thought is that this kind of “Lambda-less” application is better because:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>It requires no code, and is therefore easier to maintain and safer.</p>&#13;
</li>&#13;
<li>&#13;
<p>Since we don’t call Lambda, and API Gateway’s pricing is based on a “per-request” model (no matter how complicated the definition of the request), then it’s cheaper to use the “Lambda-less” solution.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>On the other hand, “pro-Lambda” people argue:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>It’s a lot easier to maintain and test mapping code in Lambda, than it is to do the same with Velocity mapping templates.</p>&#13;
</li>&#13;
<li>&#13;
<p>Therefore, any money you save on Lambda invocations will be wiped out by the time you spend getting your templates right.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Which group is correct?&#13;
As is so often the case, “it depends.”&#13;
Our own take is to default to the code approach, with Lambda.&#13;
However, if a particular element of your application is simple enough to create easily with mapping templates, and if the expected throughput is high enough that you’d see real cost savings if you don’t call Lambda, then use the Lambda-free approach.</p>&#13;
&#13;
<p>The client-facing part is API Gateway in both solutions, so you can change your mind about architecture down the road without impacting clients.</p>&#13;
</div></aside>&#13;
&#13;
<p>We look at building and packaging next.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Build and Package Using the AWS SDK BOM" data-type="sect2"><div class="sect2" id="idm46222420112824">&#13;
<h2>Build and Package Using the AWS SDK BOM</h2>&#13;
&#13;
<p>In <a data-type="xref" href="ch04.html#ch04">Chapter 4</a> we<a data-primary="serverless APIs, building" data-secondary="building and packaging" data-type="indexterm" id="SAPbuild05"/><a data-primary="AWS SDK BOM" data-type="indexterm" id="awsbom05"/><a data-primary="building and packaging Lambda functions" data-secondary="serverless API example" data-type="indexterm" id="BAPapi05"/> showed how to build and package a Lambda application using Maven.&#13;
In this example, we’re going to use the ZIP format that we described there, so we need a <em>pom.xml</em> file, and an assembly description file.&#13;
The latter of those is no different to what we’ve seen before, so we ignore that here.</p>&#13;
&#13;
<p>Let’s take a quick look at the <em>pom.xml</em> file, cut down a little for brevity:</p>&#13;
<div data-type="example" id="EX5-6">&#13;
<h5><span class="label">Example 5-6. </span>Partial Maven POM file for HTTP API</h5>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;project&gt;</code>&#13;
  <code class="nt">&lt;dependencyManagement&gt;</code>&#13;
    <code class="nt">&lt;dependencies&gt;</code>&#13;
      <code class="nt">&lt;dependency&gt;</code>&#13;
        <code class="nt">&lt;groupId&gt;</code>com.amazonaws<code class="nt">&lt;/groupId&gt;</code>&#13;
        <code class="nt">&lt;artifactId&gt;</code>aws-java-sdk-bom<code class="nt">&lt;/artifactId&gt;</code>&#13;
        <code class="nt">&lt;version&gt;</code>1.11.600<code class="nt">&lt;/version&gt;</code>&#13;
        <code class="nt">&lt;type&gt;</code>pom<code class="nt">&lt;/type&gt;</code>&#13;
        <code class="nt">&lt;scope&gt;</code>import<code class="nt">&lt;/scope&gt;</code>&#13;
      <code class="nt">&lt;/dependency&gt;</code>&#13;
    <code class="nt">&lt;/dependencies&gt;</code>&#13;
  <code class="nt">&lt;/dependencyManagement&gt;</code>&#13;
&#13;
  <code class="nt">&lt;dependencies&gt;</code>&#13;
    <code class="nt">&lt;dependency&gt;</code>&#13;
      <code class="nt">&lt;groupId&gt;</code>com.amazonaws<code class="nt">&lt;/groupId&gt;</code>&#13;
      <code class="nt">&lt;artifactId&gt;</code>aws-lambda-java-core<code class="nt">&lt;/artifactId&gt;</code>&#13;
      <code class="nt">&lt;version&gt;</code>1.2.0<code class="nt">&lt;/version&gt;</code>&#13;
      <code class="nt">&lt;scope&gt;</code>provided<code class="nt">&lt;/scope&gt;</code>&#13;
    <code class="nt">&lt;/dependency&gt;</code>&#13;
    <code class="nt">&lt;dependency&gt;</code>&#13;
      <code class="nt">&lt;groupId&gt;</code>com.amazonaws<code class="nt">&lt;/groupId&gt;</code>&#13;
      <code class="nt">&lt;artifactId&gt;</code>aws-java-sdk-dynamodb<code class="nt">&lt;/artifactId&gt;</code>&#13;
    <code class="nt">&lt;/dependency&gt;</code>&#13;
    <code class="nt">&lt;dependency&gt;</code>&#13;
      <code class="nt">&lt;groupId&gt;</code>com.fasterxml.jackson.core<code class="nt">&lt;/groupId&gt;</code>&#13;
      <code class="nt">&lt;artifactId&gt;</code>jackson-databind<code class="nt">&lt;/artifactId&gt;</code>&#13;
      <code class="nt">&lt;version&gt;</code>2.10.1<code class="nt">&lt;/version&gt;</code>&#13;
    <code class="nt">&lt;/dependency&gt;</code>&#13;
  <code class="nt">&lt;/dependencies&gt;</code>&#13;
&#13;
  <code class="c">&lt;!-- Other sections would follow --&gt;</code>&#13;
<code class="nt">&lt;/project&gt;</code></pre></div>&#13;
&#13;
<p>An<a data-primary="Maven" data-secondary="BOM (bill of materials) feature" data-type="indexterm" id="idm46222419080088"/> element that we’ve added here since <a data-type="xref" href="ch04.html#ch04">Chapter 4</a> is the <code>&lt;dependencyManagement&gt;</code> section.&#13;
In<a data-primary="BOM (bill of materials) feature" data-secondary="aws-java-sdk-bom" data-type="indexterm" id="idm46222419040728"/> this tag we reference a dependency named <code>aws-java-sdk-bom</code>.&#13;
This useful element is a feature of Maven known as a “bill of materials” (BOM), and in essence it groups all the version dependencies for a set of libraries.&#13;
We use it here so that any AWS Java SDK dependencies that we use are guaranteed to be in sync with each other with respect to versions.</p>&#13;
&#13;
<p>In this particular project, we actually use only one AWS Java SDK library—<code>aws-java-sdk-dynamodb</code>—and so using the BOM is less necessary for this example.&#13;
But many Lambda applications use multiple AWS SDKs, so it’s useful to start off on solid <span class="keep-together">footing</span>.</p>&#13;
&#13;
<p>You can also see that we don’t define the version for <code>aws-java-sdk-dynamodb</code> in the <code>&lt;dependency&gt;</code> section, because it uses the version defined in the BOM.&#13;
We do still have to declare the version of <code>aws-lambda-java-core</code> because that’s not part of the AWS Java SDK, and therefore not in the BOM—you can tell because it doesn’t have “sdk” in its name. You can read more about the AWS Java SDK BOM <a href="https://oreil.ly/V1x9x">in this blog article</a>.</p>&#13;
&#13;
<p>In this example, we collect the code for both of our different Lambda functions into one zipped package. In the next example later in this chapter, we show how you can break this package up into individual artifacts.</p>&#13;
&#13;
<p>With the dependency updates defined, we can build and package our application, using <code>mvn package</code> as usual.<a data-primary="" data-startref="SAPbuild05" data-type="indexterm" id="idm46222419033112"/><a data-primary="" data-startref="awsbom05" data-type="indexterm" id="idm46222419032104"/><a data-primary="" data-startref="BAPapi05" data-type="indexterm" id="idm46222419031160"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Infrastructure" data-type="sect2"><div class="sect2" id="idm46222419030088">&#13;
<h2>Infrastructure</h2>&#13;
&#13;
<p>The<a data-primary="serverless APIs, building" data-secondary="application infrastructure" data-type="indexterm" id="SAMinfra05"/> one element we still need to define is our infrastructure template.</p>&#13;
&#13;
<p>So far in this book we’ve only defined Lambda resources. Now we need to define our API Gateway, and our database. How do we do that? <a data-type="xref" href="#EX5-7">Example 5-7</a> shows the <em><span class="keep-together">template.yaml</span></em>.</p>&#13;
<div data-type="example" id="EX5-7">&#13;
<h5><span class="label">Example 5-7. </span>SAM template for HTTP API</h5>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">AWSTemplateFormatVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">2010-09-09</code>&#13;
<code class="nt">Transform</code><code class="p">:</code> <code class="l-Scalar-Plain">AWS::Serverless-2016-10-31</code>&#13;
<code class="nt">Description</code><code class="p">:</code> <code class="l-Scalar-Plain">chapter5-api</code>&#13;
&#13;
<code class="nt">Globals</code><code class="p">:</code>&#13;
  <code class="nt">Function</code><code class="p">:</code>&#13;
    <code class="nt">Runtime</code><code class="p">:</code> <code class="l-Scalar-Plain">java8</code>&#13;
    <code class="nt">MemorySize</code><code class="p">:</code> <code class="l-Scalar-Plain">512</code>&#13;
    <code class="nt">Timeout</code><code class="p">:</code> <code class="l-Scalar-Plain">25</code>&#13;
    <code class="nt">Environment</code><code class="p">:</code>&#13;
      <code class="nt">Variables</code><code class="p">:</code>&#13;
        <code class="nt">LOCATIONS_TABLE</code><code class="p">:</code> <code class="kt">!Ref</code> <code class="l-Scalar-Plain">LocationsTable</code>&#13;
  <code class="nt">Api</code><code class="p">:</code>&#13;
    <code class="nt">OpenApiVersion</code><code class="p">:</code> <code class="s">'3.0.1'</code>&#13;
&#13;
<code class="nt">Resources</code><code class="p">:</code>&#13;
  <code class="nt">LocationsTable</code><code class="p">:</code>&#13;
    <code class="nt">Type</code><code class="p">:</code> <code class="l-Scalar-Plain">AWS::Serverless::SimpleTable</code>&#13;
    <code class="nt">Properties</code><code class="p">:</code>&#13;
      <code class="nt">PrimaryKey</code><code class="p">:</code>&#13;
        <code class="nt">Name</code><code class="p">:</code> <code class="l-Scalar-Plain">locationName</code>&#13;
        <code class="nt">Type</code><code class="p">:</code> <code class="l-Scalar-Plain">String</code>&#13;
&#13;
  <code class="nt">WeatherEventLambda</code><code class="p">:</code>&#13;
    <code class="nt">Type</code><code class="p">:</code> <code class="l-Scalar-Plain">AWS::Serverless::Function</code>&#13;
    <code class="nt">Properties</code><code class="p">:</code>&#13;
      <code class="nt">CodeUri</code><code class="p">:</code> <code class="l-Scalar-Plain">target/lambda.zip</code>&#13;
      <code class="nt">Handler</code><code class="p">:</code> <code class="l-Scalar-Plain">book.api.WeatherEventLambda::handler</code>&#13;
      <code class="nt">Policies</code><code class="p">:</code>&#13;
       <code class="nt">— DynamoDBCrudPolicy</code><code class="p">:</code>&#13;
           <code class="nt">TableName</code><code class="p">:</code> <code class="kt">!Ref</code> <code class="l-Scalar-Plain">LocationsTable</code>&#13;
      <code class="nt">Events</code><code class="p">:</code>&#13;
        <code class="nt">ApiEvents</code><code class="p">:</code>&#13;
          <code class="nt">Type</code><code class="p">:</code> <code class="l-Scalar-Plain">Api</code>&#13;
          <code class="nt">Properties</code><code class="p">:</code>&#13;
            <code class="nt">Path</code><code class="p">:</code> <code class="l-Scalar-Plain">/events</code>&#13;
            <code class="nt">Method</code><code class="p">:</code> <code class="l-Scalar-Plain">POST</code>&#13;
&#13;
  <code class="nt">WeatherQueryLambda</code><code class="p">:</code>&#13;
    <code class="nt">Type</code><code class="p">:</code> <code class="l-Scalar-Plain">AWS::Serverless::Function</code>&#13;
    <code class="nt">Properties</code><code class="p">:</code>&#13;
      <code class="nt">CodeUri</code><code class="p">:</code> <code class="l-Scalar-Plain">target/lambda.zip</code>&#13;
      <code class="nt">Handler</code><code class="p">:</code> <code class="l-Scalar-Plain">book.api.WeatherQueryLambda::handler</code>&#13;
      <code class="nt">Policies</code><code class="p">:</code>&#13;
       <code class="nt">— DynamoDBReadPolicy</code><code class="p">:</code>&#13;
           <code class="nt">TableName</code><code class="p">:</code> <code class="kt">!Ref</code> <code class="l-Scalar-Plain">LocationsTable</code>&#13;
      <code class="nt">Events</code><code class="p">:</code>&#13;
        <code class="nt">ApiEvents</code><code class="p">:</code>&#13;
          <code class="nt">Type</code><code class="p">:</code> <code class="l-Scalar-Plain">Api</code>&#13;
          <code class="nt">Properties</code><code class="p">:</code>&#13;
            <code class="nt">Path</code><code class="p">:</code> <code class="l-Scalar-Plain">/locations</code>&#13;
            <code class="nt">Method</code><code class="p">:</code> <code class="l-Scalar-Plain">GET</code></pre></div>&#13;
&#13;
<p>Let’s go through this from the top.</p>&#13;
&#13;
<p>First of all we have our CloudFormation and SAM headers—these are no different to what we’ve seen before.</p>&#13;
&#13;
<p>Next is a new top-level section named <code>Globals</code>.&#13;
<code>Globals</code> is a code-optimizing feature of SAM that allows us to define some of the properties common to all the resources of the same type in an application.&#13;
We mostly use it here to define a few properties common to both of the Lambda functions that we declare later in the file.&#13;
We’ve already seen <code>Runtime</code>, <code>MemorySize</code>, and <code>Timeout</code>, but the way we’ve declared <code>LOCATIONS_TABLE</code> in the <code>Environment</code> key, with the <code>!Ref</code> string, is new—we will come back to that in a moment.&#13;
Note that not all properties from a function definition work within the <code>Globals</code> section, which is why you don’t see <code>CodeUri</code> defined within the <code>Globals</code>.</p>&#13;
&#13;
<p>Finally, in the <code>Globals</code> section is a small configuration of the API Gateway settings to use the most up-to-date version of SAM’s API configuration.</p>&#13;
&#13;
<p>Then we move into the rest of the template, which consists of <code>Resources</code> elements.</p>&#13;
&#13;
<p>The first one is new—it’s of type <code>AWS::Serverless::SimpleTable</code>.&#13;
This is SAM’s way of defining DynamoDB databases.&#13;
It works for simple configurations, which is fine for us in this example.</p>&#13;
&#13;
<p>Note that what we’re doing here isn’t merely pointing to a database that already exists—we’re actually declaring that we want CloudFormation to create a database for us, and managing it in the same stack of components as our Lambda functions, etc.&#13;
All we do is specify what we want the primary key field to be named, and AWS does everything else to manage the table on our behalf.</p>&#13;
&#13;
<p>We don’t even give the table a physical name—CloudFormation generates a unique name for us based on the name of the stack, the logical name of the table, <code><span class="keep-together">Locations</span>Table</code>, plus some randomly generated uniqueness.&#13;
That’s all well and good, but if we don’t know the name of the table, how are we meant to use it from our Lambda functions?</p>&#13;
&#13;
<p>That’s where the <code>!Ref LocationsTable</code> value that we saw earlier comes in. CloudFormation substitutes that string for the physical name of the DynamoDB table, and so our Lambda functions have an environment variable pointing them to the correct location.</p>&#13;
&#13;
<p>Moving on from the DynamoDB table, we see the definitions of our two Lambda functions.&#13;
These elements contain a lot of ideas we’ve covered already.&#13;
We saw the <code>Policies</code> section in <a data-type="xref" href="ch04.html#ch04">Chapter 4</a>—note how we’re embracing the principle of least privilege here by:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Only giving our functions access to one specific DynamoDB table (see <code>!Ref</code> being used again)</p>&#13;
</li>&#13;
<li>&#13;
<p>Only giving the Lambda function that is querying data read-only access (by declaring the <code>DynamoDBReadPolicy</code> policy)</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>We also see the <code>Events</code> section in each Lambda function that we covered briefly earlier in this chapter.&#13;
As we mentioned then, what’s happening here is that SAM is defining an implicit API Gateway, and then is attaching our Lambda functions to that Gateway with the <code>Path</code> and <code>Method</code> properties defined in the <code>Events</code> sections.</p>&#13;
&#13;
<p>In many real-life scenarios, the implicit API Gateway configuration won’t be quite enough for your needs, and in that case you can define either an explicit SAM API Gateway resource (using a resource of type <code>AWS::Serverless::Api</code>), or the underlying CloudFormation API Gateway resource types.&#13;
If you use the first of these options, you can add a <code>RestApiId</code> property to the API <code>Event</code> property of your Lambda functions to tie them to your self-defined API.</p>&#13;
&#13;
<p>You can also use Swagger/Open API as part of the CloudFormation/SAM definition of your API Gateway.&#13;
That way you’ll get better documentation, plus the opportunity for some amount of “no code required” input validation—but definitely don’t rely on Swagger/API Gateway as a complete input validator.&#13;
Also there are certain aspects to API Gateway’s configuration that can be defined only using AWS’s own <a href="https://oreil.ly/Cq-_T">OpenAPI extensions</a>.&#13;
We could write an entire mini-book just on this area, though, so we’ll leave you to go explore the AWS documentation for yourself if that’s what you need!</p>&#13;
&#13;
<p>This is all a little theoretical, but fortunately we’ve finished looking at the template, so it’s time to deploy and test our application!<a data-primary="" data-startref="SAMinfra05" data-type="indexterm" id="idm46222418760648"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Deployment" data-type="sect2"><div class="sect2" id="ch05-deployment">&#13;
<h2>Deployment</h2>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>As<a data-primary="serverless APIs, building" data-secondary="deployment" data-type="indexterm" id="SAPIdeploy05"/><a data-primary="deployment" data-secondary="serverless API example" data-type="indexterm" id="Dapi05"/> is, the API in this example is publicly accessible on the internet.&#13;
While this is OK for experimentation (since the full API name isn’t easily discoverable), it’s not something you want to leave around forever since anyone can read and write to this API.&#13;
In a production scenario you would want to add some amount of security at least around the write path, but that’s beyond the scope of what we’re going to cover here.</p>&#13;
</div>&#13;
&#13;
<p>To deploy the application, use precisely the same incantation of <code>sam deploy</code> that you’ve done already (if you need to refresh your memory, take a look at <a data-type="xref" href="ch04.html#cloudformation-and-sam">“CloudFormation and the Serverless Application Model”</a>).&#13;
The only thing you may want to change is the <code>stack-name</code> so that you deploy this to a new stack (e.g., <code>ChapterFiveApi</code>).</p>&#13;
&#13;
<p>Once SAM and CloudFormation have completed, you’ll have deployed a new stack to CloudFormation. We can see this in the CloudFormation section of the AWS Web Console (<a data-type="xref" href="#http-api-cloudformation">Figure 5-3</a>).</p>&#13;
&#13;
<figure><div class="figure" id="http-api-cloudformation">&#13;
<img alt="images/ch05_image03.png" src="assets/awsl_0503.png"/>&#13;
<h6><span class="label">Figure 5-3. </span>CloudFormation stack for HTTP API</h6>&#13;
</div></figure>&#13;
&#13;
<p>CloudFormation is a little low level, though, and so usefully AWS also provides a way of viewing this deployment in a view called <em>Serverless Application</em>, just as we designed earlier in <a data-type="xref" href="#architecture-section">“Architecture”</a>.&#13;
You can access this view via the Applications tab of the Lambda console (<a data-type="xref" href="#http-api-appview">Figure 5-4</a>).</p>&#13;
&#13;
<figure><div class="figure" id="http-api-appview">&#13;
<img alt="images/ch05_image04.png" src="assets/awsl_0504.png"/>&#13;
<h6><span class="label">Figure 5-4. </span>Serverless Application view for HTTP API</h6>&#13;
</div></figure>&#13;
&#13;
<p>In this view you can see the DynamoDB table, the API Gateway (referred to as a <em>RestAPI</em> in AWS terms), and our two Lambda functions.&#13;
If you click any of these resources, you are taken to the correct service console, and into that resource—try it out for the <em>ServerlessRestApi</em> resource.&#13;
This puts you in the API Gateway console. Click <em>Stages</em> on the left and then <em>Prod</em>—you should see something like <a data-type="xref" href="#http-api-apigateway">Figure 5-5</a>.</p>&#13;
&#13;
<figure><div class="figure" id="http-api-apigateway">&#13;
<img alt="images/ch05_image05.png" src="assets/awsl_0505.png"/>&#13;
<h6><span class="label">Figure 5-5. </span>API Gateway view for HTTP API</h6>&#13;
</div></figure>&#13;
&#13;
<p>The <em>Invoke URL</em> value is the publicly accessible URL for your API—make a note of it since you’ll need it in a moment.</p>&#13;
&#13;
<p>You can also see in the <em>Serverless Application</em> view that the physical names for the resources have the partially generated/partially random structure we discussed earlier.&#13;
For example, in this case, our DynamoDB table is actually named <em>ChapterFiveApi-LocationsTable-WFRRTZNM7JTF</em>.&#13;
And sure enough, if we look in the Lambda console at either of the two functions for this application, we can see that the <code>LOCATIONS_TABLE</code> environment variable is correctly set to this value (<a data-type="xref" href="#http-api-lambdaconfig">Figure 5-6</a>).</p>&#13;
&#13;
<figure><div class="figure" id="http-api-lambdaconfig">&#13;
<img alt="images/ch05_image06.png" src="assets/awsl_0506.png"/>&#13;
<h6><span class="label">Figure 5-6. </span>API Gateway view for HTTP API</h6>&#13;
</div></figure>&#13;
&#13;
<p>Finally, let’s test our deployment by calling both API routes. To do this, you need that URL from a moment ago.</p>&#13;
&#13;
<p>First, let’s send some data. The base of the URL is the one from the API Gateway console, but we append <code>/events</code>. We can call our API using curl, for example, as follows (substitute in your URL):</p>&#13;
&#13;
<pre data-type="programlisting">$ curl -d '{"locationName":"Brooklyn, NY", "temperature":91,&#13;
  "timestamp":1564428897, "latitude": 40.70, "longitude": -73.99}' \&#13;
  -H "Content-Type: application/json" \&#13;
  -X POST https://hnymk3astd.execute-api.us-west-2.amazonaws.com/Prod/events</pre>&#13;
&#13;
<pre data-type="programlisting">Brooklyn, NY</pre>&#13;
&#13;
<pre data-type="programlisting">$ curl -d '{"locationName":"Oxford, UK", "temperature":64,&#13;
  "timestamp":1564428898, "latitude": 51.75, "longitude": -1.25}' \&#13;
  -H "Content-Type: application/json" \&#13;
  -X POST https://hnymk3astd.execute-api.us-west-2.amazonaws.com/Prod/events</pre>&#13;
&#13;
<pre data-type="programlisting">Oxford, UK</pre>&#13;
&#13;
<p>This has saved two new events to DynamoDB.&#13;
You can prove that to yourself by clicking on the DynamoDB table from the Serverless Application console, and then clicking on the <em>Items</em> tab once you’re in the DynamoDB console (<a data-type="xref" href="#http-api-dynamodb">Figure 5-7</a>).</p>&#13;
&#13;
<figure><div class="figure" id="http-api-dynamodb">&#13;
<img alt="images/ch05_image07.png" src="assets/awsl_0507.png"/>&#13;
<h6><span class="label">Figure 5-7. </span>DynamoDB table for HTTP API</h6>&#13;
</div></figure>&#13;
&#13;
<p>And now we can use the final part of our application—reading from the API.&#13;
We can use curl for that again, adding <code>/locations</code> to the API Gateway console URL, for example:</p>&#13;
&#13;
<pre data-type="programlisting">$ curl https://hnymk3astd.execute-api.us-west-2.amazonaws.com/Prod/locations</pre>&#13;
&#13;
<pre data-type="programlisting">[{"locationName":"Oxford, UK","temperature":64.0,"timestamp":1564428898,&#13;
  "longitude":-1.25,"latitude":51.75},&#13;
  {"locationName":"Brooklyn, NY","temperature":91.0,&#13;
  "timestamp":1564428897,"longitude":-73.99,"latitude":40.7}]</pre>&#13;
&#13;
<p>As expected, this returns the list of locations that we’ve stored weather for.</p>&#13;
&#13;
<p>Congratulations! You’ve built your first full serverless application!&#13;
While it has only one simple feature, think of all the <em>nonfunctional</em> capabilities it has—it auto-scales up to handle a vast load and then back down when not in use, it’s fault-tolerant across multiple availability zones, it has infrastructure that is automatically updated to include critical security patches, and it has a whole lot more besides.</p>&#13;
&#13;
<p>Now let’s look at a different type of application, using a couple of other different AWS services.<a data-primary="" data-startref="SAbuildapi05" data-type="indexterm" id="idm46222418718024"/><a data-primary="" data-startref="SAPIdeploy05" data-type="indexterm" id="idm46222418717048"/><a data-primary="" data-startref="Dapi05" data-type="indexterm" id="idm46222418716104"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Example: Building a Serverless Data Pipeline" data-type="sect1"><div class="sect1" id="serverless-data-pipeline-example">&#13;
<h1>Example: Building a Serverless Data Pipeline</h1>&#13;
&#13;
<p>In <a data-type="xref" href="ch01.html#ch01">Chapter 1</a> we<a data-primary="serverless applications" data-secondary="building serverless data pipelines" data-type="indexterm" id="SAdatapipe05"/> listed two use cases for Lambda (<a data-type="xref" href="ch01.html#what_does_a_lambda_application_look_like">“What Does a Lambda Application Look Like?”</a>).&#13;
The first was an HTTP API that we just described in more detail—an example of synchronous usage of Lambda.&#13;
The second use case was file processing—uploading a file to S3 and then using Lambda to do something with that file.</p>&#13;
&#13;
<p>In<a data-primary="serverless data pipelines, building" data-secondary="overview of" data-type="indexterm" id="idm46222418709816"/> this example, we’re building on that second idea to create a <em>data pipeline</em>.&#13;
A data pipeline is a pattern where we chain together multiple asynchronous stages and branches of processing data.&#13;
It’s a popular pattern where the scalability of cloud resources gives a real-time alternative to batch systems.</p>&#13;
&#13;
<p>Another important element of this example is that we’re going to change the build and packaging phases of our application to create isolated output artifacts for each Lambda function.&#13;
As the amount of code in your Lambda functions grows—both that which is specific to the function and that which is imported as libraries—then deployment and startup will slow down.&#13;
Breaking up the packaged artifacts is a valuable technique to mitigate that.</p>&#13;
&#13;
<p>Let’s get started.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Behavior" data-type="sect2"><div class="sect2" id="idm46222418706568">&#13;
<h2>Behavior</h2>&#13;
&#13;
<p>This<a data-primary="serverless data pipelines, building" data-secondary="application behavior" data-type="indexterm" id="idm46222418705208"/> example is going to be another take on the weather event system we started in the previous example.&#13;
This time an application will upload a list of “weather events” in a JSON file to S3.&#13;
A data pipeline will then process this file, and for now the side effect will merely be logging the events to AWS CloudWatch Logs (<a data-type="xref" href="#data-pipeline-behavior">Figure 5-8</a>).</p>&#13;
&#13;
<figure><div class="figure" id="data-pipeline-behavior">&#13;
<img alt="images/ch05_image08.png" src="assets/awsl_0508.png"/>&#13;
<h6><span class="label">Figure 5-8. </span>Data pipeline example behavior</h6>&#13;
</div></figure>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Architecture" data-type="sect2"><div class="sect2" id="architecture-section">&#13;
<h2>Architecture</h2>&#13;
&#13;
<p>What<a data-primary="serverless data pipelines, building" data-secondary="application architecture" data-type="indexterm" id="SDParch05"/> we’ve just shown is the <em>behavior</em> of this application—the <em>architecture</em> has a few more details (<a data-type="xref" href="#data-pipeline-architecture">Figure 5-9</a>).</p>&#13;
&#13;
<figure><div class="figure" id="data-pipeline-architecture">&#13;
<img alt="images/ch05_image09.png" src="assets/awsl_0509.png"/>&#13;
<h6><span class="label">Figure 5-9. </span>Data pipeline example architecture</h6>&#13;
</div></figure>&#13;
&#13;
<p>We start this application with an S3 bucket.&#13;
The act of uploading a file, or in S3 terms an <em>object</em>, to S3 will (asynchronously) trigger a Lambda function.&#13;
This first function (<code>BulkEventsLambda</code>) will read the JSON list of weather events, separate them out into individual events, and then publish each one onto a SNS topic.&#13;
This in turn will trigger (asynchronously again) a second Lambda function (<code>SingleEventLambda</code>) which will then process each weather event. In our case, this will simply mean logging the event.</p>&#13;
&#13;
<p>This architecture is obviously far too complicated just for logging the contents of an uploaded file!&#13;
However, the important aspect of the example is that it provides a “walking skeleton” of an application that has a complete, deployable, multistage data pipeline.&#13;
You could then use this as a starting point for adding interesting processing logic.</p>&#13;
&#13;
<p>All of these components are treated as one collectively deployed serverless application, just as we did in the HTTP API example.</p>&#13;
&#13;
<p>Now we’ll dig in further to each of these stages of the architecture.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="S3" data-type="sect3"><div class="sect3" id="idm46222418689336">&#13;
<h3>S3</h3>&#13;
&#13;
<p>S3<a data-primary="Simple Storage Service (S3)" data-secondary="as a serverless BaaS product" data-type="indexterm" id="idm46222418687768"/> is one of the oldest services in AWS, as we described in <a data-type="xref" href="ch01.html#the-cloud-grows">“The Cloud Grows”</a>.&#13;
While it’s often used in the application architecture of systems, it’s commonplace too when deploying and operating AWS applications—we’ve used S3 a number of times in this book already when deploying our Lambda-based applications.</p>&#13;
&#13;
<p>More than that, however, we think that S3 is one of the earliest examples of a serverless BaaS product, at least on AWS.&#13;
If we look back to <a data-type="xref" href="ch01.html#ch01">Chapter 1</a> at the factors that “differentiate” serverless, we can see it ticks all the boxes:</p>&#13;
<dl>&#13;
<dt>Does not require managing a long-lived host or application instance</dt>&#13;
<dd>&#13;
<p>Yes—we have no “file servers” or otherwise to manage when we use S3.</p>&#13;
</dd>&#13;
<dt>Self auto-scales and auto-provisions, dependent on load</dt>&#13;
<dd>&#13;
<p>Yes, we never have to manually configure how much capacity we want with S3—it auto-scales both for total storage, and for traffic.</p>&#13;
</dd>&#13;
<dt>Has costs that are based on precise usage, up from and down to zero usage</dt>&#13;
<dd>&#13;
<p>Yes! If you have an empty bucket, you don’t pay anything. Alternatively, your cost will be dependent on the amount of bytes stored, amount of traffic, and your storage class (see next point).</p>&#13;
</dd>&#13;
<dt>Has performance capabilities defined in terms other than host size/count</dt>&#13;
<dd>&#13;
<p>Yes, again! S3’s performance capabilities are the storage class you choose—how quickly you need to access data. The more quickly you want to be able to access your data, the more you’ll pay.</p>&#13;
</dd>&#13;
<dt>Has implicit high availability</dt>&#13;
<dd>&#13;
<p>And yes. S3 replicates data across AZs within a region. If one AZ has a problem, you’ll still be able to access all of your data.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>Because S3 is serverless, it is a great partner to Lambda, especially because of their similar scaling capabilities.&#13;
Further, S3 directly integrates with Lambda by allowing Lambda functions to be triggered whenever data changes in an S3 bucket.&#13;
This way of reacting to changes automatically in S3 in an event-driven manner, rather than having to poll S3 to look for changes from a long-running traditional process, is cleaner, easier to understand, and more efficient from an infrastructure costs point of view.</p>&#13;
&#13;
<p>All of the non-Lambda services we use in these two examples—API Gateway, DynamoDB, S3, and SNS—are serverless BaaS services within the AWS ecosystem.</p>&#13;
&#13;
<p>For now we won’t provide an “upload client” to S3 in the example, and instead will use AWS tools to handle uploading.&#13;
In a real application you may choose to allow your end user client to upload directly to S3 by means of a “Signed URL”—this is a “pure” serverless approach since you are not only not running servers, you’re in fact pushing behavior to the client that you may otherwise have implemented in a server-side application.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Lambda functions" data-type="sect3"><div class="sect3" id="idm46222418673416">&#13;
<h3>Lambda functions</h3>&#13;
&#13;
<p>When<a data-primary="Lambda functions" data-secondary="serverless data pipeline example" data-type="indexterm" id="idm46222418671816"/> you see the code for the Lambda functions a little later, you won’t come across anything new given everything you’ve already learned.&#13;
The only real difference to what we did in the first example is that these functions won’t need to return any values since they are invoked asynchronously.</p>&#13;
&#13;
<p>One question that might be on your mind, though, is why do we separate out processing for each event to a separately invoked Lambda function?&#13;
This<a data-primary="fan-out pattern" data-type="indexterm" id="idm46222418669848"/> pattern is what we often call <em>fan-out</em>. Alternatively, it’s the “map” part of a “map-reduce” system, and there are a couple of reasons for using it with Lambda.</p>&#13;
&#13;
<p>The first reason is to introduce parallelism.&#13;
Each SNS message will trigger a new invocation of our <code>SingleEventLambda</code> function.&#13;
For each invocation of a Lambda function, if the previous invocation is not complete, then the Lambda platform will automatically create a new instance of the Lambda function, and call that instead.&#13;
In the case of our example app, if you upload a file of one hundred events, and each event individually took at least a few seconds to process, then Lambda would create one hundred instances of <code>SingleEventLambda</code>, and process each weather event in parallel (<a data-type="xref" href="#data-pipeline-fanout">Figure 5-10</a>).</p>&#13;
&#13;
<figure><div class="figure" id="data-pipeline-fanout">&#13;
<img alt="images/ch05_image10.png" src="assets/awsl_0510.png"/>&#13;
<h6><span class="label">Figure 5-10. </span>Data pipeline fan-out</h6>&#13;
</div></figure>&#13;
&#13;
<p>This scaling aspect of Lambda is hugely valuable, and we’ll be discussing it further in <a data-type="xref" href="ch08.html#ch08">Chapter 8</a> (<a data-type="xref" href="ch08.html#lambda-scaling">“Scaling”</a>).</p>&#13;
&#13;
<p>The second reason for introducing fan-out is if each individual event takes a long time to process—say a few minutes.&#13;
In this case, processing one hundred weather events would take longer than the maximum 15-minute timeout we have with Lambda, but putting each event into its own Lambda invocation means we may be able to avoid a timeout concern.</p>&#13;
&#13;
<p>There are other ways of solving Lambda’s timeout restriction.&#13;
One alternative (which is somewhat dangerous—see the following warning!) is to use a recursive call in a Lambda function.&#13;
In <a data-type="xref" href="ch03.html#ch03">Chapter 3</a> (<a data-type="xref" href="ch03.html#lambda-timeout">“Timeout”</a>), we saw that we could use the <code>getRemainingTimeInMillis()</code> method of the <code>Context</code> object passed to a Lambda handler to keep track of how long a function has left until it times out.&#13;
A strategy of using this value is to asynchronously directly invoke the same Lambda function that’s currently running, but only with the remaining data to be processed.</p>&#13;
&#13;
<p>This is a better choice than “fan-out” if your data needs to be processed linearly.</p>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>Be<a data-primary="Lambda functions" data-secondary="avoiding recursive calls" data-type="indexterm" id="idm46222418655960"/><a data-primary="costs" data-secondary="calling Lambda functions recursively" data-type="indexterm" id="idm46222418654888"/> careful when calling Lambda functions recursively since it’s easy to have runaway scenarios where either (a) you never stop and/or (b) you scale out your function hundreds or thousands of instances wide.&#13;
Either of these can seriously impact your AWS bill!&#13;
Because of reason (b), we recommend in the very rare case where a recursive Lambda call makes sense that you use a low “reserved concurrency” configuration (see <a data-type="xref" href="ch08.html#reserved-concurrency">“Reserved concurrency”</a>).</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="SNS" data-type="sect3"><div class="sect3" id="idm46222418672792">&#13;
<h3>SNS</h3>&#13;
&#13;
<p>SNS<a data-primary="Simple Notification Service (SNS)" data-type="indexterm" id="idm46222418650888"/> is one of AWS’s messaging services.&#13;
On one hand, SNS offers a simple <a href="https://oreil.ly/D5jdc">publish-subscribe message bus</a>; on another, it provides the capability to send <em>SMS</em> text messages, and similar human-targeted messages.&#13;
For our example, we only care about the first of these!</p>&#13;
&#13;
<p>SNS is another serverless service.&#13;
You are responsible for asking AWS to create a Topic, and then AWS handles all the scaling and operations of that Topic behind the scenes.</p>&#13;
&#13;
<p>It’s simple to publish a message with a string as its contents to a Topic using the SNS SDK, as we’ll see later.&#13;
There are also multiple subscription types for SNS, but we (not surprisingly) are only going to use the Lambda subscription type in this example.&#13;
The way this works is that when a message is published to a Topic, all subscribers for that Topic will be sent the message.&#13;
In the case of Lambda, the Lambda platform will receive the message, and then asynchronously invoke the Lambda function we’ve associated with the subscription.</p>&#13;
&#13;
<p>In the case of our example, we want a Lambda function to be asynchronously invoked for each weather event in an uploaded file.&#13;
We could have just directly called the <code>Invoke</code> method of the Lambda SDK to directly (but asynchronously) invoke <code>Single​EventLambda</code> from <code>BatchEventsLambda</code>, but instead we used SNS as an intermediary—why?</p>&#13;
&#13;
<p>This is because we want to reduce the structural coupling between the two Lambda functions.&#13;
We want <code>BatchEventsLambda</code> to know that its responsibility is splitting up a batch of weather events, but we don’t necessarily want it to be involved with what happens to those weather events next.&#13;
If we decide later to evolve our architecture so that each event is processed by multiple consumers, or perhaps we substitute the <a href="https://oreil.ly/LWX1e">AWS Step Functions service</a> for <code>SingleEvent​Lambda</code>, then the code for <code>BatchEventsLambda</code> doesn’t need to change.</p>&#13;
&#13;
<p>Finally, we chose SNS because of its simplicity and ubiquity within Lambda applications.&#13;
AWS offers a number of other messaging systems—SQS, Kinesis, and Event Bridge are some examples, and you can even use S3 if you like!&#13;
Which service you choose really comes down to the specific requirements of your application, and the various capabilities of each service.&#13;
Picking the right messaging service for an application can be a little tricky, so it’s worthwhile to do appropriate research.<a data-primary="" data-startref="SDParch05" data-type="indexterm" id="idm46222418641096"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Lambda Code" data-type="sect2"><div class="sect2" id="idm46222418699976">&#13;
<h2>Lambda Code</h2>&#13;
&#13;
<p>Our<a data-primary="serverless data pipelines, building" data-secondary="Lambda code" data-type="indexterm" id="SDPcode05"/> code consists of three classes.</p>&#13;
&#13;
<p>The first is the same <code>WeatherEvent</code> as we had in the first example, but copied into a new package, for reasons that will become clearer later.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Processing the batch with BulkEventsLambda" data-type="sect3"><div class="sect3" id="idm46222418636200">&#13;
<h3>Processing the batch with BulkEventsLambda</h3>&#13;
&#13;
<p>The next class is our <code>BulkEventsLambda</code> code.</p>&#13;
&#13;
<p>As<a data-primary="sam local generate-event command" data-type="indexterm" id="idm46222418633608"/> we’ve discussed already the first thing to do is understand the format of the input event.</p>&#13;
&#13;
<p>If we run <code>sam local generate-event s3</code>, we see that S3 can generate events for both “puts” (creates and updates) and “deletes.”&#13;
We care about the former, and the example event looks as follows (trimmed a little for conciseness):</p>&#13;
&#13;
<pre data-code-language="json" data-type="programlisting"><code class="p">{</code>&#13;
  <code class="nt">"Records"</code><code class="p">:</code> <code class="p">[</code>&#13;
    <code class="p">{</code>&#13;
      <code class="nt">"eventSource"</code><code class="p">:</code> <code class="s2">"aws:s3"</code><code class="p">,</code>&#13;
      <code class="nt">"awsRegion"</code><code class="p">:</code> <code class="s2">"us-east-1"</code><code class="p">,</code>&#13;
      <code class="nt">"eventTime"</code><code class="p">:</code> <code class="s2">"1970-01-01T00:00:00.000Z"</code><code class="p">,</code>&#13;
      <code class="nt">"eventName"</code><code class="p">:</code> <code class="s2">"ObjectCreated:Put"</code><code class="p">,</code>&#13;
      <code class="nt">"s3"</code><code class="p">:</code> <code class="p">{</code>&#13;
        <code class="nt">"bucket"</code><code class="p">:</code> <code class="p">{</code>&#13;
          <code class="nt">"name"</code><code class="p">:</code> <code class="s2">"example-bucket"</code><code class="p">,</code>&#13;
          <code class="nt">"arn"</code><code class="p">:</code> <code class="s2">"arn:aws:s3:::example-bucket"</code>&#13;
        <code class="p">},</code>&#13;
        <code class="nt">"object"</code><code class="p">:</code> <code class="p">{</code>&#13;
          <code class="nt">"key"</code><code class="p">:</code> <code class="s2">"test/key"</code><code class="p">,</code>&#13;
          <code class="nt">"size"</code><code class="p">:</code> <code class="mi">1024</code>&#13;
        <code class="p">}</code>&#13;
      <code class="p">}</code>&#13;
    <code class="p">}</code>&#13;
  <code class="p">]</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The first thing to notice is that the event contains an array of <code>Records</code>.&#13;
In fact, S3 will only ever send an array with exactly one element in it, but it’s good practice to code defensively for this if it’s easy to do so.</p>&#13;
&#13;
<p>The next thing to notice is that we are told what object has caused this event—<code>test/key</code> in bucket <code>example-bucket</code>.&#13;
It’s important to remember that S3 isn’t actually a file system, even though we often treat it as such.&#13;
It’s actually a key-value store where it just so happens that we might consider the key as if it were a path in a file system with directories.</p>&#13;
&#13;
<p>The final thing to notice is that we don’t receive the contents of the uploaded object—we’re only told the <em>location</em> of the object.&#13;
In our example application, we want the contents, so we need to load the object from S3 ourselves.</p>&#13;
&#13;
<p>In this example, we’re going to use the <code>S3Event</code> class from the <code>aws-lambda-java-events</code> library as our input event POJO.&#13;
This class references other types from the <code>aws-java-sdk-s3</code> SDK library, so we need that in our library dependencies too.&#13;
That’s OK, though, from the perspective of wanting to minimize library dependencies, since we make direct calls to the S3 SDK anyway in this class.</p>&#13;
&#13;
<p>An <code>S3Event</code> object, and its fields, includes everything we need for the input event, and since this function is asynchronous, there is no return type.&#13;
That means we’re done with the POJO definition phase and can move on to writing code.</p>&#13;
&#13;
<p>We’re leaving the <code>package</code> and <code>import</code> lines out of <a data-type="xref" href="#EX5-8">Example 5-8</a> because there are a lot of them, but if you’re interested in seeing them, please download the sample code for the book.</p>&#13;
<div data-type="example" id="EX5-8">&#13;
<h5><span class="label">Example 5-8. </span>BulkEventsLambda.java</h5>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">class</code> <code class="nc">BulkEventsLambda</code> <code class="o">{</code>&#13;
  <code class="kd">private</code> <code class="kd">final</code> <code class="n">ObjectMapper</code> <code class="n">objectMapper</code> <code class="o">=</code>&#13;
      <code class="k">new</code> <code class="nf">ObjectMapper</code><code class="o">()</code>&#13;
          <code class="o">.</code><code class="na">configure</code><code class="o">(</code>&#13;
              <code class="n">DeserializationFeature</code><code class="o">.</code><code class="na">FAIL_ON_UNKNOWN_PROPERTIES</code><code class="o">,</code>&#13;
              <code class="kc">false</code><code class="o">);</code>&#13;
  <code class="kd">private</code> <code class="kd">final</code> <code class="n">AmazonSNS</code> <code class="n">sns</code> <code class="o">=</code> <code class="n">AmazonSNSClientBuilder</code><code class="o">.</code><code class="na">defaultClient</code><code class="o">();</code>&#13;
  <code class="kd">private</code> <code class="kd">final</code> <code class="n">AmazonS3</code> <code class="n">s3</code> <code class="o">=</code> <code class="n">AmazonS3ClientBuilder</code><code class="o">.</code><code class="na">defaultClient</code><code class="o">();</code>&#13;
  <code class="kd">private</code> <code class="kd">final</code> <code class="n">String</code> <code class="n">snsTopic</code> <code class="o">=</code> <code class="n">System</code><code class="o">.</code><code class="na">getenv</code><code class="o">(</code><code class="s">"FAN_OUT_TOPIC"</code><code class="o">);</code>&#13;
&#13;
  <code class="kd">public</code> <code class="kt">void</code> <code class="nf">handler</code><code class="o">(</code><code class="n">S3Event</code> <code class="n">event</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="n">event</code><code class="o">.</code><code class="na">getRecords</code><code class="o">().</code><code class="na">forEach</code><code class="o">(</code><code class="k">this</code><code class="o">::</code><code class="n">processS3EventRecord</code><code class="o">);</code>&#13;
  <code class="o">}</code>&#13;
&#13;
  <code class="kd">private</code> <code class="kt">void</code> <code class="nf">processS3EventRecord</code><code class="o">(</code>&#13;
      <code class="n">S3EventNotification</code><code class="o">.</code><code class="na">S3EventNotificationRecord</code> <code class="n">record</code><code class="o">)</code> <code class="o">{</code>&#13;
&#13;
    <code class="kd">final</code> <code class="n">List</code><code class="o">&lt;</code><code class="n">WeatherEvent</code><code class="o">&gt;</code> <code class="n">weatherEvents</code> <code class="o">=</code> <code class="n">readWeatherEventsFromS3</code><code class="o">(</code>&#13;
        <code class="n">record</code><code class="o">.</code><code class="na">getS3</code><code class="o">().</code><code class="na">getBucket</code><code class="o">().</code><code class="na">getName</code><code class="o">(),</code>&#13;
        <code class="n">record</code><code class="o">.</code><code class="na">getS3</code><code class="o">().</code><code class="na">getObject</code><code class="o">().</code><code class="na">getKey</code><code class="o">());</code>&#13;
&#13;
    <code class="n">weatherEvents</code><code class="o">.</code><code class="na">stream</code><code class="o">()</code>&#13;
        <code class="o">.</code><code class="na">map</code><code class="o">(</code><code class="k">this</code><code class="o">::</code><code class="n">weatherEventToSnsMessage</code><code class="o">)</code>&#13;
        <code class="o">.</code><code class="na">forEach</code><code class="o">(</code><code class="n">message</code> <code class="o">-&gt;</code> <code class="n">sns</code><code class="o">.</code><code class="na">publish</code><code class="o">(</code><code class="n">snsTopic</code><code class="o">,</code> <code class="n">message</code><code class="o">));</code>&#13;
&#13;
    <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="s">"Published "</code> <code class="o">+</code> <code class="n">weatherEvents</code><code class="o">.</code><code class="na">size</code><code class="o">()</code>&#13;
              <code class="o">+</code> <code class="s">" weather events to SNS"</code><code class="o">);</code>&#13;
  <code class="o">}</code>&#13;
&#13;
  <code class="kd">private</code> <code class="n">List</code><code class="o">&lt;</code><code class="n">WeatherEvent</code><code class="o">&gt;</code> <code class="nf">readWeatherEventsFromS3</code><code class="o">(</code><code class="n">String</code> <code class="n">bucket</code><code class="o">,</code> <code class="n">String</code> <code class="n">key</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="k">try</code> <code class="o">{</code>&#13;
      <code class="kd">final</code> <code class="n">S3ObjectInputStream</code> <code class="n">s3is</code> <code class="o">=</code>&#13;
          <code class="n">s3</code><code class="o">.</code><code class="na">getObject</code><code class="o">(</code><code class="n">bucket</code><code class="o">,</code> <code class="n">key</code><code class="o">).</code><code class="na">getObjectContent</code><code class="o">();</code>&#13;
      <code class="kd">final</code> <code class="n">WeatherEvent</code><code class="o">[]</code> <code class="n">weatherEvents</code> <code class="o">=</code>&#13;
          <code class="n">objectMapper</code><code class="o">.</code><code class="na">readValue</code><code class="o">(</code><code class="n">s3is</code><code class="o">,</code> <code class="n">WeatherEvent</code><code class="o">[].</code><code class="na">class</code><code class="o">);</code>&#13;
      <code class="n">s3is</code><code class="o">.</code><code class="na">close</code><code class="o">();</code>&#13;
      <code class="k">return</code> <code class="n">Arrays</code><code class="o">.</code><code class="na">asList</code><code class="o">(</code><code class="n">weatherEvents</code><code class="o">);</code>&#13;
    <code class="o">}</code> <code class="k">catch</code> <code class="o">(</code><code class="n">IOException</code> <code class="n">e</code><code class="o">)</code> <code class="o">{</code>&#13;
      <code class="k">throw</code> <code class="k">new</code> <code class="nf">RuntimeException</code><code class="o">(</code><code class="n">e</code><code class="o">);</code>&#13;
    <code class="o">}</code>&#13;
  <code class="o">}</code>&#13;
&#13;
  <code class="kd">private</code> <code class="n">String</code> <code class="nf">weatherEventToSnsMessage</code><code class="o">(</code><code class="n">WeatherEvent</code> <code class="n">weatherEvent</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="k">try</code> <code class="o">{</code>&#13;
      <code class="k">return</code> <code class="n">objectMapper</code><code class="o">.</code><code class="na">writeValueAsString</code><code class="o">(</code><code class="n">weatherEvent</code><code class="o">);</code>&#13;
    <code class="o">}</code> <code class="k">catch</code> <code class="o">(</code><code class="n">JsonProcessingException</code> <code class="n">e</code><code class="o">)</code> <code class="o">{</code>&#13;
      <code class="k">throw</code> <code class="k">new</code> <code class="nf">RuntimeException</code><code class="o">(</code><code class="n">e</code><code class="o">);</code>&#13;
    <code class="o">}</code>&#13;
  <code class="o">}</code>&#13;
<code class="o">}</code></pre></div>&#13;
&#13;
<p>The handler method loops over each record in the <code>S3Event</code>.&#13;
We know that there should only ever be one, but we’ll be safe with this code if that’s not the case.</p>&#13;
&#13;
<p>The requirements for the remainder of the code are fairly simple:</p>&#13;
<ol>&#13;
<li>&#13;
<p>Read uploaded JSON object from S3.</p>&#13;
</li>&#13;
<li>&#13;
<p>Deserialize the JSON object into a list of <code>WeatherEvent</code> objects.</p>&#13;
</li>&#13;
<li>&#13;
<p>For each <code>WeatherEvent</code> object serialize it back into JSON…</p>&#13;
</li>&#13;
<li>&#13;
<p>…and then publish it to SNS.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>If you look at the code, you’ll see all of these expressed.&#13;
We use Jackson for serialization/deserialization just as we did in the first example.&#13;
We use the AWS SDK twice—once to read from S3 (<code>s3.getObject()</code>) and once to publish to SNS (<code>sns.publish()</code>).&#13;
While these are different SDKs, each requiring their own library dependency, they feel broadly the same to use as the DynamoDB SDK did in the previous example.</p>&#13;
&#13;
<p>One thing that’s interesting to notice is that just like in the first example we never give any credentials when creating our connections to the AWS SDKs: when we call <code>defaultClient()</code> on <code>AmazonSNSClientBuilder</code> and <code>AmazonS3ClientBuilder</code>, there is no username or password.&#13;
This works because the Java AWS SDKs, in the context of running within Lambda, by default use the Lambda execution role that we configure for the Lambda (and which we discussed in <a data-type="xref" href="ch04.html#IAM">“Identity and Access Management”</a>).&#13;
That means there aren’t any passwords that can leak from our source code!</p>&#13;
<aside class="pagebreak-before less_space" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46222418216808">&#13;
<h5>AWS SDK for Java Versions</h5>&#13;
<p>Every<a data-primary="Java" data-secondary="AWS SDK for Java versions" data-type="indexterm" id="idm46222418214968"/> time we’ve used the AWS SDK so far in this book we’ve been using the <em>AWS SDK for Java 1.11</em> (V1) version of the SDK.&#13;
You can tell this because the Maven group ID for all of our dependencies is <code>com.amazonaws</code>.</p>&#13;
&#13;
<p>There is also a newer version of the Java SDK—<em>AWS SDK for Java 2.0</em> (V2).&#13;
This offers performance improvements, automatic pagination, and more.&#13;
The V2 version of the SDK is available under the <code>software.amazon.awssdk</code> group ID in Maven <span class="keep-together">Central</span>.</p>&#13;
&#13;
<p>V2 was announced as being “generally available” in late 2018, so why don’t we use it in the book?</p>&#13;
&#13;
<p>While the lower-level elements of the complete AWS API are available in the V2 SDK, there are a number of higher-level features available in V1 that aren’t available (at the time of writing) in V2.&#13;
These are things like the DynamoDB Object Mapper.&#13;
Because of these functional gaps, we felt safer in writing this book with the V1 SDK.</p>&#13;
&#13;
<p>However, since the V2 SDK has performance improvements, and since V2’s functionality may well have advanced by the time you read this, we recommend you assess the V2 SDK and decide for yourself whether it would be a better fit for your needs.</p>&#13;
</div></aside>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Processing an individual weather event with SingleEventLambda" data-type="sect3"><div class="sect3" id="idm46222418635576">&#13;
<h3>Processing an individual weather event with SingleEventLambda</h3>&#13;
&#13;
<p>On to our final class. You should be getting the hang of this by now, so let’s zoom through it!</p>&#13;
&#13;
<p>First of all, the input event. Running <code>sam local generate-event sns notification</code> gives us the following, and again this is trimmed a little:</p>&#13;
&#13;
<pre data-code-language="json" data-type="programlisting"><code class="p">{</code>&#13;
  <code class="nt">"Records"</code><code class="p">:</code> <code class="p">[</code>&#13;
    <code class="p">{</code>&#13;
      <code class="nt">"EventSubscriptionArn"</code><code class="p">:</code> <code class="s2">"arn:aws:sns:us-east-1::ExampleTopic"</code><code class="p">,</code>&#13;
      <code class="nt">"Sns"</code><code class="p">:</code> <code class="p">{</code>&#13;
        <code class="nt">"Type"</code><code class="p">:</code> <code class="s2">"Notification"</code><code class="p">,</code>&#13;
        <code class="nt">"MessageId"</code><code class="p">:</code> <code class="s2">"95df01b4-ee98-5cb9-9903-4c221d41eb5e"</code><code class="p">,</code>&#13;
        <code class="nt">"TopicArn"</code><code class="p">:</code> <code class="s2">"arn:aws:sns:us-east-1:123456789012:ExampleTopic"</code><code class="p">,</code>&#13;
        <code class="nt">"Subject"</code><code class="p">:</code> <code class="s2">"example subject"</code><code class="p">,</code>&#13;
        <code class="nt">"Message"</code><code class="p">:</code> <code class="s2">"example message"</code><code class="p">,</code>&#13;
        <code class="nt">"Timestamp"</code><code class="p">:</code> <code class="s2">"1970-01-01T00:00:00.000Z"</code><code class="p">,</code>&#13;
        <code class="p">}</code>&#13;
      <code class="p">}</code>&#13;
  <code class="p">]</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Similar to S3, our input event consists of a single-element list of <code>Records</code>.&#13;
Within a <code>Record</code>, and the <code>Sns</code> object within that, are a number of fields.&#13;
The one we care about in this example is <code>Message</code>, but SNS messages also offer a <code>Subject</code> field.</p>&#13;
&#13;
<p>We use the <code>aws-lambda-java-events</code> library again, as we did with <code>BulkEvents​Lambda</code>, but this time we want to use the <code>SNSEvent</code> class.&#13;
<code>SNSEvent</code> doesn’t require any other AWS SDK classes, so there’s no need to add any further libraries to our Maven dependencies.</p>&#13;
&#13;
<p>And again, this is an asynchronous event type, so there’s no return type to worry about.</p>&#13;
&#13;
<p>On to the code (see <a data-type="xref" href="#EX5-9">Example 5-9</a>)! Again, we leave out the <code>package</code> and <code>import</code> statements here, but they’re in the&#13;
book’s downloadable code if you’d like to see them.</p>&#13;
<div data-type="example" id="EX5-9">&#13;
<h5><span class="label">Example 5-9. </span>SingleEventLambda Handler Class</h5>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">class</code> <code class="nc">SingleEventLambda</code> <code class="o">{</code>&#13;
  <code class="kd">private</code> <code class="kd">final</code> <code class="n">ObjectMapper</code> <code class="n">objectMapper</code> <code class="o">=</code>&#13;
      <code class="k">new</code> <code class="nf">ObjectMapper</code><code class="o">()</code>&#13;
          <code class="o">.</code><code class="na">configure</code><code class="o">(</code>&#13;
              <code class="n">DeserializationFeature</code><code class="o">.</code><code class="na">FAIL_ON_UNKNOWN_PROPERTIES</code><code class="o">,</code>&#13;
              <code class="kc">false</code><code class="o">);</code>&#13;
&#13;
  <code class="kd">public</code> <code class="kt">void</code> <code class="nf">handler</code><code class="o">(</code><code class="n">SNSEvent</code> <code class="n">event</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="n">event</code><code class="o">.</code><code class="na">getRecords</code><code class="o">().</code><code class="na">forEach</code><code class="o">(</code><code class="k">this</code><code class="o">::</code><code class="n">processSNSRecord</code><code class="o">);</code>&#13;
  <code class="o">}</code>&#13;
&#13;
  <code class="kd">private</code> <code class="kt">void</code> <code class="nf">processSNSRecord</code><code class="o">(</code><code class="n">SNSEvent</code><code class="o">.</code><code class="na">SNSRecord</code> <code class="n">snsRecord</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="k">try</code> <code class="o">{</code>&#13;
      <code class="kd">final</code> <code class="n">WeatherEvent</code> <code class="n">weatherEvent</code> <code class="o">=</code> <code class="n">objectMapper</code><code class="o">.</code><code class="na">readValue</code><code class="o">(</code>&#13;
          <code class="n">snsRecord</code><code class="o">.</code><code class="na">getSNS</code><code class="o">().</code><code class="na">getMessage</code><code class="o">(),</code>&#13;
          <code class="n">WeatherEvent</code><code class="o">.</code><code class="na">class</code><code class="o">);</code>&#13;
      <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="s">"Received weather event:"</code><code class="o">);</code>&#13;
      <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="n">weatherEvent</code><code class="o">);</code>&#13;
    <code class="o">}</code> <code class="k">catch</code> <code class="o">(</code><code class="n">IOException</code> <code class="n">e</code><code class="o">)</code> <code class="o">{</code>&#13;
      <code class="k">throw</code> <code class="k">new</code> <code class="nf">RuntimeException</code><code class="o">(</code><code class="n">e</code><code class="o">);</code>&#13;
    <code class="o">}</code>&#13;
  <code class="o">}</code>&#13;
<code class="o">}</code></pre></div>&#13;
&#13;
<p>This time our code is simpler:</p>&#13;
<ol>&#13;
<li>&#13;
<p>Code defensively again for multiple <code>SNSRecord</code> events (even though there should only be one).</p>&#13;
</li>&#13;
<li>&#13;
<p>Deserialize the <code>WeatherEvent</code> from the SNS event.</p>&#13;
</li>&#13;
<li>&#13;
<p>Log the <code>WeatherEvent</code> (we’ll look more at logging in <a data-type="xref" href="ch07.html#ch07">Chapter 7</a>).</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>This time there are no references to SDKs because the input event included all the data we cared about.<a data-primary="" data-startref="SDPcode05" data-type="indexterm" id="idm46222417938968"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Build and Package Using Multiple Modules and Isolated Artifacts" data-type="sect2"><div class="sect2" id="multi-module-build-and-package">&#13;
<h2>Build and Package Using Multiple Modules and Isolated Artifacts</h2>&#13;
&#13;
<p>With<a data-primary="serverless data pipelines, building" data-secondary="building and packaging" data-type="indexterm" id="SDPbuild05"/><a data-primary="building and packaging Lambda functions" data-secondary="serverless data pipeline example" data-type="indexterm" id="BAPdata05"/><a data-primary="artifacts" data-secondary="isolating for packaging" data-type="indexterm" id="artifact05"/><a data-primary="modules, using multiple for building and packaging" data-type="indexterm" id="modules05"/> all of the code written, it’s time to build and package our application.</p>&#13;
&#13;
<p>From a process point of view, nothing is different with this example from what we’ve covered before—we’ll run <code>mvn package</code> before running <code>sam deploy</code>.</p>&#13;
&#13;
<p>However, there’s a big structural difference to this example—we create separate ZIP file artifacts for each Lambda function.&#13;
Each ZIP file includes the classes for only one Lambda handler and the library dependencies it needs.</p>&#13;
&#13;
<p>While doing this for an application of this size is somewhat unnecessary, as your applications get bigger, it’s valuable to consider breaking up the artifacts for a few <span class="keep-together">reasons</span>:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Cold start time will be reduced (we’ll talk more about cold starts in <a data-type="xref" href="ch08.html#cold-starts">“Cold Starts”</a>).</p>&#13;
</li>&#13;
<li>&#13;
<p>Deployment time from local machines will typically be reduced since only the artifacts relating to changed functions will be uploaded for each deployment, assuming the use of the reproducible build plug-in we covered in <a data-type="xref" href="ch04.html#ch04">Chapter 4</a> (<a data-type="xref" href="ch04.html#reproducible-builds">“Reproducible Builds”</a>).</p>&#13;
</li>&#13;
<li>&#13;
<p>You may need to do so to avoid Lambda’s artifact size limitation.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>The final point relates to the 250MB size limit of (uncompressed) function artifacts in Lambda.&#13;
If you have 10 Lambda functions, all with different dependencies, and their combined (uncompressed) artifact size is more than 250MB, you’ll need to break up your artifact for each function to make deployment even possible.</p>&#13;
&#13;
<p>So how do we implement this?</p>&#13;
&#13;
<p>One way to think about it is that we’re effectively building a very small <a href="https://oreil.ly/p8jk_">monorepo</a> for our serverless application.&#13;
You can think of it, perhaps, as a “serverless application MiniMono.”&#13;
Regular monorepos consist of multiple projects in one repo; our MiniMono will consist of multiple Maven modules in one Maven project.&#13;
While Maven has its shortcomings, it does work very well as a way of declaring dependencies between multiple components, and their dependencies on external libraries.&#13;
And IntelliJ does a great job of interpreting multimodule Maven projects.</p>&#13;
&#13;
<p>Getting multimodule Maven projects working correctly is a little fiddly, so we’ll go step-by-step through it here.&#13;
We strongly recommend that you download the sample code and open it up in IntelliJ, since it’s likely to make more sense to you that way.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The top-level project" data-type="sect3"><div class="sect3" id="idm46222417918712">&#13;
<h3>The top-level project</h3>&#13;
&#13;
<p>Our top-level <em>pom.xml</em> file is going to look a little like <a data-type="xref" href="#EX5-10">Example 5-10</a>. We’ve cut out some of it to give clarity to the explanation.</p>&#13;
<div data-type="example" id="EX5-10">&#13;
<h5><span class="label">Example 5-10. </span>Parent project pom.xml for data pipeline app</h5>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;project&gt;</code>&#13;
  <code class="nt">&lt;groupId&gt;</code>my.groupId<code class="nt">&lt;/groupId&gt;</code>&#13;
  <code class="nt">&lt;artifactId&gt;</code>chapter5-Data-Pipeline<code class="nt">&lt;/artifactId&gt;</code>&#13;
  <code class="nt">&lt;version&gt;</code>1.0-SNAPSHOT<code class="nt">&lt;/version&gt;</code>&#13;
  <code class="nt">&lt;packaging&gt;</code>pom<code class="nt">&lt;/packaging&gt;</code>&#13;
&#13;
  <code class="nt">&lt;modules&gt;</code>&#13;
    <code class="nt">&lt;module&gt;</code>common-code<code class="nt">&lt;/module&gt;</code>&#13;
    <code class="nt">&lt;module&gt;</code>bulk-events-stage<code class="nt">&lt;/module&gt;</code>&#13;
    <code class="nt">&lt;module&gt;</code>single-event-stage<code class="nt">&lt;/module&gt;</code>&#13;
  <code class="nt">&lt;/modules&gt;</code>&#13;
&#13;
  <code class="nt">&lt;dependencyManagement&gt;</code>&#13;
    <code class="nt">&lt;dependencies&gt;</code>&#13;
      <code class="nt">&lt;dependency&gt;</code>&#13;
        <code class="nt">&lt;groupId&gt;</code>com.amazonaws<code class="nt">&lt;/groupId&gt;</code>&#13;
        <code class="nt">&lt;artifactId&gt;</code>aws-java-sdk-bom<code class="nt">&lt;/artifactId&gt;</code>&#13;
        <code class="nt">&lt;version&gt;</code>1.11.600<code class="nt">&lt;/version&gt;</code>&#13;
        <code class="nt">&lt;type&gt;</code>pom<code class="nt">&lt;/type&gt;</code>&#13;
        <code class="nt">&lt;scope&gt;</code>import<code class="nt">&lt;/scope&gt;</code>&#13;
      <code class="nt">&lt;/dependency&gt;</code>&#13;
      <code class="nt">&lt;dependency&gt;</code>&#13;
        <code class="nt">&lt;groupId&gt;</code>com.amazonaws<code class="nt">&lt;/groupId&gt;</code>&#13;
        <code class="nt">&lt;artifactId&gt;</code>aws-lambda-java-events<code class="nt">&lt;/artifactId&gt;</code>&#13;
        <code class="nt">&lt;version&gt;</code>2.2.6<code class="nt">&lt;/version&gt;</code>&#13;
      <code class="nt">&lt;/dependency&gt;</code>&#13;
      <code class="c">&lt;!-- etc --&gt;</code>&#13;
    <code class="nt">&lt;/dependencies&gt;</code>&#13;
  <code class="nt">&lt;/dependencyManagement&gt;</code>&#13;
&#13;
  <code class="nt">&lt;build&gt;</code>&#13;
    <code class="nt">&lt;pluginManagement&gt;</code>&#13;
      <code class="nt">&lt;plugins&gt;</code>&#13;
        <code class="nt">&lt;plugin&gt;</code>&#13;
          <code class="nt">&lt;artifactId&gt;</code>maven-assembly-plugin<code class="nt">&lt;/artifactId&gt;</code>&#13;
          <code class="nt">&lt;version&gt;</code>3.1.1<code class="nt">&lt;/version&gt;</code>&#13;
          <code class="nt">&lt;executions&gt;</code>&#13;
            <code class="nt">&lt;execution&gt;</code>&#13;
              <code class="nt">&lt;id&gt;</code>001-make-assembly<code class="nt">&lt;/id&gt;</code>&#13;
              <code class="nt">&lt;phase&gt;</code>package<code class="nt">&lt;/phase&gt;</code>&#13;
              <code class="nt">&lt;goals&gt;</code>&#13;
                <code class="nt">&lt;goal&gt;</code>single<code class="nt">&lt;/goal&gt;</code>&#13;
              <code class="nt">&lt;/goals&gt;</code>&#13;
            <code class="nt">&lt;/execution&gt;</code>&#13;
          <code class="nt">&lt;/executions&gt;</code>&#13;
          <code class="nt">&lt;configuration&gt;</code>&#13;
            <code class="nt">&lt;appendAssemblyId&gt;</code>false<code class="nt">&lt;/appendAssemblyId&gt;</code>&#13;
            <code class="nt">&lt;descriptors&gt;</code>&#13;
              <code class="nt">&lt;descriptor&gt;</code>src/assembly/lambda-zip.xml<code class="nt">&lt;/descriptor&gt;</code>&#13;
            <code class="nt">&lt;/descriptors&gt;</code>&#13;
            <code class="nt">&lt;finalName&gt;</code>lambda<code class="nt">&lt;/finalName&gt;</code>&#13;
          <code class="nt">&lt;/configuration&gt;</code>&#13;
        <code class="nt">&lt;/plugin&gt;</code>&#13;
        <code class="nt">&lt;plugin&gt;</code>&#13;
          <code class="nt">&lt;groupId&gt;</code>io.github.zlika<code class="nt">&lt;/groupId&gt;</code>&#13;
          <code class="nt">&lt;artifactId&gt;</code>reproducible-build-maven-plugin<code class="nt">&lt;/artifactId&gt;</code>&#13;
          <code class="nt">&lt;version&gt;</code>0.10<code class="nt">&lt;/version&gt;</code>&#13;
          <code class="nt">&lt;executions&gt;</code>&#13;
            <code class="nt">&lt;execution&gt;</code>&#13;
              <code class="nt">&lt;id&gt;</code>002-strip-jar<code class="nt">&lt;/id&gt;</code>&#13;
              <code class="nt">&lt;phase&gt;</code>package<code class="nt">&lt;/phase&gt;</code>&#13;
              <code class="nt">&lt;goals&gt;</code>&#13;
                <code class="nt">&lt;goal&gt;</code>strip-jar<code class="nt">&lt;/goal&gt;</code>&#13;
              <code class="nt">&lt;/goals&gt;</code>&#13;
            <code class="nt">&lt;/execution&gt;</code>&#13;
          <code class="nt">&lt;/executions&gt;</code>&#13;
          <code class="nt">&lt;configuration&gt;</code>&#13;
            <code class="nt">&lt;outputDirectory&gt;</code>${project.build.directory}<code class="nt">&lt;/outputDirectory&gt;</code>&#13;
          <code class="nt">&lt;/configuration&gt;</code>&#13;
        <code class="nt">&lt;/plugin&gt;</code>&#13;
      <code class="nt">&lt;/plugins&gt;</code>&#13;
    <code class="nt">&lt;/pluginManagement&gt;</code>&#13;
  <code class="nt">&lt;/build&gt;</code>&#13;
<code class="nt">&lt;/project&gt;</code></pre></div>&#13;
&#13;
<p>There are a few takeaways here:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>We add the <code>&lt;packaging&gt;pom&lt;/packaging&gt;</code> tag at the top level—this is declaring that this is a multimodule project.</p>&#13;
</li>&#13;
<li>&#13;
<p>We include the list of modules in the <code>&lt;modules&gt;</code> section.</p>&#13;
</li>&#13;
<li>&#13;
<p>Note that we don’t declare any inter-module dependencies at this point.</p>&#13;
</li>&#13;
<li>&#13;
<p>All of our external dependencies (not just the AWS SDK BOM) move into the <code>&lt;dependencyManagement&gt;</code> section.&#13;
It makes life easier to declare all the dependencies across the entire project here, and it guarantees that dependency versions are common across the whole project, but you don’t have too.</p>&#13;
</li>&#13;
<li>&#13;
<p>We’ll see in a moment that modules will declare which of these external dependencies they need.</p>&#13;
</li>&#13;
<li>&#13;
<p>Notice that we’ve still got the AWS SDK BOM that we talked about in the first example.&#13;
We move our build plug-in definitions into a <code>&lt;pluginManagement&gt;</code> section so that they can be used by the modules.</p>&#13;
</li>&#13;
<li>&#13;
<p>The configuration for the assembly plug-in remains at <em>src/assembly/lambda-zip.xml</em>, or you can use the version we’ve created for you in Maven Central.</p>&#13;
</li>&#13;
<li>&#13;
<p>There’s a whole bunch of other “Maven magic” detail here that we won’t go into!</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>With our top-level project in place, we can now create our modules.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The modules" data-type="sect3"><div class="sect3" id="idm46222417775416">&#13;
<h3>The modules</h3>&#13;
&#13;
<p>We create one subdirectory for each module, named the same as each element of the module list in the project <em>pom.xml</em>.</p>&#13;
&#13;
<p>Within each module subdirectory we create a new <em>pom.xml</em>.&#13;
We’ll start with the most simple one for <em>common-code</em>, which allows us to write code that is shared by both Lambda artifacts.&#13;
In our example, it contains the <code>WeatherEvent</code> class.</p>&#13;
&#13;
<p>Again, all of these Maven examples are slightly trimmed, so please refer to the book source code for the complete versions.</p>&#13;
<div data-type="example" id="EX5-11">&#13;
<h5><span class="label">Example 5-11. </span>Module pom.xml for common-code</h5>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;project&gt;</code>&#13;
  <code class="nt">&lt;parent&gt;</code>&#13;
    <code class="nt">&lt;groupId&gt;</code>my.groupId<code class="nt">&lt;/groupId&gt;</code>&#13;
    <code class="nt">&lt;artifactId&gt;</code>chapter5-Data-Pipeline<code class="nt">&lt;/artifactId&gt;</code>&#13;
    <code class="nt">&lt;version&gt;</code>1.0-SNAPSHOT<code class="nt">&lt;/version&gt;</code>&#13;
  <code class="nt">&lt;/parent&gt;</code>&#13;
&#13;
  <code class="nt">&lt;artifactId&gt;</code>common-code<code class="nt">&lt;/artifactId&gt;</code>&#13;
&#13;
  <code class="nt">&lt;build&gt;</code>&#13;
    <code class="nt">&lt;plugins&gt;</code>&#13;
      <code class="nt">&lt;plugin&gt;</code>&#13;
        <code class="nt">&lt;artifactId&gt;</code>reproducible-build-maven-plugin<code class="nt">&lt;/artifactId&gt;</code>&#13;
        <code class="nt">&lt;groupId&gt;</code>io.github.zlika<code class="nt">&lt;/groupId&gt;</code>&#13;
      <code class="nt">&lt;/plugin&gt;</code>&#13;
    <code class="nt">&lt;/plugins&gt;</code>&#13;
  <code class="nt">&lt;/build&gt;</code>&#13;
<code class="nt">&lt;/project&gt;</code></pre></div>&#13;
&#13;
<p>We declare our parent, our module’s <code>artifactId</code> (which for the sake of sanity should be the same as the module name), and then we declare which build plug-ins we want to use.&#13;
For this module we’re just creating a regular JAR file, of just the code in the module itself.&#13;
That means we don’t need to assemble a ZIP file, but we do still want to make use of the reproducible build plug-in.&#13;
The configuration for the plug-in comes from our definition in the <code>&lt;pluginManagement&gt;</code> section of the parent bom.</p>&#13;
&#13;
<p>Notice that there’s no <code>&lt;dependencies&gt;</code> section because this module doesn’t have any dependencies at this time.</p>&#13;
&#13;
<p>Next, in the <em>bulk-events-stage</em> subdirectory we create the <em>pom.xml</em> as shown in <a data-type="xref" href="#EX5-12">Example 5-12</a>.</p>&#13;
<div data-type="example" id="EX5-12">&#13;
<h5><span class="label">Example 5-12. </span>Module pom.xml for bulk-events-stage</h5>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;project&gt;</code>&#13;
  <code class="nt">&lt;parent&gt;</code>&#13;
    <code class="nt">&lt;groupId&gt;</code>my.groupId<code class="nt">&lt;/groupId&gt;</code>&#13;
    <code class="nt">&lt;artifactId&gt;</code>chapter5-Data-Pipeline<code class="nt">&lt;/artifactId&gt;</code>&#13;
    <code class="nt">&lt;version&gt;</code>1.0-SNAPSHOT<code class="nt">&lt;/version&gt;</code>&#13;
  <code class="nt">&lt;/parent&gt;</code>&#13;
&#13;
  <code class="nt">&lt;artifactId&gt;</code>bulk-events-stage<code class="nt">&lt;/artifactId&gt;</code>&#13;
&#13;
  <code class="nt">&lt;dependencies&gt;</code>&#13;
    <code class="nt">&lt;dependency&gt;</code>&#13;
      <code class="nt">&lt;groupId&gt;</code>my.groupId<code class="nt">&lt;/groupId&gt;</code>&#13;
      <code class="nt">&lt;artifactId&gt;</code>common-code<code class="nt">&lt;/artifactId&gt;</code>&#13;
      <code class="nt">&lt;version&gt;</code>${project.parent.version}<code class="nt">&lt;/version&gt;</code>&#13;
    <code class="nt">&lt;/dependency&gt;</code>&#13;
    <code class="nt">&lt;dependency&gt;</code>&#13;
      <code class="nt">&lt;groupId&gt;</code>com.amazonaws<code class="nt">&lt;/groupId&gt;</code>&#13;
      <code class="nt">&lt;artifactId&gt;</code>aws-lambda-java-events<code class="nt">&lt;/artifactId&gt;</code>&#13;
    <code class="nt">&lt;/dependency&gt;</code>&#13;
    <code class="c">&lt;!-- etc. --&gt;</code>&#13;
  <code class="nt">&lt;/dependencies&gt;</code>&#13;
&#13;
  <code class="nt">&lt;build&gt;</code>&#13;
    <code class="nt">&lt;plugins&gt;</code>&#13;
      <code class="nt">&lt;plugin&gt;</code>&#13;
        <code class="nt">&lt;artifactId&gt;</code>maven-assembly-plugin<code class="nt">&lt;/artifactId&gt;</code>&#13;
      <code class="nt">&lt;/plugin&gt;</code>&#13;
      <code class="nt">&lt;plugin&gt;</code>&#13;
        <code class="nt">&lt;artifactId&gt;</code>reproducible-build-maven-plugin<code class="nt">&lt;/artifactId&gt;</code>&#13;
        <code class="nt">&lt;groupId&gt;</code>io.github.zlika<code class="nt">&lt;/groupId&gt;</code>&#13;
      <code class="nt">&lt;/plugin&gt;</code>&#13;
    <code class="nt">&lt;/plugins&gt;</code>&#13;
  <code class="nt">&lt;/build&gt;</code>&#13;
<code class="nt">&lt;/project&gt;</code></pre></div>&#13;
&#13;
<p>The <code>&lt;parent&gt;</code> section is the same as for <em>common-code</em>, and <code>&lt;artifactId&gt;</code> follows the same rule as before.</p>&#13;
&#13;
<p>This time we do have dependencies.&#13;
The first one is how we declare an inter-module dependency, in this case to the <em>common-code</em> module.&#13;
Notice that we pick up the version from the parent module.&#13;
Then we declare all of our external dependencies.&#13;
Notice that there aren’t any versions for these—the versions come from the <code>&lt;dependency-management&gt;</code> section in the parent <em>pom.xml</em> (or, transitively, from the AWS SDK BOM).</p>&#13;
&#13;
<p>And finally in the <code>&lt;build&gt;</code> section we declare our build plug-ins.&#13;
This time we need to create a ZIP file (which will be the ZIP file just for the <code>BulkEventsLambda</code> function), and so we include a reference to <code>maven-assembly-plugin</code>.&#13;
Again, the configuration for the plug-in is defined in the parent <em>pom.xml</em>.</p>&#13;
&#13;
<p>The <em>single-event-stage</em> <em>pom.xml</em> looks almost the same as the <em>bulk-events-stage</em> <em>pom.xml</em>, but with fewer dependencies.</p>&#13;
&#13;
<p>With the Maven POM files complete, we then create <em>src</em> directories within each module.&#13;
The end result of our project directory tree looks as follows:</p>&#13;
&#13;
<pre data-type="programlisting">.&#13;
+--&gt; bulk-events-stage&#13;
|    +--&gt; src/main/java/book/pipeline/bulk&#13;
|    |                                +--&gt; BulkEventsLambda.java&#13;
|    +--&gt; pom.xml&#13;
+--&gt; common-code&#13;
|    +--&gt; src/main/java/book/pipeline/common&#13;
|    |                                +--&gt; WeatherEvent.java&#13;
|    +--&gt; pom.xml&#13;
+--&gt; single-event-stage&#13;
|    +--&gt; src/main/java/book/pipeline/single&#13;
|    |                                +--&gt; SingleEventLambda.java&#13;
|    +--&gt; pom.xml&#13;
+--&gt; src/assembly&#13;
|        +--&gt; lambda-zip.xml&#13;
+--&gt; pom.xml&#13;
+--&gt; template.yaml</pre>&#13;
&#13;
<p>Running <code>mvn package</code> for this multimodule project will create separate <em>lambda.zip</em> files in each of the two Lambda module directories.</p>&#13;
&#13;
<p>Since we have parallel modules that don’t depend on each other we can actually tune our use of Maven a little to increase build performance.&#13;
Running <code>mvn package -T 1C</code> will make Maven use multiple OS threads, one per core of your machine, when it can.<a data-primary="" data-startref="modules05" data-type="indexterm" id="idm46222417569896"/><a data-primary="" data-startref="artifact05" data-type="indexterm" id="idm46222417568920"/><a data-primary="" data-startref="BAPdata05" data-type="indexterm" id="idm46222417567976"/><a data-primary="" data-startref="SDPbuild05" data-type="indexterm" id="idm46222417567032"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Infrastructure" data-type="sect2"><div class="sect2" id="idm46222417937640">&#13;
<h2>Infrastructure</h2>&#13;
&#13;
<p>Despite<a data-primary="serverless data pipelines, building" data-secondary="application infrastructure" data-type="indexterm" id="SDPinfra05"/> the significant change in the structure of our Java project, our SAM template doesn’t change all that much.&#13;
Let’s look at how it does change, plus the other AWS resources that we use in <a data-type="xref" href="#EX5-13">Example 5-13</a>.</p>&#13;
<div data-type="example" id="EX5-13">&#13;
<h5><span class="label">Example 5-13. </span>SAM template for data pipeline</h5>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">AWSTemplateFormatVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">2010-09-09</code>&#13;
<code class="nt">Transform</code><code class="p">:</code> <code class="l-Scalar-Plain">AWS::Serverless-2016-10-31</code>&#13;
<code class="nt">Description</code><code class="p">:</code> <code class="l-Scalar-Plain">chapter5-data-pipeline</code>&#13;
&#13;
<code class="nt">Globals</code><code class="p">:</code>&#13;
  <code class="nt">Function</code><code class="p">:</code>&#13;
    <code class="nt">Runtime</code><code class="p">:</code> <code class="l-Scalar-Plain">java8</code>&#13;
    <code class="nt">MemorySize</code><code class="p">:</code> <code class="l-Scalar-Plain">512</code>&#13;
    <code class="nt">Timeout</code><code class="p">:</code> <code class="l-Scalar-Plain">10</code>&#13;
&#13;
<code class="nt">Resources</code><code class="p">:</code>&#13;
  <code class="nt">PipelineStartBucket</code><code class="p">:</code>&#13;
    <code class="nt">Type</code><code class="p">:</code> <code class="l-Scalar-Plain">AWS::S3::Bucket</code>&#13;
    <code class="nt">Properties</code><code class="p">:</code>&#13;
      <code class="nt">BucketName</code><code class="p">:</code> <code class="kt">!Sub</code> <code class="l-Scalar-Plain">${AWS::StackName}-${AWS::AccountId}-${AWS::Region}-start</code>&#13;
&#13;
  <code class="nt">FanOutTopic</code><code class="p">:</code>&#13;
    <code class="nt">Type</code><code class="p">:</code> <code class="l-Scalar-Plain">AWS::SNS::Topic</code>&#13;
&#13;
  <code class="nt">BulkEventsLambda</code><code class="p">:</code>&#13;
    <code class="nt">Type</code><code class="p">:</code> <code class="l-Scalar-Plain">AWS::Serverless::Function</code>&#13;
    <code class="nt">Properties</code><code class="p">:</code>&#13;
      <code class="nt">CodeUri</code><code class="p">:</code> <code class="l-Scalar-Plain">bulk-events-stage/target/lambda.zip</code>&#13;
      <code class="nt">Handler</code><code class="p">:</code> <code class="l-Scalar-Plain">book.pipeline.bulk.BulkEventsLambda::handler</code>&#13;
      <code class="nt">Environment</code><code class="p">:</code>&#13;
        <code class="nt">Variables</code><code class="p">:</code>&#13;
          <code class="nt">FAN_OUT_TOPIC</code><code class="p">:</code> <code class="kt">!Ref</code> <code class="l-Scalar-Plain">FanOutTopic</code>&#13;
      <code class="nt">Policies</code><code class="p">:</code>&#13;
       <code class="nt">— S3ReadPolicy</code><code class="p">:</code>&#13;
           <code class="nt">BucketName</code><code class="p">:</code> <code class="kt">!Sub</code> <code class="l-Scalar-Plain">${AWS::StackName}-${AWS::AccountId}-${AWS::Region}-start</code>&#13;
       <code class="nt">— SNSPublishMessagePolicy</code><code class="p">:</code>&#13;
           <code class="nt">TopicName</code><code class="p">:</code> <code class="kt">!GetAtt</code> <code class="l-Scalar-Plain">FanOutTopic.TopicName</code>&#13;
      <code class="nt">Events</code><code class="p">:</code>&#13;
        <code class="nt">S3Event</code><code class="p">:</code>&#13;
          <code class="nt">Type</code><code class="p">:</code> <code class="l-Scalar-Plain">S3</code>&#13;
          <code class="nt">Properties</code><code class="p">:</code>&#13;
            <code class="nt">Bucket</code><code class="p">:</code> <code class="kt">!Ref</code> <code class="l-Scalar-Plain">PipelineStartBucket</code>&#13;
            <code class="nt">Events</code><code class="p">:</code> <code class="l-Scalar-Plain">s3:ObjectCreated</code><code class="p-Indicator">:</code>&#13;
&#13;
  <code class="nt">SingleEventLambda</code><code class="p">:</code>&#13;
    <code class="nt">Type</code><code class="p">:</code> <code class="l-Scalar-Plain">AWS::Serverless::Function</code>&#13;
    <code class="nt">Properties</code><code class="p">:</code>&#13;
      <code class="nt">CodeUri</code><code class="p">:</code> <code class="l-Scalar-Plain">single-event-stage/target/lambda.zip</code>&#13;
      <code class="nt">Handler</code><code class="p">:</code> <code class="l-Scalar-Plain">book.pipeline.single.SingleEventLambda::handler</code>&#13;
      <code class="nt">Events</code><code class="p">:</code>&#13;
        <code class="nt">SnsEvent</code><code class="p">:</code>&#13;
          <code class="nt">Type</code><code class="p">:</code> <code class="l-Scalar-Plain">SNS</code>&#13;
          <code class="nt">Properties</code><code class="p">:</code>&#13;
            <code class="nt">Topic</code><code class="p">:</code> <code class="kt">!Ref</code> <code class="l-Scalar-Plain">FanOutTopic</code></pre></div>&#13;
&#13;
<p>First, while it’s still fresh in our minds, let’s look at the differences caused by the multimodule Maven project.&#13;
They are solely the updates to the <code>CodeUri</code> properties on the Lambda functions—where we used to have the same <code>target/lambda.zip</code> value for both functions in the API example, it’s now <code>bulk-events-stage/target/lambda.zip</code> for <code>BulkEventsLambda</code>, and <code>single-event-stage/target/lambda.zip</code> for the <code>SingleEventLambda</code>.</p>&#13;
&#13;
<p>OK, now let’s go back to the top.</p>&#13;
&#13;
<p>The <code>Globals</code> section is a little smaller this time.&#13;
That’s because there are no shared environment variables across the Lambda functions, and we don’t need any API <span class="keep-together">configuration</span>.</p>&#13;
&#13;
<p>Under <code>Resources</code>, first we declare our S3 bucket.&#13;
There are a whole lot of properties you can add here—access control–related properties are particularly popular.&#13;
One thing we typically like to add is server-side encryption as well as lifecycle policies.&#13;
But here we keep it to the defaults.&#13;
One thing that’s here is an explicitly declared name.&#13;
Normally we wouldn’t want to do this, and instead have CloudFormation generate a unique name for us, but due to an annoying aspect of CloudFormation’s S3 resource, if we don’t declare a name, then we get a circular dependency with some of the other elements of the file.</p>&#13;
&#13;
<p>S3 bucket names have to be globally unique across all AWS regions and accounts.&#13;
If you create a bucket named <em>sheep</em> in the us-east-1 region, then you can’t also create another one named <em>sheep</em> in us-west-2 (unless you first delete the one in us-east-1), and I can’t create a bucket named “sheep” at all.&#13;
This means that when you create a bucket name explicitly via an automated tool like CloudFormation, you need to include various context-unique aspects to avoid a naming collision.</p>&#13;
&#13;
<p>For example, we use the following declared bucket name:</p>&#13;
&#13;
<pre data-type="programlisting">!Sub ${AWS::StackName}-${AWS::AccountId}-${AWS::Region}-start</pre>&#13;
&#13;
<p>There’s some CloudFormation smarts happening here, so let’s unpack that a little.</p>&#13;
&#13;
<p>First of all <code>!Sub</code> is another <a href="https://oreil.ly/NaRtL"><em>intrinsic function</em></a>, just like <code>!Ref</code> in the first example.&#13;
<code>!Sub</code> substitutes variables in a string. Often you will use variables you declare yourself in template parameters, but in this case we are using CloudFormation <a href="https://oreil.ly/LUtMC"><em>pseudo parameters</em></a>—variables that CloudFormation defines on our behalf.&#13;
Say I created a stack named <em>my-stack</em>, our account ID was 123456, and we had created the stack in us-west-2, then the bucket name in this stack would be <em>my-stack-123456-us-west-2-start</em>.</p>&#13;
&#13;
<p>The next resource is our SNS Topic. Look—no properties!&#13;
SNS is partly configurable, but it’s also super simple to use with no configuration at all.</p>&#13;
&#13;
<p>And then we have our two Lambda functions.</p>&#13;
&#13;
<p><code>BulkEventsLambda</code> has an environment variable referring to the Amazon Resource Name (ARN) of the SNS topic.&#13;
The <a href="https://oreil.ly/r6oVW">SNS Topic CloudFormation documentation</a> tells us that calling <code>!Ref</code> on a Topic resource returns its ARN.</p>&#13;
&#13;
<p>For the security side of this Lambda we both need to read from the S3 bucket—which we refer to with the same name as we used when declaring the bucket in the first place—and we need to write (or publish) to the SNS topic.&#13;
For the SNS topic, the security policy doesn’t need the ARN (which is what is returned when we call <code>!Ref</code> on the Topic resource); it needs the Topic’s name.&#13;
To get that, we use a third intrinsic function—<code>!GetAtt</code>.&#13;
<code>!GetAtt</code> allows us to read secondary return values from a CloudFormation resource.&#13;
Again, when looking at the SNS documentation, we can see that the name is returned when asking for <code>TopicName</code>, hence the value <code>!GetAtt FanOutTopic.TopicName</code>.</p>&#13;
&#13;
<p>Finally, for <code>BulkEventsLambda</code> we need to declare the event source. This is the S3 bucket, and we declare the type of S3 events we care about in the <code>Events</code> fields.&#13;
You can be much more prescriptive here if you like, for example including filter patterns to only trigger events for certain S3 keys.</p>&#13;
&#13;
<p>As you’d expect, <code>SingleEventLambda</code> is simpler since it doesn’t call any AWS resources.&#13;
For this function, we just need to declare the event source, which is the SNS Topic, referred to by the Topic’s ARN.<a data-primary="" data-startref="SDPinfra05" data-type="indexterm" id="idm46222417352840"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Deployment" data-type="sect2"><div class="sect2" id="idm46222417565496">&#13;
<h2>Deployment</h2>&#13;
&#13;
<p>Deployment<a data-primary="serverless data pipelines, building" data-secondary="deployment" data-type="indexterm" id="idm46222417350296"/><a data-primary="deployment" data-secondary="serverless data pipeline example" data-type="indexterm" id="idm46222417349320"/> is similar to what you’ve seen before.&#13;
Again, we’re using the principles of a serverless application in that we collectively deploy all of the components together.</p>&#13;
&#13;
<p>There’s one small change for deploying this app.&#13;
Because we’re using the stack name in the manually defined S3 bucket name, we have to use only lowercase letters in the stack name (because S3 buckets can’t be named with uppercase letters):</p>&#13;
&#13;
<pre data-type="programlisting">$ sam deploy \&#13;
  --s3-bucket $CF_BUCKET \&#13;
  --stack-name chapter-five-data-pipeline \&#13;
  --capabilities CAPABILITY_IAM</pre>&#13;
&#13;
<p>Once the application is deployed, you can explore the deployed components via the Lambda Applications console, or the CloudFormation console.&#13;
<a data-type="xref" href="#data-pipeline-appview">Figure 5-11</a> shows what it looks like in Lambda applications.</p>&#13;
&#13;
<figure><div class="figure" id="data-pipeline-appview">&#13;
<img alt="images/ch05_image11.png" src="assets/awsl_0511.png"/>&#13;
<h6><span class="label">Figure 5-11. </span>Serverless Application view for data pipeline</h6>&#13;
</div></figure>&#13;
&#13;
<p>Clicking the resources will take you through to their own parts of the AWS Console. To test this application, we need to upload a file to S3. One option is to do that manually through the web console.</p>&#13;
&#13;
<p>A more automated approach is as follows.</p>&#13;
&#13;
<p>First, query CloudFormation to get the name of the S3 bucket, and assign that to a shell variable:</p>&#13;
&#13;
<pre data-type="programlisting">$ PIPELINE_BUCKET="$(aws cloudformation describe-stack-resource \&#13;
  --stack-name chapter-five-data-pipeline \&#13;
  --logical-resource-id PipelineStartBucket \&#13;
  --query 'StackResourceDetail.PhysicalResourceId' \&#13;
  --output text)"</pre>&#13;
&#13;
<p>Now use the AWS CLI to upload the sample file:</p>&#13;
&#13;
<pre data-type="programlisting">$ aws s3 cp sampledata.json s3://${PIPELINE_BUCKET}/sampledata.json</pre>&#13;
&#13;
<p>Now look at the logs for the <code>SingleEventLambda</code> function, and you’ll see, after a few seconds, each of the weather events separately logged.</p>&#13;
&#13;
<p>Congratulations—you’ve built your second serverless application!</p>&#13;
&#13;
<p>As you can imagine, with the vast number of services available on AWS, the different types of serverless application that can be built are innumerable.&#13;
And that’s before we even consider the perfectly valid capability of calling services outside of AWS from Lambda!</p>&#13;
&#13;
<p>We hope that this chapter has given you a taste of what’s possible.&#13;
The ability to deploy complete, multicomponent, applications with just a few text files, in minutes or seconds, and then tear them down again, makes for an extraordinarily valuable “application sandbox” environment that can also scale to real production use.<a data-primary="" data-startref="SAdatapipe05" data-type="indexterm" id="idm46222417336600"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="idm46222418715032">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>We<a data-primary="APIs" data-see="serverless APIs, building" data-type="indexterm" id="idm46222417334264"/><a data-primary="data pipelines" data-see="serverless data pipelines, building" data-type="indexterm" id="idm46222417333192"/> started this chapter by looking at how to trigger Lambda functions from other AWS services.&#13;
Understanding this is an important first step to embracing serverless architecture.</p>&#13;
&#13;
<p>We then explored two example serverless applications—wholly contained groups of AWS resources that can be collectively deployed. The first example was a database-backed HTTP API, using two synchronously invoked Lambda functions, along with the AWS services API Gateway and DynamoDB.</p>&#13;
&#13;
<p>The second example was a serverless data pipeline consisting of two asynchronous processing stages, including a fan-out design.&#13;
This example used Lambda, S3, and SNS.&#13;
In this example, we also explored using multimodule Maven projects to create a “serverless application MiniMono.”</p>&#13;
&#13;
<p>You<a data-primary="framework, for building serverless applications" data-type="indexterm" id="idm46222417330088"/><a data-primary="serverless applications" data-secondary="framework for building" data-type="indexterm" id="idm46222417329256"/><a data-primary="serverless APIs, building" data-secondary="framework for building" data-type="indexterm" id="idm46222417328312"/><a data-primary="serverless data pipelines, building" data-secondary="framework for building" data-type="indexterm" id="idm46222417327352"/> now have a framework for building serverless AWS applications:</p>&#13;
<ol>&#13;
<li>&#13;
<p>Identify the <em>behavior</em> you want your application to have.</p>&#13;
</li>&#13;
<li>&#13;
<p>Design the <em>architecture</em> of your application by choosing which services will implement the different aspects of your system, and how those services will interact.</p>&#13;
</li>&#13;
<li>&#13;
<p>Program <em>Lambda code</em> to:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Consume the correct event types.</p>&#13;
</li>&#13;
<li>&#13;
<p>Perform the necessary side effects on downstream services.</p>&#13;
</li>&#13;
<li>&#13;
<p>Where relevant, return the correct response.</p>&#13;
</li>&#13;
</ul>&#13;
</li>&#13;
<li>&#13;
<p>Configure your <em>infrastructure</em> using a CloudFormation/SAM template.</p>&#13;
</li>&#13;
<li>&#13;
<p>Execute <em>deployment</em> using the correct AWS tooling.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>So far all of our testing has been very manual. How can we do better, using automated testing techniques? That’s what we explore in the next chapter.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Exercises" data-type="sect1"><div class="sect1" id="idm46222417315160">&#13;
<h1>Exercises</h1>&#13;
<ol>&#13;
<li>&#13;
<p>Another<a data-primary="exercises" data-secondary="building serverless applications" data-type="indexterm" id="idm46222417313192"/> great event source for “getting started” with Lambda is<a data-primary="CloudWatch Scheduled Events" data-type="indexterm" id="idm46222417312088"/> CloudWatch Scheduled Events, which we can use to build “serverless cron jobs.”&#13;
We describe this use of Lambda in <a data-type="xref" href="ch09.html#lambda-cron-jobs">“Example: Lambda “cron jobs””</a>.&#13;
Build a Lambda function that will run every minute, and for now that just writes out a log statement when it’s called.&#13;
See the <a href="https://oreil.ly/C_FhY">SAM documentation</a> on how to set up this trigger.</p>&#13;
</li>&#13;
<li>&#13;
<p>Update your scheduled event Lambda from the previous exercise to post a message to SNS, similar to how we did so in <code>BulkEventsLambda</code> earlier in this chapter.&#13;
Update your SNS topic to send an SMS, or text, message to your mobile phone (see the <a href="https://oreil.ly/TrQct">AWS documentation</a> on how to do this).</p>&#13;
</li>&#13;
<li>&#13;
<p>Reimplement the data pipeline example from this chapter to use an SQS queue, rather than an SNS topic, between the two Lambdas.&#13;
A couple of good starting places to help with this are <a href="https://oreil.ly/LKekx">here</a> and <a href="https://oreil.ly/Cbvb3">here</a> in the Lambda documentation.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section></body></html>