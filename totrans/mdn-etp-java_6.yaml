- en: Chapter 6\. Building Kubernetes-Native Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 6 章\. 构建 Kubernetes 本地应用程序
- en: In the previous chapter, we outlined how to migrate from the traditional Java
    enterprise pattern to a container-centric approach. In this chapter, we will walk
    through the components needed to migrate to microservices-based architectures
    and how Kubernetes can connect the dots.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们概述了如何从传统的 Java 企业模式迁移到以容器为中心的方法。在本章中，我们将详细介绍迁移到基于微服务的架构所需的组件以及 Kubernetes
    如何连接各个点。
- en: We also learned in previous chapters how much a microservices-based approach
    helps to make our software reliable, portable, and ready to scale upon demand.
    Modern architectures are planned with scalability already in the scope since the
    beginning, and this offers both opportunities and challenges. Enterprise Java
    developers know their code is usually part of the business logic, relying on frameworks
    to make it robust and consistent with well-recognized software design patterns.
    It is more common today that the same application could serve millions of requests
    running on a public cloud, even distributed geographically. To do that, it has
    to be architected to fit this model, decoupling functions, avoiding a single point
    of failure, and distributing the load to several parts of the architecture to
    avoid service interruptions.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在前几章中学习了基于微服务的方法如何帮助我们使软件可靠、可移植，并且在需求增加时已做好扩展准备。现代架构从一开始就计划了可扩展性，这既提供了机会也带来了挑战。企业
    Java 开发人员知道他们的代码通常是业务逻辑的一部分，依赖于框架使其稳健并符合公认的软件设计模式。如今，同一应用程序在公共云上可能服务数百万请求，甚至在地理上分布广泛。为了做到这一点，必须对其进行架构设计，使之符合这一模型，解耦功能，避免单点故障，并将负载分布到架构的多个部分，以避免服务中断。
- en: Find the Right Balance Between Scalability and Complexity
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在可扩展性和复杂性之间找到合适的平衡点
- en: 'In an ideal world, all applications would be stateless, and they could scale
    up independently. They wouldn’t crash, and the network links would always be reliable.
    The reality looks different. The migration from monoliths to microservices-based
    architectures enables cloud native deployments, and we’ve covered some of the
    benefits that brings. However, that also brings some challenges: managing multiple
    points of ingress for your app, keeping the relationships between multiple microservices
    consistent, and managing distributed databases and schemas.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在理想的世界中，所有应用程序都是无状态的，它们可以独立扩展。它们不会崩溃，并且网络连接始终可靠。现实看起来不同。从单体应用迁移到基于微服务的架构使得云原生部署成为可能，我们已经介绍了这带来的一些好处。然而，这也带来了一些挑战：管理应用程序的多个入口点，保持多个微服务之间的关系一致性，以及管理分布式数据库和模式。
- en: In [Figure 6-1](#fig6-2), you can see how the transition from monolithic to
    microservices-based apps brings a new approach, having multiple interconnections
    or even multiple databases to work with.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [图 6-1](#fig6-2) 中，您可以看到从单体到基于微服务的应用程序的过渡带来了一种新的方法，有多个互连或甚至多个数据库可供使用。
- en: '![From Monolith to Microservices Architectures](Images/moej_0601.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![从单体到微服务架构](Images/moej_0601.png)'
- en: Figure 6-1\. From monolith to microservices architectures
  id: totrans-7
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-1\. 从单体架构到微服务架构
- en: Similar to the [CAP theorem](https://oreil.ly/nruM5), it is very hard to simultaneously
    provide scalability without increasing the complexity of a system. That’s why
    Kubernetes is so helpful because it’s ubiquitous, it runs in any cloud, and you
    can delegate most of this complexity to this platform. This lets you focus “just”
    on app development. On the other hand, we need to find a solution also for *stateful*
    apps in the cloud native world, and we will see that Kubernetes also provides
    help on this side.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 [CAP 定理](https://oreil.ly/nruM5)，同时提供可扩展性而不增加系统复杂性是非常困难的。这就是为什么 Kubernetes
    如此有帮助，因为它是无处不在的，在任何云中运行，并且您可以将大部分复杂性委托给这个平台。这使您可以“只是”专注于应用程序开发。另一方面，在云原生世界中，我们也需要为*有状态*应用找到解决方案，我们将看到
    Kubernetes 在这方面也提供了帮助。
- en: Functional Requirements for Modern Architectures
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现代架构的功能需求
- en: Kubernetes is very helpful with defining distributed applications as shown in
    [Figure 3-1](ch03.xhtml#fig3-2). Any Java developer should be well aware of [Design
    Patterns](https://oreil.ly/V4aqC) from Gang of Four, a masterpiece of software
    engineering where authors define the most-used software design patterns. Kubernetes
    extends this set of patterns, creating a new set of cloud native specific requirements
    to make applications resilient to various loads as shown in [Figure 6-2](#fig6-3).
    Let’s dig into some of those in the next sections.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes在定义分布式应用方面非常有帮助，如[图 3-1](ch03.xhtml#fig3-2)所示。任何Java开发者都应该对[《设计模式》](https://oreil.ly/V4aqC)有所了解，这是软件工程的杰作，作者在其中定义了最常用的软件设计模式。Kubernetes扩展了这些模式集合，创建了一组新的云原生特定要求，使应用程序能够抵御各种负载，如[图 6-2](#fig6-3)所示。接下来让我们深入探讨其中的一些内容。
- en: '![Functional requirements for Modern Architectures](Images/moej_0602.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![现代架构的功能要求](Images/moej_0602.png)'
- en: Figure 6-2\. Functional requirements for modern architectures
  id: totrans-12
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-2\. 现代架构的功能要求
- en: API-Driven
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: API驱动
- en: 'The microservices mantra is “API first.” If you take a look again at [Figure 6-1](#fig6-2),
    you’ll notice that splitting a monolithic app into a bunch of microservices leads
    to the first challenge: how to let these pieces of software communicate with each
    other? In monoliths, you rely on the app scope of modules, packages. Microservices
    usually communicate with each other via REST calls, where each one can be either
    producer or consumer of services. This is not the only way to connect your microservices;
    it’s also a common use case to use queues, messages, or caches. But in general,
    each microservice exposes its primitives or functions through a set of APIs, and
    this can also be intermediated by an API gateway as we discussed in the Coolstore
    example in [Chapter 2](ch02.xhtml#changing_technologies).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务的口号是“API先行”。如果你再看一下[图 6-1](#fig6-2)，你会注意到将单体应用程序拆分为一堆微服务的第一个挑战：如何让这些软件片段彼此通信？在单体应用中，你依赖于模块、包的应用范围。而微服务通常通过REST调用彼此通信，每个微服务可以是服务的生产者或消费者。连接微服务的方式不仅限于这种方法；使用队列、消息或缓存也是常见用例。但总体而言，每个微服务通过一组API暴露其原语或函数，并且这也可以通过我们在[第2章](ch02.xhtml#changing_technologies)讨论的Coolstore示例中的API网关来进行中介。
- en: Kubernetes itself is API-driven software. All core components of the platform
    such as Pods, Services, and Deployments are manipulated through REST APIs. All
    operations and communications between components and external user commands are
    [REST API calls that the API server handles](https://oreil.ly/PauGF). When we
    interact with Kubernetes through `kubectl` or JKube, we are just invoking an API
    via HTTPS sending and receiving JSON content. This ecosystem of APIs is the perfect
    environment for an API-driven architecture, such as one that uses microservices.
    Now that we know how our microservices communicate, how do we discover new services?
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes本身是API驱动的软件。平台的所有核心组件，如Pod、Service和Deployment，都通过REST API进行操作。所有组件之间的操作和与外部用户命令的通信都是通过REST
    API调用处理的，API服务器处理这些调用。当我们通过`kubectl`或JKube与Kubernetes交互时，实际上是通过HTTPS调用API发送和接收JSON内容。这种API生态系统是API驱动架构的理想环境，比如使用微服务的架构。既然我们知道了我们的微服务如何通信，那么我们如何发现新的服务呢？
- en: Discovery
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发现
- en: It’s pretty straightforward to let microservices communicate with each other
    using REST calls. In addition, it would be nice to have the invocation of other
    components and functions at ease, such as when importing a module or a package
    into our app. In modern architectures, the number of microservices to invoke and
    connect could potentially be pretty high, thus it may not be enough to simply
    store the network endpoints such as IP address or hostnames. As we discussed in
    [Chapter 4](ch04.xhtml#kubernetes_based_softw_dev_platform), Kubernetes simplifies
    networking with the `Service` object, allowing two or more Pods to talk to each
    other within the platform’s internal networking. Kubernetes also provides the
    capability to list objects inside the cluster from an application, thanks to its
    API. Java developers can use frameworks such as JKube to have a Java Kubernetes
    client for this purpose.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让微服务之间通过 REST 调用相互通信非常直接。此外，让组件和函数调用变得轻松也是很好的，例如导入模块或包到我们的应用程序中。在现代架构中，需要调用和连接的微服务数量可能非常多，因此仅存储网络端点（如
    IP 地址或主机名）可能不足够。正如我们在[第四章](ch04.xhtml#kubernetes_based_softw_dev_platform)讨论的那样，Kubernetes
    通过`Service`对象简化了网络，允许两个或多个 Pods 在平台的内部网络中互相通信。Kubernetes 还通过其 API 提供了从应用程序内部列出集群中对象的能力。Java
    开发人员可以使用像 JKube 这样的框架来实现 Java Kubernetes 客户端。
- en: Listing Kubernetes Services and Pods, which represent some microservices, is
    the first step to a real-time inventory of components of our software stack, which
    additionally helps to maintain and extend at runtime applications. Furthermore,
    Kubernetes enables integration with external tools or frameworks for that, such
    as Service Mesh, which provides service discovery protocol to detect services
    as they come up.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 列出 Kubernetes 服务和 Pods，这些 Pods 表示一些微服务，是实时组件清单的第一步，这进一步有助于在运行时维护和扩展应用程序。此外，Kubernetes
    还支持与外部工具或框架的集成，例如 Service Mesh，提供服务发现协议以检测服务的上线。
- en: Tip
  id: totrans-19
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: '[Service mesh](https://oreil.ly/jGh80) is an increasingly popular choice for
    microservices-based architectures. It provides a control panel that also interacts
    with Kubernetes to manage service discovery, mutual authentication, A/B testing,
    routing, and circuit breaker pattern out of the box. [Further details can be found
    online](https://oreil.ly/ECIF4).'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '[服务网格](https://oreil.ly/jGh80) 是基于微服务架构越来越受欢迎的选择。它提供一个控制面板，还与 Kubernetes 交互以管理服务发现、双向认证、A/B
    测试、路由和断路器模式。[更多详细信息可在线找到](https://oreil.ly/ECIF4)。'
- en: Security and Authorization
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全性与授权
- en: Another challenge that modern app developers need to take into account is security
    for the entire stack. From the app to the platform, best practices also apply
    to modern architectures, and the complexity and the required effort may rise significantly
    when there are many services to connect, many databases to query, and many endpoints
    to serve. Again, Kubernetes comes in to help.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现代应用程序开发人员需要考虑的另一个挑战是整个堆栈的安全性。从应用程序到平台，最佳实践同样适用于现代架构，当需要连接多个服务、查询多个数据库和服务多个端点时，复杂性和所需的工作量可能显著增加。再次提到，Kubernetes
    可以提供帮助。
- en: Kubernetes provides security for the entire ecosystem. Role-based access control
    (RBAC) and fine-grained permission rules are possible. Furthermore, Pods are run
    by a special user called *Service Account* that has access to the Kubernetes API
    Server, usually having limited scope to the user’s namespace. Besides that, Kubernetes
    provides a special API to manage passwords and certificates called *Secrets*.
    A Secret is a volume mounted into the Pod by the platform at runtime, with its
    value stored into Kubernetes’s database etcd, along with cluster state and configurations.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 为整个生态系统提供安全性。基于角色的访问控制（RBAC）和精细化的权限规则是可能的。此外，Pods 由一个名为*Service Account*的特殊用户运行，该用户可以访问
    Kubernetes API Server，通常仅限于用户的命名空间。除此之外，Kubernetes 还提供了一个专用的 API 来管理密码和证书，称为*Secrets*。Secret
    是一个在运行时由平台挂载到 Pod 中的卷，其值与 Kubernetes 的数据库 etcd 一起存储，以及集群状态和配置。
- en: Note
  id: totrans-24
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '[etcd](https://etcd.io) is a distributed key-value database used by Kubernetes
    to store the cluster state. The content of the database can be also encrypted,
    and only the cluster administrator can access its content.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '[etcd](https://etcd.io) 是 Kubernetes 使用的分布式键值数据库，用于存储集群状态。数据库内容也可以加密，只有集群管理员可以访问其内容。'
- en: As we discussed, the communication between microservices is usually done via
    HTTPS REST calls, whose certificates are managed via Secrets. Containers and Kubernetes
    provide a good starting point for ensuring security in applications, from which
    Java developers can start to implement app security best practices.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所讨论的，微服务之间的通信通常是通过 HTTPS REST 调用完成的，其证书是通过 Secrets 管理的。容器和 Kubernetes 为确保应用程序安全提供了一个良好的起点，从中
    Java 开发人员可以开始实施应用程序安全最佳实践。
- en: Monitoring
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 监控
- en: Measuring resource consumption is essential in modern architectures, and ever
    more so in cloud environments with a pay-per-use consumption model. It isn’t easy
    to estimate how many computational resources your app will need under stress,
    and overestimation may increase costs. Kubernetes enables monitoring at the operating
    system level to application level, with its ecosystem of API and tools.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代架构中，测量资源消耗是至关重要的，在具有按使用量付费的消费模型的云环境中更是如此。估计在压力下您的应用程序将需要多少计算资源并不容易，而且过度估计可能会增加成本。Kubernetes
    通过其 API 和工具生态系统使监视在操作系统级别到应用程序级别成为可能。
- en: A popular cloud native tool to gather metrics from the platform and the app
    is [Prometheus](https://prometheus.io), a time-series database that can export
    metrics from the Kubernetes cluster and apps using [a query language called PromQL](https://oreil.ly/tYn9Q).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 从平台和应用程序收集指标的热门云原生工具是[Prometheus](https://prometheus.io)，这是一个时间序列数据库，可以使用[一种称为
    PromQL 的查询语言](https://oreil.ly/tYn9Q)从 Kubernetes 集群和应用程序导出指标。
- en: Metrics are also used to help Kubernetes decide when to scale your application
    up or down according to the monitored load on the app. You can drive this scale
    with custom metrics, such as JVM threads or queue size, and make monitoring a
    proactive tool to empower your services. Prometheus also provides alerts and alarms,
    which are useful to schedule automated actions for your applications when they
    need to react faster.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 指标也被用来帮助 Kubernetes 根据应用程序的监控负载决定何时扩展或缩减您的应用程序。您可以使用自定义指标（如 JVM 线程或队列大小）驱动此规模，并使监视成为赋予服务力量的积极工具。Prometheus
    还提供了警报和报警功能，对于在应用程序需要更快地做出反应时调度自动操作非常有用。
- en: Java developers can also interact with Prometheus and metrics inside Kubernetes
    with [Micrometer](https://micrometer.io), an open source tool that provides a
    registration mechanism for metrics and core metric types. It is available for
    any JVM-based workloads, and it is the popular choice for both Spring Boot and
    Quarkus projects to interact with Prometheus and Kubernetes. “Think SLF4J, but
    for metrics.”
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Java 开发人员还可以使用[Micrometer](https://micrometer.io)与 Kubernetes 内部的 Prometheus
    和指标进行交互，Micrometer 是一个提供指标注册机制和核心指标类型的开源工具。它适用于任何基于 JVM 的工作负载，并且是与 Prometheus
    和 Kubernetes 进行交互的 Spring Boot 和 Quarkus 项目的热门选择。“就像 SLF4J，但用于指标。”
- en: Tracing
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 追踪
- en: Observability is another key aspect in modern architectures, and measuring latency
    between REST API calls is an important facet of managing microservices-based apps.
    It is crucial to ensure that the communication is always clear and the latency
    is minimal. When the number of microservices increases, a small delay in some
    part of the architecture can result in an acceptable service interruption for
    the user. In these situations, Kubernetes is helpful for debugging the majority
    of operational problems that arise when moving to a distributed architecture.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 可观察性是现代架构的另一个关键方面，而测量 REST API 调用之间的延迟是管理基于微服务的应用程序的重要方面。确保通信始终清晰且延迟最小是至关重要的。当微服务的数量增加时，架构的某些部分出现小延迟可能会导致对用户来说可接受的服务中断。在这些情况下，Kubernetes
    对于调试移动到分布式架构时出现的大多数操作问题非常有帮助。
- en: '[Jaeger](https://www.jaegertracing.io) is a popular open source tool that connects
    to Kubernetes to provide observability. It uses distributed tracing to follow
    the path of a request through different microservices. It provides a visual representation
    of the call flows through a dashboard, and it is often also integrated with Service
    mesh. Jaeger is very helpful to developers for monitoring distributed transactions,
    optimizing performance and latency, and performing root cause analysis.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '[Jaeger](https://www.jaegertracing.io) 是一个流行的开源工具，连接到 Kubernetes 以提供可观察性。它使用分布式跟踪来跟踪请求通过不同微服务的路径。它通过仪表板提供了调用流程的视觉表示，通常也与服务网格集成。Jaeger
    对于开发人员监视分布式事务、优化性能和延迟以及执行根本原因分析非常有帮助。'
- en: Logging
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 日志
- en: As we discussed, a single call in your microservices-based app, such as the
    Coolstore example, can invoke different services that interact with each other.
    It’s important to monitor and observe the app, but also to store relevant pieces
    of information in logs. Your application’s logging approach changes with modern
    apps. While in monoliths we usually rely on multiple log files stored in different
    paths on the disk, usually managed by the application server, distributed apps
    *stream* logs. As your app can scale up rapidly and move to different nodes or
    even clouds, it makes no sense to access the single instance to retrieve logs;
    therefore, a distributed log system is needed.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们讨论的，微服务应用程序中的单个调用，例如 Coolstore 示例，可能会调用与其他服务进行交互的不同服务。监视和观察应用程序非常重要，同时还要将相关信息存储在日志中。现代应用程序的日志记录方法与单体应用程序不同。在单体应用中，我们通常依赖于存储在磁盘上不同路径的多个日志文件，通常由应用服务器管理，而分布式应用程序则会
    *流式传输* 日志。由于您的应用程序可能会快速扩展并移动到不同的节点甚至云中，因此访问单个实例以检索日志是没有意义的；因此，需要分布式日志系统。
- en: Kubernetes makes logging easy as well. By default, it provides the capability
    to access a Pod’s logs by reading the application’s standard streams such as STDOUT
    (Standard Output) and STDERR (Standard Error). Thus, the app should not write
    logs into a certain path, but send logs to standard streams.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 使日志记录变得简单。默认情况下，它提供访问 Pod 日志的能力，通过读取应用程序的标准流，例如 STDOUT（标准输出）和 STDERR（标准错误）。因此，应用程序不应该将日志写入特定路径，而是发送到标准流。
- en: Note
  id: totrans-38
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注
- en: It is still possible to store logs in specific paths that can also be persistent
    in Kubernetes, but this is considered an antipattern.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然可以将日志存储在特定路径中，这些路径也可以在 Kubernetes 中保持持久化，但这被认为是一种反模式。
- en: Kubernetes also interacts with distributed logging systems such as [Elasticsearch](https://elastic.co),
    an open source document-oriented NoSQL database based on [Apache Lucene](https://lucene.apache.org)
    to store logs and events. Elasticsearch usually comes with a forwarder, such as
    [Fluentd](https://fluentd.org), and a dashboard to visualize logs such as [Kibana](https://elastic.co/kibana).
    Together, this creates the EFK stack (Elasticsearch, Fluentd, Kibana). With this
    logging stack, developers consult logs from multiple microservices in an aggregated
    view through the Kibana dashboard, and they are also able to make queries in a
    query language called Kibana Query Language (KQL).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 还与分布式日志系统如 [Elasticsearch](https://elastic.co) 交互，这是一个基于 [Apache
    Lucene](https://lucene.apache.org) 的开源文档导向型 NoSQL 数据库，用于存储日志和事件。Elasticsearch
    通常带有转发器，如 [Fluentd](https://fluentd.org)，以及用于可视化日志的仪表板，例如 [Kibana](https://elastic.co/kibana)。这些共同组成了
    EFK 堆栈（Elasticsearch、Fluentd、Kibana）。借助这种日志堆栈，开发人员可以通过 Kibana 仪表板的聚合视图查看多个微服务的日志，并能够在称为
    Kibana 查询语言（KQL）的查询语言中进行查询。
- en: Distributed logging is the de facto standard with cloud native apps, and Kubernetes
    connects and interacts with many offerings such as EFK to provide centralized
    logging for the whole cluster.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 云原生应用的默认标准是分布式日志记录，Kubernetes 与许多服务如 EFK 连接并进行交互，为整个集群提供集中日志记录。
- en: CI/CD
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CI/CD
- en: Continuous Integration (CI) is a phase in the software development cycle where
    code from different team members or different features is integrated. This usually
    involves merging code (integration), building the application (container), and
    carrying out basic tests, all within an ephemeral environment.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 连续集成（CI）是软件开发周期中的一个阶段，在这个阶段，来自不同团队成员或不同功能的代码被集成。通常涉及代码合并（集成）、应用程序构建（容器化）和在临时环境中执行基本测试。
- en: Continuous Delivery (CD) refers to a set of practices to automate various aspects
    of delivery software. One of these practices is called delivery pipeline, which
    is an automated process to define the steps a change in code or configuration
    has to go through to reach upper environments and eventually production.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 连续交付（CD）是指自动化软件交付各个方面的一组实践。其中之一是交付管道，这是一个自动化过程，用于定义代码或配置更改必须经历的步骤，以达到更高的环境并最终到达生产环境。
- en: Together, they are often referred to as CI/CD, and it is one of the key technology
    enablers for DevOps methodology.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 它们经常被称为 CI/CD，并且是 DevOps 方法论的关键技术推动者之一。
- en: Modern services need to react fast to changes or issues. As we can monitor,
    trace, and log distributed architectures, we should also be able to update our
    microservices-based app faster. Pipelines are the best way to deploy apps in production
    following the phases as shown in [Figure 6-3](#fig6-4).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现代服务需要快速响应变化或问题。正如我们可以监控、跟踪和记录分布式架构一样，我们还应该能够更快地更新基于微服务的应用程序。流水线是在生产环境中部署应用程序的最佳方式，遵循如
    [图 6-3](#fig6-4) 所示的阶段。
- en: '![Continuous Integration and Continuous Delivery](Images/moej_0603.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![持续集成和持续交付](Images/moej_0603.png)'
- en: Figure 6-3\. Continuous Integration and Continuous Delivery
  id: totrans-48
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-3\. 持续集成和持续交付
- en: A *pipeline* is a series of steps, sequential or parallel, that build and test
    the app in all preproduction environments before finally releasing it to production.
    It can be fully automated or can interact with external tools for manual step
    approval (e.g., Service Now, JIRA, etc.). Kubernetes interacts and connects with
    many external CI/CD tools such as [Jenkins](https://jenkins.io), and also provides
    a native CI/CD subsystem called [Tekton](https://tekton.dev).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*流水线* 是一系列步骤，顺序或并行执行，用于在所有预生产环境中构建和测试应用程序，最终发布到生产环境。它可以完全自动化，也可以与外部工具交互以进行手动步骤批准（例如
    Service Now、JIRA 等）。Kubernetes 与许多外部 CI/CD 工具（如 [Jenkins](https://jenkins.io)）进行交互，并提供称为
    [Tekton](https://tekton.dev) 的本地 CI/CD 子系统。'
- en: Tekton is a Kubernetes-native CI/CD system, which means it extends the Kubernetes
    API and provides its custom resources that you can use to create your pipelines.
    It relies [on a catalog of Tasks](https://oreil.ly/Oxx5P) that comes already bundled
    with Tekton to compose your pipelines, such as Maven or Java Source-to-Image Tasks.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Tekton 是一个 Kubernetes 本地的 CI/CD 系统，这意味着它扩展了 Kubernetes API 并提供其自定义资源，您可以使用它们来创建流水线。它依赖于捆绑在
    Tekton 中的任务目录来组成您的流水线，例如 Maven 或 Java 源到镜像任务。
- en: Tip
  id: totrans-51
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Tekton can be installed in Kubernetes with an Operator from [OperatorHub.io](https://operatorhub.io).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Tekton 可以通过 [OperatorHub.io](https://operatorhub.io) 上的 Operator 在 Kubernetes
    中安装。
- en: 'To create Kubernetes-native pipelines, the following custom resources are provided
    by Tekton:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建 Kubernetes 本机流水线，Tekton 提供了以下自定义资源：
- en: Task
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Task
- en: A reusable, loosely coupled number of steps that perform a specific function
    (e.g., building a container image). Tasks get executed as Kubernetes Pods while
    steps in a Task map onto containers.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可重复使用、松耦合的步骤集，执行特定功能（例如构建容器镜像）。任务以 Kubernetes Pods 形式执行，而任务中的步骤映射到容器。
- en: Pipeline
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Pipeline
- en: A list of Tasks needed to build and/or deploy your apps.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 用于构建和/或部署您的应用所需的任务列表。
- en: TaskRun
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: TaskRun
- en: The execution and result of running an instance of Task.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 任务实例的执行和结果。
- en: PipelineRun
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: PipelineRun
- en: The execution and result of running an instance of Pipeline, which includes
    a number of TaskRuns.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 流水线实例的执行和结果，其中包括多个任务运行。
- en: 'An example of a Tekton Pipeline for the Inventory Quarkus microservice that
    we created in [Chapter 2](ch02.xhtml#changing_technologies) is listed next, you
    can also find it in this [book’s GitHub repository](https://oreil.ly/2UUCL):'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们创建的库存 Quarkus 微服务的 Tekton 流水线示例见 [第 2 章](ch02.xhtml#changing_technologies)，您也可以在这本书的
    GitHub 存储库中找到它：[book’s GitHub repository](https://oreil.ly/2UUCL)。
- en: '[PRE0]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Java developers may also find it convenient to create and control Tekton Pipelines
    and Tasks direcly from the code, using Fabric8 Tekton Java client. This option
    gives the full control from a single point, and you don’t need to maintain external
    manifests such as YAML files.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Java 开发者也可能会发现，使用 Fabric8 Tekton Java 客户端直接从代码创建和控制 Tekton 流水线和任务非常方便。这种选择能够从单一点实现完全控制，无需维护外部清单文件（如
    YAML 文件）。
- en: 'First, import Maven dependency in POM file:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在 POM 文件中导入 Maven 依赖：
- en: '[PRE1]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then you can use Tekton Java API to create Tasks or Pipeline:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以使用 Tekton Java API 创建任务或流水线：
- en: '[PRE2]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Debugging Microservices
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务调试
- en: While distributed architectures have plenty of benefits, they also pose some
    challenges. Even if you eventually run your code inside a Kubernetes cluster,
    you still develop (in general) locally where you have your IDE, compilers, etc.
    There are several ways to explain the development cycle. There are two loops,
    as illustrated in [Figure 6-4](#fig4-10). The one closer to the developer, called
    the inner loop, is where you code, test, and debug iteratively. The other loop,
    further away from the developer, called the outer loop, is where your code runs
    inside a container image you have to build, push, and deploy, and that takes a
    lot longer.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管分布式架构有很多好处，但也存在一些挑战。即使最终在Kubernetes集群中运行代码，您仍然通常在本地开发，拥有IDE、编译器等。有几种方法可以解释开发周期。如图[6-4](#fig4-10)所示，有两个循环。靠近开发者的一个称为内部循环，是您进行编码、测试和迭代调试的地方。另一个循环，远离开发者，称为外部循环，是您的代码运行在您必须构建、推送和部署的容器镜像内，这需要更长时间。
- en: '![Inner Loop and Outer Loop](Images/moej_0604.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![内部循环和外部循环](Images/moej_0604.png)'
- en: Figure 6-4\. Inner loop and outer loop
  id: totrans-72
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-4\. 内部循环和外部循环
- en: While the outer loop is part of the CI/CD world, the inner loop is where you
    start coding and testing your software before launching a Tekton Pipeline to deploy
    your application into Kubernetes. Debugging microservices is also part of the
    inner loop.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 外部循环是CI/CD世界的一部分，内部循环是您在启动Tekton Pipeline将应用程序部署到Kubernetes之前开始编码和测试软件的地方。调试微服务也是内部循环的一部分。
- en: 'Developers can follow different approaches to start debugging microservices:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员可以采用不同的方法来开始调试微服务：
- en: Using [Docker Compose](https://oreil.ly/ULV5g) and deploying all the services
    locally
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用[Docker Compose](https://oreil.ly/ULV5g)在本地部署所有服务
- en: Using [minikube](https://oreil.ly/1ogSc), or any local Kubernetes clusters,
    and deploying all the services there
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用[minikube](https://oreil.ly/1ogSc)，或任何本地Kubernetes集群，并在那里部署所有服务
- en: Mocking up all the services you interact with
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟您与之交互的所有服务
- en: Note
  id: totrans-78
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Docker Compose helps create containers that run in any Docker hosts, without
    Kubernetes. It is used for managing multiple containers in local development,
    but it is not mapped to any target Kubernetes clusters; thus, maintaining the
    local development setup separate from the target one may be difficult.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Compose帮助创建在任何Docker主机上运行的容器，而不需要Kubernetes。它用于管理本地开发中的多个容器，但不映射到任何目标Kubernetes集群；因此，保持本地开发设置与目标设置分开可能会很困难。
- en: They are all valid approaches, but there are times where services are external
    and reachable only from the remote Kubernetes cluster, or mocking up that part
    of code is difficult or not possible.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是有效的方法，但有时服务是外部的，并且只能从远程Kubernetes集群访问，或者模拟该部分代码很难或不可能。
- en: '[Microcks](https://microcks.io) is an open source Kubernetes-native debugging
    tool for API mocking and testing. It helps turn API contract, collection, or SoapUI
    projects into live mocks. It can be a convenient way to develop faster on Kubernetes
    without dependencies.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '[Microcks](https://microcks.io)是一个开源的Kubernetes本地调试工具，用于API模拟和测试。它有助于将API合同、集合或SoapUI项目转换为实时模拟。在Kubernetes上快速开发而无需依赖项时，它可以是一种方便的方式。'
- en: Let’s look at some additional options for in-Kubernetes microservices debugging.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些用于Kubernetes中微服务调试的额外选项。
- en: Port Forwarding
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 端口转发
- en: Kubernetes offers remote shelling into Pods for quick debugging tasks such as
    filesystem check. Additionally, [you can set up port forwarding](https://oreil.ly/IAu5H)
    between your local machine connected to a Kubernetes cluster and your app running
    in a Pod. This option is useful when you want to connect to a database running
    in a Pod, attach an administrative web interface you don’t want to expose to the
    public, or, in this case, attach a debugger to the JVM running our application
    server.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes提供了远程Shell进入Pod的功能，用于快速调试任务，例如文件系统检查。此外，[您可以设置端口转发](https://oreil.ly/IAu5H)，将您的本地机器与运行在Pod中的应用程序连接到连接到Kubernetes集群。此选项在您希望连接运行在Pod中的数据库、附加您不希望暴露给公众的管理Web界面，或者像本例中一样附加JVM运行的应用程序服务器的调试器时非常有用。
- en: By port forwarding the debugging port for the application server, you can attach
    the debugger from your IDE and actually step through the code in the Pod as it
    is running in real time. Remember, if your app is not in debug mode, you first
    need to turn on the debug ports.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将应用服务器的调试端口进行端口转发，您可以从IDE附加调试器，并实时步进Pod中运行的代码。请记住，如果您的应用程序不处于调试模式，则需要首先打开调试端口。
- en: 'To start debugging, you need to expose the port for debugging. For example,
    for debugging the Inventory microservice, you need to access the debugging port
    5005:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始调试，您需要公开调试端口。例如，要调试Inventory微服务，您需要访问调试端口5005：
- en: '[PRE3]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now when we connect on *localhost:5005*, it will get forwarded to the Inventory
    instance running in the Pod.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当我们在*localhost:5005*上连接时，它将被转发到运行在Pod中的Inventory实例。
- en: Note
  id: totrans-89
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Port forwarding is only active as long as the `kubectl port-forward` command
    is allowed to run. Since we run it in the foreground, we are able to stop port
    forwarding by hitting Ctrl+C (or Cmd+C on a Mac).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 端口转发仅在允许`kubectl port-forward`命令运行期间处于活动状态。由于我们在前台运行它，因此可以通过按下Ctrl+C（或Mac上的Cmd+C）停止端口转发。
- en: 'In order to debug the source code, you can either use your IDE of choice or
    you can debug from the console as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要调试源代码，您可以使用您选择的IDE，或者可以按照以下步骤从控制台调试：
- en: '[PRE4]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Quarkus Remote Development Mode
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Quarkus远程开发模式
- en: Quarkus provides a [Remote Development Mode](https://oreil.ly/rLflo) that allows
    you to run Quarkus in a container environment such as Kubernetes and have changes
    made to your local files immediately.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Quarkus提供了一个[远程开发模式](https://oreil.ly/rLflo)，允许您在诸如Kubernetes之类的容器环境中运行Quarkus，并立即对本地文件所做的更改生效。
- en: 'To enable it, add this section in your `application.properties`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用它，请在您的`application.properties`中添加此部分：
- en: '[PRE5]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[![1](Images/1.png)](#co_building_kubernetes_native_applications_CO1-1)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_building_kubernetes_native_applications_CO1-1)'
- en: Mutable applications are used in development mode to apply and test changes
    live in a Quarkus Java application, without reloading the artifact.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发模式下，可变应用程序用于在Quarkus Java应用程序中实时应用和测试更改，而不需要重新加载构件。
- en: '[![2](Images/2.png)](#co_building_kubernetes_native_applications_CO1-2)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_building_kubernetes_native_applications_CO1-2)'
- en: A password that is used to secure communication between the remote side and
    the local side.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 用于保护远程端和本地端通信的密码。
- en: '[![3](Images/3.png)](#co_building_kubernetes_native_applications_CO1-3)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_building_kubernetes_native_applications_CO1-3)'
- en: The URL at which your app is going to be running in dev mode.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序运行在开发模式下的URL。
- en: 'You can generate the mutable JAR with Maven. You can let Quarkus deploy the
    app to Kubernetes as follows if you are connected with the Kubernetes Registry:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用Maven生成可变JAR。如果您已连接到Kubernetes注册表，可以让Quarkus将应用程序部署到Kubernetes，如下所示：
- en: '[PRE6]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-105
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can add the Quarkus Kubernetes extension with this command: `./mvnw quarkus:add-extension
    -Dextensions="kubernetes"`'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令添加Quarkus Kubernetes扩展：`./mvnw quarkus:add-extension -Dextensions="kubernetes"`
- en: 'Deploy the app to Kubernetes:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 将应用程序部署到Kubernetes：
- en: '[PRE7]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Finally, you connect in remote dev mode to the app:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以连接到应用的远程开发模式：
- en: '[PRE8]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This allows you to use Quarkus to connect the live coding features from your
    local machine to a remote container environment such as Kubernetes.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许您使用Quarkus将您的本地机器上的现场编码功能连接到远程容器环境，例如Kubernetes。
- en: Telepresence
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Telepresence
- en: '[Telepresence](https://www.telepresence.io) is an open source tool that helps
    debug microservices in Kubernetes. It runs a single service locally, while connecting
    that service to a remote Kubernetes cluster. Telepresence is programming language-agnostic,
    providing a convenient way to connect your local enviroment to any workload running
    on Kubernetes to debug.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '[Telepresence](https://www.telepresence.io) 是一个开源工具，用于帮助调试Kubernetes中的微服务。它在本地运行单个服务，同时将该服务连接到远程Kubernetes集群。Telepresence是编程语言无关的，为您提供了一个方便的方式将您的本地环境连接到在Kubernetes上运行的任何工作负载以进行调试。'
- en: Debugging apps on Kubernetes with Telepresence is very easy. First, download
    and install [Telepresence CLI](https://oreil.ly/wkwOC) and have an active session
    to your cluster, as Telepresence will read the *~/.kube/config* file to connect
    to Kubernetes.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Telepresence在Kubernetes上调试应用非常容易。首先，下载并安装[Telepresence CLI](https://oreil.ly/wkwOC)，并与您的集群保持活动会话，因为Telepresence将读取*~/.kube/config*文件以连接到Kubernetes。
- en: Note
  id: totrans-115
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Telepresence will modify the network in Kubernetes so that Services are reachable
    from your laptop and vice versa.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Telepresence将修改Kubernetes中的网络，以便服务可以从您的笔记本电脑访问，反之亦然。
- en: 'Once the CLI is installed and configured in your workstation, you can run this
    command to initialize and test the connection to your cluster with Telepresence:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦在您的工作站上安装并配置了CLI，您可以运行此命令来初始化并测试与Telepresence连接到您的集群的连接：
- en: '[PRE9]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You should get an output similar to the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会得到类似以下的输出：
- en: '[PRE10]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can start debugging the Inventory microservice that you deployed in the
    previous steps. Before doing that, let’s list available apps to debug:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以开始调试您在前面步骤中部署的库存微服务。在此之前，让我们列出可用于调试的应用程序：
- en: '[PRE11]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You should get an output similar to the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会得到类似以下的输出：
- en: '[PRE12]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: To start debugging this microservice, you need to let Telepresence intercept
    the internal Kubernetes traffic represented by the Service.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始调试此微服务，您需要让Telepresence拦截由服务表示的内部Kubernetes流量。
- en: 'The Inventory’s Kubernetes Service is using port 8080, as you can see with
    the following command:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 库存的Kubernetes服务使用端口8080，如以下命令所示：
- en: '[PRE13]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You should get an output similar to the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会得到类似以下的输出：
- en: '[PRE14]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now you can start intercepting the traffic connecting to your Deployment with
    the port used by the Service. You can also specify the path to a file on which
    Telepresence should write the environment variables that your service is currently
    running with:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以开始拦截连接到部署的流量，使用服务使用的端口。您还可以指定Telepresence应将环境变量写入的文件路径，该环境变量当前正在您的服务中运行：
- en: '[PRE15]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You should get an output similar to the following:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会得到类似以下的输出：
- en: '[PRE16]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Look at the content of the environment file `inventory.env` just created:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 查看刚刚创建的环境文件 `inventory.env` 的内容：
- en: '[PRE17]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now you can access the Inventory microservice as if you were connected to the
    internal Kubernetes network, and working with the environment variables just retrieved:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以像连接到内部Kubernetes网络一样访问库存微服务，并使用刚刚检索到的环境变量进行操作：
- en: '[PRE18]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You should get an output similar to the following:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会得到类似以下的输出：
- en: '[PRE19]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Summary
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed how Kubernetes patterns can help Java developers
    with modernizing their apps, offering a platform that provides many components
    to extend app capabilities. The API-driven, pluggable architecture of Kubernetes
    easily enables external tools to provide an ecosystem of software and utilities
    that reminds, but also extends the application server model for Java enterprise.
    Essential tasks such as logging, monitoring, or debugging apps are provided in
    a way that fits the cloud native model, where apps are ubiquituous and can run
    in multiple places and multiple clouds at the same time.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了Kubernetes模式如何帮助Java开发人员现代化其应用程序，提供了一个平台，提供许多组件来扩展应用程序的功能。 Kubernetes的API驱动，可插拔的架构轻松地使外部工具能够提供软件和实用程序的生态系统，这些工具提醒并扩展了Java企业应用服务器模型。诸如日志记录、监控或调试应用程序等基本任务以适合云原生模型的方式提供，其中应用程序普及并可以同时在多个地方和多个云中运行。
- en: 'In the next chapter, we will discuss a new concept of serving and delivering
    the enterprise application, resource-saving and cloud-ready: the serverless way.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论一种新的服务和交付企业应用程序的概念，节省资源且云就绪：无服务器方式。
