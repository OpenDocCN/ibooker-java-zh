- en: Chapter 5\. Building Serverless Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。构建无服务器应用程序
- en: So far we’ve talked a lot about Lambda functions—how to program them, how to
    package and deploy them, how to process input and output, etc. One important aspect
    to Lambda, however, that we haven’t covered much so far, is that Lambda functions
    are rarely invoked directly from code we write in a different system. Instead,
    for the *vast majority* of usages of Lambda, we configure an *event source*, or
    *trigger*, that is *another AWS service*, and let AWS invoke our Lambda function
    for us.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经大量讨论了Lambda函数——如何编写程序，如何打包和部署它们，如何处理输入和输出等等。然而，Lambda的一个重要方面，到目前为止我们还没有涉及太多，那就是Lambda函数很少直接从我们在不同系统中编写的代码中被调用。相反，对于Lambda的绝大多数用法，我们会配置一个*事件源*或*触发器*，它是*另一个AWS服务*，然后让AWS代替我们调用我们的Lambda函数。
- en: 'We looked at a couple of examples of this in [“What Does a Lambda Application
    Look Like?”](ch01.html#what_does_a_lambda_application_look_like):'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[“一个Lambda应用程序是什么样子？”](ch01.html#what_does_a_lambda_application_look_like)中看了一些示例：
- en: To implement an HTTP API, we configure AWS API Gateway as the event source.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了实现HTTP API，我们将AWS API Gateway配置为事件源。
- en: To implement file processing, we configure S3 as the event source.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了实现文件处理，我们将S3配置为事件源。
- en: There are many different AWS services that directly integrate with Lambda, and
    even more that integrate indirectly. This means that we can build *serverless
    applications*, using Lambda as the compute platform, that can perform a vast range
    of tasks.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多不同的AWS服务直接与Lambda集成，甚至还有更多间接集成的服务。这意味着我们可以构建使用Lambda作为计算平台的*无服务器应用程序*，可以执行广泛范围的任务。
- en: In this chapter, we look at how to tie event sources to Lambda and then explore
    how to build specific types of application with this technique. Along the way,
    you’ll learn more about how to architect, build, package, and deploy Lambda-based
    applications, building on our knowledge from the previous chapter.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍如何将事件源与Lambda绑定，然后探讨如何使用这种技术构建特定类型的应用程序。在这个过程中，你将学到更多关于如何从前一章的知识构建、打包和部署基于Lambda的应用程序的架构知识。
- en: If you haven’t done so already, you’ll likely want to download the [example
    source code](https://oreil.ly/8DQe_) before trying any of the examples in this
    chapter.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有这样做，你可能希望在尝试本章中的任何示例之前下载[示例源代码](https://oreil.ly/8DQe_)。
- en: Lambda Event Sources
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lambda事件源
- en: As you just learned, the typical usage pattern for Lambda is to tie a function
    to an event source. In this section, we describe the workflow to follow when you
    build a Lambda function to integrate with a particular upstream service.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你刚刚学到的那样，Lambda的典型使用模式是将函数绑定到事件源。在本节中，我们描述了构建Lambda函数以与特定上游服务集成时要遵循的工作流程。
- en: Writing Code to Work with Input and Output for Event Sources
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写代码以处理事件源的输入和输出
- en: When programming a Lambda function to respond to a particular event source,
    the first thing you’ll typically want to do is understand the format of events
    that your Lambda function will receive.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写Lambda函数以响应特定事件源时，你通常首先要做的事情是了解Lambda函数将接收到的事件的格式。
- en: 'The SAM CLI tool that we’ve already used has an interesting command to help
    with this exercise—`sam local generate-event`. If you run this command, `sam`
    lists all the services it can generate stub events for, which you can then examine
    and use to drive your code. For example, part of the output for `sam local generate-event`
    looks like this:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用过的SAM CLI工具有一个有趣的命令可以帮助我们进行这个练习——`sam local generate-event`。如果你运行这个命令，`sam`会列出它可以为其生成存根事件的所有服务，然后你可以检查并使用这些事件来驱动你的代码。例如，`sam
    local generate-event`的部分输出如下所示：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let’s say we’re interested in building a serverless HTTP API. In this case,
    we use AWS API Gateway as our upstream event source. If we run `sam local generate-event
    apigateway` the output includes the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有兴趣构建一个无服务器的HTTP API。在这种情况下，我们使用AWS API Gateway作为我们的上游事件源。如果我们运行`sam local
    generate-event apigateway`，输出将包括以下内容：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: It turns out that API Gateway can integrate with Lambda in multiple ways. The
    one we typically want from this list is the aws-proxy event, where API Gateway
    acts as a proxy server in front of a Lambda function, so let’s give that a try.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 原来API Gateway可以以多种方式与Lambda集成。我们通常从列表中想要的是aws-proxy事件，其中API Gateway充当Lambda函数前面的代理服务器，所以让我们试试这个。
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This JSON object is a fully baked sample of a typical event a Lambda function
    receives from API Gateway. In other words, when you set up API Gateway as a trigger
    for your Lambda function, the event argument that is passed to the Lambda function
    has this structure.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 JSON 对象是 Lambda 函数从 API Gateway 接收到的典型事件的完整示例。换句话说，当您设置 API Gateway 作为 Lambda
    函数的触发器时，传递给 Lambda 函数的事件参数具有此结构。
- en: This sample event doesn’t necessarily help you with the *semantics* of the integration
    with API Gateway, but it does give you the shape of the event that your Lambda
    function receives, which in turn gives you a solid start to writing your code.
    You can use this JSON object as inspiration, or you can take it a step further
    and actually embed it in a test—more on that in [Chapter 6](ch06.html#ch06)!
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例事件并不一定帮助您理解与 API Gateway 集成的语义，但它确实给出了您的 Lambda 函数接收到的事件的结构，从而为编写代码提供了坚实的起点。您可以将此
    JSON 对象作为灵感，或者更进一步，实际将其嵌入到一个测试中——详见[第 6 章](ch06.html#ch06)！
- en: Because you now know the format of the data that your Lambda function receives,
    you are able to create a handler signature to process this format. Remember [“POJOs
    and Ecosystem Types”](ch03.html#pojos_and_ecosystem_types)? That’s going to come
    into play now.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 因为您现在知道了您的 Lambda 函数接收到的数据格式，所以可以创建一个处理此格式的处理程序签名。还记得[“POJOs 和生态系统类型”](ch03.html#pojos_and_ecosystem_types)吗？现在正要发挥作用了。
- en: 'One option you have in setting up your handler is to create your own POJO input
    type that fits the structure of the inbound event but only creates fields for
    the properties you care about. For instance, if you cared only about the `path`
    and `queryStringParameters` properties of the aws-proxy event, you could create
    a POJO as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 设置处理程序的一种选项是创建自己的 POJO 输入类型，以适合传入事件的结构，但仅创建您关心的属性字段。例如，如果您只关心 aws-proxy 事件的
    `path` 和 `queryStringParameters` 属性，则可以创建如下的 POJO：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: A second option is to use a library of types that AWS provides in a Java library
    precisely for this purpose—the “AWS Lambda Java Events Library.” If you use this
    library, refer to the [documentation](https://oreil.ly/5DMvp) and look to find
    the latest versions in [Maven Central](https://oreil.ly/8WvbA).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个选项是使用 AWS 专门为此目的提供的类型库——“AWS Lambda Java Events Library”。如果使用此库，请参阅[文档](https://oreil.ly/5DMvp)，并查找
    Maven Central 中的最新版本。
- en: 'If you want to use this library to handle aws-proxy events, then you need to
    first include a library in your Maven dependencies. Add the `<dependencies>` section
    to the root of your *pom.xml* file if it isn’t already there. Otherwise, add this
    `<dependency>` subsection to the preexisting `<dependencies>` section:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要使用此库来处理 aws-proxy 事件，那么您需要首先在 Maven 依赖项中包含一个库。如果尚未包含，请将 `<dependencies>`
    部分添加到您的 *pom.xml* 文件的根部。否则，请将此 `<dependency>` 子部分添加到现有的 `<dependencies>` 部分中：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: With that update made, we can use the [`APIGatewayProxyRequestEvent` class](https://oreil.ly/S1y95)
    as our input POJO.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 通过进行这些更新，我们可以使用[`APIGatewayProxyRequestEvent` 类](https://oreil.ly/S1y95)作为我们的输入
    POJO。
- en: Now we have a class to represent the event that our Lambda function is going
    to receive. Next, let’s look at how to perform the same activity for the event
    that will be our function’s response. As you know from [“Input, Output”](ch03.html#input-output),
    this is where POJOs come into play again.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个代表我们的 Lambda 函数将接收的事件的类。接下来，让我们看看如何为将成为函数响应的事件执行相同的活动。正如您从[“输入、输出”](ch03.html#input-output)中所知，这里再次涉及到
    POJOs。
- en: The SAM CLI can’t help us this time, so alternatively you can look up the [AWS
    documentation](https://oreil.ly/RnyUg) to find valid output event structures and
    generate your own output POJO type, or you can use the AWS Lambda Java Events
    Library again. This time, use the `APIGatewayProxyResponseEvent` class if responding
    to an API Gateway proxy event (see [“API Gateway Proxy Events”](#api-gateway-proxy-events)).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: SAM CLI 这次帮不上忙，因此您可以查阅[AWS 文档](https://oreil.ly/RnyUg)来查找有效的输出事件结构并生成自己的输出 POJO
    类型，或者您可以再次使用 AWS Lambda Java Events Library。这次，如果要响应 API Gateway 代理事件，请使用 `APIGatewayProxyResponseEvent`
    类（参见[“API Gateway Proxy Events”](#api-gateway-proxy-events)）。
- en: 'Let’s say that you want to build your own POJO class and want to return just
    an HTTP Status code and a `body` in the HTTP response. In that case, your POJO
    might look as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您想要构建自己的 POJO 类，并且只想在 HTTP 响应中返回一个 HTTP 状态码和 `body`。在这种情况下，您的 POJO 可能如下所示：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Whether you use the AWS-provided POJO types or code them yourself is not a
    particularly clear-cut choice. At the present time, we default to using the AWS
    library for a couple of reasons:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 是否使用 AWS 提供的 POJO 类型或自行编码并没有一个特别明确的选择。目前，出于几个原因，我们默认使用 AWS 库：
- en: While in the past the library has lagged behind significantly with what’s actually
    available in the Lambda platform, these days AWS does a decent job keeping it
    up-to-date.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然过去这个库在 Lambda 平台上实际可用的内容上落后很多，但现在 AWS 在保持更新方面做得相当不错。
- en: Similarly, this library used to bring in a huge number of SDK dependencies,
    and so would significantly increase the size of your artifact. This is much improved
    now, and the base JAR (which is sufficient for quite a few event sources, including
    API Gateway and SNS) is less than 100KB.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类似地，这个库过去引入了大量的 SDK 依赖项，因此会显著增加您的 artifact 大小。现在这方面得到了很大改进，基础 JAR 文件（对包括 API
    Gateway 和 SNS 在内的很多事件源都足够）不到 100KB。
- en: That said, coding your own POJOs is a perfectly reasonable approach—it means
    your deployed artifact will be even smaller, it reduces the number of library
    dependencies your code has (including transitive dependencies), and it adds a
    succinctness to your code, aiding maintainability later. In this chapter, we give
    examples of both approaches.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，编写自己的 POJOs 是一个完全合理的方法——这意味着您部署的 artifact 将会更小，减少了代码的库依赖数量（包括传递依赖），并且增加了代码的简洁性，有助于以后的可维护性。在本章中，我们给出了这两种方法的示例。
- en: Once your basic Lambda function is coded, it’s time to move on to the next step—configuring
    the event source for deployment.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你编写好基本的 Lambda 函数，就该进行下一步了——配置事件源以便部署。
- en: Configuring a Lambda Event Source
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置 Lambda 事件源
- en: Just as there are multiple ways of deploying and configuring a Lambda function
    (remember that long list of deployment tools from [“Deploy”](ch04.html#lambda-deployment-tools)?),
    there are multiple ways of configuring an event source. However, since in this
    book we are using SAM to deploy our code, it makes sense, as much as possible,
    to use SAM to configure our event sources too.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 就像有多种部署和配置 Lambda 函数的方式（还记得来自[“部署”](ch04.html#lambda-deployment-tools)的长列表吗？），配置事件源也有多种方式。然而，由于本书中我们使用
    SAM 来部署代码，因此尽可能多地使用 SAM 来配置我们的事件源是有道理的。
- en: 'Let’s continue our API Gateway example. The simplest way of defining an API
    Gateway event source in SAM is to update your Lambda function definition in your
    *template.yaml* as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续我们的 API Gateway 示例。在 SAM 中定义 API Gateway 事件源的最简单方法是在您的 *template.yaml*
    中更新 Lambda 函数定义如下：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Take a look at the `Events` key—that’s where the magic happens. What SAM does
    in this case is create a whole bunch of resources, including a globally accessible
    API endpoint (which we get to later in the chapter), but part of what it also
    does is configure API Gateway to trigger your Lambda function.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 看看 `Events` 键——那里就是魔法发生的地方。在这种情况下，SAM 所做的事情包括创建一堆资源，包括一个全局可访问的 API 端点（我们在本章后面会详细讨论），但它还配置了
    API Gateway 来触发您的 Lambda 函数。
- en: SAM can directly configure [many different event sources](https://oreil.ly/s_4W2).
    However, if it doesn’t do enough for your requirements, you can always drop down
    to lower-level CloudFormation resources.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: SAM 可以直接配置[许多不同的事件源](https://oreil.ly/s_4W2)。然而，如果它对您的需求不足够，您总是可以降低到更低级别的 CloudFormation
    资源。
- en: Understanding Different Event Source Semantics
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解不同的事件源语义
- en: Back in [Chapter 1](ch01.html#ch01) we described that Lambda functions can be
    invoked in two ways—synchronously and asynchronously—and showed how those different
    invocation types were used in different scenarios.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第一章](ch01.html#ch01)中我们描述了 Lambda 函数可以以两种方式被调用——同步和异步，并展示了这些不同的调用类型在不同场景中的应用。
- en: Unsurprisingly, that means there are at least two different kinds of event source—those,
    like API Gateway, that invoke a Lambda function synchronously and wait for the
    reply (“synchronous event sources”), and others that invoke a Lambda function
    asynchronously, and don’t wait for the reply (“asynchronous event sources”).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 不出所料，这意味着至少有两种不同类型的事件源——像 API Gateway 这样的，同步调用 Lambda 函数并等待回复（“同步事件源”），以及异步调用
    Lambda 函数并且不等待回复的其他事件源（“异步事件源”）。
- en: In the case of the former group, your Lambda function needs to return the appropriate
    type of response, just like we did with the API Gateway earlier. For the latter
    group, your handler function can have a return type of `void`, showing that you
    don’t return a response.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一组的情况下，您的 Lambda 函数需要返回适当类型的响应，就像我们之前在 API 网关中所做的那样。对于后一组，您的处理函数可以具有 `void`
    返回类型，表明您不返回响应。
- en: 'It would be convenient to say, in fact, that *all* event sources fit into one
    of these two kinds, but unfortunately there’s a slight complication—there’s a
    third kind, and that’s Stream/queue event sources, such as:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，可以方便地说，*所有*事件源都适合这两种类型中的一种，但不幸的是，有一个小复杂性 —— 还有第三种类型，即流/队列事件源，例如：
- en: Kinesis Data Streams
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kinesis 数据流
- en: DynamoDB Streams
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DynamoDB Streams
- en: Simple Queue Service (SQS)
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单队列服务（SQS）
- en: In all three of these cases, we configure the Lambda *platform* to reach out
    to the upstream service to *poll* for events, as opposed to all the other event
    sources where we configure a Lambda trigger directly from the upstream service
    to *push* events to Lambda.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这三种情况下，我们都配置 Lambda *平台* 以从上游服务中*轮询*事件，与其他所有事件源不同，其中我们直接从上游服务配置 Lambda 触发器以*推送*事件到
    Lambda。
- en: 'This reversal for stream/queue sources has no impact on the Lambda handler
    programming model—the method signature is precisely the same. For example, here
    is the format of a Lambda handler event for SQS (note the array of `Records`):'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 对于流/队列源的这种反向操作对 Lambda 处理程序编程模型没有影响 —— 方法签名完全相同。例如，以下是 SQS 的 Lambda 处理程序事件格式（请注意
    `Records` 数组）：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Table 5-1\. Lambda event source types
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5-1\. Lambda 事件源类型
- en: '| Event Source Type | Event Sources |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| 事件源类型 | 事件源 |'
- en: '| --- | --- |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Synchronous |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| 同步 |'
- en: API Gateway, Amazon CloudFront (Lambda@Edge), Elastic Load Balancing (Application
    Load Balancer), Cognito, Lex, Alexa, Kinesis Data Firehose
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: API 网关，Amazon CloudFront（Lambda@Edge），弹性负载均衡（应用程序负载均衡器），Cognito，Lex，Alexa，Kinesis
    数据 Firehose
- en: '|'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Asynchronous |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| 异步 |'
- en: S3, SNS, Amazon SES, CloudFormation, CloudWatch Logs, CloudWatch Events, CodeCommit,
    Config
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: S3，SNS，Amazon SES，CloudFormation，CloudWatch 日志，CloudWatch 事件，CodeCommit，Config
- en: '|'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Stream/Queue |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| 流/队列 |'
- en: Kinesis Data Streams, DynamoDB Streams, Simple Queue Service (SQS)
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Kinesis 数据流，DynamoDB Streams，简单队列服务（SQS）
- en: '|'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Stream/queue event sources are also a little different when it comes to error
    handling (see [“Error Handling”](ch08.html#error-handling)). But for now, we know
    enough about event sources to explore a couple of detailed examples. Let’s dig
    into our serverless HTTP API.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 流/队列事件源在错误处理方面也有一些不同（参见 [“错误处理”](ch08.html#error-handling)）。但目前，我们已经了解了足够的关于事件源的信息，可以探索一些详细的示例。让我们深入研究我们的无服务器
    HTTP API。
- en: 'Example: Building a Serverless API'
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例：构建无服务器 API
- en: In [Chapter 1](ch01.html#ch01), we briefly discussed how Lambda can be used
    as part of a web API. In this section, we will show how this is built.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 1 章](ch01.html#ch01)中，我们简要讨论了 Lambda 如何作为 Web API 的一部分使用。在本节中，我们将展示这是如何构建的。
- en: Behavior
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 行为
- en: This application allows a client to upload weather data to an API, and then
    allows other clients to retrieve that data ([Figure 5-2](#web-api-again)).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 此应用程序允许客户端向 API 上传天气数据，然后允许其他客户端检索该数据（[图 5-2](#web-api-again)）。
- en: '![images/ch01_image05.png](assets/awsl_0105.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![images/ch01_image05.png](assets/awsl_0105.png)'
- en: Figure 5-2\. Web API using AWS Lambda
  id: totrans-71
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-2\. 使用 AWS Lambda 的 Web API
- en: 'The write path consists of making an HTTP POST request to the endpoint `/events`,
    with the following JSON data structure in the `body` of the request:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 写入路径包括向端点 `/events` 发出 HTTP POST 请求，并在请求的 `body` 中包含以下 JSON 数据结构：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The read path consists of making a GET request to the endpoint `/locations`,
    which returns the latest weather data for each location that we’ve saved data
    for. The format of this data is a JSON list of objects in the same format as the
    write path. An optional query string parameter `limit` can be added to the GET
    request to specify a maximum number of records to return.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 读取路径包括向端点 `/locations` 发出 GET 请求，该端点返回我们已保存数据的每个位置的最新天气数据。此数据的格式是一个 JSON 对象列表，格式与写入路径相同。可以添加可选的查询字符串参数
    `limit` 到 GET 请求中，以指定返回的最大记录数。
- en: Architecture
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 架构
- en: 'We use AWS API Gateway to implement all of the HTTP elements of this application.
    The read path and write path are implemented using two different Lambda functions.
    These are triggered by API Gateway. We store our data in a DynamoDB table. DynamoDB
    is Amazon’s “NoSQL” database service. It’s a great fit for many serverless systems
    because:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用AWS API Gateway来实现此应用程序的所有HTTP元素。 读路径和写路径使用两个不同的Lambda函数实现。 这些由API Gateway触发。
    我们将数据存储在DynamoDB表中。 DynamoDB是亚马逊的“NoSQL”数据库服务。 对于许多无服务器系统来说，它是一个很好的选择，因为：
- en: It offers the same “lightweight operations” model as Lambda—we configure the
    table structure we want and Amazon handles all runtime considerations.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供与Lambda相同的“轻量级操作”模型——我们配置我们想要的表结构，亚马逊处理所有运行时考虑因素。
- en: It can be used in a full “on-demand” scaling mode that scales up and down in
    reaction to actual usage, just like Lambda does.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以在全“按需”缩放模式下使用，根据实际使用情况进行上下调整，就像Lambda一样。
- en: Because DynamoDB is a NoSQL technology, it isn’t the right choice for all applications,
    but it’s definitely a quick way to get started.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 因为DynamoDB是一种NoSQL技术，它并不适合所有应用程序，但它绝对是快速入门的一种方式。
- en: For our DynamoDB table in this example, we declare a primary key named `locationName`
    and use “on-demand” capacity control.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们这个示例中的DynamoDB表中，我们声明了一个名为`locationName`的主键，并使用“按需”容量控制。
- en: We treat all of these resources—an API Gateway definition, two Lambda functions,
    and a DynamoDB table as one unified “serverless application.” We treat the code,
    configuration, and infrastructure definitions as one, collectively deployed, unit.
    This is not a particularly new idea just for serverless, though—encapsulating
    a database within a service is a fairly common idea of microservice architecture.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将所有这些资源——一个API网关定义、两个Lambda函数和一个DynamoDB表——视为一个统一的“无服务器应用程序”。 我们将代码、配置和基础设施定义作为一个整体部署单元。
    尽管这不是一个新的想法，但将数据库封装在服务中是微服务架构的一个相当普遍的想法。
- en: Apart from adding a useful grouping, using the idea of a serverless application
    also helps solve a concern that some people have when they consider how many Lambda
    functions they might have in their organization—it’s tough enough herding hundreds
    of microservices, but a company may end up with thousands or tens of thousands
    of Lambda functions. How can we manage all of those functions? By namespaceing
    functions within a serverless application, and by tagging or locating the deployed
    versions of those applications by their environment/stage, we can start bringing
    some order to the chaos. This concept of a serverless application is not just
    a design-time consideration—AWS actually supports it directly (see [“Deployment”](#ch05-deployment)).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 除了添加一个有用的分组外，使用无服务器应用程序的想法还有助于解决一些人在考虑他们在组织中可能拥有的Lambda函数数量时的担忧——已经足够困难组织成百上千个微服务，但一家公司可能最终会拥有数千或数万个Lambda函数。
    我们如何管理所有这些函数？ 通过在无服务器应用程序内命名空间化函数，并通过标记或定位这些应用程序的部署版本来按环境/阶段进行分类，我们可以开始为混乱带来一些秩序。
    无服务器应用程序的这个概念不仅仅是设计时的考虑——AWS实际上直接支持它（参见[“部署”](#ch05-deployment)）。
- en: Lambda Code
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Lambda Code
- en: Note
  id: totrans-84
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: At this point in the book we don’t discuss error checking or testing—we’ve done
    that for clarity of example. Don’t worry—both of these important subjects are
    addressed later in the book!
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的这一点上，我们不讨论错误检查或测试——我们为了例子的清晰性已经做过了。 别担心——这两个重要的主题稍后会在本书中讨论！
- en: We mentioned earlier that one of the first things you need to do when implementing
    an application using Lambda is to understand the format of the events that your
    Lambda function will receive, and the format of the response your Lambda function
    should return (if any).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到，当使用Lambda实现应用程序时，你需要做的第一件事情之一就是理解Lambda函数将接收的事件格式以及Lambda函数应返回的响应格式（如果有）。
- en: We already examined the API Gateway proxy types earlier. In this weather API,
    we write our own classes for POJO serialization and deserialization, rather than
    using the AWS-supplied library. Examples [5-1](#EX5-1) and [5-2](#EX5-2) are sufficient
    for our needs for both Lambda functions.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经检查了API Gateway的代理类型。 在这个天气API中，我们编写自己的类来进行POJO序列化和反序列化，而不是使用AWS提供的库。 例子[5-1](#EX5-1)和[5-2](#EX5-2)足以满足我们对两个Lambda函数的需求。
- en: Example 5-1\. For deserializing API requests
  id: totrans-88
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-1\. 用于反序列化API请求
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Example 5-2\. For serializing API responses
  id: totrans-90
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-2\. 用于序列化API响应
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We wouldn’t actually recommend this approach in general—see earlier about whether
    or not to use the AWS POJO type library ([“Writing Code to Work with Input and
    Output for Event Sources”](#code-for-event-sources))—but we wanted to show examples
    of both approaches. The second example in this chapter uses the AWS Library. When
    you build your own production implementation of an HTTP API with Lambda, you can
    substitute the `APIGatewayProxyRequestEvent` and `APIGatewayProxyResponseEvent`
    classes in the `com.amazonaws.services.lambda.runtime.events` package for these
    DIY classes.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 总体上，我们并不推荐一般情况下采用这种方法——请参见前文有关是否使用AWS POJO类型库的讨论[“编写用于事件源输入和输出的代码”](#code-for-event-sources)——但我们希望展示两种方法的示例。本章的第二个示例使用了AWS库。当您使用Lambda构建自己的HTTP
    API的生产实现时，可以将`com.amazonaws.services.lambda.runtime.events`包中的`APIGatewayProxyRequestEvent`和`APIGatewayProxyResponseEvent`类替换为这些DIY类。
- en: Now let’s look in detail at the code necessary to implement this application.
    We start with the write path.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们详细查看实现此应用程序所需的代码。我们从写入路径开始。
- en: Uploading weather data with WeatherEventLambda
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用WeatherEventLambda上传天气数据
- en: 'We know that the rough skeleton of our code to process uploaded data is going
    to be the following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，处理上传数据的代码大致的骨架如下：
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The first thing we need to do is capture the input of our event. Lambda deserialization
    starts this work for us, and the structure of the `ApiGatewayRequest` object that
    is passed to our function is as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要捕获事件的输入。Lambda反序列化已经为我们开始了这项工作，而传递给我们函数的`ApiGatewayRequest`对象的结构如下：
- en: '[PRE12]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We don’t care about the `queryStringParameters` field in this Lambda function—that
    will be used in the querying function—so we can ignore that for now.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个Lambda函数中，我们并不关心`queryStringParameters`字段——那将在查询函数中使用——因此我们现在可以忽略它。
- en: That `body` field, though, is a little tricky—the JSON object uploaded by the
    client is still serialized as a string value. That’s because Lambda only deserialized
    the event that API Gateway created; it also can’t deserialize the “next level
    in” of the weather data.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 那个`body`字段有点棘手——客户端上传的JSON对象仍然序列化为字符串值。这是因为Lambda仅对API Gateway创建的事件进行了反序列化；它也不能反序列化天气数据的“下一层级”。
- en: No matter, we can perform our own deserialization for `body`, and one way we
    can do that is to use the [Jackson library](https://github.com/FasterXML/jackson).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 不管怎样，我们可以对`body`进行自己的反序列化，其中一种方法是使用[Jackson库](https://github.com/FasterXML/jackson)。
- en: Once we’ve deserialized the weather data, we’re ready to save it to the database.
    [Example 5-3](#EX5-3) shows the full code for the Lambda function—you may also
    want to open up the example code in the *chapter5-api* directory.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们反序列化了天气数据，我们就可以将其保存到数据库中。[示例 5-3](#EX5-3)展示了Lambda函数的完整代码——您可能还想打开*chapter5-api*目录中的示例代码。
- en: Example 5-3\. WeatherEventLambda handler class
  id: totrans-103
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-3\. WeatherEventLambda处理程序类
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: First you can see we create a few instance variables outside of the handler
    function. We talk about why we do that in [“Scaling”](ch08.html#lambda-scaling),
    but the summary is that the Lambda platform typically uses the same instance of
    a Lambda function several times (although never concurrently), so we can optimize
    performance a little by only creating certain things once for the lifetime of
    the Lambda function instance.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您可以看到我们在处理程序函数外创建了一些实例变量。我们在[“扩展”](ch08.html#lambda-scaling)中讨论了为什么要这样做，但总结一下，Lambda平台通常会多次使用同一个Lambda函数实例（虽然不会同时），因此我们可以通过仅为Lambda函数实例的生命周期创建某些东西来优化性能。
- en: The first instance variable is Jackson’s `ObjectMapper`, and the second is the
    DynamoDB SDK. The third and final instance variable is the table name within DynamoDB
    that we want to use. The precise value of that comes from our infrastructure template,
    so we use an environment variable to configure our Lambda function, just as we
    discussed in [“Environment Variables”](ch03.html#environment-variables).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个实例变量是Jackson的`ObjectMapper`，第二个是DynamoDB SDK。第三个也是最后一个实例变量是我们想要使用的DynamoDB中的表名。其精确值来自我们的基础设施模板，因此我们使用环境变量来配置我们的Lambda函数，就像我们在[“环境变量”](ch03.html#environment-variables)中讨论的那样。
- en: The remainder of the class is our Lambda handler function. First of all, you
    can see the signature, with the types that you’d expect given the event source
    that we’re dealing with. One slight addition here, though, is that our Lambda
    handler declares that it may throw an exception—this is completely valid, and
    we discuss error handling more in [“Error Handling”](ch08.html#error-handling).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 类的剩余部分是我们的 Lambda 处理函数。首先，您可以看到签名，与我们正在处理的事件源所期望的类型相符。不过，这里有一个小的额外声明，即我们的 Lambda
    处理程序声明可能会抛出异常——这是完全有效的，我们在 [“错误处理”](ch08.html#error-handling) 中进一步讨论错误处理。
- en: The first line of the handler deserializes the weather event embedded within
    the `body` field of the original HTTP request. `WeatherEvent` is defined in [Example 5-4](#EX5-4)
    in its own class.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 处理程序的第一行对原始 HTTP 请求的 `body` 字段中嵌入的天气事件进行反序列化处理。`WeatherEvent` 在其自己的类中定义，详情见
    [示例 5-4](#EX5-4)。
- en: Example 5-4\. WeatherEvent class
  id: totrans-109
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-4\. WeatherEvent 类
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this case, Jackson uses the no-argument constructor, and populates the fields
    of the object based on the value passed in the `body` field of the original Lambda
    event.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，Jackson 使用无参构造函数，并根据原始 Lambda 事件的 `body` 字段中的值填充对象的字段。
- en: 'Now we’ve captured our full weather event, we can save this to the database.
    We’re not going to go into detail of how to use DynamoDB here, but you can see
    from the code that:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经捕获了完整的天气事件，我们可以将其保存到数据库中。我们不打算在这里详细介绍如何使用 DynamoDB，但从代码中可以看出：
- en: We use the environment variable of the table name to connect to our desired
    table.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用表名的环境变量来连接到我们想要的表。
- en: We use the DynamoDB Java SDK’s “Document model” to save data to the table, using
    the location name as the primary key.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用 DynamoDB Java SDK 的“文档模型”将数据保存到表中，使用位置名称作为主键。
- en: Finally, we need to return a response. Since we got this far, we assume (for
    now!) that everything worked successfully, in which case returning an HTTP 200
    (“OK”) response is the right thing to do, and to make it clearer to the client
    what we actually did, we return the location name that was saved.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要返回一个响应。由于到目前为止一切正常（目前为止！），返回 HTTP 200（“OK”）响应是正确的做法，为了让客户端更清楚我们实际做了什么，我们返回保存的位置名称。
- en: That’s all the code that we need to handle the write path of our API. Now let’s
    look at the read path.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们处理 API 写路径所需的所有代码。现在让我们看看读路径。
- en: Reading weather data with WeatherQueryLambda
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 WeatherQueryLambda 读取天气数据
- en: As you’d expect, `WeatherQueryLambda` is similar to `WeatherEventLambda`, but
    reversed. [Example 5-5](#EX5-5) shows the code.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所料，`WeatherQueryLambda` 类似于 `WeatherEventLambda`，但相反。代码详见 [示例 5-5](#EX5-5)。
- en: Example 5-5\. WeatherQueryLambda handler class
  id: totrans-119
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-5\. WeatherQueryLambda 处理程序类
- en: '[PRE15]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We see a similar set of instance variables. The DynamoDB one is slightly different
    because of the DynamoDB SDK’s API, but the Jackson one is the same, and again
    we capture the environment variable that specifies the table name.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到一组类似的实例变量。DynamoDB 的变量略有不同，因为 DynamoDB SDK 的 API，但 Jackson 的变量是相同的，并且再次捕获指定表名的环境变量。
- en: In the `WeatherEventLambda` handler, we cared about the input event’s `body`
    field. This time we care about the `queryStringParameters` field, and specifically
    the `limit` parameter, if it’s set. If it is set, we use it. Otherwise, we default
    to 50 as the maximum number of records we want to retrieve from DynamoDB.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `WeatherEventLambda` 处理程序中，我们关注输入事件的 `body` 字段。这次我们关注 `queryStringParameters`
    字段，特别是 `limit` 参数，如果设置了的话。如果设置了，我们就使用它。否则，默认情况下，我们从 DynamoDB 中检索的最大记录数为 50。
- en: The next couple of statements read the data from DynamoDB, and after those,
    we convert the DynamoDB results back into `WeatherEvent` objects. With the weather
    events captured, we use Jackson again to create a JSON string response to return
    to the client.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几个语句从 DynamoDB 中读取数据，在此之后，我们将 DynamoDB 结果转换回 `WeatherEvent` 对象。获取了天气事件之后，我们再次使用
    Jackson 创建一个 JSON 字符串响应返回给客户端。
- en: Finally, we send our API response—again setting 200 OK as the status code, but
    this time putting the useful response in the `body` field.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们发送我们的 API 响应——再次设置 200 OK 作为状态码，但这次将有用的响应放在 `body` 字段中。
- en: And that’s it for code! With very little code, even with the verbosity of Java,
    we have a full HTTP API that reads and writes values to a database. But, of course,
    our code isn’t all there is to defining the app. As we saw in [Chapter 4](ch04.html#ch04),
    we also need to build and package our code. And we actually need to define our
    infrastructure too.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是全部的代码了！即使使用Java的冗长，我们也有一个完整的HTTP API，可以读取和写入数据库的值。但是，当然，定义应用程序不仅仅是我们的代码。正如我们在[第4章](ch04.html#ch04)中看到的，我们还需要构建和打包我们的代码。而且我们实际上还需要定义我们的基础设施。
- en: We look at building and packaging next.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们来看构建和打包。
- en: Build and Package Using the AWS SDK BOM
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用AWS SDK BOM进行构建和打包
- en: In [Chapter 4](ch04.html#ch04) we showed how to build and package a Lambda application
    using Maven. In this example, we’re going to use the ZIP format that we described
    there, so we need a *pom.xml* file, and an assembly description file. The latter
    of those is no different to what we’ve seen before, so we ignore that here.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](ch04.html#ch04)中，我们展示了如何使用Maven构建和打包Lambda应用程序。在这个示例中，我们将使用我们在那里描述的ZIP格式，所以我们需要一个*pom.xml*文件和一个组件描述文件。后者与我们之前看到的没有什么不同，所以我们在这里忽略它。
- en: 'Let’s take a quick look at the *pom.xml* file, cut down a little for brevity:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下*pom.xml*文件，为了简洁起见稍微减少了一些内容：
- en: Example 5-6\. Partial Maven POM file for HTTP API
  id: totrans-130
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例5-6\. HTTP API的部分Maven POM文件
- en: '[PRE16]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: An element that we’ve added here since [Chapter 4](ch04.html#ch04) is the `<dependencyManagement>`
    section. In this tag we reference a dependency named `aws-java-sdk-bom`. This
    useful element is a feature of Maven known as a “bill of materials” (BOM), and
    in essence it groups all the version dependencies for a set of libraries. We use
    it here so that any AWS Java SDK dependencies that we use are guaranteed to be
    in sync with each other with respect to versions.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里添加的一个元素是自[第4章](ch04.html#ch04)以来的`<dependencyManagement>`部分。在这个标签中，我们引用了一个名为`aws-java-sdk-bom`的依赖关系。这个有用的元素是Maven的一个特性，称为“材料清单”（BOM），实质上它将一组库的版本依赖项分组。我们在这里使用它是为了确保我们使用的任何AWS
    Java SDK依赖项在版本上保持同步。
- en: In this particular project, we actually use only one AWS Java SDK library—`aws-java-sdk-dynamodb`—and
    so using the BOM is less necessary for this example. But many Lambda applications
    use multiple AWS SDKs, so it’s useful to start off on solid footing.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定项目中，我们实际上只使用了一个AWS Java SDK库——`aws-java-sdk-dynamodb`，因此对于这个示例来说使用BOM不是很必要。但是许多Lambda应用程序使用多个AWS
    SDK，因此从稳定的基础开始是很有用的。
- en: You can also see that we don’t define the version for `aws-java-sdk-dynamodb`
    in the `<dependency>` section, because it uses the version defined in the BOM.
    We do still have to declare the version of `aws-lambda-java-core` because that’s
    not part of the AWS Java SDK, and therefore not in the BOM—you can tell because
    it doesn’t have “sdk” in its name. You can read more about the AWS Java SDK BOM
    [in this blog article](https://oreil.ly/V1x9x).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以看到我们在`<dependency>`部分没有定义`aws-java-sdk-dynamodb`的版本，因为它使用BOM中定义的版本。但我们仍然需要声明`aws-lambda-java-core`的版本，因为它不是AWS
    Java SDK的一部分，因此不在BOM中——您可以从其名称中看出来它没有“sdk”。您可以在[这篇博客文章](https://oreil.ly/V1x9x)中了解更多关于AWS
    Java SDK BOM的信息。
- en: In this example, we collect the code for both of our different Lambda functions
    into one zipped package. In the next example later in this chapter, we show how
    you can break this package up into individual artifacts.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将两个不同的Lambda函数的代码收集到一个压缩包中。在本章后面的下一个示例中，我们展示如何将此包拆分为单独的构件。
- en: With the dependency updates defined, we can build and package our application,
    using `mvn package` as usual.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了依赖项更新后，我们可以像往常一样使用`mvn package`来构建和打包我们的应用程序。
- en: Infrastructure
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基础设施
- en: The one element we still need to define is our infrastructure template.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要定义的一个元素是我们的基础设施模板。
- en: So far in this book we’ve only defined Lambda resources. Now we need to define
    our API Gateway, and our database. How do we do that? [Example 5-7](#EX5-7) shows
    the *template.yaml*.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本书中我们只定义了Lambda资源。现在我们需要定义我们的API Gateway和我们的数据库。我们应该如何做？[示例 5-7](#EX5-7)展示了*template.yaml*。
- en: Example 5-7\. SAM template for HTTP API
  id: totrans-140
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例5-7\. HTTP API的SAM模板
- en: '[PRE17]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Let’s go through this from the top.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从头开始过一遍。
- en: First of all we have our CloudFormation and SAM headers—these are no different
    to what we’ve seen before.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 首先我们有我们的CloudFormation和SAM头文件——这与我们之前见过的没有什么不同。
- en: Next is a new top-level section named `Globals`. `Globals` is a code-optimizing
    feature of SAM that allows us to define some of the properties common to all the
    resources of the same type in an application. We mostly use it here to define
    a few properties common to both of the Lambda functions that we declare later
    in the file. We’ve already seen `Runtime`, `MemorySize`, and `Timeout`, but the
    way we’ve declared `LOCATIONS_TABLE` in the `Environment` key, with the `!Ref`
    string, is new—we will come back to that in a moment. Note that not all properties
    from a function definition work within the `Globals` section, which is why you
    don’t see `CodeUri` defined within the `Globals`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是一个名为`Globals`的新顶级部分。`Globals`是 SAM 的一个代码优化特性，允许我们在应用程序中定义所有相同类型资源的一些常见属性。我们在这里主要用它来定义稍后在文件中声明的两个
    Lambda 函数共同的一些属性。我们已经看到了`Runtime`、`MemorySize`和`Timeout`，但我们在`Environment`键中声明`LOCATIONS_TABLE`的方式，使用了`!Ref`字符串，这是新的——我们稍后会回到这一点。请注意，并非所有函数定义的属性都适用于`Globals`部分，这就是为什么您在`Globals`中没有看到`CodeUri`定义的原因。
- en: Finally, in the `Globals` section is a small configuration of the API Gateway
    settings to use the most up-to-date version of SAM’s API configuration.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`Globals`部分是 API Gateway 设置的小配置，以使用 SAM 的 API 配置的最新版本。
- en: Then we move into the rest of the template, which consists of `Resources` elements.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们进入模板的其余部分，其中包含`Resources`元素。
- en: The first one is new—it’s of type `AWS::Serverless::SimpleTable`. This is SAM’s
    way of defining DynamoDB databases. It works for simple configurations, which
    is fine for us in this example.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是新的——它是`AWS::Serverless::SimpleTable`类型。这是 SAM 定义 DynamoDB 数据库的方式。对于简单的配置，这在我们的示例中是可以的。
- en: Note that what we’re doing here isn’t merely pointing to a database that already
    exists—we’re actually declaring that we want CloudFormation to create a database
    for us, and managing it in the same stack of components as our Lambda functions,
    etc. All we do is specify what we want the primary key field to be named, and
    AWS does everything else to manage the table on our behalf.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们这里所做的并不仅仅是指向一个已经存在的数据库——我们实际上声明要求 CloudFormation 为我们创建一个数据库，并在与我们的 Lambda
    函数等组件相同的堆栈中进行管理。我们所做的就是指定我们希望主键字段命名为什么，AWS 将为我们管理表的一切。
- en: We don’t even give the table a physical name—CloudFormation generates a unique
    name for us based on the name of the stack, the logical name of the table, `LocationsTable`,
    plus some randomly generated uniqueness. That’s all well and good, but if we don’t
    know the name of the table, how are we meant to use it from our Lambda functions?
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至不给表一个物理名称——CloudFormation 为我们基于堆栈名称、表的逻辑名称`LocationsTable`以及一些随机生成的唯一性生成一个唯一名称。这一切都很好，但如果我们不知道表的名称，我们怎么能从我们的
    Lambda 函数中使用它呢？
- en: That’s where the `!Ref LocationsTable` value that we saw earlier comes in. CloudFormation
    substitutes that string for the physical name of the DynamoDB table, and so our
    Lambda functions have an environment variable pointing them to the correct location.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们之前看到的`!Ref LocationsTable`值的作用。CloudFormation 用该字符串替换 DynamoDB 表的物理名称，因此我们的
    Lambda 函数具有指向正确位置的环境变量。
- en: 'Moving on from the DynamoDB table, we see the definitions of our two Lambda
    functions. These elements contain a lot of ideas we’ve covered already. We saw
    the `Policies` section in [Chapter 4](ch04.html#ch04)—note how we’re embracing
    the principle of least privilege here by:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 离开 DynamoDB 表后，我们看到了我们两个 Lambda 函数的定义。这些元素包含了我们已经涵盖过的许多概念。我们在 [第4章](ch04.html#ch04)
    中看到了`Policies`部分——请注意，我们通过以下方式支持最小权限原则：
- en: Only giving our functions access to one specific DynamoDB table (see `!Ref`
    being used again)
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅允许我们的函数访问一个特定的 DynamoDB 表（见再次使用的`!Ref`）
- en: Only giving the Lambda function that is querying data read-only access (by declaring
    the `DynamoDBReadPolicy` policy)
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅为查询数据的 Lambda 函数提供只读访问（通过声明`DynamoDBReadPolicy`策略）
- en: We also see the `Events` section in each Lambda function that we covered briefly
    earlier in this chapter. As we mentioned then, what’s happening here is that SAM
    is defining an implicit API Gateway, and then is attaching our Lambda functions
    to that Gateway with the `Path` and `Method` properties defined in the `Events`
    sections.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在每个 Lambda 函数中看到了`Events`部分，我们在本章稍作介绍。正如我们当时提到的，这里发生的是 SAM 正在定义一个隐式的 API
    Gateway，并且将我们的 Lambda 函数与`Events`部分定义的`Path`和`Method`属性附加到该 Gateway。
- en: In many real-life scenarios, the implicit API Gateway configuration won’t be
    quite enough for your needs, and in that case you can define either an explicit
    SAM API Gateway resource (using a resource of type `AWS::Serverless::Api`), or
    the underlying CloudFormation API Gateway resource types. If you use the first
    of these options, you can add a `RestApiId` property to the API `Event` property
    of your Lambda functions to tie them to your self-defined API.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多实际场景中，隐式API Gateway配置可能不够满足您的需求，在这种情况下，您可以定义显式的SAM API Gateway资源（使用`AWS::Serverless::Api`类型的资源），或者基础CloudFormation
    API Gateway资源类型。如果您使用这些选项中的第一个选项，您可以在Lambda函数的API `Event`属性中添加一个 `RestApiId`属性，以将它们与您自定义的API绑定在一起。
- en: You can also use Swagger/Open API as part of the CloudFormation/SAM definition
    of your API Gateway. That way you’ll get better documentation, plus the opportunity
    for some amount of “no code required” input validation—but definitely don’t rely
    on Swagger/API Gateway as a complete input validator. Also there are certain aspects
    to API Gateway’s configuration that can be defined only using AWS’s own [OpenAPI
    extensions](https://oreil.ly/Cq-_T). We could write an entire mini-book just on
    this area, though, so we’ll leave you to go explore the AWS documentation for
    yourself if that’s what you need!
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在CloudFormation/SAM定义的API Gateway中使用Swagger/Open API。这样，您将获得更好的文档，以及一定程度上的“无需代码”输入验证的机会——但绝对不要依赖Swagger/API
    Gateway作为完整的输入验证器。另外，有些API Gateway配置方面的内容只能使用AWS自己的[OpenAPI扩展](https://oreil.ly/Cq-_T)来定义。如果需要的话，我们可以撰写一整本小书，但现在就让你去探索AWS文档吧！
- en: This is all a little theoretical, but fortunately we’ve finished looking at
    the template, so it’s time to deploy and test our application!
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都有点理论性，但幸运的是，我们已经完成了对模板的查看，所以现在是部署和测试我们的应用程序的时候了！
- en: Deployment
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署
- en: Warning
  id: totrans-159
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: As is, the API in this example is publicly accessible on the internet. While
    this is OK for experimentation (since the full API name isn’t easily discoverable),
    it’s not something you want to leave around forever since anyone can read and
    write to this API. In a production scenario you would want to add some amount
    of security at least around the write path, but that’s beyond the scope of what
    we’re going to cover here.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，API是公开可访问的。虽然这对于实验（因为完整的API名称不容易被发现）来说是可以的，但这不是你想永远保留的东西，因为任何人都可以读取和写入这个API。在生产环境中，您至少希望在写入路径周围添加一些安全性，但这超出了我们将在此处涵盖的范围。
- en: To deploy the application, use precisely the same incantation of `sam deploy`
    that you’ve done already (if you need to refresh your memory, take a look at [“CloudFormation
    and the Serverless Application Model”](ch04.html#cloudformation-and-sam)). The
    only thing you may want to change is the `stack-name` so that you deploy this
    to a new stack (e.g., `ChapterFiveApi`).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 部署应用程序时，请使用与之前完全相同的 `sam deploy` 命令（如果需要刷新记忆，请查看[“CloudFormation和Serverless应用程序模型”](ch04.html#cloudformation-and-sam)）。唯一可能想要更改的是
    `stack-name`，这样你就可以将其部署到一个新的堆栈（例如，`ChapterFiveApi`）。
- en: Once SAM and CloudFormation have completed, you’ll have deployed a new stack
    to CloudFormation. We can see this in the CloudFormation section of the AWS Web
    Console ([Figure 5-3](#http-api-cloudformation)).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦SAM和CloudFormation完成，您就会在CloudFormation部分的AWS Web控制台中部署一个新的堆栈。我们可以在CloudFormation部分看到这一点（参见[图 5-3](#http-api-cloudformation)）。
- en: '![images/ch05_image03.png](assets/awsl_0503.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![images/ch05_image03.png](assets/awsl_0503.png)'
- en: Figure 5-3\. CloudFormation stack for HTTP API
  id: totrans-164
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-3\. HTTP API的CloudFormation堆栈
- en: CloudFormation is a little low level, though, and so usefully AWS also provides
    a way of viewing this deployment in a view called *Serverless Application*, just
    as we designed earlier in [“Architecture”](#architecture-section). You can access
    this view via the Applications tab of the Lambda console ([Figure 5-4](#http-api-appview)).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: CloudFormation有点低级，因此AWS还提供了一种称为*Serverless Application*的视图，可以在此视图中查看此部署，就像我们之前在[“架构”](#architecture-section)中设计的那样。您可以通过Lambda控制台的应用程序选项卡访问此视图（参见[图 5-4](#http-api-appview)）。
- en: '![images/ch05_image04.png](assets/awsl_0504.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![images/ch05_image04.png](assets/awsl_0504.png)'
- en: Figure 5-4\. Serverless Application view for HTTP API
  id: totrans-167
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-4\. HTTP API的无服务器应用程序视图
- en: In this view you can see the DynamoDB table, the API Gateway (referred to as
    a *RestAPI* in AWS terms), and our two Lambda functions. If you click any of these
    resources, you are taken to the correct service console, and into that resource—try
    it out for the *ServerlessRestApi* resource. This puts you in the API Gateway
    console. Click *Stages* on the left and then *Prod*—you should see something like
    [Figure 5-5](#http-api-apigateway).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在此视图中，您可以看到 DynamoDB 表、API Gateway（在 AWS 术语中称为 *RestAPI*）以及我们的两个 Lambda 函数。如果您点击其中任何资源，您将被带到正确的服务控制台，并进入该资源
    — 尝试点击*ServerlessRestApi*资源。这将带您进入 API Gateway 控制台。在左侧点击 *Stages*，然后点击 *Prod*
    — 您应该会看到类似于 [Figure 5-5](#http-api-apigateway) 的内容。
- en: '![images/ch05_image05.png](assets/awsl_0505.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![images/ch05_image05.png](assets/awsl_0505.png)'
- en: Figure 5-5\. API Gateway view for HTTP API
  id: totrans-170
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: Figure 5-5\. HTTP API 的 API Gateway 视图
- en: The *Invoke URL* value is the publicly accessible URL for your API—make a note
    of it since you’ll need it in a moment.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '*Invoke URL* 值是您的 API 的公共访问 URL — 记下来，因为您一会儿会需要它。'
- en: You can also see in the *Serverless Application* view that the physical names
    for the resources have the partially generated/partially random structure we discussed
    earlier. For example, in this case, our DynamoDB table is actually named *ChapterFiveApi-LocationsTable-WFRRTZNM7JTF*.
    And sure enough, if we look in the Lambda console at either of the two functions
    for this application, we can see that the `LOCATIONS_TABLE` environment variable
    is correctly set to this value ([Figure 5-6](#http-api-lambdaconfig)).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在*无服务器应用程序*视图中看到资源的物理名称具有部分生成/部分随机的结构，正如我们之前讨论的那样。例如，在这种情况下，我们的 DynamoDB
    表实际上被命名为 *ChapterFiveApi-LocationsTable-WFRRTZNM7JTF*。确实，如果我们在 Lambda 控制台中查看此应用程序的两个函数之一，我们可以看到`LOCATIONS_TABLE`环境变量已正确设置为此值（参见
    [Figure 5-6](#http-api-lambdaconfig)）。
- en: '![images/ch05_image06.png](assets/awsl_0506.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![images/ch05_image06.png](assets/awsl_0506.png)'
- en: Figure 5-6\. API Gateway view for HTTP API
  id: totrans-174
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: Figure 5-6\. HTTP API 的 API Gateway 视图
- en: Finally, let’s test our deployment by calling both API routes. To do this, you
    need that URL from a moment ago.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们通过调用两个 API 路径来测试我们的部署。为此，您需要从一会儿前的 URL 获取。
- en: 'First, let’s send some data. The base of the URL is the one from the API Gateway
    console, but we append `/events`. We can call our API using curl, for example,
    as follows (substitute in your URL):'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们发送一些数据。URL 的基础是来自 API Gateway 控制台的 URL，但我们附加 `/events`。例如，我们可以使用 curl
    调用我们的 API，如下所示（请替换为您的 URL）：
- en: '[PRE18]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This has saved two new events to DynamoDB. You can prove that to yourself by
    clicking on the DynamoDB table from the Serverless Application console, and then
    clicking on the *Items* tab once you’re in the DynamoDB console ([Figure 5-7](#http-api-dynamodb)).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这将两个新事件保存到 DynamoDB。您可以通过从无服务器应用程序控制台点击 DynamoDB 表，然后在进入 DynamoDB 控制台后点击*Items*选项卡来验证这一点（参见
    [Figure 5-7](#http-api-dynamodb)）。
- en: '![images/ch05_image07.png](assets/awsl_0507.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![images/ch05_image07.png](assets/awsl_0507.png)'
- en: Figure 5-7\. DynamoDB table for HTTP API
  id: totrans-183
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: Figure 5-7\. HTTP API 的 DynamoDB 表
- en: 'And now we can use the final part of our application—reading from the API.
    We can use curl for that again, adding `/locations` to the API Gateway console
    URL, for example:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用我们应用程序的最后部分 — 从 API 读取。例如，我们可以再次使用 curl，将 `/locations` 添加到 API Gateway
    控制台的 URL 中：
- en: '[PRE22]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As expected, this returns the list of locations that we’ve stored weather for.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，这将返回我们已存储天气信息的位置列表。
- en: Congratulations! You’ve built your first full serverless application! While
    it has only one simple feature, think of all the *nonfunctional* capabilities
    it has—it auto-scales up to handle a vast load and then back down when not in
    use, it’s fault-tolerant across multiple availability zones, it has infrastructure
    that is automatically updated to include critical security patches, and it has
    a whole lot more besides.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您已经构建了您的第一个完整的无服务器应用程序！虽然它只有一个简单的功能，但想象一下它具有的所有*非功能*能力 — 它可以自动扩展以处理大量负载，然后在不使用时自动缩减，它跨多个可用区具有容错能力，其基础设施会自动更新以包括关键安全补丁，并且除此之外，还有很多其他功能。
- en: Now let’s look at a different type of application, using a couple of other different
    AWS services.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一个不同类型的应用程序，使用其他几个不同的 AWS 服务。
- en: 'Example: Building a Serverless Data Pipeline'
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例：构建无服务器数据流水线
- en: In [Chapter 1](ch01.html#ch01) we listed two use cases for Lambda ([“What Does
    a Lambda Application Look Like?”](ch01.html#what_does_a_lambda_application_look_like)).
    The first was an HTTP API that we just described in more detail—an example of
    synchronous usage of Lambda. The second use case was file processing—uploading
    a file to S3 and then using Lambda to do something with that file.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 1 章](ch01.html#ch01) 中，我们列出了 Lambda 的两个用例（[“Lambda 应用是什么样子？”](ch01.html#what_does_a_lambda_application_look_like)）。第一个是我们刚刚详细描述的
    HTTP API——Lambda 的同步使用示例。第二个用例是文件处理——将文件上传到 S3，然后使用 Lambda 处理该文件。
- en: In this example, we’re building on that second idea to create a *data pipeline*.
    A data pipeline is a pattern where we chain together multiple asynchronous stages
    and branches of processing data. It’s a popular pattern where the scalability
    of cloud resources gives a real-time alternative to batch systems.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们在第二个想法的基础上构建了一个 *数据流水线*。数据流水线是一种模式，其中我们将多个异步阶段和数据处理分支串在一起。这是一种流行的模式，云资源的可伸缩性为批处理系统提供了实时的替代方案。
- en: Another important element of this example is that we’re going to change the
    build and packaging phases of our application to create isolated output artifacts
    for each Lambda function. As the amount of code in your Lambda functions grows—both
    that which is specific to the function and that which is imported as libraries—then
    deployment and startup will slow down. Breaking up the packaged artifacts is a
    valuable technique to mitigate that.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例的另一个重要元素是，我们将改变应用程序的构建和打包阶段，以创建每个 Lambda 函数的隔离输出工件。随着 Lambda 函数中代码的增加——无论是特定于函数的代码还是作为库导入的代码——部署和启动将变慢。分解打包工件是减轻这种问题的一种有效技术。
- en: Let’s get started.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: Behavior
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 行为
- en: This example is going to be another take on the weather event system we started
    in the previous example. This time an application will upload a list of “weather
    events” in a JSON file to S3. A data pipeline will then process this file, and
    for now the side effect will merely be logging the events to AWS CloudWatch Logs
    ([Figure 5-8](#data-pipeline-behavior)).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例是我们在前一个示例中开始的另一种天气事件系统。这次，一个应用程序将一个 JSON 文件中的“天气事件”列表上传到 S3。数据流水线将处理这个文件，目前的副作用只是将事件记录到
    AWS CloudWatch Logs 中（[图 5-8](#data-pipeline-behavior)）。
- en: '![images/ch05_image08.png](assets/awsl_0508.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![images/ch05_image08.png](assets/awsl_0508.png)'
- en: Figure 5-8\. Data pipeline example behavior
  id: totrans-198
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-8\. 数据流水线示例行为
- en: Architecture
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 架构
- en: What we’ve just shown is the *behavior* of this application—the *architecture*
    has a few more details ([Figure 5-9](#data-pipeline-architecture)).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚展示的是此应用程序的 *行为* ——*架构* 还有一些更多的细节（[图 5-9](#data-pipeline-architecture)）。
- en: '![images/ch05_image09.png](assets/awsl_0509.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![images/ch05_image09.png](assets/awsl_0509.png)'
- en: Figure 5-9\. Data pipeline example architecture
  id: totrans-202
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-9\. 数据流水线示例架构
- en: We start this application with an S3 bucket. The act of uploading a file, or
    in S3 terms an *object*, to S3 will (asynchronously) trigger a Lambda function.
    This first function (`BulkEventsLambda`) will read the JSON list of weather events,
    separate them out into individual events, and then publish each one onto a SNS
    topic. This in turn will trigger (asynchronously again) a second Lambda function
    (`SingleEventLambda`) which will then process each weather event. In our case,
    this will simply mean logging the event.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个 S3 存储桶开始这个应用程序。将文件上传到 S3，或者按 S3 的术语说是一个 *对象*，将会（异步地）触发一个 Lambda 函数。这个第一个函数（`BulkEventsLambda`）将读取天气事件的
    JSON 列表，将它们分开成单个事件，并且将每个事件发布到一个 SNS 主题上。这反过来会（再次异步地）触发第二个 Lambda 函数（`SingleEventLambda`），这个函数将处理每个天气事件。在我们的案例中，这仅仅意味着记录事件。
- en: This architecture is obviously far too complicated just for logging the contents
    of an uploaded file! However, the important aspect of the example is that it provides
    a “walking skeleton” of an application that has a complete, deployable, multistage
    data pipeline. You could then use this as a starting point for adding interesting
    processing logic.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这种架构对于仅记录上传文件的内容来说过于复杂了！然而，这个示例的重要之处在于它提供了一个应用程序的“行走骨架”，具有完整、可部署的、多阶段数据流水线。您可以将其作为添加有趣处理逻辑的起点。
- en: All of these components are treated as one collectively deployed serverless
    application, just as we did in the HTTP API example.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些组件都被视为一个统一部署的无服务器应用程序，就像我们在 HTTP API 示例中所做的那样。
- en: Now we’ll dig in further to each of these stages of the architecture.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将进一步深入讨论架构的每个阶段。
- en: S3
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: S3
- en: S3 is one of the oldest services in AWS, as we described in [“The Cloud Grows”](ch01.html#the-cloud-grows).
    While it’s often used in the application architecture of systems, it’s commonplace
    too when deploying and operating AWS applications—we’ve used S3 a number of times
    in this book already when deploying our Lambda-based applications.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: S3是AWS中历史最悠久的服务之一，正如我们在[“云的增长”](ch01.html#the-cloud-grows)中所描述的。虽然它经常在系统的应用架构中使用，但在部署和操作AWS应用程序时也很普遍——在本书中，我们在部署基于Lambda的应用程序时已多次使用了S3。
- en: 'More than that, however, we think that S3 is one of the earliest examples of
    a serverless BaaS product, at least on AWS. If we look back to [Chapter 1](ch01.html#ch01)
    at the factors that “differentiate” serverless, we can see it ticks all the boxes:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们认为S3至少在AWS上是最早的无服务器BaaS产品之一。如果我们回顾[第1章](ch01.html#ch01)中“区分”无服务器的因素，我们可以看到它符合所有标准：
- en: Does not require managing a long-lived host or application instance
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要管理长期运行的主机或应用实例
- en: Yes—we have no “file servers” or otherwise to manage when we use S3.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 是的——当我们使用S3时，我们没有“文件服务器”或其他需要管理的内容。
- en: Self auto-scales and auto-provisions, dependent on load
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 自动按负载自动扩展和自动供应
- en: Yes, we never have to manually configure how much capacity we want with S3—it
    auto-scales both for total storage, and for traffic.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我们不需要手动配置S3的容量——它会自动扩展总存储空间和流量。
- en: Has costs that are based on precise usage, up from and down to zero usage
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 其费用基于精确的使用量，从零使用到高使用
- en: Yes! If you have an empty bucket, you don’t pay anything. Alternatively, your
    cost will be dependent on the amount of bytes stored, amount of traffic, and your
    storage class (see next point).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 是的！如果您有一个空的存储桶，您不需要支付任何费用。或者，您的费用将取决于存储的字节数量、流量量和存储类别（请参阅下一点）。
- en: Has performance capabilities defined in terms other than host size/count
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 以除主机大小/数量以外的术语定义的性能能力
- en: Yes, again! S3’s performance capabilities are the storage class you choose—how
    quickly you need to access data. The more quickly you want to be able to access
    your data, the more you’ll pay.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，再次确认！S3的性能能力是您选择的存储类别——您需要多快访问数据。您希望能够更快地访问数据，您就需要支付更多费用。
- en: Has implicit high availability
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 具有隐式高可用性
- en: And yes. S3 replicates data across AZs within a region. If one AZ has a problem,
    you’ll still be able to access all of your data.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 是的。S3在一个区域内的多个可用区之间复制数据。如果一个可用区出现问题，您仍然可以访问所有数据。
- en: Because S3 is serverless, it is a great partner to Lambda, especially because
    of their similar scaling capabilities. Further, S3 directly integrates with Lambda
    by allowing Lambda functions to be triggered whenever data changes in an S3 bucket.
    This way of reacting to changes automatically in S3 in an event-driven manner,
    rather than having to poll S3 to look for changes from a long-running traditional
    process, is cleaner, easier to understand, and more efficient from an infrastructure
    costs point of view.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 由于S3是无服务器的，它与Lambda是极好的伙伴，尤其是因为它们具有类似的扩展能力。此外，S3通过允许Lambda函数在S3存储桶中的数据更改时触发Lambda函数，与Lambda直接集成。这种以事件驱动方式自动响应S3中的变化，而不是从长时间运行的传统进程中轮询S3查找变化，从基础设施成本的角度来看更清晰、更易于理解和更高效。
- en: All of the non-Lambda services we use in these two examples—API Gateway, DynamoDB,
    S3, and SNS—are serverless BaaS services within the AWS ecosystem.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个示例中使用的所有非Lambda服务——API网关、DynamoDB、S3和SNS——都是AWS生态系统中的无服务器BaaS服务。
- en: For now we won’t provide an “upload client” to S3 in the example, and instead
    will use AWS tools to handle uploading. In a real application you may choose to
    allow your end user client to upload directly to S3 by means of a “Signed URL”—this
    is a “pure” serverless approach since you are not only not running servers, you’re
    in fact pushing behavior to the client that you may otherwise have implemented
    in a server-side application.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们不会在示例中提供将“上传客户端”到S3，而是使用AWS工具来处理上传。在真实应用中，您可以选择允许您的最终用户客户端通过“签名URL”直接上传到S3——这是一种“纯”无服务器方法，因为您不仅不运行服务器，实际上还将行为推送到客户端，这可能是您以前在服务器端应用程序中实现的行为。
- en: Lambda functions
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Lambda函数
- en: When you see the code for the Lambda functions a little later, you won’t come
    across anything new given everything you’ve already learned. The only real difference
    to what we did in the first example is that these functions won’t need to return
    any values since they are invoked asynchronously.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 当您稍后查看 Lambda 函数的代码时，您不会遇到任何新东西，因为您已经学到了所有的知识。与第一个示例不同的唯一真正区别是，这些函数不需要返回任何值，因为它们是异步调用的。
- en: One question that might be on your mind, though, is why do we separate out processing
    for each event to a separately invoked Lambda function? This pattern is what we
    often call *fan-out*. Alternatively, it’s the “map” part of a “map-reduce” system,
    and there are a couple of reasons for using it with Lambda.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你心中会有一个问题，为什么我们要将每个事件的处理分别调用到单独的 Lambda 函数中呢？这种模式我们通常称为*扇出*。或者说，它是“映射-减少”系统中的“映射”部分，使用
    Lambda 的原因有几点。
- en: The first reason is to introduce parallelism. Each SNS message will trigger
    a new invocation of our `SingleEventLambda` function. For each invocation of a
    Lambda function, if the previous invocation is not complete, then the Lambda platform
    will automatically create a new instance of the Lambda function, and call that
    instead. In the case of our example app, if you upload a file of one hundred events,
    and each event individually took at least a few seconds to process, then Lambda
    would create one hundred instances of `SingleEventLambda`, and process each weather
    event in parallel ([Figure 5-10](#data-pipeline-fanout)).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个原因是引入并行性。每个 SNS 消息将触发我们的`SingleEventLambda`函数的新调用。对于 Lambda 函数的每次调用，如果前一次调用未完成，Lambda
    平台将自动创建 Lambda 函数的新实例，并调用该实例。在我们的示例应用程序中，如果您上传一个包含一百个事件的文件，而每个事件单独需要至少几秒钟来处理，那么
    Lambda 将创建一百个`SingleEventLambda`实例，并并行处理每个天气事件（[图5-10](#data-pipeline-fanout)）。
- en: '![images/ch05_image10.png](assets/awsl_0510.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![images/ch05_image10.png](assets/awsl_0510.png)'
- en: Figure 5-10\. Data pipeline fan-out
  id: totrans-228
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5-10\. 数据管道扇出
- en: This scaling aspect of Lambda is hugely valuable, and we’ll be discussing it
    further in [Chapter 8](ch08.html#ch08) ([“Scaling”](ch08.html#lambda-scaling)).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 的这种可扩展性非常有价值，我们将在[第8章](ch08.html#ch08)进一步讨论（“扩展”](ch08.html#lambda-scaling)）。
- en: The second reason for introducing fan-out is if each individual event takes
    a long time to process—say a few minutes. In this case, processing one hundred
    weather events would take longer than the maximum 15-minute timeout we have with
    Lambda, but putting each event into its own Lambda invocation means we may be
    able to avoid a timeout concern.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 引入扇出的第二个原因是，如果每个单独事件的处理时间较长——比如几分钟。在这种情况下，处理一百个天气事件将超过 Lambda 的最大15分钟超时限制，但是将每个事件放入其自己的
    Lambda 调用中意味着我们可能可以避免超时问题。
- en: There are other ways of solving Lambda’s timeout restriction. One alternative
    (which is somewhat dangerous—see the following warning!) is to use a recursive
    call in a Lambda function. In [Chapter 3](ch03.html#ch03) ([“Timeout”](ch03.html#lambda-timeout)),
    we saw that we could use the `getRemainingTimeInMillis()` method of the `Context`
    object passed to a Lambda handler to keep track of how long a function has left
    until it times out. A strategy of using this value is to asynchronously directly
    invoke the same Lambda function that’s currently running, but only with the remaining
    data to be processed.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他解决 Lambda 超时限制的方法。一种替代方法（有些危险——请参阅以下警告！）是在 Lambda 函数中使用递归调用。在[第3章](ch03.html#ch03)（“超时”](ch03.html#lambda-timeout)）中，我们看到可以使用传递给
    Lambda 处理程序的`Context`对象的`getRemainingTimeInMillis()`方法来跟踪函数直到超时的剩余时间。使用此值的策略是异步直接调用当前正在运行的相同
    Lambda 函数，但仅使用剩余要处理的数据。
- en: This is a better choice than “fan-out” if your data needs to be processed linearly.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的数据需要按线性顺序处理，这比“扇出”更好的选择。
- en: Warning
  id: totrans-233
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Be careful when calling Lambda functions recursively since it’s easy to have
    runaway scenarios where either (a) you never stop and/or (b) you scale out your
    function hundreds or thousands of instances wide. Either of these can seriously
    impact your AWS bill! Because of reason (b), we recommend in the very rare case
    where a recursive Lambda call makes sense that you use a low “reserved concurrency”
    configuration (see [“Reserved concurrency”](ch08.html#reserved-concurrency)).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 当递归调用 Lambda 函数时要小心，因为很容易出现无法停止的情况，可能会出现两种情况：(a) 永远不会停止，和/或 (b) 扩展函数到数百或数千个实例宽度。这两种情况都会严重影响您的
    AWS 账单！由于情况 (b)，我们建议在极少数情况下，递归 Lambda 调用有意义时，使用低“保留并发”配置（见[“保留并发”](ch08.html#reserved-concurrency)）。
- en: SNS
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SNS
- en: SNS is one of AWS’s messaging services. On one hand, SNS offers a simple [publish-subscribe
    message bus](https://oreil.ly/D5jdc); on another, it provides the capability to
    send *SMS* text messages, and similar human-targeted messages. For our example,
    we only care about the first of these!
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: SNS是AWS的消息服务之一。一方面，SNS提供了一个简单的[publish-subscribe消息总线](https://oreil.ly/D5jdc)；另一方面，它还提供了发送*SMS*文本消息和类似的面向人类的消息的能力。在我们的示例中，我们只关心第一个！
- en: SNS is another serverless service. You are responsible for asking AWS to create
    a Topic, and then AWS handles all the scaling and operations of that Topic behind
    the scenes.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: SNS是另一个无服务器服务。您需要负责请求AWS创建一个主题，然后AWS在幕后处理该主题的所有扩展和操作。
- en: It’s simple to publish a message with a string as its contents to a Topic using
    the SNS SDK, as we’ll see later. There are also multiple subscription types for
    SNS, but we (not surprisingly) are only going to use the Lambda subscription type
    in this example. The way this works is that when a message is published to a Topic,
    all subscribers for that Topic will be sent the message. In the case of Lambda,
    the Lambda platform will receive the message, and then asynchronously invoke the
    Lambda function we’ve associated with the subscription.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 使用SNS SDK发布带有字符串内容的消息到主题非常简单，我们稍后会看到。SNS还有多种订阅类型，但在这个例子中，我们（毫不意外地）只使用Lambda订阅类型。其工作原理是，当消息发布到主题时，该主题的所有订阅者都将收到消息。对于Lambda来说，Lambda平台将接收消息，然后异步调用我们与订阅关联的Lambda函数。
- en: In the case of our example, we want a Lambda function to be asynchronously invoked
    for each weather event in an uploaded file. We could have just directly called
    the `Invoke` method of the Lambda SDK to directly (but asynchronously) invoke
    `Single​EventLambda` from `BatchEventsLambda`, but instead we used SNS as an intermediary—why?
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们希望每次上传文件中的天气事件时都会异步调用Lambda函数。我们本可以直接从Lambda SDK调用`Invoke`方法，直接（但异步地）从`BatchEventsLambda`调用`SingleEventLambda`，但我们选择了使用SNS作为中介——为什么呢？
- en: This is because we want to reduce the structural coupling between the two Lambda
    functions. We want `BatchEventsLambda` to know that its responsibility is splitting
    up a batch of weather events, but we don’t necessarily want it to be involved
    with what happens to those weather events next. If we decide later to evolve our
    architecture so that each event is processed by multiple consumers, or perhaps
    we substitute the [AWS Step Functions service](https://oreil.ly/LWX1e) for `SingleEvent​Lambda`,
    then the code for `BatchEventsLambda` doesn’t need to change.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们希望减少两个Lambda函数之间的结构耦合。我们希望`BatchEventsLambda`知道它的责任是分割一批天气事件，但我们不一定希望它涉及接下来这些天气事件的处理。如果稍后决定改变我们的架构，使每个事件由多个消费者处理，或者可能用AWS
    Step Functions服务替代`SingleEventLambda`，那么`BatchEventsLambda`的代码就不需要改变。
- en: Finally, we chose SNS because of its simplicity and ubiquity within Lambda applications.
    AWS offers a number of other messaging systems—SQS, Kinesis, and Event Bridge
    are some examples, and you can even use S3 if you like! Which service you choose
    really comes down to the specific requirements of your application, and the various
    capabilities of each service. Picking the right messaging service for an application
    can be a little tricky, so it’s worthwhile to do appropriate research.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们选择了SNS，因为它在Lambda应用程序中简单且普遍存在。AWS提供了许多其他的消息系统——SQS、Kinesis和Event Bridge就是其中一些例子，你甚至可以使用S3！选择哪种服务实际上取决于你的应用程序具体的需求，以及每种服务的不同能力。为应用程序选择正确的消息服务可能有些棘手，因此进行适当的研究是值得的。
- en: Lambda Code
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Lambda代码
- en: Our code consists of three classes.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码由三个类组成。
- en: The first is the same `WeatherEvent` as we had in the first example, but copied
    into a new package, for reasons that will become clearer later.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个与我们在第一个示例中相同的`WeatherEvent`，但复制到一个新的包中，原因稍后将会更加清晰。
- en: Processing the batch with BulkEventsLambda
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用BulkEventsLambda处理批处理
- en: The next class is our `BulkEventsLambda` code.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的类是我们的`BulkEventsLambda`代码。
- en: As we’ve discussed already the first thing to do is understand the format of
    the input event.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经讨论过的，首先要做的是了解输入事件的格式。
- en: 'If we run `sam local generate-event s3`, we see that S3 can generate events
    for both “puts” (creates and updates) and “deletes.” We care about the former,
    and the example event looks as follows (trimmed a little for conciseness):'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行`sam local generate-event s3`，我们可以看到S3可以生成“puts”（创建和更新）和“deletes”事件。我们关心前者，示例事件如下（为了简洁起见做了一些修剪）：
- en: '[PRE24]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The first thing to notice is that the event contains an array of `Records`.
    In fact, S3 will only ever send an array with exactly one element in it, but it’s
    good practice to code defensively for this if it’s easy to do so.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是，事件包含一个 `Records` 数组。实际上，S3 只会发送一个包含正好一个元素的数组，但是如果容易这样做，为此进行防御性编码是一个好的实践。
- en: The next thing to notice is that we are told what object has caused this event—`test/key`
    in bucket `example-bucket`. It’s important to remember that S3 isn’t actually
    a file system, even though we often treat it as such. It’s actually a key-value
    store where it just so happens that we might consider the key as if it were a
    path in a file system with directories.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来要注意的是，我们知道是哪个对象引起了这个事件——在存储桶 `example-bucket` 中的 `test/key`。重要的是要记住，尽管我们经常将其视为文件系统，但
    S3 实际上不是文件系统，它是一个键值存储，其中键可以看作是文件系统中的路径。
- en: The final thing to notice is that we don’t receive the contents of the uploaded
    object—we’re only told the *location* of the object. In our example application,
    we want the contents, so we need to load the object from S3 ourselves.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要注意的是，我们并不接收上传对象的内容，我们只知道对象的 *位置*。在我们的示例应用程序中，我们需要内容，因此我们需要自己从 S3 加载对象。
- en: In this example, we’re going to use the `S3Event` class from the `aws-lambda-java-events`
    library as our input event POJO. This class references other types from the `aws-java-sdk-s3`
    SDK library, so we need that in our library dependencies too. That’s OK, though,
    from the perspective of wanting to minimize library dependencies, since we make
    direct calls to the S3 SDK anyway in this class.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用 `aws-lambda-java-events` 库中的 `S3Event` 类作为我们的输入事件 POJO。这个类引用了 `aws-java-sdk-s3`
    SDK 库中的其他类型，因此我们也需要在我们的库依赖中加入它。不过，从希望尽量减少库依赖的角度来看，因为我们在这个类中直接调用了 S3 SDK，所以这是可以接受的。
- en: An `S3Event` object, and its fields, includes everything we need for the input
    event, and since this function is asynchronous, there is no return type. That
    means we’re done with the POJO definition phase and can move on to writing code.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`S3Event` 对象及其字段包含了输入事件所需的一切，由于这个函数是异步的，所以没有返回类型。这意味着我们已经完成了 POJO 定义阶段，可以开始编写代码了。'
- en: We’re leaving the `package` and `import` lines out of [Example 5-8](#EX5-8)
    because there are a lot of them, but if you’re interested in seeing them, please
    download the sample code for the book.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 [Example 5-8](#EX5-8) 的 `package` 和 `import` 行省略了，因为它们太多了，但如果你有兴趣看到它们，请下载本书的示例代码。
- en: Example 5-8\. BulkEventsLambda.java
  id: totrans-256
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-8\. BulkEventsLambda.java
- en: '[PRE25]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The handler method loops over each record in the `S3Event`. We know that there
    should only ever be one, but we’ll be safe with this code if that’s not the case.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 处理方法循环处理 `S3Event` 中的每个记录。我们知道应该只有一个记录，但如果不是这样，这段代码也能保险地处理。
- en: 'The requirements for the remainder of the code are fairly simple:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的其余部分的要求相当简单：
- en: Read uploaded JSON object from S3.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 S3 中读取上传的 JSON 对象。
- en: Deserialize the JSON object into a list of `WeatherEvent` objects.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 JSON 对象反序列化为 `WeatherEvent` 对象列表。
- en: For each `WeatherEvent` object serialize it back into JSON…
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个 `WeatherEvent` 对象，将其重新序列化为 JSON…
- en: …and then publish it to SNS.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: …然后将其发布到 SNS。
- en: If you look at the code, you’ll see all of these expressed. We use Jackson for
    serialization/deserialization just as we did in the first example. We use the
    AWS SDK twice—once to read from S3 (`s3.getObject()`) and once to publish to SNS
    (`sns.publish()`). While these are different SDKs, each requiring their own library
    dependency, they feel broadly the same to use as the DynamoDB SDK did in the previous
    example.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看代码，您会看到所有这些都得到了表达。我们像在第一个示例中一样使用 Jackson 进行序列化/反序列化。我们两次使用 AWS SDK——一次从
    S3 中读取 (`s3.getObject()`)，一次发布到 SNS (`sns.publish()`)。虽然这些是不同的 SDK，每个都需要自己的库依赖，但它们在使用上感觉与之前的
    DynamoDB SDK 大致相同。
- en: 'One thing that’s interesting to notice is that just like in the first example
    we never give any credentials when creating our connections to the AWS SDKs: when
    we call `defaultClient()` on `AmazonSNSClientBuilder` and `AmazonS3ClientBuilder`,
    there is no username or password. This works because the Java AWS SDKs, in the
    context of running within Lambda, by default use the Lambda execution role that
    we configure for the Lambda (and which we discussed in [“Identity and Access Management”](ch04.html#IAM)).
    That means there aren’t any passwords that can leak from our source code!'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的一点是，就像第一个例子中一样，我们在创建与AWS SDK的连接时从未提供任何凭据：当我们在`AmazonSNSClientBuilder`和`AmazonS3ClientBuilder`上调用`defaultClient()`时，没有用户名或密码。这是因为在Lambda中运行时，Java
    AWS SDK默认使用我们为Lambda配置的Lambda执行角色（我们在[“身份和访问管理”](ch04.html#IAM)中讨论过）。这意味着没有密码可以从我们的源代码中泄漏！
- en: Processing an individual weather event with SingleEventLambda
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理单个天气事件使用 SingleEventLambda
- en: On to our final class. You should be getting the hang of this by now, so let’s
    zoom through it!
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 进入我们的最后一个类。你现在应该已经掌握了，所以让我们快速过一遍！
- en: 'First of all, the input event. Running `sam local generate-event sns notification`
    gives us the following, and again this is trimmed a little:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 首先是输入事件。运行 `sam local generate-event sns notification` 给我们以下结果，再次略作修整：
- en: '[PRE26]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Similar to S3, our input event consists of a single-element list of `Records`.
    Within a `Record`, and the `Sns` object within that, are a number of fields. The
    one we care about in this example is `Message`, but SNS messages also offer a
    `Subject` field.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 与S3类似，我们的输入事件由单元素记录列表`Records`组成。在`Record`内部，以及其中的`Sns`对象中，有许多字段。在这个例子中，我们关心的是`Message`，但SNS消息还提供了一个`Subject`字段。
- en: We use the `aws-lambda-java-events` library again, as we did with `BulkEvents​Lambda`,
    but this time we want to use the `SNSEvent` class. `SNSEvent` doesn’t require
    any other AWS SDK classes, so there’s no need to add any further libraries to
    our Maven dependencies.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次使用 `aws-lambda-java-events` 库，就像我们与 `BulkEventsLambda` 一样，但这次我们要使用 `SNSEvent`
    类。 `SNSEvent` 不需要任何其他AWS SDK类，因此无需向我们的Maven依赖中添加任何进一步的库。
- en: And again, this is an asynchronous event type, so there’s no return type to
    worry about.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，这是一种异步事件类型，因此没有需要担心的返回类型。
- en: On to the code (see [Example 5-9](#EX5-9))! Again, we leave out the `package`
    and `import` statements here, but they’re in the book’s downloadable code if you’d
    like to see them.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看代码（参见[示例 5-9](#EX5-9)）！这里再次省略了`package`和`import`语句，但如果你想看到它们，可以在书的可下载代码中找到。
- en: Example 5-9\. SingleEventLambda Handler Class
  id: totrans-274
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-9\. SingleEventLambda Handler 类
- en: '[PRE27]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This time our code is simpler:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们的代码更简单了：
- en: Code defensively again for multiple `SNSRecord` events (even though there should
    only be one).
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次对多个 `SNSRecord` 事件进行防御性编码（尽管应该只有一个）。
- en: Deserialize the `WeatherEvent` from the SNS event.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从SNS事件中反序列化 `WeatherEvent`。
- en: Log the `WeatherEvent` (we’ll look more at logging in [Chapter 7](ch07.html#ch07)).
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记录 `WeatherEvent` 的日志（我们将在[第7章](ch07.html#ch07)更详细地讨论日志记录）。
- en: This time there are no references to SDKs because the input event included all
    the data we cared about.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这次没有提及SDK，因为输入事件包含了我们关心的所有数据。
- en: Build and Package Using Multiple Modules and Isolated Artifacts
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用多模块和隔离的构建和打包
- en: With all of the code written, it’s time to build and package our application.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 所有代码编写完毕，现在是构建和打包我们的应用程序的时候了。
- en: From a process point of view, nothing is different with this example from what
    we’ve covered before—we’ll run `mvn package` before running `sam deploy`.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 从流程角度来看，这个例子与我们之前覆盖的内容没有任何不同——我们将在运行 `sam deploy` 之前运行 `mvn package`。
- en: However, there’s a big structural difference to this example—we create separate
    ZIP file artifacts for each Lambda function. Each ZIP file includes the classes
    for only one Lambda handler and the library dependencies it needs.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，这个例子有一个重要的结构性差异——我们为每个Lambda函数创建单独的ZIP文件构件。每个ZIP文件仅包括一个Lambda处理程序的类及其所需的库依赖关系。
- en: 'While doing this for an application of this size is somewhat unnecessary, as
    your applications get bigger, it’s valuable to consider breaking up the artifacts
    for a few reasons:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然对于这样大小的应用程序来说做这些有些不必要，但随着你的应用程序变得更大，考虑分解构件是有价值的几个原因：
- en: Cold start time will be reduced (we’ll talk more about cold starts in [“Cold
    Starts”](ch08.html#cold-starts)).
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 冷启动时间将会缩短（我们将在[“冷启动”](ch08.html#cold-starts)中详细讨论冷启动）。
- en: Deployment time from local machines will typically be reduced since only the
    artifacts relating to changed functions will be uploaded for each deployment,
    assuming the use of the reproducible build plug-in we covered in [Chapter 4](ch04.html#ch04)
    ([“Reproducible Builds”](ch04.html#reproducible-builds)).
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于每次部署只上传与更改函数相关的工件（假设使用我们在[第四章](ch04.html#ch04)中介绍的可复制构建插件），因此从本地机器部署的时间通常会减少。
- en: You may need to do so to avoid Lambda’s artifact size limitation.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了避免Lambda的工件大小限制，您可能需要这样做。
- en: The final point relates to the 250MB size limit of (uncompressed) function artifacts
    in Lambda. If you have 10 Lambda functions, all with different dependencies, and
    their combined (uncompressed) artifact size is more than 250MB, you’ll need to
    break up your artifact for each function to make deployment even possible.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一点涉及Lambda中（未压缩）函数工件的250MB大小限制。如果您有10个Lambda函数，每个函数都有不同的依赖关系，并且它们的组合（未压缩）工件大小超过250MB，那么您需要为每个函数分割工件，以确保可以进行部署。
- en: So how do we implement this?
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们该如何实现这一点呢？
- en: One way to think about it is that we’re effectively building a very small [monorepo](https://oreil.ly/p8jk_)
    for our serverless application. You can think of it, perhaps, as a “serverless
    application MiniMono.” Regular monorepos consist of multiple projects in one repo;
    our MiniMono will consist of multiple Maven modules in one Maven project. While
    Maven has its shortcomings, it does work very well as a way of declaring dependencies
    between multiple components, and their dependencies on external libraries. And
    IntelliJ does a great job of interpreting multimodule Maven projects.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 一种思考方法是，我们实际上正在为我们的无服务器应用程序构建一个非常小的[单库](https://oreil.ly/p8jk_)。也许你可以将它想象成一个“无服务器应用程序MiniMono”。常规的单库包含一个仓库中的多个项目；我们的MiniMono将包含一个Maven项目中的多个Maven模块。尽管Maven有其缺点，但作为声明多个组件之间的依赖关系及其对外部库依赖的方式，它确实表现得非常好。而IntelliJ在解析多模块Maven项目方面表现得非常出色。
- en: Getting multimodule Maven projects working correctly is a little fiddly, so
    we’ll go step-by-step through it here. We strongly recommend that you download
    the sample code and open it up in IntelliJ, since it’s likely to make more sense
    to you that way.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 正确配置多模块Maven项目有点繁琐，因此我们将在此逐步进行。我们强烈建议您下载示例代码并在IntelliJ中打开它，因为这样更容易理解。
- en: The top-level project
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 顶层项目
- en: Our top-level *pom.xml* file is going to look a little like [Example 5-10](#EX5-10).
    We’ve cut out some of it to give clarity to the explanation.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的顶层*pom.xml*文件将类似于[示例5-10](#EX5-10)。我们已经剪切了一些内容以清楚解释。
- en: Example 5-10\. Parent project pom.xml for data pipeline app
  id: totrans-295
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例5-10。数据管道应用程序的父项目pom.xml
- en: '[PRE28]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'There are a few takeaways here:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几个要点：
- en: We add the `<packaging>pom</packaging>` tag at the top level—this is declaring
    that this is a multimodule project.
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在顶层添加了`<packaging>pom</packaging>`标签——这表明这是一个多模块项目。
- en: We include the list of modules in the `<modules>` section.
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在`<modules>`部分包含模块列表。
- en: Note that we don’t declare any inter-module dependencies at this point.
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意，此时我们并不声明任何模块间的依赖关系。
- en: All of our external dependencies (not just the AWS SDK BOM) move into the `<dependencyManagement>`
    section. It makes life easier to declare all the dependencies across the entire
    project here, and it guarantees that dependency versions are common across the
    whole project, but you don’t have too.
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有我们的外部依赖项（不仅仅是AWS SDK BOM）都移到了`<dependencyManagement>`部分。在此声明整个项目中的所有依赖关系会让生活更轻松，并且保证依赖版本在整个项目中是统一的，但您也不必这样做。
- en: We’ll see in a moment that modules will declare which of these external dependencies
    they need.
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们很快就会看到，模块将声明它们需要哪些外部依赖关系。
- en: Notice that we’ve still got the AWS SDK BOM that we talked about in the first
    example. We move our build plug-in definitions into a `<pluginManagement>` section
    so that they can be used by the modules.
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请注意，我们仍然有我们在第一个示例中讨论过的AWS SDK BOM。我们将构建插件定义移动到`<pluginManagement>`部分，以便模块可以使用它们。
- en: The configuration for the assembly plug-in remains at *src/assembly/lambda-zip.xml*,
    or you can use the version we’ve created for you in Maven Central.
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组装插件的配置仍然在*src/assembly/lambda-zip.xml*中，或者您可以使用我们在Maven Central为您创建的版本。
- en: There’s a whole bunch of other “Maven magic” detail here that we won’t go into!
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里有很多其他“Maven魔法”的细节我们就不深入讨论了！
- en: With our top-level project in place, we can now create our modules.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 有了我们的顶层项目，现在我们可以创建我们的模块了。
- en: The modules
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 这些模块
- en: We create one subdirectory for each module, named the same as each element of
    the module list in the project *pom.xml*.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为每个模块创建一个子目录，其名称与项目 *pom.xml* 中模块列表的各元素相同。
- en: Within each module subdirectory we create a new *pom.xml*. We’ll start with
    the most simple one for *common-code*, which allows us to write code that is shared
    by both Lambda artifacts. In our example, it contains the `WeatherEvent` class.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个模块子目录中，我们创建一个新的 *pom.xml*。我们从 *common-code* 开始，这让我们可以编写被 Lambda 构件共享的代码。在我们的示例中，它包含
    `WeatherEvent` 类。
- en: Again, all of these Maven examples are slightly trimmed, so please refer to
    the book source code for the complete versions.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，所有这些 Maven 示例都稍作裁剪，请查看书籍源代码获取完整版本。
- en: Example 5-11\. Module pom.xml for common-code
  id: totrans-311
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-11\. *common-code* 的模块 pom.xml
- en: '[PRE29]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We declare our parent, our module’s `artifactId` (which for the sake of sanity
    should be the same as the module name), and then we declare which build plug-ins
    we want to use. For this module we’re just creating a regular JAR file, of just
    the code in the module itself. That means we don’t need to assemble a ZIP file,
    but we do still want to make use of the reproducible build plug-in. The configuration
    for the plug-in comes from our definition in the `<pluginManagement>` section
    of the parent bom.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明我们的父级，我们模块的 `artifactId`（为了明智起见，应与模块名称相同），然后我们声明要使用的构建插件。对于这个模块，我们只创建一个常规的
    JAR 文件，只包含模块本身的代码。这意味着我们不需要组装 ZIP 文件，但我们仍然希望利用可重复生成的构建插件。插件的配置来自父 bom 中 `<pluginManagement>`
    部分的定义。
- en: Notice that there’s no `<dependencies>` section because this module doesn’t
    have any dependencies at this time.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于此模块目前没有任何依赖项，因此没有 `<dependencies>` 部分。
- en: Next, in the *bulk-events-stage* subdirectory we create the *pom.xml* as shown
    in [Example 5-12](#EX5-12).
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 *bulk-events-stage* 子目录中，我们按照 [示例 5-12](#EX5-12) 中所示创建 *pom.xml*。
- en: Example 5-12\. Module pom.xml for bulk-events-stage
  id: totrans-316
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-12\. *bulk-events-stage* 的模块 pom.xml
- en: '[PRE30]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `<parent>` section is the same as for *common-code*, and `<artifactId>`
    follows the same rule as before.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '`<parent>` 部分与 *common-code* 相同，`<artifactId>` 遵循之前的规则。'
- en: This time we do have dependencies. The first one is how we declare an inter-module
    dependency, in this case to the *common-code* module. Notice that we pick up the
    version from the parent module. Then we declare all of our external dependencies.
    Notice that there aren’t any versions for these—the versions come from the `<dependency-management>`
    section in the parent *pom.xml* (or, transitively, from the AWS SDK BOM).
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们确实有依赖项。第一个是我们如何声明一个模块间的依赖，本例中是对 *common-code* 模块的依赖。请注意，我们从父模块中获取版本。然后我们声明所有外部依赖项。请注意，这些依赖项没有版本号—版本号来自父
    *pom.xml* 中的 `<dependency-management>` 部分（或者从 AWS SDK BOM 中传递获取）。
- en: And finally in the `<build>` section we declare our build plug-ins. This time
    we need to create a ZIP file (which will be the ZIP file just for the `BulkEventsLambda`
    function), and so we include a reference to `maven-assembly-plugin`. Again, the
    configuration for the plug-in is defined in the parent *pom.xml*.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在 `<build>` 部分中，我们声明我们的构建插件。这次我们需要创建一个 ZIP 文件（这将是仅用于 `BulkEventsLambda` 函数的
    ZIP 文件），因此我们包含对 `maven-assembly-plugin` 的引用。再次强调，插件的配置在父 *pom.xml* 中定义。
- en: The *single-event-stage* *pom.xml* looks almost the same as the *bulk-events-stage*
    *pom.xml*, but with fewer dependencies.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '*single-event-stage* *pom.xml* 看起来几乎与 *bulk-events-stage* *pom.xml* 相同，但依赖项较少。'
- en: 'With the Maven POM files complete, we then create *src* directories within
    each module. The end result of our project directory tree looks as follows:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: Maven POM 文件完成后，我们在每个模块中创建 *src* 目录。项目目录树的最终结果如下所示：
- en: '[PRE31]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Running `mvn package` for this multimodule project will create separate *lambda.zip*
    files in each of the two Lambda module directories.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `mvn package` 以创建此多模块项目中每个 Lambda 模块目录中的单独 *lambda.zip* 文件。
- en: Since we have parallel modules that don’t depend on each other we can actually
    tune our use of Maven a little to increase build performance. Running `mvn package
    -T 1C` will make Maven use multiple OS threads, one per core of your machine,
    when it can.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们有互不依赖的并行模块，实际上我们可以微调 Maven 的使用以增加构建性能。运行 `mvn package -T 1C` 将使 Maven 在可以时使用多个操作系统线程，每个核心一个。
- en: Infrastructure
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基础设施
- en: Despite the significant change in the structure of our Java project, our SAM
    template doesn’t change all that much. Let’s look at how it does change, plus
    the other AWS resources that we use in [Example 5-13](#EX5-13).
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们的Java项目结构发生了显著变化，但我们的SAM模板并没有变化很多。让我们看看它是如何变化的，以及我们在[示例 5-13](#EX5-13)中使用的其他AWS资源。
- en: Example 5-13\. SAM template for data pipeline
  id: totrans-328
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-13\. 数据流水线的SAM模板
- en: '[PRE32]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: First, while it’s still fresh in our minds, let’s look at the differences caused
    by the multimodule Maven project. They are solely the updates to the `CodeUri`
    properties on the Lambda functions—where we used to have the same `target/lambda.zip`
    value for both functions in the API example, it’s now `bulk-events-stage/target/lambda.zip`
    for `BulkEventsLambda`, and `single-event-stage/target/lambda.zip` for the `SingleEventLambda`.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在我们的记忆中仍然清晰时，让我们看看多模块Maven项目引起的差异。唯一的更新是Lambda函数的`CodeUri`属性——在API示例中，我们曾经对两个函数都使用相同的`target/lambda.zip`值，现在对于`BulkEventsLambda`是`bulk-events-stage/target/lambda.zip`，对于`SingleEventLambda`是`single-event-stage/target/lambda.zip`。
- en: OK, now let’s go back to the top.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，现在让我们回到顶部。
- en: The `Globals` section is a little smaller this time. That’s because there are
    no shared environment variables across the Lambda functions, and we don’t need
    any API configuration.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '`Globals`部分这次稍微小了些。这是因为Lambda函数之间没有共享的环境变量，而且我们也不需要任何API配置。'
- en: Under `Resources`, first we declare our S3 bucket. There are a whole lot of
    properties you can add here—access control–related properties are particularly
    popular. One thing we typically like to add is server-side encryption as well
    as lifecycle policies. But here we keep it to the defaults. One thing that’s here
    is an explicitly declared name. Normally we wouldn’t want to do this, and instead
    have CloudFormation generate a unique name for us, but due to an annoying aspect
    of CloudFormation’s S3 resource, if we don’t declare a name, then we get a circular
    dependency with some of the other elements of the file.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Resources`下，首先声明了我们的S3存储桶。您可以在这里添加很多属性——与访问控制相关的属性尤其受欢迎。我们通常喜欢添加的一件事是服务器端加密以及生命周期策略。但在这里，我们保持默认设置。这里有一件事是显式声明的名称。通常情况下，我们不希望这样做，而是让CloudFormation为我们生成一个唯一的名称，但由于CloudFormation的S3资源的一个恼人的特性，如果我们不声明一个名称，那么我们将与文件的一些其他元素产生循环依赖。
- en: S3 bucket names have to be globally unique across all AWS regions and accounts.
    If you create a bucket named *sheep* in the us-east-1 region, then you can’t also
    create another one named *sheep* in us-west-2 (unless you first delete the one
    in us-east-1), and I can’t create a bucket named “sheep” at all. This means that
    when you create a bucket name explicitly via an automated tool like CloudFormation,
    you need to include various context-unique aspects to avoid a naming collision.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: S3存储桶名称在所有AWS区域和账户中必须是全局唯一的。如果您在us-east-1区域创建一个名为*sheep*的存储桶，那么您不能在us-west-2中再创建另一个名为*sheep*的存储桶（除非您首先删除us-east-1中的存储桶），并且我根本无法创建名为“sheep”的存储桶。这意味着当您通过像CloudFormation这样的自动化工具显式创建存储桶名称时，您需要包含各种上下文唯一的方面，以避免命名冲突。
- en: 'For example, we use the following declared bucket name:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们使用以下声明的存储桶名称：
- en: '[PRE33]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: There’s some CloudFormation smarts happening here, so let’s unpack that a little.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 这里涉及一些CloudFormation的智能操作，所以让我们来详细解析一下。
- en: First of all `!Sub` is another [*intrinsic function*](https://oreil.ly/NaRtL),
    just like `!Ref` in the first example. `!Sub` substitutes variables in a string.
    Often you will use variables you declare yourself in template parameters, but
    in this case we are using CloudFormation [*pseudo parameters*](https://oreil.ly/LUtMC)—variables
    that CloudFormation defines on our behalf. Say I created a stack named *my-stack*,
    our account ID was 123456, and we had created the stack in us-west-2, then the
    bucket name in this stack would be *my-stack-123456-us-west-2-start*.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`!Sub`是另一个[*内部函数*](https://oreil.ly/NaRtL)，就像第一个示例中的`!Ref`一样。`!Sub`用于替换字符串中的变量。通常您会使用模板参数中声明的变量，但在这种情况下，我们使用CloudFormation的[*伪参数*](https://oreil.ly/LUtMC)——由CloudFormation代表我们定义的变量。假设我创建了一个名为*my-stack*的堆栈，我们的账户ID是123456，并且我们在us-west-2中创建了该堆栈，那么该堆栈中的存储桶名称将是*my-stack-123456-us-west-2-start*。
- en: The next resource is our SNS Topic. Look—no properties! SNS is partly configurable,
    but it’s also super simple to use with no configuration at all.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个资源是我们的SNS主题。看——没有属性！SNS部分可配置，但也可以完全不配置就使用。
- en: And then we have our two Lambda functions.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们有我们的两个Lambda函数。
- en: '`BulkEventsLambda` has an environment variable referring to the Amazon Resource
    Name (ARN) of the SNS topic. The [SNS Topic CloudFormation documentation](https://oreil.ly/r6oVW)
    tells us that calling `!Ref` on a Topic resource returns its ARN.'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '`BulkEventsLambda` 具有一个环境变量，引用了 SNS 主题的 Amazon 资源名称 (ARN)。[SNS 主题 CloudFormation
    文档](https://oreil.ly/r6oVW) 告诉我们，在 Topic 资源上调用 `!Ref` 返回其 ARN。'
- en: For the security side of this Lambda we both need to read from the S3 bucket—which
    we refer to with the same name as we used when declaring the bucket in the first
    place—and we need to write (or publish) to the SNS topic. For the SNS topic, the
    security policy doesn’t need the ARN (which is what is returned when we call `!Ref`
    on the Topic resource); it needs the Topic’s name. To get that, we use a third
    intrinsic function—`!GetAtt`. `!GetAtt` allows us to read secondary return values
    from a CloudFormation resource. Again, when looking at the SNS documentation,
    we can see that the name is returned when asking for `TopicName`, hence the value
    `!GetAtt FanOutTopic.TopicName`.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个 Lambda 函数的安全性，我们需要从 S3 存储桶中读取数据（我们在首次声明存储桶时使用相同的名称），并且我们需要写入（或发布）到 SNS
    主题。对于 SNS 主题，安全策略不需要 ARN（这是当我们在主题资源上调用 `!Ref` 时返回的内容），它需要主题的名称。为了获得该名称，我们使用第三个内置函数
    `!GetAtt`。`!GetAtt` 允许我们从 CloudFormation 资源中读取次要返回值。同样地，在查看 SNS 文档时，我们可以看到在请求
    `TopicName` 时返回的名称，因此值为 `!GetAtt FanOutTopic.TopicName`。
- en: Finally, for `BulkEventsLambda` we need to declare the event source. This is
    the S3 bucket, and we declare the type of S3 events we care about in the `Events`
    fields. You can be much more prescriptive here if you like, for example including
    filter patterns to only trigger events for certain S3 keys.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于 `BulkEventsLambda`，我们需要声明事件源。这是 S3 存储桶，并且我们在 `Events` 字段中声明我们关心的 S3 事件类型。如果您愿意，您可以在这里进行更详细的描述，例如包括过滤模式，以仅触发特定
    S3 键的事件。
- en: As you’d expect, `SingleEventLambda` is simpler since it doesn’t call any AWS
    resources. For this function, we just need to declare the event source, which
    is the SNS Topic, referred to by the Topic’s ARN.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所预期的那样，`SingleEventLambda` 更简单，因为它不调用任何 AWS 资源。对于这个函数，我们只需要声明事件源，即 SNS 主题，它通过主题的
    ARN 引用。
- en: Deployment
  id: totrans-345
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署
- en: Deployment is similar to what you’ve seen before. Again, we’re using the principles
    of a serverless application in that we collectively deploy all of the components
    together.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 部署类似于您之前看到的内容。再次，我们使用无服务器应用程序的原则，将所有组件集体部署。
- en: 'There’s one small change for deploying this app. Because we’re using the stack
    name in the manually defined S3 bucket name, we have to use only lowercase letters
    in the stack name (because S3 buckets can’t be named with uppercase letters):'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 部署此应用程序有一个小的更改。因为我们在手动定义的 S3 存储桶名称中使用了堆栈名称，所以必须仅使用小写字母（因为 S3 存储桶不能以大写字母命名）：
- en: '[PRE34]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Once the application is deployed, you can explore the deployed components via
    the Lambda Applications console, or the CloudFormation console. [Figure 5-11](#data-pipeline-appview)
    shows what it looks like in Lambda applications.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序部署后，您可以通过 Lambda 应用程序控制台或 CloudFormation 控制台探索已部署的组件。[图 5-11](#data-pipeline-appview)
    展示了 Lambda 应用程序中的外观。
- en: '![images/ch05_image11.png](assets/awsl_0511.png)'
  id: totrans-350
  prefs: []
  type: TYPE_IMG
  zh: '![images/ch05_image11.png](assets/awsl_0511.png)'
- en: Figure 5-11\. Serverless Application view for data pipeline
  id: totrans-351
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-11\. 数据管道的无服务器应用程序视图
- en: Clicking the resources will take you through to their own parts of the AWS Console.
    To test this application, we need to upload a file to S3\. One option is to do
    that manually through the web console.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 单击资源将带您进入 AWS 控制台的各自部分。要测试此应用程序，我们需要将文件上传到 S3。其中一种选项是通过 Web 控制台手动执行此操作。
- en: A more automated approach is as follows.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更加自动化的方法如下所示。
- en: 'First, query CloudFormation to get the name of the S3 bucket, and assign that
    to a shell variable:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，查询 CloudFormation 获取 S3 存储桶的名称，并将其分配给一个 shell 变量：
- en: '[PRE35]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now use the AWS CLI to upload the sample file:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 现在使用 AWS CLI 来上传示例文件：
- en: '[PRE36]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Now look at the logs for the `SingleEventLambda` function, and you’ll see, after
    a few seconds, each of the weather events separately logged.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 现在查看 `SingleEventLambda` 函数的日志，您会看到，几秒钟后，每个天气事件都将分别记录。
- en: Congratulations—you’ve built your second serverless application!
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您已经构建了第二个无服务器应用程序！
- en: As you can imagine, with the vast number of services available on AWS, the different
    types of serverless application that can be built are innumerable. And that’s
    before we even consider the perfectly valid capability of calling services outside
    of AWS from Lambda!
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，通过AWS提供的大量服务，可以构建无数种不同类型的无服务器应用程序。而且，这还没有考虑到从Lambda调用AWS之外的服务的完全有效能力！
- en: We hope that this chapter has given you a taste of what’s possible. The ability
    to deploy complete, multicomponent, applications with just a few text files, in
    minutes or seconds, and then tear them down again, makes for an extraordinarily
    valuable “application sandbox” environment that can also scale to real production
    use.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望本章为您展示了可能性。仅凭几个文本文件，几分钟或几秒钟就能部署完整的、多组件的应用程序，然后再将其拆除，这构建了一个非常有价值的“应用程序沙盒”环境，也能扩展到真正的生产使用。
- en: Summary
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We started this chapter by looking at how to trigger Lambda functions from other
    AWS services. Understanding this is an important first step to embracing serverless
    architecture.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从学习如何从其他AWS服务触发Lambda函数开始本章。理解这一点是接受无服务器架构的重要第一步。
- en: We then explored two example serverless applications—wholly contained groups
    of AWS resources that can be collectively deployed. The first example was a database-backed
    HTTP API, using two synchronously invoked Lambda functions, along with the AWS
    services API Gateway and DynamoDB.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，我们探讨了两个示例无服务器应用程序——完全包含的AWS资源组。第一个例子是一个基于数据库的HTTP API，使用了两个同步调用的Lambda函数，以及AWS服务API
    Gateway和DynamoDB。
- en: The second example was a serverless data pipeline consisting of two asynchronous
    processing stages, including a fan-out design. This example used Lambda, S3, and
    SNS. In this example, we also explored using multimodule Maven projects to create
    a “serverless application MiniMono.”
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个例子是一个由两个异步处理阶段组成的无服务器数据流水线，包括扇出设计。这个例子使用了Lambda、S3和SNS。在这个例子中，我们还探讨了使用多模块Maven项目创建“无服务器应用MiniMono”的方法。
- en: 'You now have a framework for building serverless AWS applications:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已经掌握了构建无服务器AWS应用程序的框架：
- en: Identify the *behavior* you want your application to have.
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定您希望您的应用程序具有的*行为*。
- en: Design the *architecture* of your application by choosing which services will
    implement the different aspects of your system, and how those services will interact.
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择哪些服务来实现系统的不同方面，并定义这些服务之间的交互，设计您应用程序的*架构*。
- en: 'Program *Lambda code* to:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写*Lambda代码*来：
- en: Consume the correct event types.
  id: totrans-370
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理正确的事件类型。
- en: Perform the necessary side effects on downstream services.
  id: totrans-371
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在下游服务上执行必要的副作用。
- en: Where relevant, return the correct response.
  id: totrans-372
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在相关情况下，返回正确的响应。
- en: Configure your *infrastructure* using a CloudFormation/SAM template.
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用CloudFormation/SAM模板配置您的*基础设施*。
- en: Execute *deployment* using the correct AWS tooling.
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用正确的AWS工具进行*部署*。
- en: So far all of our testing has been very manual. How can we do better, using
    automated testing techniques? That’s what we explore in the next chapter.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所有的测试都是非常手动的。我们如何利用自动化测试技术来做得更好？这是我们在下一章中要探讨的内容。
- en: Exercises
  id: totrans-376
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'Another great event source for “getting started” with Lambda is CloudWatch
    Scheduled Events, which we can use to build “serverless cron jobs.” We describe
    this use of Lambda in [“Example: Lambda “cron jobs””](ch09.html#lambda-cron-jobs).
    Build a Lambda function that will run every minute, and for now that just writes
    out a log statement when it’s called. See the [SAM documentation](https://oreil.ly/C_FhY)
    on how to set up this trigger.'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一个很好的Lambda“入门”事件源是CloudWatch定时事件，我们可以使用它来构建“无服务器定时任务”。我们在[“示例：Lambda‘定时任务’”](ch09.html#lambda-cron-jobs)中描述了Lambda的这种使用方式。建立一个Lambda函数，每分钟运行一次，并且暂时只在调用时写出一个日志声明。请参阅[SAM文档](https://oreil.ly/C_FhY)了解如何设置此触发器。
- en: Update your scheduled event Lambda from the previous exercise to post a message
    to SNS, similar to how we did so in `BulkEventsLambda` earlier in this chapter.
    Update your SNS topic to send an SMS, or text, message to your mobile phone (see
    the [AWS documentation](https://oreil.ly/TrQct) on how to do this).
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新上一个练习中的定时事件Lambda，以将消息发布到SNS，类似于本章前面所做的`BulkEventsLambda`。更新您的SNS主题，以向您的手机发送SMS或文本消息（请参阅[AWS文档](https://oreil.ly/TrQct)以了解如何操作）。
- en: Reimplement the data pipeline example from this chapter to use an SQS queue,
    rather than an SNS topic, between the two Lambdas. A couple of good starting places
    to help with this are [here](https://oreil.ly/LKekx) and [here](https://oreil.ly/Cbvb3)
    in the Lambda documentation.
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新实现本章的数据管道示例，使用 SQS 队列而不是 SNS 主题，在两个 Lambda 之间传递消息。关于此，可以参考 Lambda 文档中的 [这里](https://oreil.ly/LKekx)
    和 [这里](https://oreil.ly/Cbvb3)。
