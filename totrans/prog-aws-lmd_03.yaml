- en: Chapter 3\. Programming AWS Lambda Functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章\. 编程AWS Lambda函数
- en: This chapter is about digging into what it means to build Lambda functions—what
    do they look like, how do you configure how they run, and how do you specify your
    own environmental configuration. You’ll learn about these topics by examining
    core concepts for Lambda execution environments, input and output, timeout, memory
    and CPU, and finally, how Lambda uses environment variables for application configuration.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章内容涉及构建Lambda函数的含义—它们是什么样子的，如何配置它们的运行方式，以及如何指定自己的环境配置。通过检查Lambda执行环境的核心概念、输入和输出、超时、内存和CPU，最后，Lambda如何使用环境变量进行应用程序配置来学习这些主题。
- en: To start, let’s take a look at how Lambda functions are executed. Grab your
    hiking boots—it’s time to explore.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看Lambda函数是如何执行的。系好您的登山靴—是时候探索一番了。
- en: 'Core Concepts: Runtime Model, Invocation'
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 核心概念：运行时模型、调用
- en: In [Chapter 2](ch02.html#ch02), you created a Java class, uploaded it to the
    Lambda service somewhere in the nebulous “cloud,” and magically were able to execute
    that code. You didn’t have to consider operating systems, containers, startup
    scripts, deployment of the code to an actual host, or JVM settings. Nor did you
    think about any of those pesky “servers.” So how did your code execute?
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第二章](ch02.html#ch02)中，您创建了一个Java类，将其上传到某个位于“云”中的Lambda服务，并神奇地能够执行该代码。您不必考虑操作系统、容器、启动脚本、代码部署到实际主机或JVM设置。也不必考虑那些讨厌的“服务器”。那么您的代码是如何执行的呢？
- en: To understand this, you need to first understand the basics of the Lambda execution
    environment, as shown in [Figure 3-1](#lambda-execution-environment).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解这一点，您首先需要了解Lambda执行环境的基础知识，如[图3-1](#lambda-execution-environment)所示。
- en: '![images/ch03_image01.png](assets/awsl_0301.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![images/ch03_image01.png](assets/awsl_0301.png)'
- en: Figure 3-1\. The Lambda execution environment
  id: totrans-7
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3-1\. Lambda执行环境
- en: The Lambda Execution Environment
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Lambda执行环境
- en: As we mentioned in [Chapter 2](ch02.html#ch02) (see [“Installing the AWS CLI”](ch02.html#installing_the_aws_cli)),
    both AWS management and function operations (often referred to as the *control
    plane* and *data plane*, respectively) make extensive use of APIs. Lambda is no
    different and offers an API both for management of functions and for execution
    of functions.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第二章](ch02.html#ch02)中提到的（参见[“安装AWS CLI”](ch02.html#installing_the_aws_cli)），AWS的管理和函数操作（通常称为*控制平面*和*数据平面*）都广泛使用API。Lambda也不例外，为函数的管理和执行提供API。
- en: 'A function is executed, or *invoked*, whenever the `invoke` command of the
    AWS Lambda API is called. This happens at the following times:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 每当调用AWS Lambda API的`invoke`命令时，函数都会被执行或*调用*。这发生在以下时间：
- en: When a function is triggered by an event source
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当函数由事件源触发时
- en: When you use the test harness in the web console
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您在Web控制台中使用测试工具包时
- en: When you call the Lambda API `invoke` command yourself, typically via the CLI
    or SDK, from your own code or scripts
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您自己调用Lambda API的`invoke`命令时，通常通过CLI或SDK，从您自己的代码或脚本中。
- en: Invoking a function for the first time will start the following chain of activity
    that will end in your code being executed.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 首次调用函数将启动以下一系列活动链，最终导致您的代码被执行。
- en: First, the Lambda service will create a host Linux environment—a lightweight
    micro-virtual machine. You typically won’t need to worry about the precise nature
    of what type of environment it is (which kernel, what distribution, etc.), but
    if you do care, Amazon makes that information public. But don’t rely on it staying
    constant—Amazon can and does make frequent changes to the OS of Lambda functions,
    often for your own benefit, including automatic security patches.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，Lambda服务将创建一个主机Linux环境—一个轻量级微虚拟机。通常您不需要担心它究竟是何种环境（什么内核，什么发行版等），但如果您关心，亚马逊会公布这些信息。但不要依赖它保持不变—亚马逊可能会频繁更改Lambda函数的操作系统，通常是为了您自己的利益，包括自动安全补丁。
- en: Once the host environment has been created, then Lambda will start a language
    runtime within it—in our case a Java virtual machine. At the time of this writing,
    the JVM version will always be Java 8 or Java 11. You must supply Lambda with
    code compatible with the version of Java that you choose. The JVM is started with
    a set of environment flags that we can’t change.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦主机环境被创建，Lambda将在其中启动语言运行时—在我们的例子中是Java虚拟机。在撰写本文时，JVM版本将始终为Java 8或Java 11。您必须提供与您选择的Java版本兼容的代码给Lambda。JVM是以一组环境标志启动的，我们无法更改。
- en: You may have noticed when we wrote our code that there was no “main” method—the
    top-level Java application is Amazon’s own Java application server, which we’ll
    refer to as the *Lambda Java Runtime*; that’s the next component to be started.
    The runtime is responsible for top-level error handling, logging, and more.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写代码时，您可能已经注意到没有“main”方法——顶级 Java 应用程序是亚马逊自己的 Java 应用程序服务器，我们将其称为 *Lambda
    Java 运行时*；这是下一个要启动的组件。运行时负责顶级错误处理、日志记录等。
- en: Of course, the Lambda Java Runtime’s primary concern is executing our code.
    The final steps of the invocation chain are (a) to load our Java classes and (b)
    to call the handler method that we specified during deployment.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，Lambda Java 运行时的主要任务是执行我们的代码。调用链的最后几步是：（a）加载我们的 Java 类，并（b）调用我们在部署过程中指定的处理方法。
- en: Invocation Types
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调用类型
- en: Great—our code is alive! What happens next?
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 很好——我们的代码已经运行！接下来会发生什么？
- en: 'To explore this, let’s start using the AWS CLI. In [Chapter 2](ch02.html#ch02)
    we used the higher-level SAM CLI tool—the AWS CLI is a little closer to the guts
    of the AWS machine. Specifically, we’re going to use a command in the AWS CLI
    for calling Lambda functions: `aws lambda invoke`.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了探索这个问题，让我们开始使用 AWS CLI。在 [第二章](ch02.html#ch02) 中，我们使用了更高级别的 SAM CLI 工具——AWS
    CLI 更接近 AWS 机器的内部。具体来说，我们将使用 AWS CLI 中用于调用 Lambda 函数的命令：`aws lambda invoke`。
- en: 'Assuming you ran the examples in [Chapter 2](ch02.html#ch02), let’s start with
    a small update. Open the *template.yaml* file (which we’ll refer to as the *SAM
    template* occasionally from now on), and within the properties section, add a
    new property named `FunctionName` with the value `HelloWorldJava` so that the
    resource section looks as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您在 [第二章](ch02.html#ch02) 中运行了示例，让我们从一个小更新开始。打开 *template.yaml* 文件（我们将从现在开始偶尔称为
    *SAM 模板*），在属性部分中添加一个名为 `FunctionName` 的新属性，值为 `HelloWorldJava`，以使资源部分如下所示：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Run the **`sam deploy`** command from [Chapter 2](ch02.html#ch02) again. This
    should complete after a couple of minutes. If you go back to the Lambda console,
    you’ll see your strangely named Java function has now been renamed to `HelloWorldJava`.
    In most real-use cases, we like using the generated names that AWS provides, but
    when we’re learning about Lambda, it’s nice to be able to refer to functions with
    more succinct names.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 重新从 [第二章](ch02.html#ch02) 运行 **`sam deploy`** 命令。几分钟后应该完成。如果回到 Lambda 控制台，你会看到你的奇怪命名的
    Java 函数现在已经重命名为 `HelloWorldJava`。在大多数实际用例中，我们喜欢使用 AWS 提供的生成名称，但当我们学习 Lambda 时，能够引用更简洁名称的函数会更好。
- en: Note
  id: totrans-25
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: To use the Java 11 runtime instead of Java 8, simply change the `Runtime:` property
    in your SAM template from `java8` to `java11`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Java 11 运行时而不是 Java 8，只需在 SAM 模板中将 `Runtime:` 属性从 `java8` 更改为 `java11`。
- en: 'Let’s get back to invocation. From the terminal, run the following command:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到调用。从终端运行以下命令：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This should return the following:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该返回以下内容：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You can tell that everything was OK because `StatusCode` was `200`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过 `StatusCode` 是 `200` 来确认一切正常。
- en: 'You can also see what the Lambda function returned by executing the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 通过执行以下命令，还可以查看 Lambda 函数返回的内容：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When we executed the `invoke` command, the Lambda function was first instantiated,
    as we described in the previous section. With instantiation complete, the Lambda
    Java Runtime, itself within the JVM, then called our Lambda function with the
    data that we passed in the `payload` parameter—in this case the string `"world"`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行 `invoke` 命令时，Lambda 函数首先被实例化，正如我们在前一节中描述的那样。实例化完成后，Lambda Java 运行时在 JVM
    内部调用我们的 Lambda 函数，使用我们传递给 `payload` 参数的数据——在本例中是字符串 `"world"`。
- en: 'Our code then ran. As a reminder, here it is:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码然后运行。作为提醒，这里是代码：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: It takes our input (`"world"`), and returns `"Hello, world"`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 它接受我们的输入（`"world"`），并返回 `"Hello, world"`。
- en: There’s an important but subtle point here. When we called `invoke`, we specified
    `--invocation-type RequestResponse`—this means that we are calling the function
    *synchronously* (i.e., the Lambda runtime calls our code and waits for the result).
    We explained this in [“What Does a Lambda Application Look Like?”](ch01.html#what_does_a_lambda_application_look_like).
    *Synchronous behavior* is useful for scenarios like web APIs.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个重要但微妙的点。当我们调用 `invoke` 时，我们指定了 `--invocation-type RequestResponse`——这意味着我们
    *同步* 调用函数（即 Lambda 运行时调用我们的代码并等待结果）。我们在 [“Lambda 应用程序是什么样子？”](ch01.html#what_does_a_lambda_application_look_like)
    中解释了这一点。*同步行为* 对于像 Web API 这样的场景非常有用。
- en: Because we called the function synchronously, the Lambda runtime was able to
    return the response to our terminal, and this is what was saved to *outputfile.txt*.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们同步调用了函数，Lambda 运行时能够将响应返回给我们的终端，这就是保存到 *outputfile.txt* 的内容。
- en: 'Now let’s invoke the function slightly differently:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们稍微不同地调用函数：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Notice that we’ve changed the `--invocation-type` flag to `Event`. The result
    is now as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们已将 `--invocation-type` 标志更改为 `Event`。现在的结果如下所示：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`StatusCode` is `202`, not `200`. `202` means *Accepted* in HTTP terms. If
    you take a look at *outputfile.txt*, you’ll see that it’s empty.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`StatusCode` 是 `202`，而不是 `200`。在 HTTP 术语中，`202` 意味着*已接受*。如果您查看 *outputfile.txt*，您会发现它是空的。'
- en: This time we have called the function *asynchronously*. The Lambda runtime calls
    our code precisely as before, but it does not wait for, or use, the value returned
    by our code—that value returned by our code is discarded. The point of using asynchronous
    execution is that we can perform a “side effect” on some other function or service.
    In the asynchronous example in [“What Does a Lambda Application Look Like?”](ch01.html#what_does_a_lambda_application_look_like),
    the side effect was to upload a file to Amazon’s S3 service—a new, resized, version
    of a photo.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次我们以*异步*方式调用函数。Lambda 运行时像以前一样调用我们的代码，但它不等待或使用我们代码返回的值——该值会被丢弃。使用异步执行的关键在于我们可以对某些其他函数或服务执行“副作用”。在
    [“Lambda 应用程序是什么样子？”](ch01.html#what_does_a_lambda_application_look_like) 中的异步示例中，副作用是将照片的新调整大小版本上传到亚马逊的
    S3 服务中。
- en: As you start using Lambda, you’ll discover that most classes of Lambda function
    use asynchronous invocation, embracing the idea that Lambda is an *event-driven
    platform*. We’ll explore this further later in the book when we start examining
    [“Lambda Event Sources”](ch05.html#event-sources).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当您开始使用 Lambda 时，您会发现大多数 Lambda 函数类使用异步调用，支持 Lambda 是一个*事件驱动平台*的理念。我们将在本书稍后的章节中进一步探讨这一点，当我们开始研究
    [“Lambda 事件来源”](ch05.html#event-sources) 时。
- en: We used the same code in the previous two examples; however, if you know that
    your Lambda function will never be used synchronously, you don’t need to return
    a value—the method can have a `void` return type. Let’s see an example of that.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前两个示例中使用了相同的代码；然而，如果您知道您的 Lambda 函数永远不会被同步使用，则不需要返回值——该方法可以具有 `void` 返回类型。让我们看一个例子。
- en: 'First, change your function’s method to the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将函数的方法更改为以下内容：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Notice that we’ve changed the return type to `void` and are now writing a message
    to `System.out`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们已将返回类型更改为 `void`，并且现在正在向 `System.out` 写入消息。
- en: 'Now we need to rebuild and redeploy our code. To do this, run the same two
    commands you did in [Chapter 2](ch02.html#ch02):'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要重建和重新部署我们的代码。要做到这一点，请运行与 [第 2 章](ch02.html#ch02) 中相同的两个命令：
- en: '**`mvn package`**'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`mvn package`**'
- en: '**`sam deploy…`**'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`sam deploy…`**'
- en: where `**…**` refers to the same arguments you used before. You’re going to
    be running these commands often enough that you’ll probably want to put them in
    a script.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 `**…**` 指的是您之前使用的相同参数。您会经常运行这些命令，所以可能想把它们放入一个脚本中。
- en: 'Now invoke the code again with the `Event` invocation type, and you should
    receive another `"StatusCode": 202` response. But where does that message to `System.out`
    go? To understand that, we’ll take a quick look at logging.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '现在以 `Event` 调用类型再次调用代码，您应该会收到另一个 `"StatusCode": 202` 的响应。但是 `System.out` 中的消息去哪里了？要理解这一点，让我们快速看一下日志记录。'
- en: Note
  id: totrans-56
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You now know enough about the `mvn`, `sam`, and `aws` commands to run the remaining
    examples in this chapter. If you get into a weird state, go to *CloudFormation*
    in the AWS Web Console, delete the `HelloWorldLambdaJava` stack, and deploy again.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已经了解足够的关于 `mvn`、`sam` 和 `aws` 命令的知识，可以运行本章剩余的示例。如果出现异常情况，请转到 AWS Web 控制台中的
    *CloudFormation*，删除 `HelloWorldLambdaJava` 栈，然后重新部署。
- en: Introduction to Logging
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 日志简介
- en: The Lambda runtime captures anything written by our function to either the standard
    output or standard error process streams. In Java terms, these correspond to `System.out`
    and `System.err`. Once the Lambda runtime has caught this data, it sends it to
    CloudWatch Logs. If you’re new to AWS, this will need a little more explanation!
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 运行时捕获我们的函数写入的任何内容，无论是标准输出还是标准错误流。在 Java 中，这些对应于 `System.out` 和 `System.err`。一旦
    Lambda 运行时捕获到这些数据，它会将其发送到 CloudWatch Logs。如果您是 AWS 的新手，这需要更详细的解释！
- en: CloudWatch Logs consists of a few components. The principal one is a log capturing
    service. It’s cheap, dependable, easy to use and handles all the scale you can
    throw at it.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: CloudWatch Logs 由几个组件组成。其中主要的是日志捕获服务。它便宜、可靠、易于使用，并且可以处理您可能遇到的所有规模。
- en: Once CloudWatch Logs has captured log messages, there are a few ways that you
    can view or process them. The simplest way is to use the CloudWatch Logs log viewer
    in the AWS Web Console.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 CloudWatch Logs 捕获到日志消息，您有几种方法可以查看或处理它们。最简单的方法是使用 AWS Web 控制台中的 CloudWatch
    Logs 日志查看器。
- en: There are various ways to get to this, but for now open up your Lambda function’s
    page in the AWS Web Console (as we showed in [“Running the Lambda function”](ch02.html#running_the_lambda_function)).
    If you click the Monitoring tab of that page, you should be able to see a *View
    logs in CloudWatch* button—click that, as shown in [Figure 3-2](#accessing-lambda-logs).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以实现这一点，但现在请在 AWS Web 控制台中打开您 Lambda 函数页面（如我们在 [“运行 Lambda 函数”](ch02.html#running_the_lambda_function)
    中所示）。如果您点击该页面的监控选项卡，您应该能够看到一个 *在 CloudWatch 中查看日志* 按钮—点击它，如 [图 3-2](#accessing-lambda-logs)
    所示。
- en: '![images/ch03_image02.png](assets/awsl_0302.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![images/ch03_image02.png](assets/awsl_0302.png)'
- en: Figure 3-2\. Access Lambda logs
  id: totrans-64
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-2\. 访问 Lambda 日志
- en: What you’ll see next will depend a little on how the CloudWatch console is working,
    but if you’re not already seeing log output, then click the blue *Search Log Group*
    button and scroll down to the most recent log lines. You should then be able to
    see something like in [Figure 3-3](#viewing-lambda-logs).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来您将看到的内容将取决于 CloudWatch 控制台的工作方式，但如果您尚未看到日志输出，请点击蓝色的 *搜索日志组* 按钮并向下滚动至最近的日志行。然后您应该能够看到类似
    [图 3-3](#viewing-lambda-logs) 中的内容。
- en: '![images/ch03_image03.png](assets/awsl_0303.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![images/ch03_image03.png](assets/awsl_0303.png)'
- en: Figure 3-3\. Lambda logs
  id: totrans-67
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-3\. Lambda 日志
- en: Notice there on the second line is the output we wrote from our Lambda function.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 注意第二行就是我们从 Lambda 函数中编写的输出。
- en: No good, self-respecting Java programmer does real production logging using
    `System.out.println`, though—logging frameworks give far more flexibility and
    control over logging behavior. We dig into logging practices in detail in [“Logging”](ch07.html#logging).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 没有一个优秀的、自重的 Java 程序员会真正使用 `System.out.println` 进行生产日志记录—日志记录框架提供了更多的灵活性和控制日志行为的功能。我们将在
    [“日志记录”](ch07.html#logging) 中详细讨论日志记录实践。
- en: Input, Output
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输入，输出
- en: When a Lambda function is executed, it is always passed an input argument, typically
    referred to as an *event*. Within the Lambda execution environment, this event
    is specifically always a JSON value, and in our examples so far we’ve been handcrafting
    a string—by itself valid JSON.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行 Lambda 函数时，它总是会传递一个输入参数，通常称为 *事件*。在 Lambda 执行环境中，此事件始终是一个 JSON 值，在我们到目前为止的示例中，我们一直在手动创建一个字符串—这个字符串本身就是有效的
    JSON。
- en: In real use cases, the input to the Lambda function will be a JSON object that
    represents an event from some other component or system. For example, it may be
    a representation of the details of an HTTP request, or some metadata of an image
    uploaded to the S3 storage service. Again, we look in detail at tying event sources
    to Lambda functions later in the book—see [“Lambda Event Sources”](ch05.html#event-sources).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际使用中，Lambda 函数的输入将是一个表示来自某些其他组件或系统的事件的 JSON 对象。例如，它可能是表示 HTTP 请求的详细信息，或者是上传到
    S3 存储服务的图像的一些元数据。在本书的后面章节中我们将详细讨论如何将事件源与 Lambda 函数绑定—参见 [“Lambda 事件源”](ch05.html#event-sources)。
- en: The JSON that we create in our test events, or that comes from event sources,
    is passed to the Lambda Java Runtime. In most use cases, the Lambda Java Runtime
    will automatically *deserialize* this JSON payload for us, and we have several
    options of how to guide this.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在测试事件中创建的 JSON，或者来自事件源的 JSON，会传递给 Lambda Java 运行时。在大多数用例中，Lambda Java 运行时会自动为我们反序列化此
    JSON 负载，并且我们有几种选项来指导此过程。
- en: As you saw in the previous section, when we invoke a function synchronously,
    we can return a useful value to the environment. The Lambda Java Runtime will
    automatically *serialize* this return value to JSON for us.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前一节中看到的，当我们同步调用一个函数时，我们可以将一个有用的值返回给环境。Lambda Java 运行时会自动将此返回值序列化为 JSON。
- en: How the Java Runtime performs this serialization and deserialization depends
    on types we specify within the function signature, so it’s time we took a deeper
    look at what makes a Lambda function statically valid.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Java 运行时如何执行这些序列化和反序列化操作取决于我们在函数签名中指定的类型，因此现在是时候深入了解使 Lambda 函数在静态上有效的因素了。
- en: Lambda Function Method Signatures
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Lambda 函数方法签名
- en: 'Valid Java Lambda methods must fit one of the following four signatures:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 有效的 Java Lambda 方法必须符合以下四种签名之一：
- en: '*`output-type handler-name`*`(`*`input-type`* ` `input`) `'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*`output-type handler-name`*`(`*`input-type`* ` `input`) `'
- en: '*`output-type handler-name`*`(`*`input-type`* ` `input`, Context context) `'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*`output-type handler-name`*`(`*`input-type`* ` `input`, Context context) `'
- en: '`void` *`handler-name`*`(InputStream is, OutputStream os)`'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void` *`handler-name`*`(InputStream is, OutputStream os)`'
- en: '`void` *`handler-name`*`(InputStream is, OutputStream os, Context context)`'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void` *`handler-name`*`(InputStream is, OutputStream os, Context context)`'
- en: 'where:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 其中：
- en: '*`output-type`* can be `void`, a Java primitive, or a JSON-serializable type.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*`output-type`* 可以是 `void`、Java 原始类型或可 JSON 序列化的类型。'
- en: '*`input-type`* is a Java primitive, or a JSON-serializable type.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*`input-type`* 是 Java 原始类型或可 JSON 序列化的类型。'
- en: '`Context` refers to `com.amazonaws.services.lambda.runtime.Context` (we describe
    this more later in the chapter).'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Context` 指的是 `com.amazonaws.services.lambda.runtime.Context`（我们将在本章稍后详细描述）。'
- en: '`InputStream` and `OutputStream` refer to the types with those names in the
    `java.io` package.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InputStream` 和 `OutputStream` 是指 `java.io` 包中的相应类型。'
- en: '*`handler-name`* can be any valid Java method name, and we refer to it in our
    application’s configuration.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*`handler-name`* 可以是任何有效的 Java 方法名称，并且我们在应用程序的配置中引用它。'
- en: Java Lambda methods can be either instance methods or static methods, but must
    be public.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Java Lambda 方法可以是实例方法也可以是静态方法，但必须是公共的。
- en: A class containing a Lambda function cannot be abstract and must have a no-argument
    constructor—either the default constructor (i.e., no constructor specified) or
    an explicit no-argument constructor. The main reason to consider using a constructor
    at all is for caching data between Lambda calls, which is an advanced topic that
    we’ll get to later in the book—see [“Caching”](ch08.html#caching).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 包含 Lambda 函数的类不能是抽象的，并且必须具有无参数构造函数——可以是默认构造函数（即未指定任何构造函数）或显式的无参数构造函数。考虑使用构造函数的主要原因之一是在
    Lambda 调用之间缓存数据，这是我们稍后会详细讨论的高级主题—参见 [“Caching”](ch08.html#caching)。
- en: Beyond those limitations, there are no static typing requirements of a Java
    Lambda function. You are not required to implement any interfaces or base classes,
    although you may do so if you desire. AWS provides a `RequestHandler` interface
    if you want to be very explicit about the type of your Lambda classes, but we
    have never found a need to make use of this. Also, you can if you like extend
    your own classes, subject to the constructor rules, but again we find this is
    rarely a useful ability.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些限制外，Java Lambda 函数没有静态类型要求。您不需要实现任何接口或基类，尽管如果希望可以这样做。AWS 提供了一个 `RequestHandler`
    接口，如果您想非常明确地指定 Lambda 类的类型，但我们从未发现有必要使用这个接口。此外，您可以扩展自己的类（符合构造函数规则），但我们同样发现这种能力很少有用。
- en: You may have multiple Lambda functions defined in one class with different names,
    but we don’t usually recommend this style. Since two different Lambda functions
    never run in the same execution environment, we find it makes it clearer for subsequent
    engineers when we cleanly separate the code for each function.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在一个类中定义多个具有不同名称的 Lambda 函数，但我们通常不建议这种风格。由于两个不同的 Lambda 函数永远不会在同一个执行环境中运行，我们发现将每个函数的代码清晰地分开可以让后续的工程师更容易理解。
- en: Lambda functions, statically, are simple in comparison with some other application
    frameworks. The first two signatures listed earlier are the most common for Java
    Lambdas, and we’ll look at those next.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 函数在静态上与某些其他应用程序框架相比较简单。前面列出的前两个签名是 Java Lambda 最常见的签名，接下来我们将看看它们。
- en: Configuring the Handler Function in the SAM Template
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 SAM 模板中配置处理函数
- en: 'So far we’ve made only one change to the SAM template file—*template.yaml*—to
    change the function’s name. Before we go too much further, we need to look at
    another property in that file: `Handler`.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们仅对 SAM 模板文件 *template.yaml* 进行了一次更改，即更改函数的名称。在我们继续之前，我们需要查看该文件中的另一个属性：`Handler`。
- en: Open the *template.yaml* file, and you’ll see that `Handler` is currently set
    to `book.HelloWorld::handler`. What this means is that for this Lambda function,
    the Lambda platform will attempt to find a method named `handler` in a class named
    `HelloWorld` in the package named `book`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 *template.yaml* 文件，您会看到 `Handler` 当前设置为 `book.HelloWorld::handler`。这意味着对于此
    Lambda 函数，Lambda 平台将尝试在名为 `book` 的包中的名为 `HelloWorld` 的类中找到一个名为 `handler` 的方法。
- en: If you create a new class named `Cow` in a package named `old.macdonald.farm`,
    and you have a method named `moomoo` that is your Lambda function, then you would
    set `Handler` instead to `old.macdonald.farm.Cow::moomoo`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在名为`old.macdonald.farm`的包中创建了一个名为`Cow`的新类，并且你有一个名为`moomoo`的方法作为你的Lambda函数，那么你应该将`Handler`设置为`old.macdonald.farm.Cow::moomoo`。
- en: With this information, you’re all set to create some new Lambda handlers!
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些信息，你就可以创建一些新的Lambda处理程序了！
- en: Basic Types
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本类型
- en: '[Example 3-1](#EX3-1) shows a class with three different Lambda handler functions
    (yes, we just said a moment ago that we don’t tend to use multiple Lambda functions
    per class in real use—we’re doing so here for brevity!)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 3-1](#EX3-1)展示了一个具有三个不同Lambda处理函数的类（是的，我们刚才说过在实际使用中我们不倾向于在一个类中使用多个Lambda函数—这里为了简洁起见这样做了！）'
- en: Example 3-1\. Basic type serialization and deserialization
  id: totrans-100
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-1\. 基本类型的序列化和反序列化
- en: '[PRE8]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: To try this code, add the new class `StringIntegerBooleanLambda` to your source
    tree, change the `Handler` in the *template.yaml* file (e.g., to `book.StringIntegerBooleanLambda::handlerString`),
    and then run your package and deploy commands.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试这段代码，请将新的类`StringIntegerBooleanLambda`添加到你的源代码树中，更改*template.yaml*文件中的`Handler`（例如，改为`book.StringIntegerBooleanLambda::handlerString`），然后运行你的打包和部署命令。
- en: The first of these functions is the same as we described in the previous section.
    We can test this method by invoking it with the JSON object `"world"`, and since
    it had a `void` return type, it is meant for asynchronous usage.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个函数与我们在前一节中描述的相同。我们可以通过使用JSON对象`"world"`调用它进行测试，由于它有一个`void`返回类型，它适用于异步使用。
- en: Tip
  id: totrans-104
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: From here on in you should assume that when we say to invoke a function in an
    example, we mean you should invoke it *synchronously* unless we specify otherwise.
    You can do this either using the `--invocation-type RequestResponse` flag when
    invoking from a terminal or using the *Test* functionality in the AWS Web Console.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，当我们在示例中说要调用一个函数时，假设我们是指在没有特别指定的情况下以*同步*方式调用它。你可以通过在终端调用时使用`--invocation-type
    RequestResponse`标志或在AWS Web控制台中使用*测试*功能来实现这一点。
- en: The second function can be invoked with a Boolean—any of the JSON values `true`,
    `false`, `"true"`, or `"false"`—and it will also return a Boolean, the inverse
    of the input in this case.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个函数可以用布尔值调用—任何JSON值`true`、`false`、`"true"`或`"false"`—它也会返回一个布尔值，在这种情况下是输入的反向。
- en: The final function takes an integer (either a JSON integer or a number in a
    JSON string, e.g., `5` or `"5"`) and returns a Boolean.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个函数接受一个整数（可以是JSON整数或JSON字符串中的数字，例如`5`或`"5"`），并返回一个布尔值。
- en: In the second and third examples we’re using a primitive type, but you may use
    boxed types if you prefer. For example, you are free to use `java.lang.Integer`
    instead of plain `int` if you like.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二和第三个示例中，我们使用了一个原始类型，但如果你愿意，你可以使用装箱类型。例如，你可以使用`java.lang.Integer`而不是简单的`int`。
- en: 'What’s happening in all of these cases is that the Lambda Java Runtime is deserializing
    the JSON input to a simple type on our behalf. If the event that is passed can’t
    be deserialized to the specified parameter type, you’ll get a failure, with a
    message that starts as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些情况中发生的情况是Lambda Java运行时代表我们将JSON输入反序列化为简单类型。如果传递的事件无法反序列化为指定的参数类型，你将收到一个失败消息，消息开头如下：
- en: '[PRE9]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Strings, integers, and Booleans are the only basic types that are explicitly
    documented as being supported, but with some experimentation we see other basic
    types, such as doubles and floats, are also included.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串、整数和布尔值是唯一明确记录为支持的基本类型，但通过一些实验，我们发现其他基本类型，如双精度和浮点数，也包括在内。
- en: Lists and Maps
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列表和映射
- en: JSON also includes arrays and objects/properties (see [Example 3-2](#EX3-2)).
    The Lambda Java Runtime will automatically deserialize those to Java `List`s and
    `Map`s, respectively, and will also serialize output `List`s and `Map`s to JSON
    arrays and objects.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: JSON还包括数组和对象/属性（参见[示例 3-2](#EX3-2)）。Lambda Java运行时将自动将其反序列化为Java `List`和`Map`，并且还会将输出的`List`和`Map`序列化为JSON数组和对象。
- en: Example 3-2\. List and Map serialization and deserialization
  id: totrans-114
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-2\. 列表和映射的序列化和反序列化
- en: '[PRE10]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Invoking the function `handlerList()` with the JSON array `[ 1, 2, 3 ]` returns
    `[ 101, 102, 103 ]`. Invoking the function `handlerMap()` with the JSON object
    `{ "a" : "x", "b" : "y"}` returns `{ "New Map → a" : "x", "New Map → b" : "y"
    }`.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '使用JSON数组`[ 1, 2, 3 ]`调用函数`handlerList()`返回`[ 101, 102, 103 ]`。使用JSON对象`{ "a"
    : "x", "b" : "y"}`调用函数`handlerMap()`返回`{ "New Map → a" : "x", "New Map → b" :
    "y" }`。'
- en: Furthermore, you can use nested collections as you would expect; for example,
    invoking `handlerNestedCollection()` with
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您可以如预期般使用嵌套的集合；例如，通过调用 `handlerNestedCollection()` 来执行
- en: '[PRE11]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: returns
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 返回
- en: '[PRE12]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Finally, you can also just use `java.lang.Object` as the type of the input parameter.
    While not often useful in production (unless you don’t care about the input argument’s
    value, which is sometimes a valid use), this can be handy at development time
    if you don’t know the precise format of an event. For example, you can use `.getClass()`
    on the argument to find out what type it really is, print out the `.toString()`
    value, etc. We’ll show you a better way of getting the JSON structure of an event
    a little later in this chapter.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您也可以只使用 `java.lang.Object` 作为输入参数的类型。虽然在生产中很少有用（除非您不关心输入参数的值，有时这是一个有效的用途），但在开发时，如果不知道事件的确切格式，这可能很方便。例如，您可以在参数上使用
    `.getClass()` 来查找它的实际类型，打印出 `.toString()` 的值等等。稍后我们会展示另一种更好的方法来获取事件的 JSON 结构。
- en: POJOs and Ecosystem Types
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: POJO 和生态系统类型
- en: The previous input types work well for very fairly simple inputs. An alternative
    for more complex types is to use the Lambda Java Runtime’s automatic POJO (Plain
    Old Java Object) serialization. [Example 3-3](#EX3-3) shows an example where we
    use this for both input and output.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 对于非常简单的输入类型，前面的输入类型效果很好。对于更复杂的类型，另一种选择是使用 Lambda Java 运行时的自动 POJO（普通的 Java 对象）序列化。[示例
    3-3](#EX3-3) 展示了我们如何同时用于输入和输出。
- en: Example 3-3\. POJO serialization and deserialization
  id: totrans-124
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-3\. POJO 序列化和反序列化
- en: '[PRE13]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Obviously this is a very simple case, but it shows POJO serialization in action.
    We can execute this Lambda with the input `{ "a" : "Hello Lambda" }`, and it returns
    `{ "b" : "Input was Hello Lambda" }`. Let’s look a little more closely at the
    code.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '显然，这只是一个非常简单的案例，但它展示了 POJO 序列化的实际效果。我们可以使用输入 `{ "a" : "Hello Lambda" }` 执行此
    Lambda，并返回 `{ "b" : "Input was Hello Lambda" }`。让我们仔细看一下代码。'
- en: First of all, we have our handler function, `handlerPojo()`. This takes as input
    the type `PojoInput`, which is a POJO class we’ve defined. POJO input classes
    can be static nested classes, as we’ve written here, or regular (outer) classes.
    The important thing is that they need to have an empty constructor and have field
    setters that follow the naming of the expected fields to be deserialized from
    the input JSON. If no JSON field is found with the same name as a setter, then
    the POJO field will be left null. Input POJO objects need to be mutable since
    the runtime will modify them after they’ve been instantiated.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们有我们的处理函数 `handlerPojo()`。它以 `PojoInput` 类型作为输入，这是我们定义的 POJO 类。POJO 输入类可以是静态嵌套类，就像我们在这里写的一样，也可以是常规（外部）类。重要的是，它们需要有一个空的构造函数，并且必须有字段的
    setter，这些 setter 遵循从输入 JSON 中反序列化预期字段的命名规则。如果找不到与 setter 同名的 JSON 字段，则 POJO 字段将保持为
    null。输入的 POJO 对象需要是可变的，因为运行时会在实例化后修改它们。
- en: Our handler function interrogates the POJO object and creates a new instance
    of the `PojoResponse` class, which we pass back to the Lambda runtime. The Lambda
    runtime serializes it to JSON by reflecting over all the `get…` methods. There
    are fewer limitations on POJO output classes—since they are not created or mutated
    by the Lambda runtime, you are free to construct them as you please and free to
    make them immutable. And like input classes, POJO output classes can be static
    nested classes or regular (outer) classes.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的处理函数会检查 POJO 对象，并创建 `PojoResponse` 类的新实例，然后将其传回 Lambda 运行时。Lambda 运行时通过反射所有的
    `get…` 方法将其序列化为 JSON。POJO 输出类的限制较少——由于它们不是由 Lambda 运行时创建或变异的，因此您可以根据自己的意愿构建它们，也可以使它们成为不可变对象。与输入类一样，POJO
    输出类可以是静态嵌套类或常规（外部）类。
- en: For both POJO input and output classes, you can nest further POJO classes, using
    the same rules, to serialize/deserialize nested JSON objects. Further, you can
    mix up POJOs and the collection types we discussed (`List`s and `Map`s) in your
    input and output.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 POJO 输入和输出类，您可以进一步嵌套 POJO 类，使用相同的规则来序列化/反序列化嵌套的 JSON 对象。此外，您可以在输入和输出中混合使用我们讨论过的
    POJO 和集合类型（`List` 和 `Map`）。
- en: 'The example we gave previously follows most of the documentation you’ll see
    online: using a *JavaBean* convention for fields. However, if you don’t want to
    use setters in your input class or getters in your output class, you’re free to
    also use public fields. For instance, [Example 3-4](#EX3-4) shows another example.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前给出的示例基本上遵循了您在线上看到的大部分文档：为字段使用 *JavaBean* 约定。然而，如果您不想在输入类中使用 setter 或在输出类中使用
    getter，您也可以使用公共字段。例如，[示例 3-4](#EX3-4) 展示了另一个例子。
- en: Example 3-4\. POJO serialization and deserialization alternative definition
  id: totrans-131
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-4\. POJO序列化和反序列化的备选定义
- en: '[PRE14]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can execute this Lambda with the input `{ "c" : "Hello Lambda" }`, and it
    returns `{ "d" : "Input was Hello Lambda" }`.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '我们可以使用输入 `{ "c" : "Hello Lambda" }` 来执行这个Lambda函数，它将返回 `{ "d" : "Input was
    Hello Lambda" }`。'
- en: 'One of the main uses for POJO input deserialization is when you tie your Lambda
    function to one of the AWS ecosystem Lambda event sources. Here’s an example of
    a handler function that would process the event of an object being uploaded to
    the S3 storage service:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: POJO输入反序列化的主要用途之一是将Lambda函数与AWS生态系统Lambda事件源之一绑定。以下是一个示例，展示了如何处理上传到S3存储服务的对象事件的处理函数：
- en: '[PRE15]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`S3Event` is a type that you can access from an AWS library dependency—we discuss
    this more in [“Example: Building a Serverless Data Pipeline”](ch05.html#serverless-data-pipeline-example).
    You’re also free to build your own POJO classes to handle AWS events.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`S3Event`是你可以从AWS库依赖中访问的一种类型——我们将在[“示例：构建无服务器数据流水线”](ch05.html#serverless-data-pipeline-example)中进一步讨论此问题。你也可以自由构建自己的POJO类来处理AWS事件。'
- en: Streams
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 流
- en: The input/output types we’ve covered so far will be useful for you in many,
    and possibly all, of your use of Lambda in the real world. But what if you have
    a fairly dynamic and/or complicated structure that you can’t, or don’t want to,
    use any of the previous deserialization methods for?
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们讨论的输入/输出类型在实际使用Lambda中将对你非常有用，甚至可能涵盖所有场景。但是如果你有一个相当动态和/或复杂的结构，而你不能或不想使用先前的反序列化方法的话，该怎么办？
- en: The answer is to use option 3 or 4 of the valid signature list, making use of
    `java.io.InputStream` for the event parameter. This gives you access to the raw
    bytes passed to your Lambda function.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是使用前述列表的选项3或4的有效签名，利用`java.io.InputStream`作为事件参数。这使你可以访问传递给Lambda函数的原始字节。
- en: The signature for a Lambda using an `InputStream` is a little different in that
    it always has a `void` return type. If you take an `InputStream` as a parameter,
    you must also take a `java.io.OutputStream` as the second parameter. To return
    a result from such a handler function, you need to write to the `OutputStream`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`InputStream`的Lambda的签名略有不同，因为它始终具有`void`返回类型。如果将`InputStream`作为参数，你还必须将`java.io.OutputStream`作为第二个参数。要从这样的处理函数中返回结果，你需要向`OutputStream`写入内容。
- en: '[Example 3-5](#EX3-5) shows a handler that can process streams.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 3-5](#EX3-5) 展示了一个可以处理流的处理程序。'
- en: Example 3-5\. Using streams as handler parameters
  id: totrans-142
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-5\. 使用流作为处理参数
- en: '[PRE16]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If we execute this handler with the input `"Hello World"`, it will write `"HELLO
    WORLD"` to the output stream, which becomes the function’s result.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用输入 `"Hello World"` 执行这个处理程序，它将将 `"HELLO WORLD"` 写入输出流，这将成为函数的结果。
- en: You may well want to use your own JSON manipulation code if you’re using an
    `InputStream`, but we’ll leave that as an exercise to the reader. You should also
    practice good stream hygiene—error checking, closing, etc.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用`InputStream`，你可能会想要使用自己的JSON操作代码，但我们会将这留给读者作为练习。此外，你应该保持流的良好处理习惯——错误检查、关闭等。
- en: For more on this subject, see the official documentation on [using streams in
    handler functions](https://oreil.ly/oXm39).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 想要了解更多相关内容，请参阅官方文档中关于[在处理函数中使用流](https://oreil.ly/oXm39)的说明。
- en: One particularly handy use of this type of Lambda function is at development
    time when you don’t know the structure of the event you are coding for. [Example 3-6](#EX3-6)
    will log the received event to CloudWatch Logs so you can see what it is.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 一种特别方便的Lambda函数使用场景是在开发时，当你不知道编写代码的事件结构时。[示例 3-6](#EX3-6) 将事件记录到CloudWatch Logs中，以便你查看其内容。
- en: Example 3-6\. Log received event to CloudWatch Logs
  id: totrans-148
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-6\. 记录接收到的事件到CloudWatch Logs中
- en: '[PRE17]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Context
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 上下文
- en: So far we’ve covered signature formats 1 and 3 of our earlier list, but what
    of 2 and 4? What’s that `Context` object about?
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经涵盖了前述列表中的签名格式1和3，那么2和4是什么呢？`Context`对象又是什么？
- en: In all of our examples so far, the only input we’ve taken for a Lambda handler
    function is that of the event that occurred. But that’s not the only information
    the handler can receive when it wants to do some processing. Additionally, you
    can add a `com.amazonaws.services.lambda.runtime.Context` parameter to the end
    of any handler parameter list, and the runtime will pass in an interesting object
    that you can use. Let’s look at an example ([Example 3-7](#EX3-7)).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们到目前为止的所有示例中，Lambda处理程序函数所接收的唯一输入是发生的事件。但这并不是处理程序在处理时唯一能接收的信息。此外，您可以在任何处理程序参数列表的末尾添加一个`com.amazonaws.services.lambda.runtime.Context`参数，运行时将传入一个您可以使用的有趣对象。让我们看一个例子（[示例 3-7](#EX3-7)）。
- en: Example 3-7\. Examining the Context object
  id: totrans-153
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-7\. 检查Context对象
- en: '[PRE18]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This is the first full example where we need to use a type outside of the Java
    standard library. We’ll look in more detail at dependencies and packaging in the
    next chapter, but for now add the following section anywhere under the root element
    of your *pom.xml* file:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们第一个需要使用Java标准库之外类型的完整示例。我们将在下一章节更详细地讨论依赖关系和打包，但现在请在您的*pom.xml*文件的根元素下的任何位置添加以下部分：
- en: '[PRE19]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: When you run `mvn package` now, it will compile your code using the core Lambda
    library provided by AWS, enabling you to use the `Context` interface.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当您现在运行`mvn package`时，它将使用AWS提供的核心Lambda库来编译您的代码，使您能够使用`Context`接口。
- en: 'The `Context` object gives us information about the current Lambda invocation.
    We can use this information during the processing of a Lambda event. When we invoke
    the example (passing anything as an input event—it won’t be used), we’ll get something
    like the following as a result:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`Context`对象为我们提供了有关当前Lambda调用的信息。在Lambda事件处理过程中，我们可以使用这些信息。当我们调用该示例（传入任何输入事件——它不会被使用）时，我们将得到类似以下结果：'
- en: '[PRE20]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: All the different `Context` fields are described in the [AWS documentation](https://oreil.ly/oE2hP).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 所有不同的`Context`字段都在[AWS文档](https://oreil.ly/oE2hP)中有描述。
- en: Most of these fields will stay the same whenever you call them during the processing
    of a particular event, but `getRemainingTimeInMillis()` is a notable exception.
    It’s related to *timeout*, which is what we look at next.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在特定事件处理期间，这些字段中的大多数都将保持不变，但`getRemainingTimeInMillis()`是一个显著的例外。它与*超时*相关，这是我们接下来要看的内容。
- en: Timeout
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 超时
- en: Lambda functions are subject to a configurable timeout. You are able to specify
    this timeout when you create the function, or you can update it later in the function’s
    configuration.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda函数受可配置的超时限制。您可以在创建函数时指定此超时时间，或者稍后在函数的配置中更新它。
- en: At the time of this writing, the *maximum* timeout is 15 minutes. That means
    the longest a single invocation of a Lambda function can run is 15 minutes. This
    restriction is one that AWS may increase in the future, and they’ve done so before—for
    a long time the maximum timeout was 5 minutes.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，*最大*超时时间为15分钟。这意味着单次Lambda函数调用的最长运行时间为15分钟。这个限制是AWS未来可能会增加的，之前也曾增加过——长期以来，最大超时时间为5分钟。
- en: In our examples so far we haven’t specified a timeout setting, so it defaults
    to 3 seconds. That means if our function doesn’t finish executing within 3 seconds,
    then the Lambda Java Runtime will abort it. You’ll see an example of this in a
    moment.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的示例中没有指定超时设置，因此默认为3秒。这意味着如果我们的函数在3秒内没有完成执行，则Lambda Java运行时将中止它。稍后您将在一个示例中看到这个情况。
- en: In the previous section, we looked at the `Context` object. Calling `context.getRemainingTimeInMillis()`
    will tell you how much time to run you have left at any given point during execution
    before the function is aborted by the runtime. Subsequent calls will give an updated
    duration. This is useful if you are writing a fairly long-lived Lambda and want
    to save any state before the timeout occurs.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，我们查看了`Context`对象。调用`context.getRemainingTimeInMillis()`将告诉您在执行期间的任何给定点剩余多少时间可以运行，然后函数将由运行时中止。后续调用将提供更新的持续时间。如果您正在编写一个相当长寿的Lambda并希望在超时发生之前保存任何状态，则这将非常有用。
- en: One question you may be asking yourself—why not always configure the timeout
    to the maximum of 900 seconds? As we’ll explore further in the next section, Lambda
    costs are based significantly on how long functions run—if your function should
    only ever run for at most 10 seconds, then you don’t want a billion invocations
    taking 90 times that long, since you’ll be charged 90 times as much as you want
    to be.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会问自己一个问题——为什么不总是将超时配置为最大的 900 秒？正如我们将在下一节中进一步探讨的那样，Lambda 的成本主要基于函数运行的时间——如果您的函数最多只能运行
    10 秒，那么您不希望十亿次调用花费 90 倍的时间，因为您将被收取 90 倍的费用。
- en: The timeout does *not* include the time our function is being instantiated—in
    other words, the timeout period is not started during the *cold start* of a function.
    Or, to be even more precise, the timeout applies only to the time from when Lambda
    calls our `handler` method. We discuss cold starts further in [“Cold Starts”](ch08.html#cold-starts).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 超时 *不* 包括函数实例化时的时间——换句话说，超时期间不会在函数的 *冷启动* 期间启动。或者更准确地说，超时仅适用于 Lambda 调用我们的 `handler`
    方法后的时间。我们在 [“冷启动”](ch08.html#cold-starts) 中进一步讨论了冷启动。
- en: The timeout maximum of 15 minutes is a significant constraint for Lambda functions—if
    you are writing functionality that needs more than 15 minutes, you’ll need to
    either break it up into multiple, orchestrated, Lambda functions, or not use Lambda
    at all.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 15 分钟的最大超时对 Lambda 函数来说是一个重要的约束——如果您正在编写需要超过 15 分钟的功能，您需要将其拆分为多个协调的 Lambda 函数，或者根本不使用
    Lambda。
- en: Enough theory, let’s look at timeouts in action.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 理论足够了，让我们看看超时是如何发挥作用的。
- en: '[Example 3-8](#EX3-8) shows a Lambda function that will query the remaining
    time and then eventually fail due to timeout.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 3-8](#EX3-8) 展示了一个 Lambda 函数，该函数将查询剩余时间，最终由于超时而失败。'
- en: Example 3-8\. Looking at timeout with Context.getRemainingTimeInMillis()
  id: totrans-172
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-8\. 使用 Context.getRemainingTimeInMillis() 查看超时
- en: '[PRE21]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Update your *template.yaml* file, adding a new property named `Timeout` to the
    `Properties` section of your function. Set the value to be `2`—this says that
    the function’s timeout is now two seconds. Also, remember to update your `Handler`
    property.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 更新您的 *template.yaml* 文件，在函数的 `Properties` 部分添加一个名为 `Timeout` 的新属性。将值设置为 `2`——这意味着函数的超时现在是两秒。还要记得更新您的
    `Handler` 属性。
- en: Then run your package and deploy steps as usual.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 然后按照通常步骤运行您的包和部署步骤。
- en: 'If we execute this using the test functionality in the web console, it will
    fail with the message “Task timed out after 2.00 seconds.” The log output will
    be as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在 Web 控制台中使用测试功能执行此操作，它将因“任务在 2.00 秒后超时”而失败。日志输出将如下所示：
- en: '[PRE22]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here we can see the `getRemainingTimeInMillis()` method being queried as we’d
    expect and then the function finally failing as Lambda’s timeout occurs.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们可以看到 `getRemainingTimeInMillis()` 方法被查询，正如我们预期的那样，然后函数最终由于 Lambda 的超时而失败。
- en: Memory and CPU
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存和 CPU
- en: Lambda functions do not have infinite amounts of RAM, and in fact every function
    is configured with a `memory-size` setting. The setting defaults to 128MB, but
    this is rarely enough for a production Java Lambda function, so you should treat
    `memory-size` as something you actively think about for every function.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 函数没有无限量的 RAM，实际上每个函数都配置有一个 `memory-size` 设置。默认设置为 128MB，但对于生产环境的 Java
    Lambda 函数来说很少足够，因此您应该将 `memory-size` 视为每个函数都需要认真考虑的内容。
- en: '`memory-size` can be as small as 64MB, although for Java Lambda functions you
    should probably use at least 256MB. `memory-size` must be a multiple of 64MB.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`memory-size` 可以小至 64MB，尽管对于 Java Lambda 函数，您可能应该至少使用 256MB。`memory-size` 必须是
    64MB 的倍数。'
- en: A very important thing to know is that the `memory-size` setting is not just
    for how much RAM your function can use—*it also specifies how much CPU power you
    get*. In fact, a Lambda function’s CPU power scales linearly from 64MB up to 1792MB.
    Therefore a Lambda function configured with 1024MB of RAM has twice the CPU power
    of one with 512MB of RAM.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`memory-size` 设置非常重要，不仅决定函数可以使用多少内存——*它也指定了函数可以获取多少 CPU 力量*。实际上，Lambda 函数的
    CPU 力量从 64MB 线性扩展到 1792MB。因此，配置为 1024MB RAM 的 Lambda 函数比配置为 512MB RAM 的函数具有两倍的
    CPU 力量。'
- en: A Lambda function with 1792MB RAM gets a full virtual CPU core—larger RAM settings
    than that enable fractions of a second virtual core. This is worth knowing if
    your code is not multithreaded at all—you may not see a CPU improvement for memory
    settings higher than 1792MB in such a case.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 1792MB RAM 的 Lambda 函数获得一个完整的虚拟 CPU 核心——比该设置大的 RAM 设置允许秒级虚拟核心的分数。这值得知道，如果您的代码根本没有多线程，您可能在这种情况下看不到内存设置高于
    1792MB 时的 CPU 改进。
- en: Note
  id: totrans-184
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: We discuss how the Lambda execution environment interacts with multiple threads
    in [“Lambda and Threading”](ch08.html#lambda-and-threading).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论 Lambda 执行环境如何与多个线程交互在 [“Lambda and Threading”](ch08.html#lambda-and-threading)。
- en: 'But why should you care about this—why not always just set `memory-size` to
    its maximum of 3008MB? The reason is cost. AWS charges for Lambda functions by
    two primary factors:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 但为什么你应该关心这个——为什么不总是将`memory-size`设置为其最大值3008MB？原因在于成本。AWS根据两个主要因素收取 Lambda 函数的费用：
- en: How long a function runs, rounded up to the nearest 100 ms
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数运行时间，四舍五入到最接近的100毫秒
- en: How much memory a function is specified to use
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数指定使用的内存量
- en: In other words, given the same execution duration, a Lambda function that has
    2GB of RAM costs twice as much to execute as one with 1GB of RAM. Or, one with
    512MB of RAM costs 17% of one with 3008MB. This, at scale, could be a big difference.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，给定相同的执行时间，具有2GB RAM的 Lambda 函数的执行成本是具有1GB RAM的两倍。或者，具有512MB RAM的 Lambda
    函数的成本是具有3008MB的17％。这在规模上可能会有很大的差异。
- en: Surely that means you should always use the smallest amount of memory possible
    then? No, that’s not always the best choice. Since a function with twice as much
    memory of a smaller function also has twice the CPU power, it might take half
    the time to execute, meaning the cost is the same, and it gets its work done more
    quickly.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着您应该尽可能使用最少的内存吗？不，那并不总是最好的选择。由于具有两倍于较小函数的内存的函数也具有两倍的CPU功率，因此它可能需要一半的时间来执行，这意味着成本是相同的，并且可以更快地完成工作。
- en: Right-sizing Lambda functions is something of an art. We recommend you stick
    with somewhere between 512MB and 1GB to start with and then start tuning as your
    functions get bigger or as you need to scale them.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 调整 Lambda 函数的大小有点艺术性。我们建议您从512MB到1GB之间进行选择，然后随着函数的增大或需要扩展它们而开始调整。
- en: Environment Variables
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 环境变量
- en: The previous two sections were all about Lambda’s own system configuration—what
    if you want to use configuration for your own application?
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 前两节都是关于 Lambda 自己的系统配置——如果您想为自己的应用程序使用配置，该怎么办？
- en: We can specify *environment variables* for our Lambda functions. This allows
    us to alter how our function runs in different contexts for the same code. It’s
    very typical, for example, to specify connection settings for external processes,
    or secure configuration, through environment variables.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为我们的 Lambda 函数指定 *环境变量*。这允许我们在相同代码的不同上下文中更改函数运行方式。例如，通过环境变量指定外部进程的连接设置或安全配置是非常典型的。
- en: Let’s try this. [Example 3-9](#EX3-9) shows a function that reads from the environment
    using Java’s standard method for doing so.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试这个。[示例 3-9](#EX3-9) 显示了一个使用 Java 标准方法读取环境的函数。
- en: Example 3-9\. Using an environment variable
  id: totrans-196
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-9\. 使用环境变量
- en: '[PRE23]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Update the *template.yaml* file to point to this new class and perform the package
    and deploy process.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 更新 *template.yaml* 文件以指向此新类并执行打包和部署过程。
- en: 'If we run this function (using any test input we like), the log output will
    include the following:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行此函数（使用我们喜欢的任何测试输入），日志输出将包括以下内容：
- en: '[PRE24]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now update the *template.yaml* file again so that the `HelloWorldLambda` section
    looks as follows (careful with your YAML tabbing!):'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在再次更新 *template.yaml* 文件，使 `HelloWorldLambda` 部分如下所示（注意你的 YAML 缩进！）：
- en: '[PRE25]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'After packaging and deploying, if we test the function now, the log output
    includes this instead:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 打包和部署后，如果我们现在测试函数，日志输出将包括这个代替：
- en: '[PRE26]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We are free to update the environment configuration as much as we would like.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以随意更新环境配置。
- en: When using environment variables, you often want to store sensitive data, for
    example access keys to remote services. There are a number of ways of doing this
    in a secure way with Lambda, and they are explained in Amazon’s documentation.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用环境变量时，通常希望存储敏感数据，例如远程服务的访问密钥。有许多安全的 Lambda 使用方式，并在亚马逊的文档中有所解释。
- en: Summary
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概要
- en: The programming model for AWS Lambda is significantly different from other models
    that you may be used to.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: AWS Lambda 的编程模型与您可能习惯的其他模型显着不同。
- en: In this chapter, you explored what it means to program Lambda functions—what
    the runtime environment is, how functions are invoked, and the different ways
    you can get data in and out of functions.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您探讨了编写 Lambda 函数的含义——运行环境是什么，函数如何被调用，以及您可以输入和输出函数的不同方式。
- en: Then you learned some aspects of configuration for Lambda functions—timeout
    and memory—and what those settings mean. Finally, you saw how you can apply your
    own application configuration through environment variables.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您了解了 Lambda 函数的一些配置方面——超时和内存——以及这些设置的含义。最后，您看到了如何通过环境变量应用自己的应用程序配置。
- en: Now that you know how to program Lambda functions, in the next chapter we will
    examine Lambda operations—packaging, deployment, security, monitoring, and more.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经知道如何编程 Lambda 函数，在下一章中，我们将研究 Lambda 操作——打包、部署、安全、监控等内容。
- en: Exercises
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Take some time to work through the step-by-step descriptions in this chapter—Lambda
    is very different than how you may have built and run Java applications in the
    past.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 花些时间逐步完成本章中的描述——Lambda 与您以前构建和运行 Java 应用程序的方式非常不同。
- en: Try logging something using `System.err`—the standard error stream—instead of
    `System.out`. Does the log output appear any differently to `System.out`? Does
    it change the result of calling the function, either asynchronously or synchronously?
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试使用 `System.err`——标准错误流——而不是 `System.out` 记录一些内容。日志输出与 `System.out` 有何不同？它是否改变了调用函数的结果，无论是异步还是同步？
- en: 'Deliberately call a function with invalid input to see the parsing exception
    described earlier: `An error occurred during JSON parsing`. Where do you see this
    error? How does it impact the result of calling the function, either asynchronously
    or synchronously?'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 故意使用无效输入调用一个函数，以查看前面描述的解析异常：`An error occurred during JSON parsing`。您在哪里看到这个错误？它如何影响调用函数的结果，无论是异步还是同步？
- en: Try building your own POJO types and calling Lambda with JSON versions of them.
    Do you prefer the *JavaBean* style, or public fields?
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试构建自己的 POJO 类型，并使用它们的 JSON 版本调用 Lambda。您更喜欢*JavaBean*风格，还是公共字段？
- en: Try using the `StreamLambda` described earlier that outputs the entire input
    event with one of the provided test event template objects in the Lambda web console.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试使用之前描述的 `StreamLambda` 在 Lambda web 控制台中输出整个输入事件与提供的测试事件模板对象之一。
- en: Try converting one of your classes to use a static handler method, rather than
    an instance method, to confirm that it works just as well.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试将您的一个类转换为使用静态处理器方法，而不是实例方法，以确认它是否同样有效。
