- en: Chapter 20\. Performing I/O to Passing Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第20章。执行 I/O 以传递数据
- en: Input and output are problematic in code. Our program is subject to errors talking
    to the outside world when files disappear or network sockets fail. I/O is also
    an action and so limits our ability to reason with and refactor our code. How
    can we limit the scope of the problems that I/O causes?
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 代码中的输入和输出存在问题。当文件消失或网络套接字失败时，我们的程序容易出错。I/O 也是一种动作，因此限制了我们理解和重构代码的能力。我们如何限制 I/O
    导致的问题范围？
- en: Now that earlier chapters have built some foundations, we’re going to up the
    pace here, going straight into refactoring and learning lessons as we go.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在早期章节已经打下了一些基础，我们将加快进度，直接进行重构，并在过程中学习教训。
- en: Listening to Tests
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 听从测试的建议
- en: 'In [Chapter 10](ch10.html#functions-to-extension-functions), we looked at some
    Java code that produced a report for marketing. When we left the code, we had
    introduced extension functions to the `HighValue​Custo⁠mersReport`, giving us:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第10章](ch10.html#functions-to-extension-functions) 中，我们查看了一些生成市场报告的 Java 代码。当我们离开这段代码时，我们已经将扩展函数引入了
    `HighValue​Custo⁠mersReport`，得到了：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[Example 20.1 [io-to-data.0:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=20.1&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=20.1&show=diff)'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 20.1 [io-to-data.0:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=20.1&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=20.1&show=diff)'
- en: 'Here are the tests after conversion to Kotlin:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 转换为 Kotlin 后的测试如下：
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[Example 20.2 [io-to-data.1:src/test/java/travelator/marketing/HighValueCustomersReportTests.kt]](https://java-to-kotlin.dev/code.html?ref=20.2&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=20.2&show=diff)'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 20.2 [io-to-data.1:src/test/java/travelator/marketing/HighValueCustomersReportTests.kt]](https://java-to-kotlin.dev/code.html?ref=20.2&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=20.2&show=diff)'
- en: We didn’t really look at the tests in [Chapter 10](ch10.html#functions-to-extension-functions),
    but if we do now, what stands out in the light of your authors’ obsession with
    actions and calculations ([Chapter 7](ch07.html#actions-to-calculations))? In
    particular, look at that `check` function.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们并没有真正关注 [第10章](ch10.html#functions-to-extension-functions) 中的测试，但如果我们现在看一下，在你们作者对行动和计算
    ([第7章](ch07.html#actions-to-calculations)) 的痴迷背景下，什么是显著的？特别是看看那个 `check` 函数。
- en: '`check` is evidently not a calculation ([“Calculations”](ch07.html#calculations)),
    because it works entirely by throwing an exception instead of returning a value.
    What if we look at it this way though?'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`check` 显然不是一个计算（[“Calculations”](ch07.html#calculations)），因为它完全通过抛出异常而不是返回值来工作。但如果我们这样看呢？'
- en: '[PRE2]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[Example 20.3 [io-to-data.2:src/test/java/travelator/marketing/HighValueCustomersReportTests.kt]](https://java-to-kotlin.dev/code.html?ref=20.3&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=20.3&show=diff)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 20.3 [io-to-data.2:src/test/java/travelator/marketing/HighValueCustomersReportTests.kt]](https://java-to-kotlin.dev/code.html?ref=20.3&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=20.3&show=diff)'
- en: This is for all intents and purposes the same code, but now we can see that
    we have a calculation, taking `inputLines` and yielding `outputLines`, before
    we go on to the assertion. Even though `generate` is an action, relying on the
    side effects of reading and writing to and from its parameters, we can convert
    it to a calculation by limiting the scope of its side effects to local variables.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 `generate` 是一种动作，依赖于读取和写入其参数的副作用，但我们可以通过限制其副作用的范围仅限于局部变量，将其转换为计算。
- en: 'If we stop for a moment and listen, we can hear the tests talking to us. They
    are saying, “Look, that report generation is fundamentally a calculation: it converts
    a `List<String>` to a `List<String>`. We know it does, because that’s what we
    are checking.”'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们停下来听一听，我们可以听到测试在告诉我们。“看，那个报告生成本质上是一个计算：它将 `List<String>` 转换为 `List<String>`。我们知道它这样做，因为这是我们正在检查的内容。”
- en: 'So the tests are telling us that the fundamental signature of `generate` is
    `generate(lines: List<String>): List<String>`. If *this* was the signature, then
    it would not have to declare that it throws `IOException` either, because all
    the I/O would happen outside the function. I/O has to happen somewhere, but, in
    common with other actions, the closer to the entry points of our system we can
    move it, the more we can deal in nice easy calculations.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Shall we refactor toward this goal? You’re right, that was a rhetorical question.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: I/O to Data
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As the first stage in our refactor, let’s try to wean `generate` off its `reader`
    parameter. The code is currently:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[Example 20.4 [io-to-data.3:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=20.4&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=20.4&show=diff)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: 'We can convert `generate` to read from a `List` by invoking “Introduce parameter”
    on the `reader.readLines()` expression, naming the parameter `lines`. Because
    the expression is the only use of the existing `reader` parameter, IntelliJ removes
    `reader` for us:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[Example 20.5 [io-to-data.4:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=20.5&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=20.5&show=diff)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 'The refactoring has moved the `readLines()` out into the callers; here is the
    result in test:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[Example 20.6 [io-to-data.4:src/test/java/travelator/marketing/HighValueCustomersReportTests.kt]](https://java-to-kotlin.dev/code.html?ref=20.6&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=20.6&show=diff)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: 'This now shouts what the test was whispering all along. We were having to create
    a `StringReader` from a list of lines just to parse the lines back out in `generate`.
    Now that the steps are in the same place in the test, we can elide them to remove
    the `Reader`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[Example 20.7 [io-to-data.5:src/test/java/travelator/marketing/HighValueCustomersReportTests.kt]](https://java-to-kotlin.dev/code.html?ref=20.7&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=20.7&show=diff)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now reading from a `List`. Let’s go back and look at how to return a
    `List` too, rather than modifying the `Writer`. Here is the code:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[Example 20.8 [io-to-data.5:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=20.8&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=20.8&show=diff)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of thinking imperatively about the ways that we want to mutate `Writer`,
    let’s think in terms of the data that we want written and create that:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[Example 20.9 [io-to-data.6:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=20.9&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=20.9&show=diff)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we can write it in one lump to `writer`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[Example 20.10 [io-to-data.6:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=20.10&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=20.10&show=diff)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'This function is now two statements that make up a calculation, and a final
    action taking the result of the calculation. If we now “Extract function” with
    the calculation lines, making it public and calling it `generate` too, we get
    the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[Example 20.11 [io-to-data.7:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=20.11&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=20.11&show=diff)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'Inlining both vestigial `resultLines` gives:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[Example 20.12 [io-to-data.8:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=20.12&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=20.12&show=diff)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: 'One more inline then, this time of the old `generate` function. That replaces
    its invocation in client code, leaving this in the test:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[Example 20.13 [io-to-data.9:src/test/java/travelator/marketing/HighValueCustomersReportTests.kt]](https://java-to-kotlin.dev/code.html?ref=20.13&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=20.13&show=diff)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 'This refactor has moved the action part of `generate` out a level, leaving
    the nice pure calculation bits in its place. Another way of looking at this is
    that our original `Writer` was an accumulating object, which we have replaced
    with a transformation, as we saw in [Chapter 14](ch14.html#accumulating-objects-to-transformations).
    Our tests didn’t really want to be testing an action anyway, so they again have
    redundant I/O, which we can simplify to the form we were aiming for:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[Example 20.14 [io-to-data.10:src/test/java/travelator/marketing/HighValueCustomersReportTests.kt]](https://java-to-kotlin.dev/code.html?ref=20.14&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=20.14&show=diff)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take stock of our new `generate`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[Example 20.15 [io-to-data.11:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=20.15&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=20.15&show=diff)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that `generate` is doing so much less, it isn’t clear that the function
    `toValuable​Cus⁠tomers()` is worthwhile. Looking at it afresh, we see that it
    is working at mixed levels, converting and filtering. Let’s try inlining it:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[Example 20.16 [io-to-data.12:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=20.16&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=20.16&show=diff)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: That’s better. The local variable `valuableCustomers` does a good job of telling
    us what the expression means, and the list operations spell out the implementation
    in place. This function is a case where a single-expression function ([Chapter 9](ch09.html#multi-to-single-expression-functions))
    would probably make things worse, so we’ll leave it in two parts. We’ll also continue
    to resist the temptation to make it an extension function, `List<String>.toReport()`,
    at least for now.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Efficient Writing
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’re quite pleased with this refactor. It has simplified our tests and the
    production code, and we have moved from mixing I/O and logic to a simpler calculation
    with no side effects.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: For a while, all is fine in production too, but with the easing of COVID-19
    travel restrictions, Travelator becomes the roaring success that we all knew it
    would be. Eventually, though, the lovely people in marketing start complaining
    that the report generation is failing with an `OutOfMemoryError`. Could we look
    into it?
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: (Apart from running out of memory, we have had two other issues with errors
    in this code in living memory. Both these times, the input file turned out to
    have been malformed, but marketing sit next door and just call us over to help
    if these occur. They feed us cake in these cases, so we’re hardly incentivized
    to do a better job of error handling for now (but see [Chapter 21](ch21.html#exceptions-to-values)).
    If we can fix the `OutOfMemoryError` quickly, we think we saw some crumpets…)
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'We haven’t bothered you with the details so far, but there is a `main` method
    that invokes our report. It is designed to be invoked with shell redirection,
    reading from a file piped as the standard input and writing to a file collected
    from the standard output. This way, our process doesn’t have to read filenames
    from the command line:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[Example 20.17 [io-to-data.0:src/main/java/travelator/marketing/HighValueCustomersMain.kt]](https://java-to-kotlin.dev/code.html?ref=20.17&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=20.17&show=diff)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: 'When we refactored `generate` to work with `List`s rather than a `Reader` and
    `Writer`, IntelliJ automatically updated `main` to yield:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[Example 20.18 [io-to-data.9:src/main/java/travelator/marketing/HighValueCustomersMain.kt]](https://java-to-kotlin.dev/code.html?ref=20.18&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=20.18&show=diff)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Ah, there’s our problem. We’re reading the whole of the input into memory (`readLines()`),
    processing it, and then creating the entire output in memory (`joinToString()`)
    before writing it back out.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: We sometimes run into problems like these with functional decomposition. In
    this case the original `Reader` and `Writer` code did not have this issue, so
    we have brought it on ourselves in the name of good style. We could quickly revert
    our changes and go and see whether there are any crumpets left, or we could find
    a more functional solution.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s go back to `generate` and see what leeway we have:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到`generate`函数，看看我们有哪些余地：
- en: '[PRE18]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[Example 20.19 [io-to-data.12:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=20.19&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=20.19&show=diff)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 20.19 [io-to-data.12:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=20.19&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=20.19&show=diff)'
- en: Concentrating on the output for now, we can see that we are building a `List`
    of the lines of the output; `main` then takes each `String` in the result and
    creates one giant one with `joinToString()`. At this point both the individual
    output lines and their conglomerate will be taking up memory. To avoid running
    out of memory, we’ll need to defer the creation of the intermediate collections,
    and, as we saw in [Chapter 13](ch13.html#streams-to-sequences), `Sequence`s are
    designed for just that.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只关注输出部分，可以看到我们正在构建输出行的`List`；然后`main`函数接收结果中的每个`String`，并使用`joinToString()`方法将它们组合成一个大字符串。此时，无论是单独的输出行还是它们的整体都会占用内存。为了避免内存耗尽，我们需要推迟中间集合的创建，正如我们在[第13章](ch13.html#streams-to-sequences)中所看到的，`Sequence`就是为此设计的。
- en: 'We can convert `generate` to return a `Sequence` methodically or quickly. For
    once, we’ll choose quickly and just replace `listOf` with `sequenceOf` in our
    `return` expression:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以系统地或迅速地将`generate`转换为返回`Sequence`。这一次，我们选择迅速地将`return`表达式中的`listOf`替换为`sequenceOf`：
- en: '[PRE19]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[Example 20.20 [io-to-data.13:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=20.20&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=20.20&show=diff)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 20.20 [io-to-data.13:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=20.20&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=20.20&show=diff)'
- en: Now we will only be creating the output lines one at a time when the `Sequence`
    is iterated; each line can be disposed of quickly rather than hanging around until
    we have written the whole file.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当迭代`Sequence`时，我们只会逐个创建输出行；每行都可以迅速处理，而不是等到整个文件都写完。
- en: 'The tests have to change to convert the returned `Sequence` to a `List`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 测试必须更改以将返回的`Sequence`转换为`List`：
- en: '[PRE20]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[Example 20.21 [io-to-data.13:src/test/java/travelator/marketing/HighValueCustomersReportTests.kt]](https://java-to-kotlin.dev/code.html?ref=20.21&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=20.21&show=diff)'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 20.21 [io-to-data.13:src/test/java/travelator/marketing/HighValueCustomersReportTests.kt]](https://java-to-kotlin.dev/code.html?ref=20.21&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=20.21&show=diff)'
- en: 'Interestingly, though, `main` does not:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，尽管如此，`main`并没有：
- en: '[PRE21]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[Example 20.22 [io-to-data.13:src/main/java/travelator/marketing/HighValueCustomersMain.kt]](https://java-to-kotlin.dev/code.html?ref=20.22&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=20.22&show=diff)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 20.22 [io-to-data.13:src/main/java/travelator/marketing/HighValueCustomersMain.kt]](https://java-to-kotlin.dev/code.html?ref=20.22&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=20.22&show=diff)'
- en: '`main` needs to be *recompiled* now that `generate` returns a `Sequence` rather
    than a `List`, but its *source* doesn’t need to be changed. This is because there
    are extension functions `joinToString()` defined on both `Iterable` and `Sequence`,
    both returning `String`.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`main`需要*重新编译*，因为`generate`现在返回`Sequence`而不是`List`，但是它的*源代码*无需更改。这是因为`Iterable`和`Sequence`都定义了`joinToString()`的扩展函数，都返回`String`。
- en: 'It might not *need* to change, but unless `main` *does* change, we are still
    creating one large string of all the output before writing it in one operation.
    To avoid that, we need to get imperative again and write each output line individually,
    as our original `generate` had done:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 它可能并不*需要*改变，但是除非`main`确实*改*变，否则我们仍然会在写入操作之前创建一个包含所有输出的大字符串。为了避免这种情况，我们需要再次变得命令式，并像我们最初的`generate`函数那样逐个写入每个输出行：
- en: '[PRE22]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[Example 20.23 [io-to-data.14:src/main/java/travelator/marketing/HighValueCustomersMain.kt]](https://java-to-kotlin.dev/code.html?ref=20.23&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=20.23&show=diff)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 20.23 [io-to-data.14:src/main/java/travelator/marketing/HighValueCustomersMain.kt]](https://java-to-kotlin.dev/code.html?ref=20.23&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=20.23&show=diff)'
- en: The pedantic reader (don’t worry, you’re among friends) will have spotted that
    this behavior is subtly different from the `joinToString("\n")` version. We’re
    quietly confident that a trailing newline won’t break anything, so we press on.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 一丝不苟的读者（别担心，你在朋友之中）会发现这种行为与`joinToString("\n")`版本略有不同。我们深信尾随的换行符不会引发任何问题，所以我们继续前进。
- en: 'We can always pretend we aren’t looping by hiding the iteration inside a `Writer::appendLines`
    extension function that we assumed the Kotlin standard library would define, but
    doesn’t seem to:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以假装我们没有在循环，通过将迭代隐藏在我们假设 Kotlin 标准库会定义但似乎没有的`Writer::appendLines`扩展函数内部：
- en: '[PRE23]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[Example 20.24 [io-to-data.15:src/main/java/travelator/marketing/HighValueCustomersMain.kt]](https://java-to-kotlin.dev/code.html?ref=20.24&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=20.24&show=diff)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 20.24 [io-to-data.15:src/main/java/travelator/marketing/HighValueCustomersMain.kt]](https://java-to-kotlin.dev/code.html?ref=20.24&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=20.24&show=diff)'
- en: Note that although the definition of `Writer::appendLines` is a single expression,
    we agreed in [Chapter 9](ch09.html#multi-to-single-expression-functions) to use
    the long form where functions are actions, and `appendLines` is definitely that.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，虽然`Writer::appendLines`的定义是一个单表达式，但我们在[第9章](ch09.html#multi-to-single-expression-functions)中同意在函数是动作时使用长形式，而`appendLines`绝对是这样的。
- en: Now that we are here, we realize that we could have postponed our memory crisis
    by just iterating over the original result `List` in `main`, writing each line
    individually, as we are doing now with the `Sequence`. This solution will use
    even less memory, though, so we’ll commit it, having bought ourselves lots of
    headroom with few changes and earned our crumpets. Is there any butter?
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在这里，我们意识到我们可以通过在`main`中仅迭代原始结果`List`，逐个写入每一行，就像我们现在在`Sequence`中所做的那样，来推迟我们的内存危机。这种解决方案将使用更少的内存，尽管如此，我们将其提交，用少量更改购买了大量的剩余空间，并赚取了我们的烤饼。有没有黄油？
- en: Efficient Reading
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高效阅读
- en: 'We would be remiss if we didn’t finish the job and pretend that we also need
    to save memory on reading too. Let’s look at `generate` again:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不完成工作并假装我们也需要在读取时节省内存，那我们就会做得不周全。让我们再看看`generate`：
- en: '[PRE24]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[Example 20.25 [io-to-data.15:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=20.25&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=20.25&show=diff)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 20.25 [io-to-data.15:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=20.25&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=20.25&show=diff)'
- en: 'The pipeline of operations that builds `valuableCustomers` will build intermediate
    `List`s: one for each stage, and each taking up memory. Every line in the input
    is going to be in memory at once, along with a `CustomerData` object for every
    line.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 构建`valuableCustomers`的操作管道将构建中间`List`：每个阶段一个，每个都占用内存。输入中的每一行将一次性全部在内存中，以及每一行都有一个`CustomerData`对象。
- en: 'We can avoid the intermediate collections by reading from a `Sequence`, although
    that will bring a few problems of its own. We can see this if we change the code
    in `generate` to convert the `lines` to a `Sequence` and fix up the methods that
    did take `List`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过从`Sequence`中读取来避免中间集合，尽管这将带来一些自己的问题。如果我们将`generate`中的代码更改为将`lines`转换为`Sequence`并修复接受`List`的方法，我们就可以看到这一点：
- en: '[PRE25]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[Example 20.26 [io-to-data.16:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=20.26&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=20.26&show=diff)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 20.26 [io-to-data.16:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=20.26&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=20.26&show=diff)'
- en: This passes the unit tests. Are we done? Is this another rhetorical question?
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这通过了单元测试。我们完成了吗？这又是一个修辞问题吗？
- en: 'We’ll cut to the chase and say that the issue is that we end up iterating over
    `valuableCustomers` twice, once *before* we return from `generate` in that `sumByDouble`,
    and again *after* we return, when our callers iterate over the returned `Sequence`
    to print the report. If we iterate over a `Sequence` twice, we do all the work
    of creating the `Sequence` twice, in this case: removing the header and mapping
    and filtering and sorting twice. Worse, when we try to use the code in production,
    passing a `Sequence` reading standard input, we won’t be able to iterate over
    that twice, giving an `IllegalState​Excep⁠tion`. As we saw in [Chapter 13](ch13.html#streams-to-sequences),
    instances of `Sequence` differ in ways that aren’t expressed in the type system,
    and they also carry hidden state. Iterating over a `Sequence` looks like iterating
    over a `List` but will change the `Sequence` itself by consuming its contents.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将直截了当地说，问题在于我们最终会在`sumByDouble`中迭代`valuableCustomers`两次，一次是在`generate`中*之前*返回，另一次是我们的调用者迭代返回的`Sequence`以打印报告*之后*。如果我们两次迭代`Sequence`，那么我们将两次完成创建`Sequence`的所有工作，在本例中：两次删除标题、映射和过滤以及排序。更糟糕的是，当我们尝试在生产中使用代码时，传递一个读取标准输入的`Sequence`，我们将无法两次迭代它，导致`IllegalState​Excep⁠tion`。正如我们在[第13章](ch13.html#streams-to-sequences)中看到的那样，`Sequence`的实例在类型系统中未表达的方面有所不同，并且它们还携带隐藏的状态。迭代`Sequence`看起来像迭代`List`，但通过消耗其内容会改变`Sequence`本身。
- en: 'We can show that we are abusing this `Sequence` by adding a `.constrainOnce()`
    call:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过添加`.constrainOnce()`调用来证明我们正在滥用这个`Sequence`：
- en: '[PRE26]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[Example 20.27 [io-to-data.17:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=20.27&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=20.27&show=diff)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 20.27 [io-to-data.17:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=20.27&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=20.27&show=diff)'
- en: 'This will cause our tests to fail with an `IllegalStateException`. The simplest
    fix is to resolve the `Sequence` with a `.toList()` call:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致我们的测试以`IllegalStateException`失败。最简单的修复方法是使用`.toList()`调用解析`Sequence`：
- en: '[PRE27]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[Example 20.28 [io-to-data.18:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=20.28&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=20.28&show=diff)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 20.28 [io-to-data.18:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=20.28&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=20.28&show=diff)'
- en: This terminates the sequence (and hence ultimately reads the whole file) in
    that statement, but at least we run the pipeline only once, and the memory for
    each line can be discarded as soon as it is parsed `toCustomerData`. We will in
    fact have to read through the whole input in this function anyway, because `Sequence.sortedBy`
    needs to read every item to perform the sort—it may return a `Sequence`, but it
    isn’t lazy.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这在该语句中终止了序列（因此最终读取了整个文件），但至少我们只运行了一次管道，并且每行的内存在解析为`toCustomerData`后可以立即丢弃。实际上，在这个函数中，我们确实需要读取整个输入，因为`Sequence.sortedBy`需要读取每个项目来执行排序——它可能返回一个`Sequence`，但它不是惰性的。
- en: 'Now we can replay the “Introduce parameter” refactoring we used at the beginning
    of this chapter. There we converted a `Reader` parameter into a `List`; now we
    convert the `List` to a `Sequence`. The parameter we introduce is the expression
    `lines.as​Se⁠quence().constrainOnce()`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以重播我们在本章开头使用的“引入参数”重构。在那里，我们将`Reader`参数转换为`List`；现在我们将`List`转换为`Sequence`。我们引入的参数是表达式`lines.as​Se⁠quence().constrainOnce()`：
- en: '[PRE28]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[Example 20.29 [io-to-data.19:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=20.29&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=20.29&show=diff)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 20.29 [io-to-data.19:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=20.29&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=20.29&show=diff)'
- en: 'The refactoring pulls the conversion of the `List` to the `Sequence` up into
    the tests:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 重构将`List`到`Sequence`的转换提升到测试中：
- en: '[PRE29]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[Example 20.30 [io-to-data.19:src/test/java/travelator/marketing/HighValueCustomersReportTests.kt]](https://java-to-kotlin.dev/code.html?ref=20.30&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=20.30&show=diff)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 20.30 [io-to-data.19:src/test/java/travelator/marketing/HighValueCustomersReportTests.kt]](https://java-to-kotlin.dev/code.html?ref=20.30&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=20.30&show=diff)'
- en: 'It also pulls it up into `main`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 它也将其提升到`main`中：
- en: '[PRE30]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[Example 20.31 [io-to-data.19:src/main/java/travelator/marketing/HighValueCustomersMain.kt]](https://java-to-kotlin.dev/code.html?ref=20.31&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=20.31&show=diff)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 20.31 [io-to-data.19:src/main/java/travelator/marketing/HighValueCustomersMain.kt]](https://java-to-kotlin.dev/code.html?ref=20.31&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=20.31&show=diff)'
- en: 'This is where we are really able to save memory. Instead of reading all the
    lines at once and converting to a `Sequence`, we can get a `Sequence` from the
    `Reader` with `buffered().lineSequence()`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们真正能够节省内存的地方。我们可以通过`buffered().lineSequence()`从`Reader`获取`Sequence`，而不是一次性读取所有行并转换为`Sequence`：
- en: '[PRE31]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[Example 20.32 [io-to-data.20:src/main/java/travelator/marketing/HighValueCustomersMain.kt]](https://java-to-kotlin.dev/code.html?ref=20.32&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=20.32&show=diff)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 20.32 [io-to-data.20:src/main/java/travelator/marketing/HighValueCustomersMain.kt]](https://java-to-kotlin.dev/code.html?ref=20.32&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=20.32&show=diff)'
- en: Now `generate` will be pulling the lines into memory one by one as it executes
    its pipeline. We’re now really quite efficient in our use of memory and run pleasingly
    quickly. Can we resist one last tinker? How much nicer would `main` read with
    more extension functions?
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`generate`将逐行将行加载到内存中，因为它执行其流水线。我们现在在使用内存方面非常高效并且运行速度令人愉悦。我们能否抵挡最后一次小修补？如果`main`使用更多扩展函数会更好吗？
- en: '[PRE32]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[Example 20.33 [io-to-data.21:src/main/java/travelator/marketing/HighValueCustomersMain.kt]](https://java-to-kotlin.dev/code.html?ref=20.33&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=20.33&show=diff)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 20.33 [io-to-data.21:src/main/java/travelator/marketing/HighValueCustomersMain.kt]](https://java-to-kotlin.dev/code.html?ref=20.33&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=20.33&show=diff)'
- en: 'Which finally answers the question we posed back at the end of [Chapter 10](ch10.html#functions-to-extension-functions):
    yes, we do end up with report generation as an extension function. We love it
    when a plan comes together:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 最终回答了我们在[第10章](ch10.html#functions-to-extension-functions)末尾提出的问题：是的，我们最终将报告生成作为扩展函数。计划成功时我们感到十分满意：
- en: '[PRE33]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[Example 20.34 [io-to-data.21:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=20.34&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=20.34&show=diff)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 20.34 [io-to-data.21:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=20.34&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=20.34&show=diff)'
- en: Moving On
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继续前进
- en: This refactoring was motivated by a desire to simplify our code. By moving I/O
    to the entry point of our program, the inner workings can be calculations rather
    than actions. They can also abdicate responsibility for I/O errors. That was all
    well and good, but calculations take and return values, and forming a value of
    the entire contents of large files is sometimes too much for even today’s computers.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这次重构的动机是为了简化我们的代码。通过将I/O移动到我们程序的入口点，内部工作可以是计算而不是动作。它们还可以放弃对I/O错误的责任。这一切都很好，但是计算需要接收和返回值，而形成大文件整体内容的值有时对今天的计算机来说可能太多了。
- en: To solve this problem, we resorted to converting our `List`s to `Sequence`s.
    Sequences have state and are not values, but with a little care we can treat them
    like lazy values—lazy in that they don’t require or return all their contents
    up front, but can read or supply them on demand. They aren’t as simple as lists,
    but their compatible Kotlin API allows something of the best of both worlds.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们转而将我们的`List`转换为`Sequence`。序列具有状态，不是值，但是通过一些小心处理，我们可以像延迟值一样对待它们——它们不需要或立即返回它们的全部内容，而是可以按需读取或提供它们。它们不像列表那样简单，但它们的兼容Kotlin
    API允许在两个世界中获得最好的东西的某种形式。
- en: Our original `Reader` to `Writer` version of `generate` had to worry about I/O
    errors, whereas the `List` to `List` version moved all I/O to its callers. The
    `Sequence` version is in a middle ground. It doesn’t worry about I/O errors because
    they are hidden from it by the `Sequence` abstractions wrapping the `Reader` and
    `Writer`. That doesn’t mean that they can’t happen, just that `generate` isn’t
    responsible for them. We’ll take a break to see whether our colleagues in marketing
    have any more batter-based rewards before addressing that topic in [Chapter 21,
    *Exceptions to Values*](ch21.html#exceptions-to-values).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最初的`Reader`到`Writer`版本的`generate`需要关注I/O错误，而`List`到`List`版本将所有I/O移到其调用者。`Sequence`版本介于中间。它不需要关注I/O错误，因为`Sequence`抽象封装了`Reader`和`Writer`。这并不意味着它们不可能发生，只是`generate`不负责处理它们。我们将在[第21章，*Values的例外*](ch21.html#exceptions-to-values)中看看我们的市场同事是否有更多基于面糊的奖励，然后再解决这个问题。
