- en: Chapter 20\. Performing I/O to Passing Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Input and output are problematic in code. Our program is subject to errors talking
    to the outside world when files disappear or network sockets fail. I/O is also
    an action and so limits our ability to reason with and refactor our code. How
    can we limit the scope of the problems that I/O causes?
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Now that earlier chapters have built some foundations, we’re going to up the
    pace here, going straight into refactoring and learning lessons as we go.
  prefs: []
  type: TYPE_NORMAL
- en: Listening to Tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 10](ch10.html#functions-to-extension-functions), we looked at some
    Java code that produced a report for marketing. When we left the code, we had
    introduced extension functions to the `HighValue​Custo⁠mersReport`, giving us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 20.1 [io-to-data.0:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=20.1&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=20.1&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the tests after conversion to Kotlin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 20.2 [io-to-data.1:src/test/java/travelator/marketing/HighValueCustomersReportTests.kt]](https://java-to-kotlin.dev/code.html?ref=20.2&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=20.2&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: We didn’t really look at the tests in [Chapter 10](ch10.html#functions-to-extension-functions),
    but if we do now, what stands out in the light of your authors’ obsession with
    actions and calculations ([Chapter 7](ch07.html#actions-to-calculations))? In
    particular, look at that `check` function.
  prefs: []
  type: TYPE_NORMAL
- en: '`check` is evidently not a calculation ([“Calculations”](ch07.html#calculations)),
    because it works entirely by throwing an exception instead of returning a value.
    What if we look at it this way though?'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 20.3 [io-to-data.2:src/test/java/travelator/marketing/HighValueCustomersReportTests.kt]](https://java-to-kotlin.dev/code.html?ref=20.3&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=20.3&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: This is for all intents and purposes the same code, but now we can see that
    we have a calculation, taking `inputLines` and yielding `outputLines`, before
    we go on to the assertion. Even though `generate` is an action, relying on the
    side effects of reading and writing to and from its parameters, we can convert
    it to a calculation by limiting the scope of its side effects to local variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we stop for a moment and listen, we can hear the tests talking to us. They
    are saying, “Look, that report generation is fundamentally a calculation: it converts
    a `List<String>` to a `List<String>`. We know it does, because that’s what we
    are checking.”'
  prefs: []
  type: TYPE_NORMAL
- en: 'So the tests are telling us that the fundamental signature of `generate` is
    `generate(lines: List<String>): List<String>`. If *this* was the signature, then
    it would not have to declare that it throws `IOException` either, because all
    the I/O would happen outside the function. I/O has to happen somewhere, but, in
    common with other actions, the closer to the entry points of our system we can
    move it, the more we can deal in nice easy calculations.'
  prefs: []
  type: TYPE_NORMAL
- en: Shall we refactor toward this goal? You’re right, that was a rhetorical question.
  prefs: []
  type: TYPE_NORMAL
- en: I/O to Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As the first stage in our refactor, let’s try to wean `generate` off its `reader`
    parameter. The code is currently:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 20.4 [io-to-data.3:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=20.4&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=20.4&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can convert `generate` to read from a `List` by invoking “Introduce parameter”
    on the `reader.readLines()` expression, naming the parameter `lines`. Because
    the expression is the only use of the existing `reader` parameter, IntelliJ removes
    `reader` for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 20.5 [io-to-data.4:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=20.5&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=20.5&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The refactoring has moved the `readLines()` out into the callers; here is the
    result in test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 20.6 [io-to-data.4:src/test/java/travelator/marketing/HighValueCustomersReportTests.kt]](https://java-to-kotlin.dev/code.html?ref=20.6&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=20.6&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'This now shouts what the test was whispering all along. We were having to create
    a `StringReader` from a list of lines just to parse the lines back out in `generate`.
    Now that the steps are in the same place in the test, we can elide them to remove
    the `Reader`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 20.7 [io-to-data.5:src/test/java/travelator/marketing/HighValueCustomersReportTests.kt]](https://java-to-kotlin.dev/code.html?ref=20.7&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=20.7&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now reading from a `List`. Let’s go back and look at how to return a
    `List` too, rather than modifying the `Writer`. Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 20.8 [io-to-data.5:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=20.8&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=20.8&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of thinking imperatively about the ways that we want to mutate `Writer`,
    let’s think in terms of the data that we want written and create that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 20.9 [io-to-data.6:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=20.9&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=20.9&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we can write it in one lump to `writer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 20.10 [io-to-data.6:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=20.10&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=20.10&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'This function is now two statements that make up a calculation, and a final
    action taking the result of the calculation. If we now “Extract function” with
    the calculation lines, making it public and calling it `generate` too, we get
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 20.11 [io-to-data.7:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=20.11&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=20.11&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inlining both vestigial `resultLines` gives:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 20.12 [io-to-data.8:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=20.12&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=20.12&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'One more inline then, this time of the old `generate` function. That replaces
    its invocation in client code, leaving this in the test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 20.13 [io-to-data.9:src/test/java/travelator/marketing/HighValueCustomersReportTests.kt]](https://java-to-kotlin.dev/code.html?ref=20.13&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=20.13&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'This refactor has moved the action part of `generate` out a level, leaving
    the nice pure calculation bits in its place. Another way of looking at this is
    that our original `Writer` was an accumulating object, which we have replaced
    with a transformation, as we saw in [Chapter 14](ch14.html#accumulating-objects-to-transformations).
    Our tests didn’t really want to be testing an action anyway, so they again have
    redundant I/O, which we can simplify to the form we were aiming for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 20.14 [io-to-data.10:src/test/java/travelator/marketing/HighValueCustomersReportTests.kt]](https://java-to-kotlin.dev/code.html?ref=20.14&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=20.14&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take stock of our new `generate`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 20.15 [io-to-data.11:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=20.15&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=20.15&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that `generate` is doing so much less, it isn’t clear that the function
    `toValuable​Cus⁠tomers()` is worthwhile. Looking at it afresh, we see that it
    is working at mixed levels, converting and filtering. Let’s try inlining it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 20.16 [io-to-data.12:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=20.16&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=20.16&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: That’s better. The local variable `valuableCustomers` does a good job of telling
    us what the expression means, and the list operations spell out the implementation
    in place. This function is a case where a single-expression function ([Chapter 9](ch09.html#multi-to-single-expression-functions))
    would probably make things worse, so we’ll leave it in two parts. We’ll also continue
    to resist the temptation to make it an extension function, `List<String>.toReport()`,
    at least for now.
  prefs: []
  type: TYPE_NORMAL
- en: Efficient Writing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’re quite pleased with this refactor. It has simplified our tests and the
    production code, and we have moved from mixing I/O and logic to a simpler calculation
    with no side effects.
  prefs: []
  type: TYPE_NORMAL
- en: For a while, all is fine in production too, but with the easing of COVID-19
    travel restrictions, Travelator becomes the roaring success that we all knew it
    would be. Eventually, though, the lovely people in marketing start complaining
    that the report generation is failing with an `OutOfMemoryError`. Could we look
    into it?
  prefs: []
  type: TYPE_NORMAL
- en: (Apart from running out of memory, we have had two other issues with errors
    in this code in living memory. Both these times, the input file turned out to
    have been malformed, but marketing sit next door and just call us over to help
    if these occur. They feed us cake in these cases, so we’re hardly incentivized
    to do a better job of error handling for now (but see [Chapter 21](ch21.html#exceptions-to-values)).
    If we can fix the `OutOfMemoryError` quickly, we think we saw some crumpets…)
  prefs: []
  type: TYPE_NORMAL
- en: 'We haven’t bothered you with the details so far, but there is a `main` method
    that invokes our report. It is designed to be invoked with shell redirection,
    reading from a file piped as the standard input and writing to a file collected
    from the standard output. This way, our process doesn’t have to read filenames
    from the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 20.17 [io-to-data.0:src/main/java/travelator/marketing/HighValueCustomersMain.kt]](https://java-to-kotlin.dev/code.html?ref=20.17&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=20.17&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'When we refactored `generate` to work with `List`s rather than a `Reader` and
    `Writer`, IntelliJ automatically updated `main` to yield:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 20.18 [io-to-data.9:src/main/java/travelator/marketing/HighValueCustomersMain.kt]](https://java-to-kotlin.dev/code.html?ref=20.18&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=20.18&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: Ah, there’s our problem. We’re reading the whole of the input into memory (`readLines()`),
    processing it, and then creating the entire output in memory (`joinToString()`)
    before writing it back out.
  prefs: []
  type: TYPE_NORMAL
- en: We sometimes run into problems like these with functional decomposition. In
    this case the original `Reader` and `Writer` code did not have this issue, so
    we have brought it on ourselves in the name of good style. We could quickly revert
    our changes and go and see whether there are any crumpets left, or we could find
    a more functional solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s go back to `generate` and see what leeway we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 20.19 [io-to-data.12:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=20.19&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=20.19&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: Concentrating on the output for now, we can see that we are building a `List`
    of the lines of the output; `main` then takes each `String` in the result and
    creates one giant one with `joinToString()`. At this point both the individual
    output lines and their conglomerate will be taking up memory. To avoid running
    out of memory, we’ll need to defer the creation of the intermediate collections,
    and, as we saw in [Chapter 13](ch13.html#streams-to-sequences), `Sequence`s are
    designed for just that.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can convert `generate` to return a `Sequence` methodically or quickly. For
    once, we’ll choose quickly and just replace `listOf` with `sequenceOf` in our
    `return` expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 20.20 [io-to-data.13:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=20.20&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=20.20&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: Now we will only be creating the output lines one at a time when the `Sequence`
    is iterated; each line can be disposed of quickly rather than hanging around until
    we have written the whole file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The tests have to change to convert the returned `Sequence` to a `List`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 20.21 [io-to-data.13:src/test/java/travelator/marketing/HighValueCustomersReportTests.kt]](https://java-to-kotlin.dev/code.html?ref=20.21&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=20.21&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Interestingly, though, `main` does not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 20.22 [io-to-data.13:src/main/java/travelator/marketing/HighValueCustomersMain.kt]](https://java-to-kotlin.dev/code.html?ref=20.22&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=20.22&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: '`main` needs to be *recompiled* now that `generate` returns a `Sequence` rather
    than a `List`, but its *source* doesn’t need to be changed. This is because there
    are extension functions `joinToString()` defined on both `Iterable` and `Sequence`,
    both returning `String`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It might not *need* to change, but unless `main` *does* change, we are still
    creating one large string of all the output before writing it in one operation.
    To avoid that, we need to get imperative again and write each output line individually,
    as our original `generate` had done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 20.23 [io-to-data.14:src/main/java/travelator/marketing/HighValueCustomersMain.kt]](https://java-to-kotlin.dev/code.html?ref=20.23&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=20.23&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: The pedantic reader (don’t worry, you’re among friends) will have spotted that
    this behavior is subtly different from the `joinToString("\n")` version. We’re
    quietly confident that a trailing newline won’t break anything, so we press on.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can always pretend we aren’t looping by hiding the iteration inside a `Writer::appendLines`
    extension function that we assumed the Kotlin standard library would define, but
    doesn’t seem to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 20.24 [io-to-data.15:src/main/java/travelator/marketing/HighValueCustomersMain.kt]](https://java-to-kotlin.dev/code.html?ref=20.24&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=20.24&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: Note that although the definition of `Writer::appendLines` is a single expression,
    we agreed in [Chapter 9](ch09.html#multi-to-single-expression-functions) to use
    the long form where functions are actions, and `appendLines` is definitely that.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are here, we realize that we could have postponed our memory crisis
    by just iterating over the original result `List` in `main`, writing each line
    individually, as we are doing now with the `Sequence`. This solution will use
    even less memory, though, so we’ll commit it, having bought ourselves lots of
    headroom with few changes and earned our crumpets. Is there any butter?
  prefs: []
  type: TYPE_NORMAL
- en: Efficient Reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We would be remiss if we didn’t finish the job and pretend that we also need
    to save memory on reading too. Let’s look at `generate` again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 20.25 [io-to-data.15:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=20.25&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=20.25&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The pipeline of operations that builds `valuableCustomers` will build intermediate
    `List`s: one for each stage, and each taking up memory. Every line in the input
    is going to be in memory at once, along with a `CustomerData` object for every
    line.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can avoid the intermediate collections by reading from a `Sequence`, although
    that will bring a few problems of its own. We can see this if we change the code
    in `generate` to convert the `lines` to a `Sequence` and fix up the methods that
    did take `List`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 20.26 [io-to-data.16:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=20.26&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=20.26&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: This passes the unit tests. Are we done? Is this another rhetorical question?
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll cut to the chase and say that the issue is that we end up iterating over
    `valuableCustomers` twice, once *before* we return from `generate` in that `sumByDouble`,
    and again *after* we return, when our callers iterate over the returned `Sequence`
    to print the report. If we iterate over a `Sequence` twice, we do all the work
    of creating the `Sequence` twice, in this case: removing the header and mapping
    and filtering and sorting twice. Worse, when we try to use the code in production,
    passing a `Sequence` reading standard input, we won’t be able to iterate over
    that twice, giving an `IllegalState​Excep⁠tion`. As we saw in [Chapter 13](ch13.html#streams-to-sequences),
    instances of `Sequence` differ in ways that aren’t expressed in the type system,
    and they also carry hidden state. Iterating over a `Sequence` looks like iterating
    over a `List` but will change the `Sequence` itself by consuming its contents.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can show that we are abusing this `Sequence` by adding a `.constrainOnce()`
    call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 20.27 [io-to-data.17:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=20.27&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=20.27&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'This will cause our tests to fail with an `IllegalStateException`. The simplest
    fix is to resolve the `Sequence` with a `.toList()` call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 20.28 [io-to-data.18:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=20.28&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=20.28&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: This terminates the sequence (and hence ultimately reads the whole file) in
    that statement, but at least we run the pipeline only once, and the memory for
    each line can be discarded as soon as it is parsed `toCustomerData`. We will in
    fact have to read through the whole input in this function anyway, because `Sequence.sortedBy`
    needs to read every item to perform the sort—it may return a `Sequence`, but it
    isn’t lazy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can replay the “Introduce parameter” refactoring we used at the beginning
    of this chapter. There we converted a `Reader` parameter into a `List`; now we
    convert the `List` to a `Sequence`. The parameter we introduce is the expression
    `lines.as​Se⁠quence().constrainOnce()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 20.29 [io-to-data.19:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=20.29&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=20.29&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The refactoring pulls the conversion of the `List` to the `Sequence` up into
    the tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 20.30 [io-to-data.19:src/test/java/travelator/marketing/HighValueCustomersReportTests.kt]](https://java-to-kotlin.dev/code.html?ref=20.30&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=20.30&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'It also pulls it up into `main`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 20.31 [io-to-data.19:src/main/java/travelator/marketing/HighValueCustomersMain.kt]](https://java-to-kotlin.dev/code.html?ref=20.31&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=20.31&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is where we are really able to save memory. Instead of reading all the
    lines at once and converting to a `Sequence`, we can get a `Sequence` from the
    `Reader` with `buffered().lineSequence()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 20.32 [io-to-data.20:src/main/java/travelator/marketing/HighValueCustomersMain.kt]](https://java-to-kotlin.dev/code.html?ref=20.32&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=20.32&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: Now `generate` will be pulling the lines into memory one by one as it executes
    its pipeline. We’re now really quite efficient in our use of memory and run pleasingly
    quickly. Can we resist one last tinker? How much nicer would `main` read with
    more extension functions?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 20.33 [io-to-data.21:src/main/java/travelator/marketing/HighValueCustomersMain.kt]](https://java-to-kotlin.dev/code.html?ref=20.33&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=20.33&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Which finally answers the question we posed back at the end of [Chapter 10](ch10.html#functions-to-extension-functions):
    yes, we do end up with report generation as an extension function. We love it
    when a plan comes together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 20.34 [io-to-data.21:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=20.34&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=20.34&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: Moving On
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This refactoring was motivated by a desire to simplify our code. By moving I/O
    to the entry point of our program, the inner workings can be calculations rather
    than actions. They can also abdicate responsibility for I/O errors. That was all
    well and good, but calculations take and return values, and forming a value of
    the entire contents of large files is sometimes too much for even today’s computers.
  prefs: []
  type: TYPE_NORMAL
- en: To solve this problem, we resorted to converting our `List`s to `Sequence`s.
    Sequences have state and are not values, but with a little care we can treat them
    like lazy values—lazy in that they don’t require or return all their contents
    up front, but can read or supply them on demand. They aren’t as simple as lists,
    but their compatible Kotlin API allows something of the best of both worlds.
  prefs: []
  type: TYPE_NORMAL
- en: Our original `Reader` to `Writer` version of `generate` had to worry about I/O
    errors, whereas the `List` to `List` version moved all I/O to its callers. The
    `Sequence` version is in a middle ground. It doesn’t worry about I/O errors because
    they are hidden from it by the `Sequence` abstractions wrapping the `Reader` and
    `Writer`. That doesn’t mean that they can’t happen, just that `generate` isn’t
    responsible for them. We’ll take a break to see whether our colleagues in marketing
    have any more batter-based rewards before addressing that topic in [Chapter 21,
    *Exceptions to Values*](ch21.html#exceptions-to-values).
  prefs: []
  type: TYPE_NORMAL
