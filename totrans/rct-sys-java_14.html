<html><head></head><body><section data-pdf-bookmark="Chapter 10. Reactive Messaging: The Connective Tissue" data-type="chapter" epub:type="chapter"><div class="chapter" id="messaging">&#13;
<h1><span class="label">Chapter 10. </span>Reactive Messaging: The Connective Tissue</h1>&#13;
&#13;
&#13;
<p><a data-primary="Reactive Messaging" data-type="indexterm" id="ix_messaging-adoc0"/><a data-primary="reactive systems" data-secondary="Reactive Messaging and" data-type="indexterm" id="ix_messaging-adoc1"/>In <a data-type="xref" href="part03.html#quarkus-part">Part III</a>, you saw many features to develop reactive applications with Quarkus.&#13;
But, as you remember from <a data-type="xref" href="part02.html#reactive-part">Part II</a>, we don’t want to limit ourselves to reactive applications; we want to build reactive systems.&#13;
That’s what we are going to do now.</p>&#13;
&#13;
<p>Reactive systems use asynchronous message passing among their components.&#13;
However, while middleware and frameworks can sometimes hide this message-passing aspect, we believe it’s far more efficient to make it apparent.&#13;
It not only helps you write event-driven code (<em>on event x, do y</em>), but also helps decompose your application into a set of components receiving and producing messages.&#13;
Thus, Quarkus offers a message-driven development model that is simple but powerful to consume, process, and create messages.&#13;
This chapter focuses on this model, how it relates to Reactive Streams, and how it makes building message-driven and event-driven applications straightforward.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="From Reactive Applications to Reactive Systems" data-type="sect1"><div class="sect1" id="idm45358821113440">&#13;
<h1>From Reactive Applications to Reactive Systems</h1>&#13;
&#13;
<p>When you talk to a Java developer about messaging, you can feel the frustration.&#13;
<a data-primary="JMS (Java Message Service)" data-type="indexterm" id="idm45358821111872"/>For years, JMS has been the de facto standard for messaging.&#13;
However, that API didn’t age well, and new messaging technologies such as Kafka and Pulsar use concepts that do not work well with JMS.&#13;
In addition, JMS is a blocking API, which prevents us from implementing reactive principles.</p>&#13;
&#13;
<p>While Quarkus can use JMS, we are going to look at another approach called <em>Reactive Messaging</em>.&#13;
This MicroProfile specification builds reactive and event-driven applications.&#13;
Quarkus implements version 2<em>.x</em> of the specification but also provides many extensions.</p>&#13;
&#13;
<p>Applications using Reactive Messaging can send, consume, and process messages in a protocol-agnostic way.&#13;
For example, as you will see in <a data-type="xref" href="ch11.html#event-bus">Chapter 11</a>, you will be able to use Apache Kafka or AMQP or even combine both.&#13;
Reactive Messaging also provides a natural development model for developers used to Contexts and Dependency Injection (CDI), a standard dependency injection framework.&#13;
Typically, you can summarize Reactive Messaging to a couple of annotations.&#13;
But before seeing it in action, let’s describe a few concepts that it relies on.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Channels and Messages" data-type="sect2"><div class="sect2" id="idm45358821107728">&#13;
<h2>Channels and Messages</h2>&#13;
&#13;
<p><a data-primary="Reactive Messaging" data-secondary="channels and messages" data-type="indexterm" id="idm45358821106480"/>When using Reactive Messaging, your applications and components forming them interact using <em>messages</em>, represented with the <code>o⁠r⁠g.e⁠c⁠l⁠i⁠p⁠s⁠e.m⁠i⁠c⁠r⁠o⁠p⁠r⁠o⁠f⁠i⁠l⁠e⁠.​r⁠e⁠a⁠c⁠t⁠i⁠v⁠e⁠.m⁠e⁠s⁠s⁠a⁠g⁠i⁠n⁠g⁠.M⁠e⁠s⁠s⁠a⁠g⁠e⁠&lt;T&gt;</code> class.&#13;
<a data-primary="messages" data-secondary="defined" data-type="indexterm" id="idm45358821104192"/>A <em>message</em> is an envelope that has a payload of type <code>T</code>.&#13;
In addition, a message can have metadata and provides acknowledgment methods to notify the framework of the successful or failed processing of a message.</p>&#13;
&#13;
<p><a data-primary="channels, defined" data-type="indexterm" id="idm45358821102144"/>Messages transit on <em>channels</em>.&#13;
You can picture channels as pipes.&#13;
A channel can be internal to an application or mapped, by a connector, to an external message queue or topic (<a data-type="xref" href="#image:channels">Figure 10-1</a>).</p>&#13;
&#13;
<figure><div class="figure" id="image:channels">&#13;
<img alt="Message-based Application Architecture" src="assets/rsij_1001.png"/>&#13;
<h6><span class="label">Figure 10-1. </span>Message-based application architecture</h6>&#13;
</div></figure>&#13;
&#13;
<p>Your application reads from channels and writes to channels.&#13;
You can split your application into a set of components, with all of them reading and writing to different channels.&#13;
That’s it. Reactive Messaging binds everything all together, and so constructs streams in which messages flow.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Producing Messages" data-type="sect2"><div class="sect2" id="idm45358821097568">&#13;
<h2>Producing Messages</h2>&#13;
&#13;
<p><a data-primary="messages" data-secondary="producing" data-type="indexterm" id="ix_messaging-adoc2"/><a data-primary="Reactive Messaging" data-secondary="producing messages" data-type="indexterm" id="ix_messaging-adoc3"/>Reactive Messaging provides multiple ways to produce messages, but let’s start with the simplest and probably more natural one for developers familiar with imperative programming: emitters.&#13;
<a data-primary="emitters" data-type="indexterm" id="idm45358821093008"/><code>Emitter</code> is an object that is attached to a channel and emits messages to that channel.<sup><a data-type="noteref" href="ch10.html#idm45358821092016" id="idm45358821092016-marker">1</a></sup>&#13;
<a data-type="xref" href="#messaging::emitter">Example 10-1</a> illustrates the use of <code>MutinyEmitter</code>.</p>&#13;
<div data-type="example" id="messaging::emitter">&#13;
<h5><span class="label">Example 10-1. </span>Use an emitter to send messages</h5>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="nd">@Channel</code><code class="o">(</code><code class="s">"my-channel"</code><code class="o">)</code>&#13;
<code class="n">MutinyEmitter</code><code class="o">&lt;</code><code class="n">Person</code><code class="o">&gt;</code> <code class="n">personEmitter</code><code class="o">;</code>&#13;
&#13;
<code class="kd">public</code> <code class="n">Uni</code><code class="o">&lt;</code><code class="n">Void</code><code class="o">&gt;</code> <code class="nf">send</code><code class="o">(</code><code class="n">Person</code> <code class="n">p</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="k">return</code> <code class="n">personEmitter</code><code class="o">.</code><code class="na">send</code><code class="o">(</code><code class="n">p</code><code class="o">);</code>&#13;
<code class="o">}</code></pre></div>&#13;
&#13;
<p>To access an emitter, you just inject it in your CDI bean.&#13;
The target channel is indicated using the <code>@Channel</code> annotation.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>There’s no need to use the <code>@Inject</code> annotation, as Quarkus detects the injection for you.</p>&#13;
</div>&#13;
&#13;
<p>In <a data-type="xref" href="#messaging::emitter">Example 10-1</a>, we don’t produce a <code>Message</code> instance; we just send a payload (<code>Person</code>), automatically wrapped into a message.&#13;
Note that the <code>send</code> method returns <code>Uni&lt;Void&gt;</code>.&#13;
This <code>Uni</code> produces a <code>null</code> item when the message processing completes successfully.&#13;
Otherwise, it produces a failure indicating why the processing failed.</p>&#13;
&#13;
<p>An emitter can also send an instance of <code>Message</code> directly, as shown in <a data-type="xref" href="#messaging::emitter-message">Example 10-2</a>.</p>&#13;
<div data-type="example" id="messaging::emitter-message">&#13;
<h5><span class="label">Example 10-2. </span>Injection and use of an emitter</h5>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="nd">@Channel</code><code class="o">(</code><code class="s">"my-second-channel"</code><code class="o">)</code>&#13;
<code class="n">MutinyEmitter</code><code class="o">&lt;</code><code class="n">Person</code><code class="o">&gt;</code> <code class="n">messageEmitter</code><code class="o">;</code>&#13;
&#13;
<code class="kd">public</code> <code class="kt">void</code> <code class="nf">sendMessage</code><code class="o">(</code><code class="n">Person</code> <code class="n">p</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="n">messageEmitter</code><code class="o">.</code><code class="na">send</code><code class="o">(</code>&#13;
            <code class="n">Message</code><code class="o">.</code><code class="na">of</code><code class="o">(</code><code class="n">p</code><code class="o">,</code>&#13;
                    <code class="o">()</code> <code class="o">-&gt;</code> <code class="o">{</code>&#13;
                        <code class="c1">// Acknowledgment callback</code>&#13;
                        <code class="k">return</code> <code class="n">CompletableFuture</code><code class="o">.</code><code class="na">completedFuture</code><code class="o">(</code><code class="kc">null</code><code class="o">);</code>&#13;
                    <code class="o">},</code>&#13;
                    <code class="n">failure</code> <code class="o">-&gt;</code> <code class="o">{</code>&#13;
                        <code class="c1">// Negative-acknowledgment callback</code>&#13;
                        <code class="k">return</code> <code class="n">CompletableFuture</code><code class="o">.</code><code class="na">completedFuture</code><code class="o">(</code><code class="kc">null</code><code class="o">);</code>&#13;
                    <code class="o">})</code>&#13;
    <code class="o">);</code>&#13;
<code class="o">}</code></pre></div>&#13;
&#13;
<p>When sending a <code>Message</code>, you can directly pass the acknowledgment callbacks.&#13;
We cover acknowledgment in <a data-type="xref" href="#acknowledgements_aspect">“Acknowledgments”</a>.</p>&#13;
&#13;
<p>Emitters are convenient when you want to decide when to send a message.&#13;
They allow imperative code to emit messages that will be handled in a reactive manner.&#13;
For example, you can use an emitter in an HTTP endpoint and send a message when you receive a request.</p>&#13;
&#13;
<p><a data-primary="@Outgoing annotation" data-type="indexterm" id="idm45358820934944"/>Another way to produce messages is with the <code>@Outgoing</code> annotation.&#13;
It instructs Reactive Messaging to send the output of the method to the specified channel.&#13;
Note that methods annotated with <code>@Outgoing</code> can’t be called from your code; Reactive Messaging calls them for you.&#13;
You may wonder about the benefits.&#13;
It looks a bit less flexible than emitters.&#13;
But there is a trick: <code>@Outgoing</code> allows producing streams (<code>Multi</code>) directly (<a data-type="xref" href="#messaging:outgoing">Example 10-3</a>).</p>&#13;
<div data-type="example" id="messaging:outgoing">&#13;
<h5><span class="label">Example 10-3. </span>Usage of <code>@Outgoing</code></h5>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="nd">@Outgoing</code><code class="o">(</code><code class="s">"my-channel"</code><code class="o">)</code>&#13;
<code class="n">Multi</code><code class="o">&lt;</code><code class="n">Person</code><code class="o">&gt;</code> <code class="nf">produceAStreamOfPersons</code><code class="o">()</code> <code class="o">{</code>&#13;
    <code class="k">return</code> <code class="n">Multi</code><code class="o">.</code><code class="na">createFrom</code><code class="o">().</code><code class="na">items</code><code class="o">(</code>&#13;
            <code class="k">new</code> <code class="nf">Person</code><code class="o">(</code><code class="s">"Luke"</code><code class="o">),</code>&#13;
            <code class="k">new</code> <code class="nf">Person</code><code class="o">(</code><code class="s">"Leia"</code><code class="o">),</code>&#13;
            <code class="k">new</code> <code class="nf">Person</code><code class="o">(</code><code class="s">"Obiwan"</code><code class="o">)</code>&#13;
    <code class="o">);</code>&#13;
<code class="o">}</code></pre></div>&#13;
&#13;
<p>You can produce infinite streams every second, as demonstrated in <a data-type="xref" href="#messaging:outgoing-infinite">Example 10-4</a>.</p>&#13;
<div data-type="example" id="messaging:outgoing-infinite">&#13;
<h5><span class="label">Example 10-4. </span>Generate infinite streams by using <code>@Outgoing</code></h5>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="nd">@Outgoing</code><code class="o">(</code><code class="s">"ticks"</code><code class="o">)</code>&#13;
<code class="n">Multi</code><code class="o">&lt;</code><code class="n">Long</code><code class="o">&gt;</code> <code class="nf">ticks</code><code class="o">()</code> <code class="o">{</code>&#13;
    <code class="k">return</code> <code class="n">Multi</code><code class="o">.</code><code class="na">createFrom</code><code class="o">().</code><code class="na">ticks</code><code class="o">()</code>&#13;
            <code class="o">.</code><code class="na">every</code><code class="o">(</code><code class="n">Duration</code><code class="o">.</code><code class="na">ofSeconds</code><code class="o">(</code><code class="mi">1</code><code class="o">))</code>&#13;
            <code class="o">.</code><code class="na">onOverflow</code><code class="o">().</code><code class="na">drop</code><code class="o">();</code>&#13;
<code class="o">}</code></pre></div>&#13;
&#13;
<p>When the application starts, Reactive Messaging connects all the elements to the channels.&#13;
Under the hood, it creates reactive streams (covered in <a data-type="xref" href="ch05.html#reactive-programming">Chapter 5</a>).&#13;
So, your application is a set of reactive streams, enforcing the backpressure protocol.&#13;
The &#13;
<span class="keep-together">consumption</span> rate is controlled by the downstream subscribers.&#13;
This is the reason we need <code>onOverflow.drop</code> in the preceding example.&#13;
Otherwise, if the downstream subscriber does not consume fast enough, it would fail (you can’t apply backpressure in time).</p>&#13;
&#13;
<p>As for <code>Emitter</code>, you can produce a stream of messages (<a data-type="xref" href="#messaging:outgoing-message">Example 10-5</a>).</p>&#13;
<div data-type="example" id="messaging:outgoing-message">&#13;
<h5><span class="label">Example 10-5. </span>Produce a stream of messages by using <code>@Outgoing</code></h5>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="nd">@Outgoing</code><code class="o">(</code><code class="s">"my-channel"</code><code class="o">)</code>&#13;
<code class="n">Multi</code><code class="o">&lt;</code><code class="n">Message</code><code class="o">&lt;</code><code class="n">Person</code><code class="o">&gt;&gt;</code> <code class="nf">produceAStreamOfMessagesOfPersons</code><code class="o">()</code> <code class="o">{</code>&#13;
    <code class="k">return</code> <code class="n">Multi</code><code class="o">.</code><code class="na">createFrom</code><code class="o">().</code><code class="na">items</code><code class="o">(</code>&#13;
            <code class="n">Message</code><code class="o">.</code><code class="na">of</code><code class="o">(</code><code class="k">new</code> <code class="n">Person</code><code class="o">(</code><code class="s">"Luke"</code><code class="o">)),</code>&#13;
            <code class="n">Message</code><code class="o">.</code><code class="na">of</code><code class="o">(</code><code class="k">new</code> <code class="n">Person</code><code class="o">(</code><code class="s">"Leia"</code><code class="o">)),</code>&#13;
            <code class="n">Message</code><code class="o">.</code><code class="na">of</code><code class="o">(</code><code class="k">new</code> <code class="n">Person</code><code class="o">(</code><code class="s">"Obiwan"</code><code class="o">))</code>&#13;
    <code class="o">);</code>&#13;
<code class="o">}</code></pre></div>&#13;
&#13;
<p>Here, our messages are just wrapping the payload.&#13;
As we have seen in the example, you can pass the acknowledgment callbacks.</p>&#13;
&#13;
<p>Attentive readers may have observed a significant difference between the emitter and the <code>@Outgoing</code> approaches.&#13;
Reactive Messaging handles the <code>@Outgoing</code> method completely (invoking it), so enforcing the backpressure protocol is no problem.&#13;
But with the emitter, Reactive Messaging can’t.&#13;
If your code uses an emitter to send messages faster than the consumption rate, you may be in trouble!</p>&#13;
&#13;
<p>Fortunately, to avoid this, you can configure an overflow strategy when using an emitter.&#13;
This strategy describes what happens when the downstream does not consume fast enough.&#13;
<code>@OnOverflow</code> offers six strategies.&#13;
The most common, demonstrated in <a data-type="xref" href="#messaging:onoverflow">Example 10-6</a>, consists of using a buffer.</p>&#13;
<div data-type="example" id="messaging:onoverflow">&#13;
<h5><span class="label">Example 10-6. </span>Usage of the <code>@OnOverflow</code> annotation</h5>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="nd">@Channel</code><code class="o">(</code><code class="s">"channel"</code><code class="o">)</code>&#13;
<code class="nd">@OnOverflow</code><code class="o">(</code><code class="n">value</code> <code class="o">=</code> <code class="n">OnOverflow</code><code class="o">.</code><code class="na">Strategy</code><code class="o">.</code><code class="na">BUFFER</code><code class="o">,</code> <code class="n">bufferSize</code> <code class="o">=</code> <code class="mi">100</code><code class="o">)</code>&#13;
<code class="n">MutinyEmitter</code><code class="o">&lt;</code><code class="n">Person</code><code class="o">&gt;</code> <code class="n">emitterUsingABufferOnOverflow</code><code class="o">;</code>&#13;
&#13;
<code class="nd">@Channel</code><code class="o">(</code><code class="s">"channel"</code><code class="o">)</code>&#13;
<code class="nd">@OnOverflow</code><code class="o">(</code><code class="n">value</code> <code class="o">=</code> <code class="n">OnOverflow</code><code class="o">.</code><code class="na">Strategy</code><code class="o">.</code><code class="na">UNBOUNDED_BUFFER</code><code class="o">)</code>&#13;
<code class="n">MutinyEmitter</code><code class="o">&lt;</code><code class="n">Person</code><code class="o">&gt;</code> <code class="n">emitterUsingAnUnboundedOnOverflow</code><code class="o">;</code>&#13;
&#13;
<code class="nd">@Channel</code><code class="o">(</code><code class="s">"channel"</code><code class="o">)</code>&#13;
<code class="nd">@OnOverflow</code><code class="o">(</code><code class="n">value</code> <code class="o">=</code> <code class="n">OnOverflow</code><code class="o">.</code><code class="na">Strategy</code><code class="o">.</code><code class="na">DROP</code><code class="o">)</code>&#13;
<code class="n">MutinyEmitter</code><code class="o">&lt;</code><code class="n">Person</code><code class="o">&gt;</code> <code class="n">emitterDroppingMessageOnOverflow</code><code class="o">;</code>&#13;
&#13;
<code class="nd">@Channel</code><code class="o">(</code><code class="s">"channel"</code><code class="o">)</code>&#13;
<code class="nd">@OnOverflow</code><code class="o">(</code><code class="n">value</code> <code class="o">=</code> <code class="n">OnOverflow</code><code class="o">.</code><code class="na">Strategy</code><code class="o">.</code><code class="na">LATEST</code><code class="o">)</code>&#13;
<code class="n">MutinyEmitter</code><code class="o">&lt;</code><code class="n">Person</code><code class="o">&gt;</code> <code class="n">emitterDroppingOlderMessagesOnOverflow</code><code class="o">;</code>&#13;
&#13;
<code class="nd">@Channel</code><code class="o">(</code><code class="s">"channel"</code><code class="o">)</code>&#13;
<code class="nd">@OnOverflow</code><code class="o">(</code><code class="n">value</code> <code class="o">=</code> <code class="n">OnOverflow</code><code class="o">.</code><code class="na">Strategy</code><code class="o">.</code><code class="na">FAIL</code><code class="o">)</code>&#13;
<code class="n">MutinyEmitter</code><code class="o">&lt;</code><code class="n">Person</code><code class="o">&gt;</code> <code class="n">emitterSendingAFailureDownstreamOnOverflow</code><code class="o">;</code>&#13;
&#13;
<code class="nd">@Channel</code><code class="o">(</code><code class="s">"channel"</code><code class="o">)</code>&#13;
<code class="nd">@OnOverflow</code><code class="o">(</code><code class="n">value</code> <code class="o">=</code> <code class="n">OnOverflow</code><code class="o">.</code><code class="na">Strategy</code><code class="o">.</code><code class="na">THROW_EXCEPTION</code><code class="o">)</code>&#13;
<code class="n">MutinyEmitter</code><code class="o">&lt;</code><code class="n">Person</code><code class="o">&gt;</code> <code class="n">emitterThrowingExceptionUpstreamOnOverflow</code><code class="o">;</code></pre></div>&#13;
&#13;
<p>The <code>OnOverflow</code> strategies are similar to those in Mutiny:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><code>BUFFER</code>, the default, uses a buffer to store the messages. The size can be configured; the default is 256.</p>&#13;
</li>&#13;
<li>&#13;
<p><code>UNBOUNDED_BUFFER</code> is like <code>BUFFER</code> but uses an unbounded buffer. Be cautious when using this strategy as it can lead to memory issues.</p>&#13;
</li>&#13;
<li>&#13;
<p><code>DROP</code> and <code>LATEST</code> drop the newest and oldest message, respectively.</p>&#13;
</li>&#13;
<li>&#13;
<p><code>FAIL</code> sends a failure downstream. Remember, failures are terminal for Reactive Streams. So, you can use the emitter after this.</p>&#13;
</li>&#13;
<li>&#13;
<p><code>THROW_EXCEPTION</code> throws an exception upstream to the caller of the <code>send</code> method. The caller can then react; for example, it can’t wait until the downstream subscriber catches up.<a data-startref="ix_messaging-adoc3" data-type="indexterm" id="idm45358820529472"/><a data-startref="ix_messaging-adoc2" data-type="indexterm" id="idm45358820528768"/></p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Consuming Messages" data-type="sect2"><div class="sect2" id="idm45358821096656">&#13;
<h2>Consuming Messages</h2>&#13;
&#13;
<p><a data-primary="messages" data-secondary="consuming" data-type="indexterm" id="ix_messaging-adoc4"/><a data-primary="Reactive Messaging" data-secondary="consuming messages" data-type="indexterm" id="ix_messaging-adoc5"/>Let’s have a look at the other side of the message pipe.&#13;
<a data-primary="@Channel annotation" data-type="indexterm" id="idm45358820524240"/>To consume messages, you can inject the stream by using the <code>@Channel</code> annotation, as shown in <a data-type="xref" href="#messaging:channel">Example 10-7</a>.</p>&#13;
<div data-type="example" id="messaging:channel">&#13;
<h5><span class="label">Example 10-7. </span>Inject a channel</h5>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="nd">@Channel</code><code class="o">(</code><code class="s">"my-channel"</code><code class="o">)</code>&#13;
<code class="n">Multi</code><code class="o">&lt;</code><code class="n">Person</code><code class="o">&gt;</code> <code class="n">streamOfPersons</code><code class="o">;</code>&#13;
&#13;
<code class="c1">// ...</code>&#13;
&#13;
<code class="kt">void</code> <code class="nf">init</code><code class="o">()</code> <code class="o">{</code>&#13;
    <code class="n">streamOfPersons</code>&#13;
            <code class="o">.</code><code class="na">subscribe</code><code class="o">().</code><code class="na">with</code><code class="o">(</code>&#13;
                    <code class="n">person</code> <code class="o">-&gt;</code> <code class="o">{</code> <code class="cm">/* ... */</code> <code class="o">},</code>&#13;
                    <code class="n">failure</code> <code class="o">-&gt;</code> <code class="o">{</code> <code class="cm">/* ... */</code> <code class="o">}</code>&#13;
    <code class="o">);</code>&#13;
<code class="o">}</code></pre></div>&#13;
&#13;
<p class="pagebreak-before less_space">As you can see, you must subscribe to the injected stream.&#13;
Remember, if you don’t subscribe, nothing will happen, and you won’t receive any messages.&#13;
Note that your code can inject multiple streams and consume them.</p>&#13;
&#13;
<p>You can also inject a stream of messages. In this case, you must acknowledge the messages manually (<a data-type="xref" href="#messaging:channel-ack">Example 10-8</a>).</p>&#13;
<div data-type="example" id="messaging:channel-ack">&#13;
<h5><span class="label">Example 10-8. </span>Inject a stream of messages</h5>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="nd">@Channel</code><code class="o">(</code><code class="s">"my-channel"</code><code class="o">)</code>&#13;
<code class="n">Multi</code><code class="o">&lt;</code><code class="n">Message</code><code class="o">&lt;</code><code class="n">Person</code><code class="o">&gt;&gt;</code> <code class="n">streamOfPersons</code><code class="o">;</code>&#13;
&#13;
<code class="c1">// ...</code>&#13;
&#13;
<code class="kt">void</code> <code class="nf">init</code><code class="o">()</code> <code class="o">{</code>&#13;
    <code class="n">streamOfPersons</code>&#13;
            <code class="o">.</code><code class="na">subscribe</code><code class="o">().</code><code class="na">with</code><code class="o">(</code>&#13;
                    <code class="n">message</code> <code class="o">-&gt;</code> <code class="o">{</code>&#13;
                        <code class="n">Person</code> <code class="n">person</code> <code class="o">=</code> <code class="n">message</code><code class="o">.</code><code class="na">getPayload</code><code class="o">();</code>&#13;
                        <code class="k">try</code> <code class="o">{</code>&#13;
                            <code class="c1">// do something</code>&#13;
                            <code class="c1">// acknowledge</code>&#13;
                            <code class="n">message</code><code class="o">.</code><code class="na">ack</code><code class="o">();</code>&#13;
                        <code class="o">}</code> <code class="k">catch</code> <code class="o">(</code><code class="n">Exception</code> <code class="n">e</code><code class="o">)</code> <code class="o">{</code>&#13;
                            <code class="n">message</code><code class="o">.</code><code class="na">nack</code><code class="o">(</code><code class="n">e</code><code class="o">);</code>&#13;
                        <code class="o">}</code>&#13;
                    <code class="o">},</code>&#13;
                    <code class="n">failure</code> <code class="o">-&gt;</code> <code class="o">{</code> <code class="cm">/* ... */</code> <code class="o">}</code>&#13;
    <code class="o">);</code>&#13;
<code class="o">}</code></pre></div>&#13;
&#13;
<p>Acknowledgment is automatically done for you when injecting a stream of payloads.&#13;
Messages give you more control on the acknowledgment, as well as the possibility to reject a message by using <code>nack</code>.&#13;
In addition, you can access the message metadata.&#13;
But, remember, with more power comes greater responsibility.</p>&#13;
&#13;
<p>The <code>@Channel</code> injection is convenient when you want to access the stream directly or when you want to control the subscription.</p>&#13;
&#13;
<p><a data-primary="@Incoming annotation" data-type="indexterm" id="idm45358820350064"/>Reactive Messaging also offers a more declarative way to consume messages: the <code>@Incoming</code> annotation.&#13;
This annotation is the opposite of <code>@Outgoing</code>.&#13;
Reactive Messaging invokes the annotated method for each message transiting on the specified channel (<a data-type="xref" href="#messaging:incoming">Example 10-9</a>).</p>&#13;
<div data-type="example" id="messaging:incoming">&#13;
<h5><span class="label">Example 10-9. </span>An example of a method using <code>@Incoming</code></h5>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="nd">@Incoming</code><code class="o">(</code><code class="s">"my-channel"</code><code class="o">)</code>&#13;
<code class="kt">void</code> <code class="nf">consume</code><code class="o">(</code><code class="n">Person</code> <code class="n">person</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="c1">// ...</code>&#13;
<code class="o">}</code></pre></div>&#13;
&#13;
<p><a data-type="xref" href="#messaging:incoming">Example 10-9</a> provides a convenient way to process every incoming <code>Person</code>.&#13;
You don’t need to worry about acknowledgment; it’s done for you.&#13;
You can also receive <code>Message</code>, as demonstrated in <a data-type="xref" href="#messaging:incoming-message">Example 10-10</a>.</p>&#13;
<div data-type="example" id="messaging:incoming-message">&#13;
<h5><span class="label">Example 10-10. </span>An example of a method using <code>@Incoming</code> and receiving messages</h5>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="nd">@Incoming</code><code class="o">(</code><code class="s">"my-channel"</code><code class="o">)</code>&#13;
<code class="n">CompletionStage</code><code class="o">&lt;</code><code class="n">Void</code><code class="o">&gt;</code> <code class="nf">consume</code><code class="o">(</code><code class="n">Message</code><code class="o">&lt;</code><code class="n">Person</code><code class="o">&gt;</code> <code class="n">person</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="c1">// ...</code>&#13;
    <code class="k">return</code> <code class="n">person</code><code class="o">.</code><code class="na">ack</code><code class="o">();</code>&#13;
<code class="o">}</code></pre></div>&#13;
&#13;
<p>In this case, as for <code>@Channel</code> injecting a stream of messages, you need to handle the acknowledgment yourself.&#13;
Remember: more control, but more responsibility.<a data-startref="ix_messaging-adoc5" data-type="indexterm" id="idm45358820284592"/><a data-startref="ix_messaging-adoc4" data-type="indexterm" id="idm45358820284096"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Processing Messages" data-type="sect2"><div class="sect2" id="idm45358820527712">&#13;
<h2>Processing Messages</h2>&#13;
&#13;
<p><a data-primary="messages" data-secondary="processing" data-type="indexterm" id="idm45358820282048"/><a data-primary="Reactive Messaging" data-secondary="processing messages" data-type="indexterm" id="idm45358820281072"/>Now that you have seen the two ends, let’s look at the middle of the pipeline: processing.&#13;
To process messages, you combine <code>@Incoming</code> and <code>@Outgoing</code>, as shown in Example 10-11.</p>&#13;
<div data-type="example" id="messaging:processing">&#13;
<h5><span class="label">Example 10-11. </span>Method using <code>@Incoming</code> and <code>@Outgoing</code></h5>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="nd">@Incoming</code><code class="o">(</code><code class="s">"from"</code><code class="o">)</code>&#13;
<code class="nd">@Outgoing</code><code class="o">(</code><code class="s">"to"</code><code class="o">)</code>&#13;
<code class="n">Person</code> <code class="nf">process</code><code class="o">(</code><code class="n">String</code> <code class="n">name</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="k">return</code> <code class="k">new</code> <code class="nf">Person</code><code class="o">(</code><code class="n">name</code><code class="o">);</code>&#13;
<code class="o">}</code></pre></div>&#13;
&#13;
<p>In this snippet, we read strings from the <code>from</code> channel.&#13;
For each received string, we create a <code>Person</code> instance that is sent to the <code>to</code> channel.&#13;
This method is synchronous and accepts an individual payload and returns an individual payload.&#13;
That’s not the only supported signature.&#13;
Reactive Messaging supports more than 30 signatures, allowing asynchronous processing (such as returning <code>Uni</code>), or even stream processing (where you receive and return <code>Multi</code>s),<sup><a data-type="noteref" href="ch10.html#idm45358820227664" id="idm45358820227664-marker">2</a></sup> see <a data-type="xref" href="#messaging:stream">Example 10-12</a>.</p>&#13;
<div data-type="example" id="messaging:stream">&#13;
<h5><span class="label">Example 10-12. </span>Example of stream manipulation</h5>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="nd">@Incoming</code><code class="o">(</code><code class="s">"from"</code><code class="o">)</code>&#13;
<code class="nd">@Outgoing</code><code class="o">(</code><code class="s">"to"</code><code class="o">)</code>&#13;
<code class="n">Multi</code><code class="o">&lt;</code><code class="n">Person</code><code class="o">&gt;</code> <code class="nf">processStream</code><code class="o">(</code><code class="n">Multi</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code> <code class="n">inputStream</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="k">return</code> <code class="n">inputStream</code>&#13;
            <code class="o">.</code><code class="na">onItem</code><code class="o">().</code><code class="na">transform</code><code class="o">(</code><code class="nl">Person:</code><code class="o">:</code><code class="k">new</code><code class="o">);</code>&#13;
<code class="o">}</code></pre></div>&#13;
&#13;
<p>In addition to payloads, you can process messages.&#13;
But as for the consumption of messages, you need to be more attentive.&#13;
Indeed, you often need to <em>chain</em> messages, or link the incoming message with the one you produce, as shown in <a data-type="xref" href="#messaging:processing-messages">Example 10-13</a>.</p>&#13;
<div data-type="example" id="messaging:processing-messages">&#13;
<h5><span class="label">Example 10-13. </span>Process messages</h5>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="nd">@Incoming</code><code class="o">(</code><code class="s">"from"</code><code class="o">)</code>&#13;
<code class="nd">@Outgoing</code><code class="o">(</code><code class="s">"to"</code><code class="o">)</code>&#13;
<code class="n">Message</code><code class="o">&lt;</code><code class="n">Person</code><code class="o">&gt;</code> <code class="nf">processMessage</code><code class="o">(</code><code class="n">Message</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code> <code class="n">msg</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="k">return</code> <code class="n">msg</code><code class="o">.</code><code class="na">withPayload</code><code class="o">(</code><code class="k">new</code> <code class="n">Person</code><code class="o">(</code><code class="n">msg</code><code class="o">.</code><code class="na">getPayload</code><code class="o">()));</code>&#13;
<code class="o">}</code></pre></div>&#13;
&#13;
<p>In this snippet, look at the <code>withPayload</code> method.&#13;
The <code>Message</code> interface provides various <code>with</code> methods that link messages together.&#13;
You may wonder why it’s so important to link them.&#13;
It’s all about acknowledgment. You have seen this word a couple of times already, so it’s time to explain what it means.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Acknowledgments" data-type="sect2"><div class="sect2" id="acknowledgements_aspect">&#13;
<h2>Acknowledgments</h2>&#13;
&#13;
<p><a data-primary="acknowledgments (messaging system element)" data-type="indexterm" id="idm45358820103456"/><a data-primary="Reactive Messaging" data-secondary="acknowledgments" data-type="indexterm" id="idm45358820067744"/><em>Acknowledgment</em> is an essential aspect of any messaging system.&#13;
When you use a message broker, the consumers, receiving and processing messages, must indicate to the broker when the message processing completes (successfully or not).&#13;
Then the broker can decide to dispatch the next message, or to redeliver the same one if the processing failed.&#13;
While the broker strategy is dependent on the broker itself, acknowledgment is a well-known concept that most messaging protocols use one way or another.</p>&#13;
&#13;
<p><a data-primary="ack (acknowledged successfully)" data-type="indexterm" id="idm45358820065760"/><a data-primary="nack (acknowledged negatively)" data-type="indexterm" id="idm45358820064832"/>In Reactive Messaging, each message must be <em>acked</em> (acknowledged successfully) or <em>nacked</em> (acknowledged negatively, or not acked).&#13;
The <code>Message</code> interface offers the <code>ack</code> and <code>nack</code> methods to indicate the successful or failed processing of the message, respectively.&#13;
Both methods are asynchronous and return <code>CompletionStage&lt;Void&gt;</code>.&#13;
Indeed, when using a remote broker, acknowledging a message means telling the broker whether the message has been processed successfully.&#13;
You will see in <a data-type="xref" href="ch11.html#event-bus">Chapter 11</a> how these acknowledgments are integrated with Apache Kafka and AMQP 1.0.</p>&#13;
&#13;
<p>When using individual payloads, Reactive Messaging handles the acknowledgment (positive or negative) for you.&#13;
However, when you receive messages, you need to call these methods or produce a message that is <em>linked</em> to the incoming one.&#13;
This link is essential.&#13;
When the downstream consumer receives your message and acknowledges it, that consumer also acknowledges the linked message.&#13;
These links form a chain of messages, and acknowledgments go up the chain until they reach the top (generally, a message produced by an emitter or from an external destination).</p>&#13;
&#13;
<p>As depicted on <a data-type="xref" href="#image:ack">Figure 10-2</a>, the chain allows indicating the outcome of the processing, even when the processing is composed of several steps, potentially asynchronous ones.</p>&#13;
&#13;
<figure><div class="figure" id="image:ack">&#13;
<img alt="Acknowledgement chain" src="assets/rsij_1002.png"/>&#13;
<h6><span class="label">Figure 10-2. </span>Acknowledgment chain</h6>&#13;
</div></figure>&#13;
&#13;
<p>Let’s consider an example to illustrate the behavior.&#13;
Imagine receiving a message from a broker, transforming the content, and then sending this message to a remote service.&#13;
For each message from the broker, this process creates a chain:</p>&#13;
&#13;
<pre data-type="programlisting">[(a) message from broker] -&gt; [(b) message with the transformed content]</pre>&#13;
&#13;
<p>When everything is fine, the framework acknowledges the message <code>(b)</code>, which acknowledges the message <code>(a)</code>.&#13;
The successful acknowledgment logic of the message is executed.&#13;
However, if interacting with the remote service fails, it calls the <code>nack</code> method on the message <code>(b)</code>, which also calls <code>nack</code> on the message <code>(a)</code>.&#13;
And so, it executes the negative acknowledgment logic attached to the message <code>(a)</code>.</p>&#13;
&#13;
<p>In more advanced scenarios, this chain can be too rigid, and you’ll want more control.&#13;
Typically, you may want to decide when to acknowledge a specific message, or decide to acknowledge before the processing instead of after.&#13;
When using <code>Message</code>, you have full control and can decide to deliberately not chain messages or wait for a certain condition to acknowledge.&#13;
For example, when producing multiple messages from a single one, you would acknowledge the message when all the produced messages have been acknowledged.&#13;
Regardless of the use case, when using <code>Message</code>, don’t forget to call <code>ack</code> or <code>nack</code>.&#13;
 Alternatively, you can use the <code>@Acknowledgment</code> annotation to decide where to split the chain in a more declarative manner.</p>&#13;
&#13;
<p>Acknowledgment is essential, and with Reactive Messaging, all messages must be either <em>acked</em> or <em>nacked</em>.&#13;
It’s vital to implement the elasticity and resilience patterns from reactive systems.&#13;
But how do we connect the applications and message brokers?&#13;
That’s what you are going to see in the next section.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="pagebreak-before less_space" data-pdf-bookmark="Connectors" data-type="sect2"><div class="sect2" id="idm45358820104592">&#13;
<h2>Connectors</h2>&#13;
&#13;
<p><a data-primary="connectors" data-type="indexterm" id="idm45358820044144"/><a data-primary="Reactive Messaging" data-secondary="connectors" data-type="indexterm" id="idm45358820043440"/><em>Connectors</em> are specific components that map a channel to something managed externally, such as a queue or a topic.&#13;
They are specific to a particular protocol or technology. There are two kinds of connectors:</p>&#13;
<dl>&#13;
<dt>Inbound connectors</dt>&#13;
<dd>&#13;
<p><a data-primary="inbound connector" data-type="indexterm" id="idm45358820040432"/>These receive messages and feed the channels.&#13;
<a data-primary="Reactive Streams" data-secondary="connectors and" data-type="indexterm" id="idm45358820039536"/>They must enforce the Reactive Streams backpressure protocol and create messages with the appropriate <code>ack</code> and <code>nack</code> logic.</p>&#13;
</dd>&#13;
<dt>Outbound connectors</dt>&#13;
<dd>&#13;
<p><a data-primary="outbound connector" data-type="indexterm" id="idm45358820036208"/>These receive messages from within the application and send them to external destinations. So they map internal messages to the external format and track the outcome to call the <code>ack</code> or <code>nack</code> method on the incoming messages.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>Quarkus offers multiple connectors.&#13;
<a data-type="xref" href="ch11.html#event-bus">Chapter 11</a> covers the Kafka and AMQP connectors in detail.&#13;
The HTTP connector allows binding HTTP and WebSockets with your message processing. The Camel connector allows integrating legacy systems. In your application configuration, you need to specify a connector used for each channel mapped to an external destination.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Building Message-Based Applications" data-type="sect1"><div class="sect1" id="idm45358821112848">&#13;
<h1>Building Message-Based Applications</h1>&#13;
&#13;
<p><a data-primary="message-based applications, building" data-type="indexterm" id="ix_messaging-adoc6"/><a data-primary="Reactive Messaging" data-secondary="building message-based applications" data-type="indexterm" id="ix_messaging-adoc7"/>Enough talking; it’s time to see Reactive Messaging in action. This example is located in the <em>chapter-10/hello-messaging</em> directory. To use Reactive Messaging, you need to have a dependency on <code>quarkus-smallrye-reactive-messaging</code> in your <em>pom.xml</em> file; see <a data-type="xref" href="#dependency-reactive-messaging-10-14">Example 10-14</a>.</p>&#13;
<div data-type="example" id="dependency-reactive-messaging-10-14">&#13;
<h5><span class="label">Example 10-14. </span>Dependency for the Reactive Messaging extension (<em>chapter-10/hello-messaging/pom.xml</em>)</h5>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;dependency&gt;</code>&#13;
    <code class="nt">&lt;groupId&gt;</code>io.quarkus<code class="nt">&lt;/groupId&gt;</code>&#13;
    <code class="nt">&lt;artifactId&gt;</code>quarkus-smallrye-reactive-messaging<code class="nt">&lt;/artifactId&gt;</code>&#13;
<code class="nt">&lt;/dependency&gt;</code></pre></div>&#13;
&#13;
<p>As you will see in the next chapter, you will also need to add dependencies for the connectors.&#13;
However, in this chapter, we won’t use connectors.</p>&#13;
&#13;
<p>A Reactive Messaging application includes beans containing methods annotated with <code>@Incoming</code> and <code>@Outgoing</code>.&#13;
<a data-type="xref" href="#hellomessage-10-15">Example 10-15</a> contains a single bean with three methods.</p>&#13;
<div data-type="example" id="hellomessage-10-15">&#13;
<h5><span class="label">Example 10-15. </span>Hello messaging application (<em>chapter-10/hello-messaging/src/main/java/org/acme/HelloMessaging.java</em>)</h5>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kn">package</code> <code class="n">org</code><code class="o">.</code><code class="na">acme</code><code class="o">;</code>&#13;
&#13;
<code class="kn">import</code> <code class="nn">io.smallrye.mutiny.Multi</code><code class="o">;</code>&#13;
<code class="kn">import</code> <code class="nn">org.eclipse.microprofile.reactive.messaging.Incoming</code><code class="o">;</code>&#13;
<code class="kn">import</code> <code class="nn">org.eclipse.microprofile.reactive.messaging.Outgoing</code><code class="o">;</code>&#13;
&#13;
<code class="kn">import</code> <code class="nn">javax.enterprise.context.ApplicationScoped</code><code class="o">;</code>&#13;
<code class="kn">import</code> <code class="nn">java.time.Duration</code><code class="o">;</code>&#13;
&#13;
<code class="nd">@ApplicationScoped</code>&#13;
<code class="kd">public</code> <code class="kd">class</code> <code class="nc">HelloMessaging</code> <code class="o">{</code>&#13;
&#13;
    <code class="nd">@Outgoing</code><code class="o">(</code><code class="s">"ticks"</code><code class="o">)</code>&#13;
    <code class="kd">public</code> <code class="n">Multi</code><code class="o">&lt;</code><code class="n">Long</code><code class="o">&gt;</code> <code class="nf">ticks</code><code class="o">()</code> <code class="o">{</code>&#13;
        <code class="k">return</code> <code class="n">Multi</code><code class="o">.</code><code class="na">createFrom</code><code class="o">().</code><code class="na">ticks</code><code class="o">()</code>&#13;
                <code class="o">.</code><code class="na">every</code><code class="o">(</code><code class="n">Duration</code><code class="o">.</code><code class="na">ofSeconds</code><code class="o">(</code><code class="mi">1</code><code class="o">))</code>&#13;
                <code class="o">.</code><code class="na">onOverflow</code><code class="o">().</code><code class="na">drop</code><code class="o">();</code>&#13;
    <code class="o">}</code>&#13;
&#13;
    <code class="nd">@Incoming</code><code class="o">(</code><code class="s">"ticks"</code><code class="o">)</code>&#13;
    <code class="nd">@Outgoing</code><code class="o">(</code><code class="s">"hello"</code><code class="o">)</code>&#13;
    <code class="kd">public</code> <code class="n">String</code> <code class="nf">hello</code><code class="o">(</code><code class="kt">long</code> <code class="n">tick</code><code class="o">)</code> <code class="o">{</code>&#13;
        <code class="k">return</code> <code class="s">"Hello - "</code> <code class="o">+</code> <code class="n">tick</code><code class="o">;</code>&#13;
    <code class="o">}</code>&#13;
&#13;
    <code class="nd">@Incoming</code><code class="o">(</code><code class="s">"hello"</code><code class="o">)</code>&#13;
    <code class="kd">public</code> <code class="kt">void</code> <code class="nf">print</code><code class="o">(</code><code class="n">String</code> <code class="n">msg</code><code class="o">)</code> <code class="o">{</code>&#13;
        <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="n">msg</code><code class="o">);</code>&#13;
    <code class="o">}</code>&#13;
&#13;
<code class="o">}</code></pre></div>&#13;
&#13;
<p>The methods form a processing pipeline.&#13;
The first method, <code>ticks</code>, generates messages on the <code>ticks</code> channel.&#13;
The method returns a <code>Multi</code> emitting a number every second.&#13;
This number is wrapped into a simple message automatically.&#13;
Then, the method <code>hello</code> consumes these ticks and produces a <code>String</code>, sent to the <code>hello</code> channel.&#13;
Finally, the <code>print</code> method receives these messages and displays them on the console.&#13;
We get the pipeline in Example 10-16.</p>&#13;
<div data-type="example" id="processing-pipeline-10-16">&#13;
<h5><span class="label">Example 10-16. </span>The processing pipeline</h5>&#13;
&#13;
<pre data-code-language="text" data-type="programlisting">ticks() ---&gt; [ticks] ---&gt; hello() ----&gt; [hello] ----&gt; print()</pre></div>&#13;
&#13;
<p>If you go into the <em>chapter-10/hello-messaging</em> directory and run <code>mvn quarkus:dev</code>, you will see <a data-type="xref" href="#hello-messages-10-17">Example 10-17</a>.</p>&#13;
<div data-type="example" id="hello-messages-10-17">&#13;
<h5><span class="label">Example 10-17. </span>Hello messages</h5>&#13;
&#13;
<pre data-type="programlisting">Hello - 1&#13;
Hello - 2&#13;
Hello - 3</pre></div>&#13;
&#13;
<p>As you can see, building a message-processing pipeline is pretty straightforward.&#13;
Beneath the hood, Reactive Messaging creates a reactive stream and creates the acknowledgment chain.&#13;
That’s what we are going to illustrate in the next section.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Message and Acknowledgment" data-type="sect2"><div class="sect2" id="idm45358819827664">&#13;
<h2>Message and Acknowledgment</h2>&#13;
&#13;
<p><a data-primary="acknowledgment" data-secondary="in message-based application" data-type="indexterm" id="ix_messaging-adoc8"/><a data-primary="message-based applications, building" data-secondary="message and acknowledgment" data-type="indexterm" id="ix_messaging-adoc9"/><a data-primary="messages" data-secondary="in message-based applications" data-secondary-sortas="message-based" data-type="indexterm" id="ix_messaging-adoc10"/>To better understand the message chain, let’s look at the chapter-10/messages-example directory.&#13;
In this module, we create a specific implementation of <code>Message</code> (<code>MyMessage</code>), which displays on the console when a message is <em>acked</em> or <em>nacked</em> (Example 10-18).</p>&#13;
<div data-type="example">&#13;
<h5><span class="label">Example 10-18. </span>An implementation of <code>Message</code> (<em>chapter-10/messages-example/src/main/java/org/acme/MyMessage.java</em>)</h5>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">class</code> <code class="nc">MyMessage</code> <code class="kd">implements</code> <code class="n">Message</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code> <code class="o">{</code>&#13;
&#13;
    <code class="kd">private</code> <code class="kd">final</code> <code class="n">String</code> <code class="n">payload</code><code class="o">;</code>&#13;
&#13;
    <code class="kd">public</code> <code class="nf">MyMessage</code><code class="o">(</code><code class="n">String</code> <code class="n">payload</code><code class="o">)</code> <code class="o">{</code>&#13;
        <code class="k">this</code><code class="o">.</code><code class="na">payload</code> <code class="o">=</code> <code class="n">payload</code><code class="o">;</code>&#13;
    <code class="o">}</code>&#13;
&#13;
    <code class="kd">public</code> <code class="nf">MyMessage</code><code class="o">(</code><code class="kt">long</code> <code class="n">l</code><code class="o">)</code> <code class="o">{</code>&#13;
        <code class="k">this</code><code class="o">(</code><code class="n">Long</code><code class="o">.</code><code class="na">toString</code><code class="o">(</code><code class="n">l</code><code class="o">));</code>&#13;
    <code class="o">}</code>&#13;
&#13;
    <code class="nd">@Override</code>&#13;
    <code class="kd">public</code> <code class="n">String</code> <code class="nf">getPayload</code><code class="o">()</code> <code class="o">{</code>&#13;
        <code class="k">return</code> <code class="n">payload</code><code class="o">;</code>&#13;
    <code class="o">}</code>&#13;
&#13;
    <code class="nd">@Override</code>&#13;
    <code class="kd">public</code> <code class="n">Supplier</code><code class="o">&lt;</code><code class="n">CompletionStage</code><code class="o">&lt;</code><code class="n">Void</code><code class="o">&gt;&gt;</code> <code class="nf">getAck</code><code class="o">()</code> <code class="o">{</code>&#13;
        <code class="k">return</code> <code class="o">()</code> <code class="o">-&gt;</code> <code class="o">{</code>&#13;
            <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="s">"Acknowledgment for "</code> <code class="o">+</code> <code class="n">payload</code><code class="o">);</code>&#13;
            <code class="k">return</code> <code class="n">CompletableFuture</code><code class="o">.</code><code class="na">completedFuture</code><code class="o">(</code><code class="kc">null</code><code class="o">);</code>&#13;
        <code class="o">};</code>&#13;
    <code class="o">}</code>&#13;
&#13;
    <code class="nd">@Override</code>&#13;
    <code class="kd">public</code> <code class="n">Function</code><code class="o">&lt;</code><code class="n">Throwable</code><code class="o">,</code> <code class="n">CompletionStage</code><code class="o">&lt;</code><code class="n">Void</code><code class="o">&gt;&gt;</code> <code class="n">getNack</code><code class="o">()</code> <code class="o">{</code>&#13;
        <code class="k">return</code> <code class="n">reason</code> <code class="o">-&gt;</code> <code class="o">{</code>&#13;
            <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="s">"Negative acknowledgment for "</code>&#13;
                    <code class="o">+</code> <code class="n">payload</code> <code class="o">+</code> <code class="s">", the reason is "</code> <code class="o">+</code> <code class="n">reason</code><code class="o">);</code>&#13;
            <code class="k">return</code> <code class="n">CompletableFuture</code><code class="o">.</code><code class="na">completedFuture</code><code class="o">(</code><code class="kc">null</code><code class="o">);</code>&#13;
        <code class="o">};</code>&#13;
    <code class="o">}</code>&#13;
<code class="o">}</code></pre></div>&#13;
&#13;
<p>The application itself, shown in <a data-type="xref" href="#rm::using-messages">Example 10-19</a>, is similar to the one from the previous section.&#13;
We generate a message every second, but this time, it’s an instance of <code>MyMessage</code> instead of a payload automatically wrapped into a message.&#13;
The <code>hello</code> method receives these messages and creates a new one with a different payload.&#13;
The <code>print</code> method is unchanged.</p>&#13;
<div data-type="example" id="rm::using-messages">&#13;
<h5><span class="label">Example 10-19. </span>Usage of messages (<em>chapter-10/messages-example/src/main/java/org/acme/MessageExample.java</em>)</h5>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="nd">@Outgoing</code><code class="o">(</code><code class="s">"ticks"</code><code class="o">)</code>&#13;
<code class="kd">public</code> <code class="n">Multi</code><code class="o">&lt;</code><code class="n">MyMessage</code><code class="o">&gt;</code> <code class="nf">ticks</code><code class="o">()</code> <code class="o">{</code>&#13;
    <code class="k">return</code> <code class="n">Multi</code><code class="o">.</code><code class="na">createFrom</code><code class="o">().</code><code class="na">ticks</code><code class="o">().</code><code class="na">every</code><code class="o">(</code><code class="n">Duration</code><code class="o">.</code><code class="na">ofSeconds</code><code class="o">(</code><code class="mi">1</code><code class="o">))</code>&#13;
            <code class="o">.</code><code class="na">onOverflow</code><code class="o">().</code><code class="na">drop</code><code class="o">()</code>&#13;
            <code class="o">.</code><code class="na">onItem</code><code class="o">().</code><code class="na">transform</code><code class="o">(</code><code class="nl">MyMessage:</code><code class="o">:</code><code class="k">new</code><code class="o">);</code>&#13;
<code class="o">}</code>&#13;
&#13;
<code class="nd">@Incoming</code><code class="o">(</code><code class="s">"ticks"</code><code class="o">)</code>&#13;
<code class="nd">@Outgoing</code><code class="o">(</code><code class="s">"hello"</code><code class="o">)</code>&#13;
<code class="kd">public</code> <code class="n">Message</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code> <code class="nf">hello</code><code class="o">(</code><code class="n">Message</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code> <code class="n">tick</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="k">return</code> <code class="n">tick</code><code class="o">.</code><code class="na">withPayload</code><code class="o">(</code><code class="s">"Hello "</code> <code class="o">+</code> <code class="n">tick</code><code class="o">.</code><code class="na">getPayload</code><code class="o">());</code>&#13;
<code class="o">}</code>&#13;
&#13;
<code class="nd">@Incoming</code><code class="o">(</code><code class="s">"hello"</code><code class="o">)</code>&#13;
<code class="kd">public</code> <code class="kt">void</code> <code class="nf">print</code><code class="o">(</code><code class="n">String</code> <code class="n">msg</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="n">msg</code><code class="o">);</code>&#13;
<code class="o">}</code></pre></div>&#13;
&#13;
<p>Look at the <code>hello</code> method.&#13;
It returns a new message built from the receiving one.&#13;
The <code>with</code> methods link the two messages to form the chain.&#13;
When the returned message is acknowledged, the received message is also acknowledged.</p>&#13;
&#13;
<p>If you run <code>mvn quarkus:dev</code> from the <em>chapter-10/messages-example</em> directory, you should see this:</p>&#13;
&#13;
<pre data-type="programlisting">Hello 1&#13;
Acknowledgment for 1&#13;
Hello 2&#13;
Acknowledgment for 2&#13;
Hello 3&#13;
Acknowledgment for 3</pre>&#13;
&#13;
<p>When the <code>print</code> method invocation completes for a specific message, it acknowledges this message (created in the <code>hello</code> method), which also acknowledges the one emitted by the <code>tick</code> method.&#13;
That’s why you can see “Acknowledgment for …” on the console.<a data-startref="ix_messaging-adoc10" data-type="indexterm" id="idm45358819462960"/><a data-startref="ix_messaging-adoc9" data-type="indexterm" id="idm45358819462256"/><a data-startref="ix_messaging-adoc8" data-type="indexterm" id="idm45358819461584"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Failures and Negative Acknowledgment" data-type="sect2"><div class="sect2" id="idm45358819460784">&#13;
<h2>Failures and Negative Acknowledgment</h2>&#13;
&#13;
<p><a data-primary="acknowledgment" data-secondary="negative" data-type="indexterm" id="idm45358819459456"/><a data-primary="failure handling" data-secondary="negative acknowledgment and" data-type="indexterm" id="idm45358819458480"/><a data-primary="message-based applications, building" data-secondary="failures and negative acknowledgment" data-type="indexterm" id="idm45358819457472"/><a data-primary="nack (acknowledged negatively)" data-type="indexterm" id="idm45358819456496"/>Message processing may fail, and in this case, we expect the failing message to be <em>nacked</em>.&#13;
To illustrate this, let’s update the code to throw an exception when it processes the third message, as shown in <a data-type="xref" href="#messaging:auto-nack">Example 10-20</a>.</p>&#13;
<div data-type="example" id="messaging:auto-nack">&#13;
<h5><span class="label">Example 10-20. </span>Throwing an exception acknowledges the message negatively</h5>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="nd">@Incoming</code><code class="o">(</code><code class="s">"hello"</code><code class="o">)</code>&#13;
<code class="kd">public</code> <code class="kt">void</code> <code class="nf">print</code><code class="o">(</code><code class="n">String</code> <code class="n">msg</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="k">if</code> <code class="o">(</code><code class="n">msg</code><code class="o">.</code><code class="na">contains</code><code class="o">(</code><code class="s">"3"</code><code class="o">))</code> <code class="o">{</code>&#13;
        <code class="k">throw</code> <code class="k">new</code> <code class="nf">IllegalArgumentException</code><code class="o">(</code><code class="s">"boom"</code><code class="o">);</code>&#13;
    <code class="o">}</code>&#13;
    <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="n">msg</code><code class="o">);</code>&#13;
<code class="o">}</code></pre></div>&#13;
&#13;
<p>Restart the application. Now the third message is nacked:</p>&#13;
&#13;
<pre data-type="programlisting">Hello 0&#13;
Acknowledgment for 0&#13;
Hello 1&#13;
Acknowledgment for 1&#13;
Hello 2&#13;
Acknowledgment for 2&#13;
2021-05-14 14:49:54,052 ERROR [io.sma.rea.mes.provider]&#13;
(executor-thread-1) SRMSG00200:&#13;
The method HelloMessaging#print has thrown an exception:&#13;
java.lang.IllegalArgumentException: boom&#13;
	at HelloMessaging.print(HelloMessaging.java:28)&#13;
	// ....&#13;
Negative acknowledgment for 3,&#13;
the reason is java.lang.IllegalArgumentException: boom&#13;
Hello 4&#13;
Acknowledgment for 4</pre>&#13;
&#13;
<p>Throwing an exception calls the <code>nack</code> method on the message and goes up the chain to call <code>nack</code> on the <code>MyMessage</code> instance.</p>&#13;
&#13;
<p>In this example, our <code>ack</code> and <code>nack</code> implementations are simplistic.&#13;
But they demonstrate how <code>ack</code> and <code>nack</code> can notify a message broker about the processing outcome.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Stream Manipulation" data-type="sect2"><div class="sect2" id="idm45358819381328">&#13;
<h2>Stream Manipulation</h2>&#13;
&#13;
<p><a data-primary="Reactive Messaging" data-secondary="stream manipulation" data-type="indexterm" id="ix_messaging-adoc11"/><a data-primary="stream manipulation" data-type="indexterm" id="ix_messaging-adoc12"/>Manipulating messages one by one is straightforward, but sometimes we need to do more complicated processing.&#13;
To achieve this, Reactive Messaging allows &#13;
<span class="keep-together">manipulating</span> the stream of messages directly.&#13;
Instead of an individual message or payload, the method receives a <code>Multi</code> and produces another <code>Multi</code> (<a data-type="xref" href="#stream-10-21">Example 10-21</a>).</p>&#13;
<div data-type="example" id="stream-10-21">&#13;
<h5><span class="label">Example 10-21. </span>Stream manipulation with Reactive Messaging (<em>chapter-10/stream-example/src/main/java/org/acme/StreamingExample.java</em>)</h5>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="nd">@ApplicationScoped</code>&#13;
<code class="kd">public</code> <code class="kd">class</code> <code class="nc">StreamingExample</code> <code class="o">{</code>&#13;
&#13;
    <code class="nd">@Outgoing</code><code class="o">(</code><code class="s">"ticks"</code><code class="o">)</code>&#13;
    <code class="kd">public</code> <code class="n">Multi</code><code class="o">&lt;</code><code class="n">Long</code><code class="o">&gt;</code> <code class="nf">ticks</code><code class="o">()</code> <code class="o">{</code>&#13;
        <code class="k">return</code> <code class="n">Multi</code><code class="o">.</code><code class="na">createFrom</code><code class="o">().</code><code class="na">ticks</code><code class="o">().</code><code class="na">every</code><code class="o">(</code><code class="n">Duration</code><code class="o">.</code><code class="na">ofSeconds</code><code class="o">(</code><code class="mi">1</code><code class="o">))</code>&#13;
                <code class="o">.</code><code class="na">onOverflow</code><code class="o">().</code><code class="na">drop</code><code class="o">();</code>&#13;
    <code class="o">}</code>&#13;
&#13;
    <code class="nd">@Incoming</code><code class="o">(</code><code class="s">"ticks"</code><code class="o">)</code>&#13;
    <code class="nd">@Outgoing</code><code class="o">(</code><code class="s">"groups"</code><code class="o">)</code>&#13;
    <code class="kd">public</code> <code class="n">Multi</code><code class="o">&lt;</code><code class="n">List</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;&gt;</code> <code class="nf">group</code><code class="o">(</code><code class="n">Multi</code><code class="o">&lt;</code><code class="n">Long</code><code class="o">&gt;</code> <code class="n">stream</code><code class="o">)</code> <code class="o">{</code>&#13;
        <code class="c1">// Group the incoming messages into groups of 5.</code>&#13;
        <code class="k">return</code> <code class="n">stream</code>&#13;
                <code class="o">.</code><code class="na">onItem</code><code class="o">().</code><code class="na">transform</code><code class="o">(</code><code class="n">l</code> <code class="o">-&gt;</code> <code class="n">Long</code><code class="o">.</code><code class="na">toString</code><code class="o">(</code><code class="n">l</code><code class="o">))</code>&#13;
                <code class="o">.</code><code class="na">group</code><code class="o">().</code><code class="na">intoLists</code><code class="o">().</code><code class="na">of</code><code class="o">(</code><code class="mi">5</code><code class="o">);</code>&#13;
    <code class="o">}</code>&#13;
&#13;
&#13;
    <code class="nd">@Incoming</code><code class="o">(</code><code class="s">"groups"</code><code class="o">)</code>&#13;
    <code class="nd">@Outgoing</code><code class="o">(</code><code class="s">"hello"</code><code class="o">)</code>&#13;
    <code class="kd">public</code> <code class="n">String</code> <code class="nf">processGroup</code><code class="o">(</code><code class="n">List</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code> <code class="n">list</code><code class="o">)</code> <code class="o">{</code>&#13;
        <code class="k">return</code> <code class="s">"Hello "</code> <code class="o">+</code> <code class="n">String</code><code class="o">.</code><code class="na">join</code><code class="o">(</code><code class="s">","</code><code class="o">,</code> <code class="n">list</code><code class="o">);</code>&#13;
    <code class="o">}</code>&#13;
&#13;
&#13;
    <code class="nd">@Incoming</code><code class="o">(</code><code class="s">"hello"</code><code class="o">)</code>&#13;
    <code class="kd">public</code> <code class="kt">void</code> <code class="nf">print</code><code class="o">(</code><code class="n">String</code> <code class="n">msg</code><code class="o">)</code> <code class="o">{</code>&#13;
        <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="n">msg</code><code class="o">);</code>&#13;
    <code class="o">}</code>&#13;
&#13;
<code class="o">}</code></pre></div>&#13;
&#13;
<p>You can find the complete code in the <em>chapter-10/stream-example</em> directory.&#13;
The method <code>group</code> takes the stream of ticks as input and groups the items into lists of five elements.&#13;
The <code>processGroup</code> method takes each group and processes them:</p>&#13;
&#13;
<pre data-type="programlisting">Hello 0,1,2,3,4&#13;
Hello 5,6,7,8,9&#13;
Hello 10,11,12,13,14&#13;
...</pre>&#13;
&#13;
<p>Although this example uses just the <code>group</code> operator, you can use the whole Mutiny API to orchestrate asynchronous calls, skip messages, handle failure recovery, or apply complex manipulations.<a data-startref="ix_messaging-adoc12" data-type="indexterm" id="idm45358819171504"/><a data-startref="ix_messaging-adoc11" data-type="indexterm" id="idm45358819170800"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Blocking Processing" data-type="sect2"><div class="sect2" id="idm45358819170000">&#13;
<h2>Blocking Processing</h2>&#13;
&#13;
<p><a data-primary="Reactive Messaging" data-secondary="blocking processing" data-type="indexterm" id="idm45358819168688"/><a data-primary="threads" data-secondary="Reactive Messaging and" data-type="indexterm" id="idm45358819167712"/>Reactive Messaging implements the reactive principles.&#13;
It avoids blocking the caller thread, but sometimes it’s not possible to do otherwise.&#13;
Imagine lengthy processing or using a blocking API.</p>&#13;
&#13;
<p><a data-primary="@Blocking annotation" data-type="indexterm" id="idm45358819166176"/>When facing such a situation, you can use the <code>@Blocking</code> annotation, which automatically switches the processing to a worker thread and then switches back to the I/O thread (see <a data-type="xref" href="#annotate-10-22">Example 10-22</a>).</p>&#13;
<div data-type="example" id="annotate-10-22">&#13;
<h5><span class="label">Example 10-22. </span>Annotate methods with <code>@Blocking</code> (<em>chapter-10/blocking-example/src/main/java/org/acme/BlockingExample.java</em>)</h5>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="nd">@Incoming</code><code class="o">(</code><code class="s">"ticks"</code><code class="o">)</code>&#13;
<code class="nd">@Outgoing</code><code class="o">(</code><code class="s">"hello"</code><code class="o">)</code>&#13;
<code class="nd">@Blocking</code>&#13;
<code class="kd">public</code> <code class="n">String</code> <code class="nf">hello</code><code class="o">(</code><code class="kt">long</code> <code class="n">tick</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="c1">// Simulate a long operation</code>&#13;
    <code class="k">try</code> <code class="o">{</code>&#13;
        <code class="n">Thread</code><code class="o">.</code><code class="na">sleep</code><code class="o">(</code><code class="mi">1000</code><code class="o">);</code>&#13;
    <code class="o">}</code> <code class="k">catch</code> <code class="o">(</code><code class="n">InterruptedException</code> <code class="n">e</code><code class="o">)</code> <code class="o">{</code>&#13;
        <code class="n">Thread</code><code class="o">.</code><code class="na">currentThread</code><code class="o">().</code><code class="na">interrupt</code><code class="o">();</code>&#13;
    <code class="o">}</code>&#13;
    <code class="k">return</code> <code class="s">"Hello - "</code> <code class="o">+</code> <code class="n">tick</code><code class="o">;</code>&#13;
<code class="o">}</code></pre></div>&#13;
&#13;
<p>In the <em>blocking-example</em> directory, you can find a modified version of our simple pipeline simulating a long operation in the <code>hello</code> method.&#13;
Using <code>Thread.sleep</code> is blocking, so it cannot be executed on the I/O thread.&#13;
Fortunately, thanks to the <code>@Blocking</code> annotation, that method is invoked on a worker thread. The <code>@Blocking</code> annotation is particularly interesting when integrating with blocking APIs.&#13;
However, please don’t abuse it, as it reduces the concurrency of your application.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Retrying Processing" data-type="sect2"><div class="sect2" id="idm45358819079728">&#13;
<h2>Retrying Processing</h2>&#13;
&#13;
<p><a data-primary="failure handling" data-secondary="retrying processing" data-type="indexterm" id="idm45358819078352"/><a data-primary="Reactive Messaging" data-secondary="retrying processing" data-type="indexterm" id="idm45358819077376"/><a data-primary="retries" data-type="indexterm" id="idm45358819076432"/>Intermittent failures happen. Network disruptions or temporary unavailability are part of the life of any distributed system.</p>&#13;
&#13;
<p>To handle this case, you can use the Mutiny API and use <code>onFailure.retry</code>, but you can also use the SmallRye Fault-Tolerance and its <code>@Retry</code> annotation. First, you need to declare a dependency on Fault-Tolerance, as shown in <a data-type="xref" href="#dependency-10-23">Example 10-23</a>.</p>&#13;
<div data-type="example" id="dependency-10-23">&#13;
<h5><span class="label">Example 10-23. </span>Dependency for the fault-tolerance support (<em>chapter-10/fault-tolerance-example/pom.xml</em>)</h5>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;dependency&gt;</code>&#13;
    <code class="nt">&lt;groupId&gt;</code>io.quarkus<code class="nt">&lt;/groupId&gt;</code>&#13;
    <code class="nt">&lt;artifactId&gt;</code>quarkus-smallrye-fault-tolerance<code class="nt">&lt;/artifactId&gt;</code>&#13;
<code class="nt">&lt;/dependency&gt;</code></pre></div>&#13;
&#13;
<p>Then, you can use the <code>@Retry</code> annotation that automatically catches exceptions and retries the invocation. In <em>chapter-10/fault-tolerance-example</em>, you can see the code in <a data-type="xref" href="#retry-10-24">Example 10-24</a>.</p>&#13;
<div data-type="example" id="retry-10-24">&#13;
<h5><span class="label">Example 10-24. </span>Retry the processing of messages (<em>chapter-10/fault-tolerance-example/src/main/java/org/acme/FaultToleranceExample.java</em>)</h5>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="nd">@Incoming</code><code class="o">(</code><code class="s">"ticks"</code><code class="o">)</code>&#13;
<code class="nd">@Outgoing</code><code class="o">(</code><code class="s">"hello"</code><code class="o">)</code>&#13;
<code class="nd">@Retry</code><code class="o">(</code><code class="n">maxRetries</code> <code class="o">=</code> <code class="mi">10</code><code class="o">,</code> <code class="n">delay</code> <code class="o">=</code> <code class="mi">1</code><code class="o">,</code> <code class="n">delayUnit</code> <code class="o">=</code> <code class="n">ChronoUnit</code><code class="o">.</code><code class="na">SECONDS</code><code class="o">)</code>&#13;
<code class="kd">public</code> <code class="n">String</code> <code class="nf">hello</code><code class="o">(</code><code class="kt">long</code> <code class="n">tick</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="n">maybeFaulty</code><code class="o">();</code> <code class="c1">// Randomly throws an exception</code>&#13;
    <code class="k">return</code> <code class="s">"Hello - "</code> <code class="o">+</code> <code class="n">tick</code><code class="o">;</code>&#13;
<code class="o">}</code></pre></div>&#13;
&#13;
<p>The <code>maybeFaulty</code> method throws exceptions randomly.&#13;
So the <code>@Retry</code> annotation is used to retry the processing of the message, hoping for a better outcome. Remember, don’t retry if your processing is not idempotent!&#13;
It can have terrible consequences.&#13;
It might be better to store the faulty messages on a dead-letter queue (this is covered in the next chapter).<a data-startref="ix_messaging-adoc7" data-type="indexterm" id="idm45358818966160"/><a data-startref="ix_messaging-adoc6" data-type="indexterm" id="idm45358818965664"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Putting Everything Together" data-type="sect1"><div class="sect1" id="idm45358820031936">&#13;
<h1>Putting Everything Together</h1>&#13;
&#13;
<p><a data-primary="HTTP" data-secondary="Reactive Messaging example" data-type="indexterm" id="ix_messaging-adoc13"/><a data-primary="Reactive Messaging" data-secondary="HTTP example" data-type="indexterm" id="ix_messaging-adoc14"/>The last few sections have demonstrated some features offered by Reactive Messaging.&#13;
These examples are simplistic on purpose.&#13;
Let’s now work on a more realistic pipeline where we receive HTTP requests, manipulate the body, and write it into a database.&#13;
<a data-primary="Hibernate Reactive" data-type="indexterm" id="idm45358818960672"/>We will use RESTEasy Reactive and Hibernate Reactive, which we have seen in Chapters <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch08.html#http">8</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch09.html#data">9</a>.&#13;
While the application could be perfectly implemented without Reactive Messaging, we use it to illustrate how to build more complex pipelines.</p>&#13;
&#13;
<p>The code of this application is in the <em>chapter-10/database-example</em> directory.&#13;
Four classes compose the application.&#13;
First, the <code>Person</code> class is a Hibernate Reactive Panache entity.&#13;
This entity contains two fields: the name (unique) and the age.&#13;
In this application, the user posts <code>Person</code> instances (sent as JSON), which are sent to the Reactive Messaging pipeline (as illustrated in <a data-type="xref" href="#person-10-25">Example 10-25</a>).</p>&#13;
<div data-type="example" id="person-10-25">&#13;
<h5><span class="label">Example 10-25. </span>The <code>Person</code> structure (<em>chapter-10/database-example/src/main/java/org/acme/Person.java</em>)</h5>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kn">package</code> <code class="n">org</code><code class="o">.</code><code class="na">acme</code><code class="o">;</code>&#13;
&#13;
<code class="kn">import</code> <code class="nn">io.quarkus.hibernate.reactive.panache.PanacheEntity</code><code class="o">;</code>&#13;
&#13;
<code class="kn">import</code> <code class="nn">javax.persistence.Column</code><code class="o">;</code>&#13;
<code class="kn">import</code> <code class="nn">javax.persistence.Entity</code><code class="o">;</code>&#13;
&#13;
<code class="nd">@Entity</code>&#13;
<code class="kd">public</code> <code class="kd">class</code> <code class="nc">Person</code> <code class="kd">extends</code> <code class="n">PanacheEntity</code> <code class="o">{</code>&#13;
&#13;
    <code class="nd">@Column</code><code class="o">(</code><code class="n">unique</code> <code class="o">=</code> <code class="kc">true</code><code class="o">)</code>&#13;
    <code class="kd">public</code> <code class="n">String</code> <code class="n">name</code><code class="o">;</code>&#13;
&#13;
    <code class="kd">public</code> <code class="kt">int</code> <code class="n">age</code><code class="o">;</code>&#13;
&#13;
<code class="o">}</code></pre></div>&#13;
&#13;
<p>The <code>HTTPEndpoint</code> class uses an emitter to send the received <code>Person</code> instances to the <code>upload</code> channel.&#13;
In addition, this class has two methods. The <code>upload</code> method receives the <code>Person</code> sent by the user and emits it. The <code>getAll</code> method returns the list of the stored <code>Person</code> instances from the database.&#13;
In <a data-type="xref" href="#http-endpoint-10-26">Example 10-26</a>, we use this method to verify that everything works as expected.&#13;
The <code>upload</code> method returns <code>Uni&lt;Response&gt;</code>.&#13;
It creates the HTTP response asynchronously when the emitted message is acknowledged positively (then it returns a <code>202 - Accepted</code> response), or negatively (then it returns a <code>400 - Bad Request</code> response with the error message).&#13;
So, when the processing is successful, the user receives its response after the insertion in the database completes.</p>&#13;
<div data-type="example" id="http-endpoint-10-26">&#13;
<h5><span class="label">Example 10-26. </span>The HTTP endpoint (<em>chapter-10/database-example/src/main/java/org/acme/HttpEndpoint.java</em>)</h5>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kn">package</code> <code class="n">org</code><code class="o">.</code><code class="na">acme</code><code class="o">;</code>&#13;
&#13;
<code class="kn">import</code> <code class="nn">io.smallrye.mutiny.Uni</code><code class="o">;</code>&#13;
<code class="kn">import</code> <code class="nn">io.smallrye.reactive.messaging.MutinyEmitter</code><code class="o">;</code>&#13;
<code class="kn">import</code> <code class="nn">org.eclipse.microprofile.reactive.messaging.Channel</code><code class="o">;</code>&#13;
&#13;
<code class="kn">import</code> <code class="nn">javax.ws.rs.GET</code><code class="o">;</code>&#13;
<code class="kn">import</code> <code class="nn">javax.ws.rs.POST</code><code class="o">;</code>&#13;
<code class="kn">import</code> <code class="nn">javax.ws.rs.Path</code><code class="o">;</code>&#13;
<code class="kn">import</code> <code class="nn">javax.ws.rs.core.Response</code><code class="o">;</code>&#13;
<code class="kn">import</code> <code class="nn">java.util.List</code><code class="o">;</code>&#13;
&#13;
<code class="nd">@Path</code><code class="o">(</code><code class="s">"/"</code><code class="o">)</code>&#13;
<code class="kd">public</code> <code class="kd">class</code> <code class="nc">HttpEndpoint</code> <code class="o">{</code>&#13;
&#13;
    <code class="nd">@Channel</code><code class="o">(</code><code class="s">"upload"</code><code class="o">)</code>&#13;
    <code class="n">MutinyEmitter</code><code class="o">&lt;</code><code class="n">Person</code><code class="o">&gt;</code> <code class="n">emitter</code><code class="o">;</code>&#13;
&#13;
    <code class="nd">@POST</code>&#13;
    <code class="kd">public</code> <code class="n">Uni</code><code class="o">&lt;</code><code class="n">Response</code><code class="o">&gt;</code> <code class="nf">upload</code><code class="o">(</code><code class="n">Person</code> <code class="n">person</code><code class="o">)</code> <code class="o">{</code>&#13;
        <code class="k">return</code> <code class="n">emitter</code><code class="o">.</code><code class="na">send</code><code class="o">(</code><code class="n">person</code><code class="o">)</code>&#13;
                <code class="o">.</code><code class="na">replaceWith</code><code class="o">(</code><code class="n">Response</code><code class="o">.</code><code class="na">accepted</code><code class="o">().</code><code class="na">build</code><code class="o">())</code>&#13;
                <code class="o">.</code><code class="na">onFailure</code><code class="o">()</code>&#13;
                <code class="o">.</code><code class="na">recoverWithItem</code><code class="o">(</code><code class="n">t</code> <code class="o">-&gt;</code>&#13;
                        <code class="n">Response</code><code class="o">.</code><code class="na">status</code><code class="o">(</code><code class="n">Response</code><code class="o">.</code><code class="na">Status</code><code class="o">.</code><code class="na">BAD_REQUEST</code><code class="o">)</code>&#13;
                                <code class="o">.</code><code class="na">entity</code><code class="o">(</code><code class="n">t</code><code class="o">.</code><code class="na">getMessage</code><code class="o">()).</code><code class="na">build</code><code class="o">());</code>&#13;
    <code class="o">}</code>&#13;
&#13;
    <code class="nd">@GET</code>&#13;
    <code class="kd">public</code> <code class="n">Uni</code><code class="o">&lt;</code><code class="n">List</code><code class="o">&lt;</code><code class="n">Person</code><code class="o">&gt;&gt;</code> <code class="nf">getAll</code><code class="o">()</code> <code class="o">{</code>&#13;
        <code class="k">return</code> <code class="n">Person</code><code class="o">.</code><code class="na">listAll</code><code class="o">();</code>&#13;
    <code class="o">}</code>&#13;
&#13;
<code class="o">}</code></pre></div>&#13;
&#13;
<p>The <code>Processing</code> bean receives the uploaded <code>Person</code> instances and validates and formats the input (<a data-type="xref" href="#process-10-27">Example 10-27</a>).</p>&#13;
<div data-type="example" id="process-10-27">&#13;
<h5><span class="label">Example 10-27. </span>Process <code>Person</code> instances (<em>chapter-10/database-example/src/main/java/org/acme/Processing.java</em>)</h5>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kn">package</code> <code class="n">org</code><code class="o">.</code><code class="na">acme</code><code class="o">;</code>&#13;
&#13;
<code class="kn">import</code> <code class="nn">org.eclipse.microprofile.reactive.messaging.Incoming</code><code class="o">;</code>&#13;
<code class="kn">import</code> <code class="nn">org.eclipse.microprofile.reactive.messaging.Outgoing</code><code class="o">;</code>&#13;
&#13;
<code class="kn">import</code> <code class="nn">javax.enterprise.context.ApplicationScoped</code><code class="o">;</code>&#13;
&#13;
<code class="nd">@ApplicationScoped</code>&#13;
<code class="kd">public</code> <code class="kd">class</code> <code class="nc">Processing</code> <code class="o">{</code>&#13;
&#13;
    <code class="nd">@Incoming</code><code class="o">(</code><code class="s">"upload"</code><code class="o">)</code>&#13;
    <code class="nd">@Outgoing</code><code class="o">(</code><code class="s">"database"</code><code class="o">)</code>&#13;
    <code class="kd">public</code> <code class="n">Person</code> <code class="nf">validate</code><code class="o">(</code><code class="n">Person</code> <code class="n">person</code><code class="o">)</code> <code class="o">{</code>&#13;
        <code class="k">if</code> <code class="o">(</code><code class="n">person</code><code class="o">.</code><code class="na">age</code> <code class="o">&lt;=</code> <code class="mi">0</code><code class="o">)</code> <code class="o">{</code>&#13;
            <code class="k">throw</code> <code class="k">new</code> <code class="nf">IllegalArgumentException</code><code class="o">(</code><code class="s">"Invalid age"</code><code class="o">);</code>&#13;
        <code class="o">}</code>&#13;
&#13;
        <code class="n">person</code><code class="o">.</code><code class="na">name</code> <code class="o">=</code> <code class="n">capitalize</code><code class="o">(</code><code class="n">person</code><code class="o">.</code><code class="na">name</code><code class="o">);</code>&#13;
&#13;
        <code class="k">return</code> <code class="n">person</code><code class="o">;</code>&#13;
    <code class="o">}</code>&#13;
&#13;
    <code class="kd">public</code> <code class="kd">static</code> <code class="n">String</code> <code class="nf">capitalize</code><code class="o">(</code><code class="n">String</code> <code class="n">name</code><code class="o">)</code> <code class="o">{</code>&#13;
        <code class="kt">char</code><code class="o">[]</code> <code class="n">chars</code> <code class="o">=</code> <code class="n">name</code><code class="o">.</code><code class="na">toLowerCase</code><code class="o">().</code><code class="na">toCharArray</code><code class="o">();</code>&#13;
        <code class="kt">boolean</code> <code class="n">found</code> <code class="o">=</code> <code class="kc">false</code><code class="o">;</code>&#13;
        <code class="k">for</code> <code class="o">(</code><code class="kt">int</code> <code class="n">i</code> <code class="o">=</code> <code class="mi">0</code><code class="o">;</code> <code class="n">i</code> <code class="o">&lt;</code> <code class="n">chars</code><code class="o">.</code><code class="na">length</code><code class="o">;</code> <code class="n">i</code><code class="o">++)</code> <code class="o">{</code>&#13;
            <code class="k">if</code> <code class="o">(!</code><code class="n">found</code> <code class="o">&amp;&amp;</code> <code class="n">Character</code><code class="o">.</code><code class="na">isLetter</code><code class="o">(</code><code class="n">chars</code><code class="o">[</code><code class="n">i</code><code class="o">]))</code> <code class="o">{</code>&#13;
                <code class="n">chars</code><code class="o">[</code><code class="n">i</code><code class="o">]</code> <code class="o">=</code> <code class="n">Character</code><code class="o">.</code><code class="na">toUpperCase</code><code class="o">(</code><code class="n">chars</code><code class="o">[</code><code class="n">i</code><code class="o">]);</code>&#13;
                <code class="n">found</code> <code class="o">=</code> <code class="kc">true</code><code class="o">;</code>&#13;
            <code class="o">}</code> <code class="k">else</code> <code class="k">if</code> <code class="o">(</code><code class="n">Character</code><code class="o">.</code><code class="na">isWhitespace</code><code class="o">(</code><code class="n">chars</code><code class="o">[</code><code class="n">i</code><code class="o">]))</code> <code class="o">{</code>&#13;
                <code class="n">found</code> <code class="o">=</code> <code class="kc">false</code><code class="o">;</code>&#13;
            <code class="o">}</code>&#13;
        <code class="o">}</code>&#13;
        <code class="k">return</code> <code class="n">String</code><code class="o">.</code><code class="na">valueOf</code><code class="o">(</code><code class="n">chars</code><code class="o">);</code>&#13;
    <code class="o">}</code>&#13;
&#13;
<code class="o">}</code></pre></div>&#13;
&#13;
<p>It forwards the result to the <code>database</code> channel. The <code>Database</code> class reads this channel and writes the received <code>Person</code> to the database. To achieve this, we use the <code>withTransaction</code> and <code>persist</code> methods offered by Panache, as shown in <a data-type="xref" href="#persist-10-28">Example 10-28</a>.</p>&#13;
<div data-type="example" id="persist-10-28">&#13;
<h5><span class="label">Example 10-28. </span>Persist the entities in the database (<em>chapter-10/database-example/src/main/java/org/acme/Database.java</em>)</h5>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kn">package</code> <code class="n">org</code><code class="o">.</code><code class="na">acme</code><code class="o">;</code>&#13;
&#13;
<code class="kn">import</code> <code class="nn">io.quarkus.hibernate.reactive.panache.Panache</code><code class="o">;</code>&#13;
<code class="kn">import</code> <code class="nn">io.smallrye.mutiny.Uni</code><code class="o">;</code>&#13;
<code class="kn">import</code> <code class="nn">org.eclipse.microprofile.reactive.messaging.Incoming</code><code class="o">;</code>&#13;
&#13;
<code class="kn">import</code> <code class="nn">javax.enterprise.context.ApplicationScoped</code><code class="o">;</code>&#13;
&#13;
<code class="nd">@ApplicationScoped</code>&#13;
<code class="kd">public</code> <code class="kd">class</code> <code class="nc">Database</code> <code class="o">{</code>&#13;
&#13;
    <code class="nd">@Incoming</code><code class="o">(</code><code class="s">"database"</code><code class="o">)</code>&#13;
    <code class="kd">public</code> <code class="n">Uni</code><code class="o">&lt;</code><code class="n">Void</code><code class="o">&gt;</code> <code class="nf">write</code><code class="o">(</code><code class="n">Person</code> <code class="n">person</code><code class="o">)</code> <code class="o">{</code>&#13;
        <code class="k">return</code> <code class="n">Panache</code><code class="o">.</code><code class="na">withTransaction</code><code class="o">(</code><code class="nl">person:</code><code class="o">:</code><code class="n">persist</code><code class="o">)</code>&#13;
                <code class="o">.</code><code class="na">replaceWithVoid</code><code class="o">();</code>&#13;
    <code class="o">}</code>&#13;
&#13;
<code class="o">}</code></pre></div>&#13;
&#13;
<p>This pipeline only passes payloads.&#13;
So, when the last step completes, it acknowledges the message, which, going through the chain of messages, notifies the emitter.</p>&#13;
&#13;
<p>Run the application with <code>mvn quarkus:dev</code> from the <em>chapter-10/database-example</em> directory.&#13;
No need to provision a database; Quarkus starts a test database for you.&#13;
Then, in a terminal, send a <code>Person</code> instance by using <a data-type="xref" href="#upload-new-10-29">Example 10-29</a>.</p>&#13;
<div data-type="example" id="upload-new-10-29">&#13;
<h5><span class="label">Example 10-29. </span>Upload a new person</h5>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting">&gt;  curl -v --header <code class="s2">"Content-Type: application/json"</code>  <code class="se">\</code>&#13;
  POST --data <code class="s1">'{"name":"Luke", "age":19}'</code> <code class="se">\</code>&#13;
  http://localhost:8080</pre></div>&#13;
&#13;
<p>You should get a <code>202 - Accepted</code> response.&#13;
If you try to send an invalid payload, as shown in <a data-type="xref" href="#upload-invalid-10-30">Example 10-30</a>, you will get a <code>400</code> response.</p>&#13;
<div data-type="example" id="upload-invalid-10-30">&#13;
<h5><span class="label">Example 10-30. </span>Upload an invalid person</h5>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting">&gt;  curl -v --header <code class="s2">"Content-Type: application/json"</code> <code class="se">\</code>&#13;
  POST --data <code class="s1">'{"name":"Leia"}'</code> <code class="se">\</code>&#13;
  http://localhost:8080</pre></div>&#13;
&#13;
<p>You can use <code>curl</code> to check the stored instances.<a data-startref="ix_messaging-adoc14" data-type="indexterm" id="idm45358818358976"/><a data-startref="ix_messaging-adoc13" data-type="indexterm" id="idm45358818358368"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="idm45358818964528">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>In addition to having a reactive engine and providing asynchronous and nonblocking ways to deal with HTTP and databases, Quarkus comes with a message-based model called Reactive Messaging.</p>&#13;
&#13;
<p>Remember:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Reactive Messaging allows receiving, processing, and consuming messages transiting on channels.</p>&#13;
</li>&#13;
<li>&#13;
<p>The channel can be internal to the application, as you have seen in this chapter, or mapped to external destinations, as you will see in the next chapter.</p>&#13;
</li>&#13;
<li>&#13;
<p>Reactive Messaging supports positive and negative acknowledgment. You can decide the amount of control you need.</p>&#13;
</li>&#13;
<li>&#13;
<p>Reactive Messaging allows handling messages individually or supports the Mutiny API to implement more complex transformations.<a data-startref="ix_messaging-adoc1" data-type="indexterm" id="idm45358818323872"/><a data-startref="ix_messaging-adoc0" data-type="indexterm" id="idm45358818323168"/></p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>In the next chapter, we will look at two connectors that will allow interacting with Apache Kafka and AMQP to build reactive systems.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<div data-type="footnotes"><p data-type="footnote" id="idm45358821092016"><sup><a href="ch10.html#idm45358821092016-marker">1</a></sup> In this book, we use <code>MutinyEmitter</code>, but you can use plain <code>Emitter</code> instead, providing a slightly different API.</p><p data-type="footnote" id="idm45358820227664"><sup><a href="ch10.html#idm45358820227664-marker">2</a></sup> <a href="https://oreil.ly/hewBO">You can find the list of supported signatures on GitHub</a>.</p></div></div></section></body></html>