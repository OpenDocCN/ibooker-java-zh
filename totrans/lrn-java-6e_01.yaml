- en: Chapter 1\. A Modern Language
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一章：现代语言
- en: The greatest challenges and most exciting opportunities for software developers
    today lie in harnessing the power of networks. Applications created today, whatever
    their intended scope or audience, will almost certainly run on machines linked
    by a global network of computing resources. The increasing importance of networks
    is placing new demands on existing tools and fueling the demand for a rapidly
    growing list of completely new kinds of applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当今软件开发者面临的最大挑战和最激动人心的机遇在于利用网络的力量。无论今天创建的应用程序的预期范围或受众如何，几乎肯定会在由全球计算资源连接的机器上运行。网络的日益重要性正对现有工具提出新的要求，并推动对全新类型应用程序的迅速增长需求。
- en: As users, we want software that works—consistently, anywhere, on any platform—and
    that plays well with other applications. We want dynamic applications that take
    advantage of a connected world, capable of accessing disparate and distributed
    information sources. We want truly distributed software that can be extended and
    upgraded seamlessly. We want intelligent applications that can roam the cloud
    for us, ferreting out information and serving as electronic emissaries. We have
    known for some time what kind of software we want, but it is really only in the
    past few years that we have begun to get it.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 作为用户，我们希望软件能够一直正常工作，在任何平台上都表现良好，并且与其他应用程序兼容。我们希望动态应用程序能够利用连接的世界，并能够访问各种不同和分布的信息源。我们希望真正分布式的软件可以无缝扩展和升级。我们希望智能应用程序能够在云中为我们漫游，搜寻信息并作为电子使者服务。我们已经知道想要什么样的软件已有一段时间了，但真正开始得到这样的软件，实际上是在过去几年里。
- en: 'The problem, historically, has been that the tools for building these applications
    have fallen short. The requirements of speed and portability have been, for the
    most part, mutually exclusive, and security has been largely ignored or misunderstood.
    In the past, truly portable languages were bulky, interpreted, and slow. These
    languages were popular as much for their high-level functionality as for their
    portability. Fast languages usually provided speed by binding themselves to particular
    platforms, so they met the portability requirement only halfway. There were even
    a few languages that nudged programmers to write better, more secure code, but
    they were primarily offshoots of the portable languages and suffered from the
    same problems. Java is a modern language that addresses all three of these fronts:
    portability, speed, and security. This is why it remains a dominant language in
    the world of programming almost three decades after its introduction.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 历史上的问题在于构建这些应用程序的工具一直不足够完善。速度和可移植性的要求在很大程度上是互相矛盾的，而安全性则大多被忽视或误解。过去，真正可移植的语言往往又臃肿、解释性差且运行速度慢。这些语言之所以流行，除了其高级功能外，还因为它们的可移植性。快速语言通常通过绑定到特定平台来提供速度，因此它们只能在一定程度上满足可移植性要求。甚至有一些语言督促程序员编写更好、更安全的代码，但它们主要是可移植语言的衍生物，并遭遇同样的问题。Java
    是一种现代语言，同时解决了这三个方面：可移植性、速度和安全性。这就是为什么在其推出近三十年后，它仍然是编程世界的主导语言。
- en: Enter Java
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java 的介绍
- en: The Java programming language was designed to be a machine-independent programming
    language that is both safe enough to traverse networks and powerful enough to
    replace native executable code. Java addresses the issues raised here and played
    a starring role in the growth of the internet, leading to where we are today.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Java 编程语言被设计为一种机器无关的编程语言，既安全到足以在网络上传输，又强大到可以替代本地可执行代码。Java 解决了在这里提出的问题，并在互联网的发展中扮演了重要角色，导致我们今天的现状。
- en: Java has become the premier platform for web-based applications and web services.
    These applications use technologies such as the Java Servlet API, Java Web Services,
    and many popular open source and commercial Java application servers and frameworks.
    Java’s portability and speed make it the platform of choice for modern business
    applications. Java servers running on open source Linux platforms are at the heart
    of the business and financial world today.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Java 已经成为基于网络的应用程序和网络服务的首选平台。这些应用程序使用诸如 Java Servlet API、Java Web Services 以及许多流行的开源和商业
    Java 应用服务器和框架的技术。Java 的可移植性和速度使其成为现代业务应用程序的首选平台。运行在开源 Linux 平台上的 Java 服务器是当今商业和金融界的核心。
- en: Initially, most of the enthusiasm for Java centered on its capabilities for
    building embedded applications for the web, called *applets*. But in the early
    days, applets and other client-side graphical user interfaces (GUIs) written in
    Java were limited. Today, Java has Swing, a sophisticated toolkit for building
    GUIs. This development has allowed Java to become a viable platform for developing
    traditional client-side application software, although many other contenders have
    entered this crowded field.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，大多数对Java的热情集中在其构建Web嵌入式应用程序，即*applets*的能力上。但在早期，Java编写的applets和其他客户端图形用户界面（GUIs）是有限的。如今，Java拥有Swing，一个用于构建GUI的高级工具包。这一发展使Java成为开发传统客户端应用软件的可行平台，尽管许多其他竞争者已经进入了这个拥挤的领域。
- en: This book will show you how to use Java to accomplish real-world programming
    tasks. In the coming chapters we’ll introduce you to a wide selection of Java
    features, including text processing, networking, file handling, and building desktop
    applications with Swing.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本书将向您展示如何使用Java完成实际编程任务。在接下来的章节中，我们将向您介绍Java的各种特性，包括文本处理、网络编程、文件处理以及使用Swing构建桌面应用程序。
- en: Java’s Origins
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Java的起源
- en: The seeds of Java were planted in 1990 by Sun Microsystems patriarch and chief
    researcher Bill Joy. At the time, Sun was competing in a relatively small workstation
    market, while Microsoft was beginning its domination of the more mainstream, Intel-based
    PC world. When Sun missed the boat on the PC revolution, Joy retreated to Aspen,
    Colorado, to work on advanced research. He was committed to the idea of accomplishing
    complex tasks with simple software and founded the aptly named Sun Aspen Smallworks.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Java的种子在1990年由Sun Microsystems的创始人及首席研究员比尔·乔伊（Bill Joy）播下。当时，Sun在一个相对较小的工作站市场中竞争，而微软则开始主导更为主流的基于Intel的PC世界。当Sun错过了PC革命的机会后，乔伊退居到科罗拉多州的阿斯彭，致力于高级研究。他坚信通过简单的软件完成复杂任务的理念，并创立了名为Sun
    Aspen Smallworks的公司。
- en: Of the original members of the small team of programmers Joy assembled in Aspen,
    James Gosling will be remembered as the father of Java. Gosling first made a name
    for himself in the early 1980s as the author of Gosling Emacs, the first version
    of the popular Emacs editor that was written in C and ran under Unix. Gosling
    Emacs was soon eclipsed by a free version, GNU Emacs, written by Emacs’s original
    designer. By that time, Gosling had moved on to design Sun’s Network extensible
    Window System (NeWS), which briefly contended with the X Window System for control
    of the Unix GUI desktop in 1987\. Although some people would argue that NeWS was
    superior to X, NeWS lost because Sun kept it proprietary and didn’t publish source
    code, while the primary developers of X formed the X Consortium and took the opposite
    approach.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在乔伊在阿斯彭组建的小团队中的原始成员中，詹姆斯·戈斯林（James Gosling）将被铭记为Java的奠基人。戈斯林在1980年代初因编写Gosling
    Emacs而成名，Gosling Emacs是第一版用C语言编写且运行在Unix上的流行Emacs编辑器。Gosling Emacs很快被Emacs原始设计者编写的免费版本GNU
    Emacs所取代。当时，戈斯林已转向设计Sun的网络可扩展窗口系统（NeWS），该系统在1987年短暂地与X Window System竞争Unix GUI桌面的控制权。尽管有些人认为NeWS优于X，但由于Sun将其保持为专有且未发布源代码，而X的主要开发者成立了X
    Consortium并采取了相反的方法，NeWS最终失利。
- en: Designing NeWS taught Gosling the power of integrating an expressive language
    with a network-aware windowing GUI. It also taught Sun that the internet programming
    community will ultimately refuse to accept proprietary standards, no matter how
    good they may be. NeWS’s failure sowed the seeds of Java’s licensing scheme and
    open (if not quite “open source”) code. Gosling brought what he had learned to
    Bill Joy’s nascent Aspen project. In 1992, work on the project led to the founding
    of the Sun subsidiary FirstPerson, Inc. Its mission was to lead Sun into the world
    of consumer electronics.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 设计NeWS让戈斯林（Gosling）意识到将表达语言与网络感知的窗口化GUI集成的强大功能。它还让Sun了解到，互联网编程社区最终将拒绝接受任何专有标准，无论其多么优秀。NeWS的失败播下了Java许可证方案和开放（即便不是“开源”）代码的种子。戈斯林将他学到的知识带到了比尔·乔伊（Bill
    Joy）新成立的阿斯彭项目。1992年，项目的工作促成了Sun子公司FirstPerson, Inc.的成立。其使命是将Sun带入消费电子世界。
- en: The FirstPerson team worked on developing software for information appliances,
    such as cellular phones and personal digital assistants (PDAs). The goal was to
    enable the transfer of information and real-time applications over cheap infrared
    and traditional packet-based networks. Memory and bandwidth limitations dictated
    small, efficient code. The nature of the applications also demanded they be safe
    and robust. Gosling and his teammates began programming in C++, but they soon
    found themselves confounded by a language that was too complex, unwieldy, and
    insecure for the task. They decided to start from scratch, and Gosling began working
    on something he dubbed “C++ minus minus.”
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: FirstPerson 团队致力于开发信息设备软件，如手机和个人数字助理（PDA）。目标是通过廉价红外线和传统分组网络实现信息和实时应用程序的传输。内存和带宽限制要求代码小巧高效。应用程序的性质还要求它们安全可靠。Gosling
    和他的队友开始用 C++ 编程，但很快发现这种语言对于任务来说过于复杂、笨重且不安全。他们决定从头开始，并开始开发了被称为 "C++ 减减" 的东西。
- en: With the foundering of the Apple Newton (Apple’s earliest handheld computer),
    it became apparent that the PDA’s ship had not yet come in, so Sun shifted FirstPerson’s
    efforts to interactive TV (ITV). The programming language of choice for ITV set-top
    boxes was to be the near ancestor of Java, a language called Oak. Even with its
    elegance and ability to provide safe interactivity, Oak could not salvage the
    lost cause of ITV. Customers didn’t want it, and Sun soon abandoned the concept.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 随着苹果 Newton 的失败（苹果最早的手持电脑），PDA 的时代还未到来变得显而易见，因此 Sun 将 FirstPerson 的努力转向了互动电视（ITV）。ITV
    机顶盒的编程语言选择是 Java 的近祖语言 Oak。尽管 Oak 具有优雅和提供安全交互的能力，但它无法拯救 ITV 的失利。客户不喜欢它，Sun 很快放弃了这个概念。
- en: At that time, Joy and Gosling got together to decide on a new strategy for their
    innovative language. It was 1993, and the explosion of interest in the web presented
    a new opportunity. Oak was small, safe, architecture independent, and object-oriented.
    As it happens, these are also some of the requirements for a universal, internet-savvy
    programming language. Sun quickly changed focus, and, with a little retooling,
    Oak became Java.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 那时，Joy 和 Gosling 聚在一起为他们的创新语言制定新策略。那是 1993 年，对 Web 的兴趣爆发带来了新的机遇。Oak 是小巧、安全、架构无关和面向对象的。恰好这些特点也是通用、适应互联网的编程语言的要求之一。Sun
    迅速转变了焦点，并稍作调整，Oak 成为了 Java。
- en: Growing Up
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 成长过程
- en: It wouldn’t be an overstatement to say that Java (and its developer-focused
    bundle, the Java Development Kit, or JDK) caught on like wildfire. Even before
    its first official release, when Java was still a nonproduct, nearly every major
    industry player jumped on the Java bandwagon. Java licensees included Microsoft,
    Intel, IBM, and virtually all major hardware and software vendors. However, even
    with all this support, Java took a lot of knocks and experienced some growing
    pains during its first few years.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 可以毫不夸张地说，Java（以及面向开发者的捆绑包 Java 开发工具包或 JDK）如火如荼地流行起来。甚至在其正式发布之前，当 Java 仍然是一个非产品时，几乎所有主要行业参与者都跟随了
    Java 的热潮。Java 的许可证持有者包括 Microsoft、Intel、IBM 和几乎所有主要硬件和软件供应商。然而，尽管有这些支持，Java 在最初几年经历了许多挫折和成长的痛苦。
- en: A series of breach of contract and antitrust lawsuits between Sun and Microsoft
    over the distribution of Java and its use in Internet Explorer hampered its deployment
    on the world’s most common desktop operating system—​Windows. Microsoft’s involvement
    with Java also became one focus of a larger federal lawsuit over serious anticompetitive
    practices at the company. Court testimony revealed the software giant had attempted
    to undermine Java by introducing incompatibilities in its version of the language.
    Meanwhile, Microsoft introduced its own Java-derived language called C# (C-sharp)
    as part of its .NET initiative and dropped Java from inclusion in Windows. C#
    has gone on to become a very good language in its own right, enjoying more innovation
    in recent years than has Java.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Sun 和 Microsoft 之间关于 Java 分发和其在 Internet Explorer 中使用的违约和反垄断诉讼一系列事件，阻碍了其在全球最常见的桌面操作系统——Windows
    上的部署。Microsoft 参与 Java 也成为一个更大联邦诉讼的焦点，这场诉讼涉及公司严重的反竞争行为。法庭证词显示，这家软件巨头试图通过在其语言版本中引入不兼容性来破坏
    Java。与此同时，Microsoft 推出了自己的基于 Java 的语言 C#（C-sharp），作为其 .NET 计划的一部分，并取消了在 Windows
    中包含 Java 的计划。C# 自成一派，近年来的创新比 Java 更多。
- en: But Java continues to spread on a wide variety of platforms. As we begin looking
    at the Java architecture, you’ll see that much of what is exciting about Java
    comes from the self-contained virtual machine environment in which Java applications
    run. Java was carefully designed so that this supporting architecture can be implemented
    either in software, for existing computer platforms, or in customized hardware.
    Hardware implementations of Java are used in some smart cards and other embedded
    systems. You can even buy “wearable” devices, such as rings and dog tags, that
    have Java interpreters embedded in them. Software implementations of Java are
    available for all modern computer platforms, right down to portable computing
    devices. Today, an offshoot of the Java platform is the basis for Google’s Android
    operating system, which powers billions of phones and other mobile devices.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 但Java在各种平台上继续传播。当我们开始查看Java架构时，你会发现Java的许多激动人心之处来自Java应用程序运行的自包含虚拟机环境。Java经过精心设计，以便支持体系结构可以在现有计算机平台上以软件形式实现，或者在定制硬件上实现。Java的硬件实现用于某些智能卡和其他嵌入式系统。你甚至可以购买带有Java解释器的“可穿戴”设备，例如戒指和狗牌。Java的软件实现可用于所有现代计算机平台，甚至包括便携式计算设备。今天，Java平台的一个衍生是谷歌的Android操作系统的基础，该操作系统为数十亿台手机和其他移动设备提供动力。
- en: In 2010, Oracle Corporation bought Sun Microsystems and became the steward of
    the Java language. In a somewhat rocky start to its tenure, Oracle sued Google
    over its use of the Java language in Android and lost. In July 2011, Oracle released
    Java Standard Edition 7,^([1](ch01.html#id621)) a significant Java release that
    included a new I/O package. In 2017, Java 9 introduced modules to address some
    long-standing issues with the way Java applications were compiled, distributed,
    and executed. Java 9 also kicked off a rapid update process leading to some Java
    versions being designated “long-term support” and the rest as standard, short-term
    versions. (More on these and other versions in [“A Java Road Map”](#learnjava6-CHP-1-SECT-7).)
    Oracle continues to lead Java development; however, it has also bifurcated the
    Java world by moving the main Java deployment environment to a costly commercial
    license, while offering a free subsidiary OpenJDK option that retains the accessibility
    many developers love and expect.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 2010年，Oracle Corporation收购了Sun Microsystems，并成为Java语言的管理者。在其任期开始时有些波折，Oracle起诉谷歌使用Java语言开发Android，并失败了。2011年7月，Oracle发布了Java标准版7^([1](ch01.html#id621))，这是一个重要的Java版本，包括一个新的I/O包。2017年，Java
    9引入了模块，以解决Java应用程序编译、分发和执行方面长期存在的一些问题。Java 9还启动了一个快速更新流程，其中一些Java版本被指定为“长期支持”，其他版本则为标准的短期版本。（有关这些和其他版本的更多信息，请参见[“Java路线图”](#learnjava6-CHP-1-SECT-7)。）Oracle继续领导Java开发；但是，它还通过将主要的Java部署环境移动到昂贵的商业许可证，同时提供一个免费的OpenJDK选项，保留了许多开发人员喜欢和期望的可访问性，使Java世界分裂。
- en: A Virtual Machine
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个虚拟机
- en: Before we get much farther, it’s useful to know a bit more about the environment
    Java needs to do its magic. It’s OK if you don’t understand everything we touch
    on in these next sections. Any unfamiliar term you might see will get its due
    in later chapters. We just want to provide you with an overview of Java’s ecosystem.
    At the core of that ecosystem is the *Java Virtual Machine* (JVM).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续深入之前，了解Java所需的环境更有帮助。如果你对我们接下来要提到的内容不太理解，也没关系。你可能会在后面的章节中看到任何陌生的术语都会得到解释。我们只是想为你提供Java生态系统的概览。该生态系统的核心是*Java虚拟机*（JVM）。
- en: Java is both a compiled and an interpreted language. Java source code is turned
    into simple binary instructions, much like ordinary microprocessor machine code.
    However, whereas C or C++ source is reduced to native instructions for a particular
    model of processor, Java source is compiled into a universal format—instructions
    for the virtual machine known as *bytecode*.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Java既是一种编译语言，也是一种解释语言。Java源代码被转换成简单的二进制指令，类似于普通的微处理器机器码。然而，C或C++源代码被转换为特定型号处理器的本机指令，而Java源代码被编译成一种通用格式——称为*字节码*的虚拟机指令。
- en: Java bytecode is executed by a Java runtime interpreter. The runtime system
    performs all the normal activities of a hardware processor, but it does so in
    a safe, virtual environment. It executes a stack-based instruction set and manages
    memory like an operating system. It creates and manipulates primitive data types
    and loads and invokes newly referenced blocks of code. Most importantly, it does
    all this in accordance with a strictly defined open specification that can be
    implemented by anyone who wants to produce a Java-compliant virtual machine. Together,
    the virtual machine and language definition provide a complete specification.
    There are no features of the base Java language left undefined or implementation
    dependent. For example, Java specifies the sizes and mathematical properties of
    all its primitive data types rather than leaving it up to the platform implementation.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Java 字节码由 Java 运行时解释器执行。运行时系统执行硬件处理器的所有常规活动，但是在安全的虚拟环境中执行。它执行基于堆栈的指令集，并像操作系统一样管理内存。它创建和操作原始数据类型，并加载和调用新引用的代码块。最重要的是，它是根据严格定义的开放规范执行所有这些操作，任何希望生产符合
    Java 规范的虚拟机的人都可以实现。虚拟机和语言定义共同提供了完整的规范。没有基本 Java 语言留下未定义或依赖于实现的特性。例如，Java 指定了其所有原始数据类型的大小和数学属性，而不是由平台实现决定。
- en: The Java interpreter is relatively lightweight and small; it can be implemented
    in whatever form is desirable for a particular platform. The interpreter may be
    run as a separate application or it can be embedded in another piece of software,
    such as a web browser. Put together, this means that Java code is implicitly portable.
    The same Java application bytecode can run on any platform that provides a Java
    runtime environment, as shown in [Figure 1-1](#learnjava6-CHP-1-FIG-1). You don’t
    have to produce alternative versions of your application for different platforms,
    and you don’t have to distribute source code to end users.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Java 解释器相对轻量且小巧；它可以以适合特定平台的任何形式实现。解释器可以作为单独的应用程序运行，也可以嵌入到其他软件中，如 Web 浏览器中。总之，这意味着
    Java 代码具有隐式的可移植性。相同的 Java 应用程序字节码可以在任何提供 Java 运行时环境的平台上运行，如图[1-1](#learnjava6-CHP-1-FIG-1)所示。您无需为不同的平台制作替代版本的应用程序，也无需向最终用户分发源代码。
- en: '![ljv6 0101](assets/ljv6_0101.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 0101](assets/ljv6_0101.png)'
- en: Figure 1-1\. The Java runtime environment
  id: totrans-27
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1-1\. Java 运行时环境
- en: The fundamental unit of Java code is the *class*. As in other object-oriented
    languages, classes are small, modular application components that hold executable
    code and data. Compiled Java classes are distributed in a universal binary format
    that contains Java bytecode and other class information. Classes can be maintained
    discretely and stored in files or archives locally or on a network server. Classes
    are located and loaded dynamically at runtime as they are needed by an application.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Java 代码的基本单元是*类*。与其他面向对象的语言一样，类是小型、模块化的应用组件，包含可执行代码和数据。编译后的 Java 类以包含 Java 字节码和其他类信息的通用二进制格式分发。类可以离散维护，并存储在本地文件或网络服务器上。在运行时，类根据应用程序的需要动态定位和加载。
- en: In addition to the platform-specific runtime system, Java has a number of fundamental
    classes that contain architecture-dependent methods. These *native methods* serve
    as the gateway between the Java virtual machine and the real world. They are implemented
    in a natively compiled language on the host platform and provide low-level access
    to resources such as the network, the windowing system, and the host filesystem.
    The vast majority of Java, however, is written in Java itself—bootstrapped from
    these basic parts—and is therefore portable. This includes important Java tools
    such as the Java compiler also written in Java and therefore available on all
    Java platforms in exactly the same way without porting.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 除了特定于平台的运行时系统之外，Java 还有一些包含架构相关方法的基本类。这些*本地方法*作为 Java 虚拟机与现实世界之间的门户。它们在主机平台上以本地编译语言实现，并提供对网络、窗口系统和主机文件系统等资源的低级访问。然而，绝大部分的
    Java 是用 Java 自身编写的——从这些基本部分引导出来的，并因此具有可移植性。这包括像 Java 编译器这样重要的 Java 工具，也是用 Java
    编写的，因此在所有 Java 平台上以完全相同的方式可用，无需移植。
- en: Historically, interpreters have been considered slow, but Java is not a traditional
    interpreted language. In addition to compiling source code down to portable bytecode,
    Java has also been carefully designed so that software implementations of the
    runtime system can further optimize their performance by compiling bytecode to
    native machine code on the fly. This is called dynamic or *just-in-time* (JIT)
    compilation. With JIT compilation, Java code can execute as fast as native code
    and maintain its transportability and security.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 从历史上看，解释器一直被认为速度较慢，但 Java 不是传统的解释性语言。除了将源代码编译成可移植的字节码外，Java 还经过精心设计，使得运行时系统的软件实现可以通过即时将字节码编译为本地机器代码来进一步优化性能。这称为动态或*即时*（JIT）编译。通过
    JIT 编译，Java 代码可以像本地代码一样快速执行，并保持其可移植性和安全性。
- en: 'This JIT feature is an often misunderstood point among those who want to compare
    language performance. There is only one intrinsic performance penalty that compiled
    Java code suffers at runtime for the sake of security and virtual machine design—​array
    bounds checking. Everything else can be optimized to native code just as it can
    with a statically compiled language. Going beyond that, the Java language includes
    more structural information than many other languages, providing for more types
    of optimizations. Also remember that these optimizations can be made at runtime,
    taking into account the actual application behavior and characteristics. What
    can be done at compile time that can’t be done better at runtime? Well, there
    is a trade-off: time.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 JIT 特性是在想要比较语言性能的人中经常被误解的一个点。编译后的 Java 代码在运行时只有一个内在的性能惩罚，用于安全性和虚拟机设计——数组边界检查。除此之外，所有其他部分都可以像静态编译语言一样优化到本地代码。此外，Java
    语言包含比许多其他语言更多的结构信息，提供了更多类型的优化可能性。还要记住，这些优化可以在运行时进行，考虑到实际应用程序的行为和特性。什么可以在编译时完成，而在运行时不能更好地完成？嗯，这其中存在一个时间上的权衡。
- en: The problem with a traditional JIT compilation is that optimizing code takes
    time. While a JIT compiler can produce decent results, it may suffer significant
    latency when the application starts up. This is generally not a problem for long-running
    server-side applications, but it is a serious problem for client-side software
    and applications that run on smaller devices with limited capabilities. To address
    this, Java’s compiler technology, called HotSpot, uses a trick called *adaptive
    compilation*. If you look at what programs actually spend their time doing, it
    turns out that they spend almost all their time executing a relatively small part
    of the code again and again. The chunk of code that is executed repeatedly may
    be only a small fraction of the total program, but its behavior determines the
    program’s overall performance. Adaptive compilation allows the Java runtime to
    take advantage of new kinds of optimizations that simply can’t be done in a statically
    compiled language, hence the claim that Java code can run faster than C/C++ in
    some cases.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的即时编译（JIT）的问题在于优化代码需要时间。虽然 JIT 编译器可以产生不错的结果，但在应用程序启动时可能会遇到显著的延迟。对于长期运行的服务器端应用通常不是问题，但对于客户端软件和运行在性能有限设备上的应用程序来说，这是一个严重的问题。为了解决这个问题，Java
    的编译器技术，称为 HotSpot，使用了一种称为*自适应编译*的技巧。如果你看一下实际程序花费时间在做什么，会发现它们几乎全部时间都在反复执行一小部分代码。虽然这部分反复执行的代码可能只占总程序的一小部分，但其行为决定了程序的整体性能。自适应编译允许
    Java 运行时利用新型优化，这是静态编译语言无法做到的，因此有时声称 Java 代码在某些情况下可以比 C/C++ 运行得更快。
- en: 'To take advantage of this adaptive ability, HotSpot starts out as a normal
    Java bytecode interpreter, but with a difference: it measures (profiles) the code
    as it is executing to see what parts are being executed repeatedly. Once it knows
    which parts of the code are crucial to performance, HotSpot compiles those sections
    into optimal native machine code. Since it compiles only a small portion of the
    program into machine code, it can afford to take the time necessary to optimize
    those portions. The rest of the program may not need to be compiled at all—just
    interpreted—saving memory and time. In fact, the Java VM can run in one of two
    modes: client and server, which determine whether it emphasizes quick startup
    time and memory conservation or flat-out performance. As of Java 9, you can also
    put *ahead-of-time* (AOT) compilation to use if minimizing your application startup
    time is really important.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了充分利用这种自适应能力，HotSpot起初是一个普通的Java字节码解释器，但有所不同：它在执行过程中测量（profile）代码，以查看哪些部分被重复执行。一旦确定了代码中哪些部分对性能至关重要，HotSpot将这些部分编译为最佳的本机机器代码。由于它仅将程序的一小部分编译为机器代码，因此它可以花费必要的时间来优化这些部分。程序的其余部分可能根本不需要编译——只需要解释——从而节省内存和时间。事实上，Java虚拟机可以以两种模式之一运行：客户端和服务器，它们确定虚拟机是强调快速启动时间和内存节约，还是强调性能。自Java
    9以来，如果最小化应用程序的启动时间非常重要，您还可以使用*提前编译*（AOT）。
- en: 'A natural question to ask at this point is, why throw away all this good profiling
    information each time an application shuts down? Well, Sun partially broached
    this topic with the release of Java 5.0 through the use of shared, read-only classes
    that are stored persistently in an optimized form. This significantly reduced
    both the startup time and overhead of running many Java applications on a given
    machine. The technology for doing this is complex, but the idea is simple: optimize
    the parts of the program that need to go fast, and don’t worry about the rest.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 此时一个自然的问题是，为什么每次应用程序关闭时都要丢弃所有这些好的分析信息呢？嗯，Sun在Java 5.0发布中部分解决了这个问题，通过使用共享的只读类以优化的形式持久存储。这显著减少了在给定机器上运行许多Java应用程序的启动时间和开销。这样做的技术是复杂的，但思路很简单：优化需要快速执行的程序部分，而不必担心其余部分。
- en: Of course, “the rest” does contain code that could be further optimized. In
    2022, OpenJDK’s [Project Leyden](https://oreil.ly/pZnd5) kicked off with the intention
    of further reducing the startup time, minimizing the large size of Java applications,
    and reducing the time it takes for all of the previously mentioned optimizations
    to take full effect. The mechanisms proposed by Project Leyden are fairly complex,
    so we won’t be discussing them in this book. But we wanted to highlight the constant
    work going into developing and improving Java and its ecosystem. Even some 30
    years after its debut, Java remains a modern language.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，“其余部分”中可能包含进一步优化的代码。2022年，OpenJDK的[雷登项目](https://oreil.ly/pZnd5)启动，旨在进一步减少启动时间，最小化Java应用程序的大尺寸，并减少所有先前提到的优化所需的时间。雷登项目提出的机制相当复杂，因此我们在本书中不会讨论它们。但我们想要强调不断努力开发和改进Java及其生态系统的工作。即使在其首次亮相30年之后，Java仍然是一种现代语言。
- en: Java Compared with Other Languages
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java与其他语言比较
- en: Java’s developers drew on many years of programming experience with other languages
    in their choice of features. It is worth taking a moment to compare Java at a
    high level with some of those languages, both for the benefit of those of you
    with other programming experience and for the newcomers who need to put things
    in context. While this book does expect you to have some comfort with computers
    and software applications in a generic sense, we do not expect you to have knowledge
    of any particular programming language. When we refer to other languages by way
    of comparison, we hope that the comments are self-explanatory.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Java的开发者在选择功能时汲取了许多年使用其他语言进行编程的经验。值得一提的是，不论你有其他编程经验还是需要了解背景的新手，都应该花点时间将Java与一些其他语言在高层面进行比较。虽然本书确实希望你对计算机和软件应用有一定的了解，但我们并不指望你对任何特定的编程语言有所了解。当我们通过比较提到其他语言时，希望这些评论都是不言而喻的。
- en: 'At least three pillars are necessary to support a universal programming language
    today: portability, speed, and security. [Figure 1-2](#learnjava6-CHP-1-FIG-2)
    shows how Java compares to a few of the languages that were popular when it was
    created.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 至少有三个支撑通用编程语言的支柱是必需的：可移植性、速度和安全性。[图 1-2](#learnjava6-CHP-1-FIG-2)显示了Java与创建时流行的几种语言的比较。
- en: '![ljv6 0102](assets/ljv6_0102.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 0102](assets/ljv6_0102.png)'
- en: Figure 1-2\. Programming languages compared
  id: totrans-40
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1-2\. 编程语言比较
- en: You may have heard that Java is a lot like C or C++, but that’s really not true
    except at a superficial level. When you first look at Java code, you’ll see that
    the basic syntax looks like C or C++. But that’s where the similarities end. Java
    is by no means a direct descendant of C or a next-generation C++. If you compare
    language features, you’ll see that Java actually has more in common with highly
    dynamic languages, such as Smalltalk and Lisp. In fact, Java’s implementation
    is about as far from native C as you can imagine.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能听说过Java很像C或C++，但这只在表面上是真的。当你首次看到Java代码时，你会发现其基本语法看起来像C或C++。但相似之处就止步于此。Java绝非是C的直接后裔或是下一代C++。如果你比较语言特性，你会发现Java实际上更多地与Smalltalk和Lisp等高度动态的语言相似。事实上，Java的实现与本地的C相去甚远。
- en: If you are familiar with the current language landscape, you will notice that
    C#, a popular language, is missing from this comparison. C# is largely Microsoft’s
    answer to Java, admittedly with a number of niceties layered on top. Given their
    common design goals and approach (such as use of a virtual machine, bytecode,
    and a sandbox), the platforms don’t differ substantially in terms of their speed
    or security characteristics. C# is more or less as portable as Java. Like Java,
    C# borrows heavily from C syntax but is really a closer relative of the dynamic
    languages. Most Java developers find it relatively easy to pick up C# and vice
    versa. The majority of the time you’ll spend moving from one to the other will
    be in learning the standard library.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉当前的语言格局，你会注意到这个比较中缺少了一种流行的语言C#。C#主要是微软对Java的回应，诚然在其上面加了一些便利之处。鉴于它们共同的设计目标和方法（如使用虚拟机、字节码和沙箱），这些平台在速度或安全特性上并没有显著的区别。C#和Java一样具有高度的可移植性。与Java类似，C#在很大程度上借鉴了C语法，但实际上更接近动态语言的亲戚。大多数Java开发人员发现学习C#相对容易，反之亦然。你在从一种语言转向另一种语言时，大部分时间会花在学习标准库上。
- en: The surface-level similarities to these languages are worth noting, however.
    Java borrows heavily from C and C++ syntax, so you’ll see terse language constructs,
    including an abundance of curly braces and semicolons. Java subscribes to the
    C philosophy that a good language should be compact; in other words, it should
    be sufficiently small and regular that a programmer can hold all of its capabilities
    in their head at once. Just as C is extensible with libraries, packages of Java
    classes can be added to the core language components to extend its vocabulary.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 突出的是，这些语言与Java表面上的相似之处值得注意。Java在语法上大量借鉴了C和C++，因此你会看到简洁的语言结构，包括大量的花括号和分号。Java奉行C的哲学，即一个优秀的语言应该紧凑；换句话说，它应该足够小而规范，以至于程序员能够一次性掌握其所有能力。就像C可以通过库进行扩展一样，Java类的包可以被添加到核心语言组件中以扩展其词汇量。
- en: C has been successful because it provides a reasonably feature-packed programming
    environment, with high performance and an acceptable degree of portability. Java
    also tries to balance functionality, speed, and portability, but it does so in
    a very different way. C trades functionality for portability; Java initially traded
    speed for portability. Java also addresses security issues that C does not (although
    in modern systems, many of those concerns are now addressed in the operating system
    and hardware).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: C之所以成功，是因为它提供了一个功能丰富的编程环境，具有高性能和可接受的可移植性。Java也试图在功能性、速度和可移植性之间取得平衡，但其方式大不相同。C为了可移植性而牺牲了一些功能性；Java最初为了可移植性而牺牲了速度。Java还解决了C没有解决的安全问题（尽管在现代系统中，许多这些问题现在已在操作系统和硬件中得到解决）。
- en: Scripting languages such as Perl, Python, and Ruby remain popular. There’s no
    reason a scripting language can’t be suitable for safe, networked applications.
    But most scripting languages are not well suited for serious, large-scale programming.
    The attraction to scripting languages is that they are dynamic; they are powerful
    tools for rapid development. Some scripting languages such as Tcl (more popular
    when Java was being developed) also help programmers accomplish specific tasks,
    such as quickly creating graphical interfaces, that more general-purpose languages
    find unwieldy. Scripting languages are also highly portable, albeit at the source
    code level.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Perl、Python和Ruby等脚本语言仍然很受欢迎。脚本语言也可以适用于安全的、网络化的应用程序，这并不是没有道理的。但大多数脚本语言不太适合于严肃的、大规模的编程。人们对脚本语言的吸引力在于它们是动态的；它们是快速开发的强大工具。一些脚本语言，例如Tcl（在Java开发时更受欢迎），也有助于程序员完成特定任务，比如快速创建图形界面，而这是更通用的语言觉得难以驾驭的。脚本语言在源代码级别也非常易于移植。
- en: 'Not to be confused with Java, JavaScript is an object-based scripting language
    originally developed by Netscape for the web browser. It serves as a web browser
    resident language for dynamic, interactive, web-based applications. JavaScript
    takes its name from its integration with and similarities to Java, but the comparison
    really ends there. There are, however, significant applications of JavaScript
    outside of the browser, such as Node.js,^([2](ch01.html#id642)) and it continues
    to rise in popularity for developers in a variety of fields. For more information
    on JavaScript, check out *[JavaScript: The Definitive Guide](https://oreil.ly/qj5Jt)*
    by David Flanagan (O’Reilly).'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '与Java不同，JavaScript是一种由网景公司最初为网络浏览器开发的基于对象的脚本语言。它作为一种网页浏览器常驻语言，用于动态、交互式、基于网络的应用程序。JavaScript的名称来源于它与Java的集成和相似之处，但比较实际上在这里结束了。然而，JavaScript在浏览器之外也有重要的应用，比如Node.js，^([2](ch01.html#id642))，并且在各个领域的开发者中继续备受青睐。有关JavaScript的更多信息，请参阅David
    Flanagan（O''Reilly）撰写的*[JavaScript: 权威指南](https://oreil.ly/qj5Jt)*。'
- en: The problem with scripting languages is that they are rather casual about program
    structure and data typing. They have simplified type systems and generally don’t
    provide for sophisticated scoping of variables and functions. These characteristics
    make them less suitable for building large, modular applications. Speed is another
    problem with scripting languages; the high-level, usually source-interpreted nature
    of these languages often makes them quite slow.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本语言的问题是它们对程序结构和数据类型相当随意。它们有简化的类型系统，通常不提供变量和函数的复杂作用域。这些特点使得它们不太适合构建大型、模块化的应用程序。速度是脚本语言的另一个问题；这些语言通常高级、通常由源代码解释，使得它们的速度相当慢。
- en: 'Advocates of individual scripting languages would take issue with some of these
    generalizations, and no doubt they’d be right in some cases. Scripting languages
    have improved in recent years—especially JavaScript, which has had an enormous
    amount of research poured into its performance. But the fundamental trade-off
    is undeniable: scripting languages were born as loose, less-structured alternatives
    to systems programming languages, and they are generally not ideal for large or
    complex projects for a variety of reasons.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 对于各个脚本语言的支持者可能会对这些概括提出异议，毫无疑问，在某些情况下他们是正确的。最近几年，脚本语言已经有所改进，尤其是JavaScript，它已经投入了大量的研究来提高性能。但基本的权衡是不可否认的：脚本语言诞生为系统编程语言的松散、不太结构化的选择，它们通常对于各种原因不太适合用于大型或复杂的项目。
- en: 'Java offers some of the essential advantages of a scripting language: it is
    highly dynamic and has the added benefits of a lower-level language. Java has
    a powerful regular expression package that competes with Perl for working with
    text. It also has language features that streamline coding with collections, variable
    argument lists, static imports of methods, and other syntactic sugar that make
    it more concise.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Java提供了一些脚本语言的基本优势：它高度动态，还具有低级语言的额外好处。Java具有一个强大的正则表达式包，可与Perl一起用于处理文本。它还具有简化使用集合、变量参数列表、方法的静态导入等语言功能的语法糖，使其更加简洁。
- en: Incremental development with object-oriented components, combined with Java’s
    simplicity, make it possible to develop applications rapidly and change them easily.
    Studies have found that developing in Java is faster than in C or C++, strictly
    based on language features.^([3](ch01.html#id644)) Java also comes with a large
    base of standard core classes for common tasks such as building GUIs and handling
    network communications. Maven Central is an external resource with an enormous
    range of libraries and packages that can be quickly bundled into your environment
    to help you tackle all manner of new programming problems. Along with these features,
    Java has the scalability and software-engineering advantages of more static languages.
    It provides a safe structure on which to build higher-level frameworks (and even
    other languages).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 逐步开发面向对象组件，再加上Java的简洁性，使得能够快速开发和轻松变更应用程序成为可能。研究表明，基于语言特性，使用Java开发比使用C或C++更快。Java还配备了大量的标准核心类，用于常见任务，如构建GUI和处理网络通信。Maven中央仓库是一个外部资源，拥有大量的库和包，可以快速集成到您的环境中，帮助您解决各种新的编程问题。除了这些特性，Java还具有更静态语言的可扩展性和软件工程优势。它提供了一个安全的结构，可以构建更高级别的框架（甚至其他语言）。
- en: As we’ve already said, Java is similar in design to languages such as Smalltalk
    and Lisp. However, these languages were used mostly as research vehicles rather
    than for developing large-scale systems. One reason is that these languages never
    developed a standard portable binding to operating system services, such as the
    C standard library or the Java core classes. Smalltalk is compiled to an interpreted
    bytecode format, and it can be dynamically compiled to native code on the fly,
    just like Java. But Java improves on the design by using a bytecode verifier to
    ensure the correctness of compiled Java code. This verifier gives Java a performance
    advantage over Smalltalk because Java code requires fewer runtime checks. Java’s
    bytecode verifier also helps with security issues, something that Smalltalk doesn’t
    address.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所说，Java在设计上类似于Smalltalk和Lisp等语言。然而，这些语言主要用作研究工具，而不是用于开发大规模系统。其中一个原因是这些语言从未开发出标准的可移植绑定到操作系统服务，如C标准库或Java核心类。Smalltalk被编译为解释的字节码格式，并且可以动态地即时编译为本地代码，就像Java一样。但Java通过使用字节码验证器改进了设计，以确保编译后的Java代码的正确性。这个验证器使Java在性能上优于Smalltalk，因为Java代码需要较少的运行时检查。Java的字节码验证器还有助于处理安全问题，而Smalltalk则没有这方面的解决方案。
- en: Throughout the rest of this chapter, we’ll present a bird’s-eye view of the
    Java language. We’ll explain what’s new and what’s not-so-new about Java and why.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其余部分，我们将从宏观角度介绍Java语言。我们将解释Java的新特性和不那么新的特性，以及其背后的原因。
- en: Safety of Design
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计的安全性
- en: You have no doubt heard a lot about the fact that Java is designed to be a safe
    language. But what do we mean by safe? Safe from what or whom? The Java security
    features that attract the most attention are those that make possible new types
    of dynamically portable software. Java provides several layers of protection from
    dangerously flawed code as well as more mischievous things such as viruses and
    Trojan horses. In the next section, we’ll take a look at how the Java virtual
    machine architecture assesses the safety of code before it’s run and how the Java
    *class loader* (the bytecode loading mechanism of the Java interpreter) builds
    a wall around untrusted classes. These features provide the foundation for high-level
    security policies that can allow or disallow various kinds of activities on an
    application-by-application basis.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，你肯定听说过Java被设计为一种安全语言。但是安全是指什么？安全免受什么或者谁的影响？Java安全功能中最引人注目的是那些使新类型的动态可移植软件成为可能的功能。Java提供了几层保护，防止危险缺陷代码以及更加恶意的事物，如病毒和木马。在接下来的部分中，我们将看看Java虚拟机体系结构如何在代码运行之前评估其安全性，以及Java的*类加载器*（Java解释器的字节码加载机制）如何在不信任的类周围构建防护墙。这些功能为可以基于应用程序的基础安全策略提供了基础。
- en: In this section, though, we’ll look at some general features of the Java programming
    language. Perhaps more important than the specific security features, although
    often overlooked in the security din, is the safety that Java provides by addressing
    common design and programming problems. Java is intended to be as safe as possible
    from the simple mistakes programmers make ourselves, as well as those we inherit
    from legacy software. The goal with Java has been to keep the language simple,
    provide tools that have demonstrated their usefulness, and let users build more
    complicated facilities on top of the language when needed.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看一下Java编程语言的一些常规特性。也许比具体的安全特性更重要的是，虽然在安全争论中经常被忽略，但Java通过解决常见的设计和编程问题提供了安全性。Java的目标是尽可能地安全，以避免程序员自己制造的简单错误，以及我们从遗留软件中继承的错误。Java的目标是保持语言简单，提供已证明其有用的工具，并在需要时让用户在语言之上构建更复杂的设施。
- en: Simplify, Simplify, Simplify…​
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简化，简化，简化……
- en: With Java, simplicity rules. Since Java started with a clean slate, it avoided
    features that have proved messy or controversial in other languages. For example,
    Java doesn’t allow programmer-defined operator overloading (which, in some languages,
    allows programmers to redefine the meanings of basic symbols like + and –). Java
    doesn’t have a source code preprocessor, so it doesn’t have things like macros,
    `#define` statements, or conditional source compilation. These constructs exist
    in other languages primarily to support platform dependencies, so in that sense,
    they should not be needed in Java. Conditional compilation is also commonly used
    for debugging, but Java’s sophisticated runtime optimizations and features such
    as assertions solve the problem more elegantly.^([4](ch01.html#id650))
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，简单规则。由于Java从一张干净的纸开始，它避开了在其他语言中已经被证明混乱或有争议的功能。例如，Java不允许程序员定义的运算符重载（在某些语言中，允许程序员重新定义基本符号如+和-的含义）。Java没有源代码预处理器，因此它没有宏、`#define`语句或条件源代码编译之类的东西。这些构造主要存在于其他语言中以支持平台依赖性，因此从这个意义上讲，它们在Java中是不需要的。条件编译通常也用于调试，但Java的复杂运行时优化和诸如断言之类的特性更加优雅地解决了这个问题。^([4](ch01.html#id650))
- en: Java provides a well-defined *package* structure for organizing class files.
    The package system allows the compiler to handle some of the functionality of
    the traditional *make* utility (a tool for building executables from source code).
    The compiler can also work with compiled Java classes directly because all type
    information is preserved; there is no need for extraneous source “header” files,
    as in C/C++. All this means that Java code requires less context to read. Indeed,
    you may sometimes find it faster to look at the Java source code than to refer
    to class documentation.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Java为组织类文件提供了一个明确定义的*包*结构。包系统允许编译器处理一些传统*make*工具（用于从源代码构建可执行文件的工具）的功能。编译器还可以直接处理已编译的Java类，因为所有类型信息都得到了保留；不像C/C++中那样需要外部的源“头”文件。所有这些意味着Java代码需要更少的上下文来阅读。事实上，你有时可能会发现查看Java源代码比参考类文档更快。
- en: Java also takes a different approach to some structural features that have been
    troublesome in other languages. For example, Java supports only a single inheritance
    class hierarchy (each class may have only one “parent” class) but allows multiple
    inheritance of interfaces. An *interface*, like an abstract class in C++, specifies
    the behavior of an object without defining its implementation. It is a very powerful
    mechanism that allows the developer to define a “contract” for object behavior
    that can be used and referred to independently of any particular object implementation.
    Interfaces in Java eliminate the need for multiple inheritance of classes and
    the associated problems.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Java 也采用了一种与其他语言不同的结构特性。例如，Java仅支持单一继承类层次结构（每个类只能有一个“父”类），但允许多继承接口。*接口*，类似于C++中的抽象类，指定了对象的行为而不定义其实现。这是一个非常强大的机制，允许开发人员为对象行为定义一个“合约”，该合约可以独立于任何特定对象实现而被使用和引用。Java中的接口消除了对类的多重继承及相关问题的需求。
- en: As you’ll see in [Chapter 4](ch04.html#learnjava6-CHP-4), Java is a fairly simple
    and elegant programming language, and that is still a large part of its appeal.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您将在[第4章](ch04.html#learnjava6-CHP-4)中看到的，Java是一种相当简单和优雅的编程语言，这仍然是它吸引人的重要原因。
- en: Type Safety and Method Binding
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型安全和方法绑定
- en: One attribute of a language is the kind of *type checking* it uses. Generally,
    languages are categorized as *static* or *dynamic*, which refers to the amount
    of information about variables known at compile time versus what is known while
    the application is running.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 语言的一种属性是它所使用的*类型检查*的类型。一般来说，语言被归类为*静态*或*动态*，这指的是在编译时已知变量信息的数量与应用程序运行时已知信息的数量。
- en: In a strictly statically typed language such as C or C++, data types are etched
    in stone when the source code is compiled. The compiler benefits from this by
    having enough information to catch many kinds of errors before the code is executed.
    For example, the compiler would not allow you to store a floating-point value
    in an integer variable. The code then doesn’t require runtime type checking, so
    it can be compiled to be small and fast. But statically typed languages are inflexible.
    They don’t support collections as naturally as languages with dynamic type checking,
    and they make it impossible for an application to safely import new data types
    while it’s running.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在严格静态类型的语言中，比如C或C++，数据类型在源代码编译时就已经确定了。编译器通过这个特性获益，因为它能够在代码执行之前捕获许多种类的错误。例如，编译器不会允许你将浮点值存储在整数变量中。因此，代码不需要运行时类型检查，因此可以编译成小巧且快速的形式。但是，静态类型的语言是不灵活的。它们不像具有动态类型检查的语言那样自然地支持集合，并且在应用程序运行时无法安全地导入新的数据类型。
- en: In contrast, a dynamic language such as Smalltalk or Lisp has a runtime system
    that manages the types of objects and performs necessary type checking while an
    application is executing. These kinds of languages allow for more complex behavior
    and are in many respects more powerful. However, they are also generally slower,
    less safe, and harder to debug.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，诸如Smalltalk或Lisp之类的动态语言具有一个在应用程序执行时管理对象类型并执行必要类型检查的运行时系统。这些类型的语言允许更复杂的行为，并在许多方面更为强大。然而，它们通常更慢，不太安全，并且更难调试。
- en: 'The differences in languages have been likened to the differences among kinds
    of automobiles.^([5](ch01.html#id658)) Statically typed languages such as C++
    are analogous to a sports car: reasonably safe and fast, but useful only if you’re
    driving on a nicely paved road. Highly dynamic languages such as Smalltalk are
    more like an off-road vehicle: they afford you more freedom but can be somewhat
    unwieldy. It can be fun (and sometimes faster) to go roaring through the backwoods,
    but you might also get stuck in a ditch or mauled by bears.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 语言之间的差异被类比为汽车种类之间的差异。像C++这样的静态类型语言类似于跑车：相当安全和快速，但只有在平整的道路上才有用。而高度动态的语言，如Smalltalk更像越野车：它们为你提供了更多自由，但可能有些笨拙。在郊外呼啸而过可能很有趣（有时也更快），但你也可能会被卡在沟里或被熊攻击。
- en: Another attribute of a language is the way it binds method calls to their definitions.
    In a static language such as C or C++, the definitions of methods are normally
    bound at compile time, unless the programmer specifies otherwise. Languages like
    Smalltalk, on the other hand, are called *late binding* because they locate the
    definitions of methods dynamically at runtime. Early binding is important for
    performance reasons; it lets an application run without the overhead incurred
    by searching for methods at runtime. But late binding is more flexible. It’s also
    necessary in an object-oriented language where new types can be loaded dynamically
    and only the runtime system can determine which method to run.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 语言的另一个属性是它将方法调用与其定义绑定的方式。在静态语言（如C或C++）中，方法的定义通常在编译时绑定，除非程序员另有规定。另一方面，诸如Smalltalk之类的语言被称为*late
    binding*，因为它们在运行时动态地定位方法的定义。早期绑定对于性能至关重要；它让应用程序在运行时不需要为了查找方法而产生额外的开销。但是晚期绑定更加灵活。在一个支持动态加载新类型并且只有运行时系统能够确定要运行哪个方法的面向对象语言中，它也是必需的。
- en: Java provides some of the benefits of both C++ and Smalltalk; it’s a statically
    typed, late-binding language. Every object in Java has a well-defined type that
    is known at compile time. This means the Java compiler can do the same kind of
    static type checking and usage analysis as C++. As a result, you can’t assign
    an object to the wrong type of variable or call nonexistent methods on an object.
    The Java compiler goes even further and prevents you from using uninitialized
    variables and creating unreachable statements (see [Chapter 4](ch04.html#learnjava6-CHP-4)).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Java 提供了 C++ 和 Smalltalk 的一些优点；它是一种静态类型、后期绑定的语言。Java 中的每个对象都有一个在编译时就确定的明确类型。这意味着
    Java 编译器可以像 C++ 一样进行静态类型检查和使用分析。因此，你不能将一个对象分配给错误类型的变量，也不能在对象上调用不存在的方法。Java 编译器甚至进一步防止你使用未初始化的变量和创建不可达的语句（见[第4章](ch04.html#learnjava6-CHP-4)）。
- en: However, Java is fully runtime-typed as well. The Java runtime system keeps
    track of all objects and makes it possible to determine their types and relationships
    during execution. This means you can inspect an object at runtime to determine
    what it is. Unlike C or C++, the Java runtime system checks casts from one type
    of object to another, and it’s possible to use new kinds of dynamically loaded
    objects with a degree of type safety. And because Java uses late binding, it’s
    possible to write code that replaces some method definitions at runtime.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Java 也完全支持运行时类型。Java 运行时系统跟踪所有对象，并能在执行期间确定它们的类型和关系。这意味着你可以在运行时检查对象以确定其类型。与
    C 或 C++ 不同，Java 运行时系统检查从一个对象类型到另一个对象类型的强制转换，并且可以使用一定程度的类型安全加载新类型的动态加载对象。由于 Java
    使用后期绑定，因此可以编写在运行时替换某些方法定义的代码。
- en: Incremental Development
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 增量开发
- en: Java carries all data type and method signature information with it from its
    source code to its compiled bytecode form. This means that Java classes can be
    developed incrementally. Your own Java source code can also be compiled safely
    with classes from other sources your compiler has never seen. In other words,
    you can write new code that references binary class files without losing the type
    safety you gain from having the source code.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Java 将所有数据类型和方法签名信息从源代码到编译后的字节码形式都携带在一起。这意味着 Java 类可以逐步开发。你自己的 Java 源代码也可以安全地与编译器从未见过的其他源代码的类一起编译。换句话说，你可以编写引用二进制类文件的新代码，而不会失去源代码提供的类型安全性。
- en: Java does not suffer from the “fragile base class” problem. In languages such
    as C++, the implementation of a base class can be effectively frozen because it
    has many derived classes; changing the base class may require recompiling all
    of the derived classes. This is an especially difficult problem for developers
    of class libraries. Java avoids this problem by dynamically locating fields within
    classes. As long as a class maintains a valid form of its original structure,
    it can evolve without breaking other classes that are derived from it or use.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Java 不会遭受“脆弱基类”问题的困扰。在诸如 C++ 的语言中，基类的实现可以被有效冻结，因为它有许多派生类；改变基类可能需要重新编译所有派生类，这对类库开发者来说是一个特别困难的问题。Java
    通过动态定位类内的字段来避免这个问题。只要一个类保持其原始结构的有效形式，它就可以在不破坏从它派生或使用它的其他类的情况下进化。
- en: Dynamic Memory Management
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态内存管理
- en: Some of the most important differences between Java and lower-level languages
    (such as C or C++) involve how Java manages memory. Java eliminates ad hoc references
    to arbitrary areas of memory (*pointers*, in other languages) and adds some high-level
    data structures to the language. Java also cleans up unused objects (a process
    known as *garbage collection*) efficiently and automatically. These features eliminate
    many otherwise insurmountable problems with safety, portability, and optimization.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Java 与低级语言（如 C 或 C++）之间一些最重要的区别涉及 Java 如何管理内存。Java 消除了对任意内存区域的即兴引用（在其他语言中称为*指针*），并在语言中添加了一些高级数据结构。Java
    还有效且自动地清理未使用的对象（称为*垃圾收集*）。这些特性有效地消除了许多安全性、可移植性和优化方面的难题。
- en: 'Garbage collection alone has saved countless programmers from the single largest
    source of programming errors in C or C++: explicit memory allocation and deallocation.
    In addition to maintaining objects in memory, the Java runtime system keeps track
    of all references to those objects. When an object is no longer in use, Java automatically
    removes it from memory. You can, for the most part, simply ignore objects you
    no longer use, with confidence that the interpreter will clean them up at an appropriate
    time.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅通过垃圾收集就已经拯救了无数程序员免受 C 或 C++ 中显式内存分配和释放带来的最大编程错误的困扰。除了在内存中维护对象外，Java 运行时系统还跟踪所有对这些对象的引用。当一个对象不再使用时，Java
    会自动将其从内存中删除。在很大程度上，你可以简单地忽略不再使用的对象，并确信解释器会在适当的时候清理它们。
- en: 'Java uses a sophisticated garbage collector that runs in the background, which
    means that most garbage collecting takes place during idle times: between I/O
    pauses, mouse clicks, or keyboard hits. Some runtime systems, such as HotSpot,
    have more advanced garbage collection that can differentiate the usage patterns
    of objects (such as short-lived versus long-lived) and optimize their collection.
    The Java runtime can now tune itself automatically for the optimal distribution
    of memory for different kinds of applications based on their behavior. With this
    kind of runtime profiling, automatic memory management can be much faster than
    the most diligently programmer-managed resources, something that some old-school
    programmers still find hard to believe.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Java 使用了一个复杂的垃圾收集器，它在后台运行，这意味着大多数垃圾收集发生在空闲时间：在 I/O 暂停、鼠标点击或键盘敲击之间。一些运行时系统，如
    HotSpot，具有更先进的垃圾收集机制，可以区分对象的使用模式（如短期使用与长期使用），并优化它们的收集。Java 运行时现在可以根据应用程序的行为自动调整内存的最佳分配。通过这种运行时分析，自动内存管理比大多数勤勉管理资源的程序员更快，这是一些老派程序员难以相信的。
- en: We’ve said that Java doesn’t have pointers. Strictly speaking, this statement
    is true, but it’s also misleading. What Java provides are *references*—a safer
    kind of pointer. A reference is a strongly typed handle for an object. All objects
    in Java, with the exception of primitive numeric types, are accessed through references.
    You can use references to build all the normal kinds of data structures a C programmer
    would be accustomed to building with pointers, such as linked lists, trees, and
    so forth. The only difference is that with references, you have to do so in a
    type-safe way.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们说过 Java 没有指针。严格来说，这种说法是正确的，但也有误导性。Java 提供的是*引用*——一种更安全的指针。引用是一个强类型的对象句柄。在
    Java 中，除了原始数值类型，所有对象都通过引用访问。你可以使用引用来构建所有 C 程序员习惯用指针构建的常规数据结构，如链表、树等。唯一的区别是，使用引用时必须以类型安全的方式进行操作。
- en: References in Java cannot be changed in the same way as you alter pointers in
    languages like C. A reference is an atomic thing; you can’t manipulate the value
    of a reference except by assigning it to an object. References are passed by value,
    and you can’t reference an object through more than a single level of indirection.
    Protecting references is one of the most fundamental aspects of Java security.
    It means that Java code has to play by the rules; it can’t peek into places it
    shouldn’t to circumvent those rules.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 中，引用不能像在 C 等语言中更改指针那样更改。引用是一个原子事物；你不能通过除将其分配给对象外的任何方式操纵引用的值。引用是按值传递的，你不能通过超过单一间接级别来引用对象。保护引用是
    Java 安全性的基本方面之一。这意味着 Java 代码必须遵循规则；它不能窥视不应该窥视的地方以规避这些规则。
- en: Finally, we should mention that arrays (essentially indexed lists) in Java are
    true, first-class objects. They can be dynamically allocated and assigned like
    other objects. Arrays know their own size and type. Although you can’t directly
    define or subclass array classes, they do have a well-defined inheritance relationship
    based on the relationship of their base types. Having true arrays in the language
    alleviates much of the need for pointer arithmetic, such as that used in C or
    C++.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们应该提到，在 Java 中，数组（基本上是索引列表）是真正的一级对象。它们可以像其他对象一样动态分配和分配。数组知道它们自己的大小和类型。虽然你不能直接定义或子类化数组类，但它们确实基于其基本类型的关系具有良好定义的继承关系。语言中的真正数组减少了指针算术的需求，比如在
    C 或 C++ 中使用的那种。
- en: Error Handling
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 错误处理
- en: Java’s roots are in networked devices and embedded systems. For these applications,
    it’s important to have robust and intelligent error management. Java has a powerful
    mechanism for handling *exceptions*, somewhat like that in newer implementations
    of C++. Exceptions provide a more natural and elegant way to deal with errors.
    Exceptions allow you to separate error-handling code from normal code, which makes
    for cleaner, more readable applications.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Java的根源在于网络设备和嵌入式系统。对于这些应用程序，具有健壮和智能的错误管理是很重要的。Java具有处理*异常*的强大机制，与较新的C++实现类似。异常提供了一种更自然和优雅的处理错误的方式。异常允许您将错误处理代码与正常代码分离，从而实现更清晰、更易读的应用程序。
- en: When an exception occurs, it causes the flow of program execution to be transferred
    to a predesignated “catch” block of code. The exception carries with it an object
    that contains information about the situation that caused the problem. The Java
    compiler requires that a method either declare the exceptions it can generate
    or catch and deal with them itself. This promotes error information to the same
    level of importance as arguments and return types for methods. As a Java programmer,
    you know precisely what exceptional conditions you must deal with, and you have
    help from the compiler in writing correct software that doesn’t leave them unhandled.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当发生异常时，它会导致程序执行流转移到预先指定的“catch”代码块。异常携带一个对象，其中包含引发问题的情况信息。Java编译器要求方法要么声明它可以生成的异常，要么自己捕获并处理它们。这将错误信息提升到与方法参数和返回类型同等重要的水平。作为Java程序员，你清楚地知道你必须处理的异常情况，并且在编写正确的软件时，编译器提供了帮助，使它们不会未被处理。
- en: Threads
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程
- en: Modern applications require a high degree of parallelism. Even a very single-minded
    application can have a complex user interface, which requires concurrent activities.
    As machines get faster, users become less patient with unrelated tasks that seize
    control of their time. Threads provide efficient multiprocessing and distribution
    of tasks for both client and server applications. Java makes threads easy to use
    because support for them is built into the language.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现代应用程序需要高度的并行性。即使是非常专注的应用程序也可能拥有复杂的用户界面，这需要并发活动。随着计算机速度的提高，用户对占用其时间的不相关任务越来越没有耐心。线程为客户端和服务器应用程序提供了有效的多处理和任务分配。Java使得线程易于使用，因为它们的支持内置于语言中。
- en: Concurrency is nice, but there’s more to programming with threads than just
    performing multiple tasks simultaneously. In most cases, threads need to be *synchronized*
    (coordinated), which can be tricky without explicit language support. Java supports
    synchronization based on the *monitor* model—a sort of lock and key system for
    accessing resources. The keyword `synchronized` designates methods and blocks
    of code for safe, serialized access within an object. There are also simple, primitive
    methods for explicit waiting and signaling between threads interested in the same
    object.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 并发很好，但编程中线程还有更多内容，不仅仅是同时执行多个任务。在大多数情况下，线程需要*同步*（协调），没有显式语言支持可能会很棘手。Java支持基于*监视器*模型的同步，这是一种用于访问资源的锁定和解锁系统。关键字`synchronized`指定了方法和代码块，用于在对象内部进行安全的、序列化的访问。还有简单的原始方法，用于在线程之间等待和信号传递，这些线程对同一对象感兴趣。
- en: Java has a high-level concurrency package that provides powerful utilities addressing
    common patterns in multithreaded programming, such as thread pools, coordination
    of tasks, and sophisticated locking. With the addition of the concurrency package
    and related utilities, Java provides some of the most advanced thread-related
    utilities of any language. And when you need many, many threads, you can tap into
    the world of Project Loom’s virtual threads starting as a preview feature in Java
    19.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Java拥有一个高级并发包，提供了强大的实用程序，解决了多线程编程中的常见模式，例如线程池、任务协调和复杂的锁定。通过并发包及其相关实用程序的添加，Java提供了任何语言中一些最先进的与线程相关的实用程序。而且，当您需要许多线程时，您可以利用Java
    19中作为预览功能开始的Project Loom虚拟线程的世界。
- en: Although some developers may never have to write multithreaded code, learning
    to program with threads is an important part of mastering programming in Java
    and something all developers should grasp. See [Chapter 9](ch09.html#learnjava6-CHP-9)
    for a discussion of this topic. [“Virtual Threads”](ch09.html#learnjava6-CHP-9-SECT-3)
    in particular introduces virtual threads and highlights some of their performance
    gains.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管一些开发者可能永远不需要编写多线程代码，但学习使用线程编程是掌握Java编程的重要组成部分，也是所有开发者应该掌握的技能。请参阅[第9章](ch09.html#learnjava6-CHP-9)讨论这个主题。特别是[“虚拟线程”](ch09.html#learnjava6-CHP-9-SECT-3)介绍了虚拟线程并突出了它们的一些性能优势。
- en: Scalability
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可伸缩性
- en: As we noted earlier, Java programs primarily consist of classes. Over classes,
    Java provides *packages*, a layer of structure that groups classes into functional
    units. Packages provide a naming convention for organizing classes and a second
    tier of organizational control over the visibility of variables and methods in
    Java applications.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们早先指出的，Java程序主要由类组成。在类的基础上，Java提供了*包*，这是一种将类组织成功能单元的结构层。包为组织类提供了命名约定，并在Java应用程序中提供了第二层次的组织控制，用于控制变量和方法的可见性。
- en: Within a package, a class is either publicly visible or protected from outside
    access. Packages form another type of scope that is closer to the application
    level. This lends itself to building reusable components that work together in
    a system. Packages also help in designing a scalable application that can grow
    without becoming a bird’s nest of tightly coupled code. The reuse and scale issues
    are really only enforced with the module system added in Java 9.^([6](ch01.html#id687))
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个包内，类要么是公共可见的，要么受到外部访问的保护。包形成了更接近应用程序级别的另一种作用域。这有助于构建可重用的组件，这些组件在系统中协同工作。包还有助于设计可扩展的应用程序，而不至于使代码变得紧密耦合成一团。重用和规模问题在Java
    9中增加的模块系统中得到了真正的强化。^([6](ch01.html#id687))
- en: Safety of Implementation
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施安全性
- en: It’s one thing to create a language that prevents you from shooting yourself
    in the foot; it’s quite another to create one that prevents others from shooting
    you in the foot.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个防止自己踩到坑的语言是一回事；创建一个防止别人踩到坑的语言则是另一回事。
- en: '*Encapsulation* is the concept of hiding data and behavior within a class;
    it’s an important part of object-oriented design. It helps you write clean, modular
    software. In most languages, however, the visibility of data items is simply part
    of the relationship between the programmer and the compiler. It’s a matter of
    semantics, not an assertion about the actual security of the data in the context
    of the running program’s environment.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*封装*是将数据和行为隐藏在类内部的概念；它是面向对象设计的重要组成部分。它帮助你编写干净、模块化的软件。然而，在大多数语言中，数据项的可见性只是程序员与编译器之间关系的一部分。这是语义问题，而不是关于在运行程序环境中实际数据安全性的断言。'
- en: 'When Bjarne Stroustrup, the creator of C++, chose the keyword `private` to
    designate hidden members of classes in C++, he was probably thinking about shielding
    a developer from the messy details of another developer’s code, not about shielding
    that developer’s classes and objects from attack by someone else’s viruses and
    Trojan horses. Arbitrary casting and pointer arithmetic in C or C++ make it trivial
    to violate access permissions on classes without breaking the rules of the language.
    Consider the following code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当C++的创造者**Bjarne Stroustrup**选择关键字`private`来指定C++类中的隐藏成员时，他可能考虑的是保护开发者免受其他开发者代码中混乱细节的干扰，而不是保护开发者的类和对象免受他人病毒和特洛伊木马的攻击。在C或C++中，任意的类型转换和指针算术使得在不违反语言规则的情况下就能轻易违反类的访问权限。考虑以下代码：
- en: '[PRE0]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this little C++ drama, we have written some code that violates the encapsulation
    of the `Finances` class and pulls out some secret information. This sort of shenanigan—abusing
    an untyped pointer—is not possible in Java. If this example seems unrealistic,
    consider how important it is to protect the foundation (system) classes of the
    runtime environment from similar kinds of attacks. If untrusted code can corrupt
    the components that provide access to real resources such as the filesystem, network,
    or windowing system, it certainly has a chance at stealing your credit card numbers.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个小小的 C++ 情节中，我们编写了一些违反`Finances`类封装的代码，并提取了一些秘密信息。这种花招——滥用无类型指针——在 Java 中是不可能的。如果这个例子看起来不现实，请考虑保护运行环境基础（系统）类免受类似攻击的重要性。如果不受信任的代码可以破坏提供对真实资源（如文件系统、网络或窗口系统）访问的组件，那么它肯定有机会窃取你的信用卡号码。
- en: 'Java grew up with the internet—and all the untrusted sources that abound there.
    It used to require more security than it does now, but it retains a couple security
    features: a class loader handles loading classes from local storage or the network,
    and below that, all system security ultimately rests on the Java verifier, which
    guarantees the integrity of incoming classes.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Java 随着互联网的发展而成长，以及那里充斥着的不受信任的来源。它曾经需要比现在更多的安全性，但它仍然保留了一些安全特性：类加载器处理从本地存储或网络加载类，而所有系统安全性最终都依赖于
    Java 验证器，它保证了传入类的完整性。
- en: The Java bytecode verifier is a special module and a fixed part of the Java
    runtime system. Class loaders, however, are components that may be implemented
    differently by different applications, such as servers or web browsers. All of
    these pieces need to be functioning properly to ensure security in the Java environment.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Java 字节码验证器是 Java 运行时系统的一个特殊模块和固定部分。然而，类加载器是可以由不同应用程序（如服务器或网页浏览器）不同实现的组件。所有这些部分都需要正常工作，以确保
    Java 环境的安全性。
- en: The Verifier
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证器
- en: Java’s first line of defense is the *bytecode verifier*. The verifier reads
    bytecode before it is run and makes sure it is well-behaved and obeys the basic
    rules of the Java bytecode specification. A trusted Java compiler won’t produce
    code that does otherwise. However, it’s possible for a mischievous person to deliberately
    assemble bad Java bytecode. It’s the verifier’s job to detect this.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Java 的第一道防线是*字节码验证器*。验证器在运行前读取字节码，并确保它表现良好，遵守 Java 字节码规范的基本规则。受信任的 Java 编译器不会生成不符合规范的代码。然而，一个恶作剧的人可以故意组装出有问题的
    Java 字节码。检测这些问题就是验证器的工作。
- en: Once code has been verified, it’s considered safe from certain inadvertent or
    malicious errors. For example, verified code can’t forge references or violate
    access permissions on objects (as in our credit card example). It can’t perform
    illegal casts or use objects in unintended ways. It can’t even cause certain types
    of internal errors, such as overflowing or underflowing the internal stack. These
    fundamental guarantees underlie all of Java’s security.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦代码经过验证，它就被认为是免受某些无意或恶意错误的安全的。例如，经过验证的代码不能伪造引用或违反对象的访问权限（如我们的信用卡示例）。它不能执行非法强制类型转换或以非预期的方式使用对象。它甚至不能引起某些类型的内部错误，比如溢出或下溢出内部堆栈。这些基本保证构成了
    Java 安全性的基础。
- en: You might be wondering, isn’t this kind of safety implicit in lots of interpreted
    languages? Well, while it’s true that you shouldn’t be able to corrupt a BASIC
    interpreter with a bogus line of BASIC code, remember that the protection in most
    interpreted languages happens at a higher level. Those languages are likely to
    have heavyweight interpreters that do a great deal of runtime work, so they are
    necessarily slower and more cumbersome.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你会想，这种安全性在很多解释性语言中是隐含的吧？确实，你不应该用一个虚假的 BASIC 代码行来破坏 BASIC 解释器，但要记住，大多数解释性语言的保护发生在更高的级别。这些语言通常有重量级的解释器，在运行时做大量的工作，因此它们必然更慢、更繁琐。
- en: By comparison, Java bytecode is a relatively light, low-level instruction set.
    The ability to statically verify the Java bytecode before execution lets the Java
    interpreter run at full speed later with full safety, without expensive runtime
    checks. This was one of the fundamental innovations in Java.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，Java 字节码是一个相对轻量级的低级指令集。在执行之前静态验证 Java 字节码的能力，使得 Java 解释器在后续全速运行时可以安全地运行，而无需昂贵的运行时检查。这是
    Java 中的一个基本创新。
- en: The verifier is a type of mathematical “theorem prover.” It steps through the
    Java bytecode and applies simple, inductive rules to determine certain aspects
    of how the bytecode will behave. This kind of analysis is possible because compiled
    Java bytecode contains a lot more type information than the object code of other
    languages of this kind. The bytecode also has to obey a few extra rules that simplify
    its behavior. First, most bytecode instructions operate only on individual data
    types. For example, with stack operations, there are separate instructions for
    object references and for each of the numeric types in Java. Similarly, there
    is a different instruction for moving each type of value into and out of a local
    variable.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 验证器是一种类型的数学“定理证明器”。它逐步通过Java字节码并应用简单的归纳规则来确定字节码的某些行为方面。这种分析是可能的，因为编译后的Java字节码包含比其他类似语言的目标代码更多的类型信息。字节码还必须遵守一些额外的规则，以简化其行为。首先，大多数字节码指令只操作单个数据类型。例如，在堆栈操作中，对于对象引用和Java中每种数值类型都有单独的指令。类似地，将每种类型的值移入和移出本地变量也有不同的指令。
- en: Second, the type of object resulting from any operation is always known in advance.
    No bytecode operations consume values and produce more than one possible type
    of value as output. As a result, it’s always possible to look at the next instruction
    and its operands and know the type of value that will result.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，任何操作产生的对象类型始终是预先知道的。没有字节码操作会消耗值并产生多个可能类型的值作为输出。因此，始终可以查看下一个指令及其操作数，并知道将产生的值的类型。
- en: Because an operation always produces a known type, it’s possible to determine
    the types of all items on the stack and in local variables at any point in the
    future by looking at the starting state. The collection of all this type information
    at any given time is called the *type state* of the stack. This is what Java tries
    to analyze before it runs an application. Java doesn’t know anything about the
    actual values of stack and variable items at this time; it only knows what kind
    of items they are. However, this is enough information to enforce the security
    rules and to ensure that objects are not manipulated illegally.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 因为操作总是产生已知类型，所以可以通过查看起始状态来确定堆栈和本地变量中所有项目的类型在未来任何时间的类型。在任何给定时间收集到的所有这些类型信息称为堆栈的*类型状态*。这是Java在运行应用程序之前尝试分析的内容。此时，Java并不了解堆栈和变量项的实际值；它只知道它们是什么类型的项。但这已足够强制执行安全规则，并确保对象不被非法操纵。
- en: 'To make it feasible to analyze the type state of the stack, Java places an
    additional restriction on how its bytecode instructions are executed: all paths
    to the same point in the code must arrive with exactly the same type state.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使分析堆栈的类型状态变得可行，Java对其字节码指令的执行添加了额外的限制：所有到达代码中同一点的路径必须具有完全相同的类型状态。
- en: Class Loaders
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类加载器
- en: Java adds a second layer of security with a *class loader*. A class loader is
    responsible for bringing the bytecode for Java classes into the interpreter. Every
    application that loads classes from the network must use a class loader to handle
    this task.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Java通过*类加载器*添加了第二层安全性。类加载器负责将Java类的字节码带入解释器中。每个从网络加载类的应用程序都必须使用类加载器来处理此任务。
- en: After a class has been loaded and passed through the verifier, it remains associated
    with its class loader. As a result, classes are effectively partitioned into separate
    namespaces based on their origin. When a loaded class references another class
    name, the location of the new class is provided by the original class loader.
    This means that classes retrieved from a specific source can be restricted to
    interact only with other classes retrieved from that same location. For example,
    a Java-enabled web browser can use a class loader to build a separate space for
    all the classes loaded from a given URL. Sophisticated security based on cryptographically
    signed classes can also be implemented using class loaders.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 加载和通过验证的类保持与其类加载器相关联。因此，类基本上根据其来源被分隔成不同的命名空间。当一个加载的类引用另一个类名时，新类的位置由原始类加载器提供。这意味着从特定源检索的类可以限制只与从同一位置检索的其他类进行交互。例如，一个支持Java的网络浏览器可以使用类加载器为从给定URL加载的所有类构建一个单独的空间。还可以使用基于加密签名类的复杂安全性来实现类加载器。
- en: The search for classes always begins with the built-in Java system classes.
    These classes are loaded from the locations specified by the Java interpreter’s
    *classpath* (see [Chapter 3](ch03.html#learnjava6-CHP-3)). Classes in the classpath
    are loaded by the system only once and can’t be replaced. This means that it’s
    impossible for an application to replace fundamental system classes with its own
    versions that change their functionality.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 类搜索始终从内置的 Java 系统类开始。这些类是从 Java 解释器的*classpath*指定的位置加载的（参见[第 3 章](ch03.html#learnjava6-CHP-3)）。
    Classpath 中的类仅由系统加载一次，不可替换。这意味着应用程序无法用其自己的版本替换基本系统类以改变其功能。
- en: Application and User-Level Security
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序和用户级安全性
- en: There’s a fine line between having enough power to do something useful and having
    all the power to do anything you want. Java provides the foundation for a secure
    environment in which untrusted code can be quarantined, managed, and safely executed.
    However, unless you are content with keeping that code in a little black box and
    running it just for its own benefit, you will have to grant it access to at least
    some system resources so that it can be useful. Every kind of access carries with
    it certain risks and benefits. For example, in the cloud service environment,
    the advantages of granting untrusted (unknown) code access to the cloud server’s
    filesystem are that it can find and process large files faster than you could
    download them and process locally. The associated risks are that the code may
    instead sneak around the cloud server and possibly discover sensitive information
    it should not see.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在有足够的能力做一些有用事情和有权做任何想做的事之间存在一条细微的界线。Java 提供了一个安全环境的基础，其中不受信任的代码可以被隔离、管理和安全执行。然而，除非您满足于将该代码保持在一个小黑盒子中并仅为其自身运行，否则您将不得不授予它至少某些系统资源的访问权限，以使其有用。每种访问方式都伴随着一定的风险和利益。例如，在云服务环境中，授予不受信任（未知）代码访问云服务器文件系统的优点是，它可以比您下载并在本地处理大文件更快地找到和处理。相关的风险是，该代码可能会绕过云服务器并可能发现不应查看的敏感信息。
- en: At one extreme, the simple act of running an application gives it a resource—
    computation time—that it may put to good use or burn frivolously. It’s difficult
    to prevent an untrusted application from wasting your time or even attempting
    a “denial of service” attack. At the other extreme, a powerful, trusted application
    may justifiably deserve access to all sorts of system resources (like the filesystem,
    process creation, or network interfaces); a malicious application could wreak
    havoc with these resources. The message here is that you must address important
    and sometimes complex security issues in your programs.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在一端，运行应用程序仅仅为其提供了一个资源——计算时间——它可能会用于有益用途或者草率地浪费。防止不受信任的应用程序浪费您的时间甚至尝试“拒绝服务”攻击是困难的。在另一端，一个强大的、受信任的应用程序可能理所当然地需要访问各种系统资源（如文件系统、进程创建或网络接口）；恶意应用程序可能会对这些资源造成严重破坏。这里的信息是，您必须在程序中解决重要且有时复杂的安全问题。
- en: In some situations, it may be acceptable to simply ask the user to “okay” requests.
    The Java language provides the tools to implement any security policies you want.
    However, what policies you choose ultimately depends on whether or not you trust
    the identity and integrity of the code in question. This is where digital signatures
    come into play.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，简单要求用户“确认”请求可能是可以接受的。Java 语言提供了实现任何所需安全策略的工具。然而，你选择什么策略最终取决于你是否信任所涉代码的身份和完整性。这就是数字签名发挥作用的地方。
- en: Digital signatures, together with certificates, are techniques for verifying
    that data truly comes from the source it claims to have come from and hasn’t been
    modified en route. If the Bank of Boofa signs its checkbook application, you can
    verify that the app actually came from the bank rather than an imposter and hasn’t
    been modified. Therefore, you can tell your system to trust code that has the
    Bank of Boofa’s signature.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 数字签名与证书一起，是验证数据确实来自所声称的源并且在传输过程中未被修改的技术。如果 Boofa 银行签署其支票应用程序，您可以验证该应用实际来自银行而不是冒名顶替者，并且未被修改。因此，您可以告知您的系统信任具有
    Boofa 银行签名的代码。
- en: A Java Road Map
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java 路线图
- en: With the constant updates to Java, it’s hard to keep track of what features
    are available now, what’s promised, and what’s been around for some time. The
    following sections constitute a road map that imposes some order on Java’s past,
    present, and future. As for the versions of Java, Oracle’s release notes contain
    good summaries with links to further details. If you’re using older versions for
    work, consider reading over the [Oracle technology resources documents](https://oreil.ly/oi6eL).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 随着对Java的不断更新，很难跟踪目前有哪些功能可用，什么被承诺了，以及有些功能已经存在了一段时间。以下部分构成了Java过去、现在和未来的一张路线图。至于Java的版本，Oracle的发布说明包含了良好的总结，并链接到进一步的细节。如果你在工作中使用旧版本，请考虑阅读[Oracle技术资源文档](https://oreil.ly/oi6eL)。
- en: 'The Past: Java 1.0–Java 20'
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过去：Java 1.0–Java 20
- en: 'Java 1.0 provided the basic framework for Java development: the language itself,
    plus packages that let you write applets and simple applications. Although 1.0
    is officially obsolete, a few applets still exist that conform to its API.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Java 1.0为Java开发提供了基本框架：语言本身以及让你编写小程序和简单应用程序的包。虽然1.0已经正式过时，但仍然存在一些符合其API的小程序。
- en: Java 1.1 superseded 1.0, incorporating major improvements in the Abstract Window
    Toolkit (AWT) package (Java’s original GUI facility), a new event pattern, new
    language facilities such as reflection and inner classes, and many other critical
    features. Java 1.1 is the version that was supported natively by most versions
    of Netscape and Microsoft Internet Explorer for many years. For various political
    reasons, the browser world was frozen in this condition for a long time.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Java 1.1取代了1.0，在Abstract Window Toolkit（Java的原始GUI工具包）中进行了重大改进，引入了新的事件模式、反射和内部类等新的语言功能以及许多其他关键功能。Java
    1.1是多年来大多数版本的Netscape和Microsoft Internet Explorer本地支持的版本。出于各种政治原因，浏览器世界在这种状态下冻结了很长时间。
- en: Java 1.2, dubbed “Java 2” by Sun, was a major release in December 1998\. It
    provided many improvements and additions, mainly in terms of the set of APIs that
    were bundled into the standard distributions. The most notable additions were
    the inclusion of the Swing GUI package as a core API and a new, full-fledged 2D
    drawing API. Swing is Java’s advanced UI toolkit with capabilities far exceeding
    the old AWT’s. (Swing, AWT, and some other packages have been variously called
    the JFC, or Java Foundation Classes.) Java 1.2 also added a proper collections
    API to Java.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Java 1.2，由Sun称为“Java 2”，是1998年12月的一个重大发布。它提供了许多改进和新增内容，主要是在捆绑到标准发行版中的API集合方面。最显著的增加是将Swing
    GUI包含为核心API和全新的完整2D绘图API。Swing是Java的高级UI工具包，具有远远超过旧AWT的功能。 （Swing、AWT和其他一些包有时被称为JFC，或Java基础类）。Java
    1.2还为Java添加了适当的集合API。
- en: Java 1.3, released in early 2000, added minor features but was primarily focused
    on performance. With version 1.3, Java got significantly faster on many platforms,
    and Swing received many bug fixes. In this timeframe, Java enterprise APIs such
    as Servlets and Enterprise JavaBeans also matured.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Java 1.3于2000年初发布，添加了一些小的功能，但主要集中在性能上。通过1.3版本，Java在许多平台上显著提高了性能，并且Swing接收了许多错误修复。在此期间，Java企业API如Servlets和Enterprise
    JavaBeans也得到了成熟。
- en: Java 1.4, released in 2002, integrated a major new set of APIs and many long-awaited
    features. This included language assertions, regular expressions, preferences
    and logging APIs, a new I/O system for high-volume applications, standard support
    for XML, fundamental improvements in AWT and Swing, and a greatly matured Java
    Servlets API for web applications.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Java 1.4于2002年发布，集成了一组新的重要API和许多期待已久的功能。这包括语言断言、正则表达式、首选项和日志API、面向高容量应用的新I/O系统、标准XML支持、AWT和Swing的基本改进，以及大大成熟的Java
    Servlets API用于Web应用程序。
- en: Java 5, released in 2004, was a major release that introduced many long-awaited
    language syntax enhancements, including generics, type-safe enumerations, the
    enhanced for-loop, variable argument lists, static imports, autoboxing and unboxing
    of primitives, as well as advanced metadata on classes. A new concurrency API
    provided powerful threading capabilities, and APIs for formatted printing and
    parsing similar to those in C were added. Remote Method Invocation (RMI) was also
    overhauled to eliminate the need for compiled stubs and skeletons. There were
    also major additions in the standard XML APIs.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Java 5，发布于2004年，是一次重大的发布，引入了许多期待已久的语言语法增强功能，包括泛型、类型安全的枚举、增强型for循环、可变参数列表、静态导入、基本类型的自动装箱和拆箱，以及类的高级元数据。新的并发API提供了强大的线程能力，还添加了类似于C语言的格式化打印和解析API。远程方法调用（RMI）也进行了全面改进，消除了对编译的存根和骨架的需要。标准XML
    API中也有重大的新增功能。
- en: Java 6, released in late 2006, was a relatively minor release that added no
    new syntactic features to the Java language but bundled new extension APIs such
    as those for XML and web services.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Java 6，于2006年末发布，是一个相对较小的版本，未向Java语言添加任何新的语法特性，但捆绑了诸如XML和Web服务的新扩展API。
- en: Java 7, released in 2011, represented a fairly major update. Several small tweaks
    to the language such as allowing strings in `switch` statements (more on both
    of those things later!) along with major additions such as the `java.nio` new
    I/O library were packed into the five years after the release of Java 6.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Java 7，发布于2011年，代表了一次相当重要的更新。在发布Java 6后的五年中，语言进行了几次小的调整，例如允许在`switch`语句中使用字符串（稍后详述！），同时还有主要的新增内容，比如`java.nio`新I/O库。
- en: Java 8, released in 2014, completed a few of the features such as lambdas and
    default methods that had been dropped from Java 7 as the release date of that
    version was delayed again and again. This release also had some work done to the
    date and time support, including the ability to create immutable date objects,
    handy for use in the now-supported lambdas.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8，于2014年发布，完成了一些在Java 7中因版本发布日期反复推迟而被删除的功能，如lambda表达式和默认方法。此版本还对日期和时间支持进行了一些工作，包括创建不可变日期对象的能力，在支持的lambda中非常方便。
- en: 'Java 9, released after a number of delays in 2017, introduced the Module System
    (Project Jigsaw) as well as a Read-Evaluate-Print Loop (REPL) for Java: *jshell*.
    We’ll be using *jshell* for much of our quick explorations of many of Java’s features
    throughout the rest of this book. Java 9 also removed JavaDB from the JDK.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9，经历了一些延迟后于2017年发布，引入了模块系统（Project Jigsaw），以及Java的交互式命令行工具：*jshell*。在本书的剩余部分中，我们将大量使用*jshell*来快速探索Java的许多特性。Java
    9还从JDK中删除了JavaDB。
- en: Java 10, released shortly after Java 9 in early 2018, updated garbage collection
    and brought other features such as root certificates to the OpenJDK builds. Support
    for unmodifiable collections was added, and support for old look-and-feel packages
    (such as Apple’s Aqua) was removed.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Java 10，于2018年初在Java 9之后不久发布，更新了垃圾回收，并引入了其他功能，如根证书到OpenJDK构建。添加了对不可修改集合的支持，并删除了旧的外观包（如苹果的Aqua）的支持。
- en: Java 11, released in late 2018, added a standard HTTP client and Transport Layer
    Security (TLS) 1.3\. JavaFX and Java EE modules were removed. (JavaFX was redesigned
    to live on as a standalone library.) Java applets were also removed. Along with
    Java 8, Java 11 is part of Oracle’s long-term support (LTS). Certain releases—Java
    8, Java 11, Java 17, and Java 21—will be maintained for longer periods of time.
    Oracle is trying to change the way customers and developers engage with new releases,
    but good reasons still exist to stick with known versions. You can read more about
    Oracle’s thoughts and plans for both LTS and non-LTS releases at the Oracle Technology
    Network’s [Oracle Java SE Support Roadmap](https://oreil.ly/Ba97c).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Java 11，于2018年末发布，添加了标准的HTTP客户端和传输层安全性（TLS）1.3。JavaFX和Java EE模块被移除（JavaFX被重新设计为独立库）。Java小程序也被移除。与Java
    8一样，Java 11是Oracle的长期支持（LTS）版本之一。某些版本，如Java 8、Java 11、Java 17和Java 21，将会得到更长时间的支持。Oracle试图改变客户和开发者与新版本互动的方式，但仍有充分的理由选择已知的版本。您可以在Oracle技术网络的[Oracle
    Java SE支持路线图](https://oreil.ly/Ba97c)中详细了解Oracle的思路和计划。
- en: Java 12, released in early 2019, added minor language syntax enhancements such
    as a switch expressions preview.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Java 12，于2019年初发布，添加了一些次要的语言语法增强，如预览版的switch表达式。
- en: Java 13, released in September 2019, includes more language feature previews,
    such as text blocks, as well as a big reimplementation of the Sockets API. Per
    the official design docs, this impressive effort provides “a simpler and more
    modern implementation that is easy to maintain and debug.”
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Java 13，于2019年9月发布，包括更多语言特性预览，如文本块，以及套接字API的重大重新实现。根据官方设计文档，这一令人印象深刻的努力提供了“更简单和现代化的实现，易于维护和调试。”
- en: Java 14, released in March 2020, added more language syntax enhancement previews
    such as records, updated the garbage collection feature, and removed the Pack200
    tools and API. It also moved the switch expression first previewed in Java 12
    out of its preview state and into the standard language.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Java 14，于2020年3月发布，增加了更多语言语法增强预览，如记录，更新了垃圾收集功能，并移除了Pack200工具和API。还将在Java 12首次预览的`switch`表达式移出预览状态并纳入标准语言。
- en: Java 15, released in September 2020, moved support for text blocks (multiline
    strings) out of preview, and added both hidden and sealed classes that allow new
    ways to restrict access to certain code. (Sealed classes were kept as a preview
    feature.) Text encoding support was also updated to Unicode 13.0.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Java 15，于2020年9月发布，将文本块（多行字符串）支持从预览状态移出，并添加了隐藏类和密封类，允许新的方式限制对某些代码的访问。（密封类保持为预览功能。）文本编码支持也更新到Unicode
    13.0。
- en: Java 16, released in March 2021, kept sealed classes in preview but moved records
    out of preview. Networking APIs were expanded to include Unix domain sockets.
    It also added a list output option to the Streams API.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Java 16，于2021年3月发布，保持密封类处于预览状态，但将记录移出预览状态。扩展了网络API以包括Unix域套接字。还为Streams API添加了列表输出选项。
- en: Java 17, released in September 2021 with LTS, upgraded sealed classes to a regular
    feature of the language. A preview of pattern matching for `switch` statements
    was added along with several improvements on macOS. Datagram sockets can now be
    used to join multicast groups.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Java 17，于2021年9月发布，作为LTS版本，将密封类升级为语言的常规特性。增加了`switch`语句的模式匹配预览功能，并在macOS上进行了多项改进。现在可以使用数据报套接字加入多播组。
- en: Java 18, released in March 2022, finally made UTF-8 the default character set
    for Java SE APIs. It introduced a simple, static web server appropriate for prototyping
    or testing, and expanded the options for IP address resolution.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Java 18，于2022年3月发布，最终将UTF-8设置为Java SE API的默认字符集。引入了一个适用于原型设计或测试的简单静态Web服务器，并扩展了IP地址解析的选项。
- en: Java 19, released in September 2022, previewed virtual threads, structured concurrency,
    and record patterns. Unicode support moved to version 14.0, and some additional
    date-time formats were added.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Java 19，于2022年9月发布，预览了虚拟线程、结构化并发和记录模式。Unicode支持升级到了版本14.0，并添加了一些额外的日期时间格式。
- en: Java 20, released in March 2023, finally removed several threading operations
    (stop/pause/resume) that were deprecated as unsafe over 20 years earlier in JDK
    1.2\. String parsing was improved to support graphemes, such as composed emoji
    symbols.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Java 20，于2023年3月发布，最终移除了早在JDK 1.2中标记为不安全的多达20年的多线程操作（停止/暂停/恢复）。改进了字符串解析以支持图素，例如组合表情符号。
- en: 'The Present: Java 21'
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 现在：Java 21
- en: This book includes all the latest and greatest improvements through the release
    of Java 21 in September 2023\. With a six-month release cadence in place, newer
    versions of the JDK will almost certainly be available by the time you read this.
    As noted above, Oracle wants developers to treat these releases as feature updates.
    With the exception of the examples that cover virtual threads, Java 17 is sufficient
    for working with the code in this book. In the rare cases where we use a more
    recent feature, we will note the minimum version required. You will not need to
    “keep up” while reading, but if you are using Java for published projects, consider
    going over Oracle’s official road map to see if staying current makes sense.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 本书涵盖了截至2023年9月发布的Java 21的所有最新改进。随着每六个月一次的发布节奏，当您阅读本书时，新版本的JDK几乎肯定已经推出。如上所述，Oracle希望开发人员将这些发布视为功能更新。除了覆盖虚拟线程的示例，Java
    17足以处理本书中的代码。在我们使用更新功能的罕见情况下，我们将注明所需的最低版本。在阅读时，您无需“跟进”，但如果您在已发布的项目中使用Java，请考虑查看Oracle的官方路线图，以确定保持最新状态是否有意义。
- en: Feature overview
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 功能概述
- en: 'Here’s a brief overview of the most important features of the current core
    Java API that live outside the standard library:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是当前Java核心API中最重要的功能的简要概述，这些功能位于标准库之外：
- en: '*Java Database Connectivity (JDBC)*'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '-   *Java数据库连接（JDBC）*'
- en: A general facility for interacting with databases (introduced in Java 1.1).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 与数据库交互的通用设施（Java 1.1中引入）。
- en: '*Remote Method Invocation (RMI)*'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '*远程方法调用（RMI）*'
- en: Java’s distributed objects system. RMI lets you call methods on objects hosted
    by a server running somewhere else on the network (introduced in Java 1.1).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Java的分布式对象系统。RMI允许您在网络上运行某处的服务器上托管的对象的方法调用（Java 1.1中引入）。
- en: '*Java Security*'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*Java安全性*'
- en: A facility for controlling access to system resources, combined with a uniform
    interface to cryptography. Java Security is the basis for signed classes.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 控制访问系统资源的设施，结合统一的加密接口。Java安全性是签名类的基础。
- en: '*Java Desktop*'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '*Java桌面*'
- en: A catchall for a large number of features starting with Java 9, including the
    Swing UI components; “pluggable look and feel,” which allows you to adapt and
    theme the entire UI itself; drag and drop; 2D graphics; printing; image and sound
    display, playback, and manipulation; and accessibility features that can integrate
    with special software and hardware for people with visual or other impairments.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 从Java 9开始的大量功能的通用收集，包括Swing UI组件；“可插入的外观和感觉”，允许您自定义和主题整个UI本身；拖放；2D图形；打印；图像和声音的显示、播放和操作；以及可以与视觉或其他障碍的人使用的特殊软件和硬件集成的无障碍功能。
- en: '*Internationalization*'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '*国际化*'
- en: The ability to write programs that adapt themselves to the language and locale
    the user wants to use. The program automatically displays text in the appropriate
    language (introduced in Java 1.1).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 能够编写能够适应用户希望使用的语言和区域设置的程序。程序会自动以适当的语言显示文本（Java 1.1中引入）。
- en: '*Java Naming and Directory Interface (JNDI)*'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*Java命名和目录接口（JNDI）*'
- en: A general service for looking up resources. JNDI unifies access to directory
    services, such as LDAP, Novell’s NDS, and others.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 用于查找资源的通用服务。JNDI统一访问目录服务，如LDAP、Novell的NDS等。
- en: 'The following are “standard extension” APIs. Some, such as those for working
    with XML and web services, are bundled with the standard edition of Java; some
    must be downloaded separately and deployed with your application or server:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是“标准扩展”API。有些与Java标准版捆绑在一起，如用于处理XML和Web服务的API；有些必须单独下载并与您的应用程序或服务器一起部署：
- en: '*JavaMail*'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '*JavaMail*'
- en: A uniform API for writing email software.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 用于编写电子邮件软件的统一API。
- en: '*Java Media Framework*'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '*Java媒体框架*'
- en: Another catchall for coordinating the display of many different kinds of media
    that includes Java 2D, Java 3D, Java Speech (for both speech recognition and synthesis),
    Java Sound (high-quality audio), Java TV (for interactive television and similar
    applications), and others.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个用于协调显示多种媒体的通用组件的收集，包括Java 2D、Java 3D、Java语音（用于语音识别和合成）、Java音频（高质量音频）、Java
    TV（用于互动电视和类似应用程序）等。
- en: '*Java Servlets*'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '*Java Servlets*'
- en: A facility that lets you write server-side web applications in Java.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 一个能让您在Java中编写服务器端Web应用程序的设施。
- en: '*Java Cryptography*'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '*Java加密*'
- en: Actual implementations of cryptographic algorithms. (This package was separated
    from Java Security for legal reasons.)
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 密码算法的实际实现。（出于法律原因，此包已从Java安全性中分离出来。）
- en: '*eXtensible Markup Language/eXtensible Stylesheet Language (XML/XSL)*'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '*可扩展标记语言/可扩展样式表语言（XML/XSL）*'
- en: Tools for creating and manipulating XML documents, validating them, mapping
    them to and from Java objects, and transforming them with stylesheets.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 用于创建和操作XML文档的工具，验证它们，将它们映射到Java对象，以及使用样式表进行转换。
- en: We’ll try to touch on some of these features. Unfortunately for us (but fortunately
    for Java software developers), the Java environment has become so rich that it’s
    impossible to cover everything in a single book. We’ll note other books and resources
    that do cover any topics we can’t tackle in depth.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将尽量涉及这些特性。对我们来说很不幸（但对于Java软件开发者来说很幸运），Java环境变得如此丰富，以至于不可能在一本书中涵盖所有内容。我们会注意到其他覆盖我们无法深入讲解的主题的书籍和资源。
- en: The Future
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 未来展望
- en: Java is certainly not the new kid on the block these days, but it continues
    to be one of the most popular platforms for web and application development. This
    is especially true in the areas of web services, web application frameworks, and
    XML tools. While Java has not dominated mobile platforms in the way it seemed
    destined to, you can use the Java language and core APIs to program for Google’s
    Android mobile OS, which is used on billions of devices around the world. In the
    Microsoft camp, the Java-derived C# language has taken over much .NET development
    and brought the core Java syntax and patterns to those platforms.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的 Java 绝对不是新手，但它仍然是 Web 和应用程序开发中最受欢迎的平台之一。尤其是在 Web 服务、Web 应用框架和 XML 工具领域。虽然
    Java 并没有像预期的那样主导移动平台，但你可以使用 Java 语言和核心 API 为 Google 的 Android 移动操作系统编程，Android
    操作系统在全球亿万台设备上使用。在 Microsoft 阵营，源自 Java 的 C# 语言已经接管了大量的 .NET 开发，并将核心 Java 语法和模式带到了这些平台。
- en: The JVM itself is also an interesting area of exploration and growth. New languages
    are cropping up to take advantage of the JVM’s feature set and ubiquity. [Clojure](https://clojure.org)
    is a robust functional language with a growing fan base cropping up in a range
    of work, from hobbyists to the biggest of the big-box stores. And [Kotlin](https://kotlinlang.org)
    is a general-purpose language taking over Android development with gusto. It is
    gaining traction in new environments while retaining good interoperability with
    Java.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: JVM 本身也是一个有趣的探索和成长领域。新语言不断涌现，以利用 JVM 的功能集和普及度。[Clojure](https://clojure.org)
    是一种强大的函数式语言，拥有越来越多的粉丝，应用范围从业余爱好者到最大的零售商。还有 [Kotlin](https://kotlinlang.org)，这是一种通用语言，正以极大的热情占据
    Android 开发市场。它在新环境中 gaining traction，同时保持与 Java 的良好互操作性。
- en: Probably the most exciting areas of change in Java today are found in the trends
    toward lighter-weight, simpler frameworks for business and toward integrating
    the Java platform with dynamic languages for scripting web pages and extensions.
    There is much more interesting work to come.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 目前 Java 最令人兴奋的变化领域可能是在朝着更轻量、更简单的业务框架发展，并且将 Java 平台与动态语言结合起来，用于脚本编写网页和扩展。还有更多有趣的工作等待着我们。
- en: You have several choices for Java development environments and runtime systems.
    Oracle’s Java Development Kit is available for macOS, Windows, and Linux. Visit
    [Oracle’s Java website](https://oreil.ly/rDigu) for more information about obtaining
    the latest official JDK.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你有多个选择用于 Java 开发环境和运行时系统。Oracle 的 Java 开发工具包可在 macOS、Windows 和 Linux 上使用。访问
    [Oracle 的 Java 网站](https://oreil.ly/rDigu) 获取有关获取最新官方 JDK 的更多信息。
- en: Since 2017, Oracle has officially supported updates to the open source OpenJDK.
    Individuals and small (or even medium-sized) companies may find this free version
    sufficient. The releases lag behind the commercial JDK release and do not include
    Oracle’s tech support, but Oracle has stated a firm commitment to maintaining
    free and open access to Java. All of the examples in this book were written and
    tested using the OpenJDK. You can get more details direct from the horse’s (Oracle’s?)
    mouth on the [OpenJDK site](https://openjdk.org).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 自 2017 年起，Oracle 官方支持开源 OpenJDK 的更新。个人和小型（甚至中型）公司可能会发现这个免费版本足够使用。该版本的发布滞后于商业
    JDK 的发布，并且不包括 Oracle 的技术支持，但 Oracle 已明确表示将坚定地维护 Java 的免费和开放访问。书中的所有示例都是使用 OpenJDK
    编写和测试的。你可以通过 [OpenJDK 网站](https://openjdk.org) 从“马嘴”（Oracle?）那里获取更多详细信息。
- en: For quick installation of a free version of Java 19 (sufficient for almost all
    examples in this book, although we do note a few language features from later
    releases), Amazon offers its [Corretto](https://oreil.ly/DVjwL) distribution online
    with friendly, familiar installers for all three major platforms. [Chapter 2](ch02.html#learnjava6-CHP-2)
    will walk you through the basic Corretto installation on Windows, macOS, and Linux.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 快速   为了快速安装 Java 19 的免费版本（足够应付本书中的几乎所有示例，尽管我们会提到一些后续版本的语言特性），Amazon 在线提供了其 [Corretto](https://oreil.ly/DVjwL)
    发行版，配有友好的、熟悉的安装程序，支持所有三大主流平台。[第 2 章](ch02.html#learnjava6-CHP-2)将指导你在 Windows、macOS
    和 Linux 上进行基本的 Corretto 安装。
- en: 'There is also an array of popular Java Integrated Development Environments
    (IDEs). We’ll discuss one in this book: the free Community Edition of JetBrains’s
    [IntelliJ IDEA](https://oreil.ly/gpGao). This all-in-one development environment
    lets you write, test, and package software with advanced tools at your fingertips.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 也有一系列受欢迎的Java集成开发环境（IDE）。我们将在本书中讨论其中之一：JetBrains的免费社区版[IntelliJ IDEA](https://oreil.ly/gpGao)。这款一体化开发环境让您可以使用先进的工具编写、测试和打包软件。
- en: Exercises
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: At the end of each chapter, we’ll provide a few questions and code exercises
    for you to review. The answers to the questions can be found in [Appendix B](app02.html#learnjava6-APP-B).
    Solutions to code exercises are included with the other code examples on [GitHub](https://github.com/l0y/learnjava6e).
    ([Appendix A](app01.html#learnjava6-APP-A) provides details on downloading and
    using the code for this book.) We encourage you to answer the questions and try
    the exercises. Don’t worry if you have to go back into a chapter and read a little
    more to find an answer or look up some method name. That’s the point! Learning
    how to use this book as a reference will come in handy down the road.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 每章结束时，我们都会提供一些问题和代码练习供您复习。问题的答案可以在[附录 B](app02.html#learnjava6-APP-B)中找到。代码练习的解决方案包含在[GitHub](https://github.com/l0y/learnjava6e)的其他代码示例中。（[附录 A](app01.html#learnjava6-APP-A)提供了下载和使用本书代码的详细信息。）我们鼓励您回答这些问题并尝试这些练习。如果您不得不返回章节并阅读更多内容以找到答案或查找某些方法名称，不要担心！这就是目的！学习如何使用本书作为参考将在未来派上用场。
- en: Which company currently maintains Java?
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前谁在维护Java？
- en: What is the name of the open source development kit for Java?
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Java的开源开发工具包的名称是什么？
- en: Name the two main components that play a role in Java’s approach to securely
    running bytecode.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Java安全运行字节码的两个主要组件是什么？
- en: ^([1](ch01.html#id621-marker)) The Standard Edition (SE) moniker appeared early
    in Java’s history when Sun released the J2EE platform, or Java 2 Enterprise Edition.
    The Enterprise Edition now goes by the name “Jakarta EE.”
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch01.html#id621-marker)) 标准版（SE）这个名词早在Java历史的早期出现，当Sun发布了J2EE平台或Java 2企业版时。现在企业版改名为“Jakarta
    EE”。
- en: ^([2](ch01.html#id642-marker)) If you are curious about Node.js, check out Andrew
    Mead’s [*Learning Node.js Development*](https://oreil.ly/Dl_FL) and Shelley Powers’s
    [*Learning Node*](https://oreil.ly/ZRl15) at the O’Reilly site.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch01.html#id642-marker)) 如果你对Node.js感兴趣，请查看Andrew Mead的[*学习Node.js开发*](https://oreil.ly/Dl_FL)和Shelley
    Powers的[*学习Node*](https://oreil.ly/ZRl15)，位于O’Reilly网站上。
- en: ^([3](ch01.html#id644-marker)) See, for example, G. Phipps, [“Comparing Observed
    Bug and Productivity Rates for Java and C++”](https://oreil.ly/zgpMa), *Software—Practice
    & Experience*, Volume 29, 1999.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch01.html#id644-marker)) 例如，查看G. Phipps的[“比较Java和C++的观察到的错误和生产率率”](https://oreil.ly/zgpMa)，*软件—实践与经验*，第29卷，1999年。
- en: ^([4](ch01.html#id650-marker)) Assertions are beyond the scope of this book,
    but they are a worthy topic for exploration after you’ve gained more of a foothold
    in Java. You’ll find some basic details in the [Oracle Java SE Documentation](https://oreil.ly/-giQD).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch01.html#id650-marker)) 断言不在本书的讨论范围内，但在你对Java有更深入了解后，它们是一个值得探索的话题。你可以在[Oracle
    Java SE Documentation](https://oreil.ly/-giQD)中找到一些基本的详情。
- en: ^([5](ch01.html#id658-marker)) The credit for the car analogy goes to Marshall
    P. Cline, author of *C++ FAQ*.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch01.html#id658-marker)) 车辆类比的荣誉归功于Marshall P. Cline，*C++ FAQ*的作者。
- en: ^([6](ch01.html#id687-marker)) Modules are beyond the scope of this book, but
    they are the sole focus of [*Java 9 Modularity*](https://oreil.ly/TLbpl) by Paul
    Bakker and Sander Mak (O’Reilly).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch01.html#id687-marker)) 模块不在本书的讨论范围内，但它们是Paul Bakker和Sander Mak（O’Reilly）的[*Java
    9模块化*](https://oreil.ly/TLbpl)的唯一焦点。
