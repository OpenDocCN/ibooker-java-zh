- en: Chapter 5\. Introduction to Object-Oriented Design in Java
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章 Java面向对象设计简介
- en: In this chapter, we will consider several techniques relevant to object-oriented
    design (OOD) in Java.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将考虑与Java中面向对象设计（OOD）相关的几种技术。
- en: We’ll look at how to work with Java’s objects, covering the key methods of `Object`,
    aspects of object-oriented design, and implementing exception handling schemes.
    Throughout the chapter, we will be introducing some *design patterns*—essentially
    best practices for solving some very common situations that arise in software
    design. Toward the end of the chapter, we’ll also consider *safe* programs—those
    that are designed so as not to become inconsistent over time.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论如何处理Java的对象，涵盖`Object`的关键方法、面向对象设计的方面以及实现异常处理方案。在整个章节中，我们将介绍一些*设计模式*——基本上是解决软件设计中一些非常常见情况的最佳实践。在本章的末尾，我们还将考虑*安全*程序——这些程序设计得不会随着时间的推移而变得不一致。
- en: Note
  id: totrans-3
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: This chapter is intended to showcase some examples of a complex topic and a
    few underlying principles. We encourage you to consult additional resources, such
    as *Effective Java* by Josh Bloch.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章旨在展示一个复杂主题和一些基本原则的示例。我们鼓励您查阅其他资源，比如Josh Bloch的*Effective Java*。
- en: We’ll get started by considering the subject of Java’s calling and passing conventions
    and the nature of Java values.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始考虑Java的调用和传递约定以及Java值的性质。
- en: Java Values
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java值
- en: 'Java’s values, and their relationship to the type system, are quite straightforward.
    Java has two types of values: primitives and object references.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Java的值及其与类型系统的关系非常直接。Java有两种类型的值：原始值和对象引用。
- en: Note
  id: totrans-8
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: There are only eight different primitive types in Java, and new primitive types
    cannot be defined by the programmer.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Java中只有八种不同的原始类型，并且程序员不能定义新的原始类型。
- en: The key difference between primitive values and references is that primitive
    values cannot be altered; the value `2` is always the same value. By contrast,
    the contents of object references can usually be changed—often referred to as
    *mutation* of object contents.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 原始值和引用之间的关键区别在于原始值不能被更改；值`2`始终是相同的值。相比之下，对象引用的内容通常可以更改——通常称为对象内容的*突变*。
- en: Also note that variables can contain values only of the appropriate type. In
    particular, variables of reference type always contain a reference to the memory
    location holding the object—they do not contain the object contents directly.
    This means that in Java there is no equivalent of a dereference operator or a
    `struct`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 还请注意，变量只能包含适当类型的值。特别是，引用类型的变量始终包含对持有对象的内存位置的引用——它们不直接包含对象内容。这意味着在Java中没有等价的解引用运算符或`struct`。
- en: 'Java tries to simplify a concept that often confused C++ programmers: the difference
    between “contents of an object” and “reference to an object.” Unfortunately, it’s
    not possible to completely hide the difference, and so it is necessary for the
    programmer to understand how reference values work in the platform.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Java试图简化一个经常让C++程序员困惑的概念：“对象的内容”和“对象的引用”的区别。不幸的是，完全隐藏这种差异是不可能的，因此程序员有必要了解引用值在平台上的工作原理。
- en: 'The fact that Java is pass by value can be demonstrated very simply, e.g.,
    by running the following code:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Java是按值传递的事实可以非常简单地证明，例如，通过运行以下代码：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This outputs `Radius: 2` twice and thus shows that even after the call to `manipulate()`,
    the value contained in variable `c` is unaltered—it is still holding a reference
    to a `Circle` object of radius 2. If Java was a pass-by-reference language, it
    would instead be holding a reference to a radius 3 `Circle`:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '这会两次输出`Radius: 2`，因此显示即使在调用`manipulate()`之后，变量`c`中包含的值也未更改——它仍然持有半径为2的`Circle`对象的引用。如果Java是一种按引用传递的语言，那么它将持有对半径为3的`Circle`的引用：'
- en: If we’re scrupulously careful about the distinction, and about referring to
    object references as one of Java’s possible kinds of values, then some otherwise
    surprising features of Java become obvious. Be careful! Some older texts are ambiguous
    on this point. We will meet this concept of Java’s values again when we discuss
    memory and garbage collection in [Chapter 6](ch06.xhtml#javanut8-CHP-6).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们对这种区别非常小心，并且将对象引用称为Java可能的一种值类型之一，则Java的一些否则令人惊讶的特性变得明显。要小心！一些较旧的文本在这一点上是含糊的。当我们讨论内存和垃圾收集时，我们将再次遇到Java值的概念
    [第6章](ch06.xhtml#javanut8-CHP-6)。
- en: Important Common Methods
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重要的常见方法
- en: As we’ve noted, all classes extend, directly or indirectly, `java.lang.Object`.
    This class defines a number of useful methods, some of which were designed to
    be overridden by classes you write. [Example 5-1](#javanut8-CHP-5-EX-1) shows
    a class that overrides these methods. The sections that follow this example document
    the default implementation of each method and explain why you might want to override
    it.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所述，所有类都直接或间接扩展自`java.lang.Object`。该类定义了许多有用的方法，其中一些是为你编写的类设计的。[示例 5-1](#javanut8-CHP-5-EX-1)展示了一个重写了这些方法的类。接下来的章节将文档化每个方法的默认实现，并解释为何你可能需要重写它们。
- en: Note that this example is for demonstration purposes only; in reality, we would
    represent classes like `Circle` as records and get a lot of these methods implemented
    automatically by the compiler.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此示例仅用于演示目的；在实际情况中，我们会将类如`Circle`表示为记录，并让编译器自动实现许多这些方法。
- en: Example 5-1\. A class that overrides important Object methods
  id: totrans-20
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-1\. 一个重写重要Object方法的类
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[Example 5-1](#javanut8-CHP-5-EX-1) uses a lot of the extended features of
    the type system that we introduced in [Chapter 4](ch04.xhtml#javanut8-CHP-4).
    First, this example implements a parameterized, or generic, version of the `Comparable`
    interface. Second, it uses the `@Override` annotation to emphasize (and have the
    compiler verify) that certain methods override `Object`.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 5-1](#javanut8-CHP-5-EX-1)展示了我们在[第四章](ch04.xhtml#javanut8-CHP-4)中介绍的类型系统的许多扩展特性。首先，该示例实现了一个参数化或泛型版本的`Comparable`接口。其次，它使用`@Override`注解来强调（并让编译器验证）某些方法覆盖了`Object`。'
- en: toString()
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: toString()
- en: The purpose of the `toString()` method is to return a textual representation
    of an object. The method is invoked automatically on objects during string concatenation
    and by methods such as `System.out.println()`. Giving objects a textual representation
    can be quite helpful for debugging or logging output, and a well-crafted `toString()`
    method can even help with tasks such as report generation.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`toString()`方法的目的是返回对象的文本表示。在字符串连接和诸如`System.out.println()`等方法中，对象会自动调用此方法。给对象提供文本表示在调试或日志输出中非常有用，一个精心制作的`toString()`方法甚至可以帮助生成报告。'
- en: The version of `toString()` inherited from `Object` returns a string that includes
    the name of the class of the object as well as a hexadecimal representation of
    the `hashCode()` value of the object (discussed later in this chapter). This default
    implementation provides basic type and identity information for an object but
    is not very useful. The `toString()` method in [Example 5-1](#javanut8-CHP-5-EX-1)
    instead returns a human-readable string that includes the value of each of the
    fields of the `Circle` class.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 继承自`Object`的`toString()`版本返回一个字符串，包括对象的类名以及对象的`hashCode()`值的十六进制表示（本章稍后讨论）。这个默认实现为对象提供了基本的类型和标识信息，但不是非常有用。[示例 5-1](#javanut8-CHP-5-EX-1)中的`toString()`方法返回一个包含`Circle`类每个字段值的可读字符串。
- en: equals()
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: equals()
- en: 'The `==` operator tests two references to see if they refer to the same object.
    If you want to test whether two distinct objects are equal to one another, you
    must use the `equals()` method instead. Any class can define its own notion of
    equality by overriding `equals()`. The `Object.equals()` method simply uses the
    `==` operator: this default method considers two objects equal only if they are
    actually the very same object.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`==`运算符测试两个引用是否指向同一个对象。如果你想测试两个不同的对象是否相等，你必须使用`equals()`方法。任何类都可以通过重写`equals()`方法来定义自己的相等性概念。`Object.equals()`方法简单地使用`==`运算符：此默认方法只在两个对象实际上是同一个对象时才认为它们相等。'
- en: 'The `equals()` method in [Example 5-1](#javanut8-CHP-5-EX-1) considers two
    distinct `Circle` objects to be equal if their fields are all equal. Note that
    it first does a quick identity test with `==` as an optimization and then checks
    the type of the other object with `instanceof`: a `Circle` can be equal only to
    another `Circle`, and it is not acceptable for an `equals()` method to throw a
    `ClassCastException`. Note that the `instanceof` test also rules out `null` arguments:
    `instanceof` always evaluates to `false` if its lefthand operand is `null`.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 5-1](#javanut8-CHP-5-EX-1)中，`equals()`方法认为两个不同的`Circle`对象在它们的字段都相等时是相等的。注意，它首先通过`==`进行快速的身份测试作为优化，然后使用`instanceof`检查其他对象的类型：一个`Circle`只能与另一个`Circle`相等，且`equals()`方法不可抛出`ClassCastException`。注意，`instanceof`测试还可以排除`null`参数：如果其左操作数为`null`，`instanceof`始终评估为`false`。
- en: hashCode()
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: hashCode()
- en: Whenever you override `equals()`, you also must override `hashCode()`. This
    method returns an integer for use by hash table data structures. It is critical
    that two objects have the same hash code if they are equal according to the `equals()`
    method.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 每当您重写 `equals()`，您也必须重写 `hashCode()`。此方法返回一个整数，用于哈希表数据结构。如果根据 `equals()` 方法两个对象相等，则这两个对象必须具有相同的哈希码，这一点至关重要。
- en: It is important (for efficient operation of hash tables) but not required that
    unequal objects have unequal hash codes, or at least that unequal objects are
    unlikely to share a hash code. This second criterion can lead to `hashCode()`
    methods that involve mildly tricky arithmetic or bit manipulation.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 对于哈希表的高效操作很重要，但不是必须的，不相等的对象必须具有不相等的哈希码，或者至少不相等的对象不太可能共享一个哈希码。这第二个标准可能会导致涉及轻微复杂算术或位操作的
    `hashCode()` 方法。
- en: The `Object.hashCode()` method works with the `Object.equals()` method and returns
    a hash code based on object identity rather than object equality. (If you ever
    need an identity-based hash code, you can access the functionality of `Object.hashCode()`
    through the static method `System.identityHashCode()`.)
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object.hashCode()` 方法与 `Object.equals()` 方法一起使用，根据对象的身份而不是对象的相等性返回一个哈希码。（如果您需要基于身份的哈希码，可以通过静态方法
    `System.identityHashCode()` 访问 `Object.hashCode()` 的功能。）'
- en: Warning
  id: totrans-33
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: When you override `equals()`, you must always override `hashCode()` to guarantee
    that equal objects have equal hash codes. Failing to do this can cause subtle
    bugs in your programs.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当您重写 `equals()` 时，必须始终重写 `hashCode()`，以保证相等的对象具有相等的哈希码。否则可能会在程序中引起难以察觉的错误。
- en: Because the `equals()` method in [Example 5-1](#javanut8-CHP-5-EX-1) bases object
    equality on the values of the three fields, the `hashCode()` method computes its
    hash code based on these three fields as well. It is clear from the code that
    if two `Circle` objects have the same field values, they will have the same hash
    code.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 因为在[示例 5-1](#javanut8-CHP-5-EX-1)中，`equals()` 方法基于三个字段的值来判断对象的相等性，所以 `hashCode()`
    方法也基于这三个字段计算其哈希码。从代码可以清楚地看出，如果两个 `Circle` 对象具有相同的字段值，则它们将具有相同的哈希码。
- en: Note that the `hashCode()` method in [Example 5-1](#javanut8-CHP-5-EX-1) does
    not simply add the three fields and return their sum. Such an implementation would
    be legal but not efficient because two circles with the same radius but whose
    *x* and *y* coordinates were reversed would then have the same hash code. The
    repeated multiplication and addition steps “spread out” the range of hash codes
    and dramatically reduce the likelihood that two unequal `Circle` objects have
    the same code.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在[示例 5-1](#javanut8-CHP-5-EX-1)中的 `hashCode()` 方法并不简单地将三个字段相加并返回它们的和。这样的实现是合法的，但不高效，因为具有相同半径但
    *x* 和 *y* 坐标互换的两个圆将具有相同的哈希码。重复的乘法和加法步骤“扩展”了哈希码的范围，并显著降低了两个不相等的 `Circle` 对象具有相同代码的可能性。
- en: In practice, modern Java programmers will either autogenerate `hashCode()`,
    `equals()`, and `toString()` from within their IDE (for classes), or use records
    where the source code compiler produces a standard form of these methods. For
    the extremely rare cases where the programmer chooses not to use either of these
    approaches, *Effective Java* by Joshua Bloch (Addison Wesley) includes a helpful
    recipe for constructing efficient `hashCode()` methods.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，现代Java程序员通常会从他们的IDE中自动生成类的 `hashCode()`、`equals()` 和 `toString()` 方法，或者使用记录（records）类型，其中源代码编译器会生成这些方法的标准形式。对于极少数情况，程序员选择不使用这两种方法的情况，《Effective
    Java》（Addison Wesley）中包含了一种构建高效 `hashCode()` 方法的有用方法。
- en: Comparable::compareTo()
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Comparable::compareTo()
- en: '[Example 5-1](#javanut8-CHP-5-EX-1) includes a `compareTo()` method. This method
    is defined by the `java.lang.Comparable` interface rather than by `Object`, but
    it is such a common method to implement that we include it in this section. The
    purpose of `Comparable` and its `compareTo()` method is to allow instances of
    a class to be compared to each other in a similar way to how the `<`, `<=`, `>`,
    and `>=` operators compare numbers. If a class implements `Comparable`, we can
    call methods to allow us to say that one instance is less than, greater than,
    or equal to another instance. This also means that instances of a `Comparable`
    class can be sorted.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 5-1](#javanut8-CHP-5-EX-1) 包括一个 `compareTo()` 方法。此方法由 `java.lang.Comparable`
    接口定义，而不是由 `Object` 定义，但它是一个常见的实现方法，因此我们在本节中包括它。`Comparable` 及其 `compareTo()` 方法的目的是允许类的实例以类似于
    `<`, `<=`, `>`, 和 `>=` 操作符比较数字的方式进行比较。如果一个类实现了 `Comparable` 接口，我们可以调用方法来比较类的实例，从而判断一个实例是否小于、大于或等于另一个实例。这也意味着
    `Comparable` 类的实例可以进行排序。'
- en: Note
  id: totrans-40
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The method `compareTo()` sets up a *total ordering* of the objects of the type.
    This is referred to as the *natural order* of the type, and the method is called
    the *natural comparison method*.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`compareTo()` 方法设置了该类型对象的 *全序*。这被称为该类型的 *自然顺序*，该方法被称为 *自然比较方法*。'
- en: Because `compareTo()` is not declared by the `Object` class, it is up to each
    individual class to determine whether and how its instances should be ordered
    and to include a `compareTo()` method that implements that ordering.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `compareTo()` 没有被 `Object` 类声明，所以每个单独的类都需要确定其实例是否应该以及如何排序，并包括一个实现该排序的 `compareTo()`
    方法。
- en: 'The ordering defined by [Example 5-1](#javanut8-CHP-5-EX-1) compares `Circle`
    objects as if they were words on a page. Circles are first ordered from top to
    bottom: circles with larger *y* coordinates are less than circles with smaller
    *y* coordinates. If two circles have the same *y* coordinate, they are ordered
    from left to right. A circle with a smaller *x* coordinate is less than a circle
    with a larger *x* coordinate. Finally, if two circles have the same *x* and *y*
    coordinates, they are compared by radius. The circle with the smaller radius is
    smaller.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 由 [示例 5-1](#javanut8-CHP-5-EX-1) 定义的顺序将 `Circle` 对象比作页面上的单词。首先，圆按从上到下的顺序排列：具有较大
    *y* 坐标的圆小于具有较小 *y* 坐标的圆。如果两个圆具有相同的 *y* 坐标，则按从左到右的顺序排列。具有较小 *x* 坐标的圆小于具有较大 *x*
    坐标的圆。最后，如果两个圆具有相同的 *x* 和 *y* 坐标，则按半径比较。具有较小半径的圆小于另一个圆。
- en: Note that under this ordering, two circles are equal only if all three of their
    fields are equal. This means that the ordering defined by `compareTo()` is consistent
    with the equality defined by `equals()`. This is not strictly required but is
    very desirable, and you should aim for it wherever possible.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这种顺序下，仅当三个字段都相等时，两个圆才相等。这意味着 `compareTo()` 定义的顺序与 `equals()` 定义的相等性一致。虽然这不是严格要求的，但非常值得，您应该尽可能实现它。
- en: The `compareTo()` method returns an `int` value that requires further explanation.
    `compareTo()` should return a negative number if the `this` object is less than
    the object passed to it. It should return 0 if the two objects are equal. And
    `compareTo()` should return a positive number if `this` is greater than the method
    argument.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`compareTo()` 方法返回一个需要进一步解释的 `int` 值。如果 `this` 对象小于传递给它的对象，则 `compareTo()`
    应返回一个负数。如果两个对象相等，则应返回 0。如果 `this` 大于方法参数，则 `compareTo()` 应返回一个正数。'
- en: clone()
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: clone()
- en: '`Object` defines a method named `clone()` whose purpose is to return an object
    with fields set identically to those of the current object. This is an unusual
    method for several reasons.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object` 定义了一个名为 `clone()` 的方法，其目的是返回一个字段设置与当前对象完全相同的对象。这是一个不寻常的方法的原因之一。'
- en: First, `clone()` is declared as `protected`. Therefore, if you want your object
    to be cloneable by other classes, you must override the `clone()` method, making
    it `public`. Next, the default implementation of `clone()` in `Object` throws
    a checked exception, `CloneNotSupportedException`, unless the class implements
    the `java.lang.Cloneable` interface. Note that this interface does not define
    any methods (it is a marker interface), so implementing it is simply a matter
    of listing it in the `implements` clause of the class signature.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`clone()` 被声明为 `protected`。因此，如果你想让你的对象可以被其他类克隆，你必须重写 `clone()` 方法，并使其为 `public`。接下来，`Object`
    中 `clone()` 的默认实现抛出一个受检异常，`CloneNotSupportedException`，除非类实现了 `java.lang.Cloneable`
    接口。注意，这个接口不定义任何方法（它是一个标记接口），所以实现它只是在类签名的 `implements` 子句中列出它。
- en: 'The original intent of `clone()` was to provide a mechanism to produce “deep
    copies” of objects, but it is fundamentally flawed and its use is not recommended.
    Instead, developers should prefer declaring a *copy constructor* for making copies
    of their objects, for example:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`clone()` 的最初目的是提供一个生成对象的“深度拷贝”的机制，但它本质上是有缺陷的，不建议使用。相反，开发人员应该首选声明一个 *复制构造函数*
    来制作他们对象的副本，例如：'
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We will meet copy constructors again when we consider factory methods, later
    in this chapter.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们考虑工厂方法时，我们将再次遇到复制构造函数。
- en: Constants
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常量
- en: In Java a constant is a `static final` field. This combination of modifiers
    gives a single value (per class) with the given name, and it is initialized as
    soon as the class is loaded and then cannot be changed.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 中，常量是一个 `static final` 字段。这个修饰符的组合给定了一个单一的值（每个类），并且在类加载时初始化，然后不能被更改。
- en: By convention, Java’s constants are named in all-capitals, using *snake case*,
    for example `NETWORK_SERVER_SOCKET`^([1](ch05.xhtml#idm45927734963040)) as opposed
    to the “camel case” (or “camelCase”) convention `networkServerSocket` for a regular
    field.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，Java 的常量以全大写的形式命名，使用 *蛇形命名*，例如 `NETWORK_SERVER_SOCKET`^([1](ch05.xhtml#idm45927734963040))，而不是“驼峰命名法”（或“驼峰式”）的约定，如
    `networkServerSocket` 对于一个常规字段。
- en: 'There are essentially three different subcases of constants that can appear:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上有
- en: '`public` constants: these form part of the public API of the class'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public` 常量：这些构成了类的公共 API 的一部分'
- en: '`private` constants: these are used when the constant is an internal implementation
    detail for this class only'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`private` 常量：当常量仅为该类的内部实现细节时使用'
- en: 'Package-level constants: these have no additional access keyword and are used
    when the constant is an internal implementation detail that needs to be seen by
    different classes within the same package'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包级别的常量：这些没有额外的访问关键字，当常量是需要被同一包中的不同类看到的内部实现细节时使用
- en: The final case might arise, for example, when client and server classes implement
    a network protocol whose details (such as the port number to connect to and listen
    on) are captured in a set of symbolic constants.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 最终情况可能会出现，例如，客户端和服务器类实现了一个网络协议，其细节（例如连接和监听的端口号）被捕获在一组符号常量中。
- en: As discussed earlier, an alternative approach is for constants to appear in
    an interface definition. Any class that implements an interface inherits the constants
    it defines and can use them as if they were defined directly in the class itself.
    This has the advantage that there is no need to prefix the constants with the
    name of the interface or provide any kind of implementation of the constants.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面讨论的，常量出现在接口定义中是一种替代方法。实现接口的任何类都会继承它定义的常量，并且可以像在类本身中直接定义它们一样使用它们。这样做的优点是不需要用接口的名称前缀常量，也不需要提供任何常量的实现。
- en: However, this is rather overcomplicated and so the preferred approach is to
    define constants (as either public or package-level) in a class and use them by
    importing the constants from their defining class with the `import static` declaration.
    See [“Packages and the Java Namespace”](ch02.xhtml#javanut8-CHP-2-SECT-10) for
    details.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方式相当复杂，所以首选方法是在一个类中定义常量（可以是公共的或包级别的），并通过使用 `import static` 声明从定义类中导入常量来使用它们。有关详细信息，请参阅
    [“包和 Java 命名空间”](ch02.xhtml#javanut8-CHP-2-SECT-10)。
- en: Working with Fields
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处   处理字段
- en: 'Java provides a variety of access control keywords that can be used to define
    how fields can be accessed. It is perfectly legal to use any of these possibilities,
    but in practice there are three primary choices for field access that Java developers
    typically use:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Java提供了多种访问控制关键字，用于定义字段的访问方式。使用任何这些可能性都是完全合法的，但实际上，Java开发者通常有三种主要的字段访问选择：
- en: 'Constants (`static final`): the case that we just met, which may have an additional
    access control keyword as well'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常量（`static final`）：我们刚刚遇到的情况，可能还带有额外的访问控制关键字。
- en: 'Immutable fields (`private final`): fields with this combination cannot be
    altered after object creation'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可变字段（`private final`）：使用此组合的字段在对象创建后无法更改。
- en: 'Mutable fields (`private`): this combination should only be used if the programmer
    is sure that the field’s value will change during the object’s lifetime'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可变字段（`private`）：只有在程序员确定字段值在对象生命周期内会改变时才应该使用这种组合。
- en: In recent years, many developers have adopted the practice of using immutable
    data wherever possible. There are several benefits to this approach, but the main
    one is that if objects can be designed so that they cannot be modified after creation,
    then they can be freely shared between threads.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，许多开发者开始采用尽可能使用不可变数据的实践。这种做法有几个好处，但主要的好处是，如果对象设计得不可修改，那么它们可以在线程之间自由共享。
- en: When writing classes, we recommend using the above three choices for field modifiers,
    depending on the circumstances. Instance fields should always be initially written
    as `final` and made mutable only if necessary.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写类时，我们建议根据情况使用上述三种字段修饰符选择。实例字段应始终首先写为`final`，只有在必要时才应使其可变。
- en: In addition, direct field access should not be used, except for constants. Instead,
    getter methods (and setters, for the case of mutable state) should be preferred.
    The primary reason for this is that direct field access is a very tight coupling
    between the defining class and any client code. If accessor methods are used,
    then the implementation code for those methods can later be modified without changing
    the client code—this is impossible with field access.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，除了常量外，不应使用直接字段访问。应优先使用getter方法（以及setter，对于可变状态的情况）。这样做的主要原因是直接字段访问会非常紧密地耦合定义类和任何客户端代码。如果使用访问器方法，则可以稍后修改这些方法的实现代码而无需更改客户端代码——而直接字段访问则无法做到这一点。
- en: 'We should also call out one common mistake in field handling: Developers coming
    from C++ frequently make the mistake of omitting any access modifiers for fields.
    This is a serious defect, because C++ has a default visibility of private, whereas
    Java’s default access is considerably more open. This represents a failure of
    encapsulation in Java, and developers should take care to avoid it.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该指出字段处理中的一个常见错误：从C++转过来的开发者经常犯的一个错误是省略字段的任何访问修饰符。这是一个严重的缺陷，因为C++的默认可见性是private，而Java的默认访问权限更加开放。这代表了Java中封装的失败，开发者应该注意避免这种情况。
- en: Field Inheritance and Accessors
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字段继承和访问器
- en: As well as the above considerations, Java offers multiple potential approaches
    to the design issue of the inheritance of state. The programmer could choose to
    mark fields as `protected` and allow them to be accessed directly by subclasses
    (including writing to them). Alternatively, we can provide *accessor methods*
    to read (and write, if desired) the actual object fields, while retaining encapsulation
    and leaving the fields as `private`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 除了上述考虑因素外，Java还提供了多种可能的方法来解决状态继承的设计问题。程序员可以选择将字段标记为`protected`，并允许子类直接访问（包括写入）。或者，我们可以提供*访问器方法*来读取（和写入，如果需要）实际的对象字段，同时保持封装性并将字段保留为`private`。
- en: 'Let’s revisit our earlier `PlaneCircle` example from the end of [Chapter 3](ch03.xhtml#javanut8-CHP-3)
    and explicitly show the field inheritance:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新审视我们之前在[第三章](ch03.xhtml#javanut8-CHP-3)末尾的`PlaneCircle`示例，并明确显示字段继承：
- en: '[PRE3]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Instead of the preceding code, we can rewrite `PlaneCircle` using accessor
    methods, like this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是前面的代码，我们可以使用访问器方法来重写`PlaneCircle`，如下所示：
- en: '[PRE4]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Both approaches are legal Java, but they have some differences. As we discussed
    in [“Data Hiding and Encapsulation”](ch03.xhtml#javanut8-CHP-3-SECT-5), fields
    that are writable outside of the class are usually not a correct way to model
    object state. In fact, as we will see later in this chapter and again in [“Java’s
    Support for Concurrency”](ch06.xhtml#javanut8-CHP-6-SECT-5), they can damage the
    running state of a program irreparably.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法在 Java 中都是合法的，但它们有一些区别。正如我们在 [“数据隐藏和封装”](ch03.xhtml#javanut8-CHP-3-SECT-5)
    中讨论的那样，可在类外部写入的字段通常不是模型化对象状态的正确方式。事实上，正如我们稍后将在本章中看到的，并再次在 [“Java 对并发的支持”](ch06.xhtml#javanut8-CHP-6-SECT-5)
    中看到的，它们可能会对程序的运行状态造成无法修复的损害。
- en: It is therefore unfortunate that the `protected` keyword in Java allows access
    to fields (and methods) from both subclasses *and* classes in the same packages
    as the declaring class. This, combined with the ability for anyone to write a
    class that belongs to any given package (except system packages), means that protected
    inheritance of state is potentially flawed in Java.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Java 中的 `protected` 关键字不幸地允许从子类和与声明类在同一包中的类（以及方法）访问字段。这与任何人都可以编写属于任何给定包的类（除了系统包）的能力结合在一起，意味着在
    Java 中，受保护的状态继承可能存在缺陷。
- en: Warning
  id: totrans-79
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Java does not provide a mechanism for a member to be visible only in the declaring
    class and its subclasses.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Java 不提供一种仅在声明类及其子类中可见成员的机制。
- en: For all of these reasons, it is almost always better to use accessor methods
    (either public or protected) to provide access to state for subclasses—unless
    the inherited state is declared `final`, in which case protected inheritance of
    state is perfectly permissible.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 出于所有这些原因，几乎总是更好地使用访问器方法（无论是公共的还是受保护的）来为子类提供对状态的访问——除非继承的状态声明为 `final`，在这种情况下，受保护的状态继承是完全允许的。
- en: Singleton
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单例
- en: 'The *singleton pattern* is a very well-known design pattern. It is intended
    to solve the design issue where only a single instance of a class is required
    or desired. Java provides a number of different possible ways to implement the
    singleton pattern. In our discussion, we will use a slightly more verbose form,
    which has the benefit of being very explicit in what needs to happen for a safe
    singleton:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*单例模式* 是一个非常著名的设计模式。它旨在解决只需要或希望一个类的单个实例的设计问题。Java 提供了多种不同的实现单例模式的方式。在我们的讨论中，我们将使用稍微冗长的形式，这种形式的好处在于非常明确地说明了安全单例所需的操作：'
- en: '[PRE5]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The crucial point is that for the singleton pattern to be effective, it must
    be impossible to create more than one of them, and it must be impossible to get
    a reference to the object in an uninitialized state (see later in this chapter
    for more on this important point).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 关键点在于，单例模式要有效，必须不可能创建多个实例，并且不可能获取到处于未初始化状态的对象的引用（有关这一重要点的更多信息，请参见本章后面）。
- en: To achieve this, we require a `private` constructor, which is called only once,
    ever. In our version of `Singleton`, we only call the constructor when we initialize
    the private static variable `instance`. We also separate the creation of the only
    `Singleton` object from its initialization—which occurs in the private method
    `init()`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们需要一个仅被调用一次的 `private` 构造函数。在我们的 `Singleton` 版本中，我们只在初始化私有静态变量 `instance`
    时调用构造函数。我们还将创建唯一 `Singleton` 对象的过程与初始化分开，初始化过程发生在私有方法 `init()` 中。
- en: With this mechanism in place, the only way to get a reference to the lone instance
    of `Singleton` is via the static helper method, `getInstance()`. This method checks
    the flag `initialized` to see if the object is already in an active state. If
    it is, then a reference to the singleton object is returned. If not, then `getInstance()`
    calls `init()` to activate the object and flicks the flag to `true`, so that next
    time a reference to the `Singleton` is requested, further initialization will
    not occur.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个机制，获取 `Singleton` 唯一实例的唯一方法是通过静态辅助方法 `getInstance()`。此方法检查标志 `initialized`，以查看对象是否已经处于活动状态。如果是，则返回对单例对象的引用。如果不是，则
    `getInstance()` 调用 `init()` 来激活对象，并将标志设置为 `true`，这样下次请求 `Singleton` 的引用时，不会再进行进一步的初始化。
- en: Finally, we also note that `getInstance()` is a `synchronized` method. See [Chapter 6](ch06.xhtml#javanut8-CHP-6)
    for full details of what this means and why it is necessary, but for now, know
    that it is present to guard against unintended consequences if `Singleton` is
    used in a multithreaded program.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还注意到`getInstance()`是一个`synchronized`方法。详细信息请参见[第 6 章](ch06.xhtml#javanut8-CHP-6)，了解其含义及为何需要这样做，但现在只需知道，它存在是为了防止在多线程程序中使用`Singleton`时出现意外后果。
- en: Tip
  id: totrans-89
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Singleton, being one of the simplest patterns, is often overused. When used
    correctly, it can be a useful technique, but too many singleton classes in a program
    is a classic sign of badly engineered code.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 单例模式作为最简单的模式之一，经常被滥用。正确使用时，它可以是一种有用的技术，但程序中有太多的单例类通常是代码设计不良的典型迹象。
- en: The singleton pattern has some drawbacks—in particular, it can be hard to test
    and to separate from other classes. It also requires care when used in mulithreaded
    code. Nevertheless, it is important that developers are familiar with it and do
    not accidentally reinvent it. The singleton pattern is often used in configuration
    management, but modern code will typically use a framework (often a *dependency
    injection* framework) to provide the programmer with singletons automatically,
    rather than via an explicit `Singleton` (or equivalent) class.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 单例模式有一些缺点，特别是在测试和与其他类分离时可能很难。在多线程代码中使用时也需要注意。尽管如此，开发人员熟悉单例模式并不会意外地重新发明它是很重要的。单例模式经常用于配置管理，但现代代码通常会使用框架（通常是*依赖注入*框架）自动为程序员提供单例，而不是通过显式的`Singleton`（或等效）类。
- en: Factory Methods
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工厂方法
- en: An alternative to using constructors directly is the *Factory Method* pattern.
    The basic form of this technique is to make the constructor private (or other
    nonpublic modifier, in some variants) and to provide a static method that returns
    the desired type. This static method is then used by client code that wants an
    instance of the type.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 直接使用构造函数的另一种选择是*工厂方法*模式。这种技术的基本形式是将构造函数设为私有的（或者在某些变体中设为其他非公共修饰符），并提供一个静态方法返回所需的类型。然后客户端代码使用这个静态方法来获取类型的实例。
- en: There are various reasons why, as a code author, we may not want to expose our
    constructors directly and may choose to use factories instead. For example, caching
    factories that do not necessarily create a new object, or because there are several
    valid ways of constructing an object.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 作为代码作者，我们可能不希望直接暴露构造函数，并可能选择使用工厂。例如，缓存工厂不一定创建新对象，或者因为有多种有效构造对象的方式。
- en: Note
  id: totrans-95
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The static factory approach is not the same as the *Abstract Factory* pattern
    from the classic book [*Design Patterns*](https://oreil.ly/1CbpU).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 静态工厂方法的方法并不同于经典书籍[*设计模式*](https://oreil.ly/1CbpU)中的*抽象工厂*模式。
- en: 'Let’s rewrite the constructor from [Example 5-1](#javanut8-CHP-5-EX-1) and
    introduce some factory methods:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重写来自[示例 5-1](#javanut8-CHP-5-EX-1)的构造函数，并引入一些工厂方法：
- en: '[PRE6]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This class contains a private constructor and three separate factory methods:
    a “usual” one with the same signature as the constructor, and two additional.
    One of these additional factories is effectively a copy constructor, and the other
    is used to handle a special case: circles at the origin.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类包含一个私有构造函数和三个独立的工厂方法：一个与构造函数具有相同签名的“常规”方法，以及两个额外的方法。其中一个额外的工厂实际上是一个复制构造函数，另一个用于处理一个特殊情况：原点处的圆。
- en: One advantage of using factory methods is that, unlike constructors, the method
    has a name and so can indicate its intent using part of the name. In our example,
    the factory methods are `of()`, which is one very common choice, and we distinguish
    the case of the origin circles by using a name `ofOrigin()` that expresses it.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 使用工厂方法的一个优势是，与构造函数不同，该方法具有名称，因此可以使用名称的一部分指示其意图。在我们的示例中，工厂方法是`of()`，这是一个非常常见的选择，并且我们通过使用表达这一点的名称`ofOrigin()`来区分原点圆。
- en: Builders
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建器
- en: Factory methods are a useful technique for when you don’t want to expose a constructor
    to client code. However, there are limitations to factories. They work well when
    only a few parameters, all of which are required, need to be passed. But in some
    circumstances, we need to model data where much of it is optional, or when there
    are many valid, different possible constructions for our domain objects. In this
    case, the number of factory methods can quickly multiply to represent all possible
    combinations and overwhelm us, cluttering the API.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂方法是一种有用的技术，当您不想将构造函数暴露给客户端代码时。然而，工厂方法也有其局限性。当只有少数几个参数是必需的，并且所有这些参数都需要被传递时，它们运行良好。但在某些情况下，我们需要建模数据，其中许多部分是可选的，或者我们的领域对象有许多有效的不同可能的构造。在这种情况下，工厂方法的数量可能会快速增加，以表示所有可能的组合，并且可能会使API混乱。
- en: An alternative approach is the *Builder* pattern. This pattern uses a secondary
    builder object that exactly parallels the state of the real domain object (which
    is assumed to be immutable). For every field that the domain object has, the builder
    has the same field—the same name, and the same type. However, while the domain
    object is immutable, the builder object is explicitly mutable. In fact, the builder
    has a setter method, named in the same way as the field (i.e. in “record convention”)
    that the developer will use to set up a piece of state.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是*建造者*模式。这种模式使用一个辅助建造者对象，该对象与真实领域对象的状态完全相同（假设为不可变）。对于领域对象的每个字段，建造者都有相同的字段——相同的名称和类型。然而，虽然领域对象是不可变的，建造者对象是显式可变的。实际上，建造者有一个setter方法，命名方式与字段相同（即按“记录约定”），开发人员将使用该方法来设置状态的一部分。
- en: The overall intent of the Builder pattern is to start from a “blank” builder
    object and add state to it, until the builder is ready to be converted into an
    actual domain object, usually by calling the `build()` method on the builder.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 建造者模式的整体意图是从一个“空白”的建造者对象开始，并向其添加状态，直到建造者准备好转换为实际的领域对象，通常是通过在建造者上调用`build()`方法。
- en: 'Let’s take a look at a simple example:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个简单的例子：
- en: '[PRE7]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Notice that the builder interface is typically generic. This is because in practice
    we may well have a large number of domain classes, all of which will require builders,
    so the use of a generic builder interface removes duplication. The `Builder` interface
    contains only one method, so it technically is a candidate for lambda target typing.
    But in practice this is almost never the intent, and so it is not tagged with
    `@FunctionalInterface`. The implementation of the `build()` method also contains
    a nonoptional use of the `this` reference.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 注意建造者接口通常是泛型的。这是因为在实践中，我们可能会有大量的领域类，所有这些类都将需要建造者，因此使用泛型建造者接口可以消除重复。`Builder`接口只包含一个方法，因此在技术上它可以作为lambda目标类型的候选者。但实际上这几乎从不是意图，因此没有被标记为`@FunctionalInterface`。`build()`方法的实现还包含对`this`引用的非可选使用。
- en: 'The builder can be driven by a simple bit of code like this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 建造者可以通过如下简单的代码驱动：
- en: '[PRE8]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note that first we instantiate the builder. Then, we call the methods to set
    the various parameters on the builder. Finally, we create an immutable object
    from the builder, by calling `build()`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 注意首先我们要实例化建造者。然后，我们调用方法来设置建造者的各种参数。最后，我们通过调用`build()`方法从建造者创建一个不可变对象。
- en: 'You may notice that the methods on the builder that accrete state all return
    `this`. The point of this interface design is so that the calls can be *chained*—so
    that methods can be called one after another on the same mutable object—for example
    as `cb.x(1).y(2).r(3)`. Another way of describing this style of interface design
    is as a *fluent interface*. As each method returns `this`, we know that all of
    these calls are safe: there can’t be a `NullPointerException`.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能注意到，增加状态的建造者上的方法都返回`this`。这种接口设计的目的是可以将调用*链式*——即可以在同一个可变对象上连续调用方法，例如`cb.x(1).y(2).r(3)`。另一种描述这种接口设计风格的方式是*流畅接口*。由于每个方法都返回`this`，我们知道所有这些调用都是安全的：不会出现`NullPointerException`。
- en: Our example is very simple and is somewhat contrived; it only has three parameters
    and all of them are required. In practice, builders are more useful with a larger
    number of object parameters and when there are multiple possibilities for “spanning
    sets” of valid object states. There exists an overlap between the cases where
    one should use a factory versus a builder; determining exactly where that boundary
    is for your own code is part of the development of OO design skills.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例非常简单，有些刻意；它只有三个参数，而且所有这些参数都是必需的。在实践中，当对象参数数量较多且对象状态的“跨度集”有多个可能性时，构建器更加有用。工厂与构建器的使用案例存在重叠；确定在您自己的代码中确切的边界位置是面向对象设计技能开发的一部分。
- en: Interfaces Versus Abstract Classes
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口与抽象类的比较
- en: Java 8 fundamentally changed Java’s object-oriented programming model. Before
    Java 8, interfaces were pure API specification and contained no implementation.
    This could (and often did) lead to duplication of code when the interface had
    multiple implementations.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8 彻底改变了Java的面向对象编程模型。在Java 8之前，接口是纯粹的API规范，不包含任何实现。当接口有多个实现时，这可能（并经常）导致代码重复。
- en: To prevent this wasted effort, a simple coding pattern developed that takes
    advantage of the fact that an abstract class can contain a partial implementation
    that subclasses can build upon. Numerous subclasses can rely on method implementations
    provided by an abstract superclass (also called an *abstract base*).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种浪费的努力，发展出了一个简单的编码模式，利用抽象类可以包含子类可以构建的部分实现。许多子类可以依赖抽象超类（也称为*抽象基类*）提供的方法实现。
- en: The pattern consists of an interface that contains the API spec for the basic
    methods, paired with a primary partial implementation as an abstract class. A
    good example would be `java.util.List`, which is paired with `java.util.AbstractList`.
    Two of the main implementations of `List` that ship with the JDK (`ArrayList`
    and `LinkedList`) are subclasses of `AbstractList`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式由包含基本方法 API 规范的接口以及作为抽象类的主要部分实现配对而成。一个很好的例子就是`java.util.List`，它与`java.util.AbstractList`配对。JDK
    提供的`List`的两个主要实现（`ArrayList`和`LinkedList`）都是`AbstractList`的子类。
- en: 'As another example:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子：
- en: '[PRE9]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The arrival of default methods in Java 8 changed this landscape considerably.
    Interfaces can now contain implementation code, as we saw in [“Default Methods”](ch04.xhtml#javanut8-CHP-4-SECT-1.7).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8 的默认方法的到来显著改变了这一局面。接口现在可以包含实现代码，就像我们在[“默认方法”](ch04.xhtml#javanut8-CHP-4-SECT-1.7)中看到的那样。
- en: This means that when defining an abstract type (e.g., `Shape`) that you expect
    to have many subtypes (e.g., `Circle`, `Rectangle`, `Square`), you are faced with
    a choice between interfaces and abstract classes. As they now have potentially
    similar features, it is not always clear which to use.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着当定义一个抽象类型（例如`Shape`），你期望它有许多子类型（例如`Circle`、`Rectangle`、`Square`）时，你面临选择接口和抽象类之间的选择。由于它们现在可能具有相似的特性，因此并不总是清楚该选择哪一个。
- en: Remember that a class that extends an abstract class cannot extend any other
    class, and that interfaces still cannot contain any nonconstant fields. This means
    there are still some restrictions on how we can use inheritance in our Java programs.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，扩展抽象类的类不能扩展任何其他类，而接口仍然不能包含任何非常量字段。这意味着在Java程序中使用继承仍然有一些限制。
- en: Another important difference between interfaces and abstract classes has to
    do with compatibility. If you define an interface as part of a public API and
    then later add a new mandatory method to the interface, you break any classes
    that implemented the previous version of the interface—in other words, any new
    interface methods must be declared as default and an implementation provided.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 接口和抽象类之间的另一个重要区别与兼容性有关。如果你将接口定义为公共 API 的一部分，然后稍后向接口添加一个新的强制方法，你将会破坏实现了接口先前版本的任何类——换句话说，任何新的接口方法必须声明为默认方法，并提供一个实现。
- en: If you use an abstract class, however, you can safely add nonabstract methods
    to that class without requiring modifications to existing classes that extend
    the abstract class.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果使用抽象类，可以安全地向该类添加非抽象方法，而无需修改扩展抽象类的现有类。
- en: In both cases, adding new methods can cause a clash with subclass methods of
    the same name and signature—with the subclass methods always winning. For this
    reason, think carefully when adding new methods, especially when the method names
    are “obvious” for this type or where the method could have several possible meanings.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，添加新方法可能会与具有相同名称和签名的子类方法发生冲突 —— 子类方法始终胜出。因此，在添加新方法时要仔细考虑，特别是当方法名称对于此类型是“显而易见”或方法可能具有多个可能含义时。
- en: In general, the suggested approach is to prefer interfaces when an API specification
    is needed. The mandatory methods of the interface are nondefault, as they represent
    the part of the API that must be present for an implementation to be considered
    valid. Default methods should be used only if a method is truly optional, or if
    they are really only intended to have a single possible implementation.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，建议的方法是在需要API规范时首选接口。接口的强制方法是非默认的，因为它们代表API的一部分，必须存在于实现中才能被视为有效。默认方法应仅在方法真正可选时使用，或者如果它们只打算具有单个可能的实现时使用。
- en: Finally, the older (pre-Java 8) technique of declaring in documentation which
    methods of an interface are considered “optional” and directing to implementations
    to throw a `java.lang.UnsupportedOperationException` if the programmer does not
    want to implement them is fraught with problems and should not be used in new
    code.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，旧的（Java 8之前的）在文档中声明接口的哪些方法被认为是“可选的”，并指示实现在程序员不想实现它们时抛出`java.lang.UnsupportedOperationException`的技术充满了问题，不应在新代码中使用。
- en: Do Default Methods Change Java’s Inheritance Model?
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 默认方法改变了Java的继承模型吗？
- en: Before Java 8, the strict single inheritance model of the language was clear.
    Every class (except `Object`) had exactly one direct superclass, and method implementations
    could only either be defined in a class, or be inherited from the superclass hierarchy.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 8之前，语言的严格单继承模型是清晰的。每个类（除了`Object`）都有一个直接超类，方法实现只能在类中定义，或者从超类层次结构继承。
- en: Default methods change this picture, because they allow method implementations
    to be inherited from multiple places—either from the superclass hierarchy or from
    default implementation provided in interfaces. Any potential conflicts between
    different default methods from separate interfaces will result in a compile-time
    error.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 默认方法改变了这种情况，因为它们允许方法实现从多个地方继承 —— 可以是从超类层次结构，也可以是从接口提供的默认实现。任何来自不同接口的默认方法之间的潜在冲突都会导致编译时错误。
- en: This means there is no possibility of conflicting multiple inheritance of implementation,
    as in any clash the programmer is required to manually disambiguate the methods.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着不存在实现的多重继承可能性，因为在任何冲突情况下，程序员需要手动消除歧义的方法。
- en: 'There is also no multiple inheritance of state: interfaces still do not have
    non-constant fields.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，接口仍然没有状态的多重继承：接口仍然没有非常量字段。
- en: This means that Java’s multiple inheritance is different from the general multiple
    inheritance found in, e.g., C++. In fact, default methods are effectively the
    *Mixin* pattern from C++ (for readers who are familiar with that language). Some
    developers also view default members as a form of the *trait* language feature
    that appears in some OO languages (e.g., Scala).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着Java的多重继承与例如C++中的一般多重继承不同。实际上，默认方法实际上是来自C++的*Mixin*模式（对于熟悉该语言的读者）。一些开发人员还将默认成员视为某些面向对象语言（例如Scala）中出现的*trait*语言特性的一种形式。
- en: However, the official position from Java’s language designers is that default
    methods fall short of being full traits. This view is somewhat undermined by the
    code that ships within the JDK—even the interfaces within `java.util.function`
    (such as `Function` itself) behave as simple traits.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，来自Java语言设计者的官方立场是，默认方法并不完全满足完整的特征。 JDK中随附的代码 —— 即使是`java.util.function`中的接口（如`Function`本身）也表现为简单的特征。
- en: 'For example, consider this example:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下示例：
- en: '[PRE10]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It is a simplified version of the `Function` interface in `java.util.function`
    that removes the generics and deals with `int` only as a data type.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 它是`java.util.function`中`Function`接口的简化版本，删除了泛型，并仅处理`int`作为数据类型。
- en: 'This case shows an important point for the functional composition methods (
    `compose()` and `andThen()`) present: these functions will only be composed in
    the standard way, and it is highly implausible that any sane override of the default
    `compose()` method could exist.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况显示了现有的功能组合方法（`compose()` 和 `andThen()`）的一个重要点：这些函数只会以标准方式组合，任何理智的对默认 `compose()`
    方法的重写都几乎不可能存在。
- en: This is, of course, also true for the function types present in `java.util.function`,
    and it shows that within the limited domain provided, default methods can indeed
    be treated as a form of stateless trait.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在 `java.util.function` 中存在的函数类型也是如此，这表明在提供的有限域内，默认方法确实可以被视为一种无状态特征。
- en: OOD Using Lambdas
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Lambdas 的面向对象设计
- en: 'Consider this simple lambda expression:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个简单的 lambda 表达式：
- en: '[PRE11]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The type of the *lvalue* (lefthand side of the assignment) is `Runnable`, which
    is an interface type. For this statement to make sense, the *rvalue* (right-hand
    side of the assignment) must contain an instance of some class type (because interfaces
    cannot be instantiated) that implements `Runnable`. The minimal implementation
    that satisfies these constraints is a class type (of inconsequential name) that
    directly extends `Object` and implements `Runnable`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*lvalue*（赋值语句左侧）的类型是 `Runnable`，这是一个接口类型。为了使这个语句有意义，*rvalue*（赋值语句右侧）必须包含实现
    `Runnable` 的某个类类型的实例（因为接口不能被实例化）。满足这些约束的最小实现是一个类类型（名称不重要），它直接扩展 `Object` 并实现 `Runnable`。'
- en: Recall that the intention of lambda expressions is to allow Java programmers
    to express a concept that is as close as possible to the anonymous or inline methods
    seen in other languages.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，lambda 表达式的意图是允许 Java 程序员表达尽可能接近其他语言中看到的匿名或内联方法的概念。
- en: Furthermore, given that Java is a statically typed language, this leads directly
    to the design of lambdas as implemented.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，鉴于 Java 是一种静态类型语言，这直接导致了 lambda 的设计实现。
- en: Tip
  id: totrans-145
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Lambdas are a shorthand for the construction of a new instance of a class type
    that is essentially `Object` enhanced by a single method.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Lambdas 是一个新类类型的实例构造的简写，这个新类类型本质上是 `Object` 增强了一个方法。
- en: A lambda’s single extra method has a signature provided by the interface type,
    and the compiler will check that the `rvalue` is consistent with this type signature.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: lambda 的额外方法由接口类型提供签名，并且编译器将检查 `rvalue` 是否与此类型签名一致。
- en: Lambdas Versus Nested Classes
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Lambdas 与嵌套类
- en: The addition of lambdas to the language in Java 8 was relatively late, as compared
    to other programming languages. As a consequence, the Java community had established
    patterns to work around the absence of lambdas. This manifests in a heavy use
    of very simple nested (aka inner) classes to fill the niche that lambdas usually
    occupy.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 8 中向语言添加 lambda 相对较晚，与其他编程语言相比。因此，Java 社区已经建立了模式来解决 lambda 的缺失问题。这表现在大量使用非常简单的嵌套（也称为内部）类来填补通常由
    lambda 占据的空缺。
- en: In modern Java projects developed from scratch, developers will typically use
    lambdas wherever possible. We also strongly suggest that, when refactoring old
    code, you take some time to convert inner classes to lambdas wherever possible.
    Some IDEs even provide an automatic conversion facility.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代的 Java 项目中，开发人员通常会尽可能地使用 lambda。我们还强烈建议，在重构旧代码时，您花一些时间将内部类转换为 lambda，只要有可能。一些
    IDE 甚至提供了自动转换功能。
- en: However, this still leaves the design question of when to use lambdas and when
    nested classes are still the correct solution.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这仍然留下了一个设计问题，即何时使用 lambda，何时使用嵌套类仍然是正确的解决方案。
- en: 'Some cases are obvious; for example, when extending a default implementation
    for some functionality, a nested class approach is appropriate, for two reasons:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 有些情况是显而易见的；例如，当扩展某些功能的默认实现时，嵌套类方法是适当的，原因有两个：
- en: The custom implementation may have to override multiple methods
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 自定义实现可能必须重写多个方法。
- en: The base implementation is a class, not an interface
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基础实现是一个类，而不是一个接口。
- en: Another major use case to consider is that of stateful lambdas. As there is
    nowhere to declare any fields, it would appear at first glance that lambdas cannot
    directly be used for anything that involves state—the syntax only gives the opportunity
    to declare a method body.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个要考虑的主要用例是有状态 lambda。由于没有地方声明任何字段，乍一看似乎 lambda 不能直接用于涉及状态的任何事物—语法只给出了声明方法体的机会。
- en: However, a lambda can refer to a variable defined in the scope that the lambda
    is created in, so we can create a closure, as discussed in [Chapter 4](ch04.xhtml#javanut8-CHP-4),
    to fill the role of a stateful lambda.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，lambda 可能引用 lambda 所创建的范围内定义的变量，因此我们可以创建一个闭包，如在 [第 4 章](ch04.xhtml#javanut8-CHP-4)
    中讨论的那样，来扮演有状态 lambda 的角色。
- en: Lambdas Versus Method References
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Lambda 与方法引用
- en: The question of when to use a lambda and when to use a method reference is largely
    a matter of personal taste and style. There are, of course, some circumstances
    where it is essential to create a lambda. However, in many simple cases, a lambda
    can be replaced by a method reference.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 何时使用 lambda 和何时使用方法引用大多数是个人品味和风格问题。当然，在一些情况下创建 lambda 是必要的。然而，在许多简单情况下，lambda
    可以被方法引用替代。
- en: One possible approach is to consider whether the lambda notation adds anything
    to the readability of the code. For example, in the streams API, there is a potential
    benefit in using the lambda form, as it uses the `->` operator. This provides
    a form of visual metaphor—the stream API is a lazy abstraction that can be visualized
    as data items “flowing through a functional pipeline.”
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 一种可能的方法是考虑 lambda 符号是否增加了代码的可读性。例如，在流 API 中，使用 lambda 形式可能会带来潜在的好处，因为它使用 `->`
    操作符。这提供了一种视觉隐喻形式——流 API 是一种惰性抽象，可以将数据项“通过函数管道流动”。
- en: 'For example, let’s consider a `Person` object, which has standard characteristics,
    such as name, age, etc. We can compute the average using a pipeline, like this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们考虑一个 `Person` 对象，它具有标准特征，如姓名、年龄等。我们可以使用类似以下的流水线计算平均值：
- en: '[PRE12]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The idea that the `mapToDouble()` method has an aspect of motion, or transformation,
    is strongly implied by the usage of an explicit lambda. For less experienced programmers,
    it also draws attention to the use of a functional API.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`mapToDouble()` 方法具有运动或转换方面的概念，使用显式 lambda 很明显。对于经验不足的程序员，这也引起了对函数式 API 的注意。'
- en: 'For other use cases (e.g., *dispatch tables*), method references may well be
    more appropriate. For example:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他用例（例如 *分发表*），方法引用可能更合适。例如：
- en: '[PRE13]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In situations where either notation could be used, you will come to develop
    a preference that fits your individual style over time. The key consideration
    is whether, when returning to reread code written several months (or years) ago,
    the choice of notation still makes sense and the code is easy to read.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在可以使用任一符号的情况下，随着时间的推移，您会形成适合个人风格的偏好。关键考虑因素是在重新阅读数月（或数年）前编写的代码时，符号选择是否仍然合理且代码易于阅读。
- en: OOD Using Sealed Types
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用封闭类型的面向对象设计
- en: 'We met sealed classes for the first time in [Chapter 3](ch03.xhtml#javanut8-CHP-3)
    and introduced sealed interfaces in [Chapter 4](ch04.xhtml#javanut8-CHP-4). As
    well as the cases we’ve already met, there is also a simpler possibility, in which
    a sealed type can be extended only by classes that are defined inside the same
    compilation unit (i.e., Java source file), like this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 [第 3 章](ch03.xhtml#javanut8-CHP-3) 中第一次遇到封闭类，并在 [第 4 章](ch04.xhtml#javanut8-CHP-4)
    中引入了封闭接口。除了我们已经遇到的情况外，还有一个更简单的可能性，即封闭类型只能由定义在同一编译单元内的类（即 Java 源文件）扩展，例如：
- en: '[PRE14]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The classes `Shape.Circle` and `Shape.Rectangle` are the only permitted subclasses
    of `Shape`: any other attempt to extend `Shape` will result in a compilation error.
    This is really just additional detail, as the general concept remains the same;
    `sealed` indicates a type that has only a finite number of possible types that
    are compatible with it.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 类 `Shape.Circle` 和 `Shape.Rectangle` 是 `Shape` 的唯一允许的子类：任何试图扩展 `Shape` 的尝试都将导致编译错误。这实际上只是额外的细节，因为一般概念保持不变；`sealed`
    表示一个只有有限可能兼容的类型。
- en: 'There is an interesting duality here:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个有趣的二元性：
- en: Enums are classes that have only a finite number of instances—any enum object
    is one of those instances
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 枚举是只有有限数量实例的类——任何枚举对象都是这些实例之一
- en: Sealed types have only a finite number of compatible classes—any sealed object
    belongs to one of those classes
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 封闭类型仅有限数量的兼容类——任何封闭对象都属于其中一个类
- en: 'Now consider a switch expression that accepts an enum, for example:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑一个接受枚举的 switch 表达式，例如：
- en: '[PRE15]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: All the possible enum constants for seasons are present in this switch expression,
    and so the match is said to be *total*. In this case, it is not necessary to include
    a `default`, as the compiler can use the *exhaustiveness* of the enum constants
    to infer that the default case would never be activated.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 所有季节的可能枚举常量都出现在这个switch表达式中，因此匹配被称为*完全的*。在这种情况下，不需要包含`default`，因为编译器可以利用枚举常量的*详尽性*推断出永远不会激活默认情况。
- en: 'It isn’t hard to see that we could do something similar with sealed types.
    Some code like this:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 不难看出我们可以对密封类型进行类似的操作。一些代码如下所示：
- en: '[PRE16]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: is obviously exhaustive to a human but is not currently (as of Java 17) directly
    recognized by the compiler.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 对于人类来说，这显然是详尽无遗的，但当前（截至Java 17）并未直接被编译器识别。
- en: This is because, as of Java 17, sealed types are essentially an incomplete feature.
    In a future version of Java, the intent is to extend the switch expressions feature
    and combine it with the new form of `instanceof` (and other new language features)
    to deliver a capability called *pattern matching*.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为，截至Java 17，密封类型实质上是一种不完整的功能。在Java的未来版本中，打算扩展switch表达式功能并将其与新形式的`instanceof`（以及其他新语言特性）结合起来，以提供称为*模式匹配*的功能。
- en: This new feature will enable developers to write code that, for example, “switches
    over a variable’s type,” and this will unlock new design patterns inspired by
    functional programming, which have not been easy to achieve in Java.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这一新特性将使开发人员能够编写代码，例如“对变量的类型进行切换”，这将解锁由函数式编程启发的新设计模式，在Java中实现起来并不容易。
- en: Note
  id: totrans-181
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '[Appendix](app01.xhtml#javanut8-APP-A) has more information about pattern matching
    and other future features.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '[附录](app01.xhtml#javanut8-APP-A)包含有关模式匹配和其他未来功能的更多信息。'
- en: Despite not being entirely complete as of Java 17, sealed types are still very
    useful in their current form and can also be combined with records to produce
    some compelling designs.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管截至Java 17还不完全完整，但密封类型在其当前形式下仍然非常有用，也可以与记录结合以产生一些引人注目的设计。
- en: OOD Using Records
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用记录的OOD
- en: 'Records were introduced in [Chapter 3](ch03.xhtml#javanut8-CHP-3), and in their
    simplest form they represent a data entity that is “just fields” or a “bag of
    data.” In some other programming languages, this is represented by a *tuple*,
    but Java’s records are different from tuples in two important ways:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 记录在[第3章](ch03.xhtml#javanut8-CHP-3)中引入，以其最简单的形式代表“仅仅是字段”或“数据包”。在其他一些编程语言中，这由一个*元组*表示，但Java的记录与元组有两个重要的不同之处：
- en: Java records are named types, whereas tuples are anonymous
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Java记录是具名类型，而元组是匿名的
- en: Java records can have methods, auxiliary constructors and almost everything
    a class can
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Java记录可以拥有方法、辅助构造函数以及几乎类似类的一切内容
- en: Both of these stem from the fact that records are a special type of class. This
    allows the programmer to start their design by using a record as a basic collection
    of fields, and then to evolve from there.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这两者都源于记录是一种特殊类型的类的事实。这使得程序员可以从使用记录作为基本字段集合开始其设计，然后从那里进化。
- en: 'For example, let’s rewrite [Example 5-1](#javanut8-CHP-5-EX-1) as a record
    (eliding the `Comparable` interface for simplicity):'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们将[示例 5-1](#javanut8-CHP-5-EX-1)重写为一条记录（简化了`Comparable`接口）：
- en: '[PRE17]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note that we have introduced a new type of constructor, called a *compact constructor*.
    It is available only for records and is used in the case where we want to do a
    bit of extra work in the constructor as well as initialize the fields. Compact
    constructors don’t have (or need) a parameter list, as they always have the same
    parameter list as the declaration of the record.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们引入了一种新类型的构造函数，称为*紧凑构造函数*。它仅适用于记录，并且在我们希望在构造函数中做一些额外工作以及初始化字段的情况下使用。紧凑构造函数没有（或不需要）参数列表，因为它们的参数列表始终与记录的声明相同。
- en: This code is much shorter than [Example 5-1](#javanut8-CHP-5-EX-1) and clearly
    distinguishes the case of the primary constructor (the “true form”) of the record
    from the copy constructor and any other factories that may be present.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码比[示例 5-1](#javanut8-CHP-5-EX-1)要简短得多，并清楚地区分了记录的主构造函数（“真实形式”）与复制构造函数及可能存在的其他工厂之间的情况。
- en: The design of Java’s records means that they are a very flexible choice for
    the programmer. An entity can be initially modeled as just fields, and over time,
    can acquire more methods, implement interfaces, and so on.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Java记录的设计意味着它们是程序员的一种非常灵活的选择。一个实体可以最初被建模为仅仅是字段，并且随着时间的推移，可以获得更多的方法、实现接口等。
- en: 'One other important aspect is that records also can be used very effectively
    in combination with sealed interfaces. Let’s take a look at an example: a delivery
    company that has different types of orders: basic orders (delivered free), and
    express orders (arrive quicker but for an additional charge).'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要方面是记录可以与密封接口结合使用。让我们来看一个例子：一个快递公司有不同类型的订单：基本订单（免费送货）和快速订单（速度更快但需额外费用）。
- en: 'The basic interface for the orders looks like this:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 订单的基本接口如下所示：
- en: '[PRE18]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'and has two implementations:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 并且有两个实现：
- en: '[PRE19]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Remember that the supertype of all record types is `java.lang.Record`, so for
    this type of use case we have to use interfaces; it would not be possible to have
    the different order types extend an abstract base. Our choices are:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，所有记录类型的超类型是`java.lang.Record`，因此对于这种类型的用例，我们必须使用接口；不可能使不同的订单类型扩展抽象基类。我们的选择是：
- en: Model the entities as classes and use a `sealed abstract` base class
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将实体建模为类，并使用`sealed abstract`基类。
- en: Model the entities as records and use a sealed interface
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将实体建模为记录，并使用密封接口。
- en: In the second case, any common record components need to be hoisted up into
    the interface, just as we saw for the `Order` example.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二种情况下，任何常见的记录组件都需要提升到接口中，就像我们在`Order`示例中看到的那样。
- en: Instance Methods or Class Methods?
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实例方法还是类方法？
- en: Instance methods are one of the key features of object-oriented programming.
    That doesn’t mean, however, that you should shun class methods. In many cases,
    it is perfectly reasonable to define class methods.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 实例方法是面向对象编程的一个关键特性。然而，并不意味着您应该避免使用类方法。在许多情况下，定义类方法是完全合理的。
- en: Tip
  id: totrans-205
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Remember that in Java, class methods are declared with the `static` keyword,
    and the terms *static method* and *class method* are used interchangeably.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在Java中，类方法使用`static`关键字声明，术语*static method*和*class method*可互换使用。
- en: 'For example, when working with the `Circle` class you might find that you often
    want to compute the area of a circle with a given radius but don’t want to bother
    creating a `Circle` object to represent that circle. In this case, a class method
    is more convenient:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在使用`Circle`类时，您可能经常需要计算具有给定半径的圆的面积，但不想费事地创建表示该圆的`Circle`对象。在这种情况下，类方法更方便：
- en: '[PRE20]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: It is perfectly legal for a class to define more than one method with the same
    name, as long as the methods have different parameter lists. This version of the
    `area()` method is a class method, so it does not have an implicit `this` parameter
    and must have a parameter that specifies the radius of the circle. This parameter
    keeps it distinct from the instance method of the same name.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类可以定义多个具有相同名称的方法，只要这些方法具有不同的参数列表是完全合法的。`area()`方法的这个版本是一个类方法，因此它没有隐含的`this`参数，并且必须有一个参数来指定圆的半径。这个参数使它与同名的实例方法有所区别。
- en: 'As another example of the choice between instance methods and class methods,
    consider defining a method named `bigger()` that examines two `Circle` objects
    and returns whichever has the larger radius. We can write `bigger()` as an instance
    method as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个关于实例方法和类方法选择的例子是，考虑定义一个名为`bigger()`的方法，它检查两个`Circle`对象，并返回半径较大的那个。我们可以将`bigger()`编写为实例方法，如下所示：
- en: '[PRE21]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can also implement `bigger()` as a class method as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将`bigger()`实现为一个类方法，如下所示：
- en: '[PRE22]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Given two `Circle` objects, `x` and `y`, we can use either the instance method
    or the class method to determine which is bigger. The invocation syntax differs
    significantly for the two methods, however:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 给定两个`Circle`对象`x`和`y`，我们可以使用实例方法或类方法来确定哪个更大。然而，这两种方法的调用语法有显著区别：
- en: '[PRE23]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Both methods work well, and, from an object-oriented design standpoint, neither
    of these methods is “more correct” than the other. The instance method is more
    formally object-oriented, but its invocation syntax suffers from a kind of asymmetry.
    In a case like this, the choice between an instance method and a class method
    is simply a design decision. Depending on the circumstances, one or the other
    will likely be the more natural choice.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都很有效，并且从面向对象设计的角度来看，这两种方法都没有比另一种方法更“正确”的说法。实例方法在形式上更符合面向对象，但其调用语法存在某种不对称性。在这种情况下，选择实例方法或类方法仅仅是一种设计决策。根据情况，其中一种方法可能更为自然。
- en: A word about System.out.println()
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于System.out.println()的一点说明
- en: 'We’ve frequently encountered the method `System.out.println()`—it’s used to
    display output to the terminal window or console. We’ve never explained why this
    method has such a long, awkward name or what those two periods are doing in it.
    Now that you understand class and instance fields and class and instance methods,
    it is easier to understand what is going on: `System` is a class. It has a public
    class field named `out`. This field is an object of type `java.io.PrintStream`,
    and it has an instance method named `println()`.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常遇到方法`System.out.println()` — 它用于将输出显示到终端窗口或控制台。我们从未解释过为什么这个方法有这么长、笨拙的名字，或者这两个点在里面做什么。现在你理解了类和实例字段以及类和实例方法，更容易理解正在发生的事情：`System`是一个类。它有一个名为`out`的公共类字段。这个字段是`java.io.PrintStream`类型的对象，它有一个名为`println()`的实例方法。
- en: We can use static imports to make this a bit shorter with `import static java.lang.System.out;`—this
    will enable us to refer to the printing method as `out.println()` but as this
    is an instance method, we cannot shorten it further.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用静态导入来缩短这个过程，比如`import static java.lang.System.out;` — 这将使我们能够将打印方法简化为`out.println()`，但由于这是一个实例方法，我们无法进一步缩短它。
- en: Composition Versus Inheritance
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合与继承
- en: Inheritance is not the only technique at our disposal in object-oriented design.
    Objects can contain references to other objects, so a larger conceptual unit can
    be aggregated out of smaller component parts; this is known as *composition*.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 继承并不是面向对象设计中我们唯一可以使用的技术。对象可以包含对其他对象的引用，因此可以从更小的组件部分聚合出更大的概念单元；这被称为*组合*。
- en: 'An important related technique is *delegation*, where an object of a particular
    type holds a reference to a secondary object of a compatible type and forwards
    all operations to the secondary object. This is frequently done using interface
    types, as shown in this example where we model the employment structure of software
    companies:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的相关技术是*委托*，其中特定类型的对象持有对兼容类型的次要对象的引用，并将所有操作转发到次要对象。这通常通过接口类型来完成，正如本例中展示的那样，我们在这里模拟软件公司的就业结构：
- en: '[PRE24]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `Manager` class is said to *delegate* the `work()` operation to their direct
    report, and no actual work is performed by the `Manager` object. Variations of
    this pattern involve some work being done in the delegating class, with only some
    calls being forwarded to the delegate object.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`Manager`类被认为是*委托*`work()`操作给他们的直接报告，`Manager`对象不执行任何实际工作。此模式的变体涉及在委托类中执行一些工作，只将一些调用转发到委托对象。'
- en: 'Another useful, related technique is called the *decorator pattern*. This provides
    the capability to extend objects with new functionality, including at runtime.
    The slight overhead is some extra work needed at design time. Let’s look at an
    example of the decorator pattern as applied to modeling burritos for sale at a
    taqueria. To keep things simple, we’ve modeled only a single aspect to be decorated—the
    price of the burrito:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种有用的相关技术称为*装饰者模式*。这提供了在运行时扩展对象功能的能力。设计时需要一些额外的工作量。让我们看一个装饰者模式的例子，应用于模拟在塔科店出售的卷饼。为了保持简单，我们仅模拟要装饰的一个方面——卷饼的价格：
- en: '[PRE25]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'These cover the basic burritos that can be offered—two different sizes, at
    different prices. Let’s enhance this by adding some optional extras—jalapeño chilies
    and guacamole. The key design point here is to use an abstract base class that
    all of the optional decorating components will subclass:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这些涵盖了可以提供的基本卷饼——两种不同的尺寸，不同的价格。让我们通过添加一些可选的额外配料——辣椒和鳄梨酱来增强这一点。这里的关键设计点是使用一个抽象基类，所有可选的装饰组件都将其子类化：
- en: '[PRE26]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Combining an `abstract` base, `BurritoOptionalExtra`, with a `protected` constructor
    means that the only valid way to get a `BurritoOptionalExtra` is to construct
    an instance of one of the subclasses, as they have public constructors. This approach
    also hides the setup of the price of the component from client code.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 结合一个`abstract`基类`BurritoOptionalExtra`，以及一个`protected`构造函数，意味着获取`BurritoOptionalExtra`的唯一有效方法是构造其子类的实例，因为它们具有公共构造函数。这种方法还可以隐藏组件价格的设置，使客户端代码无法访问。
- en: Note
  id: totrans-230
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Decorators can, of course, also be combined with sealed types to allow only
    a known, finite list of possible decorators.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，装饰者也可以与密封类型结合使用，以允许仅限于已知的有限列表的装饰者。
- en: 'Let’s test the implementation:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来测试这个实现：
- en: '[PRE27]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The decorator pattern is very widely used, not least in the JDK utility classes.
    When we discuss Java I/O in [Chapter 10](ch10.xhtml#javanut8-CHP-10), we will
    see more examples of decorators in the wild.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器模式被广泛应用，尤其是在 JDK 实用类中。当我们在[第 10 章](ch10.xhtml#javanut8-CHP-10)中讨论 Java I/O
    时，我们将看到更多实际应用中的装饰器示例。
- en: Exceptions and Exception Handling
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常和异常处理
- en: We met checked and unchecked exceptions in [“Checked and Unchecked Exceptions”](ch02.xhtml#javanut8-CHP-2-SECT-6.3).
    In this section, we discuss some additional aspects of the design of exceptions
    and how to use them in your own code.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[“已检查和未检查异常”](ch02.xhtml#javanut8-CHP-2-SECT-6.3)中遇到了已检查和未检查异常。在本节中，我们讨论异常设计的一些附加方面以及如何在您自己的代码中使用它们。
- en: 'Recall that an exception in Java is an object. The type of this object is `java.lang.Throwable`,
    or more commonly, some subclass of `Throwable` that more specifically describes
    the type of exception that occurred. `Throwable` has two standard subclasses:
    `java.lang.Error` and `java.lang.Exception`. Exceptions that are subclasses of
    `Error` generally indicate unrecoverable problems: the virtual machine has run
    out of memory, or a class file is corrupted and cannot be read, for example. Exceptions
    of this sort can be caught and handled, but it is rare to do so—these are the
    unchecked exceptions previously mentioned.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在 Java 中，异常是一个对象。这个对象的类型是 `java.lang.Throwable`，或者更常见的是 `Throwable` 的某个子类，更具体地描述了发生的异常类型。`Throwable`
    有两个标准的子类：`java.lang.Error` 和 `java.lang.Exception`。属于 `Error` 子类的异常通常指示不可恢复的问题：虚拟机已经耗尽了内存，或者类文件已损坏且无法读取，例如。这类异常可以被捕获和处理，但很少这样做
    —— 这些是先前提到的未检查异常。
- en: Exceptions that are subclasses of `Exception`, on the other hand, indicate less
    severe conditions. These exceptions can be reasonably caught and handled. They
    include such exceptions as `java.io.EOFException`, which signals the end of a
    file, and `java.lang.ArrayIndexOutOfBoundsException`, which indicates that a program
    has tried to read past the end of an array. These are the checked exceptions from
    [Chapter 2](ch02.xhtml#javanut8-CHP-2) (except for subclasses of `RuntimeException`,
    which are also a form of unchecked exception). In this book, we use the term “exception”
    to refer to any exception object, regardless of whether the type of that exception
    is `Exception` or `Error`.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，属于 `Exception` 子类的异常指示的是较不严重的情况。这些异常可以被合理地捕获和处理。它们包括诸如 `java.io.EOFException`（表示文件结束）和
    `java.lang.ArrayIndexOutOfBoundsException`（指示程序尝试读取超出数组末尾的位置）等异常。这些是来自[第 2 章](ch02.xhtml#javanut8-CHP-2)中的已检查异常（除了
    `RuntimeException` 子类，它们也是一种未检查异常）。在本书中，我们使用术语“异常”来指代任何异常对象，无论该异常的类型是 `Exception`
    还是 `Error`。
- en: Because an exception is an object, it can contain data, and its class can define
    methods that operate on that data. The `Throwable` class and all its subclasses
    include a `String` field that stores a human-readable error message that describes
    the exceptional condition. It’s set when the exception object is created and can
    be read from the exception with the `getMessage()` method. Most exceptions contain
    only this single message, but a few add other data. The `java.io.InterruptedIOException`,
    for example, adds a field named `bytesTransferred` that specifies how much input
    or output was completed before the exceptional condition interrupted it.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 因为异常是一个对象，它可以包含数据，并且它的类可以定义操作该数据的方法。`Throwable` 类及其所有子类都包括一个 `String` 字段，用于存储描述异常条件的可读错误消息。异常对象创建时设置该字段，并可以通过
    `getMessage()` 方法从异常中读取。大多数异常只包含这一条消息，但有些异常会添加其他数据。例如，`java.io.InterruptedIOException`
    添加了一个名为 `bytesTransferred` 的字段，指定了在异常条件中断之前完成的输入或输出量。
- en: When designing your own exceptions, you should consider what other additional
    modeling information is relevant to the exception object. This is usually situation-specific
    information about the aborted operation, and the exceptional circumstance that
    was encountered (as we saw with `java.io.InterruptedIOException`).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计自己的异常时，应考虑与异常对象相关的其他建模信息。这通常是关于中止操作的具体信息，以及遇到的异常情况（正如我们在 `java.io.InterruptedIOException`
    中看到的）。
- en: There are some trade-offs in the use of exceptions in application design. Using
    checked exceptions means that the compiler can enforce the handling (or propagation
    up the call stack) of known conditions that have the potential of recovery or
    retry. It also means that it’s more difficult to forget to actually handle errors—thus
    reducing the risk that a forgotten error condition causes a system to fail in
    production.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序设计中使用异常存在一些权衡。使用受检异常意味着编译器可以强制处理（或向上传播到调用堆栈）已知的可能恢复或重试的条件。这也意味着更难忘记实际处理错误——从而减少忘记错误条件导致系统在生产中失败的风险。
- en: On the other hand, some applications will not be able to recover from certain
    conditions, even conditions that are theoretically modeled by checked exceptions.
    For example, if an application requires a config file to be placed at a specific
    place in the filesystem and can’t locate it at startup, it may have no option
    but to print an error message and exit—despite the fact that `java.io.FileNotFoundException`
    is a checked exception. Forcing exceptions that cannot be recovered from to be
    either handled or propagated is, in these circumstances, bordering on perverse;
    in this situation, printing the error and exiting is the only really sensible
    action.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，有些应用程序将无法从某些条件中恢复，即使这些条件在理论上由受检异常建模。例如，如果应用程序要求在文件系统中特定位置放置配置文件，并且在启动时找不到它，则可能只能打印错误消息并退出——尽管`java.io.FileNotFoundException`是一个受检异常。在这些情况下，强制处理或传播无法从中恢复的异常，边缘情况，打印错误并退出是唯一真正明智的操作。
- en: 'When designing exception schemes, here are some good practices you should follow:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计异常方案时，以下是一些您应该遵循的良好实践：
- en: Consider what additional state needs to be placed on the exception—remember
    that it’s also an object like any other.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑需要放置在异常上的附加状态——记住它也是一个像其他任何对象一样的对象。
- en: '`Exception` has four public constructors—under normal circumstances, custom
    exception classes should implement all of them—to initialize the additional state
    or to customize messages.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Exception`有四个公共构造函数——在正常情况下，自定义异常类应该实现所有这些函数——用于初始化额外状态或自定义消息。'
- en: Don’t create many fine-grained custom exception classes in your APIs—the Java
    I/O and reflection APIs both suffer from this, and it needlessly complicates working
    with those packages.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要在您的API中创建许多细粒度的自定义异常类——Java I/O和反射API都受到此类问题的困扰，并且这样做只会不必要地复杂化与这些包的工作。
- en: Don’t overburden a single exception type with describing too many conditions.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要用一个单一的异常类型描述太多的条件。
- en: Never create an exception until you’re sure you need to throw it. Exception
    creation can be a costly operation.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在确定需要抛出异常之前，永远不要创建异常。异常创建可能是一个昂贵的操作。
- en: 'Finally, two exception-handling antipatterns you should avoid:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，有两种异常处理反模式您应该避免：
- en: '[PRE28]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The former just ignores a condition that almost certainly required some action
    (even if just a notification in a log). This increases the likelihood of failure
    elsewhere in the system—potentially far from the original, real source.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 前者只是忽略了几乎肯定需要采取某些行动的条件（即使只是在日志中通知）。这增加了系统中其他地方发生失败的可能性——可能远离原始的真实来源。
- en: The second just creates noise. We’re logging a message but not actually doing
    anything about the issue; we still require some other code higher up in the system
    to actually deal with the problem.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个只是制造噪音。我们记录了一条消息，但实际上没有处理这个问题；我们仍然需要在系统中更高级别的其他代码来实际处理这个问题。
- en: Safe Java Programming
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全的Java编程
- en: Programming languages are sometimes described as being *type safe*; however,
    this term is used rather loosely by working programmers. There are a number of
    different viewpoints on and definitions for type safety, not all of which are
    mutually compatible. The most useful view for our purposes is that *type safety*
    is the property of a programming language that prevents the type of data being
    incorrectly identified at runtime. This should be thought of as a sliding scale—it
    is more helpful to think of languages as being more (or less) type safe than each
    other, rather than a simple binary property of safe/unsafe.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 编程语言有时被描述为*类型安全*；然而，这个术语在工作程序员中使用得比较宽泛。关于类型安全有许多不同的观点和定义，并非所有观点都是相互兼容的。对于我们的目的来说，最有用的观点是*类型安全*是编程语言的一个属性，可以防止在运行时错误地标识数据的类型。这应该被视为一个滑动尺度——更有助于将语言视为在类型安全性方面更多（或更少）的语言，而不是一个简单的安全/不安全的二元属性。
- en: In Java, the static nature of the type system helps prevent a large class of
    possible errors by producing compilation errors if, for example, the programmer
    attempts to assign an incompatible value to a variable. However, Java is not perfectly
    type safe, as we can perform a cast between any two reference types—this will
    fail at runtime with a `ClassCastException` if the value is not compatible.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 中，类型系统的静态特性通过产生编译错误来防止大量可能的错误，例如，如果程序员尝试将不兼容的值分配给变量。然而，Java 并不是完全类型安全的，因为我们可以在任何两个引用类型之间进行强制类型转换——如果值不兼容，这将在运行时失败，抛出
    `ClassCastException`。
- en: In this book, we prefer to think of safety as inseparable from the broader topic
    of correctness. This means that we should think in terms of programs, rather than
    languages. This emphasizes the point that safe code is not guaranteed by any widely
    used language, and instead considerable programmer effort (and adherence to rigorous
    coding discipline) must be employed if the end result is to be truly safe and
    correct.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们倾向于将安全性视为不可分割的正确性主题。这意味着我们应该以程序为中心，而不是语言。这强调了一个观点：安全代码并不是任何广泛使用的语言所保证的，反而需要相当大的程序员努力（和严格的编码纪律）才能确保最终结果真正安全和正确。
- en: 'We approach our view of safe programs by working with the state model abstraction
    as shown in [Figure 5-1](#javanut8-CHP-5-FIG-1). A *safe* program is one in which:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过与状态模型抽象的合作来接近安全程序的视角，如[图 5-1](#javanut8-CHP-5-FIG-1)所示。一个 *安全* 的程序是指：
- en: All objects start off in a legal state after creation
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有对象在创建后都处于合法状态。
- en: Externally accessible methods transition objects between legal states
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部可访问的方法在合法状态之间转换对象。
- en: Externally accessible methods must not return with objects in an inconsistent
    state
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部可访问的方法不得在对象处于不一致状态时返回。
- en: Externally accessible methods must reset objects to a legal state before throwing
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部可访问的方法在抛出异常之前必须将对象重置为合法状态。
- en: In this context, “externally accessible” means `public`, package-private, or
    `protected`. This defines a reasonable model for safety of programs, and as it
    is bound up with defining our abstract types in such a way that their methods
    ensure consistency of state, it’s reasonable to refer to a program satisfying
    these requirements as a “safe program,” regardless of the language in which such
    a program is implemented.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，“外部可访问”意味着 `public`、包私有（package-private）或 `protected`。这为程序的安全性定义了一个合理的模型，因为它与定义我们的抽象类型有关，使其方法确保状态的一致性，因此合理地将满足这些要求的程序称为“安全程序”，无论该程序是在何种语言中实现。
- en: Warning
  id: totrans-263
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Private methods do not have to start or end with objects in a legal state, as
    they cannot be called by an external piece of code.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 私有方法不需要以合法状态的对象开始或结束，因为它们不能被外部代码调用。
- en: As you might imagine, actually engineering a substantial piece of code so that
    we can be sure that the state model and methods respect these properties can be
    quite an undertaking. In languages such as Java, in which programmers have direct
    control over the creation of preemptively multitasked execution threads, this
    problem is a great deal more complex.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如   正如你可能想象的，实际实现大量代码，以确保状态模型和方法遵守这些属性，可能是相当艰巨的任务。在像 Java 这样的语言中，程序员直接控制预先多任务执行线程的创建，这个问题要复杂得多。
- en: '![JN7 0501](assets/jns8_0501.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![JN7 0501](assets/jns8_0501.png)'
- en: Figure 5-1\. Program state transitions
  id: totrans-267
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-1\. 程序状态转换
- en: Moving on from our introduction of object-oriented design, one final aspect
    of the Java language and platform needs to be understood for a sound grounding.
    That is the nature of memory and concurrency—one of the most complex of the platform,
    but also one that rewards careful study with large dividends. It is the subject
    of our next chapter and concludes [Part I](part01.xhtml#javanut-PART-1).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们对面向对象设计的介绍过渡到 Java 语言和平台的最后一个方面，需要理解一个坚实的基础。这就是内存和并发的特性——这是平台中最复杂的之一，但也正是通过细致研究带来了巨大的回报。它是我们下一章的主题，并结束了[第一部分](part01.xhtml#javanut-PART-1)。
- en: ^([1](ch05.xhtml#idm45927734963040-marker)) Technically, this should probably
    be called `SCREAMING_SNAKE_CASE`
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch05.xhtml#idm45927734963040-marker)) 从技术上讲，这应该被称为 `SCREAMING_SNAKE_CASE`。
