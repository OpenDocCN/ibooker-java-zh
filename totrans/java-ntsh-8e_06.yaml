- en: Chapter 5\. Introduction to Object-Oriented Design in Java
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will consider several techniques relevant to object-oriented
    design (OOD) in Java.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll look at how to work with Java’s objects, covering the key methods of `Object`,
    aspects of object-oriented design, and implementing exception handling schemes.
    Throughout the chapter, we will be introducing some *design patterns*—essentially
    best practices for solving some very common situations that arise in software
    design. Toward the end of the chapter, we’ll also consider *safe* programs—those
    that are designed so as not to become inconsistent over time.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This chapter is intended to showcase some examples of a complex topic and a
    few underlying principles. We encourage you to consult additional resources, such
    as *Effective Java* by Josh Bloch.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll get started by considering the subject of Java’s calling and passing conventions
    and the nature of Java values.
  prefs: []
  type: TYPE_NORMAL
- en: Java Values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Java’s values, and their relationship to the type system, are quite straightforward.
    Java has two types of values: primitives and object references.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: There are only eight different primitive types in Java, and new primitive types
    cannot be defined by the programmer.
  prefs: []
  type: TYPE_NORMAL
- en: The key difference between primitive values and references is that primitive
    values cannot be altered; the value `2` is always the same value. By contrast,
    the contents of object references can usually be changed—often referred to as
    *mutation* of object contents.
  prefs: []
  type: TYPE_NORMAL
- en: Also note that variables can contain values only of the appropriate type. In
    particular, variables of reference type always contain a reference to the memory
    location holding the object—they do not contain the object contents directly.
    This means that in Java there is no equivalent of a dereference operator or a
    `struct`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Java tries to simplify a concept that often confused C++ programmers: the difference
    between “contents of an object” and “reference to an object.” Unfortunately, it’s
    not possible to completely hide the difference, and so it is necessary for the
    programmer to understand how reference values work in the platform.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The fact that Java is pass by value can be demonstrated very simply, e.g.,
    by running the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This outputs `Radius: 2` twice and thus shows that even after the call to `manipulate()`,
    the value contained in variable `c` is unaltered—it is still holding a reference
    to a `Circle` object of radius 2. If Java was a pass-by-reference language, it
    would instead be holding a reference to a radius 3 `Circle`:'
  prefs: []
  type: TYPE_NORMAL
- en: If we’re scrupulously careful about the distinction, and about referring to
    object references as one of Java’s possible kinds of values, then some otherwise
    surprising features of Java become obvious. Be careful! Some older texts are ambiguous
    on this point. We will meet this concept of Java’s values again when we discuss
    memory and garbage collection in [Chapter 6](ch06.xhtml#javanut8-CHP-6).
  prefs: []
  type: TYPE_NORMAL
- en: Important Common Methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we’ve noted, all classes extend, directly or indirectly, `java.lang.Object`.
    This class defines a number of useful methods, some of which were designed to
    be overridden by classes you write. [Example 5-1](#javanut8-CHP-5-EX-1) shows
    a class that overrides these methods. The sections that follow this example document
    the default implementation of each method and explain why you might want to override
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this example is for demonstration purposes only; in reality, we would
    represent classes like `Circle` as records and get a lot of these methods implemented
    automatically by the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-1\. A class that overrides important Object methods
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 5-1](#javanut8-CHP-5-EX-1) uses a lot of the extended features of
    the type system that we introduced in [Chapter 4](ch04.xhtml#javanut8-CHP-4).
    First, this example implements a parameterized, or generic, version of the `Comparable`
    interface. Second, it uses the `@Override` annotation to emphasize (and have the
    compiler verify) that certain methods override `Object`.'
  prefs: []
  type: TYPE_NORMAL
- en: toString()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The purpose of the `toString()` method is to return a textual representation
    of an object. The method is invoked automatically on objects during string concatenation
    and by methods such as `System.out.println()`. Giving objects a textual representation
    can be quite helpful for debugging or logging output, and a well-crafted `toString()`
    method can even help with tasks such as report generation.
  prefs: []
  type: TYPE_NORMAL
- en: The version of `toString()` inherited from `Object` returns a string that includes
    the name of the class of the object as well as a hexadecimal representation of
    the `hashCode()` value of the object (discussed later in this chapter). This default
    implementation provides basic type and identity information for an object but
    is not very useful. The `toString()` method in [Example 5-1](#javanut8-CHP-5-EX-1)
    instead returns a human-readable string that includes the value of each of the
    fields of the `Circle` class.
  prefs: []
  type: TYPE_NORMAL
- en: equals()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `==` operator tests two references to see if they refer to the same object.
    If you want to test whether two distinct objects are equal to one another, you
    must use the `equals()` method instead. Any class can define its own notion of
    equality by overriding `equals()`. The `Object.equals()` method simply uses the
    `==` operator: this default method considers two objects equal only if they are
    actually the very same object.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `equals()` method in [Example 5-1](#javanut8-CHP-5-EX-1) considers two
    distinct `Circle` objects to be equal if their fields are all equal. Note that
    it first does a quick identity test with `==` as an optimization and then checks
    the type of the other object with `instanceof`: a `Circle` can be equal only to
    another `Circle`, and it is not acceptable for an `equals()` method to throw a
    `ClassCastException`. Note that the `instanceof` test also rules out `null` arguments:
    `instanceof` always evaluates to `false` if its lefthand operand is `null`.'
  prefs: []
  type: TYPE_NORMAL
- en: hashCode()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Whenever you override `equals()`, you also must override `hashCode()`. This
    method returns an integer for use by hash table data structures. It is critical
    that two objects have the same hash code if they are equal according to the `equals()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: It is important (for efficient operation of hash tables) but not required that
    unequal objects have unequal hash codes, or at least that unequal objects are
    unlikely to share a hash code. This second criterion can lead to `hashCode()`
    methods that involve mildly tricky arithmetic or bit manipulation.
  prefs: []
  type: TYPE_NORMAL
- en: The `Object.hashCode()` method works with the `Object.equals()` method and returns
    a hash code based on object identity rather than object equality. (If you ever
    need an identity-based hash code, you can access the functionality of `Object.hashCode()`
    through the static method `System.identityHashCode()`.)
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: When you override `equals()`, you must always override `hashCode()` to guarantee
    that equal objects have equal hash codes. Failing to do this can cause subtle
    bugs in your programs.
  prefs: []
  type: TYPE_NORMAL
- en: Because the `equals()` method in [Example 5-1](#javanut8-CHP-5-EX-1) bases object
    equality on the values of the three fields, the `hashCode()` method computes its
    hash code based on these three fields as well. It is clear from the code that
    if two `Circle` objects have the same field values, they will have the same hash
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `hashCode()` method in [Example 5-1](#javanut8-CHP-5-EX-1) does
    not simply add the three fields and return their sum. Such an implementation would
    be legal but not efficient because two circles with the same radius but whose
    *x* and *y* coordinates were reversed would then have the same hash code. The
    repeated multiplication and addition steps “spread out” the range of hash codes
    and dramatically reduce the likelihood that two unequal `Circle` objects have
    the same code.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, modern Java programmers will either autogenerate `hashCode()`,
    `equals()`, and `toString()` from within their IDE (for classes), or use records
    where the source code compiler produces a standard form of these methods. For
    the extremely rare cases where the programmer chooses not to use either of these
    approaches, *Effective Java* by Joshua Bloch (Addison Wesley) includes a helpful
    recipe for constructing efficient `hashCode()` methods.
  prefs: []
  type: TYPE_NORMAL
- en: Comparable::compareTo()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Example 5-1](#javanut8-CHP-5-EX-1) includes a `compareTo()` method. This method
    is defined by the `java.lang.Comparable` interface rather than by `Object`, but
    it is such a common method to implement that we include it in this section. The
    purpose of `Comparable` and its `compareTo()` method is to allow instances of
    a class to be compared to each other in a similar way to how the `<`, `<=`, `>`,
    and `>=` operators compare numbers. If a class implements `Comparable`, we can
    call methods to allow us to say that one instance is less than, greater than,
    or equal to another instance. This also means that instances of a `Comparable`
    class can be sorted.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The method `compareTo()` sets up a *total ordering* of the objects of the type.
    This is referred to as the *natural order* of the type, and the method is called
    the *natural comparison method*.
  prefs: []
  type: TYPE_NORMAL
- en: Because `compareTo()` is not declared by the `Object` class, it is up to each
    individual class to determine whether and how its instances should be ordered
    and to include a `compareTo()` method that implements that ordering.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ordering defined by [Example 5-1](#javanut8-CHP-5-EX-1) compares `Circle`
    objects as if they were words on a page. Circles are first ordered from top to
    bottom: circles with larger *y* coordinates are less than circles with smaller
    *y* coordinates. If two circles have the same *y* coordinate, they are ordered
    from left to right. A circle with a smaller *x* coordinate is less than a circle
    with a larger *x* coordinate. Finally, if two circles have the same *x* and *y*
    coordinates, they are compared by radius. The circle with the smaller radius is
    smaller.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that under this ordering, two circles are equal only if all three of their
    fields are equal. This means that the ordering defined by `compareTo()` is consistent
    with the equality defined by `equals()`. This is not strictly required but is
    very desirable, and you should aim for it wherever possible.
  prefs: []
  type: TYPE_NORMAL
- en: The `compareTo()` method returns an `int` value that requires further explanation.
    `compareTo()` should return a negative number if the `this` object is less than
    the object passed to it. It should return 0 if the two objects are equal. And
    `compareTo()` should return a positive number if `this` is greater than the method
    argument.
  prefs: []
  type: TYPE_NORMAL
- en: clone()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Object` defines a method named `clone()` whose purpose is to return an object
    with fields set identically to those of the current object. This is an unusual
    method for several reasons.'
  prefs: []
  type: TYPE_NORMAL
- en: First, `clone()` is declared as `protected`. Therefore, if you want your object
    to be cloneable by other classes, you must override the `clone()` method, making
    it `public`. Next, the default implementation of `clone()` in `Object` throws
    a checked exception, `CloneNotSupportedException`, unless the class implements
    the `java.lang.Cloneable` interface. Note that this interface does not define
    any methods (it is a marker interface), so implementing it is simply a matter
    of listing it in the `implements` clause of the class signature.
  prefs: []
  type: TYPE_NORMAL
- en: 'The original intent of `clone()` was to provide a mechanism to produce “deep
    copies” of objects, but it is fundamentally flawed and its use is not recommended.
    Instead, developers should prefer declaring a *copy constructor* for making copies
    of their objects, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We will meet copy constructors again when we consider factory methods, later
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Constants
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Java a constant is a `static final` field. This combination of modifiers
    gives a single value (per class) with the given name, and it is initialized as
    soon as the class is loaded and then cannot be changed.
  prefs: []
  type: TYPE_NORMAL
- en: By convention, Java’s constants are named in all-capitals, using *snake case*,
    for example `NETWORK_SERVER_SOCKET`^([1](ch05.xhtml#idm45927734963040)) as opposed
    to the “camel case” (or “camelCase”) convention `networkServerSocket` for a regular
    field.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are essentially three different subcases of constants that can appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '`public` constants: these form part of the public API of the class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`private` constants: these are used when the constant is an internal implementation
    detail for this class only'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Package-level constants: these have no additional access keyword and are used
    when the constant is an internal implementation detail that needs to be seen by
    different classes within the same package'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The final case might arise, for example, when client and server classes implement
    a network protocol whose details (such as the port number to connect to and listen
    on) are captured in a set of symbolic constants.
  prefs: []
  type: TYPE_NORMAL
- en: As discussed earlier, an alternative approach is for constants to appear in
    an interface definition. Any class that implements an interface inherits the constants
    it defines and can use them as if they were defined directly in the class itself.
    This has the advantage that there is no need to prefix the constants with the
    name of the interface or provide any kind of implementation of the constants.
  prefs: []
  type: TYPE_NORMAL
- en: However, this is rather overcomplicated and so the preferred approach is to
    define constants (as either public or package-level) in a class and use them by
    importing the constants from their defining class with the `import static` declaration.
    See [“Packages and the Java Namespace”](ch02.xhtml#javanut8-CHP-2-SECT-10) for
    details.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Fields
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Java provides a variety of access control keywords that can be used to define
    how fields can be accessed. It is perfectly legal to use any of these possibilities,
    but in practice there are three primary choices for field access that Java developers
    typically use:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Constants (`static final`): the case that we just met, which may have an additional
    access control keyword as well'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Immutable fields (`private final`): fields with this combination cannot be
    altered after object creation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Mutable fields (`private`): this combination should only be used if the programmer
    is sure that the field’s value will change during the object’s lifetime'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In recent years, many developers have adopted the practice of using immutable
    data wherever possible. There are several benefits to this approach, but the main
    one is that if objects can be designed so that they cannot be modified after creation,
    then they can be freely shared between threads.
  prefs: []
  type: TYPE_NORMAL
- en: When writing classes, we recommend using the above three choices for field modifiers,
    depending on the circumstances. Instance fields should always be initially written
    as `final` and made mutable only if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, direct field access should not be used, except for constants. Instead,
    getter methods (and setters, for the case of mutable state) should be preferred.
    The primary reason for this is that direct field access is a very tight coupling
    between the defining class and any client code. If accessor methods are used,
    then the implementation code for those methods can later be modified without changing
    the client code—this is impossible with field access.
  prefs: []
  type: TYPE_NORMAL
- en: 'We should also call out one common mistake in field handling: Developers coming
    from C++ frequently make the mistake of omitting any access modifiers for fields.
    This is a serious defect, because C++ has a default visibility of private, whereas
    Java’s default access is considerably more open. This represents a failure of
    encapsulation in Java, and developers should take care to avoid it.'
  prefs: []
  type: TYPE_NORMAL
- en: Field Inheritance and Accessors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As well as the above considerations, Java offers multiple potential approaches
    to the design issue of the inheritance of state. The programmer could choose to
    mark fields as `protected` and allow them to be accessed directly by subclasses
    (including writing to them). Alternatively, we can provide *accessor methods*
    to read (and write, if desired) the actual object fields, while retaining encapsulation
    and leaving the fields as `private`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s revisit our earlier `PlaneCircle` example from the end of [Chapter 3](ch03.xhtml#javanut8-CHP-3)
    and explicitly show the field inheritance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of the preceding code, we can rewrite `PlaneCircle` using accessor
    methods, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Both approaches are legal Java, but they have some differences. As we discussed
    in [“Data Hiding and Encapsulation”](ch03.xhtml#javanut8-CHP-3-SECT-5), fields
    that are writable outside of the class are usually not a correct way to model
    object state. In fact, as we will see later in this chapter and again in [“Java’s
    Support for Concurrency”](ch06.xhtml#javanut8-CHP-6-SECT-5), they can damage the
    running state of a program irreparably.
  prefs: []
  type: TYPE_NORMAL
- en: It is therefore unfortunate that the `protected` keyword in Java allows access
    to fields (and methods) from both subclasses *and* classes in the same packages
    as the declaring class. This, combined with the ability for anyone to write a
    class that belongs to any given package (except system packages), means that protected
    inheritance of state is potentially flawed in Java.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Java does not provide a mechanism for a member to be visible only in the declaring
    class and its subclasses.
  prefs: []
  type: TYPE_NORMAL
- en: For all of these reasons, it is almost always better to use accessor methods
    (either public or protected) to provide access to state for subclasses—unless
    the inherited state is declared `final`, in which case protected inheritance of
    state is perfectly permissible.
  prefs: []
  type: TYPE_NORMAL
- en: Singleton
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The *singleton pattern* is a very well-known design pattern. It is intended
    to solve the design issue where only a single instance of a class is required
    or desired. Java provides a number of different possible ways to implement the
    singleton pattern. In our discussion, we will use a slightly more verbose form,
    which has the benefit of being very explicit in what needs to happen for a safe
    singleton:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The crucial point is that for the singleton pattern to be effective, it must
    be impossible to create more than one of them, and it must be impossible to get
    a reference to the object in an uninitialized state (see later in this chapter
    for more on this important point).
  prefs: []
  type: TYPE_NORMAL
- en: To achieve this, we require a `private` constructor, which is called only once,
    ever. In our version of `Singleton`, we only call the constructor when we initialize
    the private static variable `instance`. We also separate the creation of the only
    `Singleton` object from its initialization—which occurs in the private method
    `init()`.
  prefs: []
  type: TYPE_NORMAL
- en: With this mechanism in place, the only way to get a reference to the lone instance
    of `Singleton` is via the static helper method, `getInstance()`. This method checks
    the flag `initialized` to see if the object is already in an active state. If
    it is, then a reference to the singleton object is returned. If not, then `getInstance()`
    calls `init()` to activate the object and flicks the flag to `true`, so that next
    time a reference to the `Singleton` is requested, further initialization will
    not occur.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we also note that `getInstance()` is a `synchronized` method. See [Chapter 6](ch06.xhtml#javanut8-CHP-6)
    for full details of what this means and why it is necessary, but for now, know
    that it is present to guard against unintended consequences if `Singleton` is
    used in a multithreaded program.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Singleton, being one of the simplest patterns, is often overused. When used
    correctly, it can be a useful technique, but too many singleton classes in a program
    is a classic sign of badly engineered code.
  prefs: []
  type: TYPE_NORMAL
- en: The singleton pattern has some drawbacks—in particular, it can be hard to test
    and to separate from other classes. It also requires care when used in mulithreaded
    code. Nevertheless, it is important that developers are familiar with it and do
    not accidentally reinvent it. The singleton pattern is often used in configuration
    management, but modern code will typically use a framework (often a *dependency
    injection* framework) to provide the programmer with singletons automatically,
    rather than via an explicit `Singleton` (or equivalent) class.
  prefs: []
  type: TYPE_NORMAL
- en: Factory Methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An alternative to using constructors directly is the *Factory Method* pattern.
    The basic form of this technique is to make the constructor private (or other
    nonpublic modifier, in some variants) and to provide a static method that returns
    the desired type. This static method is then used by client code that wants an
    instance of the type.
  prefs: []
  type: TYPE_NORMAL
- en: There are various reasons why, as a code author, we may not want to expose our
    constructors directly and may choose to use factories instead. For example, caching
    factories that do not necessarily create a new object, or because there are several
    valid ways of constructing an object.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The static factory approach is not the same as the *Abstract Factory* pattern
    from the classic book [*Design Patterns*](https://oreil.ly/1CbpU).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s rewrite the constructor from [Example 5-1](#javanut8-CHP-5-EX-1) and
    introduce some factory methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This class contains a private constructor and three separate factory methods:
    a “usual” one with the same signature as the constructor, and two additional.
    One of these additional factories is effectively a copy constructor, and the other
    is used to handle a special case: circles at the origin.'
  prefs: []
  type: TYPE_NORMAL
- en: One advantage of using factory methods is that, unlike constructors, the method
    has a name and so can indicate its intent using part of the name. In our example,
    the factory methods are `of()`, which is one very common choice, and we distinguish
    the case of the origin circles by using a name `ofOrigin()` that expresses it.
  prefs: []
  type: TYPE_NORMAL
- en: Builders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Factory methods are a useful technique for when you don’t want to expose a constructor
    to client code. However, there are limitations to factories. They work well when
    only a few parameters, all of which are required, need to be passed. But in some
    circumstances, we need to model data where much of it is optional, or when there
    are many valid, different possible constructions for our domain objects. In this
    case, the number of factory methods can quickly multiply to represent all possible
    combinations and overwhelm us, cluttering the API.
  prefs: []
  type: TYPE_NORMAL
- en: An alternative approach is the *Builder* pattern. This pattern uses a secondary
    builder object that exactly parallels the state of the real domain object (which
    is assumed to be immutable). For every field that the domain object has, the builder
    has the same field—the same name, and the same type. However, while the domain
    object is immutable, the builder object is explicitly mutable. In fact, the builder
    has a setter method, named in the same way as the field (i.e. in “record convention”)
    that the developer will use to set up a piece of state.
  prefs: []
  type: TYPE_NORMAL
- en: The overall intent of the Builder pattern is to start from a “blank” builder
    object and add state to it, until the builder is ready to be converted into an
    actual domain object, usually by calling the `build()` method on the builder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the builder interface is typically generic. This is because in practice
    we may well have a large number of domain classes, all of which will require builders,
    so the use of a generic builder interface removes duplication. The `Builder` interface
    contains only one method, so it technically is a candidate for lambda target typing.
    But in practice this is almost never the intent, and so it is not tagged with
    `@FunctionalInterface`. The implementation of the `build()` method also contains
    a nonoptional use of the `this` reference.
  prefs: []
  type: TYPE_NORMAL
- en: 'The builder can be driven by a simple bit of code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note that first we instantiate the builder. Then, we call the methods to set
    the various parameters on the builder. Finally, we create an immutable object
    from the builder, by calling `build()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may notice that the methods on the builder that accrete state all return
    `this`. The point of this interface design is so that the calls can be *chained*—so
    that methods can be called one after another on the same mutable object—for example
    as `cb.x(1).y(2).r(3)`. Another way of describing this style of interface design
    is as a *fluent interface*. As each method returns `this`, we know that all of
    these calls are safe: there can’t be a `NullPointerException`.'
  prefs: []
  type: TYPE_NORMAL
- en: Our example is very simple and is somewhat contrived; it only has three parameters
    and all of them are required. In practice, builders are more useful with a larger
    number of object parameters and when there are multiple possibilities for “spanning
    sets” of valid object states. There exists an overlap between the cases where
    one should use a factory versus a builder; determining exactly where that boundary
    is for your own code is part of the development of OO design skills.
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces Versus Abstract Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java 8 fundamentally changed Java’s object-oriented programming model. Before
    Java 8, interfaces were pure API specification and contained no implementation.
    This could (and often did) lead to duplication of code when the interface had
    multiple implementations.
  prefs: []
  type: TYPE_NORMAL
- en: To prevent this wasted effort, a simple coding pattern developed that takes
    advantage of the fact that an abstract class can contain a partial implementation
    that subclasses can build upon. Numerous subclasses can rely on method implementations
    provided by an abstract superclass (also called an *abstract base*).
  prefs: []
  type: TYPE_NORMAL
- en: The pattern consists of an interface that contains the API spec for the basic
    methods, paired with a primary partial implementation as an abstract class. A
    good example would be `java.util.List`, which is paired with `java.util.AbstractList`.
    Two of the main implementations of `List` that ship with the JDK (`ArrayList`
    and `LinkedList`) are subclasses of `AbstractList`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As another example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The arrival of default methods in Java 8 changed this landscape considerably.
    Interfaces can now contain implementation code, as we saw in [“Default Methods”](ch04.xhtml#javanut8-CHP-4-SECT-1.7).
  prefs: []
  type: TYPE_NORMAL
- en: This means that when defining an abstract type (e.g., `Shape`) that you expect
    to have many subtypes (e.g., `Circle`, `Rectangle`, `Square`), you are faced with
    a choice between interfaces and abstract classes. As they now have potentially
    similar features, it is not always clear which to use.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that a class that extends an abstract class cannot extend any other
    class, and that interfaces still cannot contain any nonconstant fields. This means
    there are still some restrictions on how we can use inheritance in our Java programs.
  prefs: []
  type: TYPE_NORMAL
- en: Another important difference between interfaces and abstract classes has to
    do with compatibility. If you define an interface as part of a public API and
    then later add a new mandatory method to the interface, you break any classes
    that implemented the previous version of the interface—in other words, any new
    interface methods must be declared as default and an implementation provided.
  prefs: []
  type: TYPE_NORMAL
- en: If you use an abstract class, however, you can safely add nonabstract methods
    to that class without requiring modifications to existing classes that extend
    the abstract class.
  prefs: []
  type: TYPE_NORMAL
- en: In both cases, adding new methods can cause a clash with subclass methods of
    the same name and signature—with the subclass methods always winning. For this
    reason, think carefully when adding new methods, especially when the method names
    are “obvious” for this type or where the method could have several possible meanings.
  prefs: []
  type: TYPE_NORMAL
- en: In general, the suggested approach is to prefer interfaces when an API specification
    is needed. The mandatory methods of the interface are nondefault, as they represent
    the part of the API that must be present for an implementation to be considered
    valid. Default methods should be used only if a method is truly optional, or if
    they are really only intended to have a single possible implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the older (pre-Java 8) technique of declaring in documentation which
    methods of an interface are considered “optional” and directing to implementations
    to throw a `java.lang.UnsupportedOperationException` if the programmer does not
    want to implement them is fraught with problems and should not be used in new
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Do Default Methods Change Java’s Inheritance Model?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before Java 8, the strict single inheritance model of the language was clear.
    Every class (except `Object`) had exactly one direct superclass, and method implementations
    could only either be defined in a class, or be inherited from the superclass hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: Default methods change this picture, because they allow method implementations
    to be inherited from multiple places—either from the superclass hierarchy or from
    default implementation provided in interfaces. Any potential conflicts between
    different default methods from separate interfaces will result in a compile-time
    error.
  prefs: []
  type: TYPE_NORMAL
- en: This means there is no possibility of conflicting multiple inheritance of implementation,
    as in any clash the programmer is required to manually disambiguate the methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also no multiple inheritance of state: interfaces still do not have
    non-constant fields.'
  prefs: []
  type: TYPE_NORMAL
- en: This means that Java’s multiple inheritance is different from the general multiple
    inheritance found in, e.g., C++. In fact, default methods are effectively the
    *Mixin* pattern from C++ (for readers who are familiar with that language). Some
    developers also view default members as a form of the *trait* language feature
    that appears in some OO languages (e.g., Scala).
  prefs: []
  type: TYPE_NORMAL
- en: However, the official position from Java’s language designers is that default
    methods fall short of being full traits. This view is somewhat undermined by the
    code that ships within the JDK—even the interfaces within `java.util.function`
    (such as `Function` itself) behave as simple traits.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: It is a simplified version of the `Function` interface in `java.util.function`
    that removes the generics and deals with `int` only as a data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'This case shows an important point for the functional composition methods (
    `compose()` and `andThen()`) present: these functions will only be composed in
    the standard way, and it is highly implausible that any sane override of the default
    `compose()` method could exist.'
  prefs: []
  type: TYPE_NORMAL
- en: This is, of course, also true for the function types present in `java.util.function`,
    and it shows that within the limited domain provided, default methods can indeed
    be treated as a form of stateless trait.
  prefs: []
  type: TYPE_NORMAL
- en: OOD Using Lambdas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Consider this simple lambda expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The type of the *lvalue* (lefthand side of the assignment) is `Runnable`, which
    is an interface type. For this statement to make sense, the *rvalue* (right-hand
    side of the assignment) must contain an instance of some class type (because interfaces
    cannot be instantiated) that implements `Runnable`. The minimal implementation
    that satisfies these constraints is a class type (of inconsequential name) that
    directly extends `Object` and implements `Runnable`.
  prefs: []
  type: TYPE_NORMAL
- en: Recall that the intention of lambda expressions is to allow Java programmers
    to express a concept that is as close as possible to the anonymous or inline methods
    seen in other languages.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, given that Java is a statically typed language, this leads directly
    to the design of lambdas as implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Lambdas are a shorthand for the construction of a new instance of a class type
    that is essentially `Object` enhanced by a single method.
  prefs: []
  type: TYPE_NORMAL
- en: A lambda’s single extra method has a signature provided by the interface type,
    and the compiler will check that the `rvalue` is consistent with this type signature.
  prefs: []
  type: TYPE_NORMAL
- en: Lambdas Versus Nested Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The addition of lambdas to the language in Java 8 was relatively late, as compared
    to other programming languages. As a consequence, the Java community had established
    patterns to work around the absence of lambdas. This manifests in a heavy use
    of very simple nested (aka inner) classes to fill the niche that lambdas usually
    occupy.
  prefs: []
  type: TYPE_NORMAL
- en: In modern Java projects developed from scratch, developers will typically use
    lambdas wherever possible. We also strongly suggest that, when refactoring old
    code, you take some time to convert inner classes to lambdas wherever possible.
    Some IDEs even provide an automatic conversion facility.
  prefs: []
  type: TYPE_NORMAL
- en: However, this still leaves the design question of when to use lambdas and when
    nested classes are still the correct solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some cases are obvious; for example, when extending a default implementation
    for some functionality, a nested class approach is appropriate, for two reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: The custom implementation may have to override multiple methods
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The base implementation is a class, not an interface
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Another major use case to consider is that of stateful lambdas. As there is
    nowhere to declare any fields, it would appear at first glance that lambdas cannot
    directly be used for anything that involves state—the syntax only gives the opportunity
    to declare a method body.
  prefs: []
  type: TYPE_NORMAL
- en: However, a lambda can refer to a variable defined in the scope that the lambda
    is created in, so we can create a closure, as discussed in [Chapter 4](ch04.xhtml#javanut8-CHP-4),
    to fill the role of a stateful lambda.
  prefs: []
  type: TYPE_NORMAL
- en: Lambdas Versus Method References
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The question of when to use a lambda and when to use a method reference is largely
    a matter of personal taste and style. There are, of course, some circumstances
    where it is essential to create a lambda. However, in many simple cases, a lambda
    can be replaced by a method reference.
  prefs: []
  type: TYPE_NORMAL
- en: One possible approach is to consider whether the lambda notation adds anything
    to the readability of the code. For example, in the streams API, there is a potential
    benefit in using the lambda form, as it uses the `->` operator. This provides
    a form of visual metaphor—the stream API is a lazy abstraction that can be visualized
    as data items “flowing through a functional pipeline.”
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let’s consider a `Person` object, which has standard characteristics,
    such as name, age, etc. We can compute the average using a pipeline, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The idea that the `mapToDouble()` method has an aspect of motion, or transformation,
    is strongly implied by the usage of an explicit lambda. For less experienced programmers,
    it also draws attention to the use of a functional API.
  prefs: []
  type: TYPE_NORMAL
- en: 'For other use cases (e.g., *dispatch tables*), method references may well be
    more appropriate. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In situations where either notation could be used, you will come to develop
    a preference that fits your individual style over time. The key consideration
    is whether, when returning to reread code written several months (or years) ago,
    the choice of notation still makes sense and the code is easy to read.
  prefs: []
  type: TYPE_NORMAL
- en: OOD Using Sealed Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We met sealed classes for the first time in [Chapter 3](ch03.xhtml#javanut8-CHP-3)
    and introduced sealed interfaces in [Chapter 4](ch04.xhtml#javanut8-CHP-4). As
    well as the cases we’ve already met, there is also a simpler possibility, in which
    a sealed type can be extended only by classes that are defined inside the same
    compilation unit (i.e., Java source file), like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The classes `Shape.Circle` and `Shape.Rectangle` are the only permitted subclasses
    of `Shape`: any other attempt to extend `Shape` will result in a compilation error.
    This is really just additional detail, as the general concept remains the same;
    `sealed` indicates a type that has only a finite number of possible types that
    are compatible with it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is an interesting duality here:'
  prefs: []
  type: TYPE_NORMAL
- en: Enums are classes that have only a finite number of instances—any enum object
    is one of those instances
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sealed types have only a finite number of compatible classes—any sealed object
    belongs to one of those classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now consider a switch expression that accepts an enum, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: All the possible enum constants for seasons are present in this switch expression,
    and so the match is said to be *total*. In this case, it is not necessary to include
    a `default`, as the compiler can use the *exhaustiveness* of the enum constants
    to infer that the default case would never be activated.
  prefs: []
  type: TYPE_NORMAL
- en: 'It isn’t hard to see that we could do something similar with sealed types.
    Some code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: is obviously exhaustive to a human but is not currently (as of Java 17) directly
    recognized by the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: This is because, as of Java 17, sealed types are essentially an incomplete feature.
    In a future version of Java, the intent is to extend the switch expressions feature
    and combine it with the new form of `instanceof` (and other new language features)
    to deliver a capability called *pattern matching*.
  prefs: []
  type: TYPE_NORMAL
- en: This new feature will enable developers to write code that, for example, “switches
    over a variable’s type,” and this will unlock new design patterns inspired by
    functional programming, which have not been easy to achieve in Java.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '[Appendix](app01.xhtml#javanut8-APP-A) has more information about pattern matching
    and other future features.'
  prefs: []
  type: TYPE_NORMAL
- en: Despite not being entirely complete as of Java 17, sealed types are still very
    useful in their current form and can also be combined with records to produce
    some compelling designs.
  prefs: []
  type: TYPE_NORMAL
- en: OOD Using Records
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Records were introduced in [Chapter 3](ch03.xhtml#javanut8-CHP-3), and in their
    simplest form they represent a data entity that is “just fields” or a “bag of
    data.” In some other programming languages, this is represented by a *tuple*,
    but Java’s records are different from tuples in two important ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Java records are named types, whereas tuples are anonymous
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Java records can have methods, auxiliary constructors and almost everything
    a class can
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Both of these stem from the fact that records are a special type of class. This
    allows the programmer to start their design by using a record as a basic collection
    of fields, and then to evolve from there.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let’s rewrite [Example 5-1](#javanut8-CHP-5-EX-1) as a record
    (eliding the `Comparable` interface for simplicity):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note that we have introduced a new type of constructor, called a *compact constructor*.
    It is available only for records and is used in the case where we want to do a
    bit of extra work in the constructor as well as initialize the fields. Compact
    constructors don’t have (or need) a parameter list, as they always have the same
    parameter list as the declaration of the record.
  prefs: []
  type: TYPE_NORMAL
- en: This code is much shorter than [Example 5-1](#javanut8-CHP-5-EX-1) and clearly
    distinguishes the case of the primary constructor (the “true form”) of the record
    from the copy constructor and any other factories that may be present.
  prefs: []
  type: TYPE_NORMAL
- en: The design of Java’s records means that they are a very flexible choice for
    the programmer. An entity can be initially modeled as just fields, and over time,
    can acquire more methods, implement interfaces, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'One other important aspect is that records also can be used very effectively
    in combination with sealed interfaces. Let’s take a look at an example: a delivery
    company that has different types of orders: basic orders (delivered free), and
    express orders (arrive quicker but for an additional charge).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic interface for the orders looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'and has two implementations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember that the supertype of all record types is `java.lang.Record`, so for
    this type of use case we have to use interfaces; it would not be possible to have
    the different order types extend an abstract base. Our choices are:'
  prefs: []
  type: TYPE_NORMAL
- en: Model the entities as classes and use a `sealed abstract` base class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Model the entities as records and use a sealed interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the second case, any common record components need to be hoisted up into
    the interface, just as we saw for the `Order` example.
  prefs: []
  type: TYPE_NORMAL
- en: Instance Methods or Class Methods?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Instance methods are one of the key features of object-oriented programming.
    That doesn’t mean, however, that you should shun class methods. In many cases,
    it is perfectly reasonable to define class methods.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Remember that in Java, class methods are declared with the `static` keyword,
    and the terms *static method* and *class method* are used interchangeably.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, when working with the `Circle` class you might find that you often
    want to compute the area of a circle with a given radius but don’t want to bother
    creating a `Circle` object to represent that circle. In this case, a class method
    is more convenient:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: It is perfectly legal for a class to define more than one method with the same
    name, as long as the methods have different parameter lists. This version of the
    `area()` method is a class method, so it does not have an implicit `this` parameter
    and must have a parameter that specifies the radius of the circle. This parameter
    keeps it distinct from the instance method of the same name.
  prefs: []
  type: TYPE_NORMAL
- en: 'As another example of the choice between instance methods and class methods,
    consider defining a method named `bigger()` that examines two `Circle` objects
    and returns whichever has the larger radius. We can write `bigger()` as an instance
    method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also implement `bigger()` as a class method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Given two `Circle` objects, `x` and `y`, we can use either the instance method
    or the class method to determine which is bigger. The invocation syntax differs
    significantly for the two methods, however:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Both methods work well, and, from an object-oriented design standpoint, neither
    of these methods is “more correct” than the other. The instance method is more
    formally object-oriented, but its invocation syntax suffers from a kind of asymmetry.
    In a case like this, the choice between an instance method and a class method
    is simply a design decision. Depending on the circumstances, one or the other
    will likely be the more natural choice.
  prefs: []
  type: TYPE_NORMAL
- en: A word about System.out.println()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ve frequently encountered the method `System.out.println()`—it’s used to
    display output to the terminal window or console. We’ve never explained why this
    method has such a long, awkward name or what those two periods are doing in it.
    Now that you understand class and instance fields and class and instance methods,
    it is easier to understand what is going on: `System` is a class. It has a public
    class field named `out`. This field is an object of type `java.io.PrintStream`,
    and it has an instance method named `println()`.'
  prefs: []
  type: TYPE_NORMAL
- en: We can use static imports to make this a bit shorter with `import static java.lang.System.out;`—this
    will enable us to refer to the printing method as `out.println()` but as this
    is an instance method, we cannot shorten it further.
  prefs: []
  type: TYPE_NORMAL
- en: Composition Versus Inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Inheritance is not the only technique at our disposal in object-oriented design.
    Objects can contain references to other objects, so a larger conceptual unit can
    be aggregated out of smaller component parts; this is known as *composition*.
  prefs: []
  type: TYPE_NORMAL
- en: 'An important related technique is *delegation*, where an object of a particular
    type holds a reference to a secondary object of a compatible type and forwards
    all operations to the secondary object. This is frequently done using interface
    types, as shown in this example where we model the employment structure of software
    companies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `Manager` class is said to *delegate* the `work()` operation to their direct
    report, and no actual work is performed by the `Manager` object. Variations of
    this pattern involve some work being done in the delegating class, with only some
    calls being forwarded to the delegate object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another useful, related technique is called the *decorator pattern*. This provides
    the capability to extend objects with new functionality, including at runtime.
    The slight overhead is some extra work needed at design time. Let’s look at an
    example of the decorator pattern as applied to modeling burritos for sale at a
    taqueria. To keep things simple, we’ve modeled only a single aspect to be decorated—the
    price of the burrito:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'These cover the basic burritos that can be offered—two different sizes, at
    different prices. Let’s enhance this by adding some optional extras—jalapeño chilies
    and guacamole. The key design point here is to use an abstract base class that
    all of the optional decorating components will subclass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Combining an `abstract` base, `BurritoOptionalExtra`, with a `protected` constructor
    means that the only valid way to get a `BurritoOptionalExtra` is to construct
    an instance of one of the subclasses, as they have public constructors. This approach
    also hides the setup of the price of the component from client code.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Decorators can, of course, also be combined with sealed types to allow only
    a known, finite list of possible decorators.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s test the implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The decorator pattern is very widely used, not least in the JDK utility classes.
    When we discuss Java I/O in [Chapter 10](ch10.xhtml#javanut8-CHP-10), we will
    see more examples of decorators in the wild.
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions and Exception Handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We met checked and unchecked exceptions in [“Checked and Unchecked Exceptions”](ch02.xhtml#javanut8-CHP-2-SECT-6.3).
    In this section, we discuss some additional aspects of the design of exceptions
    and how to use them in your own code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall that an exception in Java is an object. The type of this object is `java.lang.Throwable`,
    or more commonly, some subclass of `Throwable` that more specifically describes
    the type of exception that occurred. `Throwable` has two standard subclasses:
    `java.lang.Error` and `java.lang.Exception`. Exceptions that are subclasses of
    `Error` generally indicate unrecoverable problems: the virtual machine has run
    out of memory, or a class file is corrupted and cannot be read, for example. Exceptions
    of this sort can be caught and handled, but it is rare to do so—these are the
    unchecked exceptions previously mentioned.'
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions that are subclasses of `Exception`, on the other hand, indicate less
    severe conditions. These exceptions can be reasonably caught and handled. They
    include such exceptions as `java.io.EOFException`, which signals the end of a
    file, and `java.lang.ArrayIndexOutOfBoundsException`, which indicates that a program
    has tried to read past the end of an array. These are the checked exceptions from
    [Chapter 2](ch02.xhtml#javanut8-CHP-2) (except for subclasses of `RuntimeException`,
    which are also a form of unchecked exception). In this book, we use the term “exception”
    to refer to any exception object, regardless of whether the type of that exception
    is `Exception` or `Error`.
  prefs: []
  type: TYPE_NORMAL
- en: Because an exception is an object, it can contain data, and its class can define
    methods that operate on that data. The `Throwable` class and all its subclasses
    include a `String` field that stores a human-readable error message that describes
    the exceptional condition. It’s set when the exception object is created and can
    be read from the exception with the `getMessage()` method. Most exceptions contain
    only this single message, but a few add other data. The `java.io.InterruptedIOException`,
    for example, adds a field named `bytesTransferred` that specifies how much input
    or output was completed before the exceptional condition interrupted it.
  prefs: []
  type: TYPE_NORMAL
- en: When designing your own exceptions, you should consider what other additional
    modeling information is relevant to the exception object. This is usually situation-specific
    information about the aborted operation, and the exceptional circumstance that
    was encountered (as we saw with `java.io.InterruptedIOException`).
  prefs: []
  type: TYPE_NORMAL
- en: There are some trade-offs in the use of exceptions in application design. Using
    checked exceptions means that the compiler can enforce the handling (or propagation
    up the call stack) of known conditions that have the potential of recovery or
    retry. It also means that it’s more difficult to forget to actually handle errors—thus
    reducing the risk that a forgotten error condition causes a system to fail in
    production.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, some applications will not be able to recover from certain
    conditions, even conditions that are theoretically modeled by checked exceptions.
    For example, if an application requires a config file to be placed at a specific
    place in the filesystem and can’t locate it at startup, it may have no option
    but to print an error message and exit—despite the fact that `java.io.FileNotFoundException`
    is a checked exception. Forcing exceptions that cannot be recovered from to be
    either handled or propagated is, in these circumstances, bordering on perverse;
    in this situation, printing the error and exiting is the only really sensible
    action.
  prefs: []
  type: TYPE_NORMAL
- en: 'When designing exception schemes, here are some good practices you should follow:'
  prefs: []
  type: TYPE_NORMAL
- en: Consider what additional state needs to be placed on the exception—remember
    that it’s also an object like any other.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Exception` has four public constructors—under normal circumstances, custom
    exception classes should implement all of them—to initialize the additional state
    or to customize messages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don’t create many fine-grained custom exception classes in your APIs—the Java
    I/O and reflection APIs both suffer from this, and it needlessly complicates working
    with those packages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don’t overburden a single exception type with describing too many conditions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Never create an exception until you’re sure you need to throw it. Exception
    creation can be a costly operation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, two exception-handling antipatterns you should avoid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The former just ignores a condition that almost certainly required some action
    (even if just a notification in a log). This increases the likelihood of failure
    elsewhere in the system—potentially far from the original, real source.
  prefs: []
  type: TYPE_NORMAL
- en: The second just creates noise. We’re logging a message but not actually doing
    anything about the issue; we still require some other code higher up in the system
    to actually deal with the problem.
  prefs: []
  type: TYPE_NORMAL
- en: Safe Java Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Programming languages are sometimes described as being *type safe*; however,
    this term is used rather loosely by working programmers. There are a number of
    different viewpoints on and definitions for type safety, not all of which are
    mutually compatible. The most useful view for our purposes is that *type safety*
    is the property of a programming language that prevents the type of data being
    incorrectly identified at runtime. This should be thought of as a sliding scale—it
    is more helpful to think of languages as being more (or less) type safe than each
    other, rather than a simple binary property of safe/unsafe.
  prefs: []
  type: TYPE_NORMAL
- en: In Java, the static nature of the type system helps prevent a large class of
    possible errors by producing compilation errors if, for example, the programmer
    attempts to assign an incompatible value to a variable. However, Java is not perfectly
    type safe, as we can perform a cast between any two reference types—this will
    fail at runtime with a `ClassCastException` if the value is not compatible.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we prefer to think of safety as inseparable from the broader topic
    of correctness. This means that we should think in terms of programs, rather than
    languages. This emphasizes the point that safe code is not guaranteed by any widely
    used language, and instead considerable programmer effort (and adherence to rigorous
    coding discipline) must be employed if the end result is to be truly safe and
    correct.
  prefs: []
  type: TYPE_NORMAL
- en: 'We approach our view of safe programs by working with the state model abstraction
    as shown in [Figure 5-1](#javanut8-CHP-5-FIG-1). A *safe* program is one in which:'
  prefs: []
  type: TYPE_NORMAL
- en: All objects start off in a legal state after creation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Externally accessible methods transition objects between legal states
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Externally accessible methods must not return with objects in an inconsistent
    state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Externally accessible methods must reset objects to a legal state before throwing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this context, “externally accessible” means `public`, package-private, or
    `protected`. This defines a reasonable model for safety of programs, and as it
    is bound up with defining our abstract types in such a way that their methods
    ensure consistency of state, it’s reasonable to refer to a program satisfying
    these requirements as a “safe program,” regardless of the language in which such
    a program is implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Private methods do not have to start or end with objects in a legal state, as
    they cannot be called by an external piece of code.
  prefs: []
  type: TYPE_NORMAL
- en: As you might imagine, actually engineering a substantial piece of code so that
    we can be sure that the state model and methods respect these properties can be
    quite an undertaking. In languages such as Java, in which programmers have direct
    control over the creation of preemptively multitasked execution threads, this
    problem is a great deal more complex.
  prefs: []
  type: TYPE_NORMAL
- en: '![JN7 0501](assets/jns8_0501.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-1\. Program state transitions
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Moving on from our introduction of object-oriented design, one final aspect
    of the Java language and platform needs to be understood for a sound grounding.
    That is the nature of memory and concurrency—one of the most complex of the platform,
    but also one that rewards careful study with large dividends. It is the subject
    of our next chapter and concludes [Part I](part01.xhtml#javanut-PART-1).
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch05.xhtml#idm45927734963040-marker)) Technically, this should probably
    be called `SCREAMING_SNAKE_CASE`
  prefs: []
  type: TYPE_NORMAL
