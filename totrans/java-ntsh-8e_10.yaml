- en: Chapter 8\. Working with Java Collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduces Java’s interpretation of fundamental data structures,
    known as the Java Collections. These abstractions are core to many (if not most)
    programming types and form an essential part of any programmer’s basic toolkit.
    Accordingly, this is one of the most important chapters of the entire book and
    provides a toolkit that is essential to virtually all Java programmers.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will introduce the fundamental interfaces and the type hierarchy,
    show how to use them, and discuss aspects of their overall design. Both the “classic”
    approach to handling the collections and the newer approach (using the Streams
    API and the lambda expressions functionality introduced in Java 8) will be covered.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Collections API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Java Collections are a set of generic interfaces that describe the most
    common forms of data structure. Java ships with several implementations of each
    of the classic data structures, and because the types are represented as interfaces,
    it is very possible for development teams to develop their own, specialized implementations
    of the interfaces for use in their own projects.
  prefs: []
  type: TYPE_NORMAL
- en: The Java Collections define two fundamental types of data structures. A `Collection`
    is a grouping of objects, while a `Map` is a set of mappings, or associations,
    between objects. The basic layout of the Java Collections is shown in [Figure 8-1](#javanut8-CHP-8-FIG-1).
  prefs: []
  type: TYPE_NORMAL
- en: Within this basic description, a `Set` is a type of `Collection` with no duplicates,
    and a `List` is a `Collection` in which the elements are ordered (but may contain
    duplicates).
  prefs: []
  type: TYPE_NORMAL
- en: '![JN7 0801](assets/jns8_0801.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-1\. Collections classes and inheritance
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`SortedSet` and `SortedMap` are specialized sets and maps that maintain their
    elements in a sorted order.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Collection`, `Set`, `List`, `Map`, `SortedSet`, and `SortedMap` are all interfaces,
    but the `java.util` package also defines various concrete implementations, such
    as lists based on arrays and linked lists, and maps and sets based on hash tables
    or binary trees. Other important interfaces are `Iterator` and `Iterable`, which
    allow you to loop through the objects in a collection, as we will see later on.'
  prefs: []
  type: TYPE_NORMAL
- en: The Collection Interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Collection<E>` is a parameterized interface that represents a generalized
    grouping of objects of type `E`. We can create a collection of any kind of reference
    type.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: To work properly with the expectations of collections, you must take care when
    defining `hashCode()` and `equals()` methods on your classes, as discussed in
    [Chapter 5](ch05.xhtml#javanut8-CHP-5).
  prefs: []
  type: TYPE_NORMAL
- en: Methods are defined for adding and removing objects from the group, testing
    an object for membership in the group, and iterating through all elements in the
    group. Additional methods return the elements of the group as an array and return
    the size of the collection.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The grouping within a `Collection` may or may not allow duplicate elements and
    may or may not impose an ordering on the elements.
  prefs: []
  type: TYPE_NORMAL
- en: The Java Collections Framework provides `Collection` because it defines the
    features shared by all common forms of data structure. The JDK ships `Set`, `List`,
    and `Queue` as subinterfaces of `Collection`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code illustrates the operations you can perform on `Collection`
    objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Remember that you can use any of the methods shown here with any `Set`, `List`,
    or `Queue`. These subinterfaces may impose membership restrictions or ordering
    constraints on the elements of the collection but still provide the same basic
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Methods such as `addAll()`, `retainAll()`, `clear()`, and `remove()` that alter
    the collection were conceived of as optional parts of the API. Unfortunately,
    they were specified a long time ago, when the received wisdom was to indicate
    the absence of an optional method by throwing `UnsupportedOperationException`.
    Accordingly, some implementations (notably read-only forms) may throw this unchecked
    exception.
  prefs: []
  type: TYPE_NORMAL
- en: '`Collection`, `Map`, and their subinterfaces do *not* extend the interfaces
    `Cloneable` or `Serializable`. All of the collection and map implementation classes
    provided in the Java Collections Framework, however, do implement these interfaces.'
  prefs: []
  type: TYPE_NORMAL
- en: Some collection implementations place restrictions on the elements that they
    can contain. An implementation might prohibit `null` as an element, for example.
    And `EnumSet` restricts membership to the values of a specified enumerated type.
  prefs: []
  type: TYPE_NORMAL
- en: Attempting to add a prohibited element to a collection always throws an unchecked
    exception such as `NullPointerException` or `ClassCastException`. Checking whether
    a collection contains a prohibited element may also throw such an exception, or
    it may simply return `false`.
  prefs: []
  type: TYPE_NORMAL
- en: The Set Interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A *set* is a collection of objects that does not allow duplicates: it may not
    contain two references to the same object, two references to `null`, or references
    to two objects `a` and `b` such that `a.equals(b)`. Most general-purpose `Set`
    implementations impose no ordering on the elements of the set, but ordered sets
    are not prohibited (see `SortedSet` and `LinkedHashSet`). Sets are further distinguished
    from ordered collections like lists by the general expectation that they have
    an efficient `contains` method that runs in constant or logarithmic time.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Set` defines no methods of its own beyond those defined by `Collection` but
    places additional restrictions on some methods. The `add()` and `addAll()` methods
    of a `Set` are required to enforce the no-duplicates rules: they may not add an
    element to the `Set` if the set already contains that element. Recall that the
    `add()` and `addAll()` methods defined by the `Collection` interface return `true`
    if the call resulted in a change to the collection and `false` if it did not.
    This return value is relevant for `Set` objects because the no-duplicates restriction
    means that adding an element does not always result in a change to the set.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 8-1](#javanut8-CHP-8-TABLE-2) lists the implementations of the `Set`
    interface and summarizes their internal representation, ordering characteristics,
    member restrictions, and the performance of the basic `add()`, `remove()`, and
    `contains` operations as well as iteration performance. Note that `CopyOnWriteArraySet`
    is in the `java.util.concurrent` package; all the other implementations are part
    of `java.util`. Also note that `java.util.BitSet` is not a `Set` implementation.
    This legacy class is useful as a compact and efficient list of `boolean` values
    but is not part of the Java Collections Framework.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 8-1\. Set implementations
  prefs: []
  type: TYPE_NORMAL
- en: '| Class | Internal representation | Since | Element order | Member restrictions
    | Basic operations | Iteration performance | Notes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `HashSet` | Hashtable | 1.2 | None | None | O(1) | O(capacity) | Best general-purpose
    implementation |'
  prefs: []
  type: TYPE_TB
- en: '| `LinkedHashSet` | Linked hashtable | 1.2 | Insertion order | None | O(1)
    | O(n) | Preserves insertion order |'
  prefs: []
  type: TYPE_TB
- en: '| `EnumSet` | Bit fields | 5.0 | Enum declaration | Enum values | O(1) | O(n)
    | Holds non-`null` enum values only |'
  prefs: []
  type: TYPE_TB
- en: '| `TreeSet` | Red-black tree | 1.2 | Sorted ascending | Comparable | O(log(n))
    | O(n) | `Comparable` elements or `Comparator` |'
  prefs: []
  type: TYPE_TB
- en: '| `CopyOnWriteArraySet` | Array | 5.0 | Insertion order | None | O(n) | O(n)
    | Threadsafe without synchronized methods |'
  prefs: []
  type: TYPE_TB
- en: The `TreeSet` implementation uses a red-black tree data structure to maintain
    a set that is iterated in ascending order according to the natural ordering of
    `Comparable` objects or according to an ordering specified by a `Comparator` object.
    `TreeSet` actually implements the `SortedSet` interface, which is a subinterface
    of `Set`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `SortedSet` interface offers several interesting methods that take advantage
    of its sorted nature. The following code illustrates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The addition of `\0` characters is needed because the `tailSet()` and related
    methods use the *successor* of an element, which for strings is the string value
    with a `NULL` character (ASCII code 0) appended.
  prefs: []
  type: TYPE_NORMAL
- en: 'From Java 9 onward, the API has also been upgraded with a helper static method
    on the `Set` interface, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This API has several overloads that each take a fixed number of arguments, and
    also a varargs overload. The latter is used for the case where arbitrarily many
    elements are wanted in the set and falls back to the standard varargs mechanism
    (marshaling the elements into an array before the call). It’s worth noting as
    well that the set returned by `Set.of` is immutable and will throw an `UnsupportedOperationException`
    on further attempts to add or remove from it after instantiation.
  prefs: []
  type: TYPE_NORMAL
- en: The List Interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `List` is an ordered collection of objects. Each element of a list has a position
    in the list, and the `List` interface defines methods to query or set the element
    at a particular position, or *index*. In this respect, a `List` is like an array
    whose size changes as needed to accommodate the number of elements it contains.
    Unlike sets, lists allow duplicate elements.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to its index-based `get()` and `set()` methods, the `List` interface
    defines methods to add or remove an element at a particular index and also defines
    methods to return the index of the first or last occurrence of a particular value
    in the list. The `add()` and `remove()` methods inherited from `Collection` are
    defined to append to the list and to remove the first occurrence of the specified
    value from the list. The inherited `addAll()` appends all elements in the specified
    collection to the end of the list, and another version inserts the elements at
    a specified index. The `retainAll()` and `removeAll()` methods behave as they
    do for any `Collection`, retaining or removing multiple occurrences of the same
    value, if needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `List` interface doesn’t define methods that operate on a range of list
    indexes. Instead, it defines a single `subList()` method that returns a `List`
    object that represents just the specified range of the original list. The sublist
    is backed by the parent list, and any changes made to the sublist are immediately
    visible in the parent list. Examples of `subList()` and the other basic `List`
    manipulation methods follow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Foreach loops and iteration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One very important way of working with collections is to process each element
    in turn, an approach known as *iteration*. This is an older way of looking at
    data structures, but it is still very useful (especially for small collections
    of data) and is easy to understand. This approach fits naturally with the `for`
    loop, as shown in this bit of code, and is easiest to illustrate using a `List`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The sense of the code should be clear—it takes the elements of `c` one at a
    time and uses them as a variable in the loop body. More formally, it iterates
    through the elements of an array or collection (or any object that implements
    `java.lang.Iterable`). On each iteration it assigns an element of the array or
    `Iterable` object to the loop variable you declare and then executes the loop
    body, which typically uses the loop variable to operate on the element. No loop
    counter or `Iterator` object is involved; the loop performs the iteration automatically,
    and you need not concern yourself with correct initialization or termination of
    the loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'This type of `for` loop is often referred to as a *foreach loop*. Let’s see
    how it works. The following bit of code shows a rewritten (and equivalent) `for`
    loop, with the method calls explicitly shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Iterator` object, `i`, is produced from the collection and used to step
    through the collection one item at a time. It can also be used with `while` loops:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some more things you should know about the syntax of the foreach loop:'
  prefs: []
  type: TYPE_NORMAL
- en: As noted earlier, *`expression`* must be either an array or an object that implements
    the `java.lang.Iterable` interface. This type must be known at compile time so
    that the compiler can generate appropriate looping code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The type of the array or `Iterable` elements must be assignment-compatible with
    the type of the variable declared in the *`declaration`*. If you use an `Iterable`
    object that is not parameterized with an element type, the variable must be declared
    as an `Object`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *`declaration`* usually consists of just a type and a variable name, but
    it may include a `final` modifier and any appropriate annotations (see [Chapter 4](ch04.xhtml#javanut8-CHP-4)).
    Using `final` prevents the loop variable from taking on any value other than the
    array or collection element the loop assigns it and serves to emphasize that the
    array or collection cannot be altered through the loop variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The loop variable of the foreach loop must be declared as part of the loop,
    with both a type and a variable name. You cannot use a variable declared outside
    the loop as you can with the `for` loop.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To understand in detail how the foreach loop works with collections, we need
    to consider two interfaces, `java.util.Iterator` and `java.lang.Iterable`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`Iterator` defines a way to iterate through the elements of a collection or
    other data structure. It works like this: while there are more elements in the
    collection (`hasNext()` returns `true`), call `next` to obtain the next element
    of the collection. Ordered collections, such as lists, typically have iterators
    that guarantee they’ll return elements in order. Unordered collections like `Set`
    simply guarantee that repeated calls to `next()` return all elements of the set
    without omissions or duplications, but they do not specify an ordering.'
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `next()` method of `Iterator` performs two functions—it advances through
    the collection and also returns the element of the collection that we have just
    moved past. This combination of operations can cause problems when you are programming
    in a functional or immutable style, as it mutates the underlying collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Iterable` interface was introduced to make the foreach loop work. A class
    implements this interface to advertise that it is able to provide an `Iterator`
    to anyone interested:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If an object is `Iterable<E>`, that means that it has an `iterator()` method
    that returns an `Iterator<E>`, which has a `next()` method that returns an object
    of type `E`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you use the foreach loop with an `Iterable<E>`, the loop variable must be
    of type `E` or a superclass or interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to iterate through the elements of a `List<String>`, the variable
    must be declared `String` or its superclass `Object`, or one of the interfaces
    it implements: `CharSequence`, `Comparable`, or `Serializable`.'
  prefs: []
  type: TYPE_NORMAL
- en: A common pitfall with iterators regards modification. If the collection is modified
    while iteration is in process, it may throw an error of the type `ConcurrentModificationException`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Avoiding this exception requires rethinking your algorithm so it doesn’t modify
    the collection. This can often be accomplished by working against a local copy
    instead of the original collection. The newer `Stream` APIs for collections also
    provide a lot of useful helpers for these situations.
  prefs: []
  type: TYPE_NORMAL
- en: Random access to Lists
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A general expectation of `List` implementations is that they can be efficiently
    iterated, typically in time proportional to the size of the list. Lists do not
    all provide efficient random access to the elements at any index, however. Sequential-access
    lists, such as the `LinkedList` class, provide efficient insertion and deletion
    operations at the expense of random-access performance. Implementations that provide
    efficient random access implement the `RandomAccess` marker interface, and you
    can test for this interface with `instanceof` if you need to ensure efficient
    list manipulations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `Iterator` returned by the `iterator()` method of a `List` iterates the
    list elements in the order they occur in the list. `List` implements `Iterable`,
    and lists can be iterated with a foreach loop just as any other collection can.
  prefs: []
  type: TYPE_NORMAL
- en: 'To iterate just a portion of a list, you can use the `subList()` method to
    create a sublist view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[Table 8-2](#javanut8-CHP-8-TABLE-3) summarizes the five general-purpose `List`
    implementations in the Java platform. `Vector` and `Stack` are legacy implementations
    and should not be used. `CopyOnWriteArrayList` is part of the `java.util.concurrent`
    package and is only really suitable for multithreaded use cases.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 8-2\. List implementations
  prefs: []
  type: TYPE_NORMAL
- en: '| Class | Representation | Since | Random access | Notes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `ArrayList` | Array | 1.2 | Yes | Best all-around implementation |'
  prefs: []
  type: TYPE_TB
- en: '| `LinkedList` | Double-linked list | 1.2 | No | More efficient insertion and
    deletion in middle of list |'
  prefs: []
  type: TYPE_TB
- en: '| `CopyOnWriteArrayList` | Array | 5.0 | Yes | Threadsafe; fast traversal,
    slow modification |'
  prefs: []
  type: TYPE_TB
- en: '| `Vector` | Array | 1.0 | Yes | Legacy class; synchronized methods. Do not
    use. |'
  prefs: []
  type: TYPE_TB
- en: '| `Stack` | Array | 1.0 | Yes | Extends `Vector`; adds `push()`, `pop()`, `peek()`.
    Legacy; use `Deque` instead. |'
  prefs: []
  type: TYPE_TB
- en: The Map Interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *map* is a set of *key* objects and a mapping from each member of that set
    to a *value* object. The `Map` interface defines an API for defining and querying
    mappings. `Map` is part of the Java Collections Framework, but it does not extend
    the `Collection` interface, so a `Map` is a little-c collection, not a big-C `Collection`.
    `Map` is a parameterized type with two type variables, `Map<K, V>`. Type variable
    `K` represents the type of keys held by the map, and type variable `V` represents
    the type of the values that the keys are mapped to. A mapping from `String` keys
    to `Integer` values, for example, can be represented with a `Map<String,Integer>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most important `Map` methods are `put()`, which defines a key/value pair
    in the map; `get()`, which queries the value associated with a specified key;
    and `remove()`, which removes the specified key and its associated value from
    the map. The general performance expectation for `Map` implementations is that
    these three basic methods are quite efficient: they should run in constant time
    and certainly no worse than in logarithmic time.'
  prefs: []
  type: TYPE_NORMAL
- en: 'An important feature of `Map` is its support for “collection views.” These
    can be summarized as:'
  prefs: []
  type: TYPE_NORMAL
- en: A `Map` is not a `Collection`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The keys of a `Map` can be viewed as a `Set`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The values can be viewed as a `Collection`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The mappings can be viewed as a `Set` of `Map.Entry` objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`Map.Entry` is a nested interface defined within `Map`: it simply represents
    a single key/value pair.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following sample code shows the `get()`, `put()`, `remove()`, and other
    methods of a `Map` and demonstrates some common uses of the collection views of
    a `Map`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'With the arrival of Java 9, the `Map` interface also has been enhanced with
    factory methods for spinning up collections easily:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The situation is a little more complicated as compared to `Set` and `List`,
    as the `Map` type has both keys and values, and Java does not allow more than
    one varargs parameter in a method declaration. The solution is to have fixed argument
    size overloads, up to 10 entries and also to provide a new static method, `entry()`,
    that will construct an object to represent the key/value pair.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code can then be written to use the varargs form like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note that the method name has to be different from `of()` due to the difference
    in type of the arguments—this is now a varargs method in `Map.Entry`.
  prefs: []
  type: TYPE_NORMAL
- en: The `Map` interface includes a variety of general-purpose and special-purpose
    implementations, which are summarized in [Table 8-3](#javanut8-CHP-8-TABLE-4).
    As always, complete details are in the JDK’s documentation and javadoc. All classes
    in [Table 8-3](#javanut8-CHP-8-TABLE-4) are in the `java.util` package except
    `ConcurrentHashMap` and `ConcurrentSkipListMap`, which are part of `java.util.concurrent`.
  prefs: []
  type: TYPE_NORMAL
- en: Table 8-3\. Map implementations
  prefs: []
  type: TYPE_NORMAL
- en: '| Class | Representation | Since | Null keys | Null values | Notes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `HashMap` | Hashtable | 1.2 | Yes | Yes | General-purpose implementation
    |'
  prefs: []
  type: TYPE_TB
- en: '| `C⁠o⁠n⁠c⁠u⁠r⁠r⁠e⁠n⁠t​H⁠a⁠s⁠h⁠M⁠a⁠p` | Hashtable | 5.0 | No | No | General-purpose
    threadsafe implementation; see `ConcurrentMap` interface |'
  prefs: []
  type: TYPE_TB
- en: '| `ConcurrentSkipListMap` | Hashtable | 6.0 | No | No | Specialized threadsafe
    implementation; see `ConcurrentNavigableMap` interface |'
  prefs: []
  type: TYPE_TB
- en: '| `EnumMap` | Array | 5.0 | No | Yes | Keys are instances of an enum |'
  prefs: []
  type: TYPE_TB
- en: '| `LinkedHashMap` | Hashtable plus list | 1.4 | Yes | Yes | Preserves insertion
    or access order |'
  prefs: []
  type: TYPE_TB
- en: '| `TreeMap` | Red-black tree | 1.2 | No | Yes | Sorts by key value. Operations
    are O(log(n)). See `SortedMap` interface. |'
  prefs: []
  type: TYPE_TB
- en: '| `IdentityHashMap` | Hashtable | 1.4 | Yes | Yes | Compares with `==` instead
    of `equals()` |'
  prefs: []
  type: TYPE_TB
- en: '| `WeakHashMap` | Hashtable | 1.2 | Yes | Yes | Doesn’t prevent garbage collection
    of keys |'
  prefs: []
  type: TYPE_TB
- en: '| `Hashtable` | Hashtable | 1.0 | No | No | Legacy class; synchronized methods.
    Do not use. |'
  prefs: []
  type: TYPE_TB
- en: '| `Properties` | Hashtable | 1.0 | No | No | Extends `Hashtable` with `String`
    methods |'
  prefs: []
  type: TYPE_TB
- en: The `ConcurrentHashMap` and `ConcurrentSkipListMap` classes of the `java.util.concurrent`
    package implement the `ConcurrentMap` interface of the same package. `ConcurrentMap`
    extends `Map` and defines some additional atomic operations that are important
    in multithreaded programming. For example, the `putIfAbsent()` method is like
    `put()` but adds the key/value pair to the map only if the key is not already
    mapped.
  prefs: []
  type: TYPE_NORMAL
- en: '`TreeMap` implements the `SortedMap` interface, which extends `Map` to add
    methods that take advantage of the sorted nature of the map. `SortedMap` is quite
    similar to the `SortedSet` interface. The `firstKey()` and `lastKey()` methods
    return the first and last keys in the `keySet()`. And `headMap()`, `tailMap()`,
    and `subMap()` return a restricted range of the original map.'
  prefs: []
  type: TYPE_NORMAL
- en: The Queue and BlockingQueue Interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *queue* is an ordered collection of elements with methods for extracting elements,
    in order, from the *head* of the queue. Queue implementations are commonly based
    on insertion order as in first-in, first-out (FIFO) queues or last-in, first-out
    (LIFO) queues.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: LIFO queues are also known as stacks, and Java provides a `Stack` class, but
    its use is strongly discouraged—instead, use implementations of the `Deque` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other orderings are also possible: a *priority queue* orders its elements according
    to an external `Comparator` object or according to the natural ordering of `Comparable`
    elements. Unlike a `Set`, `Queue` implementations typically allow duplicate elements.
    Unlike `List`, the `Queue` interface does not define methods for manipulating
    queue elements at arbitrary positions. Only the element at the head of the queue
    is available for examination. It is common for `Queue` implementations to have
    a fixed capacity: when a queue is full, it is not possible to add more elements.
    Similarly, when a queue is empty, it is not possible to remove any more elements.
    Because full and empty conditions are a normal part of many queue-based algorithms,
    the `Queue` interface defines methods that signal these conditions with return
    values rather than by throwing exceptions. Specifically, the `peek()` and `poll()`
    methods return `null` to indicate that the queue is empty. For this reason, most
    `Queue` implementations do not allow `null` elements.'
  prefs: []
  type: TYPE_NORMAL
- en: A *blocking queue* is a type of queue that defines blocking `put()` and `take()`
    methods. The `put()` method adds an element to the queue, waiting, if necessary,
    until there is space in the queue for the element. And the `take()` method removes
    an element from the head of the queue, waiting, if necessary, until there is an
    element to remove. Blocking queues are an important part of many multithreaded
    algorithms, and the `BlockingQueue` interface (which extends `Queue`) is defined
    as part of the `java.util.concurrent` package.
  prefs: []
  type: TYPE_NORMAL
- en: Queues are not nearly as commonly used as sets, lists, and maps, except perhaps
    in certain multithreaded programming styles. In lieu of example code here, we’ll
    try to clarify the different possible queue insertion and removal operations.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Elements to Queues
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`add()`'
  prefs: []
  type: TYPE_NORMAL
- en: This `Collection` method simply adds an element in the normal way. In bounded
    queues, this method may throw an exception if the queue is full.
  prefs: []
  type: TYPE_NORMAL
- en: '`offer()`'
  prefs: []
  type: TYPE_NORMAL
- en: This `Queue` method is like `add()` but returns `false` instead of throwing
    an exception if the element cannot be added because a bounded queue is full.
  prefs: []
  type: TYPE_NORMAL
- en: '`BlockingQueue` defines a timeout version of `offer()` that waits up to a specified
    amount of time for space to become available in a full queue. Like the basic version
    of the method, it returns `true` if the element was inserted and `false` otherwise.'
  prefs: []
  type: TYPE_NORMAL
- en: '`put()`'
  prefs: []
  type: TYPE_NORMAL
- en: 'This `BlockingQueue` method blocks: if the element cannot be inserted because
    the queue is full, `put()` waits until some other thread removes an element from
    the queue and space becomes available for the new element.'
  prefs: []
  type: TYPE_NORMAL
- en: Removing Elements from Queues
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`remove()`'
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the `Collection.remove()` method, which removes a specified element
    from the queue, the `Queue` interface defines a no-argument version of `remove()`
    that removes and returns the element at the head of the queue. If the queue is
    empty, this method throws a `NoSuchElementException`.
  prefs: []
  type: TYPE_NORMAL
- en: '`poll()`'
  prefs: []
  type: TYPE_NORMAL
- en: This `Queue` method removes and returns the element at the head of the queue,
    like `remove()` does, but returns `null` if the queue is empty instead of throwing
    an exception.
  prefs: []
  type: TYPE_NORMAL
- en: '`BlockingQueue` defines a timeout version of `poll()` that waits up to a specified
    amount of time for an element to be added to an empty queue.'
  prefs: []
  type: TYPE_NORMAL
- en: '`take()`'
  prefs: []
  type: TYPE_NORMAL
- en: This `BlockingQueue` method removes and returns the element at the head of the
    queue. If the queue is empty, it blocks until some other thread adds an element
    to the queue.
  prefs: []
  type: TYPE_NORMAL
- en: '`drainTo()`'
  prefs: []
  type: TYPE_NORMAL
- en: This `BlockingQueue` method removes all available elements from the queue and
    adds them to a specified `Collection`. It does not block to wait for elements
    to be added to the queue. A variant of the method accepts a maximum number of
    elements to drain.
  prefs: []
  type: TYPE_NORMAL
- en: Querying
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this context, querying refers to examining the element at the head without
    removing it from the queue.
  prefs: []
  type: TYPE_NORMAL
- en: '`element()`'
  prefs: []
  type: TYPE_NORMAL
- en: This `Queue` method returns the element at the head of the queue but does not
    remove that element from the queue. It throws `NoSuchElementException` if the
    queue is empty.
  prefs: []
  type: TYPE_NORMAL
- en: '`peek()`'
  prefs: []
  type: TYPE_NORMAL
- en: This `Queue` method is like `element` but returns `null` if the queue is empty.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: When using queues, it is usually a good idea to pick one particular style of
    how to deal with a failure. For example, if you want operations to block until
    they succeed, then choose `put()` and `take()`. If you want to examine the return
    code of a method to see if the queue operation succeeded, then `offer()` and `poll()`
    are appropriate choices.
  prefs: []
  type: TYPE_NORMAL
- en: The `LinkedList` class also implements `Queue`. It provides unbounded FIFO ordering,
    and insertion and removal operations require constant time. `LinkedList` allows
    `null` elements, although their use is discouraged when the list is being used
    as a queue.
  prefs: []
  type: TYPE_NORMAL
- en: There are two other `Queue` implementations in the `java.util` package. `PriorityQueue`
    orders its elements according to a `Comparator` or orders `Comparable` elements
    according to the order defined by their `compareTo()` methods. The head of a `PriorityQueue`
    is always the smallest element according to the defined ordering. Finally, `ArrayDeque`
    is a double-ended queue implementation. It is often used when a stack implementation
    is needed.
  prefs: []
  type: TYPE_NORMAL
- en: The `java.util.concurrent` package also contains a number of `BlockingQueue`
    implementations, which are designed for use in multithreaded programing style;
    advanced versions that can remove the need for synchronized methods are available.
  prefs: []
  type: TYPE_NORMAL
- en: A full discussion of `java.util.concurrent` is unfortunately outside the scope
    of this book. The interested reader should refer to *Java Concurrency in Practice*
    by Brian Goetz et al. (Addison-Wesley, 2006).
  prefs: []
  type: TYPE_NORMAL
- en: Utility Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `java.util.Collections` class is home to quite a few static utility methods
    designed for use with collections. One important group of these methods is the
    collection *wrapper* methods: they return a special-purpose collection wrapped
    around a collection you specify. The purpose of the wrapper collection is to wrap
    additional functionality around a collection that does not provide it itself.
    Wrappers exist to provide thread-safety, write protection, and runtime type checking.
    Wrapper collections are always *backed by* the original collection, which means
    that the methods of the wrapper simply dispatch to the equivalent methods of the
    wrapped collection. This means that changes made to the collection through the
    wrapper are visible through the wrapped collection and vice versa.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first set of wrapper methods provides threadsafe wrappers around collections.
    Except for the legacy classes `Vector` and `Hashtable`, the collection implementations
    in `java.util` do not have `synchronized` methods and are not protected against
    concurrent access by multiple threads. If you need threadsafe collections and
    don’t mind the additional overhead of synchronization, create them with code like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'A second set of wrapper methods provides collection objects through which the
    underlying collection cannot be modified. They return a read-only view of a collection:
    an `UnsupportedOperationException` will result from changing the collection’s
    content. These wrappers are useful when you must pass a collection to a method
    that must not be allowed to modify or mutate the content of the collection in
    any way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `java.util.Collections` class also defines methods to operate on collections.
    Some of the most notable are methods to sort and search the elements of collections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some other interesting `Collections` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: It is a good idea to familiarize yourself fully with the utility methods in
    `Collections` and `Arrays`, as they can save you from writing your own implementation
    of a common task.
  prefs: []
  type: TYPE_NORMAL
- en: Special-case collections
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In addition to its wrapper methods, the `java.util.Collections` class also defines
    utility methods for creating immutable collection instances that contain a single
    element and other methods for creating empty collections. `singleton()`, `singletonList()`,
    and `singletonMap()` return immutable `Set`, `List`, and `Map` objects that contain
    a single specified object or a single key/value pair. These methods are useful
    when you need to pass a single object to a method that expects a collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Collections` class also includes methods that return empty collections.
    If you are writing a method that returns a collection, it is usually best to handle
    the no-values-to-return case by returning an empty collection instead of a special-case
    value like `null`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Since Java 9, though, these methods are frequently replaced by the `of()` methods
    on the `Set`, `List` and `Map` interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: These return immutable versions of their type and may also take elements through
    the same method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, `nCopies()` returns an immutable `List` that contains a specified
    number of copies of a single specified object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Arrays and Helper Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Arrays of objects and collections serve similar purposes. It is possible to
    convert from one to the other:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In addition, there are a number of useful helper methods for working with Java’s
    arrays, which are included here for completeness.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `java.lang.System` class defines an `arraycopy()` method that is useful
    for copying specified elements in one array to a specified position in a second
    array. The second array must be the same type as the first, and it can even be
    the same array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'There are also a number of useful static methods defined on the `Arrays` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Arrays can be treated and manipulated as objects in Java. Given an arbitrary
    object `o`, you can use code such as the following to find out if the object is
    an array and, if so, what type of array it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Java Streams and Lambda Expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the major reasons for introducing lambda expressions in Java 8 was to
    facilitate the overhaul of the Collections API to allow more modern programming
    styles to be used by Java developers. Until the release of Java 8, the handling
    of data structures in Java looked a little bit dated. Many languages now support
    a programming style that allows collections to be treated as a whole, rather than
    requiring them to be broken apart and iterated over.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, many Java developers had taken to using alternative data structures
    libraries to achieve some of the expressivity and productivity they felt was lacking
    in the Collections API. The key to upgrading the APIs was to introduce new classes
    and methods that would accept lambda expressions as parameters—to define *what*
    needed to be done, rather than precisely *how*. This is a conception of programming
    that comes from the functional style.
  prefs: []
  type: TYPE_NORMAL
- en: The introduction of the functional collections—which are called *Java Streams*
    to make clear their divergence from the older collections approach—is an important
    step forward. A stream can be created from a collection simply by calling the
    `stream()` method on an existing collection.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The desire to add new methods to existing interfaces was directly responsible
    for the new language feature referred to as *default methods* (see [“Default Methods”](ch04.xhtml#javanut8-CHP-4-SECT-1.7)
    for more details). Without this new mechanism, older implementations of the Collections
    interfaces would fail to compile under Java 8 and would fail to link if loaded
    into a Java 8 runtime.
  prefs: []
  type: TYPE_NORMAL
- en: However, the arrival of the Streams API does not erase history. The Collections
    API is deeply embedded in the Java world, and it is not functional. Java’s commitment
    to backward compatibility and to a rigid language grammar means that the Collections
    will never go away. Java code, even when written in a functional style, will never
    be entirely free of boilerplate and will never have the concise syntax that we
    see in languages such as Haskell or Scala.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is part of the inevitable trade-off in language design—Java has retrofitted
    functional capabilities on top of an imperative design and base. This is not the
    same as designing for functional programming from the ground up. A more important
    question is: Are the functional capabilities supplied from Java 8 onward what
    working programmers need to build their applications?'
  prefs: []
  type: TYPE_NORMAL
- en: The rapid adoption of Java 8 over previous versions and the community reaction
    seem to indicate that the new features have been a success and have provided what
    the ecosystem was looking for.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will introduce the use of Java streams and lambda expressions
    in the Java Collections. For a fuller treatment, see [*Java 8 Lambdas*](http://shop.oreilly.com/product/0636920030713.do)
    by Richard Warburton (O’Reilly).
  prefs: []
  type: TYPE_NORMAL
- en: Functional Approaches
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The approach that Java 8 Streams wished to enable was derived from functional
    programming languages and styles. We met some of these key patterns in [“Functional
    Programming”](ch04.xhtml#javanut8-CHP-4-SECT-4.3)—let’s reintroduce them and look
    at some examples of each.
  prefs: []
  type: TYPE_NORMAL
- en: Filter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The filter idiom applies a piece of code returning either true or false (known
    as a predicate) to each element in a collection. A new collection is built consisting
    of the elements that “passed the test” (i.e., the bit of code returned `true`
    when applied to the element).
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let’s look at some code to work with a collection of cats and
    pick out the tigers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The key piece is the call to `filter()`, which takes a lambda expression. The
    lambda takes in a string and returns a Boolean value. This is applied over the
    whole collection `cats`, and a new collection is created, which contains only
    tigers (however they were capitalized).
  prefs: []
  type: TYPE_NORMAL
- en: The `filter()` method takes in an instance of the `Predicate` interface, from
    the package `java.util.function`. This is a functional interface, with only a
    single nondefault method, and so is a perfect fit for a lambda expression.
  prefs: []
  type: TYPE_NORMAL
- en: Note the final call to `collect()`; this is an essential part of the API and
    is used to “gather up” the results at the end of the lambda operations. We’ll
    discuss it in more detail in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: '`Predicate` has some other very useful default methods, such as for constructing
    combined predicates by using logic operations. For example, if the tigers want
    to admit leopards into their group, this can be represented by using the `or()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Note that it’s much clearer if the `Predicate<String>` object `p` is explicitly
    created, so that the defaulted `or()` method can be called on it and the second
    lambda expression (which will also be automatically converted to a `Predicate<String>`)
    passed to it.
  prefs: []
  type: TYPE_NORMAL
- en: Map
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The map idiom makes use of the interface `Function<T, R>` in the package `java.util.function`.
    Like `Predicate<T>`, this is a functional interface and so only has one nondefaulted
    method, `apply()`. The map idiom is about transforming one stream into a new stream,
    where the new stream potentially has different types and values than the original.
    This shows up in the API as the fact that `Function<T, R>` has two separate type
    parameters. The name of the type parameter `R` indicates that this represents
    the return type of the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at a code example that uses `map()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This is called upon the previous `cats` variable (which is a `Stream<String>`)
    and applies the function `String::length` (a method reference) to each string
    in turn. The result is a new stream—but of `Integer` this time. We turn that stream
    into a `List` with the `toList()` method. Note that unlike the collections API,
    the `map()` method does not mutate the stream in place but returns a new value.
    This is key to the functional style as used here.
  prefs: []
  type: TYPE_NORMAL
- en: forEach
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The map and filter idioms are used to create one collection from another. In
    languages that are strongly functional, this would be combined with requiring
    that the original collection was not affected by the body of the lambda as it
    touched each element. In computer science terms, this means that the lambda body
    should be “side effect free.”
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java, of course, we often need to deal with mutable data, so the Streams
    API provides a way to mutate elements as the collection is traversed—the `forEach()`
    method. This takes an argument of type `Consumer<T>`, which is a functional interface
    that is expected to operate by side effects (although whether it actually mutates
    the data or not is of lesser importance). This means that the signature of lambdas
    that can be converted to `Consumer<T>` is `(T t) → void`. Let’s look at a quick
    example of `forEach()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we are simply printing out each member of the collection.
    However, we’re doing so by using a special kind of method reference as a lambda
    expression. This type of method reference is called a *bound method reference*,
    as it involves a specific object (in this case, the object `System.out`, which
    is a static public field of `System`). This is equivalent to the lambda expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This is of course eligible for conversion to an instance of a type that implements
    `Consumer<? super String>` as required by the method signature.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Nothing prevents a `map()` or `filter()` call from mutating elements. It is
    only a convention that they must not mutate, but it’s one that every Java programmer
    should adhere to.
  prefs: []
  type: TYPE_NORMAL
- en: There’s one final functional technique that we should look at before we move
    on. This is the practice of aggregating a collection down to a single value, and
    it’s the subject of our next section.
  prefs: []
  type: TYPE_NORMAL
- en: Reduce
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s look at the `reduce()` method. This implements the reduce idiom, which
    is really a family of similar and related operations, some referred to as fold,
    or aggregation, operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java, `reduce()` takes two arguments. These are the initial value, which
    is often called the identity (or zero), and a function to apply step by step.
    This function is of type `BinaryOperator<T>`, which is another functional interface
    that takes in two arguments of the same type and returns another value of that
    type. This second argument to `reduce()` is a two-argument lambda. `reduce()`
    is defined in the `javadoc` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The easy way to think about the second argument to `reduce()` is that it creates
    a “running total” as it runs over the stream. It starts by combining the identity
    with the first element of the stream to produce the first result, then combines
    that result with the second element of the stream, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'It can help to imagine that the implementation of `reduce()` works a bit like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In practice, implementations of `reduce()` can be more sophisticated than these
    and can even execute in parallel if the data structure and operations are amenable
    to this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at a quick example of a `reduce()` and calculate the sum of some
    primes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In all of the examples we’ve met in this section, you may have noticed the presence
    of a `stream()` method call on the `List` instance. This is part of the evolution
    of Java Collections—it was originally chosen partly out of necessity but has proved
    to be an excellent abstraction. Let’s move on to discuss the Streams API in more
    detail.
  prefs: []
  type: TYPE_NORMAL
- en: The Streams API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The fundamental issue that caused the Java library designers to introduce the
    Streams API was the large number of implementations of the core collections interfaces
    present in the wild. As these implementations predate Java 8 and lambdas, they
    would not have any of the methods corresponding to the new functional operations.
    Worse still, as method names such as `map()` and `filter()` have never been part
    of the interface of the Collections, implementations may already have methods
    with those names.
  prefs: []
  type: TYPE_NORMAL
- en: To work around this problem, a new abstraction called a `Stream` was introduced.
    The idea is that a `Stream` object can be generated from a collection object via
    the `stream()` method. This `Stream` type, being new and under the control of
    the library designers, is then guaranteed to be free of collisions. This then
    mitigates the risk of clash, as only Collections implementations that contained
    a `stream()` method would be affected.
  prefs: []
  type: TYPE_NORMAL
- en: A `Stream` object plays a similar role to an `Iterator` in the new approach
    to collections code. The overall idea is for the developer to build up a sequence
    (or “pipeline”) of operations (such as `map`, `filter`, or `reduce`) that need
    to be applied to the collection as a whole. The actual content of the operations
    will usually be expressed as a lambda expression for each operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of the pipeline, the results usually need to be gathered up, or
    “materialized,” either as a new collection or another value. This is done either
    by using a `Collector` or by finishing the pipeline with a “terminal method” such
    as `reduce()` that returns an actual value, rather than another stream. Overall,
    the new approach to collections looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The `Stream` class behaves as a sequence of elements that are accessed one at
    a time (although there are some types of streams that support parallel access
    and can be used to process larger collections in a naturally multithreaded way).
    In a similar way to an `Iterator`, the `Stream` is used to take each item in turn.
  prefs: []
  type: TYPE_NORMAL
- en: As is usual for generic classes in Java, `Stream` is parameterized by a reference
    type. However, in many cases, we actually want streams of primitive types, especially
    ints and doubles. We cannot have `Stream<int>`, so instead in `java.util.stream`
    there are special (nongeneric) classes such as `IntStream` and `DoubleStream`.
    These are known as *primitive specializations* of the `Stream` class and have
    APIs that are very similar to the general `Stream` methods, except that they use
    primitives where appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: Lazy evaluation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In fact, streams are more general than iterators (or even collections), as streams
    do not manage storage for data. In earlier versions of Java, there was always
    a presumption that all of the elements of a collection existed (usually in memory).
    It was possible to work around this in a limited way by insisting on the use of
    iterators everywhere, as well as by having the iterators construct elements on
    the fly. However, this was neither very convenient nor that common.
  prefs: []
  type: TYPE_NORMAL
- en: 'By contrast, streams are an abstraction for managing data, rather than being
    concerned with the details of storage. This makes it possible to handle more subtle
    data structures than just finite collections. For example, infinite streams can
    easily be represented by the `Stream` interface, and they can be used as a way,
    for example, to handle the set of all square numbers. Let’s see how we could accomplish
    this using a `Stream`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Because our list of possible values is infinite, we must adopt a model in which
    elements do not all exist ahead of time. Essentially, a bit of code must return
    the next element as we demand it. The key technique used to accomplish this is
    *lazy evaluation*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Lazy evaluation is a big change for Java, as until JDK 8 the value of an expression
    was always computed as soon as it was assigned to a variable (or passed into a
    method). This familiar model, where values are computed immediately, is called
    “eager evaluation” and it is the default behavior for evaluation of expressions
    in most mainstream programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see this lazy evaluation in action in our example above if we modify
    `getAsInt()` slightly to provide output actively when it is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'When this modified program is run, we’ll see output that shows each `getAsInt()`
    call immediately followed by the use of that value in the `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: One significant consequence of modeling the infinite stream is that methods
    like `collect()` won’t work. This is because we can’t materialize the whole stream
    to a collection (we would run out of memory before we created the infinite amount
    of objects we would need).
  prefs: []
  type: TYPE_NORMAL
- en: 'Even when a stream isn’t infinite, it’s important to recognize what parts of
    the evaluation are lazy. For instance, the following code that tries to show us
    diagnostic information during a `map` operation doesn’t actually yield any output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Only once we provide a terminal action such as `collect()` or `toList()` is
    our `map()` lambda actually executed.
  prefs: []
  type: TYPE_NORMAL
- en: Recognizing which intermediate results are lazy in their evaluation is a topic
    Java developers should be mindful of when working with the Stream API. The more
    complicated implementation details, though, fall to library writers rather than
    users of streams.
  prefs: []
  type: TYPE_NORMAL
- en: While the combination of `filter`, `map`, and `reduce` can accomplish almost
    any stream-related task we’re after, it isn’t always the most convenient API.
    There are a wide variety of additional methods that build on top of these primitives
    to give us a richer vocabulary to work with stream.
  prefs: []
  type: TYPE_NORMAL
- en: Further filtering
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A common place where working with streams benefits from more elaborate methods
    is filtering. A number of methods on the `Stream` interface allow more expressive
    descriptions of how we want to trim our streams for consumption:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Matching in streams
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another typical operation is to ask questions of an entire stream of elements,
    such as whether all (or none) match a given predicate, or alternatively if there’s
    any single element that matches:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Flattening
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once we’ve started down the path of modeling our data as streams, it’s not
    unusual to find yet another layer of streams beneath. For instance, if we’re processing
    multiple lines of text and wanted to gather the set of words from the entire block,
    we might reach first for code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This isn’t quite the plain word list we’re after, though. We have an extra layer
    of nesting, a `Stream<String[]>` instead of `Stream<String>`.
  prefs: []
  type: TYPE_NORMAL
- en: The `flatMap()` method is designed for exactly these situations. For each element
    in our original stream, the lambda provided to `flatMap()` returns not an individual
    value but another `Stream`. Then `flatMap()` gathers those multiple streams and
    joins them, flattening to a single stream of the contained type.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example `split()` gives us arrays, which we can trivially convert to
    streams. From there, `flatMap()` will do the work of turning those multiple streams
    into the single stream of words we were after:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: From Streams to Collections
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Defining a separate `Stream` interface was a pragmatic way to enable newer
    styles of development with Java while not breaking existing code. However, sometimes
    you still need the standard Java Collections, whether to pass to another API or
    for functionality that isn’t present in streams. For the most common cases of
    returning a simple `List` or array of elements, the methods are provided directly
    on the `Stream` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Transforming a stream into a nonstream collection or other object is primarily
    performed through the `collect()` method. This method receives an instance of
    the `Collector` interface, allowing for a world of possible ways to gather up
    our stream results without adding to the `Stream` interface itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Standard implementations for a variety of collectors are available on the `Collectors`
    class as static methods. For instance, we can turn our stream into any of our
    normal collection types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Unlike `Stream#toList()`, all of these options return a modifiable version of
    their collection type. `Collectors` also provides specific methods if you want
    to return an unmodifiable or immutable version. They follow a naming convention
    `toUnmodifiableX()` where `X` is the collection type as seen above.
  prefs: []
  type: TYPE_NORMAL
- en: 'A final variation on gathering collections is when you want to group the elements
    by some property. In this example, we want to group the numbers by their first
    digit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: From Streams to values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We don’t always want to retrieve collections from our streams—sometimes we need
    a single value, much like the `reduce()` method gave us.
  prefs: []
  type: TYPE_NORMAL
- en: '`Stream` has a few built-in methods for the most common values we might want
    from our stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The `collect()` method isn’t limited to returning collection types either.
    A wide variety of result gathering methods are available from `Collectors` to
    aid in common calculations, particularly on streams of numbers. These methods
    all require a function for turning the incoming item from the stream to a number,
    which allows it to be easily used with objects as well as primitive values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Similar methods are available for long and double types in addition to integers.
  prefs: []
  type: TYPE_NORMAL
- en: A final way of getting a result from a stream helps us with strings. A classic
    issue is turning a series of smaller strings into one larger delimited string.
    Streams make this quite simple.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Streams utility default methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Java Streams took the opportunity to introduce a number of new methods to the
    Java Collections libraries. Using default methods, it was possible to add new
    methods to the Collections without breaking backward compatibility.
  prefs: []
  type: TYPE_NORMAL
- en: Some of these methods are *scaffold methods* for creating Streams from our existing
    collections. These include methods such as `Collection::stream`, `Collection::parallelStream`,
    and `Collection::spliterator` (which has specialized forms `List::spliterator`
    and `Set::spliterator`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Other methods provide shortcuts to functionality that existed elsewhere in
    previous versions. For instance, `List::sort` method essentially delegates to
    the more cumbersome version already available on the `Collections` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The remaining methods provide additional functional techniques using the interfaces
    of `java.util.function`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Collection::removeIf`'
  prefs: []
  type: TYPE_NORMAL
- en: This method takes a `Predicate` and iterates internally over the collection,
    removing any elements that satisfy the predicate object.
  prefs: []
  type: TYPE_NORMAL
- en: '`Map::forEach`'
  prefs: []
  type: TYPE_NORMAL
- en: The single argument to this method is a lambda expression that takes two arguments
    (one of the key’s type and one of the value’s type) and returns `void`. This is
    converted to an instance of `BiConsumer` and applied to each key/value pair in
    the map.
  prefs: []
  type: TYPE_NORMAL
- en: '`Map::computeIfAbsent`'
  prefs: []
  type: TYPE_NORMAL
- en: This takes a key and a lambda expression that maps the key type to the value
    type. If the specified key (first parameter) is not present in the map, then it
    computes a default value by using the lambda expression and puts it in the map.
  prefs: []
  type: TYPE_NORMAL
- en: (See also `Map::computeIfPresent`, `Map::compute`, and `Map::merge`.)
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we’ve met the Java Collections libraries and seen how to start
    working with Java’s implementations of fundamental and classic data structures.
    We’ve met the general `Collection` interface, as well as `List`, `Set`, and `Map`.
    We’ve seen the original, iterative way of handling collections and introduced
    the new Java Streams style, based on ideas from fundamental programming. In the
    Streams API, we’ve seen how the new approach is more general and can express more
    subtle programming concepts than the classic approach.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve only scratched the surface—the Streams API is a fundamental shift in how
    Java code is written and architected. There are inherent design limitations in
    how far the ideals of functional programming can be implemented in Java. Having
    said that, the possibility that Streams represents “just enough functional programming”
    is compelling.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s move on. In the next chapter, we’ll continue looking at data, and common
    tasks like text processing, handling numeric data, and Java 8’s new date and time
    libraries.
  prefs: []
  type: TYPE_NORMAL
