- en: Chapter 8\. Working with Java Collections
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。使用Java集合
- en: This chapter introduces Java’s interpretation of fundamental data structures,
    known as the Java Collections. These abstractions are core to many (if not most)
    programming types and form an essential part of any programmer’s basic toolkit.
    Accordingly, this is one of the most important chapters of the entire book and
    provides a toolkit that is essential to virtually all Java programmers.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了Java对基本数据结构的解释，即Java集合。这些抽象是许多编程类型的核心，并构成任何程序员基本工具包的重要组成部分。因此，这是整本书中最重要的章节之一，提供了几乎所有Java程序员都必不可少的工具包。
- en: In this chapter, we will introduce the fundamental interfaces and the type hierarchy,
    show how to use them, and discuss aspects of their overall design. Both the “classic”
    approach to handling the collections and the newer approach (using the Streams
    API and the lambda expressions functionality introduced in Java 8) will be covered.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍基本接口和类型层次结构，展示如何使用它们，并讨论它们整体设计的各个方面。我们将涵盖处理集合的“经典”方法以及较新方法（使用Java
    8中引入的Streams API和lambda表达式功能）。
- en: Introduction to Collections API
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入集合API
- en: The Java Collections are a set of generic interfaces that describe the most
    common forms of data structure. Java ships with several implementations of each
    of the classic data structures, and because the types are represented as interfaces,
    it is very possible for development teams to develop their own, specialized implementations
    of the interfaces for use in their own projects.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Java集合是一组描述最常见数据结构形式的通用接口。Java附带了每个经典数据结构的几种实现，因为这些类型被表示为接口，开发团队非常可能为自己的项目开发出专门的接口实现。
- en: The Java Collections define two fundamental types of data structures. A `Collection`
    is a grouping of objects, while a `Map` is a set of mappings, or associations,
    between objects. The basic layout of the Java Collections is shown in [Figure 8-1](#javanut8-CHP-8-FIG-1).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Java集合定义了两种基本类型的数据结构。`Collection` 是对象的集合，而 `Map` 是对象之间的映射或关联集合。Java集合的基本布局如图
    [Figure 8-1](#javanut8-CHP-8-FIG-1) 所示。
- en: Within this basic description, a `Set` is a type of `Collection` with no duplicates,
    and a `List` is a `Collection` in which the elements are ordered (but may contain
    duplicates).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个基本描述中，`Set` 是一种没有重复元素的 `Collection` 类型，而 `List` 是元素有序（但可以包含重复元素）的 `Collection`。
- en: '![JN7 0801](assets/jns8_0801.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![JN7 0801](assets/jns8_0801.png)'
- en: Figure 8-1\. Collections classes and inheritance
  id: totrans-8
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8-1。集合类和继承
- en: '`SortedSet` and `SortedMap` are specialized sets and maps that maintain their
    elements in a sorted order.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '`SortedSet` 和 `SortedMap` 是特殊的集合和映射，它们维护其元素以排序顺序排列。'
- en: '`Collection`, `Set`, `List`, `Map`, `SortedSet`, and `SortedMap` are all interfaces,
    but the `java.util` package also defines various concrete implementations, such
    as lists based on arrays and linked lists, and maps and sets based on hash tables
    or binary trees. Other important interfaces are `Iterator` and `Iterable`, which
    allow you to loop through the objects in a collection, as we will see later on.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`Collection`、`Set`、`List`、`Map`、`SortedSet` 和 `SortedMap` 都是接口，但 `java.util`
    包还定义了各种具体实现，如基于数组和链表的列表，以及基于哈希表或二叉树的映射和集合。其他重要的接口包括 `Iterator` 和 `Iterable`，它们允许您遍历集合中的对象，正如我们将在稍后看到的那样。'
- en: The Collection Interface
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Collection 接口
- en: '`Collection<E>` is a parameterized interface that represents a generalized
    grouping of objects of type `E`. We can create a collection of any kind of reference
    type.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`Collection<E>` 是一个参数化的接口，表示类型为 `E` 的对象的广义分组。我们可以创建任何类型的引用类型的集合。'
- en: Note
  id: totrans-13
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: To work properly with the expectations of collections, you must take care when
    defining `hashCode()` and `equals()` methods on your classes, as discussed in
    [Chapter 5](ch05.xhtml#javanut8-CHP-5).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要正确地与集合的期望一起工作，您必须在类上定义 `hashCode()` 和 `equals()` 方法时小心，正如 [Chapter 5](ch05.xhtml#javanut8-CHP-5)
    中所讨论的那样。
- en: Methods are defined for adding and removing objects from the group, testing
    an object for membership in the group, and iterating through all elements in the
    group. Additional methods return the elements of the group as an array and return
    the size of the collection.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了向组中添加和删除对象的方法，测试对象是否属于组的方法以及迭代组中所有元素的方法。额外的方法将组的元素作为数组返回，并返回集合的大小。
- en: Note
  id: totrans-16
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The grouping within a `Collection` may or may not allow duplicate elements and
    may or may not impose an ordering on the elements.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`Collection`中的分组可以允许或不允许重复元素，并且可以或不可以对元素进行排序。'
- en: The Java Collections Framework provides `Collection` because it defines the
    features shared by all common forms of data structure. The JDK ships `Set`, `List`,
    and `Queue` as subinterfaces of `Collection`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Java集合框架提供`Collection`，因为它定义了所有常见数据结构形式共享的特性。JDK提供`Set`、`List`和`Queue`作为`Collection`的子接口。
- en: 'The following code illustrates the operations you can perform on `Collection`
    objects:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了您可以对`Collection`对象执行的操作：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Remember that you can use any of the methods shown here with any `Set`, `List`,
    or `Queue`. These subinterfaces may impose membership restrictions or ordering
    constraints on the elements of the collection but still provide the same basic
    methods.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，您可以在任何`Set`、`List`或`Queue`上使用此处显示的任何方法。这些子接口可能对集合的元素施加成员限制或排序约束，但仍提供相同的基本方法。
- en: Note
  id: totrans-22
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Methods such as `addAll()`, `retainAll()`, `clear()`, and `remove()` that alter
    the collection were conceived of as optional parts of the API. Unfortunately,
    they were specified a long time ago, when the received wisdom was to indicate
    the absence of an optional method by throwing `UnsupportedOperationException`.
    Accordingly, some implementations (notably read-only forms) may throw this unchecked
    exception.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 诸如`addAll()`、`retainAll()`、`clear()`和`remove()`等修改集合的方法被设计为API的可选部分。不幸的是，它们是很久以前指定的，在那时的普遍观点是通过抛出`UnsupportedOperationException`来指示可选方法的缺失。因此，一些实现（尤其是只读形式）可能会抛出这个未检查异常。
- en: '`Collection`, `Map`, and their subinterfaces do *not* extend the interfaces
    `Cloneable` or `Serializable`. All of the collection and map implementation classes
    provided in the Java Collections Framework, however, do implement these interfaces.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`Collection`、`Map`及其子接口*不*扩展`Cloneable`或`Serializable`接口。然而，Java集合框架提供的所有集合和映射实现类都实现了这些接口。'
- en: Some collection implementations place restrictions on the elements that they
    can contain. An implementation might prohibit `null` as an element, for example.
    And `EnumSet` restricts membership to the values of a specified enumerated type.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一些集合实现对它们可以包含的元素施加限制。例如，一个实现可能禁止`null`作为元素，而`EnumSet`限制成员只能是指定枚举类型的值。
- en: Attempting to add a prohibited element to a collection always throws an unchecked
    exception such as `NullPointerException` or `ClassCastException`. Checking whether
    a collection contains a prohibited element may also throw such an exception, or
    it may simply return `false`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 试图向集合中添加禁止的元素总是会抛出未检查异常，例如`NullPointerException`或`ClassCastException`。检查集合是否包含禁止元素也可能会抛出这样的异常，或者可能简单地返回`false`。
- en: The Set Interface
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合接口
- en: 'A *set* is a collection of objects that does not allow duplicates: it may not
    contain two references to the same object, two references to `null`, or references
    to two objects `a` and `b` such that `a.equals(b)`. Most general-purpose `Set`
    implementations impose no ordering on the elements of the set, but ordered sets
    are not prohibited (see `SortedSet` and `LinkedHashSet`). Sets are further distinguished
    from ordered collections like lists by the general expectation that they have
    an efficient `contains` method that runs in constant or logarithmic time.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*集合*是一组对象，不允许重复：它可能不包含对同一对象的两个引用、两个对`null`的引用，或者对满足`a.equals(b)`条件的两个对象`a`和`b`的引用。大多数通用的`Set`实现对集合的元素不施加任何排序，但不排除有序集合的存在（参见`SortedSet`和`LinkedHashSet`）。集合还通过通常期望具有在常数或对数时间内运行的高效`contains`方法来与列表等有序集合区分开来。'
- en: '`Set` defines no methods of its own beyond those defined by `Collection` but
    places additional restrictions on some methods. The `add()` and `addAll()` methods
    of a `Set` are required to enforce the no-duplicates rules: they may not add an
    element to the `Set` if the set already contains that element. Recall that the
    `add()` and `addAll()` methods defined by the `Collection` interface return `true`
    if the call resulted in a change to the collection and `false` if it did not.
    This return value is relevant for `Set` objects because the no-duplicates restriction
    means that adding an element does not always result in a change to the set.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 8-1](#javanut8-CHP-8-TABLE-2) lists the implementations of the `Set`
    interface and summarizes their internal representation, ordering characteristics,
    member restrictions, and the performance of the basic `add()`, `remove()`, and
    `contains` operations as well as iteration performance. Note that `CopyOnWriteArraySet`
    is in the `java.util.concurrent` package; all the other implementations are part
    of `java.util`. Also note that `java.util.BitSet` is not a `Set` implementation.
    This legacy class is useful as a compact and efficient list of `boolean` values
    but is not part of the Java Collections Framework.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Table 8-1\. Set implementations
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '| Class | Internal representation | Since | Element order | Member restrictions
    | Basic operations | Iteration performance | Notes |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
- en: '| `HashSet` | Hashtable | 1.2 | None | None | O(1) | O(capacity) | Best general-purpose
    implementation |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
- en: '| `LinkedHashSet` | Linked hashtable | 1.2 | Insertion order | None | O(1)
    | O(n) | Preserves insertion order |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
- en: '| `EnumSet` | Bit fields | 5.0 | Enum declaration | Enum values | O(1) | O(n)
    | Holds non-`null` enum values only |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
- en: '| `TreeSet` | Red-black tree | 1.2 | Sorted ascending | Comparable | O(log(n))
    | O(n) | `Comparable` elements or `Comparator` |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
- en: '| `CopyOnWriteArraySet` | Array | 5.0 | Insertion order | None | O(n) | O(n)
    | Threadsafe without synchronized methods |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
- en: The `TreeSet` implementation uses a red-black tree data structure to maintain
    a set that is iterated in ascending order according to the natural ordering of
    `Comparable` objects or according to an ordering specified by a `Comparator` object.
    `TreeSet` actually implements the `SortedSet` interface, which is a subinterface
    of `Set`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'The `SortedSet` interface offers several interesting methods that take advantage
    of its sorted nature. The following code illustrates:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Warning
  id: totrans-42
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The addition of `\0` characters is needed because the `tailSet()` and related
    methods use the *successor* of an element, which for strings is the string value
    with a `NULL` character (ASCII code 0) appended.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 'From Java 9 onward, the API has also been upgraded with a helper static method
    on the `Set` interface, like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This API has several overloads that each take a fixed number of arguments, and
    also a varargs overload. The latter is used for the case where arbitrarily many
    elements are wanted in the set and falls back to the standard varargs mechanism
    (marshaling the elements into an array before the call). It’s worth noting as
    well that the set returned by `Set.of` is immutable and will throw an `UnsupportedOperationException`
    on further attempts to add or remove from it after instantiation.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 此API有几个重载版本，每个版本都接受固定数量的参数，还有一个可变参数的重载。后者用于需要任意多个元素的情况，并回退到标准的可变参数机制（在调用之前将元素编组成数组）。值得注意的是，`Set.of`返回的集合是不可变的，如果在实例化后尝试添加或删除元素，将抛出`UnsupportedOperationException`异常。
- en: The List Interface
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列表接口
- en: A `List` is an ordered collection of objects. Each element of a list has a position
    in the list, and the `List` interface defines methods to query or set the element
    at a particular position, or *index*. In this respect, a `List` is like an array
    whose size changes as needed to accommodate the number of elements it contains.
    Unlike sets, lists allow duplicate elements.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`List`是一组有序的对象。列表中的每个元素在列表中都有一个位置，`List`接口定义了查询或设置特定位置或*索引*处元素的方法。在这方面，`List`类似于一个大小会根据需要变化的数组，以容纳其包含的元素数量。与集合不同，列表允许重复元素。'
- en: In addition to its index-based `get()` and `set()` methods, the `List` interface
    defines methods to add or remove an element at a particular index and also defines
    methods to return the index of the first or last occurrence of a particular value
    in the list. The `add()` and `remove()` methods inherited from `Collection` are
    defined to append to the list and to remove the first occurrence of the specified
    value from the list. The inherited `addAll()` appends all elements in the specified
    collection to the end of the list, and another version inserts the elements at
    a specified index. The `retainAll()` and `removeAll()` methods behave as they
    do for any `Collection`, retaining or removing multiple occurrences of the same
    value, if needed.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 除了基于索引的`get()`和`set()`方法之外，`List`接口还定义了方法，在特定索引处添加或删除元素，并且还定义了返回列表中特定值第一次出现或最后一次出现的索引的方法。从`Collection`继承的`add()`和`remove()`方法被定义为将元素追加到列表的末尾，并从列表中删除指定值的第一个出现。从指定集合添加所有元素到列表末尾的`addAll()`方法的另一个版本将元素插入到指定索引处。`retainAll()`和`removeAll()`方法像对任何`Collection`一样行为，如果需要，保留或删除相同值的多个出现。
- en: 'The `List` interface doesn’t define methods that operate on a range of list
    indexes. Instead, it defines a single `subList()` method that returns a `List`
    object that represents just the specified range of the original list. The sublist
    is backed by the parent list, and any changes made to the sublist are immediately
    visible in the parent list. Examples of `subList()` and the other basic `List`
    manipulation methods follow:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`List`接口并不定义操作列表索引范围的方法。相反，它定义了一个`subList()`方法，该方法返回一个`List`对象，该对象仅表示原始列表的指定范围。子列表由父列表支持，对子列表的任何更改都会立即反映在父列表中。以下是`subList()`和其他基本的`List`操作方法的示例：'
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Foreach loops and iteration
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Foreach 循环和迭代
- en: 'One very important way of working with collections is to process each element
    in turn, an approach known as *iteration*. This is an older way of looking at
    data structures, but it is still very useful (especially for small collections
    of data) and is easy to understand. This approach fits naturally with the `for`
    loop, as shown in this bit of code, and is easiest to illustrate using a `List`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 处理集合的一种非常重要的方式是依次处理每个元素，这种方法称为*迭代*。这是一种查看数据结构的较旧方式，但仍然非常有用（特别是对于小数据集），而且易于理解。这种方法与`for`循环自然契合，如下面的代码片段所示，而且最容易用`List`来说明：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The sense of the code should be clear—it takes the elements of `c` one at a
    time and uses them as a variable in the loop body. More formally, it iterates
    through the elements of an array or collection (or any object that implements
    `java.lang.Iterable`). On each iteration it assigns an element of the array or
    `Iterable` object to the loop variable you declare and then executes the loop
    body, which typically uses the loop variable to operate on the element. No loop
    counter or `Iterator` object is involved; the loop performs the iteration automatically,
    and you need not concern yourself with correct initialization or termination of
    the loop.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的意图应该清晰明了——它逐个取出 `c` 的元素，并将它们用作循环体中的变量。更正式地说，它遍历数组或集合（或实现 `java.lang.Iterable`
    接口的任何对象）。在每次迭代中，它将数组或 `Iterable` 对象的一个元素赋给你声明的循环变量，然后执行循环体，通常使用循环变量来操作元素。不涉及循环计数器或
    `Iterator` 对象；循环自动执行迭代，你无需关注循环的正确初始化或终止。
- en: 'This type of `for` loop is often referred to as a *foreach loop*. Let’s see
    how it works. The following bit of code shows a rewritten (and equivalent) `for`
    loop, with the method calls explicitly shown:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的 `for` 循环通常被称为 *foreach 循环*。让我们看看它是如何工作的。下面的代码片段显示了一个重写（及等效）的 `for` 循环，明确显示了方法调用：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `Iterator` object, `i`, is produced from the collection and used to step
    through the collection one item at a time. It can also be used with `while` loops:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`Iterator` 对象 `i` 是从集合生成并用于逐个遍历集合中的项目。它也可以与 `while` 循环一起使用：'
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here are some more things you should know about the syntax of the foreach loop:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是关于 foreach 循环语法的更多信息：
- en: As noted earlier, *`expression`* must be either an array or an object that implements
    the `java.lang.Iterable` interface. This type must be known at compile time so
    that the compiler can generate appropriate looping code.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正如前面提到的，*`expression`* 必须是数组或实现了 `java.lang.Iterable` 接口的对象。这种类型必须在编译时已知，以便编译器能够生成适当的循环代码。
- en: The type of the array or `Iterable` elements must be assignment-compatible with
    the type of the variable declared in the *`declaration`*. If you use an `Iterable`
    object that is not parameterized with an element type, the variable must be declared
    as an `Object`.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组或 `Iterable` 元素的类型必须与 *`declaration`* 中声明的变量类型兼容。如果使用未参数化元素类型的 `Iterable`
    对象，则必须将变量声明为 `Object`。
- en: The *`declaration`* usually consists of just a type and a variable name, but
    it may include a `final` modifier and any appropriate annotations (see [Chapter 4](ch04.xhtml#javanut8-CHP-4)).
    Using `final` prevents the loop variable from taking on any value other than the
    array or collection element the loop assigns it and serves to emphasize that the
    array or collection cannot be altered through the loop variable.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*`declaration`* 通常只包括类型和变量名，但可能包括 `final` 修饰符和任何适当的注解（参见 [第四章](ch04.xhtml#javanut8-CHP-4)）。使用
    `final` 可以防止循环变量获得除了循环分配的数组或集合元素之外的任何值，并强调数组或集合不能通过循环变量进行更改。'
- en: The loop variable of the foreach loop must be declared as part of the loop,
    with both a type and a variable name. You cannot use a variable declared outside
    the loop as you can with the `for` loop.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: foreach 循环的循环变量必须作为循环的一部分声明，具有类型和变量名。你不能像 `for` 循环那样使用在循环外声明的变量。
- en: 'To understand in detail how the foreach loop works with collections, we need
    to consider two interfaces, `java.util.Iterator` and `java.lang.Iterable`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要详细了解 foreach 循环如何与集合一起工作，我们需要考虑两个接口，`java.util.Iterator` 和 `java.lang.Iterable`：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`Iterator` defines a way to iterate through the elements of a collection or
    other data structure. It works like this: while there are more elements in the
    collection (`hasNext()` returns `true`), call `next` to obtain the next element
    of the collection. Ordered collections, such as lists, typically have iterators
    that guarantee they’ll return elements in order. Unordered collections like `Set`
    simply guarantee that repeated calls to `next()` return all elements of the set
    without omissions or duplications, but they do not specify an ordering.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`Iterator` 定义了通过集合或其他数据结构遍历元素的方法。其工作方式如下：当集合中还有更多元素时（`hasNext()` 返回 `true`），调用
    `next` 获取集合的下一个元素。有序集合（如列表）通常具有保证按顺序返回元素的迭代器。无序集合（如 `Set`）仅保证多次调用 `next()` 返回集合的所有元素，但不指定顺序。'
- en: Warning
  id: totrans-68
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: The `next()` method of `Iterator` performs two functions—it advances through
    the collection and also returns the element of the collection that we have just
    moved past. This combination of operations can cause problems when you are programming
    in a functional or immutable style, as it mutates the underlying collection.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`Iterator`的`next()`方法执行两个功能——它在集合中前进，并返回我们刚刚移动过的集合元素。这些操作的组合可能会在以函数式或不可变风格编程时引发问题，因为它会改变底层集合。'
- en: 'The `Iterable` interface was introduced to make the foreach loop work. A class
    implements this interface to advertise that it is able to provide an `Iterator`
    to anyone interested:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`Iterable`接口的引入是为了使foreach循环工作。类实现此接口来告知任何有兴趣的人它能够提供一个`Iterator`：'
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If an object is `Iterable<E>`, that means that it has an `iterator()` method
    that returns an `Iterator<E>`, which has a `next()` method that returns an object
    of type `E`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对象是`Iterable<E>`，这意味着它有一个返回`Iterator<E>`的`iterator()`方法，该迭代器有一个返回`E`类型对象的`next()`方法。
- en: Note
  id: totrans-73
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注
- en: If you use the foreach loop with an `Iterable<E>`, the loop variable must be
    of type `E` or a superclass or interface.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用`Iterable<E>`的foreach循环，循环变量必须是类型`E`或超类或接口。
- en: 'For example, to iterate through the elements of a `List<String>`, the variable
    must be declared `String` or its superclass `Object`, or one of the interfaces
    it implements: `CharSequence`, `Comparable`, or `Serializable`.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要遍历`List<String>`的元素，变量必须声明为`String`或其超类`Object`，或者它实现的接口之一：`CharSequence`、`Comparable`或`Serializable`。
- en: A common pitfall with iterators regards modification. If the collection is modified
    while iteration is in process, it may throw an error of the type `ConcurrentModificationException`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器常见的一个陷阱涉及修改。如果在迭代过程中修改了集合，可能会抛出`ConcurrentModificationException`类型的错误。
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Avoiding this exception requires rethinking your algorithm so it doesn’t modify
    the collection. This can often be accomplished by working against a local copy
    instead of the original collection. The newer `Stream` APIs for collections also
    provide a lot of useful helpers for these situations.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 避免此异常需要重新思考算法，以便不修改集合。通常可以通过针对副本而不是原始集合进行操作来实现这一点。新的`Stream` API也为这些情况提供了许多有用的辅助功能。
- en: Random access to Lists
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对列表的随机访问
- en: 'A general expectation of `List` implementations is that they can be efficiently
    iterated, typically in time proportional to the size of the list. Lists do not
    all provide efficient random access to the elements at any index, however. Sequential-access
    lists, such as the `LinkedList` class, provide efficient insertion and deletion
    operations at the expense of random-access performance. Implementations that provide
    efficient random access implement the `RandomAccess` marker interface, and you
    can test for this interface with `instanceof` if you need to ensure efficient
    list manipulations:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`List`实现的一个普遍期望是它们能够高效地进行迭代，通常在与列表大小成比例的时间内。然而，并非所有列表都能高效地在任何索引处提供元素的随机访问。顺序访问列表，如`LinkedList`类，在提供高效的插入和删除操作的同时，牺牲了随机访问的性能。提供高效随机访问的实现会实现`RandomAccess`标记接口，如果需要确保高效的列表操作，可以使用`instanceof`测试此接口：'
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `Iterator` returned by the `iterator()` method of a `List` iterates the
    list elements in the order they occur in the list. `List` implements `Iterable`,
    and lists can be iterated with a foreach loop just as any other collection can.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`List`的`iterator()`方法返回的`Iterator`按列表中元素出现的顺序迭代列表元素。`List`实现了`Iterable`，因此可以像任何其他集合一样使用foreach循环进行迭代。'
- en: 'To iterate just a portion of a list, you can use the `subList()` method to
    create a sublist view:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要仅迭代列表的一部分，可以使用`subList()`方法创建一个子列表视图：
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[Table 8-2](#javanut8-CHP-8-TABLE-3) summarizes the five general-purpose `List`
    implementations in the Java platform. `Vector` and `Stack` are legacy implementations
    and should not be used. `CopyOnWriteArrayList` is part of the `java.util.concurrent`
    package and is only really suitable for multithreaded use cases.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 8-2](#javanut8-CHP-8-TABLE-3)总结了Java平台中五个通用的`List`实现。`Vector`和`Stack`是遗留实现，不应使用。`CopyOnWriteArrayList`属于`java.util.concurrent`包，仅适用于多线程用例。'
- en: Table 8-2\. List implementations
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8-2\. 列表实现
- en: '| Class | Representation | Since | Random access | Notes |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 类别 | 表示 | 自Java版本 | 随机访问 | 备注 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| `ArrayList` | Array | 1.2 | Yes | Best all-around implementation |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `ArrayList` | 数组 | 1.2 | 是 | 最全面的实现 |'
- en: '| `LinkedList` | Double-linked list | 1.2 | No | More efficient insertion and
    deletion in middle of list |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
- en: '| `CopyOnWriteArrayList` | Array | 5.0 | Yes | Threadsafe; fast traversal,
    slow modification |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
- en: '| `Vector` | Array | 1.0 | Yes | Legacy class; synchronized methods. Do not
    use. |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
- en: '| `Stack` | Array | 1.0 | Yes | Extends `Vector`; adds `push()`, `pop()`, `peek()`.
    Legacy; use `Deque` instead. |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
- en: The Map Interface
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *map* is a set of *key* objects and a mapping from each member of that set
    to a *value* object. The `Map` interface defines an API for defining and querying
    mappings. `Map` is part of the Java Collections Framework, but it does not extend
    the `Collection` interface, so a `Map` is a little-c collection, not a big-C `Collection`.
    `Map` is a parameterized type with two type variables, `Map<K, V>`. Type variable
    `K` represents the type of keys held by the map, and type variable `V` represents
    the type of the values that the keys are mapped to. A mapping from `String` keys
    to `Integer` values, for example, can be represented with a `Map<String,Integer>`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 'The most important `Map` methods are `put()`, which defines a key/value pair
    in the map; `get()`, which queries the value associated with a specified key;
    and `remove()`, which removes the specified key and its associated value from
    the map. The general performance expectation for `Map` implementations is that
    these three basic methods are quite efficient: they should run in constant time
    and certainly no worse than in logarithmic time.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'An important feature of `Map` is its support for “collection views.” These
    can be summarized as:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: A `Map` is not a `Collection`
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The keys of a `Map` can be viewed as a `Set`
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The values can be viewed as a `Collection`
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The mappings can be viewed as a `Set` of `Map.Entry` objects.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  id: totrans-102
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`Map.Entry` is a nested interface defined within `Map`: it simply represents
    a single key/value pair.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: 'The following sample code shows the `get()`, `put()`, `remove()`, and other
    methods of a `Map` and demonstrates some common uses of the collection views of
    a `Map`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'With the arrival of Java 9, the `Map` interface also has been enhanced with
    factory methods for spinning up collections easily:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The situation is a little more complicated as compared to `Set` and `List`,
    as the `Map` type has both keys and values, and Java does not allow more than
    one varargs parameter in a method declaration. The solution is to have fixed argument
    size overloads, up to 10 entries and also to provide a new static method, `entry()`,
    that will construct an object to represent the key/value pair.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'The code can then be written to use the varargs form like this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note that the method name has to be different from `of()` due to the difference
    in type of the arguments—this is now a varargs method in `Map.Entry`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: The `Map` interface includes a variety of general-purpose and special-purpose
    implementations, which are summarized in [Table 8-3](#javanut8-CHP-8-TABLE-4).
    As always, complete details are in the JDK’s documentation and javadoc. All classes
    in [Table 8-3](#javanut8-CHP-8-TABLE-4) are in the `java.util` package except
    `ConcurrentHashMap` and `ConcurrentSkipListMap`, which are part of `java.util.concurrent`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`Map` 接口包含各种通用和特殊用途的实现，总结如[表 8-3](#javanut8-CHP-8-TABLE-4)。如常，详细信息请参阅 JDK 文档和
    javadoc。[表 8-3](#javanut8-CHP-8-TABLE-4) 中的所有类均位于 `java.util` 包中，除了 `ConcurrentHashMap`
    和 `ConcurrentSkipListMap`，它们属于 `java.util.concurrent` 包。'
- en: Table 8-3\. Map implementations
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8-3\. 地图实现
- en: '| Class | Representation | Since | Null keys | Null values | Notes |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| 类 | 表示 | 自从 | 空键 | 空值 | 备注 |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| `HashMap` | Hashtable | 1.2 | Yes | Yes | General-purpose implementation
    |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `HashMap` | Hashtable | 1.2 | 是 | 是 | 通用实现 |'
- en: '| `C⁠o⁠n⁠c⁠u⁠r⁠r⁠e⁠n⁠t​H⁠a⁠s⁠h⁠M⁠a⁠p` | Hashtable | 5.0 | No | No | General-purpose
    threadsafe implementation; see `ConcurrentMap` interface |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `ConcurrentHashMap` | Hashtable | 5.0 | 否 | 否 | 通用线程安全实现；参见 `ConcurrentMap`
    接口 |'
- en: '| `ConcurrentSkipListMap` | Hashtable | 6.0 | No | No | Specialized threadsafe
    implementation; see `ConcurrentNavigableMap` interface |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `ConcurrentSkipListMap` | Hashtable | 6.0 | 否 | 否 | 专用线程安全实现；参见 `ConcurrentNavigableMap`
    接口 |'
- en: '| `EnumMap` | Array | 5.0 | No | Yes | Keys are instances of an enum |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `EnumMap` | 数组 | 5.0 | 否 | 是 | 键是枚举实例 |'
- en: '| `LinkedHashMap` | Hashtable plus list | 1.4 | Yes | Yes | Preserves insertion
    or access order |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `LinkedHashMap` | Hashtable 加列表 | 1.4 | 是 | 是 | 保持插入或访问顺序 |'
- en: '| `TreeMap` | Red-black tree | 1.2 | No | Yes | Sorts by key value. Operations
    are O(log(n)). See `SortedMap` interface. |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `TreeMap` | 红黑树 | 1.2 | 否 | 是 | 按键值排序。操作复杂度为 O(log(n))。参见`SortedMap`接口。 |'
- en: '| `IdentityHashMap` | Hashtable | 1.4 | Yes | Yes | Compares with `==` instead
    of `equals()` |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `IdentityHashMap` | Hashtable | 1.4 | 是 | 是 | 使用 `==` 而不是 `equals()` 比较 |'
- en: '| `WeakHashMap` | Hashtable | 1.2 | Yes | Yes | Doesn’t prevent garbage collection
    of keys |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `WeakHashMap` | Hashtable | 1.2 | 是 | 是 | 不会阻止键的垃圾回收 |'
- en: '| `Hashtable` | Hashtable | 1.0 | No | No | Legacy class; synchronized methods.
    Do not use. |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| `Hashtable` | Hashtable | 1.0 | 否 | 否 | 传统类；同步方法。不建议使用。 |'
- en: '| `Properties` | Hashtable | 1.0 | No | No | Extends `Hashtable` with `String`
    methods |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `Properties` | Hashtable | 1.0 | 否 | 否 | 扩展了 `Hashtable` 并添加了 `String` 方法
    |'
- en: The `ConcurrentHashMap` and `ConcurrentSkipListMap` classes of the `java.util.concurrent`
    package implement the `ConcurrentMap` interface of the same package. `ConcurrentMap`
    extends `Map` and defines some additional atomic operations that are important
    in multithreaded programming. For example, the `putIfAbsent()` method is like
    `put()` but adds the key/value pair to the map only if the key is not already
    mapped.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConcurrentHashMap` 和 `ConcurrentSkipListMap` 类属于 `java.util.concurrent` 包，实现了该包中的
    `ConcurrentMap` 接口。`ConcurrentMap` 扩展自 `Map` 并定义了一些在多线程编程中重要的原子操作。例如，`putIfAbsent()`
    方法类似于 `put()`，但仅在键尚未映射时才向映射中添加键值对。'
- en: '`TreeMap` implements the `SortedMap` interface, which extends `Map` to add
    methods that take advantage of the sorted nature of the map. `SortedMap` is quite
    similar to the `SortedSet` interface. The `firstKey()` and `lastKey()` methods
    return the first and last keys in the `keySet()`. And `headMap()`, `tailMap()`,
    and `subMap()` return a restricted range of the original map.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`TreeMap` 实现了 `SortedMap` 接口，该接口扩展自 `Map` 并添加了利用有序映射性质的方法。`SortedMap` 与 `SortedSet`
    接口非常相似。`firstKey()` 和 `lastKey()` 方法返回映射中键集的第一个和最后一个键。`headMap()`、`tailMap()`
    和 `subMap()` 返回原始映射的受限范围。'
- en: The Queue and BlockingQueue Interfaces
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 队列和阻塞队列接口
- en: A *queue* is an ordered collection of elements with methods for extracting elements,
    in order, from the *head* of the queue. Queue implementations are commonly based
    on insertion order as in first-in, first-out (FIFO) queues or last-in, first-out
    (LIFO) queues.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 队列 是一种有序集合，具有从队列头部按顺序提取元素的方法。队列实现通常基于插入顺序，如先进先出 (FIFO) 队列或后进先出 (LIFO) 队列。
- en: Note
  id: totrans-130
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: LIFO queues are also known as stacks, and Java provides a `Stack` class, but
    its use is strongly discouraged—instead, use implementations of the `Deque` interface.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: LIFO 队列也称为栈，Java 提供了 `Stack` 类，但强烈不建议使用——而是使用 `Deque` 接口的实现。
- en: 'Other orderings are also possible: a *priority queue* orders its elements according
    to an external `Comparator` object or according to the natural ordering of `Comparable`
    elements. Unlike a `Set`, `Queue` implementations typically allow duplicate elements.
    Unlike `List`, the `Queue` interface does not define methods for manipulating
    queue elements at arbitrary positions. Only the element at the head of the queue
    is available for examination. It is common for `Queue` implementations to have
    a fixed capacity: when a queue is full, it is not possible to add more elements.
    Similarly, when a queue is empty, it is not possible to remove any more elements.
    Because full and empty conditions are a normal part of many queue-based algorithms,
    the `Queue` interface defines methods that signal these conditions with return
    values rather than by throwing exceptions. Specifically, the `peek()` and `poll()`
    methods return `null` to indicate that the queue is empty. For this reason, most
    `Queue` implementations do not allow `null` elements.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他可能的排序方式：*优先队列*根据外部`Comparator`对象或根据`Comparable`元素的自然顺序对其元素进行排序。与`Set`不同，`Queue`实现通常允许重复元素。与`List`不同，`Queue`接口不定义用于在任意位置操作队列元素的方法。只有队列头部的元素可供检查。许多`Queue`实现通常具有固定的容量：当队列已满时，不可能再添加更多元素。类似地，当队列为空时，不可能再移除任何元素。由于满和空的条件是许多基于队列的算法的正常部分，`Queue`接口定义了用返回值而不是抛出异常来表示这些条件的方法。具体来说，`peek()`和`poll()`方法返回`null`来指示队列为空。因此，大多数`Queue`实现不允许`null`元素。
- en: A *blocking queue* is a type of queue that defines blocking `put()` and `take()`
    methods. The `put()` method adds an element to the queue, waiting, if necessary,
    until there is space in the queue for the element. And the `take()` method removes
    an element from the head of the queue, waiting, if necessary, until there is an
    element to remove. Blocking queues are an important part of many multithreaded
    algorithms, and the `BlockingQueue` interface (which extends `Queue`) is defined
    as part of the `java.util.concurrent` package.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '*阻塞队列*是一种定义了阻塞`put()`和`take()`方法的队列类型。`put()`方法会添加一个元素到队列中，在必要时等待，直到队列有空间可用。而`take()`方法会从队列头部移除一个元素，在必要时等待，直到有元素可移除。阻塞队列是许多多线程算法的重要部分，`BlockingQueue`接口（它扩展了`Queue`）作为`java.util.concurrent`包的一部分进行了定义。'
- en: Queues are not nearly as commonly used as sets, lists, and maps, except perhaps
    in certain multithreaded programming styles. In lieu of example code here, we’ll
    try to clarify the different possible queue insertion and removal operations.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 与集合、列表和映射相比，队列并不是那么常用，除了在某些多线程编程风格中可能会使用。在这里，我们将尝试澄清不同可能的队列插入和移除操作，而不提供示例代码。
- en: Adding Elements to Queues
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向队列中添加元素
- en: '`add()`'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`add()`'
- en: This `Collection` method simply adds an element in the normal way. In bounded
    queues, this method may throw an exception if the queue is full.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`Collection`方法会以常规方式添加元素。在有界队列中，如果队列已满，该方法可能会抛出异常。
- en: '`offer()`'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`offer()`'
- en: This `Queue` method is like `add()` but returns `false` instead of throwing
    an exception if the element cannot be added because a bounded queue is full.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`Queue`方法类似于`add()`，但是如果由于有界队列已满而无法添加元素，它会返回`false`而不是抛出异常。
- en: '`BlockingQueue` defines a timeout version of `offer()` that waits up to a specified
    amount of time for space to become available in a full queue. Like the basic version
    of the method, it returns `true` if the element was inserted and `false` otherwise.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`BlockingQueue`定义了`offer()`的超时版本，它会等待指定时间，直到一个满队列中有空间可用。与该方法的基本版本一样，如果元素被插入则返回`true`，否则返回`false`。'
- en: '`put()`'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`put()`'
- en: 'This `BlockingQueue` method blocks: if the element cannot be inserted because
    the queue is full, `put()` waits until some other thread removes an element from
    the queue and space becomes available for the new element.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`BlockingQueue`方法会阻塞：如果由于队列已满而无法插入元素，则`put()`会等待直到另一个线程从队列中移除一个元素，为新元素腾出空间。
- en: Removing Elements from Queues
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从队列中移除元素
- en: '`remove()`'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`remove()`'
- en: In addition to the `Collection.remove()` method, which removes a specified element
    from the queue, the `Queue` interface defines a no-argument version of `remove()`
    that removes and returns the element at the head of the queue. If the queue is
    empty, this method throws a `NoSuchElementException`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`Collection.remove()`方法可以从队列中移除指定元素之外，`Queue`接口还定义了`remove()`的无参数版本，它会移除并返回队列头部的元素。如果队列为空，该方法会抛出`NoSuchElementException`。
- en: '`poll()`'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`poll()`'
- en: This `Queue` method removes and returns the element at the head of the queue,
    like `remove()` does, but returns `null` if the queue is empty instead of throwing
    an exception.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 此 `Queue` 方法移除并返回队列头部的元素，类似于 `remove()`，但如果队列为空则返回 `null`，而不是抛出异常。
- en: '`BlockingQueue` defines a timeout version of `poll()` that waits up to a specified
    amount of time for an element to be added to an empty queue.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`BlockingQueue` 定义了 `poll()` 的超时版本，等待指定的时间量以在空队列中添加元素。'
- en: '`take()`'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`take()`'
- en: This `BlockingQueue` method removes and returns the element at the head of the
    queue. If the queue is empty, it blocks until some other thread adds an element
    to the queue.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 此 `BlockingQueue` 方法移除并返回队列头部的元素。如果队列为空，它会阻塞，直到其他线程向队列添加元素。
- en: '`drainTo()`'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`drainTo()`'
- en: This `BlockingQueue` method removes all available elements from the queue and
    adds them to a specified `Collection`. It does not block to wait for elements
    to be added to the queue. A variant of the method accepts a maximum number of
    elements to drain.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 此 `BlockingQueue` 方法从队列中移除所有可用元素并将它们添加到指定的 `Collection` 中。它不会阻塞等待元素添加到队列中。该方法的一个变体接受最大数量的要排放的元素。
- en: Querying
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查询
- en: In this context, querying refers to examining the element at the head without
    removing it from the queue.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个上下文中，查询是指检查队列头部的元素，而不从队列中移除它。
- en: '`element()`'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`element()`'
- en: This `Queue` method returns the element at the head of the queue but does not
    remove that element from the queue. It throws `NoSuchElementException` if the
    queue is empty.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 此 `Queue` 方法返回队列头部的元素，但不从队列中移除该元素。如果队列为空，则抛出 `NoSuchElementException` 异常。
- en: '`peek()`'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`peek()`'
- en: This `Queue` method is like `element` but returns `null` if the queue is empty.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 此 `Queue` 方法类似于 `element`，但如果队列为空则返回 `null`。
- en: Note
  id: totrans-159
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: When using queues, it is usually a good idea to pick one particular style of
    how to deal with a failure. For example, if you want operations to block until
    they succeed, then choose `put()` and `take()`. If you want to examine the return
    code of a method to see if the queue operation succeeded, then `offer()` and `poll()`
    are appropriate choices.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用队列时，通常建议选择一种处理失败的特定方式。例如，如果希望操作阻塞直到成功，则选择 `put()` 和 `take()`。如果想要通过方法的返回代码来检查队列操作是否成功，则适合使用
    `offer()` 和 `poll()`。
- en: The `LinkedList` class also implements `Queue`. It provides unbounded FIFO ordering,
    and insertion and removal operations require constant time. `LinkedList` allows
    `null` elements, although their use is discouraged when the list is being used
    as a queue.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`LinkedList` 类也实现了 `Queue`。它提供了无界的 FIFO 排序，插入和删除操作需要常数时间。尽管 `LinkedList` 允许使用
    `null` 元素，但在列表用作队列时不建议使用它们。'
- en: There are two other `Queue` implementations in the `java.util` package. `PriorityQueue`
    orders its elements according to a `Comparator` or orders `Comparable` elements
    according to the order defined by their `compareTo()` methods. The head of a `PriorityQueue`
    is always the smallest element according to the defined ordering. Finally, `ArrayDeque`
    is a double-ended queue implementation. It is often used when a stack implementation
    is needed.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util` 包中还有另外两个 `Queue` 实现。`PriorityQueue` 根据 `Comparator` 或者根据元素的 `compareTo()`
    方法定义的顺序对其元素进行排序。`PriorityQueue` 的头部始终是根据定义顺序的最小元素。最后，`ArrayDeque` 是双端队列实现，在需要栈实现时经常使用。'
- en: The `java.util.concurrent` package also contains a number of `BlockingQueue`
    implementations, which are designed for use in multithreaded programing style;
    advanced versions that can remove the need for synchronized methods are available.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util.concurrent` 包中还包含多个 `BlockingQueue` 实现，专为多线程编程设计；提供了高级版本，可以避免使用同步方法。'
- en: A full discussion of `java.util.concurrent` is unfortunately outside the scope
    of this book. The interested reader should refer to *Java Concurrency in Practice*
    by Brian Goetz et al. (Addison-Wesley, 2006).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 遗憾的是，本书不涵盖对 `java.util.concurrent` 的全面讨论。有兴趣的读者应参考 Brian Goetz 等人的《Java并发实战》（Addison-Wesley,
    2006）。
- en: Utility Methods
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实用方法
- en: 'The `java.util.Collections` class is home to quite a few static utility methods
    designed for use with collections. One important group of these methods is the
    collection *wrapper* methods: they return a special-purpose collection wrapped
    around a collection you specify. The purpose of the wrapper collection is to wrap
    additional functionality around a collection that does not provide it itself.
    Wrappers exist to provide thread-safety, write protection, and runtime type checking.
    Wrapper collections are always *backed by* the original collection, which means
    that the methods of the wrapper simply dispatch to the equivalent methods of the
    wrapped collection. This means that changes made to the collection through the
    wrapper are visible through the wrapped collection and vice versa.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util.Collections` 类拥有许多专为集合设计的静态实用方法。其中一个重要的方法组是集合 *包装* 方法：它们返回围绕您指定的集合包装的特殊目的集合。包装集合的目的是在不提供自身的集合周围提供额外的功能。包装器用于提供线程安全性、写保护和运行时类型检查。包装集合始终是
    *由* 原始集合支持的，这意味着包装器的方法只是将操作分派到包装的集合的等效方法。这意味着通过包装器对集合进行的更改会通过包装的集合反映出来，反之亦然。'
- en: 'The first set of wrapper methods provides threadsafe wrappers around collections.
    Except for the legacy classes `Vector` and `Hashtable`, the collection implementations
    in `java.util` do not have `synchronized` methods and are not protected against
    concurrent access by multiple threads. If you need threadsafe collections and
    don’t mind the additional overhead of synchronization, create them with code like
    this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 第一组包装方法提供了围绕集合的线程安全包装器。除了遗留类 `Vector` 和 `Hashtable` 外，`java.util` 中的集合实现没有 `synchronized`
    方法，并且不能受到多线程并发访问的保护。如果您需要线程安全的集合并且不介意额外的同步开销，可以使用类似以下代码创建它们：
- en: '[PRE15]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'A second set of wrapper methods provides collection objects through which the
    underlying collection cannot be modified. They return a read-only view of a collection:
    an `UnsupportedOperationException` will result from changing the collection’s
    content. These wrappers are useful when you must pass a collection to a method
    that must not be allowed to modify or mutate the content of the collection in
    any way:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 第二组包装方法提供了通过这些包装对象无法修改底层集合的集合对象。它们返回集合的只读视图：如果更改集合的内容将导致 `UnsupportedOperationException`。当您必须传递一个不允许以任何方式修改或变异集合内容的方法时，这些包装器非常有用：
- en: '[PRE16]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `java.util.Collections` class also defines methods to operate on collections.
    Some of the most notable are methods to sort and search the elements of collections:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util.Collections` 类还定义了操作集合的方法。其中一些最显著的是对集合元素进行排序和搜索的方法：'
- en: '[PRE17]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here are some other interesting `Collections` methods:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一些其他有趣的 `Collections` 方法：
- en: '[PRE18]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: It is a good idea to familiarize yourself fully with the utility methods in
    `Collections` and `Arrays`, as they can save you from writing your own implementation
    of a common task.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉 `Collections` 和 `Arrays` 中的实用方法是一个好主意，因为它们可以避免您编写自己的常见任务实现。
- en: Special-case collections
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 特殊情况集合
- en: In addition to its wrapper methods, the `java.util.Collections` class also defines
    utility methods for creating immutable collection instances that contain a single
    element and other methods for creating empty collections. `singleton()`, `singletonList()`,
    and `singletonMap()` return immutable `Set`, `List`, and `Map` objects that contain
    a single specified object or a single key/value pair. These methods are useful
    when you need to pass a single object to a method that expects a collection.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 除了其包装方法外，`java.util.Collections` 类还定义了用于创建包含单个元素的不可变集合实例以及用于创建空集合的实用方法。`singleton()`,
    `singletonList()` 和 `singletonMap()` 返回不可变的 `Set`, `List` 和 `Map` 对象，其中包含单个指定对象或单个键值对。当您需要向期望收集的方法传递单个对象时，这些方法非常有用。
- en: 'The `Collections` class also includes methods that return empty collections.
    If you are writing a method that returns a collection, it is usually best to handle
    the no-values-to-return case by returning an empty collection instead of a special-case
    value like `null`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`Collections` 类还包括返回空集合的方法。如果您正在编写一个返回集合的方法，通常最好通过返回空集合而不是像 `null` 这样的特殊情况值来处理没有值可返回的情况：'
- en: '[PRE19]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Since Java 9, though, these methods are frequently replaced by the `of()` methods
    on the `Set`, `List` and `Map` interfaces.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 自 Java 9 以来，这些方法经常被 `Set`, `List` 和 `Map` 接口上的 `of()` 方法所取代。
- en: '[PRE20]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: These return immutable versions of their type and may also take elements through
    the same method.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法返回它们类型的不可变版本，也可能通过相同的方法获取元素。
- en: '[PRE21]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Finally, `nCopies()` returns an immutable `List` that contains a specified
    number of copies of a single specified object:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`nCopies()` 返回一个包含指定数量副本的不可变 `List`：
- en: '[PRE22]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Arrays and Helper Methods
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组和辅助方法
- en: 'Arrays of objects and collections serve similar purposes. It is possible to
    convert from one to the other:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 对象数组和集合提供类似的功能。可以从一个转换到另一个：
- en: '[PRE23]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In addition, there are a number of useful helper methods for working with Java’s
    arrays, which are included here for completeness.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一些有用的辅助方法来处理 Java 的数组，这些方法在这里完整列出。
- en: 'The `java.lang.System` class defines an `arraycopy()` method that is useful
    for copying specified elements in one array to a specified position in a second
    array. The second array must be the same type as the first, and it can even be
    the same array:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.lang.System` 类定义了一个 `arraycopy()` 方法，用于将一个数组中的指定元素复制到第二个数组的指定位置。第二个数组必须与第一个数组类型相同，甚至可以是同一个数组：'
- en: '[PRE24]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'There are also a number of useful static methods defined on the `Arrays` class:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`Arrays` 类还定义了许多有用的静态方法：'
- en: '[PRE25]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Arrays can be treated and manipulated as objects in Java. Given an arbitrary
    object `o`, you can use code such as the following to find out if the object is
    an array and, if so, what type of array it is:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 中，可以将数组视为对象并进行操作。对于任意对象 `o`，可以使用以下代码来查找该对象是否为数组，以及如果是，则是什么类型的数组：
- en: '[PRE26]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Java Streams and Lambda Expressions
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java 流与 Lambda 表达式
- en: One of the major reasons for introducing lambda expressions in Java 8 was to
    facilitate the overhaul of the Collections API to allow more modern programming
    styles to be used by Java developers. Until the release of Java 8, the handling
    of data structures in Java looked a little bit dated. Many languages now support
    a programming style that allows collections to be treated as a whole, rather than
    requiring them to be broken apart and iterated over.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 引入 Java 8 中 lambda 表达式的一个主要原因是促进对集合 API 的重大改革，以允许 Java 开发者使用更现代的编程风格。直到 Java
    8 发布之前，Java 中处理数据结构的方式看起来有些过时。许多现代语言现在支持一种编程风格，允许将集合作为整体来处理，而不是分解和迭代它们。
- en: In fact, many Java developers had taken to using alternative data structures
    libraries to achieve some of the expressivity and productivity they felt was lacking
    in the Collections API. The key to upgrading the APIs was to introduce new classes
    and methods that would accept lambda expressions as parameters—to define *what*
    needed to be done, rather than precisely *how*. This is a conception of programming
    that comes from the functional style.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，许多 Java 开发者已经开始使用替代的数据结构库来实现他们认为在集合 API 中缺乏的表达性和生产力。更新 API 的关键在于引入新的类和方法，这些方法可以接受
    lambda 表达式作为参数，以定义需要执行的*内容*，而不是具体的*方式*。这是功能风格编程的概念。
- en: The introduction of the functional collections—which are called *Java Streams*
    to make clear their divergence from the older collections approach—is an important
    step forward. A stream can be created from a collection simply by calling the
    `stream()` method on an existing collection.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 引入功能性集合（称为*Java 流*，以明确其与旧集合方法的区别）是迈出的重要一步。可以通过在现有集合上调用 `stream()` 方法来创建流。
- en: Note
  id: totrans-200
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The desire to add new methods to existing interfaces was directly responsible
    for the new language feature referred to as *default methods* (see [“Default Methods”](ch04.xhtml#javanut8-CHP-4-SECT-1.7)
    for more details). Without this new mechanism, older implementations of the Collections
    interfaces would fail to compile under Java 8 and would fail to link if loaded
    into a Java 8 runtime.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 想要向现有接口添加新方法，这直接导致了一种称为*默认方法*的新语言特性的引入（详见[“默认方法”](ch04.xhtml#javanut8-CHP-4-SECT-1.7)以获取更多详情）。如果没有这种新机制，Java
    8 之前的集合接口的旧实现将无法在 Java 8 下编译，并且如果加载到 Java 8 运行时中，则无法连接。
- en: However, the arrival of the Streams API does not erase history. The Collections
    API is deeply embedded in the Java world, and it is not functional. Java’s commitment
    to backward compatibility and to a rigid language grammar means that the Collections
    will never go away. Java code, even when written in a functional style, will never
    be entirely free of boilerplate and will never have the concise syntax that we
    see in languages such as Haskell or Scala.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，流API的到来并没有抹去历史。集合API深深嵌入在Java世界中，它不是功能性的。Java对向后兼容性和严格的语言语法的承诺意味着集合永远不会消失。即使以功能风格编写的Java代码也永远不会完全摆脱样板代码，并且永远不会具有我们在Haskell或Scala等语言中看到的简洁语法。
- en: 'This is part of the inevitable trade-off in language design—Java has retrofitted
    functional capabilities on top of an imperative design and base. This is not the
    same as designing for functional programming from the ground up. A more important
    question is: Are the functional capabilities supplied from Java 8 onward what
    working programmers need to build their applications?'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这是语言设计中不可避免的权衡之一——Java在命令式设计和基础上添加了功能性能力。这与从头开始为函数式编程设计不同。更重要的问题是：从Java 8开始提供的功能性能力是否符合工作程序员构建应用程序的需要？
- en: The rapid adoption of Java 8 over previous versions and the community reaction
    seem to indicate that the new features have been a success and have provided what
    the ecosystem was looking for.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8相对于先前版本的快速采用以及社区的反应似乎表明新特性取得了成功，并提供了生态系统所期待的功能。
- en: In this section, we will introduce the use of Java streams and lambda expressions
    in the Java Collections. For a fuller treatment, see [*Java 8 Lambdas*](http://shop.oreilly.com/product/0636920030713.do)
    by Richard Warburton (O’Reilly).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍Java集合中使用Java流（Java streams）和lambda表达式的方法。有关更详尽的内容，请参阅[*Java 8 Lambdas*](http://shop.oreilly.com/product/0636920030713.do)（Richard
    Warburton著，O'Reilly出版社）。
- en: Functional Approaches
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 功能性方法
- en: The approach that Java 8 Streams wished to enable was derived from functional
    programming languages and styles. We met some of these key patterns in [“Functional
    Programming”](ch04.xhtml#javanut8-CHP-4-SECT-4.3)—let’s reintroduce them and look
    at some examples of each.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8 Streams希望启用的方法来源于功能性编程语言和风格。我们在[“函数式编程”](ch04.xhtml#javanut8-CHP-4-SECT-4.3)中遇到了一些关键模式——让我们重新介绍它们，并查看每个的一些示例。
- en: Filter
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 过滤器
- en: The filter idiom applies a piece of code returning either true or false (known
    as a predicate) to each element in a collection. A new collection is built consisting
    of the elements that “passed the test” (i.e., the bit of code returned `true`
    when applied to the element).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤器模式应用了一个返回`true`或`false`（称为谓词）的代码片段到集合中的每个元素上。构建一个新的集合，其中包含“通过测试”的元素（即应用于元素时代码返回`true`的部分）。
- en: 'For example, let’s look at some code to work with a collection of cats and
    pick out the tigers:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们看一些用于处理猫集合并挑选出老虎的代码：
- en: '[PRE27]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The key piece is the call to `filter()`, which takes a lambda expression. The
    lambda takes in a string and returns a Boolean value. This is applied over the
    whole collection `cats`, and a new collection is created, which contains only
    tigers (however they were capitalized).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 关键部分是调用`filter()`，它接受一个lambda表达式。Lambda接受一个字符串并返回一个布尔值。这被应用于整个`cats`集合，并创建一个只包含老虎（无论它们是否大写）的新集合。
- en: The `filter()` method takes in an instance of the `Predicate` interface, from
    the package `java.util.function`. This is a functional interface, with only a
    single nondefault method, and so is a perfect fit for a lambda expression.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter()`方法接受一个来自`java.util.function`包的`Predicate`接口的实例。这是一个功能性接口，只有一个非默认方法，因此非常适合lambda表达式。'
- en: Note the final call to `collect()`; this is an essential part of the API and
    is used to “gather up” the results at the end of the lambda operations. We’ll
    discuss it in more detail in the next section.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 注意最终调用的`collect()`；这是API的一个重要部分，用于在lambda操作结束时“收集”结果。我们将在下一节中更详细地讨论它。
- en: '`Predicate` has some other very useful default methods, such as for constructing
    combined predicates by using logic operations. For example, if the tigers want
    to admit leopards into their group, this can be represented by using the `or()`
    method:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`Predicate`还具有一些其他非常有用的默认方法，例如通过逻辑操作构建组合谓词。例如，如果老虎们想要允许豹子加入他们的团体，可以使用`or()`方法表示：'
- en: '[PRE28]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note that it’s much clearer if the `Predicate<String>` object `p` is explicitly
    created, so that the defaulted `or()` method can be called on it and the second
    lambda expression (which will also be automatically converted to a `Predicate<String>`)
    passed to it.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果明确创建`Predicate<String>`对象`p`，那么默认的`or()`方法就可以在其上调用，并且第二个lambda表达式（也将自动转换为`Predicate<String>`）将被传递给它。
- en: Map
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Map
- en: The map idiom makes use of the interface `Function<T, R>` in the package `java.util.function`.
    Like `Predicate<T>`, this is a functional interface and so only has one nondefaulted
    method, `apply()`. The map idiom is about transforming one stream into a new stream,
    where the new stream potentially has different types and values than the original.
    This shows up in the API as the fact that `Function<T, R>` has two separate type
    parameters. The name of the type parameter `R` indicates that this represents
    the return type of the function.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这种映射范式利用了`java.util.function`包中的接口`Function<T, R>`。与`Predicate<T>`类似，这是一个功能接口，因此只有一个非默认方法`apply()`。映射范式是关于将一个流转换为一个新流，新流可能具有与原始流不同的类型和值。这在API中显示为`Function<T,
    R>`有两个单独的类型参数。类型参数`R`的名称表示这表示函数的返回类型。
- en: 'Let’s look at a code example that uses `map()`:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个使用`map()`的代码示例：
- en: '[PRE29]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This is called upon the previous `cats` variable (which is a `Stream<String>`)
    and applies the function `String::length` (a method reference) to each string
    in turn. The result is a new stream—but of `Integer` this time. We turn that stream
    into a `List` with the `toList()` method. Note that unlike the collections API,
    the `map()` method does not mutate the stream in place but returns a new value.
    This is key to the functional style as used here.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对先前的`cats`变量（这是一个`Stream<String>`）调用的，并将函数`String::length`（方法引用）应用于每个字符串。结果是一个新的流，但这次是`Integer`。我们使用`toList()`方法将该流转换为`List`。请注意，与集合API不同，`map()`方法不会就地变异流，而是返回一个新值。这对于此处使用的功能样式至关重要。
- en: forEach
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: forEach
- en: The map and filter idioms are used to create one collection from another. In
    languages that are strongly functional, this would be combined with requiring
    that the original collection was not affected by the body of the lambda as it
    touched each element. In computer science terms, this means that the lambda body
    should be “side effect free.”
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 映射和过滤范式用于从另一个集合创建一个集合。在强烈的函数式语言中，这将与要求原始集合不受lambda主体影响而被合并。从计算机科学的角度来看，这意味着lambda主体应该是“无副作用”的。
- en: 'In Java, of course, we often need to deal with mutable data, so the Streams
    API provides a way to mutate elements as the collection is traversed—the `forEach()`
    method. This takes an argument of type `Consumer<T>`, which is a functional interface
    that is expected to operate by side effects (although whether it actually mutates
    the data or not is of lesser importance). This means that the signature of lambdas
    that can be converted to `Consumer<T>` is `(T t) → void`. Let’s look at a quick
    example of `forEach()`:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在Java中，我们经常需要处理可变数据，因此Streams API提供了一种在遍历集合时修改元素的方法——`forEach()`方法。它接受一个类型为`Consumer<T>`的参数，这是一个预期通过副作用操作的功能接口（尽管它实际上是否改变数据不太重要）。这意味着可以转换为`Consumer<T>`的lambda的签名是`(T
    t) → void`。让我们看一个`forEach()`的快速示例：
- en: '[PRE30]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In this example, we are simply printing out each member of the collection.
    However, we’re doing so by using a special kind of method reference as a lambda
    expression. This type of method reference is called a *bound method reference*,
    as it involves a specific object (in this case, the object `System.out`, which
    is a static public field of `System`). This is equivalent to the lambda expression:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们仅仅打印出集合的每个成员。但是，我们通过使用一种特殊类型的方法引用作为lambda表达式来实现。这种类型的方法引用称为*绑定方法引用*，因为它涉及特定对象（在本例中为`System.out`对象，这是`System`的静态公共字段）。这相当于lambda表达式：
- en: '[PRE31]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This is of course eligible for conversion to an instance of a type that implements
    `Consumer<? super String>` as required by the method signature.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这可以转换为实现`Consumer<? super String>`的类型的实例，如方法签名所需。
- en: Warning
  id: totrans-230
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Nothing prevents a `map()` or `filter()` call from mutating elements. It is
    only a convention that they must not mutate, but it’s one that every Java programmer
    should adhere to.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么能阻止`map()`或`filter()`调用改变元素。只是约定它们不能改变元素，但这是每个Java程序员都应该遵守的约定。
- en: There’s one final functional technique that we should look at before we move
    on. This is the practice of aggregating a collection down to a single value, and
    it’s the subject of our next section.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，我们应该看看一个最后的函数式技术。这是将集合聚合到单个值的做法，也是我们下一节的主题。
- en: Reduce
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 归约
- en: Let’s look at the `reduce()` method. This implements the reduce idiom, which
    is really a family of similar and related operations, some referred to as fold,
    or aggregation, operations.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`reduce()`方法。这实现了归约模式，这实际上是一组相似和相关的操作，有些被称为折叠或聚合操作。
- en: 'In Java, `reduce()` takes two arguments. These are the initial value, which
    is often called the identity (or zero), and a function to apply step by step.
    This function is of type `BinaryOperator<T>`, which is another functional interface
    that takes in two arguments of the same type and returns another value of that
    type. This second argument to `reduce()` is a two-argument lambda. `reduce()`
    is defined in the `javadoc` like this:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，`reduce()`接受两个参数。这些是初始值，通常称为标识（或零），以及一个逐步应用的函数。这个函数的类型是`BinaryOperator<T>`，这是另一个接受两个相同类型参数并返回该类型值的函数式接口。`reduce()`的第二个参数是一个二参数的lambda。`reduce()`在`javadoc`中像这样定义：
- en: '[PRE32]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The easy way to think about the second argument to `reduce()` is that it creates
    a “running total” as it runs over the stream. It starts by combining the identity
    with the first element of the stream to produce the first result, then combines
    that result with the second element of the stream, and so on.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，`reduce()`的第二个参数可以想象成在流运行时创建一个“运行总和”。它从将标识元素与流的第一个元素组合起来产生第一个结果开始，然后将该结果与流的第二个元素组合，依此类推。
- en: 'It can help to imagine that the implementation of `reduce()` works a bit like
    this:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 可以想象，`reduce()`的实现工作起来有点像这样：
- en: '[PRE33]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note
  id: totrans-240
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: In practice, implementations of `reduce()` can be more sophisticated than these
    and can even execute in parallel if the data structure and operations are amenable
    to this.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`reduce()`的实现可以比这更复杂，并且如果数据结构和操作适合，甚至可以并行执行。
- en: 'Let’s look at a quick example of a `reduce()` and calculate the sum of some
    primes:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一个`reduce()`的例子，并计算一些质数的总和：
- en: '[PRE34]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In all of the examples we’ve met in this section, you may have noticed the presence
    of a `stream()` method call on the `List` instance. This is part of the evolution
    of Java Collections—it was originally chosen partly out of necessity but has proved
    to be an excellent abstraction. Let’s move on to discuss the Streams API in more
    detail.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中我们遇到的所有示例中，您可能已经注意到在`List`实例上调用了`stream()`方法。这是Java集合演变的一部分——最初部分地出于必要性选择，但已被证明是一个极好的抽象。让我们继续详细讨论流
    API。
- en: The Streams API
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 流 API
- en: The fundamental issue that caused the Java library designers to introduce the
    Streams API was the large number of implementations of the core collections interfaces
    present in the wild. As these implementations predate Java 8 and lambdas, they
    would not have any of the methods corresponding to the new functional operations.
    Worse still, as method names such as `map()` and `filter()` have never been part
    of the interface of the Collections, implementations may already have methods
    with those names.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 引起Java库设计者引入流 API 的根本问题是现有的核心集合接口实现的数量庞大。由于这些实现是在Java 8和lambda之前存在的，它们不会具有任何对应于新的函数式操作的方法。更糟糕的是，像`map()`和`filter()`这样的方法名称从未作为集合接口的一部分，可能已经存在于实现中。
- en: To work around this problem, a new abstraction called a `Stream` was introduced.
    The idea is that a `Stream` object can be generated from a collection object via
    the `stream()` method. This `Stream` type, being new and under the control of
    the library designers, is then guaranteed to be free of collisions. This then
    mitigates the risk of clash, as only Collections implementations that contained
    a `stream()` method would be affected.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，引入了一个称为`Stream`的新抽象。其思想是通过`stream()`方法可以从集合对象生成一个`Stream`对象。这种`Stream`类型是新的，并且受到库设计者的控制，因此可以确保没有冲突。这进一步减少了冲突的风险，因为只有包含`stream()`方法的集合实现才会受到影响。
- en: A `Stream` object plays a similar role to an `Iterator` in the new approach
    to collections code. The overall idea is for the developer to build up a sequence
    (or “pipeline”) of operations (such as `map`, `filter`, or `reduce`) that need
    to be applied to the collection as a whole. The actual content of the operations
    will usually be expressed as a lambda expression for each operation.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stream` 对象在新的集合代码方法中扮演与 `Iterator` 类似的角色。总体思路是让开发人员建立一个操作序列（或“管道”），对整个集合应用操作（如
    `map`、`filter` 或 `reduce`）。操作的实际内容通常作为每个操作的 Lambda 表达式来表示。'
- en: 'At the end of the pipeline, the results usually need to be gathered up, or
    “materialized,” either as a new collection or another value. This is done either
    by using a `Collector` or by finishing the pipeline with a “terminal method” such
    as `reduce()` that returns an actual value, rather than another stream. Overall,
    the new approach to collections looks like this:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在管道的末端，通常需要收集或“具现化”结果，要么作为新的集合，要么作为另一个值。这可以通过使用 `Collector` 或通过使用像 `reduce()`
    这样的“终端方法”来完成，后者返回实际值而不是另一个流。总体而言，新的集合方法看起来是这样的：
- en: '[PRE35]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `Stream` class behaves as a sequence of elements that are accessed one at
    a time (although there are some types of streams that support parallel access
    and can be used to process larger collections in a naturally multithreaded way).
    In a similar way to an `Iterator`, the `Stream` is used to take each item in turn.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stream` 类表现为一系列元素的序列，可以逐个访问（尽管有些类型的流支持并行访问，并且可以用于以自然多线程方式处理更大的集合）。类似于 `Iterator`，`Stream`
    用于逐个获取每个项目。'
- en: As is usual for generic classes in Java, `Stream` is parameterized by a reference
    type. However, in many cases, we actually want streams of primitive types, especially
    ints and doubles. We cannot have `Stream<int>`, so instead in `java.util.stream`
    there are special (nongeneric) classes such as `IntStream` and `DoubleStream`.
    These are known as *primitive specializations* of the `Stream` class and have
    APIs that are very similar to the general `Stream` methods, except that they use
    primitives where appropriate.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Java 中的通用类一样，`Stream` 是由引用类型参数化的。然而，在许多情况下，我们实际上希望使用基本类型的流，尤其是 `int` 和 `double`。我们不能有
    `Stream<int>`，因此在 `java.util.stream` 中有特殊的（非泛型）类，如 `IntStream` 和 `DoubleStream`。这些被称为
    `Stream` 类的*原始特化*，它们的 API 与一般 `Stream` 方法非常相似，只是在适当的地方使用原始类型。
- en: Lazy evaluation
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 惰性求值
- en: In fact, streams are more general than iterators (or even collections), as streams
    do not manage storage for data. In earlier versions of Java, there was always
    a presumption that all of the elements of a collection existed (usually in memory).
    It was possible to work around this in a limited way by insisting on the use of
    iterators everywhere, as well as by having the iterators construct elements on
    the fly. However, this was neither very convenient nor that common.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，流比迭代器（甚至集合）更为一般化，因为流不管理数据的存储。在 Java 的早期版本中，通常假定集合的所有元素都存在（通常在内存中）。可以通过坚持到处都使用迭代器以及让迭代器在需要时动态构造元素的方式来部分地解决这个问题。然而，这既不是非常方便，也不是很常见。
- en: 'By contrast, streams are an abstraction for managing data, rather than being
    concerned with the details of storage. This makes it possible to handle more subtle
    data structures than just finite collections. For example, infinite streams can
    easily be represented by the `Stream` interface, and they can be used as a way,
    for example, to handle the set of all square numbers. Let’s see how we could accomplish
    this using a `Stream`:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，流是一种管理数据的抽象，而不是关注存储细节。这使得可以处理比简单有限集合更为复杂的数据结构。例如，无限流可以轻松地用 `Stream` 接口表示，并且它们可以作为处理所有平方数集合的一种方式。让我们看看如何使用
    `Stream` 完成这个任务：
- en: '[PRE36]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Because our list of possible values is infinite, we must adopt a model in which
    elements do not all exist ahead of time. Essentially, a bit of code must return
    the next element as we demand it. The key technique used to accomplish this is
    *lazy evaluation*.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们的可能值列表是无限的，所以我们必须采用一种模型，其中元素不会提前全部存在。基本上，一段代码必须在我们需要时返回下一个元素。用于实现这一点的关键技术是*惰性求值*。
- en: Note
  id: totrans-258
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Lazy evaluation is a big change for Java, as until JDK 8 the value of an expression
    was always computed as soon as it was assigned to a variable (or passed into a
    method). This familiar model, where values are computed immediately, is called
    “eager evaluation” and it is the default behavior for evaluation of expressions
    in most mainstream programming languages.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see this lazy evaluation in action in our example above if we modify
    `getAsInt()` slightly to provide output actively when it is called:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'When this modified program is run, we’ll see output that shows each `getAsInt()`
    call immediately followed by the use of that value in the `for` loop:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: One significant consequence of modeling the infinite stream is that methods
    like `collect()` won’t work. This is because we can’t materialize the whole stream
    to a collection (we would run out of memory before we created the infinite amount
    of objects we would need).
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: 'Even when a stream isn’t infinite, it’s important to recognize what parts of
    the evaluation are lazy. For instance, the following code that tries to show us
    diagnostic information during a `map` operation doesn’t actually yield any output:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Only once we provide a terminal action such as `collect()` or `toList()` is
    our `map()` lambda actually executed.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: Recognizing which intermediate results are lazy in their evaluation is a topic
    Java developers should be mindful of when working with the Stream API. The more
    complicated implementation details, though, fall to library writers rather than
    users of streams.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: While the combination of `filter`, `map`, and `reduce` can accomplish almost
    any stream-related task we’re after, it isn’t always the most convenient API.
    There are a wide variety of additional methods that build on top of these primitives
    to give us a richer vocabulary to work with stream.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: Further filtering
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A common place where working with streams benefits from more elaborate methods
    is filtering. A number of methods on the `Stream` interface allow more expressive
    descriptions of how we want to trim our streams for consumption:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Matching in streams
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another typical operation is to ask questions of an entire stream of elements,
    such as whether all (or none) match a given predicate, or alternatively if there’s
    any single element that matches:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Flattening
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once we’ve started down the path of modeling our data as streams, it’s not
    unusual to find yet another layer of streams beneath. For instance, if we’re processing
    multiple lines of text and wanted to gather the set of words from the entire block,
    we might reach first for code like this:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This isn’t quite the plain word list we’re after, though. We have an extra layer
    of nesting, a `Stream<String[]>` instead of `Stream<String>`.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: The `flatMap()` method is designed for exactly these situations. For each element
    in our original stream, the lambda provided to `flatMap()` returns not an individual
    value but another `Stream`. Then `flatMap()` gathers those multiple streams and
    joins them, flattening to a single stream of the contained type.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example `split()` gives us arrays, which we can trivially convert to
    streams. From there, `flatMap()` will do the work of turning those multiple streams
    into the single stream of words we were after:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: From Streams to Collections
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Defining a separate `Stream` interface was a pragmatic way to enable newer
    styles of development with Java while not breaking existing code. However, sometimes
    you still need the standard Java Collections, whether to pass to another API or
    for functionality that isn’t present in streams. For the most common cases of
    returning a simple `List` or array of elements, the methods are provided directly
    on the `Stream` interface:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Transforming a stream into a nonstream collection or other object is primarily
    performed through the `collect()` method. This method receives an instance of
    the `Collector` interface, allowing for a world of possible ways to gather up
    our stream results without adding to the `Stream` interface itself.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: 'Standard implementations for a variety of collectors are available on the `Collectors`
    class as static methods. For instance, we can turn our stream into any of our
    normal collection types:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Unlike `Stream#toList()`, all of these options return a modifiable version of
    their collection type. `Collectors` also provides specific methods if you want
    to return an unmodifiable or immutable version. They follow a naming convention
    `toUnmodifiableX()` where `X` is the collection type as seen above.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: 'A final variation on gathering collections is when you want to group the elements
    by some property. In this example, we want to group the numbers by their first
    digit:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: From Streams to values
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We don’t always want to retrieve collections from our streams—sometimes we need
    a single value, much like the `reduce()` method gave us.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '`Stream` has a few built-in methods for the most common values we might want
    from our stream:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The `collect()` method isn’t limited to returning collection types either.
    A wide variety of result gathering methods are available from `Collectors` to
    aid in common calculations, particularly on streams of numbers. These methods
    all require a function for turning the incoming item from the stream to a number,
    which allows it to be easily used with objects as well as primitive values:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Similar methods are available for long and double types in addition to integers.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: A final way of getting a result from a stream helps us with strings. A classic
    issue is turning a series of smaller strings into one larger delimited string.
    Streams make this quite simple.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Streams utility default methods
  id: totrans-301
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Java Streams took the opportunity to introduce a number of new methods to the
    Java Collections libraries. Using default methods, it was possible to add new
    methods to the Collections without breaking backward compatibility.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: Java Streams利用机会向Java集合库引入了许多新方法。通过默认方法，可以向集合添加新方法而不会破坏向后兼容性。
- en: Some of these methods are *scaffold methods* for creating Streams from our existing
    collections. These include methods such as `Collection::stream`, `Collection::parallelStream`,
    and `Collection::spliterator` (which has specialized forms `List::spliterator`
    and `Set::spliterator`).
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法中，有些是从我们现有的集合中创建流的**脚手架方法**。这些方法包括`Collection::stream`、`Collection::parallelStream`以及`Collection::spliterator`（其具有专门的形式`List::spliterator`和`Set::spliterator`）。
- en: 'Other methods provide shortcuts to functionality that existed elsewhere in
    previous versions. For instance, `List::sort` method essentially delegates to
    the more cumbersome version already available on the `Collections` class:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 其他方法提供了先前版本中存在的功能的快捷方式。例如，`List::sort`方法基本上委托给`Collections`类上已经可用的更繁琐的版本：
- en: '[PRE50]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The remaining methods provide additional functional techniques using the interfaces
    of `java.util.function`:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的方法利用`java.util.function`接口提供了额外的功能技术：
- en: '`Collection::removeIf`'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '`Collection::removeIf`'
- en: This method takes a `Predicate` and iterates internally over the collection,
    removing any elements that satisfy the predicate object.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法接受一个`Predicate`并在集合内部进行迭代，移除满足谓词对象的任何元素。
- en: '`Map::forEach`'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '`Map::forEach`'
- en: The single argument to this method is a lambda expression that takes two arguments
    (one of the key’s type and one of the value’s type) and returns `void`. This is
    converted to an instance of `BiConsumer` and applied to each key/value pair in
    the map.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法的单个参数是一个接受两个参数（键的类型和值的类型之一）并返回`void`的lambda表达式。这将转换为`BiConsumer`的实例，并应用于映射中的每个键值对。
- en: '`Map::computeIfAbsent`'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '`Map::computeIfAbsent`'
- en: This takes a key and a lambda expression that maps the key type to the value
    type. If the specified key (first parameter) is not present in the map, then it
    computes a default value by using the lambda expression and puts it in the map.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要一个键和一个将键类型映射到值类型的lambda表达式。如果映射中不存在指定的键（第一个参数），则使用lambda表达式计算默认值并将其放入映射中。
- en: (See also `Map::computeIfPresent`, `Map::compute`, and `Map::merge`.)
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: （还参见`Map::computeIfPresent`、`Map::compute`和`Map::merge`。）
- en: Summary
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we’ve met the Java Collections libraries and seen how to start
    working with Java’s implementations of fundamental and classic data structures.
    We’ve met the general `Collection` interface, as well as `List`, `Set`, and `Map`.
    We’ve seen the original, iterative way of handling collections and introduced
    the new Java Streams style, based on ideas from fundamental programming. In the
    Streams API, we’ve seen how the new approach is more general and can express more
    subtle programming concepts than the classic approach.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经了解了Java集合库，并看到了如何开始使用Java的基本和经典数据结构的实现。我们遇到了通用的`Collection`接口，以及`List`、`Set`和`Map`。我们看到了处理集合的原始迭代方式，并引入了基于基础编程思想的新Java
    Streams风格。在Streams API中，我们看到新方法比经典方法更加通用，可以表达比较微妙的编程概念。
- en: We’ve only scratched the surface—the Streams API is a fundamental shift in how
    Java code is written and architected. There are inherent design limitations in
    how far the ideals of functional programming can be implemented in Java. Having
    said that, the possibility that Streams represents “just enough functional programming”
    is compelling.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是触及了表面——Streams API是Java代码编写和架构中的根本性转变。在Java中，函数式编程理念的实现存在设计上的固有限制。尽管如此，Streams代表“恰好足够的函数式编程”的可能性非常有吸引力。
- en: Let’s move on. In the next chapter, we’ll continue looking at data, and common
    tasks like text processing, handling numeric data, and Java 8’s new date and time
    libraries.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续吧。在下一章中，我们将继续探讨数据，以及如文本处理、处理数值数据和Java 8的新日期和时间库等常见任务。
