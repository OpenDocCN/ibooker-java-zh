- en: Chapter 1\. Reactive in a Nutshell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Reactive* is an overloaded word. You may have searched for *reactive* with
    a search engine to understand what it’s all about. If you haven’t, no worries—you’ve
    saved yourself a lot of confusion. There are many *reactive things*: Reactive
    Systems, Reactive Programming, Reactive extensions, Reactive messaging. Every
    day new ones pop up. Are all these “reactives” the same reactive? Are they different?'
  prefs: []
  type: TYPE_NORMAL
- en: These are the questions we are going to answer in this chapter. We are going
    to sneak a peek at the reactive landscape to identify and help you understand
    the various nuances of *reactive*, what they mean, the concepts associated with
    them, and how they relate to one another. Because yes, without spoiling too much,
    all these “reactives” are related.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As noted in the preface, we use the noun *Reactive*, with an uppercase *R*,
    to aggregate all the various facets of the reactive landscape, such as reactive
    programming, reactive systems, reactive streams, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: What Do We Mean by Reactive?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s start at the beginning. Forget about software and IT for a few minutes,
    and use an old-fashioned approach. If we look for *reactive* in the [*Oxford English
    Dictionary*](https://oreil.ly/nL7Fp), we find the following definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '*reactive* (adjective)'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Showing a response to a stimulus. 1.1 Acting in response to a situation rather
    than creating or controlling it. 1.2 Having a tendency to react chemically. 1.3
    (Physiology) Showing an immune response to a specific antigen. 1.4 (Of a disease
    or illness) Caused by a reaction to something. 1.5 (Physics) Relating to reactance.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Among these definitions, two are relevant in our context. The first definition,
    *showing a response to a stimulus*, refers to some kind of reaction. Being reactive
    means reacting to stimuli, whatever they are. Subdefinition 1.1 says that being
    reactive is also about facing unexpected and uncontrolled situations. You will
    see throughout this book that cloud native applications, and distributed systems
    in general, face plenty of these kinds of situations. While these definitions
    are interesting, they don’t apply to software. But we can take these definitions
    into account to make a new one specific to software:'
  prefs: []
  type: TYPE_NORMAL
- en: 1.6 (Software) An application reacting to stimuli, such as user events, requests,
    and failures.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Yet, as you will see in this book, today’s *reactive* goes beyond this. Reactive
    is an approach to designing, implementing, and reasoning about your system in
    terms of events and flows. Reactive is about building *responsive*, *resilient*,
    and *elastic* applications. Reactive is also about resource utilization through
    efficient management of resources and communication. To put it another way: Reactive
    is about designing and building better distributed systems—more robust and more
    efficient. We call them *reactive systems*.'
  prefs: []
  type: TYPE_NORMAL
- en: Reactive Software Is Not New
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: But wait, the definition (1.6) we just gave is not groundbreaking. On the contrary,
    you may feel some déjà vu, no? Isn’t the nature of software to *react* to user
    inputs and operating system signals? How does software behave when you hit a keystroke?
    It reacts. So, why are there so many books, talks, and debates about Reactive
    if it’s just regular software?^([1](ch01.html#idm45358844096576)) Please be patient;
    there is a bit more to it.
  prefs: []
  type: TYPE_NORMAL
- en: But you are right; Reactive is *not* new. It’s actually pretty old. We can track
    the foundation of the ideas behind reactive software to just after the appearance
    of computers in the ’50s. The [DYSEAC](https://oreil.ly/ehP7l), a first-generation
    computer (in operation in 1954), was already using hardware interrupts as an optimization,
    eliminating waiting time in polling loops. This computer was one of the first
    systems to use reactive and event-driven architecture!
  prefs: []
  type: TYPE_NORMAL
- en: 'Reacting to events implies being event-driven. *Event-driven software* receives
    and produces events. The received events determine the flow of the program. A
    fundamental aspect of being event-driven is asynchronicity: you don’t know when
    you are going to receive events.^([2](ch01.html#idm45358844090400)) That is precisely
    definition 1.1 from the previous section. You cannot plan when you will receive
    events, are not in control of which events you will get, and you need to be prepared
    to handle them. That’s the essence of being reactive: being asynchronous.'
  prefs: []
  type: TYPE_NORMAL
- en: The Reactive Landscape
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From this idea of being asynchronous and event-driven, many forms of *Reactive*
    have emerged. The reactive landscape is broad and crowded. [Figure 1-1](#image:landscape)
    depicts an excerpt of this landscape and the relationships among the main *reactive
    things*.
  prefs: []
  type: TYPE_NORMAL
- en: '![The reactive landscape](assets/rsij_0101.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1-1\. The reactive landscape
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'But don’t forget our objective: building better distributed systems—reactive
    systems. The other “reactives” are here to help us implement these systems.'
  prefs: []
  type: TYPE_NORMAL
- en: The reasons for Reactive, and reactive systems in particular, come from distributed
    systems. As you will see in [Chapter 3](ch03.html#distributed-system), building
    distributed systems is hard. In 2013, distributed system experts wrote the first
    version of [“The Reactive Manifesto”](https://oreil.ly/6z8mt) and introduced the
    concept of reactive systems.
  prefs: []
  type: TYPE_NORMAL
- en: Yes, you can build distributed systems without applying reactive principles.
    Reactive provides a blueprint to ensure that no significant known concerns were
    overlooked while architecting and developing your system. On the other hand, you
    can apply these principles on nondistributed systems.
  prefs: []
  type: TYPE_NORMAL
- en: A reactive system is first and foremost responsive. It must handle requests
    in a timely fashion even under load or when facing failures. To achieve this responsiveness,
    the manifesto proposes using asynchronous message passing as the primary way to
    communicate between the components forming the system. You will see in [Chapter 4](ch04.html#reactive-systems)
    how this communication method enables elasticity and resilience, two essential
    attributes of solid distributed systems. The objective of this book is to show
    you how to build such reactive systems with Quarkus. So, building reactive systems
    is our primary goal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Infusing asynchronous message passing at the core of distributed systems does
    not come without consequences. Your application needs to use asynchronous code
    and nonblocking I/O, the ability provided by the operating system to enqueue I/O
    interactions without having to actively wait for the completion. (We cover nonblocking
    I/Os in [Chapter 4](ch04.html#reactive-systems)). The latter is essential to improve
    resource utilization, such as CPU and memory, another important aspect of Reactive.
    Today, many toolkits and frameworks, such as Quarkus, [Eclipse Vert.x](https://vertx.io),
    [Micronaut](https://micronaut.io), [Helidon](https://helidon.io), and [Netty](https://netty.io),
    are using nonblocking I/O for this very reason: doing more with limited resources.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Yet having a runtime leveraging nonblocking I/O is not enough to be reactive.
    You also need to write asynchronous code embracing the nonblocking I/O mechanics.
    Otherwise, the resource utilization benefits would vanish. Writing asynchronous
    code is a paradigm shift. From the traditional (imperative), `do x; do y;`, you
    are now going to shape your code as `on event(e) do x; on event(f) do y;`. In
    other words, to be reactive, not only is your system an event-driven architecture,
    but also your code is going to become event-driven. One of the most straightforward
    approaches to implementing such code is callbacks: you register functions invoked
    when events are received. Like futures, promises, and coroutines, every other
    approach is based on callbacks and offers higher-level APIs.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You may wonder why spreadsheets are in the landscape. Spreadsheets are reactive.
    When you write a formula in a cell and change a value read (in another cell) by
    the formula, the result of this formula is updated. The cell reacts to the update
    of a value (event), and the outcome (reaction) is the new result. Yes, your manager
    may be a better reactive developer than you are! But don’t worry, this book will
    change this.
  prefs: []
  type: TYPE_NORMAL
- en: Reactive programming, addressed in [Chapter 5](ch05.html#reactive-programming),
    is also an approach to writing asynchronous code. It uses data streams to structure
    your code. You observe the data transiting in these streams and react to it. Reactive
    programming provides a powerful abstraction and APIs to shape event-driven code.
  prefs: []
  type: TYPE_NORMAL
- en: But using data streams comes with an issue. If you have a fast producer directly
    connected to a slow consumer, you may flood the consumer. As you will see, we
    can buffer or use a message broker in between, but imagine flooding a consumer
    without them. That would be against the responsiveness and anti-fragile ideas
    promoted by Reactive. To help us with that particular issue, [Reactive Streams](https://oreil.ly/5c275)
    proposes an asynchronous and nonblocking backpressure protocol where the consumer
    signals to the producer its availability. As you can imagine, this may not be
    applicable everywhere, as some data sources cannot be slowed down.
  prefs: []
  type: TYPE_NORMAL
- en: The popularity of Reactive Streams has increased over the past few years. For
    example, [RSocket](https://rsocket.io) is a network protocol based on Reactive
    Streams. [R2DBC](https://r2dbc.io) proposes asynchronous database access using
    Reactive Streams. Also, [RxJava](https://oreil.ly/QNEOJ), [Project Reactor](https://oreil.ly/eUHAL),
    and [SmallRye Mutiny](https://oreil.ly/A17fF) adopted reactive streams to handle
    backpressure. Finally, Vert.x allows mapping the Vert.x backpressure model to
    Reactive Streams.^([3](ch01.html#idm45358839696288))
  prefs: []
  type: TYPE_NORMAL
- en: 'That concludes our quick tour of the reactive landscape. As we said, it’s crowded
    with many terms, and many tools. But never lose sight of the overall objective
    of Reactive: to build better distributed systems. That’s the primary focus of
    this book.'
  prefs: []
  type: TYPE_NORMAL
- en: Why Are Reactive Architectures So Well-Suited for Cloud Native Applications?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The cloud—public, private, or hybrid—has put Reactive in the spotlight. The
    cloud is a distributed system. When you run your application on the cloud, that
    application faces a high degree of uncertainty. The provisioning of your application
    can be slow, or fast, or even fail. Communication disruptions are common, because
    of network failures or partitions. You may hit quota restrictions, resource shortages,
    and hardware failures. Some services you are using can be unavailable at times
    or moved to other locations.
  prefs: []
  type: TYPE_NORMAL
- en: While the cloud provides outstanding facilities for the infrastructure layer,
    it covers only half of the story. The second half is your application. It needs
    to be designed to be a part of a distributed system. It needs to understand the
    challenges of being part of such a system.
  prefs: []
  type: TYPE_NORMAL
- en: The reactive principles we cover in this book help to embrace the inherent uncertainty
    and challenges of distributed systems and cloud applications. It won’t hide them—to
    the contrary, it embraces them.
  prefs: []
  type: TYPE_NORMAL
- en: As microservices and [serverless computing](https://oreil.ly/IH6wY) are becoming
    prominent architectural styles, the reactive principles become even more important.
    They can help ensure that you design your system on a solid foundation.
  prefs: []
  type: TYPE_NORMAL
- en: Reactive Is Not a Silver Bullet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with everything, Reactive has pros and cons. It’s not a magic weapon. No
    solution works everywhere.
  prefs: []
  type: TYPE_NORMAL
- en: Remember microservices in the late 2010s? They quickly became exceedingly popular,
    and many organizations implemented them in areas for which they may not have been
    well-suited. This often traded one set of problems for another. Much like microservice
    architectures, reactive architectures have areas in which they are well-suited.
    They shine for distributed and cloud applications but can be disastrous on more
    monolithic and computation-centric systems. If your system relies on remote communication,
    event processing, or high efficiency, Reactive will be interesting. If your system
    uses mostly in-process interactions, handles just a few requests per day, or is
    computation-intensive, then Reactive won’t bring anything but complexity.
  prefs: []
  type: TYPE_NORMAL
- en: With Reactive, you put the notion of events at the core of your system. If you
    are used to the traditional synchronous and imperative way of building applications,
    the path to become reactive can be steep. The need to become asynchronous disrupts
    most traditional frameworks. We are moving away from the well-known Remote Procedure
    Call (RPC) and HTTP endpoints. So, with that disclaimer, it’s time to start our
    journey!
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch01.html#idm45358844096576-marker)) You can find a [plethora of talks
    about Reactive on YouTube](https://oreil.ly/SyGxB).
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch01.html#idm45358844090400-marker)) Asynchronous is the opposite of synchronous.
    Being *asynchronous* means happening at a different point in time, while being
    *synchronous* means happening at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch01.html#idm45358839696288-marker)) See [Vert.x Reactive Streams Integration](https://oreil.ly/t2noI)
    for more details.
  prefs: []
  type: TYPE_NORMAL
