- en: 'Chapter 7\. Mutiny: An Event-Driven Reactive Programming API'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。Mutiny：一个基于事件驱动的响应式编程API
- en: In [Chapter 5](ch05.html#reactive-programming), we introduced reactive programming
    and how it helps implement reactive applications. Then, in [Chapter 6](ch06.html#quarkus-reactive),
    we discussed how Quarkus uses Mutiny to allow implementing reactive applications.
    This chapter focuses on Mutiny itself.^([1](ch07.html#idm45358827414448))
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](ch05.html#reactive-programming)中，我们介绍了响应式编程及其如何帮助实现响应式应用程序。然后，在[第6章](ch06.html#quarkus-reactive)中，我们讨论了Quarkus如何使用Mutiny来实现响应式应用程序。本章重点介绍Mutiny本身。^([1](ch07.html#idm45358827414448))
- en: This chapter presents Mutiny’s concepts and common patterns, which will help
    you understand the next few chapters. Mutiny is the API used for every reactive-related
    feature from Quarkus. You will see a lot more of it when delving into the construction
    of reactive applications and systems with Quarkus.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了Mutiny的概念和常见模式，这将帮助您理解接下来的几章。Mutiny是Quarkus中用于每个与响应式相关的功能的API。当深入学习使用Quarkus构建响应式应用程序和系统时，您将看到更多关于Mutiny的内容。
- en: Why Another Reactive Programming Library?
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么需要另一个响应式编程库？
- en: That’s a great question! As you have seen in [Chapter 5](ch05.html#reactive-programming),
    other popular reactive programming libraries exist. So why another one?
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的问题！正如您在[第5章](ch05.html#reactive-programming)中所看到的，其他流行的响应式编程库已经存在。那么为什么还要另一个呢？
- en: In the past few years, we’ve observed how developers developed reactive systems
    and used reactive programming libraries. Through this experience, we observed
    the challenges faced by the developers. In a nutshell, reactive programming is
    hard to learn and hard to read. Writing and maintaining reactive code creates
    a significant burden, slowing the adoption of reactive approaches.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 过去几年中，我们观察到开发人员如何开发响应式系统并使用响应式编程库。通过这些经验，我们发现了开发人员所面临的挑战。简而言之，响应式编程难以学习和理解。编写和维护响应式代码会带来重大负担，从而减缓采用响应式方法的速度。
- en: When we look at reactive programming usage, we immediately see a steep learning
    curve, which makes reactive programming limited to top-notch developers. Indeed,
    the functional programming roots of reactive programming are both elegant and
    limiting at the same time. Not every developer has a functional background. We
    have seen developers lost in a `map` and `flatMap` jungle, trying to find their
    way out of a maze made of monads.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们观察响应式编程的使用时，立即可以看到其陡峭的学习曲线，这使得响应式编程局限于顶尖开发人员。事实上，响应式编程的功能编程根基既优雅又限制。并非每个开发人员都具备函数背景。我们看到开发人员在`map`和`flatMap`的迷宫中迷失，试图找到出路。
- en: Even for seasoned developers, some concepts are abstract and confusing. For
    example, the difference between `flatMap` and `concatMap`, two prominent operators
    in traditional reactive programming libraries, leads to many mistakes, including
    production failures. These reactive programming libraries require a functional
    background and a good understanding of the available operators. Mastering hundreds
    of operators requires time.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 即使对经验丰富的开发人员来说，某些概念仍然抽象且令人困惑。例如，在传统的响应式编程库中，`flatMap`和`concatMap`之间的区别导致了许多错误，包括生产故障。这些响应式编程库需要具备函数背景和对可用操作符的良好理解。掌握数百个操作符需要时间。
- en: Another aspect is the API modeling. Existing libraries often implement [Reactive
    Extensions (ReactX)](http://reactivex.io/) and provide Java classes with hundreds
    of methods. Even with modern IDEs, finding the right method is like looking for
    a needle in a haystack. It’s common to scroll through the list of methods to find
    the right one, not even looking at the method names but at the signature, hoping
    for the best.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个方面是API建模。现有的库通常实现[响应式扩展 (ReactX)](http://reactivex.io/)并提供具有数百个方法的Java类。即使使用现代IDE，找到正确的方法也像大海捞针。通常需要滚动查看方法列表以找到合适的方法，甚至不看方法名称而查看签名，希望能找到最佳方法。
- en: Finally, and this is a more philosophical aspect, existing reactive programming
    libraries do not reflect the event-driven nature of the reactive principles. While
    it uses data streams, which are asynchronous constructs, the API does not convey
    the idea of events. Reactive architectures should help to implement event-based
    processes, and these approaches fall short and require an additional mental-mapping
    between the business process and its implementation.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这是一个更为哲学性的方面，现有的响应式编程库并不反映响应式原则的事件驱动性质。虽然它使用数据流，这些是异步构造，但 API 并未传达事件的概念。响应式架构应该有助于实现基于事件的过程，而这些方法存在不足，需要在业务过程和其实现之间进行额外的心智映射。
- en: To address these issues, we decided to create Mutiny, a new reactive programming
    API focusing on readability, maintenance, and putting the notion of *event* at
    the center.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这些问题，我们决定创建 Mutiny，一个新的响应式编程 API，专注于可读性、维护性，并将 *事件* 的概念置于中心位置。
- en: What Makes Mutiny Unique?
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Mutiny 的独特之处在哪里？
- en: Mutiny is an intuitive, event-driven reactive programming library for Java.
    Mutiny uses the notion of an *event* to communicate that something happened. This
    event-driven nature fits perfectly the asynchronous nature of distributed systems,
    as described in [Chapter 3](ch03.html#distributed-system). With Mutiny, you get
    notified when an event occurs, and you react to it. As a result, Mutiny structures
    itself around *on* methods such as `onItem` and `onFailure`. Each method lets
    you express what you want to do when you receive an event. For example, `onItem.transform`
    receives an item event and transforms it, or `onFailure.recoverWithItem` recovers
    with a fallback item after a failure event.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Mutiny 是一个直观的、事件驱动的 Java 响应式编程库。Mutiny 使用 *事件* 的概念来传达某事发生了。这种事件驱动的特性完美适配了分布式系统的异步性质，正如在
    [第 3 章](ch03.html#distributed-system) 中所述。使用 Mutiny，当事件发生时，你会收到通知并对其作出反应。因此，Mutiny
    围绕 `onItem` 和 `onFailure` 等 *on* 方法组织自己。每个方法让你表达当接收到事件时想要执行的操作。例如，`onItem.transform`
    接收一个项事件并对其进行转换，或者 `onFailure.recoverWithItem` 在失败事件后使用备用项进行恢复。
- en: We wanted to address the API navigation and avoid the *one class with hundreds
    of methods* pattern. We introduced the notion of method *groups*. Each group handles
    a specific type of event. In the `onItem` group, you find all the methods to handle
    an individual item event, such as to transform it (`onItem.transform`), or invoke
    a method (`onItem.invoke`). In the `onFailure` group, you find the methods to
    handle failures and recover, such as `onFailure.recoverWithItem` or `onFailure.retry`.
    The resulting API is more readable, understandable, and navigable. As a user,
    you select the group and navigate across a limited number of methods.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望解决 API 导航问题，避免 *一个类包含数百个方法* 的模式。我们引入了方法 *组* 的概念。每个组处理特定类型的事件。在 `onItem`
    组中，你可以找到处理单个项事件的所有方法，比如转换它 (`onItem.transform`) 或调用方法 (`onItem.invoke`)。在 `onFailure`
    组中，你可以找到处理失败和恢复的方法，比如 `onFailure.recoverWithItem` 或 `onFailure.retry`。结果的 API
    更易读、易懂和易于导航。作为用户，你可以选择组并跨有限数量的方法进行导航。
- en: Mutiny’s API is not concise. We favor readability and understandability over
    conciseness. Over the years, we heard many times that reactive programming was
    hard and usable only by senior developers or architects. It was a key obstacle
    to the reactive adoption. When we designed Mutiny, we wanted to avoid creating
    an elitist library. This is not to “dumb down” the ideas behind reactive programming,
    but instead the goal is to strip away mathematical jargon.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Mutiny 的 API 不是简洁的。我们更看重可读性和理解性，而不是简洁性。多年来，我们多次听到响应式编程很难，只有高级开发人员或架构师才能使用。这是响应式采纳的一个关键障碍。在设计
    Mutiny 时，我们希望避免创建一个精英主义的库。这并不是要“降低”响应式编程背后的思想，而是剥离数学术语的目标。
- en: Mutiny Usage in Quarkus
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Quarkus 中使用 Mutiny
- en: To illustrate the common patterns you will see when using Mutiny, we need an
    example. The application is a simple shop, handling users, products, and orders
    ([Figure 7-1](#image:shop-arch)). A user creates orders that contain a list of
    products. How the application is implemented is not relevant for this chapter.
    Chapters [8](ch08.html#http) and [9](ch09.html#data) will cover how Mutiny integrates
    on the HTTP and data parts of Quarkus.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明在使用 Mutiny 时可能看到的常见模式，我们需要一个例子。该应用是一个简单的商店，处理用户、产品和订单（[图 7-1](#image:shop-arch)）。用户创建包含产品列表的订单。应用的实现方式对本章来说并不重要。第
    [8](ch08.html#http) 和第 [9](ch09.html#data) 章将介绍 Mutiny 在 Quarkus 的 HTTP 和数据部分的集成。
- en: '![Shop Application Architecture](assets/rsij_0701.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![购物应用架构](assets/rsij_0701.png)'
- en: Figure 7-1\. Shop application architecture
  id: totrans-18
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The application uses nonblocking database clients to avoid blocking when integrating
    with the database. Thus, the APIs of `OrderService`, `UserService`, and `ProductService`
    are asynchronous and use Mutiny types. `ShopResource`, implementing the HTTP API,
    also uses Mutiny to query the services and compose the response.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: The code is available in the *chapter-7/order-example* directory, and can be
    started with `mvn quarkus:dev`. The code uses port 8080 to expose the HTTP API.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Uni and Multi
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Mutiny provides two main classes: `Uni` and `Multi`.^([2](ch07.html#idm45358827368080))
    `Uni` represents an asynchronous action or operation. It can emit a single item
    or failure, if the represented action fails. `Multi` represents a stream of items.
    It can convey multiple items, as well as a terminal failure or completion event.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at two use cases to better understand the differences. Imagine you
    want to retrieve a single user (represented by the `UserProfile` class) from the
    database. You will use `Uni<UserProfile>`, as shown in [Example 7-1](#mutiny::uni).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-1\. Example of `Uni` (*chapter-7/order-example/src/main/java/org/acme/ShopResource.java*)
  id: totrans-24
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You can attach logic to `Uni`, so you can react when it emits events. In the
    previous snippet, when `UserProfile` becomes available, we extract the name of
    the user. If a failure happened, we recover with a fallback value. The `onItem`
    and `onFailure` groups form the center of the `Uni` API.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '`Multi` can emit 0, 1, *n*, or an infinite number of items. It can also emit
    a failure, which is a terminal event. Finally, when there are no more items to
    emit, `Multi` emits the completion event. As a result, the API is slightly different.
    Let’s now imagine we need all the users. For this case, you use `Multi`, as shown
    in [Example 7-2](#mutiny::multi).'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-2\. Example of `Multi` (*chapter-7/order-example/src/main/java/org/acme/ShopResource.java*)
  id: totrans-28
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As for `Uni`, you can handle events. In the snippet, you extract the name of
    each user. So, unlike [Example 7-1](#mutiny::uni), the code can call the transformation
    multiple times. While the API is somewhat similar, `Multi` proposes specific groups
    to select, drop, and collect items; see [Example 7-3](#mutiny::multi-api).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-3\. Example of code using `Multi` (*chapter-7/mutiny-examples/src/main/java/org/acme/MultiApi.java*)
  id: totrans-31
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, these two types are inherently event driven. However, the set
    of events each handles differ. The API reflects these differences. `Uni` and `Multi`
    do not offer the same set of groups, as some are specific to each case ([Table 7-1](#table:uni-multi)).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Table 7-1\. `Uni` and `Multi` use cases
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '|  | Events | Use cases | Implement Reactive Streams |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
- en: '| `Uni` | Item and failure | Remote invocation, asynchronous computation returning
    a single result | No |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
- en: '| `Multi` | Item, failure, completion | Data streams, potentially unbounded
    (emitting an infinite number of items) | Yes |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
- en: An essential aspect of `Uni` and `Multi` is their laziness. Holding a reference
    on `Uni` and `Multi` instances does nothing. In [Example 7-3](#mutiny::multi-api),
    nothing will happen until someone explicitly subscribes (and so expresses an interest),
    as shown in [Example 7-4](#mutiny::creation-subscription).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-4\. Subscription to `Uni` and `Multi` (*chapter-7/order-example/src/main/java/org/acme/UniMultiExample.java*)
  id: totrans-40
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: To subscribe (and thereby trigger the operation) you use the `subscribe` group.
    In Quarkus, you may not need to subscribe, because if you return `Uni` or `Multi`
    to Quarkus, it subscribes for you. For instance, you can have the HTTP method
    shown in [Example 7-5](#mutiny::no-subscription).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-5\. Quarkus handles the subscription for HTTP methods (*chapter-7/order-example/src/main/java/org/acme/ShopResource.java*)
  id: totrans-43
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: When a matching HTTP request arrives, Quarkus calls this method and subscribes
    on the produced `Uni`. Quarkus will write the HTTP response only when `Uni` emits
    an item or failure.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Mutiny and Flow Control
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As indicated in [Table 7-1](#table:uni-multi), `Multi` implements the Reactive
    Streams backpressure protocol. In other words, it implements the Reactive Streams
    `Publisher` interface, and `Multi`’s consumers are the Reactive Streams `Subscriber`.
    That’s not the case for `Uni`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: When dealing with a stream sending multiple items, so a `Multi`, having backpressure
    support makes sense. Under the hood, the subscriber can control the flow and the
    pace by requesting items when it can handle them. It avoids flooding the subscribers
    with too many items.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: When dealing with `Uni`, subscribing to it is enough to express your interest
    and capacity to handle the emitted item. There’s no need to send another request
    signal to express your interest.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: But, as you have seen in [Chapter 5](ch05.html#reactive-programming), not every
    stream can support flow control. Streams representing events from the physical
    world, such as user clicks or time, can’t be slowed. In this case, there is a
    risk of sending too many events to the subscriber. That’s why `Multi` provides
    the `onOverflow` group. This group monitors the number of items emitted by the
    upstream source as well as the number of items requested by the downstream subscriber.
    When there are more incoming items than requests, `Multi` emits an *overflow*
    event. The `onOverflow` group allows configuring the desired behavior when this
    happens.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate this, let’s imagine a stream producing product recommendations.
    Every second, it sends a new recommended product. But time cannot be slowed, so
    we cannot apply backpressure. If the downstream can’t keep up, we would have an
    overflow. To avoid that, if we can’t emit the tick item because of the lack of
    request, we just drop it, as shown in [Example 7-6](#mutiny::multi-overflow).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-6\. Handle overflow with `Multi` (*chapter-7/order-example/src/main/java/org/acme/ShopResource.java*)
  id: totrans-52
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `onOverflow` group provides other possibilities, such as buffering the items.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: Observing Events
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you have a `Uni` or `Multi` instance, it’s natural to observe the events
    emitted by these instances. For each type of event, an `invoke` method is called
    when it sees a matching event; see [Example 7-7](#mutiny::multi-observe).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-7\. Observe events (*chapter-7/mutiny-examples/src/main/java/org/acme/MultiObserve.java*)
  id: totrans-57
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `invoke` method does not modify the event; you observe it without changing
    it. The downstream receives the same event you did. This method is handy when
    needed to implement side effects or trace your code. For example, we can use it
    to log when a new user is created or if the creation failed (see [Example 7-8](#mutiny::uni-observe)).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-8\. Observe `Uni` events (*chapter-7/order-example/src/main/java/org/acme/ShopResource.java*)
  id: totrans-60
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If you have the application running, you can run this code by using [Example 7-9](#invoke-7-9).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-9\. Invoke the `users` endpoint
  id: totrans-63
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Transforming Events
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of the time, we need to transform the event. Let’s first see how we can
    transform events synchronously. You receive the event, transform it, and produce
    the result as a new event. For each type of event, a `transform` method is called
    when it sees a matching event, as shown in [Example 7-10](#mutiny::multi-transform).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-10\. Transform events (*chapter-7/mutiny-examples/src/main/java/org/acme/MultiTransform.java*)
  id: totrans-67
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Unlike `invoke`, `transform` produces a new event. It invokes the passed function
    and sends the result to the downstream subscriber.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: The synchronous nature of `transform` is important. After receiving the event,
    `transform` calls the transformation logic and emits the result downstream. If
    the transformation logic takes a long time to complete, `transform` waits until
    the logic terminates. So, use `transform` when the transformation is fast enough.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: For example, the following method retrieves the list of products, capitalizes
    their names consistently, and builds the representation (`ProductModel`). For
    each product, `transform` extracts the name and applies the transformation. This
    synchronous process is fast. It emits the result downstream immediately, as shown
    in [Example 7-11](#mutiny::multi-transform-product).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-11\. Transform products (*chapter-7/order-example/src/main/java/org/acme/ShopResource.java*)
  id: totrans-72
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Chaining Asynchronous Actions
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `transform` method can process events synchronously, but what if we need
    to invoke an asynchronous process? Imagine that you receive an event, and need
    to invoke a remote service or interact with a database. You can’t use `transform`,
    as these methods should be asynchronous (otherwise, they would block, which would
    be against the reactive principles). You need to *wait* until the asynchronous
    computation completes.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 'How can we express this using the Mutiny lingo? It would mean transforming
    an event, but unlike `transform` returning a *plain* result, it returns an asynchronous
    structure: another `Uni` or `Multi`. What does that look like? Take a look at
    [Example 7-12](#mutiny:uni-transform-async).'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何用 Mutiny 的术语来表达这个？这意味着转换一个事件，但不像`transform`返回一个*普通*结果那样，它返回一个异步结构：另一个`Uni`或`Multi`。看一下[示例 7-12](#mutiny:uni-transform-async)是什么样子。
- en: Example 7-12\. Chain asynchronous actions (*chapter-7/mutiny-examples/src/main/java/org/acme/UniTransformAsync.java*)
  id: totrans-77
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-12\. 链式异步操作（*chapter-7/mutiny-examples/src/main/java/org/acme/UniTransformAsync.java*）
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`transformToUni` and `transformToMulti` provide the ability to produce a `Uni`
    or a `Multi` instance.^([3](ch07.html#idm45358826255536)) When you receive an
    item, Mutiny invokes the function returning `Uni` or `Multi`. Then, it emits the
    events downstream from this `Uni` or `Multi`. In [Example 7-13](#mutiny::uni-transform-async-order),
    we retrieve the list of orders for a specific user (identified by its name).'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`transformToUni`和`transformToMulti`提供了生成`Uni`或`Multi`实例的能力。^([3](ch07.html#idm45358826255536))
    当你接收到一个项时，Mutiny会调用返回`Uni`或`Multi`的函数。然后，从这个`Uni`或`Multi`向下游发出事件。在[示例 7-13](#mutiny::uni-transform-async-order)中，我们检索特定用户（通过其名称）的订单列表。'
- en: Example 7-13\. Retrieve order for a specific user (*chapter-7/order-example/src/main/java/org/acme/ShopResource.java*)
  id: totrans-80
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-13\. 检索特定用户的订单（*chapter-7/order-example/src/main/java/org/acme/ShopResource.java*）
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This code retrieves the user, and when it receives the user, the code then retrieves
    the orders. The `getOrderForUser` method returns `Multi<Order>`, so the result
    is `Multi<Order>`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码检索用户，当接收到用户时，然后代码检索订单。`getOrderForUser`方法返回`Multi<Order>`，因此结果是`Multi<Order>`。
- en: If you look carefully at the preceding code, you will say, “Hey! You’re forgetting
    something! How does that work when we chain from a `Multi` and not a `Uni`?” You
    are right; we need to discuss the `Multi` case. How would you transform each item
    of a `Multi` into another `Uni` or `Multi`?
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细看前面的代码，你会说：“嘿！你忘了一些东西！当我们从`Multi`而不是`Uni`链式调用时，它是如何工作的？” 你是对的；我们需要讨论`Multi`情况。你如何将`Multi`的每个项转换为另一个`Uni`或`Multi`？
- en: Let’s illustrate the problem with an example. Imagine you need to retrieve the
    orders for all the users. So, instead of having the username as in [Example 7-13](#mutiny::uni-transform-async-order),
    we need to retrieve all the users, and for each retrieve the orders. [Example 7-14](#mutiny::orders-per-user)
    shows the resulting code.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子来说明这个问题。假设你需要检索所有用户的订单。因此，不像[示例 7-13](#mutiny::uni-transform-async-order)中那样只需要用户名，我们需要检索所有用户，并且对于每个用户检索订单。[示例 7-14](#mutiny::orders-per-user)展示了生成的代码。
- en: Example 7-14\. Retrieve the orders for each user using `concatenate` (*chapter-7/order-example/src/main/java/org/acme/ShopResource.java*)
  id: totrans-85
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-14\. 使用`concatenate`检索每个用户的订单（*chapter-7/order-example/src/main/java/org/acme/ShopResource.java*）
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You can immediately spot a difference. Instead of `transformToMulti`, we have
    `transformToMultiAndConcatenate`. But why *AndConcatenate*? It relates to the
    order of the item sent downstream. It gets the `Multi` for the first user, emits
    the items downstream, and then handles the one for the next user, and so on. In
    other words, it takes the `Multi` instances one by one and concatenates them.
    This approach preserves the order, but also limits the concurrency as we retrieve
    the orders, one user at a time.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以立即发现一个不同点。不是`transformToMulti`，而是`transformToMultiAndConcatenate`。但为什么*AndConcatenate*？这与向下游发送的项的顺序有关。它获取第一个用户的`Multi`，将项发送到下游，然后处理下一个用户的`Multi`，依此类推。换句话说，它逐个获取`Multi`实例并将它们连接起来。这种方法保留了顺序，但同时也限制了并发性，因为我们一次只检索一个用户的订单。
- en: If you don’t need to preserve the order, you can use the `transformToMultiAndMerge`
    method.^([4](ch07.html#idm45358826140656)) In this case, it invokes `getOrderForUser`
    concurrently. It merges the items from the resulting `Multi` as they come, and
    so may interleave the orders from different users ([Example 7-15](#mutiny::orders-per-user-merge)).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不需要保留顺序，可以使用`transformToMultiAndMerge`方法。^([4](ch07.html#idm45358826140656))
    在这种情况下，它并发地调用`getOrderForUser`。它将从生成的`Multi`中合并项目，因此可能会交错来自不同用户的订单（[示例 7-15](#mutiny::orders-per-user-merge)）。
- en: Example 7-15\. Retrieve the orders for each user by using merge
  id: totrans-89
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-15\. 使用合并检索每个用户的订单
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-91
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '*chapter-7/mutiny-examples/src/main/java/org/acme/MultiTransformAsync.java*
    lets you execute these examples. They highlight the ordering difference.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*chapter-7/mutiny-examples/src/main/java/org/acme/MultiTransformAsync.java*
    让您执行这些示例。它们突出了订单差异。'
- en: Recovering from Failure
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从失败中恢复
- en: As we said, failures are inevitable. We must handle them.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: What can be done in such an unfortunate case? In the Mutiny world, failures
    are events. So, you can observe and process them. You can use `invoke` or `transform`
    as for any other events. But you can also handle the failure and recover gracefully.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: One of the most common approaches consists of recovering with a specific fallback
    item. Let’s imagine we want to create a new user, but the insertion fails because
    the name needs to be unique. We can return a message indicating the failure, as
    shown in Example 7-16.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-16\. Recover from failure with a fallback item (*chapter-7/order-example/src/main/java/org/acme/ShopResource.java*)
  id: totrans-97
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: While a failure is an event, it’s a terminal one. That’s not a problem if you
    are dealing with `Uni`; you won’t get the item, just the failure. So, the `Uni`
    would replace the failure with the fallback item. With `Multi`, you won’t get
    any more items after the failure. The recovery emits the fallback item followed
    by the completion event.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Another common possibility is to retry. Remember, retry only if your system
    can endure it. In this case (and only in this case), you can retry. Retry resubscribing
    to the upstream source, as shown in [Example 7-17](#mutiny::retry).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-17\. Retry on failure
  id: totrans-101
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You can limit the number of retries or introduce a delay between them by using
    `atMost` and configuring the backoff; see [Example 7-18](#mutiny::retry-at-most).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-18\. Retry on failure at most n times with delay between attempts
    (*chapter-7/mutiny-examples/src/main/java/org/acme/UniFailure.java*)
  id: totrans-104
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note
  id: totrans-106
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '*chapter-7/mutiny-examples/src/main/java/org/acme/UniFailure.java* lets you
    execute these examples to help you understand the various possibilities.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: The `onFailure` group contains a lot more possibilities.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Combining and Joining Items
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next common pattern consists of combining the items from multiple upstream
    sources. For example, imagine we want to generate recommendations. We would pick
    a random user and a recommended product. We could sequentially execute both, but
    they are independent, so we can execute them concurrently, and when we have both
    results, generate the recommendation ([Example 7-19](#mutiny::recommended-product)).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-19\. Combine `Uni` instances (*chapter-7/order-example/src/main/java/org/acme/ShopResource.java*)
  id: totrans-111
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This snippet gets two `Uni`s. The first one retrieves a random user, and the
    second one gets a recommended product. Then we combine both and aggregate their
    results into a tuple. When both operations complete, Mutiny collects the items
    into a tuple and emits this tuple downstream. We can transform it and generate
    the recommendation. If the `Uni` fails, it propagates the failure downstream.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Combining `Uni` operations is common when we want to execute operations concurrently
    and join their results. But we can do the same with `Multi` too. In this case,
    we associate the items from several `Multi` operations. For example, we can generate
    a stream of recommendations, associating random users and recommended products,
    as shown in [Example 7-20](#mutiny::recommented-products).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们希望并发执行操作并连接其结果时，结合`Uni`操作是很常见的。但我们也可以对`Multi`执行相同操作。在这种情况下，我们关联几个`Multi`操作的项目。例如，我们可以生成一个推荐流，关联随机用户和推荐产品，如[示例 7-20](#mutiny::recommented-products)所示。
- en: Example 7-20\. Join `Multi`s (*chapter-7/order-example/src/main/java/org/acme/ShopResource.java*)
  id: totrans-115
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-20\. 连接`Multi`（*chapter-7/order-example/src/main/java/org/acme/ShopResource.java*）
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: When joining `Multi`s, the resulting stream completes as soon as one of the
    joined `Multi` sends the completion event. Indeed, it won’t be possible to combine
    the items anymore.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当连接`Multi`时，只要连接的一个`Multi`发送完成事件，结果流就会完成。实际上，不能再组合项目了。
- en: Selecting Items
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择项目
- en: When dealing with `Multi`, you may want to select the items to propagate downstream
    and discard the others. For example, we can retrieve all the orders and then select
    only the orders containing more than three products (see [Example 7-21](#mutiny:select-where)).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 处理`Multi`时，您可能希望选择要向下传播的项目并丢弃其他项目。例如，我们可以检索所有订单，然后仅选择包含超过三个产品的订单（参见[示例 7-21](#mutiny:select-where)）。
- en: Example 7-21\. Select items (*chapter-7/order-example/src/main/java/org/acme/OrderService.java*)
  id: totrans-120
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-21\. 选择项目（*chapter-7/order-example/src/main/java/org/acme/OrderService.java*）
- en: '[PRE20]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `select.where` operation lets you select the item. For each item, the operation
    calls the predicates and decides whether the item should be propagated downstream.
    It drops the items not passing the predicate.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`select.where`操作允许您选择项目。对于每个项目，该操作调用谓词并决定是否应将项目传播到下游。它会丢弃未通过谓词的项目。'
- en: An asynchronous variant of the `select.when` operator is also available. It
    lets you select the items to keep, using an asynchronous predicate. [Example 7-22](#mutiny::select-when)
    shows how to select the orders for a specific username. For each order, the code
    retrieves the associated user and selects only when the username matches.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`select.when`操作的异步变体也可用。它允许您选择要保留的项目，使用异步谓词。[示例 7-22](#mutiny::select-when)展示了如何选择特定用户名的订单。对于每个订单，代码检索关联的用户，并且仅当用户名匹配时才选择。'
- en: Example 7-22\. Select items with an asynchronous predicate (*chapter-7/order-example/src/main/java/org/acme/OrderService.java*)
  id: totrans-124
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-22\. 使用异步谓词选择项目（*chapter-7/order-example/src/main/java/org/acme/OrderService.java*）
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Selection can also drop any duplicate items. In [Example 7-23](#mutiny::select-distinct),
    we list the ordered products.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 选择也可以删除任何重复的项目。在[示例 7-23](#mutiny::select-distinct)中，我们列出了订购的产品。
- en: Example 7-23\. Select distinct items (*chapter-7/order-example/src/main/java/org/acme/ProductService.java*)
  id: totrans-127
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-23\. 选择不同的项目（*chapter-7/order-example/src/main/java/org/acme/ProductService.java*）
- en: '[PRE22]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: For each order, we retrieve the products and generate `Multi<Product>`. Then,
    we select only distinct items, dropping duplicates. Note that we can’t use `distinct`
    on unbounded streams, as it needs to keep in memory all the already seen items.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个订单，我们检索产品并生成`Multi<Product>`。然后，我们仅选择不同的项目，丢弃重复项。请注意，我们无法在无界流上使用`distinct`，因为它需要在内存中保留所有已经看到的项目。
- en: In addition to selection, Mutiny provides a `skip` group. It provides the opposite
    functionality, and so allows skipping items matching predicates and repetitions.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 除了选择之外，Mutiny还提供了一个`skip`组。它提供相反的功能，因此允许跳过与谓词和重复匹配的项目。
- en: Collecting Items
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 收集项目
- en: Finally, when dealing with bounded `Multi`, you may want to accumulate the items
    into a list or a collection. The resulting structure is emitted when the `Multi`
    completes.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在处理有界的`Multi`时，您可能希望将项目累积到列表或集合中。当`Multi`完成时，结果结构会被发出。
- en: Let’s reuse the previous example. We know that the set of ordered products is
    bounded, so, we can collect the product into a list, as shown in [Example 7-24](#mutiny::collect).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重复使用前面的示例。我们知道订购产品的集合是有界的，因此，我们可以将产品收集到列表中，如[示例 7-24](#mutiny::collect)所示。
- en: Example 7-24\. Collect items into a list (*chapter-7/order-example/src/main/java/org/acme/ProductService.java*)
  id: totrans-134
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-24\. 将项目收集到列表中（*chapter-7/order-example/src/main/java/org/acme/ProductService.java*）
- en: '[PRE23]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note that the method returns `Uni<List<Product>>`. The method emits the list
    (containing the products) when the `Multi` returned by `getAllOrderedProducts`
    completes.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，该方法返回`Uni<List<Product>>`。当由`getAllOrderedProducts`返回的`Multi`完成时，方法会发出包含产品的列表。
- en: The `collect` group provides other methods to aggregate items into maps, collections,
    or events, using your own collector ([Example 7-25](#mutiny::collect-2)).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`collect` 组提供其他方法来将项目聚合到映射、集合或事件中，使用您自己的收集器（[示例 7-25](#mutiny::collect-2)）。'
- en: Example 7-25\. Other collection methods
  id: totrans-138
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-25\. 其他收集方法
- en: '[PRE24]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Summary
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'This chapter was a brief introduction to the Mutiny API. It did not provide
    a complete overview of the possibilities but presented key patterns we will use
    later in this book. Remember:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是对 Mutiny API 的简要介绍。它没有提供完整的概述，但介绍了我们将在本书后续使用的关键模式。记住：
- en: Mutiny is an event-driven reactive programming API.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mutiny 是一个事件驱动的响应式编程 API。
- en: You observe and transform events.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以观察和转换事件。
- en: 'Mutiny provides two main classes: `Uni` and `Multi`.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mutiny 提供了两个主要的类：`Uni` 和 `Multi`。
- en: The Mutiny API is navigable and offers you guidance to pick the right operator.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mutiny API 提供了导航功能，并为您选择正确的操作符提供了指导。
- en: With this in mind, we can now start using the reactive services and facilities
    offered by Quarkus.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个理解，我们现在可以开始使用 Quarkus 提供的响应式服务和设施。
- en: ^([1](ch07.html#idm45358827414448-marker)) Quarkus integrates Mutiny, which
    is a separate project that can be embedded anywhere.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch07.html#idm45358827414448-marker)) Quarkus 集成了 Mutiny，这是一个可以嵌入到任何地方的独立项目。
- en: ^([2](ch07.html#idm45358827368080-marker)) The Mutiny name comes from the contraction
    of `Multi` and `Uni`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch07.html#idm45358827368080-marker)) Mutiny 的名称来源于 `Multi` 和 `Uni` 的缩写。
- en: ^([3](ch07.html#idm45358826255536-marker)) The `transformToUni` and `transformToMulti`
    operations are generally called `flatMap` in traditional reactive programming
    libraries.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch07.html#idm45358826255536-marker)) `transformToUni` 和 `transformToMulti`
    操作在传统的响应式编程库中通常被称为 `flatMap`。
- en: ^([4](ch07.html#idm45358826140656-marker)) `transformToMultiAndConcatenate`
    is called `concatMap` in traditional reactive programming libraries. `transformToMultiAndMerge`
    is generally named `flatMap`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch07.html#idm45358826140656-marker)) `transformToMultiAndConcatenate`
    在传统的响应式编程库中称为 `concatMap`。`transformToMultiAndMerge` 通常被称为 `flatMap`。
