<html><head></head><body><section data-pdf-bookmark="Chapter 8. Text and Core Utilities" data-type="chapter" epub:type="chapter"><div class="chapter" id="learnjava6-CHP-8">&#13;
<h1><span class="label">Chapter 8. </span>Text and Core Utilities</h1>&#13;
&#13;
&#13;
<p>If you’ve been <a data-primary="text processing" data-type="indexterm" id="ix_text_proc_ch8"/>reading this book sequentially, you’ve read all about the core Java language constructs, including the object-oriented aspects of the language and the use of threads. Now it’s time to shift gears and start talking about the collection of classes that compose the standard Java packages and come with every Java implementation. Java’s core packages are one of its most distinguishing features. Many other object-oriented languages have similar features, but none has as extensive a set of standardized classes and tools as Java does. This is both a reflection of—and a reason for—Java’s success.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Strings" data-type="sect1"><div class="sect1" id="learnjava6-CHP-8-SECT-1">&#13;
<h1>Strings</h1>&#13;
&#13;
<p>We’ll start by <a data-primary="text processing" data-secondary="String class" data-type="indexterm" id="ix_text_string_class"/><a data-primary="String class" data-type="indexterm" id="ix_string_class"/><a data-primary="immutability" data-type="indexterm" id="id1538"/>taking a closer look at the Java <code>String</code> class (or, more specifically, <code>java.lang.String</code>). Because working with <code>String</code>s is so fundamental, it’s important to understand how they are implemented and what you can do with them. A <code>String</code> object encapsulates a sequence of <a data-primary="character encoding" data-secondary="Unicode" data-type="indexterm" id="id1539"/><a data-primary="Unicode" data-type="indexterm" id="id1540"/>Unicode characters. Internally, these characters are stored in a regular Java array, but the <code>String</code> object guards this array jealously and gives you access to it only through its own API. This is to support the idea that <code>String</code>s are <em>immutable</em>; once you create a <code>String</code> object, you can’t change its value. Lots of operations on a <code>String</code> object appear to change the characters or length of a string, but what they really do is return a new <code>String</code> object that copies or internally references the needed characters of the original. Java implementations make an effort to consolidate identical strings used in the same class into a shared-string pool and to share parts of <code>String</code>s where possible.</p>&#13;
&#13;
<p>The original motivation for all of this was <a data-primary="performance" data-secondary="and immutability of Strings" data-type="indexterm" id="id1541"/>performance. Immutable <code>String</code>s can save memory and the Java VM can optimize their use for speed. But they aren’t magic. You should have a basic understanding of the <code>String</code> class to avoid creating an excessive number of <code>String</code> objects in places where performance is an issue.<sup><a data-type="noteref" href="ch08.html#id1542" id="id1542-marker">1</a></sup></p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Constructing Strings" data-type="sect2"><div class="sect2" id="learnjava6-CHP-8-SECT-1.1">&#13;
<h2>Constructing Strings</h2>&#13;
&#13;
<p>Literal strings, <a data-primary="String class" data-secondary="constructing strings" data-type="indexterm" id="ix_string_construct"/><a data-primary="“ ” (double quotes), enclosing string literals" data-type="indexterm" id="id1543"/><a data-primary="double quotes (“ ”), enclosing string literals" data-type="indexterm" id="id1544"/>defined in your source code, are declared with double quotes and can be assigned to a <code>String</code> variable:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="n">String</code><code class="w"> </code><code class="n">quote</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">"To be or not to be"</code><code class="p">;</code><code class="w"/></pre>&#13;
&#13;
<p>Java automatically converts the literal string into a <code>String</code> object and assigns it to the variable.</p>&#13;
&#13;
<p><code>String</code>s keep track of their own length, so <code>String</code> objects in Java don’t require special terminators. <a data-primary="length() method" data-secondary="String class" data-type="indexterm" id="id1545"/>You can get the length of a <code>String</code> with the <code>length()</code> method. You can also test for a zero-length string by using <code>isEmpty()</code>:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="kt">int</code><code class="w"> </code><code class="n">length</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">quote</code><code class="p">.</code><code class="na">length</code><code class="p">();</code><code class="w"/>&#13;
<code class="w">    </code><code class="kt">boolean</code><code class="w"> </code><code class="n">empty</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">quote</code><code class="p">.</code><code class="na">isEmpty</code><code class="p">();</code><code class="w"/></pre>&#13;
&#13;
<p><code>String</code>s can take <a data-primary="+ (plus) operator" data-type="indexterm" id="id1546"/><a data-primary="plus (+) operator" data-type="indexterm" id="id1547"/>advantage of the only overloaded operator in Java, the <code>+</code> operator, for string concatenation. The following two lines produce equivalent strings:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="n">String</code><code class="w"> </code><code class="n">name</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">"John "</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="s">"Smith"</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">    </code><code class="c1">// or, equivalently:</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">String</code><code class="w"> </code><code class="n">name</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">"John "</code><code class="p">.</code><code class="na">concat</code><code class="p">(</code><code class="s">"Smith"</code><code class="p">);</code><code class="w"/></pre>&#13;
&#13;
<p>For chunks of <a data-primary="text blocks, Strings" data-type="indexterm" id="id1548"/>text larger than a name, Java 13 introduced text blocks. We can store a poem with fairly little effort by using three double-quotes to mark the beginning and end of the multiline block. This feature even preserves leading space in a clever way: the leftmost nonspace character becomes the left “edge.” Spaces to the left of that edge on subsequent lines are ignored, but spaces after that edge are retained. Consider redoing our poem in <em>jshell</em>:</p>&#13;
&#13;
<pre class="jshell" data-type="programlisting">jshell&gt; String poem = """&#13;
   ...&gt; Twas brillig, and the slithy toves&#13;
   ...&gt;    Did gyre and gimble in the wabe:&#13;
   ...&gt; All mimsy were the borogoves,&#13;
   ...&gt;    And the mome raths outgrabe.&#13;
   ...&gt; """;&#13;
poem ==&gt; "Twas brillig, and ... the mome raths outgrabe.\n"&#13;
&#13;
jshell&gt; System.out.print(poem);&#13;
Twas brillig, and the slithy toves&#13;
   Did gyre and gimble in the wabe:&#13;
All mimsy were the borogoves,&#13;
   And the mome raths outgrabe.&#13;
&#13;
jshell&gt;</pre>&#13;
&#13;
<p>Embedding lengthy text in source code is not normally something you want to do. For text longer than a few dozen lines, <a data-type="xref" href="ch10.html#learnjava6-CHP-10">Chapter 10</a> looks at ways to load <code>String</code>s from files.</p>&#13;
&#13;
<p>In addition to making strings from literal expressions, you can construct a <code>String</code> directly from an array of characters:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="kt">char</code><code class="w"> </code><code class="o">[]</code><code class="w"> </code><code class="n">data</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="kt">char</code><code class="w"> </code><code class="o">[]</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="sc">'L'</code><code class="p">,</code><code class="w"> </code><code class="sc">'e'</code><code class="p">,</code><code class="w"> </code><code class="sc">'m'</code><code class="p">,</code><code class="w"> </code><code class="sc">'m'</code><code class="p">,</code><code class="w"> </code><code class="sc">'i'</code><code class="p">,</code><code class="w"> </code><code class="sc">'n'</code><code class="p">,</code><code class="w"> </code><code class="sc">'g'</code><code class="w"> </code><code class="p">};</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">String</code><code class="w"> </code><code class="n">lemming</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">String</code><code class="p">(</code><code class="n">data</code><code class="p">);</code><code class="w"/></pre>&#13;
&#13;
<p>You can also construct a <code>String</code> from an array of bytes:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="kt">byte</code><code class="w"> </code><code class="o">[]</code><code class="w"> </code><code class="n">data</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="kt">byte</code><code class="w"> </code><code class="o">[]</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="p">(</code><code class="kt">byte</code><code class="p">)</code><code class="mi">97</code><code class="p">,</code><code class="w"> </code><code class="p">(</code><code class="kt">byte</code><code class="p">)</code><code class="mi">98</code><code class="p">,</code><code class="w"> </code><code class="p">(</code><code class="kt">byte</code><code class="p">)</code><code class="mi">99</code><code class="w"> </code><code class="p">};</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">String</code><code class="w"> </code><code class="n">abc</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">String</code><code class="p">(</code><code class="n">data</code><code class="p">,</code><code class="w"> </code><code class="s">"ISO8859_1"</code><code class="p">);</code><code class="w"/></pre>&#13;
&#13;
<p>In this case, the second argument to the <code>String</code> constructor is the name of a character-encoding scheme. The <code>String</code> constructor uses it to convert the raw bytes in the specified encoding to the internal encoding chosen by the runtime. If you don’t specify a character encoding, the default encoding scheme on your system is used.<sup><a data-type="noteref" href="ch08.html#id1549" id="id1549-marker">2</a></sup></p>&#13;
&#13;
<p>Conversely, the <code>charAt()</code> <a data-primary="charAt() method, String" data-type="indexterm" id="id1550"/>method of the <code>String</code> class lets you access the characters of a <code>String</code> in an array-like fashion:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="n">String</code><code class="w"> </code><code class="n">s</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">"Newton"</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">    </code><code class="k">for</code><code class="w"> </code><code class="p">(</code><code class="kt">int</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="o">&lt;</code><code class="w"> </code><code class="n">s</code><code class="p">.</code><code class="na">length</code><code class="p">();</code><code class="w"> </code><code class="n">i</code><code class="o">++</code><code class="p">)</code><code class="w"/>&#13;
<code class="w">      </code><code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="n">s</code><code class="p">.</code><code class="na">charAt</code><code class="p">(</code><code class="n">i</code><code class="p">)</code><code class="w"> </code><code class="p">);</code><code class="w"/></pre>&#13;
&#13;
<p>This code prints the characters of the string one at a time.</p>&#13;
&#13;
<p>The notion that a <code>String</code> is a sequence of characters is also codified by the <code>String</code> class implementing the interface <code>java.lang.CharSequence</code>, which prescribes the methods <code>length()</code> and <code>charAt()</code> as a way to get a subset of the characters.<a data-primary="" data-startref="ix_string_construct" data-type="indexterm" id="id1551"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Strings from Things" data-type="sect2"><div class="sect2" id="learnjava6-CHP-8-SECT-1.2">&#13;
<h2>Strings from Things</h2>&#13;
&#13;
<p>Objects and <a data-primary="objects" data-secondary="as strings" data-secondary-sortas="strings" data-type="indexterm" id="id1552"/><a data-primary="primitive data types" data-secondary="as strings" data-secondary-sortas="strings" data-type="indexterm" id="id1553"/><a data-primary="String class" data-secondary="objects and primitive types as strings" data-type="indexterm" id="id1554"/><a data-primary="valueOf() method, String" data-type="indexterm" id="id1555"/>primitive types in Java can be turned into a default textual representation as a <code>String</code>. For primitive types like numbers, the string should be fairly obvious; for object types, it is under the control of the object itself. We can get the string representation of an item with the static <code>String.valueOf()</code> method. Various overloaded versions of this method accept each of the primitive types:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="n">String</code><code class="w"> </code><code class="n">one</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">String</code><code class="p">.</code><code class="na">valueOf</code><code class="p">(</code><code class="mi">1</code><code class="p">);</code><code class="w"> </code><code class="c1">// integer, "1"</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">String</code><code class="w"> </code><code class="n">two</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">String</code><code class="p">.</code><code class="na">valueOf</code><code class="p">(</code><code class="mf">2.384f</code><code class="p">);</code><code class="w">  </code><code class="c1">// float, "2.384"</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">String</code><code class="w"> </code><code class="n">notTrue</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">String</code><code class="p">.</code><code class="na">valueOf</code><code class="p">(</code><code class="kc">false</code><code class="p">);</code><code class="w"> </code><code class="c1">// boolean, "false"</code><code class="w"/></pre>&#13;
&#13;
<p>All <a data-primary="toString() method" data-type="indexterm" id="id1556"/>objects in Java have a <code>toString()</code> method that is inherited from the <code>Object</code> class. For many objects, this method returns a useful result that displays the contents of the object. For example, a <code>java</code>.<code>util</code>.<code>Date</code> object’s <code>toString()</code> method returns the date it represents formatted as a string. For objects that do not provide a representation, the string result is just a unique identifier that you can use for debugging. The <code>String.valueOf()</code> method, when called for an object, invokes the object’s <code>toString()</code> method and returns the result. The only real difference in using this method is that if you pass it a null object reference, it returns the <code>String</code> “null” for you, instead of producing a <code>NullPointerException</code>:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="n">Date</code><code class="w"> </code><code class="n">date</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">Date</code><code class="p">();</code><code class="w"/>&#13;
<code class="w">    </code><code class="c1">// Equivalent, e.g., "Fri Dec 19 05:45:34 CST 1969"</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">String</code><code class="w"> </code><code class="n">d1</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">String</code><code class="p">.</code><code class="na">valueOf</code><code class="p">(</code><code class="n">date</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">String</code><code class="w"> </code><code class="n">d2</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">date</code><code class="p">.</code><code class="na">toString</code><code class="p">();</code><code class="w"/>&#13;
&#13;
<code class="w">    </code><code class="n">date</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="kc">null</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">d1</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">String</code><code class="p">.</code><code class="na">valueOf</code><code class="p">(</code><code class="n">date</code><code class="p">);</code><code class="w">  </code><code class="c1">// "null"</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">d2</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">date</code><code class="p">.</code><code class="na">toString</code><code class="p">();</code><code class="w">  </code><code class="c1">// NullPointerException!</code><code class="w"/></pre>&#13;
&#13;
<p>String <a data-primary="+ (plus) operator" data-type="indexterm" id="id1557"/><a data-primary="plus (+) operator" data-type="indexterm" id="id1558"/>concatenation uses the <code>valueOf()</code> method internally, so if you “add” an object or primitive using the plus operator (+), you get a <code>String</code>:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="n">String</code><code class="w"> </code><code class="n">today</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">"Today's date is :"</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">date</code><code class="p">;</code><code class="w"/></pre>&#13;
&#13;
<p>You’ll sometimes see people use the empty string and the plus operator (+) as shorthand to get the string value of an object. For example:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="n">String</code><code class="w"> </code><code class="n">two</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">""</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="mf">2.384f</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">String</code><code class="w"> </code><code class="n">today</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">""</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">Date</code><code class="p">();</code><code class="w"/></pre>&#13;
&#13;
<p>It’s a bit of a cheat, but it does work and it is visually succinct.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Comparing Strings" data-type="sect2"><div class="sect2" id="learnjava6-CHP-8-SECT-1.3">&#13;
<h2>Comparing Strings</h2>&#13;
&#13;
<p>The <a data-primary="equals() method, String" data-type="indexterm" id="id1559"/><a data-primary="equalsIgnoreCase() method, String" data-type="indexterm" id="id1560"/><a data-primary="String class" data-secondary="comparing strings" data-type="indexterm" id="ix_string_comp"/>standard <code>equals()</code> method can compare strings for <em>equality</em>; they must contain exactly the same characters in the same order. You can use a different method, <code>equalsIgnoreCase()</code>, to check the equivalence of strings in a case-insensitive way:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="n">String</code><code class="w"> </code><code class="n">one</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">"FOO"</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">String</code><code class="w"> </code><code class="n">two</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">"foo"</code><code class="p">;</code><code class="w"/>&#13;
&#13;
<code class="w">    </code><code class="n">one</code><code class="p">.</code><code class="na">equals</code><code class="p">(</code><code class="n">two</code><code class="p">);</code><code class="w">             </code><code class="c1">// false</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">one</code><code class="p">.</code><code class="na">equalsIgnoreCase</code><code class="p">(</code><code class="n">two</code><code class="p">);</code><code class="w">   </code><code class="c1">// true</code><code class="w"/></pre>&#13;
&#13;
<p>A common <a data-primary="== (equals operator)" data-type="indexterm" id="id1561"/><a data-primary="equals operator (==)" data-type="indexterm" id="id1562"/><a data-primary="equality versus identity" data-type="indexterm" id="id1563"/><a data-primary="identity versus equality" data-type="indexterm" id="id1564"/>mistake for novice programmers in Java is to compare strings with the <code>==</code> operator when they actually need the <code>equals()</code> method. Remember that strings are objects in Java, and <code>==</code> tests for object <em>identity</em>: that is, whether the two arguments being tested are the same object. In Java, it’s easy to make two strings that have the same characters but are not the same string object. For example:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="n">String</code><code class="w"> </code><code class="n">foo1</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">"foo"</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">String</code><code class="w"> </code><code class="n">foo2</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">String</code><code class="p">.</code><code class="na">valueOf</code><code class="p">(</code><code class="k">new</code><code class="w"> </code><code class="kt">char</code><code class="w"> </code><code class="o">[]</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="sc">'f'</code><code class="p">,</code><code class="w"> </code><code class="sc">'o'</code><code class="p">,</code><code class="w"> </code><code class="sc">'o'</code><code class="w"> </code><code class="p">});</code><code class="w"/>&#13;
&#13;
<code class="w">    </code><code class="n">foo1</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="n">foo2</code><code class="w">         </code><code class="c1">// false!</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">foo1</code><code class="p">.</code><code class="na">equals</code><code class="p">(</code><code class="n">foo2</code><code class="p">)</code><code class="w">  </code><code class="c1">// true</code><code class="w"/></pre>&#13;
&#13;
<p>This <a data-primary="literal strings" data-type="indexterm" id="id1565"/>mistake is particularly dangerous because it often works for the common case in which you are comparing <em>literal strings</em> (strings declared with double quotes right in the code). The reason for this is that Java tries to manage strings efficiently by combining them. At compile time, Java finds all the identical strings within a given class and makes only one object for them. This is safe because strings are immutable and cannot change, but it does leave room for this comparison problem.</p>&#13;
&#13;
<p>The <code>compareTo()</code> method <a data-primary="compareTo() method" data-secondary="String" data-type="indexterm" id="id1566"/>compares the lexical value of the <code>String</code> to another <code>String</code>, using the Unicode specification to compare the relative positions of two strings within the “alphabet.” (We use quotes as Unicode has many more characters than just the letters of the English alphabet.) It returns an integer that is less than, equal to, or greater than zero:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="n">String</code><code class="w"> </code><code class="n">abc</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">"abc"</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">String</code><code class="w"> </code><code class="n">def</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">"def"</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">String</code><code class="w"> </code><code class="n">num</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">"123"</code><code class="p">;</code><code class="w"/>&#13;
&#13;
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="n">abc</code><code class="p">.</code><code class="na">compareTo</code><code class="p">(</code><code class="n">def</code><code class="p">)</code><code class="w"> </code><code class="o">&lt;</code><code class="w"> </code><code class="mi">0</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="p">...</code><code class="w"> </code><code class="p">}</code><code class="w">  </code><code class="c1">// true</code><code class="w"/>&#13;
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="n">abc</code><code class="p">.</code><code class="na">compareTo</code><code class="p">(</code><code class="n">abc</code><code class="p">)</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="mi">0</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="p">...</code><code class="w"> </code><code class="p">}</code><code class="w"> </code><code class="c1">// true</code><code class="w"/>&#13;
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="n">abc</code><code class="p">.</code><code class="na">compareTo</code><code class="p">(</code><code class="n">num</code><code class="p">)</code><code class="w"> </code><code class="o">&gt;</code><code class="w"> </code><code class="mi">0</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="p">...</code><code class="w"> </code><code class="p">}</code><code class="w">  </code><code class="c1">// true</code><code class="w"/></pre>&#13;
&#13;
<p>You can’t really use the actual value returned by <code>compareTo()</code> beyond these three possibilities. Any negative number, be it -1, -5, or -1,000, simply means the first string is “less than” the second string. The <code>compareTo()</code> method compares strings strictly by their characters’ positions in the Unicode specification. This works for simple text but does not handle all language variations well. If you need more sophisticated comparisons with broader internationalization support, check out the documentation for <a href="https://oreil.ly/KrVCG">the <code>java.text.Collator</code> class</a>.<a data-primary="" data-startref="ix_string_comp" data-type="indexterm" id="id1567"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Searching" data-type="sect2"><div class="sect2" id="learnjava6-CHP-8-SECT-1.4">&#13;
<h2>Searching</h2>&#13;
&#13;
<p>The <code>String</code> class <a data-primary="searching strings for substrings" data-type="indexterm" id="id1568"/><a data-primary="startsWith() method, String" data-type="indexterm" id="id1569"/><a data-primary="String class" data-secondary="searching strings for substrings" data-type="indexterm" id="id1570"/><a data-primary="substrings" data-type="indexterm" id="id1571"/><a data-primary="endsWith() method, String" data-type="indexterm" id="id1572"/>provides several simple methods for finding fixed substrings within a string. The <code>startsWith()</code> and <code>endsWith()</code> methods compare an argument string with the beginning and end of the <code>String</code>, respectively:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="n">String</code><code class="w"> </code><code class="n">url</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">"http://foo.bar.com/"</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="n">url</code><code class="p">.</code><code class="na">startsWith</code><code class="p">(</code><code class="s">"http:"</code><code class="p">))</code><code class="w">  </code><code class="c1">// true</code><code class="w"/></pre>&#13;
&#13;
<p>The <code>indexOf()</code> method <a data-primary="indexOf() method" data-secondary="String" data-type="indexterm" id="id1573"/>searches for the first occurrence of a character or substring and returns the starting character position, or <code>-1</code> if the substring is not found:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="n">String</code><code class="w"> </code><code class="n">abcs</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">"abcdefghijklmnopqrstuvwxyz"</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">    </code><code class="kt">int</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">abcs</code><code class="p">.</code><code class="na">indexOf</code><code class="p">(</code><code class="sc">'p'</code><code class="p">);</code><code class="w">     </code><code class="c1">// 15</code><code class="w"/>&#13;
<code class="w">    </code><code class="kt">int</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">abcs</code><code class="p">.</code><code class="na">indexOf</code><code class="p">(</code><code class="s">"def"</code><code class="p">);</code><code class="w">   </code><code class="c1">// 3</code><code class="w"/>&#13;
<code class="w">    </code><code class="kt">int</code><code class="w"> </code><code class="n">I</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">abcs</code><code class="p">.</code><code class="na">indexOf</code><code class="p">(</code><code class="s">"Fang"</code><code class="p">);</code><code class="w">  </code><code class="c1">// -1</code><code class="w"/></pre>&#13;
&#13;
<p>Similarly, <code>lastIndexOf()</code> searches <a data-primary="lastIndexOf() method, String" data-type="indexterm" id="id1574"/>backward through the string for the last occurrence of a character or substring.</p>&#13;
&#13;
<p>The <code>contains()</code> method <a data-primary="contains() method" data-secondary="String" data-type="indexterm" id="id1575"/>handles the very common task of checking to see whether a given substring is contained in the target string:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="n">String</code><code class="w"> </code><code class="n">log</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">"There is an emergency in sector 7!"</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">    </code><code class="k">if</code><code class="w">  </code><code class="p">(</code><code class="n">log</code><code class="p">.</code><code class="na">contains</code><code class="p">(</code><code class="s">"emergency"</code><code class="p">))</code><code class="w"> </code><code class="n">pageSomeone</code><code class="p">();</code><code class="w"/>&#13;
&#13;
<code class="w">    </code><code class="c1">// equivalent to</code><code class="w"/>&#13;
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="n">log</code><code class="p">.</code><code class="na">indexOf</code><code class="p">(</code><code class="s">"emergency"</code><code class="p">)</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="o">-</code><code class="mi">1</code><code class="p">)</code><code class="w"> </code><code class="p">...</code><code class="w"/></pre>&#13;
&#13;
<p>For more <a data-primary="Regular Expression API" data-type="indexterm" id="id1576"/>complex searching, you can use the Regular Expression API, which allows you to look for and parse complex patterns. We’ll talk about regular expressions later in this chapter.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="String Method Summary" data-type="sect2"><div class="sect2" id="learnjava6-CHP-8-SECT-1.5">&#13;
<h2>String Method Summary</h2>&#13;
&#13;
<p><a data-type="xref" href="#learnjava6-CHP-8-TABLE-1">Table 8-1</a> summarizes the <a data-primary="String class" data-secondary="method summary" data-type="indexterm" id="id1577"/><a data-primary="methods" data-secondary="String summary" data-type="indexterm" id="id1578"/>methods provided by the <code>String</code> class. We’ve included several methods not discussed in this chapter. Feel free to try these methods out in <em>jshell</em> or look up the <a href="https://oreil.ly/lbM1R">documentation online</a>.</p>&#13;
<table id="learnjava6-CHP-8-TABLE-1">&#13;
<caption><span class="label">Table 8-1. </span>String methods</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Method</th>&#13;
<th>Functionality</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p><code>charAt()</code></p></td>&#13;
<td><p>Gets a particular character in the string</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>compareTo()</code></p></td>&#13;
<td><p>Compares the string with another string</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>concat()</code></p></td>&#13;
<td><p>Concatenates the string with another string</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>contains()</code></p></td>&#13;
<td><p>Checks whether the string contains another string</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>copyValueOf()</code></p></td>&#13;
<td><p>Returns a string equivalent to the specified character array</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>endsWith()</code></p></td>&#13;
<td><p>Checks whether the string ends with a specified suffix</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>equals()</code></p></td>&#13;
<td><p>Compares the string with another string</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>equalsIgnoreCase()</code></p></td>&#13;
<td><p>Compares the string with another string, ignoring case</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>getBytes()</code></p></td>&#13;
<td><p>Copies characters from the string into a byte array</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>getChars()</code></p></td>&#13;
<td><p>Copies characters from the string into a character array</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>hashCode()</code></p></td>&#13;
<td><p>Returns a hashcode for the string</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>indexOf()</code></p></td>&#13;
<td><p>Searches for the first occurrence of a character or substring in the string</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>intern()</code></p></td>&#13;
<td><p>Fetches a unique instance of the string from a global shared-string pool</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>isBlank()</code></p></td>&#13;
<td><p>Returns true if the string is zero length or contains only whitespace</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>isEmpty()</code></p></td>&#13;
<td><p>Returns true if the string is zero length</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>lastIndexOf()</code></p></td>&#13;
<td><p>Searches for the last occurrence of a character or substring in a string</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>length()</code></p></td>&#13;
<td><p>Returns the length of the string</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>lines()</code></p></td>&#13;
<td><p>Returns a stream of lines separated by line terminators</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>matches()</code></p></td>&#13;
<td><p>Determines if the whole string matches a regular expression pattern</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>regionMatches()</code></p></td>&#13;
<td><p>Checks whether a region of the string matches the specified region of another string</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>repeat()</code></p></td>&#13;
<td><p>Returns a concatenation of this string, repeated a given number of times</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>replace()</code></p></td>&#13;
<td><p>Replaces all occurrences of a character in the string with another character</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>replaceAll()</code></p></td>&#13;
<td><p>Replaces all occurrences of a regular expression pattern with a pattern</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>replaceFirst()</code></p></td>&#13;
<td><p>Replaces the first occurrence of a regular expression pattern with a pattern</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>split()</code></p></td>&#13;
<td><p>Splits the string into an array of strings using a regular expression pattern as a delimiter</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>startsWith()</code></p></td>&#13;
<td><p>Checks whether the string starts with a specified prefix</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>strip()</code></p></td>&#13;
<td><p>Removes leading and trailing whitespace as defined by <a href="https://oreil.ly/NK1Nl"><code>Character.isWhitespace()</code></a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>stripLeading()</code></p></td>&#13;
<td><p>Removes leading whitespace, similar to <code>strip()</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>stripTrailing()</code></p></td>&#13;
<td><p>Removes trailing whitespace, similar to <code>strip()</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>substring()</code></p></td>&#13;
<td><p>Returns a substring from the string</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>toCharArray()</code></p></td>&#13;
<td><p>Returns the array of characters from the string</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>toLowerCase()</code></p></td>&#13;
<td><p>Converts the string to lowercase</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>toString()</code></p></td>&#13;
<td><p>Returns the string value of an object</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>toUpperCase()</code></p></td>&#13;
<td><p>Converts the string to uppercase</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>trim()</code></p></td>&#13;
<td><p>Removes leading and trailing whitespace, defined here as any character with a Unicode position (called its <em>codepoint</em>) less than or equal to 32 (the “space” character)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>valueOf()</code></p></td>&#13;
<td><p>Returns a string representation of a value</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Things from Strings" data-type="sect1"><div class="sect1" id="learnjava6-CHP-8-SECT-2">&#13;
<h1>Things from Strings</h1>&#13;
&#13;
<p>Parsing and <a data-primary="numbers, parsing primitive" data-type="indexterm" id="id1579"/><a data-primary="parsing" data-secondary="primitive numbers" data-type="indexterm" id="id1580"/><a data-primary="primitive data types" data-secondary="parsing numbers" data-type="indexterm" id="id1581"/><a data-primary="String class" data-secondary="parsing primitive number types" data-type="indexterm" id="id1582"/>formatting text is a large, open-ended topic. So far in this chapter, we’ve looked at only primitive operations on strings—creation, searching, and turning simple values into strings. Now we’d like to move on to more structured forms of text. Java has a rich set of APIs for parsing and printing formatted strings, including numbers, dates, times, and currency values. We’ll cover most of these topics in this chapter, but we’ll wait to discuss date and time formatting in <a data-type="xref" href="#learnjava6-CHP-8-SECT-5.1">“Local Dates and Times”</a>.</p>&#13;
&#13;
<p>We’ll start with <em>parsing</em>—reading primitive numbers and values from strings, and chopping long strings into tokens. Then we’ll take a look at regular expressions, the most powerful text-parsing tool Java offers. Regular expressions let you define your own patterns of arbitrary complexity, search for them, and parse them from text.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Parsing Primitive Numbers" data-type="sect2"><div class="sect2" id="learnjava6-CHP-8-SECT-2.1">&#13;
<h2>Parsing Primitive Numbers</h2>&#13;
&#13;
<p>In Java, <a data-primary="java.lang package" data-secondary="primitive wrapper classes" data-type="indexterm" id="id1583"/><a data-primary="primitive data types" data-secondary="wrappers" data-type="indexterm" id="id1584"/>numbers, characters, and booleans are primitive types—not objects. But for each primitive type, Java also defines a <em>primitive wrapper</em> class. Specifically, the <code>java.lang</code> package includes the following classes: <code>Byte</code>, <code>Short</code>, <code>Integer</code>, <code>Long</code>, <code>Float</code>, <code>Double</code>, <code>Character</code>, and <code>Boolean</code>. We talked about these in <a data-type="xref" href="ch05.html#learnjava6-CHP-5-SECT-2.6">“Wrappers for Primitive Types”</a>, but we bring them up now because these classes hold static utility methods that parse their respective types from strings. Each of these primitive wrapper classes has a static “parse” method that reads a <code>String</code> and returns the corresponding primitive type. For example:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="kt">byte</code><code class="w"> </code><code class="n">b</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Byte</code><code class="p">.</code><code class="na">parseByte</code><code class="p">(</code><code class="s">"16"</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="kt">int</code><code class="w"> </code><code class="n">n</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Integer</code><code class="p">.</code><code class="na">parseInt</code><code class="p">(</code><code class="s">"42"</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="kt">long</code><code class="w"> </code><code class="n">l</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Long</code><code class="p">.</code><code class="na">parseLong</code><code class="p">(</code><code class="s">"99999999999"</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="kt">float</code><code class="w"> </code><code class="n">f</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Float</code><code class="p">.</code><code class="na">parseFloat</code><code class="p">(</code><code class="s">"4.2"</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="kt">double</code><code class="w"> </code><code class="n">d</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Double</code><code class="p">.</code><code class="na">parseDouble</code><code class="p">(</code><code class="s">"99.99999999"</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="kt">boolean</code><code class="w"> </code><code class="n">b</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Boolean</code><code class="p">.</code><code class="na">parseBoolean</code><code class="p">(</code><code class="s">"true"</code><code class="p">);</code><code class="w"/></pre>&#13;
&#13;
<p>You can <a data-primary="Integer class" data-type="indexterm" id="id1585"/><a data-primary="Long class" data-type="indexterm" id="id1586"/><a data-primary="radix argument" data-type="indexterm" id="id1587"/>find other ways to convert from strings to base types and back again, but these wrapper class methods are straightforward and easy to read. And in the case of <code>Integer</code> and <code>Long</code>, you can also supply an optional <em>radix</em> argument (the base of a number system; decimal numbers have a radix of 10, for example) to convert strings with octal or hexadecimal numbers. (Nondecimal data sometimes pops up when dealing with things such as cryptographic signatures or email attachments.)</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Tokenizing Text" data-type="sect2"><div class="sect2" id="learnjava6-CHP-8-SECT-2.2">&#13;
<h2>Tokenizing Text</h2>&#13;
&#13;
<p>You’ll rarely <a data-primary="String class" data-secondary="tokenizing text" data-type="indexterm" id="id1588"/><a data-primary="text processing" data-secondary="tokenizing text" data-type="indexterm" id="id1589"/><a data-primary="tokenizing text" data-type="indexterm" id="id1590"/>encounter strings with just one number to parse or with only the word you need. It’s a more common programming task to parse a longer string of text into individual words, or <em>tokens</em>, that are separated by some set of <em>delimiter characters</em>, such as spaces or commas.</p>&#13;
&#13;
<p>Programmers talk about tokens as a generic way to discuss different values or types present in a piece of text. A token might be a simple word, a username, an email address, or a number. Let’s take a look at some examples.</p>&#13;
&#13;
<p>Consider the sample text below. The first line contains words separated by single spaces. The remaining pair of lines involves comma-delimited fields:</p>&#13;
&#13;
<pre data-type="programlisting">    Now is the time for all good people&#13;
&#13;
    Check Number, Description,      Amount&#13;
    4231,         Java Programming, 1000.00</pre>&#13;
&#13;
<p>Java has several (unfortunately overlapping) methods and classes for handling situations like this. We’ll use the powerful <code>split()</code> method from the <code>String</code> class. It utilizes regular expressions to allow you to break up a string based on arbitrary patterns. We’ll talk about regular expressions shortly, but to show you how this works, we’ll just give you the necessary magic now.</p>&#13;
&#13;
<p>The <code>split()</code> method accepts a regular expression that describes a delimiter. It uses that expression to chop the string into an array of smaller <code>String</code>s:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="n">String</code><code class="w"> </code><code class="n">text1</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">"Now is the time for all good people"</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">String</code><code class="w"> </code><code class="o">[]</code><code class="w"> </code><code class="n">words</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">text1</code><code class="p">.</code><code class="na">split</code><code class="p">(</code><code class="s">"\\s"</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="c1">// words = "Now", "is", "the", "time", ...</code><code class="w"/>&#13;
&#13;
<code class="w">    </code><code class="n">String</code><code class="w"> </code><code class="n">text2</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">"4231,         Java Programming, 1000.00"</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">String</code><code class="w"> </code><code class="o">[]</code><code class="w"> </code><code class="n">fields</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">text2</code><code class="p">.</code><code class="na">split</code><code class="p">(</code><code class="s">"\\s*,\\s*"</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="c1">// fields = "4231", "Java Programming", "1000.00"</code><code class="w"/></pre>&#13;
&#13;
<p>In the first example, we used the <a data-primary="\s or \s* (single or multiple whitespace)" data-type="indexterm" id="id1591"/><a data-primary="whitespace, single or multiple (\s or \s*)" data-type="indexterm" id="id1592"/>regular expression <code>\\s</code>, which matches a single whitespace character (space, tab, or carriage return). Calling <code>split()</code> on our <code>text1</code> variable returns an array of eight strings. In the second example, we used a more complicated regular expression, <code>\\s*,\\s*</code>, which matches a comma surrounded by any amount of optional whitespace. This reduced our text to three nice, tidy fields.<a data-primary="" data-startref="ix_string_class" data-type="indexterm" id="id1593"/><a data-primary="" data-startref="ix_text_string_class" data-type="indexterm" id="id1594"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Regular Expressions" data-type="sect1"><div class="sect1" id="learnjava6-CHP-8-SECT-3">&#13;
<h1>Regular Expressions</h1>&#13;
&#13;
<p>Now it’s time to <a data-primary="regular expressions (regex)" data-type="indexterm" id="ix_regex_ch8"/><a data-primary="text processing" data-secondary="regular expressions" data-type="indexterm" id="ix_text_regex_ch8"/>take a brief detour on our trip through Java and enter the land of <em>regular expressions</em>. A regular expression, or <em>regex</em> for short, describes a text pattern. Regular expressions are used with many tools—including the <code>java.util.regex</code> package, text editors, and many scripting languages—to provide sophisticated text-searching and string-manipulation capabilities.</p>&#13;
&#13;
<p>Regular expressions can help you find all of the phone numbers in a large file. They can help you find all of the phone numbers with a particular area code. They can help you find all of the phone numbers that do <em>not</em> have a particular area code. You can use a regular expression to find links in the source of a web page. You can even use regular expressions to do some editing in a text file. You could look for phone numbers with the area code in parentheses, say (123) 456-7890, and replace it with the simpler 123-456-7890 format, for example. And key to the power of regular expressions, you can find <em>every</em> phone number in your block of text with parentheses and convert it—not just one specific phone number.</p>&#13;
&#13;
<p>If you are already familiar with the concept of regular expressions and how they are used with other languages, you may wish to skim through this section, but don’t skip it entirely. At the very least, you’ll need to look at <a data-type="xref" href="#learnjava6-CHP-8-SECT-3.2">“The java.util.regex API”</a> later in this chapter, which covers the Java classes necessary to use them. If you’re wondering exactly what regular expressions are, then grab a can or a cup of your favorite beverage and get ready. You are about to learn about the most powerful tool in the arsenal of text manipulation, as well as a tiny language within a language, all in the span of a few pages.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Regex Notation" data-type="sect2"><div class="sect2" id="learnjava6-CHP-8-SECT-3.1">&#13;
<h2>Regex Notation</h2>&#13;
&#13;
<p>A regular <a data-primary="patterns in regular expressions" data-type="indexterm" id="id1595"/><a data-primary="regular expressions (regex)" data-secondary="patterns" data-type="indexterm" id="id1596"/>expression (regex) describes a pattern in text. By <em>pattern</em>, we mean just about any feature you can imagine identifying in text from the literal characters alone, without actually understanding their meaning. This includes features such as words, word groupings, lines and paragraphs, punctuation, upper- or lowercase, and more generally, strings and numbers with a specific structure to them. (Think of things like phone numbers, email addresses, or zip codes.) With regular expressions, you can search the dictionary for all the words that have the letter “q” without its pal “u” next to it, or words that start and end with the same letter. Once you have constructed a pattern, you can use simple tools to hunt for it in text or to determine if a given string matches it.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Write once, run away" data-type="sect3"><div class="sect3" id="learnjava6-CHP-8-SECT-3.1.1">&#13;
<h3>Write once, run away</h3>&#13;
&#13;
<p>Regular <a data-primary="regular expressions (regex)" data-secondary="write once, run away" data-type="indexterm" id="id1597"/><a data-primary="write once, run away, regular expressions" data-type="indexterm" id="id1598"/>expressions constitute a simple form of programming language. Think for a moment about the examples we cited earlier. We would need something like a language to describe even simple patterns—such as email addresses—that have common elements but also some variation in form.</p>&#13;
&#13;
<p>A computer science textbook would classify regular expressions at the bottom of the hierarchy of computer languages, in terms of both what they can describe and what you can do with them. They are still capable of being quite sophisticated, however. As with most programming languages, the elements of regular expressions are simple, but you can combine them to create something quite complex. And that potential complexity is where things start to get sticky.</p>&#13;
&#13;
<p>Since regexes work on strings, which can be found everywhere in Java code, it is convenient to have a very compact notation. But compact notation can be cryptic, and experience shows that it is much easier to write a complex statement than to read it again later. Such is the curse of the regular expression. You may find yourself in a moment of late-night, caffeine-fueled inspiration, writing a single glorious pattern to simplify the rest of your program down to one line. When you return to read that line the next day, however, it may look like Egyptian hieroglyphics to you. Simpler is generally better, but if you can break your problem more clearly into several steps, maybe you should.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Escaped characters" data-type="sect3"><div class="sect3" id="learnjava6-CHP-8-SECT-3.1.2">&#13;
<h3>Escaped characters</h3>&#13;
&#13;
<p>Now that you’ve been <a data-primary="regular expressions (regex)" data-secondary="escaped characters" data-type="indexterm" id="ix_regex_escape_char"/><a data-primary="escaped characters, regular expressions" data-type="indexterm" id="ix_escape_char"/><a data-primary="\ (backslash), preceding escape sequences" data-type="indexterm" id="id1599"/><a data-primary="backslash (\), preceding escape sequences" data-type="indexterm" id="id1600"/>properly warned, we have to throw one more thing at you before we build you back up. Not only can the regex notation get a little hairy, but it is also somewhat ambiguous when used with ordinary Java strings. An important part of the notation is the escaped character—a character with a backslash in front of it. For example, in regex notation, the escaped <code>d</code> character, <code>\d</code>, (backslash “d”) is a shorthand for any single digit character (0–9). However, you cannot simply write <code>\d</code> as part of a Java string, because Java uses the backslash for its own special characters and to specify Unicode character sequences (<code>\uxxxx</code>). Fortunately, Java gives us a replacement: an <em>escaped backslash</em>: two backslashes (<code>\\</code>). It represents a literal backslash. The rule is, when you want a backslash to appear in your regex, you must escape it with an extra one:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="s">"\\d"</code><code class="w"> </code><code class="c1">// Java string that yields \d in a regex</code><code class="w"/></pre>&#13;
&#13;
<p>It gets weirder! Because regex notation itself uses a backslash to denote special characters, it must provide the same “escape hatch” for itself. You need to double up backslashes if you want your regex to match a literal backslash. It looks like this:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="s">"\\\\"</code><code class="w">  </code><code class="c1">// Java string yields two backslashes; regex yields one</code><code class="w"/></pre>&#13;
&#13;
<p>Most of the “magic” operator characters in this section operate on the character that precedes them, so you must escape them if you want their literal meaning. This includes such characters as <code>.</code>, <code>*</code>, <code>+</code>, <code>{}</code>, and <code>()</code>. An expression that can match formal US phone numbers (with the area code inside a pair of parentheses) looks like this:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="s">"\\(\\d\\d\dd\\) \\d\\d\\d-\\d\\d\\d\\d"</code><code class="w"/></pre>&#13;
&#13;
<p>If you need to create part of an expression that has lots of literal characters in it, you can use the special delimiters <code>\Q</code> and <code>\E</code> to help you. Any text appearing between <code>\Q</code> and <code>\E</code> is automatically escaped. (You still need the Java <code>String</code> escapes—double backslashes for backslash, but not quadruple.) There is also a <a data-primary="quote() method, Pattern" data-type="indexterm" id="id1601"/>static method called <code>Pattern.quote()</code> that does the same thing, returning a properly escaped version of whatever string you give it.</p>&#13;
&#13;
<p>We have one more suggestion to help maintain your cool when working with these examples. Write out the plain regex using a comment line above the real Java string (where you must double up all backslashes). We also tend to include a comment with an example of the text we hope to match. Here’s that US phone number example again with this commenting approach:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="c1">// US phone number: (123) 456-7890</code><code class="w"/>&#13;
<code class="w">    </code><code class="c1">// regex: \(\d\d\d\) \d\d\d-\d\d\d\d</code><code class="w"/>&#13;
<code class="w">    </code><code class="s">"\\(\\d\\d\dd\\) \\d\\d\\d-\\d\\d\\d\\d"</code><code class="w"/></pre>&#13;
&#13;
<p>And don’t forget <a data-primary="jshell" data-type="indexterm" id="id1602"/>about <em>jshell</em>! It can be a very powerful playground for testing and tweaking your patterns. We’ll see several examples of testing patterns with <em>jshell</em> in <a data-type="xref" href="#learnjava6-CHP-8-SECT-3.2">“The java.util.regex API”</a>. But first, let’s look at more of the elements you can use to construct patterns.<a data-primary="" data-startref="ix_escape_char" data-type="indexterm" id="id1603"/><a data-primary="" data-startref="ix_regex_escape_char" data-type="indexterm" id="id1604"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Characters and character classes" data-type="sect3"><div class="sect3" id="learnjava6-CHP-8-SECT-3.1.3">&#13;
<h3>Characters and character classes</h3>&#13;
&#13;
<p>Now, let’s <a data-primary="regular expressions (regex)" data-secondary="characters and character classes" data-type="indexterm" id="ix_regex_char_classes"/><a data-primary="characters, regular expressions" data-type="indexterm" id="ix_char_regex"/>dive into the actual regex syntax. The simplest form of a regular expression is plain, literal text, which has no special meaning and is matched directly (character for character) in the input. This can be a single character or more. For example, in the following string, the pattern <code>s</code> can match the character “s” in the words “rose” &#13;
<span class="keep-together">and “is”</span>:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="s">"A rose is $1.99."</code><code class="w"/></pre>&#13;
&#13;
<p>The pattern “rose” can match only the literal word <code>rose</code>. But this isn’t very interesting. Let’s crank things up a notch by introducing some special characters and the notion of character “classes”:</p>&#13;
<dl>&#13;
<dt><em>Any character: dot</em> (<code>.</code>)</dt>&#13;
<dd>&#13;
<p>The special <a data-primary="dot (.) notation/operator" data-secondary="any character" data-type="indexterm" id="id1605"/><a data-primary="dot (.) notation/operator" data-secondary="in regular expressions" data-secondary-sortas="regular expressions" data-type="indexterm" id="id1606"/>character dot (<code>.</code>) matches any single character. The pattern <code>.ose</code> matches “rose,” “nose,” “_ose” (space followed by “ose”), or any other character followed by the sequence “ose.” Two dots match any two characters (“prose,” “close”), and so on. The dot operator is very broad; it normally stops only for a <em>line terminator</em> (a newline, carriage return, or combination of both). Think of <code>.</code> as representing the class of all characters.</p>&#13;
</dd>&#13;
<dt><em>Whitespace or nonwhitespace character:</em>  <code>\s</code>, <code>\S</code></dt>&#13;
<dd>&#13;
<p>The special <a data-primary="\s or \S (whitespace or nonwhitespace character)" data-type="indexterm" id="id1607"/><a data-primary="whitespace or nonwhitespace character (\s or \S)" data-type="indexterm" id="id1608"/>character <code>\s</code> matches whitespace. <em>Whitespace</em> includes any character that relates to visual space in text or that marks the end of a line. Common whitespace characters include the literal space character (what you get when you press the space bar on your keyboard), <code>\t</code> (tab), <code>\r</code> (carriage return), <code>\n</code> (newline), and <code>\f</code> (formfeed). The corresponding special character <code>\S</code> does the inverse, matching any character that is <em>not</em> whitespace.</p>&#13;
</dd>&#13;
<dt><em>Digit or nondigit character</em>: <code>\d</code>, <code>\D</code></dt>&#13;
<dd>&#13;
<p><code>\d</code> matches <a data-primary="\d or \D (digit or nondigit character)" data-type="indexterm" id="id1609"/><a data-primary="digit or nondigit character (\d or \D)" data-type="indexterm" id="id1610"/>any of the digits from 0 to 9. <code>\D</code> does the inverse, matching all characters except digits.</p>&#13;
</dd>&#13;
<dt><em>Word or nonword character</em>: <code>\w</code>, <code>\W</code></dt>&#13;
<dd>&#13;
<p><code>\w</code> matches <a data-primary="word or nonword (\w or \W) character" data-type="indexterm" id="id1611"/><a data-primary="\w or \W (word or nonword) character" data-type="indexterm" id="id1612"/>characters typically found in “words,” such as upper- and lowercase letters A–Z, a–z, the digits 0–9, and the underscore character (_). <code>\W</code> matches everything except those characters.</p>&#13;
</dd>&#13;
</dl>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Custom character classes" data-type="sect3"><div class="sect3" id="learnjava6-CHP-8-SECT-3.1.4">&#13;
<h3>Custom character classes</h3>&#13;
&#13;
<p>You can define your own <a data-primary="regular expressions (regex)" data-secondary="custom character classes" data-type="indexterm" id="id1613"/><a data-primary="[] (index operator)" data-type="indexterm" id="id1614"/><a data-primary="index ([]) operator" data-type="indexterm" id="id1615"/>character classes using square brackets (<code>[ ]</code>) around the characters you want. Here are some examples:</p>&#13;
&#13;
<pre data-type="programlisting">    [abcxyz]     // matches any of a, b, c, x, y, or z&#13;
    [02468]      // matches any even digit&#13;
    [aeiouAEIOU] // matches any vowel, upper- or lowercase&#13;
    [AaEeIiOoUu] // also matches any vowel</pre>&#13;
&#13;
<p>The <a data-primary="range notation (x-y), regular expressions" data-type="indexterm" id="id1616"/><a data-primary="x-y (range notation), regular expressions" data-type="indexterm" id="id1617"/>special <code>x-y</code> <em>range notation</em> can be used as shorthand for consecutive runs of alphanumeric characters:</p>&#13;
&#13;
<pre data-type="programlisting">    [LMNOPQ]     // Explicit class of L, M, N, O, P, or Q&#13;
    [L-Q]        // Equivalent shorthand version&#13;
    [12345]      // Explicit class of 1, 2, 3, 4, or 5&#13;
    [1-5]        // Equivalent shorthand version</pre>&#13;
&#13;
<p>Placing a <a data-primary="carat (^)" data-secondary="inverting character class" data-type="indexterm" id="id1618"/><a data-primary="^ (carat)" data-secondary="inverting character class" data-type="indexterm" id="id1619"/>caret (<code>^</code>) as the first character inside the brackets inverts the character class, matching any character <em>except</em> those included in the brackets:</p>&#13;
&#13;
<pre data-type="programlisting">    [^A-F]       // G, H, I, ..., a, b, c, 1, 2, $, #... etc.&#13;
    [^aeiou]     // Any character that isn't a lowercase vowel</pre>&#13;
&#13;
<p>Nesting character classes simply concatenates them into a single class:<a data-primary="" data-startref="ix_char_regex" data-type="indexterm" id="id1620"/><a data-primary="" data-startref="ix_regex_char_classes" data-type="indexterm" id="id1621"/></p>&#13;
&#13;
<pre data-type="programlisting">    [A-F[G-Z]\s] // A-Z plus whitespace</pre>&#13;
&#13;
<p>You <a data-primary="&amp;&amp; logical AND in regular expression" data-type="indexterm" id="id1622"/>can use the <code>&amp;&amp;</code> logical AND notation (similar to the Boolean operator we saw in <a data-type="xref" href="ch04.html#learnjava6-CHP-4-SECT-5.2.1">“Operators”</a>) to take the <em>intersection</em> (characters in <span class="keep-together">common):</span></p>&#13;
&#13;
<pre data-type="programlisting">    [a-p&amp;&amp;[l-z]] // l, m, n, o, p&#13;
    [A-Z&amp;&amp;[^P]]  // A through Z except P</pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Position markers" data-type="sect3"><div class="sect3" id="learnjava6-CHP-8-SECT-3.1.5">&#13;
<h3>Position markers</h3>&#13;
&#13;
<p>The <a data-primary="regular expressions (regex)" data-secondary="position markers" data-type="indexterm" id="id1623"/><a data-primary="position markers, regular expressions" data-type="indexterm" id="id1624"/>pattern <code>[Aa] rose</code> (including an upper- or lowercase A) matches three times in the following phrase:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="s">"A rose is a rose is a rose"</code><code class="w"/></pre>&#13;
&#13;
<p>Position <a data-primary="^ (carat)" data-secondary="position marker" data-type="indexterm" id="id1625"/><a data-primary="carat (^)" data-secondary="position marker" data-type="indexterm" id="id1626"/><a data-primary="$ (dollar sign), position marker" data-type="indexterm" id="id1627"/><a data-primary="dollar sign ($), position marker" data-type="indexterm" id="id1628"/>characters allow you to designate the relative location of a match within a line. The most important are <code>^</code> and <code>$</code>, which match the beginning and end of a line, respectively:</p>&#13;
&#13;
<pre data-type="programlisting">    ^[Aa] rose  // matches "A rose" at the beginning of line&#13;
    [Aa] rose$  // matches "a rose" at end of line</pre>&#13;
&#13;
<p>To be a little more precise, <code>^</code> and <code>$</code> match the beginning and end of “input,” which is usually a single line. If you are working with multiple lines of text and wish to match the beginnings and endings of lines within a single large string, you can turn on “multiline” mode with a flag, as described later in <a data-type="xref" href="#learnjava6-CHP-8-SECT-3.1.8">“Special options”</a>.</p>&#13;
&#13;
<p>The <a data-primary="\b or \B (word boundary position marker)" data-type="indexterm" id="id1629"/><a data-primary="word boundary position marker (\b or \B)" data-type="indexterm" id="id1630"/>position markers <code>\b</code> and <code>\B</code> match a word boundary (whitespace, punctuation, or the beginning or end of a line), or a nonword boundary (the middle of a word), respectively. For example, the first pattern matches “rose” and “rosemary,” but not “primrose.” The second pattern matches “primrose” and “prose,” but not “rose” at the beginning of a word or by itself:</p>&#13;
&#13;
<pre data-type="programlisting">    \brose      // rose, rosemary, roses; NOT prose&#13;
    \Brose      // prose, primrose; NOT rose or rosemary</pre>&#13;
&#13;
<p>You often use these position markers when you need to look for or exclude prefixes or suffixes.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Iteration (multiplicity)" data-type="sect3"><div class="sect3" id="learnjava6-CHP-8-SECT-3.1.6">&#13;
<h3>Iteration (multiplicity)</h3>&#13;
&#13;
<p>Simply <a data-primary="iteration, regular expressions" data-type="indexterm" id="ix_iter_regex"/><a data-primary="multiplicity, regular expressions" data-type="indexterm" id="ix_multip_regex"/><a data-primary="regular expressions (regex)" data-secondary="iteration (multiplicity)" data-type="indexterm" id="ix_regex_iter"/><a data-primary="patterns in regular expressions" data-type="indexterm" id="id1631"/>matching fixed-character patterns will not get us very far. Next, we look at operators that count the number of occurrences of a character (or more generally, of a pattern, as we’ll see in <a data-type="xref" href="#learnjava6-CHP-8-SECT-3.2.1">“Pattern”</a>):</p>&#13;
<dl>&#13;
<dt><em>Any (zero or more iterations): asterisk</em> (<code>*</code>)</dt>&#13;
<dd>&#13;
<p>Placing an <a data-primary="* (asterisk)" data-secondary="any number of character iterations" data-type="indexterm" id="id1632"/><a data-primary="asterisk (*)" data-secondary="any number of character iterations" data-type="indexterm" id="id1633"/>asterisk (*) after a character or character class means “allow any number of that type of character”—in other words, zero or more. For example, the following pattern matches a digit with any number of leading zeros (possibly none):</p>&#13;
&#13;
<pre data-type="programlisting">    0*\d   // match a digit with any number of leading zeros</pre>&#13;
</dd>&#13;
<dt><em>Some (one or more iterations): plus sign</em> (<code>+</code>)</dt>&#13;
<dd>&#13;
<p>The <a data-primary="plus (+) operator" data-type="indexterm" id="id1634"/><a data-primary="+ (plus) operator" data-type="indexterm" id="id1635"/>plus sign (+) means “one or more” iterations and is equivalent to XX* (pattern followed by pattern asterisk). For example, the following pattern matches a number with one or more digits, plus optional leading zeros:</p>&#13;
<div class="openblock">&#13;
<pre data-type="programlisting">    0*\d+   // match a number (one or more digits) with optional&#13;
            // leading zeros</pre>&#13;
&#13;
<p>It may seem redundant to match the zeros at the beginning of an expression because zero is a digit and is thus matched by the <code>\d+</code> portion of the expression anyway. However, we’ll show later how you can pick apart the string using a regex and get at just the pieces you want. In this case, you might want to strip off the leading zeros and keep only the digits.</p>&#13;
</div>&#13;
</dd>&#13;
<dt><em>Optional (zero or one iteration): question mark</em> (<code>?</code>)</dt>&#13;
<dd>&#13;
<p>The <a data-primary="? (question mark), zero or one iteration" data-type="indexterm" id="id1636"/><a data-primary="question mark (?), zero or one iteration" data-type="indexterm" id="id1637"/>question mark operator (<code>?</code>) allows exactly zero or one iteration. For example, the following pattern matches a credit card expiration date, which may or may not have a slash in the middle:</p>&#13;
&#13;
<pre data-type="programlisting">    \d\d/?\d\d  // match four digits with optional slash in the middle</pre>&#13;
</dd>&#13;
<dt><em>Range (between x and y iterations, inclusive)</em>: <code>{x,y}</code></dt>&#13;
<dd>&#13;
<p>The <code>{x,y}</code> curly brace range operator is the most general iteration operator. It specifies a precise range to match. A range takes two arguments: a lower bound and an upper bound, separated by a comma. This regex matches any word with five to seven characters, inclusive:</p>&#13;
&#13;
<pre data-type="programlisting">    \b\w{5,7}\b  // match words with 5, 6, or 7 characters</pre>&#13;
</dd>&#13;
<dt><em>At least x or more iterations (y is infinite)</em>: <code>{x,}</code></dt>&#13;
<dd>&#13;
<p>If you omit the <a data-primary="{x,} (range), at least x or more iterations" data-type="indexterm" id="id1638"/>upper bound, simply leaving a dangling comma in the range, the upper bound becomes infinite. This is a way to specify a minimum of occurrences with no maximum.<a data-primary="" data-startref="ix_iter_regex" data-type="indexterm" id="id1639"/><a data-primary="" data-startref="ix_multip_regex" data-type="indexterm" id="id1640"/><a data-primary="" data-startref="ix_regex_iter" data-type="indexterm" id="id1641"/></p>&#13;
</dd>&#13;
</dl>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Alternation" data-type="sect3"><div class="sect3" id="learnjava6-CHP-8-SECT-3.1.7">&#13;
<h3>Alternation</h3>&#13;
&#13;
<p>The <a data-primary="regular expressions (regex)" data-secondary="alternation" data-type="indexterm" id="id1642"/><a data-primary="| (vertical bar)" data-secondary="alternation" data-type="indexterm" id="id1643"/><a data-primary="alternation (|), regular expressions" data-type="indexterm" id="id1644"/><a data-primary="vertical bar (|)" data-secondary="alternation" data-type="indexterm" id="id1645"/>vertical bar (<code>|</code>) operator denotes the logical OR operation, also called <em>alternation</em> or <em>choice</em>. The <code>|</code> operator does not operate on individual characters but instead applies to everything on either side of it. It splits the expression in two unless constrained by parentheses grouping. For example, a slightly naive approach to parsing dates might be the following:</p>&#13;
&#13;
<pre data-type="programlisting">    \w+, \w+ \d+, \d+|\d\d/\d\d/\d\d  // pattern 1 OR pattern 2</pre>&#13;
&#13;
<p>In this expression, the left matches patterns such as “Fri, Oct 12, 2001,” and the right matches “10/12/01.”</p>&#13;
&#13;
<p>The following regex might be used to match email addresses with one of three domains (<em>net</em>, <em>edu</em>, and <em>gov</em>):</p>&#13;
&#13;
<pre data-type="programlisting">    \w+@[\w.]+\.(net|edu|gov)&#13;
    // email address ending in .net, .edu, or .gov</pre>&#13;
&#13;
<p>This pattern is by no means complete in terms of true, valid email addresses. But it does highlight how you can use alternation to help build regular expressions with some useful characteristics.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Special options" data-type="sect3"><div class="sect3" id="learnjava6-CHP-8-SECT-3.1.8">&#13;
<h3>Special options</h3>&#13;
&#13;
<p><a data-primary="regular expressions (regex)" data-secondary="special options" data-type="indexterm" id="ix_regex_spec_opt"/>Several special options affect the way the regex engine performs its matching. These options can be applied in two ways:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>You can <a data-primary="compile() method, Pattern" data-type="indexterm" id="id1646"/>supply one or more special arguments (flags) to the <code>Pattern.compile()</code> step (discussed in <a data-type="xref" href="#learnjava6-CHP-8-SECT-3.2">“The java.util.regex API”</a>).</p>&#13;
</li>&#13;
<li>&#13;
<p>You can include a special block of code in your regex.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>We’ll show the latter approach here. To do this, include one or more flags in a special block <code>(?</code><em><code>x</code></em><code>)</code>, where <em><code>x</code></em> is the flag for the option we want to turn on. Generally, you do this at the beginning of the regex. You can also turn off flags by adding a minus sign <code>(?-</code><em><code>x</code></em><code>)</code>, which allows you to apply flags to select parts of your pattern.</p>&#13;
&#13;
<p>The following flags are available:</p>&#13;
<dl>&#13;
<dt><em>Case-insensitive</em>: <code>(?i)</code></dt>&#13;
<dd>&#13;
<p>The <code>(?i)</code> flag <a data-primary="case-insensitive flag (?i)" data-type="indexterm" id="id1647"/><a data-primary="?i (case-insensitive flag)" data-type="indexterm" id="id1648"/>tells the regex engine to ignore character case while matching. For example:</p>&#13;
&#13;
<pre data-type="programlisting">    (?i)yahoo   // matches Yahoo, yahoo, yahOO, etc.</pre>&#13;
</dd>&#13;
<dt><em>Dot all</em>: <code>(?s)</code></dt>&#13;
<dd>&#13;
<p>The <code>(?s)</code> flag <a data-primary="?s (dot all flag)" data-type="indexterm" id="id1649"/><a data-primary="dot all flag (?s)" data-type="indexterm" id="id1650"/><a data-primary="dot (.) notation/operator" data-secondary="any character" data-type="indexterm" id="id1651"/>turns on “dot all” mode, allowing the dot character to match anything, including end-of-line characters. It is useful if you are matching patterns that span multiple lines. The <code>s</code> stands for “single-line mode,” a somewhat confusing name derived from Perl.</p>&#13;
</dd>&#13;
<dt><em>Multiline</em>: <code>(?m)</code></dt>&#13;
<dd>&#13;
<p>By <a data-primary="?m (multiline flag)" data-type="indexterm" id="id1652"/><a data-primary="multiline flag (?m)" data-type="indexterm" id="id1653"/>default, <code>^</code> and <code>$</code> don’t really match the beginnings and ends of lines (as defined by carriage return or newline combinations). Instead, they match the beginning or end of the entire input text. In many cases, “one line” is synonymous with the entire input.</p>&#13;
&#13;
<p>If you have a big block of text to process, you’ll often break that block into separate lines for other reasons. If you do that, checking any given line for a regular expression will be straightforward, and <code>^</code> and <code>$</code> will behave as expected. However, if you want to use a regex with the entire input string containing multiple lines (separated by those carriage return or newline combinations), you can turn on multiline mode with <code>(?m)</code>. This flag causes <code>^</code> and <code>$</code> to match the beginning and end of the individual lines <em>within</em> the block of text, <em>as well as</em> the beginning and end of the entire block. Specifically, this means the spot before the first character, the spot after the last character, and the spots just before and after line terminators inside the string.</p>&#13;
</dd>&#13;
<dt><em>Unix lines</em>: <code>(?d)</code></dt>&#13;
<dd>&#13;
<p>The <code>(?d)</code> flag <a data-primary="Unix lines flag (?d)" data-type="indexterm" id="id1654"/><a data-primary="?d (Unix lines flag)" data-type="indexterm" id="id1655"/>limits the definition of the line terminator for the <code>^</code>, <code>$</code>, and <code>.</code> special characters to Unix-style newline only (<code>\n</code>). By default, carriage return newline (<code>\r\n</code>) is also allowed.<a data-primary="" data-startref="ix_regex_spec_opt" data-type="indexterm" id="id1656"/></p>&#13;
</dd>&#13;
</dl>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The java.util.regex API" data-type="sect2"><div class="sect2" id="learnjava6-CHP-8-SECT-3.2">&#13;
<h2>The java.util.regex API</h2>&#13;
&#13;
<p>Now that we’ve <a data-primary="regular expressions (regex)" data-secondary="Java API for" data-type="indexterm" id="ix_regext_java_util"/><a data-primary="java.util.regext API" data-type="indexterm" id="ix_java_util_regex"/>covered the theory of how to construct regular expressions, the hard part is over. All that’s left is to investigate the Java API to see how to apply these expressions.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Pattern" data-type="sect3"><div class="sect3" id="learnjava6-CHP-8-SECT-3.2.1">&#13;
<h3>Pattern</h3>&#13;
&#13;
<p>As we’ve said, the <a data-primary="regular expressions (regex)" data-secondary="patterns" data-type="indexterm" id="ix_regex_pattern"/><a data-primary="patterns in regular expressions" data-type="indexterm" id="ix_pattern_regex"/><a data-primary="convenience methods" data-type="indexterm" id="id1657"/>regex patterns that we write as strings are, in actuality, little programs describing how to match text. At runtime, the Java regex package compiles these little programs into a form that it can execute against some target text. Several simple convenience methods accept strings directly to use as patterns.</p>&#13;
&#13;
<p>The static <a data-primary="matches() method, Pattern" data-type="indexterm" id="id1658"/>method <code>Pattern.matches()</code> takes two strings—a regex and a target string—and determines if the target matches the regex. This is very convenient if you want to do a quick test once in your application. For example:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="n">Boolean</code><code class="w"> </code><code class="n">match</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Pattern</code><code class="p">.</code><code class="na">matches</code><code class="p">(</code><code class="s">"\\d+\\.\\d+f?"</code><code class="p">,</code><code class="w"> </code><code class="n">myText</code><code class="p">);</code><code class="w"/></pre>&#13;
&#13;
<p>This line of code can test whether the string <code>myText</code> contains a Java-style floating-point number such as “42.0f.” Note that the string must match completely to be considered a match. If you want to see if a small pattern is contained within a larger string but don’t care about the rest of the string, you have to use a <code>Matcher</code>, as described in <a data-type="xref" href="#learnjava6-CHP-8-SECT-3.2.2">“The Matcher”</a>.</p>&#13;
&#13;
<p>Let’s try another (simplified) pattern that we could use in our game once we start letting multiple players compete against each other. Many login systems use email addresses as the user identifier. Such systems aren’t perfect, of course, but an email address will work for our needs. We would like to invite users to input their email address, but we want to make sure it looks valid before using it. A regular expression can be a quick way to perform such a validation.<sup><a data-type="noteref" href="ch08.html#id1659" id="id1659-marker">3</a></sup></p>&#13;
&#13;
<p>Much like writing algorithms to solve programming problems, designing a regular expression requires you to break your pattern matching problem into bite-sized pieces. If we think about email addresses, a few patterns stand out right away. The most obvious is the <code>@</code> in the middle of every address. A naive (but better than nothing!) pattern relying on that fact could be built like this:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="n">String</code><code class="w"> </code><code class="n">sample</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">"my.name@some.domain"</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">Boolean</code><code class="w"> </code><code class="n">validEmail</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Pattern</code><code class="p">.</code><code class="na">matches</code><code class="p">(</code><code class="s">".*@.*"</code><code class="p">,</code><code class="w"> </code><code class="n">sample</code><code class="p">);</code><code class="w"/></pre>&#13;
&#13;
<p>But that pattern is too permissive. It will certainly recognize valid email addresses, but it will also recognize many invalid ones like <code>"bad.address@"</code> or <code>"@also.bad"</code> or even <code>"@@"</code>. Let’s test these out in <em>jshell</em>:</p>&#13;
&#13;
<pre class="jshell" data-type="programlisting">jshell&gt; String sample = "my.name@some.domain";&#13;
sample ==&gt; "my.name@some.domain"&#13;
&#13;
jshell&gt; Pattern.matches(".*@.*", sample)&#13;
Pattern.matches(".*@.*", sample)$2 ==&gt; true&#13;
&#13;
jshell&gt; Pattern.matches(".*@.*", "bad.address@")&#13;
Pattern.matches(".*@.*", "bad.address@")$3 ==&gt; true&#13;
&#13;
jshell&gt; Pattern.matches(".*@.*", "@@")&#13;
Pattern.matches(".*@.*", "@@")$4 ==&gt; true</pre>&#13;
&#13;
<p>Try to cook up a few more bad examples of your own. You’ll quickly see that our simple email pattern is definitely too simple.</p>&#13;
&#13;
<p>How can we make better matches? One quick adjustment would be to use the <code>+</code> modifier instead of the <code>*</code>. The upgraded pattern now requires at least one character on each side of the <code>@</code>. But we know a few other things about email addresses. For example, the left “half” of the address (the name portion) cannot contain the <code>@</code> character. For that matter, neither can the domain portion. We can use a custom character class for this next upgrade:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="n">String</code><code class="w"> </code><code class="n">sample</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">"my.name@some.domain"</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">Boolean</code><code class="w"> </code><code class="n">validEmail</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Pattern</code><code class="p">.</code><code class="na">matches</code><code class="p">(</code><code class="s">"[^@]+@[^@]+"</code><code class="p">,</code><code class="w"> </code><code class="n">sample</code><code class="p">);</code><code class="w"/></pre>&#13;
&#13;
<p>This pattern is better but still allows several invalid addresses such as <code>"still@bad"</code> since domain names have at least a name followed by a period (<code>.</code>) followed by a top-level domain (TLD) such as “oreilly.com.” So maybe a pattern like this:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="n">String</code><code class="w"> </code><code class="n">sample</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">"my.name@some.domain"</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">Boolean</code><code class="w"> </code><code class="n">validEmail</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Pattern</code><code class="p">.</code><code class="na">matches</code><code class="p">(</code><code class="s">"[^@]+@[^@]+\\.(com|org)"</code><code class="p">,</code><code class="w"> </code><code class="n">sample</code><code class="p">);</code><code class="w"/></pre>&#13;
&#13;
<p>That pattern fixes our issue with an address like <code>"still@bad"</code>, but we’ve gone a bit too far the other way. There are many, many TLDs—too many to reasonably list even if we ignore the problem of maintaining that list as new TLDs are added.<sup><a data-type="noteref" href="ch08.html#id1660" id="id1660-marker">4</a></sup> So let’s step back a little. We’ll keep the “dot” in the domain portion, but remove the specific TLD and just accept a simple run of letters:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="n">String</code><code class="w"> </code><code class="n">sample</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">"my.name@some.domain"</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">Boolean</code><code class="w"> </code><code class="n">validEmail</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Pattern</code><code class="p">.</code><code class="na">matches</code><code class="p">(</code><code class="s">"[^@]+@[^@]+\\.[a-z]+"</code><code class="p">,</code><code class="w"> </code><code class="n">sample</code><code class="p">);</code><code class="w"/></pre>&#13;
&#13;
<p>Much better. We can add one last tweak to make sure we don’t worry about the case of the address since all email addresses are case-insensitive. Just tack on the <code>(?i)</code> flag at the beginning of our pattern string:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="n">String</code><code class="w"> </code><code class="n">sample</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">"my.name@some.domain"</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">Boolean</code><code class="w"> </code><code class="n">validEmail</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Pattern</code><code class="p">.</code><code class="na">matches</code><code class="p">(</code><code class="s">"(?i)[^@]+@[^@]+\\.[a-z]+"</code><code class="p">,</code><code class="w"> </code><code class="n">sample</code><code class="p">);</code><code class="w"/></pre>&#13;
&#13;
<p>Again, this is by no means a perfect email validator, but it is definitely a good start and suffices for our hypothetical login system:</p>&#13;
&#13;
<pre class="jshell" data-type="programlisting">jshell&gt; Pattern.matches("(?i)[^@]+@[^@]+\\.[a-z]+", "good@some.domain")&#13;
$1 ==&gt; true&#13;
&#13;
jshell&gt; Pattern.matches("(?i)[^@]+@[^@]+\\.[a-z]+", "good@oreilly.com")&#13;
$2 ==&gt; true&#13;
&#13;
jshell&gt; Pattern.matches("(?i)[^@]+@[^@]+\\.[a-z]+", "oreilly.com")&#13;
$3 ==&gt; false&#13;
&#13;
jshell&gt; Pattern.matches("(?i)[^@]+@[^@]+\\.[a-z]+", "bad@oreilly@com")&#13;
$4 ==&gt; false&#13;
&#13;
jshell&gt; Pattern.matches("(?i)[^@]+@[^@]+\\.[a-z]+", "me@oreilly.COM")&#13;
$5 ==&gt; true&#13;
&#13;
jshell&gt; Pattern.matches("[^@]+@[^@]+\\.[a-z]+", "me@oreilly.COM")&#13;
$6 ==&gt; false</pre>&#13;
&#13;
<p>In these <a data-primary="matches() method, Pattern" data-type="indexterm" id="id1661"/>examples, we typed in the full <code>Pattern.matches(…​)</code> line only once. After that it was a simple up arrow, edit, and then hit Return for the subsequent five lines. Can you spot the flaw in our final pattern that causes the match to fail?<a data-primary="" data-startref="ix_pattern_regex" data-type="indexterm" id="id1662"/><a data-primary="" data-startref="ix_regex_pattern" data-type="indexterm" id="id1663"/></p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>If you want to tinker around with the validation pattern and expand or improve it, remember you can “reuse” lines in <em>jshell</em> with the keyboard arrow keys. Use the up arrow to retrieve the previous line. Indeed, you can use the up arrow and down arrow to navigate all of your recent lines. Within a line, use the left arrow and right arrow to move around and delete/add/edit your command. Then just press the Return key to run the newly altered command—you do not need to move the cursor to the end of the line before pressing Return.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The Matcher" data-type="sect3"><div class="sect3" id="learnjava6-CHP-8-SECT-3.2.2">&#13;
<h3>The Matcher</h3>&#13;
&#13;
<p>A <code>Matcher</code> associates a <a data-primary="regular expressions (regex)" data-secondary="Matcher" data-type="indexterm" id="id1664"/><a data-primary="Matcher class, regular expressions" data-type="indexterm" id="id1665"/>pattern with a string and provides tools for testing, finding, and iterating over matches of the pattern against it. <a data-primary="reset() method" data-secondary="Matcher" data-type="indexterm" id="id1666"/>The <code>Matcher</code> is “stateful.” For example, the <code>find()</code> method tries to find the next match each time it is called. But you can clear the <code>Matcher</code> and start over by calling its <code>reset()</code> method.</p>&#13;
&#13;
<p>To <a data-primary="compile() method, Pattern" data-type="indexterm" id="id1667"/>create a <code>Matcher</code> object, you first need to compile your pattern string into a <code>Pattern</code> object using the static <code>Pattern.compile()</code> method. With that pattern object in hand, you can use the <code>matcher()</code> method to get your <code>Matcher</code>, like so:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="n">String</code><code class="w"> </code><code class="n">myText</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">"Lots of text with hyperlinks and stuff ..."</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">Pattern</code><code class="w"> </code><code class="n">urlPattern</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Pattern</code><code class="p">.</code><code class="na">compile</code><code class="p">(</code><code class="s">"https?://[\\w./]*"</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">Matcher</code><code class="w"> </code><code class="n">matcher</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">urlPattern</code><code class="p">.</code><code class="na">matcher</code><code class="p">(</code><code class="n">myText</code><code class="p">);</code><code class="w"/></pre>&#13;
&#13;
<p>If you’re just <a data-primary="lookingAt() method, Matcher" data-type="indexterm" id="id1668"/>interested in “one big match”—that is, you’re expecting your string to either match the pattern or not—you can use <code>matches()</code> or <code>lookingAt()</code>. These correspond roughly to the methods <code>equals()</code> and <code>startsWith()</code> of the <code>String</code> class. The <code>matches()</code> method asks if the string matches the pattern in its entirety (with no string characters left over) and returns <code>true</code> or <code>false</code>. The <code>lookingAt()</code> method does the same, except that it asks only whether the string starts with the pattern and doesn’t care if the pattern uses up all the string’s characters.</p>&#13;
&#13;
<p>More <a data-primary="end() method, Matcher" data-type="indexterm" id="id1669"/><a data-primary="group() method, Matcher" data-type="indexterm" id="id1670"/><a data-primary="start() method" data-secondary="Matcher" data-type="indexterm" id="id1671"/><a data-primary="find() method, Matcher" data-type="indexterm" id="id1672"/>generally, you’ll want to be able to search through the string and find one or more matches. To do this, you can use the <code>find()</code> method. Each call to <code>find()</code> returns <code>true</code> or <code>false</code> for the next match of the pattern and internally notes the position of the matching text. You can get the starting and ending character positions with the <code>Matcher start()</code> and <code>end()</code> methods, or you can simply retrieve the matched text with the <code>group()</code> method. For example:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kn">import</code><code class="w"> </code><code class="nn">java.util.regex.*</code><code class="p">;</code><code class="w"/>&#13;
&#13;
<code class="c1">// ...</code><code class="w"/>&#13;
&#13;
<code class="w">    </code><code class="n">String</code><code class="w"> </code><code class="n">text</code><code class="o">=</code><code class="s">"A horse is a horse, of course of course..."</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">String</code><code class="w"> </code><code class="n">pattern</code><code class="o">=</code><code class="s">"horse|course"</code><code class="p">;</code><code class="w"/>&#13;
&#13;
<code class="w">    </code><code class="n">Matcher</code><code class="w"> </code><code class="n">matcher</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Pattern</code><code class="p">.</code><code class="na">compile</code><code class="p">(</code><code class="n">pattern</code><code class="p">).</code><code class="na">matcher</code><code class="p">(</code><code class="n">text</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="k">while</code><code class="w"> </code><code class="p">(</code><code class="n">matcher</code><code class="p">.</code><code class="na">find</code><code class="p">())</code><code class="w"/>&#13;
<code class="w">      </code><code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="w"/>&#13;
<code class="w">        </code><code class="s">"Matched: '"</code><code class="o">+</code><code class="n">matcher</code><code class="p">.</code><code class="na">group</code><code class="p">()</code><code class="o">+</code><code class="s">"' at position "</code><code class="o">+</code><code class="n">matcher</code><code class="p">.</code><code class="na">start</code><code class="p">());</code><code class="w"/></pre>&#13;
&#13;
<p>The previous snippet prints the starting location of the words “horse” and “course” (four in all):</p>&#13;
&#13;
<pre data-type="programlisting">    Matched: 'horse' at position 2&#13;
    Matched: 'horse' at position 13&#13;
    Matched: 'course' at position 23&#13;
    Matched: 'course' at position 33</pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Splitting strings" data-type="sect3"><div class="sect3" id="learnjava6-CHP-8-SECT-3.2.3">&#13;
<h3>Splitting strings</h3>&#13;
&#13;
<p>A very <a data-primary="String class" data-secondary="splitting strings" data-type="indexterm" id="id1673"/><a data-primary="strings" data-secondary="splitting in regular expressions" data-type="indexterm" id="id1674"/><a data-primary="split() method, String" data-type="indexterm" id="id1675"/>common need is to parse a string into a bunch of fields based on some delimiter, such as a comma. It’s such a common problem that the <code>String</code> class contains a method for doing just this. The <code>split()</code> method accepts a regular expression and returns an array of substrings broken around that pattern. Consider the following string and <code>split()</code> calls:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="n">String</code><code class="w"> </code><code class="n">text</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">"Foo, bar ,   blah"</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">String</code><code class="o">[]</code><code class="w"> </code><code class="n">badFields</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">text</code><code class="p">.</code><code class="na">split</code><code class="p">(</code><code class="s">","</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="c1">// { "Foo", " bar ", "   blah" }</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">String</code><code class="o">[]</code><code class="w"> </code><code class="n">goodFields</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">text</code><code class="p">.</code><code class="na">split</code><code class="p">(</code><code class="s">"\\s*,\\s*"</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="c1">// { "Foo", "bar", "blah" }</code><code class="w"/></pre>&#13;
&#13;
<p>The first <code>split()</code> returns a <code>String</code> array, but the <a data-primary="String arrays" data-type="indexterm" id="id1676"/>naive use of <code>,</code> to separate the string means the space characters in our <code>text</code> variable remain stuck to the more interesting characters. We get <code>“Foo”</code> as a single word, as expected, but then we get <code>“bar&lt;space&gt;”</code> and finally <code>“&lt;space&gt;&lt;space&gt;&lt;space&gt;blah”</code>. Yikes! The second <code>split()</code> also yields a <code>String</code> array, but this time containing the expected <code>“Foo”, “bar”</code> (with no trailing space), and <code>“blah”</code> (with no leading spaces).</p>&#13;
&#13;
<p>If you are going to use an operation like this more than a few times in your code, you should probably compile the pattern and use its <code>split()</code> method, which is identical to the version in <code>String</code>. The <code>String split()</code> method is equivalent to:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="n">Pattern</code><code class="p">.</code><code class="na">compile</code><code class="p">(</code><code class="n">pattern</code><code class="p">).</code><code class="na">split</code><code class="p">(</code><code class="n">string</code><code class="p">);</code><code class="w"/></pre>&#13;
&#13;
<p>As we noted before, there is a lot to learn about regular expressions above and beyond the few regex capabilities we covered here. Check out the <a href="https://oreil.ly/L8BUD">documentation on patterns</a>. Play around on your own using <em>jshell</em>. Modify the <em>ch08/examples/ValidEmail.java</em> file and see if you can create a better email validator! This is definitely a topic that benefits from practice.<a data-primary="" data-startref="ix_regex_ch8" data-type="indexterm" id="id1677"/><a data-primary="" data-startref="ix_text_regex_ch8" data-type="indexterm" id="id1678"/><a data-primary="" data-startref="ix_java_util_regex" data-type="indexterm" id="id1679"/><a data-primary="" data-startref="ix_regext_java_util" data-type="indexterm" id="id1680"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Math Utilities" data-type="sect1"><div class="sect1" id="learnjava6-CHP-8-SECT-4">&#13;
<h1>Math Utilities</h1>&#13;
&#13;
<p>Of course, <a data-primary="text processing" data-secondary="math utilities" data-type="indexterm" id="ix_text_math_util"/><a data-primary="math utilities" data-type="indexterm" id="ix_math_util"/>string manipulation and pattern matching are not the only types of operations Java can do. Java supports integer and floating-point arithmetic directly in the language. Higher-level math operations are supported through the <code>java.lang.Math</code> class. As you have seen, wrapper classes for primitive data types allow you to treat them as objects. Wrapper classes also hold some methods for basic conversions.</p>&#13;
&#13;
<p>Let’s <a data-primary="ArithmeticException" data-type="indexterm" id="id1681"/>start with a quick look at the built-in arithmetic in Java. Java handles errors in integer arithmetic by throwing an <code>ArithmeticException</code>:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="kt">int</code><code class="w"> </code><code class="n">zero</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"/>&#13;
&#13;
<code class="w">    </code><code class="k">try</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="kt">int</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">72</code><code class="w"> </code><code class="o">/</code><code class="w"> </code><code class="n">zero</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">}</code><code class="w"> </code><code class="k">catch</code><code class="w"> </code><code class="p">(</code><code class="n">ArithmeticException</code><code class="w"> </code><code class="n">e</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="c1">// division by zero</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>To generate the error in this example, we created the intermediate variable <code>zero</code>. The compiler is somewhat crafty. It would have caught us if we had tried to divide by <code>0</code> directly.</p>&#13;
&#13;
<p>Floating-point <a data-primary="floating-point values" data-type="indexterm" id="id1682"/>arithmetic expressions, on the other hand, don’t throw exceptions. Instead, they take on the special out-of-range values shown in <a data-type="xref" href="#learnjava6-CHP-8-TABLE-2">Table 8-2</a>.</p>&#13;
<table id="learnjava6-CHP-8-TABLE-2">&#13;
<caption><span class="label">Table 8-2. </span>Special floating-point values</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Value</th>&#13;
<th>Mathematical representation</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p><code>POSITIVE_INFINITY</code></p></td>&#13;
<td><p>1.0/0.0</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>NEGATIVE_INFINITY</code></p></td>&#13;
<td><p>-1.0/0.0</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>NaN</code></p></td>&#13;
<td><p>0.0/0.0</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p class="pagebreak-before">The following example generates an infinite result:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="kt">double</code><code class="w"> </code><code class="n">zero</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mf">0.0</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">    </code><code class="kt">double</code><code class="w"> </code><code class="n">d</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mf">1.0</code><code class="o">/</code><code class="n">zero</code><code class="p">;</code><code class="w"/>&#13;
&#13;
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="n">d</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="n">Double</code><code class="p">.</code><code class="na">POSITIVE_INFINITY</code><code class="p">)</code><code class="w"/>&#13;
<code class="w">      </code><code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="s">"Division by zero"</code><code class="p">);</code><code class="w"/></pre>&#13;
&#13;
<p>The <a data-primary="NaN (not-a-number)" data-type="indexterm" id="id1683"/>special value <code>NaN</code> (not a number) indicates the result of dividing zero by zero. This value has the special mathematical distinction of not being equal to itself (<code>NaN != NaN</code> evaluates to <code>true</code>). Use <code>Float.isNaN()</code> or <code>Double.isNaN()</code> to test for <code>NaN</code>.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The java.lang.Math Class" data-type="sect2"><div class="sect2" id="learnjava6-CHP-8-SECT-4.1">&#13;
<h2>The java.lang.Math Class</h2>&#13;
&#13;
<p>The <code>java.lang.Math</code> class is Java’s <a data-primary="Math class" data-type="indexterm" id="ix_math_class"/><a data-primary="type system" data-secondary="Math class" data-type="indexterm" id="ix_type_math_class"/><a data-primary="java.lang package" data-secondary="Math class" data-type="indexterm" id="ix_java_lang_math"/><a data-primary="methods" data-secondary="Math class list" data-type="indexterm" id="id1684"/>math library. It holds a suite of static methods covering all of the usual mathematical operations like <code>sin()</code>, <code>cos()</code>, and <code>sqrt()</code>. The <code>Math</code> class isn’t very object-oriented (you can’t create an instance of <code>Math</code>). Instead, it’s really just a convenient holder for static methods that are more like global functions. As we saw in <a data-type="xref" href="ch05.html#learnjava6-CHP-5">Chapter 5</a>, it’s possible to use the static import functionality to import the names of static methods and constants like this directly into the scope of our class and use them by their simple, unqualified names.</p>&#13;
&#13;
<p><a data-type="xref" href="#learnjava6-CHP-8-TABLE-3">Table 8-3</a> summarizes the methods in <code>java.lang.Math</code>.</p>&#13;
<table id="learnjava6-CHP-8-TABLE-3">&#13;
<caption><span class="label">Table 8-3. </span>Methods in java.lang.Math</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Method</th>&#13;
<th>Argument type(s)</th>&#13;
<th>Functionality</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p><code>Math.abs(a)</code></p></td>&#13;
<td><p><code>int</code>, <code>long</code>, <code>float</code>, <code>double</code></p></td>&#13;
<td><p>Absolute value</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>Math.acos(a)</code></p></td>&#13;
<td><p><code>double</code></p></td>&#13;
<td><p>Arc cosine</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>Math.asin(a)</code></p></td>&#13;
<td><p><code>double</code></p></td>&#13;
<td><p>Arc sine</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>Math.atan(a)</code></p></td>&#13;
<td><p><code>double</code></p></td>&#13;
<td><p>Arc tangent</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>Math.atan2(a,b)</code></p></td>&#13;
<td><p><code>double</code></p></td>&#13;
<td><p>Angle part of rectangular-to-polar coordinate transform</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>Math.ceil(a)</code></p></td>&#13;
<td><p><code>double</code></p></td>&#13;
<td><p>Smallest whole number greater than or equal to <code>a</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>Math.cbrt(a)</code></p></td>&#13;
<td><p><code>double</code></p></td>&#13;
<td><p>Cube root of <code>a</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>Math.cos(a)</code></p></td>&#13;
<td><p><code>double</code></p></td>&#13;
<td><p>Cosine</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>Math.cosh(a)</code></p></td>&#13;
<td><p><code>double</code></p></td>&#13;
<td><p>Hyperbolic cosine</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>Math.exp(a)</code></p></td>&#13;
<td><p><code>double</code></p></td>&#13;
<td><p><code>Math.E</code> to the power <code>a</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>Math.floor(a)</code></p></td>&#13;
<td><p><code>double</code></p></td>&#13;
<td><p>Largest whole number less than or equal to <code>a</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>Math.hypot(a,b)</code></p></td>&#13;
<td><p><code>double</code></p></td>&#13;
<td><p>Precision calculation of the <code>sqrt()</code> of <code>a</code>2 + <code>b</code>2</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>Math.log(a)</code></p></td>&#13;
<td><p><code>double</code></p></td>&#13;
<td><p>Natural logarithm of <code>a</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>Math.log10(a)</code></p></td>&#13;
<td><p><code>double</code></p></td>&#13;
<td><p>Log base 10 of <code>a</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>Math.max(a, b)</code></p></td>&#13;
<td><p><code>int</code>, <code>long</code>, <code>float</code>, <code>double</code></p></td>&#13;
<td><p>The value <code>a</code> or <code>b</code> closer to <code>Long.MAX_VALUE</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>Math.min(a, b)</code></p></td>&#13;
<td><p><code>int</code>, <code>long</code>, <code>float</code>, <code>double</code></p></td>&#13;
<td><p>The value <code>a</code> or <code>b</code> closer to <code>Long.MIN_VALUE</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>Math.pow(a, b)</code></p></td>&#13;
<td><p><code>double</code></p></td>&#13;
<td><p><code>a</code> to the power <code>b</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>Math.random()</code></p></td>&#13;
<td><p><code>None</code></p></td>&#13;
<td><p>Random-number generator</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>Math.rint(a)</code></p></td>&#13;
<td><p><code>double</code></p></td>&#13;
<td><p>Converts double value to integral value in double format</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>Math.round(a)</code></p></td>&#13;
<td><p><code>float</code>, <code>double</code></p></td>&#13;
<td><p>Rounds to whole number</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>Math.signum(a)</code></p></td>&#13;
<td><p><code>float</code>, <code>double</code></p></td>&#13;
<td><p>Get the sign of the number at 1.0, –1.0, or 0</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>Math.sin(a)</code></p></td>&#13;
<td><p><code>double</code></p></td>&#13;
<td><p>Sine</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>Math.sinh(a)</code></p></td>&#13;
<td><p><code>double</code></p></td>&#13;
<td><p>Hyperbolic sine</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>Math.sqrt(a)</code></p></td>&#13;
<td><p><code>double</code></p></td>&#13;
<td><p>Square root</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>Math.tan(a)</code></p></td>&#13;
<td><p><code>double</code></p></td>&#13;
<td><p>Tangent</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>Math.tanh(a)</code></p></td>&#13;
<td><p><code>double</code></p></td>&#13;
<td><p>Hyperbolic tangent</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>Math.toDegrees(a)</code></p></td>&#13;
<td><p><code>double</code></p></td>&#13;
<td><p>Convert radians to degrees</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>Math.toRadians(a)</code></p></td>&#13;
<td><p><code>double</code></p></td>&#13;
<td><p>Convert degrees to radians</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>The <a data-primary="ArithmeticException" data-type="indexterm" id="id1685"/><a data-primary="abs() method, Math" data-type="indexterm" id="id1686"/><a data-primary="log() method, Math" data-type="indexterm" id="id1687"/><a data-primary="max() method, Math" data-type="indexterm" id="id1688"/><a data-primary="min() method, Math" data-type="indexterm" id="id1689"/><a data-primary="pow() method, Math" data-type="indexterm" id="id1690"/><a data-primary="round() method, Math" data-type="indexterm" id="id1691"/><a data-primary="sqrt() method, Math" data-type="indexterm" id="id1692"/><a data-primary="methods" data-secondary="overloading" data-type="indexterm" id="id1693"/><a data-primary="overloading methods" data-type="indexterm" id="id1694"/>methods <code>log()</code>, <code>pow()</code>, and <code>sqrt()</code> can throw a runtime <code>ArithmeticException</code>. The methods <code>abs()</code>, <code>max()</code>, and <code>min()</code> are overloaded for all the scalar values (<code>int</code>, <code>long</code>, <code>float</code>, and <code>double</code>) and return the corresponding type. Versions of <code>Math.round()</code> accept either <code>float</code> or <span class="keep-together"><code>double</code></span> and return <code>int</code> or <code>long</code>, respectively. The rest of the methods operate on and return <code>double</code> values:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="kt">double</code><code class="w"> </code><code class="n">irrational</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Math</code><code class="p">.</code><code class="na">sqrt</code><code class="p">(</code><code class="mf">2.0</code><code class="p">);</code><code class="w"> </code><code class="c1">// 1.414...</code><code class="w"/>&#13;
<code class="w">    </code><code class="kt">int</code><code class="w"> </code><code class="n">bigger</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Math</code><code class="p">.</code><code class="na">max</code><code class="p">(</code><code class="mi">3</code><code class="p">,</code><code class="w"> </code><code class="mi">4</code><code class="p">);</code><code class="w">  </code><code class="c1">// 4</code><code class="w"/>&#13;
<code class="w">    </code><code class="kt">long</code><code class="w"> </code><code class="n">one</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Math</code><code class="p">.</code><code class="na">round</code><code class="p">(</code><code class="mf">1.125798</code><code class="p">);</code><code class="w"> </code><code class="c1">// 1</code><code class="w"/></pre>&#13;
&#13;
<p>Just to highlight the convenience of that static import option, try these simple functions in <em>jshell</em>:</p>&#13;
&#13;
<pre class="jshell" data-type="programlisting">jshell&gt; import static java.lang.Math.*&#13;
&#13;
jshell&gt; double irrational = sqrt(2.0)&#13;
irrational ==&gt; 1.4142135623730951&#13;
&#13;
jshell&gt; int bigger = max(3,4)&#13;
bigger ==&gt; 4&#13;
&#13;
jshell&gt; long one = round(1.125798)&#13;
one ==&gt; 1</pre>&#13;
&#13;
<p><code>Math</code> also contains the static final double constants <code>E</code> and <code>PI</code>. To find the perimeter of a circle, for example:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="kt">double</code><code class="w"> </code><code class="n">circumference</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">diameter</code><code class="w">  </code><code class="o">*</code><code class="w"> </code><code class="n">Math</code><code class="p">.</code><code class="na">PI</code><code class="p">;</code><code class="w"/></pre>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Math in action" data-type="sect3"><div class="sect3" id="learnjava6-CHP-8-SECT-4.1.1">&#13;
<h3>Math in action</h3>&#13;
&#13;
<p>We’ve already <a data-primary="random() method, Math" data-type="indexterm" id="id1695"/>touched on using the <code>Math</code> class and its static methods in <a data-type="xref" href="ch05.html#learnjava6-CHP-5-SECT-1.2">“Accessing Fields and Methods”</a>. We can use it again to make our game a little more fun by randomizing where the trees appear. The <code>Math.random()</code> method returns a random <code>double</code> greater than or equal to 0 and less than 1. Add in a little arithmetic and rounding or truncating, and you can use that value to create random numbers in any range you need. In particular, converting this value into a desired range follows this formula:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="kt">int</code><code class="w"> </code><code class="n">randomValue</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">min</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="p">(</code><code class="kt">int</code><code class="p">)(</code><code class="n">Math</code><code class="p">.</code><code class="na">random</code><code class="p">()</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="p">(</code><code class="n">max</code><code class="w"> </code><code class="o">-</code><code class="w"> </code><code class="n">min</code><code class="p">));</code><code class="w"/></pre>&#13;
&#13;
<p>Try it! Try to generate a random four-digit number in <em>jshell</em>. You could set the <code>min</code> to 1,000 and the <code>max</code> to 10,000, like so:</p>&#13;
&#13;
<pre class="jshell" data-type="programlisting">jshell&gt; int min = 1000&#13;
min ==&gt; 1000&#13;
&#13;
jshell&gt; int max = 10000&#13;
max ==&gt; 10000&#13;
&#13;
jshell&gt; int fourDigit = min + (int)(Math.random() * (max - min))&#13;
fourDigit ==&gt; 9603&#13;
&#13;
jshell&gt; fourDigit = min + (int)(Math.random() * (max - min))&#13;
fourDigit ==&gt; 9178&#13;
&#13;
jshell&gt; fourDigit = min + (int)(Math.random() * (max - min))&#13;
fourDigit ==&gt; 3789</pre>&#13;
&#13;
<p>To place our trees, we’ll need two random numbers for the x and y coordinates. We can set a range that will keep the trees on the screen by thinking about a margin around the edges. For the x coordinate, one way to do that might look like this:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">  </code><code class="kd">private</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="nf">goodX</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="c1">// at least half the width of the tree plus a few pixels</code><code class="w"/>&#13;
<code class="w">    </code><code class="kt">int</code><code class="w"> </code><code class="n">leftMargin</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Field</code><code class="p">.</code><code class="na">TREE_WIDTH_IN_PIXELS</code><code class="w"> </code><code class="o">/</code><code class="w"> </code><code class="mi">2</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="mi">5</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">    </code><code class="c1">// now find a random number between a left and right margin</code><code class="w"/>&#13;
<code class="w">    </code><code class="kt">int</code><code class="w"> </code><code class="n">rightMargin</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">FIELD_WIDTH</code><code class="w"> </code><code class="o">-</code><code class="w"> </code><code class="n">leftMargin</code><code class="p">;</code><code class="w"/>&#13;
&#13;
<code class="w">    </code><code class="c1">// And return a random number starting at the left margin</code><code class="w"/>&#13;
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="n">leftMargin</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="p">(</code><code class="kt">int</code><code class="p">)(</code><code class="n">Math</code><code class="p">.</code><code class="na">random</code><code class="p">()</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="p">(</code><code class="n">rightMargin</code><code class="w"> </code><code class="o">-</code><code class="w"> </code><code class="n">leftMargin</code><code class="p">));</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>Set up a similar method for finding a y value, and you should start to see something like the image shown in <a data-type="xref" href="#learnjava6-CHP-8-FIG-1">Figure 8-1</a>. You could even get fancy and use the &#13;
<span class="keep-together"><code>isTouching()</code></span> method we discussed back in <a data-type="xref" href="ch05.html#learnjava6-CHP-5">Chapter 5</a> to avoid placing any trees in direct contact with our physicist. Here’s our upgraded tree setup loop:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">  </code><code class="k">for</code><code class="w"> </code><code class="p">(</code><code class="kt">int</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">field</code><code class="p">.</code><code class="na">trees</code><code class="p">.</code><code class="na">size</code><code class="p">();</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="o">&lt;</code><code class="w"> </code><code class="n">Field</code><code class="p">.</code><code class="na">MAX_TREES</code><code class="p">;</code><code class="w"> </code><code class="n">i</code><code class="o">++</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">Tree</code><code class="w"> </code><code class="n">t</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">Tree</code><code class="p">();</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">t</code><code class="p">.</code><code class="na">setPosition</code><code class="p">(</code><code class="n">goodX</code><code class="p">(),</code><code class="w"> </code><code class="n">goodY</code><code class="p">());</code><code class="w"/>&#13;
&#13;
<code class="w">    </code><code class="c1">// Trees can be close to each other and overlap,</code><code class="w"/>&#13;
<code class="w">    </code><code class="c1">// but they shouldn't intersect our physicist</code><code class="w"/>&#13;
<code class="w">    </code><code class="k">while</code><code class="p">(</code><code class="n">player1</code><code class="p">.</code><code class="na">isTouching</code><code class="p">(</code><code class="n">t</code><code class="p">))</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="c1">// We do intersect this tree, so let's try again</code><code class="w"/>&#13;
<code class="w">      </code><code class="n">System</code><code class="p">.</code><code class="na">err</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="s">"Repositioning an intersecting tree..."</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">      </code><code class="n">t</code><code class="p">.</code><code class="na">setPosition</code><code class="p">(</code><code class="n">goodX</code><code class="p">(),</code><code class="w"> </code><code class="n">goodY</code><code class="p">());</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">}</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">field</code><code class="p">.</code><code class="na">addTree</code><code class="p">(</code><code class="n">t</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<figure><div class="figure" id="learnjava6-CHP-8-FIG-1">&#13;
<img alt="ljv6 0801" src="assets/ljv6_0801.png"/>&#13;
<h6><span class="label">Figure 8-1. </span>Randomly distributed trees</h6>&#13;
</div></figure>&#13;
&#13;
<p>Try quitting the game and launching it again. You should see the trees in different places each time you run the application.<a data-primary="" data-startref="ix_java_lang_math" data-type="indexterm" id="id1696"/><a data-primary="" data-startref="ix_math_class" data-type="indexterm" id="id1697"/><a data-primary="" data-startref="ix_type_math_class" data-type="indexterm" id="id1698"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Big/Precise Numbers" data-type="sect2"><div class="sect2" id="learnjava6-CHP-8-SECT-4.2">&#13;
<h2>Big/Precise Numbers</h2>&#13;
&#13;
<p>If the <code>long</code> and <code>double</code> types are not <a data-primary="BigDecimal class" data-type="indexterm" id="id1699"/><a data-primary="BigInteger class" data-type="indexterm" id="id1700"/><a data-primary="arbitrary-precision math" data-type="indexterm" id="id1701"/>large or precise enough for you, the <code>java.math</code> package provides two classes, <code>BigInteger</code> and <code>BigDecimal</code>, that support arbitrary-precision numbers. These full-featured classes have a bevy of methods for performing arbitrary-precision<sup><a data-type="noteref" href="ch08.html#id1702" id="id1702-marker">5</a></sup> math and precisely controlling rounding of remainders. In the following example, we use <code>BigDecimal</code> to add two very large numbers and then create a fraction with a 100-digit result:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="kt">long</code><code class="w"> </code><code class="n">l1</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">9223372036854775807L</code><code class="p">;</code><code class="w"> </code><code class="c1">// Long.MAX_VALUE</code><code class="w"/>&#13;
<code class="w">    </code><code class="kt">long</code><code class="w"> </code><code class="n">l2</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">9223372036854775807L</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="n">l1</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">l2</code><code class="p">);</code><code class="w"> </code><code class="c1">// -2 ! Not good.</code><code class="w"/>&#13;
&#13;
<code class="w">    </code><code class="k">try</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="n">BigDecimal</code><code class="w"> </code><code class="n">bd1</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">BigDecimal</code><code class="p">(</code><code class="s">"9223372036854775807"</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">      </code><code class="n">BigDecimal</code><code class="w"> </code><code class="n">bd2</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">BigDecimal</code><code class="p">(</code><code class="mi">9223372036854775807L</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">      </code><code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="n">bd1</code><code class="p">.</code><code class="na">add</code><code class="p">(</code><code class="n">bd2</code><code class="p">)</code><code class="w"> </code><code class="p">);</code><code class="w"> </code><code class="c1">// 18446744073709551614</code><code class="w"/>&#13;
&#13;
<code class="w">      </code><code class="n">BigDecimal</code><code class="w"> </code><code class="n">numerator</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">BigDecimal</code><code class="p">(</code><code class="mi">1</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">      </code><code class="n">BigDecimal</code><code class="w"> </code><code class="n">denominator</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">BigDecimal</code><code class="p">(</code><code class="mi">3</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">      </code><code class="n">BigDecimal</code><code class="w"> </code><code class="n">fraction</code><code class="w"> </code><code class="o">=</code><code class="w"/>&#13;
<code class="w">          </code><code class="n">numerator</code><code class="p">.</code><code class="na">divide</code><code class="p">(</code><code class="n">denominator</code><code class="p">,</code><code class="w"> </code><code class="mi">100</code><code class="p">,</code><code class="w"> </code><code class="n">BigDecimal</code><code class="p">.</code><code class="na">ROUND_UP</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">      </code><code class="c1">// 100-digit fraction = 0.333333 ... 3334</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">}</code><code class="w"/>&#13;
<code class="w">    </code><code class="k">catch</code><code class="w"> </code><code class="p">(</code><code class="n">NumberFormatException</code><code class="w"> </code><code class="n">nfe</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="p">}</code><code class="w"/>&#13;
<code class="w">    </code><code class="k">catch</code><code class="w"> </code><code class="p">(</code><code class="n">ArithmeticException</code><code class="w"> </code><code class="n">ae</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>If you implement cryptographic or scientific algorithms for fun, <code>BigInteger</code> is crucial. <code>BigDecimal</code>, in turn, can be found in applications dealing with currency and financial data. Other than that, you’re not likely to need these classes.<a data-primary="" data-startref="ix_math_util" data-type="indexterm" id="id1703"/><a data-primary="" data-startref="ix_text_math_util" data-type="indexterm" id="id1704"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Dates and Times" data-type="sect1"><div class="sect1" id="learnjava6-CHP-8-SECT-5">&#13;
<h1>Dates and Times</h1>&#13;
&#13;
<p>Working with <a data-primary="text processing" data-secondary="dates and times" data-type="indexterm" id="ix_text_date_time_ch8"/><a data-primary="dates and times" data-type="indexterm" id="ix_date_time_ch8"/><a data-primary="Date class" data-type="indexterm" id="id1705"/><a data-primary="DateFormat class" data-type="indexterm" id="id1706"/><a data-primary="java.util package" data-secondary="Calendar class" data-type="indexterm" id="id1707"/><a data-primary="java.util package" data-secondary="Date class" data-type="indexterm" id="id1708"/><a data-primary="java.util package" data-secondary="GregorianCalendar class" data-type="indexterm" id="id1709"/>dates and times without the proper tools can be a chore. Java includes three classes that handle simple cases for you. The <code>java.util.Date</code> class encapsulates a point in time. The <code>java.util.GregorianCalendar</code> class, which extends the abstract <code>java.util.Calendar</code>, translates between a point in time and calendar fields like month, day, and year. Finally, the <code>java.text.DateFormat</code> class knows how to generate and parse string representations of dates and times in many languages and locales.</p>&#13;
&#13;
<p>While the <code>Date</code> and <code>Calendar</code> classes covered many use cases, they lacked granularity and were missing other features. Several third-party libraries cropped up, all aimed at making it easier for developers to work with dates and times and time durations. Java 8 provided much needed improvements in this area with the addition of the <code>java.time</code> package. The rest of this chapter explores this package, but you will still encounter many, many <code>Date</code> and <code>Calendar</code> examples in the wild, so it’s useful to know they exist. As always, the <a href="https://oreil.ly/Behlk">online docs</a> are an invaluable source for reviewing parts of the Java API we don’t tackle here.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Local Dates and Times" data-type="sect2"><div class="sect2" id="learnjava6-CHP-8-SECT-5.1">&#13;
<h2>Local Dates and Times</h2>&#13;
&#13;
<p>The <code>java.time.LocalDate</code> class <a data-primary="java.time package" data-type="indexterm" id="ix_java_time_pkg"/><a data-primary="local dates and times" data-type="indexterm" id="ix_local_date"/><a data-primary="dates and times" data-secondary="local" data-type="indexterm" id="ix_date_local"/><a data-primary="LocalDate class" data-type="indexterm" id="id1710"/><a data-primary="LocalDateTime class" data-type="indexterm" id="id1711"/><a data-primary="LocalTime class" data-type="indexterm" id="id1712"/>represents a date without time information for your local region. Think of an annual event such as the winter solstice on December 21. <a data-primary="of() method, dates and times" data-type="indexterm" id="id1713"/><a data-primary="parse() method, dates and times" data-type="indexterm" id="id1714"/>Similarly, <code>java.time.LocalTime</code> represents a time without any date information. Perhaps your alarm clock goes off at 7:15 every morning. The <code>java.time.LocalDateTime</code> stores both date and time values for things like appointments with your eye doctor (so you can keep reading books on Java). All of these classes offer static methods for creating new instances, either using appropriate numeric values with the method <code>of()</code> or by parsing strings with <code>parse()</code>. Let’s pop into <em>jshell</em> and try creating a few examples:</p>&#13;
&#13;
<pre class="jshell" data-type="programlisting">jshell&gt; import java.time.*&#13;
&#13;
jshell&gt; LocalDate.of(2019,5,4)&#13;
$2 ==&gt; 2019-05-04&#13;
&#13;
jshell&gt; LocalDate.parse("2019-05-04")&#13;
$3 ==&gt; 2019-05-04&#13;
&#13;
jshell&gt; LocalTime.of(7,15)&#13;
$4 ==&gt; 07:15&#13;
&#13;
jshell&gt; LocalTime.parse("07:15")&#13;
$5 ==&gt; 07:15&#13;
&#13;
jshell&gt; LocalDateTime.of(2019,5,4,7,0)&#13;
$6 ==&gt; 2019-05-04T07:00&#13;
&#13;
jshell&gt; LocalDateTime.parse("2019-05-04T07:15")&#13;
$7 ==&gt; 2019-05-04T07:15</pre>&#13;
&#13;
<p>Another great <a data-primary="now() method" data-type="indexterm" id="id1715"/>static method for creating these objects is <code>now()</code>, which provides the current date, time, or date-and-time as you might expect:</p>&#13;
&#13;
<pre class="jshell" data-type="programlisting">jshell&gt; LocalTime.now()&#13;
$8 ==&gt; 15:57:24.052935&#13;
&#13;
jshell&gt; LocalDate.now()&#13;
$9 ==&gt; 2023-03-31&#13;
&#13;
jshell&gt; LocalDateTime.now()&#13;
$10 ==&gt; 2023-03-31T15:57:37.909038</pre>&#13;
&#13;
<p>Great! After importing the <code>java.time</code> package, you can create instances of each of the <code>Local…​</code> classes for specific moments or for “right now.” You may have noticed the objects created with <code>now()</code> include seconds and nanoseconds in the time. You can supply those values to the <code>of()</code> and <code>parse()</code> methods if you want or need them. Not much exciting there, but once you have these objects, you can do a lot with them. Read on!<a data-primary="" data-startref="ix_date_local" data-type="indexterm" id="id1716"/><a data-primary="" data-startref="ix_local_date" data-type="indexterm" id="id1717"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Comparing and Manipulating Dates and Times" data-type="sect2"><div class="sect2" id="learnjava6-CHP-8-SECT-5.2">&#13;
<h2>Comparing and Manipulating Dates and Times</h2>&#13;
&#13;
<p>One of the <a data-primary="dates and times" data-secondary="comparing and manipulating" data-type="indexterm" id="id1718"/><a data-primary="between() method, dates and times" data-type="indexterm" id="id1719"/><a data-primary="java.time package" data-secondary="temporal subpackage" data-type="indexterm" id="id1720"/>big advantages of using <code>java.time</code> classes is the consistent set of methods available for comparing and changing dates and times. For example, many chat applications will show you “how long ago” a message was sent. The <code>java.time.temporal</code> subpackage has just what we need: the <code>ChronoUnit</code> interface. It contains several date and time units such as <code>MONTHS</code>, <code>DAYS</code>, <code>HOURS</code>, <code>MINUTES</code>, etc. These units can be used to calculate differences. For example, we could calculate how long it takes us to create two example date-times in <em>jshell</em> using the <code>between()</code> method:</p>&#13;
&#13;
<pre class="jshell" data-type="programlisting">jshell&gt; LocalDateTime first = LocalDateTime.now()&#13;
first ==&gt; 2023-03-31T16:03:21.875196&#13;
&#13;
jshell&gt; LocalDateTime second = LocalDateTime.now()&#13;
second ==&gt; 2023-03-31T16:03:33.175675&#13;
&#13;
jshell&gt; import java.time.temporal.*&#13;
&#13;
jshell&gt; ChronoUnit.SECONDS.between(first, second)&#13;
$12 ==&gt; 11</pre>&#13;
&#13;
<p>A visual spot check shows that it did indeed take about 11 seconds to type in the line that created our <code>second</code> variable. Check out the <a href="https://oreil.ly/BhCr2">docs for <code>ChronoUnit</code></a> for a complete list, but you get the full range, from nanoseconds up to millennia.</p>&#13;
&#13;
<p>Those <a data-primary="plus() method, dates and times" data-type="indexterm" id="id1721"/><a data-primary="minus() method, dates and times" data-type="indexterm" id="id1722"/>units can also help you manipulate dates and times with the <code>plus()</code> and <code>minus()</code> methods. To set a reminder for one week from today, for example:</p>&#13;
&#13;
<pre class="jshell" data-type="programlisting">jshell&gt; LocalDate today = LocalDate.now()&#13;
today ==&gt; 2023-03-31&#13;
&#13;
jshell&gt; LocalDate reminder = today.plus(1, ChronoUnit.WEEKS)&#13;
reminder ==&gt; 2023-04-07</pre>&#13;
&#13;
<p>Neat! But this <code>reminder</code> example brings up another bit of manipulation you may need to perform from time to time. You might want a reminder at a particular time on the 7th. You can convert between dates, times, and date-times easily enough with the <code>atDate()</code> or <code>atTime()</code> methods:</p>&#13;
&#13;
<pre class="jshell" data-type="programlisting">jshell&gt; LocalDateTime betterReminder = reminder.atTime(LocalTime.of(9,0))&#13;
betterReminder ==&gt; 2023-04-07T09:00</pre>&#13;
&#13;
<p>Now you’ll get a reminder at 9 A.M. Except, what if you set that reminder in Atlanta and then flew to San Francisco? When would the alarm go off? <code>LocalDateTime</code> is, well, local! So the <code>T09:00</code> portion is still 9 A.M. wherever you are when you run the program. But if you are handling something like scheduling a meeting, you can’t ignore the different time zones involved. Fortunately the <code>java.time</code> package has thought of that, too.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Time Zones" data-type="sect2"><div class="sect2" id="learnjava6-CHP-8-SECT-5.3">&#13;
<h2>Time Zones</h2>&#13;
&#13;
<p>The <a data-primary="time zones" data-type="indexterm" id="id1723"/><a data-primary="dates and times" data-secondary="time zones" data-type="indexterm" id="id1724"/><a data-primary="java.time package" data-secondary="time zone classes" data-type="indexterm" id="id1725"/><a data-primary="OffsetDateTime class" data-type="indexterm" id="id1726"/><a data-primary="ZonedDateTime class" data-type="indexterm" id="id1727"/>authors of the new <code>java.time</code> package encourage you to use the local variations of the time and date classes where possible. Adding support for time zones means adding complexity to your app—they want you to avoid that complexity if possible. But there are many scenarios where support for time zones is unavoidable. You can work with “zoned” dates and times using the <code>ZonedDateTime</code> and <code>OffsetDateTime</code> classes. The zoned variant understands named time zones and things like daylight saving adjustments. The offset variant is a constant, simple numeric offset from UTC/Greenwich.</p>&#13;
&#13;
<p>Most <a data-primary="ZoneID class" data-type="indexterm" id="id1728"/>user-facing uses of dates and times will use the named zone approach, so let’s look at creating a zoned date-time. To attach a zone, we use the <code>ZoneId</code> class, which has the common <code>of()</code> static method for creating new instances. You can supply a region zone as a <code>String</code> to get your zoned value:</p>&#13;
&#13;
<pre class="jshell" data-type="programlisting">jshell&gt; LocalDateTime piLocal = LocalDateTime.parse("2023-03-14T01:59")&#13;
piLocal ==&gt; 2023-03-14T01:59&#13;
&#13;
jshell&gt; ZonedDateTime piCentral = piLocal.atZone(ZoneId.of("America/Chicago"))&#13;
piCentral ==&gt; 2023-03-14T01:59-05:00[America/Chicago]</pre>&#13;
&#13;
<p>And <a data-primary="withZoneSameInstant() method, dates and times" data-type="indexterm" id="id1729"/>now you can do things like make sure your friends in Paris can join you at the correct moment using the verbosely but aptly named <code>withZoneSameInstant()</code> method:</p>&#13;
&#13;
<pre class="jshell" data-type="programlisting">jshell&gt; ZonedDateTime piAlaMode =&#13;
piCentral.withZoneSameInstant(ZoneId.of("Europe/Paris"))&#13;
piAlaMode ==&gt; 2023-03-14T07:59+01:00[Europe/Paris]</pre>&#13;
&#13;
<p>If you <a data-primary="systemDefault() method, dates and times" data-type="indexterm" id="id1730"/>have other friends who aren’t conveniently located in a major metropolitan region but you want them to join as well, you can use the <code>systemDefault()</code> method of <code>ZoneId</code> to pick up their time zone programmatically:</p>&#13;
&#13;
<pre class="jshell" data-type="programlisting">jshell&gt; ZonedDateTime piOther =&#13;
piCentral.withZoneSameInstant(ZoneId.systemDefault())&#13;
piOther ==&gt; 2023-03-14T02:59-04:00[America/New_York]</pre>&#13;
&#13;
<p>We were running <em>jshell</em> on a laptop in the Eastern time zone of the United States. <code>piOther</code> comes out exactly as hoped. The <code>systemDefault()</code> zone ID is a very handy way to quickly tailor date-times from other zones to match what your user’s clock and calendar are most likely to say. In commercial applications you may want to let the user tell you their preferred zone, but <code>systemDefault()</code> is usually a good guess.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Parsing and Formatting Dates and Times" data-type="sect2"><div class="sect2" id="learnjava6-CHP-8-SECT-5.4">&#13;
<h2>Parsing and Formatting Dates and Times</h2>&#13;
&#13;
<p>For <a data-primary="dates and times" data-secondary="parsing" data-type="indexterm" id="ix_date_parse"/><a data-primary="java.time.format package" data-type="indexterm" id="id1731"/><a data-primary="DateTimeFormatter utility class" data-type="indexterm" id="ix_date_time_format"/><a data-primary="parsing" data-secondary="dates and times" data-type="indexterm" id="ix_parse_date_time"/>creating and showing our local and zoned date-times using strings, we’ve been relying on the default formats that follow ISO values. These generally work wherever we need to accept or display dates and times. But as every programmer knows, “generally” is not “always.” Fortunately, you can use the utility class <code>java.time.format.DateTimeFormatter</code> to help with parsing input and formatting output.</p>&#13;
&#13;
<p>The core of <code>DateTimeFormatter</code> centers on building a format string that governs both parsing and formatting. You build up your format with the pieces listed in <a data-type="xref" href="#learnjava6-CHP-8-TABLE-4">Table 8-4</a>. We are listing only a portion of the options available here, but these should get you through the bulk of the dates and times you will encounter. Note that case matters when using the characters mentioned!</p>&#13;
<table id="learnjava6-CHP-8-TABLE-4">&#13;
<caption><span class="label">Table 8-4. </span>Popular and useful <code>DateTimeFormatter</code> elements</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Character</th>&#13;
<th>Description</th>&#13;
<th>Example</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p>a</p></td>&#13;
<td><p>am-pm-of-day</p></td>&#13;
<td><p>PM</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>d</p></td>&#13;
<td><p>day-of-month</p></td>&#13;
<td><p>10</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>E</p></td>&#13;
<td><p>day-of-week</p></td>&#13;
<td><p>Tue; Tuesday; T</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>G</p></td>&#13;
<td><p>era</p></td>&#13;
<td><p>BCE, CE</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>k</p></td>&#13;
<td><p>clock-hour-of-day (1-24)</p></td>&#13;
<td><p>24</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>K</p></td>&#13;
<td><p>hour-of-am-pm (0-11)</p></td>&#13;
<td><p>0</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>L</p></td>&#13;
<td><p>month-of-year</p></td>&#13;
<td><p>Jul; July; J</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>h</p></td>&#13;
<td><p>clock-hour-of-am-pm (1-12)</p></td>&#13;
<td><p>12</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>H</p></td>&#13;
<td><p>hour-of-day (0-23)</p></td>&#13;
<td><p>0</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>m</p></td>&#13;
<td><p>minute-of-hour</p></td>&#13;
<td><p>30</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>M</p></td>&#13;
<td><p>month-of-year</p></td>&#13;
<td><p>7; 07</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>s</p></td>&#13;
<td><p>second-of-minute</p></td>&#13;
<td><p>55</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>S</p></td>&#13;
<td><p>fraction-of-second</p></td>&#13;
<td><p>033954</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>u</p></td>&#13;
<td><p>year (without era)</p></td>&#13;
<td><p>2004; 04</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>y</p></td>&#13;
<td><p>year-of-era</p></td>&#13;
<td><p>2004; 04</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>z</p></td>&#13;
<td><p>time-zone name</p></td>&#13;
<td><p>Pacific Standard Time; PST</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Z</p></td>&#13;
<td><p>zone-offset</p></td>&#13;
<td><p>+0000; -0800; -08:00</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>To put <a data-primary="ofPattern() method, dates and times" data-type="indexterm" id="id1732"/><a data-primary="parse() method, dates and times" data-type="indexterm" id="id1733"/>together a common US short format, for example, you could use the <code>M</code>, <code>d</code>, and <code>y</code> characters. You build the formatter using the static <code>ofPattern()</code> method. Now you can use (and reuse) the formatter with the <code>parse()</code> method of any of the date or time classes:</p>&#13;
&#13;
<pre class="jshell" data-type="programlisting">jshell&gt; import java.time.format.DateTimeFormatter&#13;
&#13;
jshell&gt; DateTimeFormatter shortUS =&#13;
   ...&gt; DateTimeFormatter.ofPattern("MM/dd/yy")&#13;
shortUS ==&gt; Value(MonthOfYe ...) ... (YearOfEra,2,2,2000-01-01)&#13;
&#13;
jshell&gt; LocalDate valentines = LocalDate.parse("02/14/23", shortUS)&#13;
valentines ==&gt; 2023-02-14&#13;
&#13;
jshell&gt; LocalDate piDay = LocalDate.parse("03/14/23", shortUS)&#13;
piDay ==&gt; 2023-03-14</pre>&#13;
&#13;
<p>And as we <a data-primary="format() method, dates and times" data-type="indexterm" id="id1734"/>mentioned earlier, the formatter works in both directions. Just use the <code>format()</code> method of your formatter to produce a string representation of your date or time:</p>&#13;
&#13;
<pre class="jshell" data-type="programlisting">jshell&gt; LocalDate today = LocalDate.now()&#13;
today ==&gt; 2023-12-14&#13;
&#13;
jshell&gt; shortUS.format(today)&#13;
$30 ==&gt; "12/14/23"&#13;
&#13;
jshell&gt; shortUS.format(piDay)&#13;
$31 ==&gt; "03/14/23"</pre>&#13;
&#13;
<p>Of course, formatters work for times and date-times as well!</p>&#13;
&#13;
<pre class="jshell" data-type="programlisting">jshell&gt; DateTimeFormatter military =&#13;
   ...&gt; DateTimeFormatter.ofPattern("HHmm")&#13;
military ==&gt; Value(HourOfDay,2)Value(MinuteOfHour,2)&#13;
&#13;
jshell&gt; LocalTime sunset = LocalTime.parse("2020", military)&#13;
sunset ==&gt; 20:20&#13;
&#13;
jshell&gt; DateTimeFormatter basic =&#13;
   ...&gt; DateTimeFormatter.ofPattern("h:mm a")&#13;
basic ==&gt; Value(ClockHourOfAmPm)': ... ,SHORT)&#13;
&#13;
jshell&gt; basic.format(sunset)&#13;
$42 ==&gt; "8:20 PM"&#13;
&#13;
jshell&gt; DateTimeFormatter appointment =&#13;
DateTimeFormatter.ofPattern("h:mm a MM/dd/yy z")&#13;
appointment ==&gt;&#13;
Value(ClockHourOfAmPm)':' ...&#13;
0-01-01)' 'ZoneText(SHORT)</pre>&#13;
&#13;
<p>Notice in <a data-primary="ZonedDateTime class" data-type="indexterm" id="id1735"/>the <code>ZonedDateTime</code> portion that follows that we put the time zone identifier (the <code>z</code> character) at the end—probably not where you were expecting it!</p>&#13;
&#13;
<pre class="jshell" data-type="programlisting">jshell&gt; ZonedDateTime dentist =&#13;
ZonedDateTime.parse("10:30 AM 11/01/23 EST", appointment)&#13;
dentist ==&gt; 2023-11-01T10:30-04:00[America/New_York]&#13;
&#13;
jshell&gt; ZonedDateTime nowEST = ZonedDateTime.now()&#13;
nowEST ==&gt; 2023-12-14T09:55:58.493006-05:00[America/New_York]&#13;
&#13;
jshell&gt; appointment.format(nowEST)&#13;
$47 ==&gt; "9:55 AM 12/14/23 EST"</pre>&#13;
&#13;
<p>We wanted to illustrate the power of these formats. You can design a format to accommodate a very wide range of input or output styles. Legacy data and poorly designed web forms come to mind as direct examples where <code>DateTimeFormatter</code> can help.<a data-primary="" data-startref="ix_date_parse" data-type="indexterm" id="id1736"/><a data-primary="" data-startref="ix_date_time_format" data-type="indexterm" id="id1737"/><a data-primary="" data-startref="ix_parse_date_time" data-type="indexterm" id="id1738"/></p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Parsing Errors" data-type="sect3"><div class="sect3" id="learnjava6-CHP-8-SECT-5.4.1">&#13;
<h3>Parsing Errors</h3>&#13;
&#13;
<p>Even with all this <a data-primary="error handling" data-secondary="dates and times" data-type="indexterm" id="ix_error_date"/>parsing power at your fingertips, things will sometimes go wrong. Regrettably, the exceptions you see are often too vague to be immediately useful. Consider the following attempt to parse a time with hours, minutes, and seconds:</p>&#13;
&#13;
<pre class="jshell" data-type="programlisting">jshell&gt; DateTimeFormatter withSeconds =&#13;
   ...&gt; DateTimeFormatter.ofPattern("hh:mm:ss")&#13;
withSeconds ==&gt;&#13;
Value(ClockHourOfAmPm,2)':' ...&#13;
Value(SecondOfMinute,2)&#13;
&#13;
jshell&gt; LocalTime.parse("03:14:15", withSeconds)&#13;
|  Exception java.time.format.DateTimeParseException:&#13;
|  Text '03:14:15' could not be parsed: Unable to obtain&#13;
|  LocalTime from TemporalAccessor: {MinuteOfHour=14, MilliOfSecond=0,&#13;
|  SecondOfMinute=15, NanoOfSecond=0, HourOfAmPm=3,&#13;
|  MicroOfSecond=0},ISO of type java.time.format.Parsed&#13;
|        at DateTimeFormatter.createError (DateTimeFormatter.java:2020)&#13;
|        at DateTimeFormatter.parse (DateTimeFormatter.java:1955)&#13;
|        at LocalTime.parse (LocalTime.java:463)&#13;
|        at (#33:1)&#13;
|  Caused by: java.time.DateTimeException:&#13;
  Unable to obtain LocalTime from ...&#13;
|        at LocalTime.from (LocalTime.java:431)&#13;
|        at Parsed.query (Parsed.java:235)&#13;
|        at DateTimeFormatter.parse (DateTimeFormatter.java:1951)&#13;
|        ...</pre>&#13;
&#13;
<p>Yikes! Java will <a data-primary="DateTimeParseException" data-type="indexterm" id="id1739"/>throw a <code>DateTimeParseException</code> any time it cannot parse the string input. Java will also throw the exception in cases like our example above; the fields were correctly parsed from the string, but they did not supply enough information to create a <code>LocalTime</code> object. It may not be obvious, but our time, <code>“3:14:15,”</code> could be either mid-afternoon or very early in the morning. Our choice of the <code>hh</code> pattern for the hours turns out to be the culprit. We can either pick an hour pattern that uses an unambiguous 24-hour scale or we can add an explicit A.M./P.M. element:</p>&#13;
&#13;
<pre class="jshell" data-type="programlisting">jshell&gt; DateTimeFormatter valid1 =&#13;
   ...&gt; DateTimeFormatter.ofPattern("hh:mm:ss a")&#13;
valid1 ==&gt; Value(ClockHourOfAmPm,...y,SHORT)&#13;
&#13;
jshell&gt; DateTimeFormatter valid2 =&#13;
   ...&gt; DateTimeFormatter.ofPattern("HH:mm:ss")&#13;
valid2 ==&gt; Value(HourOfDay,2)': ... Minute,2)&#13;
&#13;
jshell&gt; LocalTime piDay1 =&#13;
   ...&gt; LocalTime.parse("03:14:15 PM", valid1)&#13;
piDay1 ==&gt; 15:14:15&#13;
&#13;
jshell&gt; LocalTime piDay2 =&#13;
   ...&gt; LocalTime.parse("03:14:15", valid2)&#13;
piDay2 ==&gt; 03:14:15</pre>&#13;
&#13;
<p>If you ever get a <code>DateTimeParseException</code> but your input looks like a correct match for the format, double-check that your format itself includes everything necessary to create your date or time. One parting thought on these exceptions: you may need to use the nonmnemonic <code>u</code> character for parsing years if your dates don’t naturally include an era designator such as <code>CE</code>.</p>&#13;
&#13;
<p>There are many, <em>many</em> more details on <code>DateTimeFormatter</code>. For this, more than for most utility classes, it’s worth a trip to <a href="https://oreil.ly/rhosl">read the docs online</a>.<a data-primary="" data-startref="ix_error_date" data-type="indexterm" id="id1740"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Formatting Dates and Times" data-type="sect2"><div class="sect2" id="learnjava6-CHP-8-SECT-5.5">&#13;
<h2>Formatting Dates and Times</h2>&#13;
&#13;
<p>Now that you <a data-primary="dates and times" data-secondary="formatting" data-type="indexterm" id="id1741"/>know how to create, parse, and store dates and times, you need to display that handy data. Happily, you can build nice, human-readable strings using the same formatter you built to parse dates and times from strings. Remember our <code>withSeconds</code> and <code>military</code> formatters? You can pick up the current time and quickly turn it into either format, like this:</p>&#13;
&#13;
<pre class="jshell" data-type="programlisting">jshell&gt; DateTimeFormatter withSeconds =&#13;
   ...&gt; DateTimeFormatter.ofPattern("hh:mm:ss")&#13;
withSeconds ==&gt; Value(ClockHou ... OfMinute,2)&#13;
&#13;
jshell&gt; DateTimeFormatter military =&#13;
   ...&gt; DateTimeFormatter.ofPattern("HHmm")&#13;
military ==&gt; Value(HourOfDay,2)Value(MinuteOfHour,2)&#13;
&#13;
jshell&gt; LocalTime t = LocalTime.now()&#13;
t ==&gt; 09:17:34.356758&#13;
&#13;
jshell&gt; withSeconds.format(t)&#13;
$7 ==&gt; "09:17:34"&#13;
&#13;
jshell&gt; military.format(t)&#13;
$8 ==&gt; "0917"</pre>&#13;
&#13;
<p>You can use any <a data-primary="LocalDate class" data-type="indexterm" id="id1742"/><a data-primary="LocalTime class" data-type="indexterm" id="id1743"/><a data-primary="now() method" data-secondary="LocalDate" data-type="indexterm" id="id1744"/><a data-primary="now() method" data-secondary="LocalTime" data-type="indexterm" id="id1745"/>date or time pattern you build from the parts shown in <a data-type="xref" href="#learnjava6-CHP-8-TABLE-4">Table 8-4</a> to produce this formatted output. Hop into <em>jshell</em> and try creating a few formats. You can use the <code>LocalTime.now()</code> and <code>LocalDate.now()</code> methods to create some easy targets for your formatting tests.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Timestamps" data-type="sect2"><div class="sect2" id="learnjava6-CHP-8-SECT-5.6">&#13;
<h2>Timestamps</h2>&#13;
&#13;
<p>One other popular <a data-primary="dates and times" data-secondary="timestamps" data-type="indexterm" id="id1746"/><a data-primary="java.time package" data-secondary="Instant class" data-type="indexterm" id="id1747"/><a data-primary="java.time package" data-secondary="timestamps" data-type="indexterm" id="id1748"/><a data-primary="timestamps" data-type="indexterm" id="id1749"/>date-time concept that <code>java.time</code> understands is timestamps. In any situation where you need to track the flow of information, you’ll need a record of exactly when the information is produced or modified. You will still see the <code>java.util.Date</code> class used to store these moments in time, but the <code>java.time.Instant</code> class carries everything you need for a timestamp and comes with all the other benefits of the other classes in the <code>java.time</code> package:</p>&#13;
&#13;
<pre class="jshell" data-type="programlisting">jshell&gt; Instant time1 = Instant.now()&#13;
time1 ==&gt; 2019-12-14T15:38:29.033954Z&#13;
&#13;
jshell&gt; Instant time2 = Instant.now()&#13;
time2 ==&gt; 2019-12-14T15:38:46.095633Z&#13;
&#13;
jshell&gt; time1.isAfter(time2)&#13;
$54 ==&gt; false&#13;
&#13;
jshell&gt; time1.plus(3, ChronoUnit.DAYS)&#13;
$55 ==&gt; 2019-12-17T15:38:29.033954Z</pre>&#13;
&#13;
<p>If dates or times appear in your work, the <code>java.time</code> package makes for a welcome helper. You have a mature, well-designed set of tools for dealing with this data—no third-party libraries needed!<a data-primary="" data-startref="ix_date_time_ch8" data-type="indexterm" id="id1750"/><a data-primary="" data-startref="ix_text_date_time_ch8" data-type="indexterm" id="id1751"/><a data-primary="" data-startref="ix_java_time_pkg" data-type="indexterm" id="id1752"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Other Useful Utilities" data-type="sect1"><div class="sect1" id="learnjava6-CHP-8-SECT-6">&#13;
<h1>Other Useful Utilities</h1>&#13;
&#13;
<p>We’ve looked at some of Java’s building blocks, including strings and numbers, as well as one of the most popular combinations of those strings and numbers—dates—in the <code>LocalDate</code> and <code>LocalTime</code> classes. We hope this range of utilities has given you a sense of how Java works with many of the elements you are likely to encounter.</p>&#13;
&#13;
<p>Be sure to read the documentation on the <code>java.util</code>, <code>java.text</code>, and <code>java.time</code> packages for more utilities that may come in handy. For example, you could look into using <code>java.util.Random</code> for generating the random coordinates of the trees in <a data-type="xref" href="#learnjava6-CHP-8-FIG-1">Figure 8-1</a>. Sometimes “utility” work is actually complex and requires careful attention to detail. Searching online for code examples or even complete libraries written by other developers may speed up your own efforts.</p>&#13;
&#13;
<p class="pagebreak-before">Next up, we’ll start building on these fundamental concepts. Java remains as popular as it is because it includes support for more advanced techniques in addition to the basics. One of those techniques is the “thread” features, which are baked right in. Threads provide better access to modern, powerful systems, keeping your applications performant even while handling many complex tasks. We’ll show you how to take advantage of this signature feature in <a data-type="xref" href="ch09.html#learnjava6-CHP-9">Chapter 9</a>.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Review Questions" data-type="sect2"><div class="sect2" id="learnjava6-CHP-8-SECT-6.1">&#13;
<h2>Review Questions</h2>&#13;
<ol>&#13;
<li>&#13;
<p>Which class contains the constant π? Do you need to import that class to use π?</p>&#13;
</li>&#13;
<li>&#13;
<p>Which package contains better replacements for the original <code>java.util.Date</code> class?</p>&#13;
</li>&#13;
<li>&#13;
<p>Which class should you use to format a date for user-friendly output?</p>&#13;
</li>&#13;
<li>&#13;
<p>What symbol would you use in a regular expression to help match the words “yes” and “yup”?</p>&#13;
</li>&#13;
<li>&#13;
<p>How would you convert the string “42” into the integer 42?</p>&#13;
</li>&#13;
<li>&#13;
<p>How would you compare two strings (such as “yes” and “YES”) to see if they match, ignoring any capitalization?</p>&#13;
</li>&#13;
<li>&#13;
<p>Which operator concatenates strings?</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Code Exercises" data-type="sect2"><div class="sect2" id="learnjava6-CHP-8-SECT-6.2">&#13;
<h2>Code Exercises</h2>&#13;
&#13;
<p>Let’s revisit our graphical Hello Java application and upgrade it using some new utilities and string features discussed in this chapter. You can start with the <code>HelloChapter8</code> class in the <em>exercises/ch08</em> folder. We want the program to support some command-line arguments for the message and initial position.</p>&#13;
&#13;
<p>Your program should accept 0, 1, or 2 arguments:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Zero arguments should place the text “Hello, utilities!” at the center to start.</p>&#13;
</li>&#13;
<li>&#13;
<p>One argument should be treated as the message to display; it should be centered to start:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Remember that multiword messages must be enclosed in quotes.</p>&#13;
</li>&#13;
<li>&#13;
<p>If the message is the word <code>today</code>, your code should generate a formatted date to use as the message.</p>&#13;
</li>&#13;
</ul>&#13;
</li>&#13;
<li>&#13;
<p>Two arguments represent the message and initial coordinates for where to display it:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>The coordinates should be a quoted string containing a pair of numbers separated by a comma and optional whitespace. These are all valid coordinate strings:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><code>150,150</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>50, 50</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>100, 220</code></p>&#13;
</li>&#13;
</ul>&#13;
</li>&#13;
<li>&#13;
<p>The coordinates argument may also be the word <code>random</code>, meaning your code should generate a random initial position.<a data-primary="" data-startref="ix_text_proc_ch8" data-type="indexterm" id="id1753"/></p>&#13;
</li>&#13;
</ul>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Here are some examples:</p>&#13;
&#13;
<pre data-type="programlisting">$ java HelloChapter8&#13;
// "Hello, utilities!" centered in the window&#13;
$ java HelloChapter8 "It works!"&#13;
// "It works!" centered in the window&#13;
$ java HelloChapter8 "I feel cornered" "20,20"&#13;
// "I feel cornered" in the upper left corner</pre>&#13;
&#13;
<p>If the user tries to pass three or more arguments, your code should generate an error message and exit.</p>&#13;
&#13;
<p>Start by testing the number of arguments. If your program gets at least one argument, use the first argument for the message. If it gets two, you’ll need to split the coordinates and convert them to numbers. If you get the <code>random</code> argument, be sure to generate random numbers that will keep the message visible. (You can assume some reasonable default length for the message; it’s OK if some of a longer message gets truncated on the right side.)</p>&#13;
&#13;
<p>Test out your solution with a few runs. Try different coordinates. Try the randomized option. Try the randomized option a few times successively to make sure the starting position really does change. What happens if you misspell <code>random</code> in the second argument?</p>&#13;
&#13;
<p>For a further upgrade: try to write a regular expression to accept some variations on <code>random</code> while still ignoring the case:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><code>random</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>rand</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>rndm</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>r</code></p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>As always, you can find a few hints for this problem in <a data-type="xref" href="app02.html#learnjava6-APP-B">Appendix B</a>. Our solutions are in the <em>ch08/exercises</em> folder of the source code.</p>&#13;
</div></section>&#13;
</div></section>&#13;
<div data-type="footnotes"><p data-type="footnote" id="id1542"><sup><a href="ch08.html#id1542-marker">1</a></sup> When in doubt, measure it! If your <code>String</code>-manipulating code is clean and easy to understand, don’t rewrite it until someone proves to you that it is too slow. Chances are that they will be wrong. And don’t be fooled by relative comparisons. A millisecond is a thousand times slower than a microsecond, but it still may be negligible to your application’s overall performance.</p><p data-type="footnote" id="id1549"><sup><a href="ch08.html#id1549-marker">2</a></sup> On most platforms the default encoding is UTF-8. You can get more details on character sets, default sets, and standard sets supported by Java in the <a href="https://oreil.ly/UarRO">official Javadoc documentation</a> for the  <span class="keep-together"><code>java.nio.charset.Charset</code></span> class.</p><p data-type="footnote" id="id1659"><sup><a href="ch08.html#id1659-marker">3</a></sup> Validating email addresses turns out to be much trickier than we can address here. Regular expressions can cover most valid addresses, but if you are doing validation for a commercial or other professional application, you may want to investigate third-party libraries, such as those available from <a href="https://oreil.ly/JEjEk">Apache Commons</a>.</p><p data-type="footnote" id="id1660"><sup><a href="ch08.html#id1660-marker">4</a></sup> You are welcome to <a href="https://oreil.ly/lMRnm">apply for your own, custom global TLD</a> if you have a few hundred thousand dollars lying around.</p><p data-type="footnote" id="id1702"><sup><a href="ch08.html#id1702-marker">5</a></sup> The <code>float</code> type is “single-precision,” and <code>double</code> is, well, double-precision. (Hence its name!) A <code>double</code> can retain numbers with roughly twice the precision as a <code>float</code>. Arbitrary-precision simply means that you can have as many digits as you need before and after the decimal point. To be fair, NASA uses a value for π with only 15 digits of precision, which <code>double</code> can handle fine.</p></div></div></section></body></html>