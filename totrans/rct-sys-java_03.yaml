- en: Chapter 2\. Introduction to Quarkus
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章。Quarkus简介
- en: Before continuing with understanding Reactive, let’s take a few moments to learn
    more about Quarkus. So what is Quarkus?
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续理解响应式之前，让我们花点时间了解一下Quarkus。那么，什么是Quarkus？
- en: '*Quarkus* is a Kubernetes-native Java stack. It has been tailored for Kubernetes,
    containers, and the cloud, but works perfectly well on bare metal and virtual
    machines.^([1](ch02.html#idm45358839670352)) Quarkus applications require less
    memory and start faster than applications using traditional frameworks. They also
    have the capability to be compiled into native executables, which make them consume
    even less memory and start instantly.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*Quarkus*是一个基于Kubernetes的Java堆栈。它专为Kubernetes、容器和云环境进行了定制，但在裸金属和虚拟机上也能完美运行。^([1](ch02.html#idm45358839670352))
    Quarkus应用程序需要比使用传统框架的应用程序更少的内存，并且启动更快。它们还可以编译成本地可执行文件，从而消耗更少的内存并实现即时启动。'
- en: One exciting, and central, aspect of Quarkus is the reactive engine. When running
    in containers or virtualized environments, a reactive engine is essential to reducing
    memory and CPU consumption. The engine makes any Quarkus application efficient
    while also enabling the creation of reactive applications and systems.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Quarkus一个令人兴奋且核心的方面是其响应式引擎。在容器或虚拟化环境中运行时，响应式引擎对于减少内存和CPU消耗至关重要。该引擎使得任何Quarkus应用程序都能高效运行，并支持响应式应用程序和系统的创建。
- en: In this chapter, you will see the main characteristics of Quarkus and learn
    to create an application, deploy it to Kubernetes, and create native builds. In
    [Chapter 6](ch06.html#quarkus-reactive), we cover the reactive engine in detail
    and show how to develop on Quarkus with a unified reactive and imperative programming
    model.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将看到Quarkus的主要特点，并学会创建应用程序、将其部署到Kubernetes，并创建本地构建。在[第6章](ch06.html#quarkus-reactive)中，我们详细介绍了响应式引擎，并展示了如何在Quarkus上开发统一的响应式和命令式编程模型。
- en: Java on the Cloud
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java云上的运行
- en: Java is now 25 years old! That’s hard to imagine sometimes. From the era of
    three-tier and client/server architecture, Java has evolved with many changes
    in architecture over the years. However, when a language is 25 years old, there
    will be pieces lingering that may not be suited to modern development.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Java现在已经25岁了！有时很难想象。从三层架构和客户端/服务器架构的时代开始，Java随着多年来架构的许多变化而发展。然而，当一门语言已经25岁时，可能会留下一些不适合现代开发的部分内容。
- en: What do we mean by that? When the initial versions of Java came out, *clouds*,
    *containers*, *microservices*, *serverless*, and any other term associated with
    computing today had not been imagined yet. There is no way we can expect the Java
    language created in the era of three-tier and client/server architecture to perform
    as we need in containers today.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这是什么意思？当Java的最初版本发布时，*云*、*容器*、*微服务*、*无服务器*以及今天与计算相关的任何其他术语都还没有被想象出来。我们无法指望Java语言在三层架构和客户端/服务器架构时代创建的版本在今天的容器中表现得符合我们的需求。
- en: Yes, many advancements have occurred over the years in Java, especially over
    the last couple of years with a new and faster release cadence. At the same time,
    Java prides itself on not breaking backward compatibility for developers and users.
    A large cost of that approach is that Java still retains pieces that were conceived
    without the benefits and knowledge of containers and what they provide.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，Java在多年来确实取得了许多进展，尤其是在最近几年的更快发布周期下。同时，Java自豪地宣称没有打破开发人员和用户的向后兼容性。这种方法的一个巨大成本是，Java仍然保留了在没有容器和其提供的知识和好处的情况下构思的部分内容。
- en: For many applications, Java will continue to work fine, and as is, for many
    more years to come. However, over the last few years, with the explosion of microservices,
    and most recently the evolution to serverless, Java does not fit these deployment
    models naturally.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多应用程序来说，Java将继续正常工作，并且如现在这样运行很多年。然而，在过去几年中，随着微服务的爆发，以及最近的向无服务器的演变，Java并不自然适应这些部署模型。
- en: Only a few years ago, Java’s lack of suitability in containers became apparent
    for all as we found out [Java ignored cgroups](https://oreil.ly/Mbux3). For containers,
    this created a huge problem. Java, unable to see the amount of memory allocated
    to a container, could only see the memory of the entire physical machine.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 几年前，Java在容器中的适应性不足问题显而易见，因为我们发现[Java忽视了cgroups](https://oreil.ly/Mbux3)。对于容器来说，这造成了一个巨大的问题。Java无法看到分配给容器的内存量，只能看到整个物理机的内存。
- en: In an environment where each container needs to work within a constrained amount
    of memory, Java didn’t *play nice*. Java was greedy. In addition, Java would create
    application threads based on the number of CPU cores. This caused many more threads
    to be allocated in a memory- and CPU-constrained container.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Is it a big deal? You might get lucky with your Java applications deployed in
    containers, if deploying to a Kubernetes node with other containers staying well
    within their memory limits. Then one day there’s a load spike, along with a spike
    in the memory consumed by the Java Virtual Machine (JVM), and then *boom*! Kubernetes
    kills the container for using too much memory.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: This specific problem with Java and cgroups has been fixed since Java 10, and
    since Java Development Kit (JDK) 8u131 options are available for enabling the
    same behavior. Check out the [“Java Inside Docker” article](https://oreil.ly/L5Yh7)
    on the Red Hat Developer’s site by Rafael Benevides with all the details.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: You might be thinking that Java should now be *good* in containers or in the
    cloud, right? Though this fix is available with an appropriate JDK version, many
    enterprises are using JDK 8 or older, and quite possibly not using a JDK 8 with
    the flags available. And Java’s issue in the cloud is more than cgroups alone.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Containers not being killed for grabbing more memory than the container expected
    is great. However, Java in containers raises concerns about the speed with which
    applications start receiving requests and the amount of memory they consume while
    running. Neither of these are great for Java applications, compared with other
    languages running in containers. Maybe startup speed isn’t a concern for many
    applications running today, but it can impact microservices needing to scale quickly
    for large traffic spikes, or the cold start time for serverless applications.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: What do we mean by *start receiving requests*? While it’s common for frameworks
    used in building applications to log their startup time, it refers to the amount
    of time taken for a *framework* to start. The time does not represent the time
    taken by an *application* before being able to start receiving requests. This
    time is a critical indicator with containers and the cloud!
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: The time to start receiving requests can also be called *time to first request*.
    Whether a framework can start in half a second doesn’t mean much, if another 2–3
    seconds passes before any traffic can be received and processed by the application.
    In such an example, it could be anywhere from 2.5 to 3.5 seconds before a new
    application instance can begin receiving user requests.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Granted, time to start receiving requests and memory consumption may not be
    a concern for a monolithic application with a few hundred, or even thousand, internal
    users. Monolithic applications can be developed with Quarkus, though the benefits
    we talk of for Quarkus will not be as prominent when developing monoliths. However,
    for microservices, and especially serverless, both these factors impact the costs
    of running a service and the availability to users.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 诚然，对于具有少量内部用户的单体应用程序，启动接收请求的时间和内存消耗可能并不是问题。虽然可以使用 Quarkus 开发单体应用程序，但我们谈论 Quarkus
    的好处时，在开发单体应用程序时不会像在微服务中那样显著。但是，对于微服务，尤其是无服务器架构，这两个因素都会影响运行服务的成本和向用户提供的可用性。
- en: Warning
  id: totrans-19
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Frameworks can often have low startup times by delaying work until receiving
    the first request. The remainder of any startup tasks are performed before processing
    the first request. *Lazy initialization* is another name for this behavior, offering
    a false indication on when an application is really ready. The time to *start
    receiving requests* is the best measure of application startup time. Having a
    low *time to first request* is essential in serverless workloads, as well as any
    kind of mechanism using a *scale-to-zero* approach, where the services are started
    only when needed. In more common architectures, such fast startup time reduces
    the recovery time after a crash.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 框架通常可以通过延迟工作直到接收到第一个请求来实现较低的启动时间。任何剩余的启动任务在处理第一个请求之前完成。*惰性初始化* 是这种行为的另一个名称，它提供了一个关于应用真正准备好的虚假指示。*开始接收请求*
    的时间是衡量应用启动时间的最佳指标。在无服务器工作负载以及使用 *规模至零* 方法的任何机制中，具有较低的 *首个请求时间* 是至关重要的，其中服务仅在需要时启动。在更常见的架构中，这种快速启动时间可以减少崩溃后的恢复时间。
- en: How can we measure startup time? Many approaches are possible, including modification
    of endpoints to output a timestamp when they’re accessed. To make our lives a
    bit simpler, we’re going to use a Node.js script developed by John O’Hara from
    Red Hat.^([2](ch02.html#idm45358839636416)) The script uses the application start
    command, and the URL to access it, to start the application in another process.
    The script waits for the URL to return `200`, meaning success, before computing
    the time to first request.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如何测量启动时间？有许多方法可行，包括修改端点以在访问时输出时间戳。为了让生活更简单，我们将使用由 Red Hat 的 John O’Hara 开发的
    Node.js 脚本。^[2](ch02.html#idm45358839636416) 此脚本使用应用程序启动命令和访问它的 URL，在另一个进程中启动应用程序。脚本会等待
    URL 返回 `200`，表示成功，然后计算首个请求的时间。
- en: Note
  id: totrans-22
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: For ease of use, we included [the contents of the GitHub repository](https://github.com/cescoffier/reactive-systems-in-java)
    along with the code in the *chapter-2/startup-measurement* directory. Ensure that
    you have Node.js installed, and run `npm install request` to install the script
    dependencies.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便使用，我们将 [GitHub 仓库的内容](https://github.com/cescoffier/reactive-systems-in-java)
    和 *chapter-2/startup-measurement* 目录中的代码一并包含在内。确保你已安装了 Node.js，并运行 `npm install
    request` 来安装脚本依赖。
- en: Right now you might be thinking that this discussion about startup speed and
    memory consumption is a very *hand wavy* topic that’s too subjective. We totally
    agree, which is why we’re now going to use a traditional Java EE stack, in this
    case [Thorntail](https://thorntail.io), to illustrate these concepts in practice.
    We chose Thorntail for the comparison as the first microservice framework from
    Red Hat, while Quarkus is the latest. Though the Thorntail project is no longer
    maintained, sadly, the good news is Quarkus incorporates lots of ideas from Thorntail.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可能会认为，关于启动速度和内存消耗的讨论是一个非常 *手摇摆* 的主题，太主观了。我们完全同意这一点，这就是为什么我们现在将使用传统的 Java
    EE 技术栈，在本例中使用 [Thorntail](https://thorntail.io) 来实践这些概念。我们选择 Thorntail 进行比较，因为它是
    Red Hat 的第一个微服务框架，而 Quarkus 则是最新的。尽管 Thorntail 项目已不再维护，但好消息是 Quarkus 吸收了许多 Thorntail
    的想法。
- en: 'One last thing before we get coding and running applications. *Memory* can
    be a somewhat vague term, as there are many types of memory. When we’re talking
    about memory, we’re referring to [*resident set size* (RSS)](https://oreil.ly/o4TzC),
    and not the JVM heap size, as heap is only part of the total memory that a Java
    application consumes. When running an application on the JVM, the total allocated
    memory can include the following:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编码和运行应用程序之前的最后一点要说明的是 *内存* 可能是一个比较模糊的术语，因为有许多类型的内存。当我们谈论内存时，我们指的是 [*常驻集大小*
    (RSS)](https://oreil.ly/o4TzC)，而不是 JVM 堆大小，因为堆只是 Java 应用程序消耗的总内存的一部分。在 JVM 上运行应用程序时，总分配内存可以包括以下内容：
- en: Heap space
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆空间
- en: Class metadata
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类元数据
- en: Thread stacks
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程堆栈
- en: Compiled code
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译后的代码
- en: Garbage collection
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 垃圾收集
- en: RSS represents the amount of memory that a process is occupying from main memory
    (RAM). RSS includes all the memory that the JVM requires to run an application,
    providing a more accurate value for the amount of memory actually occupied. As
    we’re running a single application in a single JVM process, we can easily ensure
    that we’re not measuring memory consumption of nonapplication processes.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: RSS 表示进程从主内存（RAM）占用的内存量。 RSS 包括 JVM 运行应用程序所需的所有内存，提供了实际占用内存量的更精确值。由于我们在单个 JVM
    进程中运行单个应用程序，因此可以轻松确保我们未测量非应用程序进程的内存消耗。
- en: Note
  id: totrans-32
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: All performance numbers are from our MacBook computer. As such, the results
    you see in this chapter may differ slightly, depending on your particular hardware
    configuration. If you happen to have an Apple M1, you could see even better results!
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 所有性能数字均来自我们的 MacBook 计算机。因此，在本章中看到的结果可能因您的特定硬件配置而略有不同。如果您拥有 Apple M1，您可能会看到更好的结果！
- en: Okay, time to run some code and see what we’re talking about with startup speed
    and memory consumption.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，是时候运行一些代码，看看我们在启动速度和内存消耗方面的讨论。
- en: Thorntail Example
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Thorntail 示例
- en: We start by creating a *traditional* application with Thorntail to provide a
    comparison of the memory, or RSS, and time-to-first-request metrics. For anyone
    not familiar with Thorntail, the project focused on the idea of a customizable
    [WildFly server](https://wildfly.org). Thorntail takes only the bits you need
    for a specific application, removing everything else.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过使用 Thorntail 创建一个 *传统* 应用程序来进行比较内存或 RSS 和首次请求时间指标。对于不熟悉 Thorntail 的人来说，该项目专注于可定制的[WildFly
    服务器](https://wildfly.org)的概念。Thorntail 只获取特定应用程序所需的部分，删除其他所有内容。
- en: The Thorntail application requires a [Java API for RESTful Web Services](https://oreil.ly/eYjXF)
    (JAX-RS) application, and a simple resource endpoint for us to make requests against.
    The Thorntail example needs a JAX-RS application, and a JAX-RS resource with a
    single method returning a greeting for an HTTP GET request. All the source code
    for the Thorntail example can be found in the */chapter-2/thorntail-hello* directory.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Thorntail 应用程序需要一个[Java API for RESTful Web Services](https://oreil.ly/eYjXF)
    (JAX-RS) 应用程序，并提供一个简单的资源端点用于我们发送请求。Thorntail 示例需要一个 JAX-RS 应用程序，以及一个 JAX-RS 资源，其中包含一个方法，用于对
    HTTP GET 请求返回问候语。Thorntail 示例的所有源代码可以在 */chapter-2/thorntail-hello* 目录中找到。
- en: There’s nothing special about the classes. They’re the bare minimum required
    to provide an HTTP endpoint with JAX-RS to make requests against. Let’s build
    the Thorntail application and then start it, as shown in [Example 2-1](#thorntail-2-1).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 类并没有什么特别之处。它们是提供使用 JAX-RS 提供 HTTP 端点进行请求的最低要求。让我们构建 Thorntail 应用程序，然后像 [示例 2-1](#thorntail-2-1)
    中所示启动它。
- en: Example 2-1\. Build and run the Thorntail Hello World application
  id: totrans-39
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-1\. 构建和运行 Thorntail Hello World 应用程序
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Once the application has started, hit the *[*http://localhost:8080/hello*](http://localhost:8080/hello)*
    endpoint with `curl` or a browser. After you’ve made a few requests, or more if
    you prefer, it’s time to take a look at the RSS memory used by the process. Accessing
    the endpoint before measuring RSS is important because an application may not
    have loaded all classes during startup, meaning we could see a misleading figure.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序启动后，请使用 `curl` 或浏览器访问[*http://localhost:8080/hello*](http://localhost:8080/hello)端点。在进行测量
    RSS 之前访问端点非常重要，因为应用程序可能在启动时未加载所有类，这意味着我们可能会看到误导性的数字。
- en: To be able to find out the memory used, we need the ID of the process the Thorntail
    application is running in. On Linux-based systems, including Mac, we can use `ps
    -e | grep thorntail`, which lists all the active processes and restricts the results
    to those containing `thorntail` in the name. With the process ID in hand, we can
    now find out how much RSS the process is using (as seen in [Example 2-2](#measure-2-2)).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要查找 Thorntail 应用程序所使用的内存，我们需要其运行的进程 ID。在基于 Linux 的系统中（包括 Mac），我们可以使用 `ps -e
    | grep thorntail` 命令列出所有活动进程，并将结果限制为名称中包含 `thorntail` 的进程。有了进程 ID，现在我们可以查找进程使用的
    RSS 量（如 [示例 2-2](#measure-2-2) 中所示）。
- en: Example 2-2\. Measure the RSS usage of the Thorntail application
  id: totrans-43
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-2\. 测量 Thorntail 应用程序的 RSS 使用情况
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[![1](assets/1.png)](#co_introduction_to_quarkus_CO1-1)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_introduction_to_quarkus_CO1-1)'
- en: '`ps` retrieves the RSS and command, and `awk` converts the RSS value to megabytes.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`ps` 命令检索 RSS 和命令，而 `awk` 将 RSS 值转换为兆字节。'
- en: You will see something like the preceding terminal output, showing the process
    ID, RSS converted to megabytes (`M`), and the command. Full details on how to
    find RSS for a process can be found on the Quarkus website.^([3](ch02.html#idm45358841838240))
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: We can see that a “Hello World” style application with a single endpoint returning
    a string uses 441 megabytes (MB). Whoa! That’s a lot of memory for a single JAX-RS
    endpoint returning a fixed string!
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: We should caution we’re running these tests on OpenJDK 11 without any customization
    for limiting the amount of memory the JVM captures, or any other tuning available
    to the JVM. We can limit what the JVM is able to grab and see how that affects
    the overall RSS ([Example 2-3](#start-thorntail-2-3)).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-3\. Start the Thorntail application to configure the heap size
  id: totrans-50
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now we get the output in [Example 2-4](#measure-rss-2-4).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-4\. Measure the RSS usage
  id: totrans-53
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: That dropped the memory usage down to 265 MB! We saved nearly 200 MB of RSS
    by limiting the amount of heap the JVM grabbed to 48 MB. Maybe 48 MB isn’t quite
    the sweet spot in terms of throughput, but that’s something to verify with your
    own applications, to find the balance between reduced memory consumption and increased
    throughput.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: We’ve shown the RSS usage, and now we need to calculate the time to first request.
    Ensure that all previous instances of the Thorntail application are stopped before
    continuing. Let’s check out time to first request, as shown in [Example 2-5](#measure-time-2-5).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-5\. Measure the time to first request of the Thorntail application
  id: totrans-57
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We see a bunch of `404` messages fly past in the console until the application
    returns a `200` response, and then we see the time taken. In our case, it was
    6,810 milliseconds (ms)! That’s not exactly fast in the world of microservices
    and functions. You can run it a few times to see whether the time varies much
    or not really at all. With a 7-second startup time, scaling microservices can’t
    meet traffic spikes quick enough, causing user delays and possibly errors. From
    a serverless perspective, we’re even worse off as we’d expect a serverless function
    to be started, run, and stopped well before 7 seconds elapsed.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-60
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The time to first request captured with *time.js* may be fractionally longer
    than it actually is, as a very small amount of time will be included as the child
    process spawns but before the JVM starts. We’re not too worried about such a small
    amount, as the impact applies to each runtime we test in the same manner.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: So, we’ve seen what a traditional application consumes for RSS, and how long
    it can take to reach time to first request. Now it’s time to see how Quarkus compares.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Quarkus Example
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’re going to create an identical Hello World endpoint, though it doesn’t say
    “Hello from Thorntail!” With Quarkus, we don’t need the JAX-RS application class;
    we need only the JAX-RS resource that has the same content as the Thorntail version,
    except for the message.^([4](ch02.html#idm45358833902576)) The source code for
    the Quarkus example can be found in the */chapter-2/quarkus-hello* directory.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: In [“Create Your First Quarkus Application”](#quarkus::create-first-application),
    we cover how to create a Quarkus application. Now build and run the Quarkus Hello
    World application, as shown in [Example 2-6](#build-start-quarkus-2-6).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-6\. Build and start the Quarkus Hello World application
  id: totrans-66
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As with Thorntail, we’re not optimizing the JVM to see what raw RSS usage we
    see. Hit *[*http://localhost:8080/hello*](http://localhost:8080/hello)* a few
    times as we did with Thorntail. Hopefully, you’re seeing the message “Hello from
    Quarkus!” Otherwise, you’re still running the Thorntail application.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Go find the process ID for the Quarkus application and check out the RSS ([Example 2-7](#measure-rss-2-7)).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-7\. Measure the RSS usage of the Quarkus Hello World application
  id: totrans-70
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here we see Quarkus using 133 MB of RSS, over 300 MB less than the 441 MB with
    Thorntail! That’s an astonishing improvement for what is essentially the same
    application.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: If we limit the maximum heap size to 48 MB, as we did for Thorntail, how much
    of an improvement do we get? Review [Example 2-8](#constrain-2-8). Don’t forget
    to use the endpoint once the application is started.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-8\. Constrain the heap usage and measure the RSS usage
  id: totrans-74
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: That got it down to 114 MB, but let’s see how far we can push Quarkus into smaller
    heap sizes! Refer to [Example 2-9](#constrain-2-9). Once again, don’t forget to
    use the endpoint once started.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-9\. Constrain the heap usage of the Quarkus application even more
    and measure the RSS usage
  id: totrans-77
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: With a max heap of 24 MB, we’re down to 98 MB of RSS! More importantly, the
    application still works! See how low you can reduce the maximum heap before Quarkus
    is unable to start. Although for regular applications, and even microservices,
    you wouldn’t be setting the maximum heap so low, being able to set it this low
    is critical for serverless environments.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-80
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Setting the heap size to a very low value may penalize the performance of the
    application, especially if the application does a lot of allocations. Don’t aim
    for the smallest value as possible, but verify the value according to your expected
    performance and deployment density gain. Note that the Quarkus architecture tries
    to avoid having such a penalty. However, we highly recommend you check with your
    application.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Time for startup speed (see [Example 2-10](#measure-time-2-10)).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-10\. Measure the time to first request for the Quarkus application
  id: totrans-83
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If your hardware is similar to ours, you should see a time to first request
    of around 1,001 ms! That’s nearly seven times faster than the traditional application!
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的硬件与我们的相似，您应该能看到大约 1,001 毫秒的第一次请求时间！这几乎比传统应用程序快了七倍！
- en: All this is really great, but what’s the point? Recalling our earlier discussion
    about Java in containers, let’s see the impact when running in containers. Assuming
    we have a node with 2 GB of RAM available, how many containers of each application
    can fit? Take a look at [Figure 2-1](#image:java-memory-containers).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都非常棒，但是意义何在？回顾我们之前关于 Java 在容器中的讨论，让我们来看看在容器中运行时的影响。假设我们有一个可用内存为 2 GB 的节点，每种应用程序可以容纳多少个容器？参考
    [图 2-1](#image:java-memory-containers)。
- en: '![Java memory in containers](assets/rsij_0201.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![Java 内存中的容器](assets/rsij_0201.png)'
- en: 'Figure 2-1\. Java memory in containers: Quarkus allows increasing the deployment
    density'
  id: totrans-88
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-1\. 容器中的 Java 内存：Quarkus 允许增加部署密度
- en: '*Container density* is a key characteristic of cloud deployments with Kubernetes.
    Given a specific node size, such as 2 GB of RAM, the more containers that can
    run in that single node, the greater container density we can provide. Improving
    container density enables better utilization of the resources available. From
    the example in [Figure 2-1](#image:java-memory-containers), will more throughput
    be achieved with 4 instances or 14? If each of the 14 containers supports less
    throughput, or requests per second, compared with one of the traditional containers,
    it doesn’t matter. A minor reduction in throughput in a container is more than
    offset by supporting 14 containers instead of 4.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*容器密度* 是使用 Kubernetes 进行云部署的关键特征。给定特定节点大小，例如 2 GB 的 RAM，能够在单个节点中运行的容器越多，我们就能提供更大的容器密度。从
    [图 2-1](#image:java-memory-containers) 的例子中可以看出，使用 4 个实例还是 14 个实例可以实现更高的吞吐量？即使每个
    14 个容器支持的吞吐量或请求每秒较少，与传统容器中的一个相比，这也无关紧要。在容器中轻微减少吞吐量比支持 14 个容器而不是 4 个容器更为重要。'
- en: Container density is an important metric in determining the number of instances
    that are required. What a developer needs to determine is their expected, or desired,
    throughput to be supported. Maybe fewer containers with larger memory requirements
    are fine for today’s needs, but keep in mind that things change, and you could
    easily need more than four to support your users!
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 容器密度是确定所需实例数量的重要指标。开发人员需要确定的是他们期望的或需要支持的吞吐量。也许今天的需求可以接受少量具有较大内存需求的容器，但请记住事情是会变化的，您可能很快就需要超过四个容器来支持您的用户！
- en: You’ve now seen the amount of RSS memory and time to first request with traditional
    applications on the JVM, and how Quarkus can significantly reduce these aspects
    for an application. Quarkus wants to tackle the challenge of improving Java in
    containers with a new approach. This approach improves the startup speed and the
    memory consumption of Java in a container.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已经看到了传统应用程序在 JVM 上的 RSS 内存量和第一次请求的时间，以及 Quarkus 如何显著减少这些方面。Quarkus 想要应对改善
    Java 在容器中的挑战，提出了一种新的方法。这种方法提高了 Java 在容器中的启动速度和内存消耗。
- en: The next section explains the details of how Quarkus makes this possible, and
    more importantly, how it differs from a traditional framework approach.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的部分将详细解释 Quarkus 如何实现这一点，更重要的是，它与传统框架方法的不同之处。
- en: The Quarkus Way
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Quarkus 的方式
- en: We’re sure you want to know all the intricate details of how Quarkus starts
    faster and consumes less memory than a traditional framework, right? We need to
    slow down a bit first, by explaining how traditional frameworks work, so you can
    understand what changes with Quarkus.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 您肯定想知道 Quarkus 比传统框架启动更快，内存消耗更少的复杂细节，对吧？我们需要先放慢速度，解释传统框架的工作方式，这样您才能理解 Quarkus
    带来的变化。
- en: 'Some well-known features of traditional frameworks are depicted in [Figure 2-2](#image:quarkus-build):'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 传统框架的一些著名特性展示在 [图 2-2](#image:quarkus-build) 中：
- en: Annotations within code defining expected behavior, with many examples of this
    we’ve all used over the years. Typical ones include `@Entity`, `@Autowired`, `@Inject`,
    and many, many more.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在代码中定义预期行为的注解，多年来我们都使用了许多示例。典型的例子包括 `@Entity`、`@Autowired`、`@Inject` 等等。
- en: Configuration files of various kinds. These files do everything from defining
    how classes should be wired together to configuring persistent data sources, and
    everything in between.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种类型的配置文件。这些文件做的事情从定义类如何被连接到配置持久数据源，无所不包。
- en: Classes used only during startup for creating runtime metadata and classes for
    the application to function.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅在启动期间使用的用于创建运行时元数据和应用程序功能的类。
- en: Utilizing reflection in determining methods to invoke, setting values into objects,
    and dynamically loading classes by name only.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用反射确定要调用的方法，将值设置到对象中，并仅通过名称动态加载类。
- en: '![Quarkus build time approach](assets/rsij_0202.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![Quarkus 构建时间方法](assets/rsij_0202.png)'
- en: Figure 2-2\. The Quarkus way
  id: totrans-101
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-2\. Quarkus 的方式
- en: We’re certainly not saying that Quarkus doesn’t have annotations, configuration
    files, or any other features of traditional frameworks. We *are* saying Quarkus
    handles them in a very different manner.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当然并不是说 Quarkus 没有注解、配置文件或传统框架的任何其他特性。我们*确实*是说 Quarkus 以非常不同的方式处理它们。
- en: Why would these features of traditional frameworks be considered “bad”? That’s
    a good question, and the answer requires some understanding of how these frameworks
    handle the preceding features. When there’s any type of configuration to be parsed
    or annotations to be discovered, framework classes are required to perform this
    work. Depending on how complex the process might be, anywhere from dozens to hundreds
    of classes could be needed to perform the task. In addition, each class would
    typically be holding state within itself representing intermediate states as startup
    occurs, or a final desired state after everything is processed.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么传统框架的这些特性会被认为是“不好”的呢？这是一个很好的问题，回答需要对这些框架如何处理前述特性有一定的理解。当需要解析任何配置或发现注解时，框架类需要执行这项工作。根据过程的复杂程度，可能需要从几十到几百个类来执行任务。此外，每个类通常会在自身内部保存状态，代表启动过程中的中间状态，或者在处理完成后表示最终期望的状态。
- en: There’s nothing particularly special about this; frameworks have worked this
    way for years, decades even. What you may not realize, though, is that any classes
    used to perform these startup tasks are still present, even if the JVM process
    has been running for six months without a restart! While any memory those classes
    grabbed should be eventually garbage collected, provided the classes properly
    released their hold on the memory when work was complete, the class metadata for
    them is still present in the JVM, even on the latest Java versions. It may not
    seem like much, but a couple of hundred classes that are no longer needed can
    impact the amount of memory required by the JVM.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 对此并没有什么特别之处；框架多年来甚至几十年来都是这样工作的。然而，您可能没有意识到的是，任何用于执行这些启动任务的类仍然存在，即使 JVM 进程已经运行了六个月而没有重启！虽然这些类抓取的任何内存应该最终被垃圾回收，只要这些类在工作完成时正确释放了它们对内存的控制，但它们的类元数据仍然存在于
    JVM 中，即使在最新的 Java 版本上也是如此。这可能看起来不是很多，但是几百个不再需要的类可能会影响 JVM 所需的内存量。
- en: This problem impacts all JVMs today, without special handling by a framework.
    All the classes used during startup, and never again, can be garbage collected
    by the JVM only if all objects of the class can be garbage collected, all references
    to the class are removed, and most importantly, all other classes in the same
    classloader are also no longer referenced. To facilitate the garbage collection
    of startup classes, a framework would need to utilize a classloader for startup
    classes and another classloader for runtime classes. It can be difficult to enable
    garbage collection for startup classes when thread pools are used, especially
    `ForkJoinPool`, and when thread-local variables are set during startup.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题今天影响所有的 JVM，没有框架的特殊处理。只有当类的所有对象可以被垃圾回收、对类的所有引用被删除，并且最重要的是，同一个类加载器中的所有其他类也不再被引用时，JVM
    才能够对启动期间使用的所有类进行垃圾回收。为了促进启动类的垃圾回收，框架需要为启动类使用一个类加载器，而为运行时类使用另一个类加载器。在使用线程池（特别是
    `ForkJoinPool`）和在启动期间设置线程局部变量时，启动类的垃圾回收可能会变得困难。
- en: Why should we retain classes in JVM memory if they will never be used again?
    Ideally, we shouldn’t, as it’s wasteful. This is where Quarkus shines. Quarkus
    extensions are designed and built to separate the various pieces of the traditional
    framework startup processing into smaller chunks of work. Doing this enables the
    build process, with Maven or Gradle, to take advantage of those smaller chunks
    and execute them during the build, instead of waiting until the runtime start.
    Utilizing startup classes *during build time* means those classes don’t need to
    be included in the JVM at runtime! This saves us memory and startup time.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果永远不会再次使用类，为什么要在 JVM 内存中保留它们？理想情况下，我们不应该这样做，因为这是浪费的。这就是 Quarkus 的优势所在。Quarkus
    扩展被设计和构建成将传统框架启动处理的各个部分分解为更小的工作块。这样做使得 Maven 或 Gradle 的构建过程能够利用这些较小的块，并在构建期间执行它们，而不是等到运行时启动。在构建时利用启动类意味着这些类在运行时不需要包含在
    JVM 中！这样就节省了内存和启动时间。
- en: How does it help to do this at build time, and where does the output go that’s
    needed during runtime? Extensions use bytecode recorders to do everything from
    setting static values on classes for runtime, to creating new classes to hold
    metadata that’s needed for runtime. What do we mean by that? Earlier we talked
    about frameworks doing a lot of work during startup, and Quarkus is able to create
    the output of that work during build time and write bytecode equating to the same
    result as with traditional frameworks at startup. At runtime, instead of performing
    the startup work, the JVM loads the class written by a Quarkus extension into
    memory as if all that startup work just happened without the cost of the memory
    and classes to do the work.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如何在构建时完成这些工作，并且在运行时需要的输出放在哪里？扩展使用字节码记录器来完成所有工作，从在运行时为类设置静态值到创建新类以保存运行时需要的元数据。我们是什么意思呢？早些时候我们讨论过框架在启动时做了很多工作，而
    Quarkus 能够在构建时创建该工作的输出，并编写字节码以达到与传统框架在启动时相同的结果。在运行时，JVM 加载由 Quarkus 扩展编写的类到内存中，就好像所有这些启动工作都刚刚发生过一样，但没有了内存和类的成本。
- en: Looking at some steps a traditional framework performs at startup, we can see
    in [Figure 2-3](#image:quarkus-framework-phases) how Quarkus handles them differently.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 查看传统框架在启动时执行的一些步骤，我们可以在 [图 2-3](#image:quarkus-framework-phases) 中看到 Quarkus
    如何以不同的方式处理它们。
- en: '![Framework startup phases in Traditional Frameworks vs Quarkus](assets/rsij_0203.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![传统框架与 Quarkus 中的框架启动阶段](assets/rsij_0203.png)'
- en: Figure 2-3\. Framework startup phases in traditional frameworks versus Quarkus
  id: totrans-110
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-3\. 传统框架与 Quarkus 中的框架启动阶段比较
- en: 'While Quarkus reads the configuration at build time, some properties, such
    as locations and credentials, are still configured and read at runtime. However,
    everything application-centric that can be decided at build time is handled during
    the build process. So far, we’ve been using build time to describe when Quarkus
    completes these typically startup-related tasks, but there is another term: *ahead-of-time*
    (AOT) compilation. You’ve seen that Quarkus differs from traditional frameworks
    in the way it approaches optimizing your application code and dependencies. Yes,
    this approach reduces the variability that is generally handled at runtime.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Quarkus 在构建时读取配置，但某些属性，例如位置和凭据，仍然在运行时配置和读取。然而，一切应用程序相关的可以在构建时决定的内容都在构建过程中处理。到目前为止，我们一直在使用构建时来描述
    Quarkus 完成这些通常与启动相关的任务的时间，但还有另一个术语：*提前编译*（AOT）。您已经看到 Quarkus 在优化应用程序代码和依赖项的方法上与传统框架有所不同。是的，这种方法减少了通常在运行时处理的可变性。
- en: However, modern workloads deployed in the cloud or in containers do not need
    such variability, as almost everything is known at build time. We hope you now
    have a clearer understanding of what Quarkus offers with this innovative approach,
    and why it is bringing excitement to Java development in the cloud again.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在云端或容器中部署的现代工作负载并不需要这种可变性，因为几乎所有内容在构建时都是已知的。我们希望您现在对 Quarkus 通过这种创新方式提供的优势有了更清晰的理解，以及为什么它再次为
    Java 在云端开发带来了兴奋。
- en: Create Your First Quarkus Application
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建您的第一个 Quarkus 应用程序
- en: 'There are quite a few ways to create a Quarkus application for the first time:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 Quarkus 应用程序的方法有很多种：
- en: Manually creating the project *pom.xml* or *build.gradle* file, adding Quarkus
    dependencies, setting up and configuring the plug-ins, and defining the source
    folders. Pretty messy and tedious, in our view!
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动创建项目的 *pom.xml* 或 *build.gradle* 文件，添加 Quarkus 依赖项，设置和配置插件，并定义源文件夹。在我们看来，相当混乱和乏味！
- en: Using Maven and the Quarkus plug-in to construct the project skeleton.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Maven和Quarkus插件构建项目框架。
- en: Browsing to [*https://code.quarkus.io*](https://code.quarkus.io) and selecting
    the dependencies that are needed. This is the simplest, quickest way to get started,
    and the method we’ll use.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览至[*https://code.quarkus.io*](https://code.quarkus.io)，并选择所需的依赖项。这是最简单、最快速的入门方法，也是我们将要使用的方法。
- en: It’s time to dive into creating a project! Head over to [*https://code.quarkus.io*](https://code.quarkus.io),
    and you will be presented with the page in [Figure 2-4](#image:quarkus-code-start).
    We’ve circled some key parts to explain them in detail.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候着手创建项目了！前往[*https://code.quarkus.io*](https://code.quarkus.io)，您将看到[图2-4](#image:quarkus-code-start)中的页面。我们已圈出一些关键部分，以便详细解释它们。
- en: At the very top of the page is the Quarkus version of the generated project.
    Just below it to the left, you can customize the group and artifact names that
    will be set for the project. These can be changed later if desired as well; you’re
    not stuck with *org.acme* if you forget to customize it.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在页面的最顶部是生成项目的Quarkus版本。稍低左侧是可以自定义的项目组和构件名称。如果需要，稍后也可以更改这些；如果忘记自定义，也不用担心一直使用*org.acme*。
- en: To the right, users can decide whether they want starter code added to the project.
    The default is yes, so if you select any extensions with the *CODE* marker, such
    as *RESTEasy JAX-RS*, starter code for that extension will be generated for the
    project. Below the top part of the page is the list of all available Quarkus extensions.
    A lot of extensions are available; the screenshot shows only the ones that would
    fit on a single page. Use each checkbox to select specific extensions to include
    in your project.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在右侧，用户可以决定是否向项目添加起始代码。默认情况下是是，因此如果您选择了任何带有*CODE*标记的扩展，例如*RESTEasy JAX-RS*，则会为该扩展生成项目的起始代码。在页面的顶部以下是所有可用的Quarkus扩展列表。提供了大量扩展；屏幕截图仅显示适合单页的扩展。使用每个复选框选择要包含在项目中的特定扩展。
- en: '![Quarkus project selection](assets/rsij_0204.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![Quarkus 项目选择](assets/rsij_0204.png)'
- en: Figure 2-4\. Quarkus project selection
  id: totrans-122
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2-4\. Quarkus 项目选择
- en: Lastly, if you don’t want to scroll through all the extensions, start typing
    terms into the search box above all the extensions. As you type, the list of extensions
    below it will filter, showing only the extensions matching your search criteria.
    As extensions are selected, they appear under the Selected Extensions area next
    to “Generate your application.”
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果您不想浏览所有扩展，可以在所有扩展上方的搜索框中开始输入术语。随着您的输入，下方的扩展列表将进行过滤，仅显示与您搜索条件匹配的扩展。在选择扩展后，它们将显示在“已选扩展”区域下方，旁边是“生成您的应用程序”。
- en: '[Figure 2-5](#image:quarkus-code-start-generate) shows how the screen looks
    when we’re about to generate the application.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2-5](#image:quarkus-code-start-generate)展示了当我们即将生成应用程序时屏幕的样子。'
- en: '![Quarkus project generation](assets/rsij_0205.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![Quarkus 项目生成](assets/rsij_0205.png)'
- en: Figure 2-5\. Quarkus project generation
  id: totrans-126
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2-5\. Quarkus 项目生成
- en: You can see we’ve chosen not to generate any starter code, and the RESTEasy
    JAX-RS extension is selected. We’re sticking with plain JAX-RS for now. We will
    explore a more reactive JAX-RS in [Chapter 8](ch08.html#http).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 可以看到，我们选择不生成任何起始代码，并选择了RESTEasy JAX-RS扩展。目前我们坚持使用普通的JAX-RS。我们将在[第8章](ch08.html#http)中探索更响应式的JAX-RS。
- en: As we hover over “Generate your application,” we can decide to download the
    project as a ZIP file or publish it to a GitHub repository. Right now, we will
    download as a ZIP file. The file will be automatically downloaded, with a name
    matching the artifact name. Once the download is finished, extract the ZIP file
    to a directory.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们悬停在“生成您的应用程序”上时，我们可以决定将项目下载为ZIP文件或发布到GitHub存储库。目前，我们将下载为ZIP文件。文件将自动下载，名称与构件名称匹配。下载完成后，将ZIP文件解压缩到一个目录中。
- en: With that done, we open a terminal window and change to the directory where
    the generated project was extracted. Let’s dive into using live reload ([Example 2-11](#run-app-dev-mode))
    and experience real Developer Joy!
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，我们打开一个终端窗口并切换到生成项目的目录。让我们深入使用实时重载（[示例2-11](#run-app-dev-mode)）并体验真正的开发者乐趣！
- en: Example 2-11\. Run the application in dev mode
  id: totrans-130
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-11\. 在开发模式下运行应用程序
- en: '[PRE10]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The preceding command starts Quarkus in live reload, enabling us to quickly
    iterate with code and instantly see the impact. A successful start will have the
    terminal output, shown in [Example 2-12](#output-quarkus-app).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令启动了 Quarkus 的实时重新加载，使我们能够快速迭代代码并即时看到影响。如果成功启动，终端输出如 [示例 2-12](#output-quarkus-app)
    所示。
- en: Example 2-12\. Output the Quarkus application
  id: totrans-133
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-12\. 输出 Quarkus 应用程序
- en: '[PRE11]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We’re off and running. Open *[*http://localhost:8080*](http://localhost:8080)*
    in a browser, and you will see `Resource not found`. Oh, no! What went wrong?
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经开始并且正常运行了。在浏览器中打开 *[*http://localhost:8080*](http://localhost:8080)*，你将看到
    `资源未找到`。哦，不！出了什么问题？
- en: Actually, nothing went wrong. Eagle-eyed readers might have noticed the startup
    log listed only `cdi` as an installed feature. What about RESTEasy? We selected
    the extension for it when creating the project. Have a look inside *pom.xml*,
    and you will see the dependencies ([Example 2-13](#quarkus-ext-dep-gen-proj)).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，没有任何问题。敏锐的读者可能已经注意到启动日志只列出了`cdi`作为已安装的功能。那么 RESTEasy 呢？我们在创建项目时选择了其扩展。打开
    *pom.xml*，你会看到这些依赖项（[示例 2-13](#quarkus-ext-dep-gen-proj)）。
- en: Example 2-13\. Quarkus extension dependencies of generated project (*chapter-2/code-with-quarkus/pom.xml*)
  id: totrans-137
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-13\. 生成项目的 Quarkus 扩展依赖项 (*chapter-2/code-with-quarkus/pom.xml*)
- en: '[PRE12]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: RESTEasy is definitely there as a dependency, so what’s going on? During the
    build process, Quarkus recognized there wasn’t actually any code present utilizing
    RESTEasy, making the feature uninstalled and available for removal to save memory.
    Let’s fix that now.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: RESTEasy 明确作为一个依赖项存在，那么出了什么问题呢？在构建过程中，Quarkus 发现实际上没有任何使用 RESTEasy 的代码，因此卸载了该功能，并可用于释放内存。现在让我们来修复这个问题。
- en: With Quarkus still running, create the *org.acme* package within */src/main/java*.
    Now create a class named `MyResource` within the package and the content in [Example 2-14](#jaxrs-myresource).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Quarkus 仍在运行时，在 */src/main/java* 内创建 *org.acme* 包。然后在该包内创建名为 `MyResource`
    的类，并参考 [示例 2-14](#jaxrs-myresource) 中的内容。
- en: Example 2-14\. JAX-RS `MyResource` (*chapter-2/code-with-quarkus/src/main/java/org/acme/MyResource.java*)
  id: totrans-141
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-14\. JAX-RS `MyResource` (*chapter-2/code-with-quarkus/src/main/java/org/acme/MyResource.java*)
- en: '[PRE13]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note
  id: totrans-143
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You may wonder why in the preceding snippet none of the `import` lines are Quarkus
    specific. Quarkus provides a cohesive full-stack framework by leveraging a growing
    list of over 50 best-of-breed libraries. In the preceding example, we use JAX-RS,
    a simple but efficient and flexible approach to building HTTP and REST APIs.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想为什么上述片段中没有任何 `import` 行是 Quarkus 特定的。Quarkus 通过利用超过 50 个最佳库提供了一个具有内聚性的全栈框架。在上述示例中，我们使用了
    JAX-RS，这是构建 HTTP 和 REST API 的简单而高效的方法。
- en: Refresh *[*http://localhost:8080*](http://localhost:8080)*. Wow, we now see
    `Hi` in the browser; what happened? Take a look in the terminal window ([Example 2-15](#automatic-restart-of-app)).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 刷新 *[*http://localhost:8080*](http://localhost:8080)*。哇，现在我们在浏览器中看到 `Hi` 了；发生了什么？查看终端窗口（[示例 2-15](#automatic-restart-of-app)）。
- en: Example 2-15\. Automatic restart of the application after a code change
  id: totrans-146
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-15\. 代码更改后应用程序的自动重启
- en: '[PRE14]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We can see Quarkus noticed modifications to *MyResource.java*, stopped, and
    then restarted itself. Looking at the installed features, we see it now includes
    `resteasy`. How cool is that? Even better, the server stopped and restarted in
    just over 300 ms.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到 Quarkus 察觉到了对 *MyResource.java* 的修改，停止并重新启动了自身。查看已安装的功能，我们现在看到它包括`resteasy`。这是多么酷啊！更好的是，服务器仅在
    300 毫秒内停止并重新启动。
- en: Why don’t we explore live reload some more to have a better feel of the real
    Developer Joy! With `mvn quarkus:dev` still running, open *[*http://localhost:8080/welcome*](http://localhost:8080/welcome)*
    in a browser ([Figure 2-6](#image:quarkus-resource-not-found)).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为什么不更深入地探索实时重新加载，以更好地体验真正的开发者乐趣呢！保持 `mvn quarkus:dev` 运行，然后在浏览器中打开 *[*http://localhost:8080/welcome*](http://localhost:8080/welcome)*（[图 2-6](#image:quarkus-resource-not-found)）。
- en: '![Resource not found](assets/rsij_0206.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![资源未找到](assets/rsij_0206.png)'
- en: Figure 2-6\. Resource not found
  id: totrans-151
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-6\. 资源未找到
- en: We got an error. Oh no!
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遇到了一个错误。哦，不！
- en: Don’t fear too much; we did expect it because we don’t have anything to respond
    to the */welcome* endpoint yet. However, Quarkus offers us some links to help
    diagnose the problem based on what it knows about the application. We are shown
    the list of valid endpoints—in this case, there is only an HTTP GET on */*.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 不要太害怕，我们是预料到的，因为我们没有任何响应 */welcome* 终点的内容。然而，Quarkus 提供了一些链接来帮助诊断问题，基于它所知道的应用程序信息。它显示了有效终点的列表——在这种情况下，只有一个
    */* 上的 HTTP GET。
- en: Under “Additional endpoints,” there are endpoints to assist while developing
    applications. In this example, we have endpoints related to *ArC*, which is the
    bean container based on Contexts and Dependency Injection (CDI) for Quarkus, as
    well as a link to the developer console. Clicking the developer console link will
    bring you to its main page ([Figure 2-7](#image:quarkus-dev-console)).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在“附加端点”下，有一些用于开发应用程序的端点。在这个例子中，我们有与*ArC*相关的端点，它是基于上下文和依赖注入（CDI）的Quarkus的bean容器，还有一个链接到开发者控制台。点击开发者控制台链接将带你到其主页（[图 2-7](#image:quarkus-dev-console)）。
- en: '![Quarkus Dev console](assets/rsij_0207.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![Quarkus 开发控制台](assets/rsij_0207.png)'
- en: Figure 2-7\. Quarkus Dev console
  id: totrans-156
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-7\. Quarkus 开发控制台
- en: There isn’t a lot there now, but we need to remember that the only extension
    we’ve added is RESTEasy. As we enhance an application with more extensions, more
    options and abilities will be available from the developer console. We went down
    a side track there, so let’s get back to resolving our failed page load! With
    the */welcome* page open to the failure in the browser, go back to the source
    and create a new class called `WelcomeResource` ([Example 2-16](#jaxrs-welcome-resource)).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在那里并没有太多内容，但我们需要记住，我们唯一添加的扩展是RESTEasy。随着我们用更多扩展增强应用程序，将从开发者控制台获得更多选项和能力。我们在一旁岔开了话题，所以让我们回到解决加载页面失败的问题上吧！在浏览器中打开
    */welcome* 页面并在失败页的源代码处，返回并创建一个名为`WelcomeResource`的新类（[示例 2-16](#jaxrs-welcome-resource)）。
- en: Example 2-16\. JAX-RS `WelcomeResource` (*chapter-2/code-with-quarkus/src/main/java/org/acme/WelcomeResource.java*)
  id: totrans-158
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-16\. JAX-RS `WelcomeResource` (*chapter-2/code-with-quarkus/src/main/java/org/acme/WelcomeResource.java*)
- en: '[PRE15]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: With the class written, head back to the browser and click Refresh.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 类写好后，回到浏览器并点击刷新。
- en: Triggering an HTTP request causes Quarkus to check whether any files were modified
    since the last request, as we’re running with live reload. Quarkus notices the
    presence of `WelcomeResource`, compiles it, and then restarts the server. If you’re
    like us, you may not have realized everything happening behind the scenes because
    the browser gave the expected response without much delay.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 触发HTTP请求会导致 Quarkus 检查自上次请求以来是否修改了任何文件，因为我们正在使用实时重载。Quarkus 注意到了 `WelcomeResource`
    的存在，对其进行编译，然后重新启动服务器。如果你和我们一样，你可能没有意识到在幕后发生的一切，因为浏览器几乎立即给出了预期的响应。
- en: Are you exhausted yet? We are.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经筋疲力尽了吗？我们是。
- en: That was a lot of information on creating a Quarkus project for the first time
    with [*https://code.quarkus.io*](https://code.quarkus.io), and experiencing the
    ease of development that live reload with Quarkus brings. It does have drawbacks,
    including less chance to get a coffee during a compile and restart. We will continue
    to explore everything that live reload can do as we work through the chapters,
    but take it for a spin yourself, adding new extensions and seeing what can be
    done without stopping it!
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第一次使用 [*https://code.quarkus.io*](https://code.quarkus.io) 创建 Quarkus 项目，并体验到与
    Quarkus 实时重载一起带来的开发便利。它确实有缺点，包括编译和重启期间较少喝咖啡的机会。随着我们逐步深入章节，我们将继续探索实时重载的一切可能性，但是你也可以自己尝试，添加新扩展并查看在不停止服务的情况下可以完成什么！
- en: Kubernetes with Quarkus in 10 Minutes
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用Quarkus在10分钟内部署Kubernetes
- en: In the previous section, we had lots of fun changing code and seeing the application
    update on the fly. We hope you had fun; we know we did!
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们乐在其中改变代码并看到应用程序实时更新。我们希望你玩得开心；我们知道我们玩得很开心！
- en: While that’s great for developing the code, can we use live coding in production?
    Well, maybe you could, but we really don’t think you want to do that!
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这对于开发代码非常棒，但我们可以在生产中使用实时编码吗？嗯，也许你可以，但我们真的不认为你想那样做！
- en: 'For deploying to production, we want to use immutable containers, which requires
    container orchestration, which for most means Kubernetes. [“The New Kids on the
    Block: Cloud Native and Kubernetes Native Applications”](ch03.html#distributed-system::cloud-native-kube)
    covers cloud native and Kubernetes applications in further detail.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 对于部署到生产环境，我们想使用不可变容器，这需要容器编排，对于大多数人来说意味着Kubernetes。[“新贵：云原生和 Kubernetes 原生应用”](ch03.html#distributed-system::cloud-native-kube)详细介绍了云原生和
    Kubernetes 应用。
- en: Why is Quarkus great for the cloud and, in particular, Kubernetes? Quarkus applications
    are designed to run efficiently in containers and have built-in health checks
    and monitoring capabilities. Quarkus also provides a great user experience, including
    the ability to deploy in a Kubernetes cluster in a single command, without having
    to write Kubernetes resource descriptors.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes introduces its own specific jargon, which may be confusing. This
    section introduces its main concepts.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: What are the steps to take our Quarkus application from the previous section
    and deploy it to Kubernetes? Let’s extend the application we generated in the
    previous section. The first thing we do is add the extension for Kubernetes to
    our application, as shown in [Example 2-17](#kubernetes-ext-dep).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-17\. Kubernetes extension dependency (*chapter-2/code-with-quarkus/pom.xml*)
  id: totrans-171
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: With this new dependency, the build can generate the necessary resource files
    for deploying the application to Kubernetes, as well as enable us to deploy the
    application. What a time-saver! Let’s see how it works!
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Before we can see how it works, we need to choose the preferred containerization
    mechanism. With Quarkus, we can choose between Docker, [Jib](https://oreil.ly/Ybxcs),
    and Source-to-Image (S2I). We will choose Jib, as all dependencies are cached
    in a layer separate from the application, making subsequent container builds much
    faster. Let’s add the Jib container dependency, as shown in [Example 2-18](#jib-container-ext-dep).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-18\. Jib container extension dependency (*chapter-2/code-with-quarkus/pom.xml*)
  id: totrans-175
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We’re nearly there! But first, we need a Kubernetes cluster! The easiest is
    to use minikube, but you can also use Docker Desktop, or [MicroK8s](https://microk8s.io/).
    In this book, we will use minikube, as it’s one of the most straightforward solutions.
    Minikube is not a complete Kubernetes cluster but provides enough features for
    us.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Follow the instructions from [the minikube documentation](https://oreil.ly/Vn7Jf)
    to download and install minikube. With minikube installed, start it ([Example 2-19](#start-minikube)).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-19\. Start minikube
  id: totrans-179
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The default configuration of minikube will be used unless we have specific configuration
    options set. Right now, the default is fine, which is two CPUs and 4 GB RAM for
    a virtual machine. If this is the first time minikube is being run, there will
    be a short delay while minikube downloads the necessary images.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Quarkus provides an additional extension for use with minikube, to tailor the
    Kubernetes resources specifically for minikube. A big advantage to this approach
    is not requiring a Kubernetes `Ingress` to access services inside Kubernetes;
    instead, we can access them through a `NodePort` service. This allows us to see
    localhost-accessible URLs for our services when running `minikube services list`.
    To activate localhost-accessible URLs, we need another dependency ([Example 2-20](#minikube-ext-dep)).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-20\. Minikube extension dependency (*chapter-2/code-with-quarkus/pom.xml*)
  id: totrans-183
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-20\. Minikube 扩展依赖 (*chapter-2/code-with-quarkus/pom.xml*)
- en: '[PRE19]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Before deploying our application, let’s play a bit with Kubernetes to understand
    some concepts. You can interact with Kubernetes clusters by using the `kubectl`
    command; see [Example 2-21](#retrieving-the-nodes).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在部署我们的应用程序之前，让我们稍微玩一下 Kubernetes，以了解一些概念。你可以使用`kubectl`命令与 Kubernetes 集群交互；参见[示例 2-21](#retrieving-the-nodes)。
- en: Example 2-21\. Retrieve the nodes
  id: totrans-186
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-21\. 检索节点
- en: '[PRE20]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This command prints the *nodes* managed by Kubernetes. You should not be surprised
    to see that we have a single node here, named `master`. That’s your machine, or
    virtual machine, depending on your operating system.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令打印由 Kubernetes 管理的 *节点*。你看到我们这里只有一个节点，名为`master`，不应感到惊讶。那就是你的机器，或者是你的操作系统的虚拟机，具体取决于你的操作系统。
- en: Unlike other systems such as Docker, Kubernetes doesn’t run containers directly.
    Instead, it wraps one or more containers into a higher-level structure called
    a *pod*. Pods are used as the unit of replication. If your application is getting
    too many requests, and a single pod instance can’t carry the load, you can ask
    Kubernetes to instantiate new replicas. Even when not under heavy load, it is
    a good idea to have multiple replicas of a pod, to allow load balancing and fault-tolerance.
    You can get the list of pods by using `kubectl get pods` ([Example 2-22](#get-kubectl-pods-2-22)).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Docker 等其他系统不同，Kubernetes 不直接运行容器。相反，它将一个或多个容器封装到称为 *pod* 的更高级结构中。Pod 用作复制的单位。如果你的应用程序收到了太多的请求，单个
    pod 实例无法承载负载，你可以要求 Kubernetes 实例化新的副本。即使在不受重负载的情况下，拥有一个 pod 的多个副本也是个好主意，以允许负载平衡和容错。你可以使用`kubectl
    get pods`获取 pod 的列表（参见[示例 2-22](#get-kubectl-pods-2-22)）。
- en: Example 2-22\. Use the `kubectl` command to list the running pods
  id: totrans-190
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-22\. 使用`kubectl`命令列出运行中的 pods
- en: '[PRE21]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Not a big surprise, our cluster is empty.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 不出意外，我们的集群是空的。
- en: In [“Java on the Cloud”](#quarkus::java-cloud), we talked a lot about wanting
    to reduce the amount of memory for services written in Java within a container.
    To be able to determine that in minikube, we need to install an add-on before
    deploying our service ([Example 2-23](#add-metric-server-to-minikube)).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在[“Java on the Cloud”](#quarkus::java-cloud)中，我们谈到了希望减少容器中使用 Java 编写的服务的内存量。为了能够在
    minikube 中确定这一点，我们需要在部署我们的服务之前安装一个插件（参见[示例 2-23](#add-metric-server-to-minikube)）。
- en: Example 2-23\. Add the metric server to the minikube cluster
  id: totrans-194
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-23\. 向 minikube 集群添加度量服务器
- en: '[PRE22]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To create pods, we need a *deployment*. Deployments have two primary purposes:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建 pods，我们需要一个 *deployment*。部署有两个主要目的：
- en: Indicate which containers need to run in the pod
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指示哪些容器需要在 pod 中运行
- en: Indicate the number of instances of the pod that should be running at a time
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指示应该同时运行的 pod 实例数
- en: 'Generally, to create a deployment, you need the following:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，要创建一个部署，你需要以下内容：
- en: A container image accessible to your Kubernetes cluster
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可供你的 Kubernetes 集群访问的容器镜像
- en: A YAML document describing your deployment^([5](ch02.html#idm45358833162544))
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个描述你的部署的 YAML 文档^([5](ch02.html#idm45358833162544))
- en: Quarkus provides facilities to avoid having to create the image and write the
    deployment manually, such as the Kubernetes, minikube, and Jib container extensions
    we mentioned earlier.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Quarkus 提供了一些工具来避免手动创建镜像和编写部署，比如我们之前提到的 Kubernetes、minikube 和 Jib 容器扩展。
- en: With all the pieces in place, it’s time for us to build and deploy the application
    to Kubernetes in minikube! Open a terminal window and change to the directory
    of the project. Because we don’t want to run our own Docker daemon for building
    the containers, we can run `eval $(minikube -p minikube docker-env)` to expose
    the Docker daemon from minikube to the local terminal environment.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 所有组件就位后，现在是我们构建并部署应用程序到 Kubernetes 中的 minikube 的时候了！打开一个终端窗口并切换到项目目录。因为我们不想运行自己的
    Docker 守护程序来构建容器，我们可以运行`eval $(minikube -p minikube docker-env)`来将 Docker 守护程序从
    minikube 暴露到本地终端环境。
- en: Tip
  id: totrans-204
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: '`eval $(minikube -p minikube docker-env)` must be run in every terminal window
    we use to access minikube. Without, it any Docker commands we execute will use
    the local Docker daemon, which we don’t want.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`eval $(minikube -p minikube docker-env)`必须在我们用来访问 minikube 的每个终端窗口中运行。如果没有，我们执行的任何
    Docker 命令都将使用本地 Docker 守护程序，这是我们不想要的。'
- en: Next we build and deploy the container (as shown in [Example 2-24](#deploy-quarkus-app-to-kub)).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们构建并部署容器（如[示例 2-24](#deploy-quarkus-app-to-kub)所示）。
- en: Example 2-24\. Deploy a Quarkus application to Kubernetes
  id: totrans-207
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-24\. 将 Quarkus 应用程序部署到 Kubernetes
- en: '[PRE23]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[![1](assets/1.png)](#co_introduction_to_quarkus_CO2-1)'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_introduction_to_quarkus_CO2-1)'
- en: Package the application, create the container image, create the deployment descriptor,
    and deploy it to our cluster.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 打包应用程序，创建容器镜像，创建部署描述符，并将其部署到我们的集群。
- en: Execute the `kubeclt get pods` command to verify ([Example 2-25](#list-running-pods-with-kubectl)).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`kubeclt get pods`命令进行验证（参见[示例 2-25](#list-running-pods-with-kubectl)）。
- en: Example 2-25\. List running pods with `kubectl`
  id: totrans-212
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-25\. 使用`kubectl`列出正在运行的Pod。
- en: '[PRE24]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Yeah! Our application is running!
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 是的！我们的应用程序正在运行！
- en: Quarkus creates a deployment for us, as shown in [Example 2-26](#list-installed-deployments).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: Quarkus为我们创建了一个部署，如[示例 2-26](#list-installed-deployments)所示。
- en: Example 2-26\. List the installed deployments
  id: totrans-216
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-26\. 列出已安装的部署
- en: '[PRE25]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You can check the created deployment in *target/kubernetes/minikube.yml*, or
    review [Example 2-27](#generated-deployment).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以检查`target/kubernetes/minikube.yml`中创建的部署，或者查看[示例 2-27](#generated-deployment)。
- en: Example 2-27\. The generated deployment
  id: totrans-219
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-27\. 生成的部署
- en: '[PRE26]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[![1](assets/1.png)](#co_introduction_to_quarkus_CO3-1)'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_introduction_to_quarkus_CO3-1)'
- en: The number of replicas
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 副本数量
- en: '[![2](assets/2.png)](#co_introduction_to_quarkus_CO3-2)'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_introduction_to_quarkus_CO3-2)'
- en: The container image name
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 容器镜像名称
- en: As you can see, the deployment YAML indicates the number of replicas and the
    set of containers running in the pod (here, a single one).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，部署的YAML文件指示了副本的数量以及在Pod中运行的容器集（这里是一个）。
- en: 'If you look carefully at the generated descriptor, you will see `service`:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您仔细查看生成的描述符，您会看到`service`：
- en: '[PRE27]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[![1](assets/1.png)](#co_introduction_to_quarkus_CO4-1)'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_introduction_to_quarkus_CO4-1)'
- en: Random local port number we can access the service on
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 随机的本地端口号，我们可以访问服务。
- en: A *service* is a channel of communication delegating to a set of pods (selected
    using labels). In our example, the service is named `code-with-quarkus`. This
    name can be used by other applications to discover the functionality we expose.
    This service delegates the port 8080 on pods with matching labels (*app.kubernetes.io/name*
    and *app.kubernetes.io/version*). The good news is that our pod is configured
    with these labels. As a result, calling this `code-with-quarkus` on port 8080
    delegates to port 8080 of our container.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '*服务*是一种通信渠道，委托给一组Pod（使用标签选择）。在我们的示例中，服务被命名为`code-with-quarkus`。其他应用程序可以使用这个名称来发现我们公开的功能。该服务将端口8080委托给具有匹配标签（*app.kubernetes.io/name*和*app.kubernetes.io/version*）的Pod。好消息是我们的Pod配置了这些标签。因此，调用此`code-with-quarkus`在容器的8080端口上委托给我们的8080端口。'
- en: Note
  id: totrans-231
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Quarkus generates multiple descriptors. The *minikube.yml* descriptor is tailored
    for minikube. The *kubernetes.yml* descriptor is more generic. The main difference
    is the type of service that gets created.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: Quarkus生成了多个描述符。*minikube.yml*描述符专为minikube定制。*kubernetes.yml*描述符更通用。主要区别在于创建的服务类型。
- en: So, let’s invoke our service! We need to ask minikube to give us the service
    URL, as shown in [Example 2-28](#retrieve-the-service-url).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们调用我们的服务！我们需要请求minikube提供服务的URL，如[示例 2-28](#retrieve-the-service-url)所示。
- en: Example 2-28\. Retrieve the service URL
  id: totrans-234
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-28\. 检索服务URL
- en: '[PRE28]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Open a browser and use the URL of the service to access it, or `curl` if you
    prefer. If deployment worked, we see `Hi` as a response on the root path. Add
    `/welcome` to see `Welcome to Quarkus!` We deployed a Quarkus service to Kubernetes!
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 打开浏览器并使用服务的URL访问，或者如果您喜欢，使用`curl`。如果部署成功，我们在根路径上会看到`Hi`作为响应。添加`/welcome`可以看到`Welcome
    to Quarkus!`我们已经将一个Quarkus服务部署到了Kubernetes！
- en: We’ve verified that our Quarkus service deployed and works as expected, but
    what about the memory situation? Let’s check it out in [Example 2-29](#measure-resource-usage-kubectl).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经验证了我们的Quarkus服务部署并正常工作，但内存情况如何呢？让我们在[示例 2-29](#measure-resource-usage-kubectl)中检查一下。
- en: Example 2-29\. Measure resource usage using `kubectl top`
  id: totrans-238
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-29\. 使用`kubectl top`来测量资源使用情况。
- en: '[PRE29]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Wow, only 80 MB is really nice and compact! That’s a large improvement over
    traditional frameworks in containers.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，只有80 MB，确实非常好而且紧凑！这比容器中传统框架有了很大的改进。
- en: You’ve just seen how to take a Quarkus application and add the ability to deploy
    it to Kubernetes or, in this case, to minikube. There are certainly potential
    gotchas in defining the Kubernetes resources we need for deployment, but that’s
    why we use the Kubernetes extension with Quarkus to handle all that for us. We
    prefer not to handcode YAML or JSON, inadvertently making an error with indentation,
    and then watching deployment fail!
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 刚才我们看到如何将一个 Quarkus 应用程序添加到 Kubernetes 或者在这种情况下，minikube 的部署能力。在定义部署所需的 Kubernetes
    资源时，肯定会遇到一些潜在问题，但这就是为什么我们使用 Quarkus 的 Kubernetes 扩展来处理这一切。我们宁愿不手动编写 YAML 或 JSON，无意中在缩进上犯错，然后看到部署失败！
- en: Going Native
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 走本地
- en: What does *going native* mean? We’re referring to the ability to build native
    executables for an environment. Many applications we use every day on our machines
    are *native executables*, meaning the code of the application was compiled down
    to low-level instructions for a specific operating system, in our case macOS.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '*“走本地”*是什么意思？我们指的是能够为特定环境构建本地可执行文件的能力。我们每天在计算机上使用的许多应用程序都是*本地可执行文件*，这意味着应用程序的代码已经编译成针对特定操作系统（在我们的例子中是
    macOS）的低级指令。'
- en: Developing Java applications has always required the presence of a JVM for execution.
    However, the ability to build a native executable from Java code has recently
    been made possible with releases from the [GraalVM](https://www.graalvm.org) project.
    In this section, we explain how to utilize the GraalVM project with Quarkus to
    generate a native executable for your Java code!
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 开发 Java 应用程序一直需要 JVM 执行。然而，最近通过 [GraalVM](https://www.graalvm.org) 项目的发布，使得从
    Java 代码构建本地可执行文件成为可能。在本节中，我们解释了如何利用 GraalVM 项目与 Quarkus 一起为您的 Java 代码生成本地可执行文件！
- en: In [“The Quarkus Way”](#quarkus::quarkus-way), we discussed how Quarkus utilizes
    AOT compilation to perform actions during build time instead of on application
    start.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [“Quarkus 的方式”](#quarkus::quarkus-way) 中，我们讨论了 Quarkus 如何利用 AOT 编译在构建时执行操作，而不是在应用程序启动时执行。
- en: 'Quarkus extensions achieve this by breaking all the work into three separate
    phases:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: Quarkus 扩展通过将所有工作分为三个独立阶段来实现这一点：
- en: Augmentation
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 增强
- en: Build steps process descriptors and annotations, and augment the application
    classes by generating bytecode containing any required metadata. This phase is
    always executed within the build process on a JVM.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 构建步骤处理描述符和注解，并通过生成包含任何必需元数据的字节码来增强应用程序类。这个阶段总是在 JVM 的构建过程中执行。
- en: Static initialization
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 静态初始化
- en: Runs any steps intended to have their resulting output captured in bytecode.
    There are restrictions on what these steps can do, as they should not open ports
    for listening or start threads.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 运行任何旨在捕获其结果输出的步骤到字节码中。这些步骤有一些限制，不应打开监听端口或启动线程。
- en: Runtime initialization
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时初始化
- en: These steps are run as part of the application’s main method during startup.
    Tasks should be kept to a minimum to take the most advantage of AOT.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤作为应用程序主方法的一部分在启动时运行。任务应尽可能保持最小化，以充分利用 AOT 的优势。
- en: Static and runtime initialization both occur at startup when executing on a
    JVM. However, with native executables we have an extra benefit. With initialization
    separated into two phases, we’re able to perform static initialization during
    the native executable build process. This allows the output from the static initialization
    phase to be serialized directly into the native executable, allowing any classes
    used in this phase to be dropped from the native executable as they’re no longer
    needed. This provides benefits in native executable startup time and reduction
    in memory requirements.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 静态和运行时初始化都发生在 JVM 上的启动过程中。然而，使用本地可执行文件，我们有额外的好处。通过将初始化分为两个阶段，我们能够在本地可执行文件构建过程中执行静态初始化。这允许静态初始化阶段的输出直接序列化到本地可执行文件中，从而允许在本阶段使用的任何类在之后不再需要时从本地可执行文件中删除。这在本地可执行文件的启动时间和内存需求减少方面带来了好处。
- en: As part of the native executable build process with GraalVM, all execution paths
    are evaluated. Any classes, methods, or fields deemed to not be on the execution
    path are removed from the resulting native executable. This is why reflection,
    dynamic class loading, and other features of JVM usage are disallowed without
    special flags, because the goal is to *not* retain every piece of code within
    a native executable. If we were to attempt to build a native executable for the
    earlier Thorntail example, it would require flags to be set to allow reflection,
    dynamic class loading, and possibly others. The design of Thorntail is not suitable
    for a native executable build, whereas Quarkus has the goal of code reduction
    in mind from the beginning.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what’s needed to actually build a native executable.^([6](ch02.html#idm45358832739008))
    Creating the project with [*https://code.quarkus.io*](https://code.quarkus.io)
    means a Maven profile was already added to the project for us. [Example 2-30](#native-image-gen-maven-profile)
    shows what that looks like.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-30\. Native image generation Maven profile (*chapter-2/code-with-quarkus/pom.xml*)
  id: totrans-256
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We now have the ability to build a native executable for Quarkus, but without
    GraalVM installed we won’t get very far! Check [the “Building a Native Executable”
    guide](https://oreil.ly/HFtW1) for all the details on installing GraalVM for building
    native executables.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Once GraalVM is installed, let’s build a native executable; see [Example 2-31](#compile-quarkus-app-into-native).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-31\. Compile a Quarkus application into a native executable
  id: totrans-260
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Unfortunately, building a native executable does take longer than usual JVM
    builds. For this reason, we suggest not building a native executable regularly,
    and recommend doing these builds as part of a CI pipeline.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: Running these builds is our new opportunity for coffee breaks!
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-264
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As the number of classes grows in an application, a native executable build
    takes longer to complete. This longer time is caused by the larger number of execution
    paths requiring evaluation.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: With the native executable built, we can run it with `./target/code-with-quarkus-1.0.0-SNAPSHOT-runner`.
    Relish in the speed with which it starts, and be sure to verify that the two endpoints
    we created still work.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now built a native executable for our local environment, but unless we’re
    using a Linux operating system, our native executable won’t work inside a container!
    As native executables are specific to an operating system, we need to specially
    build one for use in a Linux container.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: To build a native executable for containers, we need to utilize [Docker](https://docker.com).
    Once Docker is installed, ensure that it’s started. As the current terminal has
    been switched to use the Docker daemon inside minikube, we need to open a new
    terminal so we can use local Docker for a build. Navigate to the project directory
    and run [Example 2-32](#compile-quarkus-app-linux-64).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-32\. Compile a Quarkus application into a Linux 64-bit native executable
  id: totrans-269
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: What we’ve done is utilized our local Docker environment to build a native executable
    for a Linux operating system. If we tried to run the native executable, and our
    local operating system is not Linux, we see an error ([Example 2-33](#format-error-start-application)).
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-33\. Format error when we start an application not compiled for the
    host operating system
  id: totrans-272
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We need to go back to the previous terminal now, as we want to interact with
    the Docker daemon in minikube. Let’s run a Docker build inside minikube, as shown
    in [Example 2-34](#build-container-running-quarkus-app).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-34\. Build a container running a Quarkus application compiled into
    a native executable
  id: totrans-275
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Tip
  id: totrans-277
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Don’t forget to replace `*<your_docker_username>*` with your local Docker username.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: We now have a container available inside minikube, so let’s create the application
    deployment; see [Example 2-35](#deploy-quarkus-application-into-minikube).
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-35\. Deploy the Quarkus application into minikube
  id: totrans-280
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We used the minikube-specific Kubernetes YAML from an earlier build to create
    the deployment. This version creates the *NodePort* service we need to access
    a service from our local environment, but also modifies the `imagePullPolicy`
    of the container to `IfNotPresent` instead of `Always`. This last change prevents
    minikube from trying to check for a newer container image from Docker Hub, which
    is good because it wouldn’t find one there!
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: With the deployment done, grab the URL from `minikube service list` and test
    out the endpoints again. Everything should be good, and we get the same messages
    as before.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: Now for the interesting part! Earlier we installed the metrics server into minikube
    to track memory utilization, and now it’s time to see what our native executable
    looks like. Though we’ve made requests and the deployment is present, it can be
    a few minutes before the metrics are available. Keep trying until they appear.
    You should see something similar to [Example 2-36](#measure-resource-usages-kubernetes).
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-36\. Measure resource usage in Kubernetes
  id: totrans-285
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: That’s fantastic! Only 7 MB of RAM used!
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: This is where the combination of Quarkus and native executables really shines.
    We can also check the logs of the pod to see how quickly the container started;
    we would expect it to be around 10–20 ms.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-289
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We attempted to build a native image for Thorntail to provide a comparison.
    However, we experienced issues building a usable native image and were stopped
    by an [`UnsatisfiedLinkError`](https://oreil.ly/hxcqo).
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve covered a great deal about Quarkus in a short amount of time, and there’s
    still plenty more to go through in the remainder of the book. Quarkus is a Kubernetes-native
    Java stack, focused on minimizing memory requirements with AOT, and amping up
    the memory reduction even further when we want a native executable. With the Kubernetes
    and container extensions, Quarkus takes the hassle out of handwriting YAML deployment
    files, doing it all for us!
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在短时间内涵盖了大量关于 Quarkus 的内容，但在本书的剩余部分仍有很多内容需要探讨。Quarkus 是一个针对 Kubernetes 的本地化
    Java 栈，专注于通过 AOT 最小化内存需求，并在需要本地可执行文件时进一步增加内存减少。通过 Kubernetes 和容器扩展，Quarkus 消除了手工编写
    YAML 部署文件的麻烦，为我们完成了所有工作！
- en: 'In this chapter, you learned about the following:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了以下内容：
- en: Understanding the problems with Java in containers
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解在容器中使用 Java 遇到的问题
- en: Understanding how Quarkus differs from traditional frameworks in moving runtime
    startup tasks to buildtime with AOT
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Quarkus 如何通过 AOT 将运行时启动任务移动到构建时与传统框架不同
- en: Creating a Quarkus project with [*https://code.quarkus.io*](https://code.quarkus.io)
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 [*https://code.quarkus.io*](https://code.quarkus.io) 创建 Quarkus 项目
- en: Using Kubernetes and minikube extensions to generate the required deployment
    configuration
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Kubernetes 和 minikube 扩展生成所需的部署配置
- en: Building a native executable for Quarkus with GraalVM
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 GraalVM 为 Quarkus 构建本地可执行文件
- en: Using the Kubernetes extension to deploy Quarkus applications to a container
    environment
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Kubernetes 扩展部署 Quarkus 应用到容器环境中
- en: In the next chapters, we will briefly take a step back to detail distributed
    systems, reactive systems, reactive programming, and how they relate to each other.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将简要回顾详细分布式系统、响应式系统、响应式编程及其相互关系。
- en: ^([1](ch02.html#idm45358839670352-marker)) In this book, *container* refers
    to a form of operating system virtualization, not to Java EE containers.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch02.html#idm45358839670352-marker)) 本书中，*容器* 指的是操作系统虚拟化形式，而不是 Java EE
    容器。
- en: ^([2](ch02.html#idm45358839636416-marker)) You can find the [script to measure
    startup time on GitHub](https://github.com/cescoffier/reactive-systems-in-java).
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch02.html#idm45358839636416-marker)) 您可以在 GitHub 上找到 [用于测量启动时间的脚本](https://github.com/cescoffier/reactive-systems-in-java)。
- en: ^([3](ch02.html#idm45358841838240-marker)) [See Platform Specific Memory Reporting
    on the Quarkus website](https://oreil.ly/eYjXF).
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch02.html#idm45358841838240-marker)) [查看 Quarkus 网站上特定平台的内存报告](https://oreil.ly/eYjXF)。
- en: ^([4](ch02.html#idm45358833902576-marker)) Quarkus offers multiple ways to implement
    HTTP endpoints. JAX-RS is one of them. You can also use controller classes with
    Spring MVC annotation or reactive routes if you prefer more programmatic approaches.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch02.html#idm45358833902576-marker)) Quarkus 提供多种实现 HTTP 端点的方式。JAX-RS
    是其中之一。您还可以使用带有 Spring MVC 注解的控制器类或者如果更喜欢程序化方法，可以使用响应式路由。
- en: ^([5](ch02.html#idm45358833162544-marker)) YAML (Yet Another Markup Language)
    is the most used format to describe Kubernetes resources. [Wikipedia provides
    a gentle introduction](https://oreil.ly/mZOTT).
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch02.html#idm45358833162544-marker)) YAML（Yet Another Markup Language）是描述
    Kubernetes 资源最常用的格式。[Wikipedia 提供了一个简明介绍](https://oreil.ly/mZOTT)。
- en: ^([6](ch02.html#idm45358832739008-marker)) GraalVM is not the first tool to
    build native executables from Java code. Dalvik, Avian, GNU Compiler for Java
    (GCJ,) and Excelsior JET predate GraalVM.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch02.html#idm45358832739008-marker)) GraalVM 并非第一个用于从 Java 代码构建本地可执行文件的工具。Dalvik、Avian、GNU
    Compiler for Java (GCJ) 和 Excelsior JET 在 GraalVM 之前就存在了。
