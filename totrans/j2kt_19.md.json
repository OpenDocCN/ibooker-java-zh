["```java\nval secondsIn24hours = 60 * 60 * 24\n```", "```java\nsecondsIn(today())\n```", "```java\nsealed class Either<out L, out R>\n\ndata class Left<out L>(val l: L) : Either<L, Nothing>()\n\ndata class Right<out R>(val r: R) : Either<Nothing, R>()\n```", "```java\nfun parseInt(s: String): Either<String, Int> = try {\n    Right(Integer.parseInt(s))\n} catch (exception: Exception) {\n    Left(exception.message ?: \"No message\")\n}\n```", "```java\nval result: Either<String, Int> = parseInt(readLine() ?: \"\")\nwhen (result) {\n    is Right -> println(\"Your number was ${result.r}\")\n    is Left -> println(\"I couldn't read your number because ${result.l}\")\n}\n```", "```java\nfun doubleString(s: String): Either<String, Int> {\n    val result: Either<String, Int> = parseInt(s)\n    return when (result) {\n        is Right -> Right(2 * result.r)\n        is Left -> result\n    }\n}\n```", "```java\ninline fun <L, R1, R2> Either<L, R1>.map(f: (R1) -> R2): Either<L, R2> =\n    when (this) {\n        is Right -> Right(f(this.r))\n        is Left -> this\n    }\n```", "```java\nfun doubleString(s: String): Either<String, Int> = parseInt(s).map { 2 * it }\n```", "```java\ninline fun <L, R1, R2> Either<L, R1>.flatMap(\n    f: (R1) -> Either<L, R2>\n): Either<L, R2> =\n    when (this) {\n        is Right -> f(this.r)\n        is Left -> this\n    }\n```", "```java\nfun BufferedReader.eitherReadLine(): Either<String, String> =\n    try {\n        val line = this.readLine()\n        if (line == null)\n            Left(\"No more lines\")\n        else\n            Right(line)\n    } catch (x: IOException) {\n        Left(x.message ?: \"No message\")\n    }\n```", "```java\nfun doubleNextLine(reader: BufferedReader): Either<String, Int> =\n    reader.eitherReadLine().flatMap { doubleString(it) }\n```", "```java\npublic class CustomerRegistrationHandler {\n\n    private final IRegisterCustomers registration;\n    private final ObjectMapper objectMapper = new ObjectMapper();\n\n    public CustomerRegistrationHandler(IRegisterCustomers registration) {\n        this.registration = registration;\n    }\n\n    public Response handle(Request request) {\n        try {\n            RegistrationData data = objectMapper.readValue(\n                request.getBody(),\n                RegistrationData.class\n            );\n            Customer customer = registration.register(data);\n            return new Response(HTTP_CREATED,\n                objectMapper.writeValueAsString(customer)\n            );\n        } catch (JsonProcessingException x) {\n            return new Response(HTTP_BAD_REQUEST);\n        } catch (ExcludedException x) {\n            return new Response(HTTP_FORBIDDEN);\n        } catch (DuplicateException x) {\n            return new Response(HTTP_CONFLICT);\n        } catch (Exception x) {\n            return new Response(HTTP_INTERNAL_ERROR);\n        }\n    }\n}\n```", "```java\npublic class CustomerRegistration implements IRegisterCustomers {\n\n    private final ExclusionList exclusionList;\n    private final Customers customers;\n\n    public CustomerRegistration(\n        Customers customers,\n        ExclusionList exclusionList\n    ) {\n        this.exclusionList = exclusionList;\n        this.customers = customers;\n    }\n\n    public Customer register(RegistrationData data)\n        throws ExcludedException, DuplicateException {\n        if (exclusionList.exclude(data)) {\n            throw new ExcludedException();\n        } else {\n            return customers.add(data.name, data.email);\n        }\n    }\n}\n```", "```java\npublic interface Customers {\n\n    Customer add(String name, String email) throws DuplicateException;\n\n    Optional<Customer> find(String id);\n}\n```", "```java\ndata class Customer(\n    val id: String,\n    val name: String,\n    val email: String\n)\n```", "```java\ninterface Customers {\n\n    @Throws(DuplicateException::class) ![1](assets/1.png)\n    fun add(name: String, email: String): Customer\n\n    fun find(id: String): Optional<Customer>\n}\n```", "```java\ninterface Customers {\n\n    @Throws(DuplicateException::class)\n    fun add(name: String, email: String): Customer\n\n    fun addToo(name:String, email:String)\n        : Result<Customer, DuplicateException> =\n        try {\n            Success(add(name, email))\n        } catch (x: DuplicateException) {\n            Failure(x)\n        }\n\n    fun find(id: String): Optional<Customer>\n}\n```", "```java\npublic class CustomerRegistration implements IRegisterCustomers {\n\n    private final ExclusionList exclusionList;\n    private final Customers customers;\n\n    public CustomerRegistration(\n        Customers customers,\n        ExclusionList exclusionList\n    ) {\n        this.exclusionList = exclusionList;\n        this.customers = customers;\n    }\n\n    public Customer register(RegistrationData data)\n        throws ExcludedException, DuplicateException {\n        if (exclusionList.exclude(data)) {\n            throw new ExcludedException();\n        } else {\n            return customers.add(data.name, data.email);\n        }\n    }\n}\n```", "```java\nclass CustomerRegistration(\n    private val customers: Customers,\n    private val exclusionList: ExclusionList\n) : IRegisterCustomers {\n\n    @Throws(ExcludedException::class, DuplicateException::class)\n    override fun register(data: RegistrationData): Customer {\n        return if (exclusionList.exclude(data)) {\n            throw ExcludedException()\n        } else {\n            customers.add(data.name, data.email)\n        }\n    }\n\n}\n```", "```java\n@Throws(ExcludedException::class, DuplicateException::class)\noverride fun register(data: RegistrationData): Customer {\n    return if (exclusionList.exclude(data)) {\n        throw ExcludedException()\n    } else {\n        val result = customers.add(data.name, data.email)\n        result\n    }\n}\n```", "```java\n@Throws(ExcludedException::class, DuplicateException::class)\noverride fun register(data: RegistrationData): Customer {\n    return if (exclusionList.exclude(data)) {\n        throw ExcludedException()\n    } else {\n        val result: Result<Customer, DuplicateException> =\n            customers.addToo(data.name, data.email)\n        result ![1](assets/1.png)\n    }\n}\n```", "```java\n@Throws(ExcludedException::class, DuplicateException::class)\noverride fun register(data: RegistrationData): Customer {\n    return if (exclusionList.exclude(data)) {\n        throw ExcludedException()\n    } else {\n        val result: Result<Customer, DuplicateException> =\n            customers.addToo(data.name, data.email)\n        when (result) {\n            is Success<Customer> ->\n                result.value\n            is Failure<DuplicateException> ->\n                throw result.reason\n        }\n    }\n}\n```", "```java\n@Throws(ExcludedException::class, DuplicateException::class)\noverride fun register(data: RegistrationData): Customer {\n    return if (exclusionList.exclude(data)) {\n        throw ExcludedException()\n    } else {\n        val result: Result<Customer, DuplicateException> =\n            customers.addToo(data.name, data.email)\n        result.orThrow()\n    }\n}\n```", "```java\n@Throws(ExcludedException::class, DuplicateException::class)\noverride fun register(data: RegistrationData): Customer {\n    return if (exclusionList.exclude(data)) {\n        throw ExcludedException()\n    } else {\n        customers.addToo(data.name, data.email).orThrow()\n    }\n}\n```", "```java\n@Throws(ExcludedException::class, DuplicateException::class)\noverride fun register(data: RegistrationData): Customer {\n    when {\n        exclusionList.exclude(data) -> throw ExcludedException()\n        else -> return customers.addToo(data.name, data.email).orThrow()\n    }\n}\n```", "```java\npublic class InMemoryCustomers implements Customers {\n\n    private final List<Customer> list = new ArrayList<>();\n    private int id = 0;\n\n    @Override\n    public Customer add(String name, String email) throws DuplicateException {\n        if (list.stream().anyMatch( item -> item.getEmail().equals(email)))\n            throw new DuplicateException(\n                \"customer with email \" + email + \" already exists\"\n            );\n        int newId = id++;\n        Customer result = new Customer(Integer.toString(newId), name, email);\n        list.add(result);\n        return result;\n    }\n\n    @Override\n    public Optional<Customer> find(String id) {\n        return list.stream()\n            .filter(customer -> customer.getId().equals(id))\n            .findFirst();\n    }\n\n    // for test\n    public void add(Customer customer) {\n        list.add(customer);\n    }\n\n    public int size() {\n        return list.size();\n    }\n}\n```", "```java\n@SuppressWarnings(\"unchecked\")\n@Override\npublic Result<Customer, DuplicateException> addToo(\n    String name, String email\n) {\n    if (list.stream().anyMatch( item -> item.getEmail().equals(email)))\n        return new Failure<>(\n            new DuplicateException(\n                \"customer with email \" + email + \" already exists\"\n            )\n        );\n    int newId = id++;\n    Customer result = new Customer(Integer.toString(newId), name, email);\n    list.add(result);\n    return new Success<Customer>(result);\n}\n```", "```java\ninterface Customers {\n\n    fun add(name:String, email:String): Result<Customer, DuplicateException>\n\n    fun find(id: String): Optional<Customer>\n}\n```", "```java\nclass CustomerRegistration(\n    private val customers: Customers,\n    private val exclusionList: ExclusionList\n) : IRegisterCustomers {\n\n    @Throws(ExcludedException::class, DuplicateException::class)\n    override fun register(data: RegistrationData): Customer {\n        when {\n            exclusionList.exclude(data) -> throw ExcludedException()\n            else -> return customers.add(data.name, data.email).orThrow()\n        }\n    }\n}\n```", "```java\nclass InMemoryCustomers : Customers {\n\n    private val list: MutableList<Customer> = ArrayList()\n    private var id = 0\n\n    override fun add(name: String, email: String)\n        : Result<Customer, DuplicateException> =\n        when {\n            list.any { it.email == email } -> Failure(\n                DuplicateException(\n                    \"customer with email $email already exists\"\n                )\n            )\n            else -> {\n                val result = Customer(id++.toString(), name, email)\n                list.add(result)\n                Success(result)\n            }\n        }\n\n    override fun find(id: String): Optional<Customer> =\n        list.firstOrNull { it.id == id }.toOptional()\n\n    // for test\n    fun add(customer: Customer) {\n        list.add(customer)\n    }\n\n    fun size(): Int = list.size\n}\n```", "```java\ninterface Customers {\n\n    fun add(name:String, email:String): Result<Customer, DuplicateException>\n\n    fun find(id: String): Optional<Customer>\n}\n```", "```java\npublic interface IRegisterCustomers {\n    Customer register(RegistrationData data)\n        throws ExcludedException, DuplicateException;\n}\n```", "```java\nclass CustomerRegistration(\n    private val customers: Customers,\n    private val exclusionList: ExclusionList\n) : IRegisterCustomers {\n\n    @Throws(ExcludedException::class, DuplicateException::class)\n    override fun register(data: RegistrationData): Customer {\n        when {\n            exclusionList.exclude(data) -> throw ExcludedException()\n            else -> return customers.add(data.name, data.email).orThrow()\n        }\n    }\n}\n```", "```java\nsealed class RegistrationProblem\n\nobject Excluded : RegistrationProblem()\n\ndata class Duplicate(\n    val message: String?\n) : RegistrationProblem()\n```", "```java\ninterface IRegisterCustomers {\n\n    @Throws(ExcludedException::class, DuplicateException::class)\n    fun register(data: RegistrationData): Customer\n\n    fun registerToo(data: RegistrationData):\n        Result<Customer, RegistrationProblem> =\n        try {\n            Success(register(data))\n        } catch (x: ExcludedException) {\n            Failure(Excluded)\n        } catch (x: DuplicateException) {\n            Failure(Duplicate(x.message))\n        }\n}\n```", "```java\nclass CustomerRegistrationHandler(\n    private val registration: IRegisterCustomers\n) {\n    private val objectMapper = ObjectMapper()\n\n    fun handle(request: Request): Response {\n        return try {\n            val data = objectMapper.readValue(\n                request.body,\n                RegistrationData::class.java\n            )\n            val customer = registration.register(data)\n            Response(\n                HTTP_CREATED,\n                objectMapper.writeValueAsString(customer)\n            )\n        } catch (x: JsonProcessingException) {\n            Response(HTTP_BAD_REQUEST)\n        } catch (x: ExcludedException) {\n            Response(HTTP_FORBIDDEN)\n        } catch (x: DuplicateException) {\n            Response(HTTP_CONFLICT)\n        } catch (x: Exception) {\n            Response(HTTP_INTERNAL_ERROR)\n        }\n    }\n}\n```", "```java\nclass CustomerRegistrationHandler(\n    private val registration: IRegisterCustomers\n) {\n    private val objectMapper = ObjectMapper()\n\n    fun handle(request: Request): Response {\n        return try {\n            val data = objectMapper.readValue(\n                request.body,\n                RegistrationData::class.java\n            )\n            val customerResult = registration.registerToo(data)\n            when (customerResult) {\n                is Success -> Response(\n                    HTTP_CREATED,\n                    objectMapper.writeValueAsString(customerResult.value)\n                )\n                is Failure -> customerResult.reason.toResponse()\n\n            }\n        } catch (x: JsonProcessingException) {\n            Response(HTTP_BAD_REQUEST)\n        } catch (x: ExcludedException) {\n            Response(HTTP_FORBIDDEN)\n        } catch (x: DuplicateException) {\n            Response(HTTP_CONFLICT)\n        } catch (x: Exception) {\n            Response(HTTP_INTERNAL_ERROR)\n        }\n    }\n}\n\nprivate fun RegistrationProblem.toResponse() = when (this) {\n    is Duplicate -> Response(HTTP_CONFLICT)\n    is Excluded -> Response(HTTP_FORBIDDEN)\n}\n```", "```java\nfun handle(request: Request): Response =\n    try {\n        val data = objectMapper.readValue(\n            request.body,\n            RegistrationData::class.java\n        )\n        registration.registerToo(data)\n            .map { value ->\n                Response(\n                    HTTP_CREATED,\n                    objectMapper.writeValueAsString(value)\n                )\n            }\n            .recover { reason -> reason.toResponse() }\n    } catch (x: JsonProcessingException) {\n        Response(HTTP_BAD_REQUEST)\n    } catch (x: Exception) {\n        Response(HTTP_INTERNAL_ERROR)\n    }\n```", "```java\npublic class CustomerRegistrationHandlerTests {\n\n    final IRegisterCustomers registration =\n        mock(IRegisterCustomers.class);\n    final CustomerRegistrationHandler handler =\n        new CustomerRegistrationHandler(registration);\n\n    final String fredBody = toJson(\n        \"{ 'name' : 'fred', 'email' : 'fred@bedrock.com' }\"\n    );\n    final RegistrationData fredData =\n        new RegistrationData(\"fred\", \"fred@bedrock.com\");\n\n    @Test\n    public void returns_Created_with_body_on_success()\n        throws DuplicateException, ExcludedException {\n        when(registration.register(fredData))\n            .thenReturn(\n                new Customer(\"0\", fredData.name, fredData.email)\n            );\n\n        String expectedBody = toJson(\n            \"{'id':'0','name':'fred','email':'fred@bedrock.com'}\"\n        );\n        assertEquals(\n            new Response(HTTP_CREATED, expectedBody),\n            handler.handle(new Request(fredBody))\n        );\n    }\n\n    @Test\n    public void returns_Conflict_for_duplicate()\n        throws DuplicateException, ExcludedException {\n\n        when(registration.register(fredData))\n            .thenThrow(\n                new DuplicateException(\"deliberate\")\n            );\n\n        assertEquals(\n            new Response(HTTP_CONFLICT),\n            handler.handle(new Request(fredBody))\n        );\n    }\n    ...\n\n    private String toJson(String jsonIsh) {\n        return jsonIsh.replace('\\'', '\"');\n    }\n}\n```", "```java\n@Test\npublic void returns_Created_with_body_on_success() {\n\n    when(registration.registerToo(fredData))\n        .thenReturn(new Success<>(\n            new Customer(\"0\", fredData.name, fredData.email)\n        ));\n\n    String expectedBody = toJson(\n        \"{'id':'0','name':'fred','email':'fred@bedrock.com'}\"\n    );\n    assertEquals(\n        new Response(HTTP_CREATED, expectedBody),\n        handler.handle(new Request(fredBody))\n    );\n}\n\n@Test\npublic void returns_Conflict_for_duplicate() {\n\n    when(registration.registerToo(fredData))\n        .thenReturn(new Failure<>(\n            new Duplicate(\"deliberate\")\n        ));\n\n    assertEquals(\n        new Response(HTTP_CONFLICT),\n        handler.handle(new Request(fredBody))\n    );\n}\n    ...\n```", "```java\nclass CustomerRegistration(\n    private val customers: Customers,\n    private val exclusionList: ExclusionList\n) : IRegisterCustomers {\n\n    @Throws(ExcludedException::class, DuplicateException::class)\n    override fun register(data: RegistrationData): Customer {\n        when {\n            exclusionList.exclude(data) -> throw ExcludedException()\n            else -> return customers.add(data.name, data.email).orThrow()\n        }\n    }\n\n    override fun registerToo(\n        data: RegistrationData\n    ): Result<Customer, RegistrationProblem> {\n        return when {\n            exclusionList.exclude(data) -> Failure(Excluded)\n            else -> customers.add(data.name, data.email)\n                .mapFailure { exception: DuplicateException -> ![1](assets/1.png)\n                    Duplicate(exception.message)\n                }\n        }\n    }\n}\n```", "```java\nclass CustomerRegistration(\n    private val customers: Customers,\n    private val exclusionList: ExclusionList\n) : IRegisterCustomers {\n\n    @Throws(ExcludedException::class, DuplicateException::class)\n    override fun register(data: RegistrationData): Customer =\n        registerToo(data).recover { error ->  ![1](assets/1.png)\n            when (error) {\n                is Excluded -> throw ExcludedException()\n                is Duplicate -> throw DuplicateException(error.message)\n        }\n    }\n\n    override fun registerToo(\n        data: RegistrationData\n    ): Result<Customer, RegistrationProblem> {\n        return when {\n            exclusionList.exclude(data) -> Failure(Excluded)\n            else -> customers.add(data.name, data.email)\n                .mapFailure { exception: DuplicateException ->\n                    Duplicate(exception.message)\n                }\n        }\n    }\n}\n```", "```java\npublic class CustomerRegistrationTests {\n\n    InMemoryCustomers customers = new InMemoryCustomers();\n    Set<String> excluded = Set.of(\n        \"cruella@hellhall.co.uk\"\n    );\n    CustomerRegistration registration = new CustomerRegistration(customers,\n        (registrationData) -> excluded.contains(registrationData.email)\n    );\n\n    @Test\n    public void adds_a_customer_when_not_excluded()\n        throws DuplicateException, ExcludedException {\n        assertEquals(Optional.empty(), customers.find(\"0\"));\n\n        Customer added = registration.register(\n            new RegistrationData(\"fred flintstone\", \"fred@bedrock.com\")\n        );\n        assertEquals(\n            new Customer(\"0\", \"fred flintstone\", \"fred@bedrock.com\"),\n            added\n        );\n        assertEquals(added, customers.find(\"0\").orElseThrow());\n    }\n\n    @Test\n    public void throws_DuplicateException_when_email_address_exists() {\n        customers.add(new Customer(\"0\", \"fred flintstone\", \"fred@bedrock.com\"));\n        assertEquals(1, customers.size());\n\n        assertThrows(DuplicateException.class,\n            () -> registration.register(\n                new RegistrationData(\"another name\", \"fred@bedrock.com\")\n            )\n        );\n        assertEquals(1, customers.size());\n    }\n\n    ...\n}\n```", "```java\n@Test\nfun `adds a customer when not excluded`() {\n    assertEquals(Optional.empty<Any>(), customers.find(\"0\"))\n    val added = registration.registerToo(\n        RegistrationData(\"fred flintstone\", \"fred@bedrock.com\")\n    ).valueOrNull()\n    assertEquals(\n        Customer(\"0\", \"fred flintstone\", \"fred@bedrock.com\"),\n        added\n    )\n    assertEquals(added, customers.find(\"0\").orElseThrow())\n}\n\n@Test\nfun `returns Duplicate when email address exists`() {\n    customers.add(Customer(\"0\", \"fred flintstone\", \"fred@bedrock.com\"))\n    assertEquals(1, customers.size())\n    val failure = registration.registerToo(\n        RegistrationData(\"another name\", \"fred@bedrock.com\")\n    ).failureOrNull()\n    assertEquals(\n        Duplicate(\"customer with email fred@bedrock.com already exists\"),\n        failure\n    )\n    assertEquals(1, customers.size())\n}\n\n    ...\n```", "```java\ninterface IRegisterCustomers {\n    fun register(data: RegistrationData):\n        Result<Customer, RegistrationProblem>\n}\n\nsealed class RegistrationProblem\n\nobject Excluded : RegistrationProblem()\n\ndata class Duplicate(\n    val message: String?\n) : RegistrationProblem()\n```", "```java\ninterface Customers {\n\n    fun add(name:String, email:String): Result<Customer, DuplicateException>\n\n    fun find(id: String): Optional<Customer>\n}\n```", "```java\ninterface Customers {\n\n    fun add(name:String, email:String): Result<Customer, CustomersProblem>\n\n    fun find(id: String): Optional<Customer>\n}\n\nsealed class CustomersProblem\n\ndata class DuplicateCustomerProblem(val message: String): CustomersProblem()\n\ndata class DatabaseCustomerProblem(val message: String): CustomersProblem()\n```", "```java\nclass CustomerRegistration(\n    private val customers: Customers,\n    private val exclusionList: ExclusionList\n) : IRegisterCustomers {\n\n    override fun register(\n        data: RegistrationData\n    ): Result<Customer, RegistrationProblem> {\n        return when {\n            exclusionList.exclude(data) -> Failure(Excluded)\n            else -> customers.add(data.name, data.email)\n                .mapFailure { duplicate: DuplicateCustomerProblem ->\n                    Duplicate(duplicate.message)\n                }\n        }\n    }\n}\n```", "```java\nsealed class RegistrationProblem\n\nobject Excluded : RegistrationProblem()\n\ndata class Duplicate(val message: String) : RegistrationProblem()\n\ndata class DatabaseProblem(val message: String) : RegistrationProblem()\n```", "```java\noverride fun register(\n    data: RegistrationData\n): Result<Customer, RegistrationProblem> {\n    return when {\n        exclusionList.exclude(data) -> Failure(Excluded)\n        else -> customers.add(data.name, data.email)\n            .mapFailure { problem: CustomersProblem ->\n                when (problem) {\n                    is DuplicateCustomerProblem ->\n                        Duplicate(problem.message)\n                    is DatabaseCustomerProblem ->\n                        DatabaseProblem(problem.message)\n                }\n            }\n    }\n}\n```", "```java\nprivate fun RegistrationProblem.toResponse() = when (this) {\n    is Duplicate -> Response(HTTP_CONFLICT)\n    is Excluded -> Response(HTTP_FORBIDDEN)\n    is DatabaseProblem -> Response(HTTP_INTERNAL_ERROR) ![1](assets/1.png)\n}\n```"]