- en: Chapter 5\. The Business Rules Engine
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Challenge
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Your business is now doing really well. In fact, you’ve now scaled to an organization
    with thousands of employees. This mean you’ve hired many people for different
    business functions: marketing, sales, operations, admin, accounting, and so on.
    You realize that all the business functions have requirements for creating rules
    that trigger actions depending on some conditions; for example, “notify sales
    team if prospect’s job title is ‘CEO’.” You could be asking your tech team to
    implement each new requirement with bespoke software, but your developers are
    quite busy working on other products. In order to encourage collaboration between
    the business team and the tech team, you’ve decided that you will develop a Business
    Rules Engine that will enable developers and the business team to write code together.
    This will allow you to increase productivity and reduce the time it takes to implement
    new rules because your business team will be able to contribute directly.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: The Goal
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter you’ll first learn about how to approach a new design problem
    using test-driven development. You will get an overview about a technique called
    mocking, which will help specify unit tests. You will then learn about a couple
    of modern features in Java: local variable type inference and switch expressions.
    Finally, you’ll learn how to develop a friendly API using the Builder pattern
    and the Interface Segregation Principle.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-5
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If at any point you want to look at the source code for this chapter, you can
    look at the package `com.iteratrlearning.shu_book.chapter_05` in the book’s code
    repository.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Business Rules Engine Requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before you start, let’s think about what is it you want to achieve. You’d like
    to enable nonprogrammers to add or change business logic in their own workflow.
    For example, a marketing executive may wish to apply a special discount when a
    prospect is making an inquiry about one of your products and fits certain criteria.
    An accounting executive may wish to create an alert if expenses are unusually
    high. These are examples of what you can achieve with a Business Rules Engine.
    It’s essentially software that executes one or more business rules that are often
    declared using a simple bespoke language. A Business Rules Engine can support
    multiple different components:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Facts
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: The available information to which rules have access
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Actions
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: The operation you want to perform
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Conditions
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: These specify when an action should be triggered
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Rules
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: These specify the business logic you want to execute, essentially grouping facts,
    conditions, and actions together
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: The main productivity benefit of a Business Rules Engine is that it enables
    rules to be maintained, executed, and tested within one place without having to
    integrate with a main application.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-18
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: There are many production-ready Java Business Rules Engine such as [Drools](https://www.drools.org).
    Typically such an engine conforms to standards such as the *Decision Model and
    Notation* (DMN) and comes with a centralized rule repository, an editor using
    a *Graphical User Interface* (GUI), and visualization tools to help maintenance
    of complex rules. In this chapter, you will develop a minimal viable product for
    a Business Rules Engine and iterate over it to improve both its functionality
    and accessibility.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多成熟的 Java 业务规则引擎，比如[Drools](https://www.drools.org)。通常这样的引擎符合诸如*决策建模和标记*（DMN）的标准，并配备一个集中的规则库，一个使用*图形用户界面*（GUI）的编辑器和可视化工具，以帮助维护复杂的规则。在本章中，您将开发一个业务规则引擎的最小可行产品，并对其进行迭代，以改进其功能和可访问性。
- en: Test Driven Development
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试驱动开发
- en: 'Where do you start? The requirements are not set in stone and are expected
    to evolve so you begin by simply listing the basic features you will need your
    users to undertake:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 从哪里开始？需求并不是一成不变的，预计会不断演变，因此您开始时只需列出用户需要完成的基本功能即可：
- en: Add an action
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个动作
- en: Run the action
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行动作
- en: Basic reporting
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本报告
- en: This translates in the basic API shown in [Example 5-1](#business_rule_engine_basic_skeleton).
    Each method throws an `UnsupportedOperationException` indicating it is yet to
    be implemented.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这在[示例 5-1](#business_rule_engine_basic_skeleton)中的基本 API 中有所体现。每个方法抛出`UnsupportedOperationException`，表示它尚未实现。
- en: Example 5-1\. Basic API for Business Rules Engine
  id: totrans-26
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-1\. 业务规则引擎的基本 API
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: An action is simply a piece of code that will be executed. We could use the
    `Runnable` interface, but introducing a separate interface `Action` is more representative
    of the domain at hand. The `Action` interface will allow the Business Rules Engine
    to be decoupled from concrete actions. Since the `Action` interface only declares
    a single abstract method, we can annotate it as a functional interface, as shown
    in [Example 5-2](#action_interface).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 动作简单地是将要执行的代码片段。我们可以使用`Runnable`接口，但引入一个单独的接口`Action`更能代表手头的领域。`Action`接口将允许业务规则引擎与具体动作解耦。由于`Action`接口只声明了一个抽象方法，我们可以将其注释为功能接口，如[示例 5-2](#action_interface)所示。
- en: Example 5-2\. The Action interface
  id: totrans-29
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-2\. 动作接口
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Where do we go from here? It’s now time to actually write some code—where is
    the implementation? You will use an approach called *test-driven development*
    (TDD). The TDD philosophy is to start writing some tests that are going to let
    you guide the implementation of the code. In other words, you write tests first
    before the actual implementation. It’s a bit like doing the opposite of what you’ve
    been doing so far: you wrote the full code for a requirement and then tested it.
    You will now focus more on the tests.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来怎么办？现在是时候真正写些代码了——实现在哪里？你将使用一种称为*测试驱动开发*（TDD）的方法。TDD 的哲学是首先编写一些测试，这些测试将指导你编写代码的实现。换句话说，你先写测试，再写实现。这有点像迄今为止你所做的相反：你先为一个需求写了完整的代码，然后测试它。现在你会更多地关注测试。
- en: Why Use TDD?
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么使用 TDD？
- en: 'Why should you take this approach? There are several benefits:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么要采用这种方法？有几个好处：
- en: Writing a test at a time will help you focus and refine the requirements by
    correctly implementing one thing at a time.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逐个编写测试将帮助您专注并完善需求，通过逐个正确实现一件事情来实现。
- en: It’s a way to ensure a relevant organization for your code. For example, by
    writing a test first, you need to think hard about the public interfaces for your
    code.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是确保代码有关联组织的一种方式。例如，通过先写测试，你需要仔细考虑代码的公共接口。
- en: You are building a comprehensive test suite as you iterate through the requirements,
    which increases confidence that you are matching the requirements and also reduces
    the scope of bugs.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着你按需求迭代，构建全面的测试套件，这既增加了你符合需求的信心，也减少了 bug 的范围。
- en: You don’t write code that you don’t need (over-engineer) because you’re just
    writing code that passes the tests.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不会写不需要的代码（过度工程），因为你只是写通过测试的代码。
- en: The TDD Cycle
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TDD 循环
- en: 'The TDD approach roughly consists of the following steps in a cycle, as depicted
    in [Figure 5-1](#test_cycle):'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: TDD 方法大致包括以下循环步骤，如[图 5-1](#test_cycle)所示：
- en: Write a test that fails
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写一个失败的测试
- en: Run all tests
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行所有测试
- en: Make the implementation work
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使实现生效
- en: Run all tests
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行所有测试
- en: '![TDD Cycle](Images/rwsd_0501.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![TDD 循环](Images/rwsd_0501.png)'
- en: Figure 5-1\. TDD cycle
  id: totrans-45
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-1\. TDD 循环
- en: In practice, as part of this process, you must continuously *refactor* your
    code or it will end up unmaintainable. At this moment you know you have a suite
    of tests that you can rely on when you introduce changes. [Figure 5-2](#test_cycle_refactor)
    illustrates this improved TDD process.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，作为这个过程的一部分，你必须持续*重构*你的代码，否则它将变得难以维护。此时，当你引入变更时，你知道你有一套可以依赖的测试套件。[图 5-2](#test_cycle_refactor)展示了这一改进的TDD过程。
- en: '![TDD Cycle with Refactoring](Images/rwsd_0502.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![TDD循环与重构](Images/rwsd_0502.png)'
- en: Figure 5-2\. TDD with refactoring
  id: totrans-48
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-2\. TDD与重构
- en: In the spirit of TDD, let’s start by writing our first tests to verify that
    `addActions` and `count` behave correctly, as shown in [Example 5-3](#business_rule_engine_basic_tests).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在TDD的精神下，让我们首先编写我们的第一个测试来验证`addActions`和`count`的行为是否正确，如[示例 5-3](#business_rule_engine_basic_tests)所示。
- en: Example 5-3\. Basic tests for the Business Rules Engine
  id: totrans-50
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-3\. 业务规则引擎的基本测试
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When running the tests, you will see that they fail with an `UnsupportedOperationException`,
    as shown in [Figure 5-3](#failing_tests).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行测试时，你会看到它们失败，并显示`UnsupportedOperationException`，如[图 5-3](#failing_tests)所示。
- en: '![Failing tests](Images/rwsd_0503.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![失败的测试](Images/rwsd_0503.png)'
- en: Figure 5-3\. Failing tests
  id: totrans-54
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-3\. 失败的测试
- en: All tests are failing, but that’s fine. It gives us a reproducible test suite
    that will guide the implementation of the code. Now can add some implementation
    code, as shown in [Example 5-4](#business_rule_engine_basic_impl).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 所有测试都失败了，但没关系。这给了我们一个可重现的测试套件，将指导代码的实现。现在可以添加一些实现代码，如[示例 5-4](#business_rule_engine_basic_impl)所示。
- en: Example 5-4\. Basic implementation for the Business Rules Engine
  id: totrans-56
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-4\. 业务规则引擎的基本实现
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You can now rerun the tests and they are passing! However, there’s one crucial
    operation missing. How do we write a test for the method run? Unfortunately, `run()`
    does not return any result. We are going to need a new technique called *mocking*
    to verify that the method `run()` operates correctly.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以重新运行测试，它们通过了！但是，还有一个关键操作缺失。我们如何为`run`方法编写测试？不幸的是，`run()`不返回任何结果。我们将需要一种称为*模拟*的新技术，以验证`run()`方法的正确操作。
- en: Mocking
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟
- en: 'Mocking is a technique that will allow you to verify that when the method `run()`
    is executed, each action that was added to the Business Rules Engine is actually
    executed. At the moment it is difficult to do because both the methods `run()`
    in `BusinessRuleEngine` and `perform()` in `Action` are returning `void`. We have
    no way to write an assertion! Mocking is covered in detail in [Chapter 6](ch06.xhtml#chapter_06),
    but you will get a brief overview now so you are able to progress with writing
    a test. You’ll be using Mockito, which is a popular mocking library for Java.
    At its simplest you can do two things:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟是一种技术，它允许你验证当执行`run()`方法时，业务规则引擎中添加的每个动作是否确实被执行。目前很难做到这一点，因为`BusinessRuleEngine`中的`run()`方法和`Action`中的`perform()`方法都返回`void`。我们无法编写断言！模拟在[第6章](ch06.xhtml#chapter_06)中有详细介绍，但现在你将会得到一个简要概述，这样你就能继续编写测试了。你将使用Mockito，这是一个流行的Java模拟库。在其最简单的形式下，你可以做两件事情：
- en: Create a mock.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个模拟对象。
- en: Verify that a method is called.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证方法是否被调用。
- en: 'So how do you get started? You will need to import the library first:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如何开始呢？你需要首先导入这个库：
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This import allows you to use the methods `mock()` and `verify()`. The static
    method `mock()` allows you to create a mock object which you can then verify that
    certain behaviors happen. The method `verify()` allows you to set up assertions
    that a particular method is invoked. [Example 5-5](#mocking_verifying_interaction)
    shows an example.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这个导入允许你使用`mock()`和`verify()`方法。静态方法`mock()`允许你创建一个模拟对象，然后你可以验证某些行为是否发生。方法`verify()`允许你设置断言，即特定方法是否被调用。[示例 5-5](#mocking_verifying_interaction)展示了一个例子。
- en: Example 5-5\. Mocking and verifying interaction with an Action object
  id: totrans-66
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-5\. 模拟并验证与`Action`对象的交互
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The unit test creates a mock object for `Action`. This is done by passing the
    class as argument to the mock method. Next, you have the *when* part of your test
    where you invoke behaviors. Here we are adding the action and executing the method
    `run()`. Finally, you have the *then* part of the unit tests, which sets up assertions.
    In this case, we verify that the method `perform()` on the `Action` object was
    invoked.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试为`Action`创建了一个模拟对象。这通过将类作为参数传递给`mock`方法来实现。接下来是测试的*when*部分，在这里你调用行为。这里我们添加了动作并执行了`run()`方法。最后，单元测试的*then*部分设置了断言。在这种情况下，我们验证了`Action`对象上的`perform()`方法是否被调用。
- en: 'If you run this test it will fail as expected with a `UnsupportedOperationException`.
    What if the body of `run()` is empty? You will receive a new exception trace:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这个测试，正如预期的那样会失败，并显示 `UnsupportedOperationException`。如果 `run()` 方法体为空会发生什么？你将收到新的异常跟踪：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This error is coming from Mockito and tells you that the method `perform()`
    was never invoked. It’s now time to write the correct implementation for the method
    `run()`, as shown in [Example 5-6](#run_method_basic_impl).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误来自 Mockito，并告诉你 `perform()` 方法从未被调用。现在是时候为 `run()` 方法编写正确的实现了，如 [示例 5-6](#run_method_basic_impl)
    所示。
- en: Example 5-6\. The run() method implementation
  id: totrans-72
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-6\. `run()` 方法的实现
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Re-run the tests and you will now see the test passing. Mockito was able to
    verify that when the Business Rules Engine is running, the method `perform()`
    on the `Action` object should be invoked. Mockito allows you to specify sophisticated
    verification logic such as how many times a method should be invoked, with certain
    arguments, etc. You will learn more about this in [Chapter 6](ch06.xhtml#chapter_06).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 重新运行测试，你会看到测试通过了。Mockito 能够验证当业务规则引擎运行时，`Action` 对象的 `perform()` 方法是否被调用。Mockito
    允许你指定复杂的验证逻辑，比如方法应该被调用多少次，带有特定参数等。你将在 [第 6 章](ch06.xhtml#chapter_06) 中了解更多相关信息。
- en: Adding Conditions
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加条件
- en: You have to admit that so far the Business Rules Engine is pretty limiting.
    You can only declare simple actions. However, in practice, the users of the Business
    Rules Engine will need to execute actions based on certain conditions. These conditions
    will be dependent on some facts. For example, notify the sales team *only if the
    prospect’s job title is CEO*.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须承认，到目前为止，业务规则引擎的功能相当有限。你只能声明简单的动作。然而，在实践中，业务规则引擎的使用者需要根据某些条件执行动作。这些条件将依赖于一些事实。例如，仅当潜在客户的职位是
    CEO 时，通知销售团队。
- en: Modeling State
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 建模状态
- en: You may start by writing code that adds an action and refers to a local variable
    using an anonymous class as shown in [Example 5-7](#anonm_add_action), or using
    a lambda expression as shown in [Example 5-8](#lambda_add_action).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以先编写代码，添加一个动作，并使用匿名类引用本地变量，如 [示例 5-7](#anonm_add_action) 所示，或者使用 lambda 表达式，如
    [示例 5-8](#lambda_add_action) 所示。
- en: Example 5-7\. Adding an action using an anonymous class
  id: totrans-79
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-7\. 使用匿名类添加一个动作
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Example 5-8\. Adding an action using a lambda expression
  id: totrans-81
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-8\. 使用 lambda 表达式添加一个动作
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'However, this approach is inconvenient for several reasons:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，出于几个原因，这种方法并不方便：
- en: How do you test the action? It’s not an independent piece of functionality;
    it has a hardcoded dependency on the customer object.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何测试这个动作？它不是一个独立的功能模块；它对 `customer` 对象有硬编码的依赖。
- en: The customer object is not grouped with the action. It is a sort of external
    state that is shared around, leading to a confusing mix of responsibilities.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`customer` 对象没有与动作分组。它是一种外部状态，被共享使用，导致责任混淆。'
- en: So what do we need? We need to encapsulate the state that is available to actions
    within the Business Rules Engine. Let’s model these requirements by introducing
    a new class called `Facts`, which will represent the state available as part of
    the Business Rules Engine, and an updated `Action` interface that can operate
    on facts. An updated unit test is shown in [Example 5-9](#test_action_facts).
    The unit test checks that when the Business Rules Engine runs, the specified action
    is actually invoked with the `Facts` object passed as an argument.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们需要什么？我们需要封装状态，使其可供业务规则引擎中的动作使用。让我们通过引入一个名为 `Facts` 的新类来建模这些需求，`Facts` 将代表业务规则引擎中可用的状态，并且更新
    `Action` 接口，使其能够操作 `Facts`。一个更新后的单元测试显示在 [示例 5-9](#test_action_facts) 中。该单元测试检查当业务规则引擎运行时，指定的动作是否确实被调用，并且传递了
    `Facts` 对象作为参数。
- en: Example 5-9\. Testing an action with facts
  id: totrans-87
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-9\. 使用事实测试一个动作
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: To follow the TDD philosophy, this test will initially fail. You always need
    to run the tests to begin with to ensure that they fail, otherwise you may write
    a test that accidentally passes. To make the test pass you will need to update
    the API and implementation code. First, you’ll introduce the `Facts` class, which
    allows you to store a fact represented as a key and a value. The benefit of introducing
    a separate `Facts` class for modeling state is that you can control the operations
    available to your users by providing a public API, and also unit test the behavior
    of the class. For the time being, the `Facts` class will only support `String`
    keys and `String` values. The code for the `Facts` class is shown in [Example 5-10](#facts_class).
    We chose the names `getFact` and `addFact` because they better represent the domain
    at hand (working with facts) rather than `getValue` and `setValue`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了遵循 TDD 哲学，此测试最初将失败。您始终需要运行测试以确保它们失败，否则可能会意外通过一个测试。要使测试通过，您需要更新 API 和实现代码。首先，您将引入`Facts`类，它允许您存储以键和值表示的事实。引入一个单独的`Facts`类来建模状态的好处是，您可以通过提供公共
    API 控制用户可用的操作，并对类的行为进行单元测试。目前，`Facts`类仅支持`String`键和`String`值。`Facts`类的代码显示在[示例
    5-10](#facts_class)中。我们选择名称`getFact`和`addFact`，因为它们更好地表示手头的领域（处理事实），而不是`getValue`和`setValue`。
- en: Example 5-10\. The Facts class
  id: totrans-90
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-10\. Facts 类
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You’ll now need to refactor the `Action` interface so that the `perform()` method
    can use a `Facts` object passed as an argument. This way it’s clear the facts
    are available within the context of the single `Action` ([Example 5-11](#action_with_facts)).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您需要重构`Action`接口，以便`perform()`方法可以使用作为参数传递的`Facts`对象。这样一来，清楚地表明了在单个`Action`的上下文中可用的事实（[示例
    5-11](#action_with_facts)）。
- en: Example 5-11\. The Action interface that takes facts
  id: totrans-93
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-11\. 接受事实的行动接口
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Finally, you can now update the `BusinessRuleEngine` class to utilize the facts
    and the updated `Action`’s `perform()` method as shown in [Example 5-12](#business_rule_engine_facts).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您现在可以更新`BusinessRuleEngine`类，以利用事实和更新的`Action`的`perform()`方法，如[示例 5-12](#business_rule_engine_facts)所示。
- en: Example 5-12\. BusinessRuleEngine with facts
  id: totrans-96
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-12\. 带有事实的 BusinessRuleEngine
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now that the `Facts` object is available to actions, you can specify arbitrary
    logic in your code that looks up the `Facts` object as shown in [Example 5-13](#example_action_with_facts).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`Facts`对象可用于行动，您可以在代码中指定查找`Facts`对象的任意逻辑，如[示例 5-13](#example_action_with_facts)所示。
- en: Example 5-13\. An action utilizing the facts
  id: totrans-99
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-13\. 利用事实的行动
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let’s look at some more examples. This is also a good opportunity to introduce
    two recent features in Java, which we explore in order:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些更多的示例。这也是介绍 Java 中两个最近功能的好机会，我们按顺序探索：
- en: Local variable type inference
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 局部变量类型推断
- en: Switch expressions
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Switch 表达式
- en: Local Variable Type Inference
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 局部变量类型推断
- en: Java 10 introduced variable local type inference. Type inference is the idea
    that the compiler can figure out the static types for you so you don’t have to
    type them. You saw an example of type inference earlier in [Example 5-10](#facts_class)
    when you wrote
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Java 10 引入了局部变量类型推断。类型推断是编译器可以为您确定静态类型，因此您无需输入它们的想法。在[示例 5-10](#facts_class)中，您在之前看到了类型推断的示例，当您编写时
- en: '[PRE15]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: instead of
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This is a feature that was introduced in Java 7 called the *diamond operator*.
    Essentially, you can omit the type parameters of generics (in this case `String,
    String`) in an expression when its context determines them. In the preceding code,
    the lefthand side of the assignment indicates the keys and values of the `Map`
    should be `String`s.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Java 7 中引入的一个特性，称为 *菱形操作符*。基本上，当其上下文确定类型参数（在本例中为 `String, String`）时，您可以省略泛型的类型参数。在前面的代码中，赋值的左侧指示`Map`的键和值应为
    `String`。
- en: Since Java 10, type inference has been extended to work on local variables.
    For example, the code in [Example 5-14](#local_variable_declarations) can be rewritten
    using the `var` keyword and local variable type inference shown in [Example 5-15](#local_variable_type_inference).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 自 Java 10 起，类型推断已扩展到局部变量上。例如，[示例 5-14](#local_variable_declarations)中的代码可以使用`var`关键字和局部变量类型推断进行重写，如[示例
    5-15](#local_variable_type_inference)所示。
- en: Example 5-14\. Local variable declaration with explicit types
  id: totrans-111
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-14\. 显式类型声明的局部变量声明
- en: '[PRE17]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Example 5-15\. Local variable type inference
  id: totrans-113
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-15\. 局部变量类型推断
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: By using the `var` keyword in the code shown in [Example 5-15](#local_variable_type_inference),
    the variable `env` still has a static type `Facts` and the variable `businessRuleEngine`
    still has the static type `BusinessRuleEngine`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在[Example 5-15](#local_variable_type_inference)中显示的代码中使用`var`关键字，变量`env`仍具有静态类型`Facts`，变量`businessRuleEngine`仍具有静态类型`BusinessRuleEngine`。
- en: Note
  id: totrans-116
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'A variable declared using the `var` keyword is not made `final`. For example,
    this code:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`var`关键字声明的变量不是`final`。例如，以下代码：
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'is not strictly equivalent to:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 不严格等同于：
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You can still assign another value to the variable `env` after declaring it
    using `var`. You’d have to explicitly add the `final` keyword as follows in front
    of the variable `env` for it to be final:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`var`声明后，仍然可以为变量`env`分配另一个值。您必须在变量`env`前显式添加`final`关键字，如下所示：
- en: '[PRE21]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the rest of the chapters, we simply use the `var` keyword without `final`
    for brevity as it is in the spirit of code conciseness. When we explicitly declare
    the type of a variable, we use the `final` keyword.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在其余章节中，出于简洁性考虑，我们简单使用`var`关键字，不使用`final`。当我们显式声明变量类型时，我们使用`final`关键字。
- en: Type inference helps reduce the amount of time taken to write Java code. However,
    should you use this feature all the time? It’s worth remembering that developers
    spend more time reading code than writing it. In other words, you should think
    about optimizing for ease of reading over ease of writing. The extent to which
    `var` improves this will always be subjective. You should always be focusing on
    what helps your teammates read your code, so if they are happy reading code with
    `var` then you should use it, otherwise not. For example, here we can refactor
    the code in [Example 5-13](#example_action_with_facts) to use local variable type
    inference to tidy up the code as shown in [Example 5-16](#example_action_with_facts_var).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 类型推断有助于减少编写Java代码所需的时间。然而，您应该始终使用这个特性吗？值得记住的是，开发人员花费的时间更多是在阅读代码而不是编写代码。换句话说，您应该考虑优化阅读的便利性而不是编写的便利性。`var`改善这一点的程度总是主观的。您应该始终专注于帮助您的团队成员阅读您的代码，因此，如果他们乐意使用`var`阅读代码，那么您应该使用它，否则不要使用。例如，我们可以重构[Example 5-13](#example_action_with_facts)中的代码，使用本地变量类型推断来整理代码，如[Example 5-16](#example_action_with_facts_var)所示。
- en: Example 5-16\. An action utilizing the facts and local variable type inference
  id: totrans-125
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 5-16\. 使用事实和本地变量类型推断的操作
- en: '[PRE22]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Switch Expressions
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Switch表达式
- en: So far you’ve only set up actions with exactly one condition to handle. This
    is pretty limiting. For example, say you work with your sales team. They may record
    on their *Customer Relationship Management* (CRM) system different deals with
    different amounts that have different stages. A deal stage may be represented
    as an enum `Stage` with values including `LEAD`, `INTERESTED`, `EVALUATING`, `CLOSED`,
    as shown in [Example 5-17](#enum_stages).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您只设置了处理一个条件的操作。这相当受限制。例如，假设您与销售团队合作。他们可能在他们的*客户关系管理*（CRM）系统中记录具有不同金额和不同阶段的不同交易。交易阶段可以表示为枚举`Stage`，其值包括`LEAD`、`INTERESTED`、`EVALUATING`、`CLOSED`，如[Example 5-17](#enum_stages)所示。
- en: Example 5-17\. Enum representing different deal stages
  id: totrans-129
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 5-17\. 枚举表示不同的交易阶段
- en: '[PRE23]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Depending on the stage of the deal you can assign a rule that gives you the
    probability of winning the deal. Consequently, you can help the sales team with
    generating a forecast. Say for a particular team, `LEAD` has 20% probability to
    convert, then a deal at stage `LEAD` with amount of 1000USD will have a forecasted
    amount of 200USD. Let’s create an action to model these rules and return a forecasted
    amount for a particular deal as shown in [Example 5-18](#deal_stages_if).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 根据交易阶段，您可以分配一个规则，给出您赢得交易的概率。因此，您可以帮助销售团队生成预测。例如，对于特定团队，`LEAD` 阶段的转化概率为20%，那么一个金额为1000美元的`LEAD`阶段的交易将有一个预测金额为200美元。让我们创建一个操作来建模这些规则，并返回一个特定交易的预测金额，如[Example 5-18](#deal_stages_if)所示。
- en: Example 5-18\. A rule to calculate a forecast amount for a specific deal
  id: totrans-132
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 5-18\. 计算特定交易预测金额的规则
- en: '[PRE24]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The code shown in [Example 5-18](#deal_stages_if) is essentially providing a
    value for each enum value available. A preferred language construct is the `switch`
    statement as it’s more succinct. This is shown in [Example 5-19](#deal_stages_switch_statement).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '[Example 5-18](#deal_stages_if)中显示的代码基本上为每个枚举值提供一个值。更优选的语言构造是`switch`语句，因为它更简洁。这在[Example 5-19](#deal_stages_switch_statement)中展示。'
- en: Example 5-19\. A rule to calculate a forecast amount for a specific deal using
    a switch statement
  id: totrans-135
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-19\. 使用`switch`语句计算特定交易预测金额的规则
- en: '[PRE25]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note all the `break` statements in the code in [Example 5-19](#deal_stages_switch_statement).
    The `break` statement ensures that the next block in the `switch` statement is
    not executed. If you forget the `break` by accident, then the code still compiles
    and you get what’s called a *fall-through* behavior. In other words, the next
    block is executed and this can lead to subtle bugs. Since Java 12 (using the language
    feature preview mode) you can rewrite this to avoid the fall-through behavior
    and multiple breaks by using a different syntax for `switch`. `switch` can now
    be used as an expression, as illustrated in [Example 5-20](#deal_stages_switch_statement_no_fall_through).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 注意[示例 5-19](#deal_stages_switch_statement)中代码中的所有`break`语句。`break`语句确保不执行`switch`语句中的下一个块。如果您不小心忘记了`break`，则代码仍然会编译，并且会出现所谓的*穿透*行为。换句话说，将执行下一个块，这可能导致微妙的错误。自Java
    12起（使用语言功能预览模式），您可以通过使用不同的语法来重写此以避免穿透行为和多个`break`，来使用`switch`作为表达式，如[示例 5-20](#deal_stages_switch_statement_no_fall_through)所示。
- en: Example 5-20\. Switch expression with no fall-through behavior
  id: totrans-138
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-20\. 没有穿透行为的`switch`表达式
- en: '[PRE26]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Another benefit of this enhanced switch form, besides increased readability,
    is *exhaustiveness*. This means that when you use `switch` with an enum, the Java
    compiler checks that for all enum values there’s a corresponding switch label.
    For example, if you forget to handle the `CLOSED` case, the Java compiler would
    produce the following error:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 除了增加的可读性外，这种增强的`switch`形式还有一个好处是*穷尽性*。这意味着当您使用`switch`与枚举时，Java编译器会检查所有枚举值是否有对应的`switch`标签。例如，如果您忘记处理`CLOSED`情况，Java编译器将产生以下错误：
- en: '[PRE27]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: You can rewrite the overall action using a `switch` expression as shown in [Example 5-21](#deal_stages_switch_refactored).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 可以像在[示例 5-21](#deal_stages_switch_refactored)中展示的那样，使用`switch`表达式重新编写整体操作。
- en: Example 5-21\. A rule to calculate a forecast amount for a specific deal
  id: totrans-143
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-21\. 用于计算特定交易预测金额的规则
- en: '[PRE28]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Interface Segregation Principle
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口隔离原则
- en: We would now like to develop an *inspector tool* that allows users of the Business
    Rules Engine to inspect the status of possible actions and conditions. For example,
    we would like to evaluate each action and associated condition in order to log
    them without actually performing the action. How do we go about this? The current
    `Action` interface is not sufficient because it doesn’t separate the code performed
    versus the condition that triggers that code. At the moment there’s no way to
    separate out the condition from the action code. To make up for this, we could
    introduce an enhanced `Action` interface that has a built-in functionality for
    evaluating the condition. For example, we could create an interface `ConditionalAction`
    that includes a new method `evaluate()` as shown in [Example 5-22](#isp_violation_business_rule_engine).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们想开发一个*检查工具*，允许业务规则引擎的用户检查可能的动作和条件的状态。例如，我们希望评估每个动作和相关条件，以便记录它们而不实际执行动作。我们该如何做呢？当前的`Action`接口不够用，因为它没有区分执行的代码与触发该代码的条件。目前没有办法将条件与动作代码分开。为了弥补这一点，我们可以引入一个增强的`Action`接口，其中内置了评估条件的功能。例如，我们可以创建一个名为`ConditionalAction`的接口，其中包括一个新方法`evaluate()`，如[示例 5-22](#isp_violation_business_rule_engine)所示。
- en: Example 5-22\. ConditionalAction interface
  id: totrans-147
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-22\. ConditionalAction接口
- en: '[PRE29]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We can now implement a basic `Inspector` class that takes a list of `ConditionalAction`
    objects and evaluates them based on some facts, as shown in [Example 5-23](#inspector_conditions).
    The `Inspector` returns a list of reports that captures the facts, the conditional
    action, and the result. The implementation for the `Report` class is shown in
    [Example 5-24](#report_class).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以实现一个基本的`Inspector`类，它接受一组`ConditionalAction`对象并根据某些事实对它们进行评估，如[示例 5-23](#inspector_conditions)所示。`Inspector`返回一个报告列表，其中包含事实、条件动作和结果。`Report`类的实现如[示例 5-24](#report_class)所示。
- en: Example 5-23\. An Inspector of conditions
  id: totrans-150
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-23\. 条件检查器
- en: '[PRE30]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Example 5-24\. The Report class
  id: totrans-152
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-24\. 报告类
- en: '[PRE31]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: How would we go about testing the `Inspector`? You may start by writing a simple
    unit test as shown in [Example 5-25](#inspector_test). This test highlights a
    fundamental issue with our current design. In fact, the `ConditionalAction` interface
    breaks the *Interface Segregation Principle* (ISP).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何测试`Inspector`？您可以通过编写一个简单的单元测试开始，如[示例 5-25](#inspector_test)所示。这个测试突显了我们当前设计的一个基本问题。事实上，`ConditionalAction`接口违反了*接口隔离原则*（ISP）。
- en: Example 5-25\. Highlighting ISP violation
  id: totrans-155
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-25\. 强调 ISP 违规
- en: '[PRE32]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: What is the Interface Segregation Principle? You may notice that the implementation
    of the `perform` method is empty. In fact, it throws an `UnsupportedOperationException`.
    This is a situation where you are coupled to an interface (`ConditionalAction`)
    that provides more than what you need. In this case, we just want a way to model
    a condition—something that evaluates to either true or false. Nonetheless, we
    are forced to depend on the `perform()` method because it is part of the interface.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是接口隔离原则？您可能注意到`perform`方法的实现是空的。事实上，它抛出了一个`UnsupportedOperationException`异常。这是一个情况，您依赖于一个接口（`ConditionalAction`），它提供了比您实际需要的更多内容。在这种情况下，我们只是想要建模一个条件——一个求值为真或假的东西。尽管如此，我们还是被迫依赖于`perform()`方法，因为它是接口的一部分。
- en: This general idea is the foundation of the Interface Segregation Principle.
    It makes the case that no class should be forced to depend on methods it does
    not use because this introduces unnecessary coupling. In [Chapter 2](ch02.xhtml#chapter_02),
    you learned about another principle, the *Single Responsibility Principle* (SRP),
    which promotes high cohesion. The SRP is a general design guideline that a class
    has responsibility over a single functionality and there should be only one reason
    for it to change. Although the ISP may sound like the same idea, it takes a different
    view. The ISP focuses on the user of an interface rather than its design. In other
    words, if an interface ends up very large, it may be that the user of that interface
    sees some behaviors it doesn’t care for, which causes unnecessary coupling.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这个通用想法是接口隔离原则的基础。它主张，任何类都不应该被迫依赖它不使用的方法，因为这会引入不必要的耦合。在[第二章](ch02.xhtml#chapter_02)中，您学习了另一个原则，即*单一责任原则*（SRP），它促进了高内聚性。SRP
    是一个通用的设计指导原则，一个类应该负责一个功能，并且只有一个改变的原因。尽管 ISP 听起来可能像是相同的想法，但它采取了不同的视角。ISP 关注的是接口的使用者而不是其设计。换句话说，如果一个接口最终非常庞大，可能是因为接口的使用者看到了一些它不关心的行为，这会导致不必要的耦合。
- en: To provide a solution that meets the Interface Segregation Principle, we are
    encouraged to separate out concepts in smaller interface that can evolve separately.
    This idea essentially promotes higher cohesion. Separating out interfaces also
    provides an opportunity for introducing names that are closer to the domain at
    hand, such as `Condition` and `Action`, which we explore in the next section.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 为了符合接口隔离原则，我们鼓励将概念分离到更小的接口中，这些接口可以独立演化。这个想法实质上促进了更高的内聚性。分离接口还为引入更接近所需领域的命名提供了机会，比如`Condition`和`Action`，我们将在下一节中探讨这些内容。
- en: Designing a Fluent API
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计流畅的 API
- en: So far we’ve provided a way for our users to add actions with complex conditions.
    These conditions were created using the enhanced switch statement. However, for
    business users the syntax isn’t as friendly as it could be to specify simple conditions.
    We’d like to allow them to add rules (a condition and an action) in a way that
    matches their domain and is simpler to specify. In this section, you will learn
    about the Builder pattern and how to develop your own Fluent API to address this
    problem.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们为用户提供了一种添加具有复杂条件的操作的方式。这些条件是使用增强的开关语句创建的。然而，对于业务用户来说，语法并不像他们希望的那样友好，以指定简单条件。我们希望允许他们以符合其领域并且更简单的方式添加规则（条件和动作）。在本节中，您将了解建造者模式以及如何开发自己的流畅
    API 来解决这个问题。
- en: What Is a Fluent API?
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是流畅 API？
- en: 'A Fluent API is an API that is explicitly tailored for a specific domain so
    that you can solve a specific problem more intuitively. It also embraces the idea
    of chaining method calls to specify a more complex operation. There are several
    high-profile Fluent APIs you may be already familiar with:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 流畅 API 是专门为特定领域量身定制的 API，以便您可以更直观地解决特定问题。它还支持链式方法调用的概念，用于指定更复杂的操作。您可能已经熟悉几个知名的流畅
    API：
- en: The [Java Streams API](https://oreil.ly/549wN) allows you to specify data processing
    queries in a way that reads more like the problem you need to solve.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Java Streams API](https://oreil.ly/549wN) 允许您以更符合解决问题需求的方式指定数据处理查询。'
- en: '[Spring Integration](https://oreil.ly/rMIMD) offers a Java API to specify enterprise
    integration patterns using a vocabulary close to the domain of enterprise integration
    patterns.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Spring Integration](https://oreil.ly/rMIMD) 提供了一个Java API，用于使用与企业集成模式领域接近的词汇指定企业集成模式。'
- en: '[jOOQ](https://www.jooq.org/) offers a library to interact with different databases
    using an intuitive API.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[jOOQ](https://www.jooq.org/) 提供了一个库，使用直观的API与不同的数据库进行交互。'
- en: Modeling the Domain
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 领域建模
- en: 'So what is it that we want to simply for our business users? We’d like to help
    them specify a simple combination of “when some condition holds,” “then do something”
    as a rule. There are three concepts in this domain:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们希望为我们的业务用户简化什么？我们希望帮助他们指定一个简单的“当某个条件成立时”，“然后执行某事”的组合作为规则。在此领域中有三个概念：
- en: Condition
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 条件
- en: A condition applied on certain facts that will evaluate to either true or false.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 应用于某些事实的条件，将评估为真或假。
- en: Action
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 动作
- en: A specific set of operations or code to execute.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 一组特定的操作或要执行的代码。
- en: Rule
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 规则
- en: This is a condition and an action together. The action only runs if the condition
    is true.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个条件和一个动作在一起。只有在条件为真时动作才会执行。
- en: Now that we’ve defined the concepts in the domain, we translate it into Java!
    Let’s first define the `Condition` interface and reuse our existing `Action` interface
    as shown in [Example 5-26](#condition_interface). Note that we could have also
    used the `java.util.function.Predicate` interface available since Java 8, but
    the name `Condition` better represents our domain.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了领域中的概念，我们将其转换为Java！让我们首先定义`Condition`接口，并重用我们现有的`Action`接口，如[示例 5-26](#condition_interface)所示。请注意，我们也可以使用自Java
    8起可用的`java.util.function.Predicate`接口，但是`Condition`名称更能代表我们的领域。
- en: Note
  id: totrans-176
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Names are very important in programming because good names help you understand
    the problem that your code is solving. Names are in many cases more important
    than the “shape” of the interface (in terms of its parameters and return types),
    because the names convey contextual information to humans reading the code.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中名称非常重要，因为良好的名称有助于理解代码解决的问题。在许多情况下，名称比接口的“形状”（其参数和返回类型）更重要，因为名称向阅读代码的人传达上下文信息。
- en: Example 5-26\. The Condition interface
  id: totrans-178
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-26\. Condition接口
- en: '[PRE33]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Now the remaining question is how to model the concept of a rule? We can define
    a interface `Rule` with an operation `perform()`. This will allow you to provide
    different implementations of a `Rule`. A suitable default implementation of this
    interface is a class `DefaultRule`, which will hold a `Condition` and `Action`
    object together with the appropriate logic to perform a rule as shown in [Example 5-27](#modeling_rule).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在剩下的问题是如何建模规则的概念？我们可以定义一个带有`perform()`操作的接口`Rule`。这将允许您提供`Rule`的不同实现。这个接口的一个合适的默认实现是一个名为`DefaultRule`的类，它将与执行规则相关的适当逻辑一起持有`Condition`和`Action`对象，如[示例
    5-27](#modeling_rule)所示。
- en: Example 5-27\. Modeling the concept of a rule
  id: totrans-181
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-27\. 建模规则的概念
- en: '[PRE34]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: How do we create new rules using all these different elements? You can see an
    example in [Example 5-28](#building_a_rule).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何使用所有这些不同的元素创建新规则？您可以在[示例 5-28](#building_a_rule)中看到一个示例。
- en: Example 5-28\. Building a rule
  id: totrans-184
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-28\. 构建一个规则
- en: '[PRE35]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Builder Pattern
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建器模式
- en: However, even though the code uses names that are close to our domain (`Condition`,
    `Action`, `Rule`), this code is fairly manual. The user has to instantiate separate
    objects and assemble things together. Let’s introduce what’s called the *Builder
    pattern* to improve the process of creating a `Rule` object with the appropriate
    condition and action. The purpose of this pattern is to allow the creation of
    an object in a simpler manner. The Builder pattern essentially deconstructs the
    parameters of a constructor and instead provides methods to supply each of the
    parameters. The benefit of this approach is that it allows you to declare methods
    with names that are suitable to the domain at hand. For example, in our case we’d
    like to use the vocabulary `when` and `then`. The code in [Example 5-29](#builder_pattern_declaration_v1)
    shows how to set up the Builder pattern to build a `DefaultRule` object. We’ve
    introduced a method `when()`, which supplies the condition. The method `when()`
    returns `this` (i.e., the current instance), which will allow us to chain up further
    methods. We’ve also introduced a method `then()`, which will supply the action.
    The method `then()` also returns `this`, which allows us to further chain a method.
    Finally, the method `createRule()` is responsible for the creation of the `DefaultRule`
    object.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，即使代码使用了接近我们域的名称（`Condition`、`Action`、`Rule`），这段代码仍然相当手动。用户必须实例化单独的对象并将它们组合在一起。让我们引入所谓的*构建器模式*来改进使用适当条件和操作创建
    `Rule` 对象的过程。这种模式的目的是以更简单的方式创建对象。构建器模式基本上会解构构造函数的参数，并提供方法来提供每个参数。这种方法的好处在于它允许您声明与手头域相适应的方法名称。例如，在我们的案例中，我们想要使用
    `when` 和 `then` 的词汇。示例 5-29 中的代码展示了如何设置构建器模式以构建 `DefaultRule` 对象。我们引入了一个方法 `when()`，它提供了条件。方法
    `when()` 返回 `this`（即当前实例），这将允许我们进一步链接其他方法。我们还引入了一个方法 `then()`，它提供了动作。方法 `then()`
    也返回 `this`，这允许我们进一步链接方法。最后，方法 `createRule()` 负责创建 `DefaultRule` 对象。
- en: Example 5-29\. Builder pattern for a Rule
  id: totrans-188
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-29\. 用于 Rule 的构建器模式
- en: '[PRE36]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Using this new class, you can create `RuleBuilder` and configure a `Rule` using
    the methods `when()`, `then()`, and `createRule()` as shown in [Example 5-30](#builder_pattern_usage_v1).
    This idea of chaining methods is a key aspect of designing a Fluent API.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个新类，您可以创建 `RuleBuilder` 并使用 `when()`、`then()` 和 `createRule()` 方法配置 `Rule`，如
    [示例 5-30](#builder_pattern_usage_v1) 所示。方法链的概念是设计流畅 API 的关键方面之一。
- en: Example 5-30\. Using the RuleBuilder
  id: totrans-191
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-30\. 使用 RuleBuilder
- en: '[PRE37]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This code looks more like a query and it leverages the domain at hand: the
    notion of a rule, `when()`, and `then()` as built-in constructs. But it’s not
    entirely satisfactory because there are still two awkward constructs the user
    of your API will have to encounter:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码看起来更像一个查询，并利用了所涉领域：规则的概念、`when()` 和 `then()` 作为内置结构。但它并不完全令人满意，因为用户还是会遇到两个笨拙的构造体。
- en: Instantiate an “empty” `RuleBuilder`
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例化一个“空的”`RuleBuilder`
- en: Call the method `createRule()`
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用方法`createRule()`
- en: 'We can improve this by coming up with a slightly improved API. There are three
    possible improvements:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过提出稍微改进的 API 来改进这一点。有三种可能的改进方法：
- en: We’ll make the constructor private so that it can not be invoked explicitly
    by a user. This means that we will need to come up with a different entry point
    for our API.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将构造函数设置为私有，以防止用户显式调用。这意味着我们需要为我们的 API 设计一个不同的入口点。
- en: We can make the method `when()` static so it’s invoked directly and essentially
    short circuits the invocation to the old constructor. In addition, a static factor
    method improves discoverability of what’s the right method to use to set up `Rule`
    objects.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以将方法`when()`改为静态方法，这样就可以直接调用并且实际上会将调用转发到旧构造函数。此外，静态工厂方法提高了发现正确方法以设置`Rule`对象的可读性。
- en: The method `then()` will become responsible for the final creation of our `DefaultRule`
    object.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法`then()`将负责最终创建我们的`DefaultRule`对象。
- en: '[Example 5-31](#builder_pattern_declaration_v2) shows the improved `RuleBuilder`.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 5-31](#builder_pattern_declaration_v2)展示了改进的`RuleBuilder`。'
- en: Example 5-31\. Improved RuleBuilder
  id: totrans-201
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-31\. 改进的 RuleBuilder
- en: '[PRE38]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: You can now simply create rules by starting with the `RuleBuilder.when()` method
    followed by the `then()` method as shown in [Example 5-32](#improvedRulebuilder).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以通过从 `RuleBuilder.when()` 方法开始，然后使用 `then()` 方法简单地创建规则，如 [示例 5-32](#improvedRulebuilder)
    所示。
- en: Example 5-32\. Using the improved RuleBuilder
  id: totrans-204
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-32\. 使用改进的 RuleBuilder
- en: '[PRE39]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now that we’ve refactored the `RuleBuilder`, we can refactor the Business Rules
    Engine to support rules instead of just actions, as shown in [Example 5-33](#builder_pattern_usage_v2).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经重构了`RuleBuilder`，我们可以重构业务规则引擎以支持规则而不仅仅是动作，如[示例 5-33](#builder_pattern_usage_v2)所示。
- en: Example 5-33\. Updated Business Rules Engine
  id: totrans-207
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-33\. 更新的业务规则引擎
- en: '[PRE40]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Takeaways
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 收获
- en: The test-driven development philosophy starts with writing some tests that are
    going to let you guide the implementation of the code.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试驱动开发（Test-Driven Development，TDD）的哲学是从编写一些测试开始，这些测试将指导您实现代码。
- en: Mocking allows you to write unit tests that assert that certain behaviors are
    triggered.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟允许您编写单元测试，以确保触发某些行为。
- en: Java supports local variable type inferences and switch expressions.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java支持局部变量类型推断和switch表达式。
- en: The Builder pattern helps design a user-friendly API for instantiating complex
    objects.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建造者模式有助于为实例化复杂对象设计用户友好的API。
- en: The Interface Segregation Principle helps promote high cohesion by reducing
    dependence on unnecessary methods. This is achieved by breaking up large interfaces
    into smaller cohesive interfaces so that users only see what they need.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口隔离原则通过减少对不必要方法的依赖来促进高内聚。通过将大型接口分解为更小的内聚接口，使用户只看到他们需要的内容，从而实现这一目标。
- en: Iterating on You
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在你身上循环
- en: 'If you want to extend and solidify the knowledge from this chapter you could
    try one of these activities:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想扩展并巩固本章的知识，您可以尝试以下活动之一：
- en: Enhance the `Rule` and `RuleBuilder` to support a name and description.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增强`Rule`和`RuleBuilder`以支持名称和描述。
- en: Enhance the `Facts` class so the facts can be loaded from a JSON file.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增强`Facts`类，以便可以从JSON文件加载事实。
- en: Enhance the Business Rules Engine to support rules having multiple conditions.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增强业务规则引擎以支持具有多个条件的规则。
- en: Enhance the Business Rules Engine to support rules with different priorities.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增强业务规则引擎以支持具有不同优先级的规则。
- en: Completing the Challenge
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成挑战
- en: Your business is booming and your company has adopted the Business Rules Engine
    as part of its workflow! You are now looking for your next idea and want to put
    your software development skills to something new that will help the world rather
    than just your company. It’s time to jump to the next chapter—Twootr!
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 您的业务蒸蒸日上，您的公司已将业务规则引擎作为工作流程的一部分采纳！现在您正在寻找下一个创意，并希望将您的软件开发技能应用到能够帮助世界而不仅仅是公司的新事物上。是时候迈向下一章——Twootr了！
