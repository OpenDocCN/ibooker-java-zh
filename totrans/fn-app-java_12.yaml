- en: Chapter 10\. Functional Exception Handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As much as we would like to write perfect and error-free code, it’s an almost
    impossible endeavor. That’s why we need a way to deal with inevitable problems
    in our code. Java’s mechanism of choice to deal with such disruptive and abnormal
    control flow conditions is Exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Exception handling can be tricky, even in imperative and OO code. Combining
    Exceptions with a functional approach, however, can be a real challenge because
    the techniques are fraught with considerations and requirements. Although there
    are third-party libraries that can assist with this, you may not want to rely
    solely on them in the long term by incurring technical debt due to a new dependency,
    instead of adapting to a more functional approach overall.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will show you the different kinds of Exceptions and their impact
    on functional programming with lambdas. You will learn how to handle Exceptions
    in lambdas as well as alternative ways to approach control flow disruptions in
    a functional context.
  prefs: []
  type: TYPE_NORMAL
- en: Java Exception Handling in a Nutshell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In general, an Exception is a special event that happens during the execution
    of a program that disrupts the normal flow of instructions. This concept is present
    in many different programming languages, not only in Java, and traces back to
    the origins of Lisp^([1](ch10.xhtml#idm45115227087312)).
  prefs: []
  type: TYPE_NORMAL
- en: The actual form of how Exceptions are handled depends on the language.
  prefs: []
  type: TYPE_NORMAL
- en: The try-catch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java’s mechanism of choice is the `try`-`catch`-block which is an integral element
    of the language.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The overall concept of it has slightly evolved since its inception. Instead
    of requiring multiple `catch` blocks, you can catch more than one Exception with
    a [`multi-catch`](https://docs.oracle.com/javase/7/docs/technotes/guides/language/catch-multiple.xhtml)
    block by using `|` (pipe) between their types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If you need to handle resources, using a [`try-with-resources`](https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.xhtml)
    construct will automatically close any resource that implements `AutoCloseable`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Regardless of which variant you use, you will end up with an Exception that
    disrupts the flow of execution of your code by jumping from the origin of the
    thrown Exception to the nearest `catch` point up the call stack or crashing the
    current thread if none is available.
  prefs: []
  type: TYPE_NORMAL
- en: The Different Types of Exceptions and Errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are three types of control flow disruptions in Java, with disparate requirements
    regarding their handling in your code: *checked* and *unchecked* Exceptions, and
    *Errors*.'
  prefs: []
  type: TYPE_NORMAL
- en: Checked Exceptions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Checked* Exceptions are *anticipated* and potentially *recoverable* events
    outside the normal control flow. For example, you should always expect the possibility
    of a missing file (`FileNotFoundException`) or an invalid URL (`MalformedURLException`).
    Because they’re anticipated, they must adhere to Java’s *catch-or-specify* requirement.'
  prefs: []
  type: TYPE_NORMAL
- en: Unchecked Exceptions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Unchecked* Exceptions, on the other hand, are *not anticipated*, and are often
    *unrecoverable*, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '`UnsupportedOperationException` in the case of an unsupported operation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ArithmeticException` for invalid mathematical calculations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NullPointerException` if an empty reference is encountered'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They aren’t considered part of the methods’ public contract but rather represent
    what happens if any assumed contract preconditions are broken. Therefore, such
    Exceptions aren’t subject to the catch-or-specify requirement, and methods usually
    don’t signify them with the `throws` keyword, even if it’s known that a method
    will throw them in under certain conditions.
  prefs: []
  type: TYPE_NORMAL
- en: However, unchecked Exceptions still have to be handled in some form if you don’t
    want your program to crash. If not handled locally, an Exception automatically
    goes up the call stack of the current thread until it finds an appropriate handler.
    Or, if none is available, the thread dies. For single-threaded applications, the
    runtime will terminate, and your program will crash.
  prefs: []
  type: TYPE_NORMAL
- en: Errors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The third kind of control flow disruption — *Errors* — indicates a severe problem
    you shouldn’t catch or can’t handle under normal circumstances.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if the runtime runs out of available memory, the runtime throws
    a `OutOfMemoryError`. Or an endless recursive call will eventually lead to a `StackOverflowError`.
    There’s nothing you can really do without any memory left, regardless of whether
    it’s the heap or the stack. Faulty hardware is another source for Java errors,
    like `java.io.IOError` in case of a disk error. These are all grave and not anticipated
    problems with almost no possibility of recovering gracefully. That’s why errors
    mustn’t adhere to the catch-or-specify requirement.
  prefs: []
  type: TYPE_NORMAL
- en: Exception Hierarchy in Java
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Which category an Exception falls into depends on its base class. All Exceptions
    are checked, except types subclassing `java.lang.RuntimeException` or `java.lang.Error`.
    But they share a common base type: `java.lang.Throwable`. Types inheriting from
    the latter two are either unchecked or an error. The type hierarchy is illustrated
    in [Figure 10-1](#_02-exception-handling_hierachy).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Hierarchy of Java Exception Types](assets/afaj_1001.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-1\. Exceptions hierarchy in Java
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The concept of having different kinds of Exceptions is rather uncommon among
    programming languages, and it’s a controversial topic of discussion due to their
    different requirements of how to handle them. Kotlin^([2](ch10.xhtml#idm45115226777968)),
    for example, inherits the general mechanisms of handling Exceptions but doesn’t
    have any checked Exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Checked Exceptions in Lambdas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java’s Exception-handling mechanisms were designed to fulfill specific requirements
    at the time of its inception, 18 years before the introduction of lambdas. That’s
    why throwing and handling Exceptions don’t fit nicely into the new functional
    Java coding style without any special considerations or completely disregarding
    the catch-or-specify requirement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at loading the content of a file with a `static` method available
    on `java.util.Files` with the following method signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The method signature is quite simple and indicates that a checked `IOException`
    might get thrown, so a `try`-`catch`-block is required. That’s why the method
    can’t be used as a method reference, or in a simple lambda:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The problem stems from the functional interface required to satisfy the `map`
    operation. None of the functional interfaces of the JDK throw checked Exceptions
    and are, therefore, not compatible with any method that does.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: There are interfaces marked with @FunctionalInterface that throw Exceptions,
    like `java.util.concurrent.Callable<V>`. They *are* functional interfaces by definition,
    but it’s for compatibility reasons, not because they represent functional types
    to be used indiscriminately.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most obvious solution is using `try`-`catch`-block by converting the lambda
    to a block-based one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The code required to satisfy the compiler defeats the purpose of Stream pipelines
    lambdas in general. The conciseness and straightforward representation of an operation
    is diluted by the required boilerplate for Exception handling.
  prefs: []
  type: TYPE_NORMAL
- en: Using Exceptions in lambdas almost feels like an anti-pattern. A `throws` declaration
    indicates that the caller has to decide how to handle that Exception, and lambdas
    don’t have a dedicated way of dealing with Exceptions except for the pre-existing
    `try-catch`, which can’t be used for method references.
  prefs: []
  type: TYPE_NORMAL
- en: 'Still, there are certain ways of dealing with Exceptions without losing (most
    of) the simplicity and clarity that lambdas, methods references, and pipelines
    like Streams or Optionals give you:'
  prefs: []
  type: TYPE_NORMAL
- en: Safe method extraction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Un-Checking Exceptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sneaky throws
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All these options are imperfect workarounds to mitigate Exception handling in
    functional code. Still, we will have a look at each of them because they can be
    useful in certain scenarios if you do not have a built-in way to deal with Exceptions
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: The last two can even be treacherous or at least become a code smell if used
    unwisely. Nevertheless, knowing such “last resort” tools can help you navigate
    more difficult amalgamations of pre-existing, non-functional code, and give you
    a more functional approach.
  prefs: []
  type: TYPE_NORMAL
- en: Safe Method Extraction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Efficiently handling Exceptions in your functional code depends on who effectively
    controls or owns the code. If the throwing code is entirely under your control,
    you should *always* adequately handle them. But often, the offending code is *not*
    yours, or you can’t change or refactor it as needed. That’s when you can still
    extract it into a “safer” method with appropriate local Exception handling.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a “safe” method decouples the actual work from handling any Exception,
    restoring the principle of the caller being responsible for any checked Exceptions.
    Any functional code can use the safe method instead, as shown in [Example 10-1](#_02-exception-handling_safe-wrapper).
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-1\. Extract throwing code into a safe method
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_functional_exception_handling_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The “safe” method has the same method signature except for the `throws IOException`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_functional_exception_handling_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The Exception is dealt with locally and returns an appropriate fallback.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_functional_exception_handling_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The wrapper method can be used as a method reference, making the code concise
    and readable again.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_functional_exception_handling_CO1-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The possibility of a `null` element must be handled accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: The pipeline is concise and straightforward again. The `IOException` is handled
    in the sense that it doesn’t affect the pipeline, but this approach isn’t “one-size-fits-all.”
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Safe method extraction is akin to a more localized version of the *facade pattern*⁠^([3](ch10.xhtml#idm45115226386080)).
    Instead of wrapping a whole class to provide a safer, context-specific interface,
    only specific methods get a new facade to improve their handling for particular
    use cases. That reduces the affected code and still gives you the advantages of
    a facade, like reduced complexity and improved readability. It’s also a good starting
    point for future refactoring efforts.
  prefs: []
  type: TYPE_NORMAL
- en: Extracted safe methods might be an improvement over using `try`-`catch` blocks
    in a lambda because you keep the expressiveness of inline-lambdas and method references
    and have a chance to handle any Exceptions. But the handling is confined in another
    abstraction over existing code to regain control of disruptive control-flow conditions.
    The actual caller of the method — the Stream operation — gets no chance to deal
    with the Exception, making the handling opaque and inflexible.
  prefs: []
  type: TYPE_NORMAL
- en: Un-Checking Exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next way to deal with checked Exceptions goes against the fundamental purpose
    of using checked Exceptions in the first place. Instead of dealing with a checked
    Exception directly, you hide it in an unchecked Exception to circumvent the catch-or-specify
    requirement. It’s a nonsensical, but effective way to make the compiler happy.
  prefs: []
  type: TYPE_NORMAL
- en: This approach uses specialized functional interfaces that use the `throws` keywords
    to wrap the offending lambda or method reference. It catches the original Exception
    and rethrows it as an unchecked `RuntimeException`, or one of its siblings. These
    functional interfaces extend the original one to ensure compatibility. The original
    single-abstract method uses a `default` implementation to connect it to the throwing
    one, as shown in [Example 10-2](#_02-exception-handling_uncheck-exceptions).
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-2\. Unchecking `java.util.Function`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_functional_exception_handling_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The wrapper extends the original type to act as a drop-in replacement.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_functional_exception_handling_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The single-abstract method (SAM) mimics the original but throws an `Exception`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_functional_exception_handling_CO2-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The original SAM is implemented as a `default` method to wrap any `Exception`
    as a `RuntimeException`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_functional_exception_handling_CO2-4)'
  prefs: []
  type: TYPE_NORMAL
- en: A `static` helper to uncheck any throwing `Function<T, U>` to circumvent the
    catch-or-specify requirement.
  prefs: []
  type: TYPE_NORMAL
- en: The `ThrowingFunction<T, U>` type can either be used explicitly by calling the
    `uncheck` method or implicitly as seen in [Example 10-3](#_02-exception-handling_uncheck-exceptions_how-to-use).
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-3\. Using `ThrowingFunction<T, U>`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_functional_exception_handling_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Any throwing method is assignable as a `ThrowingFunction` via a method reference
    and used in a context requiring a `Function`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_functional_exception_handling_CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, a throwing lambda or method reference can be unchecked on the
    fly by using the `static` helper `uncheck`.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations, the compiler is happy again and won’t force you to handle the
    Exception anymore. The wrapper type doesn’t fix the original problem of possible
    control flow disruption but hides it from plain sight. The Stream pipeline will
    still blow up if any Exception occurs without any possibility for localized Exception
    handling.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Exception-throwing functional interfaces only disguise their exceptional states.
    They have their place and can be quite useful, but shouldn’t be considered a go-to
    solution instead of a last resort.
  prefs: []
  type: TYPE_NORMAL
- en: Sneaky Throws
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *sneaky throws* idiom is a hack to throw a checked Exception without declaring
    it with the `throws` keyword in a method’s signature.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of throwing a checked Exception using the `throw` keyword in a method’s
    body, which requires a `throws` declaration in the method signature, the actual
    Exception is thrown by another method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The actual throwing of the Exception is delegated to the `sneakyThrow` method.
  prefs: []
  type: TYPE_NORMAL
- en: Wait a minute, doesn’t anyone using a method throwing a checked Exception, like
    `sneakyThrow`, have to adhere to the catch-or-specify requirement?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, there’s one exception to the rule (pun intended). You can take advantage
    of a change^([4](ch10.xhtml#idm45115226007984)) in Java’s type inference regarding
    Generics and Exceptions in Java 8. In simple terms, if there are no upper or lower
    bounds on a generic method signature with `throws E`, the compiler assumes the
    type `E` to be a `RuntimeException`. This allows you to create the following `sneakyThrow`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Regardless of the actual type for the argument `e`, the compiler assumes `throws
    E` to be a `RuntimeException` and thereby exempts the method from the catch-or-specify
    requirement. The compiler might not complain, but this approach is highly problematic.
  prefs: []
  type: TYPE_NORMAL
- en: The method signature of `sneakyRead` no longer signifies its checked Exception.
    Checked Exceptions are supposed to be anticipated and recoverable, and therefore,
    belong to the method’s public contract. By removing the `throws` keyword and circumventing
    the catch-or-specify requirement, you reduce the amount of information conferred
    to the caller by making the method’s public contract more opaque for convenience
    reasons. You still could — and should — list all Exceptions and their reasoning
    in the method’s documentation.
  prefs: []
  type: TYPE_NORMAL
- en: The method no longer follows “normal reasoning” by bypassing the `throws` keyword
    and the enforcement of the catch-or-specify requirement. Anyone reading the code
    has to know what `sneakyThrow` does. You could add an appropriate `return` statement
    after the call to at least convey that it’s an exit point. But the significance
    that a `throws` keyword emits is lost.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Sneaky throws circumvent an integral part of the Java language of how to deal
    with control flow disruptions. There is a place for it in a few edge cases for
    internal implementations. In external code, however, like `public` methods, throwing
    Exceptions sneakily breaks the reasonably expected contract between the method
    and the caller any Java developer would anticipate.
  prefs: []
  type: TYPE_NORMAL
- en: Sneakily throwing Exceptions might be an acceptable “last resort” hack for internal
    code, but you still have to communicate the implications with the help of the
    context, method names, and documentation. In the next section, I show you an acceptable
    use case for sneakily throwing an Exception in a specialized implementation for
    internal code.
  prefs: []
  type: TYPE_NORMAL
- en: A Functional Approach to Exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, I’ve only discussed how to “brute force” Java’s Exception handling mechanics
    to play nice with lambdas by ignoring and circumventing the intended purpose of
    Exceptions. What’s really needed is finding a reasonable compromise and balance
    between a functional approach and the more traditional constructs.
  prefs: []
  type: TYPE_NORMAL
- en: Your options include designing your code to not throw Exceptions at all or mimicking
    the Exception-handling approaches of other more functional languages.
  prefs: []
  type: TYPE_NORMAL
- en: Not Throwing Exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Checked Exceptions are an integral part of a method’s contract and are designed
    as control flow disruptions. That’s what makes it so difficult to deal with them
    in the first place! So, instead of finding a better way of handling checked Exceptions
    and all of their complications, we can instead find an alternative way of dealing
    with control flow disruption in a functional context.
  prefs: []
  type: TYPE_NORMAL
- en: '[“Safe Method Extraction”](#_02-exception-handling_safe-method-extraction)
    discussed a variant of not throwing Exceptions by wrapping an Exception-throwing
    method with a non-throwing “safer” method. This approach helps if you don’t have
    control over the code and can’t design it to not throw any Exceptions in the first
    place. It replaces disruptive control flow events in the form of Exceptions with
    another value to represent an “exceptional” state: `Optional<T>`. If you have
    control over the API, you could design its contracts not to use Exceptions or
    make them at least more manageable. Exceptions are a reaction to some form of
    illegal state. The best way to avoid Exception handling is to make the representation
    of such an illegal state impossible in the first place.'
  prefs: []
  type: TYPE_NORMAL
- en: I discussed in [Chapter 9](ch09.xhtml#_02-optionals) that Optionals are a “box”
    to wrap an actual value. It’s a specialized type representing the presence or
    absence of values without risking encountering a `null` reference and the eventually
    dreaded `NullPointerException`.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at the previous example again. This time, however, let’s use an Optional
    instead of throwing an Exception, as seen in [Example 10-4](#_02-exception-handling_optional-vs-exception).
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-4\. Using `Optional<String>` instead of throwing an `IOException`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_functional_exception_handling_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: An `Optional<String>` is used instead of a plain `String`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_functional_exception_handling_CO4-2)'
  prefs: []
  type: TYPE_NORMAL
- en: By returning an `Optional<String>`, either with the file content or an empty
    one in the case of an `IOException`, a valid non-`null` object is returned.
  prefs: []
  type: TYPE_NORMAL
- en: Returning an `Optional<String>` has two advantages over simply returning `String`.
    First, a valid object is returned, so no additional `null`-checks are required
    to use it safely. Second, the Optional type is a starting point for a fluent functional
    pipeline to deal with the inner value, or its absence.
  prefs: []
  type: TYPE_NORMAL
- en: If your API doesn’t expose any illegal states requiring control flow disruptions,
    you, or anyone else calling such methods, don’t have to handle them. Optionals
    are a simple and readily available choice, although it lacks some desirable features.
    The new `safeReadString` conveys that it wasn’t able to read the file but doesn’t
    tell you *why* it wasn’t able to do so.
  prefs: []
  type: TYPE_NORMAL
- en: Errors as Values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Where `Optional<T>` only provides the difference between the presence and absence
    of a value, a dedicated *result object* conveys more information about *why* an
    operation might have failed. The concept of dedicated type representing the overall
    result of an operation isn’t a new one. They are wrapper objects indicating whether
    or not an operation was a success and include a value or, if unsuccessful, a reason
    why not. Many languages support dynamic tuples as return types, so you don’t need
    an explicit type representing your operation, like in Go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Even though Java lacks such dynamic tuples, thanks to Generics, a versatile
    and functionally inclined result type can be created that leverages tools and
    concepts discussed in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create a rudimentary `Result<V, E extends Throwable>` type together.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Scaffold
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The main goal of the `Result` type is to hold a possible value or, if not successful,
    an Exception representing the reason for failure.
  prefs: []
  type: TYPE_NORMAL
- en: A “traditional” result object could be implemented as a Record as shown in [Example 10-5](#_02-exception-handling_result-type-01).
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-5\. Traditional Result Object
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_functional_exception_handling_CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The Record components reflect the different states. The explicit `isSuccess`
    field helps to better determine a successful operation and to support `null` as
    a valid value.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_functional_exception_handling_CO5-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Convenience factory methods provide a more expressive API.
  prefs: []
  type: TYPE_NORMAL
- en: Even this simple scaffold provides a certain improvement over using Optionals
    already, with the convenience factory methods being an expressive way to create
    appropriate results.
  prefs: []
  type: TYPE_NORMAL
- en: The previous examples of `safeReadString` can be easily converted to use the
    `Result<V,E>` type, as shown in [Example 10-6](#_02-exception-handling_result-type-02)
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-6\. Using `Result<V, E>` as a return type
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The new type is just as easy to use in a Stream pipeline as an Optional. But
    the real power comes from giving it more functional properties by introducing
    higher-order functions that depend on the success state.
  prefs: []
  type: TYPE_NORMAL
- en: Making Result<V, E> Functional
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The general features of the `Optional<T>` type are the inspiration on how to
    improve the `Result` type further, including:'
  prefs: []
  type: TYPE_NORMAL
- en: Transforming its value or Exception
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reacting to an Exception
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing a fallback value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transforming the `value` or `throwable` field requires dedicated `map` methods
    or a combined one to handle both use cases at once, as shown in [Example 10-7](#_02-exception-handling_result-type-03).
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-7\. Adding Transformers to `Result<V, E>`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_functional_exception_handling_CO6-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The singular mapping methods are quite similar and transform the respective
    result, success or failure. That’s why both must return an `Optional` instead
    of a concrete value.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_functional_exception_handling_CO6-3)'
  prefs: []
  type: TYPE_NORMAL
- en: A combined `map` method allows you to handle both cases, success or failure,
    in a single call. Because both states are handled, a concrete value instead of
    an `Optional` is returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the help of the mapper methods, you can now handle either one or both
    cases directly, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: There also needs to be a way to work with a `Result` without requiring to transform
    its value or Exception first.
  prefs: []
  type: TYPE_NORMAL
- en: 'To react to a certain state, let’s add `ifSuccess`, `ifFailure`, and `handle`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The implementation is almost equivalent to the mapper methods, except they use
    a `Consumer` instead of a `Function`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: These two additions are side-effect-only and, therefore, not very “functional”
    in the purest sense. Nevertheless, such additions provide an excellent stopgap
    between imperative and functional approaches.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s add convenience methods for providing fallback values. The most
    obvious ones are `orElse` and `orElseGet`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: No surprises here.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, adding an `orElseThrow` as a shortcut to re-throw the inner `Throwable`
    isn’t as straightforward because it still has to adhere to the catch-or-specify
    requirement. This is actually the one acceptable use case I talked about earlier
    about using a “sneaky throw,” as discussed in [“Sneaky Throws”](#_02-exception-handling_sneaky-throws),
    to circumvent the requirement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In this particular case, a “sneaky throw” is justified in my opinion due to
    the general context and public contract of `orElseThrow()`. Like with `Optional<T>`,
    the method force-unwraps the “box” holding a possible result and warns you about
    a possible exception with its name.
  prefs: []
  type: TYPE_NORMAL
- en: There’s a lot left to be desired, like adding a `Stream<V> stream()` method
    for even better integration into Stream pipelines. Still, the general approach
    was a great exercise on how to combine functional concepts to provide an alternative
    to handling disruptive control flow events. The implementation shown in this book
    is quite simplistic and reduced to a minimal amount of code.
  prefs: []
  type: TYPE_NORMAL
- en: If you intend to use a type like `Result<V, E>`, you should check out one of
    the functional libraries of the Java ecosystem. Projects like [vavr](https://www.vavr.io),
    [jOOλ](https://github.com/jOOQ/jOOL) (pronounced “JOOL”), and [Functional Java](https://www.functionaljava.org)
    provide quite comprehensive and battle-tested implementations ready to use.
  prefs: []
  type: TYPE_NORMAL
- en: The Try/Success/Failure Pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Scala is arguably the closest functional relative to Java available on the JVM,
    not considering Clojure due to its more foreign syntax and dynamic type system.
    It addresses many of Java’s perceived “shortcomings” over younger languages and
    is functional at its core, including an excellent way of dealing with exceptional
    conditions.
  prefs: []
  type: TYPE_NORMAL
- en: The *Try/Success/Failure* pattern and its related types `Try[+T]`⁠^([5](ch10.xhtml#idm45115224366432)),
    `Success[+T]`, and `Failure[+T]`, are Scala’s way of dealing with Exceptions in
    a more functional fashion.
  prefs: []
  type: TYPE_NORMAL
- en: Where an `Optional<T>` indicates that a value might be missing, `Try[+T]` can
    tell you *why* and gives you the possibility to handle any occurred Exception,
    similar to the `Result` type discussed earlier in this chapter. If the code succeeds,
    a `Success[+T]` object is returned, and if it fails, the error will be contained
    in a `Failure[+T]` object. Scala also supports *pattern-matching*, a `switch`-like
    concept of handling different outcomes. That allows for quite concise and straightforward
    Exception handling without the usual boilerplate a Java developer is used to.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Scala-like pattern matching for Java’s `switch` construct is available as a
    preview feature^([6](ch10.xhtml#idm45115224250464)) since Java 17.
  prefs: []
  type: TYPE_NORMAL
- en: A `Try[+T]` can either be in a `Success[+T]` or `Failure[+T]` state, with the
    latter containing a `Throwable`. Even without full knowledge of Scala’s syntax,
    the code in [Example 10-8](#_02-exception-handling_try-success-failure) shouldn’t
    be too foreign to a Java developer.
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-8\. Scala’s Try/Success/Failure pattern
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_functional_exception_handling_CO7-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The return type is `Try[String]`, so the method must either return a `Success[String]`
    containing the content of the `Path`, or a `Failure[Throwable]`. Scala doesn’t
    need an explicit `return` and returns the last value implicitly. Any Exception
    is caught by the `Try { …​ }` construct.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_functional_exception_handling_CO7-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Scala’s pattern matching simplifies the result handling. The cases are lambdas,
    and the whole block is similar to an Optional call chain with a `map` and a `orElse`
    operation.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_functional_exception_handling_CO7-3)'
  prefs: []
  type: TYPE_NORMAL
- en: '`Success` provides access to the return value.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_functional_exception_handling_CO7-4)'
  prefs: []
  type: TYPE_NORMAL
- en: If an Exception occurs, it’s handled by the `Failure` case.
  prefs: []
  type: TYPE_NORMAL
- en: '`Try[+A]` is an excellent Scala feature, combining concepts similar to Optionals
    and Exception handling into a single, easy-to-use type and idiom. But what does
    that mean for you as a Java developer?'
  prefs: []
  type: TYPE_NORMAL
- en: Java doesn’t provide anything out-of-the-box that comes even close to the simplicity
    or language integration of Scala’s try/success/failure pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Even without language support, you can still try to implement an approximation
    of the try/success/failure pattern with the new functional tools since Java 8.
    So let’s do that now.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Pipeline
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Similar to how Streams provide a launch pad for a functional pipeline, the `Try`
    type we’re going to create will have a creation step, intermediate, but independent
    operations, and finally, a terminal operation to kickstart the pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: To replicate Scala’s functionality, a construct accepting a lambda is needed
    as a starting point.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As with other functional constructs, many variants would be needed to support
    the various available functional interfaces. To simplify the required code, the
    `Try` type only supports `Function<T, R>` as the initial lambda.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main requirements of the `Try` type are:'
  prefs: []
  type: TYPE_NORMAL
- en: Accepting a possibly throwing lambda
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing a `success` operation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing a `failure` operation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starting the pipeline with a value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Try` type could be simplified by only supporting `RuntimeException`, but
    then, it wouldn’t be a flexible alternative to regular `try`-`catch`-block. To
    circumvent the catch-or-specify requirement, the `ThrowingFunction` interface
    discussed in [“Un-Checking Exceptions”](#_02-exception-handling_unchecking-exceptions).
  prefs: []
  type: TYPE_NORMAL
- en: The minimum scaffold required to accept `ThrowingFunction` and a possible `Function`
    to handle any a `RuntimeException` is shown in [Example 10-9](#_02-exception-handling_try-success-failure-01).
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-9\. Minimal `Try<T, R>` accepting a lambda and Exception handler
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_functional_exception_handling_CO8-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The Generic types `T` and `R` correspond to `Function<T, R>`. A `class` is used
    instead of a `record` to hide the sole constructor.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_functional_exception_handling_CO8-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The construct needs to hold the initial `Function<T, R>` and a possible error
    handling `Function<RuntimeException, R>`. Both fields are `final`, making the
    `Try` type immutable.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_functional_exception_handling_CO8-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The `static` factory method `of` provides a similar interface as other functional
    pipelines. It accepts a `ThrowingFunction<T, R>` to circumvent the catch-or-specify
    requirement, but assigns it immediately to a `Function<T, R>`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_functional_exception_handling_CO8-5)'
  prefs: []
  type: TYPE_NORMAL
- en: The `private` constructor enforces the use of the factory method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even though the type doesn’t do anything, creating a new pipeline from an existing
    lambda or method reference is pretty straightforward, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The type hints in front of the `of` call are required because the compiler can’t
    necessarily infer the type from the surrounding context.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the type needs to handle success and failure.
  prefs: []
  type: TYPE_NORMAL
- en: Handling Success and Failure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Two new methods are needed to handle the outcome of the `Try` pipeline, `success`
    and `failure`, as seen in [Example 10-10](#_02-exception-handling_try-success-failure-02).
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-10\. Handling success and failure in `Try<T, R>`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_functional_exception_handling_CO9-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The `successFn` is composed to the original lambda to provide the base for the
    new `Try` instance. The `failureFn` is used as-is.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_functional_exception_handling_CO9-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Handling an error requires only passing through the original `fn` and the provided
    `failureFn`.
  prefs: []
  type: TYPE_NORMAL
- en: Because the `Try` type is designed to be immutable, both handling methods return
    a new instance of `Try`. The `success` method uses functional composition to create
    the fully required task, whereas the `failure` method creates a new `Try` instance
    with the pre-existing lambda and the provided error handling `Function`.
  prefs: []
  type: TYPE_NORMAL
- en: By using functional composition for the `success` operation instead of an extra
    control path, like storing `successFn` in another field, the handler isn’t even
    required in case of no modifications to the result of the initial lambda.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the handler methods is as you would expect and feels similar to working
    with a Stream’s intermediate operations, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Unlike a Stream, though, the operations are independent of one another and not
    in a sequential pipeline. It’s more akin to how an Optionals pipeline seems to
    be sequential but actually has tracks to follow. Which handling operation, `success`
    or `failure`, is supposed to be evaluated depends on the state of the `Try` evaluation.
  prefs: []
  type: TYPE_NORMAL
- en: It’s time to kickstart the pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Running the Pipeline
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The last operation needed to complete the pipeline is the ability to push a
    value down the pipeline and let the handlers do their work, in the form of an
    `apply` method, as shown in [Example 10-11](#_02-exception-handling_try-success-failure-apply).
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-11\. Applying a value to `Try`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_functional_exception_handling_CO10-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The “happy path” is appyling `fn` to the value. Thanks to designing the `success`
    method as functional composition, no special handling is needed to run the initial
    lambda and optional `success` transformation. The code has to be run in a `try`-`catch`-block
    to handle the `failure` case.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_functional_exception_handling_CO10-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Failure handling is optional, so a `null`-check is necessary.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_functional_exception_handling_CO10-3)'
  prefs: []
  type: TYPE_NORMAL
- en: This point is the ultimate fallback if no error handler was added to the pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: The return type `Optional<R>` provides another lift-off point for a functional
    pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now our minimalistic `Try` pipeline has all the operations needed to call a
    throwing method and handle both the success and failure cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Even though the `Try` pipeline gives you higher-order function operations to
    deal with a throwing lambda, the pipeline itself isn’t functional on the outside.
    Or is it?
  prefs: []
  type: TYPE_NORMAL
- en: 'The name, `apply`, I’ve chosen for the terminal operation reveals the possible
    functional interface that `Try` could implement to be more easily usable in other
    functional pipelines like Streams or Optionals: `Function<T, Optional<R>>`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'By implementing the functional interface the `Try` type becomes a drop-in replacement
    for any `Function` without requiring actual logic changes, as shown in [Example 10-12](#_02-exception-handling_try-success-failure-function):'
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-12\. Implementing `Function<T, Optional<R>>`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, any `Try` pipeline is easily usable in any higher-order function that
    accepts a `Function`, like in a Stream `map` operation, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: As with the `Result` before, the `Try` type is quite minimalistic and should
    be regarded as an exercise of how to combine functional concepts to create new
    constructs, like a lazy fluent pipeline consisting of higher-order functions.
    If you want to use a type like `Try`, you should consider using an established
    functional third-party library like [vavr](https://www.vavr.io) which provides
    a versatile `Try` type and much more.
  prefs: []
  type: TYPE_NORMAL
- en: Final Thoughts on Functional Exception Handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Disruptive and abnormal control flow conditions in our code are inevitable,
    which is why we need a way to deal with them. Exception handling helps to improve
    program safety. For example, the catch-or-specify requirement is designed to make
    you think about the anticipated exceptional states and deal with them accordingly
    to increase code quality. Although it’s certainly useful, it’s also tricky to
    carry out.
  prefs: []
  type: TYPE_NORMAL
- en: 'Handling Exceptions can be quite a pain point in Java, regardless of using
    a functional approach. There is always a trade-off, no matter which Exception-handling
    approach you choose, especially if checked Exceptions are involved:'
  prefs: []
  type: TYPE_NORMAL
- en: Extracting unsafe methods to gain localized Exception handling is a good compromise
    but not an easy-to-use general solution.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing your APIs to not have any exceptional states is not as easy as it
    sounds.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unchecking your Exceptions is a “last-resort” tool that hides them away without
    a chance to handle them and contradicts their purpose.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So what should you do? Well, it depends.
  prefs: []
  type: TYPE_NORMAL
- en: None of the presented solutions is *perfect*. You have to find a balance between
    “convenience” and “usability.” Exceptions are sometimes an overused feature, but
    they are still essential signals to the control flow of your programs. Hiding
    them away might not be in your best interest in the long run, even if the resulting
    code is more concise and reasonable, as long as no Exception occurs.
  prefs: []
  type: TYPE_NORMAL
- en: Not every imperative or OOP feature/technique is replaceable with a functional
    equivalent in Java. Many of Java’s (functional) shortcomings are circumventable
    to gain their general advantages, even if the resulting code is not as concise
    as in fully-functional programming languages. Exceptions, however, are one of
    those features that aren’t easily replaceable in most circumstances. They’re often
    an indicator that you either should try to refactor your code to make it “more
    functional” or that a functional approach might not be the best solution for the
    problem.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, there are several third-party libraries available, like the [Vavr
    project](https://www.vavr.io/) or [jOOλ](https://github.com/jOOQ/jOOL), that allow
    you to circumvent or at least mitigate problems when using (checked) Exceptions
    in functional Java code. They did all the work implementing all relevant wrapper
    interfaces and replicating control structures and types from other languages,
    like pattern matching. But in the end, you end up with highly specialized code
    that tries to bend Java to its will, without much regard for traditional or common
    code constructs. Such dependence on a third-party library is a long-term commitment
    and shouldn’t be added lightly.
  prefs: []
  type: TYPE_NORMAL
- en: Takeaways
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are no specialized constructs for handling Exceptions in functional code
    like lambda expressions, only the `try`-`catch`-block as usual, which leads to
    verbose and unwieldy code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can fulfill or circumvent the catch-or-specify requirement in multiple ways,
    but that merely hides the original “problem.”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom wrappers can provide a more functional approach.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Third-party libraries can help to reduce the additional boilerplate required
    for handling Exceptions more functionally. But the newly introduced types and
    constructs are no lightweight addition to your code and might create a lot of
    technical debt.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing the right way to deal with Exceptions in functional code depends highly
    on the surrounding context.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ^([1](ch10.xhtml#idm45115227087312-marker)) Guy L. Steele and Richard P. Gabriel.
    1996\. “The evolution of Lisp.” [History of programming languages---II. Association
    for Computing Machinery, 233-330](https://doi.org/10.1145/234286.1057818).
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch10.xhtml#idm45115226777968-marker)) The [official Kotlin documentation](https://kotlinlang.org/docs/exceptions.xhtml)
    highlights the differences between Java and Kotlin exception handling.
  prefs: []
  type: TYPE_NORMAL
- en: '^([3](ch10.xhtml#idm45115226386080-marker)) Gamma, E., Helm, R., Johnson, R.,
    & Vlissides, J. (1994). Design patterns: Elements of reusable object-oriented
    software. Boston, MA: Addison Wesley.'
  prefs: []
  type: TYPE_NORMAL
- en: ^([4](ch10.xhtml#idm45115226007984-marker)) The rules for type resolution are
    listed in §18.4 of the [Java SE 8 Language Specification](https://docs.oracle.com/javase/specs/jls/se8/html/jls-18.xhtml#jls-18.4).
  prefs: []
  type: TYPE_NORMAL
- en: ^([5](ch10.xhtml#idm45115224366432-marker)) Scala’s generic types are declared
    with `[]` (square brackets) instead of `<>` (angle brackets). The `+` (plus) signifies
    the type’s variance. See [“Tour of Scala”](https://docs.scala-lang.org/tour/variances.xhtml)
    for more information about type variance.
  prefs: []
  type: TYPE_NORMAL
- en: ^([6](ch10.xhtml#idm45115224250464-marker)) The first preview of pattern matching
    for `switch` is described in [JEP 406](https://openjdk.org/jeps/406). A second
    preview is described in [JEP 420](https://openjdk.org/jeps/420), which was delivered
    in Java 18\. The next release, Java 19, included the third preview described in
    [JEP 427](https://openjdk.org/jeps/427). The feature is still evolving with another
    preview planned for Java 20, described in [JEP 433](https://openjdk.org/jeps/433).
  prefs: []
  type: TYPE_NORMAL
