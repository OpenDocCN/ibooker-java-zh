- en: Chapter 10\. Functional Exception Handling
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 10 章。函数式异常处理
- en: As much as we would like to write perfect and error-free code, it’s an almost
    impossible endeavor. That’s why we need a way to deal with inevitable problems
    in our code. Java’s mechanism of choice to deal with such disruptive and abnormal
    control flow conditions is Exceptions.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们希望编写完美且无错误的代码，这几乎是不可能的事情。这就是为什么我们需要一种处理代码中不可避免问题的方法。Java 处理这种破坏性和异常控制流条件的机制选择是异常。
- en: Exception handling can be tricky, even in imperative and OO code. Combining
    Exceptions with a functional approach, however, can be a real challenge because
    the techniques are fraught with considerations and requirements. Although there
    are third-party libraries that can assist with this, you may not want to rely
    solely on them in the long term by incurring technical debt due to a new dependency,
    instead of adapting to a more functional approach overall.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 异常处理可能会很棘手，即使在命令式和面向对象的代码中也是如此。然而，将异常与函数式方法结合使用确实是一个真正的挑战，因为这些技术充满了考虑和要求。虽然有第三方库可以帮助解决这个问题，但长期依赖它们可能会因为引入新的依赖而导致技术债务，而不是全面采用更加函数化的方法。
- en: This chapter will show you the different kinds of Exceptions and their impact
    on functional programming with lambdas. You will learn how to handle Exceptions
    in lambdas as well as alternative ways to approach control flow disruptions in
    a functional context.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将展示不同类型的异常及其在带有 lambda 的函数式编程中的影响。你将学习如何在 lambda 中处理异常，以及在函数上下文中处理控制流中断的替代方法。
- en: Java Exception Handling in a Nutshell
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java 异常处理简介
- en: In general, an Exception is a special event that happens during the execution
    of a program that disrupts the normal flow of instructions. This concept is present
    in many different programming languages, not only in Java, and traces back to
    the origins of Lisp^([1](ch10.xhtml#idm45115227087312)).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，异常是程序执行过程中发生的特殊事件，会打断正常指令流。这个概念不仅存在于 Java 中，而且在许多其他编程语言中都有，并可以追溯到 Lisp 的起源^([1](ch10.xhtml#idm45115227087312))。
- en: The actual form of how Exceptions are handled depends on the language.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，异常处理的形式取决于编程语言。
- en: The try-catch
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: try-catch
- en: Java’s mechanism of choice is the `try`-`catch`-block which is an integral element
    of the language.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Java 的选择机制是 `try`-`catch`-块，它是语言的一个组成部分。
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The overall concept of it has slightly evolved since its inception. Instead
    of requiring multiple `catch` blocks, you can catch more than one Exception with
    a [`multi-catch`](https://docs.oracle.com/javase/7/docs/technotes/guides/language/catch-multiple.xhtml)
    block by using `|` (pipe) between their types:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 它的整体概念自其创始以来略有发展。现在，你可以使用 [`multi-catch`](https://docs.oracle.com/javase/7/docs/technotes/guides/language/catch-multiple.xhtml)
    块通过在它们的类型之间使用 `|`（管道）来捕获多个异常，而不需要多个 `catch` 块：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If you need to handle resources, using a [`try-with-resources`](https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.xhtml)
    construct will automatically close any resource that implements `AutoCloseable`:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要处理资源，可以使用 [`try-with-resources`](https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.xhtml)
    结构来自动关闭任何实现了 `AutoCloseable` 接口的资源：
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Regardless of which variant you use, you will end up with an Exception that
    disrupts the flow of execution of your code by jumping from the origin of the
    thrown Exception to the nearest `catch` point up the call stack or crashing the
    current thread if none is available.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你使用哪种变体，最终都会因为异常而打断代码的执行流程，从抛出异常的原点跳转到调用堆栈中最近的 `catch` 点，或者如果没有可用的话，会导致当前线程崩溃。
- en: The Different Types of Exceptions and Errors
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异常和错误的不同类型
- en: 'There are three types of control flow disruptions in Java, with disparate requirements
    regarding their handling in your code: *checked* and *unchecked* Exceptions, and
    *Errors*.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 中有三种控制流中断类型，对于它们在代码中的处理有不同的要求：*已检查*和*未检查*异常，以及*错误*。
- en: Checked Exceptions
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 已检查异常
- en: '*Checked* Exceptions are *anticipated* and potentially *recoverable* events
    outside the normal control flow. For example, you should always expect the possibility
    of a missing file (`FileNotFoundException`) or an invalid URL (`MalformedURLException`).
    Because they’re anticipated, they must adhere to Java’s *catch-or-specify* requirement.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*已检查*异常是在正常控制流之外*预期*且有可能*可恢复*的事件。例如，你应该始终考虑到文件丢失 (`FileNotFoundException`)
    或无效 URL (`MalformedURLException`) 的可能性。因为它们是预期的，所以必须遵循 Java 的*捕获或指定*要求。'
- en: Unchecked Exceptions
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 未检查异常
- en: '*Unchecked* Exceptions, on the other hand, are *not anticipated*, and are often
    *unrecoverable*, such as:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*未经检查*的异常，另一方面，*不可预料*，通常是*不可恢复*的，例如：'
- en: '`UnsupportedOperationException` in the case of an unsupported operation'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果遇到不支持的操作，会抛出`UnsupportedOperationException`。
- en: '`ArithmeticException` for invalid mathematical calculations'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于无效的数学计算，会抛出`ArithmeticException`。
- en: '`NullPointerException` if an empty reference is encountered'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果遇到空引用，会抛出`NullPointerException`。
- en: They aren’t considered part of the methods’ public contract but rather represent
    what happens if any assumed contract preconditions are broken. Therefore, such
    Exceptions aren’t subject to the catch-or-specify requirement, and methods usually
    don’t signify them with the `throws` keyword, even if it’s known that a method
    will throw them in under certain conditions.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 它们不被视为方法的公共合同部分，而是代表了如果破坏任何假定的合同前提条件会发生什么。因此，这些异常不受捕获或指定要求的限制，通常方法即使知道在某些条件下会抛出它们，也不会用`throws`关键字表示它们。
- en: However, unchecked Exceptions still have to be handled in some form if you don’t
    want your program to crash. If not handled locally, an Exception automatically
    goes up the call stack of the current thread until it finds an appropriate handler.
    Or, if none is available, the thread dies. For single-threaded applications, the
    runtime will terminate, and your program will crash.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，未经检查的异常仍然必须以某种形式处理，如果不希望程序崩溃的话。如果在本地没有处理，异常会自动上升到当前线程的调用堆栈，直到找到合适的处理程序。或者，如果找不到任何处理程序，线程将终止。对于单线程应用程序，运行时会终止，程序将崩溃。
- en: Errors
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 错误
- en: The third kind of control flow disruption — *Errors* — indicates a severe problem
    you shouldn’t catch or can’t handle under normal circumstances.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种控制流中断 — *错误* — 指的是在正常情况下不应捕获或无法处理的严重问题。
- en: For example, if the runtime runs out of available memory, the runtime throws
    a `OutOfMemoryError`. Or an endless recursive call will eventually lead to a `StackOverflowError`.
    There’s nothing you can really do without any memory left, regardless of whether
    it’s the heap or the stack. Faulty hardware is another source for Java errors,
    like `java.io.IOError` in case of a disk error. These are all grave and not anticipated
    problems with almost no possibility of recovering gracefully. That’s why errors
    mustn’t adhere to the catch-or-specify requirement.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果运行时内存不足，运行时会抛出`OutOfMemoryError`。或者无限递归调用最终会导致`StackOverflowError`。在没有剩余内存的情况下，无论是堆还是栈都没有什么你可以做的。故障硬件是Java错误的另一个来源，例如磁盘错误的情况下会抛出`java.io.IOError`。这些都是严重且不可预料的问题，几乎没有可能优雅地恢复。这就是为什么错误不必遵循捕获或指定的要求。
- en: Exception Hierarchy in Java
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Java中的异常层次结构
- en: 'Which category an Exception falls into depends on its base class. All Exceptions
    are checked, except types subclassing `java.lang.RuntimeException` or `java.lang.Error`.
    But they share a common base type: `java.lang.Throwable`. Types inheriting from
    the latter two are either unchecked or an error. The type hierarchy is illustrated
    in [Figure 10-1](#_02-exception-handling_hierachy).'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 异常属于哪个类别取决于其基类。所有异常都是经过检查的，除了那些继承自`java.lang.RuntimeException`或`java.lang.Error`的类型。但它们共享一个共同的基类型：`java.lang.Throwable`。继承自后两者的类型要么是未经检查的，要么是一个错误。异常类型层次结构如[图 10-1](#_02-exception-handling_hierachy)所示。
- en: '![Hierarchy of Java Exception Types](assets/afaj_1001.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![Java异常类型的层次结构](assets/afaj_1001.png)'
- en: Figure 10-1\. Exceptions hierarchy in Java
  id: totrans-32
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10-1\. Java中的异常层次结构
- en: The concept of having different kinds of Exceptions is rather uncommon among
    programming languages, and it’s a controversial topic of discussion due to their
    different requirements of how to handle them. Kotlin^([2](ch10.xhtml#idm45115226777968)),
    for example, inherits the general mechanisms of handling Exceptions but doesn’t
    have any checked Exceptions.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程语言中有不同类型的异常的概念相当不常见，并且由于它们在处理方式上的不同需求，是一个有争议的讨论话题。例如，Kotlin^([2](ch10.xhtml#idm45115226777968))继承了处理异常的一般机制，但没有任何经过检查的异常。
- en: Checked Exceptions in Lambdas
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lambda表达式中的经过检查的异常
- en: Java’s Exception-handling mechanisms were designed to fulfill specific requirements
    at the time of its inception, 18 years before the introduction of lambdas. That’s
    why throwing and handling Exceptions don’t fit nicely into the new functional
    Java coding style without any special considerations or completely disregarding
    the catch-or-specify requirement.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Java的异常处理机制设计时考虑了特定的需求，这是在引入lambda 18年之前的事情。这就是为什么抛出和处理异常在新的函数式Java编码风格中不太适合的原因，除非特别考虑或完全忽略捕获或声明要求。
- en: 'Let’s take a look at loading the content of a file with a `static` method available
    on `java.util.Files` with the following method signature:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看使用`java.util.Files`上的静态方法加载文件内容的方法签名如下：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The method signature is quite simple and indicates that a checked `IOException`
    might get thrown, so a `try`-`catch`-block is required. That’s why the method
    can’t be used as a method reference, or in a simple lambda:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 方法签名非常简单，并且指示可能抛出检查的`IOException`，因此需要一个`try`-`catch`块。这就是为什么该方法不能作为方法引用或简单lambda使用的原因：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The problem stems from the functional interface required to satisfy the `map`
    operation. None of the functional interfaces of the JDK throw checked Exceptions
    and are, therefore, not compatible with any method that does.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 问题源自于满足`map`操作所需的函数式接口。JDK的函数式接口中没有一个抛出受检异常，因此它们与任何可能抛出异常的方法都不兼容。
- en: Note
  id: totrans-41
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: There are interfaces marked with @FunctionalInterface that throw Exceptions,
    like `java.util.concurrent.Callable<V>`. They *are* functional interfaces by definition,
    but it’s for compatibility reasons, not because they represent functional types
    to be used indiscriminately.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 有些被`@FunctionalInterface`标记的接口会抛出异常，比如`java.util.concurrent.Callable<V>`。它们从定义上来说是函数式接口，但这是为了兼容性考虑，而不是因为它们可以随意表示函数式类型。
- en: 'The most obvious solution is using `try`-`catch`-block by converting the lambda
    to a block-based one:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 最明显的解决方案是使用`try`-`catch`块，将lambda转换为基于块的形式：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The code required to satisfy the compiler defeats the purpose of Stream pipelines
    lambdas in general. The conciseness and straightforward representation of an operation
    is diluted by the required boilerplate for Exception handling.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 满足编译器要求的代码反而破坏了流式处理lambda的目的。操作的简洁性和直接性表达被异常处理所需的样板代码稀释了。
- en: Using Exceptions in lambdas almost feels like an anti-pattern. A `throws` declaration
    indicates that the caller has to decide how to handle that Exception, and lambdas
    don’t have a dedicated way of dealing with Exceptions except for the pre-existing
    `try-catch`, which can’t be used for method references.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在lambda中使用异常几乎感觉像是一种反模式。`throws`声明表明调用者必须决定如何处理该异常，而lambda没有专门处理异常的方式，除了预先存在的`try-catch`，这不能用于方法引用。
- en: 'Still, there are certain ways of dealing with Exceptions without losing (most
    of) the simplicity and clarity that lambdas, methods references, and pipelines
    like Streams or Optionals give you:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，仍然有某些处理异常的方式，可以在不失去（大部分）lambda、方法引用和流式处理（如Streams或Optionals）的简洁和清晰性的情况下使用：
- en: Safe method extraction
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全的方法提取
- en: Un-Checking Exceptions
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不检查异常
- en: Sneaky throws
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sneaky throws
- en: All these options are imperfect workarounds to mitigate Exception handling in
    functional code. Still, we will have a look at each of them because they can be
    useful in certain scenarios if you do not have a built-in way to deal with Exceptions
    properly.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些选项都是在函数式代码中缓解异常处理的不完美解决方案。尽管如此，我们将逐个查看它们，因为在某些情况下它们可能很有用，如果没有内置的正确处理异常的方式。
- en: The last two can even be treacherous or at least become a code smell if used
    unwisely. Nevertheless, knowing such “last resort” tools can help you navigate
    more difficult amalgamations of pre-existing, non-functional code, and give you
    a more functional approach.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两者甚至可能是危险的，或者至少会成为代码异味，如果不明智地使用。尽管如此，了解这样的“最后手段”工具可以帮助您处理更复杂的预先存在的非函数式代码结合，以及提供更加函数化的方法。
- en: Safe Method Extraction
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全的方法提取
- en: Efficiently handling Exceptions in your functional code depends on who effectively
    controls or owns the code. If the throwing code is entirely under your control,
    you should *always* adequately handle them. But often, the offending code is *not*
    yours, or you can’t change or refactor it as needed. That’s when you can still
    extract it into a “safer” method with appropriate local Exception handling.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式代码中高效处理异常取决于谁有效地控制或拥有代码。如果抛出异常的代码完全在您的控制范围内，您应该*始终*充分处理它们。但通常，冒犯的代码*不*是您自己的，或者您无法根据需要更改或重构它。这时，您仍然可以将其提取到一个具有适当局部异常处理的“更安全”的方法中。
- en: Creating a “safe” method decouples the actual work from handling any Exception,
    restoring the principle of the caller being responsible for any checked Exceptions.
    Any functional code can use the safe method instead, as shown in [Example 10-1](#_02-exception-handling_safe-wrapper).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个“安全”方法将实际工作与处理任何异常解耦，恢复了调用者负责处理任何已检查异常的原则。任何函数式代码都可以使用安全方法，如[Example 10-1](#_02-exception-handling_safe-wrapper)中所示。
- en: Example 10-1\. Extract throwing code into a safe method
  id: totrans-56
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 10-1\. 将抛出的代码提取到一个安全方法中
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[![1](assets/1.png)](#co_functional_exception_handling_CO1-1)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_functional_exception_handling_CO1-1)'
- en: The “safe” method has the same method signature except for the `throws IOException`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: “安全”方法具有与`throws IOException`不同的方法签名。
- en: '[![2](assets/2.png)](#co_functional_exception_handling_CO1-2)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_functional_exception_handling_CO1-2)'
- en: The Exception is dealt with locally and returns an appropriate fallback.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 异常在本地处理并返回适当的回退。
- en: '[![3](assets/3.png)](#co_functional_exception_handling_CO1-3)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_functional_exception_handling_CO1-3)'
- en: The wrapper method can be used as a method reference, making the code concise
    and readable again.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 包装器方法可以用作方法引用，使代码简洁且易读。
- en: '[![4](assets/4.png)](#co_functional_exception_handling_CO1-4)'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_functional_exception_handling_CO1-4)'
- en: The possibility of a `null` element must be handled accordingly.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 必须相应地处理`null`元素的可能性。
- en: The pipeline is concise and straightforward again. The `IOException` is handled
    in the sense that it doesn’t affect the pipeline, but this approach isn’t “one-size-fits-all.”
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 流水线再次简洁明了。`IOException`被处理，以使其不影响流水线，但这种方法并非“一刀切”。
- en: Note
  id: totrans-67
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注
- en: Safe method extraction is akin to a more localized version of the *facade pattern*⁠^([3](ch10.xhtml#idm45115226386080)).
    Instead of wrapping a whole class to provide a safer, context-specific interface,
    only specific methods get a new facade to improve their handling for particular
    use cases. That reduces the affected code and still gives you the advantages of
    a facade, like reduced complexity and improved readability. It’s also a good starting
    point for future refactoring efforts.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 安全方法提取类似于*外观模式*的更局部化版本⁠^([3](ch10.xhtml#idm45115226386080))。与包装整个类以提供更安全的、上下文特定接口不同，只有特定方法获得新外观以改进它们的处理以适应特定用例。这减少了受影响的代码量，但仍为您提供了外观的优点，如减少复杂性和提高可读性。这也是未来重构工作的良好起点。
- en: Extracted safe methods might be an improvement over using `try`-`catch` blocks
    in a lambda because you keep the expressiveness of inline-lambdas and method references
    and have a chance to handle any Exceptions. But the handling is confined in another
    abstraction over existing code to regain control of disruptive control-flow conditions.
    The actual caller of the method — the Stream operation — gets no chance to deal
    with the Exception, making the handling opaque and inflexible.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 提取的安全方法可能比在lambda中使用`try`-`catch`块更好，因为您保留了内联lambda和方法引用的表现力，并有机会处理任何异常。但是，处理被限制在另一个抽象层上的现有代码以恢复对干扰性控制流条件的控制。方法的实际调用者——流操作——没有处理异常的机会，使得处理不透明且不灵活。
- en: Un-Checking Exceptions
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 取消检查异常
- en: The next way to deal with checked Exceptions goes against the fundamental purpose
    of using checked Exceptions in the first place. Instead of dealing with a checked
    Exception directly, you hide it in an unchecked Exception to circumvent the catch-or-specify
    requirement. It’s a nonsensical, but effective way to make the compiler happy.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 处理已检查异常的下一种方法与最初使用已检查异常的基本目的背道而驰。不直接处理已检查异常，而是将其隐藏在未检查异常中以绕过捕获或指定要求。这是一个毫无意义但有效的使编译器满意的方法。
- en: This approach uses specialized functional interfaces that use the `throws` keywords
    to wrap the offending lambda or method reference. It catches the original Exception
    and rethrows it as an unchecked `RuntimeException`, or one of its siblings. These
    functional interfaces extend the original one to ensure compatibility. The original
    single-abstract method uses a `default` implementation to connect it to the throwing
    one, as shown in [Example 10-2](#_02-exception-handling_uncheck-exceptions).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法使用专门的功能接口，这些接口使用`throws`关键字来包装有问题的lambda或方法引用。它捕获原始异常并将其重新抛出为未检查的`RuntimeException`或其兄弟姐妹之一。这些功能接口扩展了原始接口，以确保兼容性。原始的单抽象方法使用一个`default`实现将其连接到抛出异常的方法，如[示例 10-2](#_02-exception-handling_uncheck-exceptions)所示。
- en: Example 10-2\. Unchecking `java.util.Function`
  id: totrans-73
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-2\. 取消检查`java.util.Function`
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[![1](assets/1.png)](#co_functional_exception_handling_CO2-1)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_functional_exception_handling_CO2-1)'
- en: The wrapper extends the original type to act as a drop-in replacement.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 包装器扩展了原始类型以充当可插入替换。
- en: '[![2](assets/2.png)](#co_functional_exception_handling_CO2-2)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_functional_exception_handling_CO2-2)'
- en: The single-abstract method (SAM) mimics the original but throws an `Exception`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 单抽象方法（SAM）模仿原始方法，但会抛出异常。
- en: '[![3](assets/3.png)](#co_functional_exception_handling_CO2-3)'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_functional_exception_handling_CO2-3)'
- en: The original SAM is implemented as a `default` method to wrap any `Exception`
    as a `RuntimeException`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的SAM被实现为一个`default`方法，用于将任何异常包装为`RuntimeException`。
- en: '[![4](assets/4.png)](#co_functional_exception_handling_CO2-4)'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_functional_exception_handling_CO2-4)'
- en: A `static` helper to uncheck any throwing `Function<T, U>` to circumvent the
    catch-or-specify requirement.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`static`助手用于取消检查任何抛出的`Function<T, U>`，以规避捕获或指定的要求。
- en: The `ThrowingFunction<T, U>` type can either be used explicitly by calling the
    `uncheck` method or implicitly as seen in [Example 10-3](#_02-exception-handling_uncheck-exceptions_how-to-use).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`ThrowingFunction<T, U>`类型可以通过调用`uncheck`方法显式使用，也可以像在[示例 10-3](#_02-exception-handling_uncheck-exceptions_how-to-use)中看到的那样隐式使用。'
- en: Example 10-3\. Using `ThrowingFunction<T, U>`
  id: totrans-84
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-3\. 使用`ThrowingFunction<T, U>`
- en: '[PRE8]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[![1](assets/1.png)](#co_functional_exception_handling_CO3-1)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_functional_exception_handling_CO3-1)'
- en: Any throwing method is assignable as a `ThrowingFunction` via a method reference
    and used in a context requiring a `Function`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 任何抛出异常的方法都可以通过方法引用分配为`ThrowingFunction`，并在需要`Function`的上下文中使用。
- en: '[![2](assets/2.png)](#co_functional_exception_handling_CO3-2)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_functional_exception_handling_CO3-2)'
- en: Alternatively, a throwing lambda or method reference can be unchecked on the
    fly by using the `static` helper `uncheck`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，可以通过使用`static`助手`uncheck`来即时取消检查的抛出lambda或方法引用。
- en: Congratulations, the compiler is happy again and won’t force you to handle the
    Exception anymore. The wrapper type doesn’t fix the original problem of possible
    control flow disruption but hides it from plain sight. The Stream pipeline will
    still blow up if any Exception occurs without any possibility for localized Exception
    handling.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜，编译器再次欣然接受，并且不再强制您处理异常。包装器类型没有解决原始可能导致控制流中断的问题，但将其隐藏在视线之外。如果流水线中出现任何异常，仍会爆炸，而没有任何可能的本地化异常处理。
- en: Warning
  id: totrans-91
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Exception-throwing functional interfaces only disguise their exceptional states.
    They have their place and can be quite useful, but shouldn’t be considered a go-to
    solution instead of a last resort.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 抛出异常的功能接口只是掩盖其异常状态。它们有其用途并且可能非常有用，但不应该被视为首选解决方案，而应该作为最后的手段。
- en: Sneaky Throws
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隐式抛出异常
- en: The *sneaky throws* idiom is a hack to throw a checked Exception without declaring
    it with the `throws` keyword in a method’s signature.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*隐式抛出异常*习语是一种方法，用于在方法签名中不声明`throws`关键字的情况下抛出已检查的异常。'
- en: 'Instead of throwing a checked Exception using the `throw` keyword in a method’s
    body, which requires a `throws` declaration in the method signature, the actual
    Exception is thrown by another method, as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是在方法体中使用`throw`关键字抛出已检查的异常，这要求在方法签名中使用`throws`声明，实际异常是通过另一个方法抛出的，如下所示：
- en: '[PRE9]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The actual throwing of the Exception is delegated to the `sneakyThrow` method.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的异常抛出被委托给`sneakyThrow`方法。
- en: Wait a minute, doesn’t anyone using a method throwing a checked Exception, like
    `sneakyThrow`, have to adhere to the catch-or-specify requirement?
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 等等，难道使用像`sneakyThrow`这样的方法抛出已检查的异常的人不必遵循捕获或指定的要求吗？
- en: 'Well, there’s one exception to the rule (pun intended). You can take advantage
    of a change^([4](ch10.xhtml#idm45115226007984)) in Java’s type inference regarding
    Generics and Exceptions in Java 8. In simple terms, if there are no upper or lower
    bounds on a generic method signature with `throws E`, the compiler assumes the
    type `E` to be a `RuntimeException`. This allows you to create the following `sneakyThrow`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，这里有一个例外（双关语）。你可以利用Java 8关于泛型和异常的类型推断的变化^([4](ch10.xhtml#idm45115226007984))。简单来说，如果一个泛型方法签名没有上限或下限，并且有`throws
    E`，编译器会假定类型`E`是`RuntimeException`。这使你可以创建以下的`sneakyThrow`：
- en: '[PRE10]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Regardless of the actual type for the argument `e`, the compiler assumes `throws
    E` to be a `RuntimeException` and thereby exempts the method from the catch-or-specify
    requirement. The compiler might not complain, but this approach is highly problematic.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 不管参数`e`的实际类型如何，编译器都假定`throws E`是`RuntimeException`，从而豁免了方法的捕获或指定要求。编译器可能不会抱怨，但这种方法是非常有问题的。
- en: The method signature of `sneakyRead` no longer signifies its checked Exception.
    Checked Exceptions are supposed to be anticipated and recoverable, and therefore,
    belong to the method’s public contract. By removing the `throws` keyword and circumventing
    the catch-or-specify requirement, you reduce the amount of information conferred
    to the caller by making the method’s public contract more opaque for convenience
    reasons. You still could — and should — list all Exceptions and their reasoning
    in the method’s documentation.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`sneakyRead`的方法签名不再表示其已检查的异常。已检查的异常应该被预期并且是可恢复的，因此属于方法的公共契约。通过删除`throws`关键字并规避捕获或指定的要求，你减少了传给调用者的信息量，使方法的公共契约更为不透明，以便获得便利性的原因。你仍然可以——而且应该——在方法的文档中列出所有异常及其原因。'
- en: The method no longer follows “normal reasoning” by bypassing the `throws` keyword
    and the enforcement of the catch-or-specify requirement. Anyone reading the code
    has to know what `sneakyThrow` does. You could add an appropriate `return` statement
    after the call to at least convey that it’s an exit point. But the significance
    that a `throws` keyword emits is lost.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法不再遵循通过绕过`throws`关键字和强制执行捕获或指定要求的“正常推理”。阅读代码的任何人都必须知道`sneakyThrow`的作用。你可以在调用后添加一个适当的`return`语句，至少表明这是一个退出点。但是失去了`throws`关键字所发出的意义。
- en: Warning
  id: totrans-104
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Sneaky throws circumvent an integral part of the Java language of how to deal
    with control flow disruptions. There is a place for it in a few edge cases for
    internal implementations. In external code, however, like `public` methods, throwing
    Exceptions sneakily breaks the reasonably expected contract between the method
    and the caller any Java developer would anticipate.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Sneaky throws绕过了Java语言处理控制流中的一个重要部分。在一些内部实现的边缘情况下是有用的。然而，在像`public`方法这样的外部代码中，悄悄地抛出异常会打破任何Java开发者都能预期到的合理预期的方法和调用者之间的契约。
- en: Sneakily throwing Exceptions might be an acceptable “last resort” hack for internal
    code, but you still have to communicate the implications with the help of the
    context, method names, and documentation. In the next section, I show you an acceptable
    use case for sneakily throwing an Exception in a specialized implementation for
    internal code.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 悄悄地抛出异常可能是内部代码的可接受的“最后手段”黑客方法，但你仍然必须通过上下文、方法名称和文档来传达其影响。在下一节中，我将展示一个在专门的内部代码实现中悄悄地抛出异常的合理用例。
- en: A Functional Approach to Exceptions
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常的功能性方法
- en: So far, I’ve only discussed how to “brute force” Java’s Exception handling mechanics
    to play nice with lambdas by ignoring and circumventing the intended purpose of
    Exceptions. What’s really needed is finding a reasonable compromise and balance
    between a functional approach and the more traditional constructs.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我只讨论了如何通过忽略和规避异常的预期目的来“强制执行”Java的异常处理机制，使其与Lambda表达式协同工作。真正需要的是在功能性方法和传统构造之间找到一个合理的折衷和平衡。
- en: Your options include designing your code to not throw Exceptions at all or mimicking
    the Exception-handling approaches of other more functional languages.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你的选择包括设计你的代码根本不抛出异常，或者模仿其他更为功能性语言的异常处理方法。
- en: Not Throwing Exceptions
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不抛出异常
- en: Checked Exceptions are an integral part of a method’s contract and are designed
    as control flow disruptions. That’s what makes it so difficult to deal with them
    in the first place! So, instead of finding a better way of handling checked Exceptions
    and all of their complications, we can instead find an alternative way of dealing
    with control flow disruption in a functional context.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[“Safe Method Extraction”](#_02-exception-handling_safe-method-extraction)
    discussed a variant of not throwing Exceptions by wrapping an Exception-throwing
    method with a non-throwing “safer” method. This approach helps if you don’t have
    control over the code and can’t design it to not throw any Exceptions in the first
    place. It replaces disruptive control flow events in the form of Exceptions with
    another value to represent an “exceptional” state: `Optional<T>`. If you have
    control over the API, you could design its contracts not to use Exceptions or
    make them at least more manageable. Exceptions are a reaction to some form of
    illegal state. The best way to avoid Exception handling is to make the representation
    of such an illegal state impossible in the first place.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: I discussed in [Chapter 9](ch09.xhtml#_02-optionals) that Optionals are a “box”
    to wrap an actual value. It’s a specialized type representing the presence or
    absence of values without risking encountering a `null` reference and the eventually
    dreaded `NullPointerException`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at the previous example again. This time, however, let’s use an Optional
    instead of throwing an Exception, as seen in [Example 10-4](#_02-exception-handling_optional-vs-exception).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-4\. Using `Optional<String>` instead of throwing an `IOException`
  id: totrans-115
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[![1](assets/1.png)](#co_functional_exception_handling_CO4-1)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: An `Optional<String>` is used instead of a plain `String`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_functional_exception_handling_CO4-2)'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: By returning an `Optional<String>`, either with the file content or an empty
    one in the case of an `IOException`, a valid non-`null` object is returned.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Returning an `Optional<String>` has two advantages over simply returning `String`.
    First, a valid object is returned, so no additional `null`-checks are required
    to use it safely. Second, the Optional type is a starting point for a fluent functional
    pipeline to deal with the inner value, or its absence.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: If your API doesn’t expose any illegal states requiring control flow disruptions,
    you, or anyone else calling such methods, don’t have to handle them. Optionals
    are a simple and readily available choice, although it lacks some desirable features.
    The new `safeReadString` conveys that it wasn’t able to read the file but doesn’t
    tell you *why* it wasn’t able to do so.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Errors as Values
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Where `Optional<T>` only provides the difference between the presence and absence
    of a value, a dedicated *result object* conveys more information about *why* an
    operation might have failed. The concept of dedicated type representing the overall
    result of an operation isn’t a new one. They are wrapper objects indicating whether
    or not an operation was a success and include a value or, if unsuccessful, a reason
    why not. Many languages support dynamic tuples as return types, so you don’t need
    an explicit type representing your operation, like in Go:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`Optional<T>` 仅提供值的存在与不存在之间的差异，而专用的 *结果对象* 提供了关于为什么操作可能失败的更多信息。表示操作整体结果的专用类型的概念并不新鲜。它们是包装对象，指示操作是否成功，并包括一个值或者如果不成功，原因。许多语言支持动态元组作为返回类型，因此你不需要像在
    Go 中那样显式地表示你的操作类型：'
- en: '[PRE12]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Even though Java lacks such dynamic tuples, thanks to Generics, a versatile
    and functionally inclined result type can be created that leverages tools and
    concepts discussed in this book.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Java 缺乏这样的动态元组，但通过泛型，可以创建一个多功能且功能倾向的结果类型，利用本书讨论的工具和概念。
- en: Let’s create a rudimentary `Result<V, E extends Throwable>` type together.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一起创建一个基本的 `Result<V, E extends Throwable>` 类型。
- en: Creating the Scaffold
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建支架
- en: The main goal of the `Result` type is to hold a possible value or, if not successful,
    an Exception representing the reason for failure.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`Result` 类型的主要目标是保存可能的值，或者如果不成功，则保存表示失败原因的异常。'
- en: A “traditional” result object could be implemented as a Record as shown in [Example 10-5](#_02-exception-handling_result-type-01).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: “传统”结果对象可以像在 [Example 10-5](#_02-exception-handling_result-type-01) 中展示的记录一样实现。
- en: Example 10-5\. Traditional Result Object
  id: totrans-131
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 10-5\. 传统的 Result 对象
- en: '[PRE13]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[![1](assets/1.png)](#co_functional_exception_handling_CO5-1)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_functional_exception_handling_CO5-1)'
- en: The Record components reflect the different states. The explicit `isSuccess`
    field helps to better determine a successful operation and to support `null` as
    a valid value.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 记录组件反映了不同的状态。显式的 `isSuccess` 字段有助于更好地确定操作是否成功，并支持 `null` 作为有效值。
- en: '[![2](assets/2.png)](#co_functional_exception_handling_CO5-2)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_functional_exception_handling_CO5-2)'
- en: Convenience factory methods provide a more expressive API.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 方便的工厂方法提供了更表现力的 API。
- en: Even this simple scaffold provides a certain improvement over using Optionals
    already, with the convenience factory methods being an expressive way to create
    appropriate results.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 即使这个简单的支架已经比使用 Optional 提供了一定的改进，方便的工厂方法是创建适当结果的表达性方式。
- en: The previous examples of `safeReadString` can be easily converted to use the
    `Result<V,E>` type, as shown in [Example 10-6](#_02-exception-handling_result-type-02)
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 先前的 `safeReadString` 示例可以很容易地转换为使用 `Result<V,E>` 类型，如 [Example 10-6](#_02-exception-handling_result-type-02)
    中所示。
- en: Example 10-6\. Using `Result<V, E>` as a return type
  id: totrans-139
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 10-6\. 使用 `Result<V, E>` 作为返回类型
- en: '[PRE14]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The new type is just as easy to use in a Stream pipeline as an Optional. But
    the real power comes from giving it more functional properties by introducing
    higher-order functions that depend on the success state.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这种新类型在流管道中使用起来与 Optional 一样简单。但真正的力量来自于通过引入依赖于成功状态的高阶函数，赋予它更多的功能属性。
- en: Making Result<V, E> Functional
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使 Result<V, E> 具有功能性
- en: 'The general features of the `Optional<T>` type are the inspiration on how to
    improve the `Result` type further, including:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`Optional<T>` 类型的一般特性为进一步改进 `Result` 类型提供了灵感，包括：'
- en: Transforming its value or Exception
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换其值或异常
- en: Reacting to an Exception
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对异常的反应
- en: Providing a fallback value
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供回退值
- en: Transforming the `value` or `throwable` field requires dedicated `map` methods
    or a combined one to handle both use cases at once, as shown in [Example 10-7](#_02-exception-handling_result-type-03).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 转换 `value` 或 `throwable` 字段需要专用的 `map` 方法或组合方法来同时处理两种用例，如 [Example 10-7](#_02-exception-handling_result-type-03)
    中所示。
- en: Example 10-7\. Adding Transformers to `Result<V, E>`
  id: totrans-148
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 10-7\. 向 `Result<V, E>` 添加转换器
- en: '[PRE15]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[![1](assets/1.png)](#co_functional_exception_handling_CO6-1)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_functional_exception_handling_CO6-1)'
- en: The singular mapping methods are quite similar and transform the respective
    result, success or failure. That’s why both must return an `Optional` instead
    of a concrete value.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这些单一映射方法非常相似，并转换相应的结果，成功或失败。这就是为什么两者必须返回一个 `Optional` 而不是具体值的原因。
- en: '[![2](assets/2.png)](#co_functional_exception_handling_CO6-3)'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_functional_exception_handling_CO6-3)'
- en: A combined `map` method allows you to handle both cases, success or failure,
    in a single call. Because both states are handled, a concrete value instead of
    an `Optional` is returned.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 通过组合的`map`方法，您可以在单个调用中处理成功或失败的两种情况。因为两种状态都被处理了，所以返回的是一个具体的值，而不是`Optional`。
- en: 'With the help of the mapper methods, you can now handle either one or both
    cases directly, as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在映射方法的帮助下，现在您可以直接处理其中一个或两个情况，如下所示：
- en: '[PRE16]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: There also needs to be a way to work with a `Result` without requiring to transform
    its value or Exception first.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要一种方法来处理`Result`，而无需首先转换其值或异常。
- en: 'To react to a certain state, let’s add `ifSuccess`, `ifFailure`, and `handle`,
    as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 为了对特定状态做出反应，让我们添加`ifSuccess`，`ifFailure`和`handle`，如下所示：
- en: '[PRE17]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The implementation is almost equivalent to the mapper methods, except they use
    a `Consumer` instead of a `Function`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 实现几乎与映射方法相同，只是它们使用`Consumer`而不是`Function`。
- en: Note
  id: totrans-160
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: These two additions are side-effect-only and, therefore, not very “functional”
    in the purest sense. Nevertheless, such additions provide an excellent stopgap
    between imperative and functional approaches.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个附加功能仅限于副作用，因此在纯函数意义上并不是非常“函数式”。尽管如此，这些附加功能在命令式和函数式方法之间提供了一个很好的权宜之计。
- en: 'Next, let’s add convenience methods for providing fallback values. The most
    obvious ones are `orElse` and `orElseGet`, as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们添加一些方便的方法来提供回退值。最明显的是`orElse`和`orElseGet`，如下所示：
- en: '[PRE18]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: No surprises here.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么意外。
- en: 'However, adding an `orElseThrow` as a shortcut to re-throw the inner `Throwable`
    isn’t as straightforward because it still has to adhere to the catch-or-specify
    requirement. This is actually the one acceptable use case I talked about earlier
    about using a “sneaky throw,” as discussed in [“Sneaky Throws”](#_02-exception-handling_sneaky-throws),
    to circumvent the requirement:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，作为重新抛出内部`Throwable`的快捷方式添加`orElseThrow`并不是那么直接，因为它仍然必须遵守捕获或指定的要求。这实际上是我之前提到过的有关使用“偷偷抛出”的唯一可接受的用例，如在[“偷偷抛出”](#_02-exception-handling_sneaky-throws)中讨论的那样，以规避此要求：
- en: '[PRE19]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this particular case, a “sneaky throw” is justified in my opinion due to
    the general context and public contract of `orElseThrow()`. Like with `Optional<T>`,
    the method force-unwraps the “box” holding a possible result and warns you about
    a possible exception with its name.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种特定情况下，由于`orElseThrow()`的一般上下文和公共契约，我认为“偷偷抛出”是合理的。就像`Optional<T>`一样，该方法强制解开可能结果的“盒子”，并用其名称警告您可能发生的异常。
- en: There’s a lot left to be desired, like adding a `Stream<V> stream()` method
    for even better integration into Stream pipelines. Still, the general approach
    was a great exercise on how to combine functional concepts to provide an alternative
    to handling disruptive control flow events. The implementation shown in this book
    is quite simplistic and reduced to a minimal amount of code.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 还有很多可以期待的地方，比如添加一个`Stream<V> stream()`方法，以便更好地集成到Stream流水线中。尽管如此，这种一般方法是如何结合函数概念以提供一种处理破坏性控制流事件的替代方法的良好实践。本书中展示的实现非常简化，并减少到最少的代码量。
- en: If you intend to use a type like `Result<V, E>`, you should check out one of
    the functional libraries of the Java ecosystem. Projects like [vavr](https://www.vavr.io),
    [jOOλ](https://github.com/jOOQ/jOOL) (pronounced “JOOL”), and [Functional Java](https://www.functionaljava.org)
    provide quite comprehensive and battle-tested implementations ready to use.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您打算使用类似`Result<V, E>`的类型，您应该查看Java生态系统中的某个函数库。像[vavr](https://www.vavr.io)，[jOOλ](https://github.com/jOOQ/jOOL)（发音为“JOOL”）和[Functional
    Java](https://www.functionaljava.org)这样的项目提供了非常全面和经过实战检验的实现，可以直接使用。
- en: The Try/Success/Failure Pattern
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试/成功/失败模式
- en: Scala is arguably the closest functional relative to Java available on the JVM,
    not considering Clojure due to its more foreign syntax and dynamic type system.
    It addresses many of Java’s perceived “shortcomings” over younger languages and
    is functional at its core, including an excellent way of dealing with exceptional
    conditions.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Scala可以说是JVM上可用的最接近Java的函数式语言，不考虑Clojure，因为后者具有更外来的语法和动态类型系统。它解决了许多Java被认为有的“缺陷”，并且从根本上是函数式的，包括处理异常条件的优秀方式。
- en: The *Try/Success/Failure* pattern and its related types `Try[+T]`⁠^([5](ch10.xhtml#idm45115224366432)),
    `Success[+T]`, and `Failure[+T]`, are Scala’s way of dealing with Exceptions in
    a more functional fashion.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '*尝试/成功/失败*模式及其相关类型`Try[+T]`⁠^([5](ch10.xhtml#idm45115224366432))，`Success[+T]`和`Failure[+T]`，是Scala处理异常的一种更函数式方式。'
- en: Where an `Optional<T>` indicates that a value might be missing, `Try[+T]` can
    tell you *why* and gives you the possibility to handle any occurred Exception,
    similar to the `Result` type discussed earlier in this chapter. If the code succeeds,
    a `Success[+T]` object is returned, and if it fails, the error will be contained
    in a `Failure[+T]` object. Scala also supports *pattern-matching*, a `switch`-like
    concept of handling different outcomes. That allows for quite concise and straightforward
    Exception handling without the usual boilerplate a Java developer is used to.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`Optional<T>` 表示值可能丢失，而 `Try[+T]` 可以告诉你 *为什么* 并提供处理任何发生的异常的可能性，类似于本章前面讨论的 `Result`
    类型。如果代码成功，将返回一个 `Success[+T]` 对象，如果失败，错误将包含在一个 `Failure[+T]` 对象中。Scala 还支持 *模式匹配*，一种处理不同结果的
    `switch`-like 概念。这允许相当简洁直接的异常处理，而无需 Java 开发者通常习惯的样板代码。'
- en: Note
  id: totrans-174
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Scala-like pattern matching for Java’s `switch` construct is available as a
    preview feature^([6](ch10.xhtml#idm45115224250464)) since Java 17.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 自 Java 17 起，Java 的 `switch` 结构可以使用类似 Scala 的模式匹配作为预览功能^([6](ch10.xhtml#idm45115224250464))。
- en: A `Try[+T]` can either be in a `Success[+T]` or `Failure[+T]` state, with the
    latter containing a `Throwable`. Even without full knowledge of Scala’s syntax,
    the code in [Example 10-8](#_02-exception-handling_try-success-failure) shouldn’t
    be too foreign to a Java developer.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`Try[+T]` 可以处于 `Success[+T]` 或 `Failure[+T]` 状态，后者包含一个 `Throwable`。即使没有完全了解
    Scala 语法，[示例 10-8](#_02-exception-handling_try-success-failure) 中的代码对于 Java 开发者来说也不应该太陌生。'
- en: Example 10-8\. Scala’s Try/Success/Failure pattern
  id: totrans-177
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-8\. Scala 的 Try/Success/Failure 模式
- en: '[PRE20]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[![1](assets/1.png)](#co_functional_exception_handling_CO7-1)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_functional_exception_handling_CO7-1)'
- en: The return type is `Try[String]`, so the method must either return a `Success[String]`
    containing the content of the `Path`, or a `Failure[Throwable]`. Scala doesn’t
    need an explicit `return` and returns the last value implicitly. Any Exception
    is caught by the `Try { …​ }` construct.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 返回类型是 `Try[String]`，所以该方法必须返回一个包含 `Path` 内容的 `Success[String]`，或者一个 `Failure[Throwable]`。Scala
    不需要显式的 `return` 并隐式地返回最后一个值。任何异常都会被 `Try { …​ }` 结构捕获。
- en: '[![2](assets/2.png)](#co_functional_exception_handling_CO7-2)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_functional_exception_handling_CO7-2)'
- en: Scala’s pattern matching simplifies the result handling. The cases are lambdas,
    and the whole block is similar to an Optional call chain with a `map` and a `orElse`
    operation.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 的模式匹配简化了结果处理。案例是 lambdas，并且整个块类似于带有 `map` 和 `orElse` 操作的 Optional 调用链。
- en: '[![3](assets/3.png)](#co_functional_exception_handling_CO7-3)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_functional_exception_handling_CO7-3)'
- en: '`Success` provides access to the return value.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`Success` 提供对返回值的访问。'
- en: '[![4](assets/4.png)](#co_functional_exception_handling_CO7-4)'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_functional_exception_handling_CO7-4)'
- en: If an Exception occurs, it’s handled by the `Failure` case.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生异常，将通过 `Failure` 情况处理。
- en: '`Try[+A]` is an excellent Scala feature, combining concepts similar to Optionals
    and Exception handling into a single, easy-to-use type and idiom. But what does
    that mean for you as a Java developer?'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`Try[+A]` 是 Scala 中的一个优秀特性，将类似于 Optional 和异常处理的概念结合到一个简单易用的类型和习惯用法中。但作为 Java
    开发者，这对你意味着什么呢？'
- en: Java doesn’t provide anything out-of-the-box that comes even close to the simplicity
    or language integration of Scala’s try/success/failure pattern.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Java 没有提供任何类似 Scala try/success/failure 模式的简单性或语言集成性。
- en: Even without language support, you can still try to implement an approximation
    of the try/success/failure pattern with the new functional tools since Java 8.
    So let’s do that now.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 即使没有语言支持，你仍然可以尝试使用自 Java 8 以来的新功能工具来实现对 try/success/failure 模式的近似。所以现在让我们来做吧。
- en: Creating a Pipeline
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个流水线
- en: Similar to how Streams provide a launch pad for a functional pipeline, the `Try`
    type we’re going to create will have a creation step, intermediate, but independent
    operations, and finally, a terminal operation to kickstart the pipeline.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 与流提供功能管道的起点类似，我们即将创建的 `Try` 类型将具有创建步骤、中间但独立的操作以及最后的终端操作来启动管道。
- en: To replicate Scala’s functionality, a construct accepting a lambda is needed
    as a starting point.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 要复制 Scala 的功能，需要一个接受 lambda 的结构作为起点。
- en: Note
  id: totrans-193
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: As with other functional constructs, many variants would be needed to support
    the various available functional interfaces. To simplify the required code, the
    `Try` type only supports `Function<T, R>` as the initial lambda.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他功能构造一样，需要许多变体来支持各种可用的功能接口。为了简化所需的代码，`Try` 类型仅支持 `Function<T, R>` 作为初始 lambda。
- en: 'The main requirements of the `Try` type are:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`Try`类型的主要要求包括：'
- en: Accepting a possibly throwing lambda
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受可能会抛出异常的lambda
- en: Providing a `success` operation
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供`success`操作
- en: Providing a `failure` operation
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供`failure`操作
- en: Starting the pipeline with a value
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用一个值开始管道
- en: The `Try` type could be simplified by only supporting `RuntimeException`, but
    then, it wouldn’t be a flexible alternative to regular `try`-`catch`-block. To
    circumvent the catch-or-specify requirement, the `ThrowingFunction` interface
    discussed in [“Un-Checking Exceptions”](#_02-exception-handling_unchecking-exceptions).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`Try`类型可以通过仅支持`RuntimeException`来简化，但这样就不会成为常规`try`-`catch`块的灵活替代。为了规避捕获或指定的要求，讨论的`ThrowingFunction`接口在["异常的取消检查"](#_02-exception-handling_unchecking-exceptions)中讨论。'
- en: The minimum scaffold required to accept `ThrowingFunction` and a possible `Function`
    to handle any a `RuntimeException` is shown in [Example 10-9](#_02-exception-handling_try-success-failure-01).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 接受`ThrowingFunction`和可能的`Function`来处理`RuntimeException`的最小支架如[示例 10-9](#_02-exception-handling_try-success-failure-01)所示。
- en: Example 10-9\. Minimal `Try<T, R>` accepting a lambda and Exception handler
  id: totrans-202
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-9\. 最小的`Try<T, R>`接受lambda和异常处理程序
- en: '[PRE21]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[![1](assets/1.png)](#co_functional_exception_handling_CO8-1)'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_functional_exception_handling_CO8-1)'
- en: The Generic types `T` and `R` correspond to `Function<T, R>`. A `class` is used
    instead of a `record` to hide the sole constructor.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型类型`T`和`R`对应于`Function<T, R>`。使用`class`而不是`record`来隐藏唯一的构造函数。
- en: '[![2](assets/2.png)](#co_functional_exception_handling_CO8-2)'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_functional_exception_handling_CO8-2)'
- en: The construct needs to hold the initial `Function<T, R>` and a possible error
    handling `Function<RuntimeException, R>`. Both fields are `final`, making the
    `Try` type immutable.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 构造需要保存初始的`Function<T, R>`和可能的错误处理`Function<RuntimeException, R>`。这两个字段都是`final`，使得`Try`类型是不可变的。
- en: '[![3](assets/3.png)](#co_functional_exception_handling_CO8-4)'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_functional_exception_handling_CO8-4)'
- en: The `static` factory method `of` provides a similar interface as other functional
    pipelines. It accepts a `ThrowingFunction<T, R>` to circumvent the catch-or-specify
    requirement, but assigns it immediately to a `Function<T, R>`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`static`工厂方法`of`提供了与其他函数管道类似的接口。它接受一个`ThrowingFunction<T, R>`来规避捕获或指定的要求，但立即将其分配给一个`Function<T,
    R>`。'
- en: '[![4](assets/4.png)](#co_functional_exception_handling_CO8-5)'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_functional_exception_handling_CO8-5)'
- en: The `private` constructor enforces the use of the factory method.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`private`构造函数强制使用工厂方法。'
- en: 'Even though the type doesn’t do anything, creating a new pipeline from an existing
    lambda or method reference is pretty straightforward, as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 即使类型不起作用，从现有的lambda或方法引用创建新的管道也非常简单，如下所示：
- en: '[PRE22]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The type hints in front of the `of` call are required because the compiler can’t
    necessarily infer the type from the surrounding context.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`of`调用前的类型提示是必需的，因为编译器不能从周围的上下文中推断出类型。'
- en: Next, the type needs to handle success and failure.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，该类型需要处理成功和失败。
- en: Handling Success and Failure
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理成功和失败
- en: Two new methods are needed to handle the outcome of the `Try` pipeline, `success`
    and `failure`, as seen in [Example 10-10](#_02-exception-handling_try-success-failure-02).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 需要两个新方法来处理`Try`管道的结果，即`success`和`failure`，如[示例 10-10](#_02-exception-handling_try-success-failure-02)中所示。
- en: Example 10-10\. Handling success and failure in `Try<T, R>`
  id: totrans-218
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-10\. 在`Try<T, R>`中处理成功和失败
- en: '[PRE23]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[![1](assets/1.png)](#co_functional_exception_handling_CO9-1)'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_functional_exception_handling_CO9-1)'
- en: The `successFn` is composed to the original lambda to provide the base for the
    new `Try` instance. The `failureFn` is used as-is.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`successFn`被组合到原始的lambda中，为新的`Try`实例提供基础。`failureFn`则按原样使用。'
- en: '[![2](assets/2.png)](#co_functional_exception_handling_CO9-2)'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_functional_exception_handling_CO9-2)'
- en: Handling an error requires only passing through the original `fn` and the provided
    `failureFn`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 处理错误只需要通过原始的`fn`和提供的`failureFn`。
- en: Because the `Try` type is designed to be immutable, both handling methods return
    a new instance of `Try`. The `success` method uses functional composition to create
    the fully required task, whereas the `failure` method creates a new `Try` instance
    with the pre-existing lambda and the provided error handling `Function`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`Try`类型设计为不可变的，两个处理方法都返回一个新的`Try`实例。`success`方法使用函数组合来创建完全所需的任务，而`failure`方法则使用预先存在的lambda和提供的错误处理`Function`创建一个新的`Try`实例。
- en: By using functional composition for the `success` operation instead of an extra
    control path, like storing `successFn` in another field, the handler isn’t even
    required in case of no modifications to the result of the initial lambda.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用功能组合来进行`success`操作，而不是使用额外的控制路径，例如将`successFn`存储在另一个字段中，即使在没有对初始lambda的结果进行修改的情况下，也不需要处理程序。
- en: 'Using the handler methods is as you would expect and feels similar to working
    with a Stream’s intermediate operations, as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 使用处理程序方法就像您所期望的那样，并且感觉与使用流（Stream）的中间操作类似，如下所示：
- en: '[PRE24]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Unlike a Stream, though, the operations are independent of one another and not
    in a sequential pipeline. It’s more akin to how an Optionals pipeline seems to
    be sequential but actually has tracks to follow. Which handling operation, `success`
    or `failure`, is supposed to be evaluated depends on the state of the `Try` evaluation.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 不过与流（Stream）不同的是，这些操作是彼此独立的，不是顺序管道。这更类似于可选值（Optionals）管道似乎是顺序的，但实际上有要遵循的轨迹。哪个处理操作，`success`或`failure`，应该进行评估取决于`Try`评估的状态。
- en: It’s time to kickstart the pipeline.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候启动管道了。
- en: Running the Pipeline
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行管道
- en: The last operation needed to complete the pipeline is the ability to push a
    value down the pipeline and let the handlers do their work, in the form of an
    `apply` method, as shown in [Example 10-11](#_02-exception-handling_try-success-failure-apply).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 完成管道所需的最后一个操作是能够将值推送到管道下游并让处理程序完成其工作，形式上为一个`apply`方法，如[示例 10-11](#_02-exception-handling_try-success-failure-apply)所示。
- en: Example 10-11\. Applying a value to `Try`
  id: totrans-232
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-11. 将值应用于`Try`
- en: '[PRE25]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[![1](assets/1.png)](#co_functional_exception_handling_CO10-1)'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_functional_exception_handling_CO10-1)'
- en: The “happy path” is appyling `fn` to the value. Thanks to designing the `success`
    method as functional composition, no special handling is needed to run the initial
    lambda and optional `success` transformation. The code has to be run in a `try`-`catch`-block
    to handle the `failure` case.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: “快乐路径”是将`fn`应用于值。由于将`success`方法设计为函数组合，因此不需要特殊处理来运行初始lambda和可选的`success`转换。代码必须在`try`-`catch`-block中运行以处理`failure`情况。
- en: '[![2](assets/2.png)](#co_functional_exception_handling_CO10-2)'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_functional_exception_handling_CO10-2)'
- en: Failure handling is optional, so a `null`-check is necessary.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 失败处理是可选的，因此需要进行`null`检查。
- en: '[![3](assets/3.png)](#co_functional_exception_handling_CO10-3)'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_functional_exception_handling_CO10-3)'
- en: This point is the ultimate fallback if no error handler was added to the pipeline.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果管道中没有添加错误处理程序，则此点是终极回退。
- en: The return type `Optional<R>` provides another lift-off point for a functional
    pipeline.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 返回类型`Optional<R>`为功能管道提供了另一个起点。
- en: 'Now our minimalistic `Try` pipeline has all the operations needed to call a
    throwing method and handle both the success and failure cases:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的极简`Try`管道已经包含了调用一个可能抛出异常的方法并处理成功和失败情况所需的所有操作：
- en: '[PRE26]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Even though the `Try` pipeline gives you higher-order function operations to
    deal with a throwing lambda, the pipeline itself isn’t functional on the outside.
    Or is it?
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 即使`Try`管道提供了高阶函数操作来处理可能抛出异常的lambda，但管道本身在外部并不是功能性的。还是吗？
- en: 'The name, `apply`, I’ve chosen for the terminal operation reveals the possible
    functional interface that `Try` could implement to be more easily usable in other
    functional pipelines like Streams or Optionals: `Function<T, Optional<R>>`.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择的终端操作名称`apply`揭示了`Try`可能实现的功能接口，以便在其他功能管道中更容易使用，如流（Streams）或可选值（Optionals）：`Function<T,
    Optional<R>>`。
- en: 'By implementing the functional interface the `Try` type becomes a drop-in replacement
    for any `Function` without requiring actual logic changes, as shown in [Example 10-12](#_02-exception-handling_try-success-failure-function):'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实现功能接口，`Try`类型变成了任何`Function`的即插即用替代品，无需实际逻辑更改，如[示例 10-12](#_02-exception-handling_try-success-failure-function)所示：
- en: Example 10-12\. Implementing `Function<T, Optional<R>>`
  id: totrans-246
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-12. 实现`Function<T, Optional<R>>`
- en: '[PRE27]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, any `Try` pipeline is easily usable in any higher-order function that
    accepts a `Function`, like in a Stream `map` operation, as follows:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，任何`Try`管道都可以轻松在接受`Function`的任何高阶函数中使用，例如在流（Stream）的`map`操作中，如下所示：
- en: '[PRE28]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As with the `Result` before, the `Try` type is quite minimalistic and should
    be regarded as an exercise of how to combine functional concepts to create new
    constructs, like a lazy fluent pipeline consisting of higher-order functions.
    If you want to use a type like `Try`, you should consider using an established
    functional third-party library like [vavr](https://www.vavr.io) which provides
    a versatile `Try` type and much more.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的`Result`一样，`Try`类型非常简约，应该被视为如何组合功能概念以创建新构造的一种练习，比如由高阶函数组成的惰性流畅管道。如果你想使用类似`Try`的类型，你应该考虑使用像[vavr](https://www.vavr.io)这样的成熟的功能第三方库，它提供了多功能的`Try`类型等等。
- en: Final Thoughts on Functional Exception Handling
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**函数式异常处理的最后思考**'
- en: Disruptive and abnormal control flow conditions in our code are inevitable,
    which is why we need a way to deal with them. Exception handling helps to improve
    program safety. For example, the catch-or-specify requirement is designed to make
    you think about the anticipated exceptional states and deal with them accordingly
    to increase code quality. Although it’s certainly useful, it’s also tricky to
    carry out.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们代码中的突发和异常的控制流条件是不可避免的，这就是为什么我们需要一种处理它们的方法。异常处理有助于提高程序的安全性。例如，捕获或指定的要求旨在让您考虑预期的异常状态并相应地处理它们，以提高代码质量。虽然它肯定是有用的，但也很难实施。
- en: 'Handling Exceptions can be quite a pain point in Java, regardless of using
    a functional approach. There is always a trade-off, no matter which Exception-handling
    approach you choose, especially if checked Exceptions are involved:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中处理异常可能是一个非常棘手的问题，无论使用何种功能方法。无论您选择哪种异常处理方法，总是有一个权衡：
- en: Extracting unsafe methods to gain localized Exception handling is a good compromise
    but not an easy-to-use general solution.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提取不安全方法以获取局部化的异常处理是一个不错的折衷方案，但不是一个易于使用的通用解决方案。
- en: Designing your APIs to not have any exceptional states is not as easy as it
    sounds.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计您的API以不具有任何异常状态并不像听起来那么简单。
- en: Unchecking your Exceptions is a “last-resort” tool that hides them away without
    a chance to handle them and contradicts their purpose.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 取消选中您的异常是一个“最后手段”的工具，它将异常隐藏起来而没有机会处理它们，这与它们的目的相矛盾。
- en: So what should you do? Well, it depends.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 那么你应该怎么做呢？嗯，这取决于情况。
- en: None of the presented solutions is *perfect*. You have to find a balance between
    “convenience” and “usability.” Exceptions are sometimes an overused feature, but
    they are still essential signals to the control flow of your programs. Hiding
    them away might not be in your best interest in the long run, even if the resulting
    code is more concise and reasonable, as long as no Exception occurs.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 所有提出的解决方案都不是*完美的*。你必须在“方便性”和“可用性”之间找到平衡。异常有时是一个被过度使用的特性，但它们仍然是程序控制流的重要信号。长期来看，隐藏它们可能并不符合您的最佳利益，即使最终的代码更加简洁和合理，只要没有异常发生。
- en: Not every imperative or OOP feature/technique is replaceable with a functional
    equivalent in Java. Many of Java’s (functional) shortcomings are circumventable
    to gain their general advantages, even if the resulting code is not as concise
    as in fully-functional programming languages. Exceptions, however, are one of
    those features that aren’t easily replaceable in most circumstances. They’re often
    an indicator that you either should try to refactor your code to make it “more
    functional” or that a functional approach might not be the best solution for the
    problem.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有的命令式或面向对象的特性/技术在Java中都能用功能等价物替代。Java的许多（功能性）缺陷可以通过绕过来获得它们的一般优势，即使最终的代码不像完全功能化的编程语言那样简洁。然而，异常是其中一个特性，在大多数情况下很难替代。它们通常是你应该尝试重构代码以使其“更加功能化”，或者功能方法可能不是问题的最佳解决方案的指示器之一。
- en: Alternatively, there are several third-party libraries available, like the [Vavr
    project](https://www.vavr.io/) or [jOOλ](https://github.com/jOOQ/jOOL), that allow
    you to circumvent or at least mitigate problems when using (checked) Exceptions
    in functional Java code. They did all the work implementing all relevant wrapper
    interfaces and replicating control structures and types from other languages,
    like pattern matching. But in the end, you end up with highly specialized code
    that tries to bend Java to its will, without much regard for traditional or common
    code constructs. Such dependence on a third-party library is a long-term commitment
    and shouldn’t be added lightly.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，还有几个第三方库可供选择，如 [Vavr 项目](https://www.vavr.io/) 或 [jOOλ](https://github.com/jOOQ/jOOL)，允许您在使用（检查的）Java
    代码中规避或至少减轻问题。它们完成了所有相关包装接口的实现，并复制了其他语言的控制结构和类型，如模式匹配。但最终，您将得到高度专业化的代码，试图随心所欲地修改
    Java，而不太考虑传统或常见的代码构造。依赖第三方库是一种长期承诺，不应轻率添加。
- en: Takeaways
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 要点
- en: There are no specialized constructs for handling Exceptions in functional code
    like lambda expressions, only the `try`-`catch`-block as usual, which leads to
    verbose and unwieldy code.
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在函数式代码中，如 Lambda 表达式中没有专门的异常处理结构，只能像通常一样使用`try`-`catch`块，这导致代码冗长且笨拙。
- en: You can fulfill or circumvent the catch-or-specify requirement in multiple ways,
    but that merely hides the original “problem.”
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以通过多种方式实现或规避捕获或指定的要求，但这只是隐藏了原始的“问题”。
- en: Custom wrappers can provide a more functional approach.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义包装器可以提供更具功能性的方法。
- en: Third-party libraries can help to reduce the additional boilerplate required
    for handling Exceptions more functionally. But the newly introduced types and
    constructs are no lightweight addition to your code and might create a lot of
    technical debt.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三方库可以帮助减少处理异常所需的额外样板代码。但是，新引入的类型和结构对您的代码来说并非轻量级的增加，可能会产生大量技术债务。
- en: Choosing the right way to deal with Exceptions in functional code depends highly
    on the surrounding context.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在函数式代码中选择正确处理异常的方式高度依赖于周围的上下文。
- en: ^([1](ch10.xhtml#idm45115227087312-marker)) Guy L. Steele and Richard P. Gabriel.
    1996\. “The evolution of Lisp.” [History of programming languages---II. Association
    for Computing Machinery, 233-330](https://doi.org/10.1145/234286.1057818).
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch10.xhtml#idm45115227087312-marker)) Guy L. Steele 和 Richard P. Gabriel.
    1996年。《Lisp 的演变》。《编程语言历史---II。计算机协会，233-330页》(https://doi.org/10.1145/234286.1057818)。
- en: ^([2](ch10.xhtml#idm45115226777968-marker)) The [official Kotlin documentation](https://kotlinlang.org/docs/exceptions.xhtml)
    highlights the differences between Java and Kotlin exception handling.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch10.xhtml#idm45115226777968-marker)) [官方 Kotlin 文档](https://kotlinlang.org/docs/exceptions.xhtml)强调了
    Java 和 Kotlin 异常处理之间的区别。
- en: '^([3](ch10.xhtml#idm45115226386080-marker)) Gamma, E., Helm, R., Johnson, R.,
    & Vlissides, J. (1994). Design patterns: Elements of reusable object-oriented
    software. Boston, MA: Addison Wesley.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch10.xhtml#idm45115226386080-marker)) Gamma, E., Helm, R., Johnson, R.,
    & Vlissides, J. (1994). 设计模式：可重用面向对象软件的元素。马萨诸塞州波士顿：Addison Wesley。
- en: ^([4](ch10.xhtml#idm45115226007984-marker)) The rules for type resolution are
    listed in §18.4 of the [Java SE 8 Language Specification](https://docs.oracle.com/javase/specs/jls/se8/html/jls-18.xhtml#jls-18.4).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch10.xhtml#idm45115226007984-marker)) 类型解析的规则在《Java SE 8 语言规范》的第 §18.4
    节中列出。
- en: ^([5](ch10.xhtml#idm45115224366432-marker)) Scala’s generic types are declared
    with `[]` (square brackets) instead of `<>` (angle brackets). The `+` (plus) signifies
    the type’s variance. See [“Tour of Scala”](https://docs.scala-lang.org/tour/variances.xhtml)
    for more information about type variance.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch10.xhtml#idm45115224366432-marker)) Scala 的泛型类型使用`[]`（方括号）而不是`<>`（尖括号）声明。`+`（加号）表示类型的变异性。有关类型变异的更多信息，请参见[“Scala
    之旅”](https://docs.scala-lang.org/tour/variances.xhtml)。
- en: ^([6](ch10.xhtml#idm45115224250464-marker)) The first preview of pattern matching
    for `switch` is described in [JEP 406](https://openjdk.org/jeps/406). A second
    preview is described in [JEP 420](https://openjdk.org/jeps/420), which was delivered
    in Java 18\. The next release, Java 19, included the third preview described in
    [JEP 427](https://openjdk.org/jeps/427). The feature is still evolving with another
    preview planned for Java 20, described in [JEP 433](https://openjdk.org/jeps/433).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch10.xhtml#idm45115224250464-marker)) `switch` 的模式匹配首次预览在[JEP 406](https://openjdk.org/jeps/406)中描述。第二个预览在[Java
    18](https://openjdk.org/jeps/420)中发布，其中包括[JEP 420](https://openjdk.org/jeps/420)的描述。下一个发布版本，Java
    19，包括在[JEP 427](https://openjdk.org/jeps/427)中描述的第三个预览。该功能仍在发展中，并计划在Java 20中进行另一次预览，详见[JEP
    433](https://openjdk.org/jeps/433)。
