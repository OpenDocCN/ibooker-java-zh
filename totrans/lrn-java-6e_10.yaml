- en: Chapter 10\. File Input and Output
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ability to store data in files and retrieve it later is crucial to desktop
    and enterprise applications. In this chapter, we’ll look at some of the most popular
    classes in the `java.io` and `java.nio` packages. These packages offer a rich
    set of tools for basic input and output (I/O) and also provide the framework on
    which all file and network communication in Java is built. [Figure 10-1](#learnjava6-CHP-10-FIG-io-classes)
    shows the breadth of the `java.io` package.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start by looking at the stream classes in `java.io`, which are subclasses
    of the basic `InputStream`, `OutputStream`, `Reader`, and `Writer` classes. Then
    we’ll examine the `File` class and discuss how you can read and write files using
    classes in `java.io`. We also take a quick look at data compression and serialization.
    Along the way, we introduce the `java.nio` package. The “new” I/O package (or
    NIO) adds significant functionality tailored for building high-performance services.
    NIO centers on working with *buffers* (where you store stuff to make more efficient
    use of other resources) and *channels* (where you can efficiently put stuff that
    can be just as efficiently picked up by others). In some cases, NIO also provides
    better APIs that can be used in place of some `java.io` features.^([1](ch10.html#id1908))
  prefs: []
  type: TYPE_NORMAL
- en: '![ljv6 1001](assets/ljv6_1001.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-1\. The `java.io` class hierarchy
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most I/O in Java is based on streams. Conceptually, a *stream* represents a
    flow of data with a *writer* at one end and a *reader* at the other. When you
    are working with the `java.io` package to perform terminal input and output, reading
    or writing files, or communicating through network sockets in Java (more on networking
    in [Chapter 13](ch13.html#learnjava6-CHP-13)), you are using various types of
    streams. When we look at the NIO package, we’ll find a similar concept called
    a *channel*. The main difference between the two is that streams are oriented
    around bytes or characters, while channels are oriented around “buffers” containing
    those data types. A *buffer* is typically a fast, temporary storage for data that
    makes it easier to optimize throughput. They both perform roughly the same job.
    Let’s start with streams. Here’s a quick overview of the most popular stream classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`InputStream`, `OutputStream`'
  prefs: []
  type: TYPE_NORMAL
- en: Abstract classes that define the basic functionality for reading or writing
    an unstructured sequence of bytes. All other byte streams in Java are built on
    top of the basic `InputStream` and `OutputStream`.
  prefs: []
  type: TYPE_NORMAL
- en: '`Reader`, `Writer`'
  prefs: []
  type: TYPE_NORMAL
- en: Abstract classes that define the basic functionality for reading or writing
    a sequence of character data, with support for Unicode. All other character streams
    in Java are built on top of `Reader` and `Writer`.
  prefs: []
  type: TYPE_NORMAL
- en: '`InputStreamReader`, `OutputStreamWriter`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Classes that bridge byte and character streams by converting according to a
    specific character-encoding scheme such as ASCII or Unicode. (Remember: in Unicode,
    a character is not necessarily one byte!)'
  prefs: []
  type: TYPE_NORMAL
- en: '`DataInputStream`, `DataOutputStream`'
  prefs: []
  type: TYPE_NORMAL
- en: Specialized stream filters that add the ability to read and write multibyte
    data types, such as numeric primitives and `String` objects in a standardized
    format.
  prefs: []
  type: TYPE_NORMAL
- en: '`ObjectInputStream`, `ObjectOutputStream`'
  prefs: []
  type: TYPE_NORMAL
- en: Specialized stream filters that are capable of writing whole groups of serialized
    Java objects and reconstructing them.
  prefs: []
  type: TYPE_NORMAL
- en: '`BufferedInputStream`, `BufferedOutputStream`, `BufferedReader`, `BufferedWriter`'
  prefs: []
  type: TYPE_NORMAL
- en: Specialized stream filters that add buffering for additional efficiency. For
    real-world I/O, a buffer is almost always used.
  prefs: []
  type: TYPE_NORMAL
- en: '`PrintStream`, `PrintWriter`'
  prefs: []
  type: TYPE_NORMAL
- en: Specialized streams that simplify printing text.
  prefs: []
  type: TYPE_NORMAL
- en: '`PipedInputStream`, `PipedOutputStream`, `PipedReader`, `PipedWriter`'
  prefs: []
  type: TYPE_NORMAL
- en: Paired classes that move data within an application. Data written into a `PipedOutputStream`
    or `PipedWriter` is read from its corresponding `PipedInputStream` or `PipedReader`.
  prefs: []
  type: TYPE_NORMAL
- en: '`FileInputStream`, `FileOutputStream`, `FileReader`, `FileWriter`'
  prefs: []
  type: TYPE_NORMAL
- en: Implementations of `InputStream`, `OutputStream`, `Reader`, and `Writer` that
    read from and write to files on the local filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: Streams in Java are one-way streets. The `java.io` input and output classes
    represent only the ends of a simple stream. For bidirectional conversations, you’ll
    use one of each type of stream.
  prefs: []
  type: TYPE_NORMAL
- en: '`InputStream` and `OutputStream`, as shown in [Figure 10-2](#learnjava6-CHP-10-FIG-1),
    are abstract classes that define the lowest-level interface for all byte streams.
    They contain methods for reading or writing an unstructured flow of byte-level
    data. Because these classes are abstract, you can’t create a generic input or
    output stream.'
  prefs: []
  type: TYPE_NORMAL
- en: '![ljv6 1002](assets/ljv6_1002.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-2\. Basic input and output stream functionality
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Java implements subclasses of these for activities such as reading from and
    writing to files or communicating with network connections. Because all byte streams
    inherit the structure of `InputStream` or `OutputStream`, the various kinds of
    byte streams can be used interchangeably. A method specifying an `InputStream`
    as an argument can accept any subclass of `InputStream`. Specialized types of
    streams can also be layered or wrapped around basic streams to add features such
    as buffering, filtering, compression, or handling higher-level data types.
  prefs: []
  type: TYPE_NORMAL
- en: '`Reader` and `Writer` are very much like `InputStream` and `OutputStream`,
    except that they deal with characters instead of bytes. As true character streams,
    these classes correctly handle Unicode characters, which is not always the case
    with byte streams. Often, a bridge is needed between these character streams and
    the byte streams of physical devices, such as disks and networks. `InputStreamReader`
    and `OutputStreamWriter` are special classes that use a character-encoding scheme
    like ASCII or UTF-8 to translate between character and byte streams.'
  prefs: []
  type: TYPE_NORMAL
- en: This section describes several stream types, with the exception of `FileInputStream`,
    `FileOutputStream`, `FileReader`, and `FileWriter`. We postpone the discussion
    of file streams until the next section, where we cover accessing the filesystem
    in Java.
  prefs: []
  type: TYPE_NORMAL
- en: Basic I/O
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The prototypical example of an `InputStream` object is the *standard input*
    of a Java application. Like `stdin` in C or `cin` in C++, this is the source of
    input to a command-line (non-GUI) program. It is an input stream from the environment—usually
    a terminal window or possibly the output of another command. The `java.lang.System`
    class, a general repository for system-related resources, provides a reference
    to the standard input stream in the static variable `System.in`. It also provides
    a *standard output stream* and a *standard error stream* in the `out` and `err`
    variables, respectively.^([2](ch10.html#id1946)) The following example shows the
    correspondence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This snippet hides the fact that `System.out` and `System.err` aren’t just `OutputStream`
    objects but more specialized and useful `PrintStream` objects. We’ll explain these
    later in [“PrintWriter and PrintStream”](#learnjava6-CHP-10-SECT-1.3.3), but for
    now we can reference `out` and `err` as `OutputStream` objects because they are
    derived from `OutputStream`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can read a single byte at a time from standard input with the `InputStream`’s
    `read()` method. If you look closely at the [online documentation](https://oreil.ly/GSEj0),
    you’ll see that the `read()` method of the base `InputStream` class is an abstract
    method. What lies behind `System.in` is a particular implementation of `InputStream`
    that provides the real implementation of the `read()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Although we said that the `read()` method reads a byte value, the return type
    in the example is `int`, not `byte`. That’s because the `read()` method of basic
    input streams in Java uses a convention carried over from the C language to indicate
    the end of a stream with a special value. Byte values are returned in the range
    0 to 255, and the special value of `-1` is used to indicate that the end of the
    stream has been reached. You test for this condition when using the simple `read()`
    method. You can then cast the value to a byte, if needed. The following example
    reads each byte from an input stream and prints its value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As we’ve shown in the examples, the `read()` method can also throw an `IOException`
    if there is an error reading from the underlying stream source. Various subclasses
    of `IOException` may indicate that a source (such as a file or network connection)
    has had an error. Additionally, higher-level streams that read data types more
    complex than a single byte may throw `EOFException` (“end of file”), which indicates
    an unexpected or premature end of a stream.
  prefs: []
  type: TYPE_NORMAL
- en: 'An overloaded form of `read()` fills a byte array with as much data as possible
    up to the capacity of the array and returns the number of bytes read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In theory, we can also check the number of bytes available for reading at a
    given time on an `InputStream` using the `available()` method. With that information,
    we could create an array of exactly the right size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: However, the reliability of this technique depends on whether the underlying
    stream implementation can detect how much data it can retrieve. It generally works
    for files but should not be relied upon for all types of streams.
  prefs: []
  type: TYPE_NORMAL
- en: These `read()` methods block until at least some data is read (at least one
    byte). You must, in general, check the returned value to determine how much data
    you got and if you need to read more. (We look at nonblocking I/O later in this
    chapter.) The `skip()` method of `InputStream` provides a way of jumping over
    a number of bytes. Depending on the implementation of the stream, skipping bytes
    may be more efficient than reading them.
  prefs: []
  type: TYPE_NORMAL
- en: The `close()` method shuts down the stream and frees up any associated system
    resources. It’s important for performance to remember to close most types of streams
    when you are finished using them. In some cases, streams may close automatically
    when objects are garbage-collected, but it is not a good idea to rely on this
    behavior. The `try`*-with-resources* feature discussed in [“try with Resources”](ch06.html#learnjava6-CHP-6-SECT-1.9)
    makes automatically closing streams and other closeable entities easier. We’ll
    see some examples of that in [“File Streams”](#learnjava6-CHP-10-SECT-1.5). The
    interface `java.io.Closeable` identifies all types of stream, channel, and related
    utility classes that can be closed.
  prefs: []
  type: TYPE_NORMAL
- en: Character Streams
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In early versions of Java, some `InputStream` and `OutputStream` types included
    methods for reading and writing strings, but most of them operated by naively
    assuming that a 16-bit Unicode character was equivalent to an 8-bit byte in the
    stream. This works for Latin-1 (ISO 8859-1) characters, but not for the world
    of other encodings used with different languages.
  prefs: []
  type: TYPE_NORMAL
- en: The `java.io Reader` and `Writer` character stream classes were introduced as
    streams that handle character data only. When you use these classes, you think
    only in terms of characters and string data. You allow the underlying implementation
    to handle the conversion of bytes to a specific character encoding. As you’ll
    see, there are some direct implementations of `Reader` and `Writer`, such as those
    for reading and writing files.
  prefs: []
  type: TYPE_NORMAL
- en: More generally, two special classes, `InputStreamReader` and `OutputStreamWriter`,
    bridge the gap between character streams and byte streams. These are, respectively,
    a `Reader` and a `Writer` that can be wrapped around any underlying byte stream
    to make it a character stream. An encoding scheme converts between the bytes (which
    may come in groups representing multibyte characters) and Java’s two-byte characters.
    An encoding scheme can be specified by name in the constructor of `InputStreamReader`
    or `OutputStreamWriter`. For convenience, the default constructor uses the system’s
    default encoding scheme.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how to use readers and the `java.text.NumberFormat` class to retrieve
    numeric input from the user at the command line. We’ll assume that the bytes coming
    from `System.in` use the system’s default encoding scheme:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: First, we wrap an `InputStreamReader` around `System.in`. This reader converts
    the incoming bytes of `System.in` to characters using the default encoding scheme.
    Then, we wrap a `BufferedReader` around the `InputStreamReader`. `BufferedReader`
    adds the `readLine()` method, which we can use to grab a full line of text (up
    to a platform-specific, line-terminator character combination) into a `String`.
    The string is then parsed into an integer using the techniques described in [Chapter 8](ch08.html#learnjava6-CHP-8).
    Try it yourself. When prompted, try providing different input. What happens if
    you enter a “0”? What if you only enter your first name?
  prefs: []
  type: TYPE_NORMAL
- en: 'We have just taken a byte-oriented input stream, `System.in`, and safely converted
    it to a `Reader` for reading characters. If we wished to use an encoding other
    than the system default, we could have specified it in the `InputStreamReader`’s
    constructor, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: For each character that is read from the reader, the `InputStreamReader` reads
    one or more bytes and performs the necessary conversion to Unicode.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll return to the topic of character encodings in [“The New I/O File API”](#learnjava6-CHP-10-SECT-2)
    when we discuss the `java.nio.charset` package, which allows you to find and use
    encoders and decoders. Both `InputStreamReader` and `OutputStreamWriter` can accept
    a `Charset` codec object as well as a character-encoding name.
  prefs: []
  type: TYPE_NORMAL
- en: Stream Wrappers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'What if you want to do more than read and write a sequence of bytes or characters?
    We can use a *filter stream*, which is a type of `InputStream`, `OutputStream`,
    `Reader`, or `Writer` that wraps another stream and adds new features. A filter
    stream takes the target stream as an argument in its constructor, does some additional
    processing of its own, and then delegates calls to the target. For example, we
    can construct a `BufferedInputStream` to wrap the system standard input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `BufferedInputStream` reads ahead and buffers a certain amount of data.
    It wraps an additional layer of functionality around the underlying stream. [Figure 10-3](#learnjava6-CHP-10-FIG-2)
    shows this arrangement for a `DataInputStream`, which can read higher-level data
    types, such as Java primitives and strings.
  prefs: []
  type: TYPE_NORMAL
- en: '![ljv6 1003](assets/ljv6_1003.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-3\. Layered streams
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As you can see from the previous code snippet, the `BufferedInputStream` filter
    is a type of `InputStream`. Because filter streams are themselves subclasses of
    the basic stream types, they can be used as arguments to the construction of other
    filter streams. This allows filter streams to be layered on top of one another
    to provide different combinations of features. For example, we could first wrap
    our `System.in` with a `BufferedInputStream` to benefit from buffering our input,
    and then wrap the `BufferedInputStream` with a `DataInputStream` for reading special
    data types with buffering.
  prefs: []
  type: TYPE_NORMAL
- en: 'Java provides base classes for creating new types of filter streams: `FilterInputStream`,
    `FilterOutputStream`, `FilterReader`, and `FilterWriter`. These superclasses provide
    the basic machinery for a filter by delegating all their method calls to their
    underlying stream. To create your own filter stream, you can extend these classes
    and override various methods to add the additional processing you need.'
  prefs: []
  type: TYPE_NORMAL
- en: Data streams
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`DataInputStream` and `DataOutputStream` are filter streams that let you read
    or write strings (as opposed to individual characters) and primitive data types
    composed of more than a single byte. `DataInputStream` and `DataOutputStream`
    implement the `DataInput` and `DataOutput` interfaces, respectively. These interfaces
    define methods for reading or writing strings and all of the Java primitive types,
    including numbers and Boolean values. `DataOutputStream` encodes these values
    in a way that can be read back correctly on any machine and then writes them to
    its underlying byte stream. `DataInputStream` picks up the encoded data from its
    underlying byte stream and decodes it into its original types and values.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can construct a `DataInputStream` from an `InputStream` and then use a
    method such as `readDouble()` to read a primitive data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This snippet wraps the standard input stream in a `DataInputStream` and uses
    it to read a `double` value. The `readDouble()` method reads bytes from the stream
    and constructs a `double` from them. The `DataInputStream` methods expect the
    bytes of numeric data types to be in *network byte order*, a standard that specifies
    that the high-order bytes of any multibyte values are sent first (also known as
    *big-endian*; see [“Byte order”](#learnjava6-CHP-10-SECT-3.5.3)).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `DataOutputStream` class provides write methods that correspond to the
    read methods in `DataInputStream`. The complement to our input snippet looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`DataOutputStream` and `DataInputStream` work with binary data, not human-readable
    text. Typically, you would use a `DataInputStream` to read content that was produced
    by a `DataOutputStream`. These filter streams are perfect for working directly
    with things like image files.'
  prefs: []
  type: TYPE_NORMAL
- en: The `readUTF()` and `writeUTF()` methods of `DataInputStream` and `DataOutputStream`
    read and write a Java `String` of Unicode characters using the UTF-8 character
    encoding. As discussed in [Chapter 8](ch08.html#learnjava6-CHP-8), UTF-8 is an
    ASCII-compatible encoding of Unicode characters that is very widely used. Not
    all encodings are guaranteed to preserve all Unicode characters, but UTF-8 does.
    You can also use UTF-8 with `Reader` and `Writer` streams by specifying it as
    the encoding name.
  prefs: []
  type: TYPE_NORMAL
- en: Buffered streams
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `BufferedInputStream`, `BufferedOutputStream`, `BufferedReader`, and `BufferedWriter`
    classes add a data buffer of a specified size to the stream path. A buffer can
    increase efficiency by reducing the number of physical read or write operations
    that correspond to `read()` or `write()` method calls, as seen in [Figure 10-4](#learnjava6-CHP-10-FIG-buffered).
  prefs: []
  type: TYPE_NORMAL
- en: '![ljv6 1004](assets/ljv6_1004.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-4\. Reading data with and without a buffer
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'You create a buffered stream with an appropriate input or output stream and
    a buffer size. (You can also wrap another stream around a buffered stream so that
    it benefits from the buffering.) Here’s a simple buffered input stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we specify a buffer size of 32 KB. If we leave off the size
    of the buffer in the constructor, Java creates a reasonably sized buffer for us.
    (Currently the default is 8 KB.) On our first call to `read()`, `bis` tries to
    fill our entire 32 KB buffer with data, if it’s available. Thereafter, calls to
    `read()` retrieve data from the buffer, which is refilled as necessary.
  prefs: []
  type: TYPE_NORMAL
- en: A `BufferedOutputStream` works in a similar way. Calls to `write()` store the
    data in a buffer; data is actually written to the underlying stream only when
    the buffer fills up. You can also use the `flush()` method to write out the contents
    of a `BufferedOutputStream` at any time. The `flush()` method is actually a method
    of the `OutputStream` class itself. It allows you to be sure that all data in
    any underlying streams has been saved or sent.
  prefs: []
  type: TYPE_NORMAL
- en: The `BufferedReader` and `BufferedWriter` classes work just like their byte-based
    counterparts, except that they operate on characters instead of bytes.
  prefs: []
  type: TYPE_NORMAL
- en: PrintWriter and PrintStream
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another useful wrapper is `java.io.PrintWriter`. This class provides a suite
    of overloaded `print()` methods that turn their arguments into strings and push
    them out the stream. A complementary set of `println()` convenience methods appends
    a new line to the end of the strings. For formatted text output, `printf()` and
    the identical `format()` methods allow you to write C `printf`-style formatted
    text to the stream.
  prefs: []
  type: TYPE_NORMAL
- en: '`PrintWriter` is an unusual character stream because it can wrap either an
    `OutputStream` or another `Writer`. `PrintWriter` is the more capable big brother
    of the legacy `PrintStream` byte stream. The `System.out` and `System.err` streams
    are `PrintStream` objects, which you have already seen throughout this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'When you create a `PrintWriter` object, you can pass an additional Boolean
    value to the constructor, specifying whether it should “auto-flush.” If this value
    is `true`, the `PrintWriter` automatically performs a `flush()` on the underlying
    `OutputStream` or `Writer` each time it sends a newline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: When you use this technique with a buffered output stream, it acts like a terminal
    that outputs data line by line.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other big advantage that `PrintStream` and `PrintWriter` have over regular
    character streams is that they shield you from exceptions thrown by the underlying
    streams. Unlike methods in other stream classes, the methods of `PrintWriter`
    and `PrintStream` do not throw `IOException`s. Instead, they provide a method
    to explicitly check for errors, if required. This makes the common operation of
    printing text a lot easier. You can check for errors with the `checkError()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This feature of `PrintStream` and `PrintWriter` means you can generally output
    text to a variety of destinations without wrapping every print statement in a
    `try` block. But it still gives you access to any errors that occur if you are
    writing important information and want to guarantee that nothing went wrong.
  prefs: []
  type: TYPE_NORMAL
- en: The java.io.File Class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A popular destination for printed output is a file. The `java.io.File` class
    encapsulates access to information about a file or directory. You can use `File`
    to get attribute information about a file, list the entries in a directory, and
    perform basic filesystem operations, such as deleting a file or making a new directory.
    While the `File` object handles these “meta” operations, it doesn’t provide the
    API for reading and writing file data; you’ll need file streams for that.
  prefs: []
  type: TYPE_NORMAL
- en: File constructors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can create an instance of `File` from a `String` pathname:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also create a file with a relative path that starts in the current
    working directory of the JVM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'You can determine the current working directory by reading the `user.dir` property
    in the `System` properties list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'An overloaded version of the `File` constructor lets you specify the directory
    path and filename as separate `String` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'With yet another variation, you can specify the directory with a `File` object
    and the filename with a `String`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: None of these `File` constructors actually creates a file or directory, and
    it is not an error to create a `File` object for a nonexistent file. The `File`
    object is just a handle for a file or directory whose properties you may wish
    to read, write, or test. For example, you can use the `exists()` instance method
    to learn whether the file or directory exists. Many applications perform this
    test prior to saving to a file, for example. If the chosen file doesn’t exist,
    hooray! The application can safely save its data. If the file does already exist,
    you often get an overwrite warning to make sure you want to replace the old file.
  prefs: []
  type: TYPE_NORMAL
- en: Path localization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Java, pathnames are expected to follow the conventions of the local filesystem.
    The Windows filesystem uses distinct *roots* (top-level directories) with drive
    letters (for example, “C:”) and a backslash (\) instead of the single root and
    forward slash (/) path separator that is used in Linux and macOS systems.
  prefs: []
  type: TYPE_NORMAL
- en: Java tries to compensate for this difference. For example, on Windows platforms,
    it accepts paths with either forward slashes or backslashes. On macOS and Linux,
    however, it only accepts forward slashes.
  prefs: []
  type: TYPE_NORMAL
- en: Your best bet is to make sure you follow the filename conventions of the host
    filesystem. If your application has a GUI that is opening and saving files at
    the user’s request, you should be able to handle that functionality with the Swing
    `JFileChooser` class. This class encapsulates a graphical file-selection dialog
    box. The methods of the `JFileChooser` take care of system-dependent filename
    features for you.
  prefs: []
  type: TYPE_NORMAL
- en: If your application needs to deal with files on its own behalf, however, things
    get a little more complicated. The `File` class contains a few `static` variables
    to make this task easier. `File.separator` defines a `String` that specifies the
    file separator on the local host (e.g., `/` on Unix and macOS systems, and `\`
    on Windows systems); `File.separatorChar` provides the same information as a `char`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use this system-dependent information in several ways. Probably the
    simplest way to localize pathnames is to pick a convention that you use internally,
    such as the forward slash (/), and do a `String` replace to substitute for the
    localized separator character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you could work with the components of a pathname and build the
    local pathname when you need it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Remember that Java interprets backslash characters (`\`) in source code as
    escape characters when they’re used in a `String`. To get a literal backslash,
    you have to double up: `\\`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To grapple with the issue of filesystems with multiple “roots” (for example,
    `C:\` on Windows), the `File` class provides the static method `listRoots()`,
    which returns an array of `File` objects corresponding to the filesystem root
    directories. You can try this out in *jshell*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Again, in a GUI application, a graphical file chooser dialog generally shields
    you from this problem.
  prefs: []
  type: TYPE_NORMAL
- en: File operations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once we have a `File` object, we can use it to perform a number of standard
    operations on the file or directory it represents. Several methods let us ask
    questions about the `File`. For example, `isFile()` returns `true` if the `File`
    represents a regular file, while `isDirectory()` returns `true` if it’s a directory.
    `isAbsolute()` indicates whether the `File` encapsulates an absolute or relative
    path specification. A *relative path* is relative to the application’s working
    directory. An *absolute path* is a system-dependent notion that means that the
    path isn’t tied to the working directory or current drive. In Unix and macOS,
    an absolute path starts with a forward slash: */Users/pat/foo.txt*. In Windows,
    it is a full path including the drive letter: *C:\Users\pat\foo.txt* (and, again,
    it can be on a different drive letter than the working directory if there are
    multiple drives in the system).'
  prefs: []
  type: TYPE_NORMAL
- en: Components of the pathname are available through the methods `getName()`, `getPath()`,
    `getAbsolutePath()`, and `getParent()`. The `getName()` method returns a `String`
    for the filename without any directory information. If the `File` has an absolute
    path specification, `getAbsolutePath()` returns that path. Otherwise, it returns
    the relative path appended to the current working directory (attempting to make
    it an absolute path). The `getParent()` method returns the parent directory of
    the file or directory.
  prefs: []
  type: TYPE_NORMAL
- en: The string returned by `getPath()` or `getAbsolutePath()` may not follow the
    same case conventions as the underlying filesystem. You can retrieve the filesystem’s
    own (or “canonical”) version of the file’s path by using the method `getCanonicalPath()`.
    In Windows, for example, you can create a `File` object whose `getAbsolutePath()`
    is *C:\Autoexec.bat* but whose `getCanonicalPath()` is *C:\AUTOEXEC.BAT*; both
    actually point to the same file. This is useful for comparing filenames or for
    showing them to the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can get or set the modification time of a file or directory with the `lastModified()`
    and `setLastModified()` methods. The value is a `long` that is the number of milliseconds
    since the *epoch* (the name for the “first” date in Unix: January 1, 1970, 00:00:00
    GMT). We can also get the size of the file, in bytes, with `length()`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a fragment of code that prints some information about a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'If the `File` object corresponds to a directory, we can list the files in the
    directory with the `list()` method or the `listFiles()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '`list()` returns an array of `String` objects that contains filenames. `listFiles()`
    returns an array of `File` objects. Note that in neither case are the files guaranteed
    to be in any kind of order (alphabetical, for example). You can use the Collections
    API to sort strings alphabetically, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: If the `File` refers to a nonexistent directory, we can create the directory
    with `mkdir()` or `mkdirs()`. The `mkdir()` method creates at most a single directory
    level, so any intervening directories in the path must already exist. `mkdirs()`
    creates all directory levels necessary to create the full path of the `File` specification.
    In either case, if the directory cannot be created, the method returns `false`.
    Use `renameTo()` to rename a file or directory, and `delete()` to delete a file
    or directory.
  prefs: []
  type: TYPE_NORMAL
- en: Although you can create a directory using the `File` object, you don’t typically
    use `File` to create a file; that’s normally done implicitly when you write data
    to it with a `FileOutputStream` or `FileWriter`, as we’ll discuss in a moment.
    The exception is the `createNewFile()` method, which you can use to create a new
    zero-length file at the `File`’s location.
  prefs: []
  type: TYPE_NORMAL
- en: The `createNewFile()` operation is guaranteed to be atomic^([3](ch10.html#id2038))
    with respect to all other file creation in the filesystem. Java returns a Boolean
    value from `createNewFile()` that tells you whether the file was created or not.
    Creating a new file this way is useful when you also use `deleteOnExit()`, which
    flags the file to be automatically removed when the Java VM exits. This combination
    allows you to guard resources or make an application that can only be run in a
    single instance at a time.
  prefs: []
  type: TYPE_NORMAL
- en: Another file creation method that is related to the `File` class itself is the
    static method `createTempFile()`, which creates a file in a specified location
    using an automatically generated, unique name. You typically use `createTempFile()`
    in conjunction with `deleteOnExit()`. Network applications use this combination
    frequently to create short-lived files for storing requests or building responses.
  prefs: []
  type: TYPE_NORMAL
- en: The `toURL()` method converts a file path to a `file:` URL object. URLs are
    a kind of abstraction that allow you to point to any kind of object anywhere on
    a network. Converting a `File` reference to a URL may be useful for consistency
    with more general utilities that deal with URLs. Java’s NIO, for example, uses
    URLs to reference new types of filesystems that are implemented directly in Java
    code.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 10-1](#learnjava6-CHP-10-TABLE-1) summarizes the methods provided by
    the `File` class.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 10-1\. File methods
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Return type | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `canExecute()` | `boolean` | Is the file executable? |'
  prefs: []
  type: TYPE_TB
- en: '| `canRead()` | `boolean` | Is the file (or directory) readable? |'
  prefs: []
  type: TYPE_TB
- en: '| `canWrite()` | `boolean` | Is the file (or directory) writable? |'
  prefs: []
  type: TYPE_TB
- en: '| `createNewFile()` | `boolean` | Creates a new file. |'
  prefs: []
  type: TYPE_TB
- en: '| `createTempFile (String` *`pfx`*, `String`*`sfx`*`)` | `File` | Static method
    to create a new file, with the specified prefix and suffix, in the default temp
    file directory. |'
  prefs: []
  type: TYPE_TB
- en: '| `delete()` | `boolean` | Deletes the file (or directory). |'
  prefs: []
  type: TYPE_TB
- en: '| `deleteOnExit()` | `Void` | When it exits, the Java runtime system deletes
    the file. |'
  prefs: []
  type: TYPE_TB
- en: '| `exists()` | `boolean` | Does the file (or directory) exist? |'
  prefs: []
  type: TYPE_TB
- en: '| `getAbsolutePath()` | `String` | Returns the absolute path of the file (or
    directory). |'
  prefs: []
  type: TYPE_TB
- en: '| `getCanonicalPath()` | `String` | Returns the absolute, case-correct, and
    relative-element-resolved path of the file (or directory). |'
  prefs: []
  type: TYPE_TB
- en: '| `getFreeSpace()` | `long` | Gets the number of bytes of unallocated space
    on the partition holding this path or 0 if the path is invalid. |'
  prefs: []
  type: TYPE_TB
- en: '| `getName()` | `String` | Returns the name of the file (or directory). |'
  prefs: []
  type: TYPE_TB
- en: '| `getParent()` | `String` | Returns the name of the parent directory of the
    file (or directory). |'
  prefs: []
  type: TYPE_TB
- en: '| `getPath()` | `String` | Returns the path of the file (or directory). (Not
    to be confused with `toPath()`.) |'
  prefs: []
  type: TYPE_TB
- en: '| `getTotalSpace()` | `long` | Gets the size of the partition that contains
    the file path, in bytes, or 0 if the path is invalid. |'
  prefs: []
  type: TYPE_TB
- en: '| `getUseableSpace()` | `long` | Gets the number of bytes of user-accessible
    unallocated space on the partition holding this path or 0 if the path is invalid.
    This method attempts to take into account user write permissions. |'
  prefs: []
  type: TYPE_TB
- en: '| `isAbsolute()` | `boolean` | Is the filename (or directory name) absolute?
    |'
  prefs: []
  type: TYPE_TB
- en: '| `isDirectory()` | `boolean` | Is the item a directory? |'
  prefs: []
  type: TYPE_TB
- en: '| `isFile()` | `boolean` | Is the item a file? |'
  prefs: []
  type: TYPE_TB
- en: '| `isHidden()` | `boolean` | Is the item hidden? (System dependent.) |'
  prefs: []
  type: TYPE_TB
- en: '| `lastModified()` | `long` | Returns the last modification time of the file
    (or directory). |'
  prefs: []
  type: TYPE_TB
- en: '| `length()` | `long` | Returns the length of the file. |'
  prefs: []
  type: TYPE_TB
- en: '| `list()` | `String []` | Returns a list of files in the directory. |'
  prefs: []
  type: TYPE_TB
- en: '| `listFiles()` | `File[]` | Returns the contents of the directory as an array
    of `File` objects. |'
  prefs: []
  type: TYPE_TB
- en: '| `listRoots()` | `File[]` | Returns an array of root filesystems, if any (e.g.,
    C:/, D:/). |'
  prefs: []
  type: TYPE_TB
- en: '| `mkdir()` | `boolean` | Creates the directory. |'
  prefs: []
  type: TYPE_TB
- en: '| `mkdirs()` | `boolean` | Creates all directories in the path. |'
  prefs: []
  type: TYPE_TB
- en: '| `renameTo(File` *`dest`* `)` | `boolean` | Renames the file (or directory).
    |'
  prefs: []
  type: TYPE_TB
- en: '| `setExecutable()` | `boolean` | Sets execute permissions for the file. |'
  prefs: []
  type: TYPE_TB
- en: '| `setLastModified()` | `boolean` | Sets the last-modified time of the file
    (or directory). |'
  prefs: []
  type: TYPE_TB
- en: '| `setReadable()` | `boolean` | Sets read permissions for the file. |'
  prefs: []
  type: TYPE_TB
- en: '| `setReadOnly()` | `boolean` | Sets the file to read-only status. |'
  prefs: []
  type: TYPE_TB
- en: '| `setWriteable()` | `boolean` | Sets the write permissions for the file. |'
  prefs: []
  type: TYPE_TB
- en: '| `toPath()` | `java.nio.file.Path` | Convert the file to an NIO file path.
    (Not to be confused with `getPath()`.) |'
  prefs: []
  type: TYPE_TB
- en: '| `toURL()` | `java.net.URL` | Generates a URL object for the file (or directory).
    |'
  prefs: []
  type: TYPE_TB
- en: File Streams
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You’re probably sick of hearing about files already—and we haven’t even written
    a byte yet! Well, now the fun begins. Java provides two fundamental streams for
    reading from and writing to files: `FileInputStream` and `FileOutputStream`. These
    streams provide the basic byte-oriented `InputStream` and `OutputStream` functionality
    that is applied to reading and writing files. They can be combined with the filter
    streams described earlier to work with files in the same way as other stream communications.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create a `FileInputStream` from a `String` pathname or a `File` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'When you create a `FileInputStream`, the Java runtime system attempts to open
    the specified file. Thus, the `FileInputStream` constructors can throw a `FileNotFoundException`
    if the specified file doesn’t exist, or an `IOException` if some other I/O error
    occurs. You must catch these exceptions in your code. Wherever possible, it’s
    a good idea to get in the habit of using the `try`-with-resources construct to
    automatically close files for you when you are finished with them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: When you first create the stream, its `available()` method and the `File` object’s
    `length()` method should return the same value.
  prefs: []
  type: TYPE_NORMAL
- en: To read characters from a file as a `Reader`, you can wrap an `InputStreamReader`
    around a `FileInputStream`. You can also use the `FileReader` class, which is
    provided as a convenience. `FileReader` is just a `FileInputStream` wrapped in
    an `InputStreamReader` with some defaults.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following class, `ListIt`, is a small utility that prints the contents
    of a file or directory to standard output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '`ListIt` constructs a `File` object from its first command-line argument and
    tests the `File` to see whether it exists and is readable. If the `File` is a
    directory, `ListIt` outputs the names of the files in the directory. Otherwise,
    `ListIt` reads and outputs the file, line by line. Give it a try! Can you use
    `ListIt` on *ListIt.java*?'
  prefs: []
  type: TYPE_NORMAL
- en: For writing files, you can create a `FileOutputStream` from a `String` pathname
    or a `File` object. Unlike `FileInputStream`, however, the `FileOutputStream`
    constructors don’t throw a `FileNotFoundException`. If the specified file doesn’t
    exist, the `FileOutputStream` creates the file. The `FileOutputStream` constructors
    can throw an `IOException` if some other I/O error occurs, so you still need to
    handle this exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the specified file does exist, the `FileOutputStream` opens it for writing.
    When you subsequently call the `write()` method, the new data overwrites the current
    contents of the file. If you need to append data to an existing file, you can
    use a form of the constructor that accepts a Boolean `append` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Another way to append data to files is with `RandomAccessFile`, which we’ll
    discuss shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Just as with reading, to write characters (instead of bytes) to a file, you
    can wrap an `OutputStreamWriter` around a `FileOutputStream`. If you want to use
    the default character-encoding scheme, you can use the `FileWriter` class instead,
    which is provided as a convenience.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following snippet reads a line of data from standard input and writes it
    to the file */tmp/foo.txt*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Notice how we wrapped the `FileWriter` in a `PrintWriter` to facilitate writing
    the data. Also, to be a good filesystem citizen, call the `close()` method when
    you’re done. Here, closing the `PrintWriter` closes the underlying `Writer` for
    us.
  prefs: []
  type: TYPE_NORMAL
- en: RandomAccessFile
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `java.io.RandomAccessFile` class provides the ability to read *and* write
    data at any location in a file. `RandomAccessFile` implements both the `DataInput`
    and `DataOutput` interfaces, so you can use it to read and write strings and primitive
    types anywhere in the file just as if it were a `DataInputStream` and `DataOutputStream`.
    However, because the class provides random, rather than sequential, access to
    file data, it’s not a subclass of either `InputStream` or `OutputStream`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create a `RandomAccessFile` from a `String` pathname or a `File` object.
    The constructor also takes a second `String` argument that specifies the mode
    of the file. Use the string `"r"` for a read-only file or `"rw"` for a read/write
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: When you create a `RandomAccessFile` in read-only mode, Java tries to open the
    specified file. If the file doesn’t exist, `RandomAccessFile` throws an `IOException`.
    If, however, you’re creating a `RandomAccessFile` in read/write mode, the object
    creates the file if it doesn’t exist. The constructor can still throw an `IOException`
    if some other I/O error occurs, so you still need to handle this exception.
  prefs: []
  type: TYPE_NORMAL
- en: After you have created a `RandomAccessFile`, you can call any of the normal
    reading and writing methods, just as you would with a `DataInputStream` or `DataOutputStream`.
    If you try to write to a read-only file, the write method throws an `IOException`.
  prefs: []
  type: TYPE_NORMAL
- en: What makes a `RandomAccessFile` special is the `seek()` method. This method
    takes a `long` value and uses it to set the location for reading and writing in
    the file. You can use the `getFilePointer()` method to get the current location.
    If you need to append data to the end of the file, use `length()` to determine
    that location, then `seek()` to it. You can write or seek beyond the end of a
    file, but you can’t read beyond the end of a file. The `read()` method throws
    an `EOFException` if you try to do this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of writing data for a simple database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In this snippet, we assume that the `String` length for `userName`, along with
    any data that comes after it, fits within the specified record size.
  prefs: []
  type: TYPE_NORMAL
- en: The New I/O File API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are now going to turn our attention from the original, “classic” Java File
    API to the NIO File API. As we mentioned earlier, the NIO File API can be thought
    of as either a replacement for or a complement to the classic API. The new API
    moves Java toward a higher performance and more flexible style of I/O supporting
    *selectable* and asynchronously interruptible *channels*. (More on selecting and
    using channels soon.) When working with files, the new API’s strength is providing
    a fuller abstraction of the filesystem in Java.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to better support for existing, real-world filesystem types—including
    the new and welcomed ability to copy and move files, manage links, and get detailed
    file attributes like owners and permissions—NIO allows you to implement entirely
    new types of filesystems directly in Java. The best example of this is the ZIP
    filesystem provider. You can “mount” a ZIP archive file as a filesystem. You can
    work with the files within the archive directly using the standard APIs, just
    like any other filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: The NIO File package also provides some utilities that would have saved Java
    developers a lot of repeated code over the years, including directory tree change
    monitoring, filesystem traversal, filename “globbing” (the jargon for using wildcards
    in filenames), and convenience methods to read entire files directly into memory.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll cover the basic NIO File API in this section and return to the topic of
    buffers and channels at the end of the chapter. In particular, we’ll talk about
    `ByteChannel`s and `FileChannel`, which you can think of as alternate, buffer-oriented
    streams for reading and writing files and other types of data.
  prefs: []
  type: TYPE_NORMAL
- en: FileSystem and Path
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are three main players in the `java.nio.file` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FileSystem`'
  prefs: []
  type: TYPE_NORMAL
- en: An underlying storage mechanism and serves as a factory^([4](ch10.html#id2069))
    for `Path` objects.
  prefs: []
  type: TYPE_NORMAL
- en: '`FileSystems`'
  prefs: []
  type: TYPE_NORMAL
- en: A factory for `FileSystem` objects.
  prefs: []
  type: TYPE_NORMAL
- en: '`Path`'
  prefs: []
  type: TYPE_NORMAL
- en: The location of a file or directory within the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: '`Files`'
  prefs: []
  type: TYPE_NORMAL
- en: A utility class that contains a rich set of static methods for manipulating
    `Path` objects to perform all of the basic file operations analogous to the classic
    API.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `FileSystems` (plural) class is our starting point. Let’s create a couple
    of filesystems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: As shown in this snippet, we ask for the default filesystem to manipulate files
    in the host computer’s environment. We also use the `FileSystems` class to construct
    another `FileSystem` by taking a *uniform resource identifier* (or URI, a special
    identifier similar to a URL) that references a custom filesystem type. We use
    `jar:file` as our URI protocol to indicate we are working with a JAR or ZIP file.
  prefs: []
  type: TYPE_NORMAL
- en: '`FileSystem` implements `Closeable`, and when a `FileSystem` is closed, all
    open file channels and other streaming objects associated with it are closed as
    well. Attempting to read or write to those channels will throw an exception at
    that point. Note that the default filesystem (associated with the host computer)
    cannot be closed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have a `FileSystem`, you can use it as a factory for `Path` objects
    that represent files or directories. You can obtain a `Path` using a string representation
    just like the classic `File` class. Subsequently, you can use that `Path` object
    with methods of the `Files` utility to create, read, write, or delete the item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This example opens an `OutputStream` to write to the file *foo.txt*. By default,
    if the file does not exist, it will be created, and if it does exist, it will
    be truncated (set to zero length) before new data is written—but you can change
    these results using options. We’ll talk more about `Files` methods in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: The `Path` class implements the `java.lang.Iterable` interface, which can be
    used to iterate through its literal path components, such as the slash-separated
    `tmp` and `foo.txt` in the preceding snippet. (If you want to traverse the path
    to find other files or directories, you might be more interested in the `DirectoryStream`
    and `FileVisitor` that we’ll discuss later.) `Path` also implements the `java.nio.file.Watchable`
    interface, which allows it to be monitored for changes.
  prefs: []
  type: TYPE_NORMAL
- en: '`Path` has convenience methods for resolving paths relative to a file or directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In this snippet, we’ve shown the `Path` methods `resolve()` and `resolveSibling()`
    used to find files or directories relative to a given `Path` object. The `resolve()`
    method is generally used to append a relative path to an existing `Path` representing
    a directory. If the argument provided to the `resolve()` method is an absolute
    path, it will just yield the absolute path (it acts kind of like the Unix or DOS
    `cd` command). The `resolveSibling()` method works the same way, but it is relative
    to the parent of the target `Path`; this method is useful for describing the target
    of a `move()` operation.
  prefs: []
  type: TYPE_NORMAL
- en: Path to classic files and back
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To bridge the classic and new APIs, corresponding `toPath()` and `toFile()`
    methods have been provided in `java.io.File` and `java.nio.file.Path`, respectively,
    to convert to the other form. Of course, the only types of `Path`s that can be
    produced from `File` are paths representing files and directories in the default
    host filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: NIO File Operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once we have a `Path`, we can operate on it with static methods of the `Files`
    utility to create the path as a file or directory, read and write to it, and interrogate
    and set its properties. We’ll list the bulk of them and then discuss some of the
    more important ones as we proceed.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 10-2](#learnjava6-CHP-10-TABLE-2) summarizes these methods of the `java.nio.file.Files`
    class. As you might expect, because the `Files` class handles all types of file
    operations, it contains a large number of methods. To make the table more readable,
    we have elided overloaded forms of the same method (those taking different kinds
    of arguments), and we grouped corresponding and related types of methods together.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 10-2\. NIO Files methods
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Return type | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `copy()` | long or `Path` | Copy a stream to a file path, file path to stream,
    or path to path. Returns the number of bytes copied or the target `Path`. A target
    file may optionally be replaced if it exists (the default is to fail if the target
    exists). Copying a directory results in an empty directory at the target (the
    contents are not copied). Copying a symbolic link copies the linked file’s data
    (producing a regular file copy). |'
  prefs: []
  type: TYPE_TB
- en: '| `createDirectory()`, `createDirectories()` | `Path` | Create a single directory
    or all directories in a specified path. `createDirectory()` throws an exception
    if the directory already exists. `createDirectories()` will ignore existing directories
    and only create as needed. |'
  prefs: []
  type: TYPE_TB
- en: '| `createFile()` | `Path` | Create an empty file. The operation is atomic and
    will only succeed if the file does not exist. (This property can be used to create
    flag files to guard resources, etc.) |'
  prefs: []
  type: TYPE_TB
- en: '| `createLink()`, `createSymbolicLink()`, `isSymbolicLink()`, `readSymbolicLink()`,
    `createLink()` | boolean or `Path` | Create a hard or symbolic link, test to see
    if a file is a symbolic link, or read the target file pointed to by the symbolic
    link. Symbolic links are files that reference other files. Regular (“hard”) links
    are low-level mirrors of a file where two filenames point to the same underlying
    data. If you don’t know which to use, use a symbolic link. |'
  prefs: []
  type: TYPE_TB
- en: '| `createTempDirectory()`, `createTempFile()` | `Path` | Create a temporary,
    guaranteed, uniquely named directory or file with the specified prefix. Optionally,
    place it in the system default temp directory. |'
  prefs: []
  type: TYPE_TB
- en: '| `delete()`, `deleteIfExists()` | void | Delete a file or an empty directory.
    `delete``IfExists()` will not throw an exception if the file does not exist. |'
  prefs: []
  type: TYPE_TB
- en: '| `exists()`, `notExists()` | boolean | Determine whether the file exists (`notExists()`
    simply returns the opposite). Optionally, specify whether links should be followed
    (by default they are). |'
  prefs: []
  type: TYPE_TB
- en: '| `getAttribute()`, `set​Attri⁠bute()`, `getFile​Attri⁠buteView()`, `readAttributes()`
    | `Object`, `Map`, or `FileAttributeView` | Get or set filesystem-specific file
    attributes such as access and update times, detailed permissions, and owner information
    using implementation-specific names. |'
  prefs: []
  type: TYPE_TB
- en: '| `getFileStore()` | `FileStore` | Get a `FileStore` object that represents
    the device, volume, or other type of partition of the filesystem on which the
    path resides. |'
  prefs: []
  type: TYPE_TB
- en: '| `getLastModifiedTime()`, `setLastModifiedTime()` | `FileTime` or `Path` |
    Get or set the last modified time of a file or directory. |'
  prefs: []
  type: TYPE_TB
- en: '| `getOwner()`, `setOwner()` | `UserPrincipal` | Get or set a `UserPrincipal`
    object representing the owner of the file. Use `toString()` or `getName()` to
    get a string representation of the username. |'
  prefs: []
  type: TYPE_TB
- en: '| `getPosixFile​Permis⁠sions()`, `setPosixFilePermissions()` | `Set` or `Path`
    | Get or set the full POSIX user-group-other style read and write permissions
    for the path as a Set of `PosixFile​Per⁠mission` enum values. |'
  prefs: []
  type: TYPE_TB
- en: '| `isDirectory()`, `isExecutable()`, `isHidden()`, `isReadable()`, `isRegularFile()`,
    `isWriteable()` | boolean | Test file features such as whether the path is a directory
    and other basic attributes. |'
  prefs: []
  type: TYPE_TB
- en: '| `isSameFile()` | boolean | Test to see whether the two paths reference the
    same file (which may potentially be true even if the paths are not identical).
    |'
  prefs: []
  type: TYPE_TB
- en: '| `move()` | `Path` | Move a file or directory by renaming or copying it, optionally
    specifying whether to replace any existing target. Rename will be used unless
    a copy is required to move a file across file stores or filesystems. Directories
    can be moved using this method only if the simple rename is possible or if the
    directory is empty. If a directory move requires copying files across file stores
    or filesystems, the method throws an `IOException`. (In this case, you must copy
    the files yourself. See `walkFileTree()`.) |'
  prefs: []
  type: TYPE_TB
- en: '| `newBufferedReader()`, `newBufferedWriter()` | `BufferedReader` or `BufferedWriter`
    | Open a file for reading via a `BufferedReader`, or create and open a file for
    writing via a `BufferedWriter`. In both cases, a character encoding is specified.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `newByteChannel()` | `SeekableByteChannel` | Create a new file or open an
    existing file as a seekable byte channel. (See the full discussion of NIO later
    in this chapter.) Consider using `FileChannel``open()` as an alternative. |'
  prefs: []
  type: TYPE_TB
- en: '| `newDirectoryStream()` | `DirectoryStream` | Return a `DirectoryStream` for
    iterating over a directory hierarchy. Optionally, supply a glob pattern or filter
    object to match files. |'
  prefs: []
  type: TYPE_TB
- en: '| `newInputStream()`, `newOutputStream()` | `InputStream` or `OutputStream`
    | Open a file for reading via an `InputStream`, or create and open a file for
    writing via an `OutputStream`. Optionally, specify file truncation for the output
    stream; if overwriting, the default is to truncate the existing file. |'
  prefs: []
  type: TYPE_TB
- en: '| `probeContentType()` | `String` | Return the MIME type of the file if it
    can be determined by installed `FileTypeDetector` services or `null` if unknown.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `readAllBytes()`, `readAllLines()` | byte[] or `List`<`String`> | Read all
    data from the file as a byte [] or all characters as a list of strings using a
    specified character encoding. |'
  prefs: []
  type: TYPE_TB
- en: '| `size()` | long | Get the size, in bytes, of the file at the specified path.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `walkFileTree()` | `Path` | Apply a `FileVisitor` to the specified directory
    tree, optionally specifying whether to follow links and a maximum depth of traversal.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `write()` | `Path` | Write an array of bytes or a collection of strings (with
    a specified character encoding) to the file at the specified path and close the
    file, optionally specifying append and truncation behavior. The default is to
    truncate and write the data. |'
  prefs: []
  type: TYPE_TB
- en: With these methods, we can fetch input or output streams, or buffered readers
    and writers, to a given file. We can also create paths as files and directories,
    and iterate through file hierarchies. We’ll discuss directory operations in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a reminder, the `resolve()` and `resolveSibling()` methods of `Path` are
    useful for constructing targets for the `copy()` and `move()` operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'For quickly reading and writing the contents of files without streaming, we
    can use the various `readAll…​` and `write` methods that move byte arrays or strings
    in and out of files in a single operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: These are convenient for files that easily fit into memory.
  prefs: []
  type: TYPE_NORMAL
- en: The NIO Package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s return to the `java.nio` package and round out our discussion of core
    Java I/O. One aspect of NIO is simply to update and enhance features of the classic
    `java.io` package. Much of the general NIO functionality does indeed overlap with
    existing APIs. However, NIO was first introduced to address specific issues of
    scalability for large systems, especially in networked applications. The following
    sections outline the basic elements of NIO.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous I/O
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most of the need for the NIO package was driven by the desire to add *nonblocking*
    and *selectable* I/O to Java. Prior to NIO, most read and write operations in
    Java were bound to threads and were forced to block for unpredictable amounts
    of time. Although certain APIs, such as Sockets (which we’ll see in [“Sockets”](ch13.html#learnjava6-CHP-13-SECT-5)),
    provided specific means to limit how long an I/O call could take, this was a workaround
    to compensate for the lack of a more general mechanism. In many languages, even
    those without threading, I/O could still be done efficiently by setting I/O streams
    to a nonblocking mode and testing them for their readiness to send or receive
    data. In a nonblocking mode, a read or write does only as much work as can be
    done immediately—filling or emptying a buffer and then returning. Combined with
    the ability to test for readiness, this allows a single-threaded application to
    continuously service many channels efficiently. The main thread “selects” a channel
    that is ready, works with it until it blocks, and then moves on to another. On
    a single-processor system, this is fundamentally equivalent to using multiple
    threads.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to nonblocking and selectable I/O, the NIO package enables closing
    and interrupting I/O operations asynchronously. As discussed in [Chapter 9](ch09.html#learnjava6-CHP-9),
    prior to NIO there was no reliable way to stop or wake up a thread blocked in
    an I/O operation. With NIO, threads blocked in I/O operations always wake up when
    interrupted or when another thread closes the channel. Additionally, if you interrupt
    a thread while it is blocked in an NIO operation, its channel is automatically
    closed. (Closing the channel because the thread is interrupted might seem too
    strong, but usually it’s the right thing to do. Leaving it open could result in
    unexpected behavior or subject the channel to unwanted manipulation.)
  prefs: []
  type: TYPE_NORMAL
- en: Performance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Channel I/O is designed around the concept of buffers, which are a sophisticated
    form of array, tailored to communication tasks. The NIO package supports the concept
    of *direct buffers*—buffers that maintain their memory outside the Java VM in
    the host operating system. Because all real I/O operations ultimately have to
    work with the host OS by maintaining the buffer space there, using direct buffers
    can make many operations more efficient. Data moving between two external endpoints
    can be transferred without first copying it into Java and back out.
  prefs: []
  type: TYPE_NORMAL
- en: Mapped and Locked Files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'NIO provides two general-purpose file-related features not found in `java.io`:
    memory-mapped files and file locking. A *memory-mapped* file behaves as if all
    of its content is in an array in memory rather than on a disk. Memory-mapped files
    are beyond the scope of this chapter, but if you work with lots of data and occasionally
    need really fast read/write access, look up the [`MappedByteBuffer` documentation](https://oreil.ly/yNLMn)
    online.'
  prefs: []
  type: TYPE_NORMAL
- en: File locking supports both shared and exclusive locks on regions of files—useful
    for concurrent access by multiple applications. We’ll look at file locking in
    [“File locking”](#learnjava6-CHP-10-SECT-3.7.2).
  prefs: []
  type: TYPE_NORMAL
- en: Channels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While `java.io` deals with streams, `java.nio` works with channels. A *channel*
    is an endpoint for communication. Although in practice channels are similar to
    streams, the underlying notion of a channel is simultaneously more abstract and
    more primitive. Whereas streams in `java.io` are defined in terms of input or
    output with methods to read and write bytes, the basic channel interface says
    nothing about how communications happen. It simply has the notion of being open
    or closed, supported via the methods `isOpen()` and `close()`. Implementations
    of channels for files, network sockets, or arbitrary devices then add their own
    methods for operations, such as reading, writing, or transferring data. NIO provides
    the following channels:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FileChannel`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Pipe.SinkChannel`, `Pipe.SourceChannel`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SocketChannel`, `ServerSocketChannel`, `DatagramChannel`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We’ll cover `FileChannel` and its asynchronous cousin, `AsynchronousFileChannel`,
    in [“FileChannel”](#learnjava6-CHP-10-SECT-3.7). (The asynchronous version essentially
    buffers all of its operations through a thread pool and reports results back through
    an asynchronous API.) The `Pipe` channels are simply the channel equivalents of
    the `java.io Pipe` facilities. The socket and datagram channels play in Java’s
    networking world, which we’ll look at in [Chapter 13](ch13.html#learnjava6-CHP-13).
    The network-related channels have asynchronous versions as well: `AsynchronousSocketChannel`,
    `AsynchronousServerSocketChannel`, and `AsynchronousDatagramChannel`.'
  prefs: []
  type: TYPE_NORMAL
- en: All these basic channels implement the `ByteChannel` interface, designed for
    channels that have read and write methods like I/O streams. `ByteChannel`s, however,
    read and write `ByteBuffer`s, as opposed to plain byte arrays.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to these channel implementations, you can bridge channels with `java.io`
    I/O streams and readers and writers for interoperability. However, if you mix
    these features, you may not get the full benefits and performance NIO offers.
  prefs: []
  type: TYPE_NORMAL
- en: Buffers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Most of the utilities of the `java.io` and `java.net` packages operate on byte
    arrays. The corresponding tools of the NIO package are built around `ByteBuffer`s
    (with a character-based buffer, `CharBuffer`, for text). Byte arrays are simple,
    so why are buffers necessary? They serve several purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: They formalize the usage patterns for buffered data, provide for things like
    read-only buffers, and keep track of read/write positions and limits within a
    large buffer space. They also provide a mark/reset facility like that of `java.io​.BufferedInputStream`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They provide additional APIs for working with raw data representing primitive
    types. You can create buffers that “view” your byte data as a series of larger
    primitives, such as `short`s, `int`s, or `float`s. The most general type of data
    buffer, `ByteBuffer`, includes methods that let you read and write all primitive
    types just like `DataInputStream` and `DataOutputStream` do for streams.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They abstract the underlying storage of the data, allowing Java to optimize
    throughput. Specifically, buffers may be allocated as direct buffers that use
    native buffers of the host operating system instead of arrays in Java’s memory.
    The NIO `Channel` facilities that work with buffers can recognize direct buffers
    automatically and try to optimize their interactions with them. For example, a
    read from a file channel into a Java byte array normally requires Java to copy
    the data for the read from the host operating system into Java’s memory. With
    a direct buffer, the data can remain in the host operating system, outside Java’s
    normal memory space, until and unless it is needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Buffer operations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The base `java.nio.Buffer` class is something like an array with state. It
    does not specify what type of elements it holds (that is for subtypes to decide),
    but it does define functionality that is common to all data buffers. A `Buffer`
    has a fixed size, called its *capacity*. Although all the standard `Buffer`s provide
    “random access” to their contents, a `Buffer` generally expects to be read and
    written sequentially, so `Buffer`s maintain the notion of a *position* where the
    next element is read or written. In addition to position, a `Buffer` can maintain
    two other pieces of state information: a *limit*, which typically denotes the
    available data in read mode and the capacity of the file in write mode, and a
    *mark*, which can be used to remember an earlier position for future recall.'
  prefs: []
  type: TYPE_NORMAL
- en: Implementations of `Buffer` add specific, typed get and put methods that read
    and write the buffer contents. For example, `ByteBuffer` is a buffer of bytes
    and it has `get()` and `put()` methods that read and write bytes and arrays of
    bytes (along with many other useful methods we’ll discuss later). Getting from
    and putting to the `Buffer` changes the position marker, so the `Buffer` keeps
    track of its contents somewhat like a stream. Attempting to read or write past
    the limit marker generates a `BufferUnderflowException` or `BufferOverflowException`,
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'The mark, position, limit, and capacity values always obey the following formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The position for reading and writing the `Buffer` is always between the mark,
    which serves as a lower bound, and the limit, which serves as an upper bound.
    The capacity represents the physical extent of the buffer space.
  prefs: []
  type: TYPE_NORMAL
- en: You can set the position and limit markers explicitly with the `position()`
    and `limit()` methods. Several convenience methods are provided for common usage
    patterns. The `reset()` method sets the position back to the mark. If no mark
    has been set, an `InvalidMarkException` is thrown. The `clear()` method resets
    the position to `0` and makes the limit the capacity, readying the buffer for
    new data (the mark is discarded). Note that the `clear()` method does not actually
    do anything to the data in the buffer; it simply changes the position markers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `flip()` method is used for the common pattern of writing data into the
    buffer and then reading it back out. `flip` makes the current position the limit
    and then resets the current position to `0` (any mark is thrown away), which saves
    having to keep track of how much data was read. Another method, `rewind()`, simply
    resets the position to `0`, leaving the limit alone. You might use it to write
    the same size of data again. Here is a snippet of code that uses these methods
    to read data from a channel and write it to two channels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This might be confusing the first time you look at it because here, the read
    from the `Channel` is actually a write to the `Buffer` and vice versa. Because
    this example writes all the available data up to the limit, either `flip()` or
    `rewind()` have the same effect in this case.
  prefs: []
  type: TYPE_NORMAL
- en: Buffer types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The various buffer implementations add get and put methods for reading and
    writing specific data types. Each of the Java primitive types has an associated
    buffer type: `ByteBuffer`, `CharBuffer`, `ShortBuffer`, `IntBuffer`, `LongBuffer`,
    `FloatBuffer`, and `DoubleBuffer`. Each provides get and put methods for reading
    and writing its type and arrays of its type. Of these, `ByteBuffer` is the most
    flexible. Because it has the “finest grain” of all the buffers, it has been given
    a full complement of get and put methods for reading and writing all the other
    data types as well as `byte`. Here are some `ByteBuffer` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'All the standard buffers also support random access. For each of the aforementioned
    methods of `ByteBuffer`, an additional form takes an index, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: But that’s not all! `ByteBuffer` can also provide “views” of itself as any of
    the coarse-grained types. For example, you can fetch a `ShortBuffer` view of a
    `ByteBuffer` with the `asShortBuffer()` method. The `ShortBuffer` view is *backed*
    by the `ByteBuffer`, which means that they work on the same data, and changes
    to either one affect the other. The view buffer’s extent starts at the `ByteBuffer`’s
    current position, and its capacity is a function of the remaining number of bytes,
    divided by the new type’s size. (For example, `short`s consume two bytes each,
    `float`s four, and `long`s and `double`s take eight.) View buffers are convenient
    for reading and writing large blocks of a contiguous type within a `ByteBuffer`.
  prefs: []
  type: TYPE_NORMAL
- en: '`CharBuffer`s are interesting as well, primarily because of their integration
    with `String`s. Both `CharBuffer`s and `String`s implement the `java.lang.CharSequence`
    interface. This is the interface that provides the standard `charAt()` and `length()`
    methods. Many other parts of Java (such as the `java.util.regex` package) allow
    you to use a `CharBuffer` or a `String` interchangeably. In this case, the `CharBuffer`
    acts like a modifiable `String` with user-configurable, logical start and end
    positions.'
  prefs: []
  type: TYPE_NORMAL
- en: Byte order
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Because we’re talking about reading and writing types larger than a byte, the
    question arises: in what order do the bytes of multibyte values (like `short`s
    and `int`s) get written? There are two camps in this world: *big-endian* and *little-endian*.^([5](ch10.html#id2150))
    Big-endian means that the most significant bytes come first; little-endian is
    the reverse. If you’re writing binary data for consumption by some native application,
    this is important. Intel-compatible computers use little-endian, and many workstations
    that run Unix use big-endian. The `ByteOrder` class encapsulates the choice. You
    can specify the byte order to use with the `ByteBuffer order()` method, using
    the identifiers `ByteOrder.BIG_ENDIAN` and `ByteOrder.LITTLE_ENDIAN`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'You can retrieve the native ordering for your platform using the static `ByteOrder.nativeOrder()`
    method. We know you’re curious:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: We ran this on a Linux desktop with an Intel chip. Give it a try on your own
    system!
  prefs: []
  type: TYPE_NORMAL
- en: Allocating buffers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can create a buffer either by allocating it explicitly using `allocate()`
    or by wrapping an existing plain Java array type. Each buffer type has a static
    `allocate()` method that takes a capacity (size), and a `wrap()` method that takes
    an existing array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'A direct buffer is allocated in the same way, with the `allocateDirect()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: As we described earlier, direct buffers can use operating system memory structures
    that are optimized for use with some kinds of I/O operations. The trade-off is
    that allocating a direct buffer is a little slower and heavier-weight operation
    than a plain buffer, so you should try to use them for longer-term buffers.
  prefs: []
  type: TYPE_NORMAL
- en: Character Encoders and Decoders
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Character encoders and decoders turn characters into raw bytes and vice versa,
    mapping from the Unicode standard to particular encoding schemes. Encoders and
    decoders have long existed in Java for use by `Reader` and `Writer` streams and
    in the methods of the `String` class that work with byte arrays. However, early
    on there was no API for working with encoding explicitly; you simply referred
    to encoders and decoders wherever necessary by name as a `String`. The `java.nio.charset`
    package formalized the idea of a Unicode character set encoding with the `Charset`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Charset` class is a factory for `Charset` instances, which know how to
    encode character buffers to byte buffers and decode byte buffers to character
    buffers. You can look up a character set by name with the static `Charset.forName()`
    method and use it in conversions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: You can also test to see if an encoding is available with the static `Charset.isSupported()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following character sets are guaranteed to be supplied:'
  prefs: []
  type: TYPE_NORMAL
- en: US-ASCII
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ISO-8859-1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UTF-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UTF-16BE (big-endian)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UTF-16LE (little-endian)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UTF-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can list all the encoders available on your platform using the static `availableCharsets()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The result of `availableCharsets()` is a map, because character sets may have
    “aliases” and appear under more than one name.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the buffer-oriented classes of the `java.nio` package, the `InputStreamReader`
    and `OutputStreamWriter` bridge classes of the `java.io` package work with `Charset`
    as well. You can specify the encoding as a `Charset` object or by name.
  prefs: []
  type: TYPE_NORMAL
- en: CharsetEncoder and CharsetDecoder
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can get more control over the encoding and decoding process by creating
    an instance of `CharsetEncoder` or `CharsetDecoder` (a codec) with the `Charset
    newEncoder()` and `newDecoder()` methods. In the previous snippet, we assumed
    that all the data was available in a single buffer. More often, however, we might
    have to process data as it arrives in chunks. The encoder/decoder API allows for
    this by providing more general `encode()` and `decode()` methods that take a flag
    specifying whether more data is expected. The codec needs to know this because
    it might have been left hanging in the middle of a multibyte character conversion
    when the data ran out. If it knows that more data is coming, it does not throw
    an error on this incomplete conversion.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following snippet, we use a decoder to read from a `ByteBuffer bbuff`
    and accumulate character data into a `CharBuffer cbuff`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we look for the end of input condition on the `in` channel to set the
    flag `done`. Note that we take advantage of the `flip()` method on `ByteBuffer`
    to set the limit to the amount of data read and reset the position, setting us
    up for the decode operation in one step. In case of problems, both `encode()`
    and `decode()` return a result object, `CoderResult`, that can determine the progress
    of encoding. The methods `isError()`, `isUnderflow()`, and `isOverflow()` on the
    `CoderResult` specify why encoding stopped: for an error, a lack of bytes on the
    input buffer, or a full output buffer, respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: FileChannel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we’ve covered the basics of channels and buffers, it’s time to look
    at a real channel type. The `FileChannel` is the NIO equivalent of the `java.io.RandomAccessFile`,
    but it provides several enhanced features in addition to some performance optimizations.
    In particular, you can use a `FileChannel` in place of a plain `java.io` file
    stream if you wish to use file locking, memory-mapped file access, or highly optimized
    data transfer between files or between file and network channels. These are all
    fairly advanced use cases, but if you do backend work or handle large quantities
    of data, they will definitely come in handy.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create a `FileChannel` for a `Path` using the static `FileChannel.open()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: By default, `open()` creates a read-only channel for the file. We can open a
    channel for writing or appending and control other, more advanced features such
    as atomic create and data syncing by passing additional options, as shown in the
    second part of the previous example. [Table 10-3](#learnjava6-CHP-10-TABLE-3)
    summarizes these options.
  prefs: []
  type: TYPE_NORMAL
- en: Table 10-3\. `java.nio.file.StandardOpenOption`
  prefs: []
  type: TYPE_NORMAL
- en: '| Option | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `APPEND` | Open the file for writing; all writes are positioned at the end
    of the file. |'
  prefs: []
  type: TYPE_TB
- en: '| `CREATE` | Use with `WRITE` to open the file and create it if needed. |'
  prefs: []
  type: TYPE_TB
- en: '| `CREATE_NEW` | Use with `WRITE` to create a file atomically; failing if the
    file already exists. |'
  prefs: []
  type: TYPE_TB
- en: '| `DELETE_ON_CLOSE` | Attempt to delete the file when it is closed or, if open,
    when the VM exits. |'
  prefs: []
  type: TYPE_TB
- en: '| `READ`, `WRITE` | Open the file for read-only or write-only (default is read-only).
    Use both for read-write. |'
  prefs: []
  type: TYPE_TB
- en: '| `SPARSE` | Use when creating a new file; requests the file be sparse. On
    filesystems where this is supported, a sparse file handles very large, mostly
    empty files without allocating as much real storage for empty portions. |'
  prefs: []
  type: TYPE_TB
- en: '| `SYNC`, `DSYNC` | Wherever possible, guarantee that write operations block
    until all data is written to storage. `SYNC` does this for all file changes including
    data and metadata (attributes), whereas `DSYNC` adds this requirement only for
    the data content of the file. |'
  prefs: []
  type: TYPE_TB
- en: '| `TRUNCATE_EXISTING` | Use `WRITE` on an existing file; set the file length
    to zero upon opening it. |'
  prefs: []
  type: TYPE_TB
- en: 'A `FileChannel` can also be constructed from a classic `FileInputStream`, `FileOutputStream`,
    or `RandomAccessFile`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '`FileChannel`s created from these file input and output streams are read-only
    or write-only, respectively. To get a read/write `FileChannel`, you must construct
    a `RandomAccessFile` with read/write options, as in the previous example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using a `FileChannel` is just like a `RandomAccessFile`, but it works with
    a `ByteBuffer` instead of byte arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'You can control how much data is read and written either by setting buffer
    position and limit markers or using another form of read/write that takes a buffer
    starting position and length. You can also read and write to a random position
    by supplying indexes with the read and write methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: In each case, the actual number of bytes read or written depends on several
    factors. The operation tries to read or write to the limit of the buffer, and
    the vast majority of the time, that is what happens with local file access. The
    operation is guaranteed to block only until at least one byte has been processed.
    Whatever happens, the number of bytes processed is returned and the buffer position
    is updated accordingly, preparing you to repeat the operation until it is complete,
    if needed. This is one of the conveniences of working with buffers; they can manage
    the count for you. Like standard streams, the channel `read()` method returns
    `-1` upon reaching the end of input.
  prefs: []
  type: TYPE_NORMAL
- en: The size of the file is always available with the `size()` method. It can change
    if you write past the end of the file. Conversely, you can truncate the file to
    a specified length with the `truncate()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Concurrent access
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`FileChannel`s are safe for use by multiple threads and guarantee a consistent
    view of that data across channels in the same VM. Unless you specify the `SYNC`
    or `DSYNC` options, however, channels do not guarantee how quickly writes are
    propagated to the storage mechanism. If you only intermittently need to be sure
    that data is safe before moving on, you can use the `force()` method to flush
    changes to disk. This method takes a Boolean argument indicating whether file
    metadata, including timestamp and permissions, must be included. Some systems
    keep track of reads on files as well as writes, so you can save a lot of updates
    if you set the flag to `false`, which indicates that you don’t care about syncing
    that metadata immediately.'
  prefs: []
  type: TYPE_NORMAL
- en: As with all `Channel`s, any thread may close a `FileChannel`. Once closed, all
    the channel’s read/write and position-related methods throw a `ClosedChannelException`.
  prefs: []
  type: TYPE_NORMAL
- en: File locking
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`FileChannel`s support exclusive and shared locks on regions of files through
    the `lock()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Locks may be either shared or exclusive. An *exclusive* lock prevents others
    from acquiring a lock of any kind on the specified file or file region. A *shared*
    lock allows others to acquire overlapping shared locks but not exclusive locks.
    These are useful as write and read locks, respectively. When you are writing,
    you don’t want others to be able to write until you’re done, but when reading,
    you need only to block others from writing, not from reading.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `lock()` method with no arguments in the previous example attempts to acquire
    an exclusive lock for the whole file. The second form accepts starting and length
    parameters, as well as a flag indicating whether the lock should be shared (`true`)
    or exclusive (`false`). The `FileLock` object returned by the `lock()` method
    can be used to release the lock:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: File locks are only guaranteed to be *cooperative*. They work when all threads
    honor them; they do not necessarily prevent a non-cooperating thread from reading
    or writing a locked file. In general, the only way to guarantee that locks are
    obeyed is for both parties to attempt to acquire the lock and proceed only if
    that attempt is successful.
  prefs: []
  type: TYPE_NORMAL
- en: Also, shared locks are not implemented on some systems, in which case all requested
    locks are exclusive. You can test whether a lock is shared with the `isShared()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: '`FileChannel` locks are held until the channel is closed or interrupted, so
    performing locks within a `try`-with-resources statement will help ensure that
    locks are released more robustly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: FileChannel Example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s see some concrete usage of our channels and buffers. We’ll create a small
    text file that includes a count of how many times it has been accessed by our
    program. Our program, then, will open the file, read the current count, increment
    that count, and then write (well, overwrite) the count back to the file. You can
    try out a complete version of the snippets below in the *AccessNIO.java* file
    in the *ch10/examples* folder.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You could absolutely tackle this project using the standard I/O classes in `java.io`.
    The NIO suite is not meant to replace the old classes wholesale, but to add functionality
    that is missing in the standard classes without breaking any code that relies
    on those classes. If you find NIO a little complex or dense, feel free to ignore
    it until you need some of those missing features, like file locking or manipulating
    metadata.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our first task is to see if our access-counting file exists (*access.txt* in
    this example, but the name is arbitrary). If not, we need to create it (and set
    the internal access counter to 1). We can use a `Path` object with the `Files`
    static helper methods to get going:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'If the file doesn’t exist yet, we can write out an initial message (“This file
    has been accessed 0 times.”) and then rewind to the beginning of the new file.
    This gives us the same baseline to work from as though the file had existed all
    along:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'If the file does exist, we need to make sure we can read from and write to
    it. We can gather this information with the `accessChannel` object we created
    in the constructor. We could certainly add other tests and more verbose error
    messages, but these minimal checks are useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we come to our primary use case. The file exists and has some content.
    We have the appropriate permissions for everything we want to do. We’ll start
    by opening the file in a read/write mode and reading its contents into a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'We want the file to be human-readable on its own, so we won’t take advantage
    of `FileChannel`’s ability to read and write binary data. We can use our knowledge
    of how the single line of text is structured to parse our access count:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can reset our position and overwrite the previous line with our
    new, updated line. Notice that we also truncate our file to the end of the saved
    message. We gave ourselves extra room to accommodate a bigger number, but we don’t
    want excess space in the actual file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Try compiling and running this example a few times. Does the count go up as
    expected? What happens if you open the file in another program like a text editor?
    Unfortunately, Java NIO only *feels* like magic. Accessing the file using any
    other program will not necessarily change its contents according to the rules
    of our little example.
  prefs: []
  type: TYPE_NORMAL
- en: wrap() Up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Almost any application bound for distribution will need to handle file I/O.
    Java has robust support for working efficiently with local files, including access
    to metadata for both files and directories. Java’s commitment to a broad compatibility
    shows up in the range of character encodings available when working with text
    files. Java is certainly known for working with nonlocal files, as well. We’ll
    tackle network I/O and web resources in [Chapter 13](ch13.html#learnjava6-CHP-13).
  prefs: []
  type: TYPE_NORMAL
- en: Review Questions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How could you check to see if a given file already exists?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you have to work with a legacy text file using an old encoding scheme, such
    as ISO 8859, how might you set up a reader to properly convert that content to
    something like UTF-8?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which package has the best classes for nonblocking file I/O?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which type of input stream might you use to parse a binary file, such as a JPEG-compressed
    image?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the three standard text streams built into the `System` class?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Absolute paths begin at a root (*/* or *C:\*, for example). Where do relative
    paths begin? More specifically, where are relative paths relative to?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you retrieve a NIO channel from an existing `FileInputStream`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Code Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For these exercises, a skeleton `Count.java` file is in the *ch10/exercises*
    folder, but feel free to start with your own class. We iterate on a single project,
    so you can use your solution from the first exercise as the starting point for
    the second, and so on. Because testing the program requires supplying different
    files on the command line, you may find it easier to run this program from a terminal
    or command window. You can certainly use the terminal tab in your IDE, too:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the classes of the `java.io` package, create a small program that will
    print the size of a file specified on the command line. For example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If no file argument is given, print an error message to `System.err`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Expand on the previous exercise to open the given file and count the number
    of lines. (For these simple exercises, it’s OK to assume the file being analyzed
    is a text file.) If you want a little practice with some of the tools from [Chapter 8](ch08.html#learnjava6-CHP-8),
    split each line based on whitespace and include a word count in the output. (You
    can use regular expressions to split words on fancier patterns such as punctuation,
    but that’s not required.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As before, if no file argument is given, print an error message to `System.err`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Convert your previous solution to use NIO classes like `Path` and `Files` instead
    of readers. You can use any part of the `java.nio` and `java.nio.file` packages
    that you like. You will almost certainly still need the `java.io.IOException`
    class from the “old” I/O, of course.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Advanced Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Accept a second command-line containing the name of a statistics log file.
    Rather than printing the various counts back to the terminal, append a line containing
    the current timestamp, the name of the file, and its three counts. The exact format
    of the line isn’t really important, but it should look something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can use either your NIO or your old I/O (OIO?) solution as your starting
    point. If you go with the NIO version, try to use a `ByteBuffer` and a `FileChannel`
    to do the writing.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If only one command-line argument is provided, revert to printing the stats
    out to the screen as before. If no arguments are provided, or if the second argument
    is not writable, print an error to `System.err`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Run this version a few times on a few files. Check your log to make sure each
    new result is correctly appended to the end of the log file and is not overwriting
    it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ^([1](ch10.html#id1908-marker)) While NIO was introduced with Java 1.4—so not
    very new anymore—it was newer than the original, basic package and the name has
    stuck.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch10.html#id1946-marker)) Standard error (`stderr`) is a stream usually
    reserved for error-related text messages that should be shown to the user of a
    command-line application. It is different from standard output (`stdout`), which
    is often redirected to a log file or another application and not seen by the user.
  prefs: []
  type: TYPE_NORMAL
- en: '^([3](ch10.html#id2038-marker)) The term is borrowed from the world of threads
    and means the same thing: an atomic file creation cannot be interrupted by another
    thread.'
  prefs: []
  type: TYPE_NORMAL
- en: ^([4](ch10.html#id2069-marker)) In OO programming, the term *factory* typically
    refers to a static helper that can construct and tailor some object. A factory
    (or factory method) is similar to a constructor, but that additional tailoring
    can add details to the new object that might be difficult (or impossible) to specify
    in a constructor.
  prefs: []
  type: TYPE_NORMAL
- en: '^([5](ch10.html#id2150-marker)) The terms *big-endian* and *little-endian*
    come from Jonathan Swift’s novel *Gulliver’s Travels*, where they denoted two
    camps of Lilliputians: those who eat eggs from the big end and those who eat them
    from the little end.'
  prefs: []
  type: TYPE_NORMAL
