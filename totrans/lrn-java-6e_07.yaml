- en: Chapter 7\. Collections and Generics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we start to use our growing knowledge of objects to handle more and more
    interesting problems, one recurring question will emerge. How do we store the
    data we’re manipulating in the course of solving those problems? We’ll definitely
    use variables of all the different types, but we’ll also need bigger, fancier
    storage options. The arrays we discussed back in [“Arrays”](ch04.html#learnjava6-CHP-4-SECT-6)
    are a start, but arrays have some limitations. In this chapter we will see how
    to get efficient, flexible access to large amounts of data using Java’s idea of
    collections. We’ll also see how to deal with the various types of data we want
    to store in these big containers like we do with individual values in variables.
    That’s where generics come in. We’ll get to those in [“Type Limitations”](#learnjava6-CHP-7-SECT-2).
  prefs: []
  type: TYPE_NORMAL
- en: Collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Collections* are data structures that are fundamental to all types of programming.
    Whenever we need to refer to a group of objects, we have some kind of collection.
    At the core language level, Java supports collections in the form of arrays. But
    arrays are static, and because they have a fixed length, they are awkward for
    groups of things that grow and shrink over the lifetime of an application. Arrays
    are also bad at representing abstract relationships between objects. In the early
    days, the Java platform had only two basic classes to address these needs: the
    `java.util.Vector` class, which represents a dynamic list of objects, and the
    `java.util.Hashtable` class, which holds a map of key/value pairs. Today, Java
    has a more comprehensive approach called the *collections framework*. The framework
    standardizes how you work with a variety of collections. The older classes still
    exist, but they have been retrofitted into the framework (with some eccentricities)
    and are generally no longer used.'
  prefs: []
  type: TYPE_NORMAL
- en: Though conceptually simple, collections are one of the most powerful parts of
    any programming language. They implement data structures that lie at the heart
    of managing complex problems. A great deal of basic computer science is devoted
    to describing the most efficient ways to implement certain types of algorithms
    over collections. (How do you quickly find something in a large collection? How
    do you sort items in a collection? How do you add or remove items efficiently?)
    Having these tools at your disposal and understanding how to use them can make
    your code both much smaller and faster. It can also save you from reinventing
    the wheel.
  prefs: []
  type: TYPE_NORMAL
- en: The original collections framework had two major drawbacks. The first was that
    collections were by necessity untyped and worked only with undifferentiated `Object`s
    instead of specific types like `Date`s and `String`s. This meant that you had
    to perform a type cast every time you took an object out of a collection. This
    flew in the face of Java’s compile-time type safety. But in practice, this was
    less a problem than it was just plain cumbersome and tedious. The second issue
    was that, for practical reasons, collections could work only with objects and
    not with primitive types. This meant that any time you wanted to put a number
    or other primitive type into a collection, you had to store it in a wrapper class
    first and unpack it later upon retrieving it. This combination of factors made
    code working with collections less readable and more dangerous.
  prefs: []
  type: TYPE_NORMAL
- en: Generic types (again, more on this in [“Type Limitations”](#learnjava6-CHP-7-SECT-2))
    make it possible for truly type-safe collections to be under the control of the
    programmer. Alongside generics, autoboxing and unboxing of primitive types means
    that you can generally treat objects and primitives as equals where collections
    are concerned. The combination of these new features adds a bit of safety and
    can significantly reduce the amount of code you write. As we’ll see, all of the
    collections classes now take advantage of these features.
  prefs: []
  type: TYPE_NORMAL
- en: The collections framework is based around a handful of interfaces in the `java.util`
    package. These interfaces are divided into two hierarchies. The first hierarchy
    descends from the `Collection` interface. This interface (and its descendants)
    represents a container that holds other objects. The second, separate hierarchy
    is based on the `Map` interface, another container that represents a group of
    key/value pairs where the key can be used to retrieve the value in an efficient
    way.
  prefs: []
  type: TYPE_NORMAL
- en: The Collection Interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The mother of all collections is an interface appropriately named `Collection`.
    It serves as a container that holds other objects, its *elements*. It doesn’t
    specify exactly how the objects are organized; it doesn’t say, for example, whether
    duplicate objects are allowed or whether the objects are ordered in any way. These
    kinds of details are left to child interfaces or implementing classes. Nevertheless,
    the `Collection` interface defines some basic operations common to all collections:'
  prefs: []
  type: TYPE_NORMAL
- en: '`public boolean add(` *`element`* `)`'
  prefs: []
  type: TYPE_NORMAL
- en: Adds the supplied object to this collection. If the operation succeeds, this
    method returns `true`. If the object already exists in this collection and the
    collection does not permit duplicates, `false` is returned. Furthermore, some
    collections are read-only. Those collections throw an `UnsupportedOperationException`
    if this method is called.
  prefs: []
  type: TYPE_NORMAL
- en: '`public boolean remove(` *`element`* `)`'
  prefs: []
  type: TYPE_NORMAL
- en: Removes the specified object from this collection. Like the `add()` method,
    this method returns `true` if the object is removed from the collection. If the
    object doesn’t exist in this collection, `false` is returned. Read-only collections
    throw an `UnsupportedOperationException` if this method is called.
  prefs: []
  type: TYPE_NORMAL
- en: '`public boolean contains(` *`element`* `)`'
  prefs: []
  type: TYPE_NORMAL
- en: Returns `true` if the collection contains the specified object.
  prefs: []
  type: TYPE_NORMAL
- en: '`public int size()`'
  prefs: []
  type: TYPE_NORMAL
- en: Returns the number of elements in this collection.
  prefs: []
  type: TYPE_NORMAL
- en: '`public boolean isEmpty()`'
  prefs: []
  type: TYPE_NORMAL
- en: Returns `true` if this collection has no elements.
  prefs: []
  type: TYPE_NORMAL
- en: '`public Iterator iterator()`'
  prefs: []
  type: TYPE_NORMAL
- en: Examines all the elements in this collection. This method returns an `Iterator`,
    which is an object you can use to step through the collection’s elements. We’ll
    talk more about iterators in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the methods `addAll()`, `removeAll()`, and `containsAll()` accept
    another `Collection` and add, remove, or test for all of the elements of the supplied
    collection.
  prefs: []
  type: TYPE_NORMAL
- en: Collection Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Collection` interface has three child interfaces. `Set` represents a collection
    in which duplicate elements are not allowed. `List` is a collection whose elements
    have a specific order. The `Queue` interface is a buffer for objects with a notion
    of a “head” element that’s next in line for processing.
  prefs: []
  type: TYPE_NORMAL
- en: Set
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`Set` has no methods besides the ones it inherits from `Collection`. It simply
    enforces its no-duplicates rule. If you try to add an element that already exists
    in a `Set`, the `add()` method simply returns `false`. `SortedSet` maintains elements
    in a prescribed order; like a sorted list that cannot contain duplicates. You
    can retrieve subsets (which are also sorted) using the `subSet()`, `headSet()`,
    and `tailSet()` methods. These methods accept one or two elements that mark the
    boundaries. The `first()` and `last()` calls provide access to the first and last
    elements, respectively. And the `comparator()` method returns the object used
    to compare elements (more on this in [“A Closer Look: The sort() Method”](#learnjava6-CHP-7-SECT-7)).'
  prefs: []
  type: TYPE_NORMAL
- en: '`NavigableSet` extends `SortedSet` and adds methods for finding the closest
    match greater or lesser than a target value within the sort order of the `Set`.
    You can implement this interface efficiently using techniques such as skip lists,
    which make finding ordered elements fast.'
  prefs: []
  type: TYPE_NORMAL
- en: List
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The next child interface of `Collection` is `List`. A `List` is an ordered
    collection, similar to an array but with methods for manipulating the position
    of elements in the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '`public boolean add(E` *`element`* `)`'
  prefs: []
  type: TYPE_NORMAL
- en: Adds the specified element to the end of the list.
  prefs: []
  type: TYPE_NORMAL
- en: '`public void add(int` *`index`* `, E` *`element`* `)`'
  prefs: []
  type: TYPE_NORMAL
- en: Inserts the given object at the supplied position in the list. If the position
    is less than zero or greater than the list length, an `IndexOutOfBoundsException`
    will be thrown. The element that was previously at the supplied position, and
    all elements after it, are moved up one index position.
  prefs: []
  type: TYPE_NORMAL
- en: '`public void remove(int` *`index`* `)`'
  prefs: []
  type: TYPE_NORMAL
- en: Removes the element at the specified position. All subsequent elements move
    down one index position.
  prefs: []
  type: TYPE_NORMAL
- en: '`public E get(int` *`index`* `)`'
  prefs: []
  type: TYPE_NORMAL
- en: Returns the element at the given position but does not change the list.
  prefs: []
  type: TYPE_NORMAL
- en: '`public Object set(int` *`index`* `, E` *`element`* `)`'
  prefs: []
  type: TYPE_NORMAL
- en: Changes the element at the given position to the specified object. There must
    already be an object at the index or else an `IndexOutOfBoundsException` is thrown.
    No other elements of the list are affected.
  prefs: []
  type: TYPE_NORMAL
- en: The type `E` in these methods refers to the parameterized element type of the
    `List` class. `Collection`, `Set`, and `List` are all interface types. This is
    an example of the Generics feature we hinted at in the introduction to this chapter,
    and we’ll look at concrete implementations of these shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Queue
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A `Queue` is a collection that acts like a buffer for elements. The queue maintains
    the insertion order of items placed into it and has the notion of a “head” item.
    Queues may be first in, first out (FIFO or “in order”) or last in, first out (LIFO,
    sometimes “most recent” or “reverse” order), depending on the implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '`public boolean offer(E element)`, `public boolean add(E element)`'
  prefs: []
  type: TYPE_NORMAL
- en: The `offer()` method attempts to place the element into the queue, returning
    `true` if successful. Different `Queue` types may have different limits or restrictions
    on element types (including capacity). This method differs from the `add()` method
    inherited from `Collection` in that it returns a Boolean value instead of throwing
    an exception to indicate that the collection cannot accept the element.
  prefs: []
  type: TYPE_NORMAL
- en: '`public E` `poll()`, `public E remove()`'
  prefs: []
  type: TYPE_NORMAL
- en: The `poll()` method removes the element at the head of the queue and returns
    it. This method differs from the `Collection` method `remove()` in that if the
    queue is empty, `null` is returned instead of throwing an exception.
  prefs: []
  type: TYPE_NORMAL
- en: '`public E` `peek()`'
  prefs: []
  type: TYPE_NORMAL
- en: Returns the head element *without* removing it from the queue. If the queue
    is empty, `null` is returned.
  prefs: []
  type: TYPE_NORMAL
- en: The Map Interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The collections framework also includes the `java.util.Map`, which is a collection
    of key/value pairs. Other names for a map are “dictionary” or “associative array.”
    Maps store and retrieve elements with key values; they are very useful for things
    like caches and minimalist databases. When you store a value in a map, you associate
    a key object with that value. When you need to look up the value, the map retrieves
    it using the key.
  prefs: []
  type: TYPE_NORMAL
- en: 'With generics (that `E` type again), a `Map` type is parameterized with two
    types: one for the keys and one for the values. The following snippet uses a `HashMap`,
    which is an efficient but unordered type of map implementation that we’ll discuss
    later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In legacy code, maps simply map `Object` types to `Object` types and require
    an appropriate cast to retrieve values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic operations on `Map` are straightforward. In the following methods,
    the type `K` refers to the key parameter type, and the type `V` refers to the
    value parameter type:'
  prefs: []
  type: TYPE_NORMAL
- en: '`public V put(K` *`key`* `, V` *`value`* `)`'
  prefs: []
  type: TYPE_NORMAL
- en: Adds the specified key/value pair to the map. If the map already contains a
    value for the specified key, the old value is replaced and returned as the result.
  prefs: []
  type: TYPE_NORMAL
- en: '`public V get(K` *`key`* `)`'
  prefs: []
  type: TYPE_NORMAL
- en: Retrieves the value corresponding to `key` from the map.
  prefs: []
  type: TYPE_NORMAL
- en: '`public V remove(K` *`key`* `)`'
  prefs: []
  type: TYPE_NORMAL
- en: Removes the value corresponding to `key` from the map. The value removed is
    returned.
  prefs: []
  type: TYPE_NORMAL
- en: '`public int size()`'
  prefs: []
  type: TYPE_NORMAL
- en: Returns the number of key/value pairs in this map.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can retrieve all the keys or values in the map using the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`public Set keySet()`'
  prefs: []
  type: TYPE_NORMAL
- en: This method returns a `Set` that contains all the keys in this map.
  prefs: []
  type: TYPE_NORMAL
- en: '`public Collection values()`'
  prefs: []
  type: TYPE_NORMAL
- en: Use this method to retrieve all the values in this map. The returned `Collection`
    can contain duplicate elements.
  prefs: []
  type: TYPE_NORMAL
- en: '`public Set entrySet()`'
  prefs: []
  type: TYPE_NORMAL
- en: This method returns a `Set` that contains all the key/value pairs (as `Map.Entry`
    objects) in this map.
  prefs: []
  type: TYPE_NORMAL
- en: '`Map` has one child interface, `SortedMap`. A `SortedMap` maintains its key/value
    pairs sorted in a particular order according to the keys. It provides the `subMap()`,
    `headMap()`, and `tailMap()` methods for retrieving sorted map subsets. Like `SortedSet`,
    it also provides a `comparator()` method, which returns an object that determines
    how the map keys are sorted. We’ll talk more about that in [“A Closer Look: The
    sort() Method”](#learnjava6-CHP-7-SECT-7). Java 7 added a `NavigableMap` with
    functionality parallel to that of `NavigableSet`; namely, it adds methods to search
    the sorted elements for an element greater or lesser than a target value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we should make it clear that although they’re related, `Map` is not
    literally a type of `Collection` (`Map` does not extend the `Collection` interface).
    You might wonder why. All of the methods of the `Collection` interface would appear
    to make sense for `Map`, except for `iterator()`. A `Map`, again, has two sets
    of objects: keys and values, and separate iterators for each. This is why a `Map`
    does not implement a `Collection`. If you do want a `Collection`-like view of
    a `Map` with both keys and values, you can use the `entrySet()` method.'
  prefs: []
  type: TYPE_NORMAL
- en: 'One more note about maps: some map implementations (including Java’s standard
    `HashMap`) allow `null` to be used as a key or value, but others do not.'
  prefs: []
  type: TYPE_NORMAL
- en: Type Limitations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generics are about abstraction. Generics let you create classes and methods
    that work in the same way on different types of objects. The term *generic* comes
    from the idea that we’d like to be able to write general algorithms that can be
    broadly reused for many types of objects rather than having to adapt our code
    to fit each circumstance. This concept is not new; it is the impetus behind object-oriented
    programming itself. Java generics do not so much add new capabilities to the language
    as they make reusable Java code easier to write and easier to read.
  prefs: []
  type: TYPE_NORMAL
- en: Generics take reuse to the next level by making the *type* of the objects we
    work with an explicit parameter of the generic code. For this reason, generics
    are also referred to as *parameterized types*. In the case of a generic class,
    the developer specifies a type as a parameter (an argument) whenever they use
    the generic type. The class is parameterized by the supplied type to which the
    code adapts itself.
  prefs: []
  type: TYPE_NORMAL
- en: In other languages, generics are sometimes referred to as *templates*, which
    is more of an implementation term. Templates are like intermediate classes, waiting
    for their type parameters so that they can be used. Java takes a different path,
    which has both benefits and drawbacks that we’ll describe in detail in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: There is much to say about Java generics. Some of the fine points may seem a
    bit obscure at first, but don’t get discouraged. The vast majority of what you’ll
    do with generics—using existing classes such as `List` and `Set`, for example—is
    easy and intuitive. Designing and creating your own generics requires a more careful
    understanding and will come with a little patience and tinkering.
  prefs: []
  type: TYPE_NORMAL
- en: 'We begin our discussion in that intuitive space with the most compelling case
    for generics: the container classes and collections we just covered. Next, we
    take a step back and look at the good, bad, and ugly of how Java generics work.
    We conclude by looking at a couple of real-world generic classes in Java.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Containers: Building a Better Mousetrap'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Recall that in an object-oriented programming language like Java, *polymorphism*
    means that objects are always interchangeable to some degree. Any child of a type
    of object can serve in place of its parent type and, ultimately, every object
    is a child of `java.lang.Object`: the object-oriented “Eve,” so to speak.'
  prefs: []
  type: TYPE_NORMAL
- en: It is natural for the most general types of containers in Java to work with
    the type `Object` so that they can hold just about anything. By *containers*,
    we mean classes that hold instances of other classes in some way. The Java collections
    framework we looked at in the previous section is the best example of containers.
    `List`, to recap, holds an ordered collection of elements of type `Object`. And
    `Map` holds an association of key/value pairs, with the keys and values also being
    of the most general type, `Object`. With a little help from wrappers for primitive
    types, this arrangement has served us well. But (not to get too Zen on you), a
    “collection of any type” is also a “collection of no type,” and working with `Object`s
    pushes a great deal of responsibility onto the developer.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s kind of like a costume party for objects where everybody is wearing the
    same mask and disappears into the crowd of the collection. Once objects are dressed
    as the `Object` type, the compiler can no longer see the real types and loses
    track of them. It’s up to the user to pierce the anonymity of the objects later
    by using a type cast. And like attempting to yank off a partygoer’s fake beard,
    you’d better have the cast correct or you’ll get an unwelcome surprise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `List` interface has an `add()` method that accepts any type of `Object`.
    Here, we assigned an instance of `ArrayList`, which is simply an implementation
    of the `List` interface, and added a `Date` object. Is the cast in this example
    correct? It depends on what happens in the elided “other code” period of time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Java compiler knows this type of activity is fraught and currently issues
    warnings when you add elements to a simple `ArrayList`, as above. We can see this
    with a little *jshell* detour. After importing from the `java.util` and `javax.swing`
    packages, try creating an `ArrayList` and add a few disparate elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You can see that the warning is the same no matter what type of object you `add()`.
    In the last step, where we display the contents of `things`, both the plain `String`
    object and the `JLabel` object are happily in the list. The compiler is not worried
    about using disparate types; it is helpfully warning you that it will not know
    whether casts such as the `(Date)` cast above will work at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Can Containers Be Fixed?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s natural to ask if there is a way to make this situation better. What if
    we know that we are only going to put `Date`s into our list? Can’t we just make
    our own list that only accepts `Date` objects, get rid of the cast, and let the
    compiler help us again? The answer, perhaps surprisingly, is no. At least, not
    in a very satisfying way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our first instinct may be to try to “override” the methods of `ArrayList` in
    a subclass. But of course, rewriting the `add()` method in a subclass would not
    actually override anything; it would add a new *overloaded* method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The resulting object still accepts any kind of object—it just invokes different
    methods to get there.
  prefs: []
  type: TYPE_NORMAL
- en: Moving along, we might take on a bigger task. For example, we might write our
    own `DateList` class that does not extend `ArrayList` but rather delegates the
    guts of its methods to the `ArrayList` implementation. With a fair amount of tedious
    work, that would get us an object that does everything a `List` does but works
    with `Date`s in a way that both the compiler and the runtime environment can understand
    and enforce. However, we’ve now shot ourselves in the foot because our container
    is no longer an implementation of `List`. That means we can’t use it interoperably
    with all of the utilities that deal with collections, such as `Collections`.`sort()`,
    or add it to another collection with the `Collection addAll()` method.
  prefs: []
  type: TYPE_NORMAL
- en: To generalize, the problem is that instead of refining the behavior of our objects,
    what we really want to do is to change their contract with the user. We want to
    adapt their method signatures to a more specific type, and polymorphism doesn’t
    allow that. So are we stuck with `Object`s for our collections? That’s where generics
    come in.
  prefs: []
  type: TYPE_NORMAL
- en: Enter Generics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we noted when introducing the type limitations in the previous section, generics
    enhance the syntax of classes that allow us to specialize the class for a given
    type or set of types. A generic class requires one or more *type parameters* wherever
    we refer to the class type. It uses them to customize itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look at the source or Javadoc for the `List` class, for example, you’ll
    see it defines something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The identifier `E` between the angle brackets (`<>`) is a *type parameter*.^([1](ch07.html#id1465))
    It indicates that the class `List` is generic and requires a Java type as an argument
    to make it complete. The name `E` is arbitrary, but there are conventions that
    we’ll see as we go on. In this case, the type parameter `E` represents the type
    of elements we want to store in the list. The `List` class refers to the type
    parameter within its body and methods as if it were a real type, to be substituted
    later. The type parameter may be used to declare instance variables, arguments
    to methods, and the return type of methods. In this case, `E` is used as the type
    for the elements we’ll be adding via the `add()` method and for the return type
    of the `get()` method. Let’s see how to use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same angle bracket syntax supplies the type parameter when we want to use
    the `List` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In this snippet, we declared a variable called `listOfStrings` using the generic
    type `List` with a type parameter of `String`. `String` refers to the `String`
    class, but we could have a specialized `List` with any Java class type. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Completing the type by supplying its type parameter is called *instantiating
    the type*. It is also sometimes called *invoking the type*, by analogy with invoking
    a method and supplying its arguments. Whereas with a regular Java type we simply
    refer to the type by name, a generic type like `List<>` must be instantiated with
    parameters wherever it is used.^([2](ch07.html#id1468)) Specifically, this means
    that we must instantiate the type everywhere types can appear: as the declared
    type of a variable (as shown in this code snippet), as the type of a method parameter,
    as the return type of a method, or in an object allocation expression using the
    `new` keyword.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Returning to our `listOfStrings`, what we have now is effectively a `List`
    in which the type `String` has been substituted for the type variable `E` in the
    class body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We have specialized the `List` class to work with elements of type `String`
    and *only* elements of type `String`. This method signature is no longer capable
    of accepting an arbitrary `Object` type.
  prefs: []
  type: TYPE_NORMAL
- en: '`List` is just an interface. To use the variable, we’ll need to create an instance
    of some actual implementation of `List`. As we did in our introduction, we’ll
    use `ArrayList`. As before, `ArrayList` is a class that implements the `List`
    interface, but in this case, both `List` and `ArrayList` are generic classes.
    As such, they require type parameters to instantiate them where they are used.
    Of course, we’ll create our `ArrayList` to hold `String` elements to match our
    `List` of `String`s:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As always, the `new` keyword takes a Java type and parentheses with possible
    arguments for the class’s constructor. In this case, the type is `ArrayList<String>`—the
    generic `ArrayList` type instantiated with the `String` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Declaring variables (as shown in the first line of the preceding example) is
    a bit cumbersome because it requires us to provide the generic parameter type
    twice: once on the left side in the variable type and once on the right in the
    initialing expression. And in complicated cases, the generic types can get very
    lengthy and nested within one another.'
  prefs: []
  type: TYPE_NORMAL
- en: The compiler is smart enough to infer the type of the initializing expression
    from the type of the variable to which you are assigning it. This is called *generic
    type inference* and boils down to the fact that you can use shorthand on the right
    side of your variable declarations by leaving out the contents of the `<>` notation,
    as shown in the example’s second version.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now use our specialized `List` with strings. The compiler prevents us
    from even trying to put anything other than a `String` object (or a subtype of
    `String` if there were any) into the list. It also allows us to fetch `String`
    objects with the `get()` method without requiring any cast:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s take another example from the Collections API. The `Map` interface provides
    a dictionary-like mapping that associates key objects with value objects. Keys
    and values do not have to be of the same type. The generic `Map` interface requires
    two type parameters: one for the key type and one for the value type. The Javadoc
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We can make a `Map` that stores `Employee` objects by `Integer` “employee ID”
    numbers, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Here, we used `HashMap`, which is a generic class that implements the `Map`
    interface. We instantiated both types with the type parameters `Integer` and `Employee`.
    The `Map` now works only with keys of type `Integer` and holds values of type
    `Employee`.
  prefs: []
  type: TYPE_NORMAL
- en: The reason we used `Integer` here to hold our number is that the type parameters
    to a generic class must be class types. We can’t parameterize a generic class
    with a primitive type, such as `int` or `boolean`. Fortunately, autoboxing of
    primitives in Java (see [“Wrappers for Primitive Types”](ch05.html#learnjava6-CHP-5-SECT-2.6))
    almost makes it appear as if we can by allowing us to use primitive types as though
    they were wrapper types.
  prefs: []
  type: TYPE_NORMAL
- en: Dozens of other APIs beyond Collections use generics to let you adapt them to
    specific types. We’ll talk about them as they occur throughout the book.
  prefs: []
  type: TYPE_NORMAL
- en: Talking About Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we move on to more important things, we should say a few words about
    the way we describe a particular parameterization of a generic class. Because
    the most common and compelling case for generics is for container-like objects,
    it’s common to think in terms of a generic type “holding” a parameter type. In
    our example, we called our `List<String>` a “list of strings” because, sure enough,
    that’s what it was. Similarly, we might have called our employee map a “Map of
    Employee IDs to Employee Objects.” However, these descriptions focus a little
    more on what the classes *do* than on the type itself.
  prefs: []
  type: TYPE_NORMAL
- en: Take instead a single object container called `Trap< E >` that could be instantiated
    on an object of type `Mouse` or of type `Bear`; that is, `Trap<Mouse>` or `Trap<Bear>`.
    Our instinct is to call the new type a “mouse trap” or “bear trap.” We can think
    of our list of strings as a new type, as well. We could talk about a “string list”
    or describe our employee map as a new “integer employee object map” type. You
    may use whatever verbiage you prefer, but these latter descriptions focus more
    on the notion of the generic as a *type* and may help you keep the terms straight
    when we discuss how generic types are related in the type system. There we’ll
    see that the container terminology turns out to be a little counterintuitive.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we’ll discuss generic types in Java from a different
    perspective. We’ve seen a little of what they can do; now we need to talk about
    how they do it.
  prefs: []
  type: TYPE_NORMAL
- en: “There Is No Spoon”
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the movie *The Matrix*,^([3](ch07.html#id1481)) the hero Neo is offered
    a choice: take the blue pill and remain in the world of fantasy, or take the red
    pill and see things as they really are. In dealing with generics in Java, we are
    faced with a similar ontological dilemma. We can go only so far in any discussion
    of generics before we are forced to confront the reality of how they are implemented.
    Our fantasy world is one created by the compiler to make our lives writing code
    easier to accept. Our reality (though not quite the dystopian nightmare in the
    movie) is a harsher place, filled with unseen dangers and questions. Why don’t
    casts and tests work properly with generics? Why can’t I implement what appear
    to be two different generic interfaces in one class? Why can I declare an array
    of generic types, even though there is no way in Java to create such an array?!?'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll answer these questions and more in the rest of this chapter, and you won’t
    even have to wait for the sequel. You’ll be bending spoons (well, types) in no
    time. Let’s get started.
  prefs: []
  type: TYPE_NORMAL
- en: Erasure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The design goals for Java generics were formidable: add a radical new syntax
    to the language that safely introduces parameterized types with no impact on performance
    and, oh, by the way, make it backward compatible with all existing Java code and
    don’t change the compiled classes in any serious way. It’s amazing that they actually
    satisfied these conditions and no surprise that it took a while. But as always,
    some necessary compromises led to some headaches.'
  prefs: []
  type: TYPE_NORMAL
- en: To accomplish this feat, Java employs a technique called *erasure*. Erasure
    relates to the idea that since most everything we do with generics applies statically
    at compile time, generic information does not need to be carried over into the
    compiled classes. The generic nature of the classes, enforced by the compiler,
    can be “erased” in the binary classes, maintaining compatibility with nongeneric
    code.
  prefs: []
  type: TYPE_NORMAL
- en: While Java does retain information about the generic features of classes in
    the compiled form, this information is used mainly by the compiler. The Java runtime
    does not know anything about generics at all (and does not waste any resources
    on them).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use *jshell* to confirm the runtime notion of a parameterized `List<E>`
    still being a `List`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'But our generic `dateList` clearly does not implement the `List` methods just
    discussed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This illustrates the somewhat eclectic nature of Java generics. The compiler
    believes in them, but the runtime says they are an illusion. What if we try something
    a little simpler and check that our `dateList` is a `List<Date>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This time the compiler simply puts its foot down and says, “No.” You can’t test
    for a generic type in an `instanceof` operation. Since there are no discernible
    classes for different parameterizations of `List` at runtime (every `List` is
    still a `List`), there is no way for the `instanceof` operator to tell the difference
    between one incarnation of `List` and another. All of the generic safety checking
    was done at compile time, so at runtime we’re just dealing with a single actual
    `List` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what really happened: the compiler erased all of the angle bracket syntax
    and replaced the type parameters in our `List` class with a type that can work
    at runtime with any allowed type: in this case, `Object`. We would seem to be
    back where we started, except that the compiler still has the knowledge to enforce
    our usage of the generics in the code at compile time and can, therefore, handle
    the cast for us. If you decompile a class using a `List<Date>` (the *javap* command
    with the *-c* option shows you the bytecode, if you dare), you will see that the
    compiled code actually contains the cast to `Date`, even though we didn’t write
    it ourselves.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now answer one of the questions posed at the beginning of the section:
    “Why can’t I implement what appear to be two different generic interfaces in one
    class?” We can’t have a class that implements two different generic `List` instantiations
    because they are really the same type at runtime, and there is no way to tell
    them apart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Fortunately, there are always workarounds. In this case, for example, you can
    use a common superclass or create multiple classes. The alternatives may not be
    as elegant, but you can almost always land on a clean answer—even if it is a little
    verbose.
  prefs: []
  type: TYPE_NORMAL
- en: Raw Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although the compiler treats different parameterizations of a generic type as
    different types (with different APIs) at compile time, we have seen that only
    one real type exists at runtime. For example, both `List<Date>` and `List<String>`
    share the plain old Java class `List`. `List` is called the *raw type* of the
    generic class. Every generic has a raw type. It is the base, “plain” Java form
    from which all of the generic type information has been removed and the type variables
    replaced by a general Java type like `Object`.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is possible to use raw types in Java. However, the Java compiler generates
    a warning wherever they are used in an “unsafe” way. Outside *jshell*, the compiler
    still notices these problems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This snippet uses the raw `List` type just as old-fashioned Java code prior
    to Java 5 would have. The difference is that now the Java compiler issues an *unchecked
    warning* about the code if we attempt to insert an object into the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The compiler instructs us to use the `-Xlint:unchecked` option to get more
    specific information about the locations of unsafe operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Note that creating and assigning the raw `ArrayList` does not generate a warning.
    It is only when we try to use an “unsafe” method (one that refers to a type variable)
    that we get the warning. This means that it’s still OK to use older-style, nongeneric
    Java APIs that work with raw types. We get warnings only when we do something
    unsafe in our own code.
  prefs: []
  type: TYPE_NORMAL
- en: 'One more thing about erasure before we move on. In the previous examples, the
    type variables were replaced by the `Object` type, which could represent any type
    applicable to the type variable `E`. Later, we’ll see that this is not always
    the case. We can place limitations or *bounds* on the parameter types, and, when
    we do, the compiler can be more restrictive about the erasure of the type, for
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This parameter type declaration says that the element type `E` must be a subtype
    of the `Date` type. In this case, the erasure of the `addElement()` method is
    therefore more restrictive than `Object`, and the compiler uses `Date`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '`Date` is called the *upper bound* of this type, meaning that it is the top
    of the object hierarchy here. You can only instantiate the parameterized type
    on a `Date` or on a “lower” (more derived, or subclassed) type.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a handle on what generic types really are, we can go into a
    little more detail about how they behave.
  prefs: []
  type: TYPE_NORMAL
- en: Parameterized Type Relationships
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We know now that parameterized types share a common, raw type. This is why
    our parameterized `List<Date>` is just a `List` at runtime. In fact, we can assign
    any instantiation of `List` to the raw type if we want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We can even go the other way and assign a raw type to a specific instantiation
    of the generic type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This statement generates an unchecked warning on the assignment, but after that,
    the compiler trusts that the list contained only `Date`s prior to the assignment.
    You can try casting `new ArrayList()` to `List<Date>`, but that won’t address
    the warning. We’ll talk about casting to generic types in [“Casts”](#learnjava6-CHP-7-SECT-6).
  prefs: []
  type: TYPE_NORMAL
- en: 'Whatever the runtime types, the compiler is running the show. It does not let
    us assign things that are clearly incompatible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Of course, the `ArrayList<String>` does not implement the methods of `List<Date>`
    required by the compiler, so these types are incompatible.
  prefs: []
  type: TYPE_NORMAL
- en: But what about more interesting type relationships? The `List` interface, for
    example, is a subtype of the more general `Collection` interface. Can you take
    a particular instantiation of the generic `List` and assign it to some instantiation
    of the generic `Collection`? Does it depend on the type parameters and their relationships?
    Clearly, a `List<Date>` is not a `Collection<String>`. But is a `List<Date>` a
    `Collection<Date>`? Can a `List<Date>` be a `Collection<Object>`?
  prefs: []
  type: TYPE_NORMAL
- en: We’ll just blurt out the answer here first, then walk through it and explain.
    The rule for the simple types of generic instantiations we’ve discussed so far
    is that *inheritance applies only to the “base” generic type and not to the parameter
    types*. Furthermore, assignability applies only when the two generic types are
    instantiated on *exactly the same parameter type*. In other words, there is still
    one-dimensional inheritance, following the base generic class type, but with the
    additional restriction that the parameter types must be identical.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, since a `List` is a type of `Collection`, we can assign instantiations
    of `List` to instantiations of `Collection` when the type parameter is exactly
    the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This code snippet says that a `List<Date>` is a `Collection<Date>`—pretty intuitive.
    But trying the same logic on a variation in the parameter types fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Although our intuition tells us that the `Date`s in that `List` could all live
    happily as `Object`s in a `List`, the assignment is an error. We’ll explain precisely
    why in the next section, but for now just note that the type parameters are not
    exactly the same and that there is no inheritance relationship among parameter
    types in generics.
  prefs: []
  type: TYPE_NORMAL
- en: This is a case where it helps to think of the instantiation in terms of types
    and not in terms of what the instantiated objects do. These are not really a “list
    of dates” and a “list of objects”—more like a `DateList` and an `ObjectList`,
    the relationship of which is not immediately obvious.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try to pick out what’s OK and what’s not OK in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: It is possible for an instantiation of `List` to be an instantiation of `Collection`,
    but only if the parameter types are exactly the same. Inheritance doesn’t follow
    the parameter types, so the final assignment in this example fails.
  prefs: []
  type: TYPE_NORMAL
- en: 'Earlier we mentioned that this rule applies to the simple types of instantiations
    we’ve discussed so far in this chapter. What other types are there? Well, the
    kinds of instantiations we’ve seen so far where we plug in an actual Java type
    as a parameter are called *concrete type instantiations*. Later, we’ll talk about
    *wildcard instantiations*, which are like mathematical set operations on types
    (think unions and intersections). It’s possible to make more exotic instantiations
    of generics where the type relationships are actually two-dimensional, depending
    both on the base type and the parameterization. But don’t worry: this doesn’t
    come up very often and is not as scary as it sounds.'
  prefs: []
  type: TYPE_NORMAL
- en: Why Isn’t a List<Date> a List<Object>?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s a reasonable question. Why shouldn’t we be able to assign our `List<Date>`
    to a `List<Object>` and work with the `Date` elements as `Object` types?
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason gets back to the heart of the rationale for generics: changing programming
    contracts. In the simplest case, supposing a `DateList` type extends an `ObjectList`
    type, the `DateList` would have all of the methods of `ObjectList` and we could
    insert `Object`s into it. Now, you might object that generics let us change the
    method signatures, so that doesn’t apply anymore. That’s true, but there is a
    bigger problem. If we could assign our `DateList` to an `ObjectList` variable,
    we could use `Object` methods to insert elements of types other than `Date` into
    it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We could *alias* (provide an alternate, broader type) the `DateList` as an
    `ObjectList`. Using the aliased object, we could try to trick it into accepting
    some other type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We’d expect to get a runtime error when the actual `DateList` implementation
    was presented with the wrong type of object.
  prefs: []
  type: TYPE_NORMAL
- en: And therein lies the problem. Java generics have no runtime representation.
    Even if this functionality were useful, there is no way for Java to know what
    to do at runtime. This feature is simply dangerous—it allows for an error at runtime
    that can’t be caught at compile time. In general, we’d like to catch type errors
    at compile time.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might think Java could guarantee the type safety of your code if it compiles
    with no unchecked warnings by disallowing these assignments. Unfortunately it
    can’t, but that limitation has nothing to do with generics; it has to do with
    arrays. (If this all sounds familiar to you, it’s because we mentioned this issue
    in [Chapter 4](ch04.html#learnjava6-CHP-4) in relation to Java arrays.) Array
    types have an inheritance relationship that allows this kind of aliasing to occur:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Arrays have runtime representations as different classes. They check themselves
    at runtime, throwing an `ArrayStoreException` in situations like this. The Java
    compiler cannot guarantee the type safety of your code if you use arrays in this
    way.
  prefs: []
  type: TYPE_NORMAL
- en: Casts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve now talked about relationships between generic types and even between
    generic types and raw types. But we haven’t really explored the concept of casts
    in the world of generics.
  prefs: []
  type: TYPE_NORMAL
- en: 'No cast was necessary when we interchanged generics with their raw types. But
    we triggered unchecked warnings from the compiler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Normally, we use a cast in Java to work with two types that could be assignable.
    For example, we could attempt to cast an `Object` to a `Date` because it is plausible
    that the `Object` could be a `Date` value. The cast then performs the check at
    runtime to see if we are correct.
  prefs: []
  type: TYPE_NORMAL
- en: Casting between unrelated types is a compile-time error. For example, we can’t
    even try to cast an `Integer` to a `String`. Those types have no inheritance relationship.
    What about casts between compatible generic types?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This code snippet shows a valid cast from a more general `Collection<Date>`
    to a `List<Date>`. The cast is plausible here because a `Collection<Date>` is
    assignable from and could actually be a `List<Date>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, the following cast catches our mistake: we have aliased a `TreeSet<Date>`
    as a `Collection<Date>` and tried to cast it to a `List<Date>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'There is one case where casts are not effective with generics, however, and
    that is when trying to differentiate the types based on their parameter types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Here, we aliased an `ArrayList<String>` as a plain `Object`. Next, we cast `o`
    to a `List<Date>`. Unfortunately, Java does not know the difference between a
    `List<String>` and a `List<Date>` at runtime, so the cast is fruitless. The compiler
    warns us by generating an unchecked warning at the location of the cast. When
    we try to use the cast object, `ld`, we might find out that it is incorrect. Casts
    on generic types are ineffective at runtime because of erasure and the lack of
    type information.
  prefs: []
  type: TYPE_NORMAL
- en: Converting Between Collections and Arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While not related by direct inheritance or shared interfaces, converting between
    collections and arrays is still straightforward. For convenience, you can retrieve
    the elements of a collection as an array using the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The first method returns a plain `Object` array. With the second form, we can
    be more specific and get back an array of the correct element type. If we supply
    an array of sufficient size, it will be filled in with the values. But if the
    array is too short (for instance, zero length), Java will create a new array of
    the *same type but the required length* and return it instead. So you can just
    pass in an empty array of the correct type like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This trick is a little awkward. It would be nice if Java let us specify the
    type explicitly using a `Class` reference, but for some reason, it doesn’t.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going the other way, you can convert an array of objects to a `List` collection
    with the static `asList()` method of the `java.util.Arrays` helper class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The compiler is also smart enough to recognize a valid assignment to a `List<String>`
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: Iterator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An *iterator* is an object that lets you step through a sequence of values.
    This kind of operation comes up so often that it has a standard interface: `java.util.Iterator`.
    The `Iterator` interface has three interesting methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`public E next()`'
  prefs: []
  type: TYPE_NORMAL
- en: This method returns the next element (an element of generic type E) of the associated
    collection.
  prefs: []
  type: TYPE_NORMAL
- en: '`public boolean hasNext()`'
  prefs: []
  type: TYPE_NORMAL
- en: This method returns `true` if you have not yet stepped through all the `Collection`’s
    elements. In other words, it returns `true` if you can call `next()` to get the
    next element.
  prefs: []
  type: TYPE_NORMAL
- en: '`public void remove()`'
  prefs: []
  type: TYPE_NORMAL
- en: This method removes the most recent object returned from `next()` from the associated
    `Collection`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows how to use an `Iterator` to print out every element
    of a collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'After using `next()` to get the next element, you can sometimes `remove()`
    it. Working your way through a to-do list, for example, might follow a pattern:
    “get an item, process the item, remove the item.” But the removal feature of iterators
    is not always appropriate and not all iterators implement `remove()`. It doesn’t
    make sense to be able to remove an element from a read-only collection, for example.'
  prefs: []
  type: TYPE_NORMAL
- en: If element removal is not allowed, an `UnsupportedOperationException` is thrown
    from this method. If you call `remove()` before first calling `next()`, or if
    you call `remove()` twice in a row, you’ll get an `IllegalStateException`.
  prefs: []
  type: TYPE_NORMAL
- en: Looping over collections
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A form of the `for` loop, described in [“The for loop”](ch04.html#learnjava6-CHP-4-SECT-5.1.4),
    can operate over all `Iterable` types, which means it can iterate over all types
    of `Collection` objects as that interface extends `Iterable`. For example, it
    can now step over all of the elements of a typed collection of `Date` objects,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This feature of the Java built-in `for` loop is called the “enhanced” `for`
    loop (as opposed to the pregenerics, numeric-only `for` loop). The enhanced `for`
    loop applies only to `Collection` type collections, not `Map`s. But looping over
    a map can be useful in some situations. You can use the `Map` methods `keySet()`
    or `values()` (or even `entrySet()` if you want each key/value pair as a single
    entity) to get a collection from your map that *does* work with this enhanced
    `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The collection of keys is a simple, unordered set. The enhanced `for` loop above
    will show all of your employees, but their printed order might appear somewhat
    random. If you wanted them listed in order of their IDs or perhaps their names,
    you would need to sort the keys or values first. Fortunately, sorting is a very
    common task—and the collections framework can help.
  prefs: []
  type: TYPE_NORMAL
- en: 'A Closer Look: The sort() Method'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Poking around in the `java.util.Collections` class, we find all kinds of static
    utility methods for working with collections. Among them is this goody—the static
    generic method `sort()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Another nut for us to crack. Let’s focus on the last part of the bound:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This is a wildcard instantiation that we mentioned in [“Parameterized Type Relationships”](#learnjava6-CHP-7-SECT-5).
    In this case, it is an interface, so we can read the `extends` in the `sort()`
    return type as `implements` if it helps.
  prefs: []
  type: TYPE_NORMAL
- en: '`Comparable` holds a `compareTo()` method for some parameter type. A `Comparable<String>`
    means that the `compareTo()` method takes type `String`. Therefore, `Comparable<?
    super T>` is the set of instantiations of `Comparable` on `T` and all of its superclasses.
    A `Comparable<T>` suffices and, at the other end, so does a `Comparable<Object>`.'
  prefs: []
  type: TYPE_NORMAL
- en: What this means in English is that the elements must be comparable to their
    own type, or some supertype of their own type for the `sort()` method to use them.
    This ensures that the elements can all be compared to one another, but it’s not
    as restrictive as saying that they must all implement the `compareTo()` method
    themselves. Some of the elements may inherit the `Comparable` interface from a
    parent class that knows how to compare only to a supertype of `T`, and that is
    exactly what is allowed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Application: Trees on the Field'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is a lot of theory in this chapter. Don’t be afraid of theory—it can help
    you predict behavior in novel scenarios and inspire solutions to new problems.
    But practice is just as important, so let’s revisit the game that we started in
    [“Classes”](ch05.html#learnjava6-CHP-5-SECT-1). In particular, it’s time to store
    more than one object of each type.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 13](ch13.html#learnjava6-CHP-13) we’ll cover networking and look
    at creating a two-player setup that would require storing multiple physicists.
    For now, we still have one physicist who can throw one apple at a time. But we
    can populate our field with several trees for target practice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add six trees. We’ll use a pair of loops so you can easily increase the
    tree count if you wish. Our `Field` currently stores a lone tree instance. We
    can upgrade that storage to a typed list (we’ll call it `trees`). From there we
    can approach adding and removing trees in a number of ways:'
  prefs: []
  type: TYPE_NORMAL
- en: We could create some methods for `Field` that work with the list and maybe enforce
    some other game rules (like managing a maximum number of trees).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We could just use the list directly since the `List` class already has nice
    methods for most of the things we want to do.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We could use some combination of those approaches: special methods where it
    makes sense for our game, and direct manipulation everywhere else.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Since we do have some game rules that are peculiar to our `Field`, we’ll take
    the first approach here. (But look at the examples and think about how you might
    alter them to use the list of trees directly.) We’ll start with an `addTree()`
    method. One benefit of this approach is that we can also relocate the creation
    of the tree instance to our method rather than creating and manipulating the tree
    separately. Here’s one way to add a tree at a desired point on the field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'With that method in place, we could add a couple of trees quite quickly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Those two lines add a pair of trees side by side. Let’s go ahead and write
    the loops we need to create our six trees:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Can you see now how easy it would be to add eight or nine or a hundred trees?
    Computers are really good at repetition.
  prefs: []
  type: TYPE_NORMAL
- en: Hooray for creating our forest of apple targets! We left off a few critical
    details, though. Most importantly, we need to show our new forest on the screen.
    We also need to update our drawing method for the `Field` class so that it understands
    and uses our list of trees correctly. Eventually we’ll do the same for our physicists
    and apples as we add more functionality to our game. We’ll also need a way to
    remove elements that are no longer active. But first, let’s see our forest!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Since we are already in the `Field` class where our `trees` are stored, there
    is no need to write a separate function to pull out an individual tree and paint
    it. We can use the nifty enhanced `for` loop structure and quickly get all of
    our trees on the field, as shown in [Figure 7-1](#learnjava6-CHP-7-FIG-1).
  prefs: []
  type: TYPE_NORMAL
- en: '![ljv6 0701](assets/ljv6_0701.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-1\. Rendering all the trees in our `List`
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Useful Features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Java collections and generics are very powerful and useful additions to the
    language. Although some of the details we delved into in the latter half of this
    chapter may seem daunting, the common usage is very simple and compelling: generics
    make collections better. As you begin to use generics more, you will find that
    your code becomes more readable and more maintainable. Collections allow for elegant,
    efficient storage. Generics make explicit what you previously had to infer from
    usage.'
  prefs: []
  type: TYPE_NORMAL
- en: Review Questions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you want to store a contact list with names and phone numbers, which kind
    of collection would work best?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What method do you use to get an iterator for the items in a `Set`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you turn a `List` into an array?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you turn an array into a `List`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What interface should you implement to sort a list using the `Collections.sort()`
    method?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Code Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The class `EmployeeList` in the *ch07exercises* folder contains a few employees
    loaded into a map of employee IDs and `Employee` objects, similar to the one used
    in several examples above. We mentioned printing these employees in a sorted fashion,
    but didn’t show any code. Try to sort the employees by their ID numbers. You’ll
    likely need to use the `keySet()` method and then create a temporary—but sortable—list
    from that set.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In [Advanced Exercise 5.1](ch05.html#learnjava6-CHP-5-SECT-7.3), you created
    a new obstacle class, `Hedge`. Update the game so that you can have multiple hedges
    similar to the multiple trees. Make sure all of your trees and hedges paint correctly
    when you run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Advanced Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Code Exercise 1 above, you probably sorted the keys of the map and then
    used the correctly sorted keys to get the corresponding employee. For a bit more
    of a challenge, implement the `Comparable` interface in your `Employee` class.
    You can decide how you want to organize the employees: by ID, by last name, by
    full name, or maybe some combination of those attributes. Rather than sorting
    the `keySet()` collection, try sorting your newly comparable employees directly
    by building a temporary list from the `values()` of your map.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: ^([1](ch07.html#id1465-marker)) You may also see the term *type variable* used.
    The Java Language Specification mostly uses *parameter* so that’s what we try
    to stick with, but you may see both names used in the wild.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch07.html#id1468-marker)) That is, unless you want to use a generic type
    in a nongeneric way. We’ll talk about “raw” types later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch07.html#id1481-marker)) For those of you who might like some context
    for the title of this section, here is where it comes from. Our hero, Neo, is
    learning about his powers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Boy: Do not try and bend the spoon. That’s impossible. Instead, only try to
    realize the truth.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Neo: What truth?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Boy: There is no spoon.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Neo: There is no spoon?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Boy: Then you’ll see that it is not the spoon that bends, it is only yourself.'
  prefs: []
  type: TYPE_NORMAL
- en: —The Wachowskis. *The Matrix*. 136 minutes. Warner Brothers, 1999.
  prefs: []
  type: TYPE_NORMAL
