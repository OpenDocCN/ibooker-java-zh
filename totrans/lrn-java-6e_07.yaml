- en: Chapter 7\. Collections and Generics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章\. 集合与泛型
- en: As we start to use our growing knowledge of objects to handle more and more
    interesting problems, one recurring question will emerge. How do we store the
    data we’re manipulating in the course of solving those problems? We’ll definitely
    use variables of all the different types, but we’ll also need bigger, fancier
    storage options. The arrays we discussed back in [“Arrays”](ch04.html#learnjava6-CHP-4-SECT-6)
    are a start, but arrays have some limitations. In this chapter we will see how
    to get efficient, flexible access to large amounts of data using Java’s idea of
    collections. We’ll also see how to deal with the various types of data we want
    to store in these big containers like we do with individual values in variables.
    That’s where generics come in. We’ll get to those in [“Type Limitations”](#learnjava6-CHP-7-SECT-2).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们利用日益增长的对象知识来处理更多有趣的问题，一个经常出现的问题是如何存储我们在解决这些问题过程中操作的数据？我们肯定会使用各种不同类型的变量，但我们还需要更大更复杂的存储选项。我们在[“数组”](ch04.html#learnjava6-CHP-4-SECT-6)章节中讨论过的数组是一个开始，但是数组有一些限制。在本章中，我们将看到如何使用Java集合的概念来高效、灵活地访问大量数据。我们还将看到如何处理我们想要存储在这些大容器中的各种类型的数据，就像我们处理变量中的单个值一样。这就是泛型的用武之地。我们将在[“类型限制”](#learnjava6-CHP-7-SECT-2)中深入讨论它们。
- en: Collections
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合
- en: '*Collections* are data structures that are fundamental to all types of programming.
    Whenever we need to refer to a group of objects, we have some kind of collection.
    At the core language level, Java supports collections in the form of arrays. But
    arrays are static, and because they have a fixed length, they are awkward for
    groups of things that grow and shrink over the lifetime of an application. Arrays
    are also bad at representing abstract relationships between objects. In the early
    days, the Java platform had only two basic classes to address these needs: the
    `java.util.Vector` class, which represents a dynamic list of objects, and the
    `java.util.Hashtable` class, which holds a map of key/value pairs. Today, Java
    has a more comprehensive approach called the *collections framework*. The framework
    standardizes how you work with a variety of collections. The older classes still
    exist, but they have been retrofitted into the framework (with some eccentricities)
    and are generally no longer used.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*集合*是所有类型编程中基础的数据结构。每当我们需要引用一组对象时，就会涉及某种类型的集合。在核心语言级别上，Java通过数组支持集合。但是数组是静态的，由于长度固定，对于应用程序生命周期内增长和缩小的对象组来说显得笨拙。数组也不擅长表示对象之间的抽象关系。在早期，Java平台仅有两个基本类来满足这些需求：`java.util.Vector`类代表动态对象列表，`java.util.Hashtable`类保存键/值对映射。如今，Java有了更全面的方法，称为*集合框架*。该框架标准化了处理各种集合的方式。旧的类仍然存在，但已经被整合到框架中（带有一些古怪之处），通常不再使用。'
- en: Though conceptually simple, collections are one of the most powerful parts of
    any programming language. They implement data structures that lie at the heart
    of managing complex problems. A great deal of basic computer science is devoted
    to describing the most efficient ways to implement certain types of algorithms
    over collections. (How do you quickly find something in a large collection? How
    do you sort items in a collection? How do you add or remove items efficiently?)
    Having these tools at your disposal and understanding how to use them can make
    your code both much smaller and faster. It can also save you from reinventing
    the wheel.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在概念上简单，集合是任何编程语言中最强大的部分之一。它们实现了管理复杂问题核心的数据结构。基础计算机科学致力于描述如何以最高效的方式实现某些类型的算法来操作集合。
    （如何在大型集合中快速找到某物？如何对集合中的项目进行排序？如何高效地添加或删除项目？）掌握这些工具并理解如何使用它们可以使您的代码变得更小更快。它还可以避免重复造轮子。
- en: The original collections framework had two major drawbacks. The first was that
    collections were by necessity untyped and worked only with undifferentiated `Object`s
    instead of specific types like `Date`s and `String`s. This meant that you had
    to perform a type cast every time you took an object out of a collection. This
    flew in the face of Java’s compile-time type safety. But in practice, this was
    less a problem than it was just plain cumbersome and tedious. The second issue
    was that, for practical reasons, collections could work only with objects and
    not with primitive types. This meant that any time you wanted to put a number
    or other primitive type into a collection, you had to store it in a wrapper class
    first and unpack it later upon retrieving it. This combination of factors made
    code working with collections less readable and more dangerous.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的集合框架有两个主要缺陷。第一个是集合由于需要是无类型的，只能使用未区分的`Object`而不能使用特定类型如`Date`和`String`。这意味着每次从集合中取出对象时都必须进行类型转换。这与Java的编译时类型安全相悖。但实际上，这不是问题，只是非常繁琐和乏味。第二个问题是，出于实际原因，集合只能处理对象而不能处理原始类型。这意味着每当你想将数字或其他原始类型放入集合时，你必须首先将其存储在包装类中，然后在检索时解包。这些因素的结合使得使用集合的代码更加难以阅读和更加危险。
- en: Generic types (again, more on this in [“Type Limitations”](#learnjava6-CHP-7-SECT-2))
    make it possible for truly type-safe collections to be under the control of the
    programmer. Alongside generics, autoboxing and unboxing of primitive types means
    that you can generally treat objects and primitives as equals where collections
    are concerned. The combination of these new features adds a bit of safety and
    can significantly reduce the amount of code you write. As we’ll see, all of the
    collections classes now take advantage of these features.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型类型（稍后在[“类型限制”](#learnjava6-CHP-7-SECT-2)中详述）使得真正类型安全的集合可以由程序员控制。除了泛型，原始类型的自动装箱和拆箱意味着在涉及集合时，你通常可以将对象和原始类型视为相等。这些新特性的结合增加了一些安全性，并且可以显著减少你编写的代码量。正如我们将看到的，现在所有的集合类都利用了这些特性。
- en: The collections framework is based around a handful of interfaces in the `java.util`
    package. These interfaces are divided into two hierarchies. The first hierarchy
    descends from the `Collection` interface. This interface (and its descendants)
    represents a container that holds other objects. The second, separate hierarchy
    is based on the `Map` interface, another container that represents a group of
    key/value pairs where the key can be used to retrieve the value in an efficient
    way.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 集合框架围绕`java.util`包中的少数接口展开。这些接口分为两个层次结构。第一个层次结构从`Collection`接口派生。这个接口（及其子类）代表一个容器，用来保存其他对象。第二个独立的层次结构基于`Map`接口，另一个容器，表示一组键值对，其中键可以用来以高效的方式检索值。
- en: The Collection Interface
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**集合接口**'
- en: 'The mother of all collections is an interface appropriately named `Collection`.
    It serves as a container that holds other objects, its *elements*. It doesn’t
    specify exactly how the objects are organized; it doesn’t say, for example, whether
    duplicate objects are allowed or whether the objects are ordered in any way. These
    kinds of details are left to child interfaces or implementing classes. Nevertheless,
    the `Collection` interface defines some basic operations common to all collections:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 所有集合的鼻祖是一个名为`Collection`的接口。它作为容器来保存其他对象，即它的*元素*。它并不明确指定对象的组织方式；例如，它并不说明是否允许重复对象或对象是否以某种方式有序。这些细节留给子接口或实现类处理。尽管如此，`Collection`接口定义了一些对所有集合通用的基本操作：
- en: '`public boolean add(` *`element`* `)`'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`public boolean add(` *`element`* `)`'
- en: Adds the supplied object to this collection. If the operation succeeds, this
    method returns `true`. If the object already exists in this collection and the
    collection does not permit duplicates, `false` is returned. Furthermore, some
    collections are read-only. Those collections throw an `UnsupportedOperationException`
    if this method is called.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 将提供的对象添加到此集合。如果操作成功，则此方法返回`true`。如果对象已经存在于此集合中并且集合不允许重复，则返回`false`。此外，某些集合是只读的。如果调用此方法，则这些集合会抛出`UnsupportedOperationException`。
- en: '`public boolean remove(` *`element`* `)`'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`public boolean remove(` *`element`* `)`'
- en: Removes the specified object from this collection. Like the `add()` method,
    this method returns `true` if the object is removed from the collection. If the
    object doesn’t exist in this collection, `false` is returned. Read-only collections
    throw an `UnsupportedOperationException` if this method is called.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 从此集合中移除指定对象。类似于`add()`方法，如果从集合中移除对象，则此方法返回`true`。如果对象在此集合中不存在，则返回`false`。只读集合在调用此方法时会抛出`UnsupportedOperationException`。
- en: '`public boolean contains(` *`element`* `)`'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`public boolean contains(` *`element`* `)`'
- en: Returns `true` if the collection contains the specified object.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果集合包含指定对象，则返回`true`。
- en: '`public int size()`'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`public int size()`'
- en: Returns the number of elements in this collection.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 返回此集合中的元素数。
- en: '`public boolean isEmpty()`'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`public boolean isEmpty()`'
- en: Returns `true` if this collection has no elements.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果此集合没有元素，则返回`true`。
- en: '`public Iterator iterator()`'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`public Iterator iterator()`'
- en: Examines all the elements in this collection. This method returns an `Iterator`,
    which is an object you can use to step through the collection’s elements. We’ll
    talk more about iterators in the next section.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 检查此集合中的所有元素。此方法返回一个`Iterator`，这是一个可以用来遍历集合元素的对象。我们将在下一节详细讨论迭代器。
- en: Additionally, the methods `addAll()`, `removeAll()`, and `containsAll()` accept
    another `Collection` and add, remove, or test for all of the elements of the supplied
    collection.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，方法`addAll()`、`removeAll()`和`containsAll()`接受另一个`Collection`，并添加、移除或测试供应集合的所有元素。
- en: Collection Types
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合类型
- en: The `Collection` interface has three child interfaces. `Set` represents a collection
    in which duplicate elements are not allowed. `List` is a collection whose elements
    have a specific order. The `Queue` interface is a buffer for objects with a notion
    of a “head” element that’s next in line for processing.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`Collection`接口有三个子接口。`Set`表示不允许重复元素的集合。`List`是其元素具有特定顺序的集合。`Queue`接口是具有“头”元素概念的对象缓冲区，该元素是下一个要处理的元素。'
- en: Set
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集合
- en: '`Set` has no methods besides the ones it inherits from `Collection`. It simply
    enforces its no-duplicates rule. If you try to add an element that already exists
    in a `Set`, the `add()` method simply returns `false`. `SortedSet` maintains elements
    in a prescribed order; like a sorted list that cannot contain duplicates. You
    can retrieve subsets (which are also sorted) using the `subSet()`, `headSet()`,
    and `tailSet()` methods. These methods accept one or two elements that mark the
    boundaries. The `first()` and `last()` calls provide access to the first and last
    elements, respectively. And the `comparator()` method returns the object used
    to compare elements (more on this in [“A Closer Look: The sort() Method”](#learnjava6-CHP-7-SECT-7)).'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`Set`除了从`Collection`继承的方法外，没有其他方法。它只是强制执行不允许重复的规则。如果尝试添加已存在于`Set`中的元素，则`add()`方法简单地返回`false`。`SortedSet`按照规定的顺序维护元素；类似于无法包含重复项的排序列表。您可以使用`subSet()`、`headSet()`和`tailSet()`方法检索子集（这些子集也是排序的）。这些方法接受一个或两个标记边界的元素。`first()`和`last()`调用提供对第一个和最后一个元素的访问。`comparator()`方法返回用于比较元素的对象（关于此方法的更多信息请参见[“深入了解：sort()
    方法”](#learnjava6-CHP-7-SECT-7)）。'
- en: '`NavigableSet` extends `SortedSet` and adds methods for finding the closest
    match greater or lesser than a target value within the sort order of the `Set`.
    You can implement this interface efficiently using techniques such as skip lists,
    which make finding ordered elements fast.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`NavigableSet`扩展了`SortedSet`并添加了一些方法，用于在`Set`的排序顺序内找到大于或小于目标值的最接近匹配。您可以使用跳跃表等技术有效地实现此接口，使得查找有序元素变得更快。'
- en: List
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列表
- en: 'The next child interface of `Collection` is `List`. A `List` is an ordered
    collection, similar to an array but with methods for manipulating the position
    of elements in the list:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`Collection`的下一个子接口是`List`。`List`是一个有序集合，类似于数组，但具有用于操作列表中元素位置的方法：'
- en: '`public boolean add(E` *`element`* `)`'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`public boolean add(E` *`element`* `)`'
- en: Adds the specified element to the end of the list.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 将指定元素从列表末尾移除。
- en: '`public void add(int` *`index`* `, E` *`element`* `)`'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`public void add(int` *`index`* `, E` *`element`* `)`'
- en: Inserts the given object at the supplied position in the list. If the position
    is less than zero or greater than the list length, an `IndexOutOfBoundsException`
    will be thrown. The element that was previously at the supplied position, and
    all elements after it, are moved up one index position.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表中指定位置插入给定对象。如果位置小于零或大于列表长度，则抛出`IndexOutOfBoundsException`。原来在指定位置的元素和其后的所有元素都将向上移动一个索引位置。
- en: '`public void remove(int` *`index`* `)`'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`public void remove(int` *`index`* `)`'
- en: Removes the element at the specified position. All subsequent elements move
    down one index position.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 移除指定位置的元素。所有后续元素向下移动一个索引位置。
- en: '`public E get(int` *`index`* `)`'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`public E get(int` *`index`* `)`'
- en: Returns the element at the given position but does not change the list.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 返回给定位置的元素，但不更改列表。
- en: '`public Object set(int` *`index`* `, E` *`element`* `)`'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`public Object set(int` *`index`* `, E` *`element`* `)`'
- en: Changes the element at the given position to the specified object. There must
    already be an object at the index or else an `IndexOutOfBoundsException` is thrown.
    No other elements of the list are affected.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 将给定位置的元素更改为指定对象。必须已经有一个对象在索引处，否则会抛出 `IndexOutOfBoundsException`。不会影响列表的其他元素。
- en: The type `E` in these methods refers to the parameterized element type of the
    `List` class. `Collection`, `Set`, and `List` are all interface types. This is
    an example of the Generics feature we hinted at in the introduction to this chapter,
    and we’ll look at concrete implementations of these shortly.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法中的类型 `E` 是 `List` 类的参数化元素类型。`Collection`、`Set` 和 `List` 都是接口类型。这是我们在本章开头提到的泛型特性的一个示例，我们将很快看到这些类型的具体实现。
- en: Queue
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 队列
- en: 'A `Queue` is a collection that acts like a buffer for elements. The queue maintains
    the insertion order of items placed into it and has the notion of a “head” item.
    Queues may be first in, first out (FIFO or “in order”) or last in, first out (LIFO,
    sometimes “most recent” or “reverse” order), depending on the implementation:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`Queue` 是一个行为类似缓冲区的集合。队列维护放入其中的项目的插入顺序，并且有“头”项目的概念。队列可以是先进先出（FIFO 或“按顺序”）或后进先出（LIFO，有时是“最近”或“逆序”），这取决于实现：'
- en: '`public boolean offer(E element)`, `public boolean add(E element)`'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`public boolean offer(E element)`, `public boolean add(E element)`'
- en: The `offer()` method attempts to place the element into the queue, returning
    `true` if successful. Different `Queue` types may have different limits or restrictions
    on element types (including capacity). This method differs from the `add()` method
    inherited from `Collection` in that it returns a Boolean value instead of throwing
    an exception to indicate that the collection cannot accept the element.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`offer()` 方法尝试将元素放入队列，如果成功则返回 `true`。不同的 `Queue` 类型可能对元素类型（包括容量）有不同的限制或限制。该方法与从
    `Collection` 继承的 `add()` 方法不同，它返回一个布尔值而不是抛出异常以指示集合无法接受元素。'
- en: '`public E` `poll()`, `public E remove()`'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`public E` `poll()`, `public E remove()`'
- en: The `poll()` method removes the element at the head of the queue and returns
    it. This method differs from the `Collection` method `remove()` in that if the
    queue is empty, `null` is returned instead of throwing an exception.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`poll()` 方法移除队列头部的元素并返回它。该方法与 `Collection` 的 `remove()` 方法不同，如果队列为空，则返回 `null`
    而不是抛出异常。'
- en: '`public E` `peek()`'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`public E` `peek()`'
- en: Returns the head element *without* removing it from the queue. If the queue
    is empty, `null` is returned.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 返回头部元素，但不从队列中删除它。如果队列为空，则返回 `null`。
- en: The Map Interface
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 映射接口
- en: The collections framework also includes the `java.util.Map`, which is a collection
    of key/value pairs. Other names for a map are “dictionary” or “associative array.”
    Maps store and retrieve elements with key values; they are very useful for things
    like caches and minimalist databases. When you store a value in a map, you associate
    a key object with that value. When you need to look up the value, the map retrieves
    it using the key.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 集合框架还包括 `java.util.Map`，它是一组键值对的集合。映射的其他名称包括“字典”或“关联数组”。映射存储和检索具有键值的元素；它们对于像缓存和最小数据库这样的东西非常有用。将值存储在映射中时，您将一个键对象与该值关联起来。当您需要查找值时，映射使用键检索它。
- en: 'With generics (that `E` type again), a `Map` type is parameterized with two
    types: one for the keys and one for the values. The following snippet uses a `HashMap`,
    which is an efficient but unordered type of map implementation that we’ll discuss
    later:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 使用泛型（再次出现的 `E` 类型），`Map` 类型是使用两种类型进行参数化的：一种用于键，一种用于值。以下片段使用 `HashMap`，这是一种高效但无序的映射实现类型，我们稍后会讨论它：
- en: '[PRE0]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In legacy code, maps simply map `Object` types to `Object` types and require
    an appropriate cast to retrieve values.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在旧代码中，映射简单地将 `Object` 类型映射到 `Object` 类型，并需要适当的类型转换来检索值。
- en: 'The basic operations on `Map` are straightforward. In the following methods,
    the type `K` refers to the key parameter type, and the type `V` refers to the
    value parameter type:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`Map` 的基本操作很简单。在以下方法中，类型 `K` 是指键参数类型，类型 `V` 是指值参数类型：'
- en: '`public V put(K` *`key`* `, V` *`value`* `)`'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Adds the specified key/value pair to the map. If the map already contains a
    value for the specified key, the old value is replaced and returned as the result.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '`public V get(K` *`key`* `)`'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Retrieves the value corresponding to `key` from the map.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '`public V remove(K` *`key`* `)`'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Removes the value corresponding to `key` from the map. The value removed is
    returned.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '`public int size()`'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Returns the number of key/value pairs in this map.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'You can retrieve all the keys or values in the map using the following methods:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '`public Set keySet()`'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: This method returns a `Set` that contains all the keys in this map.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '`public Collection values()`'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Use this method to retrieve all the values in this map. The returned `Collection`
    can contain duplicate elements.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '`public Set entrySet()`'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: This method returns a `Set` that contains all the key/value pairs (as `Map.Entry`
    objects) in this map.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '`Map` has one child interface, `SortedMap`. A `SortedMap` maintains its key/value
    pairs sorted in a particular order according to the keys. It provides the `subMap()`,
    `headMap()`, and `tailMap()` methods for retrieving sorted map subsets. Like `SortedSet`,
    it also provides a `comparator()` method, which returns an object that determines
    how the map keys are sorted. We’ll talk more about that in [“A Closer Look: The
    sort() Method”](#learnjava6-CHP-7-SECT-7). Java 7 added a `NavigableMap` with
    functionality parallel to that of `NavigableSet`; namely, it adds methods to search
    the sorted elements for an element greater or lesser than a target value.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we should make it clear that although they’re related, `Map` is not
    literally a type of `Collection` (`Map` does not extend the `Collection` interface).
    You might wonder why. All of the methods of the `Collection` interface would appear
    to make sense for `Map`, except for `iterator()`. A `Map`, again, has two sets
    of objects: keys and values, and separate iterators for each. This is why a `Map`
    does not implement a `Collection`. If you do want a `Collection`-like view of
    a `Map` with both keys and values, you can use the `entrySet()` method.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'One more note about maps: some map implementations (including Java’s standard
    `HashMap`) allow `null` to be used as a key or value, but others do not.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Type Limitations
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generics are about abstraction. Generics let you create classes and methods
    that work in the same way on different types of objects. The term *generic* comes
    from the idea that we’d like to be able to write general algorithms that can be
    broadly reused for many types of objects rather than having to adapt our code
    to fit each circumstance. This concept is not new; it is the impetus behind object-oriented
    programming itself. Java generics do not so much add new capabilities to the language
    as they make reusable Java code easier to write and easier to read.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Generics take reuse to the next level by making the *type* of the objects we
    work with an explicit parameter of the generic code. For this reason, generics
    are also referred to as *parameterized types*. In the case of a generic class,
    the developer specifies a type as a parameter (an argument) whenever they use
    the generic type. The class is parameterized by the supplied type to which the
    code adapts itself.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型将重用推向了一个新的水平，通过使我们处理的对象的 *类型* 成为泛型代码的显式参数。因此，泛型也被称为 *参数化类型*。对于泛型类来说，开发者在使用泛型类型时指定一个类型作为参数（一个参数），代码则根据提供的类型进行自适应。
- en: In other languages, generics are sometimes referred to as *templates*, which
    is more of an implementation term. Templates are like intermediate classes, waiting
    for their type parameters so that they can be used. Java takes a different path,
    which has both benefits and drawbacks that we’ll describe in detail in this chapter.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他语言中，泛型有时被称为 *模板*，这更多是一种实现术语。模板就像是中间类，等待其类型参数以便使用。Java 走了一条不同的路线，这既有利也有弊，我们将在本章节详细描述。
- en: There is much to say about Java generics. Some of the fine points may seem a
    bit obscure at first, but don’t get discouraged. The vast majority of what you’ll
    do with generics—using existing classes such as `List` and `Set`, for example—is
    easy and intuitive. Designing and creating your own generics requires a more careful
    understanding and will come with a little patience and tinkering.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Java 泛型有很多值得探讨的地方。一些细节起初可能显得有点晦涩，但不要灰心。你将会大量使用泛型，例如使用现有的类如 `List` 和 `Set`，这些都是简单直观的。设计和创建你自己的泛型需要更谨慎的理解，以及一点耐心和试验。
- en: 'We begin our discussion in that intuitive space with the most compelling case
    for generics: the container classes and collections we just covered. Next, we
    take a step back and look at the good, bad, and ugly of how Java generics work.
    We conclude by looking at a couple of real-world generic classes in Java.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从直觉的角度开始讨论泛型的最引人注目的案例：刚才提到的容器类和集合。接下来，我们退一步，看看 Java 泛型的好坏与丑陋。最后，我们将看几个 Java
    中真实世界的泛型类。
- en: 'Containers: Building a Better Mousetrap'
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器：打造更好的捕鼠器
- en: 'Recall that in an object-oriented programming language like Java, *polymorphism*
    means that objects are always interchangeable to some degree. Any child of a type
    of object can serve in place of its parent type and, ultimately, every object
    is a child of `java.lang.Object`: the object-oriented “Eve,” so to speak.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在像 Java 这样的面向对象编程语言中，*多态性* 意味着对象总是在某种程度上可互换的。任何类型对象的子类都可以替代其父类型，最终，每个对象都是
    `java.lang.Object` 的子类：可以说是面向对象的“夏娃”。
- en: It is natural for the most general types of containers in Java to work with
    the type `Object` so that they can hold just about anything. By *containers*,
    we mean classes that hold instances of other classes in some way. The Java collections
    framework we looked at in the previous section is the best example of containers.
    `List`, to recap, holds an ordered collection of elements of type `Object`. And
    `Map` holds an association of key/value pairs, with the keys and values also being
    of the most general type, `Object`. With a little help from wrappers for primitive
    types, this arrangement has served us well. But (not to get too Zen on you), a
    “collection of any type” is also a “collection of no type,” and working with `Object`s
    pushes a great deal of responsibility onto the developer.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Java 中最一般类型的容器通常与类型 `Object` 一起工作，因此它们可以容纳几乎任何内容。通过 *容器*，我们指的是以某种方式持有其他类实例的类。我们在前一节中看到的
    Java 集合框架就是容器的最佳例子。`List`，简而言之，持有一个类型为 `Object` 的有序元素集合。而 `Map` 则持有键值对的关联，其键和值也是最一般的类型
    `Object`。通过原始类型的包装器的帮助，这种安排已经为我们服务良好。但是（不要太深奥），“任何类型的集合”也是“没有类型的集合”，而且使用 `Object`
    带来了开发者很大的责任。
- en: 'It’s kind of like a costume party for objects where everybody is wearing the
    same mask and disappears into the crowd of the collection. Once objects are dressed
    as the `Object` type, the compiler can no longer see the real types and loses
    track of them. It’s up to the user to pierce the anonymity of the objects later
    by using a type cast. And like attempting to yank off a partygoer’s fake beard,
    you’d better have the cast correct or you’ll get an unwelcome surprise:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这有点像对象的化装派对，每个人都戴着同样的面具，消失在集合的人群中。一旦对象穿上`Object`类型的服装，编译器就再也看不到真正的类型并且无法跟踪它们。用户需要稍后使用类型转换来穿透对象的匿名性。就像试图拔掉派对参与者的假胡须一样，您最好确保类型转换是正确的，否则会得到一个不受欢迎的惊喜：
- en: '[PRE1]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `List` interface has an `add()` method that accepts any type of `Object`.
    Here, we assigned an instance of `ArrayList`, which is simply an implementation
    of the `List` interface, and added a `Date` object. Is the cast in this example
    correct? It depends on what happens in the elided “other code” period of time.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`List`接口有一个接受任何类型`Object`的`add()`方法。在这里，我们分配了一个`ArrayList`的实例，它只是`List`接口的一个实现，并添加了一个`Date`对象。这个例子中的转换是否正确？这取决于省略的“其他代码”段内发生了什么。'
- en: 'The Java compiler knows this type of activity is fraught and currently issues
    warnings when you add elements to a simple `ArrayList`, as above. We can see this
    with a little *jshell* detour. After importing from the `java.util` and `javax.swing`
    packages, try creating an `ArrayList` and add a few disparate elements:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Java编译器知道这种类型的活动是危险的，并且在您向简单的`ArrayList`添加元素时发出警告，就像上面的例子一样。我们可以通过一个小小的*jshell*迂回看到这一点。在从`java.util`和`javax.swing`包导入后，尝试创建一个`ArrayList`并添加一些不同的元素：
- en: '[PRE2]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You can see that the warning is the same no matter what type of object you `add()`.
    In the last step, where we display the contents of `things`, both the plain `String`
    object and the `JLabel` object are happily in the list. The compiler is not worried
    about using disparate types; it is helpfully warning you that it will not know
    whether casts such as the `(Date)` cast above will work at runtime.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您添加的是什么类型的对象，您都可以看到警告是相同的。在最后一步，当我们显示`things`的内容时，普通的`String`对象和`JLabel`对象都在列表中。编译器并不担心使用不同的类型；它友好地警告您，它不知道像上面的`(Date)`转换在运行时是否会起作用。
- en: Can Containers Be Fixed?
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可以修复容器吗？
- en: It’s natural to ask if there is a way to make this situation better. What if
    we know that we are only going to put `Date`s into our list? Can’t we just make
    our own list that only accepts `Date` objects, get rid of the cast, and let the
    compiler help us again? The answer, perhaps surprisingly, is no. At least, not
    in a very satisfying way.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 自然而然地会问，是否有办法改善这种情况。如果我们知道我们只会将`Date`放入我们的列表中，我们不能只创建一个只接受`Date`对象的列表，消除转换，再次让编译器帮助我们吗？也许令人惊讶的答案是，不行。至少，不是以一种令人满意的方式。
- en: 'Our first instinct may be to try to “override” the methods of `ArrayList` in
    a subclass. But of course, rewriting the `add()` method in a subclass would not
    actually override anything; it would add a new *overloaded* method:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一反应可能是尝试在子类中“重写”`ArrayList`的方法。但当然，重写`add()`方法在子类中实际上并没有覆盖任何东西；它会添加一个新的*重载*方法：
- en: '[PRE3]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The resulting object still accepts any kind of object—it just invokes different
    methods to get there.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 结果对象仍然接受任何类型的对象——它只是调用不同的方法来实现这一点。
- en: Moving along, we might take on a bigger task. For example, we might write our
    own `DateList` class that does not extend `ArrayList` but rather delegates the
    guts of its methods to the `ArrayList` implementation. With a fair amount of tedious
    work, that would get us an object that does everything a `List` does but works
    with `Date`s in a way that both the compiler and the runtime environment can understand
    and enforce. However, we’ve now shot ourselves in the foot because our container
    is no longer an implementation of `List`. That means we can’t use it interoperably
    with all of the utilities that deal with collections, such as `Collections`.`sort()`,
    or add it to another collection with the `Collection addAll()` method.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 继续前进，我们可能会承担更大的任务。例如，我们可以编写自己的`DateList`类，该类不是扩展`ArrayList`，而是将其方法的实质部分委托给`ArrayList`的实现。通过相当多的单调工作，我们可以得到一个对象，它可以做所有`List`做的事情，但以一种编译器和运行时环境都能理解和强制执行的方式处理`Date`。然而，我们现在给自己挖了个大坑，因为我们的容器不再是`List`的一个实现。这意味着我们不能与所有处理集合的实用程序（如`Collections`.`sort()`）互操作，也不能使用`Collection
    addAll()`方法将其添加到另一个集合中。
- en: To generalize, the problem is that instead of refining the behavior of our objects,
    what we really want to do is to change their contract with the user. We want to
    adapt their method signatures to a more specific type, and polymorphism doesn’t
    allow that. So are we stuck with `Object`s for our collections? That’s where generics
    come in.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，问题在于我们并不想细化对象的行为，我们真正想做的是改变它们与用户的契约。我们希望调整它们的方法签名以适应更具体的类型，而多态性无法做到这一点。所以我们是否为我们的集合困于`Object`？这就是泛型的用武之地。
- en: Enter Generics
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进入泛型
- en: As we noted when introducing the type limitations in the previous section, generics
    enhance the syntax of classes that allow us to specialize the class for a given
    type or set of types. A generic class requires one or more *type parameters* wherever
    we refer to the class type. It uses them to customize itself.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一节介绍类型限制时所指出的，泛型增强了允许我们为特定类型或一组类型定制类的语法。泛型类在引用类类型时需要一个或多个*类型参数*。它们用于自定义自身。
- en: 'If you look at the source or Javadoc for the `List` class, for example, you’ll
    see it defines something like this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你查看`List`类的源代码或Javadoc，你会看到它定义了类似这样的内容：
- en: '[PRE4]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The identifier `E` between the angle brackets (`<>`) is a *type parameter*.^([1](ch07.html#id1465))
    It indicates that the class `List` is generic and requires a Java type as an argument
    to make it complete. The name `E` is arbitrary, but there are conventions that
    we’ll see as we go on. In this case, the type parameter `E` represents the type
    of elements we want to store in the list. The `List` class refers to the type
    parameter within its body and methods as if it were a real type, to be substituted
    later. The type parameter may be used to declare instance variables, arguments
    to methods, and the return type of methods. In this case, `E` is used as the type
    for the elements we’ll be adding via the `add()` method and for the return type
    of the `get()` method. Let’s see how to use it.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 角括号（`<>`）之间的标识符`E`是*类型参数*。^([1](ch07.html#id1465)) 它指示`List`类是泛型的，并需要一个Java类型作为参数以使其完整。名称`E`是任意的，但随着我们继续，会看到一些惯例。在这种情况下，类型参数`E`代表我们希望存储在列表中的元素类型。`List`类在其体和方法中引用类型参数，就好像它是一个真实的类型，稍后会被替换。类型参数可以用于声明实例变量、方法参数和方法的返回类型。在这种情况下，`E`用作我们将通过`add()`方法添加的元素的类型，以及`get()`方法的返回类型。让我们看看如何使用它。
- en: 'The same angle bracket syntax supplies the type parameter when we want to use
    the `List` type:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想使用`List`类型时，同样的角括号语法提供了类型参数：
- en: '[PRE5]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In this snippet, we declared a variable called `listOfStrings` using the generic
    type `List` with a type parameter of `String`. `String` refers to the `String`
    class, but we could have a specialized `List` with any Java class type. For example:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，我们使用了泛型类型`List`声明了一个名为`listOfStrings`的变量，其类型参数为`String`。`String`指的是`String`类，但我们也可以有一个以任何Java类类型为类型参数的专门化`List`。例如：
- en: '[PRE6]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Completing the type by supplying its type parameter is called *instantiating
    the type*. It is also sometimes called *invoking the type*, by analogy with invoking
    a method and supplying its arguments. Whereas with a regular Java type we simply
    refer to the type by name, a generic type like `List<>` must be instantiated with
    parameters wherever it is used.^([2](ch07.html#id1468)) Specifically, this means
    that we must instantiate the type everywhere types can appear: as the declared
    type of a variable (as shown in this code snippet), as the type of a method parameter,
    as the return type of a method, or in an object allocation expression using the
    `new` keyword.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 通过提供其类型参数来完成类型称为*实例化该类型*。有时也称为*调用该类型*，类比于调用方法并提供其参数。与普通的Java类型不同，我们简单地通过名称引用类型，像`List<>`这样的泛型类型必须在使用时用参数实例化。^([2](ch07.html#id1468))
    具体而言，这意味着我们必须在可以出现类型的任何地方实例化类型：作为变量的声明类型（如本代码片段所示），作为方法参数的类型，作为方法的返回类型，或者在使用`new`关键字的对象分配表达式中。
- en: 'Returning to our `listOfStrings`, what we have now is effectively a `List`
    in which the type `String` has been substituted for the type variable `E` in the
    class body:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的`listOfStrings`，现在实际上是一个`List`，其中`String`类型已经替换了类体中的类型变量`E`：
- en: '[PRE7]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We have specialized the `List` class to work with elements of type `String`
    and *only* elements of type `String`. This method signature is no longer capable
    of accepting an arbitrary `Object` type.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已将`List`类专门化为仅与`String`类型的元素一起使用。此方法签名不再能接受任意的`Object`类型。
- en: '`List` is just an interface. To use the variable, we’ll need to create an instance
    of some actual implementation of `List`. As we did in our introduction, we’ll
    use `ArrayList`. As before, `ArrayList` is a class that implements the `List`
    interface, but in this case, both `List` and `ArrayList` are generic classes.
    As such, they require type parameters to instantiate them where they are used.
    Of course, we’ll create our `ArrayList` to hold `String` elements to match our
    `List` of `String`s:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`List` 只是一个接口。要使用该变量，我们需要创建一些实际的 `List` 实现的实例。正如我们在介绍中所做的那样，我们将使用 `ArrayList`。与以前一样，`ArrayList`
    是实现 `List` 接口的类，但在这种情况下，`List` 和 `ArrayList` 都是泛型类。因此，在使用它们的地方需要类型参数来实例化它们。当然，我们将创建我们的
    `ArrayList` 来保存 `String` 元素以匹配我们的 `List` 的 `String`：'
- en: '[PRE8]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As always, the `new` keyword takes a Java type and parentheses with possible
    arguments for the class’s constructor. In this case, the type is `ArrayList<String>`—the
    generic `ArrayList` type instantiated with the `String` type.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如往常一样，`new` 关键字接受一个 Java 类型和可能包含类构造函数参数的括号。在这种情况下，类型是 `ArrayList<String>`——泛型
    `ArrayList` 类型实例化为 `String` 类型。
- en: 'Declaring variables (as shown in the first line of the preceding example) is
    a bit cumbersome because it requires us to provide the generic parameter type
    twice: once on the left side in the variable type and once on the right in the
    initialing expression. And in complicated cases, the generic types can get very
    lengthy and nested within one another.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 声明变量（如上例中第一行所示）有点麻烦，因为它要求我们在变量类型的左侧和初始化表达式的右侧各提供一次泛型参数类型。在复杂情况下，泛型类型可以变得非常冗长且相互嵌套。
- en: The compiler is smart enough to infer the type of the initializing expression
    from the type of the variable to which you are assigning it. This is called *generic
    type inference* and boils down to the fact that you can use shorthand on the right
    side of your variable declarations by leaving out the contents of the `<>` notation,
    as shown in the example’s second version.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器足够智能，可以从您分配给变量的表达式的类型中推断出初始化表达式的类型。这称为*泛型类型推断*，其本质在于您可以通过在变量声明的右侧省略 `<>`
    符号的内容来使用简写，如示例的第二个版本所示。
- en: 'We can now use our specialized `List` with strings. The compiler prevents us
    from even trying to put anything other than a `String` object (or a subtype of
    `String` if there were any) into the list. It also allows us to fetch `String`
    objects with the `get()` method without requiring any cast:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用我们专门的字符串 `List`。编译器甚至阻止我们尝试将除 `String` 对象（如果有的话还有子类型）之外的任何东西放入列表中。它还允许我们使用
    `get()` 方法获取 `String` 对象，而无需进行任何强制转换：
- en: '[PRE9]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let’s take another example from the Collections API. The `Map` interface provides
    a dictionary-like mapping that associates key objects with value objects. Keys
    and values do not have to be of the same type. The generic `Map` interface requires
    two type parameters: one for the key type and one for the value type. The Javadoc
    looks like this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 Collections API 中再举一个例子。`Map` 接口提供了类似字典的映射，将键对象与值对象关联起来。键和值不必是相同类型。泛型 `Map`
    接口需要两个类型参数：一个是键的类型，另一个是值的类型。Javadoc 如下所示：
- en: '[PRE10]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can make a `Map` that stores `Employee` objects by `Integer` “employee ID”
    numbers, like this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个 `Map`，用于按 `Integer` 类型的“员工ID”号存储 `Employee` 对象，如下所示：
- en: '[PRE11]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, we used `HashMap`, which is a generic class that implements the `Map`
    interface. We instantiated both types with the type parameters `Integer` and `Employee`.
    The `Map` now works only with keys of type `Integer` and holds values of type
    `Employee`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了 `HashMap`，它是实现 `Map` 接口的泛型类。我们用类型参数 `Integer` 和 `Employee` 实例化了两种类型。现在，`Map`
    只能使用类型为 `Integer` 的键，并保存类型为 `Employee` 的值。
- en: The reason we used `Integer` here to hold our number is that the type parameters
    to a generic class must be class types. We can’t parameterize a generic class
    with a primitive type, such as `int` or `boolean`. Fortunately, autoboxing of
    primitives in Java (see [“Wrappers for Primitive Types”](ch05.html#learnjava6-CHP-5-SECT-2.6))
    almost makes it appear as if we can by allowing us to use primitive types as though
    they were wrapper types.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用 `Integer` 来保存我们的数字的原因是，泛型类的类型参数必须是类类型。我们不能使用原始类型（例如 `int` 或 `boolean`）参数化泛型类。幸运的是，在
    Java 中，原始类型的自动装箱（参见[“原始类型的包装类”](ch05.html#learnjava6-CHP-5-SECT-2.6)）几乎使其看起来像是我们可以通过允许我们像使用包装类型一样使用原始类型。
- en: Dozens of other APIs beyond Collections use generics to let you adapt them to
    specific types. We’ll talk about them as they occur throughout the book.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 超过 Collections 的许多其他 API 都使用泛型来使您能够将它们适应特定类型。我们将在本书的各个部分讨论它们。
- en: Talking About Types
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 谈论类型
- en: Before we move on to more important things, we should say a few words about
    the way we describe a particular parameterization of a generic class. Because
    the most common and compelling case for generics is for container-like objects,
    it’s common to think in terms of a generic type “holding” a parameter type. In
    our example, we called our `List<String>` a “list of strings” because, sure enough,
    that’s what it was. Similarly, we might have called our employee map a “Map of
    Employee IDs to Employee Objects.” However, these descriptions focus a little
    more on what the classes *do* than on the type itself.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们转向更重要的事情之前，我们应该对我们如何描述泛型类的特定参数化方式说几句话。因为最常见和最引人注目的泛型案例是用于类似容器的对象，所以通常会以泛型类型“持有”参数类型的方式来思考。在我们的示例中，我们称我们的
    `List<String>` 为“字符串列表”，因为确实是这样的。类似地，我们可能会称我们的员工映射为“员工 ID 到员工对象的映射”。然而，这些描述更专注于类的*行为*而不是类型本身。
- en: Take instead a single object container called `Trap< E >` that could be instantiated
    on an object of type `Mouse` or of type `Bear`; that is, `Trap<Mouse>` or `Trap<Bear>`.
    Our instinct is to call the new type a “mouse trap” or “bear trap.” We can think
    of our list of strings as a new type, as well. We could talk about a “string list”
    or describe our employee map as a new “integer employee object map” type. You
    may use whatever verbiage you prefer, but these latter descriptions focus more
    on the notion of the generic as a *type* and may help you keep the terms straight
    when we discuss how generic types are related in the type system. There we’ll
    see that the container terminology turns out to be a little counterintuitive.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 取而代之的是，考虑一个名为 `Trap<E>` 的单个对象容器，可以实例化为 `Mouse` 类型或 `Bear` 类型的对象；也就是说，`Trap<Mouse>`
    或 `Trap<Bear>`。我们本能地称新类型为“捕鼠器”或“熊夹”。我们也可以将我们的字符串列表看作是一个新类型。我们可以讨论“字符串列表”，或将我们的员工映射描述为新的“整数员工对象映射”类型。您可以使用您喜欢的任何措辞，但后一种描述更专注于将泛型视为*类型*的概念，并且在讨论泛型类型在类型系统中如何相关时，可能会帮助您保持术语的清晰性。在那里，我们将看到容器术语实际上有点反直觉。
- en: In the following section, we’ll discuss generic types in Java from a different
    perspective. We’ve seen a little of what they can do; now we need to talk about
    how they do it.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将从不同的角度讨论 Java 中的泛型类型。我们已经看到它们能做些什么；现在我们需要讨论它们如何做到这一点。
- en: “There Is No Spoon”
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: “没有勺子”
- en: 'In the movie *The Matrix*,^([3](ch07.html#id1481)) the hero Neo is offered
    a choice: take the blue pill and remain in the world of fantasy, or take the red
    pill and see things as they really are. In dealing with generics in Java, we are
    faced with a similar ontological dilemma. We can go only so far in any discussion
    of generics before we are forced to confront the reality of how they are implemented.
    Our fantasy world is one created by the compiler to make our lives writing code
    easier to accept. Our reality (though not quite the dystopian nightmare in the
    movie) is a harsher place, filled with unseen dangers and questions. Why don’t
    casts and tests work properly with generics? Why can’t I implement what appear
    to be two different generic interfaces in one class? Why can I declare an array
    of generic types, even though there is no way in Java to create such an array?!?'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在电影 *The Matrix* 中，主人公尼奥被提出了一个选择：服用蓝色药丸并留在幻想世界中，或者服用红色药丸并看到事物的真实面目。在处理 Java
    中的泛型时，我们面临着类似的本体论困境。在讨论泛型时，我们只能走得那么远，然后不得不面对它们如何实现的现实。我们的幻想世界是编译器为了让我们编写代码更容易接受而创造的一个地方。我们的现实（虽然不像电影中的反乌托邦噩梦那样严峻）是一个更加艰难的地方，充满了看不见的危险和问题。为什么强制类型转换和测试在泛型中不能正常工作？为什么我不能在一个类中实现看似两个不同的泛型接口？为什么我可以声明一个泛型类型的数组，即使在
    Java 中无法创建这样的数组？！
- en: We’ll answer these questions and more in the rest of this chapter, and you won’t
    even have to wait for the sequel. You’ll be bending spoons (well, types) in no
    time. Let’s get started.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章的其余部分回答这些问题，您甚至无需等待续集。您将很快能够弯曲勺子（好吧，类型）。让我们开始吧。
- en: Erasure
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 擦除
- en: 'The design goals for Java generics were formidable: add a radical new syntax
    to the language that safely introduces parameterized types with no impact on performance
    and, oh, by the way, make it backward compatible with all existing Java code and
    don’t change the compiled classes in any serious way. It’s amazing that they actually
    satisfied these conditions and no surprise that it took a while. But as always,
    some necessary compromises led to some headaches.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Java通用类型的设计目标是雄心勃勃的：在语言中添加一个全新的语法，安全地引入参数化类型，并且不影响性能，并且，哦，顺便兼容所有现有的Java代码，并且不以任何严重的方式改变编译后的类。令人惊讶的是，他们实际上满足了这些条件，也不奇怪这需要一些时间。但是一如既往，一些必要的妥协导致了一些头痛。
- en: To accomplish this feat, Java employs a technique called *erasure*. Erasure
    relates to the idea that since most everything we do with generics applies statically
    at compile time, generic information does not need to be carried over into the
    compiled classes. The generic nature of the classes, enforced by the compiler,
    can be “erased” in the binary classes, maintaining compatibility with nongeneric
    code.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一功能，Java采用了一种称为*擦除*的技术。擦除与这样一个想法有关：由于我们与通用类型的大多数操作都是在编译时静态应用的，通用信息不需要在编译后的类中保留。编译器强制执行的类的通用特性可以在二进制类中被“擦除”，以保持与非通用代码的兼容性。
- en: While Java does retain information about the generic features of classes in
    the compiled form, this information is used mainly by the compiler. The Java runtime
    does not know anything about generics at all (and does not waste any resources
    on them).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Java在编译形式中保留了关于类的通用特性的信息，但这些信息主要由编译器使用。Java运行时根本不知道通用类型（generics），也不会浪费任何资源在其上。
- en: 'We can use *jshell* to confirm the runtime notion of a parameterized `List<E>`
    still being a `List`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用*jshell*来确认参数化的`List<E>`在运行时仍然是一个`List`：
- en: '[PRE12]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'But our generic `dateList` clearly does not implement the `List` methods just
    discussed:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我们的通用`dateList`显然没有实现刚刚讨论的`List`方法：
- en: '[PRE13]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This illustrates the somewhat eclectic nature of Java generics. The compiler
    believes in them, but the runtime says they are an illusion. What if we try something
    a little simpler and check that our `dateList` is a `List<Date>`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这说明了Java通用类型的有些古怪的性质。编译器相信它们，但运行时却说它们是幻觉。如果我们尝试一些更简单的事情并检查我们的`dateList`是否是一个`List<Date>`：
- en: '[PRE14]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This time the compiler simply puts its foot down and says, “No.” You can’t test
    for a generic type in an `instanceof` operation. Since there are no discernible
    classes for different parameterizations of `List` at runtime (every `List` is
    still a `List`), there is no way for the `instanceof` operator to tell the difference
    between one incarnation of `List` and another. All of the generic safety checking
    was done at compile time, so at runtime we’re just dealing with a single actual
    `List` type.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这次编译器直截了当地说：“不行。” 你不能在`instanceof`操作中测试一个通用类型。由于在运行时没有可辨别不同参数化的`List`的类（每个`List`仍然是一个`List`），`instanceof`运算符无法区分一个`List`的不同实例。所有的通用安全检查都是在编译时完成的，因此在运行时我们只是处理一个单一的实际`List`类型。
- en: 'Here’s what really happened: the compiler erased all of the angle bracket syntax
    and replaced the type parameters in our `List` class with a type that can work
    at runtime with any allowed type: in this case, `Object`. We would seem to be
    back where we started, except that the compiler still has the knowledge to enforce
    our usage of the generics in the code at compile time and can, therefore, handle
    the cast for us. If you decompile a class using a `List<Date>` (the *javap* command
    with the *-c* option shows you the bytecode, if you dare), you will see that the
    compiled code actually contains the cast to `Date`, even though we didn’t write
    it ourselves.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上是这样的：编译器抹去了所有的尖括号语法，并在我们的`List`类中用一个在运行时可以与任何允许的类型一起工作的类型替换了类型参数：在这种情况下，是`Object`。我们似乎回到了起点，只是编译器仍然具有在编译时强制我们使用通用类型的知识，并且因此可以为我们处理类型转换。如果你反编译一个使用了`List<Date>`（使用*javap*命令和*-c*选项显示字节码，如果你敢的话），你会看到编译后的代码实际上包含了到`Date`的转换，尽管我们自己并没有写。
- en: 'We can now answer one of the questions posed at the beginning of the section:
    “Why can’t I implement what appear to be two different generic interfaces in one
    class?” We can’t have a class that implements two different generic `List` instantiations
    because they are really the same type at runtime, and there is no way to tell
    them apart:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以回答本节开始时提出的一个问题：“为什么我不能在一个类中实现看起来是两个不同的泛型接口？”我们不能有一个类同时实现两个不同的泛型`List`实例化，因为它们在运行时实际上是相同类型，没有办法区分它们：
- en: '[PRE15]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Fortunately, there are always workarounds. In this case, for example, you can
    use a common superclass or create multiple classes. The alternatives may not be
    as elegant, but you can almost always land on a clean answer—even if it is a little
    verbose.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，总有办法解决。例如，在这种情况下，您可以使用一个共同的超类或创建多个类。虽然这些替代方法可能不那么优雅，但您几乎总能找到一个干净的答案，即使有点冗长。
- en: Raw Types
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原始类型
- en: Although the compiler treats different parameterizations of a generic type as
    different types (with different APIs) at compile time, we have seen that only
    one real type exists at runtime. For example, both `List<Date>` and `List<String>`
    share the plain old Java class `List`. `List` is called the *raw type* of the
    generic class. Every generic has a raw type. It is the base, “plain” Java form
    from which all of the generic type information has been removed and the type variables
    replaced by a general Java type like `Object`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管编译器在编译时将泛型类型的不同参数化视为不同的类型（具有不同的API），但我们已经看到在运行时只存在一个真正的类型。例如，`List<Date>`和`List<String>`共享旧式的Java类`List`。`List`被称为泛型类的*原始类型*。每个泛型都有一个原始类型。它是“普通”的Java形式，所有泛型类型信息已被移除，类型变量被一般的Java类型如`Object`替换。
- en: 'It is possible to use raw types in Java. However, the Java compiler generates
    a warning wherever they are used in an “unsafe” way. Outside *jshell*, the compiler
    still notices these problems:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中可以使用原始类型。然而，Java编译器在以“不安全”方式使用它们时生成警告。在*jshell*之外，编译器仍然会注意到这些问题：
- en: '[PRE16]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This snippet uses the raw `List` type just as old-fashioned Java code prior
    to Java 5 would have. The difference is that now the Java compiler issues an *unchecked
    warning* about the code if we attempt to insert an object into the list:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码片段像Java 5之前的老式Java代码一样使用了原始的`List`类型。不同之处在于现在Java编译器在我们尝试向列表中插入对象时会发出*未经检查的警告*：
- en: '[PRE17]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The compiler instructs us to use the `-Xlint:unchecked` option to get more
    specific information about the locations of unsafe operations:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器指导我们使用`-Xlint:unchecked`选项，以获取有关不安全操作位置的更详细信息：
- en: '[PRE18]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note that creating and assigning the raw `ArrayList` does not generate a warning.
    It is only when we try to use an “unsafe” method (one that refers to a type variable)
    that we get the warning. This means that it’s still OK to use older-style, nongeneric
    Java APIs that work with raw types. We get warnings only when we do something
    unsafe in our own code.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，创建和分配原始的`ArrayList`并不会生成警告。只有当我们尝试使用“不安全”的方法（引用类型变量的方法）时才会收到警告。这意味着仍然可以使用与原始类型相关的旧式非泛型Java
    API。只有在我们自己的代码中做一些不安全的操作时才会收到警告。
- en: 'One more thing about erasure before we move on. In the previous examples, the
    type variables were replaced by the `Object` type, which could represent any type
    applicable to the type variable `E`. Later, we’ll see that this is not always
    the case. We can place limitations or *bounds* on the parameter types, and, when
    we do, the compiler can be more restrictive about the erasure of the type, for
    example:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，还有关于擦除的一件事。在前面的示例中，类型变量被`Object`类型替换，它可以表示适用于类型变量`E`的任何类型。后面我们会看到，并非总是这样。我们可以对参数类型设置限制或*边界*，当我们这样做时，编译器对类型的擦除可以更加严格，例如：
- en: '[PRE19]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This parameter type declaration says that the element type `E` must be a subtype
    of the `Date` type. In this case, the erasure of the `addElement()` method is
    therefore more restrictive than `Object`, and the compiler uses `Date`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 此参数类型声明表示元素类型`E`必须是`Date`类型的子类型。在这种情况下，`addElement()`方法的擦除因此比`Object`更加严格，编译器使用`Date`：
- en: '[PRE20]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`Date` is called the *upper bound* of this type, meaning that it is the top
    of the object hierarchy here. You can only instantiate the parameterized type
    on a `Date` or on a “lower” (more derived, or subclassed) type.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`Date`被称为此类型的*上界*，这意味着它是对象层次结构的顶部。您只能在`Date`或“较低”（更派生或子类化）类型上实例化参数化类型。'
- en: Now that we have a handle on what generic types really are, we can go into a
    little more detail about how they behave.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Parameterized Type Relationships
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We know now that parameterized types share a common, raw type. This is why
    our parameterized `List<Date>` is just a `List` at runtime. In fact, we can assign
    any instantiation of `List` to the raw type if we want:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can even go the other way and assign a raw type to a specific instantiation
    of the generic type:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This statement generates an unchecked warning on the assignment, but after that,
    the compiler trusts that the list contained only `Date`s prior to the assignment.
    You can try casting `new ArrayList()` to `List<Date>`, but that won’t address
    the warning. We’ll talk about casting to generic types in [“Casts”](#learnjava6-CHP-7-SECT-6).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'Whatever the runtime types, the compiler is running the show. It does not let
    us assign things that are clearly incompatible:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Of course, the `ArrayList<String>` does not implement the methods of `List<Date>`
    required by the compiler, so these types are incompatible.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: But what about more interesting type relationships? The `List` interface, for
    example, is a subtype of the more general `Collection` interface. Can you take
    a particular instantiation of the generic `List` and assign it to some instantiation
    of the generic `Collection`? Does it depend on the type parameters and their relationships?
    Clearly, a `List<Date>` is not a `Collection<String>`. But is a `List<Date>` a
    `Collection<Date>`? Can a `List<Date>` be a `Collection<Object>`?
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: We’ll just blurt out the answer here first, then walk through it and explain.
    The rule for the simple types of generic instantiations we’ve discussed so far
    is that *inheritance applies only to the “base” generic type and not to the parameter
    types*. Furthermore, assignability applies only when the two generic types are
    instantiated on *exactly the same parameter type*. In other words, there is still
    one-dimensional inheritance, following the base generic class type, but with the
    additional restriction that the parameter types must be identical.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, since a `List` is a type of `Collection`, we can assign instantiations
    of `List` to instantiations of `Collection` when the type parameter is exactly
    the same:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This code snippet says that a `List<Date>` is a `Collection<Date>`—pretty intuitive.
    But trying the same logic on a variation in the parameter types fails:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Although our intuition tells us that the `Date`s in that `List` could all live
    happily as `Object`s in a `List`, the assignment is an error. We’ll explain precisely
    why in the next section, but for now just note that the type parameters are not
    exactly the same and that there is no inheritance relationship among parameter
    types in generics.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: This is a case where it helps to think of the instantiation in terms of types
    and not in terms of what the instantiated objects do. These are not really a “list
    of dates” and a “list of objects”—more like a `DateList` and an `ObjectList`,
    the relationship of which is not immediately obvious.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'Try to pick out what’s OK and what’s not OK in the following example:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: It is possible for an instantiation of `List` to be an instantiation of `Collection`,
    but only if the parameter types are exactly the same. Inheritance doesn’t follow
    the parameter types, so the final assignment in this example fails.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'Earlier we mentioned that this rule applies to the simple types of instantiations
    we’ve discussed so far in this chapter. What other types are there? Well, the
    kinds of instantiations we’ve seen so far where we plug in an actual Java type
    as a parameter are called *concrete type instantiations*. Later, we’ll talk about
    *wildcard instantiations*, which are like mathematical set operations on types
    (think unions and intersections). It’s possible to make more exotic instantiations
    of generics where the type relationships are actually two-dimensional, depending
    both on the base type and the parameterization. But don’t worry: this doesn’t
    come up very often and is not as scary as it sounds.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Why Isn’t a List<Date> a List<Object>?
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s a reasonable question. Why shouldn’t we be able to assign our `List<Date>`
    to a `List<Object>` and work with the `Date` elements as `Object` types?
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason gets back to the heart of the rationale for generics: changing programming
    contracts. In the simplest case, supposing a `DateList` type extends an `ObjectList`
    type, the `DateList` would have all of the methods of `ObjectList` and we could
    insert `Object`s into it. Now, you might object that generics let us change the
    method signatures, so that doesn’t apply anymore. That’s true, but there is a
    bigger problem. If we could assign our `DateList` to an `ObjectList` variable,
    we could use `Object` methods to insert elements of types other than `Date` into
    it.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'We could *alias* (provide an alternate, broader type) the `DateList` as an
    `ObjectList`. Using the aliased object, we could try to trick it into accepting
    some other type:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We’d expect to get a runtime error when the actual `DateList` implementation
    was presented with the wrong type of object.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: And therein lies the problem. Java generics have no runtime representation.
    Even if this functionality were useful, there is no way for Java to know what
    to do at runtime. This feature is simply dangerous—it allows for an error at runtime
    that can’t be caught at compile time. In general, we’d like to catch type errors
    at compile time.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: 'You might think Java could guarantee the type safety of your code if it compiles
    with no unchecked warnings by disallowing these assignments. Unfortunately it
    can’t, but that limitation has nothing to do with generics; it has to do with
    arrays. (If this all sounds familiar to you, it’s because we mentioned this issue
    in [Chapter 4](ch04.html#learnjava6-CHP-4) in relation to Java arrays.) Array
    types have an inheritance relationship that allows this kind of aliasing to occur:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您认为Java可以通过禁止这些赋值来在编译时不生成未检查的警告来保证代码的类型安全性。不幸的是它不能，但这种限制与泛型无关；它与数组有关。（如果这些对你听起来很熟悉，那是因为我们在[第四章](ch04.html#learnjava6-CHP-4)中提到了这个问题，与Java数组有关。）数组类型具有一种继承关系，允许这种别名发生：
- en: '[PRE28]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Arrays have runtime representations as different classes. They check themselves
    at runtime, throwing an `ArrayStoreException` in situations like this. The Java
    compiler cannot guarantee the type safety of your code if you use arrays in this
    way.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 数组在运行时具有不同的类表示。它们在运行时进行自检，在这种情况下会抛出`ArrayStoreException`。如果你以这种方式使用数组，Java编译器无法保证你的代码的类型安全性。
- en: Casts
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 强制类型转换
- en: We’ve now talked about relationships between generic types and even between
    generic types and raw types. But we haven’t really explored the concept of casts
    in the world of generics.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经谈论了泛型类型之间甚至泛型类型与原始类型之间的关系。但我们还没有真正探讨在泛型世界中的强制类型转换的概念。
- en: 'No cast was necessary when we interchanged generics with their raw types. But
    we triggered unchecked warnings from the compiler:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们用泛型与它们的原始类型交换时，是不需要强制类型转换的。但我们会触发编译器的未检查警告：
- en: '[PRE29]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Normally, we use a cast in Java to work with two types that could be assignable.
    For example, we could attempt to cast an `Object` to a `Date` because it is plausible
    that the `Object` could be a `Date` value. The cast then performs the check at
    runtime to see if we are correct.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，我们在Java中使用强制类型转换来处理可能可赋值的两种类型。例如，我们可以尝试将一个`Object`转换为`Date`，因为`Object`可能是一个`Date`值。然后强制类型转换会在运行时进行检查，以查看我们是否正确。
- en: Casting between unrelated types is a compile-time error. For example, we can’t
    even try to cast an `Integer` to a `String`. Those types have no inheritance relationship.
    What about casts between compatible generic types?
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在不相关的类型之间进行强制类型转换是一个编译时错误。例如，我们甚至无法尝试将一个`Integer`转换为`String`。这些类型之间没有继承关系。那么在兼容的泛型类型之间进行转换呢？
- en: '[PRE30]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This code snippet shows a valid cast from a more general `Collection<Date>`
    to a `List<Date>`. The cast is plausible here because a `Collection<Date>` is
    assignable from and could actually be a `List<Date>`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码片段展示了从更一般的`Collection<Date>`到`List<Date>`的有效转换。这里的转换是合理的，因为一个`Collection<Date>`可以赋值并且实际上可能是一个`List<Date>`。
- en: 'Similarly, the following cast catches our mistake: we have aliased a `TreeSet<Date>`
    as a `Collection<Date>` and tried to cast it to a `List<Date>`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，下面的强制类型转换捕获了我们的错误：我们将`TreeSet<Date>`别名为`Collection<Date>`，然后尝试将其转换为`List<Date>`：
- en: '[PRE31]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'There is one case where casts are not effective with generics, however, and
    that is when trying to differentiate the types based on their parameter types:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 但是有一种情况下，泛型的强制类型转换是无效的，那就是在尝试根据它们的参数类型来区分类型时：
- en: '[PRE32]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here, we aliased an `ArrayList<String>` as a plain `Object`. Next, we cast `o`
    to a `List<Date>`. Unfortunately, Java does not know the difference between a
    `List<String>` and a `List<Date>` at runtime, so the cast is fruitless. The compiler
    warns us by generating an unchecked warning at the location of the cast. When
    we try to use the cast object, `ld`, we might find out that it is incorrect. Casts
    on generic types are ineffective at runtime because of erasure and the lack of
    type information.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将一个`ArrayList<String>`别名为一个普通的`Object`。接下来，我们将`o`强制类型转换为`List<Date>`。不幸的是，Java在运行时无法区分`List<String>`和`List<Date>`之间的区别，所以这种强制类型转换是无效的。编译器通过在强制类型转换位置生成未检查的警告来提醒我们。当我们尝试使用强制类型转换的对象`ld`时，我们可能会发现它是不正确的。由于擦除和缺乏类型信息，泛型类型上的强制类型转换在运行时是无效的。
- en: Converting Between Collections and Arrays
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在集合和数组之间进行转换
- en: 'While not related by direct inheritance or shared interfaces, converting between
    collections and arrays is still straightforward. For convenience, you can retrieve
    the elements of a collection as an array using the following methods:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它们没有直接的继承关系或共享接口，但在集合和数组之间进行转换仍然很简单。为了方便起见，您可以使用以下方法将集合的元素作为数组检索出来：
- en: '[PRE33]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The first method returns a plain `Object` array. With the second form, we can
    be more specific and get back an array of the correct element type. If we supply
    an array of sufficient size, it will be filled in with the values. But if the
    array is too short (for instance, zero length), Java will create a new array of
    the *same type but the required length* and return it instead. So you can just
    pass in an empty array of the correct type like this:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个方法返回一个普通的 `Object` 数组。通过第二种形式，我们可以更具体地返回正确元素类型的数组。如果我们提供了足够大小的数组，它将用值填充。但如果数组长度太短（例如，长度为零），Java
    将创建一个所需长度的相同类型的新数组，并返回它。因此，您可以像这样传递一个空数组来获取正确类型的数组：
- en: '[PRE34]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This trick is a little awkward. It would be nice if Java let us specify the
    type explicitly using a `Class` reference, but for some reason, it doesn’t.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这个技巧有点笨拙。如果 Java 允许我们使用 `Class` 引用显式指定类型，会更好，但出于某种原因，它并没有这样做。
- en: 'Going the other way, you can convert an array of objects to a `List` collection
    with the static `asList()` method of the `java.util.Arrays` helper class:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是，您可以使用 `java.util.Arrays` 辅助类的静态 `asList()` 方法将对象数组转换为 `List` 集合：
- en: '[PRE35]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The compiler is also smart enough to recognize a valid assignment to a `List<String>`
    variable.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器还足够智能，能够识别对 `List<String>` 变量的有效赋值。
- en: Iterator
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迭代器
- en: 'An *iterator* is an object that lets you step through a sequence of values.
    This kind of operation comes up so often that it has a standard interface: `java.util.Iterator`.
    The `Iterator` interface has three interesting methods:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '*迭代器* 是一种允许您逐步浏览一系列值的对象。这种操作非常常见，因此有一个标准接口：`java.util.Iterator`。`Iterator`
    接口有三个有趣的方法：'
- en: '`public E next()`'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`public E next()`'
- en: This method returns the next element (an element of generic type E) of the associated
    collection.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法返回关联集合的下一个元素（泛型类型 E 的元素）。
- en: '`public boolean hasNext()`'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`public boolean hasNext()`'
- en: This method returns `true` if you have not yet stepped through all the `Collection`’s
    elements. In other words, it returns `true` if you can call `next()` to get the
    next element.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果尚未遍历完 `Collection` 的所有元素，则此方法返回 `true`。换句话说，如果可以调用 `next()` 获取下一个元素，则返回 `true`。
- en: '`public void remove()`'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`public void remove()`'
- en: This method removes the most recent object returned from `next()` from the associated
    `Collection`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法从关联的 `Collection` 中移除从 `next()` 返回的最近对象。
- en: 'The following example shows how to use an `Iterator` to print out every element
    of a collection:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了如何使用 `Iterator` 打印集合的每个元素：
- en: '[PRE36]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'After using `next()` to get the next element, you can sometimes `remove()`
    it. Working your way through a to-do list, for example, might follow a pattern:
    “get an item, process the item, remove the item.” But the removal feature of iterators
    is not always appropriate and not all iterators implement `remove()`. It doesn’t
    make sense to be able to remove an element from a read-only collection, for example.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `next()` 获取下一个元素后，有时可以使用 `remove()` 将其移除。例如，通过待办事项清单的方式进行处理时，可能会遵循以下模式：“获取一个项目，处理该项目，移除该项目”。但是，迭代器的移除功能并不总是合适，也不是所有迭代器都实现了
    `remove()`。例如，无法从只读集合中移除元素是没有意义的。
- en: If element removal is not allowed, an `UnsupportedOperationException` is thrown
    from this method. If you call `remove()` before first calling `next()`, or if
    you call `remove()` twice in a row, you’ll get an `IllegalStateException`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不允许删除元素，则从此方法中抛出 `UnsupportedOperationException`。如果在首次调用 `next()` 之前调用 `remove()`，或者连续两次调用
    `remove()`，则会抛出 `IllegalStateException`。
- en: Looping over collections
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 遍历集合
- en: 'A form of the `for` loop, described in [“The for loop”](ch04.html#learnjava6-CHP-4-SECT-5.1.4),
    can operate over all `Iterable` types, which means it can iterate over all types
    of `Collection` objects as that interface extends `Iterable`. For example, it
    can now step over all of the elements of a typed collection of `Date` objects,
    like so:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [“for 循环”](ch04.html#learnjava6-CHP-4-SECT-5.1.4) 中描述的一种形式的 `for` 循环可以操作所有
    `Iterable` 类型，这意味着它可以迭代所有 `Collection` 对象类型，因为该接口扩展了 `Iterable`。例如，它现在可以遍历类型化的
    `Date` 对象集合的所有元素，如下所示：
- en: '[PRE37]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This feature of the Java built-in `for` loop is called the “enhanced” `for`
    loop (as opposed to the pregenerics, numeric-only `for` loop). The enhanced `for`
    loop applies only to `Collection` type collections, not `Map`s. But looping over
    a map can be useful in some situations. You can use the `Map` methods `keySet()`
    or `values()` (or even `entrySet()` if you want each key/value pair as a single
    entity) to get a collection from your map that *does* work with this enhanced
    `for` loop:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: Java 内置 `for` 循环的这个特性称为“增强” `for` 循环（与预泛型、仅数字 `for` 循环相对）。增强 `for` 循环仅适用于 `Collection`
    类型的集合，而不适用于 `Map`。但在某些情况下，遍历映射可能很有用。您可以使用 `Map` 方法 `keySet()` 或 `values()`（甚至
    `entrySet()` 如果您希望每个键/值对作为单个实体）从您的映射中获取一个可以使用这个增强 `for` 循环的集合：
- en: '[PRE38]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The collection of keys is a simple, unordered set. The enhanced `for` loop above
    will show all of your employees, but their printed order might appear somewhat
    random. If you wanted them listed in order of their IDs or perhaps their names,
    you would need to sort the keys or values first. Fortunately, sorting is a very
    common task—and the collections framework can help.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 键的集合是一个简单的无序集合。上面的增强 `for` 循环将显示所有您的员工，但它们的打印顺序可能看起来有些随机。如果您希望按其 ID 或者也许是它们的名称列出它们，您需要首先对键或值进行排序。幸运的是，排序是一个非常常见的任务——集合框架可以帮助。
- en: 'A Closer Look: The sort() Method'
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 详细解析：`sort()` 方法
- en: 'Poking around in the `java.util.Collections` class, we find all kinds of static
    utility methods for working with collections. Among them is this goody—the static
    generic method `sort()`:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `java.util.Collections` 类中查找，我们找到了各种用于处理集合的静态实用方法。其中之一是这个好东西——静态泛型方法 `sort()`：
- en: '[PRE39]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Another nut for us to crack. Let’s focus on the last part of the bound:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个我们要解决的难题。让我们专注于边界的最后部分：
- en: '[PRE40]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This is a wildcard instantiation that we mentioned in [“Parameterized Type Relationships”](#learnjava6-CHP-7-SECT-5).
    In this case, it is an interface, so we can read the `extends` in the `sort()`
    return type as `implements` if it helps.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在 [“参数化类型关系”](#learnjava6-CHP-7-SECT-5) 中提到的通配符实例化。在这种情况下，它是一个接口，因此我们可以将
    `sort()` 方法返回类型中的 `extends` 理解为 `implements`。
- en: '`Comparable` holds a `compareTo()` method for some parameter type. A `Comparable<String>`
    means that the `compareTo()` method takes type `String`. Therefore, `Comparable<?
    super T>` is the set of instantiations of `Comparable` on `T` and all of its superclasses.
    A `Comparable<T>` suffices and, at the other end, so does a `Comparable<Object>`.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`Comparable` 包含一个 `compareTo()` 方法，用于某个参数类型。`Comparable<String>` 意味着 `compareTo()`
    方法接受类型 `String`。因此，`Comparable<? super T>` 是在 `T` 及其所有超类上的 `Comparable` 实例化的集合。`Comparable<T>`
    足够，并且在另一端，`Comparable<Object>` 也是如此。'
- en: What this means in English is that the elements must be comparable to their
    own type, or some supertype of their own type for the `sort()` method to use them.
    This ensures that the elements can all be compared to one another, but it’s not
    as restrictive as saying that they must all implement the `compareTo()` method
    themselves. Some of the elements may inherit the `Comparable` interface from a
    parent class that knows how to compare only to a supertype of `T`, and that is
    exactly what is allowed.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这在英语中意味着元素必须与它们自己的类型可比较，或者与它们自己的类型的某个超类型可比较，以便 `sort()` 方法可以使用它们。这确保了所有元素可以相互比较，但并不像说它们都必须自己实现
    `compareTo()` 方法那样具有限制性。一些元素可以从一个知道如何仅与 `T` 的某个超类型比较的父类继承 `Comparable` 接口，这正是允许的。
- en: 'Application: Trees on the Field'
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用：田野上的树木
- en: There is a lot of theory in this chapter. Don’t be afraid of theory—it can help
    you predict behavior in novel scenarios and inspire solutions to new problems.
    But practice is just as important, so let’s revisit the game that we started in
    [“Classes”](ch05.html#learnjava6-CHP-5-SECT-1). In particular, it’s time to store
    more than one object of each type.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中有很多理论。不要害怕理论——它可以帮助您预测新场景中的行为，并激发解决新问题的解决方案。但实践同样重要，所以让我们回顾一下我们在 [“类”](ch05.html#learnjava6-CHP-5-SECT-1)
    中开始的游戏。特别是，现在是存储每种类型多个对象的时候了。
- en: In [Chapter 13](ch13.html#learnjava6-CHP-13) we’ll cover networking and look
    at creating a two-player setup that would require storing multiple physicists.
    For now, we still have one physicist who can throw one apple at a time. But we
    can populate our field with several trees for target practice.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 13 章](ch13.html#learnjava6-CHP-13) 中，我们将介绍网络和创建需要存储多个物理学家的两人游戏设置。现在，我们仍然只有一个物理学家可以一次扔一个苹果。但我们可以在我们的场地上种植几棵树作为靶子练习。
- en: 'Let’s add six trees. We’ll use a pair of loops so you can easily increase the
    tree count if you wish. Our `Field` currently stores a lone tree instance. We
    can upgrade that storage to a typed list (we’ll call it `trees`). From there we
    can approach adding and removing trees in a number of ways:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加六棵树。我们将使用一对循环，这样您可以轻松增加树木数量（如果愿意）。我们的`Field`当前仅存储一个树实例。我们可以将该存储升级为一个类型化列表（我们称之为`trees`）。从那里，我们可以以多种方式添加和移除树木：
- en: We could create some methods for `Field` that work with the list and maybe enforce
    some other game rules (like managing a maximum number of trees).
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以为`Field`创建一些处理列表的方法，也许还可以实施其他一些游戏规则（例如管理最大数量的树木）。
- en: We could just use the list directly since the `List` class already has nice
    methods for most of the things we want to do.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以直接使用列表，因为`List`类已经有了大多数我们想做的事情的好方法。
- en: 'We could use some combination of those approaches: special methods where it
    makes sense for our game, and direct manipulation everywhere else.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以结合这些方法的一些组合：适合我们的游戏的特殊方法，以及其他所有地方直接操作。
- en: 'Since we do have some game rules that are peculiar to our `Field`, we’ll take
    the first approach here. (But look at the examples and think about how you might
    alter them to use the list of trees directly.) We’ll start with an `addTree()`
    method. One benefit of this approach is that we can also relocate the creation
    of the tree instance to our method rather than creating and manipulating the tree
    separately. Here’s one way to add a tree at a desired point on the field:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们确实有一些特定于`Field`的游戏规则，因此我们将在此处采取第一种方法。（但是请查看示例，并考虑如何修改以直接使用树木列表。）我们将从一个`addTree()`方法开始。采用这种方法的一个好处是，我们还可以将树实例的创建重定位到我们的方法中，而不是单独创建和操作树。以下是在场地上添加树木的一种方法：
- en: '[PRE41]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'With that method in place, we could add a couple of trees quite quickly:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这种方法，我们可以很快地添加一些树木：
- en: '[PRE42]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Those two lines add a pair of trees side by side. Let’s go ahead and write
    the loops we need to create our six trees:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这两行代码并排添加了一对树木。让我们继续编写我们需要创建六棵树的循环：
- en: '[PRE43]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Can you see now how easy it would be to add eight or nine or a hundred trees?
    Computers are really good at repetition.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你能看到，如果要添加八、九或一百棵树是多么容易了吗？计算机在重复方面做得很好。
- en: Hooray for creating our forest of apple targets! We left off a few critical
    details, though. Most importantly, we need to show our new forest on the screen.
    We also need to update our drawing method for the `Field` class so that it understands
    and uses our list of trees correctly. Eventually we’ll do the same for our physicists
    and apples as we add more functionality to our game. We’ll also need a way to
    remove elements that are no longer active. But first, let’s see our forest!
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建我们的苹果目标森林万岁！尽管我们遗漏了一些关键细节。最重要的是，我们需要在屏幕上显示我们的新森林。我们还需要更新`Field`类的绘图方法，以便正确理解和使用我们的树木列表。随着我们为游戏添加更多功能，我们也将对物理学家和苹果执行相同的操作。此外，我们还需要一种方法来移除不再活动的元素。但首先，让我们看看我们的森林！
- en: '[PRE44]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Since we are already in the `Field` class where our `trees` are stored, there
    is no need to write a separate function to pull out an individual tree and paint
    it. We can use the nifty enhanced `for` loop structure and quickly get all of
    our trees on the field, as shown in [Figure 7-1](#learnjava6-CHP-7-FIG-1).
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经在存储我们的树木的`Field`类中，没有必要编写一个单独的函数来提取单个树并对其进行绘制。我们可以使用巧妙的增强型`for`循环结构，快速将所有树木放在场地上，如[图7-1](#learnjava6-CHP-7-FIG-1)所示。
- en: '![ljv6 0701](assets/ljv6_0701.png)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 0701](assets/ljv6_0701.png)'
- en: Figure 7-1\. Rendering all the trees in our `List`
  id: totrans-256
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7-1。在我们的`List`中渲染所有树木
- en: Useful Features
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有用的特性
- en: 'Java collections and generics are very powerful and useful additions to the
    language. Although some of the details we delved into in the latter half of this
    chapter may seem daunting, the common usage is very simple and compelling: generics
    make collections better. As you begin to use generics more, you will find that
    your code becomes more readable and more maintainable. Collections allow for elegant,
    efficient storage. Generics make explicit what you previously had to infer from
    usage.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: Java集合和泛型是语言中非常强大和有用的附加功能。尽管本章后半部分深入探讨的一些细节可能看起来令人生畏，但通常使用却非常简单和引人注目：泛型使集合更好。随着您对泛型的使用增加，您会发现您的代码变得更加可读和可维护。集合允许优雅、高效的存储。泛型使您之前根据使用推断出来的内容显式化。
- en: Review Questions
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复习问题
- en: If you want to store a contact list with names and phone numbers, which kind
    of collection would work best?
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想存储一个包含姓名和电话号码的联系人列表，哪种类型的集合最适合？
- en: What method do you use to get an iterator for the items in a `Set`?
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你使用什么方法来获取`Set`中项的迭代器？
- en: How can you turn a `List` into an array?
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何将`List`转换为数组？
- en: How can you turn an array into a `List`?
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何将数组转换为`List`？
- en: What interface should you implement to sort a list using the `Collections.sort()`
    method?
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该实现哪个接口以使用`Collections.sort()`方法对列表进行排序？
- en: Code Exercises
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码练习
- en: The class `EmployeeList` in the *ch07exercises* folder contains a few employees
    loaded into a map of employee IDs and `Employee` objects, similar to the one used
    in several examples above. We mentioned printing these employees in a sorted fashion,
    but didn’t show any code. Try to sort the employees by their ID numbers. You’ll
    likely need to use the `keySet()` method and then create a temporary—but sortable—list
    from that set.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*ch07exercises*文件夹中的`EmployeeList`类包含了一些员工，加载到一个员工ID和`Employee`对象的映射中，与前面几个示例中使用的类似。我们提到要按ID号对这些员工进行排序，但没有展示任何代码。尝试按照他们的ID号排序员工。你可能需要使用`keySet()`方法，然后从该集合创建一个临时但可排序的列表。'
- en: In [Advanced Exercise 5.1](ch05.html#learnjava6-CHP-5-SECT-7.3), you created
    a new obstacle class, `Hedge`. Update the game so that you can have multiple hedges
    similar to the multiple trees. Make sure all of your trees and hedges paint correctly
    when you run the program.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在[高级练习 5.1](ch05.html#learnjava6-CHP-5-SECT-7.3)中，你创建了一个新的障碍类`Hedge`。更新游戏，使得你可以拥有多个树篱，类似于多个树木。确保当你运行程序时所有的树木和树篱都能正确绘制。
- en: Advanced Exercises
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高级练习
- en: 'In Code Exercise 1 above, you probably sorted the keys of the map and then
    used the correctly sorted keys to get the corresponding employee. For a bit more
    of a challenge, implement the `Comparable` interface in your `Employee` class.
    You can decide how you want to organize the employees: by ID, by last name, by
    full name, or maybe some combination of those attributes. Rather than sorting
    the `keySet()` collection, try sorting your newly comparable employees directly
    by building a temporary list from the `values()` of your map.'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上述代码练习1中，你可能对映射的键进行了排序，然后使用正确排序的键来获取相应的员工。为了更具挑战性，尝试在你的`Employee`类中实现`Comparable`接口。你可以决定如何组织员工：按ID、姓氏、全名或者可能是这些属性的某种组合。而不是对`keySet()`集合进行排序，尝试直接通过从你的映射的`values()`中构建临时列表来对你新建的可比较员工进行排序。
- en: ^([1](ch07.html#id1465-marker)) You may also see the term *type variable* used.
    The Java Language Specification mostly uses *parameter* so that’s what we try
    to stick with, but you may see both names used in the wild.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch07.html#id1465-marker)) 你可能还会看到术语*类型变量*。Java语言规范大多使用*参数*，所以我们尽量坚持这个术语，但你可能会看到两个名称都在使用。
- en: ^([2](ch07.html#id1468-marker)) That is, unless you want to use a generic type
    in a nongeneric way. We’ll talk about “raw” types later in this chapter.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch07.html#id1468-marker)) 也就是说，除非你想以非泛型方式使用泛型类型。我们稍后会讨论“原始”类型。
- en: ^([3](ch07.html#id1481-marker)) For those of you who might like some context
    for the title of this section, here is where it comes from. Our hero, Neo, is
    learning about his powers.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch07.html#id1481-marker)) 如果你们中有些人想要了解本节标题的背景，这里是它的来源。我们的英雄Neo正在学习他的超能力。
- en: 'Boy: Do not try and bend the spoon. That’s impossible. Instead, only try to
    realize the truth.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 男孩：不要试图弯曲勺子。那是不可能的。相反，只需试图意识到真相。
- en: 'Neo: What truth?'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: Neo：什么真相？
- en: 'Boy: There is no spoon.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 男孩：没有勺子。
- en: 'Neo: There is no spoon?'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: Neo：没有勺子？
- en: 'Boy: Then you’ll see that it is not the spoon that bends, it is only yourself.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 男孩：那么你会看到不是勺子弯曲，只有你自己在弯曲。
- en: —The Wachowskis. *The Matrix*. 136 minutes. Warner Brothers, 1999.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: —瓦卓斯基姐弟。*黑客帝国*。136分钟。华纳兄弟，1999年。
