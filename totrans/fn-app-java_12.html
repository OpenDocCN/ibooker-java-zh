<html><head></head><body>
<div id="sbo-rt-content"><section data-pdf-bookmark="Chapter 10. Functional Exception Handling" data-type="chapter" epub:type="chapter"><div class="chapter" id="_02-exception-handling">
<h1><span class="label">Chapter 10. </span>Functional Exception Handling</h1>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45115227092992">
<h1>A Note for Early Release Readers</h1>
<p>With Early Release ebooks, you get books in their earliest form—the author’s raw and unedited content as they write—so you can take advantage of these technologies long before the official release of these titles.</p>
<p>This will be the 10th chapter of the final book. Please note that the GitHub repo will be made active later on.</p>
<p>If you have comments about how we might improve the content and/or examples in this book, or if you notice missing material within this chapter, please reach out to the editor at <em>rfernando@oreilly.com</em>.</p>
</div></aside>
<p>As much as we would like to write perfect and error-free code, it’s an almost impossible endeavor.
That’s why we need a way to deal with inevitable problems in our code.
Java’s mechanism of choice to deal with such disruptive and abnormal control flow conditions is Exceptions.</p>
<p>Exception handling can be tricky, even in imperative and OO code.
Combining Exceptions with a functional approach, however, can be a real challenge because the techniques are fraught with considerations and requirements.
Although there are third-party libraries that can assist with this, you may not want to rely solely on them in the long term by incurring technical debt due to a new dependency, instead of adapting to a more functional approach overall.</p>
<p>This chapter will show you the different kinds of Exceptions and their impact on functional programming with lambdas.
You will learn how to handle Exceptions in lambdas as well as alternative ways to approach control flow disruptions in a functional context.</p>
<section data-pdf-bookmark="Java Exception Handling in a Nutshell" data-type="sect1"><div class="sect1" id="_02-exception-handling-nutshell">
<h1>Java Exception Handling in a Nutshell</h1>
<p>In general, an Exception is a special event that happens during the execution of a program that disrupts the normal flow of instructions.
This concept is present in many different programming languages, not only in Java, and traces back to the origins of Lisp<sup><a data-type="noteref" href="ch10.xhtml#idm45115227087312" id="idm45115227087312-marker">1</a></sup>.</p>
<p>The actual form of how Exceptions are handled depends on the language.</p>
</div></section>
<section data-pdf-bookmark="The try-catch" data-type="sect1"><div class="sect1" id="idm45115227085200">
<h1>The try-catch</h1>
<p>Java’s mechanism of choice is the <code>try</code>-<code>catch</code>-block which is an integral element of the language.</p>
<pre data-code-language="java" data-type="programlisting"><code class="k">try</code> <code class="p">{</code>
  <code class="k">return</code> <code class="n">doCalculation</code><code class="p">(</code><code class="n">input</code><code class="p">);</code>
<code class="p">}</code> <code class="k">catch</code> <code class="p">(</code><code class="n">ArithmeticException</code> <code class="n">e</code><code class="p">)</code> <code class="p">{</code>
  <code class="k">this</code><code class="p">.</code><code class="na">log</code><code class="p">.</code><code class="na">error</code><code class="p">(</code><code class="s">"Calculation failed"</code><code class="p">,</code> <code class="n">e</code><code class="p">);</code>
  <code class="k">return</code> <code class="kc">null</code><code class="p">;</code>
<code class="p">}</code></pre>
<p>The overall concept of it has slightly evolved since its inception.
Instead of requiring multiple <code>catch</code> blocks, you can catch more than one Exception with a <a href="https://docs.oracle.com/javase/7/docs/technotes/guides/language/catch-multiple.xhtml"><code>multi-catch</code></a> block by using <code>|</code> (pipe) between their types:</p>
<pre data-code-language="java" data-type="programlisting"><code class="k">try</code> <code class="p">{</code>
  <code class="k">return</code> <code class="n">doCalculation</code><code class="p">(</code><code class="n">input</code><code class="p">);</code>
<code class="p">}</code> <code class="k">catch</code> <code class="p">(</code><code class="n">ArithmeticException</code> <code class="o">|</code> <code class="n">IllegalArgumentException</code> <code class="n">e</code><code class="p">)</code> <code class="p">{</code>
  <code class="k">this</code><code class="p">.</code><code class="na">log</code><code class="p">.</code><code class="na">error</code><code class="p">(</code><code class="s">"Calculation failed"</code><code class="p">,</code> <code class="n">e</code><code class="p">);</code>
  <code class="k">return</code> <code class="kc">null</code><code class="p">;</code>
<code class="p">}</code></pre>
<p>If you need to handle resources, using a <a href="https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.xhtml"><code>try-with-resources</code></a> construct will automatically close any resource that implements <code>AutoCloseable</code>:</p>
<pre data-code-language="java" data-type="programlisting"><code class="k">try</code> <code class="p">(</code><code class="kd">var</code> <code class="n">fileReader</code> <code class="o">=</code> <code class="k">new</code> <code class="n">FileReader</code><code class="p">(</code><code class="n">file</code><code class="p">);</code>
     <code class="kd">var</code> <code class="n">bufferedReader</code> <code class="o">=</code> <code class="k">new</code> <code class="n">BufferedReader</code><code class="p">(</code><code class="n">fileReader</code><code class="p">))</code> <code class="p">{</code>

    <code class="kd">var</code> <code class="n">firstLine</code> <code class="o">=</code> <code class="n">bufferedReader</code><code class="p">.</code><code class="na">readLine</code><code class="p">();</code>
    <code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="n">firstLine</code><code class="p">);</code>
<code class="p">}</code> <code class="k">catch</code> <code class="p">(</code><code class="n">IOException</code> <code class="n">e</code><code class="p">)</code> <code class="p">{</code>
  <code class="n">System</code><code class="p">.</code><code class="na">err</code><code class="p">.</code><code class="na">printlin</code><code class="p">(</code><code class="s">"Couldn't read first line of "</code> <code class="o">+</code> <code class="n">file</code><code class="p">);</code>
<code class="p">}</code></pre>
<p>Regardless of which variant you use, you will end up with an Exception that disrupts the flow of execution of your code by jumping from the origin of the thrown Exception to the nearest <code>catch</code> point up the call stack or crashing the current thread if none is available.</p>
<section data-pdf-bookmark="The Different Types of Exceptions and Errors" data-type="sect2"><div class="sect2" id="idm45115226890256">
<h2>The Different Types of Exceptions and Errors</h2>
<p>There are three types of control flow disruptions in Java, with disparate requirements regarding their handling in your code: <em>checked</em> and <em>unchecked</em> Exceptions, and <em>Errors</em>.</p>
<section data-pdf-bookmark="Checked Exceptions" data-type="sect3"><div class="sect3" id="idm45115226864784">
<h3>Checked Exceptions</h3>
<p><em>Checked</em> Exceptions are <em>anticipated</em> and potentially <em>recoverable</em> events outside the normal control flow.
For example, you should always expect the possibility of a missing file (<code>FileNotFoundException</code>) or an invalid URL (<code>MalformedURLException</code>).
Because they’re anticipated, they must adhere to Java’s <em>catch-or-specify</em> requirement.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45115226803936">
<h1>Catch-or-specify</h1>
<p>The <em>catch-or-specify</em> requirement declares that your code must honor one of the following conditions while dealing with checked Exceptions:</p>
<dl>
<dt>Catch the Exception in its current context</dt>
<dd>
<p>An appropriate handler — a <code>catch</code>-block — is provided to catch the specific Exception or one of its base types.</p>
</dd>
<dt>Specify thrown Exceptions in the method’s signature</dt>
<dd>
<p>The surrounding method signifies its thrown Exception types by using the <code>throws</code> keyword, followed by a comma-separated list of possible checked Exceptions.</p>
</dd>
</dl>
<p>This requirement <strong>must</strong> be obliged, and the compiler forces you to adhere to at least one of the two conditions.
The reliability and resilience of your code will improve by allowing you to recover gracefully or hand over the liability down the line instead of completely ignoring the Exception.
Either flag possible exceptional states or handle them directly.</p>
<p>There’s no need to specify an Exception type if you catch and handle it.
An unnecessary <code>throws</code> declaration forces the caller of such a method to comply with the catch-or-specify requirement, too.</p>
</div></aside>
</div></section>
<section data-pdf-bookmark="Unchecked Exceptions" data-type="sect3"><div class="sect3" id="idm45115226795872">
<h3>Unchecked Exceptions</h3>
<p><em>Unchecked</em> Exceptions, on the other hand, are <em>not anticipated</em>, and are often <em>unrecoverable</em>, such as:</p>
<ul>
<li>
<p><code>UnsupportedOperationException</code> in the case of an unsupported operation</p>
</li>
<li>
<p><code>ArithmeticException</code> for invalid mathematical calculations</p>
</li>
<li>
<p><code>NullPointerException</code> if an empty reference is encountered</p>
</li>
</ul>
<p>They aren’t considered part of the methods’ public contract but rather represent what happens if any assumed contract preconditions are broken.
Therefore, such Exceptions aren’t subject to the catch-or-specify requirement, and methods usually don’t signify them with the <code>throws</code> keyword, even if it’s known that a method will throw them in under certain conditions.</p>
<p>However, unchecked Exceptions still have to be handled in some form if you don’t want your program to crash.
If not handled locally, an Exception automatically goes up the call stack of the current thread until it finds an appropriate handler.
Or, if none is available, the thread dies.
For single-threaded applications, the runtime will terminate, and your program will crash.</p>
</div></section>
<section data-pdf-bookmark="Errors" data-type="sect3"><div class="sect3" id="idm45115226787760">
<h3>Errors</h3>
<p>The third kind of control flow disruption — <em>Errors</em> — indicates a severe problem you shouldn’t catch or can’t handle under normal circumstances.</p>
<p>For example, if the runtime runs out of available memory, the runtime throws a <code>OutOfMemoryError</code>.
Or an endless recursive call will eventually lead to a <code>StackOverflowError</code>.
There’s nothing you can really do without any memory left, regardless of whether it’s the heap or the stack.
Faulty hardware is another source for Java errors, like <code>java.io.IOError</code> in case of a disk error.
These are all grave and not anticipated problems with almost no possibility of recovering gracefully.
That’s why errors mustn’t adhere to the catch-or-specify requirement.</p>
</div></section>
<section data-pdf-bookmark="Exception Hierarchy in Java" data-type="sect3"><div class="sect3" id="idm45115226783920">
<h3>Exception Hierarchy in Java</h3>
<p>Which category an Exception falls into depends on its base class.
All Exceptions are checked, except types subclassing <code>java.lang.RuntimeException</code> or <code>java.lang.Error</code>.
But they share a common base type: <code>java.lang.Throwable</code>.
Types inheriting from the latter two are either unchecked or an error.
The type hierarchy is illustrated in <a data-type="xref" href="#_02-exception-handling_hierachy">Figure 10-1</a>.</p>
<figure><div class="figure" id="_02-exception-handling_hierachy">
<img alt="Hierarchy of Java Exception Types" height="363" src="assets/afaj_1001.png" width="477"/>
<h6><span class="label">Figure 10-1. </span>Exceptions hierarchy in Java</h6>
</div></figure>
<p>The concept of having different kinds of Exceptions is rather uncommon among programming languages, and it’s a controversial topic of discussion due to their different requirements of how to handle them.
Kotlin<sup><a data-type="noteref" href="ch10.xhtml#idm45115226777968" id="idm45115226777968-marker">2</a></sup>, for example, inherits the general mechanisms of handling Exceptions but doesn’t have any checked Exceptions.</p>
</div></section>
</div></section>
</div></section>
<section data-pdf-bookmark="Checked Exceptions in Lambdas" data-type="sect1"><div class="sect1" id="idm45115226775984">
<h1>Checked Exceptions in Lambdas</h1>
<p>Java’s Exception-handling mechanisms were designed to fulfill specific requirements at the time of its inception, 18 years before the introduction of lambdas.
That’s why throwing and handling Exceptions don’t fit nicely into the new functional Java coding style without any special considerations or completely disregarding the catch-or-specify requirement.</p>
<p>Let’s take a look at loading the content of a file with a <code>static</code> method available on <code>java.util.Files</code> with the following method signature:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">static</code> <code class="n">String</code> <code class="nf">readString</code><code class="p">(</code><code class="n">Path</code> <code class="n">path</code><code class="p">)</code> <code class="kd">throws</code> <code class="n">IOException</code> <code class="p">{</code>
  <code class="c1">// ...</code>
<code class="p">}</code></pre>
<p>The method signature is quite simple and indicates that a checked <code>IOException</code> might get thrown, so a <code>try</code>-<code>catch</code>-block is required.
That’s why the method can’t be used as a method reference, or in a simple lambda:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">Stream</code><code class="p">.</code><code class="na">of</code><code class="p">(</code><code class="n">path1</code><code class="p">,</code> <code class="n">path2</code><code class="p">,</code> <code class="n">path3</code><code class="p">)</code>
      <code class="p">.</code><code class="na">map</code><code class="p">(</code><code class="n">Files</code><code class="p">::</code><code class="n">readString</code><code class="p">)</code>
      <code class="p">.</code><code class="na">forEach</code><code class="p">(</code><code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">::</code><code class="n">println</code><code class="p">);</code>

<code class="c1">// Compiler Error:</code>
<code class="c1">// incompatible thrown types java.io.IOException in functional expression</code></pre>
<p>The problem stems from the functional interface required to satisfy the <code>map</code> operation.
None of the functional interfaces of the JDK throw checked Exceptions and are, therefore, not compatible with any method that does.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>There are interfaces marked with @FunctionalInterface that throw Exceptions, like <code>java.util.concurrent.Callable&lt;V&gt;</code>.
They <em>are</em> functional interfaces by definition, but it’s for compatibility reasons, not because they represent functional types to be used indiscriminately.</p>
</div>
<p>The most obvious solution is using <code>try</code>-<code>catch</code>-block by converting the lambda to a block-based one:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">Stream</code><code class="p">.</code><code class="na">of</code><code class="p">(</code><code class="n">path1</code><code class="p">,</code> <code class="n">path2</code><code class="p">,</code> <code class="n">path3</code><code class="p">)</code>
      <code class="p">.</code><code class="na">map</code><code class="p">(</code><code class="n">path</code> <code class="o">-&gt;</code> <code class="p">{</code>
        <code class="k">try</code> <code class="p">{</code>
          <code class="k">return</code> <code class="n">Files</code><code class="p">.</code><code class="na">readString</code><code class="p">(</code><code class="n">path</code><code class="p">);</code>
        <code class="p">}</code> <code class="k">catch</code> <code class="p">(</code><code class="n">IOException</code> <code class="n">e</code><code class="p">)</code> <code class="p">{</code>
          <code class="k">return</code> <code class="kc">null</code><code class="p">;</code>
        <code class="p">}</code>
      <code class="p">})</code>
      <code class="p">.</code><code class="na">forEach</code><code class="p">(</code><code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">::</code><code class="n">println</code><code class="p">);</code></pre>
<p>The code required to satisfy the compiler defeats the purpose of Stream pipelines lambdas in general.
The conciseness and straightforward representation of an operation is diluted by the required boilerplate for Exception handling.</p>
<p>Using Exceptions in lambdas almost feels like an anti-pattern.
A <code>throws</code> declaration indicates that the caller has to decide how to handle that Exception, and lambdas don’t have a dedicated way of dealing with Exceptions except for the pre-existing <code>try-catch</code>, which can’t be used for method references.</p>
<p>Still, there are certain ways of dealing with Exceptions without losing (most of) the simplicity and clarity that lambdas, methods references, and pipelines like Streams or Optionals give you:</p>
<ul>
<li>
<p>Safe method extraction</p>
</li>
<li>
<p>Un-Checking Exceptions</p>
</li>
<li>
<p>Sneaky throws</p>
</li>
</ul>
<p>All these options are imperfect workarounds to mitigate Exception handling in functional code.
Still, we will have a look at each of them because they can be useful in certain scenarios if you do not have a built-in way to deal with Exceptions properly.</p>
<p>The last two can even be treacherous or at least become a code smell if used unwisely.
Nevertheless, knowing such “last resort” tools can help you navigate more difficult amalgamations of pre-existing, non-functional code, and give you a more functional approach.</p>
<section data-pdf-bookmark="Safe Method Extraction" data-type="sect2"><div class="sect2" id="_02-exception-handling_safe-method-extraction">
<h2>Safe Method Extraction</h2>
<p>Efficiently handling Exceptions in your functional code depends on who effectively controls or owns the code.
If the throwing code is entirely under your control, you should <em>always</em> adequately handle them.
But often, the offending code is <em>not</em> yours, or you can’t change or refactor it as needed.
That’s when you can still extract it into a “safer” method with appropriate local Exception handling.</p>
<p>Creating a “safe” method decouples the actual work from handling any Exception, restoring the principle of the caller being responsible for any checked Exceptions.
Any functional code can use the safe method instead, as shown in <a data-type="xref" href="#_02-exception-handling_safe-wrapper">Example 10-1</a>.</p>
<div data-type="example" id="_02-exception-handling_safe-wrapper">
<h5><span class="label">Example 10-1. </span>Extract throwing code into a safe method</h5>
<pre data-code-language="java" data-type="programlisting"><code class="n">String</code> <code class="nf">safeReadString</code><code class="p">(</code><code class="n">Path</code> <code class="n">path</code><code class="p">)</code> <code class="p">{</code> <a class="co" href="#callout_functional_exception_handling_CO1-1" id="co_functional_exception_handling_CO1-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a>
  <code class="k">try</code> <code class="p">{</code> <a class="co" href="#callout_functional_exception_handling_CO1-2" id="co_functional_exception_handling_CO1-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a>
    <code class="k">return</code> <code class="n">Files</code><code class="p">.</code><code class="na">readString</code><code class="p">(</code><code class="n">path</code><code class="p">)</code><code class="p">;</code>
  <code class="p">}</code> <code class="k">catch</code> <code class="p">(</code><code class="n">IOException</code> <code class="n">e</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="kc">null</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="n">Stream</code><code class="p">.</code><code class="na">of</code><code class="p">(</code><code class="n">path1</code><code class="p">,</code> <code class="n">path2</code><code class="p">,</code> <code class="n">path3</code><code class="p">)</code>
      <code class="p">.</code><code class="na">map</code><code class="p">(</code><code class="k">this</code><code class="p">:</code><code class="p">:</code><code class="n">safeReadString</code><code class="p">)</code> <a class="co" href="#callout_functional_exception_handling_CO1-3" id="co_functional_exception_handling_CO1-3"><img alt="3" height="12" src="assets/3.png" width="12"/></a>
      <code class="p">.</code><code class="na">filter</code><code class="p">(</code><code class="n">Objects</code><code class="p">:</code><code class="p">:</code><code class="n">nonNull</code><code class="p">)</code> <a class="co" href="#callout_functional_exception_handling_CO1-4" id="co_functional_exception_handling_CO1-4"><img alt="4" height="12" src="assets/4.png" width="12"/></a>
      <code class="p">.</code><code class="na">forEach</code><code class="p">(</code><code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">:</code><code class="p">:</code><code class="n">println</code><code class="p">)</code><code class="p">;</code></pre></div>
<dl class="calloutlist">
<dt><a class="co" href="#co_functional_exception_handling_CO1-1" id="callout_functional_exception_handling_CO1-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p>The “safe” method has the same method signature except for the <code>throws IOException</code>.</p></dd>
<dt><a class="co" href="#co_functional_exception_handling_CO1-2" id="callout_functional_exception_handling_CO1-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a></dt>
<dd><p>The Exception is dealt with locally and returns an appropriate fallback.</p></dd>
<dt><a class="co" href="#co_functional_exception_handling_CO1-3" id="callout_functional_exception_handling_CO1-3"><img alt="3" height="12" src="assets/3.png" width="12"/></a></dt>
<dd><p>The wrapper method can be used as a method reference, making the code concise and readable again.</p></dd>
<dt><a class="co" href="#co_functional_exception_handling_CO1-4" id="callout_functional_exception_handling_CO1-4"><img alt="4" height="12" src="assets/4.png" width="12"/></a></dt>
<dd><p>The possibility of a <code>null</code> element must be handled accordingly.</p></dd>
</dl>
<p>The pipeline is concise and straightforward again.
The <code>IOException</code> is handled in the sense that it doesn’t affect the pipeline, but this approach isn’t “one-size-fits-all.”</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Safe method extraction is akin to a more localized version of the <em>facade pattern</em>⁠<sup><a data-type="noteref" href="ch10.xhtml#idm45115226386080" id="idm45115226386080-marker">3</a></sup>.
Instead of wrapping a whole class to provide a safer, context-specific interface, only specific methods get a new facade to improve their handling for particular use cases.
That reduces the affected code and still gives you the advantages of a facade, like reduced complexity and improved readability.
It’s also a good starting point for future refactoring efforts.</p>
</div>
<p>Extracted safe methods might be an improvement over using <code>try</code>-<code>catch</code> blocks in a lambda because you keep the expressiveness of inline-lambdas and method references and have a chance to handle any Exceptions.
But the handling is confined in another abstraction over existing code to regain control of disruptive control-flow conditions.
The actual caller of the method — the Stream operation — gets no chance to deal with the Exception, making the handling opaque and inflexible.</p>
</div></section>
<section data-pdf-bookmark="Un-Checking Exceptions" data-type="sect2"><div class="sect2" id="_02-exception-handling_unchecking-exceptions">
<h2>Un-Checking Exceptions</h2>
<p>The next way to deal with checked Exceptions goes against the fundamental purpose of using checked Exceptions in the first place.
Instead of dealing with a checked Exception directly, you hide it in an unchecked Exception to circumvent the catch-or-specify requirement.
It’s a nonsensical, but effective way to make the compiler happy.</p>
<p>This approach uses specialized functional interfaces that use the <code>throws</code> keywords to wrap the offending lambda or method reference.
It catches the original Exception and rethrows it as an unchecked <code>RuntimeException</code>, or one of its siblings.
These functional interfaces extend the original one to ensure compatibility.
The original single-abstract method uses a <code>default</code> implementation to connect it to the throwing one, as shown in <a data-type="xref" href="#_02-exception-handling_uncheck-exceptions">Example 10-2</a>.</p>
<div data-type="example" id="_02-exception-handling_uncheck-exceptions">
<h5><span class="label">Example 10-2. </span>Unchecking <code>java.util.Function</code></h5>
<pre data-code-language="java" data-type="programlisting"><code class="nd">@FunctionalInterface</code>
<code class="kd">public</code> <code class="kd">interface</code> <code class="nc">ThrowingFunction</code><code class="o">&lt;</code><code class="n">T</code><code class="p">,</code> <code class="n">U</code><code class="o">&gt;</code> <code class="kd">extends</code> <code class="n">Function</code><code class="o">&lt;</code><code class="n">T</code><code class="p">,</code> <code class="n">U</code><code class="o">&gt;</code> <code class="p">{</code> <a class="co" href="#callout_functional_exception_handling_CO2-1" id="co_functional_exception_handling_CO2-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a>

  <code class="n">U</code> <code class="nf">applyThrows</code><code class="p">(</code><code class="n">T</code> <code class="n">elem</code><code class="p">)</code> <code class="kd">throws</code> <code class="n">Exception</code><code class="p">;</code> <a class="co" href="#callout_functional_exception_handling_CO2-2" id="co_functional_exception_handling_CO2-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a>

  <code class="nd">@Override</code>
  <code class="k">default</code> <code class="n">U</code> <code class="nf">apply</code><code class="p">(</code><code class="n">T</code> <code class="n">t</code><code class="p">)</code> <code class="p">{</code> <a class="co" href="#callout_functional_exception_handling_CO2-3" id="co_functional_exception_handling_CO2-3"><img alt="3" height="12" src="assets/3.png" width="12"/></a>
    <code class="k">try</code> <code class="p">{</code>
      <code class="k">return</code> <code class="n">applyThrows</code><code class="p">(</code><code class="n">t</code><code class="p">)</code><code class="p">;</code>
    <code class="p">}</code> <code class="k">catch</code> <code class="p">(</code><code class="n">Exception</code> <code class="n">e</code><code class="p">)</code> <code class="p">{</code>
      <code class="k">throw</code> <code class="k">new</code> <code class="n">RuntimeException</code><code class="p">(</code><code class="n">e</code><code class="p">)</code><code class="p">;</code>
    <code class="p">}</code>
  <code class="p">}</code>

  <code class="kd">public</code> <code class="kd">static</code> <code class="o">&lt;</code><code class="n">T</code><code class="p">,</code> <code class="n">U</code><code class="o">&gt;</code> <code class="n">Function</code><code class="o">&lt;</code><code class="n">T</code><code class="p">,</code> <code class="n">U</code><code class="o">&gt;</code> <code class="nf">uncheck</code><code class="p">(</code><code class="n">ThrowingFunction</code><code class="o">&lt;</code><code class="n">T</code><code class="p">,</code> <code class="n">U</code><code class="o">&gt;</code> <code class="n">fn</code><code class="p">)</code> <code class="p">{</code> <a class="co" href="#callout_functional_exception_handling_CO2-4" id="co_functional_exception_handling_CO2-4"><img alt="4" height="12" src="assets/4.png" width="12"/></a>
    <code class="k">return</code> <code class="n">fn</code><code class="p">:</code><code class="p">:</code><code class="n">apply</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code></pre></div>
<dl class="calloutlist">
<dt><a class="co" href="#co_functional_exception_handling_CO2-1" id="callout_functional_exception_handling_CO2-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p>The wrapper extends the original type to act as a drop-in replacement.</p></dd>
<dt><a class="co" href="#co_functional_exception_handling_CO2-2" id="callout_functional_exception_handling_CO2-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a></dt>
<dd><p>The single-abstract method (SAM) mimics the original but throws an <code>Exception</code>.</p></dd>
<dt><a class="co" href="#co_functional_exception_handling_CO2-3" id="callout_functional_exception_handling_CO2-3"><img alt="3" height="12" src="assets/3.png" width="12"/></a></dt>
<dd><p>The original SAM is implemented as a <code>default</code> method to wrap any <code>Exception</code> as a <code>RuntimeException</code>.</p></dd>
<dt><a class="co" href="#co_functional_exception_handling_CO2-4" id="callout_functional_exception_handling_CO2-4"><img alt="4" height="12" src="assets/4.png" width="12"/></a></dt>
<dd><p>A <code>static</code> helper to uncheck any throwing <code>Function&lt;T, U&gt;</code> to circumvent the catch-or-specify requirement.</p></dd>
</dl>
<p>The <code>ThrowingFunction&lt;T, U&gt;</code> type can either be used explicitly by calling the <code>uncheck</code> method or implicitly as seen in <a data-type="xref" href="#_02-exception-handling_uncheck-exceptions_how-to-use">Example 10-3</a>.</p>
<div data-type="example" id="_02-exception-handling_uncheck-exceptions_how-to-use">
<h5><span class="label">Example 10-3. </span>Using <code>ThrowingFunction&lt;T, U&gt;</code></h5>
<pre data-code-language="java" data-type="programlisting"><code class="n">ThrowingFunction</code><code class="o">&lt;</code><code class="n">Path</code><code class="p">,</code> <code class="n">String</code><code class="o">&gt;</code> <code class="n">throwingFn</code> <code class="o">=</code> <code class="n">Files</code><code class="p">:</code><code class="p">:</code><code class="n">readString</code><code class="p">;</code> <a class="co" href="#callout_functional_exception_handling_CO3-1" id="co_functional_exception_handling_CO3-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a>

<code class="n">Stream</code><code class="p">.</code><code class="na">of</code><code class="p">(</code><code class="n">path1</code><code class="p">,</code> <code class="n">path2</code><code class="p">,</code> <code class="n">path3</code><code class="p">)</code>
      <code class="p">.</code><code class="na">map</code><code class="p">(</code><code class="n">ThrowingFunction</code><code class="p">.</code><code class="na">uncheck</code><code class="p">(</code><code class="n">Files</code><code class="p">:</code><code class="p">:</code><code class="n">readString</code><code class="p">)</code><code class="p">)</code> <a class="co" href="#callout_functional_exception_handling_CO3-2" id="co_functional_exception_handling_CO3-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a>
      <code class="p">.</code><code class="na">filter</code><code class="p">(</code><code class="n">Objects</code><code class="p">:</code><code class="p">:</code><code class="n">nonNull</code><code class="p">)</code>
      <code class="p">.</code><code class="na">forEach</code><code class="p">(</code><code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">:</code><code class="p">:</code><code class="n">println</code><code class="p">)</code><code class="p">;</code></pre></div>
<dl class="calloutlist">
<dt><a class="co" href="#co_functional_exception_handling_CO3-1" id="callout_functional_exception_handling_CO3-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p>Any throwing method is assignable as a <code>ThrowingFunction</code> via a method reference and used in a context requiring a <code>Function</code>.</p></dd>
<dt><a class="co" href="#co_functional_exception_handling_CO3-2" id="callout_functional_exception_handling_CO3-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a></dt>
<dd><p>Alternatively, a throwing lambda or method reference can be unchecked on the fly by using the <code>static</code> helper <code>uncheck</code>.</p></dd>
</dl>
<p>Congratulations, the compiler is happy again and won’t force you to handle the Exception anymore.
The wrapper type doesn’t fix the original problem of possible control flow disruption but hides it from plain sight.
The Stream pipeline will still blow up if any Exception occurs without any possibility for localized Exception handling.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>Exception-throwing functional interfaces only disguise their exceptional states.
They have their place and can be quite useful, but shouldn’t be considered a go-to solution instead of a last resort.</p>
</div>
</div></section>
<section data-pdf-bookmark="Sneaky Throws" data-type="sect2"><div class="sect2" id="_02-exception-handling_sneaky-throws">
<h2>Sneaky Throws</h2>
<p>The <em>sneaky throws</em> idiom is a hack to throw a checked Exception without declaring it with the <code>throws</code> keyword in a method’s signature.</p>
<p>Instead of throwing a checked Exception using the <code>throw</code> keyword in a method’s body, which requires a <code>throws</code> declaration in the method signature, the actual Exception is thrown by another method, as follows:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">String</code> <code class="nf">sneakyRead</code><code class="p">(</code><code class="n">File</code> <code class="n">input</code><code class="p">)</code> <code class="p">{</code>

  <code class="c1">// ...</code>

  <code class="k">if</code> <code class="p">(</code><code class="n">fileNotFound</code><code class="p">)</code> <code class="p">{</code>
    <code class="n">sneakyThrow</code><code class="p">(</code><code class="k">new</code> <code class="n">IOException</code><code class="p">(</code><code class="s">"File '"</code> <code class="o">+</code> <code class="n">file</code> <code class="o">+</code> <code class="s">"' not found."</code><code class="p">));</code>
  <code class="p">}</code>

  <code class="c1">// ...</code>
<code class="p">}</code></pre>
<p>The actual throwing of the Exception is delegated to the <code>sneakyThrow</code> method.</p>
<p>Wait a minute, doesn’t anyone using a method throwing a checked Exception, like <code>sneakyThrow</code>, have to adhere to the catch-or-specify requirement?</p>
<p>Well, there’s one exception to the rule (pun intended).
You can take advantage of a change<sup><a data-type="noteref" href="ch10.xhtml#idm45115226007984" id="idm45115226007984-marker">4</a></sup> in Java’s type inference regarding Generics and Exceptions in Java 8.
In simple terms, if there are no upper or lower bounds on a generic method signature with <code>throws E</code>, the compiler assumes the type <code>E</code> to be a <code>RuntimeException</code>.
This allows you to create the following <code>sneakyThrow</code>:</p>
<pre data-code-language="java" data-type="programlisting"><code class="o">&lt;</code><code class="n">E</code> <code class="kd">extends</code> <code class="n">Throwable</code><code class="o">&gt;</code> <code class="kt">void</code> <code class="nf">sneakyThrow</code><code class="p">(</code><code class="n">Throwable</code> <code class="n">e</code><code class="p">)</code> <code class="kd">throws</code> <code class="n">E</code> <code class="p">{</code>
  <code class="k">throw</code> <code class="p">(</code><code class="n">E</code><code class="p">)</code> <code class="n">e</code><code class="p">;</code>
<code class="p">}</code></pre>
<p>Regardless of the actual type for the argument <code>e</code>, the compiler assumes <code>throws E</code> to be a <code>RuntimeException</code> and thereby exempts the method from the catch-or-specify requirement.
The compiler might not complain, but this approach is highly problematic.</p>
<p>The method signature of <code>sneakyRead</code> no longer signifies its checked Exception.
Checked Exceptions are supposed to be anticipated and recoverable, and therefore, belong to the method’s public contract.
By removing the <code>throws</code> keyword and circumventing the catch-or-specify requirement, you reduce the amount of information conferred to the caller by making the method’s public contract more opaque for convenience reasons.
You still could — and should — list all Exceptions and their reasoning in the method’s documentation.</p>
<p>The method no longer follows “normal reasoning” by bypassing the <code>throws</code> keyword and the enforcement of the catch-or-specify requirement.
Anyone reading the code has to know what <code>sneakyThrow</code> does.
You could add an appropriate <code>return</code> statement after the call to at least convey that it’s an exit point.
But the significance that a <code>throws</code> keyword emits is lost.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>Sneaky throws circumvent an integral part of the Java language of how to deal with control flow disruptions.
There is a place for it in a few edge cases for internal implementations.
In external code, however, like <code>public</code> methods, throwing Exceptions sneakily breaks the reasonably expected contract between the method and the caller any Java developer would anticipate.</p>
</div>
<p>Sneakily throwing Exceptions might be an acceptable “last resort” hack for internal code, but you still have to communicate the implications with the help of the context, method names, and documentation.
In the next section, I show you an acceptable use case for sneakily throwing an Exception in a specialized implementation for internal code.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="A Functional Approach to Exceptions" data-type="sect1"><div class="sect1" id="idm45115226775392">
<h1>A Functional Approach to Exceptions</h1>
<p>So far, I’ve only discussed how to “brute force” Java’s Exception handling mechanics to play nice with lambdas by ignoring and circumventing the intended purpose of Exceptions.
What’s really needed is finding a reasonable compromise and balance between a functional approach and the more traditional constructs.</p>
<p>Your options include designing your code to not throw Exceptions at all or mimicking the Exception-handling approaches of other more functional languages.</p>
<section data-pdf-bookmark="Not Throwing Exceptions" data-type="sect2"><div class="sect2" id="_02-exception-handling_not-throwing-exceptions">
<h2>Not Throwing Exceptions</h2>
<p>Checked Exceptions are an integral part of a method’s contract and are designed as control flow disruptions.
That’s what makes it so difficult to deal with them in the first place!
So, instead of finding a better way of handling checked Exceptions and all of their complications, we can instead find an alternative way of dealing with control flow disruption in a functional context.</p>
<p><a data-type="xref" href="#_02-exception-handling_safe-method-extraction">“Safe Method Extraction”</a> discussed a variant of not throwing Exceptions by wrapping an Exception-throwing method with a non-throwing “safer” method.
This approach helps if you don’t have control over the code and can’t design it to not throw any Exceptions in the first place.
It replaces disruptive control flow events in the form of Exceptions with another value to represent an “exceptional” state: <code>Optional&lt;T&gt;</code>.
If you have control over the API, you could design its contracts not to use Exceptions or make them at least more manageable.
Exceptions are a reaction to some form of illegal state.
The best way to avoid Exception handling is to make the representation of such an illegal state impossible in the first place.</p>
<p>I discussed in <a data-type="xref" href="ch09.xhtml#_02-optionals">Chapter 9</a> that Optionals are a “box” to wrap an actual value.
It’s a specialized type representing the presence or absence of values without risking encountering a <code>null</code> reference and the eventually dreaded <code>NullPointerException</code>.</p>
<p>Let’s look at the previous example again.
This time, however, let’s use an Optional instead of throwing an Exception, as seen in <a data-type="xref" href="#_02-exception-handling_optional-vs-exception">Example 10-4</a>.</p>
<div data-type="example" id="_02-exception-handling_optional-vs-exception">
<h5><span class="label">Example 10-4. </span>Using <code>Optional&lt;String&gt;</code> instead of throwing an <code>IOException</code></h5>
<pre data-code-language="java" data-type="programlisting"><code class="n">Optional</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code> <code class="nf">safeReadString</code><code class="p">(</code><code class="n">Path</code> <code class="n">path</code><code class="p">)</code> <code class="p">{</code> <a class="co" href="#callout_functional_exception_handling_CO4-1" id="co_functional_exception_handling_CO4-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a>
  <code class="k">try</code> <code class="p">{</code>
    <code class="kd">var</code> <code class="n">content</code> <code class="o">=</code> <code class="n">Files</code><code class="p">.</code><code class="na">readString</code><code class="p">(</code><code class="n">path</code><code class="p">)</code><code class="p">;</code>
    <code class="k">return</code> <code class="n">Optional</code><code class="p">.</code><code class="na">of</code><code class="p">(</code><code class="n">content</code><code class="p">)</code><code class="p">;</code>
  <code class="p">}</code> <code class="k">catch</code> <code class="p">(</code><code class="n">IOException</code> <code class="n">e</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="n">Optional</code><code class="p">.</code><code class="na">empty</code><code class="p">(</code><code class="p">)</code><code class="p">;</code> <a class="co" href="#callout_functional_exception_handling_CO4-2" id="co_functional_exception_handling_CO4-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a>
  <code class="p">}</code>
<code class="p">}</code></pre></div>
<dl class="calloutlist">
<dt><a class="co" href="#co_functional_exception_handling_CO4-1" id="callout_functional_exception_handling_CO4-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p>An <code>Optional&lt;String&gt;</code> is used instead of a plain <code>String</code>.</p></dd>
<dt><a class="co" href="#co_functional_exception_handling_CO4-2" id="callout_functional_exception_handling_CO4-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a></dt>
<dd><p>By returning an <code>Optional&lt;String&gt;</code>, either with the file content or an empty one in the case of an <code>IOException</code>, a valid non-<code>null</code> object is returned.</p></dd>
</dl>
<p>Returning an <code>Optional&lt;String&gt;</code> has two advantages over simply returning <code>String</code>.
First, a valid object is returned, so no additional <code>null</code>-checks are required to use it safely.
Second, the Optional type is a starting point for a fluent functional pipeline to deal with the inner value, or its absence.</p>
<p>If your API doesn’t expose any illegal states requiring control flow disruptions, you, or anyone else calling such methods, don’t have to handle them.
Optionals are a simple and readily available choice, although it lacks some desirable features.
The new <code>safeReadString</code> conveys that it wasn’t able to read the file but doesn’t tell you <em>why</em> it wasn’t able to do so.</p>
</div></section>
<section data-pdf-bookmark="Errors as Values" data-type="sect2"><div class="sect2" id="idm45115225769376">
<h2>Errors as Values</h2>
<p>Where <code>Optional&lt;T&gt;</code> only provides the difference between the presence and absence of a value, a dedicated <em>result object</em> conveys more information about <em>why</em> an operation might have failed.
The concept of dedicated type representing the overall result of an operation isn’t a new one.
They are wrapper objects indicating whether or not an operation was a success and include a value or, if unsuccessful, a reason why not.
Many languages support dynamic tuples as return types, so you don’t need an explicit type representing your operation, like in Go:</p>
<pre data-code-language="go" data-type="programlisting"><code class="kd">func</code> <code class="nx">safeReadString</code><code class="p">(</code><code class="nx">path</code> <code class="kt">string</code><code class="p">)</code> <code class="p">(</code><code class="kt">string</code><code class="p">,</code> <code class="kt">error</code><code class="p">)</code> <code class="p">{</code>
  <code class="c1">// ...</code>
<code class="p">}</code>

<code class="nx">content</code><code class="p">,</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">safeReadString</code><code class="p">(</code><code class="s">"location/content.md"</code><code class="p">)</code>
<code class="k">if</code> <code class="nx">err</code> <code class="o">!=</code> <code class="kc">nil</code> <code class="p">{</code>
  <code class="c1">// error handling code</code>
<code class="p">}</code></pre>
<p>Even though Java lacks such dynamic tuples, thanks to Generics, a versatile and functionally inclined result type can be created that leverages tools and concepts discussed in this book.</p>
<p>Let’s create a rudimentary <code>Result&lt;V, E extends Throwable&gt;</code> type together.</p>
<section data-pdf-bookmark="Creating the Scaffold" data-type="sect3"><div class="sect3" id="idm45115225698000">
<h3>Creating the Scaffold</h3>
<p>The main goal of the <code>Result</code> type is to hold a possible value or, if not successful, an Exception representing the reason for failure.</p>
<p>A “traditional” result object could be implemented as a Record as shown in <a data-type="xref" href="#_02-exception-handling_result-type-01">Example 10-5</a>.</p>
<div data-type="example" id="_02-exception-handling_result-type-01">
<h5><span class="label">Example 10-5. </span>Traditional Result Object</h5>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">record</code> <code class="nc">Result</code><code class="o">&lt;</code><code class="n">V</code><code class="p">,</code> <code class="n">E</code> <code class="kd">extends</code> <code class="n">Throwable</code><code class="o">&gt;</code><code class="p">(</code><code class="n">V</code> <code class="n">value</code><code class="p">,</code> <a class="co" href="#callout_functional_exception_handling_CO5-1" id="co_functional_exception_handling_CO5-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a>
                                             <code class="n">E</code> <code class="n">throwable</code><code class="p">,</code>
                                             <code class="kt">boolean</code> <code class="n">isSuccess</code><code class="p">)</code> <code class="p">{</code>

  <code class="kd">public</code> <code class="kd">static</code> <code class="o">&lt;</code><code class="n">V</code><code class="p">,</code> <code class="n">E</code> <code class="kd">extends</code> <code class="n">Throwable</code><code class="o">&gt;</code> <code class="n">Result</code><code class="o">&lt;</code><code class="n">V</code><code class="p">,</code> <code class="n">E</code><code class="o">&gt;</code> <code class="nf">success</code><code class="p">(</code><code class="n">V</code> <code class="n">value</code><code class="p">)</code> <code class="p">{</code> <a class="co" href="#callout_functional_exception_handling_CO5-2" id="co_functional_exception_handling_CO5-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a>
    <code class="k">return</code> <code class="k">new</code> <code class="n">Result</code><code class="o">&lt;</code><code class="o">&gt;</code><code class="p">(</code><code class="n">value</code><code class="p">,</code> <code class="kc">null</code><code class="p">,</code> <code class="kc">true</code><code class="p">)</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="kd">public</code> <code class="kd">static</code> <code class="o">&lt;</code><code class="n">V</code><code class="p">,</code> <code class="n">E</code> <code class="kd">extends</code> <code class="n">Throwable</code><code class="o">&gt;</code> <code class="n">Result</code><code class="o">&lt;</code><code class="n">V</code><code class="p">,</code> <code class="n">E</code><code class="o">&gt;</code> <code class="nf">failure</code><code class="p">(</code><code class="n">E</code> <code class="n">throwable</code><code class="p">)</code> <code class="p">{</code> <a class="co" href="#callout_functional_exception_handling_CO5-2" id="co_functional_exception_handling_CO5-3"><img alt="2" height="12" src="assets/2.png" width="12"/></a>
    <code class="k">return</code> <code class="k">new</code> <code class="n">Result</code><code class="o">&lt;</code><code class="o">&gt;</code><code class="p">(</code><code class="kc">null</code><code class="p">,</code> <code class="n">throwable</code><code class="p">,</code> <code class="kc">false</code><code class="p">)</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code></pre></div>
<dl class="calloutlist">
<dt><a class="co" href="#co_functional_exception_handling_CO5-1" id="callout_functional_exception_handling_CO5-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p>The Record components reflect the different states.
The explicit <code>isSuccess</code> field helps to better determine a successful operation and to support <code>null</code> as a valid value.</p></dd>
<dt><a class="co" href="#co_functional_exception_handling_CO5-2" id="callout_functional_exception_handling_CO5-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a></dt>
<dd><p>Convenience factory methods provide a more expressive API.</p></dd>
</dl>
<p>Even this simple scaffold provides a certain improvement over using Optionals already, with the convenience factory methods being an expressive way to create appropriate results.</p>
<p>The previous examples of <code>safeReadString</code> can be easily converted to use the <code>Result&lt;V,E&gt;</code> type, as shown in <a data-type="xref" href="#_02-exception-handling_result-type-02">Example 10-6</a></p>
<div data-type="example" id="_02-exception-handling_result-type-02">
<h5><span class="label">Example 10-6. </span>Using <code>Result&lt;V, E&gt;</code> as a return type</h5>
<pre data-code-language="java" data-type="programlisting"><code class="n">Result</code><code class="o">&lt;</code><code class="n">String</code><code class="p">,</code> <code class="n">IOException</code><code class="o">&gt;</code> <code class="nf">safeReadString</code><code class="p">(</code><code class="n">Path</code> <code class="n">path</code><code class="p">)</code> <code class="p">{</code>
  <code class="k">try</code> <code class="p">{</code>
    <code class="k">return</code> <code class="n">Result</code><code class="p">.</code><code class="na">success</code><code class="p">(</code><code class="n">Files</code><code class="p">.</code><code class="na">readString</code><code class="p">(</code><code class="n">path</code><code class="p">));</code>
  <code class="p">}</code> <code class="k">catch</code> <code class="p">(</code><code class="n">IOException</code> <code class="n">e</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="n">Result</code><code class="p">.</code><code class="na">failure</code><code class="p">(</code><code class="n">e</code><code class="p">);</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="n">Stream</code><code class="p">.</code><code class="na">of</code><code class="p">(</code><code class="n">path1</code><code class="p">,</code> <code class="n">path2</code><code class="p">,</code> <code class="n">path3</code><code class="p">)</code>
      <code class="p">.</code><code class="na">map</code><code class="p">(</code><code class="k">this</code><code class="p">::</code><code class="n">safeReadString</code><code class="p">)</code>
      <code class="p">.</code><code class="na">filter</code><code class="p">(</code><code class="n">Result</code><code class="p">::</code><code class="n">isSuccess</code><code class="p">)</code>
      <code class="p">.</code><code class="na">forEach</code><code class="p">(</code><code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">::</code><code class="n">println</code><code class="p">);</code></pre></div>
<p>The new type is just as easy to use in a Stream pipeline as an Optional.
But the real power comes from giving it more functional properties by introducing higher-order functions that depend on the success state.</p>
</div></section>
<section data-pdf-bookmark="Making Result&lt;V, E&gt; Functional" data-type="sect3"><div class="sect3" id="idm45115225451088">
<h3>Making Result&lt;V, E&gt; Functional</h3>
<p>The general features of the <code>Optional&lt;T&gt;</code> type are the inspiration on how to improve the <code>Result</code> type further, including:</p>
<ul>
<li>
<p>Transforming its value or Exception</p>
</li>
<li>
<p>Reacting to an Exception</p>
</li>
<li>
<p>Providing a fallback value</p>
</li>
</ul>
<p>Transforming the <code>value</code> or <code>throwable</code> field requires dedicated <code>map</code> methods or a combined one to handle both use cases at once, as shown in <a data-type="xref" href="#_02-exception-handling_result-type-03">Example 10-7</a>.</p>
<div data-type="example" id="_02-exception-handling_result-type-03">
<h5><span class="label">Example 10-7. </span>Adding Transformers to <code>Result&lt;V, E&gt;</code></h5>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">record</code> <code class="nc">Result</code><code class="o">&lt;</code><code class="n">V</code><code class="p">,</code> <code class="n">E</code> <code class="kd">extends</code> <code class="n">Throwable</code><code class="o">&gt;</code> <code class="p">(</code><code class="n">V</code> <code class="n">value</code><code class="p">,</code>
                                              <code class="n">E</code> <code class="n">throwable</code><code class="p">,</code>
                                              <code class="kt">boolean</code> <code class="n">isSuccess</code><code class="p">)</code> <code class="p">{</code>
  <code class="c1">// ...</code>

  <code class="kd">public</code> <code class="o">&lt;</code><code class="n">R</code><code class="o">&gt;</code> <code class="n">Optional</code><code class="o">&lt;</code><code class="n">R</code><code class="o">&gt;</code> <code class="nf">mapSuccess</code><code class="p">(</code><code class="n">Function</code><code class="o">&lt;</code><code class="n">V</code><code class="p">,</code> <code class="n">R</code><code class="o">&gt;</code> <code class="n">fn</code><code class="p">)</code> <code class="p">{</code> <a class="co" href="#callout_functional_exception_handling_CO6-1" id="co_functional_exception_handling_CO6-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="na">isSuccess</code> <code class="o">?</code> <code class="n">Optional</code><code class="p">.</code><code class="na">ofNullable</code><code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="na">value</code><code class="p">)</code><code class="p">.</code><code class="na">map</code><code class="p">(</code><code class="n">fn</code><code class="p">)</code>
                          <code class="p">:</code> <code class="n">Optional</code><code class="p">.</code><code class="na">empty</code><code class="p">(</code><code class="p">)</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="kd">public</code> <code class="o">&lt;</code><code class="n">R</code><code class="o">&gt;</code> <code class="n">Optional</code><code class="o">&lt;</code><code class="n">R</code><code class="o">&gt;</code> <code class="nf">mapFailure</code><code class="p">(</code><code class="n">Function</code><code class="o">&lt;</code><code class="n">E</code><code class="p">,</code> <code class="n">R</code><code class="o">&gt;</code> <code class="n">fn</code><code class="p">)</code> <code class="p">{</code> <a class="co" href="#callout_functional_exception_handling_CO6-1" id="co_functional_exception_handling_CO6-2"><img alt="1" height="12" src="assets/1.png" width="12"/></a>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="na">isSuccess</code> <code class="o">?</code> <code class="n">Optional</code><code class="p">.</code><code class="na">empty</code><code class="p">(</code><code class="p">)</code>
                          <code class="p">:</code> <code class="n">Optional</code><code class="p">.</code><code class="na">ofNullable</code><code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="na">throwable</code><code class="p">)</code><code class="p">.</code><code class="na">map</code><code class="p">(</code><code class="n">fn</code><code class="p">)</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="kd">public</code> <code class="o">&lt;</code><code class="n">R</code><code class="o">&gt;</code> <code class="n">R</code> <code class="nf">map</code><code class="p">(</code><code class="n">Function</code><code class="o">&lt;</code><code class="n">V</code><code class="p">,</code> <code class="n">R</code><code class="o">&gt;</code> <code class="n">successFn</code><code class="p">,</code> <a class="co" href="#callout_functional_exception_handling_CO6-2" id="co_functional_exception_handling_CO6-3"><img alt="2" height="12" src="assets/2.png" width="12"/></a>
                   <code class="n">Function</code><code class="o">&lt;</code><code class="n">E</code><code class="p">,</code> <code class="n">R</code><code class="o">&gt;</code> <code class="n">failureFn</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="na">isSuccess</code> <code class="o">?</code> <code class="n">successFn</code><code class="p">.</code><code class="na">apply</code><code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="na">value</code><code class="p">)</code> <code class="c1">//</code>
                          <code class="p">:</code> <code class="n">failureFn</code><code class="p">.</code><code class="na">apply</code><code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="na">throwable</code><code class="p">)</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code></pre></div>
<dl class="calloutlist">
<dt><a class="co" href="#co_functional_exception_handling_CO6-1" id="callout_functional_exception_handling_CO6-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p>The singular mapping methods are quite similar and transform the respective result, success or failure.
That’s why both must return an <code>Optional</code> instead of a concrete value.</p></dd>
<dt><a class="co" href="#co_functional_exception_handling_CO6-3" id="callout_functional_exception_handling_CO6-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a></dt>
<dd><p>A combined <code>map</code> method allows you to handle both cases, success or failure, in a single call.
Because both states are handled, a concrete value instead of an <code>Optional</code> is returned.</p></dd>
</dl>
<p>With the help of the mapper methods, you can now handle either one or both cases directly, as follows:</p>
<pre data-code-language="java" data-type="programlisting"><code class="c1">// HANDLE ONLY SUCCESS CASE</code>

<code class="n">Stream</code><code class="p">.</code><code class="na">of</code><code class="p">(</code><code class="n">path1</code><code class="p">,</code> <code class="n">path2</code><code class="p">,</code> <code class="n">path3</code><code class="p">)</code>
      <code class="p">.</code><code class="na">map</code><code class="p">(</code><code class="k">this</code><code class="p">::</code><code class="n">safeReadString</code><code class="p">)</code>
      <code class="p">.</code><code class="na">map</code><code class="p">(</code><code class="n">result</code> <code class="o">-&gt;</code> <code class="n">result</code><code class="p">.</code><code class="na">mapSuccess</code><code class="p">(</code><code class="n">String</code><code class="p">::</code><code class="n">toUpperCase</code><code class="p">))</code>
      <code class="p">.</code><code class="na">flatMap</code><code class="p">(</code><code class="n">Optional</code><code class="p">::</code><code class="n">stream</code><code class="p">)</code>
      <code class="p">.</code><code class="na">forEach</code><code class="p">(</code><code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">::</code><code class="n">println</code><code class="p">);</code>


<code class="c1">// HANDLE BOTH CASES</code>

<code class="kd">var</code> <code class="n">result</code> <code class="o">=</code> <code class="n">safeReadString</code><code class="p">(</code><code class="n">path</code><code class="p">).</code><code class="na">map</code><code class="p">(</code>
  <code class="n">success</code> <code class="o">-&gt;</code> <code class="n">success</code><code class="p">.</code><code class="na">toUpperCase</code><code class="p">(),</code>
  <code class="n">failure</code> <code class="o">-&gt;</code> <code class="s">"IO-Error: "</code> <code class="o">+</code> <code class="n">failure</code><code class="p">.</code><code class="na">getMessage</code><code class="p">()</code>
<code class="p">);</code></pre>
<p>There also needs to be a way to work with a <code>Result</code> without requiring to transform its value or Exception first.</p>
<p>To react to a certain state, let’s add <code>ifSuccess</code>, <code>ifFailure</code>, and <code>handle</code>, as follows:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">record</code> <code class="nc">Result</code><code class="o">&lt;</code><code class="n">V</code><code class="p">,</code> <code class="n">E</code> <code class="kd">extends</code> <code class="n">Throwable</code><code class="o">&gt;</code> <code class="p">(</code><code class="n">V</code> <code class="n">value</code><code class="p">,</code>
                                              <code class="n">E</code> <code class="n">throwable</code><code class="p">,</code>
                                              <code class="kt">boolean</code> <code class="n">isSuccess</code><code class="p">)</code> <code class="p">{</code>
  <code class="c1">// ...</code>

  <code class="kd">public</code> <code class="kt">void</code> <code class="nf">ifSuccess</code><code class="p">(</code><code class="n">Consumer</code><code class="o">&lt;?</code> <code class="kd">super</code> <code class="n">V</code><code class="o">&gt;</code> <code class="n">action</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="na">isSuccess</code><code class="p">)</code> <code class="p">{</code>
      <code class="n">action</code><code class="p">.</code><code class="na">accept</code><code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="na">value</code><code class="p">);</code>
    <code class="p">}</code>
  <code class="p">}</code>

  <code class="kd">public</code> <code class="kt">void</code> <code class="nf">ifFailure</code><code class="p">(</code><code class="n">Consumer</code><code class="o">&lt;?</code> <code class="kd">super</code> <code class="n">E</code><code class="o">&gt;</code> <code class="n">action</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="o">!</code><code class="k">this</code><code class="p">.</code><code class="na">isSuccess</code><code class="p">)</code> <code class="p">{</code>
      <code class="n">action</code><code class="p">.</code><code class="na">accept</code><code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="na">throwable</code><code class="p">);</code>
    <code class="p">}</code>
  <code class="p">}</code>

  <code class="kd">public</code> <code class="kt">void</code> <code class="nf">handle</code><code class="p">(</code><code class="n">Consumer</code><code class="o">&lt;?</code> <code class="kd">super</code> <code class="n">V</code><code class="o">&gt;</code> <code class="n">successAction</code><code class="p">,</code>
                     <code class="n">Consumer</code><code class="o">&lt;?</code> <code class="kd">super</code> <code class="n">E</code><code class="o">&gt;</code> <code class="n">failureAction</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="na">isSuccess</code><code class="p">)</code> <code class="p">{</code>
      <code class="n">successAction</code><code class="p">.</code><code class="na">accept</code><code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="na">value</code><code class="p">);</code>
    <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>
      <code class="n">failureAction</code><code class="p">.</code><code class="na">accept</code><code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="na">throwable</code><code class="p">);</code>
    <code class="p">}</code>
  <code class="p">}</code>
<code class="p">}</code></pre>
<p>The implementation is almost equivalent to the mapper methods, except they use a <code>Consumer</code> instead of a <code>Function</code>.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>These two additions are side-effect-only and, therefore, not very “functional” in the purest sense.
Nevertheless, such additions provide an excellent stopgap between imperative and functional approaches.</p>
</div>
<p>Next, let’s add convenience methods for providing fallback values.
The most obvious ones are <code>orElse</code> and <code>orElseGet</code>, as follows:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">record</code> <code class="nc">Result</code><code class="o">&lt;</code><code class="n">V</code><code class="p">,</code> <code class="n">E</code> <code class="kd">extends</code> <code class="n">Throwable</code><code class="o">&gt;</code><code class="p">(</code><code class="n">V</code> <code class="n">value</code><code class="p">,</code>
                                             <code class="n">E</code> <code class="n">throwable</code><code class="p">,</code>
                                             <code class="kt">boolean</code> <code class="n">isSuccess</code><code class="p">)</code> <code class="p">{</code>
  <code class="c1">// ...</code>

  <code class="kd">public</code> <code class="n">V</code> <code class="nf">orElse</code><code class="p">(</code><code class="n">V</code> <code class="n">other</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="na">isSuccess</code> <code class="o">?</code> <code class="k">this</code><code class="p">.</code><code class="na">value</code>
                          <code class="p">:</code> <code class="n">other</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="kd">public</code> <code class="n">V</code> <code class="nf">orElseGet</code><code class="p">(</code><code class="n">Supplier</code><code class="o">&lt;?</code> <code class="kd">extends</code> <code class="n">V</code><code class="o">&gt;</code> <code class="n">otherSupplier</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="na">isSuccess</code> <code class="o">?</code> <code class="k">this</code><code class="p">.</code><code class="na">value</code>
                          <code class="p">:</code> <code class="n">otherSupplier</code><code class="p">.</code><code class="na">get</code><code class="p">();</code>
  <code class="p">}</code>
<code class="p">}</code></pre>
<p>No surprises here.</p>
<p>However, adding an <code>orElseThrow</code> as a shortcut to re-throw the inner <code>Throwable</code> isn’t as straightforward because it still has to adhere to the catch-or-specify requirement.
This is actually the one acceptable use case I talked about earlier about using a “sneaky throw,” as discussed in <a data-type="xref" href="#_02-exception-handling_sneaky-throws">“Sneaky Throws”</a>, to circumvent the requirement:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">record</code> <code class="nc">Result</code><code class="o">&lt;</code><code class="n">V</code><code class="p">,</code> <code class="n">E</code> <code class="kd">extends</code> <code class="n">Throwable</code><code class="o">&gt;</code><code class="p">(</code><code class="n">V</code> <code class="n">value</code><code class="p">,</code>
                                             <code class="n">E</code> <code class="n">throwable</code><code class="p">,</code>
                                             <code class="kt">boolean</code> <code class="n">isSuccess</code><code class="p">)</code> <code class="p">{</code>
  <code class="c1">// ...</code>

  <code class="kd">private</code> <code class="o">&lt;</code><code class="n">E</code> <code class="kd">extends</code> <code class="n">Throwable</code><code class="o">&gt;</code> <code class="kt">void</code> <code class="nf">sneakyThrow</code><code class="p">(</code><code class="n">Throwable</code> <code class="n">e</code><code class="p">)</code> <code class="kd">throws</code> <code class="n">E</code> <code class="p">{</code>
    <code class="k">throw</code> <code class="p">(</code><code class="n">E</code><code class="p">)</code> <code class="n">e</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="kd">public</code> <code class="n">V</code> <code class="nf">orElseThrow</code><code class="p">()</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="o">!</code><code class="k">this</code><code class="p">.</code><code class="na">isSuccess</code><code class="p">)</code> <code class="p">{</code>
      <code class="n">sneakyThrow</code><code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="na">throwable</code><code class="p">);</code>
      <code class="k">return</code> <code class="kc">null</code><code class="p">;</code>
    <code class="p">}</code>

    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="na">value</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code></pre>
<p>In this particular case, a “sneaky throw” is justified in my opinion due to the general context and public contract of <code>orElseThrow()</code>.
Like with <code>Optional&lt;T&gt;</code>, the method force-unwraps the “box” holding a possible result and warns you about a possible exception with its name.</p>
<p>There’s a lot left to be desired, like adding a <code>Stream&lt;V&gt; stream()</code> method for even better integration into Stream pipelines.
Still, the general approach was a great exercise on how to combine functional concepts to provide an alternative to handling disruptive control flow events.
The implementation shown in this book is quite simplistic and reduced to a minimal amount of code.</p>
<p>If you intend to use a type like <code>Result&lt;V, E&gt;</code>, you should check out one of the functional libraries of the Java ecosystem.
Projects like <a href="https://www.vavr.io">vavr</a>, <a href="https://github.com/jOOQ/jOOL">jOOλ</a> (pronounced “JOOL”), and <a href="https://www.functionaljava.org">Functional Java</a> provide quite comprehensive and battle-tested implementations ready to use.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="The Try/Success/Failure Pattern" data-type="sect2"><div class="sect2" id="idm45115225385104">
<h2>The Try/Success/Failure Pattern</h2>
<p>Scala is arguably the closest functional relative to Java available on the JVM, not considering Clojure due to its more foreign syntax and dynamic type system.
It addresses many of Java’s perceived “shortcomings” over younger languages and is functional at its core, including an excellent way of dealing with exceptional conditions.</p>
<p>The <em>Try/Success/Failure</em> pattern and its related types <code>Try[+T]</code>⁠<sup><a data-type="noteref" href="ch10.xhtml#idm45115224366432" id="idm45115224366432-marker">5</a></sup>, <code>Success[+T]</code>, and <code>Failure[+T]</code>, are Scala’s way of dealing with Exceptions in a more functional fashion.</p>
<p>Where an <code>Optional&lt;T&gt;</code> indicates that a value might be missing, <code>Try[+T]</code> can tell you <em>why</em> and gives you the possibility to handle any occurred Exception, similar to the <code>Result</code> type discussed earlier in this chapter.
If the code succeeds, a <code>Success[+T]</code> object is returned, and if it fails, the error will be contained in a <code>Failure[+T]</code> object.
Scala also supports <em>pattern-matching</em>, a <code>switch</code>-like concept of handling different outcomes.
That allows for quite concise and straightforward Exception handling without the usual boilerplate a Java developer is used to.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Scala-like pattern matching for Java’s <code>switch</code> construct is available as a preview feature<sup><a data-type="noteref" href="ch10.xhtml#idm45115224250464" id="idm45115224250464-marker">6</a></sup> since Java 17.</p>
</div>
<p>A <code>Try[+T]</code> can either be in a <code>Success[+T]</code> or <code>Failure[+T]</code> state, with the latter containing a <code>Throwable</code>.
Even without full knowledge of Scala’s syntax, the code in <a data-type="xref" href="#_02-exception-handling_try-success-failure">Example 10-8</a> shouldn’t be too foreign to a Java developer.</p>
<div data-type="example" id="_02-exception-handling_try-success-failure">
<h5><span class="label">Example 10-8. </span>Scala’s Try/Success/Failure pattern</h5>
<pre data-code-language="scala" data-type="programlisting"><code class="k">def</code> <code class="nf">readString</code><code class="p">(</code><code class="n">path</code><code class="p">:</code> <code class="nc">Path</code><code class="p">)</code><code class="p">:</code> <code class="nc">Try</code><code class="p">[</code><code class="nc">String</code><code class="p">]</code> <code class="o">=</code> <code class="nc">Try</code> <code class="p">{</code> <a class="co" href="#callout_functional_exception_handling_CO7-1" id="co_functional_exception_handling_CO7-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a>
  <code class="c1">// code that will throw an Exception
</code><code class="p">}</code>

<code class="kd">val</code> <code class="n">path</code> <code class="o">=</code> <code class="nc">Path</code><code class="p">.</code><code class="n">of</code><code class="p">(</code><code class="p">.</code><code class="p">.</code><code class="p">.</code><code class="p">)</code><code class="p">;</code>

<code class="n">readString</code><code class="p">(</code><code class="n">path</code><code class="p">)</code> <code class="k">match</code> <code class="p">{</code> <a class="co" href="#callout_functional_exception_handling_CO7-2" id="co_functional_exception_handling_CO7-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a>
  <code class="k">case</code> <code class="nc">Success</code><code class="p">(</code><code class="n">value</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="n">println</code><code class="p">(</code><code class="n">value</code><code class="p">.</code><code class="n">toUpperCase</code><code class="p">)</code> <a class="co" href="#callout_functional_exception_handling_CO7-3" id="co_functional_exception_handling_CO7-3"><img alt="3" height="12" src="assets/3.png" width="12"/></a>
  <code class="k">case</code> <code class="nc">Failure</code><code class="p">(</code><code class="n">e</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="n">println</code><code class="p">(</code><code class="s">"Couldn't read file: "</code> <code class="o">+</code> <code class="n">e</code><code class="p">.</code><code class="n">getMessage</code><code class="p">)</code> <a class="co" href="#callout_functional_exception_handling_CO7-4" id="co_functional_exception_handling_CO7-4"><img alt="4" height="12" src="assets/4.png" width="12"/></a>
<code class="p">}</code></pre></div>
<dl class="calloutlist">
<dt><a class="co" href="#co_functional_exception_handling_CO7-1" id="callout_functional_exception_handling_CO7-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p>The return type is <code>Try[String]</code>, so the method must either return a <code>Success[String]</code> containing the content of the <code>Path</code>, or a <code>Failure[Throwable]</code>.
Scala doesn’t need an explicit <code>return</code> and returns the last value implicitly.
Any Exception is caught by the <code>Try { …​ }</code> construct.</p></dd>
<dt><a class="co" href="#co_functional_exception_handling_CO7-2" id="callout_functional_exception_handling_CO7-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a></dt>
<dd><p>Scala’s pattern matching simplifies the result handling.
The cases are lambdas, and the whole block is similar to an Optional call chain with a <code>map</code> and a <code>orElse</code> operation.</p></dd>
<dt><a class="co" href="#co_functional_exception_handling_CO7-3" id="callout_functional_exception_handling_CO7-3"><img alt="3" height="12" src="assets/3.png" width="12"/></a></dt>
<dd><p><code>Success</code> provides access to the return value.</p></dd>
<dt><a class="co" href="#co_functional_exception_handling_CO7-4" id="callout_functional_exception_handling_CO7-4"><img alt="4" height="12" src="assets/4.png" width="12"/></a></dt>
<dd><p>If an Exception occurs, it’s handled by the <code>Failure</code> case.</p></dd>
</dl>
<p><code>Try[+A]</code> is an excellent Scala feature, combining concepts similar to Optionals and Exception handling into a single, easy-to-use type and idiom.
But what does that mean for you as a Java developer?</p>
<p>Java doesn’t provide anything out-of-the-box that comes even close to the simplicity or language integration of Scala’s try/success/failure pattern.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45115223910448">
<h1>Functional Exception Handling with CompletableFuture</h1>
<p>Java actually has a type capable of handling lambdas in the vein of the try/success/failure pattern: <code>CompletableFuture&lt;T&gt;</code>.
It provides a fluent functional API including error handling, which I will discuss in more detail in <a data-type="xref" href="ch13.xhtml#_02-completable-future">Chapter 13</a>.</p>
<p>On the surface, it’s quite similar to the custom <code>Try</code> implementation.
However, its optimal problem context isn’t handling throwing lambdas.
Instead, <code>CompletableFuture</code> is designed for asynchronous tasks and running lambdas in multi-threaded environments.</p>
</div></aside>
<p>Even without language support, you can still try to implement an approximation of the try/success/failure pattern with the new functional tools since Java 8.
So let’s do that now.</p>
<section data-pdf-bookmark="Creating a Pipeline" data-type="sect3"><div class="sect3" id="idm45115223905584">
<h3>Creating a Pipeline</h3>
<p>Similar to how Streams provide a launch pad for a functional pipeline, the <code>Try</code> type we’re going to create will have a creation step, intermediate, but independent operations, and finally, a terminal operation to kickstart the pipeline.</p>
<p>To replicate Scala’s functionality, a construct accepting a lambda is needed as a starting point.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>As with other functional constructs, many variants would be needed to support the various available functional interfaces.
To simplify the required code, the <code>Try</code> type only supports <code>Function&lt;T, R&gt;</code> as the initial lambda.</p>
</div>
<p>The main requirements of the <code>Try</code> type are:</p>
<ul>
<li>
<p>Accepting a possibly throwing lambda</p>
</li>
<li>
<p>Providing a <code>success</code> operation</p>
</li>
<li>
<p>Providing a <code>failure</code> operation</p>
</li>
<li>
<p>Starting the pipeline with a value</p>
</li>
</ul>
<p>The <code>Try</code> type could be simplified by only supporting <code>RuntimeException</code>, but then, it wouldn’t be a flexible alternative to regular <code>try</code>-<code>catch</code>-block.
To circumvent the catch-or-specify requirement, the <code>ThrowingFunction</code> interface discussed in <a data-type="xref" href="#_02-exception-handling_unchecking-exceptions">“Un-Checking Exceptions”</a>.</p>
<p>The minimum scaffold required to accept <code>ThrowingFunction</code> and a possible <code>Function</code> to handle any a <code>RuntimeException</code> is shown in <a data-type="xref" href="#_02-exception-handling_try-success-failure-01">Example 10-9</a>.</p>
<div data-type="example" id="_02-exception-handling_try-success-failure-01">
<h5><span class="label">Example 10-9. </span>Minimal <code>Try&lt;T, R&gt;</code> accepting a lambda and Exception handler</h5>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">class</code> <code class="nc">Try</code><code class="o">&lt;</code><code class="n">T</code><code class="p">,</code> <code class="n">R</code><code class="o">&gt;</code> <code class="p">{</code> <a class="co" href="#callout_functional_exception_handling_CO8-1" id="co_functional_exception_handling_CO8-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a>

  <code class="kd">private</code> <code class="kd">final</code> <code class="n">Function</code><code class="o">&lt;</code><code class="n">T</code><code class="p">,</code> <code class="n">R</code><code class="o">&gt;</code>                <code class="n">fn</code><code class="p">;</code> <a class="co" href="#callout_functional_exception_handling_CO8-2" id="co_functional_exception_handling_CO8-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a>
  <code class="kd">private</code> <code class="kd">final</code> <code class="n">Function</code><code class="o">&lt;</code><code class="n">RuntimeException</code><code class="p">,</code> <code class="n">R</code><code class="o">&gt;</code> <code class="n">failureFn</code><code class="p">;</code> <a class="co" href="#callout_functional_exception_handling_CO8-2" id="co_functional_exception_handling_CO8-3"><img alt="2" height="12" src="assets/2.png" width="12"/></a>

  <code class="kd">public</code> <code class="kd">static</code> <code class="o">&lt;</code><code class="n">T</code><code class="p">,</code> <code class="n">R</code><code class="o">&gt;</code> <code class="n">Try</code><code class="o">&lt;</code><code class="n">T</code><code class="p">,</code> <code class="n">R</code><code class="o">&gt;</code> <code class="nf">of</code><code class="p">(</code><code class="n">ThrowingFunction</code><code class="o">&lt;</code><code class="n">T</code><code class="p">,</code> <code class="n">R</code><code class="o">&gt;</code> <code class="n">fn</code><code class="p">)</code> <code class="p">{</code> <a class="co" href="#callout_functional_exception_handling_CO8-3" id="co_functional_exception_handling_CO8-4"><img alt="3" height="12" src="assets/3.png" width="12"/></a>
    <code class="n">Objects</code><code class="p">.</code><code class="na">requireNonNull</code><code class="p">(</code><code class="n">fn</code><code class="p">)</code><code class="p">;</code>

    <code class="k">return</code> <code class="k">new</code> <code class="n">Try</code><code class="o">&lt;</code><code class="o">&gt;</code><code class="p">(</code><code class="n">fn</code><code class="p">,</code>
                     <code class="kc">null</code><code class="p">)</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="kd">private</code> <code class="nf">Try</code><code class="p">(</code><code class="n">Function</code><code class="o">&lt;</code><code class="n">T</code><code class="p">,</code> <code class="n">R</code><code class="o">&gt;</code> <code class="n">fn</code><code class="p">,</code> <a class="co" href="#callout_functional_exception_handling_CO8-4" id="co_functional_exception_handling_CO8-5"><img alt="4" height="12" src="assets/4.png" width="12"/></a>
              <code class="n">Function</code><code class="o">&lt;</code><code class="n">RuntimeException</code><code class="p">,</code> <code class="n">R</code><code class="o">&gt;</code> <code class="n">failureFn</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="na">fn</code> <code class="o">=</code> <code class="n">fn</code><code class="p">;</code>
    <code class="k">this</code><code class="p">.</code><code class="na">failureFn</code> <code class="o">=</code> <code class="n">failureFn</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code></pre></div>
<dl class="calloutlist">
<dt><a class="co" href="#co_functional_exception_handling_CO8-1" id="callout_functional_exception_handling_CO8-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p>The Generic types <code>T</code> and <code>R</code> correspond to <code>Function&lt;T, R&gt;</code>.
A <code>class</code> is used instead of a <code>record</code> to hide the sole constructor.</p></dd>
<dt><a class="co" href="#co_functional_exception_handling_CO8-2" id="callout_functional_exception_handling_CO8-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a></dt>
<dd><p>The construct needs to hold the initial <code>Function&lt;T, R&gt;</code> and a possible error handling <code>Function&lt;RuntimeException, R&gt;</code>.
Both fields are <code>final</code>, making the <code>Try</code> type immutable.</p></dd>
<dt><a class="co" href="#co_functional_exception_handling_CO8-4" id="callout_functional_exception_handling_CO8-3"><img alt="3" height="12" src="assets/3.png" width="12"/></a></dt>
<dd><p>The <code>static</code> factory method <code>of</code> provides a similar interface as other functional pipelines.
It accepts a <code>ThrowingFunction&lt;T, R&gt;</code> to circumvent the catch-or-specify requirement, but assigns it immediately to a <code>Function&lt;T, R&gt;</code>.</p></dd>
<dt><a class="co" href="#co_functional_exception_handling_CO8-5" id="callout_functional_exception_handling_CO8-4"><img alt="4" height="12" src="assets/4.png" width="12"/></a></dt>
<dd><p>The <code>private</code> constructor enforces the use of the factory method.</p></dd>
</dl>
<p>Even though the type doesn’t do anything, creating a new pipeline from an existing lambda or method reference is pretty straightforward, as follows:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">var</code> <code class="n">trySuccessFailure</code> <code class="o">=</code> <code class="n">Try</code><code class="p">.</code><code class="o">&lt;</code><code class="n">Path</code><code class="p">,</code> <code class="n">String</code><code class="o">&gt;</code> <code class="nf">of</code><code class="p">(</code><code class="n">Files</code><code class="p">::</code><code class="n">readString</code><code class="p">);</code></pre>
<p>The type hints in front of the <code>of</code> call are required because the compiler can’t necessarily infer the type from the surrounding context.</p>
<p>Next, the type needs to handle success and failure.</p>
</div></section>
<section data-pdf-bookmark="Handling Success and Failure" data-type="sect3"><div class="sect3" id="idm45115223904960">
<h3>Handling Success and Failure</h3>
<p>Two new methods are needed to handle the outcome of the <code>Try</code> pipeline, <code>success</code> and <code>failure</code>, as seen in <a data-type="xref" href="#_02-exception-handling_try-success-failure-02">Example 10-10</a>.</p>
<div data-type="example" id="_02-exception-handling_try-success-failure-02">
<h5><span class="label">Example 10-10. </span>Handling success and failure in <code>Try&lt;T, R&gt;</code></h5>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">class</code> <code class="nc">Try</code><code class="o">&lt;</code><code class="n">T</code><code class="p">,</code> <code class="n">R</code><code class="o">&gt;</code> <code class="p">{</code>

  <code class="c1">// ...</code>

  <code class="kd">public</code> <code class="n">Try</code><code class="o">&lt;</code><code class="n">T</code><code class="p">,</code> <code class="n">R</code><code class="o">&gt;</code> <code class="nf">success</code><code class="p">(</code><code class="n">Function</code><code class="o">&lt;</code><code class="n">R</code><code class="p">,</code> <code class="n">R</code><code class="o">&gt;</code> <code class="n">successFn</code><code class="p">)</code> <code class="p">{</code>
    <code class="n">Objects</code><code class="p">.</code><code class="na">requireNonNull</code><code class="p">(</code><code class="n">successFn</code><code class="p">)</code><code class="p">;</code>

    <code class="kd">var</code> <code class="n">composedFn</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="na">fn</code><code class="p">.</code><code class="na">andThen</code><code class="p">(</code><code class="n">successFn</code><code class="p">)</code><code class="p">;</code> <a class="co" href="#callout_functional_exception_handling_CO9-1" id="co_functional_exception_handling_CO9-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a>
    <code class="k">return</code> <code class="k">new</code> <code class="n">Try</code><code class="o">&lt;</code><code class="o">&gt;</code><code class="p">(</code><code class="n">composedFn</code><code class="p">,</code>
                     <code class="k">this</code><code class="p">.</code><code class="na">failureFn</code><code class="p">)</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="kd">public</code> <code class="n">Try</code><code class="o">&lt;</code><code class="n">T</code><code class="p">,</code> <code class="n">R</code><code class="o">&gt;</code> <code class="nf">failure</code><code class="p">(</code><code class="n">Function</code><code class="o">&lt;</code><code class="n">RuntimeException</code><code class="p">,</code> <code class="n">R</code><code class="o">&gt;</code> <code class="n">failureFn</code><code class="p">)</code> <code class="p">{</code>
    <code class="n">Objects</code><code class="p">.</code><code class="na">requireNonNull</code><code class="p">(</code><code class="n">failureFn</code><code class="p">)</code><code class="p">;</code>

    <code class="k">return</code> <code class="k">new</code> <code class="n">Try</code><code class="o">&lt;</code><code class="o">&gt;</code><code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="na">fn</code><code class="p">,</code> <a class="co" href="#callout_functional_exception_handling_CO9-2" id="co_functional_exception_handling_CO9-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a>
                     <code class="n">failureFn</code><code class="p">)</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code></pre></div>
<dl class="calloutlist">
<dt><a class="co" href="#co_functional_exception_handling_CO9-1" id="callout_functional_exception_handling_CO9-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p>The <code>successFn</code> is composed to the original lambda to provide the base for the new <code>Try</code> instance.
The <code>failureFn</code> is used as-is.</p></dd>
<dt><a class="co" href="#co_functional_exception_handling_CO9-2" id="callout_functional_exception_handling_CO9-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a></dt>
<dd><p>Handling an error requires only passing through the original <code>fn</code> and the provided <code>failureFn</code>.</p></dd>
</dl>
<p>Because the <code>Try</code> type is designed to be immutable, both handling methods return a new instance of <code>Try</code>.
The <code>success</code> method uses functional composition to create the fully required task, whereas the <code>failure</code> method creates a new <code>Try</code> instance with the pre-existing lambda and the provided error handling <code>Function</code>.</p>
<p>By using functional composition for the <code>success</code> operation instead of an extra control path, like storing <code>successFn</code> in another field, the handler isn’t even required in case of no modifications to the result of the initial lambda.</p>
<p>Using the handler methods is as you would expect and feels similar to working with a Stream’s intermediate operations, as follows:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">var</code> <code class="n">trySuccessFailure</code> <code class="o">=</code>
  <code class="n">Try</code><code class="p">.</code><code class="o">&lt;</code><code class="n">Path</code><code class="p">,</code> <code class="n">String</code><code class="o">&gt;</code> <code class="nf">of</code><code class="p">(</code><code class="n">Files</code><code class="p">::</code><code class="n">readString</code><code class="p">)</code>
                    <code class="p">.</code><code class="na">success</code><code class="p">(</code><code class="n">String</code><code class="p">::</code><code class="n">toUpperCase</code><code class="p">)</code>
                    <code class="p">.</code><code class="na">failure</code><code class="p">(</code><code class="n">str</code> <code class="o">-&gt;</code> <code class="kc">null</code><code class="p">);</code></pre>
<p>Unlike a Stream, though, the operations are independent of one another and not in a sequential pipeline.
It’s more akin to how an Optionals pipeline seems to be sequential but actually has tracks to follow.
Which handling operation, <code>success</code> or <code>failure</code>, is supposed to be evaluated depends on the state of the <code>Try</code> evaluation.</p>
<p>It’s time to kickstart the pipeline.</p>
</div></section>
<section data-pdf-bookmark="Running the Pipeline" data-type="sect3"><div class="sect3" id="idm45115223591264">
<h3>Running the Pipeline</h3>
<p>The last operation needed to complete the pipeline is the ability to push a value down the pipeline and let the handlers do their work, in the form of an <code>apply</code> method, as shown in <a data-type="xref" href="#_02-exception-handling_try-success-failure-apply">Example 10-11</a>.</p>
<div data-type="example" id="_02-exception-handling_try-success-failure-apply">
<h5><span class="label">Example 10-11. </span>Applying a value to <code>Try</code></h5>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">class</code> <code class="nc">Try</code><code class="o">&lt;</code><code class="n">T</code><code class="p">,</code> <code class="n">R</code><code class="o">&gt;</code> <code class="p">{</code>

  <code class="c1">// ...</code>

  <code class="kd">public</code> <code class="n">Optional</code><code class="o">&lt;</code><code class="n">R</code><code class="o">&gt;</code> <code class="nf">apply</code><code class="p">(</code><code class="n">T</code> <code class="n">value</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">try</code> <code class="p">{</code>
      <code class="kd">var</code> <code class="n">result</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="na">fn</code><code class="p">.</code><code class="na">apply</code><code class="p">(</code><code class="n">value</code><code class="p">)</code><code class="p">;</code>
      <code class="k">return</code> <code class="n">Optional</code><code class="p">.</code><code class="na">ofNullable</code><code class="p">(</code><code class="n">result</code><code class="p">)</code><code class="p">;</code> <a class="co" href="#callout_functional_exception_handling_CO10-1" id="co_functional_exception_handling_CO10-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a>
    <code class="p">}</code>
    <code class="k">catch</code> <code class="p">(</code><code class="n">RuntimeException</code> <code class="n">e</code><code class="p">)</code> <code class="p">{</code>
      <code class="k">if</code> <code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="na">failureFn</code> <code class="o">!</code><code class="o">=</code> <code class="kc">null</code><code class="p">)</code> <code class="p">{</code> <a class="co" href="#callout_functional_exception_handling_CO10-2" id="co_functional_exception_handling_CO10-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a>
        <code class="kd">var</code> <code class="n">result</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="na">failureFn</code><code class="p">.</code><code class="na">apply</code><code class="p">(</code><code class="n">e</code><code class="p">)</code><code class="p">;</code>
        <code class="k">return</code> <code class="n">Optional</code><code class="p">.</code><code class="na">ofNullable</code><code class="p">(</code><code class="n">result</code><code class="p">)</code><code class="p">;</code>
      <code class="p">}</code>
    <code class="p">}</code>

    <code class="k">return</code> <code class="n">Optional</code><code class="p">.</code><code class="na">empty</code><code class="p">(</code><code class="p">)</code><code class="p">;</code> <a class="co" href="#callout_functional_exception_handling_CO10-3" id="co_functional_exception_handling_CO10-3"><img alt="3" height="12" src="assets/3.png" width="12"/></a>
  <code class="p">}</code>
<code class="p">}</code></pre></div>
<dl class="calloutlist">
<dt><a class="co" href="#co_functional_exception_handling_CO10-1" id="callout_functional_exception_handling_CO10-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p>The “happy path” is appyling <code>fn</code> to the value.
Thanks to designing the <code>success</code> method as functional composition, no special handling is needed to run the initial lambda and optional <code>success</code> transformation.
The code has to be run in a <code>try</code>-<code>catch</code>-block to handle the <code>failure</code> case.</p></dd>
<dt><a class="co" href="#co_functional_exception_handling_CO10-2" id="callout_functional_exception_handling_CO10-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a></dt>
<dd><p>Failure handling is optional, so a <code>null</code>-check is necessary.</p></dd>
<dt><a class="co" href="#co_functional_exception_handling_CO10-3" id="callout_functional_exception_handling_CO10-3"><img alt="3" height="12" src="assets/3.png" width="12"/></a></dt>
<dd><p>This point is the ultimate fallback if no error handler was added to the pipeline.</p></dd>
</dl>
<p>The return type <code>Optional&lt;R&gt;</code> provides another lift-off point for a functional pipeline.</p>
<p>Now our minimalistic <code>Try</code> pipeline has all the operations needed to call a throwing method and handle both the success and failure cases:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">var</code> <code class="n">path</code> <code class="o">=</code> <code class="n">Path</code><code class="p">.</code><code class="na">of</code><code class="p">(</code><code class="s">"location"</code><code class="p">,</code> <code class="s">"content.md"</code><code class="p">);</code>

<code class="n">Optional</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code> <code class="n">content</code> <code class="o">=</code>
  <code class="n">Try</code><code class="p">.</code><code class="o">&lt;</code><code class="n">Path</code><code class="p">,</code> <code class="n">String</code><code class="o">&gt;</code> <code class="nf">of</code><code class="p">(</code><code class="n">Files</code><code class="p">::</code><code class="n">readString</code><code class="p">)</code>
                    <code class="p">.</code><code class="na">success</code><code class="p">(</code><code class="n">String</code><code class="p">::</code><code class="n">toUpperCase</code><code class="p">)</code>
                    <code class="p">.</code><code class="na">failure</code><code class="p">(</code><code class="n">str</code> <code class="o">-&gt;</code> <code class="kc">null</code><code class="p">)</code>
                    <code class="p">.</code><code class="na">apply</code><code class="p">(</code><code class="n">path</code><code class="p">);</code></pre>
<p>Even though the <code>Try</code> pipeline gives you higher-order function operations to deal with a throwing lambda, the pipeline itself isn’t functional on the outside.
Or is it?</p>
<p>The name, <code>apply</code>, I’ve chosen for the terminal operation reveals the possible functional interface that <code>Try</code> could implement to be more easily usable in other functional pipelines like Streams or Optionals: <code>Function&lt;T, Optional&lt;R&gt;&gt;</code>.</p>
<p>By implementing the functional interface the <code>Try</code> type becomes a drop-in replacement for any <code>Function</code> without requiring actual logic changes, as shown in <a data-type="xref" href="#_02-exception-handling_try-success-failure-function">Example 10-12</a>:</p>
<div data-type="example" id="_02-exception-handling_try-success-failure-function">
<h5><span class="label">Example 10-12. </span>Implementing <code>Function&lt;T, Optional&lt;R&gt;&gt;</code></h5>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">class</code> <code class="nc">Try</code><code class="o">&lt;</code><code class="n">T</code><code class="p">,</code> <code class="n">R</code><code class="o">&gt;</code> <code class="kd">implements</code> <code class="n">Function</code><code class="o">&lt;</code><code class="n">T</code><code class="p">,</code> <code class="n">Optional</code><code class="o">&lt;</code><code class="n">R</code><code class="o">&gt;&gt;</code> <code class="p">{</code>

  <code class="c1">// ...</code>

  <code class="nd">@Override</code>
  <code class="kd">public</code> <code class="n">Optional</code><code class="o">&lt;</code><code class="n">R</code><code class="o">&gt;</code> <code class="nf">apply</code><code class="p">(</code><code class="n">T</code> <code class="n">value</code><code class="p">)</code> <code class="p">{</code>
    <code class="c1">// ...</code>
  <code class="p">}</code>
<code class="p">}</code></pre></div>
<p>Now, any <code>Try</code> pipeline is easily usable in any higher-order function that accepts a <code>Function</code>, like in a Stream <code>map</code> operation, as follows:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">Function</code><code class="o">&lt;</code><code class="n">Path</code><code class="p">,</code> <code class="n">Optional</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;&gt;</code> <code class="n">fileLoader</code> <code class="o">=</code>
  <code class="n">Try</code><code class="p">.</code><code class="o">&lt;</code><code class="n">Path</code><code class="p">,</code> <code class="n">String</code><code class="o">&gt;</code> <code class="nf">of</code><code class="p">(</code><code class="n">Files</code><code class="p">::</code><code class="n">readString</code><code class="p">)</code>
                    <code class="p">.</code><code class="na">success</code><code class="p">(</code><code class="n">String</code><code class="p">::</code><code class="n">toUpperCase</code><code class="p">)</code>
                    <code class="p">.</code><code class="na">failure</code><code class="p">(</code><code class="n">str</code> <code class="o">-&gt;</code> <code class="kc">null</code><code class="p">);</code>

<code class="n">Stream</code><code class="p">.</code><code class="na">of</code><code class="p">(</code><code class="n">path1</code><code class="p">,</code> <code class="n">path2</code><code class="p">,</code> <code class="n">path3</code><code class="p">)</code>
      <code class="p">.</code><code class="na">map</code><code class="p">(</code><code class="n">fileLoader</code><code class="p">)</code>
      <code class="p">.</code><code class="na">flatMap</code><code class="p">(</code><code class="n">Optional</code><code class="p">::</code><code class="n">stream</code><code class="p">)</code>
      <code class="p">.</code><code class="na">toList</code><code class="p">();</code></pre>
<p>As with the <code>Result</code> before, the <code>Try</code> type is quite minimalistic and should be regarded as an exercise of how to combine functional concepts to create new constructs, like a lazy fluent pipeline consisting of higher-order functions.
If you want to use a type like <code>Try</code>, you should consider using an established functional third-party library like <a href="https://www.vavr.io">vavr</a> which provides a versatile <code>Try</code> type and much more.</p>
</div></section>
</div></section>
</div></section>
<section data-pdf-bookmark="Final Thoughts on Functional Exception Handling" data-type="sect1"><div class="sect1" id="idm45115224369376">
<h1>Final Thoughts on Functional Exception Handling</h1>
<p>Disruptive and abnormal control flow conditions in our code are inevitable, which is why we need a way to deal with them.
Exception handling helps to improve program safety.
For example, the catch-or-specify requirement is designed to make you think about the anticipated exceptional states and deal with them accordingly to increase code quality.
Although it’s certainly useful, it’s also tricky to carry out.</p>
<p>Handling Exceptions can be quite a pain point in Java, regardless of using a functional approach.
There is always a trade-off, no matter which Exception-handling approach you choose, especially if checked Exceptions are involved:</p>
<ul>
<li>
<p>Extracting unsafe methods to gain localized Exception handling is a good compromise but not an easy-to-use general solution.</p>
</li>
<li>
<p>Designing your APIs to not have any exceptional states is not as easy as it sounds.</p>
</li>
<li>
<p>Unchecking your Exceptions is a “last-resort” tool that hides them away without a chance to handle them and contradicts their purpose.</p>
</li>
</ul>
<p>So what should you do?
Well, it depends.</p>
<p>None of the presented solutions is <em>perfect</em>.
You have to find a balance between “convenience” and “usability.”
Exceptions are sometimes an overused feature, but they are still essential signals to the control flow of your programs.
Hiding them away might not be in your best interest in the long run, even if the resulting code is more concise and reasonable, as long as no Exception occurs.</p>
<p>Not every imperative or OOP feature/technique is replaceable with a functional equivalent in Java.
Many of Java’s (functional) shortcomings are circumventable to gain their general advantages, even if the resulting code is not as concise as in fully-functional programming languages.
Exceptions, however, are one of those features that aren’t easily replaceable in most circumstances.
They’re often an indicator that you either should try to refactor your code to make it “more functional” or that a functional approach might not be the best solution for the problem.</p>
<p>Alternatively, there are several third-party libraries available, like the <a href="https://www.vavr.io/">Vavr project</a> or <a href="https://github.com/jOOQ/jOOL">jOOλ</a>,
that allow you to circumvent or at least mitigate problems when using (checked) Exceptions in functional Java code.
They did all the work implementing all relevant wrapper interfaces and replicating control structures and types from other languages, like pattern matching.
But in the end, you end up with highly specialized code that tries to bend Java to its will, without much regard for traditional or common code constructs.
Such dependence on a third-party library is a long-term commitment and shouldn’t be added lightly.</p>
</div></section>
<section data-pdf-bookmark="Takeaways" data-type="sect1"><div class="sect1" id="idm45115222812256">
<h1>Takeaways</h1>
<ul>
<li>
<p>There are no specialized constructs for handling Exceptions in functional code like lambda expressions, only the <code>try</code>-<code>catch</code>-block as usual, which leads to verbose and unwieldy code.</p>
</li>
<li>
<p>You can fulfill or circumvent the catch-or-specify requirement in multiple ways, but that merely hides the original “problem.”</p>
</li>
<li>
<p>Custom wrappers can provide a more functional approach.</p>
</li>
<li>
<p>Third-party libraries can help to reduce the additional boilerplate required for handling Exceptions more functionally.
But the newly introduced types and constructs are no lightweight addition to your code and might create a lot of technical debt.</p>
</li>
<li>
<p>Choosing the right way to deal with Exceptions in functional code depends highly on the surrounding context.</p>
</li>
</ul>
</div></section>
<div data-type="footnotes"><p data-type="footnote" id="idm45115227087312"><sup><a href="ch10.xhtml#idm45115227087312-marker">1</a></sup> Guy L. Steele and Richard P. Gabriel. 1996. “The evolution of Lisp.” <a href="https://doi.org/10.1145/234286.1057818">History of programming languages---II. Association for Computing Machinery, 233-330</a>.</p><p data-type="footnote" id="idm45115226777968"><sup><a href="ch10.xhtml#idm45115226777968-marker">2</a></sup> The <a href="https://kotlinlang.org/docs/exceptions.xhtml">official Kotlin documentation</a> highlights the differences between Java and Kotlin exception handling.</p><p data-type="footnote" id="idm45115226386080"><sup><a href="ch10.xhtml#idm45115226386080-marker">3</a></sup> Gamma, E., Helm, R., Johnson, R., &amp; Vlissides, J. (1994). Design patterns: Elements of reusable object-oriented software. Boston, MA: Addison Wesley.</p><p data-type="footnote" id="idm45115226007984"><sup><a href="ch10.xhtml#idm45115226007984-marker">4</a></sup> The rules for type resolution are listed in §18.4 of the <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-18.xhtml#jls-18.4">Java SE 8 Language Specification</a>.</p><p data-type="footnote" id="idm45115224366432"><sup><a href="ch10.xhtml#idm45115224366432-marker">5</a></sup> Scala’s generic types are declared with <code>[]</code> (square brackets) instead of <code>&lt;&gt;</code> (angle brackets). The <code>+</code> (plus) signifies the type’s variance. See <a href="https://docs.scala-lang.org/tour/variances.xhtml">“Tour of Scala”</a> for more information about type variance.</p><p data-type="footnote" id="idm45115224250464"><sup><a href="ch10.xhtml#idm45115224250464-marker">6</a></sup> The first preview of pattern matching for <code>switch</code> is described in <a href="https://openjdk.org/jeps/406">JEP 406</a>. A second preview is described in <a href="https://openjdk.org/jeps/420">JEP 420</a>, which was delivered in Java 18. The next release, Java 19, included the third preview described in <a href="https://openjdk.org/jeps/427">JEP 427</a>. The feature is still evolving with another preview planned for Java 20, described in <a href="https://openjdk.org/jeps/433">JEP 433</a>.</p></div></div></section></div></body></html>