["```java\nAngie|Anjie|Angy\n```", "```java\nAn[^ dn]\n```", "```java\ngrep 'An[^ dn]' *\n```", "```java\npublic static void main(String args[]) {\n```", "```java\npublic static void main(String[] args) {\n```", "```java\n\"You said it\\.\"\n```", "```java\nString pattern = \"\\\"You said it\\\\.\\\"\"\n```", "```java\nString pattern = \"\"\"\n\t\"You said it\\\\.\"\"\"\"\n```", "```java\nif (inputString.matches(stringRegexPattern)) {\n    // it matched... do something with it...\n}\n```", "```java\npublic class RESimple {\n    public static void main(String[] argv) {\n        String pattern = \"^Q[^u]\\\\d+\\\\.\";\n        String[] input = {\n            \"QA777\\. is the next flight. It is on time.\",\n            \"Quack, Quack, Quack!\"\n        };\n\n        Pattern p = Pattern.compile(pattern);\n\n        for (String in : input) {\n            boolean found = p.matcher(in).lookingAt();\n\n            System.out.println(\"'\" + pattern + \"'\" +\n            (found ? \" matches '\" : \" doesn't match '\") + in + \"'\");\n        }\n    }\n}\n```", "```java\n/**\n * The main public API of the java.util.regex package.\n */\n\npackage java.util.regex;\n\npublic final class Pattern {\n    // Flags values ('or' together)\n    public static final int\n        UNIX_LINES, CASE_INSENSITIVE, COMMENTS, MULTILINE,\n        DOTALL, UNICODE_CASE, CANON_EQ;\n    // No public constructors; use these Factory methods\n    public static Pattern compile(String patt);\n    public static Pattern compile(String patt, int flags);\n    // Method to get a Matcher for this Pattern\n    public Matcher matcher(CharSequence input);\n    // Information methods\n    public String pattern();\n    public int flags();\n    // Convenience methods\n    public static boolean matches(String pattern, CharSequence input);\n    public String[] split(CharSequence input);\n    public String[] split(CharSequence input, int max);\n}\n\npublic final class Matcher {\n    // Action: find or match methods\n    public boolean matches();\n    public boolean find();\n    public boolean find(int start);\n    public boolean lookingAt();\n    // \"Information about the previous match\" methods\n    public int start();\n    public int start(int whichGroup);\n    public int end();\n    public int end(int whichGroup);\n    public int groupCount();\n    public String group();\n    public String group(int whichGroup);\n    // Reset methods\n    public Matcher reset();\n    public Matcher reset(CharSequence newInput);\n    // Replacement methods\n    public Matcher appendReplacement(StringBuffer where, String newText);\n    public StringBuffer appendTail(StringBuffer where);\n    public String replaceAll(String newText);\n    public String replaceFirst(String newText);\n    // information methods\n    public Pattern pattern();\n}\n\n/* String, showing only the RE-related methods */\npublic final class String {\n    public boolean matches(String regex);\n    public String replaceFirst(String regex, String newStr);\n    public String replaceAll(String regex, String newStr);\n    public String[] split(String regex);\n    public String[] split(String regex, int max);\n}\n```", "```java\npublic class StringConvenience {\n    public static void main(String[] argv) {\n\n        String pattern = \".*Q[^u]\\\\d+\\\\..*\";\n        String line = \"Order QT300\\. Now!\";\n        if (line.matches(pattern)) {\n            System.out.println(line + \" matches \\\"\" + pattern + \"\\\"\");\n        } else {\n            System.out.println(\"NO MATCH\");\n        }\n    }\n}\n```", "```java\nMatcher m = Pattern.compile(patt).matcher(line);\nif (m.find( )) {\n    System.out.println(line + \" matches \" + patt)\n}\n```", "```java\npublic class REmatch {\n    public static void main(String[] argv) {\n\n        String patt = \"Q[^u]\\\\d+\\\\.\";\n        Pattern r = Pattern.compile(patt);\n        String line = \"Order QT300\\. Now!\";\n        Matcher m = r.matcher(line);\n        if (m.find()) {\n            System.out.println(patt + \" matches \\\"\" +\n                m.group(0) +\n                \"\\\" in \\\"\" + line + \"\\\"\");\n        } else {\n            System.out.println(\"NO MATCH\");\n        }\n    }\n}\n```", "```java\nQ[\\^u]\\d+\\. matches \"QT300.\" in \"Order QT300\\. Now!\"\n```", "```java\n        String patt = \"Q[^u]\\\\d+\\\\.\";\n        Pattern r = Pattern.compile(patt);\n        String line = \"Order QT300\\. Now!\";\n        Matcher m = r.matcher(line);\n        if (m.find()) {\n            System.out.println(patt + \" matches \\\"\" +\n                line.substring(m.start(0), m.end(0)) +\n                \"\\\" in \\\"\" + line + \"\\\"\");\n        } else {\n            System.out.println(\"NO MATCH\");\n        }\n```", "```java\nSmith, John\nAdams, John Quincy\n```", "```java\nJohn Smith\nJohn Quincy Adams\n```", "```java\npublic class REmatchTwoFields {\n    public static void main(String[] args) {\n        String inputLine = \"Adams, John Quincy\";\n        // Construct an RE with parens to \"grab\" both field1 and field2\n        Pattern r = Pattern.compile(\"(.*), (.*)\");\n        Matcher m = r.matcher(inputLine);\n        if (!m.matches())\n            throw new IllegalArgumentException(\"Bad input\");\n        System.out.println(m.group(2) + ' ' + m.group(1));\n    }\n}\n```", "```java\n/**\n * Quick demo of RE substitution: correct U.S. 'favor'\n * to Canadian/British 'favour', but not in \"favorite\"\n * @author Ian F. Darwin, http://www.darwinsys.com/\n */\npublic class ReplaceDemo {\n    public static void main(String[] argv) {\n\n        // Make an RE pattern to match as a word only (\\b=word boundary)\n        String patt = \"\\\\bfavor\\\\b\";\n\n        // A test input\n        String input = \"Do me a favor? Fetch my favorite.\";\n        System.out.println(\"Input: \" + input);\n\n        // Run it from a RE instance and see that it works\n        Pattern r = Pattern.compile(patt);\n        Matcher m = r.matcher(input);\n        System.out.println(\"ReplaceAll: \" + m.replaceAll(\"favour\"));\n\n        // Show the appendReplacement method\n        m.reset();\n        StringBuffer sb = new StringBuffer();\n        System.out.print(\"Append methods: \");\n        while (m.find()) {\n            // Copy to before first match,\n            // plus the word \"favor\"\n            m.appendReplacement(sb, \"favour\");\n        }\n        m.appendTail(sb);        // copy remainder\n        System.out.println(sb.toString());\n    }\n}\n```", "```java\nInput: Do me a favor? Fetch my favorite.\nReplaceAll: Do me a favour? Fetch my favorite.\nAppend methods: Do me a favour? Fetch my favorite.\n```", "```java\n/**\n * To perform multiple distinct substitutions in the same String,\n * you need a loop, and must call reset() on the matcher.\n */\npublic class ReplaceMulti {\n    public static void main(String[] args) {\n\n        Pattern patt = Pattern.compile(\"cat|dog\");\n        String line = \"The cat and the dog never got along well.\";\n        System.out.println(\"Input: \" + line);\n        Matcher matcher = patt.matcher(line);\n        while (matcher.find()) {\n            String found = matcher.group(0);\n            String replacement = computeReplacement(found);\n            line = matcher.replaceFirst(replacement);\n            matcher.reset(line);\n        }\n        System.out.println(\"Final: \" + line);\n    }\n\n    static String computeReplacement(String in) {\n        switch(in) {\n        case \"cat\": return \"feline\";\n        case \"dog\": return \"canine\";\n        default: return \"animal\";\n        }\n    }\n}\n```", "```java\npublic class ReplaceDemo2 {\n    public static void main(String[] argv) {\n\n        // Make an RE pattern\n        String patt = \"(\\\\w+)\\\\s+(\\\\w+)\";\n\n        // A test input\n        String input = \"Ian Darwin\";\n        System.out.println(\"Input: \" + input);\n\n        // Run it from a RE instance and see that it works\n        Pattern r = Pattern.compile(patt);\n        Matcher m = r.matcher(input);\n        m.find();\n        System.out.println(\"Replaced: \" + m.replaceFirst(\"$2, $1\"));\n\n        // The short inline version:\n        // System.out.println(input.replaceFirst(\"(\\\\w+)\\\\s+(\\\\w+)\", \"$2, $1\"));\n    }\n}\n```", "```java\nC:\\> java ReaderIter.java ReaderIter.java\nimport\njava\nutil\nregex\nimport\njava\nio\nPrint\nall\nthe\nstrings\nthat\nmatch\ngiven\npattern\nfrom\nfile\npublic\n...\nC:\\\\>\n```", "```java\npublic class ReaderIter {\n    public static void main(String[] args) throws IOException {\n        // The RE pattern\n        Pattern patt = Pattern.compile(\"[A-Za-z][a-z]+\");\n        // See the I/O chapter\n        // For each line of input, try matching in it.\n        Files.lines(Path.of(args[0])).forEach(line -> {\n            // For each match in the line, extract and print it.\n            Matcher m = patt.matcher(line);\n            while (m.find()) {\n                // Simplest method:\n                // System.out.println(m.group(0));\n\n                // Get the starting position of the text\n                int start = m.start(0);\n                // Get ending position\n                int end = m.end(0);\n                // Print whatever matched.\n                // Use CharacterIterator.substring(offset, end);\n                System.out.println(line.substring(start, end));\n            }\n        });\n    }\n}\n```", "```java\npublic class GrepNIO {\n    public static void main(String[] args) throws IOException {\n\n        if (args.length < 2) {\n            System.err.println(\"Usage: GrepNIO patt file [...]\");\n            System.exit(1);\n        }\n\n        Pattern p=Pattern.compile(args[0]);\n        for (int i=1; i<args.length; i++)\n            process(p, args[i]);\n    }\n\n    static void process(Pattern pattern, String fileName) throws IOException {\n\n        // Get a FileChannel from the given file\n        FileInputStream fis = new FileInputStream(fileName);\n        FileChannel fc = fis.getChannel();\n\n        // Map the file's content\n        ByteBuffer buf = fc.map(FileChannel.MapMode.READ_ONLY, 0, fc.size());\n\n        // Decode ByteBuffer into CharBuffer\n        CharBuffer cbuf =\n            Charset.forName(\"ISO-8859-1\").newDecoder().decode(buf);\n\n        Matcher m = pattern.matcher(cbuf);\n        while (m.find()) {\n            System.out.println(m.group(0));\n        }\n        fis.close();\n    }\n}\n```", "```java\njava regex.GrepNIO \"[A-Za-z][a-z]+\"  ReaderIter.java\n```", "```java\ngrep \"[dD]arwin\" *.txt \n```", "```java\npublic class Grep0 {\n    public static void main(String[] args) throws IOException {\n        BufferedReader is =\n            new BufferedReader(new InputStreamReader(System.in));\n        if (args.length != 1) {\n            System.err.println(\"Usage: MatchLines pattern\");\n            System.exit(1);\n        }\n        Pattern patt = Pattern.compile(args[0]);\n        Matcher matcher = patt.matcher(\"\");\n        String line = null;\n        while ((line = is.readLine()) != null) {\n            matcher.reset(line);\n            if (matcher.find()) {\n                System.out.println(\"MATCH: \" + line);\n            }\n        }\n    }\n}\n```", "```java\n// regex/CaseMatch.java\nPattern  reCaseInsens = Pattern.compile(pattern, Pattern.CASE_INSENSITIVE |\n    Pattern.UNICODE_CASE);\nreCaseInsens.matches(input);        // will match case-insensitively\n```", "```java\npublic class CanonEqDemo {\n    public static void main(String[] args) {\n        String pattStr = \"\\u00e9gal\"; // egal\n        String[] input = {\n                \"\\u00e9gal\", // egal - this one had better match :-)\n                \"e\\u0301gal\", // e + \"Combining acute accent\"\n                \"e\\u02cagal\", // e + \"modifier letter acute accent\"\n                \"e'gal\", // e + single quote\n                \"e\\u00b4gal\", // e + Latin-1 \"acute\"\n        };\n        Pattern pattern = Pattern.compile(pattStr, Pattern.CANON_EQ);\n        for (int i = 0; i < input.length; i++) {\n            if (pattern.matcher(input[i]).matches()) {\n                System.out.println(\n                    pattStr + \" matches input \" + input[i]);\n            } else {\n                System.out.println(\n                    pattStr + \" does not match input \" + input[i]);\n            }\n        }\n    }\n}\n```", "```java\négal matches input égal\négal matches input e?gal\négal does not match input e?gal\négal does not match input e'gal\négal does not match input e´gal\n```", "```java\npublic class NLMatch {\n    public static void main(String[] argv) {\n\n        String input = \"I dream of engines\\nmore engines, all day long\";\n        System.out.println(\"INPUT: \" + input);\n        System.out.println();\n\n        String[] patt = {\n            \"engines.more engines\",\n            \"ines\\nmore\",\n            \"engines$\"\n        };\n\n        for (int i = 0; i < patt.length; i++) {\n            System.out.println(\"PATTERN \" + patt[i]);\n\n            boolean found;\n            Pattern p1l = Pattern.compile(patt[i]);\n            found = p1l.matcher(input).find();\n            System.out.println(\"DEFAULT match \" + found);\n\n            Pattern pml = Pattern.compile(patt[i],\n                Pattern.DOTALL|Pattern.MULTILINE);\n            found = pml.matcher(input).find();\n            System.out.println(\"MultiLine match \" + found);\n            System.out.println();\n        }\n    }\n}\n```", "```java\n> java regex.NLMatch\nINPUT: I dream of engines\nmore engines, all day long\n\nPATTERN engines\nmore engines\nDEFAULT match true\nMULTILINE match: true\n\nPATTERN engines$\nDEFAULT match false\nMULTILINE match: true\n```", "```java\n123.45.67.89 - - [27/Oct/2000:09:27:09 -0400] \"GET /java/javaResources.html\nHTTP/1.0\" 200 10450 \"-\" \"Mozilla/4.6 [en] (X11; U; OpenBSD 2.8 i386; Nav)\"\n```", "```java\n\\^([\\d.]+) (\\S+) (\\S+) \\[([\\w:/]+\\s[+\\-]\\d{4})\\] \"(.+?)\" (\\d{3}) (\\d+)\n  \"([\\^\"]+)\" \"([\\^\"]+)\"\n```", "```java\npublic class LogRegExp {\n\n    final static String logEntryPattern =\n            \"^([\\\\d.]+) (\\\\S+) (\\\\S+) \\\\[([\\\\w:/]+\\\\s[+-]\\\\d{4})\\\\] \" +\n            \"\\\"(.+?)\\\" (\\\\d{3}) (\\\\d+) \\\"([^\\\"]+)\\\" \\\"([^\\\"]+)\\\"\";\n\n    public static void main(String argv[]) {\n\n        System.out.println(\"RE Pattern:\");\n        System.out.println(logEntryPattern);\n\n        System.out.println(\"Input line is:\");\n        String logEntryLine = LogParseInfo.LOG_ENTRY_LINE;\n        System.out.println(logEntryLine);\n\n        Pattern p = Pattern.compile(logEntryPattern);\n        Matcher matcher = p.matcher(logEntryLine);\n        if (!matcher.matches() ||\n            LogParseInfo.MIN_FIELDS > matcher.groupCount()) {\n            System.err.println(\"Bad log entry (or problem with regex):\");\n            System.err.println(logEntryLine);\n            return;\n        }\n        System.out.println(\"IP Address: \" + matcher.group(1));\n        System.out.println(\"UserName: \" + matcher.group(3));\n        System.out.println(\"Date/Time: \" + matcher.group(4));\n        System.out.println(\"Request: \" + matcher.group(5));\n        System.out.println(\"Response: \" + matcher.group(6));\n        System.out.println(\"Bytes Sent: \" + matcher.group(7));\n        if (!matcher.group(8).equals(\"-\"))\n            System.out.println(\"Referer: \" + matcher.group(8));\n        System.out.println(\"User-Agent: \" + matcher.group(9));\n    }\n}\n```", "```java\nUsing regex Pattern:\n\\^([\\d.]+) (\\S+) (\\S+) \\[([\\w:/]+\\s[+\\-]\\d{4})\\] \"(.+?)\" (\\d{3}) (\\d+) \"([\\^\"]+)\"\n\"([\\^\"]+)\"\nInput line is:\n123.45.67.89 - - [27/Oct/2000:09:27:09 -0400] \"GET /java/javaResources.html\nHTTP/1.0\" 200 10450 \"-\" \"Mozilla/4.6 [en] (X11; U; OpenBSD 2.8 i386; Nav)\"\nIP Address: 123.45.67.89\nDate&Time: 27/Oct/2000:09:27:09 -0400\nRequest: GET /java/javaResources.html HTTP/1.0\nResponse: 200\nBytes Sent: 10450\nBrowser: Mozilla/4.6 [en] (X11; U; OpenBSD 2.8 i386; Nav)\n```", "```java\n/** A command-line grep-like program. Accepts some command-line options,\n * and takes a pattern and a list of text files.\n * N.B. The current implementation of GetOpt does not allow combining short\n * arguments, so put spaces e.g., \"JGrep -l -r -i pattern file...\" is OK, but\n * \"JGrep -lri pattern file...\" will fail. Getopt will hopefully be fixed soon.\n */\npublic class JGrep {\n    private static final String USAGE =\n        \"Usage: JGrep pattern [-chilrsnv][-f pattfile][filename...]\";\n    /** The pattern we're looking for */\n    protected Pattern pattern;\n    /** The matcher for this pattern */\n    protected Matcher matcher;\n    private boolean debug;\n    /** Are we to only count lines, instead of printing? */\n    protected static boolean countOnly = false;\n    /** Are we to ignore case? */\n    protected static boolean ignoreCase = false;\n    /** Are we to suppress printing of filenames? */\n    protected static boolean dontPrintFileName = false;\n    /** Are we to only list names of files that match? */\n    protected static boolean listOnly = false;\n    /** Are we to print line numbers? */\n    protected static boolean numbered = false;\n    /** Are we to be silent about errors? */\n    protected static boolean silent = false;\n    /** Are we to print only lines that DONT match? */\n    protected static boolean inVert = false;\n    /** Are we to process arguments recursively if directories? */\n    protected static boolean recursive = false;\n\n    /** Construct a Grep object for the pattern, and run it\n * on all input files listed in args.\n * Be aware that a few of the command-line options are not\n * acted upon in this version - left as an exercise for the reader!\n * @param args args\n */\n    public static void main(String[] args) {\n\n        if (args.length < 1) {\n            System.err.println(USAGE);\n            System.exit(1);\n        }\n        String patt = null;\n\n        GetOpt go = new GetOpt(\"cf:hilnrRsv\");\n\n        char c;\n        while ((c = go.getopt(args)) != 0) {\n            switch(c) {\n                case 'c':\n                    countOnly = true;\n                    break;\n                case 'f':    /* External file contains the pattern */\n                    try (BufferedReader b =\n                        new BufferedReader(new FileReader(go.optarg()))) {\n                        patt = b.readLine();\n                    } catch (IOException e) {\n                        System.err.println(\n                            \"Can't read pattern file \" + go.optarg());\n                        System.exit(1);\n                    }\n                    break;\n                case 'h':\n                    dontPrintFileName = true;\n                    break;\n                case 'i':\n                    ignoreCase = true;\n                    break;\n                case 'l':\n                    listOnly = true;\n                    break;\n                case 'n':\n                    numbered = true;\n                    break;\n                case 'r':\n                case 'R':\n                    recursive = true;\n                    break;\n                case 's':\n                    silent = true;\n                    break;\n                case 'v':\n                    inVert = true;\n                    break;\n                case '?':\n                    System.err.println(\"Getopts was not happy!\");\n                    System.err.println(USAGE);\n                    break;\n            }\n        }\n\n        int ix = go.getOptInd();\n\n        if (patt == null)\n            patt = args[ix++];\n\n        JGrep prog = null;\n        try {\n            prog = new JGrep(patt);\n        } catch (PatternSyntaxException ex) {\n            System.err.println(\"RE Syntax error in \" + patt);\n            return;\n        }\n\n        if (args.length == ix) {\n            dontPrintFileName = true; // Don't print filenames if stdin\n            if (recursive) {\n                System.err.println(\"Warning: recursive search of stdin!\");\n            }\n            prog.process(new InputStreamReader(System.in), null);\n        } else {\n            if (!dontPrintFileName)\n                dontPrintFileName = ix == args.length - 1; // Nor if only one file\n            if (recursive)\n                dontPrintFileName = false;                // unless a directory!\n\n            for (int i=ix; i<args.length; i++) { // note starting index\n                try {\n                    prog.process(new File(args[i]));\n                } catch(Exception e) {\n                    System.err.println(e);\n                }\n            }\n        }\n    }\n\n    /**\n * Construct a JGrep object.\n * @param patt The regex to look for\n * @throws PatternSyntaxException if pattern is not a valid regex\n */\n    public JGrep(String patt) throws PatternSyntaxException {\n        if (debug) {\n            System.err.printf(\"JGrep.JGrep(%s)%n\", patt);\n        }\n        // compile the regular expression\n        int caseMode = ignoreCase ?\n            Pattern.UNICODE_CASE | Pattern.CASE_INSENSITIVE :\n            0;\n        pattern = Pattern.compile(patt, caseMode);\n        matcher = pattern.matcher(\"\");\n    }\n\n    /** Process one command line argument (file or directory)\n * @param file The input File\n * @throws FileNotFoundException If the file doesn't exist\n */\n    public void process(File file) throws FileNotFoundException {\n        if (!file.exists() || !file.canRead()) {\n            throw new FileNotFoundException(\n                \"Can't read file \" + file.getAbsolutePath());\n        }\n        if (file.isFile()) {\n            process(new BufferedReader(new FileReader(file)),\n                file.getAbsolutePath());\n            return;\n        }\n        if (file.isDirectory()) {\n            if (!recursive) {\n                System.err.println(\n                    \"ERROR: -r not specified but directory given \" +\n                    file.getAbsolutePath());\n                return;\n            }\n            for (File nf : file.listFiles()) {\n                process(nf);    // \"Recursion, n.: See Recursion.\"\n            }\n            return;\n        }\n        System.err.println(\n            \"WEIRDNESS: neither file nor directory: \" + file.getAbsolutePath());\n    }\n\n    /** Do the work of scanning one file\n * @param    ifile    Reader    Reader object already open\n * @param    fileName String    Name of the input file\n */\n    public void process(Reader ifile, String fileName) {\n\n        String inputLine;\n        int matches = 0;\n\n        try (BufferedReader reader = new BufferedReader(ifile)) {\n\n            while ((inputLine = reader.readLine()) != null) {\n                matcher.reset(inputLine);\n                if (matcher.find()) {\n                    if (listOnly) {\n                        // -l, print filename on first match, and we're done\n                        System.out.println(fileName);\n                        return;\n                    }\n                    if (countOnly) {\n                        matches++;\n                    } else {\n                        if (!dontPrintFileName) {\n                            System.out.print(fileName + \": \");\n                        }\n                        System.out.println(inputLine);\n                    }\n                } else if (inVert) {\n                    System.out.println(inputLine);\n                }\n            }\n            if (countOnly)\n                System.out.println(matches + \" matches in \" + fileName);\n        } catch (IOException e) {\n            System.err.println(e);\n        }\n    }\n}\n```"]