- en: Chapter 10\. Integrating with Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, you’ve been learning how to develop and run Quarkus applications on
    bare-metal, but where Quarkus really shines is when it is running in a Kubernetes
    cluster.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll learn about the integration between Quarkus and Kubernetes,
    and how several extensions can help develop and deploy a Quarkus service for Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes is becoming the de facto platform to deploy applications; for this
    reason it is important to have a good understanding of Kubernetes and how to correctly
    develop and deploy applications on it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you’ll learn how to accomplish the following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Build and push container images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generate Kubernetes resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploy a Quarkus service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Develop a Kubernetes operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploy a service in Knative
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 10.1 Building and Pushing Container Images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to build and push container images.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The working unit in Kubernetes is a *pod*. A pod represents a group of containers
    that are running in the same host machine and share resources like IP and ports.
    To deploy a service to Kubernetes, you need to create a pod. Since a pod is composed
    by one or more containers, you need to build a container image of your service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Quarkus provides extensions for building and optionally pushing container images.
    At the time of writing, the following container build strategies are supported:'
  prefs: []
  type: TYPE_NORMAL
- en: Jib
  prefs: []
  type: TYPE_NORMAL
- en: Jib builds Docker and OCI container images for your Java applications without
    a Docker daemon (Dockerless). This makes it perfect for building Docker images
    when running the process inside a container because you avoid the hassle of the
    Docker-in-Docker (DinD) process. Further, using Jib with Quarkus caches all dependencies
    in a different layer than the actual application, making rebuilds fast and small.
    This improves push times as well as build times.
  prefs: []
  type: TYPE_NORMAL
- en: Docker
  prefs: []
  type: TYPE_NORMAL
- en: Using the Docker strategy builds container images using the `docker` binary,
    which is installed locally and by default uses `Dockerfiles` located under *src/main/docker*
    to build the images.
  prefs: []
  type: TYPE_NORMAL
- en: S2I
  prefs: []
  type: TYPE_NORMAL
- en: The Source-to-Image (S2I) strategy uses `s2i` binary builds to perform container
    builds inside an OpenShift cluster. S2I builds require creating a `BuildConfig`
    and two `ImageStream` resources. The creation of these resources is leveraged
    by the Quarkus Kubernetes extension.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we’re going to build and push the container using Jib; the “Discussion”
    section of this recipe will address Docker and S2I.
  prefs: []
  type: TYPE_NORMAL
- en: 'To build and push a container image using Jib, first you need to add the Jib
    extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then you can customize the container image build process. You can set these
    properties in the *application.properties*, system properties, or environment
    variables, just as any other configuration parameter in Quarkus:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_integrating_with_kubernetes_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets the group part of the image; by default this is `${user.name}`
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_integrating_with_kubernetes_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Registry where to push the image; by default, images are pushed to `docker.io`
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_integrating_with_kubernetes_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The username to log into the container registry
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_integrating_with_kubernetes_CO1-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The password to log into the container registry
  prefs: []
  type: TYPE_NORMAL
- en: 'To build and push the container image for the project, you need to set the
    `quarkus.container-image.push` parameter to `true`, and during the `package` stage,
    the container is created and pushed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_integrating_with_kubernetes_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The container image is built
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_integrating_with_kubernetes_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The container image is pushed to quay.io
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Apart from Jib, there are two other options available to build a container
    image; to use them you simply need to register the extension:'
  prefs: []
  type: TYPE_NORMAL
- en: Docker
  prefs: []
  type: TYPE_NORMAL
- en: '`quarkus-container-image-docker`'
  prefs: []
  type: TYPE_NORMAL
- en: S2I
  prefs: []
  type: TYPE_NORMAL
- en: '`quarkus-container-image-s2i`'
  prefs: []
  type: TYPE_NORMAL
- en: Each of the extensions provides specific configuration parameters to change
    the build process. These parameters let you change the base images used for building
    the container image and let you set environment variables, the arguments to pass
    to the executable, or the location of the Dockerfiles.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also build the image but not push it to a registry. To do this, you
    need to set the `quarkus.container-image.build` property to `true` and not set
    the `quarkus.container-image.push` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Important
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If `Jib` is used and `push` is set to `false`, the extension creates a container
    image and registers it with the Docker daemon. This means that although Docker
    isn’t used to build the image, it is still necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'The container image extensions can create a container from a JAR package (for
    use in JVM mode) and from a native executable, depending on what is found in the
    *build/output* directory. If you want to create a native executable that can be
    run from a Linux container and then create a container image with the resulting
    native executable inside, you can run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Setting the `quarkus.native.container-build` property to `true` creates the
    native executable inside a Docker container.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For more information, visit the following pages on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Google Container Tools: Jib](https://oreil.ly/6vrh5)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Source-To-Image](https://oreil.ly/8PEgn)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 10.2 Generating Kubernetes Resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to generate Kubernetes resources automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Quarkus has a Kubernetes extension that is able to generate Kubernetes resources
    automatically with sane defaults and optional user-supplied configuration. Currently,
    the extension can produce resources for Kubernetes and OpenShift.
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable the generation of Kubernetes resources, you need to register the
    `quarkus-kubernetes` extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To generate the Kubernetes resources, execute in a new terminal `./mvnw package`.
    Then among the usual files generated by the build tool in the `target` directory,
    two new files are created inside the *target/kubernetes* directory. These new
    files are named *kubernetes.json* and *kubernetes.yaml*, and they each contain
    the definition of both a `Deployment` and a `Service`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_integrating_with_kubernetes_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Defaults to project name
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_integrating_with_kubernetes_CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Defaults to version field
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_integrating_with_kubernetes_CO3-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Defaults to OS username
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can customize the group and the name used in the generated manifest by
    adding these properties to *application.properties*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The Kubernetes extension allows user customizations to be supplied to different
    parts of the manifest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_integrating_with_kubernetes_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets the number of replicas
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_integrating_with_kubernetes_CO4-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Adds the Docker registry to pull images
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_integrating_with_kubernetes_CO4-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Adds new labels
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_integrating_with_kubernetes_CO4-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets readiness probe
  prefs: []
  type: TYPE_NORMAL
- en: You can generate different resources by setting the property as `quarkus.kubernetes.deployment-target`
    in the *application.properties* file or as a system property.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default value of this property is `kubernetes`, but the following values
    are also supported at the time of writing: `kubernetes`, `openshift`, and `knative`.'
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following web page provides a list of all Kubernetes configuration options
    to modify the generated file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Quarkus: Kubernetes Extension](https://oreil.ly/oLxhT)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 10.3 Generating Kubernetes Resources with Health Checks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to automatically generate Kubernetes resources with liveness and readiness
    probes.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By default, health probes are not generated in the output file, but if the
    `quarkus-smallrye-health` extension is present (as explained in [Recipe 9.1](ch09.xhtml#using-automatic-health-checks)),
    then readiness and liveness probe sections are generated automatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_integrating_with_kubernetes_CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Defines the liveness probe
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_integrating_with_kubernetes_CO5-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The path is the one defined by MicroProfile Health spec
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_integrating_with_kubernetes_CO5-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Defines the readiness probe
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_integrating_with_kubernetes_CO5-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The path is the one defined by MicroProfile Health spec
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Kubernetes uses probes to determine the health state of a service and take automatic
    actions to solve any problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Quarkus automatically generates two Kubernetes probes:'
  prefs: []
  type: TYPE_NORMAL
- en: Liveness
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes uses a liveness probe to decide if a service must be restarted. If
    the application becomes unresponsive, perhaps because of a deadlock or memory
    problem, restarting the container might be a good solution to fix the problem.
  prefs: []
  type: TYPE_NORMAL
- en: Readiness
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes uses a readiness probe to decide if a service is available for accepting
    traffic. Sometimes a service might need to execute some operations before accepting
    requests. Examples include updating local caching system, populating a change
    to the database schema, applying a batch process, or connecting to an external
    service like Kafka Streams.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For more information, see the following website:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Kubernetes: Configure Liveness, Readiness, and Startup Probes](https://oreil.ly/PWl_B)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 10.4 Deploying Services on Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to deploy services on Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use `kubectl` and all the features offered by Quarkus to create and deploy a
    service on Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Quarkus makes it really easy to create and deploy a Java application into Kubernetes
    by doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Generating a container native executable of your enterprise application, as
    explained in [Recipe 6.6](ch06.xhtml#building-a-docker-container-native-file)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Providing a *Dockerfile.native* file to build the Docker container
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generating a Kubernetes resources file by using `quarkus-kubernetes` extension,
    as explained in [Recipe 10.2](#generate-kubernetes-resources)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is time to see all these steps working together.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a native executable that can be run within a container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_integrating_with_kubernetes_CO6-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Creates the native executable inside a Docker container
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_integrating_with_kubernetes_CO6-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Creates a Docker image with the native executable generated previously
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_integrating_with_kubernetes_CO6-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Pushes image to the Docker registry (in minikube, this is `eval $(minikube docker-env)`,
    so no push.)
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_integrating_with_kubernetes_CO6-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Deploys the application to Kubernetes
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](Images/5.png)](#co_integrating_with_kubernetes_CO6-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Changes to `NodePort`
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](Images/6.png)](#co_integrating_with_kubernetes_CO6-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Gets the URL to access the service
  prefs: []
  type: TYPE_NORMAL
- en: Notice that steps 5 and 6 are required only because the service is deployed
    in minikube. Depending on the Kubernetes platform you are using to deploy the
    service to, you might need to do different things.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Steps 1 and 2 could be simplified into one if you use the multi-stage Docker
    build feature. In the first stage, the native executable is generated, and the
    second stage creates the runtime image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_integrating_with_kubernetes_CO7-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Generates the native executable
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_integrating_with_kubernetes_CO7-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Creates the runtime image from the output of the previous stage
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the *.dockerignore* file from the root directory of the project (`rm
    .dockerignore`). This is necessary because, by default, the *src* directory is
    ignored, and to build the native executable, the *src* directory is required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_integrating_with_kubernetes_CO8-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Creates the runtime image with native executable bundled
  prefs: []
  type: TYPE_NORMAL
- en: 10.5 Deploying Services on OpenShift
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to deploy services on OpenShift.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: OpenShift works perfectly with the resources generated in the previous recipe,
    so even though you are using OpenShift, you can still use everything provided
    previously. But if you want to use some of the capabilities offered by OpenShift,
    you can set the `kubernetes.deployment.target` property to `openshift`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The two generated files are placed at *target/kubernetes/openshift.json* and
    *target/kubernetes/openshift.yaml*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 10.6 Building and Deploying a Container Image Automatically
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to build, push, and deploy container images automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Quarkus provides extensions for building and pushing container images with the
    `container-image` extensions and for deploying to Kubernetes using the `kubernetes`
    extension.
  prefs: []
  type: TYPE_NORMAL
- en: 'To build, push, and deploy a container image, you need to first add the required
    extensions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Then you can customize the container image build process. You can set these
    properties in the *application.properties*, system properties, or environment
    variables as any other configuration parameter in Quarkus:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_integrating_with_kubernetes_CO9-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets the group part of the image; by default this is `${user.name}`
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_integrating_with_kubernetes_CO9-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Registry where to push the image; by default, images are pushed to `docker.io`
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_integrating_with_kubernetes_CO9-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The username to log into the container registry
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_integrating_with_kubernetes_CO9-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The password to log into the container registry
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, deploy to Kubernetes using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Notice that setting `quarkus.kubernetes.deploy` to `true` implicitly sets the
    `quarkus.container-image.push` property to `true`, so you do not need to set it
    manually.
  prefs: []
  type: TYPE_NORMAL
- en: The Kubernetes extension uses the standard `kubectl` configuration file located
    at *~/.kube/config* to know where to deploy the application.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can also use `-Pnative -Dquarkus.native.container-build=true` flags to create
    and deploy a container image with native compilation.
  prefs: []
  type: TYPE_NORMAL
- en: 10.7 Configuring an Application from Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to configure your application through (or via) Kubernetes instead of
    the configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use `ConfigMaps` to configure the applications running inside a pod.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, you are going to configure a service using a `ConfigMap` and
    Kubernetes extension. To enable the generation of Kubernetes resources with the
    `ConfigMap` injection in the `Pod`, you need to register the `quarkus-kubernetes`
    extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The service returns the `greeting.message` configuration value when the `/hello`
    endpoint is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `ConfigMap` resource with the key-value pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_integrating_with_kubernetes_CO10-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Defines the `ConfigMap` type
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_integrating_with_kubernetes_CO10-2)'
  prefs: []
  type: TYPE_NORMAL
- en: For the key `greeting` defines the value `Kubernetes`
  prefs: []
  type: TYPE_NORMAL
- en: 'Then the resource must be applied to the Kubernetes cluster by running the
    next command in a terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, set the Kubernetes extension properties in the *application.properties*
    so that the generated Kubernetes deployment file contains the segments to inject
    the config map as an environment variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_integrating_with_kubernetes_CO11-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Configures Docker image
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_integrating_with_kubernetes_CO11-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets the environment variable to override the `greeting.message` property
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_integrating_with_kubernetes_CO11-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets the config map resource name to load
  prefs: []
  type: TYPE_NORMAL
- en: The generation of the Kubernetes file will contain a new entry defining the
    key-value pairs in the container definition called `configMapKeyRef`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To deploy the application, open a new terminal window, package the application,
    create the Docker container, and apply the generated Kubernetes resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`ConfigMap` consists of key-value pairs that Kubernetes injects into pods’
    containers in the form of files or environment variables so the application can
    read them and configure accordingly. With `ConfigMaps`, you can decouple the configuration
    of the application from the business logic, making it portable across environments.'
  prefs: []
  type: TYPE_NORMAL
- en: Important
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`ConfigMaps` are meant to be used for storing and sharing non-sensitive configuration
    properties.'
  prefs: []
  type: TYPE_NORMAL
- en: The MicroProfile Config spec permits the override of any configuration property
    using the equivalent environment variable (in uppercase and changing dots [`.`]
    to underscores [`_`]). The `ConfigMap` contains the configuration properties.
    In *application.properties*, the Kubernetes extension is configured to generate
    a deployment descriptor that sets these properties as environment variables so
    that when the container is started inside the Kubernetes cluster, the specific
    configuration applied to this cluster is used.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To learn more about `ConfigMaps` in Kubernetes, visit the following website:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Kubernetes: Configure a Pod to Use a ConfigMap](https://oreil.ly/BPmo5)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 10.8 Configuring an Application from Kubernetes with Config Extension
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to configure your application through (or via) Kubernetes instead of
    the configuration file using the MicroProfile Config specification.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Quarkus has a Kubernetes Configuration extension that can read the secrets and
    config maps elements from the Kubernetes API Server and inject them using `@ConfigProperty`
    annotation.
  prefs: []
  type: TYPE_NORMAL
- en: To enable the generation of Kubernetes resources, you need to register the `quarkus-kubernetes-config`
    extension.
  prefs: []
  type: TYPE_NORMAL
- en: The extension supports injecting `ConfigMaps`, either as a single key/value
    form or in the form in which the key is a filename (where only `application.properties`
    or `application.yaml` is supported) and the value is the content of that file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a config map with a single key/value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_integrating_with_kubernetes_CO12-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Config name is important for the extension
  prefs: []
  type: TYPE_NORMAL
- en: 'Then register the previous `ConfigMap` resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: For this example, an *application.properties* file as `ConfigMap` is also registered.
  prefs: []
  type: TYPE_NORMAL
- en: 'The configuration file added contains the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Then register the previous file in a `ConfigMap` named `my-file-config`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The last step before you can inject these values is to configure the extension
    to read values from these `ConfigMaps`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_integrating_with_kubernetes_CO13-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Enables the extension
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_integrating_with_kubernetes_CO13-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets the `ConfigMap` names
  prefs: []
  type: TYPE_NORMAL
- en: 'These configuration values are injected like any other configuration value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_integrating_with_kubernetes_CO14-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Simple key is injected
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_integrating_with_kubernetes_CO14-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Keys from the *application.properties* file are injected too
  prefs: []
  type: TYPE_NORMAL
- en: 'To deploy the application, open a new terminal window, package the application,
    create the Docker container, and apply the generated Kubernetes resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 10.9 Interacting with a Kubernetes Cluster Programmatically
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to interact with a Kubernetes API server programmatically.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the `kubernetes-client` extension to start watching and reacting to changes
    on Kubernetes resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add the `kubernetes-extension`, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The main class to connect to the Kubernetes cluster is `io.fabric8.kubernetes.client.KubernetesClient`.
    The extension produces this instance so it can be injected in the code. The client
    can be configured using various properties, setting them in *application.properties*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The example developed here is an endpoint that returns the name of all deployed
    pods on the given namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_integrating_with_kubernetes_CO15-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The `KubernetesClient` is injected like any other CDI bean
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_integrating_with_kubernetes_CO15-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Select all pods
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_integrating_with_kubernetes_CO15-3)'
  prefs: []
  type: TYPE_NORMAL
- en: From given namespace
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_integrating_with_kubernetes_CO15-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Gets only the generated name of the pod
  prefs: []
  type: TYPE_NORMAL
- en: The recommended way to access the REST API of Kubernetes is by using `kubectl`
    in proxy mode because no man-in-the-middle attack is possible.
  prefs: []
  type: TYPE_NORMAL
- en: The other way is by providing the location and the credentials directly, but
    to avoid man-in-the-middle attacks you might need to import the root certificate.
  prefs: []
  type: TYPE_NORMAL
- en: Because the proxy mode is the recommended way, this is the method used for this
    example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pointing `kubectl` to the cluster that the application must connect with, open
    a new terminal window and run the next command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This command runs `kubectl` as a reverse proxy, exposing the remote Kubernetes
    API server at [*http://localhost:8090*](http://localhost:8090).
  prefs: []
  type: TYPE_NORMAL
- en: 'Configure `KubernetesClient` to connect to [*http://localhost:8090*](http://localhost:8090)
    by using the `quarkus.kubernetes-client.master-url` property in *application.properties*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_integrating_with_kubernetes_CO16-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets the URL of the Kubernetes API server
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, run the service and make a request to the `/pod/default` endpoint
    to get all the pods deployed in the default namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In some circumstances, you need to create new Kubernetes resources programmatically
    or get some information about Kubernetes clusters/resources (what pods are deployed,
    configuration parameters, set secrets, and so on). Where `kubernetes-client` really
    shines is in implementing a *Kubernetes Operator* in Java. Thanks to the capabilities
    of Quarkus to generate a native executable, this is a great way to implement Kubernetes
    Operators in Java.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the service was deployed outside the Kubernetes cluster, and
    you connect to it using the Kubernetes API server.
  prefs: []
  type: TYPE_NORMAL
- en: If the service was deployed into the Kubernetes cluster that needs to be accessed,
    then the `quarkus.kubernetes-client.master-url` property must be set to `https://kubernetes.default.svc`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The creation of `KubernetesClient` can be overridden by simply declaring a
    CDI provider factory method returning the configured instance of `KubernetesClient`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_integrating_with_kubernetes_CO17-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Configures the client
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_integrating_with_kubernetes_CO17-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Creates an instance of `KubernetesClient`
  prefs: []
  type: TYPE_NORMAL
- en: 'In most cases, to access the Kubernetes API server, a `ServiceAccount`, `Role`,
    and `RoleBinding` are necessary. The following might be a starting point to work
    the example provided in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To learn more about Fabric8 Kubernetes Client, visit the following page on
    GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Kubernetes & OpenShift Java Client](https://oreil.ly/_QNSL)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 10.10 Testing Kubernetes Client Interactions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to test Kubernetes Client code.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Quarkus implements a Quarkus Test Resource that launches a mock of the Kubernetes
    API server and sets the correct configuration to make the Kubernetes Client use
    the mock server instance instead of the value provided in *application.properties*.
    Moreover, you can set up the mock server to respond to any canned request required
    for any particular test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_integrating_with_kubernetes_CO18-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets Kubernetes Test Resource mock server
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_integrating_with_kubernetes_CO18-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Injects Kubernetes mock server instance to record any interaction
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_integrating_with_kubernetes_CO18-3)'
  prefs: []
  type: TYPE_NORMAL
- en: To maintain test isolation, before every test, the interaction is recorded again
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_integrating_with_kubernetes_CO18-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Builds the pod to be returned
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](Images/5.png)](#co_integrating_with_kubernetes_CO18-5)'
  prefs: []
  type: TYPE_NORMAL
- en: The pod is returned as a result of querying all pods from `test` namespace
  prefs: []
  type: TYPE_NORMAL
- en: 10.11 Implementing a Kubernetes Operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to implement a Kubernetes Operator to extend Kubernetes using custom
    resources to manage applications in Java.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the `kubernetes-client` extension and Quarkus to implement a Kubernetes
    operator in Java and compile it into a native executable.
  prefs: []
  type: TYPE_NORMAL
- en: One of the use cases for an operator is to create a template (*custom resource*)
    where some values are set in the creation time. The biggest difference between
    a file template and an operator is that the common content (in the case of a *template*)
    is static, whereas in an operator it is set programmatically, which means that
    you’ve got the freedom to change the definition of the common part dynamically.
    This is known as a *custom resource*, in which, instead of using a well-known
    Kubernetes resource, you implement your own custom Kubernetes resource with your
    own fields.
  prefs: []
  type: TYPE_NORMAL
- en: Another use case might be to react/operate when something happens inside the
    cluster. Suppose you’ve got some in-memory data grids deployed on the cluster,
    and one of these instances dies. Maybe in this case what you want is to notify
    all living instances that one of the elements of the data grid cluster has been
    stopped.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, it is about not only the creation of a resource but also applying
    some tasks that are specific to your application that need to be done atop one
    of the tasks that Kubernetes is already doing.
  prefs: []
  type: TYPE_NORMAL
- en: The Kubernetes Operator uses Kubernetes API to decide when and how to run some
    of these customizations.
  prefs: []
  type: TYPE_NORMAL
- en: The following simple example does not make a lot of sense from the point of
    view of the logic it implements, but it will help you understand the basics of
    writing a Kubernetes Operator. Use it as a starting point for implementing your
    own Kubernetes Operators.
  prefs: []
  type: TYPE_NORMAL
- en: 'To write a Kubernetes Operator, the following elements may be needed:'
  prefs: []
  type: TYPE_NORMAL
- en: Classes that parse custom resources.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Factory method that registers and generates a client to operate with custom
    resources.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A watcher that reacts when a custom resource is applied to the cluster. You
    can think of it as the operator controller or the operator implementation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Docker image with all previous code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: YAML/JSON file to define the custom resource (`CustomResourceDefinition`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deployment file to deploy the custom operator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s implement a simple Kubernetes Operator that configures the command to
    run in the container and instantiates the pod with this configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'The base image used for the example is [Whalesay](https://oreil.ly/98T7t),
    which basically prints in the container console the message you passed as argument
    in the `run` command, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'An example of a pod resource using this image could look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_integrating_with_kubernetes_CO19-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets the output message
  prefs: []
  type: TYPE_NORMAL
- en: The goal of this operator is that only the message to be printed must be provided.
    The rest of the content (e.g., Docker image, container configuration, etc.) is
    set by the Kubernetes Operator automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a custom operator, the Kubernetes Client and Jackson dependencies
    are required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing to do is define what the custom resource looks like. For this
    example, it looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_integrating_with_kubernetes_CO20-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Uses custom `kind` schema (defined later in this recipe)
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_integrating_with_kubernetes_CO20-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets the message to print
  prefs: []
  type: TYPE_NORMAL
- en: An object model is required to parse the custom resource. In this case, the
    Jackson library is used to map from YAML to Java Object. Three classes are required,
    one for the whole resource, another one for the `spec` section, and another one
    for the `status` section, which is empty but required because it might be filled
    automatically by the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create all of them at *src/main/java* inside package `org.acme.quickstart.cr`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_integrating_with_kubernetes_CO21-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets POJO as deserializable
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_integrating_with_kubernetes_CO21-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Inherits common custom resource fields like `kind`, `apiVersion`, or `metadata`
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_integrating_with_kubernetes_CO21-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Custom `spec` section
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_integrating_with_kubernetes_CO21-4)'
  prefs: []
  type: TYPE_NORMAL
- en: '`status` section'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `spec` section is mapped as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_integrating_with_kubernetes_CO22-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The custom spec contains only a `message` field
  prefs: []
  type: TYPE_NORMAL
- en: 'And the empty `status` section is mapped as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Still, two classes are required from the model point of view.
  prefs: []
  type: TYPE_NORMAL
- en: 'One class is used when, instead of applying a single custom resource (as shown
    previously) to the cluster, a list of the custom resources is provided (using
    the `items` array):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_integrating_with_kubernetes_CO23-1)'
  prefs: []
  type: TYPE_NORMAL
- en: '`CustomResourceList` inherits all fields required to support a list of custom
    resources'
  prefs: []
  type: TYPE_NORMAL
- en: 'The other class is used to make the custom resource editable from the operator
    implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_integrating_with_kubernetes_CO24-1)'
  prefs: []
  type: TYPE_NORMAL
- en: '`CustomResourceDoneable` class makes the resource editable'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next big thing that is required is a CDI factory bean that provides all
    the machinery required by the operator. Create this class at *src/main/java* inside
    package `org.acme.quickstart`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_integrating_with_kubernetes_CO25-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Gets the namespace where the operator is running
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_integrating_with_kubernetes_CO25-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Configures `KubernetesClient` with the current namespace; defaults fit for Kubernetes
    Operator development
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_integrating_with_kubernetes_CO25-3)'
  prefs: []
  type: TYPE_NORMAL
- en: '`MixedOperation` is used for watching events about the custom resource (e.g.,
    when a new custom resource is applied)'
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_integrating_with_kubernetes_CO25-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Registers the `apiVersion` and `Kind` to be parsed by `org.acme.quickstart.cr.HelloResource`
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](Images/5.png)](#co_integrating_with_kubernetes_CO25-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Gets the definition of the custom resource; because there is only one (i.e.,
    the one we are developing), `findFirst` can be used
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](Images/6.png)](#co_integrating_with_kubernetes_CO25-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Registers for the customer resource, the parser, the list parser, and the `doneable`
    class
  prefs: []
  type: TYPE_NORMAL
- en: The last Java class to implement is the controller. This controller (or watcher/operator)
    is responsible for inspecting what’s going on inside the cluster and reacting
    to the subscribed events—for example, a new pod has been created/destroyed or
    a custom resource of kind `Hello` has been applied.
  prefs: []
  type: TYPE_NORMAL
- en: In this implementation, the controller is watching when a new resource of kind
    `Hello` is added. When the custom resource is applied, then the message is retrieved
    from the model, and the pod definition is created using all the builders provided
    by the Kubernetes Client API. Finally, the pod is deployed into the Kubernetes
    cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create this class at *src/main/java* inside package `org.acme.quickstart`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_integrating_with_kubernetes_CO26-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Injects KubernetesClient
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_integrating_with_kubernetes_CO26-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Injects operations specific to the developed custom resource
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_integrating_with_kubernetes_CO26-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Executes logic when the application is started
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_integrating_with_kubernetes_CO26-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Watches for any operation that `HelloResource` is implied
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](Images/5.png)](#co_integrating_with_kubernetes_CO26-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Gets the information provided in the custom resource
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](Images/6.png)](#co_integrating_with_kubernetes_CO26-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Starts the creation of the pod definition programmatically
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](Images/7.png)](#co_integrating_with_kubernetes_CO26-7)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets the message provided by the custom resource
  prefs: []
  type: TYPE_NORMAL
- en: '[![8](Images/8.png)](#co_integrating_with_kubernetes_CO26-8)'
  prefs: []
  type: TYPE_NORMAL
- en: Builds the pod
  prefs: []
  type: TYPE_NORMAL
- en: '[![9](Images/9.png)](#co_integrating_with_kubernetes_CO26-9)'
  prefs: []
  type: TYPE_NORMAL
- en: Adds the pod to the cluster
  prefs: []
  type: TYPE_NORMAL
- en: '[![10](Images/10.png)](#co_integrating_with_kubernetes_CO26-10)'
  prefs: []
  type: TYPE_NORMAL
- en: If there is any critical error when closing, then stop the container
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On the Java side, this is all you need to do; however, there are still some
    remaining parts, such as packaging and containerizing the operator, or defining
    the custom operator inside the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing to take into consideration when developing a Kubernetes Operator
    is that the communication with the Kubernetes API server is done through HTTPS,
    and this means that crypto libraries must be provided in the Docker image if they
    are not provided by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the time of writing, the *Dockerfile.jvm* file provided by Quarkus does
    not contain the crypto libraries required to communicate to the Kubernetes server.
    To fix this, just open *src/main/docker/Dockerfile.jvm* and add the `nss` (Network
    Security Services) package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Then containerize the operator by running Maven and Docker:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Then register the custom resource definition into the Kubernetes cluster so
    that it is aware of the new kind, the scope of the custom resource, or the group
    name, among other things.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file at *src/main/kubernetes* with name *custom-resource-definition.yaml*
    that defines all the information required by the cluster to register a new resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_integrating_with_kubernetes_CO27-1)'
  prefs: []
  type: TYPE_NORMAL
- en: '`plural` plus `group`'
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_integrating_with_kubernetes_CO27-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets the group of the custom resource (used in the `apiVersion` field of the
    custom resource)
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_integrating_with_kubernetes_CO27-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Name of the `kind`
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_integrating_with_kubernetes_CO27-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Name when the kind is a list of this custom resource
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](Images/5.png)](#co_integrating_with_kubernetes_CO27-5)'
  prefs: []
  type: TYPE_NORMAL
- en: The plural name
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](Images/6.png)](#co_integrating_with_kubernetes_CO27-6)'
  prefs: []
  type: TYPE_NORMAL
- en: The singular name
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](Images/7.png)](#co_integrating_with_kubernetes_CO27-7)'
  prefs: []
  type: TYPE_NORMAL
- en: Scope of the resource
  prefs: []
  type: TYPE_NORMAL
- en: '[![8](Images/8.png)](#co_integrating_with_kubernetes_CO27-8)'
  prefs: []
  type: TYPE_NORMAL
- en: The version of the resource (used in the `apiVersion` field of the custom resource)
  prefs: []
  type: TYPE_NORMAL
- en: 'And the last thing to create is a deployment file that deploys the operator.
    Create a new file named *deploy.yaml* at *src/main/kubernetes*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_integrating_with_kubernetes_CO28-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Defines a cluster role for the role-based access control (RBAC) for Kubernetes
    resources
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_integrating_with_kubernetes_CO28-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Adds rights to get, list, watch, create, update, delete, and patch pods
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_integrating_with_kubernetes_CO28-3)'
  prefs: []
  type: TYPE_NORMAL
- en: For the custom resource (`hellos.acme.org`), the required operations are `list`
    and `watch`
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_integrating_with_kubernetes_CO28-4)'
  prefs: []
  type: TYPE_NORMAL
- en: An operator is deployed with a `Deployment`
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](Images/5.png)](#co_integrating_with_kubernetes_CO28-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets the service account linked to the cluster role defined in the file
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](Images/6.png)](#co_integrating_with_kubernetes_CO28-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets the container image containing the operator
  prefs: []
  type: TYPE_NORMAL
- en: 'The last step before having the operator up and running is to apply all these
    created resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The operator is now installed and running. To test the operator, just create
    a custom resource of kind `Hello` with the message to show:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_integrating_with_kubernetes_CO29-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Uses custom `kind` schema
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_integrating_with_kubernetes_CO29-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets the message to print
  prefs: []
  type: TYPE_NORMAL
- en: 'And apply it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'When it’s completed, check the pod logs to validate that the message has been
    printed on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Although an operator and a custom resource are usually related, an operator
    without a custom resource definition is still possible—for example, to create
    a watcher class to intercept any event that affects a pod and apply some logic.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To learn more about operators, check out the following websites:'
  prefs: []
  type: TYPE_NORMAL
- en: '[CoreOS: Operators](https://oreil.ly/NV2dN)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Kubernetes: Operator pattern](https://oreil.ly/6Z77K)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 10.12 Deploying and Managing Serverless Workloads with Knative
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to deploy and manage serverless workloads.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use Knative, the Kubernetes-based platform to deploy and manage modern serverless
    workloads.
  prefs: []
  type: TYPE_NORMAL
- en: The `quarkus-kubernetes` extension provides support for generating Knative resources
    automatically with sane defaults and optional user-supplied configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable the generation of Kubernetes resources, you need to register the
    `quarkus-kubernetes` extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: For this example, the `quarkus-container-image-docker` extension is used to
    build the container image using `docker` binary, so the image is built directly
    inside the `minikube` cluster and registered inside the internal registry, so
    no external registry is required.
  prefs: []
  type: TYPE_NORMAL
- en: You need to run `eval $(minikube docker-env)` to configure `docker` to use the
    minikube docker host.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then you need to set the `quarkus.kubernetes.deployment-target` property to
    `knative` and set it to build a Docker container during package phase, among other
    configuration properties regarding container image creation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_integrating_with_kubernetes_CO30-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets target deployment to `knative`
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_integrating_with_kubernetes_CO30-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Builds the container image with `lordofthejars` group
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_integrating_with_kubernetes_CO30-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets to `dev.local` when deploying local container images
  prefs: []
  type: TYPE_NORMAL
- en: The Knative controller resolves image tags to digests in order to guarantee
    the immutability of revisions. This works well when using a normal registry; however,
    it can cause problems when used with minikube and local images.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the Knative controller skips resolving digests with images prefixed
    with `dev.local` or `ko.local`. If you are running this example in minikube, you
    must set the registry property to any of these two options to make Knative find
    the images to deploy.
  prefs: []
  type: TYPE_NORMAL
- en: 'To generate the Kubernetes resources, execute in a new terminal `./mvnw package`.
    Then, among the usual files generated by the build tool in the *target* directory,
    two new files are created inside the *target/kubernetes* directory named *knative.json*
    and *knative.yaml* containing a Knative service definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Then deploy the generated Knative service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'It can take a few seconds to move the `ready` state from `Unknown` to `True`.
    If there is a failure, which means that `ready` state remains in `false`, you
    can check the reason and the sequence of events by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'To test that the service has been deployed correctly, open a new terminal window
    and do a port forward between the local machine and Knative gateway:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Notice that this is required only because the service is deployed in minikube.
    Depending on the Kubernetes platform on which you are deploying the service, you
    might need to do different things.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you can send a request to the service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'To undeploy the example, you need to run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can combine the `container-image` and `kubernetes` extensions to build the
    container image and push it to Kubernetes automatically, as shown in [Recipe 10.6](#build-deploy-container-image-automatically),
    so no manual steps are required.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To learn more, visit the following web pages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Knative Serving](https://oreil.ly/RBv52)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[GitHub: Kourier](https://oreil.ly/3bSDL)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
