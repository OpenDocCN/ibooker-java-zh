- en: Chapter 10\. Integrating with Kubernetes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第十章. 集成 Kubernetes
- en: So far, you’ve been learning how to develop and run Quarkus applications on
    bare-metal, but where Quarkus really shines is when it is running in a Kubernetes
    cluster.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您一直在学习如何在裸机上开发和运行 Quarkus 应用程序，但 Quarkus 真正发光的地方是在 Kubernetes 集群中运行时。
- en: In this chapter, you’ll learn about the integration between Quarkus and Kubernetes,
    and how several extensions can help develop and deploy a Quarkus service for Kubernetes.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将了解 Quarkus 与 Kubernetes 之间的集成，以及如何使用多个扩展来帮助开发和部署 Quarkus 服务到 Kubernetes。
- en: Kubernetes is becoming the de facto platform to deploy applications; for this
    reason it is important to have a good understanding of Kubernetes and how to correctly
    develop and deploy applications on it.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 正在成为部署应用程序的事实标准平台；因此，了解 Kubernetes 及如何在其上正确开发和部署应用程序至关重要。
- en: 'In this chapter, you’ll learn how to accomplish the following tasks:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何完成以下任务：
- en: Build and push container images
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建并推送容器镜像。
- en: Generate Kubernetes resources
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成 Kubernetes 资源
- en: Deploy a Quarkus service
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署一个 Quarkus 服务
- en: Develop a Kubernetes operator
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发 Kubernetes 运算符。
- en: Deploy a service in Knative
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Knative 中部署一个服务。
- en: 10.1 Building and Pushing Container Images
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10.1 构建和推送容器镜像
- en: Problem
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to build and push container images.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望构建并推送容器镜像。
- en: Solution
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: The working unit in Kubernetes is a *pod*. A pod represents a group of containers
    that are running in the same host machine and share resources like IP and ports.
    To deploy a service to Kubernetes, you need to create a pod. Since a pod is composed
    by one or more containers, you need to build a container image of your service.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 中的工作单元是一个 *pod*。Pod 表示在同一主机上运行并共享 IP 和端口等资源的一组容器。要将服务部署到 Kubernetes，您需要创建一个
    pod。由于 pod 由一个或多个容器组成，因此需要构建服务的容器镜像。
- en: 'Quarkus provides extensions for building and optionally pushing container images.
    At the time of writing, the following container build strategies are supported:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Quarkus 提供了用于构建和可选推送容器镜像的扩展。在撰写本文时，支持以下容器构建策略：
- en: Jib
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Jib
- en: Jib builds Docker and OCI container images for your Java applications without
    a Docker daemon (Dockerless). This makes it perfect for building Docker images
    when running the process inside a container because you avoid the hassle of the
    Docker-in-Docker (DinD) process. Further, using Jib with Quarkus caches all dependencies
    in a different layer than the actual application, making rebuilds fast and small.
    This improves push times as well as build times.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Jib 为您的 Java 应用程序构建 Docker 和 OCI 容器镜像，无需 Docker 守护程序（无 Docker）。这使得在容器内部运行进程时构建
    Docker 镜像变得非常完美，因为您避免了 Docker-in-Docker (DinD) 进程的麻烦。此外，使用 Jib 与 Quarkus 将所有依赖项缓存到与实际应用程序不同的层中，使重建速度快且节省空间。这也改善了推送和构建时间。
- en: Docker
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Docker
- en: Using the Docker strategy builds container images using the `docker` binary,
    which is installed locally and by default uses `Dockerfiles` located under *src/main/docker*
    to build the images.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Docker 策略构建容器镜像，使用本地安装的 `docker` 二进制文件，默认情况下使用位于 *src/main/docker* 下的 `Dockerfiles`
    来构建镜像。
- en: S2I
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: S2I
- en: The Source-to-Image (S2I) strategy uses `s2i` binary builds to perform container
    builds inside an OpenShift cluster. S2I builds require creating a `BuildConfig`
    and two `ImageStream` resources. The creation of these resources is leveraged
    by the Quarkus Kubernetes extension.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Source-to-Image (S2I) 策略使用 `s2i` 二进制文件在 OpenShift 集群内执行容器构建。S2I 构建需要创建 `BuildConfig`
    和两个 `ImageStream` 资源。这些资源的创建由 Quarkus Kubernetes 扩展来实现。
- en: In this recipe, we’re going to build and push the container using Jib; the “Discussion”
    section of this recipe will address Docker and S2I.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将使用 Jib 构建和推送容器；本教程的“讨论”部分将涉及 Docker 和 S2I。
- en: 'To build and push a container image using Jib, first you need to add the Jib
    extension:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Jib 构建并推送容器镜像，首先需要添加 Jib 扩展。
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then you can customize the container image build process. You can set these
    properties in the *application.properties*, system properties, or environment
    variables, just as any other configuration parameter in Quarkus:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以定制容器镜像构建过程。您可以在 *application.properties*、系统属性或环境变量中设置这些属性，就像在 Quarkus
    中设置任何其他配置参数一样：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[![1](Images/1.png)](#co_integrating_with_kubernetes_CO1-1)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_integrating_with_kubernetes_CO1-1)'
- en: Sets the group part of the image; by default this is `${user.name}`
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 设置镜像的组部分；默认情况下为 `${user.name}`
- en: '[![2](Images/2.png)](#co_integrating_with_kubernetes_CO1-2)'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_integrating_with_kubernetes_CO1-2)'
- en: Registry where to push the image; by default, images are pushed to `docker.io`
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像推送的注册表；默认情况下，镜像被推送到`docker.io`
- en: '[![3](Images/3.png)](#co_integrating_with_kubernetes_CO1-3)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_integrating_with_kubernetes_CO1-3)'
- en: The username to log into the container registry
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 登录容器注册表的用户名
- en: '[![4](Images/4.png)](#co_integrating_with_kubernetes_CO1-4)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](Images/4.png)](#co_integrating_with_kubernetes_CO1-4)'
- en: The password to log into the container registry
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 登录容器注册表的密码
- en: 'To build and push the container image for the project, you need to set the
    `quarkus.container-image.push` parameter to `true`, and during the `package` stage,
    the container is created and pushed:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要为项目构建并推送容器镜像，您需要将`quarkus.container-image.push`参数设置为`true`，并且在`package`阶段期间，将创建并推送容器：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[![1](Images/1.png)](#co_integrating_with_kubernetes_CO2-1)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_integrating_with_kubernetes_CO2-1)'
- en: The container image is built
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 容器镜像已构建
- en: '[![2](Images/2.png)](#co_integrating_with_kubernetes_CO2-2)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_integrating_with_kubernetes_CO2-2)'
- en: The container image is pushed to quay.io
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 容器镜像被推送到quay.io
- en: Discussion
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'Apart from Jib, there are two other options available to build a container
    image; to use them you simply need to register the extension:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Jib之外，还有两个其他选项可用于构建容器镜像；要使用它们，您只需注册该扩展：
- en: Docker
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Docker
- en: '`quarkus-container-image-docker`'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`quarkus-container-image-docker`'
- en: S2I
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: S2I
- en: '`quarkus-container-image-s2i`'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`quarkus-container-image-s2i`'
- en: Each of the extensions provides specific configuration parameters to change
    the build process. These parameters let you change the base images used for building
    the container image and let you set environment variables, the arguments to pass
    to the executable, or the location of the Dockerfiles.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 每个扩展都提供特定的配置参数来修改构建过程。这些参数允许您更改用于构建容器镜像的基础镜像，并允许您设置环境变量、传递给可执行文件的参数或Dockerfile的位置。
- en: 'You can also build the image but not push it to a registry. To do this, you
    need to set the `quarkus.container-image.build` property to `true` and not set
    the `quarkus.container-image.push` property:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以构建镜像，但不将其推送到注册表。为此，您需要将`quarkus.container-image.build`属性设置为`true`，并且不设置`quarkus.container-image.push`属性：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Important
  id: totrans-50
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 重要提示
- en: If `Jib` is used and `push` is set to `false`, the extension creates a container
    image and registers it with the Docker daemon. This means that although Docker
    isn’t used to build the image, it is still necessary.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用了`Jib`并且将`push`设置为`false`，该扩展将创建一个容器镜像并将其注册到Docker守护程序。这意味着虽然不使用Docker构建镜像，但它仍然是必要的。
- en: 'The container image extensions can create a container from a JAR package (for
    use in JVM mode) and from a native executable, depending on what is found in the
    *build/output* directory. If you want to create a native executable that can be
    run from a Linux container and then create a container image with the resulting
    native executable inside, you can run the following command:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 容器镜像扩展可以从*build/output*目录中的JAR包（用于JVM模式）或本地可执行文件创建容器，具体取决于目录中的内容。如果您希望创建一个可以在Linux容器中运行的本地可执行文件，并在其中创建包含生成的本地可执行文件的容器镜像，您可以运行以下命令：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Setting the `quarkus.native.container-build` property to `true` creates the
    native executable inside a Docker container.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 将`quarkus.native.container-build`属性设置为`true`，可以在Docker容器内创建本地可执行文件。
- en: See Also
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'For more information, visit the following pages on GitHub:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 欲获取更多信息，请访问GitHub上的以下页面：
- en: '[Google Container Tools: Jib](https://oreil.ly/6vrh5)'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Google容器工具：Jib](https://oreil.ly/6vrh5)'
- en: '[Source-To-Image](https://oreil.ly/8PEgn)'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[源码到镜像（Source-To-Image）](https://oreil.ly/8PEgn)'
- en: 10.2 Generating Kubernetes Resources
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10.2 生成Kubernetes资源
- en: Problem
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to generate Kubernetes resources automatically.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望自动生成Kubernetes资源。
- en: Solution
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Quarkus has a Kubernetes extension that is able to generate Kubernetes resources
    automatically with sane defaults and optional user-supplied configuration. Currently,
    the extension can produce resources for Kubernetes and OpenShift.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Quarkus具有一个Kubernetes扩展，能够根据合理的默认值和可选的用户提供的配置自动生成Kubernetes资源。目前，该扩展可以为Kubernetes和OpenShift生成资源。
- en: 'To enable the generation of Kubernetes resources, you need to register the
    `quarkus-kubernetes` extension:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用生成Kubernetes资源的功能，您需要注册`quarkus-kubernetes`扩展：
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To generate the Kubernetes resources, execute in a new terminal `./mvnw package`.
    Then among the usual files generated by the build tool in the `target` directory,
    two new files are created inside the *target/kubernetes* directory. These new
    files are named *kubernetes.json* and *kubernetes.yaml*, and they each contain
    the definition of both a `Deployment` and a `Service`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成 Kubernetes 资源，请在新的终端中执行 `./mvnw package`。然后在 `target` 目录中，构建工具通常生成的文件中，会在
    *target/kubernetes* 目录下生成两个新文件。这些新文件分别命名为 *kubernetes.json* 和 *kubernetes.yaml*，每个文件都包含
    `Deployment` 和 `Service` 的定义：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[![1](Images/1.png)](#co_integrating_with_kubernetes_CO3-1)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_integrating_with_kubernetes_CO3-1)'
- en: Defaults to project name
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 默认为项目名称
- en: '[![2](Images/2.png)](#co_integrating_with_kubernetes_CO3-2)'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_integrating_with_kubernetes_CO3-2)'
- en: Defaults to version field
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 默认为版本字段
- en: '[![3](Images/3.png)](#co_integrating_with_kubernetes_CO3-3)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_integrating_with_kubernetes_CO3-3)'
- en: Defaults to OS username
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 默认为操作系统用户名
- en: Discussion
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'You can customize the group and the name used in the generated manifest by
    adding these properties to *application.properties*:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过将这些属性添加到 *application.properties* 中，自定义生成清单中使用的组和名称：
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The Kubernetes extension allows user customizations to be supplied to different
    parts of the manifest:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 扩展允许向清单的不同部分提供用户自定义：
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[![1](Images/1.png)](#co_integrating_with_kubernetes_CO4-1)'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_integrating_with_kubernetes_CO4-1)'
- en: Sets the number of replicas
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 设置副本数
- en: '[![2](Images/2.png)](#co_integrating_with_kubernetes_CO4-2)'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_integrating_with_kubernetes_CO4-2)'
- en: Adds the Docker registry to pull images
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 添加 Docker 注册表以拉取镜像
- en: '[![3](Images/3.png)](#co_integrating_with_kubernetes_CO4-3)'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_integrating_with_kubernetes_CO4-3)'
- en: Adds new labels
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 添加新的标签
- en: '[![4](Images/4.png)](#co_integrating_with_kubernetes_CO4-4)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](Images/4.png)](#co_integrating_with_kubernetes_CO4-4)'
- en: Sets readiness probe
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 设置就绪性探针
- en: You can generate different resources by setting the property as `quarkus.kubernetes.deployment-target`
    in the *application.properties* file or as a system property.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在 *application.properties* 文件中设置属性 `quarkus.kubernetes.deployment-target`
    或作为系统属性来生成不同的资源。
- en: 'The default value of this property is `kubernetes`, but the following values
    are also supported at the time of writing: `kubernetes`, `openshift`, and `knative`.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 该属性的默认值是 `kubernetes`，但在撰写时还支持以下值：`kubernetes`、`openshift` 和 `knative`。
- en: See Also
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'The following web page provides a list of all Kubernetes configuration options
    to modify the generated file:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 以下网页列出了所有 Kubernetes 配置选项，以修改生成的文件：
- en: '[Quarkus: Kubernetes Extension](https://oreil.ly/oLxhT)'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Quarkus: Kubernetes 扩展](https://oreil.ly/oLxhT)'
- en: 10.3 Generating Kubernetes Resources with Health Checks
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10.3 使用健康检查生成 Kubernetes 资源
- en: Problem
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to automatically generate Kubernetes resources with liveness and readiness
    probes.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望自动创建带有存活检查和就绪检查的 Kubernetes 资源。
- en: Solution
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'By default, health probes are not generated in the output file, but if the
    `quarkus-smallrye-health` extension is present (as explained in [Recipe 9.1](ch09.xhtml#using-automatic-health-checks)),
    then readiness and liveness probe sections are generated automatically:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，输出文件中不会生成健康检查探针，但如果存在 `quarkus-smallrye-health` 扩展（如 [配方 9.1](ch09.xhtml#using-automatic-health-checks)
    中所述），则会自动生成就绪性和存活性探针部分：
- en: '[PRE9]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[![1](Images/1.png)](#co_integrating_with_kubernetes_CO5-1)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_integrating_with_kubernetes_CO5-1)'
- en: Defines the liveness probe
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 定义存活性探针
- en: '[![2](Images/2.png)](#co_integrating_with_kubernetes_CO5-2)'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_integrating_with_kubernetes_CO5-2)'
- en: The path is the one defined by MicroProfile Health spec
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 路径由 MicroProfile Health 规范定义
- en: '[![3](Images/3.png)](#co_integrating_with_kubernetes_CO5-3)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_integrating_with_kubernetes_CO5-3)'
- en: Defines the readiness probe
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 定义就绪性探针
- en: '[![4](Images/4.png)](#co_integrating_with_kubernetes_CO5-4)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](Images/4.png)](#co_integrating_with_kubernetes_CO5-4)'
- en: The path is the one defined by MicroProfile Health spec
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 路径由 MicroProfile Health 规范定义
- en: Discussion
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Kubernetes uses probes to determine the health state of a service and take automatic
    actions to solve any problem.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 使用探针来确定服务的健康状态，并自动采取行动解决任何问题。
- en: 'Quarkus automatically generates two Kubernetes probes:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Quarkus 自动为 Kubernetes 生成两个探针：
- en: Liveness
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 存活性检查
- en: Kubernetes uses a liveness probe to decide if a service must be restarted. If
    the application becomes unresponsive, perhaps because of a deadlock or memory
    problem, restarting the container might be a good solution to fix the problem.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 使用存活性探针来确定是否必须重新启动服务。如果应用程序变得无响应，可能是因为死锁或内存问题，重新启动容器可能是解决问题的良好解决方案。
- en: Readiness
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 就绪性检查
- en: Kubernetes uses a readiness probe to decide if a service is available for accepting
    traffic. Sometimes a service might need to execute some operations before accepting
    requests. Examples include updating local caching system, populating a change
    to the database schema, applying a batch process, or connecting to an external
    service like Kafka Streams.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes使用就绪探针来确定服务是否可以接受流量。有时，服务在接受请求之前可能需要执行一些操作。例如更新本地缓存系统、将更改应用到数据库架构、应用批处理过程或连接到像Kafka
    Streams这样的外部服务。
- en: See Also
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'For more information, see the following website:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解更多信息，请访问以下网站：
- en: '[Kubernetes: Configure Liveness, Readiness, and Startup Probes](https://oreil.ly/PWl_B)'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Kubernetes：配置存活性、就绪性和启动探测](https://oreil.ly/PWl_B)'
- en: 10.4 Deploying Services on Kubernetes
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10.4 在Kubernetes上部署服务
- en: Problem
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to deploy services on Kubernetes.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望在Kubernetes上部署服务。
- en: Solution
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use `kubectl` and all the features offered by Quarkus to create and deploy a
    service on Kubernetes.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`kubectl`和Quarkus提供的所有功能在Kubernetes上创建和部署服务。
- en: 'Quarkus makes it really easy to create and deploy a Java application into Kubernetes
    by doing the following:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下步骤，Quarkus使得创建并在Kubernetes上部署Java应用程序变得非常简单：
- en: Generating a container native executable of your enterprise application, as
    explained in [Recipe 6.6](ch06.xhtml#building-a-docker-container-native-file)
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如[Recipe 6.6](ch06.xhtml#building-a-docker-container-native-file)中所述，生成企业应用程序的容器本地可执行文件。
- en: Providing a *Dockerfile.native* file to build the Docker container
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供*Dockerfile.native*文件以构建Docker容器
- en: Generating a Kubernetes resources file by using `quarkus-kubernetes` extension,
    as explained in [Recipe 10.2](#generate-kubernetes-resources)
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`quarkus-kubernetes`扩展生成Kubernetes资源文件，详见[Recipe 10.2](#generate-kubernetes-resources)
- en: It is time to see all these steps working together.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候看到所有这些步骤如何一起运作了。
- en: 'To create a native executable that can be run within a container:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 若要创建可在容器内运行的本机可执行文件：
- en: '[PRE10]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[![1](Images/1.png)](#co_integrating_with_kubernetes_CO6-1)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_integrating_with_kubernetes_CO6-1)'
- en: Creates the native executable inside a Docker container
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在Docker容器内创建本机可执行文件
- en: '[![2](Images/2.png)](#co_integrating_with_kubernetes_CO6-2)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_integrating_with_kubernetes_CO6-2)'
- en: Creates a Docker image with the native executable generated previously
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 使用之前生成的本机可执行文件创建Docker镜像
- en: '[![3](Images/3.png)](#co_integrating_with_kubernetes_CO6-3)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_integrating_with_kubernetes_CO6-3)'
- en: Pushes image to the Docker registry (in minikube, this is `eval $(minikube docker-env)`,
    so no push.)
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 将镜像推送到Docker注册表（在minikube中，这是`eval $(minikube docker-env)`，因此无需推送。）
- en: '[![4](Images/4.png)](#co_integrating_with_kubernetes_CO6-4)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](Images/4.png)](#co_integrating_with_kubernetes_CO6-4)'
- en: Deploys the application to Kubernetes
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 将应用程序部署到Kubernetes
- en: '[![5](Images/5.png)](#co_integrating_with_kubernetes_CO6-5)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](Images/5.png)](#co_integrating_with_kubernetes_CO6-5)'
- en: Changes to `NodePort`
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 更改为`NodePort`
- en: '[![6](Images/6.png)](#co_integrating_with_kubernetes_CO6-6)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](Images/6.png)](#co_integrating_with_kubernetes_CO6-6)'
- en: Gets the URL to access the service
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 获取访问服务的URL
- en: Notice that steps 5 and 6 are required only because the service is deployed
    in minikube. Depending on the Kubernetes platform you are using to deploy the
    service to, you might need to do different things.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，仅因服务部署在minikube中，才需要执行第5和第6步。根据您用于部署服务的Kubernetes平台，您可能需要执行不同的操作。
- en: Discussion
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'Steps 1 and 2 could be simplified into one if you use the multi-stage Docker
    build feature. In the first stage, the native executable is generated, and the
    second stage creates the runtime image:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用多阶段Docker构建功能，步骤1和2可以简化为一个步骤。在第一阶段生成本机可执行文件，第二阶段创建运行时镜像：
- en: '[PRE11]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[![1](Images/1.png)](#co_integrating_with_kubernetes_CO7-1)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_integrating_with_kubernetes_CO7-1)'
- en: Generates the native executable
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 生成本机可执行文件
- en: '[![2](Images/2.png)](#co_integrating_with_kubernetes_CO7-2)'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_integrating_with_kubernetes_CO7-2)'
- en: Creates the runtime image from the output of the previous stage
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 从上一阶段的输出创建运行时镜像
- en: 'Remove the *.dockerignore* file from the root directory of the project (`rm
    .dockerignore`). This is necessary because, by default, the *src* directory is
    ignored, and to build the native executable, the *src* directory is required:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 从项目根目录中删除*.dockerignore*文件（`rm .dockerignore`）。这是必要的，因为默认情况下会忽略*src*目录，而构建本机可执行文件需要*src*目录：
- en: '[PRE12]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[![1](Images/1.png)](#co_integrating_with_kubernetes_CO8-1)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_integrating_with_kubernetes_CO8-1)'
- en: Creates the runtime image with native executable bundled
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 使用捆绑本机可执行文件创建运行时镜像
- en: 10.5 Deploying Services on OpenShift
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10.5 在OpenShift上部署服务
- en: Problem
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to deploy services on OpenShift.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望在OpenShift上部署服务。
- en: Solution
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: OpenShift works perfectly with the resources generated in the previous recipe,
    so even though you are using OpenShift, you can still use everything provided
    previously. But if you want to use some of the capabilities offered by OpenShift,
    you can set the `kubernetes.deployment.target` property to `openshift`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: OpenShift与前一个示例生成的资源完美配合，因此即使您在使用OpenShift，仍然可以使用之前提供的所有内容。但是，如果您想使用OpenShift提供的某些功能，可以将`kubernetes.deployment.target`属性设置为`openshift`。
- en: 'The two generated files are placed at *target/kubernetes/openshift.json* and
    *target/kubernetes/openshift.yaml*:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的两个文件分别位于*target/kubernetes/openshift.json*和*target/kubernetes/openshift.yaml*：
- en: '[PRE13]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 10.6 Building and Deploying a Container Image Automatically
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10.6 构建和自动部署容器镜像
- en: Problem
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to build, push, and deploy container images automatically.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望自动构建、推送和部署容器镜像。
- en: Solution
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Quarkus provides extensions for building and pushing container images with the
    `container-image` extensions and for deploying to Kubernetes using the `kubernetes`
    extension.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Quarkus通过`container-image`扩展提供了构建和推送容器镜像的功能，并通过`kubernetes`扩展提供了部署到Kubernetes的功能。
- en: 'To build, push, and deploy a container image, you need to first add the required
    extensions:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建、推送和部署容器镜像，首先需要添加所需的扩展：
- en: '[PRE14]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then you can customize the container image build process. You can set these
    properties in the *application.properties*, system properties, or environment
    variables as any other configuration parameter in Quarkus:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以自定义容器镜像构建过程。您可以在*application.properties*、系统属性或环境变量中设置这些属性，就像Quarkus中的任何其他配置参数一样：
- en: '[PRE15]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[![1](Images/1.png)](#co_integrating_with_kubernetes_CO9-1)'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_integrating_with_kubernetes_CO9-1)'
- en: Sets the group part of the image; by default this is `${user.name}`
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 设置镜像的组部分；默认情况下为`${user.name}`
- en: '[![2](Images/2.png)](#co_integrating_with_kubernetes_CO9-2)'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_integrating_with_kubernetes_CO9-2)'
- en: Registry where to push the image; by default, images are pushed to `docker.io`
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 将镜像推送到的注册表；默认情况下，镜像推送到`docker.io`
- en: '[![3](Images/3.png)](#co_integrating_with_kubernetes_CO9-3)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_integrating_with_kubernetes_CO9-3)'
- en: The username to log into the container registry
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 登录容器注册表的用户名
- en: '[![4](Images/4.png)](#co_integrating_with_kubernetes_CO9-4)'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](Images/4.png)](#co_integrating_with_kubernetes_CO9-4)'
- en: The password to log into the container registry
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 登录容器注册表的密码
- en: 'Finally, deploy to Kubernetes using the following command:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用以下命令将部署到Kubernetes：
- en: '[PRE16]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Discussion
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Notice that setting `quarkus.kubernetes.deploy` to `true` implicitly sets the
    `quarkus.container-image.push` property to `true`, so you do not need to set it
    manually.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，将`quarkus.kubernetes.deploy`设置为`true`会隐式地将`quarkus.container-image.push`属性设置为`true`，因此您无需手动设置它。
- en: The Kubernetes extension uses the standard `kubectl` configuration file located
    at *~/.kube/config* to know where to deploy the application.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes扩展使用位于*~/.kube/config*的标准`kubectl`配置文件，以了解在哪里部署应用程序。
- en: Tip
  id: totrans-181
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: You can also use `-Pnative -Dquarkus.native.container-build=true` flags to create
    and deploy a container image with native compilation.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`-Pnative -Dquarkus.native.container-build=true`标志使用本地编译创建和部署容器镜像。
- en: 10.7 Configuring an Application from Kubernetes
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10.7 从Kubernetes配置应用程序
- en: Problem
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to configure your application through (or via) Kubernetes instead of
    the configuration file.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望通过Kubernetes而不是配置文件来配置应用程序。
- en: Solution
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use `ConfigMaps` to configure the applications running inside a pod.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ConfigMaps`配置在Pod内运行的应用程序。
- en: 'In this example, you are going to configure a service using a `ConfigMap` and
    Kubernetes extension. To enable the generation of Kubernetes resources with the
    `ConfigMap` injection in the `Pod`, you need to register the `quarkus-kubernetes`
    extension:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，您将使用`ConfigMap`和Kubernetes扩展配置服务。要启用在`Pod`中注入`ConfigMap`的Kubernetes资源生成，您需要注册`quarkus-kubernetes`扩展：
- en: '[PRE17]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The service returns the `greeting.message` configuration value when the `/hello`
    endpoint is called:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`/hello`端点时，服务返回`greeting.message`配置值：
- en: '[PRE18]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Create the `ConfigMap` resource with the key-value pairs:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 创建包含键值对的`ConfigMap`资源：
- en: '[PRE19]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[![1](Images/1.png)](#co_integrating_with_kubernetes_CO10-1)'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_integrating_with_kubernetes_CO10-1)'
- en: Defines the `ConfigMap` type
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 定义`ConfigMap`类型
- en: '[![2](Images/2.png)](#co_integrating_with_kubernetes_CO10-2)'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_integrating_with_kubernetes_CO10-2)'
- en: For the key `greeting` defines the value `Kubernetes`
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 对于键`greeting`定义值为`Kubernetes`
- en: 'Then the resource must be applied to the Kubernetes cluster by running the
    next command in a terminal window:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，必须通过在终端窗口中运行以下命令将资源应用于 Kubernetes 集群：
- en: '[PRE20]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Finally, set the Kubernetes extension properties in the *application.properties*
    so that the generated Kubernetes deployment file contains the segments to inject
    the config map as an environment variable:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在*application.properties*中设置 Kubernetes 扩展属性，以便生成的 Kubernetes 部署文件包含将 config
    map 作为环境变量注入的部分：
- en: '[PRE21]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[![1](Images/1.png)](#co_integrating_with_kubernetes_CO11-1)'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_integrating_with_kubernetes_CO11-1)'
- en: Configures Docker image
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 配置 Docker 镜像
- en: '[![2](Images/2.png)](#co_integrating_with_kubernetes_CO11-2)'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_integrating_with_kubernetes_CO11-2)'
- en: Sets the environment variable to override the `greeting.message` property
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 将环境变量设置为覆盖`greeting.message`属性
- en: '[![3](Images/3.png)](#co_integrating_with_kubernetes_CO11-3)'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_integrating_with_kubernetes_CO11-3)'
- en: Sets the config map resource name to load
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 设置要加载的 config map 资源名称
- en: The generation of the Kubernetes file will contain a new entry defining the
    key-value pairs in the container definition called `configMapKeyRef`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的 Kubernetes 文件将包含一个新条目，定义容器定义中的键值对，称为`configMapKeyRef`。
- en: 'To deploy the application, open a new terminal window, package the application,
    create the Docker container, and apply the generated Kubernetes resources:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 要部署应用程序，请打开新的终端窗口，打包应用程序，创建 Docker 容器，并应用生成的 Kubernetes 资源：
- en: '[PRE22]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Discussion
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: '`ConfigMap` consists of key-value pairs that Kubernetes injects into pods’
    containers in the form of files or environment variables so the application can
    read them and configure accordingly. With `ConfigMaps`, you can decouple the configuration
    of the application from the business logic, making it portable across environments.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConfigMap`由 Kubernetes 注入到 pod 的容器中，以文件或环境变量的形式组成键值对，使应用程序可以读取并相应地进行配置。通过`ConfigMaps`，可以将应用程序的配置与业务逻辑解耦，从而使其在不同环境中具备可移植性。'
- en: Important
  id: totrans-213
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 重要
- en: '`ConfigMaps` are meant to be used for storing and sharing non-sensitive configuration
    properties.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConfigMaps`用于存储和共享非敏感配置属性。'
- en: The MicroProfile Config spec permits the override of any configuration property
    using the equivalent environment variable (in uppercase and changing dots [`.`]
    to underscores [`_`]). The `ConfigMap` contains the configuration properties.
    In *application.properties*, the Kubernetes extension is configured to generate
    a deployment descriptor that sets these properties as environment variables so
    that when the container is started inside the Kubernetes cluster, the specific
    configuration applied to this cluster is used.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: MicroProfile Config 规范允许通过等效的环境变量（大写并将点[`.`]改为下划线[`_`]）来覆盖任何配置属性。`ConfigMap`包含配置属性。在*application.properties*中，配置了
    Kubernetes 扩展以生成部署描述符，将这些属性设置为环境变量，因此当在 Kubernetes 集群内启动容器时，使用适用于该集群的特定配置。
- en: See Also
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'To learn more about `ConfigMaps` in Kubernetes, visit the following website:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于 Kubernetes 中`ConfigMaps`的信息，请访问以下网站：
- en: '[Kubernetes: Configure a Pod to Use a ConfigMap](https://oreil.ly/BPmo5)'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Kubernetes: 配置 Pod 使用 ConfigMap](https://oreil.ly/BPmo5)'
- en: 10.8 Configuring an Application from Kubernetes with Config Extension
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10.8 通过 Config 扩展从 Kubernetes 配置应用程序
- en: Problem
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to configure your application through (or via) Kubernetes instead of
    the configuration file using the MicroProfile Config specification.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望通过 Kubernetes 而不是配置文件来配置您的应用程序，使用 MicroProfile Config 规范。
- en: Solution
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Quarkus has a Kubernetes Configuration extension that can read the secrets and
    config maps elements from the Kubernetes API Server and inject them using `@ConfigProperty`
    annotation.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: Quarkus 提供了一个 Kubernetes 配置扩展，可以从 Kubernetes API 服务器中读取 secrets 和 config maps
    元素，并使用`@ConfigProperty`注解进行注入。
- en: To enable the generation of Kubernetes resources, you need to register the `quarkus-kubernetes-config`
    extension.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用生成 Kubernetes 资源，请注册`quarkus-kubernetes-config`扩展。
- en: The extension supports injecting `ConfigMaps`, either as a single key/value
    form or in the form in which the key is a filename (where only `application.properties`
    or `application.yaml` is supported) and the value is the content of that file.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 该扩展支持注入`ConfigMaps`，可以是单个键/值形式，也可以是键为文件名的形式（仅支持`application.properties`或`application.yaml`），其值是文件的内容。
- en: 'Let’s create a config map with a single key/value:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个带有单个键/值的 config map：
- en: '[PRE23]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[![1](Images/1.png)](#co_integrating_with_kubernetes_CO12-1)'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_integrating_with_kubernetes_CO12-1)'
- en: Config name is important for the extension
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 对于扩展来说，配置名称很重要。
- en: 'Then register the previous `ConfigMap` resource:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 然后注册前述的 `ConfigMap` 资源：
- en: '[PRE24]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: For this example, an *application.properties* file as `ConfigMap` is also registered.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此示例，还注册了一个名为 *application.properties* 的 `ConfigMap` 文件。
- en: 'The configuration file added contains the following:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 添加的配置文件包含以下内容：
- en: '[PRE25]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then register the previous file in a `ConfigMap` named `my-file-config`:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将前述文件注册到名为 `my-file-config` 的 `ConfigMap` 中：
- en: '[PRE26]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The last step before you can inject these values is to configure the extension
    to read values from these `ConfigMaps`:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在注入这些值之前的最后一步是配置扩展程序以从这些 `ConfigMaps` 中读取值：
- en: '[PRE27]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[![1](Images/1.png)](#co_integrating_with_kubernetes_CO13-1)'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_integrating_with_kubernetes_CO13-1)'
- en: Enables the extension
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 启用扩展
- en: '[![2](Images/2.png)](#co_integrating_with_kubernetes_CO13-2)'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_integrating_with_kubernetes_CO13-2)'
- en: Sets the `ConfigMap` names
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 `ConfigMap` 的名称
- en: 'These configuration values are injected like any other configuration value:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这些配置值像其他配置值一样注入：
- en: '[PRE28]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[![1](Images/1.png)](#co_integrating_with_kubernetes_CO14-1)'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_integrating_with_kubernetes_CO14-1)'
- en: Simple key is injected
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 注入简单键
- en: '[![2](Images/2.png)](#co_integrating_with_kubernetes_CO14-2)'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_integrating_with_kubernetes_CO14-2)'
- en: Keys from the *application.properties* file are injected too
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 也注入了 *application.properties* 文件中的键
- en: 'To deploy the application, open a new terminal window, package the application,
    create the Docker container, and apply the generated Kubernetes resources:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 要部署应用程序，请打开新的终端窗口，打包应用程序，创建 Docker 容器，并应用生成的 Kubernetes 资源：
- en: '[PRE29]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 10.9 Interacting with a Kubernetes Cluster Programmatically
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10.9 以编程方式与 Kubernetes 集群交互
- en: Problem
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to interact with a Kubernetes API server programmatically.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望以编程方式与 Kubernetes API 服务器进行交互。
- en: Solution
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the `kubernetes-client` extension to start watching and reacting to changes
    on Kubernetes resources.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `kubernetes-client` 扩展程序开始观察和响应 Kubernetes 资源的更改。
- en: 'To add the `kubernetes-extension`, run the following:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加`kubernetes-extension`，运行以下命令：
- en: '[PRE30]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The main class to connect to the Kubernetes cluster is `io.fabric8.kubernetes.client.KubernetesClient`.
    The extension produces this instance so it can be injected in the code. The client
    can be configured using various properties, setting them in *application.properties*.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到 Kubernetes 集群的主要类是 `io.fabric8.kubernetes.client.KubernetesClient`。扩展程序生成此实例以便在代码中注入。可以使用各种属性配置客户端，将它们设置在
    *application.properties* 中。
- en: 'The example developed here is an endpoint that returns the name of all deployed
    pods on the given namespace:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 此处开发的示例是一个端点，返回给定命名空间上所有部署的 Pod 的名称：
- en: '[PRE31]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[![1](Images/1.png)](#co_integrating_with_kubernetes_CO15-1)'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_integrating_with_kubernetes_CO15-1)'
- en: The `KubernetesClient` is injected like any other CDI bean
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`KubernetesClient` 被注入，就像任何其他 CDI bean 一样'
- en: '[![2](Images/2.png)](#co_integrating_with_kubernetes_CO15-2)'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_integrating_with_kubernetes_CO15-2)'
- en: Select all pods
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 选择所有的 Pods
- en: '[![3](Images/3.png)](#co_integrating_with_kubernetes_CO15-3)'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_integrating_with_kubernetes_CO15-3)'
- en: From given namespace
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 来自给定命名空间
- en: '[![4](Images/4.png)](#co_integrating_with_kubernetes_CO15-4)'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](Images/4.png)](#co_integrating_with_kubernetes_CO15-4)'
- en: Gets only the generated name of the pod
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 仅获取 Pod 的生成名称
- en: The recommended way to access the REST API of Kubernetes is by using `kubectl`
    in proxy mode because no man-in-the-middle attack is possible.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 访问 Kubernetes 的 REST API 推荐的方式是使用 `kubectl` 代理模式，因为这样可以避免中间人攻击。
- en: The other way is by providing the location and the credentials directly, but
    to avoid man-in-the-middle attacks you might need to import the root certificate.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是直接提供位置和凭据，但为了避免中间人攻击，可能需要导入根证书。
- en: Because the proxy mode is the recommended way, this is the method used for this
    example.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 因为代理模式是推荐的方式，所以本示例中使用了此方法。
- en: 'Pointing `kubectl` to the cluster that the application must connect with, open
    a new terminal window and run the next command:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 指向应用程序必须连接的集群的 `kubectl`，打开新的终端窗口并运行以下命令：
- en: '[PRE32]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This command runs `kubectl` as a reverse proxy, exposing the remote Kubernetes
    API server at [*http://localhost:8090*](http://localhost:8090).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令以反向代理方式运行 `kubectl`，在 [*http://localhost:8090*](http://localhost:8090) 上公开远程
    Kubernetes API 服务器。
- en: 'Configure `KubernetesClient` to connect to [*http://localhost:8090*](http://localhost:8090)
    by using the `quarkus.kubernetes-client.master-url` property in *application.properties*:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 配置 `KubernetesClient` 以通过 *application.properties* 中的 `quarkus.kubernetes-client.master-url`
    属性连接到 [*http://localhost:8090*](http://localhost:8090)：
- en: '[PRE33]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[![1](Images/1.png)](#co_integrating_with_kubernetes_CO16-1)'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_integrating_with_kubernetes_CO16-1)'
- en: Sets the URL of the Kubernetes API server
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 Kubernetes API 服务器的 URL
- en: 'Finally, run the service and make a request to the `/pod/default` endpoint
    to get all the pods deployed in the default namespace:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，运行服务并请求`/pod/default`端点，以获取在默认命名空间中部署的所有 pod：
- en: '[PRE34]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Discussion
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: In some circumstances, you need to create new Kubernetes resources programmatically
    or get some information about Kubernetes clusters/resources (what pods are deployed,
    configuration parameters, set secrets, and so on). Where `kubernetes-client` really
    shines is in implementing a *Kubernetes Operator* in Java. Thanks to the capabilities
    of Quarkus to generate a native executable, this is a great way to implement Kubernetes
    Operators in Java.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，您需要以编程方式创建新的 Kubernetes 资源或获取有关 Kubernetes 集群/资源的一些信息（已部署的 pod、配置参数、设置密码等）。`kubernetes-client`真正出色的地方在于在
    Java 中实现*Kubernetes Operator*。由于 Quarkus 的能力可以生成本机可执行文件，这是在 Java 中实现 Kubernetes
    Operator 的绝佳方式。
- en: In this example, the service was deployed outside the Kubernetes cluster, and
    you connect to it using the Kubernetes API server.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，服务是在 Kubernetes 集群外部部署的，并且您使用 Kubernetes API 服务器连接到它。
- en: If the service was deployed into the Kubernetes cluster that needs to be accessed,
    then the `quarkus.kubernetes-client.master-url` property must be set to `https://kubernetes.default.svc`.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 如果部署了需要访问的 Kubernetes 集群中的服务，则必须将`quarkus.kubernetes-client.master-url`属性设置为`https://kubernetes.default.svc`。
- en: 'The creation of `KubernetesClient` can be overridden by simply declaring a
    CDI provider factory method returning the configured instance of `KubernetesClient`:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过简单声明返回已配置`KubernetesClient`实例的 CDI 提供程序工厂方法来重写`KubernetesClient`的创建：
- en: '[PRE35]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[![1](Images/1.png)](#co_integrating_with_kubernetes_CO17-1)'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_integrating_with_kubernetes_CO17-1)'
- en: Configures the client
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 配置客户端
- en: '[![2](Images/2.png)](#co_integrating_with_kubernetes_CO17-2)'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_integrating_with_kubernetes_CO17-2)'
- en: Creates an instance of `KubernetesClient`
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`KubernetesClient`的实例
- en: 'In most cases, to access the Kubernetes API server, a `ServiceAccount`, `Role`,
    and `RoleBinding` are necessary. The following might be a starting point to work
    the example provided in this section:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，要访问 Kubernetes API 服务器，需要`ServiceAccount`、`Role`和`RoleBinding`。以下可能是在本节提供的示例中工作的起点：
- en: '[PRE36]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: See Also
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'To learn more about Fabric8 Kubernetes Client, visit the following page on
    GitHub:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解有关 Fabric8 Kubernetes 客户端的更多信息，请访问 GitHub 上的以下页面：
- en: '[Kubernetes & OpenShift Java Client](https://oreil.ly/_QNSL)'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Kubernetes & OpenShift Java Client](https://oreil.ly/_QNSL)'
- en: 10.10 Testing Kubernetes Client Interactions
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10.10 测试 Kubernetes 客户端交互
- en: Problem
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to test Kubernetes Client code.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 您想要测试 Kubernetes 客户端代码。
- en: Solution
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Quarkus implements a Quarkus Test Resource that launches a mock of the Kubernetes
    API server and sets the correct configuration to make the Kubernetes Client use
    the mock server instance instead of the value provided in *application.properties*.
    Moreover, you can set up the mock server to respond to any canned request required
    for any particular test:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: Quarkus 实现了一个 Quarkus 测试资源，用于启动 Kubernetes API 服务器的模拟，并设置正确的配置以使 Kubernetes
    客户端使用模拟服务器实例而不是*application.properties*中提供的值。此外，您可以设置模拟服务器以响应任何特定测试所需的任何 canned
    请求：
- en: '[PRE37]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[![1](Images/1.png)](#co_integrating_with_kubernetes_CO18-1)'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_integrating_with_kubernetes_CO18-1)'
- en: Sets Kubernetes Test Resource mock server
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 Kubernetes 测试资源模拟服务器
- en: '[![2](Images/2.png)](#co_integrating_with_kubernetes_CO18-2)'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_integrating_with_kubernetes_CO18-2)'
- en: Injects Kubernetes mock server instance to record any interaction
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 注入 Kubernetes 模拟服务器实例以记录任何交互
- en: '[![3](Images/3.png)](#co_integrating_with_kubernetes_CO18-3)'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_integrating_with_kubernetes_CO18-3)'
- en: To maintain test isolation, before every test, the interaction is recorded again
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持测试隔离性，在每次测试之前，再次记录交互
- en: '[![4](Images/4.png)](#co_integrating_with_kubernetes_CO18-4)'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](Images/4.png)](#co_integrating_with_kubernetes_CO18-4)'
- en: Builds the pod to be returned
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 构建要返回的 pod
- en: '[![5](Images/5.png)](#co_integrating_with_kubernetes_CO18-5)'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](Images/5.png)](#co_integrating_with_kubernetes_CO18-5)'
- en: The pod is returned as a result of querying all pods from `test` namespace
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查询`test`命名空间中的所有 pod，返回一个 pod 作为结果
- en: 10.11 Implementing a Kubernetes Operator
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10.11 实现 Kubernetes 运算符
- en: Problem
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to implement a Kubernetes Operator to extend Kubernetes using custom
    resources to manage applications in Java.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 您想要实现一个 Kubernetes 运算符，以使用自定义资源扩展 Kubernetes 以管理 Java 中的应用程序。
- en: Solution
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the `kubernetes-client` extension and Quarkus to implement a Kubernetes
    operator in Java and compile it into a native executable.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`kubernetes-client`扩展和 Quarkus 在 Java 中实现 Kubernetes 运算符，并将其编译为本机可执行文件。
- en: One of the use cases for an operator is to create a template (*custom resource*)
    where some values are set in the creation time. The biggest difference between
    a file template and an operator is that the common content (in the case of a *template*)
    is static, whereas in an operator it is set programmatically, which means that
    you’ve got the freedom to change the definition of the common part dynamically.
    This is known as a *custom resource*, in which, instead of using a well-known
    Kubernetes resource, you implement your own custom Kubernetes resource with your
    own fields.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 操作员的一个用例是创建一个模板（*自定义资源*），其中在创建时设置一些值。文件模板和操作员之间最大的区别在于，通用内容（在*模板*的情况下）是静态的，而在操作员中是以编程方式设置的，这意味着您可以自由地动态更改公共部分的定义。这被称为*自定义资源*，其中，您不是使用一个众所周知的
    Kubernetes 资源，而是使用您自己的字段实现自己的自定义 Kubernetes 资源。
- en: Another use case might be to react/operate when something happens inside the
    cluster. Suppose you’ve got some in-memory data grids deployed on the cluster,
    and one of these instances dies. Maybe in this case what you want is to notify
    all living instances that one of the elements of the data grid cluster has been
    stopped.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个用例可能是在集群内部发生某事时做出反应/操作。假设您在集群上部署了一些内存数据网格，并且其中一个实例停止运行。也许在这种情况下，您希望通知所有存活的实例，数据网格集群的一个元素已经停止。
- en: As you can see, it is about not only the creation of a resource but also applying
    some tasks that are specific to your application that need to be done atop one
    of the tasks that Kubernetes is already doing.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，这不仅仅是创建资源，还涉及到应用一些特定于您的应用程序的任务，这些任务需要在 Kubernetes 已经在执行的任务之上执行。
- en: The Kubernetes Operator uses Kubernetes API to decide when and how to run some
    of these customizations.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 操作员使用 Kubernetes API 来决定何时以及如何运行其中一些定制化内容。
- en: The following simple example does not make a lot of sense from the point of
    view of the logic it implements, but it will help you understand the basics of
    writing a Kubernetes Operator. Use it as a starting point for implementing your
    own Kubernetes Operators.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 从逻辑实现的角度来看，以下简单示例并没有太多意义，但它将帮助您理解编写 Kubernetes 操作员的基础知识。将其用作实现自己的 Kubernetes
    操作员的起点。
- en: 'To write a Kubernetes Operator, the following elements may be needed:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写 Kubernetes 操作员，可能需要以下元素：
- en: Classes that parse custom resources.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解析自定义资源的类。
- en: Factory method that registers and generates a client to operate with custom
    resources.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注册并生成客户端以操作自定义资源的工厂方法。
- en: A watcher that reacts when a custom resource is applied to the cluster. You
    can think of it as the operator controller or the operator implementation.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当将自定义资源应用于集群时，反应的观察者。您可以将其视为操作员控制器或操作员实现。
- en: Docker image with all previous code.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 具有所有先前代码的 Docker 镜像。
- en: YAML/JSON file to define the custom resource (`CustomResourceDefinition`).
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于定义自定义资源（`CustomResourceDefinition`）的 YAML/JSON 文件。
- en: Deployment file to deploy the custom operator.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署文件以部署自定义操作员。
- en: Let’s implement a simple Kubernetes Operator that configures the command to
    run in the container and instantiates the pod with this configuration.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现一个简单的 Kubernetes 操作员，配置在容器中运行的命令，并使用此配置实例化 pod。
- en: 'The base image used for the example is [Whalesay](https://oreil.ly/98T7t),
    which basically prints in the container console the message you passed as argument
    in the `run` command, like this:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 用于示例的基础镜像是 [Whalesay](https://oreil.ly/98T7t)，它基本上会在容器控制台中打印您在`run`命令中传递的消息，就像这样：
- en: '[PRE38]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'An example of a pod resource using this image could look like the following:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此镜像的 pod 资源的示例可能如下所示：
- en: '[PRE39]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[![1](Images/1.png)](#co_integrating_with_kubernetes_CO19-1)'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_integrating_with_kubernetes_CO19-1)'
- en: Sets the output message
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 设置输出消息
- en: The goal of this operator is that only the message to be printed must be provided.
    The rest of the content (e.g., Docker image, container configuration, etc.) is
    set by the Kubernetes Operator automatically.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 此操作员的目标是只需提供要打印的消息。其余内容（例如 Docker 镜像、容器配置等）将由 Kubernetes 操作员自动设置。
- en: 'To create a custom operator, the Kubernetes Client and Jackson dependencies
    are required:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建自定义操作员，需要 Kubernetes 客户端和 Jackson 依赖项：
- en: '[PRE40]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The first thing to do is define what the custom resource looks like. For this
    example, it looks like the following:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要做的是定义自定义资源的外观。例如，对于这个示例，它看起来如下所示：
- en: '[PRE41]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[![1](Images/1.png)](#co_integrating_with_kubernetes_CO20-1)'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_integrating_with_kubernetes_CO20-1)'
- en: Uses custom `kind` schema (defined later in this recipe)
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 使用自定义 `kind` 架构（稍后在本文档中定义）
- en: '[![2](Images/2.png)](#co_integrating_with_kubernetes_CO20-2)'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_integrating_with_kubernetes_CO20-2)'
- en: Sets the message to print
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 设置要打印的消息
- en: An object model is required to parse the custom resource. In this case, the
    Jackson library is used to map from YAML to Java Object. Three classes are required,
    one for the whole resource, another one for the `spec` section, and another one
    for the `status` section, which is empty but required because it might be filled
    automatically by the cluster.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 需要对象模型来解析自定义资源。 在这种情况下，使用 Jackson 库将 YAML 映射到 Java 对象。 需要三个类，一个用于整个资源，另一个用于
    `spec` 部分，另一个用于 `status` 部分，后者为空但是需要，因为集群可能会自动填充它。
- en: 'Create all of them at *src/main/java* inside package `org.acme.quickstart.cr`:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `org.acme.quickstart.cr` 包内的 *src/main/java* 中创建它们：
- en: '[PRE42]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[![1](Images/1.png)](#co_integrating_with_kubernetes_CO21-1)'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_integrating_with_kubernetes_CO21-1)'
- en: Sets POJO as deserializable
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 将 POJO 设置为可反序列化
- en: '[![2](Images/2.png)](#co_integrating_with_kubernetes_CO21-2)'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_integrating_with_kubernetes_CO21-2)'
- en: Inherits common custom resource fields like `kind`, `apiVersion`, or `metadata`
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 继承通用自定义资源字段，如 `kind`、`apiVersion` 或 `metadata`
- en: '[![3](Images/3.png)](#co_integrating_with_kubernetes_CO21-3)'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_integrating_with_kubernetes_CO21-3)'
- en: Custom `spec` section
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义 `spec` 部分
- en: '[![4](Images/4.png)](#co_integrating_with_kubernetes_CO21-4)'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](Images/4.png)](#co_integrating_with_kubernetes_CO21-4)'
- en: '`status` section'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '`status` 部分'
- en: 'The `spec` section is mapped as follows:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '`spec` 部分映射如下：'
- en: '[PRE43]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[![1](Images/1.png)](#co_integrating_with_kubernetes_CO22-1)'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_integrating_with_kubernetes_CO22-1)'
- en: The custom spec contains only a `message` field
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义规格仅包含一个 `message` 字段
- en: 'And the empty `status` section is mapped as follows:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 空的 `status` 部分映射如下：
- en: '[PRE44]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Still, two classes are required from the model point of view.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 从模型观点仍然需要两个类。
- en: 'One class is used when, instead of applying a single custom resource (as shown
    previously) to the cluster, a list of the custom resources is provided (using
    the `items` array):'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 当不仅仅是将单个自定义资源（如前所示）应用于集群时，而是提供了自定义资源列表（使用`items`数组）时，使用 `One class`。
- en: '[PRE45]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[![1](Images/1.png)](#co_integrating_with_kubernetes_CO23-1)'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_integrating_with_kubernetes_CO23-1)'
- en: '`CustomResourceList` inherits all fields required to support a list of custom
    resources'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '`CustomResourceList` 继承了支持自定义资源列表的所有必需字段'
- en: 'The other class is used to make the custom resource editable from the operator
    implementation:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个类用于从操作员实现中使自定义资源可编辑：
- en: '[PRE46]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[![1](Images/1.png)](#co_integrating_with_kubernetes_CO24-1)'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_integrating_with_kubernetes_CO24-1)'
- en: '`CustomResourceDoneable` class makes the resource editable'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '`CustomResourceDoneable` 类使资源可编辑'
- en: 'The next big thing that is required is a CDI factory bean that provides all
    the machinery required by the operator. Create this class at *src/main/java* inside
    package `org.acme.quickstart`:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来所需的另一件重要事情是一个 CDI 工厂 bean，它提供了操作员所需的所有机制。 在 *src/main/java* 的 `org.acme.quickstart`
    包中创建此类：
- en: '[PRE47]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[![1](Images/1.png)](#co_integrating_with_kubernetes_CO25-1)'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_integrating_with_kubernetes_CO25-1)'
- en: Gets the namespace where the operator is running
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 获取操作员正在运行的命名空间
- en: '[![2](Images/2.png)](#co_integrating_with_kubernetes_CO25-2)'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_integrating_with_kubernetes_CO25-2)'
- en: Configures `KubernetesClient` with the current namespace; defaults fit for Kubernetes
    Operator development
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 配置 `KubernetesClient` 与当前命名空间；默认适用于 Kubernetes Operator 开发
- en: '[![3](Images/3.png)](#co_integrating_with_kubernetes_CO25-3)'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_integrating_with_kubernetes_CO25-3)'
- en: '`MixedOperation` is used for watching events about the custom resource (e.g.,
    when a new custom resource is applied)'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '`MixedOperation` 用于监视有关自定义资源的事件（例如，应用新的自定义资源时）'
- en: '[![4](Images/4.png)](#co_integrating_with_kubernetes_CO25-4)'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](Images/4.png)](#co_integrating_with_kubernetes_CO25-4)'
- en: Registers the `apiVersion` and `Kind` to be parsed by `org.acme.quickstart.cr.HelloResource`
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 注册要由 `org.acme.quickstart.cr.HelloResource` 解析的 `apiVersion` 和 `Kind`
- en: '[![5](Images/5.png)](#co_integrating_with_kubernetes_CO25-5)'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](Images/5.png)](#co_integrating_with_kubernetes_CO25-5)'
- en: Gets the definition of the custom resource; because there is only one (i.e.,
    the one we are developing), `findFirst` can be used
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 获取自定义资源的定义；因为只有一个（即我们正在开发的），可以使用 `findFirst`
- en: '[![6](Images/6.png)](#co_integrating_with_kubernetes_CO25-6)'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](Images/6.png)](#co_integrating_with_kubernetes_CO25-6)'
- en: Registers for the customer resource, the parser, the list parser, and the `doneable`
    class
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 注册客户端资源、解析器、列表解析器和 `doneable` 类
- en: The last Java class to implement is the controller. This controller (or watcher/operator)
    is responsible for inspecting what’s going on inside the cluster and reacting
    to the subscribed events—for example, a new pod has been created/destroyed or
    a custom resource of kind `Hello` has been applied.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 最后需要实现的Java类是控制器。这个控制器（或者观察者/操作者）负责检查集群内部的运行情况，并对订阅的事件做出响应，例如，一个新的Pod已经被创建或销毁，或者应用了一个名为`Hello`的自定义资源。
- en: In this implementation, the controller is watching when a new resource of kind
    `Hello` is added. When the custom resource is applied, then the message is retrieved
    from the model, and the pod definition is created using all the builders provided
    by the Kubernetes Client API. Finally, the pod is deployed into the Kubernetes
    cluster.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实现中，控制器会监视当一个新的`Hello`资源被添加时。当自定义资源被应用时，然后从模型中检索消息，并使用Kubernetes客户端API提供的所有构建器创建Pod定义。最终，将Pod部署到Kubernetes集群中。
- en: 'Create this class at *src/main/java* inside package `org.acme.quickstart`:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 在`org.acme.quickstart`包内的*src/main/java*中创建这个类：
- en: '[PRE48]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[![1](Images/1.png)](#co_integrating_with_kubernetes_CO26-1)'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_integrating_with_kubernetes_CO26-1)'
- en: Injects KubernetesClient
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 注入KubernetesClient
- en: '[![2](Images/2.png)](#co_integrating_with_kubernetes_CO26-2)'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_integrating_with_kubernetes_CO26-2)'
- en: Injects operations specific to the developed custom resource
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 注入特定于开发的自定义资源的操作
- en: '[![3](Images/3.png)](#co_integrating_with_kubernetes_CO26-3)'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_integrating_with_kubernetes_CO26-3)'
- en: Executes logic when the application is started
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序启动时执行逻辑
- en: '[![4](Images/4.png)](#co_integrating_with_kubernetes_CO26-4)'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](Images/4.png)](#co_integrating_with_kubernetes_CO26-4)'
- en: Watches for any operation that `HelloResource` is implied
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 监视任何涉及`HelloResource`的操作
- en: '[![5](Images/5.png)](#co_integrating_with_kubernetes_CO26-5)'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](Images/5.png)](#co_integrating_with_kubernetes_CO26-5)'
- en: Gets the information provided in the custom resource
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 获取自定义资源中提供的信息
- en: '[![6](Images/6.png)](#co_integrating_with_kubernetes_CO26-6)'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](Images/6.png)](#co_integrating_with_kubernetes_CO26-6)'
- en: Starts the creation of the pod definition programmatically
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 程序化地开始创建Pod定义
- en: '[![7](Images/7.png)](#co_integrating_with_kubernetes_CO26-7)'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](Images/7.png)](#co_integrating_with_kubernetes_CO26-7)'
- en: Sets the message provided by the custom resource
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 设置自定义资源提供的消息
- en: '[![8](Images/8.png)](#co_integrating_with_kubernetes_CO26-8)'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '[![8](Images/8.png)](#co_integrating_with_kubernetes_CO26-8)'
- en: Builds the pod
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 构建Pod
- en: '[![9](Images/9.png)](#co_integrating_with_kubernetes_CO26-9)'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '[![9](Images/9.png)](#co_integrating_with_kubernetes_CO26-9)'
- en: Adds the pod to the cluster
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 将Pod添加到集群中
- en: '[![10](Images/10.png)](#co_integrating_with_kubernetes_CO26-10)'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '[![10](Images/10.png)](#co_integrating_with_kubernetes_CO26-10)'
- en: If there is any critical error when closing, then stop the container
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在关闭时出现任何关键错误，则停止容器
- en: Discussion
  id: totrans-409
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: On the Java side, this is all you need to do; however, there are still some
    remaining parts, such as packaging and containerizing the operator, or defining
    the custom operator inside the cluster.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java端，这就是你需要做的一切；然而，还有一些未完成的部分，例如打包和容器化操作符，或者在集群中定义自定义操作符。
- en: The first thing to take into consideration when developing a Kubernetes Operator
    is that the communication with the Kubernetes API server is done through HTTPS,
    and this means that crypto libraries must be provided in the Docker image if they
    are not provided by default.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 开发Kubernetes Operator时首要考虑的事项是与Kubernetes API服务器的通信通过HTTPS进行，并且这意味着如果默认情况下未提供加密库，则必须在Docker镜像中提供它们。
- en: 'At the time of writing, the *Dockerfile.jvm* file provided by Quarkus does
    not contain the crypto libraries required to communicate to the Kubernetes server.
    To fix this, just open *src/main/docker/Dockerfile.jvm* and add the `nss` (Network
    Security Services) package:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Quarkus提供的*Dockerfile.jvm*文件中不包含与Kubernetes服务器通信所需的加密库。要解决这个问题，只需打开*src/main/docker/Dockerfile.jvm*文件并添加`nss`（Network
    Security Services）包：
- en: '[PRE49]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Then containerize the operator by running Maven and Docker:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 然后通过运行Maven和Docker将操作符容器化：
- en: '[PRE50]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Then register the custom resource definition into the Kubernetes cluster so
    that it is aware of the new kind, the scope of the custom resource, or the group
    name, among other things.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将自定义资源定义注册到Kubernetes集群中，以便它了解新资源类型、自定义资源的范围或组名称等信息。
- en: 'Create a new file at *src/main/kubernetes* with name *custom-resource-definition.yaml*
    that defines all the information required by the cluster to register a new resource:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为*custom-resource-definition.yaml*的文件，在*src/main/kubernetes*中定义所有集群注册新资源所需的信息：
- en: '[PRE51]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[![1](Images/1.png)](#co_integrating_with_kubernetes_CO27-1)'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_integrating_with_kubernetes_CO27-1)'
- en: '`plural` plus `group`'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '`plural` 加上 `group`'
- en: '[![2](Images/2.png)](#co_integrating_with_kubernetes_CO27-2)'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_integrating_with_kubernetes_CO27-2)'
- en: Sets the group of the custom resource (used in the `apiVersion` field of the
    custom resource)
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 设置自定义资源的组（用于自定义资源的 `apiVersion` 字段）
- en: '[![3](Images/3.png)](#co_integrating_with_kubernetes_CO27-3)'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_integrating_with_kubernetes_CO27-3)'
- en: Name of the `kind`
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '`kind` 的名称'
- en: '[![4](Images/4.png)](#co_integrating_with_kubernetes_CO27-4)'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](Images/4.png)](#co_integrating_with_kubernetes_CO27-4)'
- en: Name when the kind is a list of this custom resource
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 当种类是此自定义资源列表时的名称
- en: '[![5](Images/5.png)](#co_integrating_with_kubernetes_CO27-5)'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](Images/5.png)](#co_integrating_with_kubernetes_CO27-5)'
- en: The plural name
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 复数名字
- en: '[![6](Images/6.png)](#co_integrating_with_kubernetes_CO27-6)'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](Images/6.png)](#co_integrating_with_kubernetes_CO27-6)'
- en: The singular name
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 单数名字
- en: '[![7](Images/7.png)](#co_integrating_with_kubernetes_CO27-7)'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](Images/7.png)](#co_integrating_with_kubernetes_CO27-7)'
- en: Scope of the resource
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 资源的范围
- en: '[![8](Images/8.png)](#co_integrating_with_kubernetes_CO27-8)'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '[![8](Images/8.png)](#co_integrating_with_kubernetes_CO27-8)'
- en: The version of the resource (used in the `apiVersion` field of the custom resource)
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 资源的版本（用于自定义资源的 `apiVersion` 字段）
- en: 'And the last thing to create is a deployment file that deploys the operator.
    Create a new file named *deploy.yaml* at *src/main/kubernetes*:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要创建的是部署操作者的部署文件。在 *src/main/kubernetes* 下创建一个名为 *deploy.yaml* 的新文件：
- en: '[PRE52]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[![1](Images/1.png)](#co_integrating_with_kubernetes_CO28-1)'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_integrating_with_kubernetes_CO28-1)'
- en: Defines a cluster role for the role-based access control (RBAC) for Kubernetes
    resources
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 为 Kubernetes 资源的基于角色的访问控制（RBAC）定义了一个集群角色
- en: '[![2](Images/2.png)](#co_integrating_with_kubernetes_CO28-2)'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_integrating_with_kubernetes_CO28-2)'
- en: Adds rights to get, list, watch, create, update, delete, and patch pods
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了获取、列表、观察、创建、更新、删除和修补 Pod 的权限
- en: '[![3](Images/3.png)](#co_integrating_with_kubernetes_CO28-3)'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_integrating_with_kubernetes_CO28-3)'
- en: For the custom resource (`hellos.acme.org`), the required operations are `list`
    and `watch`
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 对于自定义资源（`hellos.acme.org`），所需的操作是 `list` 和 `watch`
- en: '[![4](Images/4.png)](#co_integrating_with_kubernetes_CO28-4)'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](Images/4.png)](#co_integrating_with_kubernetes_CO28-4)'
- en: An operator is deployed with a `Deployment`
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 操作者使用 `Deployment` 部署
- en: '[![5](Images/5.png)](#co_integrating_with_kubernetes_CO28-5)'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](Images/5.png)](#co_integrating_with_kubernetes_CO28-5)'
- en: Sets the service account linked to the cluster role defined in the file
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 设置与文件中定义的集群角色关联的服务帐户
- en: '[![6](Images/6.png)](#co_integrating_with_kubernetes_CO28-6)'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](Images/6.png)](#co_integrating_with_kubernetes_CO28-6)'
- en: Sets the container image containing the operator
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 设置包含操作者的容器镜像
- en: 'The last step before having the operator up and running is to apply all these
    created resources:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 在操作者启动之前的最后一步是应用所有这些创建的资源：
- en: '[PRE53]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The operator is now installed and running. To test the operator, just create
    a custom resource of kind `Hello` with the message to show:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 操作者现已安装并运行。要测试操作者，只需创建一种 `Hello` 种类的自定义资源，并提供要显示的消息：
- en: '[PRE54]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[![1](Images/1.png)](#co_integrating_with_kubernetes_CO29-1)'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_integrating_with_kubernetes_CO29-1)'
- en: Uses custom `kind` schema
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 使用自定义 `kind` 模式
- en: '[![2](Images/2.png)](#co_integrating_with_kubernetes_CO29-2)'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_integrating_with_kubernetes_CO29-2)'
- en: Sets the message to print
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 设置要打印的消息
- en: 'And apply it as follows:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 然后按如下方式应用：
- en: '[PRE55]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'When it’s completed, check the pod logs to validate that the message has been
    printed on the console:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，请检查 Pod 日志，验证消息是否已打印到控制台上：
- en: '[PRE56]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Although an operator and a custom resource are usually related, an operator
    without a custom resource definition is still possible—for example, to create
    a watcher class to intercept any event that affects a pod and apply some logic.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管操作者和自定义资源通常是相关的，但没有自定义资源定义的操作者仍然是可能的——例如，创建一个监视器类来拦截影响 Pod 的任何事件并应用一些逻辑。
- en: See Also
  id: totrans-462
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'To learn more about operators, check out the following websites:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于操作者的信息，请查看以下网站：
- en: '[CoreOS: Operators](https://oreil.ly/NV2dN)'
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[CoreOS：Operators](https://oreil.ly/NV2dN)'
- en: '[Kubernetes: Operator pattern](https://oreil.ly/6Z77K)'
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Kubernetes：操作者模式](https://oreil.ly/6Z77K)'
- en: 10.12 Deploying and Managing Serverless Workloads with Knative
  id: totrans-466
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10.12 使用 Knative 部署和管理无服务器工作负载
- en: Problem
  id: totrans-467
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to deploy and manage serverless workloads.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 您想要部署和管理无服务器工作负载。
- en: Solution
  id: totrans-469
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use Knative, the Kubernetes-based platform to deploy and manage modern serverless
    workloads.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Knative，基于 Kubernetes 的平台，部署和管理现代无服务器工作负载。
- en: The `quarkus-kubernetes` extension provides support for generating Knative resources
    automatically with sane defaults and optional user-supplied configuration.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '`quarkus-kubernetes` 扩展提供了自动生成 Knative 资源的支持，具有合理的默认设置和可选的用户提供的配置。'
- en: 'To enable the generation of Kubernetes resources, you need to register the
    `quarkus-kubernetes` extension:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用 Kubernetes 资源的生成，您需要注册 `quarkus-kubernetes` 扩展：
- en: '[PRE57]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: For this example, the `quarkus-container-image-docker` extension is used to
    build the container image using `docker` binary, so the image is built directly
    inside the `minikube` cluster and registered inside the internal registry, so
    no external registry is required.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本示例，使用 `quarkus-container-image-docker` 扩展来使用 `docker` 二进制文件构建容器镜像，因此镜像直接在
    `minikube` 集群内构建并在内部注册表中注册，因此不需要外部注册表。
- en: You need to run `eval $(minikube docker-env)` to configure `docker` to use the
    minikube docker host.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要运行 `eval $(minikube docker-env)` 来配置 `docker` 使用 minikube docker 主机。
- en: 'Then you need to set the `quarkus.kubernetes.deployment-target` property to
    `knative` and set it to build a Docker container during package phase, among other
    configuration properties regarding container image creation:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您需要将 `quarkus.kubernetes.deployment-target` 属性设置为 `knative`，并在打包阶段设置为构建 Docker
    容器，以及其他有关容器镜像创建的配置属性：
- en: '[PRE58]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[![1](Images/1.png)](#co_integrating_with_kubernetes_CO30-1)'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_integrating_with_kubernetes_CO30-1)'
- en: Sets target deployment to `knative`
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 将目标部署设置为 `knative`
- en: '[![2](Images/2.png)](#co_integrating_with_kubernetes_CO30-2)'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_integrating_with_kubernetes_CO30-2)'
- en: Builds the container image with `lordofthejars` group
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `lordofthejars` 组构建容器镜像
- en: '[![3](Images/3.png)](#co_integrating_with_kubernetes_CO30-3)'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_integrating_with_kubernetes_CO30-3)'
- en: Sets to `dev.local` when deploying local container images
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 在部署本地容器镜像时设置为 `dev.local`
- en: The Knative controller resolves image tags to digests in order to guarantee
    the immutability of revisions. This works well when using a normal registry; however,
    it can cause problems when used with minikube and local images.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: Knative 控制器将图像标签解析为摘要，以确保修订版本的不可变性。 当使用普通注册表时，这很有效； 但是，当与 minikube 和本地图像一起使用时，可能会导致问题。
- en: By default, the Knative controller skips resolving digests with images prefixed
    with `dev.local` or `ko.local`. If you are running this example in minikube, you
    must set the registry property to any of these two options to make Knative find
    the images to deploy.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Knative 控制器会跳过以 `dev.local` 或 `ko.local` 为前缀的图像的摘要。 如果您在 minikube 中运行此示例，则必须将注册表属性设置为其中的任何一个选项，以使
    Knative 找到要部署的图像。
- en: 'To generate the Kubernetes resources, execute in a new terminal `./mvnw package`.
    Then, among the usual files generated by the build tool in the *target* directory,
    two new files are created inside the *target/kubernetes* directory named *knative.json*
    and *knative.yaml* containing a Knative service definition:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成 Kubernetes 资源，请在新终端中执行 `./mvnw package`。 然后，在 *target* 目录中构建工具生成的常规文件中，会在
    *target/kubernetes* 目录内创建两个名为 *knative.json* 和 *knative.yaml* 的新文件，其中包含 Knative
    服务定义：
- en: '[PRE59]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Then deploy the generated Knative service:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 然后部署生成的 Knative 服务：
- en: '[PRE60]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'It can take a few seconds to move the `ready` state from `Unknown` to `True`.
    If there is a failure, which means that `ready` state remains in `false`, you
    can check the reason and the sequence of events by running the following:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `Unknown` 状态移动到 `True` 状态可能需要几秒钟的时间。 如果出现失败，也就是 `ready` 状态仍然为 `false`，您可以通过运行以下命令来检查原因和事件序列：
- en: '[PRE61]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'To test that the service has been deployed correctly, open a new terminal window
    and do a port forward between the local machine and Knative gateway:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试服务是否已正确部署，请打开一个新的终端窗口，并在本地机器和 Knative 网关之间进行端口转发：
- en: '[PRE62]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Notice that this is required only because the service is deployed in minikube.
    Depending on the Kubernetes platform on which you are deploying the service, you
    might need to do different things.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这仅在服务部署在 minikube 中时才需要。 根据您部署服务的 Kubernetes 平台的不同，您可能需要执行不同的操作。
- en: 'Finally, you can send a request to the service:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以向服务发送请求：
- en: '[PRE63]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'To undeploy the example, you need to run the following:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 要取消部署示例，您需要运行以下命令：
- en: '[PRE64]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Discussion
  id: totrans-499
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: You can combine the `container-image` and `kubernetes` extensions to build the
    container image and push it to Kubernetes automatically, as shown in [Recipe 10.6](#build-deploy-container-image-automatically),
    so no manual steps are required.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将 `container-image` 和 `kubernetes` 扩展组合起来，自动构建容器镜像并将其推送到 Kubernetes，如[配方
    10.6](#build-deploy-container-image-automatically)所示，因此无需手动步骤。
- en: See Also
  id: totrans-501
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'To learn more, visit the following web pages:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多，请访问以下网页：
- en: '[Knative Serving](https://oreil.ly/RBv52)'
  id: totrans-503
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Knative Serving](https://oreil.ly/RBv52)'
- en: '[GitHub: Kourier](https://oreil.ly/3bSDL)'
  id: totrans-504
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[GitHub: Kourier](https://oreil.ly/3bSDL)'
