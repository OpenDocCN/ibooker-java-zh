["```java\npublic class Array1  {\n    @SuppressWarnings(\"unused\")\n    public static void main(String[] argv) {\n        int[] monthLen1;            // declare a reference\n        monthLen1 = new int[12];        // construct it\n        int[] monthLen2 = new int[12];    // short form\n        // even shorter is this initializer form:\n        int[] monthLen3 = {\n                31, 28, 31, 30,\n                31, 30, 31, 31,\n                30, 31, 30, 31,\n        };\n\n        final int MAX = 10;\n        LocalDate[] days = new LocalDate[MAX];\n        for (int i=0; i<MAX; i++) {\n            days[i] = LocalDate.of(2022, 02, i + 1);\n        }\n\n        // Two-Dimensional Arrays\n        // Want a 10-by-24 array\n        int[][] me = new int[10][];\n        for (int i=0; i<10; i++)\n            me[i] = new int[24];\n\n        // Remember that an array has a \".length\" attribute\n        System.out.println(me.length);\n        System.out.println(me[0].length);\n\n    }\n}\n```", "```java\npublic class Array2  {\n    public final static int INITIAL = 10,   ![1](assets/1.png)\n        GROW_FACTOR = 2;                    ![2](assets/2.png)\n\n    public static void main(String[] argv) {\n        int nDates = 0;\n        LocalDateTime[] dates = new LocalDateTime[INITIAL];\n        StructureDemo source = new StructureDemo(21);\n        LocalDateTime c;\n        while ((c=source.getDate()) != null) {\n\n            // if (nDates >= dates.length) {\n            //     throw new RuntimeException(\n            //         \"Too Many Dates! Simplify your life!!\");\n            // } \n            // better: reallocate, making data structure dynamic\n            if (nDates >= dates.length) {\n                LocalDateTime[] tmp =\n                    new LocalDateTime[dates.length * GROW_FACTOR];\n                System.arraycopy(dates, 0, tmp, 0, dates.length);\n                dates = tmp;    // copies the array reference\n                // old array will be garbage collected soon...\n            }\n            dates[nDates++] = c;\n        }\n        System.out.println(\"Final array size = \" + dates.length);\n    }\n}\n```", "```java\nList<String> myList = new ArrayList<>();\n```", "```java\nvar myList = new ArrayList<String>();\n```", "```java\npublic class ArrayListDemo {\n    public static void main(String[] argv) {\n        List<LocalDate> editions = new ArrayList<>();\n\n        // Add lots of elements to the ArrayList...\n        editions.add(LocalDate.of(2001, 06, 01));\n        editions.add(LocalDate.of(2004, 06, 01));\n        editions.add(LocalDate.of(2014, 06, 20));\n\n        // Use old-style 'for' loop to get index number.\n        System.out.println(\"Retrieving by index:\");\n        for (int i = 0; i<editions.size(); i++) {\n            System.out.printf(\"Edition %d was %s\\n\", i + 1, editions.get(i));\n        }\n        // Use normal 'for' loop for simpler access\n        System.out.println(\"Retrieving by Iterable:\");\n        for (LocalDate dt : editions) {\n            System.out.println(\"Edition \" + dt);\n        }\n\n    }\n}\n```", "```java\nList<String> firstNames = List.of(\"Robin\", \"Jaime\", \"Joey\");\n```", "```java\nList<String> lastNames = Arrays.asList(\"Smith\", \"Jones\", \"MacKenzie\");\n// or even\nList<String> lastNames =\n    Arrays.asList(new String[]{\"Smith\", \"Jones\", \"MacKenzie\"});\n```", "```java\nMap<Person, Address> addressMap = new HashMap<>();\n```", "```java\npublic class MyStack<T> implements SimpleStack<T> {\n\n    private int depth = 0;\n    public static final int DEFAULT_INITIAL = 10;\n    private T[] stack;\n\n    public MyStack() {\n        this(DEFAULT_INITIAL);\n    }\n\n    public MyStack(int howBig) {\n        if (howBig <= 0) {\n            throw new IllegalArgumentException(\n            howBig + \" must be positive, but was \" + howBig);\n        }\n        stack = (T[])new Object[howBig];\n    }\n\n    @Override\n    public boolean empty() {\n        return depth == 0;\n    }\n\n    /** push - add an element onto the stack */\n    @Override\n    public void push(T obj) {\n        // Could check capacity and expand\n        stack[depth++] = obj;\n    }\n\n    /* pop - return and remove the top element */\n    @Override\n    public T pop() {\n        --depth;\n        T tmp = stack[depth];\n        stack[depth] = null;\n        return tmp;\n    }\n\n    /** peek - return the top element but don't remove it */\n    @Override\n    public T peek() {\n        if (depth == 0) {\n            return null;\n        }\n        return stack[depth-1];\n    }\n\n    public boolean hasNext() {\n        return depth > 0;\n    }\n\n    public boolean hasRoom() {\n        return depth < stack.length;\n    }\n\n    public int getStackDepth() {\n        return depth;\n    }\n}\n```", "```java\nMyStack<BankAccount> theAccounts = new MyStack<>( );\n```", "```java\npublic class MyStackDemo {\n\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n    public static void main(String[] args) {\n        MyStack<String> ms1 = new MyStack<>();\n        ms1.push(\"billg\");\n        ms1.push(\"scottm\");\n\n        while (ms1.hasNext()) {\n            String name = ms1.pop();\n            System.out.println(name);\n        }\n\n        // Old way of using Collections: not type safe.\n        // DO NOT GENERICIZE THIS\n        MyStack ms2 = new MyStack();\n        ms2.push(\"billg\");               // EXPECT WARNING\n        ms2.push(\"scottm\");              // EXPECT WARNING\n        ms2.push(new java.util.Date());  // EXPECT WARNING\n\n        // Show that it is broken\n        try {\n            String bad = (String)ms2.pop();\n            System.err.println(\"Didn't get expected exception, popped \" + bad);\n        } catch (ClassCastException ex) {\n            System.out.println(\"Did get expected exception.\");\n        }\n\n        // Removed the brokenness, print rest of it.\n        while (ms2.hasNext()) {\n            String name = (String)ms2.pop();\n            System.out.println(name);\n        }\n    }\n}\n```", "```java\nC:> javac -source 1.5 structure/MyStackDemo.java\nNote: MyStackDemo.java uses unchecked or unsafe operations.\nNote: Recompile with -Xlint:unchecked for details.\nC:> javac -source 1.5 -Xlint:unchecked structure/MyStackDemo.java\nMyStackDemo.java:14: warning: unchecked call to push(T) as a member of the raw\ntype MyStack\n                ms2.push(\"billg\");\n                   ^\nMyStackDemo.java:15: warning: unchecked call to push(T) as a member of the raw\ntype MyStack\n                ms2.push(\"scottm\");\n                   ^\nMyStackDemo.java:16: warning: unchecked call to push(T) as a member of the raw\ntype MyStack\n                ms2.push(new java.util.Date( ));\n                   ^\n3 warnings\nC:>\n```", "```java\n$ jshell\njshell> import java.io.*;\njshell> BufferedReader is =\n  new BufferedReader(new FileReader(\"/home/ian/.profile\"));\nis ==> java.io.BufferedReader@58651fd0\njshell> is.lines().forEach(System.out::println)\n... prints the lines of the file ...\n```", "```java\npublic class IterableForEach {\n\n    public static void main(String[] args) {\n        Collection<String> c =                    ![1](assets/1.png)\n                List.of(\"One\", \"Two\", \"Three\");   ![2](assets/2.png)\n        c.forEach(s -> System.out.println(s));    ![3](assets/3.png)\n    }\n}\n```", "```java\nfor (Type var : Iterable<Type>) {\n\t// do something with \"var\"\n}\n```", "```java\npublic interface java.util.Iterator<E> {\n  public abstract boolean hasNext();\n  public abstract E next();\n  public default void remove();\n}\n```", "```java\nIterator it = ...; // legacy code; might not even have type parameter\nwhile (it.hasNext()) {\n\t(MyDataType) c = it.next();\n\t// Do something with c\n}\n```", "```java\npublic default void forEachRemaining(java.util.function.Consumer<? super E>);\n```", "```java\nfor (init; test; change) {\n\t// do something\n}\n```", "```java\nMyDataType[] data = ...\nfor (int i = 0; i < data.length; i++)\n\tMyDataType d = data[i];\n\t// do something with it\n}\n```", "```java\nIterator<MyData> iterator = ...\nwhile (iterator.hasNext()) {\n\tMyData md = iterator.next();\n\t//\n}\n```", "```java\n        Set<String> hashSet = new HashSet<>();\n        hashSet.add(\"One\");\n        hashSet.add(\"Two\");\n        hashSet.add(\"One\"); // DUPLICATE\n        hashSet.add(\"Three\");\n        hashSet.forEach(s -> System.out.println(s));\n```", "```java\nSet<Double> nums = Set.of(Math.PI, 22D/7, Math.E);\nSet<String> firstNames = Set.of(\"Robin\", \"Jaime\", \"Joey\");\n```", "```java\npublic class LinkedListDemo {\n    public static void main(String[] argv) {\n        System.out.println(\"Here is a demo of Java's LinkedList class\");\n        LinkedList<String> l = new LinkedList<>();\n        l.add(new Object().toString());\n        l.add(\"Hello\");\n        l.add(\"end of the list\");\n\n        System.out.println(\"Here is a list of all the elements\");\n        l.forEach(o ->\n            System.out.println(\"Next element: \" + o));\n\n        if (l.indexOf(\"Hello\") < 0)\n            System.err.println(\"Lookup does not work\");\n        else\n            System.err.println(\"Lookup works\");\n\n        // Now, for added fun, let's walk the linked list backwards.\n        ListIterator<String> li = l.listIterator();\n        while (li.hasPrevious()) {\n            System.out.println(\"Back to: \" + li.previous());\n        }\n    }\n}\n```", "```java\npublic class LinkList<T> implements List<T> {\n\n    /* A TNode stores one node or item in a Linked List */\n    private static class TNode<T> {\n        private TNode<T> next;\n        private T data;\n        TNode(T o, TNode<T> next) {\n            data = o;\n            this.next = next;\n        }\n        @Override\n        public String toString() {\n            return String.format(\"TNode: data='%s', next='%d'\", data,\n                    next == null ? 0 : next.hashCode());\n        }\n    }\n\n    private boolean DIAGNOSTIC = false;\n\n    /** The root or first TNode in the list; is a dummy pointer,\n * so its data will always be null. Simpler this way.\n */\n    protected TNode<T> first;\n    /**\n * For certain optimizations: A second ref to the last TNode in the list;\n * initially == first; always valid (never null), always has next == null.\n */\n    protected TNode<T> last;\n\n    /** Construct a LinkList: initialize the first and last nodes */\n    public LinkList() {\n        clear();\n    }\n\n    /** Construct a LinkList given another Collection.\n * This method is recommended by the general contract of List.\n */\n    public LinkList(Collection<T> c) {\n        this();\n        addAll(c);\n    }\n\n    /** Set the List (back) to its initial state.\n * Any references held will be discarded.\n */\n    @Override\n    public void clear() {\n        first = new TNode<T>(null, null);\n        last = first;\n    }\n\n    /** Add one object to the end of the list. Update the \"next\"\n * reference in the previous end, to refer to the new node.\n * Update \"last\" to refer to the new node.\n */\n    @Override\n    public boolean add(T o) {\n        last.next = new TNode<T>(o, null);\n        last = last.next;\n        return true;\n    }\n\n    @Override\n    public void add(int where, T o) {\n        TNode<T> t = first;\n        for (int i=0; i<=where; i++) {\n            t = t.next;\n            if (t == null) {\n                throw new IndexOutOfBoundsException(\n                    \"'add(n,T) went off end of list\");\n            }\n            if (DIAGNOSTIC) {\n                System.out.printf(\"in add(int,T): i = %d, t = %s%n\", i, t);\n            }\n        }\n        if (DIAGNOSTIC) {\n            System.out.printf(\"in add(int,T): to insert before %s\\n\", t);\n        }\n        final TNode<T> nn = new TNode<>(o, t.next);\n        t.next = nn;\n        if (DIAGNOSTIC) {\n            System.out.printf(\"add(%d,%s)\\n\", where, o);\n            dump(\"add(int,T)\");\n        }\n    }\n\n    @Override\n    public boolean addAll(Collection<? extends T> c) {\n        c.forEach(o -> add((T) o));\n        return false;\n    }\n\n    @Override\n    public boolean addAll(int i, Collection<? extends T> c) {\n        AtomicInteger j = new AtomicInteger(i);\n        c.forEach(o -> { add(j.getAndIncrement(), o); });\n        return true;\n    }\n\n    @Override\n    public boolean contains(Object o) {\n        TNode<T> t = first;\n        while ((t = t.next) != null) {\n            if (t.data.equals(o)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    @Override\n    public T get(int where) {\n        TNode<T> t = first;\n        int i=0;\n        // If we get to the end of list before 'where', error out\n        while (i++<=where) {\n            if (t.next == null) {\n                throw new IndexOutOfBoundsException();\n            }\n            t = t.next;\n        }\n        return t.data;\n    }\n\n    @Override\n    public boolean isEmpty() {\n        return first == last;\n    }\n\n    public Iterator<T> iterator() {\n        return new Iterator<T>() {\n            final int size = size();\n            int n = 0;\n            TNode<T> t = first;\n            /**\n * Two cases in which next == null:\n * 1) The list is empty, we are at first\n * 2) The list is not empty, we are at last.\n */\n            public boolean hasNext() {\n                return n < size;\n            }\n\n            public T next() {\n                if (t == first) {\n                    t = t.next;\n                }\n                TNode<T> result = t;\n                t = t.next;\n                ++n;\n                return result.data;\n            }\n            public void remove() {\n                throw new UnsupportedOperationException(\"remove\");\n            }\n        };\n    }\n\n    @Override\n    public boolean remove(Object o) {\n        TNode<T> p = first, prev = null;\n        while (p != null) {\n            if (p.data == o) {\n                prev.next = p.next;\n                return true;\n            }\n            prev = p; p = p.next;\n        }\n        return false;\n    }\n\n    @Override\n    public T set(int i, T o) {\n        TNode<T> tmp = find(i);\n        tmp.data = o;\n        return o;\n    }\n\n    @Override\n    public int size() {\n        TNode<T> t = first;\n        int i;\n        for (i=0; ; i++) {\n            if (t == null)\n                break;\n            t = t.next;\n        }\n        return i - 1;    // subtract one for mandatory head node\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public T[] toArray(Object[] data) {\n        // First is an empty anchor, start at its next\n        TNode<T> p = first.next;\n        for (int i = 0; p != null && i < data.length; i++) {\n            data[i] = p.data;\n            p = p.next;\n        }\n        return (T[]) data;\n    }\n\n    public Object[] toArray() {\n        Object[] data = new Object[size()];\n        return toArray(data);\n    }\n```", "```java\npublic class HashMapDemo {\n\n    public static void main(String[] argv) {\n\n        // Construct and load the hash. This simulates loading a\n        // database or reading from a file, or wherever the data is.\n\n        Map<String,String> map = new HashMap<String,String>();\n\n        // The hash maps from company name to address.\n        // In real life this might map to an Address object...\n        map.put(\"Adobe\", \"Mountain View, CA\");\n        map.put(\"IBM\", \"White Plains, NY\");\n        map.put(\"Learning Tree\", \"Los Angeles, CA\");\n        map.put(\"Microsoft\", \"Redmond, WA\");\n        map.put(\"Netscape\", \"Mountain View, CA\");\n        map.put(\"O'Reilly\", \"Sebastopol, CA\");\n        map.put(\"Sun\", \"Mountain View, CA\");\n\n        // Two versions of the \"retrieval\" phase.\n        // Version 1: get one pair's value given its key\n        // (presumably the key would really come from user input):\n        String queryString = \"O'Reilly\";\n        System.out.println(\"You asked about \" + queryString + \".\");\n        String resultString = map.get(queryString);\n        System.out.println(\"They are located in: \" + resultString);\n        System.out.println();\n\n        // Version 2: get ALL the keys and values\n        // (maybe to print a report, or to save to disk)\n        for( String key : map.keySet()) {\n            System.out.println(\"Key \" + key +\n                \"; Value \" + map.get(key));\n        }\n\n        // Version 3: Same but using a Map.Entry lambda\n        map.entrySet().forEach(mE ->\n            System.out.println(\"Key + \" + mE.getKey()+\n                \"; Value \" +mE.getValue()));\n    }\n}\n```", "```java\n        // Version 2: get ALL the keys and values\n        // with concurrent modification\n        Iterator<String> it = map.keySet().iterator();\n        while (it.hasNext()) {\n            String key = it.next();\n            if (key.equals(\"Sun\") || key.equals(\"Netscape\")) {\n                it.remove();\n                continue;\n            }\n            System.out.println(\"Company \" + key + \"; \" +\n                \"Address \" + map.get(key));\n        }\n```", "```java\n        // Alternate to just do the removals, without explicit looping\n        map.keySet().removeIf(key -> Set.of(\"Netscape\", \"Sun\").contains(key));\n        // or\n        map .entrySet()\n            .removeIf(entry -> Set.of(\"Netscape\", \"Sun\")\n            .contains(entry.getKey()));\n        map.entrySet().forEach(System.out::println);\n```", "```java\npublic class PrefsDemo {\n\n    public static void main(String[] args) throws Exception {\n\n        // Set up the Preferences for this application, by class.\n        Preferences prefs = Preferences.userNodeForPackage(PrefsDemo.class);\n\n        // Retrieve some preferences previously stored, with defaults in case\n        // this is the first run.\n        String text    = prefs.get(\"textFontName\", \"lucida-bright\");\n        String display = prefs.get(\"displayFontName\", \"lucida-blackletter\");\n        System.out.println(text);\n        System.out.println(display);\n\n        // Assume the user chose new preference values: Store them back.\n        prefs.put(\"textFontName\", \"times-roman\");\n        prefs.put(\"displayFontName\", \"helvetica\");\n\n        // Toss in a couple more values for the curious who want to look\n        // at how Preferences values are actually stored.\n        Preferences child = prefs.node(\"a/b\");\n        child.putInt(\"meaning\", 42);\n        child.putDouble(\"pi\", Math.PI);\n\n        // And dump the subtree from our first node on down, in XML.\n        prefs.exportSubtree(System.out);\n    }\n}\n```", "```java\n$ java -cp target/classes structure.PrefsDemo\nlucida-bright\nlucida-blackletter\n<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n<!DOCTYPE preferences SYSTEM \"http://java.sun.com/dtd/preferences.dtd\">\n<preferences EXTERNAL_XML_VERSION=\"1.0\">\n  <root type=\"user\">\n    <map/>\n    <node name=\"structure\">\n      <map>\n        <entry key=\"displayFontName\" value=\"helvetica\"/>\n        <entry key=\"textFontName\" value=\"times-roman\"/>\n      </map>\n      <node name=\"a\">\n        <map/>\n        <node name=\"b\">\n          <map>\n            <entry key=\"meaning\" value=\"42\"/>\n            <entry key=\"pi\" value=\"3.141592653589793\"/>\n          </map>\n        </node>\n      </node>\n    </node>\n  </root>\n</preferences>\n```", "```java\n> java structure.PrefsDemo\ntimes-roman\nhelvetica\n...\n>\n```", "```java\n# Default properties for MenuIntl\nprogram.title=Demonstrate I18N (MenuIntl)\nprogram.message=Welcome to an English-localized Java Program\n#\n# The File Menu\n#\nfile.label=File Menu\nfile.new.label=New File\nfile.new.key=N\nfile.open.label=Open...\nfile.open.key=O\nfile.save.label=Save\nfile.save.key=S\nfile.exit.label=Exit\nfile.exit.key=Q\n```", "```java\nname=Ian Darwin\nfavorite_popsicle=cherry\nfavorite_rock group=Fleetwood Mac\nfavorite_programming_language=Java\npencil_color=green\n```", "```java\n# Here is a list of properties\n! first, my name\nname Ian Darwin\nfavorite_popsicle = cherry\nfavorite_rock\\ group \\\n Fleetwood Mac\nfavorite_programming_language=Java\npencil_color green\n```", "```java\nkey=value\n```", "```java\npublic class PropsCompanies {\n\n    public static void main(String[] argv) throws java.io.IOException {\n\n        Properties props = new Properties();\n\n        // Get my data\n        props.put(\"Adobe\", \"Mountain View, CA\");\n        props.put(\"IBM\", \"White Plains, NY\");\n        props.put(\"Learning Tree\", \"Los Angeles, CA\");\n        props.put(\"Microsoft\", \"Redmond, WA\");\n        props.put(\"Netscape\", \"Mountain View, CA\");\n        props.put(\"O'Reilly\", \"Sebastopol, CA\");\n        props.put(\"Sun\", \"Mountain View, CA\");\n\n        // Now load additional properties\n        props.load(System.in);\n\n        // List merged properties, using System.out\n        props.list(System.out);\n    }\n}\n```", "```java\njava structure.PropsCompanies < PropsDemo.out\n\n```", "```java\n-- listing properties --\nSony=Japan\nSun=Mountain View, CA\nIBM=White Plains, NY\nNetscape=Mountain View, CA\nNippon_Kogaku=Japan\nAcorn=United Kingdom\nAdobe=Mountain View, CA\nEricsson=Sweden\nO'Reilly & Associates=Sebastopol, CA\nLearning Tree=Los Angeles, CA\n```", "```java\nimport com.darwinsys.util.FileProperties;\n...\nProperties p = new FileProperties(\"PropsDemo.out\");\n```", "```java\npublic class SortArray {\n    public static void main(String[] unused) {\n        String[] strings = {\n            \"painful\",\n            \"mainly\",\n            \"gaining\",\n            \"raindrops\"\n        };\n        Arrays.sort(strings);\n        for (int i=0; i<strings.length; i++) {\n            System.out.println(strings[i]);\n        }\n    }\n}\n```", "```java\n/** Comparator for comparing strings ignoring first character.\n */\npublic class SubstringComparator implements Comparator<String> {\n    @Override\n    public int compare(String s1, String s2) {\n        s1 = s1.substring(1);\n        s2 = s2.substring(1);\n        return s1.compareTo(s2);\n        // or, more concisely:\n        // return s1.substring(1).compareTo(s2.substring(1));\n    }\n}\n```", "```java\npublic class SubstringComparatorDemo {\n    public static void main(String[] unused) {\n        String[] strings = {\n            \"painful\",\n            \"mainly\",\n            \"gaining\",\n            \"raindrops\"\n        };\n        Arrays.sort(strings);\n        dump(strings, \"Using Default Sort\");\n        Arrays.sort(strings, new SubstringComparator());\n        dump(strings, \"Using SubstringComparator\");\n\n        // tag::functional[]\n        System.out.println(\"Functional approach:\");\n        Arrays.stream(strings)\n            .sorted(Comparator.comparing(s->s.substring(1)))\n            .forEach(System.out::println);\n        // end::functional[]\n    }\n\n    static void dump(String[] args, String title) {\n        System.out.println(title);\n        for (String s : args)\n            System.out.println(s);\n    }\n}\n```", "```java\n        System.out.println(\"Functional approach:\");\n        Arrays.stream(strings)\n            .sorted(Comparator.comparing(s->s.substring(1)))\n            .forEach(System.out::println);\n```", "```java\n$ java structure.SubstrCompDemo\nUsing Default Sort\ngaining\nmainly\npainful\nraindrops\nUsing SubstringComparator\nraindrops\npainful\ngaining\nmainly\n```", "```java\n// public class Appt implements Comparable {\n    // Much code and variables omitted - see online version\n    //-----------------------------------------------------------------\n    //    METHODS - COMPARISON\n    //-----------------------------------------------------------------\n    /** compareTo method, from Comparable interface.\n * Compare this Appointment against another, for purposes of sorting.\n * <P>Only date and time, then text, participate, not repetition!\n * (Repetition has to do with recurring events, e.g.,\n *  \"Meeting every Tuesday at 9\").\n * This methods is consistent with equals().\n * @return -1 if this<a2, +1 if this>a2, else 0.\n */\n    @Override\n    public int compareTo(Appt a2) {\n        // If dates not same, trigger on their comparison\n        int dateComp = date.compareTo(a2.date);\n        if (dateComp != 0)\n            return dateComp;\n        // Same date. If times not same, trigger on their comparison\n        if (time != null && a2.time != null) {\n            // Neither time is null\n            int timeComp = time.compareTo(a2.time);\n            if (timeComp != 0)\n                return timeComp;\n        } else /* At least one time is null */ {\n            if (time == null && a2.time != null) {\n                return -1; // All-day appts sort low to appear first\n            } else if (time != null && a2.time == null)\n                return +1;\n                // else both have no time set, so carry on\n        }\n        // Same date & time, trigger on text\n        return text.compareTo(a2.text);\n    }\n\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + ((date == null) ? 0 : date.hashCode());\n        result = prime * result + ((text == null) ? 0 : text.hashCode());\n        result = prime * result + ((time == null) ? 0 : time.hashCode());\n        return result;\n    }\n\n    @Override\n    public boolean equals(Object o2) {\n        if (this == o2)\n            return true;\n        if (o2.getClass() != Appt.class)\n            return false;\n        Appt a2 = (Appt) o2;\n        if (!date.equals(a2.date))\n            return false;\n        if (time != null && !time.equals(a2.time))\n            return false;\n        return text.equals(a2.text);\n    }\n\n    /** Return a String representation of this Appt.\n * Output is intended for debugging, not presentation!\n */\n    @Override\n    public String toString() {\n        var sb = new StringBuilder();\n        sb.append(date).append(' ');\n        if (time != null) {\n            sb.append(time.getHour())\n            .append(':')\n            .append(time.getMinute())\n            .append(' ');\n        } else {\n            sb.append(\"(All day)\").append(' ');\n        }\n        sb.append(text).toString();\n        return sb.toString();\n    }\n```", "```java\npublic class CallTrack {\n\n    /** The list of Person objects. */\n    protected List<Person> usrList = new ArrayList<>();\n\n    /** The scrolling list */\n    protected java.awt.List visList = new java.awt.List();\n\n    /** Add one (new) Person to the list, keeping the list sorted. */\n    protected void add(Person p) {\n        String lastName = p.getLastName();\n        int i;\n        // Find in \"i\" the position in the list where to insert this person\n        for (i=0; i<usrList.size(); i++)\n            if (lastName.compareTo((usrList.get(i)).getLastName()) <= 0)\n                break; // If we don't break, OK, will insert at end of list.\n        usrList.add(i, p);\n\n        // Now insert them in the scrolling list, in the same position.\n        visList.add(p.getFullName(), i);\n        visList.select(i);      // ensure current\n    }\n\n}\n```", "```java\n        // A TreeSet keeps objects in sorted order. Use a Comparator\n        // published by String for case-insensitive sorting order.\n        TreeSet<String> theSet = new TreeSet<>(String.CASE_INSENSITIVE_ORDER);\n        theSet.add(\"Gosling\");\n        theSet.add(\"da Vinci\");\n        theSet.add(\"van Gogh\");\n        theSet.add(\"Java To Go\");\n        theSet.add(\"Vanguard\");\n        theSet.add(\"Darwin\");\n        theSet.add(\"Darwin\");    // TreeSet is Set, ignores duplicates.\n\n        System.out.printf(\"Our set contains %d elements\", theSet.size());\n\n        // Since it is sorted we can easily get various subsets\n        System.out.println(\"Lowest (alphabetically) is \" + theSet.first());\n\n        // Print how many elements are greater than \"k\"\n        // Should be 2 - \"van Gogh\" and \"Vanguard\"\n        System.out.println(theSet.tailSet(\"k\").toArray().length +\n            \" elements higher than \\\"k\\\"\");\n\n        // Print the whole list in sorted order\n        System.out.println(\"Sorted list:\");\n        theSet.forEach(name -> System.out.println(name));\n```", "```java\nTreeMap sorted = new TreeMap(unsortedHashMap);\n```", "```java\npublic class ArrayHunt  {\n    /** the maximum (and actual) number of random ints to allocate */\n    protected final static int MAX    = 4000;\n    /** the value to look for */\n    protected final static int NEEDLE = 1999;\n    int[] haystack;\n    Random r;\n\n    public static void main(String[] argv) {\n        ArrayHunt h = new ArrayHunt();\n        if (argv.length == 0)\n            h.play();\n        else {\n            int won = 0;\n            int games = Integer.parseInt(argv[0]);\n            for (int i=0; i<games; i++)\n                if (h.play())\n                    ++won;\n            System.out.println(\"Computer won \" + won +\n                \" out of \" + games + \".\");\n        }\n    }\n\n    /** Construct the hunting ground */\n    public ArrayHunt() {\n        haystack = new int[MAX];\n        r = new Random();\n    }\n\n    /** Play one game. */\n    public boolean play() {\n        int i;\n\n        // Fill the array with random data (hay?)\n        for (i=0; i<MAX; i++) {\n            haystack[i] = (int)(r.nextFloat() * MAX);\n        }\n\n        // Precondition for binary search is that data be sorted!\n        Arrays.sort(haystack);\n\n        // Look for needle in haystack\n        i = Arrays.binarySearch(haystack, NEEDLE);\n\n        if (i >= 0) {        // Found it, we win.\n            System.out.println(\"Value \" + NEEDLE +\n                \" occurs at haystack[\" + i + \"]\");\n            return true;\n        } else {        // Not found, we lose.\n            System.out.println(\"Value \" + NEEDLE +\n                \" does not occur in haystack; nearest value is \" +\n                haystack[-(i+2)] + \" (found at \" + -(i+2) + \")\");\n            return false;\n        }\n    }\n}\n```", "```java\n        List<String> list = new ArrayList<>();\n        list.add(\"Blobbo\");\n        list.add(\"Cracked\");\n        list.add(\"Dumbo\");\n\n        // Convert a collection to Object[], which can store objects\n        // of any type.\n        Object[] ol = list.toArray();\n        System.out.println(\"Array of Object has length \" + ol.length);\n\n        String[] sl = (String[]) list.toArray(new String[0]);\n        System.out.println(\"Array of String has length \" + sl.length);\n```", "```java\npublic class IterableDemo {\n\n    /** Demo implements Iterable, meaning it must provide an Iterator,\n * and that it can be used in a foreach loop.\n */\n    static class Demo implements Iterable<String> {\n\n        // Simple demo: use array instead of inventing new data structure\n        String[] data = { \"One\", \"Two\", \"Three\"};\n\n        /** This is the Iterator that makes it all happen */\n        class DemoIterator implements Iterator<String> {\n            int i = 0;\n\n            /**\n * Tell if there are any more elements.\n * @return true if next() will succeed, false otherwise\n */\n            public boolean hasNext() {\n                return i < data.length;\n            }\n\n            /** @return the next element from the data */\n            public String next() {\n                return data[i++];\n            }\n\n            /** Remove the object that next() just returned.\n * An Iterator is not required to support this interface, and we don't.\n * @throws UnsupportedOperationException unconditionally\n */\n            public void remove() {\n                throw new UnsupportedOperationException(\"remove\");\n            }\n        }\n\n        /** Method by which the Demo class makes its iterator available */\n        public Iterator<String> iterator() {\n            return new DemoIterator();\n        }\n    }\n\n    public static void main(String[] args) {\n        Demo demo = new Demo();\n        for (String s : demo) {\n            System.out.println(s);\n        }\n    }\n}\n```", "```java\npackage structure;\n\nimport com.darwinsys.util.ArrayIterator;\n\npublic class ArrayIteratorDemo {\n\n    private final static String[] names = {\n        \"rose\", \"petunia\", \"tulip\"\n    };\n\n    public static void main(String[] args) {\n        ArrayIterator<String> arrayIterator = new ArrayIterator<>(names);\n\n        System.out.println(\"Java 5, 6 way\");\n        for (String s : arrayIterator) {\n            System.out.println(s);\n        }\n\n        System.out.println(\"Java 5, 6 ways\");\n        arrayIterator.forEach(s->System.out.println(s));\n        arrayIterator.forEach(System.out::println);\n    }\n}\n```", "```java\npublic class ToyStack {\n\n    /** The maximum stack depth */\n    protected int MAX_DEPTH = 10;\n    /** The current stack depth */\n    protected int depth = 0;\n    /* The actual stack */\n    protected int[] stack = new int[MAX_DEPTH];\n\n    /** push - add an element onto the stack */\n    protected void push(int n) {\n        stack[depth++] = n;\n    }\n    /** pop - return and remove the top element */\n    protected int pop() {\n        return stack[--depth];\n    }\n    /** peek - return the top element but don't remove it */\n    protected int peek() {\n        return stack[depth-1];\n    }\n}\n```", "```java\npublic interface SimpleStack<T> {\n\n    /** empty - return true if the stack is empty */\n    abstract boolean empty();\n\n    /** push - add an element onto the stack */\n    abstract void push(T n);\n\n    /** pop - return and remove the top element */\n    abstract T pop();\n\n    /** peek - return the top element but don't remove it */\n    abstract T peek();\n}\n```", "```java\npublic class MyStack<T> implements SimpleStack<T> {\n\n    private int depth = 0;\n    public static final int DEFAULT_INITIAL = 10;\n    private T[] stack;\n\n    public MyStack() {\n        this(DEFAULT_INITIAL);\n    }\n\n    public MyStack(int howBig) {\n        if (howBig <= 0) {\n            throw new IllegalArgumentException(\n            howBig + \" must be positive, but was \" + howBig);\n        }\n        stack = (T[])new Object[howBig];\n    }\n\n    @Override\n    public boolean empty() {\n        return depth == 0;\n    }\n\n    /** push - add an element onto the stack */\n    @Override\n    public void push(T obj) {\n        // Could check capacity and expand\n        stack[depth++] = obj;\n    }\n\n    /* pop - return and remove the top element */\n    @Override\n    public T pop() {\n        --depth;\n        T tmp = stack[depth];\n        stack[depth] = null;\n        return tmp;\n    }\n\n    /** peek - return the top element but don't remove it */\n    @Override\n    public T peek() {\n        if (depth == 0) {\n            return null;\n        }\n        return stack[depth-1];\n    }\n\n    public boolean hasNext() {\n        return depth > 0;\n    }\n\n    public boolean hasRoom() {\n        return depth < stack.length;\n    }\n\n    public int getStackDepth() {\n        return depth;\n    }\n}\n```", "```java\npublic class ArrayTwoDObjects {\n\n    /** Return list of subscript names (unrealistic; just for demo). */\n    public static String[][] getArrayInfo() {\n        String info[][];\n        info = new String[10][10];\n        for (int i=0; i < info.length; i++) {\n            for (int j = 0; j < info[i].length; j++) {\n                info[i][j] = \"String[\" + i + \",\" + j + \"]\";\n            }\n        }\n        return info;\n    }\n\n    /** Run the initialization method and print part of the results */\n    public static void main(String[] args) {\n        print(\"from getArrayInfo\", getArrayInfo());\n    }\n\n    /** Print selected elements from the 2D array */\n    public static void print(String tag, String[][] array) {\n        System.out.println(\"Array \" + tag + \" is \" + array.length + \" x \" +\n            array[0].length);\n        System.out.println(\"Array[0][0] = \" + array[0][0]);\n        System.out.println(\"Array[0][1] = \" + array[0][1]);\n        System.out.println(\"Array[1][0] = \" + array[1][0]);\n        System.out.println(\"Array[0][0] = \" + array[0][0]);\n        System.out.println(\"Array[1][1] = \" + array[1][1]);\n    }\n}\n```", "```java\n> java structure.ArrayTwoDObjects\nArray from getArrayInfo is 10 x 10\nArray[0][0] = String[0,0]\nArray[0][1] = String[0,1]\nArray[1][0] = String[1,0]\nArray[0][0] = String[0,0]\nArray[1][1] = String[1,1]\nArray from getParameterInfo is 2 x 3\nArray[0][0] = fontsize\nArray[0][1] = 9-18\nArray[1][0] = URL\nArray[0][0] = fontsize\nArray[1][1] = -\n>\n```", "```java\n@Setters @Getters\n```", "```java\n@ToString\n@EqualsAndHashCode\n@AllArgsConstructor\n```", "```java\npublic record Person(String name, String emailAddress) { }\n```", "```java\n$ jshell --enable-preview\n|  Welcome to JShell -- Version 14-ea\n|  For an introduction type: /help intro\n\njshell> record Person(String name, String email) {}\n\njshell> var p = new Person(\"Covington Roderick Smythe\", \"roddy@smythe.tld\")\np ==> Person[name=Covington Roderick Smythe, email=roddy@smythe.tld]\n\njshell> p.name()\n$3 ==> \"Covington Roderick Smythe\"\n\njshell>\n```", "```java\n$ javac --enable-preview -source 14 PersonRecordDemo.java\nNote: PersonRecordDemo.java uses preview language features.\nNote: Recompile with -Xlint:preview for details.\n$ javap PersonRecordDemo'$'Person\nCompiled from \"PersonRecordDemo.java\"\npublic final class PersonRecordDemo$Person extends java.lang.Record {\n  public PersonRecordDemo$Person(java.lang.String, java.lang.String);\n  public java.lang.String toString();\n  public final int hashCode();\n  public final boolean equals(java.lang.Object);\n  public java.lang.String name();\n  public java.lang.String email();\n}\n```", "```java\npublic class Array {\n    public static final int MAX = 250000;\n    public static void main(String[] args) {\n        System.out.println(new Array().run());\n    }\n    public int run() {\n        MutableInteger list[] = new MutableInteger[MAX];\n        for (int i=0; i<list.length; i++) {\n            list[i] = new MutableInteger(i);\n        }\n        int sum = 0;\n        for (int i=0; i<list.length; i++) {\n            sum += list[i].getValue();\n        }\n        return sum;\n    }\n}\n```", "```java\npublic class ArrayLst {\n    public static final int MAX = 250000;\n    public static void main(String[] args) {\n        System.out.println(new ArrayLst().run());\n    }\n    public int run() {\n        ArrayList<MutableInteger> list = new ArrayList<>();\n        for (int i=0; i<MAX; i++) {\n            list.add(new MutableInteger(i));\n        }\n        int sum = 0;\n        for (int i=0; i<MAX; i++) {\n            sum += ((MutableInteger)list.get(i)).getValue();\n        }\n        return sum;\n    }\n}\n```", "```java\n$ java performance.Time Array \nStarting class class Array\n1185103928\nrunTime=4.310\n$ java performance.Time ArrayLst\nStarting class class ArrayLst\n1185103928\nrunTime=5.626\n$ java performance.Time ArrayVec\nStarting class class ArrayVec\n1185103928\nrunTime=6.699\n$\n```"]