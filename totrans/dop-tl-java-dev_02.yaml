- en: Chapter 2\. The System of Truth
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Stephen Chin
  prefs: []
  type: TYPE_NORMAL
- en: A complex system that works is invariably found to have evolved from a simple
    system that worked.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: John Gall (Gall’s law)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: To have an effective DevOps pipeline, it is important to have a single system
    of truth to understand what bits and bytes are being deployed into production.
    Typically, this starts with a source code management system that contains all
    of the source code that gets compiled and built into the production deployment.
    By tracing a production deployment back to a specific revision in source control,
    you can do root cause analysis of bugs, security holes, and performance issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'Source code management solves several key roles in the software delivery lifecycle:'
  prefs: []
  type: TYPE_NORMAL
- en: Collaboration
  prefs: []
  type: TYPE_NORMAL
- en: Large teams working on a single codebase would constantly get blocked by one
    another without effective source code management, reducing productivity as the
    team size grows.
  prefs: []
  type: TYPE_NORMAL
- en: Versioning
  prefs: []
  type: TYPE_NORMAL
- en: Source code systems let you track versions of the code to identify what is being
    deployed into production or released to a customer.
  prefs: []
  type: TYPE_NORMAL
- en: History
  prefs: []
  type: TYPE_NORMAL
- en: By keeping a chronological record of all versions of software as it is developed,
    it is possible to revert to an older version of the code or identify the specific
    change that caused a regression.
  prefs: []
  type: TYPE_NORMAL
- en: Attribution
  prefs: []
  type: TYPE_NORMAL
- en: Knowing who made the changes in a particular file allows you to identify ownership,
    assess domain expertise, and assess risk when making changes.
  prefs: []
  type: TYPE_NORMAL
- en: Dependencies
  prefs: []
  type: TYPE_NORMAL
- en: Source code has become the canonical source for other key metadata about the
    project, like dependencies on other packages.
  prefs: []
  type: TYPE_NORMAL
- en: Quality
  prefs: []
  type: TYPE_NORMAL
- en: A source code management system allows for easy peer review of changes before
    they are accepted, increasing the overall quality of the software.
  prefs: []
  type: TYPE_NORMAL
- en: Since source code management plays such a critical role in software development,
    it is important to understand how it works and select a system that best meets
    the needs of your organization and the desired DevOps workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Three Generations of Source Code Management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Collaboration is a big part of software development, and as you scale with larger
    teams, the ability to collaborate effectively on a shared codebase often becomes
    a bottleneck to developer productivity. Also, the complexity of systems tends
    to increase, so rather than managing a dozen files or a handful of modules, it
    is common to see thousands of source files that need to be updated en masse to
    accomplish system-wide changes and refactorings.
  prefs: []
  type: TYPE_NORMAL
- en: 'To manage the need to collaborate on codebases, *source code management* *(SCM)*
    systems were created. The first-generation SCM systems handled collaboration via
    file locking. Examples of these are SCCS and RCS, which required that you lock
    files before editing, make your changes, and then release the lock for other folks
    to contribute. This seemingly eliminated the possibility of two developers making
    conflicting changes, with two major drawbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: Productivity was still impacted since you had to wait for other developers to
    finish their changes before editing. In systems with large files, this could effectively
    limit the concurrency to only one developer at a time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This did not solve the problem of conflicts across files. It is still possible
    for two developers to modify different files with interdependencies and create
    a buggy or unstable system by introducing conflicting changes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A substantial improvement was made in the second-generation version control
    systems, starting with Concurrent Versions System (CVS) created by Dick Grune.
    CVS was revolutionary in its approach to (or lack of) file locking. Rather than
    preventing you from changing files, it would allow multiple developers to make
    their simultaneous (and possibly conflicting) changes to the same files. This
    was later resolved via file merging: the conflicting files were analyzed via a
    difference (diff) algorithm, and any conflicting changes were presented to the
    user to resolve.'
  prefs: []
  type: TYPE_NORMAL
- en: By delaying the resolution of conflicting changes to a check-in, CVS allowed
    multiple developers to freely modify and refactor a large codebase without becoming
    blocked on other changes to the same files. This not only increases developer
    productivity, but also allows for the isolation and testing of large features
    separately, which can later be merged into an integrated codebase.
  prefs: []
  type: TYPE_NORMAL
- en: The most popular second-generation SCM is currently Apache Subversion, which
    is designed as a drop-in replacement for CVS. It offers several advantages over
    CVS, including tracking commits as a single revision, which avoids file-update
    collisions that can corrupt the CVS repository state.
  prefs: []
  type: TYPE_NORMAL
- en: The third generation of version control is distributed version control systems
    (DVCSs). In a DVCS, every developer has a copy of the entire repository along
    with the full history stored locally. Just as in a second-generation version control
    system, you check out a copy of the repository, make changes, and check it back
    in. However, to integrate those changes with other developers, you sync your entire
    repository in a peer-to-peer fashion.
  prefs: []
  type: TYPE_NORMAL
- en: Several early DVCS systems existed, including GNU Arch, Monotone, and Darcs,
    but DVCS become popularized by Git and Mercurial. Git was developed as a direct
    response to the Linux team’s need for a stable and reliable version control system
    that could support the scale and requirements for open source operating system
    development, and it has become the de facto standard for both open source and
    commercial version control system usage.
  prefs: []
  type: TYPE_NORMAL
- en: 'DVCSs offer several advantages over server-based version control:'
  prefs: []
  type: TYPE_NORMAL
- en: Working entirely offline
  prefs: []
  type: TYPE_NORMAL
- en: Since you have a local copy of the repository, checking code in and out, merging,
    and managing branches can all be done without a network connection.
  prefs: []
  type: TYPE_NORMAL
- en: No single point of failure
  prefs: []
  type: TYPE_NORMAL
- en: Unlike a server-based SCM, where only one copy of the entire repository with
    full history exists, a DVCS creates a copy of the repository on every developer’s
    machine, increasing redundancy.
  prefs: []
  type: TYPE_NORMAL
- en: Faster local operations
  prefs: []
  type: TYPE_NORMAL
- en: Since most version control operations are local to the machine, they are much
    faster and not affected by network speed or server load.
  prefs: []
  type: TYPE_NORMAL
- en: Decentralized control
  prefs: []
  type: TYPE_NORMAL
- en: Since syncing the code involves copying the entire repository, this makes it
    much easier to fork a codebase, and in the case of open source projects can make
    it much easier to start an independent effort when the main project has stalled
    or taken an undesirable direction.
  prefs: []
  type: TYPE_NORMAL
- en: Ease of migration
  prefs: []
  type: TYPE_NORMAL
- en: Converting from most SCM tools into Git is a relatively straightforward operation,
    and you can retain commit history.
  prefs: []
  type: TYPE_NORMAL
- en: 'And distributed version control has a few disadvantages, including these:'
  prefs: []
  type: TYPE_NORMAL
- en: Slower initial repository sync
  prefs: []
  type: TYPE_NORMAL
- en: The initial sync includes copying the entire repository history, which can be
    much slower.
  prefs: []
  type: TYPE_NORMAL
- en: Larger storage requirements
  prefs: []
  type: TYPE_NORMAL
- en: Since everyone has a full copy of the repository and all history, very large
    and/or long-running projects may require a sizable disk requirement.
  prefs: []
  type: TYPE_NORMAL
- en: No ability to lock files
  prefs: []
  type: TYPE_NORMAL
- en: Server-based version control systems offer some support for locking files when
    a binary file that cannot be merged needs to be edited. With DVCSs locking mechanics
    cannot be enforced, which means only files that can be merged (for example, text)
    are suitable for versioning.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing Your Source Control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hopefully, by now you are convinced that using a modern DVCS is the way to go.
    It provides the best capabilities for local and remote development of any size
    team.
  prefs: []
  type: TYPE_NORMAL
- en: Also, of the commonly used version control systems, Git has become the clear
    winner in adoption. This is shown clearly by looking at the Google Trends analysis
    of the most commonly used version control systems, as shown in [Figure 2-1](#version_control_adoption).
  prefs: []
  type: TYPE_NORMAL
- en: '![Line graph comparing popularity of Git,Mercurial,Subversion,and CVS](Images/dtjd_0201.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-1\. Popularity of version control systems from 2004 through 2022 (source:
    [Google Trends](https://oreil.ly/qRxyG))'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Git has become the de facto standard in the open source community, which means
    a wide base of support exists for its usage along with a rich ecosystem. However,
    sometimes convincing your boss or peers to adopt new technologies is difficult
    if they have a deep investment in a legacy source control technology.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some reasons you can use to convince your boss to upgrade to Git:'
  prefs: []
  type: TYPE_NORMAL
- en: Reliability
  prefs: []
  type: TYPE_NORMAL
- en: Git is written like a filesystem, including a proper filesystem check tool (`git
    fsck`) and checksums to ensure data reliability. And given it is a DVCS, you probably
    have your data also pushed to multiple external repositories, creating several
    redundant backups of the data.
  prefs: []
  type: TYPE_NORMAL
- en: Performance
  prefs: []
  type: TYPE_NORMAL
- en: Git is not the first DVCS, but it is extremely performant. It was built from
    the ground up to support Linux development with extremely large codebases and
    thousands of developers. Git continues to be actively developed by a large open
    source community.
  prefs: []
  type: TYPE_NORMAL
- en: Tool support
  prefs: []
  type: TYPE_NORMAL
- en: There are over 40 frontends for Git and support in just about every major IDE
    (JetBrains IntelliJ IDEA, Microsoft Visual Studio Code, Eclipse, Apache NetBeans,
    etc.), so you are unlikely to find a development platform that does not fully
    support it.
  prefs: []
  type: TYPE_NORMAL
- en: Integrations
  prefs: []
  type: TYPE_NORMAL
- en: Git has first-class integrations with IDEs, issue trackers, messaging platforms,
    continuous integration servers, security scanners, code review tools, dependency
    management, and cloud platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Upgrade tools
  prefs: []
  type: TYPE_NORMAL
- en: There are migration tools to ease the transition from other version-control
    systems to Git, such as `git-svn` that supports bidirectional changes from Subversion
    to Git, or the Team Foundation Version Control (TFVC) repository import tool for
    Git.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, there is not much to lose by upgrading to Git, and a lot of additional
    capabilities and integrations to start to take advantage of. Getting started with
    Git is as simple as [downloading a release](https://oreil.ly/dxgt4) for your development
    machine and creating a local repository.
  prefs: []
  type: TYPE_NORMAL
- en: However, the real power comes in collaboration with the rest of your team, and
    this is most convenient if you have a central repository to push changes to and
    collaborate with. Several companies offer commercial Git repos that you can self-host
    or run on their cloud platform. These include AWS CodeCommit, Assembla, Azure
    DevOps, GitLab, SourceForge, GitHub, RhodeCode, Bitbucket, Gitcolony, and others.
    According to data from the JetBrains “State of the Developer Ecosystem 2020” report
    shown in [Figure 2-2](#version_control_service_chart), these Git-based source
    control systems accounted for over 96% of the commercial source control market.
  prefs: []
  type: TYPE_NORMAL
- en: '![Chart comparing the adoption of different CVS systems](Images/dtjd_0202.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-2\. Data from the JetBrains [“State of the Developer Ecosystem 2020”](https://oreil.ly/e9yJu)
    report on usage of version control services (source: JetBrains [CC BY 4.0](https://oreil.ly/W5qPM))'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'All of these version control services offer additional services on top of basic
    version control, including capabilities like these:'
  prefs: []
  type: TYPE_NORMAL
- en: Collaboration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code reviews
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Having an efficient system for code reviews is important to maintain code integrity,
    quality, and standards.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Advanced pull request/merge features
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Many vendors implement advanced features on top of Git that help with multirepository
    and team workflows for more-efficient change request management.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Workflow automation
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Approvals in a large organization can be both fluid and complicated, so having
    automation of team and corporate workflows improves efficiency.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Team comments/discussions
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Effective team interaction and discussions that can be tied to specific pull
    requests and code changes help improve communication within and around the team.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Online editing
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In-browser IDEs allow for collaboration on source code from anywhere, on almost
    any device. GitHub even recently released [Codespaces](https://oreil.ly/1PKf4)
    to give you a fully functional development environment hosted by GitHub.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Compliance/security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tracking
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Being able to track the code history is a core feature of any version control
    system, but often additional compliance checks and reports are required.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Auditing changes
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For control and regulatory purposes, auditing the changes to a codebase is often
    required, so having tools to automate this can be helpful.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Permissions management
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Fine-grained roles and permissions allow for restricting access to sensitive
    files or codebases.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Bill of materials
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For auditing purposes, a full list of all software modules and dependencies
    is often required, and can be generated off the source code.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Security vulnerability scanning
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Many common security vulnerabilities can be uncovered by scanning the codebase
    and looking for common patterns that are used to exploit deployed applications.
    Using an automated vulnerability scanner on the source code can help identify
    vulnerabilities early in the development process.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Integration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Issue tracking
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: By having tight integration with an issue tracker, you can tie specific changesets
    to a software defect, making it easier to identify the version a bug is fixed
    in and trace any regressions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: CI/CD
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Typically, a continuous integration server will be used to build the code checked
    into source control. A tight integration makes it easier to kick off builds, report
    back on success and test results, and automate promotion and/or deployment of
    successful builds.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Binary package repository
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Fetching dependencies from a binary repository and storing build results provides
    a central place to look for artifacts and to stage deployments.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Messaging integration
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Team collaboration is important to a successful development effort, and making
    it easy to discuss source files, check-ins, and other source control events simplifies
    communication with platforms like Slack, Microsoft Teams, Element, etc.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Clients (desktop/IDE)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A lot of free clients and plug-ins for various IDEs allow you to access your
    source control system, including open source clients from GitHub, Bitbucket, and
    others.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When selecting a version control service, it is important to make sure that
    it fits into the development workflow of your team, integrates with other tools
    that you already use, and fits into your corporate security policies. Often companies
    have a version control system that is standardized across the organization, but
    there may be benefits to adopting a more modern version control system, especially
    if the corporate standard is not a DVCS like Git.
  prefs: []
  type: TYPE_NORMAL
- en: Making Your First Pull Request
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To get a feel for how version control works, we are going to run through a simple
    exercise to create your first pull request to the official book repository on
    GitHub. A section of the readme file is dedicated to reader comments, so you can
    join the rest of the readers in showing your accomplishment in learning modern
    DevOps best practices!
  prefs: []
  type: TYPE_NORMAL
- en: This exercise doesn’t require installing any software or using the command line,
    so it should be easy and straightforward to accomplish. Finishing this exercise
    is highly recommended so you understand the basic concepts of distributed version
    control that we go into more detail on later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: To start, you need to navigate to the [book repository](https://oreil.ly/ApzqX).
    For this exercise, you need to be logged in so you can create a pull request from
    the web user interface. If you don’t already have a GitHub account, signing up
    and getting started is easy and free.
  prefs: []
  type: TYPE_NORMAL
- en: The DevOps Tools for Java Developers repository GitHub page is shown in [Figure 2-3](#book_repository).
    The GitHub UI shows the root files and the contents of a special file called *README.md*
    by default. We are going to make edits to the readme file, which is coded in a
    visual text language called Markdown.
  prefs: []
  type: TYPE_NORMAL
- en: Since we have only read access to this repository, we are going to create a
    personal clone of the repository, known as a *fork*, that we can freely edit to
    make and propose the changes. Once you are logged in to GitHub, you can start
    this process by clicking the Fork button highlighted in the upper-right corner.
  prefs: []
  type: TYPE_NORMAL
- en: '![Website page showing the GitHub book repository](Images/dtjd_0203.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-3\. The GitHub repository containing this book’s samples
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Your new fork will get created under your personal account at GitHub. Once
    your fork is created, complete the following steps to open the web-based text
    editor:'
  prefs: []
  type: TYPE_NORMAL
- en: Click the *README.md* file that you want to edit to see the details page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the pencil icon on the details page to edit the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you click the pencil icon, you will see the web-based text editor shown
    in [Figure 2-4](#edit_readme). Scroll down to the section with the visitor log,
    and add your own personal comment to the end to let folks know you completed this
    exercise.
  prefs: []
  type: TYPE_NORMAL
- en: '![Website page showing the GitHub text file editor](Images/dtjd_0204.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-4\. The GitHub web-based text editor for making quick changes to files
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The recommended format for visitor log entries is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to be fancy on the Twitter handle and link to your profile, the
    Markdown syntax for Twitter links is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: To check your changes, you can click the “Preview changes” tab, which will show
    the rendered output once it’s inserted into the original readme.
  prefs: []
  type: TYPE_NORMAL
- en: When you are satisfied with your changes, scroll down to the code commit section
    shown in [Figure 2-5](#commit_changes). Enter a helpful description for the change
    to explain your updates. Then go ahead and click the “Commit changes” button.
  prefs: []
  type: TYPE_NORMAL
- en: For this example, we will simply commit to the main branch, which is the default.
    However, if you were working in a shared repository, you would commit your pull
    request to a feature branch that can be integrated separately.
  prefs: []
  type: TYPE_NORMAL
- en: '![Website page showing the code commit form](Images/dtjd_0205.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-5\. Using GitHub UI to commit changes to a repository you have write
    access to
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: After you have made a change to your forked repository, you can submit this
    as a pull request for the original project. This will notify the project maintainers
    (in this case, the book authors) that a proposed change is waiting for review
    and let them choose whether to integrate it into the original project.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, go to the “Pull requests” tab in the GitHub user interface. This
    screen has a button to create a “New pull request” that will present you with
    a choice of the “base” and “head” repository to be merged, as shown in [Figure 2-6](#create_pull_request).
  prefs: []
  type: TYPE_NORMAL
- en: In this case, since you have only one change, the default repositories should
    be selected correctly. Simply click the “Create pull request” button, and a new
    pull request against the original repository will be submitted for review.
  prefs: []
  type: TYPE_NORMAL
- en: '![Website page showing the GitHub pull request UI](Images/dtjd_0206.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-6\. User interface for creating a pull request from a forked repository
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This completes your submission of a pull request! Now it is up to the original
    repository owners to review and comment on, or accept/reject the pull request.
    While you don’t have write access to the original repository to see what this
    looks like, [Figure 2-7](#merge_pull_request) shows you what will be presented
    to the repository owners.
  prefs: []
  type: TYPE_NORMAL
- en: Once the repository owners accept your pull request, your custom visitor log
    greeting will be added to the official book repository.
  prefs: []
  type: TYPE_NORMAL
- en: '![Website page showing the GitHub merge resolution UI](Images/dtjd_0207.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-7\. The repository owner user interface for merging in the resulting
    pull request
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This workflow is an example of the fork and pull request collaboration model
    for handling project integration. We will talk a bit more about collaboration
    patterns and the sort of projects and team structures they are most suitable for
    in [“Git Collaboration Patterns”](#git_collab_patterns).
  prefs: []
  type: TYPE_NORMAL
- en: Git Tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous section, we showed an entire web-based workflow for Git using
    the GitHub UI. However, other than code reviews and repository management, most
    developers spend the majority of their time in one of the client-based user interfaces
    to Git. The available client interfaces can be broadly split into the following
    categories:'
  prefs: []
  type: TYPE_NORMAL
- en: Command line
  prefs: []
  type: TYPE_NORMAL
- en: An official Git command-line client may already be installed on your system
    or is easily added.
  prefs: []
  type: TYPE_NORMAL
- en: GUI clients
  prefs: []
  type: TYPE_NORMAL
- en: The official Git distribution comes with a couple of open source tools that
    can be used to more easily browse your revision history or to structure a commit.
    Also, several third-party free and open source Git tools can make working with
    your repository easier.
  prefs: []
  type: TYPE_NORMAL
- en: Git IDE plug-ins
  prefs: []
  type: TYPE_NORMAL
- en: Often you need to go no further than your favorite IDE to work with your distributed
    source control system. Many major IDEs have Git support packaged by default or
    offer a well-supported plug-in.
  prefs: []
  type: TYPE_NORMAL
- en: Git Command-Line Basics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Git command line is the most powerful interface to your source control
    system, allowing for all local and remote options to manage your repository. You
    can check whether you have the Git command line installed by typing the following
    on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have Git installed, the command will return the operating system and
    version that you are using, similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if you don’t have Git installed, here’s the easiest way to get it
    on various platforms:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Linux distributions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Debian-based:* `sudo apt install git-all`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*RPM-based:* `sudo dnf install git-all`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: macOS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running `git` on macOS 10.9 or later will ask you to install it.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Another easy option is to install [GitHub Desktop](https://oreil.ly/0x2A3),
    which installs and configures the command-line tools.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Windows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The easiest way is to simply install GitHub Desktop, which installs the command-line
    tools as well.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Another option is [Git for Windows](https://oreil.ly/BioSg).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Regardless of which approach you use to install Git, you will end up with the
    same great command-line tools, which are well supported across all desktop platforms.
  prefs: []
  type: TYPE_NORMAL
- en: To start with, it is helpful to understand the basic Git commands. [Figure 2-8](#git_repository_hierarchy)
    shows a typical repository hierarchy with one central repository and three clients
    who have cloned it locally. Notice that every client has a full copy of the repository
    as well as a working copy where they can make changes.
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram showing relationship of remote and local repositories, and the Git
    working copy](Images/dtjd_0208.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-8\. A typical central server pattern for distributed version control
    collaboration
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Some of the Git commands that allow you to move data between repositories as
    well as the working copy are shown. Now let’s go through some of the most common
    commands that are used to manage your repository and collaborate in Git.
  prefs: []
  type: TYPE_NORMAL
- en: 'Repository management:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`clone`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Makes a connected copy of another local or remote repository on the local filesystem.
    For those coming from a concurrent version control system like CVS or Subversion,
    this command serves a similar purpose to `checkout`, but is semantically different
    in that it creates a full copy of the remote repository. All of the clients in
    [Figure 2-8](#git_repository_hierarchy) would have cloned the central server to
    begin.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`init`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Creates a new, empty repository. However, most of the time you will start by
    cloning an existing repository.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Changeset management:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`add`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Adds file revisions to version control, which can be either a new file or modifications
    to an existing file. This is different from the `add` command in CVS or Subversion
    in that it does not *track* the file and needs to be called every time the file
    changes. Make sure to call `add` on all new and modified files before committing.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`mv`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Renames or moves a file/directory, while also updating the version control record
    for the next commit. It is similar in use to the `mv` command in Unix and should
    be used instead of filesystem commands to keep version control history intact.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`restore`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Allows you to restore files from the Git index if they are deleted or erroneously
    modified.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`rm`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Removes a file or directory, while also updating the version control record
    for the next commit. It is similar in use to the `rm` command in Unix and should
    be used instead of filesystem commands to keep version control history intact.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'History control:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`branch`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With no arguments, lists all branches in the local repository. It can also be
    used to create a new branch or delete branches.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`commit`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Saves changes in the working copy to the local repository. Before running `commit`,
    make sure to register all your file changes by calling `add`, `mv`, and `rm` on
    files that have been added, modified, renamed, or moved. You also need to specify
    a commit message that can be done on the command line with the `-m` option; or
    if omitted, a text editor (such as `vi`) will be spawned to allow you to enter
    a message.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`merge`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Joins changes from the named commits into the current branch. If the merged
    history is already a descendant of the current branch, a “fast-forward” is used
    to combine the history sequentially. Otherwise, a merge is created that combines
    the history; the user is prompted to resolve any conflicts. This command is also
    used by `git pull` to integrate changes from the remote repository.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`rebase`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Replays the commits from your current branch on the upstream branch. This is
    different from `merge` in that the result will be a linear history rather than
    a merge commit, which can make the revision history easier to follow. The disadvantage
    is that rebase creates entirely new commits when it moves the history, so if the
    current branch contains changes that have previously been pushed, you are rewriting
    history that other clients may depend upon.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`reset`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Reverts the `HEAD` to a previous state, and has several practical uses such
    as reverting an `add` or undoing a commit. However, if those changes have been
    pushed remotely, this can cause problems with the upstream repository. Use with
    care!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`switch`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Switches between branches for the working copy. If you have changes in the working
    copy, this can result in a three-way merge, so it is often better to commit or
    stash your changes first. With `-c`, this command will create a branch and immediately
    switch to it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`tag`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Allows you to create a tag on a specific commit that is signed by PGP. This
    uses the default email address’s PGP key. Since tags are cryptographically signed
    and unique, they should not be reused or changed once pushed. Additional options
    on this command allow for deleting, verifying, and listing tags.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`log`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Shows the commit logs in a textual format. It can be used for a quick view of
    recent changes, and supports advanced options for the history subset shown and
    formatting of the output. Later in this chapter, we also show how to visually
    browse the history by using tools like `gitk`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Collaboration:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fetch`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Pulls the history from a remote repository into the local repository, but makes
    no attempt to merge it with local commits. This is a safe operation that can be
    performed at any time and repeatedly without causing merge conflicts or affecting
    the working copy.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`pull`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Equivalent to a `git fetch` followed by `git merge FETCH_HEAD`. It is convenient
    for the common workflow of grabbing the latest changes from a remote repository
    and integrating it with your working copy. However, if you have local changes,
    `pull` can cause merge conflicts that you will be forced to resolve. For this
    reason, it is often safer to `fetch` first and then decide if a simple merge will
    suffice.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`push`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Sends changes to the upstream remote repository from the local repository. Use
    this after a `commit` to push your changes to the upstream repository so other
    developers can see your changes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that you have a basic understanding of the Git commands, let’s put this
    knowledge into practice.
  prefs: []
  type: TYPE_NORMAL
- en: Git Command-Line Tutorial
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To demonstrate how to use these commands, we will go through a simple example
    to create a new local repository from scratch. For this exercise, we are assuming
    you are on a system with a Bash-like command shell. This is the default on most
    Linux distributions as well as macOS. If you are on Windows, you can do this via
    Windows PowerShell, which has sufficient aliases to emulate Bash for basic commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'If this is your first time using Git, it is a good idea to put in your name
    and email, which will be associated with all of your version control operations.
    You can do this with the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'After configuring your personal information, go to a suitable directory to
    create your working project. First, create the project folder and initialize the
    repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates the repository and initializes it so you can start tracking revisions
    of files. Let’s create a new file that we can add to revision control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'To add this file to revision control, use the `git add` command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'And you can add this file to version control by using the `git commit` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Congratulations on making your first command-line commit using Git! You can
    double-check to make sure that your file is being tracked in revision control
    by using the `git log` command, which should return output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: From this, you can see some of the details that Git stores in the repository,
    including branch information (the default branch is `master`), and revisions by
    globally unique identifiers (GUIDs). Though you can do a lot more from the command
    line, it is often easier to use a Git client built for your workflow or IDE integration
    that is designed for a developer workflow. The next couple of sections talk about
    these client options.
  prefs: []
  type: TYPE_NORMAL
- en: Git Clients
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Several free and open source clients that you can use to work with Git repos
    more easily are optimized for various different workflows. Most clients do not
    try to do everything, but specialize in visualizations and functionality for specific
    workflows.
  prefs: []
  type: TYPE_NORMAL
- en: The default Git installation comes with a couple of handy visual tools that
    make committing and viewing history easier. These tools are written in Tcl/Tk,
    are cross-platform, and are easily launched from the command line to supplement
    the Git command-line interface (CLI).
  prefs: []
  type: TYPE_NORMAL
- en: The first tool, `gitk`, provides an alternative to the command line for navigating,
    viewing, and searching the Git history of your local repository. The `gitk` user
    interface displaying the history for the ScalaFX open source project is shown
    in [Figure 2-9](#gitk).
  prefs: []
  type: TYPE_NORMAL
- en: '![User interface showing Git history visually via split panes with graphs and
    revision data](Images/dtjd_0209.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-9\. The bundled Git history viewer application
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The top pane of `gitk` displays the revision history with branching information
    drawn visually, which can be useful for deciphering complicated branch history.
    Below this are search filters that can be used to find commits containing specific
    text. Finally, for the selected changeset, you can see the changed files and a
    textual diff of the changes, which is also searchable.
  prefs: []
  type: TYPE_NORMAL
- en: The other tool that comes bundled with Git is `git-gui`. Unlike `gitk`, which
    only shows information about the repository history, `git-gui` allows you to modify
    the repository by executing many of the Git commands including `commit`, `push`,
    `branch`, `merge`, and others.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 2-10](#git-gui) shows the `git-gui` user interface for editing the
    source code repository for this book. On the left side, all of the changes to
    the working copy are shown, with the unstaged changes on top and the files that
    will be included in the next commit on the bottom. The details for the selected
    file are shown on the right side with the full file contents for new files, or
    a diff for modified files. At the bottom right, buttons are provided for common
    operations like Rescan, Sign Off, Commit, and Push. Further commands are available
    in the menu for advanced operations like branching, merging, and remote repository
    management.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot of the bundled Git UI for reviewing and committing code](Images/dtjd_0210.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-10\. The bundled Git collaboration application
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`git-gui` is an example of a workflow-driven user interface for Git. It doesn’t
    expose the full set of functionality available on the command line, but is convenient
    for the commonly used Git workflows.'
  prefs: []
  type: TYPE_NORMAL
- en: Another example of a workflow-driven user interface is *GitHub Desktop*. This
    is the most popular third-party GitHub user interface, and as mentioned earlier,
    also conveniently comes bundled with the command-line tools so you can use it
    as an installer for the Git CLI and aforementioned bundled GUIs.
  prefs: []
  type: TYPE_NORMAL
- en: GitHub Desktop is similar to `git-gui`, but is optimized for integration with
    GitHub’s service, and the user interface is designed to make it easy to follow
    workflows similar to GitHub Flow. The GitHub Desktop user interface editing the
    source repository for another great book, *The Definitive Guide to Modern Java
    Clients with JavaFX*, is shown in [Figure 2-11](#github_desktop).
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot of the GitHub Desktop user interface](Images/dtjd_0211.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-11\. GitHub’s open source desktop client
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In addition to the same sort of capabilities as `git-gui` to view changes,
    commit revisions, and pull/push code, GitHub Desktop has a bunch of advanced features
    that make managing your code much easier:'
  prefs: []
  type: TYPE_NORMAL
- en: Commit attribution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Syntax highlighted diffs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Image diff support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Editor and shell integration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CI status of pull requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'GitHub Desktop can be used with any Git repo, but has features tailored specifically
    for use with GitHub-hosted repositories. Here are some other popular Git tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Sourcetree](https://www.sourcetreeapp.com)'
  prefs: []
  type: TYPE_NORMAL
- en: A free, but proprietary, Git client made by Atlassian. It is a good alternative
    to GitHub Desktop and has only a slight bias toward Atlassian’s Git service, Bitbucket.
  prefs: []
  type: TYPE_NORMAL
- en: '[GitKraken Client](https://www.gitkraken.com)'
  prefs: []
  type: TYPE_NORMAL
- en: A commercial and featureful Git client. It is free for open source developers,
    but paid for commercial use.
  prefs: []
  type: TYPE_NORMAL
- en: '[TortoiseGit](https://tortoisegit.org)'
  prefs: []
  type: TYPE_NORMAL
- en: A free, GNU Public License (GPL), Git client based on TortoiseSVN. The only
    downside is that it is Windows only.
  prefs: []
  type: TYPE_NORMAL
- en: Others
  prefs: []
  type: TYPE_NORMAL
- en: A full list of Git GUI clients is maintained on the [Git website](https://oreil.ly/JPi0J).
  prefs: []
  type: TYPE_NORMAL
- en: Git desktop clients are a great addition to the arsenal of available source
    control management tools you have available. However, the most useful Git interface
    may already be at your fingertips, right inside your IDE.
  prefs: []
  type: TYPE_NORMAL
- en: Git IDE Integration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many integrated development environments (IDEs) include Git support either as
    a standard feature, or as a well-supported plug-in. Chances are that you need
    to go no further than your favorite IDE to do basic version control operations
    like adding, moving, and removing files, committing code, and pushing your changes
    to an upstream repository.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most popular Java IDEs is JetBrains IntelliJ IDEA. It has a Community
    Edition that is open source as well as a commercial version with additional features
    for enterprise developers. The IntelliJ Git support is full featured, with the
    ability to sync changes from a remote repository, track and commit changes performed
    in the IDE, and integrate upstream changes. The integrated Commit tab for a Git
    changeset is shown in [Figure 2-12](#intellij_git_commit).
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot of the IntelliJ commit tab](Images/dtjd_0212.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-12\. IntelliJ Commit tab for managing working copy changes
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: IntelliJ offers a rich set of features that you can use to customize the Git
    behavior to your team workflow. For example, if your team prefers a git-flow or
    GitHub Flow workflow, you can choose to merge on update (more details on Git workflows
    in the next section). However, if your team wants to keep a linear history as
    prescribed in OneFlow, you can choose to rebase on update instead. IntelliJ also
    supports the native credential provider as well as the open source KeePass password
    manager.
  prefs: []
  type: TYPE_NORMAL
- en: Another IDE that offers great Git support is Eclipse, a fully open source IDE
    that has strong community support and is run by the Eclipse Foundation. The Eclipse
    Git support is provided by the EGit project, which is based on JGit, a pure Java
    implementation of the Git version control system.
  prefs: []
  type: TYPE_NORMAL
- en: Because of the tight integration with the embedded Java implementation of Git,
    Eclipse has the most full-featured Git support. From the Eclipse user interface,
    you can accomplish almost everything that you would normally have to do from the
    command line, including rebasing, cherry-picking, tagging, patching, and more.
    The rich set of features is obvious from the Preferences dialog, shown in [Figure 2-13](#eclipse_git).
    This dialog has 12 configuration pages detailing how the Git integration works
    and is supported by a user guide that is almost a book itself at 161 pages.
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot of the Eclipse settings dialog for Git configuration](Images/dtjd_0213.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-13\. Eclipse Preferences dialog for Git configuration
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Other Java IDEs that you can expect great Git support from include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: NetBeans
  prefs: []
  type: TYPE_NORMAL
- en: Offers a Git plug-in that fully supports workflow from the IDE.
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio Code
  prefs: []
  type: TYPE_NORMAL
- en: Supports Git along with other version control systems out of the box.
  prefs: []
  type: TYPE_NORMAL
- en: BlueJ
  prefs: []
  type: TYPE_NORMAL
- en: A popular learning IDE built by King’s College London also supports Git in its
    team workflows.
  prefs: []
  type: TYPE_NORMAL
- en: Oracle JDeveloper
  prefs: []
  type: TYPE_NORMAL
- en: While it doesn’t support complicated workflows, JDeveloper does have basic support
    for cloning, committing, and pushing to Git repos.
  prefs: []
  type: TYPE_NORMAL
- en: So far in this chapter, you have added a whole set of new command-line, desktop,
    and integrated tools to your arsenal to work with Git repos. This range of community-
    and industry-supported tools means that no matter your operating system, project
    workflow, or even team preference, you will find full tooling support to be successful
    with your source control management. The next section goes into more detail on
    collaboration patterns that are well supported by the full range of Git tools.
  prefs: []
  type: TYPE_NORMAL
- en: Git Collaboration Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DVCSs have a proven track record of scaling to extremely large teams with hundreds
    of collaborators. At this scale, it is necessary to agree on uniform collaboration
    patterns that help the team avoid rework, avoid large and unwieldy merges, and
    reduce the amount of time blocked on administering the version control history.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most projects follow a central repository model: a single repository is designated
    as the official repository for integrations, builds, and releases. Even though
    a DVCS allows for noncentralized peer-to-peer exchanges of revisions, these are
    best reserved for short-lived efforts among a small number of developers. For
    any large project, having a single system of truth is important and requires one
    repository that everyone agrees is the official codeline.'
  prefs: []
  type: TYPE_NORMAL
- en: For open source projects, it is common for a limited set of developers to have
    write access to the central repository, while other committers *fork* the project
    and issue pull requests to have their changes included. Best practices are to
    have small pull requests, and to have someone other than the pull request creator
    accept them. This scales well to projects with thousands of contributors, and
    allows for review and oversight from a core team when the codebase is not well
    understood.
  prefs: []
  type: TYPE_NORMAL
- en: However, for most corporate projects, a shared repository with a single master
    branch is preferred. The same workflow with pull requests can be used to keep
    a central or release branch clean, but this simplifies the contribution process
    and encourages more frequent integration, which reduces the size and difficulty
    of merging in changes. For teams on tight deadlines or following an Agile process
    with short iterations, this also reduces the risk of last-minute integration failures.
  prefs: []
  type: TYPE_NORMAL
- en: The last best practice employed by most teams is to use branches to work on
    features, which then get integrated back into the main codeline. Git makes it
    inexpensive to create short-lived branches, so it is common to create and merge
    back in a branch for work that takes only a couple of hours. The risk with creating
    long-lived feature branches is that if they diverge too much from the main trunk
    of code development, they can become difficult to integrate back in.
  prefs: []
  type: TYPE_NORMAL
- en: Following these general best practices for distributed version control, several
    collaboration models have emerged. They share a lot of commonalities and primarily
    diverge in their approach to branching, history management, and integration speed.
  prefs: []
  type: TYPE_NORMAL
- en: git-flow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Git-flow* is one of the earliest Git workflows and was inspired by a [blog
    post](https://oreil.ly/v6aI4) from Vincent Driessen. It laid the groundwork for
    later Git collaboration workflows like GitHub Flow; however, git-flow is a more
    complicated workflow than most projects require and can add additional branch
    management and integration work.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Key attributes include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Development branches
  prefs: []
  type: TYPE_NORMAL
- en: Branch per feature
  prefs: []
  type: TYPE_NORMAL
- en: Merge strategy
  prefs: []
  type: TYPE_NORMAL
- en: No fast-forward merges
  prefs: []
  type: TYPE_NORMAL
- en: Rebasing history
  prefs: []
  type: TYPE_NORMAL
- en: No rebasing
  prefs: []
  type: TYPE_NORMAL
- en: Release strategy
  prefs: []
  type: TYPE_NORMAL
- en: Separate release branch
  prefs: []
  type: TYPE_NORMAL
- en: 'In git-flow, there are two long-lived branches: one for development integration,
    called *develop*, and another for final releases, called *master*. Developers
    are expected to do all of their coding in feature branches that are named according
    to the feature they are working on and integrate that with the develop branch
    once complete. When the develop branch has the features necessary for a release,
    a new release branch is created that is used to stabilize the codebase with patches
    and bugfixes.'
  prefs: []
  type: TYPE_NORMAL
- en: Once the release branch has stabilized and is ready for release, it is integrated
    into the master branch and given a release tag. Once on the master, only hotfixes
    are applied, which are small changes managed on a dedicated branch. These hotfixes
    also need to be applied back to the develop branch and any other concurrent releases
    that need the same fix. [Figure 2-14](#git_flow_diagram) shows a sample diagram
    for git-flow.
  prefs: []
  type: TYPE_NORMAL
- en: Because of the design decisions on git-flow, it tends to create a complicated
    merge history. By not taking advantage of fast-forward merges or rebasing, every
    integration becomes a commit, and the number of concurrent branches can be hard
    to follow even with visual tools. Also, the complicated rules and branch strategy
    require team training and are difficult to enforce with tools, often requiring
    check-ins and integration to be done from the command-line interface.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Git-flow is best applied to explicitly versioned projects that have multiple
    releases needing to be maintained in parallel. Usually, this is not the case for
    web applications, which have only one *latest* version and can be managed with
    a single release branch.
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram showing branches and integrations over time](Images/dtjd_0214.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-14\. Managing branches and integration with git-flow [(source: Vincent
    Driessen, Creative Commons BY-SA)](https://oreil.ly/baH6Z)'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If your project is in the sweet spot where git-flow excels, it is a very well-thought-out
    collaboration model. Otherwise, you may find that a simpler collaboration model
    will suffice.
  prefs: []
  type: TYPE_NORMAL
- en: GitHub Flow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*GitHub Flow* is a simplified Git workflow launched in response to the complexity
    of git-flow by Scott Chacon in another prominent [blog](https://oreil.ly/l7gTx).
    GitHub Flow or a close variant has been adopted by most development teams, since
    it is easier to implement in practice, handles the common case for continuous
    released web development, and is well supported by tools.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Key attributes include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Development branches
  prefs: []
  type: TYPE_NORMAL
- en: Branch per feature
  prefs: []
  type: TYPE_NORMAL
- en: Merge strategy
  prefs: []
  type: TYPE_NORMAL
- en: No fast-forward merges
  prefs: []
  type: TYPE_NORMAL
- en: Rebasing history
  prefs: []
  type: TYPE_NORMAL
- en: No rebasing
  prefs: []
  type: TYPE_NORMAL
- en: Release strategy
  prefs: []
  type: TYPE_NORMAL
- en: No separate release branches
  prefs: []
  type: TYPE_NORMAL
- en: GitHub Flow takes a simple approach to branch management, using *master* as
    the main codeline as well as the release branch. Developers do all of their work
    on short-lived feature branches and integrate them back into the master as soon
    as their code passes tests and code reviews.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In general, GitHub Flow makes good use of available tooling by having a straightforward
    workflow with a simple branching strategy and no use of complicated arguments
    to enable fast-forward merges or replace merges with rebasing. Developers who
    are not familiar with the team process or not as familiar with the command-line
    Git interface therefore find GitHub Flow easy to use.
  prefs: []
  type: TYPE_NORMAL
- en: The GitHub Flow collaboration model works well for server-side and cloud-deployed
    applications, where the only meaningful version is the latest release. In fact,
    GitHub Flow recommends that teams continuously deploy to production to avoid feature
    stacking, in which a single release build has multiple features that increase
    complexity and make it harder to determine the breaking change. However, for more
    complicated workflows with multiple concurrent releases, GitHub Flow needs to
    be modified to accommodate.
  prefs: []
  type: TYPE_NORMAL
- en: GitLab Flow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*GitLab Flow* is basically an extension of GitHub Flow, as documented on GitLab’s
    [website](https://oreil.ly/P1LzH). It takes the same core design principles about
    using a master as a single long-lived branch and doing the majority of development
    on feature branches. However, it adds a few extensions to support release branches
    and history cleanup that many teams have adopted as best practices.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Key attributes include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Development branches
  prefs: []
  type: TYPE_NORMAL
- en: Branch per feature
  prefs: []
  type: TYPE_NORMAL
- en: Merge strategy
  prefs: []
  type: TYPE_NORMAL
- en: Open-ended
  prefs: []
  type: TYPE_NORMAL
- en: Rebasing history
  prefs: []
  type: TYPE_NORMAL
- en: Optional
  prefs: []
  type: TYPE_NORMAL
- en: Release strategy
  prefs: []
  type: TYPE_NORMAL
- en: Separate release branches
  prefs: []
  type: TYPE_NORMAL
- en: The key difference between GitHub Flow and GitLab Flow is the addition of release
    branches. This is recognition that most teams are not practicing continuous deployment
    at the level GitHub does. Having release branches allows stabilization of code
    before it gets pushed into production; however, GitLab Flow recommends making
    patches to the master and then cherry-picking them for release rather than having
    an extra hotfix branch like git-flow.
  prefs: []
  type: TYPE_NORMAL
- en: The other significant difference is the willingness to edit history using `rebase`
    and `squash`. By cleaning up the history before committing to master, it is easier
    to retroactively go back and read the history to discover when key changes or
    bugs were introduced. However, this involves rewriting the local history and can
    be dangerous when that history has already been pushed to the central repository.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: GitLab Flow is a modern take on the GitHub Flow philosophy to collaboration
    workflow, but ultimately your team has to decide on the features and branch strategy
    based on your project’s needs.
  prefs: []
  type: TYPE_NORMAL
- en: OneFlow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*OneFlow*, another collaboration workflow based on git-flow, was proposed by
    Adam Ruka and introduced in a detailed [blog](https://oreil.ly/euJ37). OneFlow
    makes the same adaptation as GitHub/GitLab Flow in squashing the separate develop
    branch in favor of feature branches and direct integration on the main branch.
    However, it keeps the release and hotfix branches that are used in git-flow.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Key attributes include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Development branches
  prefs: []
  type: TYPE_NORMAL
- en: Branch per feature
  prefs: []
  type: TYPE_NORMAL
- en: Merge strategy
  prefs: []
  type: TYPE_NORMAL
- en: No fast-forward merges without rebase
  prefs: []
  type: TYPE_NORMAL
- en: Rebasing history
  prefs: []
  type: TYPE_NORMAL
- en: Rebasing recommended
  prefs: []
  type: TYPE_NORMAL
- en: Release strategy
  prefs: []
  type: TYPE_NORMAL
- en: Separate release branches
  prefs: []
  type: TYPE_NORMAL
- en: 'The other big deviation in OneFlow is that it heavily favors modifying history
    to keep the Git revision history readable. It offers three merge strategies that
    have varying levels of revision cleanliness and rollback friendliness:'
  prefs: []
  type: TYPE_NORMAL
- en: Rebase
  prefs: []
  type: TYPE_NORMAL
- en: This makes the merge history mostly linear and easy to follow. It has the usual
    caveat that changesets pushed to the central server should not be rebased and
    makes it more difficult to roll back changes since they are not captured in a
    single commit.
  prefs: []
  type: TYPE_NORMAL
- en: merge -no-ff
  prefs: []
  type: TYPE_NORMAL
- en: This is the same strategy used in git-flow and has the disadvantage that the
    merge history is largely nonsequential and difficult to follow.
  prefs: []
  type: TYPE_NORMAL
- en: rebase + merge -no-ff
  prefs: []
  type: TYPE_NORMAL
- en: This is a rebase workaround that tacks on an extra merge integration at the
    end so it can be rolled back as a unit even though it is still mostly sequential.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: OneFlow is a thoughtful approach to a Git collaboration workflow that is created
    from the experience of developers on large enterprise projects. It can be seen
    as a modern variant on git-flow that should serve the needs of projects of any
    size.
  prefs: []
  type: TYPE_NORMAL
- en: Trunk-Based Development
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All of the aforementioned approaches are variants of the feature branch development
    model; all active development is done on branches that get merged into either
    the master or a dedicated development branch. They take advantage of the great
    support Git has for branch management, but if features are not granular enough,
    they suffer from the typical integration problems that have plagued teams for
    decades. The longer the feature branch is in active development, the higher the
    likelihood for merge conflicts with other features and maintenance going on in
    the master branch (or trunk).
  prefs: []
  type: TYPE_NORMAL
- en: '*Trunk-based development* solves this problem by recommending that all development
    happen on the main branch with very short integrations that occur anytime that
    tests are passing, but not necessarily waiting for a full feature to be completed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Key attributes include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Development branches
  prefs: []
  type: TYPE_NORMAL
- en: Optional, but no long-lived branches
  prefs: []
  type: TYPE_NORMAL
- en: Merge strategy
  prefs: []
  type: TYPE_NORMAL
- en: Only if using development branches
  prefs: []
  type: TYPE_NORMAL
- en: Rebasing history
  prefs: []
  type: TYPE_NORMAL
- en: Rebasing recommended
  prefs: []
  type: TYPE_NORMAL
- en: Release strategy
  prefs: []
  type: TYPE_NORMAL
- en: Separate release branches
  prefs: []
  type: TYPE_NORMAL
- en: Paul Hammant, a strong advocate for trunk-based development, has set up a [full
    website](https://oreil.ly/HFo0J) and written a book on the topic. While this is
    not a new approach to collaboration on source control management systems, it is
    a proven approach to Agile development in large teams and works equally well on
    classic central SCMs like CVS and Subversion, and modern DVCSs like Git.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Good source control systems and practices lay the foundation for a solid DevOps
    approach to building, releasing, and deploying code quickly. In this chapter,
    we discussed the history of source control systems and explained why the world
    has moved to embrace distributed version control.
  prefs: []
  type: TYPE_NORMAL
- en: This consolidation has built a rich ecosystem of source control servers, developer
    tools, and commercial integrations. Finally, through the adoption of distributed
    version control by DevOps thought leaders, best practices and collaboration workflows
    have been established that you can follow to help make your team successful with
    adopting a modern SCM.
  prefs: []
  type: TYPE_NORMAL
- en: In the next few chapters, we will drill into systems that connect to your source
    control management system, including continuous integration, package management,
    and security scanning, that allow you to rapidly deploy to traditional or cloud
    native environments. You are on the way to building a comprehensive DevOps platform
    that will support whatever workflow you need to meet your quality and deployment
    objectives.
  prefs: []
  type: TYPE_NORMAL
