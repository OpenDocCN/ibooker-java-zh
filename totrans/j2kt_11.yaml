- en: Chapter 11\. Methods to Properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java does not distinguish between property access methods and other types. Kotlin,
    on the other hand, treats properties differently than member functions. When should
    we prefer a computed property to a function returning a result?
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fields, Accessors, and Properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most programming languages allow us to group data together in some way, giving
    names (and often types) to the properties of a composite.
  prefs: []
  type: TYPE_NORMAL
- en: Here, for example, is a *record*, composed of three *fields*, in ALGOL W, one
    of the first general-purpose languages to support record types. (ALGOL W was also
    the language in which Tony Hoare introduced null references.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Things were different then: real programmers only had CAPITAL LETTERS, and
    gender was a Boolean.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In ALGOL W, we can (well OK, could) update the age held in a `PERSON` record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In this case the compiler will emit the instructions to reach into the memory
    of the record, find the bytes representing Wilma’s age, and increment it. Records,
    also known as *structs* (for structure) in other languages, are a convenience
    for grouping related data. There is no information hiding here, just composition.
  prefs: []
  type: TYPE_NORMAL
- en: Most early object-oriented systems (C++ in particular) were based on this record
    mechanism. Instance variables were simply record fields, and methods (aka member
    functions) were fields holding pointers to functions. Smalltalk was different.
    Smalltalk objects can have instance variables, but access to this state is by
    sending a message to the object asking for the value. Messages, not fields, is
    the fundamental abstraction.
  prefs: []
  type: TYPE_NORMAL
- en: The Java implementers took a little of each approach. Objects can have public
    fields, but clients can’t just reach into their memory to retrieve them; they
    have to call bytecode instructions to access their values. This allows us to treat
    classes as records while allowing the runtime to enforce private field access.
  prefs: []
  type: TYPE_NORMAL
- en: Although direct access to fields was *permitted*, from the outset it was discouraged.
    We can’t change the internal representation of data if clients access fields directly,
    at least not without changing those clients too. We also cannot maintain any invariant
    relationships between fields if clients can mutate them directly, and as we’ve
    seen in [Chapter 5](ch05.html#beans-to-values), in those days objects were all
    about mutation. Fields access is also not polymorphic, so subclasses cannot change
    their implementation. In those days, objects were all about the subclassing too.
  prefs: []
  type: TYPE_NORMAL
- en: 'So instead of direct field access in Java, we usually write *accessor* methods:
    getters and (if need be) setters. Getters usually do nothing except return the
    value of a field, but they may instead compute a value from other fields. Setters
    may maintain invariants or fire events as well as update a field or, perhaps,
    more than one field.'
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, though, data is just data. When it is, then direct access to public
    fields may be fine, especially when we have immutable values (which is to say,
    final fields of immutable types). For more complicated models, polymorphic behavior
    and/or a uniform way of accessing values from either a field or a calculation
    become useful, and accessor methods come into their own.
  prefs: []
  type: TYPE_NORMAL
- en: The Kotlin designers choose to take the decision away from us and only support
    accessor methods. The language doesn’t support giving direct access to fields.
    Kotlin will generate code to access public fields of Java classes but does not
    define public fields itself. (A special annotation, `@JvmField`, provides a back
    door if you really need it.) They did this to encourage us to use accessors so
    that we can change representations without affecting clients.
  prefs: []
  type: TYPE_NORMAL
- en: To encourage accessors further, Kotlin allows us to generate both a private
    member-variable and an accessor in a single *property* declaration.
  prefs: []
  type: TYPE_NORMAL
- en: 'So in Java we can give access to a field directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, we can write our own accessor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In Kotlin, we only have properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This declaration will generate private fields: `givenName`, `familyName`, and
    `dateOfBirth`, accessor methods `getGivenName()` and so on, and a constructor
    to initialize all the fields.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java, we can access (visible) fields directly or call accessors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In Kotlin, we can access visible fields (from Java classes) directly or call
    accessors as if they were fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Properties are a convenience backed by some compiler magic. They make it as
    simple to use fields and accessors in Kotlin as plain old fields in Java, so we
    will naturally write code that can take advantage of encapsulation. For example,
    we might find that we want to define a property in an interface or compute a property
    that we previously stored.
  prefs: []
  type: TYPE_NORMAL
- en: '*Computed* properties are those not backed by a field. If we have `givenName`
    and `familyName` backed by fields, there is no need to store `fullName`; we can
    compute it when we need it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If we use direct-field access in Java, there is now a difference between the
    way we access the stored and computed properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This isn’t the case in Kotlin, even when accessing the Java fields and methods,
    which is nice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In Kotlin, we define computed properties outside the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'So, in Java, we *can* define classes that give direct access to fields, but
    *should* generally use accessors, which are just methods named (by convention
    but not always) with a `get` or `set` prefix. In Kotlin, we cannot define fields
    and accessors separately. When we define a property in Kotlin, the compiler generates
    a field and accessors that follow the Java naming convention. When we refer to
    a property in Kotlin, the syntax is the same as Java’s syntax for field access,
    but the compiler generates a call to the accessor. This even applies across the
    interop boundary: when we refer to properties of Java objects, the compiler will
    generate a call to the accessor if one exists and follows the Java naming convention.'
  prefs: []
  type: TYPE_NORMAL
- en: How to Choose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Returning to the question at the beginning of the chapter: given that computed
    properties are just methods with sugar on top, when should we choose a computed
    property, and when should we choose a method?'
  prefs: []
  type: TYPE_NORMAL
- en: A good rule of thumb is to use a property when it depends only on other properties
    on the type and is cheap to compute. This applies to `fullName`, so that is a
    good computed property. What about a person’s age?
  prefs: []
  type: TYPE_NORMAL
- en: We can compute age easily (ignoring time zones) from the `dateOfBirth` property,
    so we might be tempted in Java to write `fred.getAge()`. But this doesn’t depend
    only on other properties, it also depends on when we call it. Unlikely though
    it is, `fred.age == fred.age` can return `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Age is an action ([“Actions”](ch07.html#actions)); its result depends on when
    it is called. Properties should be calculations ([“Calculations”](ch07.html#calculations)),
    timeless and dependent only on their inputs, in this case the `dateOfBirth` property.
    Hence `age()` should be a function, not a property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'What about a cryptographic hash of all the other properties of the object?
    This is a calculation (for immutable objects), but if it is expensive to compute,
    it should be a method `hash()` not a property `hash`. We might even want to hint
    at the cost of the method in its name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We could make a property by calculating it up front and storing it in a field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This has the disadvantage of making every instance slow to create, whether
    or not its `hash` is ever accessed. We might split the difference with a lazy
    property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In a limited scope this would be fine, but if the class was more widely used,
    we should at least hint at the potential first-invocation performance issue by
    hiding the computed property behind a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we might consider an extension property. As we saw in [Chapter 10](ch10.html#functions-to-extension-functions),
    though, extension properties can only be computed rather than backed by a field
    and so cannot be lazy. Apart from that, most of the discussion here also applies
    to extension functions versus extension properties.
  prefs: []
  type: TYPE_NORMAL
- en: Mutable Properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So what of mutable properties? Kotlin allows us to define properties as `var`,
    for variable.
  prefs: []
  type: TYPE_NORMAL
- en: If you’ve read this far, you’ll know that your authors like to keep their data
    ([Chapter 5](ch05.html#beans-to-values)) and collections ([Chapter 6](ch06.html#java-to-kotlin-collections))
    immutable. We can *imagine* using Kotlin to define a mutable property to integrate
    with some Java code that required it, but very, very rarely use mutable public
    properties in practice. We might occasionally define a property that will change
    over time (to give access to a count, for example), but almost never one that
    clients can set. In practice, we find that data classes with copy methods work
    better in almost all situations that might have called for a setter; in fact,
    we would go as far as to say that allowing `var` properties in data classes was
    a language design mistake.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring to Properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: IntelliJ provides excellent refactoring support for converting between Kotlin
    methods and properties. This is on the one hand simple, because both are simply
    method calls, and on the other complicated, because Java interop relies on naming
    conventions to identify accessors. Let’s look at an example from Travelator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of our hardier clients like to camp, so we list campsites in the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 11.1 [methods-to-properties.0:src/main/java/travelator/CampSite.java]](https://java-to-kotlin.dev/code.html?ref=11.1&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=11.1&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: This is typical of a domain class that has grown over the years. It has lots
    of properties, some backed by fields like `id` and `name`, and some computed (for
    low values of compute) like `countryCode` and `region`. Someone ignored bean conventions
    by naming an accessor `region` rather than `getRegion`, but it is clear to us
    what they meant.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s some code that uses the accessors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 11.2 [methods-to-properties.0:src/main/java/travelator/CampSites.java]](https://java-to-kotlin.dev/code.html?ref=11.2&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=11.2&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s convert `Campsite` to Kotlin with IntelliJ (and then make it a data class):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 11.3 [methods-to-properties.1:src/main/java/travelator/CampSite.kt]](https://java-to-kotlin.dev/code.html?ref=11.3&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=11.3&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our field-backed properties have become constructor properties, and the computed
    `countryCode` a computed property. However, IntelliJ has not realized that `region`
    is a property, because it didn’t obey getter naming conventions and has simply
    converted the method. The net result is that client code doesn’t need to change.
    If we want to correct the oversight, we can Alt-Enter on `region` and “Convert
    function to property”, yielding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 11.4 [methods-to-properties.2:src/main/java/travelator/CampSite.kt]](https://java-to-kotlin.dev/code.html?ref=11.4&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=11.4&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'As with most computed properties, this is better as a single expression (see
    [Chapter 9](ch09.html#multi-to-single-expression-functions)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 11.5 [methods-to-properties.3:src/main/java/travelator/CampSite.kt]](https://java-to-kotlin.dev/code.html?ref=11.5&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=11.5&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Changing the Kotlin `region` method to a property means that the accessor method
    will now be named `getRegion`; thankfully, IntelliJ is smart enough to fix up
    our clients for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 11.6 [methods-to-properties.3:src/main/java/travelator/CampSites.java]](https://java-to-kotlin.dev/code.html?ref=11.6&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=11.6&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: '[![1](assets/1.png)](#co_introduction_CO19-1)'
  prefs: []
  type: TYPE_NORMAL
- en: '`campsite.region()` has been replaced by `campsite.getRegion()`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we now convert `sitesInRegion` to Kotlin, we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 11.7 [methods-to-properties.4:src/main/java/travelator/CampSites.kt]](https://java-to-kotlin.dev/code.html?ref=11.7&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=11.7&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: '[![1](assets/1.png)](#co_introduction_CO20-1)'
  prefs: []
  type: TYPE_NORMAL
- en: '`campsite.getRegion()` is now invoked by `campsite.region`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We saw how to move `sitesInRegion` to the top level in [Chapter 8](ch08.html#static-methods-to-top-level-functions),
    and to an extension function in [Chapter 10](ch10.html#functions-to-extension-functions):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 11.8 [methods-to-properties.5:src/main/java/travelator/CampSites.kt]](https://java-to-kotlin.dev/code.html?ref=11.8&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=11.8&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: '*Streams to Iterables to Sequences* ([Chapter 13](ch13.html#streams-to-sequences))
    and *Multi- to Single-Expression Functions* ([Chapter 9](ch09.html#multi-to-single-expression-functions))
    show how to finish the job to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 11.9 [methods-to-properties.6:src/main/java/travelator/CampSites.kt]](https://java-to-kotlin.dev/code.html?ref=11.9&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=11.9&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: Due to the excellent tooling and interop around methods, accessors, and properties,
    this has been a mercifully short refactor. So we crave your indulgence while we
    add just one more tweak.
  prefs: []
  type: TYPE_NORMAL
- en: '`sitesInRegion` is a bit of an odd method. It is making up for a deficiency
    in our modeling, which is that regions are just strings not entities. Without
    the country code, if we filter just on region name “Hampshire,” we risk returning
    a set of sites, most of which are in an English county, but where one (Moonlight
    Camping—it sounds lovely) is on a Canadian island. Until we can fix that, what
    if we pull the filter predicate out into its own method?'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 11.10 [methods-to-properties.7:src/main/java/travelator/CampSites.kt]](https://java-to-kotlin.dev/code.html?ref=11.10&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=11.10&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have `Campsite.isIn(...)`, maybe `sitesInRegion` could be inlined
    into the places that call it, because the code is now really quite self-explanatory.
    We prefer to find and publish the fundamental operations that clients can build
    on, rather than hiding them inside functions. Pulling on this thread, we might
    expand the functionality of `isIn` by making `region` optional:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 11.11 [methods-to-properties.8:src/main/java/travelator/CampSites.kt]](https://java-to-kotlin.dev/code.html?ref=11.11&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=11.11&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Nat prefers the same, but with an Elvis operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 11.12 [methods-to-properties.9:src/main/java/travelator/CampSites.kt]](https://java-to-kotlin.dev/code.html?ref=11.12&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=11.12&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: Duncan likes a good Elvis but thinks the code is clearer his way. Your team
    will probably have these little battles (choose Duncan’s way).
  prefs: []
  type: TYPE_NORMAL
- en: A fundamental operation like `isIn` might now be promoted to a method (as opposed
    to an extension function) on `Campsite` or, even better, `Address`. This way,
    the problem of regions not being entities is confined to the type closest to the
    problem, and fixing it there will have the least effect on the rest of the codebase.
  prefs: []
  type: TYPE_NORMAL
- en: Moving On
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kotlin provides a convenient syntax for both field-backed and computed properties
    that allows us to express the difference between accessing a property and calling
    a function, even if they are the same message-passing mechanism under the hood.
  prefs: []
  type: TYPE_NORMAL
- en: We should prefer a property to a method when it applies to a value type, depends
    only on the value, and is not expensive to compute. In these cases, refactoring
    from a method to a property is simple and makes our code easier to understand.
  prefs: []
  type: TYPE_NORMAL
