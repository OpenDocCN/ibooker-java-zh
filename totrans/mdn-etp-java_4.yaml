- en: Chapter 4\. A Kubernetes-Based Software Development Platform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we outlined our methodology around modernization and
    the steps required to design and develop modern architectures. We described the
    need for a platform like Kubernetes that can help you with requirements to make
    your applications cloud native, ready to scale up proportionally to your business’s
    need.
  prefs: []
  type: TYPE_NORMAL
- en: We have also demonstrated that a microservices-based architecture is usually
    implemented using container technology, which makes apps portable and consistent.
    Let’s now see in detail how Kubernetes can help us modernize our Java applications
    and what the steps are to achieve that using its declarative approach through
    a rich set of APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Developers and Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Kubernetes](https://kubernetes.io), which in Greek translates to “pilot” or
    “governor,” is an open source project that is currently the de facto target environment
    for modern architectures and the most popular container orchestration platform;
    a simple illustration is presented in [Figure 4-1](#fig4-1). Started from Google’s
    experience in managing distributed complex applications for their software stack
    back in 2015, today it is one of the biggest open source communities; it is managed
    by a foundation, the Cloud Native Computing Foundation (CNCF), and embraced by
    vendors and individual contributors.'
  prefs: []
  type: TYPE_NORMAL
- en: '![A Kubernetes Cluster running apps in Nodes](Images/moej_0401.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-1\. A Kubernetes cluster running apps in Nodes
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'As a container-orchestration platform, its focus is primarily on ensuring that
    our apps are running correctly, providing out-of-the-box self-healing, recovery,
    and a powerful API to control this mechanism. You may be wondering now: as a developer,
    why should I care about Kubernetes if it is so self-proficient?'
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s a good question, and maybe a good answer is an analogy: you have a Formula
    1 car with autopilot, but if you want to win the race, you need to tune and set
    up your car to compete with all other good ones. The same is true for your apps,
    which can benefit from all the capabilities offered by the platform to tune them
    so they run optimally.'
  prefs: []
  type: TYPE_NORMAL
- en: What Kubernetes Does
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you have Kubernetes as a target platform to run your applications, you
    can rely on an ecosystem of APIs and components put in place to make deployments
    easier so developers can focus only on the most important part: coding. Kubernetes
    provides you with [a framework to run distributed systems resiliently](https://oreil.ly/DNRQS).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In practice, this means you don’t need to reimplement custom solutions when
    it comes to:'
  prefs: []
  type: TYPE_NORMAL
- en: Service discovery
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes uses internal DNS resolution to expose your apps; this is automatically
    assigned and can also be used to send the traffic to multiple instances of your
    app.
  prefs: []
  type: TYPE_NORMAL
- en: Load balancing
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes takes care of managing the load on your apps, balancing the traffic,
    and distributing user requests accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Self-healing
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes discovers and replaces failing containers automatically, providing
    a health check and self-healing mechanism out of the box.
  prefs: []
  type: TYPE_NORMAL
- en: Rollout and Rollback
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes ensures your app is always running consistently at the desired state,
    providing control to scale up and scale down workloads. In addition, it offers
    the capability to rollout or rollback to a specific version of your application.
  prefs: []
  type: TYPE_NORMAL
- en: What Kubernetes Doesn’t Do
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many headaches that developers usually need to deal with in production are already
    solved and delegated to a platform, whose primary goal is to ensure applications
    are running. But does that provide all you need for modernizing your apps? Probably
    not.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we discussed in the previous chapter, the modernization steps toward a cloud
    native approach are more closely tied to a methodology rather than a specific
    technology. Once you’ve converted your mindset from building monolithic apps to
    creating microservices, we are in a good position to start thinking big. Nowadays,
    many apps run on cloud platforms targeting Kubernetes, and those are the ones
    running global-reach workloads. Here are some things to consider:'
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes doesn’t know how to handle your app. It can restart it if it fails,
    but it cannot understand why that is happening, so we need to ensure we have full
    control of our microservices-based architecture and be able to debug each container.
    This is particularly important in the case of a large-scale deployment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes doesn’t provide any middleware or application-level services. Granular
    discovery services need to be addressed by interacting with Kubernetes API or
    relying on some service on top of Kubernetes, such as a service mesh framework.
    There is no ecosystem for developers out of the box.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes doesn’t build your app. You are responsible for providing your app
    compiled and packaged as a container image or relying on additional components
    on top of Kubernetes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With that in mind, let’s start digging into a Kubernetes journey for developers
    in order to make our first step to bringing our app into the next cloud native
    production environment.
  prefs: []
  type: TYPE_NORMAL
- en: Infrastructure as a Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Kubernetes provides a set of APIs to manage the desired state of our app as
    well as the whole platform. Each component in Kubernetes has an API representation
    that can be consumed. Kubernetes offers a [declarative deployment pattern](https://oreil.ly/cURvG)
    that allows you to to automate the execution of upgrade and rollback processes
    for a group of Pods. The declarative approach is granular, and it is also used
    to extend Kubernetes APIs with the concept of *custom resources*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Custom resources are extensions of the Kubernetes API. A *custom resource* represents
    a customization of a particular Kubernetes installation, bringing additional objects
    to extend cluster capabilities. You can get more info about it from the official
    Kubernetes [documentation](https://oreil.ly/cVBnl).
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the core objects you have to manage an application in Kubernetes are:'
  prefs: []
  type: TYPE_NORMAL
- en: Pod
  prefs: []
  type: TYPE_NORMAL
- en: A group of one or more containers deployed into a Kubernetes cluster. This is
    the entity that Kubernetes manages and orchestrates, so any application packaged
    as a container needs to be declared as a Pod.
  prefs: []
  type: TYPE_NORMAL
- en: Service
  prefs: []
  type: TYPE_NORMAL
- en: The resource responsible for service discovery and load balancing. For any Pod
    to be discoverable and consumable, it needs to be mapped to a Service.
  prefs: []
  type: TYPE_NORMAL
- en: Deployment
  prefs: []
  type: TYPE_NORMAL
- en: This allows describing an application’s life cycle, driving the creation of
    Pods in terms of which images to use for the app, the number of Pods there should
    be, and how they should be updated. Furthermore, it helps to define health checks
    and constraint resources for your application.
  prefs: []
  type: TYPE_NORMAL
- en: Each of these objects, along with all other resources in the cluster, can be
    defined and controlled with a YAML representation, or by Kubernetes API. There
    are also other useful API objects such as those related to storage (PersistentVolume)
    or used specifically to manage stateful apps (StatefulSet). In this chapter, we
    will focus on the fundamental ones needed to bring your app up and running inside
    a Kubernetes platform.
  prefs: []
  type: TYPE_NORMAL
- en: Container Images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step for you in this journey is to containerize your microservices
    so they can be deployed into Kubernetes as a Pod, which is controlled by using
    a YAML file, invoking the API, or using a Kubernetes Java client.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the Inventory Quarkus microservice from Coolstore as an example
    to create your first container image. Containers are defined by a manifest called
    Dockerfile or Containerfile, where you will define your software stack as a layer,
    from the operating system layer to your application binary layer. The benefits
    of this approach are multiple: it is easy to track versions, inherit from existing
    layers, add layers, and expand the container. A diagram of layers is shown in
    [Figure 4-2](#fig4-2).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Container Image Layers](Images/moej_0402.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-2\. Container image layers
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Dockerfile
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Writing a Dockerfile to package our app as a container is pretty straightforward
    for simple use cases. There are some basic directives called *Instructions* to
    use, such as the ones listed in [Table 4-1](#dockerfile_instructions).
  prefs: []
  type: TYPE_NORMAL
- en: Table 4-1\. Dockerfile Instructions
  prefs: []
  type: TYPE_NORMAL
- en: '| Instruction | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `FROM` | Used to inherit from a base image. For example, it can be a Linux
    distribution like `fedora`, `centos`, `rhel`, `ubuntu`. |'
  prefs: []
  type: TYPE_TB
- en: '| `ENV` | Use environment variable for the container. These variables will
    be visible to the application and can be set at runtime. |'
  prefs: []
  type: TYPE_TB
- en: '| `RUN` | Execute a command in the current layer, like installing a package
    or executing an application. |'
  prefs: []
  type: TYPE_TB
- en: '| `ADD` | Copy files from your workstation to the container layer, like a JAR
    file or a configuration file. |'
  prefs: []
  type: TYPE_TB
- en: '| `EXPOSE` | If your application is listening to some port, you can expose
    it to the container network so Kubernetes can map it to a Pod and a Service. |'
  prefs: []
  type: TYPE_TB
- en: '| `CMD` | The command you use to start your application: the final step of
    the container image building process where you have all your dependencies in the
    layers, and you can run your app safely. |'
  prefs: []
  type: TYPE_TB
- en: The process for creating your container from your Dockerfile is also described
    in [Figure 4-3](#fig4-3).
  prefs: []
  type: TYPE_NORMAL
- en: '![Building a Container Image](Images/moej_0403.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-3\. Building a container image
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'An example of a Dockerfile for the Inventory Quarkus Java microservice that
    we created in [Chapter 2](ch02.xhtml#changing_technologies) is listed next, and
    you can find it in this [book’s GitHub repository](https://oreil.ly/D9u1k):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_a_kubernetes_based_software_development_platform_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We start from OpenJDK 11 layer to build our container image.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_a_kubernetes_based_software_development_platform_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Set an environment variable that can be consumed within the app for differentiating
    profiles or configurations to load.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_a_kubernetes_based_software_development_platform_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Copy the JAR artifact built during compilation into the container image. This
    supposes you have compiled a “fat-jar” or “uber-jar” that contains all dependencies
    in the same JAR file.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_a_kubernetes_based_software_development_platform_CO1-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Expose port 8080 to the container network.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](Images/5.png)](#co_a_kubernetes_based_software_development_platform_CO1-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Run the application invoking the artifact we copied into the layer.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we defined a Dockerfile with the minimum instructions set to
    build up a container image. Let’s see now how to create container images from
    a Dockerfile.
  prefs: []
  type: TYPE_NORMAL
- en: Building Container Images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now you need to create the container image. [Docker](https://www.docker.com)
    is a popular open source project to create containers; you can download it for
    your operating system and start using it to build and run your containers. [Podman](https://podman.io)
    is another open source alternative to do this, and it can also generate Kubernetes
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you have Docker or Podman on your workstation, you can start building
    your container from the Dockerfile with this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This will generate your container image by reading the instructions from the
    Dockerfile. Then it will tag your container image in the form `<repository>/<name>:<tag>`,
    in this case, `docker.io/modernizingjavaappsbook/inventory-quarkus:latest`. You
    will see an output similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Your container image is now stored in Docker’s or Podman’s local storage called
    *Docker cache* or *Container cache*, and it is ready to be used locally.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'You can create an Uber-Jar for production for the Inventory service with this
    command: `./mvnw package -Dquarkus.profile=prod`. You can let Docker or Podman
    compile your software and create the container using a particular kind of container
    images build called [Multi-stage](https://oreil.ly/HzhDj). See [this Dockerfile](https://oreil.ly/UK3c2)
    as an example.'
  prefs: []
  type: TYPE_NORMAL
- en: Run Containers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Running containers* refers to pulling the container images from the container
    cache to run applications. This process will be isolated by the container runtime
    (such as Docker or Podman) from the other ones in our workstation, providing a
    portable application with all dependencies managed inside a container and not
    in our workstation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To start testing the Inventory microservice packaged now as a container image,
    you can run the command below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You see that the Quarkus microservice is up and running in a container, listening
    to the port 8080\. Docker or Podman takes care of mapping container networking
    into your workstation; open your browser at [*http://localhost:8080*](http://localhost:8080),
    and you will see the Quarkus welcome page (as in [Figure 2-4](ch02.xhtml#fig2-4)).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '[Docker Network documentation](https://oreil.ly/ja9Iu) contains more info on
    how to map ports and networks within containers and hosts running Docker.'
  prefs: []
  type: TYPE_NORMAL
- en: Registry
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we described in the previous section, container images are stored in a local
    cache. However, if you want to make them available outside your workstation, you
    need to send them over in some convenient way. A container image’s size is generally
    hundreds of megabytes. That’s why you need a container image registry.
  prefs: []
  type: TYPE_NORMAL
- en: The registry essentially acts as a place to store container images and share
    them via a process of uploading to (pushing) and downloading from (pulling). Once
    the image is on another system, the original application contained within it can
    be run on that system as well.
  prefs: []
  type: TYPE_NORMAL
- en: Registries can be public or private. Popular public registries include [Docker
    Hub](https://hub.docker.com) and [Quay.io](https://quay.io). They are offered
    as a SaaS on the internet and allow images to be available publicly with or without
    authentication. Private registries are usually dedicated to specific users and
    are not accessible for public usage. However, you may make them available to private
    environments, such as private Kubernetes clusters.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we created an organization at DockerHub for the book, called
    `modernizingjavaappsbook`, that maps into a repository of this public registry
    where we want to push our container image.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you need to log in to the registry. You need to authenticate against
    it in order to be able to push new content, then you will leave the container
    image publicly available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'After you log in successfully, you can start uploading the Inventory container
    image to the registry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This command pushes the images to the registry, and you should get output similar
    to the following as confirmation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The Quarkus microservice, packaged as a container image, is now ready to be
    deployed everywhere!
  prefs: []
  type: TYPE_NORMAL
- en: Deploying to Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Deploying applications to Kubernetes is done by interacting with Kubernetes
    API to create the objects representing the desired state of the app in a Kubernetes
    cluster. As we discussed, Pods, Services, and Deployments are the minimum objects
    created to let Kubernetes manage the entire application life cycle and connectivity.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you don’t have a Kubernetes cluster yet, you can download and use [minikube](https://oreil.ly/n2Kgx),
    a standalone Kubernetes cluster designed for local development.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every object in Kubernetes contains the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: apiVersion
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes API version used to create this object
  prefs: []
  type: TYPE_NORMAL
- en: kind
  prefs: []
  type: TYPE_NORMAL
- en: The object type (e.g. Pod, Service)
  prefs: []
  type: TYPE_NORMAL
- en: metadata
  prefs: []
  type: TYPE_NORMAL
- en: Pieces of information that help uniquely identify the object, such as a name
    or UID
  prefs: []
  type: TYPE_NORMAL
- en: spec
  prefs: []
  type: TYPE_NORMAL
- en: The desired state for the object
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we defined the basic structure of any Kubernetes objects. Now,
    let’s explore the fundamental objects needed to run applications on top of Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Pod
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A [Pod](https://oreil.ly/KQk2T) is a group of one or more containers with shared
    storage and network resources and a specification for how to run the containers.
    In [Figure 4-4](#fig4-4), you can see a representation of two Pods in a Kubernetes
    cluster, with an example IP address assigned by Kubernetes to each of them.
  prefs: []
  type: TYPE_NORMAL
- en: '![Pods and containers](Images/moej_0404.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-4\. Pods and containers
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Kubernetes doesn’t work directly with containers; it relies on the Pod concept
    to orchestrate containers. As such, you need to provide a Pod definition that
    matches your container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_a_kubernetes_based_software_development_platform_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Name for the Pod object, unique per Namespace
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_a_kubernetes_based_software_development_platform_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: A list of key/value pairs to apply to this object
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_a_kubernetes_based_software_development_platform_CO2-3)'
  prefs: []
  type: TYPE_NORMAL
- en: A list of containers used in this Pod
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_a_kubernetes_based_software_development_platform_CO2-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The container image URI, in this case a repository publicly available in Docker
    Hub
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](Images/5.png)](#co_a_kubernetes_based_software_development_platform_CO2-5)'
  prefs: []
  type: TYPE_NORMAL
- en: The port exposed by this container, to be mapped into a Pod
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Generally, one Pod contains one container, thus the mapping is 1 Pod : 1 application.
    Although you could have multiple containers in one Pod for some use cases (e.g.,
    sidecars), the best practice is to map 1 Pod to 1 app, because this ensures scalability
    and maintainability.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create any of the Kubernetes objects described previously as a YAML
    file with the Kubernetes CLI `kubectl`. Run the command as shown next to deploy
    your first microservice as a single Pod. You can find it in this [book’s GitHub
    repository](https://oreil.ly/YF8bT):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'To check that it is running on Kubernetes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get an output similar to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: If you look at the `STATUS` column, it shows the Pod is running correctly and
    all default health checks are correctly satisfied.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you want further details on how to make more granular health checks, please
    refer to the official Kubernetes documentation for [liveness and readiness probes](https://oreil.ly/sOdnL).
  prefs: []
  type: TYPE_NORMAL
- en: Service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Kubernetes Services](https://oreil.ly/fOfpN) are used to expose an application
    running on a set of Pods. This is useful because a Pod gets a random IP address
    from the Kubernetes network, which may change if it is restarted or moved to another
    node within a Kubernetes cluster. Services offers a more consistent way to communicate
    with Pods, acting as a DNS server and load balancer.'
  prefs: []
  type: TYPE_NORMAL
- en: A Service is mapped to one or more Pods; it uses the internal DNS to resolve
    to an internal IP from a mnemonic short hostname (e.g., `inventory-quarkus`),
    and balances the traffic to the Pods as shown in [Figure 4-5](#fig4-5). Each Service
    get its own IP address from a dedicated IP address range, which is different from
    a Pod’s IP address range.
  prefs: []
  type: TYPE_NORMAL
- en: '![Kubernetes Service](Images/moej_0405.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-5\. A Kubernetes Service
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The balancing method offered by Kubernetes Services is Layer 4 (TCP/UDP). The
    only two strategies usable are round-robin and source IP. For application layer
    balancing (e.g., HTTP), there are other objects like `Ingress` not covered in
    this book, but you can find the documentation for them [here](https://oreil.ly/VBvOu).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a look at a Service that could map our Pod:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_a_kubernetes_based_software_development_platform_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Name for the Service object
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_a_kubernetes_based_software_development_platform_CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The label exposed by the Pod to match the Service
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_a_kubernetes_based_software_development_platform_CO3-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The L4 protocol used, TCP or UDP
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_a_kubernetes_based_software_development_platform_CO3-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The port used by this Service
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](Images/5.png)](#co_a_kubernetes_based_software_development_platform_CO3-5)'
  prefs: []
  type: TYPE_NORMAL
- en: The port used by the Pod and mapped into the Service
  prefs: []
  type: TYPE_NORMAL
- en: 'To create your Service, run the command as shown below. You can also find it
    in this [book’s GitHub repository](https://oreil.ly/e13Dd):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'To check that it is running on Kubernetes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get output similar to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You just defined a Service, mapped to a Pod. This is only accessible from the
    internal Kubernetes network, unless you expose it with an object that can accept
    the traffic from outside the cluster, like Ingress.
  prefs: []
  type: TYPE_NORMAL
- en: Deployment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Deployments are Kubernetes objects created for managing an application life
    cycle. A deployment describes a desired state, and Kubernetes will implement it
    using either a *rolling* or *re-create* deployment strategy. The rollout life
    cycle consists of progressing, complete, and failed states. A deployment is progressing
    while it is performing update tasks, such as updating or scaling Pods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Kubernetes deployments offer a set of capabilities on top of the basic Pod
    and Service concepts as listed next and in [Figure 4-6](#fig4-6):'
  prefs: []
  type: TYPE_NORMAL
- en: Deploy a ReplicaSet or Pod
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update Pods and ReplicaSets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rollback to previous deployment versions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scale a deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pause or continue a deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define health checks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define resources constraints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Deployments manage applications life-cycle and updates](Images/moej_0406.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-6\. Deployments manage an application’s life cycle and updates
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Managing applications with a Kubernetes deployment includes the way in which
    an application should be updated. A major benefit of a deployment is the ability
    to start and stop a set of Pods predictably. There are two strategies for deploying
    apps in Kubernetes:'
  prefs: []
  type: TYPE_NORMAL
- en: Rolling update
  prefs: []
  type: TYPE_NORMAL
- en: It provides a controlled, phased replacement of the application’s Pods, ensuring
    that there are always a minimum number available. This is useful for the business
    continuity of an application, where the traffic is not routed into a new version
    of the application until the health checks (probes) on the desired number of Pods
    deployed are satisfied.
  prefs: []
  type: TYPE_NORMAL
- en: Re-create
  prefs: []
  type: TYPE_NORMAL
- en: It removes all existing pods before new ones are created. Kubernetes first terminates
    all containers from the current version and then starts all new containers simultaneously
    when the old containers are gone. This provides downtime for the app, but it ensures
    there aren’t multiple versions running at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `Deployment` object driving Pods deployment on Kubernetes is listed in the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_a_kubernetes_based_software_development_platform_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Name for the Deployment object.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_a_kubernetes_based_software_development_platform_CO4-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The label for this object.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_a_kubernetes_based_software_development_platform_CO4-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The desired number of Pod replicas.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_a_kubernetes_based_software_development_platform_CO4-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The selector to find which Pods to manage using labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](Images/5.png)](#co_a_kubernetes_based_software_development_platform_CO4-5)'
  prefs: []
  type: TYPE_NORMAL
- en: The Pod template to use, including labels to inherit or containers to create.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](Images/6.png)](#co_a_kubernetes_based_software_development_platform_CO4-6)'
  prefs: []
  type: TYPE_NORMAL
- en: The container image to use.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](Images/7.png)](#co_a_kubernetes_based_software_development_platform_CO4-7)'
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes uses readiness probes to know when a container is ready to start
    accepting traffic, and a Pod is considered ready when all of its containers are
    ready. Here we define an HTTP health check on the root path as a readiness probe.
  prefs: []
  type: TYPE_NORMAL
- en: '[![8](Images/8.png)](#co_a_kubernetes_based_software_development_platform_CO4-8)'
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes uses liveness probes to know when to restart a container. Here we
    define an HTTP health check on the root path as a liveness probe.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to create your Deployment. You can also find it in
    this [book’s GitHub repository](https://oreil.ly/PWucG):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following command to verify that the Deployment has been created, and
    to get the status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get output similar to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Looking at the `READY` column, you have your desired state correctly matched,
    having requested one replica for the Inventory microservice running on Kubernetes.
    You can cross-check that a Pod has been created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get similar output to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now a new Pod has been created using a randomly generated name, starting from
    the `inventory-quarkus-deploy` Deployment name. If the app crashes or if we kill
    the Pod managed by the Deployment, Kubernetes will re-create it automatically
    for us. This is not true for the Pod generated without a Deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see that the desired state is always met:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get output similar to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Kubernetes and Java
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kubernetes has a tremendous amount of potential for managing applications’ life
    cycles, and there are a number of studies on how developers and architects could
    best fit in its architecture, like patterns. Kubernetes patterns are reusable
    design patterns for container-based applications and services.
  prefs: []
  type: TYPE_NORMAL
- en: 'From a Java developer perspective, the first step is to migrate from the monolithic
    approach to a microservice-based approach. Once that is complete, the next step
    is to get into the Kubernetes context and maximize the benefits this platform
    offers: API extendibility, a declarative model, and a standarized process where
    the IT industry is converging.'
  prefs: []
  type: TYPE_NORMAL
- en: There are Java frameworks that help developers connect to Kubernetes and convert
    their apps to containers. You already containerized the `Inventory` Quarkus microservice
    with a Dockerfile. Now let’s drive this containerization from Java, generating
    a container image for the `Catalog` Spring Boot microservice using Maven and Gradle.
  prefs: []
  type: TYPE_NORMAL
- en: Jib
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Jib](https://oreil.ly/N2jRr) is an open source framework made by Google to
    build container images compliant to the Open Container Initiative (OCI) image
    format, without the need of Docker or any container runtime. You can create containers
    even from your Java codebase because it offers a Maven and Gradle plug-in for
    that. This means Java developers can containerize their app without writing and/or
    maintaining any Dockerfiles, delegating this complexity to Jib.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We see the [benefits from this approach](https://oreil.ly/2y92D) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Pure Java
  prefs: []
  type: TYPE_NORMAL
- en: No Docker or Dockerfile knowledge is required; simply add Jib as a plug-in,
    and it will generate the container image for you. The resulting image is commonly
    referred to as “distroless,” since it doesn’t inherit from any base image.
  prefs: []
  type: TYPE_NORMAL
- en: Speed
  prefs: []
  type: TYPE_NORMAL
- en: The application is divided into multiple layers, splitting dependencies from
    classes. There’s no need to rebuild the container image as is necessary for Dockerfiles;
    Jib takes care of deploying the layers that changed.
  prefs: []
  type: TYPE_NORMAL
- en: Reproducibility
  prefs: []
  type: TYPE_NORMAL
- en: Unnecessary updates are not triggered, as the same contents always generate
    the same image.
  prefs: []
  type: TYPE_NORMAL
- en: 'The easiest way to kick-start a container image build with Jib, on existing
    Maven, is by adding the plug-in via command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can do so by adding Jib as a plug-in into *pom.xml*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In this way you can also manage other settings such as authentication or parameters
    for the build. Run the command below if you want to build the Catalog service
    and push it directly to Docker Hub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The authentication here is managed as command line options, but Jib is able
    to manage existing authentication with Docker CLI or read credentials from your
    *settings.xml*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The build takes a few moments, and the result is a distroless container image
    built locally and pushed directly to a registry, in this case Docker Hub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Your container image is not present in your local cache, as you don’t need any
    container runtime to build images with Jib. You won’t see it with the `docker
    images` command, but you pull it from Docker Hub afterward and it will be stored
    in your cache. In case you also want to store it locally from the beginning, Jib
    also connects to Docker hosts and can do it for you.
  prefs: []
  type: TYPE_NORMAL
- en: JKube
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Eclipse JKube](https://oreil.ly/Km2ci), a community project supported by the
    Eclipse Foundation and Red Hat, is another open source Java framework to help
    with interacting with Kubernetes from a Java developer perspective. It supports
    building container images using Docker/Podman, Jib, and Source-to-Image (S2I).
    Eclipse JKube also provides a set of tools to deploy automatically to Kubernetes
    and manage the application with helpers for debugging and logging. It comes from
    Fabric8 Maven Plug-in, rebranded and enhanced as a project to target Kubernetes.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: JKube supports Kubernetes and OpenShift. OpenShift brings [Source-to-Image](https://oreil.ly/4z2Zn)
    on top of Kubernetes, a mechanism to automatically compile a container image from
    source code. In this way the build is made on Kubernetes, so developers can test
    and deploy their apps directly on the target platform.
  prefs: []
  type: TYPE_NORMAL
- en: As with Jib, JKube provides Zero Configuration mode for a quick ramp-up where
    opinionated defaults will be preselected. It provides Inline Configuration within
    the plug-in configuration using an XML syntax. Furthermore, it provides External
    Configuration templates of real deployment descriptors, which are enriched by
    the plug-in.
  prefs: []
  type: TYPE_NORMAL
- en: 'JKube is offered in three forms:'
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes Plug-in
  prefs: []
  type: TYPE_NORMAL
- en: It works in any Kubernetes cluster, providing either distroless or Dockerfile-driven
    builds.
  prefs: []
  type: TYPE_NORMAL
- en: OpenShift Plug-in
  prefs: []
  type: TYPE_NORMAL
- en: It works in any Kubernetes or OpenShift cluster, providing either distroless,
    Dockerfile-driven builds, or Source-to-Image (S2I) builds.
  prefs: []
  type: TYPE_NORMAL
- en: JKube Kit
  prefs: []
  type: TYPE_NORMAL
- en: A toolkit and a CLI to interact with JKube Core, it also acts as a Kubernetes
    Client and provides an Enricher API to extend Kubernetes manifests.
  prefs: []
  type: TYPE_NORMAL
- en: JKube offers more functionality than Jib; in fact, it can be considered a superset.
    You can do distroless Jib builds, but you can also work with Dockerfile and deploy
    Kubernetes manifests from Java. In this case, we don’t need to write a Deployment
    or Service; JKube will take care of building the container and deploy it to Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s include JKube in our Catalog POM file and configure it to do a Jib build
    and a deploy to Kubernetes. Doing so will make the plug-in persistent. You can
    also find the source code in this [book’s GitHub repository](https://oreil.ly/Ba4Ro).
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to add JKube as a plug-in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, you can drive the container image build with properties. In this
    case, you may want to use Jib for building the image and pushing it to Docker
    Hub. Afterward, you will deploy it to Kubernetes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s build the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get output similar to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'JKube using Jib created the container image locally, and it is now ready to
    be pushed to Docker Hub. You can specify credentials in one of three ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Docker login
  prefs: []
  type: TYPE_NORMAL
- en: You can log in to your registry, in this case Docker Hub, and JKube will read
    the *~/.docker/config.json* file to get authentication details.
  prefs: []
  type: TYPE_NORMAL
- en: Provide credentials inside POM
  prefs: []
  type: TYPE_NORMAL
- en: Provide registry credentials as part of XML configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Provide credentials inside Maven Settings
  prefs: []
  type: TYPE_NORMAL
- en: You can provide registry credentials in your *~/.m2/settings.xml* file and the
    plug-in will read it from there.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, you use the third option and set up credentials into Maven Settings,
    so you can copy this file using your credentials. You can also find the source
    code in this [book’s GitHub repository](https://oreil.ly/uxAxW):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'To push it to Docker Hub, you just run this Maven goal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see output similar to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it’s time to deploy the Catalog on Kubernetes. JKube will connect to your
    Kubernetes cluster reading the `~/.kube/config` file on your workstation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get output similar to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The app has been deployed successfully to Kubernetes, using generated manifests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'To test it, let’s have a look at the Service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: By default, Kubernetes exposes the application only internally to the cluster,
    using `ClusterIP` Service type. You can expose it externally using a Service type
    `NodePort` or using an Ingress. In this example, you will use `kubectl port-forward`
    to map the Kubernetes exposed port to our workstation’s port.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try our app using the `kubectl port-forward` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: If you open your browser now at [*http://localhost:8080/api/catalog*](http://localhost:8080/api/catalog),
    you will see the Coolstore’s Catalog JSON output.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed how Java developers can benefit from Kubernetes
    capabilities to modernize and enhance their apps, showing a developer’s inner
    loop with Kubernetes environments. We have demonstrated how to create container
    images and how to deploy them to Kubernetes. We also walked through steps to drive
    container creation and deploy directly from Java with Maven thanks to Jib and
    JKube.
  prefs: []
  type: TYPE_NORMAL
- en: Modernization is important for developers in order to make apps cloud native
    and portable, ready for serving highly available productions and services. In
    the next chapter, we will look deeper into the modernization of existing Java
    applications and what steps are needed to achieve it.
  prefs: []
  type: TYPE_NORMAL
