- en: Chapter 1\. Introduction
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章 介绍
- en: This is a book about the art and science of Java performance.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本书讨论了Java性能的艺术和科学。
- en: The science part of this statement isn’t surprising; discussions about performance
    include lots of numbers and measurements and analytics. Most performance engineers
    have a background in the sciences, and applying scientific rigor is a crucial
    part of achieving maximum performance.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这个说法的科学部分并不令人惊讶；关于性能的讨论涉及大量的数字、测量和分析。大多数性能工程师背景都是科学，应用科学严谨性是实现最大性能的关键部分之一。
- en: What about the art part? The notion that performance tuning is part art and
    part science is hardly new, but it is rarely given explicit acknowledgment in
    performance discussions. This is partly because the idea of “art” goes against
    our training. But what looks like art to some people is fundamentally based on
    deep knowledge and experience. It is said that magic is indistinguishable from
    sufficiently advanced technologies, and certainly it is true that a cell phone
    would look magical to a knight of the Round Table. Similarly, the work produced
    by a good performance engineer may look like art, but that art is really an application
    of deep knowledge, experience, and intuition.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 艺术部分是什么呢？性能调优既是一部分艺术，又是一部分科学的概念并不新鲜，但在性能讨论中很少得到明确的承认。部分原因是“艺术”的概念与我们的训练相抵触。但对一些人来说看起来像艺术的东西，实质上基于深厚的知识和经验。据说魔术与高度先进的技术是无法区分的，确实，对于圆桌骑士来说，手机看起来就像是魔法一样。同样地，一名优秀的性能工程师所产生的工作可能看起来像艺术，但这种艺术实际上是深知识、经验和直觉的应用。
- en: This book cannot help with the experience and intuition part of that equation,
    but it can provide the deep knowledge—with the view that applying knowledge over
    time will help you develop the skills needed to be a good Java performance engineer.
    The goal is to give you an in-depth understanding of the performance aspects of
    the Java platform.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书无法帮助你在经验和直觉方面，但它可以提供深刻的知识——通过长期应用知识来帮助你发展成为一名优秀的Java性能工程师所需的技能。目标是让你深入了解Java平台的性能方面。
- en: 'This knowledge falls into two broad categories. First is the performance of
    the Java Virtual Machine (JVM) itself: the way that the JVM is configured affects
    many aspects of a program’s performance. Developers who are experienced in other
    languages may find the need for tuning to be somewhat irksome, though in reality
    tuning the JVM is completely analogous to testing and choosing compiler flags
    during compilation for C++ programmers, or to setting appropriate variables in
    a *php.ini* file for PHP coders, and so on.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这些知识分为两大类。第一类是Java虚拟机（JVM）本身的性能：JVM的配置方式影响程序性能的许多方面。其他语言有经验的开发者可能会觉得需要进行调优有些烦人，尽管事实上调优JVM完全类似于编译C++程序时的测试和选择编译器标志，或者为PHP编码者在*php.ini*文件中设置适当的变量等等。
- en: 'The second aspect is to understand how the features of the Java platform affect
    performance. Note the use of the word *platform* here: some features (e.g., threading
    and synchronization) are part of the language, and some features (e.g., string
    handling) are part of the standard Java API. Though important distinctions exist
    between the Java language and the Java API, in this case they will be treated
    similarly. This book covers both facets of the platform.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个方面是理解Java平台的特性如何影响性能。在这里，“平台”一词的使用很重要：一些特性（例如线程和同步）是语言的一部分，而一些特性（例如字符串处理）则是标准Java
    API的一部分。尽管Java语言和Java API之间有重要的区别，在这种情况下它们将被类似地对待。本书涵盖了平台的这两个方面。
- en: 'The performance of the JVM is based largely on tuning flags, while the performance
    of the platform is determined more by using best practices within your application
    code. For a long time, these were considered separate areas of expertise: developers
    code, and the performance group tests and recommends fixes for performance issues.
    That was never a particularly useful distinction—anyone who works with Java should
    be equally adept at understanding how code behaves in the JVM and what kinds of
    tuning are likely to help its performance. As projects move to a devops model,
    this distinction is starting to become less strict. Knowledge of the complete
    sphere is what will give your work the patina of art.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: JVM的性能在很大程度上取决于调优标志，而平台的性能更多地取决于在应用程序代码中使用最佳实践。长期以来，这些被认为是不同的专业领域：开发者编写代码，性能组测试并推荐性能问题的修复。这从未是一个特别有用的区分
    —— 任何与Java工作的人都应该同样擅长理解代码在JVM中的行为以及哪些调优可能有助于其性能。随着项目转向DevOps模型，这种区分开始变得不那么严格。对整个领域的了解才能使你的工作具有艺术的氛围。
- en: A Brief Outline
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简要概述
- en: 'First things first, though: [Chapter 2](ch02.html#SampleApplications) discusses
    general methodologies for testing Java applications, including pitfalls of Java
    benchmarking. Since performance analysis requires visibility into what the application
    is doing, [Chapter 3](ch03.html#Tools) provides an overview of some of the tools
    available to monitor Java applications.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先：[第二章](ch02.html#SampleApplications)讨论了测试Java应用程序的一般方法论，包括Java基准测试的陷阱。由于性能分析需要了解应用程序的操作，[第三章](ch03.html#Tools)概述了一些可用于监视Java应用程序的工具。
- en: 'Then it is time to dive into performance, focusing first on common tuning aspects:
    just-in-time compilation ([Chapter 4](ch04.html#JustInTimeCompilation)) and garbage
    collection ([Chapter 5](ch05.html#GC) and [Chapter 6](ch06.html#Collectors)).
    The remaining chapters focus on best-practice uses of various parts of the Java
    platform: memory use with the Java heap ([Chapter 7](ch07.html#Memory)), native
    memory use ([Chapter 8](ch08.html#NativeMemory)), thread performance ([Chapter 9](ch09.html#ThreadPerformance)),
    Java server technology ([Chapter 10](ch10.html#JavaServers)), database access,
    ([Chapter 11](ch11.html#Database)), and general Java SE API tips ([Chapter 12](ch12.html#Misc)).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是深入探讨性能的时候了，首先专注于常见的调优方面：即时编译（[第四章](ch04.html#JustInTimeCompilation)）和垃圾回收（[第五章](ch05.html#GC)和[第六章](ch06.html#Collectors)）。其余章节则侧重于Java平台各部分的最佳实践使用：Java堆内存使用（[第七章](ch07.html#Memory)）、本地内存使用（[第八章](ch08.html#NativeMemory)）、线程性能（[第九章](ch09.html#ThreadPerformance)）、Java服务器技术（[第十章](ch10.html#JavaServers)）、数据库访问（[第十一章](ch11.html#Database)）以及Java
    SE API的通用技巧（[第十二章](ch12.html#Misc)）。
- en: '[Appendix A](app01.html#FlagAppendix) lists all the tuning flags discussed
    in this book, with cross-references to the chapter where they are examined.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[附录A](app01.html#FlagAppendix)列出了本书讨论的所有调优标志，以及它们在哪些章节中进行了交叉引用。'
- en: Platforms and Conventions
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 平台与约定
- en: 'While this book is about the performance of Java, that performance will be
    influenced by a few factors: the version of Java itself, of course, as well as
    the hardware and software platforms it is running on.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然本书关注于Java的性能，但该性能将受到几个因素的影响：Java本身的版本，当然，以及它运行在的硬件和软件平台。
- en: Java Platforms
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Java平台
- en: This book covers the performance of the Oracle HotSpot Java Virtual Machine
    (JVM) and the Java Development Kit (JDK), versions 8 and 11\. This is also known
    as Java, Standard Edition (SE). The Java Runtime Environment (JRE) is a subset
    of the JDK containing only the JVM, but since the tools in the JDK are important
    for performance analysis, the JDK is the focus of this book. As a practical matter,
    that means it also covers platforms derived from the OpenJDK repository of that
    technology, which includes the JVMs released from the [AdoptOpenJDK project](http://adoptopenjdk.net).
    Strictly speaking, the Oracle binaries require a license for production use, and
    the AdoptOpenJdK binaries come with an open source license. For our purposes,
    we’ll consider the two versions to be the same thing, which we’ll refer to as
    the *JDK* or the *Java platform*.^([1](ch01.html#idm45775551886680))
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本书涵盖了 Oracle HotSpot Java 虚拟机（JVM）和 Java 开发工具包（JDK）的性能，分别针对版本 8 和 11。这也被称为 Java
    标准版（SE）。Java 运行环境（JRE）是 JDK 的子集，仅包含 JVM，但由于 JDK 中的工具对性能分析至关重要，本书将重点介绍 JDK。实际上，这意味着它还涵盖了从该技术的
    OpenJDK 代码库衍生出的平台，包括由 [AdoptOpenJDK 项目](http://adoptopenjdk.net) 发布的 JVM。严格来说，Oracle
    二进制文件需要许可证才能用于生产，而 AdoptOpenJDK 二进制文件则带有开源许可证。对于我们的目的，我们将认为这两个版本是同一件事情，我们将称之为
    *JDK* 或 *Java 平台*。^([1](ch01.html#idm45775551886680))
- en: These releases have gone through various bug fix releases. As I write this,
    the current version of Java 8 is jdk8u222 (version 222), and the current version
    of Java 11 is 11.0.5\. It is important to use at least these versions (if not
    later), particularly in the case of Java 8\. Early releases of Java 8 (through
    about jdk8u60) do not contain many of the important performance enhancements and
    features discussed throughout this book (particularly so with regard to garbage
    collection and the G1 garbage collector).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这些版本已经经历了各种错误修复版本。在我撰写本文时，Java 8 的当前版本是 jdk8u222（版本 222），Java 11 的当前版本是 11.0.5。重要的是至少使用这些版本（如果不是更高版本），特别是在
    Java 8 的情况下。Java 8 的早期版本（大约到 jdk8u60）不包含本书中讨论的许多重要性能增强和功能（特别是垃圾收集和 G1 垃圾收集器方面）。
- en: 'These versions of the JDK were selected because they carry long-term support
    (LTS) from Oracle. The Java community is free to develop their own support models
    but so far have followed the Oracle model. So these releases will be supported
    and available for quite some time: through at least 2023 for Java 8 (via AdoptOpenJDK;
    later via extended Oracle support contracts), and through at least 2022 for Java
    11\. The next long-term release is expected to be in late 2021.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 选择这些 JDK 版本是因为它们来自 Oracle 的长期支持（LTS）。Java 社区可以自由发展自己的支持模型，但到目前为止，他们一直在遵循 Oracle
    的模式。因此，这些发布版本将会得到支持，并且将在相当长的时间内可用：通过 AdoptOpenJDK 至少支持到 2023 年的 Java 8（稍后通过扩展的
    Oracle 支持合同），以及至少支持到 2022 年的 Java 11。预计下一个长期支持版本将在 2021 年底发布。
- en: 'For the interim releases, the discussion of Java 11 obviously includes features
    that were first made available in Java 9 or Java 10, even though those releases
    are unsupported both by Oracle and by the community at large. In fact, I’m somewhat
    imprecise when discussing such features; it may seem that I’m saying features
    X and Y were originally included in Java 11 when they may have been available
    in Java 9 or 10\. Java 11 is the first LTS release that carries those features,
    and that’s the important part: since Java 9 and 10 aren’t in use, it doesn’t really
    matter when the feature first appeared. Similarly, although Java 13 will be out
    at the time of this book’s release, there isn’t a lot of coverage of Java 12 or
    Java 13\. You can use those releases in production, but only for six months, after
    which you’ll need to upgrade to a new release (so by the time you’re reading this,
    Java 12 is no longer supported, and if Java 13 is supported, it will be soon replaced
    by Java 14). We’ll peek into a few features of these interim releases, but since
    those releases are not likely to be put into production in most environments,
    the focus remains on Java 8 and 11.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对于临时发布版本，显然 Java 11 的讨论包括最初在 Java 9 或 Java 10 中首次提供的功能，尽管这些版本都不受 Oracle 和整个社区的支持。事实上，当讨论这些功能时，我的描述可能有些不够准确；可能会让人觉得我在说功能
    X 和 Y 最初是在 Java 11 中包含的，但实际上它们可能在 Java 9 或 10 中就已经存在了。Java 11 是第一个包含这些功能的 LTS
    版本，这才是重要的部分：由于 Java 9 和 10 并未被使用，功能首次出现的时间并不重要。同样，尽管在本书发布时 Java 13 将会发布，但对 Java
    12 或 Java 13 的涵盖范围不是很广。您可以在生产中使用这些版本，但仅限于六个月，之后您将需要升级到新版本（所以当您阅读本书时，Java 12 已不再受支持，如果
    Java 13 受支持，它将很快被 Java 14 替代）。我们将简要介绍一些这些临时发布版本的功能，但由于这些版本不太可能在大多数环境中投入生产，因此重点仍然放在
    Java 8 和 11 上。
- en: Other implementations of the Java Language specification are available, including
    forks of the open source implementation. AdoptOpenJDK supplies one of these (Eclipse
    OpenJ9), and others are available from other vendors. Although all these platforms
    must pass a compatibility test in order to be able to use the Java name, that
    compatibility does not always extend to the topics discussed in this book. This
    is particularly true of tuning flags. All JVM implementations have one or more
    garbage collectors, but the flags to tune each vendor’s GC implementation are
    product-specific. Thus, while the concepts of this book apply to any Java implementation,
    the specific flags and recommendations apply only to the HotSpot JVM.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他可用的 Java 语言规范实现，包括开源实现的分支。AdoptOpenJDK 提供了其中一个（Eclipse OpenJ9），其他供应商也提供了其他实现。尽管所有这些平台都必须通过兼容性测试才能使用
    Java 名称，但这种兼容性并不总是延伸到本书讨论的主题。调整标志尤其如此。所有 JVM 实现都有一个或多个垃圾收集器，但调整每个供应商的 GC 实现的标志是产品特定的。因此，虽然本书的概念适用于任何
    Java 实现，但具体的标志和建议仅适用于 HotSpot JVM。
- en: That caveat is applicable to earlier releases of the HotSpot JVM—flags and their
    default values change from release to release. The flags discussed here are valid
    for Java 8 (specifically, version 222) and 11 (specifically, 11.0.5). Later releases
    could slightly change some of this information. Always consult the release notes
    for important changes.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 上述警告适用于 HotSpot JVM 的早期版本 —— 从一个版本到另一个版本，标志及其默认值可能会发生变化。本文讨论的标志适用于 Java 8（具体来说是版本
    222）和 11（具体来说是 11.0.5）。稍后的版本可能会轻微更改部分信息。请始终查阅发布说明以获取重要更改信息。
- en: At an API level, different JVM implementations are much more compatible, though
    even then subtle differences might exist between the way a particular class is
    implemented in the Oracle HotSpot Java platform and an alternate platform. The
    classes must be functionally equivalent, but the actual implementation may change.
    Fortunately, that is infrequent, and unlikely to drastically affect performance.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在 API 级别上，不同的 JVM 实现要兼容得多，尽管即便如此，在 Oracle HotSpot Java 平台和其他平台中实现特定类的方式之间可能仍存在细微差异。这些类必须在功能上等效，但实际实现可能会有所变化。幸运的是，这种情况并不经常发生，而且不太可能对性能造成重大影响。
- en: For the remainder of this book, the terms *Java* and *JVM* should be understood
    to refer specifically to the Oracle HotSpot implementation. Strictly speaking,
    saying “The JVM does not compile code upon first execution” is wrong; some Java
    implementations do compile code the first time it is executed. But that shorthand
    is much easier than continuing to write (and read), “The Oracle HotSpot JVM…”
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的剩余部分中，术语*Java*和*JVM*应理解为特指 Oracle HotSpot 实现。严格来说，说“JVM 在首次执行时不会编译代码”是错误的；一些
    Java 实现在首次执行时确实会编译代码。但使用这种简写比继续写（和阅读）“Oracle HotSpot JVM…”要简单得多。
- en: JVM tuning flags
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JVM 调整标志
- en: 'With a few exceptions, the JVM accepts two kinds of flags: boolean flags, and
    flags that require a parameter.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 除了一些例外，JVM 接受两种类型的标志：布尔标志和需要参数的标志。
- en: 'Boolean flags use this syntax: `-XX:+`*`FlagName`* enables the flag, and `-XX:-`*`FlagName`*
    disables the flag.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔标志使用以下语法：`-XX:+`*`FlagName`* 启用标志，`-XX:-`*`FlagName`* 禁用标志。
- en: 'Flags that require a parameter use this syntax: `-XX:`*`FlagName`*=*`something`*,
    meaning to set the value of `FlagName` to `something`. In the text, the value
    of the flag is usually rendered with something indicating an arbitrary value.
    For example, `-XX:NewRatio=`*`N`* means that the `NewRatio` flag can be set to
    an arbitrary value *`N`* (where the implications of *`N`* are the focus of the
    discussion).'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 需要参数的标志使用以下语法：`-XX:`*`FlagName`*=*`something`*，表示将 `FlagName` 的值设置为 `something`。在文本中，标志的值通常用表示任意值的
    something 表示。例如，`-XX:NewRatio=`*`N`* 意味着 `NewRatio` 标志可以设置为任意值 *`N`*（*`N`* 的含义是讨论的重点）。
- en: 'The default value of each flag is discussed as the flag is introduced. That
    default is often based on a combination of factors: the platform on which the
    JVM is running and other command-line arguments to the JVM. When in doubt, [“Basic
    VM Information”](ch03.html#VMInformation) shows how to use the `-XX:+PrintFlagsFinal`
    flag (by default, `false`) to determine the default value for a particular flag
    in a particular environment, given a particular command line. The process of automatically
    tuning flags based on the environment is called *ergonomics*.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 每个标志的默认值在引入标志时讨论。该默认值通常基于 JVM 运行的平台以及 JVM 的其他命令行参数的组合。如果有疑问，[“基本 VM 信息”](ch03.html#VMInformation)显示如何使用
    `-XX:+PrintFlagsFinal` 标志（默认为 `false`）来确定在特定环境中特定命令行下特定标志的默认值。根据环境自动调整标志的过程称为*人体工程学*。
- en: 'The JVM that is downloaded from Oracle and AdoptOpenJDK sites is called the
    *product build* of the JVM. When the JVM is built from source code, many builds
    can be produced: debug builds, developer builds, and so on. These builds often
    have additional functionality. In particular, developer builds include an even
    larger set of tuning flags so that developers can experiment with the most minute
    operations of various algorithms used by the JVM. Those flags are generally not
    considered in this book.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Oracle 和 AdoptOpenJDK 网站下载的 JVM 称为 JVM 的*产品构建*。当 JVM 从源代码构建时，可以产生许多构建：调试构建，开发者构建等。这些构建通常具有附加功能。特别是，开发者构建包含了更大量的调整标志集，使开发者可以实验
    JVM 使用的各种算法的最微小操作。这些标志通常不在本书中考虑。
- en: Hardware Platforms
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 硬件平台
- en: When the first edition of this book was published, the hardware landscape looked
    different than it does today. Multicore machines were popular, but 32-bit platforms
    and single-CPU platforms were still very much in use. Other platforms in use today—virtual
    machines and software containers—were coming into their own. Here’s an overview
    of how those platforms affect the topics of this book.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当本书的第一版出版时，硬件环境看起来与今天不同。多核机器很受欢迎，但 32 位平台和单 CPU 平台仍然在广泛使用。今天正在使用的其他平台——虚拟机和软件容器——正在崭露头角。以下是这些平台如何影响本书主题的概述。
- en: Multicore hardware
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多核硬件
- en: Virtually all machines today have multiple cores of execution, which appear
    to the JVM (and to any other program) as multiple CPUs. Typically, each core is
    enabled for hyper-threading. *Hyper-threading* is the term that Intel prefers,
    though AMD (and others) use the term *simultaneous multithreading*, and some chip
    manufactures refer to hardware strands within a core. These are all the same thing,
    and we’ll refer to this technology as hyper-threading.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 今天几乎所有的机器都有多个执行核心，对 JVM（以及任何其他程序）而言，这些核心看起来像多个 CPU。通常，每个核心都启用了超线程。*超线程*是英特尔首选的术语，虽然
    AMD（和其他公司）使用术语*同时多线程*，一些芯片制造商则称之为核心内的硬件线程。这些都是同一回事，我们将这项技术称为超线程。
- en: 'From a performance perspective, the important thing about a machine is its
    number of cores. Let’s take a basic four-core machine: each core can (for the
    most part) process independently of the others, so a machine with four cores can
    achieve four times the throughput of a machine with a single core. (This depends
    on other factors about the software, of course.)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 从性能的角度来看，机器的重要性在于其核心数。让我们以一个基本的四核机器为例：每个核心（大部分情况下）可以独立处理，因此一个有四个核心的机器可以实现比单核心机器高四倍的吞吐量。（当然，这取决于软件的其他因素。）
- en: 'In most cases, each core will contain two hardware or hyper-threads. These
    threads are not independent of each other: the core can run only one of them at
    a time. Often, the thread will stall: it will, for example, need to load a value
    from main memory, and that process can take a few cycles. In a core with a single
    thread, the thread stalls at that point, and those CPU cycles are wasted. In a
    core with two threads, the core can switch and execute instructions from the other
    thread.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，每个核心将包含两个硬件线程或超线程。这些线程不是彼此独立的：核心一次只能运行其中一个。通常情况下，线程会停滞：例如，它需要从主存中加载一个值，这个过程可能需要几个周期。在单线程核心中，线程在这一点上停滞，这些CPU周期就浪费了。在双线程核心中，核心可以切换并执行另一个线程的指令。
- en: 'So our four-core machine with hyper-threading enabled appears as if it can
    execute instructions from eight threads at once (even though, technically, it
    can execute only four instructions per CPU cycle). To the operating system—and
    hence to Java and other applications—the machine appears to have eight CPUs. But
    all of those CPUs are not equal from a performance perspective. If we run one
    CPU-bound task, it will use one core; a second CPU-bound task will use a second
    core; and so on up to four: we can run four independent CPU-bound tasks and get
    our fourfold increase in throughput.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们启用超线程的四核机器看起来可以同时执行来自八个线程的指令（即使在技术上，每个CPU周期只能执行四条指令）。对操作系统来说——因此对Java和其他应用程序来说——这台机器看起来有八个CPU。但是所有这些CPU在性能上并不相等。如果我们运行一个CPU密集型任务，它将使用一个核心；第二个CPU密集型任务将使用第二个核心；依此类推，最多四个：我们可以运行四个独立的CPU密集型任务并获得四倍的吞吐量提升。
- en: If we add a fifth task, it will be able to run only when one of the other tasks
    stalls, which on average turns out to happen between 20% to 40% of the time. Each
    additional task faces the same challenge. So adding a fifth task adds only about
    30% more performance; in the end, the eight CPUs will give us about five to six
    times the performance of a single core (without hyper-threading).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们添加第五个任务，它只有在其他任务之一停滞时才能运行，平均情况下这种情况发生的概率在20%到40%之间。每增加一个额外的任务都面临相同的挑战。因此，添加第五个任务只会增加大约30%的性能；最终，这八个CPU将给我们提供约五到六倍于单个核心（无超线程）的性能。
- en: You’ll see this example in a few sections. Garbage collection is very much a
    CPU-bound task, so [Chapter 5](ch05.html#GC) shows how hyper-threading affects
    the parallelization of garbage collection algorithms. [Chapter 9](ch09.html#ThreadPerformance)
    discusses in general how to exploit Java’s threading facilities to best effect,
    so you’ll see an example of the scaling of hyper-threaded cores there as well.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在几个部分看到这个例子。垃圾收集非常依赖CPU，因此[第五章](ch05.html#GC)展示了超线程如何影响垃圾收集算法的并行化。[第九章](ch09.html#ThreadPerformance)总结了如何充分利用Java的线程设施，您也将在那里看到超线程核心扩展的例子。
- en: Software containers
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 软件容器
- en: The biggest change in Java deployments in recent years is that they are now
    frequently deployed within a software container. That change is not limited to
    Java, of course; it’s an industry trend hastened by the move to cloud computing.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来Java部署中最大的变化是它们现在经常部署在软件容器中。当然，这种变化不仅限于Java，它是云计算推动的行业趋势。
- en: 'Two containers here are important. First is the virtual machine, which sets
    up a completely isolated copy of the operating system on a subset of the hardware
    on which the virtual machine is running. This is the basis of cloud computing:
    your cloud computing vendor has a data center with very large machines. These
    machines have potentially 128 cores, though they are likely smaller because of
    cost efficiencies. From the perspective of the virtual machine, that doesn’t really
    matter: the virtual machine is given access to a subset of that hardware. Hence,
    a given virtual machine may have two cores (and four CPUs, since they are usually
    hyper-threaded) and 16 GB of memory.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个重要的容器。首先是虚拟机，它在虚拟机运行的硬件子集上设置了操作系统的完全隔离副本。这是云计算的基础：你的云计算供应商有一个带有非常大机器的数据中心。这些机器可能有128个核心，尽管由于成本效益的原因，它们可能更小。从虚拟机的角度来看，这并不重要：虚拟机被授予对硬件子集的访问。因此，给定的虚拟机可能有两个核心（并且四个
    CPU，因为它们通常是超线程的）和16 GB 内存。
- en: From Java’s perspective (and the perspective of other applications), that virtual
    machine is indistinguishable from a regular machine with two cores and 16 GB of
    memory. For tuning and performance purposes, you need only consider it in the
    same way.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Java 的角度（以及其他应用程序的角度），这个虚拟机与一个具有两个核心和16 GB 内存的常规机器是无法区分的。为了调优和性能目的，你只需以相同的方式考虑它。
- en: The second container of note is the Docker container. A Java process running
    inside a Docker container doesn’t necessarily know it is in such a container (though
    it could figure it out by inspection), but the Docker container is just a process
    (potentially with resource constraints) within a running OS. As such, its isolation
    from other processes’ CPU and memory usage is somewhat different. As you’ll see,
    the way Java handles that differs between early versions of Java 8 (up until update
    192) and later version of Java 8 (and all versions of Java 11).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个需要注意的容器是 Docker 容器。运行在 Docker 容器中的 Java 进程并不一定知道它在这样一个容器中（尽管可以通过检查找出），但 Docker
    容器只是一个进程（可能有资源限制）在运行中的操作系统内。因此，它与其他进程在 CPU 和内存使用方面的隔离有所不同。正如你将看到的，Java 处理这一点在早期
    Java 8 版本（直至更新192）与后来的 Java 8 版本（以及所有 Java 11 版本）之间有所不同。
- en: 'By default, a Docker container is free to use all of the machine’s resources:
    it can use all the available CPUs and all the available memory on the machine.
    That’s fine if we want to use Docker merely to streamline deployment of our single
    application on the machine (and hence the machine will run only that Docker container).
    But frequently we want to deploy multiple Docker containers on a machine and restrict
    the resources of each container. In effect, given our four-core machine with 16
    GB of memory, we might want to run two Docker containers, each with access to
    only two cores and 8 GB of memory.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Docker 容器可以自由使用机器的所有资源：它可以使用机器上所有可用的 CPU 和所有可用的内存。如果我们只想要使用 Docker 来简化在机器上部署我们的单个应用程序（因此该机器将仅运行该
    Docker 容器），那没问题。但通常我们希望在一台机器上部署多个 Docker 容器并限制每个容器的资源。实际上，考虑到我们有四核心的机器和16 GB 内存，我们可能希望运行两个
    Docker 容器，每个容器仅访问两个核心和8 GB 内存。
- en: Configuring Docker to do that is simple enough, but complications can arise
    at the Java level. Numerous Java resources are configured automatically (or ergonomically)
    based on the size of the machine running the JVM. This includes the default heap
    size and the number of threads used by the garbage collector, explained in detail
    in [Chapter 5](ch05.html#GC), and some thread pool settings, mentioned in [Chapter 9](ch09.html#ThreadPerformance).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 配置 Docker 完成这一点相对简单，但在 Java 层面可能会出现复杂情况。根据运行 JVM 的机器的大小，许多 Java 资源会自动配置（或者根据人体工程学）。这包括默认堆大小和垃圾回收器使用的线程数，详细解释在[第5章](ch05.html#GC)中，以及一些线程池设置，在[第9章](ch09.html#ThreadPerformance)中提到。
- en: 'If you are running a recent version of Java 8 (update version 192 or later)
    or Java 11, the JVM handles this as you would hope: if you limit the Docker container
    to use only two cores, the values set ergonomically based on the CPU count of
    the machine will be based on the limit of the Docker container.^([2](ch01.html#idm45775551341432))
    Similarly, heap and other settings that by default are based on the amount of
    memory on a machine are based on any memory limit given to the Docker container.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在运行Java 8的最新版本（更新版本192或更高）或Java 11，JVM会如你所希望地处理这个问题：如果你将Docker容器限制为仅使用两个核心，基于机器CPU计数的人体工程学设置的值将基于Docker容器的限制。类似地，默认情况下基于机器上内存量的堆和其他设置将基于给定给Docker容器的任何内存限制。
- en: 'In earlier versions of Java 8, the JVM has no knowledge of any limits that
    the container will enforce: when it inspects the environment to find out how much
    memory is available so it can calculate its default heap size, it will see all
    the memory on the machine (instead of, as we would prefer, the amount of memory
    the Docker container is allowed to use). Similarly, when it checks how many CPUs
    are available to tune the garbage collector, it will see all the CPUs on the machine,
    rather than the number of CPUs assigned to the Docker container. As a result,
    the JVM will run suboptimally: it will start too many threads and will set up
    too large a heap. Having too many threads will lead to some performance degradation,
    but the real issue here is the memory: the maximum size of the heap will potentially
    be larger than the memory assigned to the Docker container. When the heap grows
    to that size, the Docker container (and hence the JVM) will be killed.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期的Java 8版本中，JVM对容器强制执行的任何限制都没有了解：当它检查环境以找出可用的内存量，以便计算其默认堆大小时，它将看到机器上的所有内存（而不是我们希望的Docker容器允许使用的内存量）。类似地，当它检查可用于调整垃圾收集器的CPU数量时，它将看到机器上的所有CPU，而不是分配给Docker容器的CPU数量。因此，JVM将运行不够优化：它会启动过多的线程，并设置过大的堆。拥有过多的线程会导致一些性能下降，但这里真正的问题是内存：堆的最大大小可能会大于分配给Docker容器的内存。当堆增长到该大小时，Docker容器（以及JVM）将被终止。
- en: In early Java 8 versions, you can set the appropriate values for the memory
    and CPU usage by hand. As we come across those tunings, I’ll point out the ones
    that will need to be adjusted for this situation, but it is better simply to upgrade
    to a later Java 8 version (or Java 11).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期的Java 8版本中，你可以手动设置内存和CPU使用的适当值。当我们遇到这些调整时，我会指出哪些需要针对这种情况进行调整，但最好的方法是直接升级到更新的Java
    8版本（或Java 11）。
- en: 'Docker containers provide one additional challenge to Java: Java comes with
    a rich set of tools for diagnosing performance issues. These are often not available
    in a Docker container. We’ll look at that issue a little more in [Chapter 3](ch03.html#Tools).'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Docker容器对Java提出了一个额外的挑战：Java配备了一套丰富的工具用于诊断性能问题。这些工具通常在Docker容器中不可用。我们将在[第三章](ch03.html#Tools)中更详细地讨论这个问题。
- en: The Complete Performance Story
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完整的性能故事
- en: This book is focused on how to best use the JVM and Java platform APIs so that
    programs run faster, but many outside influences affect performance. Those influences
    pop up from time to time in the discussion, but because they are not specific
    to Java, they are not necessarily discussed in detail. The performance of the
    JVM and the Java platform is a small part of getting to fast performance.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 本书专注于如何最佳利用JVM和Java平台API，以使程序运行更快，但许多外部影响会影响性能。这些影响偶尔会在讨论中出现，但因为它们不特定于Java，所以并未详细讨论。JVM和Java平台的性能只是快速性能的一小部分。
- en: This section introduces the outside influences that are at least as important
    as the Java tuning topics covered in this book. The Java knowledge-based approach
    of this book complements these influences, but many of them are beyond the scope
    of what we’ll discuss.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了至少与本书涵盖的Java调优主题同等重要的外部影响因素。本书基于Java知识的方法与这些影响互补，但其中许多超出了我们讨论的范围。
- en: Write Better Algorithms
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写更好的算法
- en: Many details about Java affect the performance of an application, and a lot
    of tuning flags are discussed. But there is no magical `-XX:+RunReallyFast` option.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Java的许多细节会影响应用程序的性能，并讨论了许多调优标志。但并没有神奇的`-XX:+RunReallyFast`选项。
- en: Ultimately, the performance of an application is based on how well it is written.
    If the program loops through all elements in an array, the JVM will optimize the
    way it performs bounds checking of the array so that the loop runs faster, and
    it may unroll the loop operations to provide an additional speedup. But if the
    purpose of the loop is to find a specific item, no optimization in the world is
    going to make the array-based code as fast as a different version that uses a
    hash map.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，应用程序的性能取决于编写的质量。如果程序循环遍历数组中的所有元素，JVM将优化它执行数组边界检查的方式，使得循环运行更快，并且它可能展开循环操作以提供额外的加速。但是，如果循环的目的是查找特定项，世界上没有任何优化可以使基于数组的代码像使用哈希映射的不同版本一样快。
- en: A good algorithm is the most important thing when it comes to fast performance.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到快速性能时，一个良好的算法是最重要的事情。
- en: Write Less Code
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 写更少的代码
- en: Some of us write programs for money, some for fun, some to give back to a community,
    but all of us write programs (or work on teams that write programs). It is hard
    to feel like you’re making a contribution to a project by pruning code, and some
    managers still evaluate developers by the amount of code they write.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们中的一些人为了赚钱编写程序，一些人为了乐趣，一些人为了回馈社区，但我们所有人都在编写程序（或者参与团队编写程序）。通过修剪代码来感觉自己在项目中做出贡献很难，有些经理仍然通过开发者编写的代码量来评估开发者。
- en: I get that, but the conflict here is that a small well-written program will
    run faster than a large well-written program. This is generally true for all computer
    programs, and it applies specifically to Java programs. The more code that has
    to be compiled, the longer it will take until that code runs quickly. The more
    objects that have to be allocated and discarded, the more work the garbage collector
    has to do. The more objects that are allocated and retained, the longer a GC cycle
    will take. The more classes that have to be loaded from disk into the JVM, the
    longer it will take for a program to start. The more code that is executed, the
    less likely that it will fit in the hardware caches on the machine. And the more
    code that has to be executed, the longer that execution will take.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我明白这一点，但这里的矛盾在于一个小而精良的程序将比一个大而精良的程序运行得更快。这对所有的计算机程序通常都是正确的，特别是适用于Java程序。需要编译的代码越多，程序启动运行的时间就越长。需要分配和丢弃的对象越多，垃圾收集器需要做的工作就越多。分配和保留的对象越多，垃圾收集周期就越长。需要从磁盘加载到JVM中的类越多，程序启动的时间就越长。执行的代码越多，它就越不可能适应机器上的硬件缓存。执行的代码越多，执行时间就越长。
- en: I think of this as the “death by 1,000 cuts” principle. Developers will argue
    that they are just adding a very small feature and it will take no time at all
    (especially if the feature isn’t used). And then other developers on the same
    project make the same claim, and suddenly the performance has regressed by a few
    percent. The cycle is repeated in the next release, and now program performance
    has regressed by 10%. A couple of times during the process, performance testing
    may hit a certain resource threshold—a critical point in memory use, a code cache
    overflow, or something like that. In those cases, regular performance tests will
    catch that particular condition, and the performance team can fix what appears
    to be a major regression. But over time, as the small regressions creep in, it
    will be harder and harder to fix them.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为这是“千刀万剐”的原则。开发者会争辩说他们只是添加一个非常小的功能，并且这几乎不需要时间（特别是如果该功能没有被使用）。然后同一项目中的其他开发者也会做同样的主张，突然间性能就退步了几个百分点。这个周期在下一个版本中重复，现在程序性能已经退步了10%。在过程中的几次，性能测试可能会达到某个资源阈值——内存使用的临界点、代码缓存溢出等等。在这些情况下，定期的性能测试将捕获到特定条件，性能团队可以修复看似重大的退化。但随着小的退化逐渐增加，修复它们将变得越来越困难。
- en: I’m not advocating that you should never add a new feature or new code to your
    product; clearly benefits result from enhancing programs. But be aware of the
    trade-offs you are making, and when you can, streamline.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我并不主张您永远不应该向产品添加新功能或新代码；显然增强程序会带来好处。但要意识到您正在做出的权衡，并且在可能时简化流程。
- en: Oh, Go Ahead, Prematurely Optimize
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 哦，继续，过早优化吧
- en: Donald Knuth is widely credited with coining the term *premature optimization,*
    which is often used by developers to claim that the performance of their code
    doesn’t matter, and if it does matter, we won’t know that until the code is run.
    The full quote, if you’ve never come across it, is “We should forget about small
    efficiencies, say about 97% of the time; premature optimization is the root of
    all evil.”^([3](ch01.html#idm45775551378952))
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 通常认为唐纳德·克努特(Donald Knuth)创造了“过早优化”(premature optimization)一词，开发人员经常使用这个词来声称他们的代码性能并不重要，如果性能确实重要，那么我们在运行代码之前就不会知道。如果你还没有见过完整的引用，那么就是这样：“我们应该忘记小效率，大约有97%的时间；过早优化是所有邪恶的根源。”（[3](ch01.html#idm45775551378952)）
- en: The point of this dictum is that in the end, you should write clean, straightforward
    code that is simple to read and understand. In this context, *optimizing* is understood
    to mean employing algorithmic and design changes that complicate program structure
    but provide better performance. Those kinds of optimizations indeed are best left
    undone until such time as the profiling of a program shows that a large benefit
    is gained from performing them.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这句格言的要点是，最终，你应该编写简洁、直接、易于阅读和理解的代码。在这种情况下，“优化”的理解是指采用复杂的算法和设计更改来复杂化程序结构，但提供更好的性能。这些类型的优化确实最好在程序的性能分析显示从中获得了巨大好处时再进行。
- en: What optimization does not mean in this context, however, is avoiding code constructs
    that are known to be bad for performance. Every line of code involves a choice,
    and if you have a choice between two simple, straightforward ways of programming,
    choose the better-performing one.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在这种情况下，“优化”并不意味着避免已知对性能有害的代码结构。每一行代码都涉及一种选择，如果你在两种简单、直接的编程方式之间进行选择，选择更高效的一种。
- en: 'At one level, this is well understood by experienced Java developers (it is
    an example of their art, as they have learned it over time). Consider this code:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个层面上，经验丰富的Java开发人员已经很好地理解了这一点（这是他们随着时间学会的艺术的一个例子）。考虑以下代码：
- en: '[PRE0]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This code does a string concatenation that is likely unnecessary, since the
    message won’t be logged unless the logging level is set quite high. If the message
    isn’t printed, unnecessary calls are also made to the `calcX()` and `calcY()`
    methods. Experienced Java developers will reflexively reject that; some IDEs will
    even flag the code and suggest it be changed. (Tools aren’t perfect, though: the
    NetBeans IDE will flag the string concatenation, but the suggested improvement
    retains the unneeded method calls.)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码进行了字符串拼接，这可能是不必要的，因为只有在设置了非常高的日志记录级别时才会记录消息。如果消息未打印，则还将不必要地调用`calcX()`和`calcY()`方法。有经验的Java开发人员会本能地拒绝这种做法；一些集成开发环境甚至会标记代码并建议修改它。（不过工具并不完美：NetBeans集成开发环境会标记字符串拼接，但建议的改进仍保留了不需要的方法调用。）
- en: 'This logging code is better written like this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这样写日志记录代码会更好：
- en: '[PRE1]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This avoids the string concatenation altogether (the message format isn’t necessarily
    more efficient, but it is cleaner), and there are no method calls or allocation
    of the object array unless logging has been enabled.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这避免了字符串拼接（消息格式不一定更有效，但更干净），并且除非启用了日志记录，否则不会调用方法或分配对象数组。
- en: Writing code in this way is still clean and easy to read; it took no more effort
    than writing the original code. Well, OK, it required a few more keystrokes and
    an extra line of logic. But it isn’t the type of premature optimization that should
    be avoided; it’s the kind of choice that good coders learn to make.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式编写代码仍然干净且易于阅读；它并没有比编写原始代码需要更多的工作量。好吧，好吧，它需要多输入一些按键和额外的逻辑行。但这并不是应该避免的过早优化类型；这是好程序员学会做出的选择。
- en: Don’t let out-of-context dogma from pioneering heroes prevent you from thinking
    about the code you are writing. You’ll see other examples of this throughout this
    book, including in [Chapter 9](ch09.html#ThreadPerformance), which discusses the
    performance of a benign-looking loop construct to process a vector of objects.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 不要让来自先驱英雄的脱离上下文的教条阻止你思考你正在编写的代码。本书中将在其他章节中看到类似的例子，包括第9章，在该章节中讨论了处理对象向量的看似无害的循环构造的性能问题。
- en: 'Look Elsewhere: The Database Is Always the Bottleneck'
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不妨另寻他路：数据库总是瓶颈。
- en: If you are developing standalone Java applications that use no external resources,
    the performance of that application is (mostly) all that matters. Once an external
    resource (a database, for example) is added, the performance of both programs
    is important. And in a distributed environment—say with a Java REST server, a
    load balancer, a database, and a backend enterprise information system—the performance
    of the Java server may be the least of the performance issues.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在开发没有使用外部资源的独立Java应用程序，那么该应用程序的性能（大多数情况下）是唯一重要的。一旦添加了外部资源（例如数据库），两个程序的性能都变得重要起来。在一个分布式环境中——例如具有Java
    REST服务器、负载均衡器、数据库和后端企业信息系统——Java服务器的性能可能是性能问题中最不重要的部分。
- en: This is not a book about holistic system performance. In such an environment,
    a structured approach must be taken toward all aspects of the system. CPU usage,
    I/O latencies, and throughput of all parts of the system must be measured and
    analyzed; only then can we determine which component is causing the performance
    bottleneck. Excellent resources are available on that subject, and those approaches
    and tools are not specific to Java. I assume you’ve done that analysis and determined
    that it is the Java component of your environment that needs to be improved.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一本关于整体系统性能的书。在这样的环境中，必须采取有条不紊的方法来处理系统的所有方面。必须测量和分析系统各部分的CPU使用率、I/O延迟和吞吐量；只有这样，我们才能确定哪个组件导致了性能瓶颈。有关该主题的优秀资源可供使用，并且这些方法和工具并不专门针对Java。我假设你已经进行了分析，并确定了需要改进的是你环境中的Java组件。
- en: 'On the other hand, don’t overlook that initial analysis. If the database is
    the bottleneck (and here’s a hint: it is), tuning the Java application accessing
    the database won’t help overall performance at all. In fact, it might be counterproductive.
    As a general rule, when load is increased into a system that is overburdened,
    performance of that system gets worse. If something is changed in the Java application
    that makes it more efficient—which only increases the load on an already overloaded
    database—overall performance may actually go down. The danger is then reaching
    the incorrect conclusion that the particular JVM improvement shouldn’t be used.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，不要忽视初始分析。如果数据库是瓶颈（提示：确实是），调整访问数据库的Java应用程序对整体性能毫无帮助。事实上，这可能适得其反。一般而言，当负载增加到一个负载过重的系统中时，该系统的性能变得更糟。如果在Java应用程序中做出了使其更有效的改变——这只会增加已经超负荷的数据库的负载——总体性能实际上可能会下降。危险就在于得出错误的结论，即不应该使用特定的JVM改进。
- en: This principle—that increasing load to a component in a system that is performing
    badly will make the entire system slower—isn’t confined to a database. It applies
    when load is added to a server that is CPU-bound or if more threads start accessing
    a lock that already has threads waiting for it or any number of other scenarios.
    An extreme example of this that involves only the JVM is shown in [Chapter 9](ch09.html#ThreadPerformance).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这个原则——在一个性能不佳的系统组件上增加负载会使整个系统变慢——并不局限于数据库。当负载增加到一个CPU密集型的服务器上，或者更多线程开始访问已经有线程在等待的锁，或者任何其他情况时，都会应用这个原则。一个仅涉及JVM的极端示例显示在[第九章](ch09.html#ThreadPerformance)中。
- en: Optimize for the Common Case
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优化常见情况
- en: 'It is tempting—particularly given the “death by 1,000 cuts” syndrome—to treat
    all performance aspects as equally important. But we should focus on the common
    use case scenarios. This principle manifests itself in several ways:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 很诱人——特别是考虑到“千刀万剐”的综合症——将所有性能方面视为同等重要。但我们应该专注于常见用例场景。这个原则以几种方式体现：
- en: Optimize code by profiling it and focusing on the operations in the profile
    taking the most time. Note, however, that this does not mean looking at only the
    leaf methods in a profile (see [Chapter 3](ch03.html#Tools)).
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过对代码进行分析并专注于在分析中占用最多时间的操作来优化代码。但是，请注意，这并不意味着只查看分析中的叶子方法（参见[第三章](ch03.html#Tools)）。
- en: 'Apply Occam’s razor to diagnosing performance problems. The simplest explanation
    for a performance issue is the most conceivable cause: a performance bug in new
    code is more likely than a configuration issue on a machine, which in turn is
    more likely than a bug in the JVM or operating system. Obscure OS or JVM bugs
    do exist, and as more credible causes for a performance issue are ruled out, it
    does become possible that somehow the test case in question has triggered such
    a latent bug. But don’t jump to the unlikely case first.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将奥卡姆剃刀应用于诊断性能问题。性能问题的最简单解释是最可信的原因：新代码中的性能 bug 比机器上的配置问题更有可能，后者比 JVM 或操作系统的 bug
    更有可能。晦涩的操作系统或 JVM bug 确实存在，随着排除更可信的性能问题的原因，可能发现某些测试用例不知何故触发了这种潜在 bug。但不要首先考虑不太可能的情况。
- en: Write simple algorithms for the most common operations in an application. Say
    a program estimates a mathematical formula, and the user can choose whether to
    get an answer within a 10% margin of error or a 1% margin. If most users will
    be satisfied with the 10% margin, optimize that code path—even if it means slowing
    down the code that provides the 1% margin of error.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为应用程序的最常见操作编写简单算法。例如，一个程序估算一个数学公式，用户可以选择是否在10%误差范围内得到答案，或者1%误差范围。如果大多数用户满意于10%的误差范围，优化该代码路径——即使这意味着减慢提供1%误差范围的代码。
- en: Summary
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概要
- en: Java has features and tools that make it possible to get the best performance
    from a Java application. This book will help you understand how best to use all
    the features of the JVM in order to end up with fast-running programs.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Java 具有使其可能从 Java 应用程序中获得最佳性能的特性和工具。本书将帮助您理解如何最好地利用 JVM 的所有特性，以便获得快速运行的程序。
- en: In many cases, though, remember that the JVM is a small part of the overall
    performance picture. A systemic approach to performance is required in Java environments
    where the performance of databases and other backend systems is at least as important
    as the performance of the JVM. That level of performance analysis is not the focus
    of this book—it is assumed due diligence has been performed to make sure that
    the Java component of the environment is the important bottleneck in the system.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在许多情况下，请记住 JVM 只是整体性能图景中的一小部分。在 Java 环境中，数据库和其他后端系统的性能至少与 JVM 的性能一样重要。本书不关注该级别的性能分析——假定已经进行了尽职调查，以确保
    Java 环境的组件是系统中重要的瓶颈。
- en: However, the interaction between the JVM and other areas of the system is equally
    important—whether that interaction is direct (e.g., the best way to make database
    calls) or indirect (e.g., optimizing native memory usage of an application that
    shares a machine with several components of a large system). The information in
    this book should help solve performance issues along those lines as well.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，JVM 与系统其他领域的交互同样重要——无论是直接的（例如，进行最佳的数据库调用方式）还是间接的（例如，优化共享大型系统多个组件的应用程序的本地内存使用）。本书中的信息应该有助于解决沿这些线路的性能问题。
- en: ^([1](ch01.html#idm45775551886680-marker)) Rarely, differences between the two
    exist; for example, the AdoptOpenJDK versions of Java contain new garbage collectors
    in JDK 11\. I’ll point out those differences when they occur.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch01.html#idm45775551886680-marker)) 很少情况下，这两者之间存在差异；例如，AdoptOpenJDK 版本的
    Java 在 JDK 11 中包含新的垃圾收集器。当发生这些差异时，我会指出这些差异。
- en: ^([2](ch01.html#idm45775551341432-marker)) You can specify fractional values
    for CPU limits in Docker. Java rounds up all fractional values to the next highest
    integer.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch01.html#idm45775551341432-marker)) 在 Docker 中，可以为 CPU 限制指定分数值。Java 将所有分数值都向上舍入到下一个最高整数。
- en: ^([3](ch01.html#idm45775551378952-marker)) There is some dispute over who said
    this originally, Donald Knuth or Topy Hoare, but it appears in an article by Knuth
    entitled “Structured Programming with `goto` Statements.” And in context, it is
    an argument *for* optimizing code, even if it requires inelegant solutions like
    a `goto` statement.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch01.html#idm45775551378952-marker)) 谁最初说过这句话，唐纳德·克努斯还是托尼·霍尔之间存在一些争议，但它出现在克努斯的一篇名为“带有
    `goto` 语句的结构化编程”的文章中。在上下文中，这是一个优化代码的论据，即使需要像 `goto` 语句这样的不优雅解决方案。
