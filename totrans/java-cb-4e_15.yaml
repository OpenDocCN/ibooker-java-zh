- en: Chapter 15\. Packages and Packaging
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 15 章 包和打包
- en: 15.0 Introduction
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 15.0 章 引言
- en: 'One of the better aspects of the Java language is that it has defined a very
    clear packaging mechanism for categorizing and managing its large API. Contrast
    this with most other languages, where symbols may be found in the C library itself
    or in any of dozens of other libraries, with no clearly defined naming conventions.^([1](ch15.html#idm45290635070328))
    APIs consist of one or more package, packages consist of classes, and classes
    consist of methods and fields. Anybody can create a package, with one important
    restriction: you or I cannot create a package whose name begins with the four
    letters `java`. Packages named `java`. or `javax`. are reserved for use by Oracle’s
    Java developers, under the management of the Java Community Process (JCP). When
    Java was new, there were about a dozen packages in a structure that is very much
    still with us, though it has quadrupled in size; some of these packages are shown
    in [Table 15-1](#javacook-packages-TABLE-1).'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Java 语言的一个更好的方面之一是它定义了一个非常清晰的打包机制，用于分类和管理其庞大的 API。与大多数其他语言相比，这些语言中的符号可能在 C 库本身或其他几十个库中找到，而没有明确定义的命名约定。^([1](ch15.html#idm45290635070328))
    API 包括一个或多个包，包括类，类包括方法和字段。任何人都可以创建一个包，但有一个重要的限制：你和我不能创建以四个字母 `java` 开头的包。以 `java.`
    或 `javax.` 命名的包是由 Oracle 的 Java 开发人员使用的，受 Java Community Process (JCP) 管理。当 Java
    刚推出时，大约有十几个包，这个结构至今仍然存在，尽管它的大小已经增加了四倍；其中一些包显示在 [Table 15-1](#javacook-packages-TABLE-1)
    中。
- en: Table 15-1\. Java packages basic structure
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Table 15-1\. Java 包基本结构
- en: '| Name | Function |'
  id: totrans-4
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 功能 |'
- en: '| --- | --- |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `java.awt` | Graphical user interface |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '| `java.awt` | 图形用户界面 |'
- en: '| `java.io` | Reading and writing |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '| `java.io` | 读写 |'
- en: '| `java.lang` | Intrinsic classes (`String`, etc.) |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '| `java.lang` | 内置类 (`String` 等) |'
- en: '| `java.lang.annotation` | Library support for annotation processing |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| `java.lang.annotation` | 注解处理的库支持 |'
- en: '| `java.math` | Math library |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| `java.math` | 数学库 |'
- en: '| `java.net` | Networking (sockets) |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| `java.net` | 网络 (套接字) |'
- en: '| `java.nio` | “New” I/O (not new anymore): channel-based I/O |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| `java.nio` | “New” I/O (不再是新的)：基于通道的 I/O |'
- en: '| `java.sql` | Java database connectivity |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| `java.sql` | Java 数据库连接 |'
- en: '| `java.text` | Handling and formatting/parsing dates, numbers, messages |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| `java.text` | 处理和格式化/解析日期、数字、消息 |'
- en: '| `java.time` | Java 8: modern date/time API (JSR-311) |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| `java.time` | Java 8：现代日期/时间 API (JSR-311) |'
- en: '| `java.util` | Utilities (collections, date) |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| `java.util` | 实用程序 (集合、日期) |'
- en: '| `java.util.regex` | Regular expressions |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| `java.util.regex` | 正则表达式 |'
- en: '| `javax.naming` | JNDI |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| `javax.naming` | JNDI |'
- en: '| `javax.print` | Support for printing |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| `javax.print` | 打印支持 |'
- en: '| `javax.script` | Java 6: scripting engines support |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `javax.script` | Java 6：脚本引擎支持 |'
- en: '| `javax.swing` | Modern graphical user interface |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| `javax.swing` | 现代图形用户界面 |'
- en: Many packages have been added over the years, but the initial structure has
    stood the test of time fairly well. In this chapter, I’ll show you how to create
    and document your own packages, and then I’ll discuss a number of issues related
    to deploying your package in various ways on various platforms.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来已经添加了许多包，但最初的结构在相当长的时间内经受住了考验。在本章中，我将向您展示如何创建和记录自己的包，然后讨论与在各种平台上以各种方式部署您的包相关的一些问题。
- en: This chapter also covers the more traditional meaning of packaging, as in, creating
    a package of your program for others to use. This covers the Java Platform Modules
    System (JPMS) introduced in Java 9. We also cover `jlink`, a tool for creating
    a mini-Java distribution containing your application and only the parts of the
    JDK that you actually use. We do not yet cover the `jpackage` tool for packaging
    applications, because it’s not yet in the JDK; it may arrive with Java 14 or 15.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还涵盖了包的更传统的含义，即为他人使用创建程序包。这包括了在 Java 9 中引入的 Java 平台模块系统 (JPMS)。我们还涵盖了 `jlink`，这是一个用于创建仅包含您实际使用的
    JDK 部分的迷你 Java 分发工具。我们还没有涵盖用于打包应用程序的 `jpackage` 工具，因为它尚未包含在 JDK 中；它可能会在 Java 14
    或 15 中推出。
- en: 15.1 Creating a Package
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 15.1 创建一个包
- en: Problem
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to be able to import classes and/or organize your classes, so you want
    to create your own package.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望能够导入类和/或组织您的类，因此您希望创建自己的包。
- en: Solution
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Put a `package` statement at the front of each file, and recompile with `-d`
    or a build tool or IDE.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个文件的开头放置一个 `package` 语句，并使用 `-d` 或构建工具或 IDE 重新编译。
- en: Discussion
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'The `package` statement must be the very first noncomment statement in your
    Java source file—preceding even `import` statements—and it must give the full
    name of the package. Package names are expected to start with your domain name
    backward; for example, my internet domain is *darwinsys.com*, so most of my packages
    begin with `com.darwinsys` and a project name. The utility classes used in this
    book and meant for reuse are in one of the `com.darwinsys` packages listed in
    [Recipe 1.6](ch01.html#javacook-getstarted-samplecode), and each source file begins
    with a statement, such as this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`package`语句必须是你的Java源文件中非注释语句的第一个语句，甚至必须在`import`语句之前，并且必须给出包的完整名称。包名预期以你的域名反向开始；例如，我的互联网域名是
    *darwinsys.com*，因此我的大多数包都以`com.darwinsys`和项目名称开头。本书中用于重复使用的实用类位于[Recipe 1.6](ch01.html#javacook-getstarted-samplecode)中列出的`com.darwinsys`包中，并且每个源文件都以这样的语句开头：'
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The demonstration classes in the *JavaSrc* repository do not follow this pattern;
    they are in packages with names related to the chapter they are in or the `java.*`
    package they relate to; for example, `lang` for basic Java stuff, `structure`
    for examples from the data structuring chapter ([Chapter 7](ch07.html#javacook-structure)),
    `threads` for the threading chapter ([Chapter 16](ch16.html#javacook-threads)),
    and so on. It is hoped that you will put them in a “real” package if you reuse
    them in your application!
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*JavaSrc*存储库中的演示类没有遵循这种模式；它们位于与它们所在章节或`java.*`包相关的命名的包中；例如，`lang`用于基本的Java内容，`structure`用于数据结构章节的示例（[Chapter 7](ch07.html#javacook-structure)），`threads`用于线程章节（[Chapter 16](ch16.html#javacook-threads)），等等。希望如果你在应用程序中重用它们，你会将它们放入一个“真正的”包中！'
- en: 'Once you have package statements in place, be aware that the Java runtime,
    and even the compiler, will expect the compiled *.class* files to be found in
    their rightful place (i.e., in the subdirectory corresponding to the full name
    somewhere in your `CLASSPATH` settings). For example, the class file for `com.darwinsys.util.FileIO`
    must *not* be in the file *FileIO.class* in my `CLASSPATH` but must be in *com/darwinsys/util/FileIO.class*
    relative to one of the directories or archives in my `CLASSPATH`. Accordingly,
    if you are compiling with the command-line compiler, it is customary (almost mandatory)
    to use the `-d` command-line argument when compiling. This argument must be followed
    by the name of an existing directory (often . is used to signify the current directory)
    to specify where to build the directory tree. For example, to compile all the
    *.java* files in the current directory, and create the directory path under it
    (e.g., create *./com/darwinsys/util* in the example), use this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你放置了包语句，请注意Java运行时甚至编译器都期望找到正确位置的编译后的 *.class* 文件（即在与完整名称对应的子目录中，这些子目录应该在你的`CLASSPATH`设置中）。例如，`com.darwinsys.util.FileIO`的类文件绝不能在我的`CLASSPATH`中的
    *FileIO.class* 文件中，而必须相对于`CLASSPATH`中的一个目录或存档中的 *com/darwinsys/util/FileIO.class*。因此，如果你正在使用命令行编译器编译，习惯上（几乎是强制性的）在编译时使用
    `-d` 命令行参数。此参数后必须跟随一个现有目录的名称（通常使用 . 表示当前目录），以指定构建目录树的位置。例如，要编译当前目录中的所有 *.java*
    文件，并在其中创建目录路径（例如，在示例中创建 *./com/darwinsys/util*），请使用以下命令：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This creates the path (e.g., *com/darwinsys/util/*) relative to the current
    directory and puts the class files into that subdirectory. This makes life easy
    for subsequent compilations and also for creating archives, which is covered in
    [Recipe 15.5](#javacook-packages-SECT-4).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在当前目录中创建路径（例如 *com/darwinsys/util/*），并将类文件放入该子目录中。这使得后续的编译和创建存档变得简单，这在[Recipe
    15.5](#javacook-packages-SECT-4)中有所涵盖。
- en: Of course, if you use a build tool such as Maven (see [Recipe 1.7](ch01.html#javacook-getstarted-maven)),
    this will be done correctly by default (Maven), so you won’t have to remember
    to keep doing it!
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果你使用像Maven这样的构建工具（见[Recipe 1.7](ch01.html#javacook-getstarted-maven)），这将会默认正确完成（Maven），所以你不必记得一直去做它！
- en: Note that in all modern Java environments, classes that do not belong to a package
    (the *anonymous package*) cannot be listed in an `import` statement, although
    they can be referred to by other classes in that package. They also cannot become
    part of a JPMS module.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在所有现代Java环境中，不属于包的类（匿名包）不能在`import`语句中列出，尽管它们可以被同一包中的其他类引用。它们也不能成为JPMS模块的一部分。
- en: 15.2 Documenting Classes with Javadoc
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 15.2 使用Javadoc文档化类
- en: Problem
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You have heard about this thing called *code reuse* and would like to promote
    it by allowing other developers to use your classes.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你听说过这个叫做*代码重用*的东西，并希望通过允许其他开发者使用你的类来推广它。
- en: Solution
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use javadoc. Write the comments when you write the code.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 使用javadoc。写代码时编写评论。
- en: Discussion
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'Javadoc is one of the great inventions of the early Java years. Like so many
    good things, it was not wholly invented by the Java folks; earlier projects such
    as Knuth’s Literate Programming had combined source code and documentation in
    a single source file. But the Java folks did a good job on it and came along at
    the right time. Javadoc is to Java classes what *man pages* are to Unix, or what
    Windows Help is to Windows applications: it is a standard format that everybody
    expects to find and knows how to use. Learn it. Use it. Write it. Live long and
    prosper (well, perhaps that’s not guaranteed). But all that HTML documentation
    that you learned from writing Java code, the complete reference for the JDK—did
    you think they hired dozens of tech writers to produce it? Nay, that’s not the
    Java way. Java’s developers wrote the documentation comments as they went along,
    and when the release was made, they ran javadoc on all the zillions of public
    classes and generated the documentation bundle at the same time as the JDK. You
    can, should, and really must do the same when you are preparing classes for other
    developers to use.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Java文档注释是Java早期伟大的发明之一。就像许多好东西一样，它并非完全由Java开发者发明；早期的项目如Knuth的文学编程已将源代码和文档结合在单个源文件中。但Java开发者们在正确的时间做了好事情。Javadoc对Java类而言，就像Unix的*man页面*或Windows应用程序的Windows帮助一样：这是每个人都期望找到并知道如何使用的标准格式。学习它。使用它。编写它。长命百岁（好吧，也许这并不是百分之百保证）。但是所有那些HTML文档，你从编写Java代码中学到的，JDK的完整参考资料——你是否认为他们雇佣了数十名技术作家来制作它？不，这不是Java的方式。Java的开发者们在编写代码的同时编写文档注释，并在发布时，在所有数以万计的公共类上运行javadoc，并同时生成文档捆绑包。当你为其他开发者准备类时，你可以、应该且真的必须这样做。
- en: All you have to do to use javadoc is to put special *javadoc comments* into
    your Java source files. These are similar to multiline Java comments, but they
    begin with a slash and *two* stars and end with the normal star-slash. Javadoc
    comments must appear immediately before the definition of the class, method, or
    field that they document; if placed elsewhere, they are ignored.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需在Java源文件中放入特殊的*javadoc注释*就可以使用javadoc。这些注释类似于多行Java注释，但以斜杠和*两个*星号开始，并以正常的星号斜杠结束。Javadoc注释必须出现在它们所文档化的类、方法或字段的定义之前；如果放在其他地方，它们将被忽略。
- en: A series of keywords, prefixed by the at sign, can appear inside doc comments
    in certain contexts. Some are contained in braces. The keywords as of Java 8 are
    listed in [Table 15-2](#javacook-packages-TABLE-2).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一系列关键字，以@符号为前缀，可以出现在特定上下文的文档注释中。其中一些包含在大括号中。截至Java 8，这些关键字列在[Table 15-2](#javacook-packages-TABLE-2)中。
- en: Table 15-2\. Javadoc keywords
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 表15-2\. Javadoc关键字
- en: '| Keyword | Use |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 关键字 | 使用 |'
- en: '| --- | --- |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `@author` | Author name(s) |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `@author` | 作者姓名 |'
- en: '| `{@code *text*}` | Displays text in code font without HTML interpretation
    |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `{@code *text*}` | 以代码字体显示文本，不解析HTML |'
- en: '| `@deprecated` | Causes deprecation warning |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `@deprecated` | 引发过时警告 |'
- en: '| `{@docroot}` | Refers to the root of the generated documentation tree |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `{@docroot}` | 指向生成文档树的根目录 |'
- en: '| `@exception` | Alias for `@throws` |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `@exception` | `@throws`的别名 |'
- en: '| `{@inheritDoc}` | Inherits documentation from nearest superclass/superinterface
    |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `{@inheritDoc}` | 从最近的超类/超接口继承文档 |'
- en: '| `@link` | Generates inline link to another class or member |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `@link` | 生成指向另一个类或成员的内联链接 |'
- en: '| `@linkplain` | As `@link` but displays in plain text |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `@linkplain` | 与`@link`类似，但以纯文本显示 |'
- en: '| `{@literal *text*}` | Displays text without interpretation |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `{@literal *text*}` | 以不解析形式显示文本 |'
- en: '| `@param *name description*` | Argument name and meaning (methods only) |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `@param *name description*` | 参数名称和含义（仅限方法） |'
- en: '| `@return` | Return value |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `@return` | 返回值 |'
- en: '| `@see` | Generate cross-reference link to another class or member |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `@see` | 生成到另一个类或成员的交叉引用链接 |'
- en: '| `@serial` | Describes serializable field |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `@serial` | 描述可序列化字段 |'
- en: '| `@serialData` | Describes order and types of data in serialized form |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `@serialData` | 描述序列化形式中数据的顺序和类型 |'
- en: '| `@serialField` | Describes serializable field |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `@serialField` | 描述可序列化字段 |'
- en: '| `@since` | JDK version in which introduced (primarily for Sun use) |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `@since` | JDK版本引入的版本（主要用于Sun使用） |'
- en: '| `@throws` | Exception class and conditions under which thrown |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `@throws` | 抛出的异常类及条件 |'
- en: '| `{@value [*ref*]}` | Displays values of this or another constant field |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `{@value [*ref*]}` | 显示此常量字段或另一个常量字段的值 |'
- en: '| `@version` | Version identifier |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `@version` | 版本标识符 |'
- en: '[Example 15-1](#javacook-packages-EX-1) is a somewhat contrived example that
    shows some common javadoc keywords in use. The output of running this through
    javadoc is shown in a browser in [Figure 15-1](#javacook-packages-FIG-1).'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '[Example 15-1](#javacook-packages-EX-1) 是一个有些刻意的示例，展示了一些常见的javadoc关键字的使用。将其通过javadoc运行后，在浏览器中显示的输出如
    [图 15-1](#javacook-packages-FIG-1) 所示。'
- en: Example 15-1\. main/src/main/java/javadoc/JavadocDemo.java
  id: totrans-70
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 15-1\. main/src/main/java/javadoc/JavadocDemo.java
- en: '[PRE2]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The javadoc tool works fine for one class but really comes into its own when
    dealing with a package or collection of packages. You can provide a package summary
    file for each package, which will be incorporated into the generated files. Javadoc
    generates thoroughly interlinked and crosslinked documentation, just like that
    which accompanies the standard JDK. There are several command-line options; I
    normally use `-author` and `-version` to get it to include these items, and often
    `-link` to tell it where to find the standard JDK to link to.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Javadoc对单个类的文档生成效果很好，但在处理包或多个包时效果更佳。您可以为每个包提供一个包摘要文件，该文件将被合并到生成的文件中。Javadoc生成的文档具有深度交叉链接，就像伴随标准JDK的文档一样。有几个命令行选项；我通常使用
    `-author` 和 `-version` 来包含这些信息，并经常使用 `-link` 告诉它在哪里找到标准JDK以进行链接。
- en: 'Run `javadoc -help` for a complete list of options, or see the full documentation
    online at [Oracle’s website](https://docs.oracle.com/en/java/javase/13/docs/specs/man/javadoc.html).
    [Figure 15-1](#javacook-packages-FIG-1) shows one view of the documentation that
    the class shown in [Example 15-1](#javacook-packages-EX-1) generates when run
    as the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `javadoc -help` 可获取完整的选项列表，或在线查看完整文档：[Oracle’s website](https://docs.oracle.com/en/java/javase/13/docs/specs/man/javadoc.html)。[图 15-1](#javacook-packages-FIG-1)
    展示了在运行 [Example 15-1](#javacook-packages-EX-1) 所示示例时生成的文档的视图：
- en: '[PRE3]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If you run this with Java 9+, it will also include a fully functional search
    box, shown in the upper right of [Figure 15-1](#javacook-packages-FIG-1). This
    is implemented in JavaScript, so it should work in any modern browser.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在Java 9+上运行此代码，还将包括一个完全功能的搜索框，显示在[图 15-1](#javacook-packages-FIG-1)的右上角。这是用JavaScript实现的，因此应该在任何现代浏览器中都能工作。
- en: Be aware that quite a few files are generated, and one of the generated files
    will have the same name as each class, with the extension *.html*. If you happened
    to have an HTML file documenting the class, and you generate javadoc in the source
    directory, the *.html* file is silently overwritten with the javadoc output. If
    you wish to avoid cluttering up your source directories with the generated files,
    the `-d __directorypath` option to javadoc allows you to place the generated files
    into the specified directory.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，会生成相当多的文件，并且每个生成的文件将与每个类的名称相同，扩展名为 *.html*。如果恰好有一个HTML文件记录了该类，并且您在源目录中生成了javadoc，那么该
    *.html* 文件将被静默地覆盖为javadoc输出。如果希望避免在源目录中生成文件导致混乱，可以使用javadoc的 `-d __directorypath`
    选项将生成的文件放置到指定目录中。
- en: '![jcb4 1501](assets/jcb4_1501.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![jcb4 1501](assets/jcb4_1501.png)'
- en: Figure 15-1\. Javadoc opened in a browser
  id: totrans-78
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 15-1\. Javadoc在浏览器中打开的视图
- en: See Also
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Javadoc has numerous other command-line arguments. If documentation is for your
    own use only and will not be distributed, you can use the `-link` option to tell
    it where your standard JDK documentation is installed so that links can be generated
    to standard Java classes (like `String`, `Object`, and so on). If documentation
    is to be distributed, you can omit `-link` or use `-link` with a URL to the appropriate
    Java API page on Oracle’s website. See the online tools documentation for all
    the command-line options.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Javadoc还有许多其他命令行参数。如果文档仅供您自己使用而不会分发，可以使用 `-link` 选项告诉它您的标准JDK文档的安装位置，以便生成到标准Java类（如
    `String`、`Object` 等）的链接。如果要分发文档，可以省略 `-link` 或使用 `-link` 与Oracle网站上适当Java API页面的URL。查看在线工具文档以获取所有命令行选项。
- en: The output that javadoc generates is fine for most purposes. It is possible
    to write your own `Doclet` class to make the javadoc program into a class documentation
    verifier, a Java-to-other-format (such as Java-to-RTF) documentation generator,
    or whatever you like. Those are actual examples; see the javadoc tools documentation
    that comes with the JDK for documents and examples, or go to [Oracle’s website](https://docs.oracle.com/en/java/javase/13/docs/specs/man/javadoc.html).
    Visit [Doclet](http://www.doclet.com) for a somewhat dated but useful collection
    of Doclets and other javadoc-based tools.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: javadoc生成的输出对大多数目的都很好。可以编写自己的`Doclet`类来将javadoc程序转换为类文档验证器、Java到其他格式（如Java到RTF）的文档生成器或其他任何你喜欢的工具。这些都是实际例子；请查看随JDK提供的javadoc工具文档和示例，或者访问[Oracle的网站](https://docs.oracle.com/en/java/javase/13/docs/specs/man/javadoc.html)。访问[Doclet](http://www.doclet.com)获取一些有点过时但有用的Doclets和其他基于javadoc的工具集。
- en: Javadoc Versus JavaHelp
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Javadoc与JavaHelp
- en: Javadoc is for programmers using your classes; for a GUI application, end users
    will probably appreciate standard online help. This is the role of the JavaHelp
    API, which is not covered in this book but is fully explained in *[Creating Effective
    JavaHelp](http://shop.oreilly.com/product/9781565927193.do)* by Kevin Lewis (O’Reilly),
    which every GUI application developer should read. JavaHelp is another useful
    specification that was somewhat left to coast during the Sun sellout to Oracle;
    it is now hosted on *java.net* at [javahelp](https://javaee.github.io/javahelp).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Javadoc适用于使用你的类的程序员；对于GUI应用程序，终端用户可能更喜欢标准的在线帮助。这就是JavaHelp API的角色，该API未在本书中涵盖，但在*[Creating
    Effective JavaHelp](http://shop.oreilly.com/product/9781565927193.do)* by Kevin
    Lewis (O’Reilly)中有全面解释，每个GUI应用程序开发者都应该阅读。JavaHelp是另一个有用的规范，Sun被Oracle收购期间有些被忽视；现在托管在*java.net*上，访问[javahelp](https://javaee.github.io/javahelp)。
- en: '15.3 Beyond Javadoc: Annotations/Metadata'
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 15.3 超越Javadoc：注解/元数据
- en: Problem
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to generate not just documentation from your source code, but also
    other code artifacts. You want to mark code for additional compiler verification.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要不仅从源代码生成文档，还要生成其他代码工件。你需要标记代码以进行额外的编译器验证。
- en: Solution
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the Java Annotations, or Metadata, facility.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Java Annotations或Metadata设施。
- en: Discussion
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: The continuing success of the open source tool [XDoclet](http://xdoclet.sourceforge.net)—originally
    used to generate the tedious auxiliary classes and deployment descriptor files
    for the widely criticized EJB2 framework—led to a demand for a similar mechanism
    in standard Java. Java *Annotations* were the result. The *annotation* mechanism
    uses an interface-like syntax, in which both declaration and use of annotations
    use the name preceded by an at character (`@`). This was chosen, according to
    the designers, to be reminiscent of “Javadoc tags, a preexisting ad hoc annotation
    facility in the Java programming language.” Javadoc is ad hoc only in the sense
    that its `@` tags were never fully integrated into the language; most were ignored
    by the compiler, but `@deprecated` was always understood by the compiler (see
    [Recipe 1.9](ch01.html#javacook-getstarted-SECT-9)).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 开源工具[XDoclet](http://xdoclet.sourceforge.net)的持续成功——最初用于为广受批评的EJB2框架生成繁琐的辅助类和部署描述符文件——导致标准Java中对类似机制的需求。Java
    *Annotations* 是其结果。*注解* 机制使用类似接口的语法，其中注解的声明和使用都使用前导符号（`@`）。设计者选择这种方式，是为了让人联想到“Javadoc标签”，这是Java编程语言中已有的一种特定注解设施。Javadoc只是在其`@`标签从未完全集成到语言中的意义上是特定的；大多数标签被编译器忽略，但`@deprecated`始终被编译器理解（参见[Recipe
    1.9](ch01.html#javacook-getstarted-SECT-9)）。
- en: Annotations can be read at runtime by use of the Reflection API; this is discussed
    in [Recipe 17.10](ch17.html#javacook-reflection-annotations), where I also show
    you how to define your own annotations. Annotations can also be read post–compile
    time by tools such as code generators (and others to be invented, perhaps by you,
    gentle reader!).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 注解可以在运行时通过反射API读取；这在[Recipe 17.10](ch17.html#javacook-reflection-annotations)中讨论，我还会向你展示如何定义自己的注解。注解也可以在编译后由代码生成器等工具读取（也许是你，亲爱的读者！）。
- en: Annotations are also read by *javac* at compile time to provide extra information
    to the compiler.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 注解还会被*javac*在编译时读取，向编译器提供额外信息。
- en: For example, a common coding error is overloading a method when you mean to
    override it, by mistakenly using the wrong argument type. Consider overriding
    the equals method in `Object`. If you mistakenly write
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个常见的编码错误是在你打算覆盖方法时重载它，因为你错误地使用了错误的参数类型。考虑在`Object`中覆盖`equals`方法。如果你误写了
- en: '[PRE4]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'then you have created a new overload that will likely never be called, and
    the default version in `Object` will be called. To prevent this, an annotation
    included in `java.lang` is the `Override` annotation. This has no parameters but
    simply is placed before the method call, like this:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 那么你已经创建了一个新的重载，很可能永远不会被调用，并且将调用`Object`中的默认版本。为了防止这种情况，在`java.lang`中包含的一个注解是`Override`注解。这个注解没有参数，只需简单地放置在方法调用之前，就像这样：
- en: '[PRE5]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Attempting to compile this results in a compiler error that the method in question
    does not override a method, even though the annotation says it does; this is a
    fatal compile-time error:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试编译此代码将导致编译器错误，指出该方法未覆盖已有方法，尽管注释指示它已覆盖；这是一个致命的编译时错误：
- en: '[PRE6]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 15.4 Preparing a Class as a JavaBean
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 15.4 准备一个类作为JavaBean
- en: Problem
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You have a class that you would like to use as a JavaBean.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 您有一个希望用作JavaBean的类。
- en: Solution
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Make sure the class meets the JavaBeans requirements. Optionally, create a JAR
    file containing the class, a manifest, and any ancillary entries.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 确保该类符合JavaBeans的要求。可选地，创建一个包含该类、清单和任何辅助条目的JAR文件。
- en: Discussion
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'Several kinds of Java components are called either Beans or JavaBeans:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 有些Java组件被称为Beans或JavaBeans：
- en: Visual components for use in GUI builders, as discussed in this recipe.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GUI构建器中用于视觉组件，如本章节所述。
- en: Plain Old Java Objects (POJOs), or components meant for reuse.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 普通的旧Java对象（POJOs）或用于重用的组件。
- en: Java Enterprise has Enterprise JavaBeans (EJBs), JSP JavaBeans, JSF Managed
    Beans, and CDI Beans, containing features for building enterprise-scale applications.
    Creating and using Java EE components is more involved than regular JavaBeans
    and would take us very far afield, so they are not covered in this book. When
    you need to learn about enterprise functionality, turn to *[Java EE 7 Essentials](http://oreil.ly/javaee7)*
    by Arun Gupta.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java Enterprise拥有Enterprise JavaBeans（EJBs）、JSP JavaBeans、JSF Managed Beans和CDI
    Beans，包含用于构建企业级应用程序的功能。创建和使用Java EE组件比普通JavaBeans更复杂，我们无法在本书中覆盖它们。当您需要了解企业功能时，请参阅Arun
    Gupta的*[Java EE 7 Essentials](http://oreil.ly/javaee7)*。
- en: The [Spring Framework](http://springframework.org) also uses the term “Beans”
    (or “Spring Beans”) for the objects it manages.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Spring Framework](http://springframework.org)也使用术语“Beans”（或“Spring Beans”）来管理它所管理的对象。'
- en: 'What all these types of beans have in common are certain naming paradigms.
    All public properties should be accessible by get/set accessor methods. For a
    given property `Prop` of type `Type`, the following two methods should exist (note
    the capitalization):'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些类型的Beans共同拥有某些命名范例。所有公共属性应通过get/set访问器方法访问。对于类型为`Type`的属性`Prop`，应存在以下两种方法（注意大写）：
- en: '[PRE7]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'For example, the various AWT and Swing components that have textual labels
    all have the following pair of methods:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，所有具有文本标签的各种AWT和Swing组件都具有以下一对方法：
- en: '[PRE8]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: One commonly permitted variance to this pattern is that, for `boolean` or `Boolean`
    arguments, the getter method is usually called `isProp()` rather than `getProp()`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式的一个常见变化是，对于`boolean`或`Boolean`参数，getter方法通常称为`isProp()`而不是`getProp()`。
- en: You should use this set/get design pattern (set/get methods) for methods that
    control a bean. Indeed, this technique is useful even in nonbean classes for regularity.
    The bean containers for the APIs listed at the start of this section generally
    use Java introspection (see [Chapter 17](ch17.html#javacook-reflection)) to find
    the set/get method pairs, and some use these to construct properties editors for
    your bean. Bean-aware IDEs, for example, provide editors for all standard types
    (colors, fonts, labels, etc.). You can supplement this with a `BeanInfo` class
    to provide or override information.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该为控制Bean的方法（set/get方法）使用这种set/get设计模式。事实上，即使在非bean类中，这种技术也很有用以保持一致性。本节开始列出的API的Bean容器通常使用Java内省（参见[第17章](ch17.html#javacook-reflection)）来查找set/get方法对，并且有些使用它们来构建bean的属性编辑器。例如，bean-aware
    IDE为所有标准类型（颜色、字体、标签等）提供编辑器。您可以补充一个`BeanInfo`类以提供或覆盖信息。
- en: 'The bare minimum a class requires to be usable as a JavaBean is the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 作为JavaBean可用的类的最低要求如下：
- en: The class must have a no-argument constructor.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类必须有一个无参数的构造函数。
- en: The class should use the set/get paradigm.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该类应使用设置/获取范式。
- en: The class must implement `java.io.Serializable`, although many containers don’t
    enforce this.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该类必须实现`java.io.Serializable`，尽管许多容器并不强制执行此操作。
- en: Depending on the intended use, the class file might need to be packaged into
    a JAR file (see [Recipe 15.5](#javacook-packages-SECT-4)).
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据预期的使用方式，类文件可能需要打包成JAR文件（参见[Recipe 15.5](#javacook-packages-SECT-4)）。
- en: Note that a JavaBean with no *required* inheritance or `implement`s is also
    called a POJO. Most new Java frameworks accept POJO components, instead of (as
    in days of yore) requiring inheritance (e.g., Struts 1 `org.struts.Action` class)
    or implementation of interfaces (e.g., EJB2 `javax.ejb.SessionBean` interface).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，没有*required*继承或`implement`s的JavaBean也被称为POJO。大多数新的Java框架接受POJO组件，而不是（像往昔那样）要求继承（例如，Struts
    1的`org.struts.Action`类）或实现接口（例如，EJB2的`javax.ejb.SessionBean`接口）。
- en: Here is a sample JavaBean that might have been a useful addition to one’s Java
    GUI toolbox, the `LabelText` widget. It combines a label and a one-line text field
    into a single unit, making it easier to compose GUI applications. A demo program
    in the online source directory sets up three `LabelText` widgets, as shown in
    [Figure 15-2](#javacook-packages-FIG-6).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个可能对Java GUI工具箱有用的示例JavaBean，即`LabelText`小部件。它将标签和一行文本字段组合成一个单元，使得组合GUI应用程序更加容易。在线源目录中的演示程序设置了三个`LabelText`小部件，如[图 15-2](#javacook-packages-FIG-6)所示。
- en: '![jcb4 1502](assets/jcb4_1502.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![jcb4 1502](assets/jcb4_1502.png)'
- en: Figure 15-2\. LabelText bean
  id: totrans-124
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 15-2\. LabelText bean
- en: The code for `LabelText` is shown in [Example 15-2](#javacook-packages-EX-4).
    Notice that it is serializable and uses the set/get paradigm for most of its public
    methods. Most of the public set/get methods simply delegate to the corresponding
    methods in the label or the text field. There isn’t really a lot to this bean,
    but it’s a good example of aggregation, in addition to being a good example of
    a bean.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`LabelText`的代码显示在[Example 15-2](#javacook-packages-EX-4)中。请注意，它是可序列化的，并且大多数公共方法使用了设置/获取范式。大多数公共设置/获取方法只是将任务委托给标签或文本字段中的相应方法。这个bean实际上并没有太多内容，但它是聚合的一个很好的例子，也是bean的一个很好的例子。'
- en: Example 15-2\. darwinsys-api/src/main/java/com/darwinsys/swingui/LabelText.java
  id: totrans-126
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 例 15-2\. darwinsys-api/src/main/java/com/darwinsys/swingui/LabelText.java
- en: '[PRE9]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Once it’s compiled, it’s ready to be packaged into a JAR. Most build tools such
    as Maven will do this work for you.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦编译完成，它就可以打包成JAR文件。大多数构建工具（如Maven）都会为您完成这项工作。
- en: 15.5 Archiving with JAR
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 15.5 使用JAR进行归档
- en: Problem
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to create a Java archive (JAR) file from your package (or any other
    collection of files).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你想从你的包（或任何其他文件集合）创建一个Java存档（JAR）文件。
- en: Solution
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use *jar*.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*jar*。
- en: Discussion
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'The *jar* archiver is Java’s standard tool for building archives. Archives
    serve the same purpose as the program libraries that some other programming languages
    use. Java normally loads its standard classes from archives, a fact you can verify
    by running a simple “Hello, World” program with the `-verbose` option:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*jar*归档程序是Java的标准工具，用于构建归档文件。归档文件的作用与其他一些编程语言使用的程序库相同。Java通常从归档文件加载其标准类，您可以通过使用`-verbose`选项运行一个简单的“Hello,
    World”程序来验证这一点：'
- en: '[PRE10]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Creating an archive is a simple process. The *jar* tool takes several command-line
    arguments: the most common are `c` for create, `t` for table of contents, and
    `x` for extract. The archive name is specified with `-f` and a filename. The options
    are followed by the files and directories to be archived, like this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 创建归档是一个简单的过程。*jar*工具接受几个命令行参数：最常见的是`c`表示创建，`t`表示目录，`x`表示提取。归档名称由`-f`和文件名指定。选项后跟着要归档的文件和目录，如下所示：
- en: '[PRE11]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The dot at the end is important; it means the current directory. This command
    creates an archive of all files in the current directory and its subdirectories
    into the file */tmp/MyClasses.jar*.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 末尾的点很重要；它表示当前目录。这个命令将当前目录及其子目录中的所有文件创建成一个归档文件，并将其保存为*/tmp/MyClasses.jar*文件。
- en: 'Most applications of JAR files depend on an extra file that is always present
    in a true JAR file, called a *manifest*. This file always lists the contents of
    the JAR and their attributes; you can add extra information into it. The attributes
    are in the form `name`: `value`, as used in email headers, properties files (see
    [Recipe 7.10](ch07.html#javacook-structure-SECT-7)), and elsewhere. Some attributes
    are required by the application, whereas others are optional. For example, [Recipe
    15.6](#javacook-packages-SECT-7) discusses running a main program directly from
    a JAR; this requires a `Main-Program` header. You can even invent your own attributes,
    such as the following:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '大多数 JAR 文件的应用都依赖于一个额外的文件，这个文件在真正的 JAR 文件中总是存在，称为*清单*（*manifest*）。这个文件总是列出了
    JAR 文件的内容及其属性；你可以在其中添加额外的信息。这些属性的形式为`name`: `value`，就像在电子邮件头部、属性文件（参见 [Recipe
    7.10](ch07.html#javacook-structure-SECT-7)）和其他地方使用的方式一样。一些属性是应用程序必需的，而另一些是可选的。例如，[Recipe
    15.6](#javacook-packages-SECT-7)讨论了直接从 JAR 运行主程序；这需要一个`Main-Program`头部。你甚至可以自己定义属性，比如以下内容：'
- en: '[PRE12]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You store this in a file called, say, *manifest.stub*,^([2](ch15.html#idm45290634169336))
    and pass it to *jar* with the `-m` switch. *jar* includes your attributes in the
    manifest file it creates:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你将其存储在一个名为*manifest.stub*的文件中^([2](ch15.html#idm45290634169336))，并使用 `-m` 开关将其传递给*jar*。*jar*
    将包含你的属性在它创建的清单文件中：
- en: '[PRE13]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The *jar* program and related tools add additional information to the manifest,
    including a listing of all the other files included in the archive.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '*jar* 程序和相关工具向清单添加了额外的信息，包括存档中包含的所有其他文件的列表。'
- en: Tip
  id: totrans-145
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: If you use a tool like Maven (see [Recipe 1.7](ch01.html#javacook-getstarted-maven)),
    it automatically creates a JAR file from your source project just by saying `mvn`
    `package`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用像 Maven 这样的工具（参见 [Recipe 1.7](ch01.html#javacook-getstarted-maven)），它会自动从源代码项目创建一个
    JAR 文件，只需输入 `mvn` `package`。
- en: 15.6 Running a Program from a JAR
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 15.6 从 JAR 运行程序
- en: Problem
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to distribute a single large file containing all the classes of your
    application and run the main program from within the JAR.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要分发一个包含应用程序所有类的单个大文件，并从 JAR 中运行主程序。
- en: Solution
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Create a JAR file with a `Main-Class`: line in the manifest; run the program
    with the `java -jar` option.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在清单中创建一个带有`Main-Class`:行的 JAR 文件；使用`java -jar`选项运行程序。
- en: Discussion
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'The *java* command has a `-jar` option that tells it to run the main program
    found within a JAR file. In this case, it will also find classes it needs to load
    from within the same JAR file. How does it know which class to run? You must tell
    it. Create a one-line entry like this, noting that the attribute fields are case-sensitive
    and that the colon must be followed by a space:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '*java* 命令有一个 `-jar` 选项，告诉它从 JAR 文件中运行找到的主程序。在这种情况下，它还会从同一个 JAR 文件中找到它需要加载的类。它如何知道要运行哪个类？你必须告诉它。创建一个像这样的单行条目，注意属性字段是区分大小写的，冒号后必须跟一个空格：'
- en: '[PRE14]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Place that in a file called, say, *manifest.stub*, and assuming that you want
    to run the program `HelloWorld` from the given package. You can then use the following
    commands to package your app and run it from the JAR file:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 将其放在一个名为*manifest.stub*的文件中，并假设你想从给定包中运行程序`HelloWorld`。然后，你可以使用以下命令打包你的应用并从
    JAR 文件中运行它：
- en: '[PRE15]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You can now copy the JAR file anywhere and run it the same way. You do not need
    to add it to your `CLASSPATH` or list the name of the main class.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以将 JAR 文件复制到任何地方并以相同的方式运行它。你不需要将其添加到你的`CLASSPATH`或列出主类的名称。
- en: On GUI platforms that support it, you can also launch this application by double-clicking
    the JAR file. This works on macOS, Microsoft Windows, and many X Windows desktops.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在支持的 GUI 平台上，你也可以通过双击 JAR 文件来启动这个应用程序。这适用于 macOS、Microsoft Windows 和许多 X Windows
    桌面。
- en: 'In real life you would probably automate this with Maven, where your POM file
    would contain, among other things, the following:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际生活中，你可能会用 Maven 自动化这个过程，在你的 POM 文件中会包含以下内容之一：
- en: '[PRE16]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'With this in place, `mvn package` will build a runnable JAR file. However,
    if your class has external dependencies, the preceding steps will not package
    them, and you will get a missing class exception when you run it. For this, you
    need to use the Maven assembly plug-in:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个设置，`mvn package` 将会构建一个可运行的 JAR 文件。然而，如果你的类有外部依赖关系，上述步骤将不会将它们打包，当你运行它时会得到一个缺少类异常。为此，你需要使用
    Maven 组件插件：
- en: '[PRE17]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now, the invocation `mvn package assembly:single` will produce a runnable JAR
    with all dependencies. Note that your *target* folder will contain both *foo-0.0.1-SNAPSHOT.jar*
    and *foo-0.0.1-SNAPSHOT-jar-with-dependencies.jar*; the latter is the one you
    need.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，调用`mvn package assembly:single`将生成一个带有所有依赖关系的可运行 JAR。请注意，你的 *target* 文件夹将包含
    *foo-0.0.1-SNAPSHOT.jar* 和 *foo-0.0.1-SNAPSHOT-jar-with-dependencies.jar* 两者；后者是你需要的。
- en: The *jpackage* tool (mentioned in this chapter’s introduction) will do much
    the same job as *assembly:single*, and is expected to ship with Java 14.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '*jpackage* 工具（本章介绍中提到的）将执行与 *assembly:single* 类似的工作，并预计将随 Java 14 一起发布。'
- en: 15.7 Packaging Web Tier Components into a WAR File
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 15.7 将 Web 层组件打包成 WAR 文件
- en: Problem
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You have some web-tier resources and want to package them into a single file
    for deploying to the server.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 你有一些 Web 层资源，并希望将它们打包成一个单一文件以部署到服务器上。
- en: Solution
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use *jar* to make a web archive (WAR) file. Or, as mentioned earlier, use Maven
    with `packaging=*war*`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 *jar* 制作 Web 存档（WAR）文件。或者，如前所述，使用 Maven，其`packaging=*war*`。
- en: Discussion
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'Servlets are server-side components for use in web servers. They can be packaged
    for easy installation into a web server. A *web application* in the Servlet API
    specification is a collection of HTML and/or JSP pages, servlets, and other resources.
    A typical directory structure might include the following:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Servlet 是用于 Web 服务器的服务器端组件。它们可以打包成一个方便安装到 Web 服务器的软件包。在 Servlet API 规范中，*Web
    应用程序* 是 HTML 和/或 JSP 页面、Servlet 和其他资源的集合。典型的目录结构可能包括以下内容：
- en: '[PRE18]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Once you have prepared the files in this way, you just package them up with
    a build tool. Using Maven, with `<packaging>war</packaging>`, your tree might
    look like this:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你以这种方式准备好文件，只需用构建工具打包它们即可。使用 Maven，使用`<packaging>war</packaging>`，你的目录结构可能如下所示：
- en: '[PRE19]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Then `mvn package` will compile things, put them in place, and create the WAR
    file for you, leaving it under *target*. Gradle users would use a similar directory
    structure.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`mvn package` 将编译内容，放置内容，并为你创建 WAR 文件，将其留在 *target* 下。Gradle 用户将使用类似的目录结构。
- en: You could also invoke *jar* manually, though this has little to recommend it.
    You then deploy the resulting WAR file into your web server. For details on the
    deployment step, consult the documentation on the particular server you’re using.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以手动调用 *jar*，尽管这没什么值得推荐的。然后将生成的 WAR 文件部署到你的 Web 服务器上。有关部署步骤的详细信息，请参阅你使用的特定服务器的文档。
- en: See Also
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: For more information on signing and permissions, see *[Java Security](http://shop.oreilly.com/product/9780596001575.do)*
    by Scott Oaks. For more information on the JDK tools mentioned here, see the documentation
    that accompanies the JDK you are using.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 关于签名和权限的更多信息，请参阅 Scott Oaks 的 *[Java 安全](http://shop.oreilly.com/product/9780596001575.do)*。有关此处提到的
    JDK 工具的更多信息，请参阅你正在使用的 JDK 附带的文档。
- en: 15.8 Creating a Smaller Distribution with jlink
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 15.8 使用 jlink 创建更小的分发包
- en: Problem
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You are distributing your application to end users, and you want to minimize
    the size of your download.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在将你的应用程序分发给最终用户，并希望最小化下载大小。
- en: Solution
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Modularize your application (see [Recipe 15.9](#javacook-packages-creating-JPMS-modules)),
    use `jdeps` to get a complete list of the modules it uses, then use `jlink` to
    create the mini-Java, and distribute that to your users.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 将你的应用程序模块化（参见 [Recipe 15.9](#javacook-packages-creating-JPMS-modules)），使用 `jdeps`
    获取它使用的所有模块的完整列表，然后使用 `jlink` 创建迷你 Java，并将其分发给用户。
- en: Discussion
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: '`jlink` is a command-line tool introduced in Java 9 that can make up a mini-Java
    distribution containing only your application and the JDK classes it uses. That
    is, it omits any of the thousands of JDK classes that your app will never use.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`jlink` 是在 Java 9 中引入的命令行工具，可以制作一个迷你的 Java 分发包，其中只包含你的应用程序和它使用的 JDK 类。也就是说，它省略了你的应用程序永远不会使用的数千个
    JDK 类。'
- en: 'First, you need to compile and package your `module-info` and your application
    code. You can use Maven or Gradle, or just use the JDK tools directly:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要编译和打包你的 `module-info` 和应用程序代码。你可以使用 Maven 或 Gradle，或者直接使用 JDK 工具：
- en: '[PRE20]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If you wish to see the list of modules that will be included, you can optionally
    run the `jdeps` tool to get this list:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想查看将包含的模块列表，可以选择运行`jdeps`工具以获取此列表：
- en: '[PRE21]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Once the classes have been compiled, you can run the `jlink` tool to build
    a mini-java distribution with your demo app imbedded:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦类文件编译完成，你可以运行`jlink`工具来构建一个嵌入你的演示应用的迷你Java分发包：
- en: '[PRE22]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `--launcher *name*=*module/main*` argument asks `jlink` to create a script
    file named *name* to run the application.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`--launcher *name*=*module/main*`参数要求`jlink`创建一个名为*name*的脚本文件来运行应用程序。'
- en: 'If you got no errors, you should be able to run it either with the *java* command
    or with the generated shell script:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有错误，您应该能够使用*java*命令或生成的shell脚本来运行它：
- en: '[PRE23]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You might want to copy the entire mini-Java folder to a machine that doesn’t
    have a regular Java installation and run it there in order to be sure you don’t
    have any missing dependencies.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能希望将整个迷你Java文件夹复制到没有常规Java安装的计算机上，并在那里运行它，以确保没有任何缺少的依赖项。
- en: Warning
  id: totrans-196
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: 'The concept of a mini-distribution is appealing, but you must consider these
    issues:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 迷你分发的概念很吸引人，但您必须考虑这些问题：
- en: There is no upgrade mechanism for such mini-Javas. These are quite suitable
    for microservice deployments where you rebuild often. For applications shipped
    to customers, though, you’d have to regenerate them and get your customers to
    download and reinstall (on short notice whenever there’s a security update).
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种迷你Java没有升级机制。它们非常适合微服务部署，因为您经常重建。但是对于发送给客户的应用程序，您必须重新生成它们，并让客户下载和重新安装（每当有安全更新时要在短时间内完成）。
- en: Disk space is generally no longer expensive relative to the cost of your time
    in maintaining such a distribution.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相对于维护此类分发所需的时间成本，磁盘空间通常不再昂贵。
- en: Thus, you have to decide if this is worthwhile for your application.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您必须决定这对您的应用程序是否值得。
- en: 15.9 Using JPMS to Create a Module
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 15.9 使用JPMS创建模块
- en: Problem
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want your packaged archive to work smoothly with the Java Modules System
    (JPMS).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望您打包的存档能够与Java模块系统（JPMS）平稳地工作。
- en: Solution
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Create a *module-info.java* file in the root of the source directory.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在源目录的根目录中创建一个*module-info.java*文件。
- en: Discussion
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'The file *module-info.java* was introduced in Java 9 to provide the compiler
    and tools with information about your library’s needs and what it provides. Note
    that this is not even a valid Java class filename because it contains a minus
    sign. The module also has a group of pseudokeywords, which only have their special
    meaning inside a module file. The simplest *module-info* is the following:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '*module-info.java*文件是在Java 9中引入的，用于为编译器和工具提供有关库需求和提供内容的信息。请注意，这甚至不是一个有效的Java类文件名，因为它包含一个减号。该模块还有一组伪关键字，这些关键字仅在模块文件内部具有特殊含义。最简单的*module-info*如下所示：'
- en: '[PRE24]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'But just as a Java class with no members won’t get you very far in the real
    world, neither will this empty module file. We need to provide some additional
    information. For this example, I will modularize my `darwinsys-api`, a collection
    of 40 or so randomly accumulated classes that I reuse sometimes. Remember that
    Jigsaw (the module system’s early name) was initially proposed as a way of modularizing
    the overgrown JDK itself. Most applications will need the module `java.base` (which
    is always included). If they need AWT, Swing, or certain other desktop-application-related
    classes, they also need `java.desktop`. Thus I add the following line into the
    module definition:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 但就像一个没有成员的Java类在现实世界中不能让你走得很远一样，这个空模块文件也是如此。我们需要提供一些额外的信息。例如，在这个示例中，我将模块化我的`darwinsys-api`，这是一个大约有40个随机积累的类的集合，有时我会重复使用它们。请记住，Jigsaw（模块系统的早期名称）最初被提议作为模块化过度庞大的JDK本身的一种方法。大多数应用程序将需要模块`java.base`（它总是包含在内）。如果它们需要AWT、Swing或某些其他与桌面应用程序相关的类，则还需要`java.desktop`。因此，我在模块定义中添加了以下行：
- en: '[PRE25]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This code also has some JUnit-annotated classes and makes use of JavaMail API,
    so we need those as well. JUnit, however, is only needed at test time. While Maven
    offers `scope`s for compile, test, and runtime, the modules system does not. Thus
    we could omit JUnit from the POM file and add it to Eclipse. But then `maven test`
    will not work.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码还有一些带有JUnit注解的类，并使用了JavaMail API，因此我们也需要它们。不过，JUnit仅在测试时需要。虽然Maven提供了`scope`来编译、测试和运行，但模块系统则没有。因此，我们可以在POM文件中省略JUnit，并将其添加到Eclipse中。但是，这样一来，`maven
    test`将无法工作。
- en: 'And unfortunately, as of this writing, there does not appear to be modularized
    version of JavaMail either. Fortunately, there is a feature known as *automatic
    modules*, by which if you place a JAR file on the module path that doesn’t declare
    a module, its JAR filename will be used as the basis of an automatically generated
    module. So we’ll also add the following:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，截至本文撰写时，似乎还没有 JavaMail 的模块化版本。幸运的是，有一个称为 *automatic modules* 的功能，如果将一个没有声明模块的
    JAR 文件放置在模块路径上，其 JAR 文件名将被用作自动生成模块的基础。因此，我们还将添加以下内容：
- en: '[PRE26]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Unfortunately, when we compile, Maven’s Java Compiler module spits out this
    scary-looking warning:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，当我们编译时，Maven 的 Java 编译器模块会输出这样一条看起来很吓人的警告：
- en: '[PRE27]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Given that there are so many public Java API libraries out there, and that
    most of them depend on other libraries in turn, I wonder: how is that state supposed
    to end? Nonetheless, I have heeded that warning, and so people will continue to
    use the auto-module version of `com.darwinsys.api` until I stumble across modularized
    JavaMail and JUnit4 APIs.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于存在如此多的公共 Java API 库，而且它们大多依赖于其他库，我想知道：这种状态该如何结束？尽管如此，我已经注意到了这个警告，因此人们将继续使用
    `com.darwinsys.api` 的自动模块版本，直到我找到模块化的 JavaMail 和 JUnit4 API 为止。
- en: 'The *module-info* also lists any packages that your module desires to make
    available, that is, its public API. So we need a series of export commands:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '*module-info* 还列出了模块希望提供的任何包，即其公共 API。因此，我们需要一系列的导出命令：'
- en: '[PRE28]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: By default, packages that are exported can not be examined using the Reflection
    API. To allow a module to introspect (use the Reflection API) on another, say,
    a domain model used with JPA, use `opens`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，导出的包不能使用反射 API 进行检查。为了允许一个模块在另一个模块上进行内省（使用反射 API），例如与 JPA 一起使用的领域模型，需要使用
    `opens`。
- en: 'One of the points of Java interfaces is to allow multiple implementations of
    a service. This is supported in JPMS by the service feature. Where an API is defined
    as one or more interfaces in one module, and multiple implementations are provided,
    each in its own module, the implementation module(s) can define an implementation
    using `provides ... with`, as in the following:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: Java 接口的一个重要点是允许对服务进行多个实现。这在 JPMS 中通过服务特性得到支持。其中 API 在一个模块中定义为一个或多个接口，并提供多个实现，每个实现在其自己的模块中，实现模块可以使用
    `provides ... with` 定义实现，如下所示：
- en: '[PRE29]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The completed *module-info* for the `darwinsys-api` module is shown in [Example 15-3](#javacook-packages-modules-1).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`darwinsys-api` 模块的完成的 *module-info* 在 [示例 15-3](#javacook-packages-modules-1)
    中显示。'
- en: Example 15-3\. DarwinSys-API module-info
  id: totrans-223
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-3\. DarwinSys-API 模块的 *module-info*
- en: '[PRE30]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'A module wanting to use the lock interface feature would need a `requires com.darwinsys`
    and might do something like this in code:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 想要使用锁接口特性的模块需要 `requires com.darwinsys` 并可能在代码中执行如下操作：
- en: '[PRE31]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `Optional` interface is described in [Recipe 8.6](ch08.html#javacook-oo-SECT-Optionals).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`Optional` 接口在 [Recipe 8.6](ch08.html#javacook-oo-SECT-Optionals) 中有描述。'
- en: See Also
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'JPMS is relatively new, and library providers are still learning to use it
    properly. An early posting was [*https://openjdk.java.net/projects/jigsaw/quick-start*](https://openjdk.java.net/projects/jigsaw/quick-start).
    A plan for migrating to modules can be found at [*http://tutorials.jenkov.com/java/modules.html#migrating-to-java-9*](http://tutorials.jenkov.com/java/modules.html#migrating-to-java-9).
    A discussion about preparing a multi-module Maven application is at [*https://www.baeldung.com/maven-multi-module-project-java-jpms*](https://www.baeldung.com/maven-multi-module-project-java-jpms).
    The book [*Java 9 Modularity: Patterns and Practices for Developing Maintainable
    Applications*](http://shop.oreilly.com/product/0636920049494.do) by Sander Mak
    and Paul Bakker is probably the most comprehensive treatment of JPMS.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 'JPMS 是相对较新的技术，库提供者仍在学习如何正确使用它。早期的发布可以在 [*https://openjdk.java.net/projects/jigsaw/quick-start*](https://openjdk.java.net/projects/jigsaw/quick-start)
    找到。关于迁移到模块化的计划可以在 [*http://tutorials.jenkov.com/java/modules.html#migrating-to-java-9*](http://tutorials.jenkov.com/java/modules.html#migrating-to-java-9)
    找到。关于准备多模块 Maven 应用程序的讨论可以在 [*https://www.baeldung.com/maven-multi-module-project-java-jpms*](https://www.baeldung.com/maven-multi-module-project-java-jpms)
    找到。Sander Mak 和 Paul Bakker 的书 [*Java 9 Modularity: Patterns and Practices for
    Developing Maintainable Applications*](http://shop.oreilly.com/product/0636920049494.do)
    可能是对 JPMS 最全面的处理。'
- en: ^([1](ch15.html#idm45290635070328-marker)) This is not strictly true. On Unix
    in C, at least, there is a distinction between normal include files and those
    in the *sys* subdirectory, and many structures have names beginning with one or
    two letters and an underscore in the password structure, like `pw_name`, `pw_passwd`,
    and `pw_home`. But this is nowhere near as consistent as Java’s `java.*` naming
    conventions.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch15.html#idm45290635070328-marker)) 这并不严格正确。至少在 Unix 中的 C 语言中，普通的包含文件和*sys*子目录中的文件是有区别的，而且许多结构体的名称以一个或两个字母加下划线开始，如`pw_name`、`pw_passwd`和`pw_home`。但这远不及
    Java 的`java.*`命名约定那样一致。
- en: ^([2](ch15.html#idm45290634169336-marker)) Some people like to use names like
    *MyPackage.mf* so that it’s clear which package it is for; the extension *.mf*
    is arbitrary, but it’s a good convention for identifying manifest files.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch15.html#idm45290634169336-marker)) 有些人喜欢使用像*MyPackage.mf*这样的名称，这样就清楚这是为哪个包而准备的；扩展名*.mf*是任意的，但对于识别清单文件来说是一个好的约定。
