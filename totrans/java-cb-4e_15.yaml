- en: Chapter 15\. Packages and Packaging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 15.0 Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the better aspects of the Java language is that it has defined a very
    clear packaging mechanism for categorizing and managing its large API. Contrast
    this with most other languages, where symbols may be found in the C library itself
    or in any of dozens of other libraries, with no clearly defined naming conventions.^([1](ch15.html#idm45290635070328))
    APIs consist of one or more package, packages consist of classes, and classes
    consist of methods and fields. Anybody can create a package, with one important
    restriction: you or I cannot create a package whose name begins with the four
    letters `java`. Packages named `java`. or `javax`. are reserved for use by Oracle’s
    Java developers, under the management of the Java Community Process (JCP). When
    Java was new, there were about a dozen packages in a structure that is very much
    still with us, though it has quadrupled in size; some of these packages are shown
    in [Table 15-1](#javacook-packages-TABLE-1).'
  prefs: []
  type: TYPE_NORMAL
- en: Table 15-1\. Java packages basic structure
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Function |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `java.awt` | Graphical user interface |'
  prefs: []
  type: TYPE_TB
- en: '| `java.io` | Reading and writing |'
  prefs: []
  type: TYPE_TB
- en: '| `java.lang` | Intrinsic classes (`String`, etc.) |'
  prefs: []
  type: TYPE_TB
- en: '| `java.lang.annotation` | Library support for annotation processing |'
  prefs: []
  type: TYPE_TB
- en: '| `java.math` | Math library |'
  prefs: []
  type: TYPE_TB
- en: '| `java.net` | Networking (sockets) |'
  prefs: []
  type: TYPE_TB
- en: '| `java.nio` | “New” I/O (not new anymore): channel-based I/O |'
  prefs: []
  type: TYPE_TB
- en: '| `java.sql` | Java database connectivity |'
  prefs: []
  type: TYPE_TB
- en: '| `java.text` | Handling and formatting/parsing dates, numbers, messages |'
  prefs: []
  type: TYPE_TB
- en: '| `java.time` | Java 8: modern date/time API (JSR-311) |'
  prefs: []
  type: TYPE_TB
- en: '| `java.util` | Utilities (collections, date) |'
  prefs: []
  type: TYPE_TB
- en: '| `java.util.regex` | Regular expressions |'
  prefs: []
  type: TYPE_TB
- en: '| `javax.naming` | JNDI |'
  prefs: []
  type: TYPE_TB
- en: '| `javax.print` | Support for printing |'
  prefs: []
  type: TYPE_TB
- en: '| `javax.script` | Java 6: scripting engines support |'
  prefs: []
  type: TYPE_TB
- en: '| `javax.swing` | Modern graphical user interface |'
  prefs: []
  type: TYPE_TB
- en: Many packages have been added over the years, but the initial structure has
    stood the test of time fairly well. In this chapter, I’ll show you how to create
    and document your own packages, and then I’ll discuss a number of issues related
    to deploying your package in various ways on various platforms.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter also covers the more traditional meaning of packaging, as in, creating
    a package of your program for others to use. This covers the Java Platform Modules
    System (JPMS) introduced in Java 9. We also cover `jlink`, a tool for creating
    a mini-Java distribution containing your application and only the parts of the
    JDK that you actually use. We do not yet cover the `jpackage` tool for packaging
    applications, because it’s not yet in the JDK; it may arrive with Java 14 or 15.
  prefs: []
  type: TYPE_NORMAL
- en: 15.1 Creating a Package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to be able to import classes and/or organize your classes, so you want
    to create your own package.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Put a `package` statement at the front of each file, and recompile with `-d`
    or a build tool or IDE.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `package` statement must be the very first noncomment statement in your
    Java source file—preceding even `import` statements—and it must give the full
    name of the package. Package names are expected to start with your domain name
    backward; for example, my internet domain is *darwinsys.com*, so most of my packages
    begin with `com.darwinsys` and a project name. The utility classes used in this
    book and meant for reuse are in one of the `com.darwinsys` packages listed in
    [Recipe 1.6](ch01.html#javacook-getstarted-samplecode), and each source file begins
    with a statement, such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The demonstration classes in the *JavaSrc* repository do not follow this pattern;
    they are in packages with names related to the chapter they are in or the `java.*`
    package they relate to; for example, `lang` for basic Java stuff, `structure`
    for examples from the data structuring chapter ([Chapter 7](ch07.html#javacook-structure)),
    `threads` for the threading chapter ([Chapter 16](ch16.html#javacook-threads)),
    and so on. It is hoped that you will put them in a “real” package if you reuse
    them in your application!
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have package statements in place, be aware that the Java runtime,
    and even the compiler, will expect the compiled *.class* files to be found in
    their rightful place (i.e., in the subdirectory corresponding to the full name
    somewhere in your `CLASSPATH` settings). For example, the class file for `com.darwinsys.util.FileIO`
    must *not* be in the file *FileIO.class* in my `CLASSPATH` but must be in *com/darwinsys/util/FileIO.class*
    relative to one of the directories or archives in my `CLASSPATH`. Accordingly,
    if you are compiling with the command-line compiler, it is customary (almost mandatory)
    to use the `-d` command-line argument when compiling. This argument must be followed
    by the name of an existing directory (often . is used to signify the current directory)
    to specify where to build the directory tree. For example, to compile all the
    *.java* files in the current directory, and create the directory path under it
    (e.g., create *./com/darwinsys/util* in the example), use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This creates the path (e.g., *com/darwinsys/util/*) relative to the current
    directory and puts the class files into that subdirectory. This makes life easy
    for subsequent compilations and also for creating archives, which is covered in
    [Recipe 15.5](#javacook-packages-SECT-4).
  prefs: []
  type: TYPE_NORMAL
- en: Of course, if you use a build tool such as Maven (see [Recipe 1.7](ch01.html#javacook-getstarted-maven)),
    this will be done correctly by default (Maven), so you won’t have to remember
    to keep doing it!
  prefs: []
  type: TYPE_NORMAL
- en: Note that in all modern Java environments, classes that do not belong to a package
    (the *anonymous package*) cannot be listed in an `import` statement, although
    they can be referred to by other classes in that package. They also cannot become
    part of a JPMS module.
  prefs: []
  type: TYPE_NORMAL
- en: 15.2 Documenting Classes with Javadoc
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have heard about this thing called *code reuse* and would like to promote
    it by allowing other developers to use your classes.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use javadoc. Write the comments when you write the code.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Javadoc is one of the great inventions of the early Java years. Like so many
    good things, it was not wholly invented by the Java folks; earlier projects such
    as Knuth’s Literate Programming had combined source code and documentation in
    a single source file. But the Java folks did a good job on it and came along at
    the right time. Javadoc is to Java classes what *man pages* are to Unix, or what
    Windows Help is to Windows applications: it is a standard format that everybody
    expects to find and knows how to use. Learn it. Use it. Write it. Live long and
    prosper (well, perhaps that’s not guaranteed). But all that HTML documentation
    that you learned from writing Java code, the complete reference for the JDK—did
    you think they hired dozens of tech writers to produce it? Nay, that’s not the
    Java way. Java’s developers wrote the documentation comments as they went along,
    and when the release was made, they ran javadoc on all the zillions of public
    classes and generated the documentation bundle at the same time as the JDK. You
    can, should, and really must do the same when you are preparing classes for other
    developers to use.'
  prefs: []
  type: TYPE_NORMAL
- en: All you have to do to use javadoc is to put special *javadoc comments* into
    your Java source files. These are similar to multiline Java comments, but they
    begin with a slash and *two* stars and end with the normal star-slash. Javadoc
    comments must appear immediately before the definition of the class, method, or
    field that they document; if placed elsewhere, they are ignored.
  prefs: []
  type: TYPE_NORMAL
- en: A series of keywords, prefixed by the at sign, can appear inside doc comments
    in certain contexts. Some are contained in braces. The keywords as of Java 8 are
    listed in [Table 15-2](#javacook-packages-TABLE-2).
  prefs: []
  type: TYPE_NORMAL
- en: Table 15-2\. Javadoc keywords
  prefs: []
  type: TYPE_NORMAL
- en: '| Keyword | Use |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `@author` | Author name(s) |'
  prefs: []
  type: TYPE_TB
- en: '| `{@code *text*}` | Displays text in code font without HTML interpretation
    |'
  prefs: []
  type: TYPE_TB
- en: '| `@deprecated` | Causes deprecation warning |'
  prefs: []
  type: TYPE_TB
- en: '| `{@docroot}` | Refers to the root of the generated documentation tree |'
  prefs: []
  type: TYPE_TB
- en: '| `@exception` | Alias for `@throws` |'
  prefs: []
  type: TYPE_TB
- en: '| `{@inheritDoc}` | Inherits documentation from nearest superclass/superinterface
    |'
  prefs: []
  type: TYPE_TB
- en: '| `@link` | Generates inline link to another class or member |'
  prefs: []
  type: TYPE_TB
- en: '| `@linkplain` | As `@link` but displays in plain text |'
  prefs: []
  type: TYPE_TB
- en: '| `{@literal *text*}` | Displays text without interpretation |'
  prefs: []
  type: TYPE_TB
- en: '| `@param *name description*` | Argument name and meaning (methods only) |'
  prefs: []
  type: TYPE_TB
- en: '| `@return` | Return value |'
  prefs: []
  type: TYPE_TB
- en: '| `@see` | Generate cross-reference link to another class or member |'
  prefs: []
  type: TYPE_TB
- en: '| `@serial` | Describes serializable field |'
  prefs: []
  type: TYPE_TB
- en: '| `@serialData` | Describes order and types of data in serialized form |'
  prefs: []
  type: TYPE_TB
- en: '| `@serialField` | Describes serializable field |'
  prefs: []
  type: TYPE_TB
- en: '| `@since` | JDK version in which introduced (primarily for Sun use) |'
  prefs: []
  type: TYPE_TB
- en: '| `@throws` | Exception class and conditions under which thrown |'
  prefs: []
  type: TYPE_TB
- en: '| `{@value [*ref*]}` | Displays values of this or another constant field |'
  prefs: []
  type: TYPE_TB
- en: '| `@version` | Version identifier |'
  prefs: []
  type: TYPE_TB
- en: '[Example 15-1](#javacook-packages-EX-1) is a somewhat contrived example that
    shows some common javadoc keywords in use. The output of running this through
    javadoc is shown in a browser in [Figure 15-1](#javacook-packages-FIG-1).'
  prefs: []
  type: TYPE_NORMAL
- en: Example 15-1\. main/src/main/java/javadoc/JavadocDemo.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The javadoc tool works fine for one class but really comes into its own when
    dealing with a package or collection of packages. You can provide a package summary
    file for each package, which will be incorporated into the generated files. Javadoc
    generates thoroughly interlinked and crosslinked documentation, just like that
    which accompanies the standard JDK. There are several command-line options; I
    normally use `-author` and `-version` to get it to include these items, and often
    `-link` to tell it where to find the standard JDK to link to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run `javadoc -help` for a complete list of options, or see the full documentation
    online at [Oracle’s website](https://docs.oracle.com/en/java/javase/13/docs/specs/man/javadoc.html).
    [Figure 15-1](#javacook-packages-FIG-1) shows one view of the documentation that
    the class shown in [Example 15-1](#javacook-packages-EX-1) generates when run
    as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If you run this with Java 9+, it will also include a fully functional search
    box, shown in the upper right of [Figure 15-1](#javacook-packages-FIG-1). This
    is implemented in JavaScript, so it should work in any modern browser.
  prefs: []
  type: TYPE_NORMAL
- en: Be aware that quite a few files are generated, and one of the generated files
    will have the same name as each class, with the extension *.html*. If you happened
    to have an HTML file documenting the class, and you generate javadoc in the source
    directory, the *.html* file is silently overwritten with the javadoc output. If
    you wish to avoid cluttering up your source directories with the generated files,
    the `-d __directorypath` option to javadoc allows you to place the generated files
    into the specified directory.
  prefs: []
  type: TYPE_NORMAL
- en: '![jcb4 1501](assets/jcb4_1501.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15-1\. Javadoc opened in a browser
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Javadoc has numerous other command-line arguments. If documentation is for your
    own use only and will not be distributed, you can use the `-link` option to tell
    it where your standard JDK documentation is installed so that links can be generated
    to standard Java classes (like `String`, `Object`, and so on). If documentation
    is to be distributed, you can omit `-link` or use `-link` with a URL to the appropriate
    Java API page on Oracle’s website. See the online tools documentation for all
    the command-line options.
  prefs: []
  type: TYPE_NORMAL
- en: The output that javadoc generates is fine for most purposes. It is possible
    to write your own `Doclet` class to make the javadoc program into a class documentation
    verifier, a Java-to-other-format (such as Java-to-RTF) documentation generator,
    or whatever you like. Those are actual examples; see the javadoc tools documentation
    that comes with the JDK for documents and examples, or go to [Oracle’s website](https://docs.oracle.com/en/java/javase/13/docs/specs/man/javadoc.html).
    Visit [Doclet](http://www.doclet.com) for a somewhat dated but useful collection
    of Doclets and other javadoc-based tools.
  prefs: []
  type: TYPE_NORMAL
- en: Javadoc Versus JavaHelp
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Javadoc is for programmers using your classes; for a GUI application, end users
    will probably appreciate standard online help. This is the role of the JavaHelp
    API, which is not covered in this book but is fully explained in *[Creating Effective
    JavaHelp](http://shop.oreilly.com/product/9781565927193.do)* by Kevin Lewis (O’Reilly),
    which every GUI application developer should read. JavaHelp is another useful
    specification that was somewhat left to coast during the Sun sellout to Oracle;
    it is now hosted on *java.net* at [javahelp](https://javaee.github.io/javahelp).
  prefs: []
  type: TYPE_NORMAL
- en: '15.3 Beyond Javadoc: Annotations/Metadata'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to generate not just documentation from your source code, but also
    other code artifacts. You want to mark code for additional compiler verification.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the Java Annotations, or Metadata, facility.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The continuing success of the open source tool [XDoclet](http://xdoclet.sourceforge.net)—originally
    used to generate the tedious auxiliary classes and deployment descriptor files
    for the widely criticized EJB2 framework—led to a demand for a similar mechanism
    in standard Java. Java *Annotations* were the result. The *annotation* mechanism
    uses an interface-like syntax, in which both declaration and use of annotations
    use the name preceded by an at character (`@`). This was chosen, according to
    the designers, to be reminiscent of “Javadoc tags, a preexisting ad hoc annotation
    facility in the Java programming language.” Javadoc is ad hoc only in the sense
    that its `@` tags were never fully integrated into the language; most were ignored
    by the compiler, but `@deprecated` was always understood by the compiler (see
    [Recipe 1.9](ch01.html#javacook-getstarted-SECT-9)).
  prefs: []
  type: TYPE_NORMAL
- en: Annotations can be read at runtime by use of the Reflection API; this is discussed
    in [Recipe 17.10](ch17.html#javacook-reflection-annotations), where I also show
    you how to define your own annotations. Annotations can also be read post–compile
    time by tools such as code generators (and others to be invented, perhaps by you,
    gentle reader!).
  prefs: []
  type: TYPE_NORMAL
- en: Annotations are also read by *javac* at compile time to provide extra information
    to the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: For example, a common coding error is overloading a method when you mean to
    override it, by mistakenly using the wrong argument type. Consider overriding
    the equals method in `Object`. If you mistakenly write
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'then you have created a new overload that will likely never be called, and
    the default version in `Object` will be called. To prevent this, an annotation
    included in `java.lang` is the `Override` annotation. This has no parameters but
    simply is placed before the method call, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Attempting to compile this results in a compiler error that the method in question
    does not override a method, even though the annotation says it does; this is a
    fatal compile-time error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 15.4 Preparing a Class as a JavaBean
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have a class that you would like to use as a JavaBean.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make sure the class meets the JavaBeans requirements. Optionally, create a JAR
    file containing the class, a manifest, and any ancillary entries.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Several kinds of Java components are called either Beans or JavaBeans:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual components for use in GUI builders, as discussed in this recipe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plain Old Java Objects (POJOs), or components meant for reuse.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java Enterprise has Enterprise JavaBeans (EJBs), JSP JavaBeans, JSF Managed
    Beans, and CDI Beans, containing features for building enterprise-scale applications.
    Creating and using Java EE components is more involved than regular JavaBeans
    and would take us very far afield, so they are not covered in this book. When
    you need to learn about enterprise functionality, turn to *[Java EE 7 Essentials](http://oreil.ly/javaee7)*
    by Arun Gupta.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [Spring Framework](http://springframework.org) also uses the term “Beans”
    (or “Spring Beans”) for the objects it manages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'What all these types of beans have in common are certain naming paradigms.
    All public properties should be accessible by get/set accessor methods. For a
    given property `Prop` of type `Type`, the following two methods should exist (note
    the capitalization):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, the various AWT and Swing components that have textual labels
    all have the following pair of methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: One commonly permitted variance to this pattern is that, for `boolean` or `Boolean`
    arguments, the getter method is usually called `isProp()` rather than `getProp()`.
  prefs: []
  type: TYPE_NORMAL
- en: You should use this set/get design pattern (set/get methods) for methods that
    control a bean. Indeed, this technique is useful even in nonbean classes for regularity.
    The bean containers for the APIs listed at the start of this section generally
    use Java introspection (see [Chapter 17](ch17.html#javacook-reflection)) to find
    the set/get method pairs, and some use these to construct properties editors for
    your bean. Bean-aware IDEs, for example, provide editors for all standard types
    (colors, fonts, labels, etc.). You can supplement this with a `BeanInfo` class
    to provide or override information.
  prefs: []
  type: TYPE_NORMAL
- en: 'The bare minimum a class requires to be usable as a JavaBean is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The class must have a no-argument constructor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The class should use the set/get paradigm.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The class must implement `java.io.Serializable`, although many containers don’t
    enforce this.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Depending on the intended use, the class file might need to be packaged into
    a JAR file (see [Recipe 15.5](#javacook-packages-SECT-4)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that a JavaBean with no *required* inheritance or `implement`s is also
    called a POJO. Most new Java frameworks accept POJO components, instead of (as
    in days of yore) requiring inheritance (e.g., Struts 1 `org.struts.Action` class)
    or implementation of interfaces (e.g., EJB2 `javax.ejb.SessionBean` interface).
  prefs: []
  type: TYPE_NORMAL
- en: Here is a sample JavaBean that might have been a useful addition to one’s Java
    GUI toolbox, the `LabelText` widget. It combines a label and a one-line text field
    into a single unit, making it easier to compose GUI applications. A demo program
    in the online source directory sets up three `LabelText` widgets, as shown in
    [Figure 15-2](#javacook-packages-FIG-6).
  prefs: []
  type: TYPE_NORMAL
- en: '![jcb4 1502](assets/jcb4_1502.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15-2\. LabelText bean
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The code for `LabelText` is shown in [Example 15-2](#javacook-packages-EX-4).
    Notice that it is serializable and uses the set/get paradigm for most of its public
    methods. Most of the public set/get methods simply delegate to the corresponding
    methods in the label or the text field. There isn’t really a lot to this bean,
    but it’s a good example of aggregation, in addition to being a good example of
    a bean.
  prefs: []
  type: TYPE_NORMAL
- en: Example 15-2\. darwinsys-api/src/main/java/com/darwinsys/swingui/LabelText.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Once it’s compiled, it’s ready to be packaged into a JAR. Most build tools such
    as Maven will do this work for you.
  prefs: []
  type: TYPE_NORMAL
- en: 15.5 Archiving with JAR
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to create a Java archive (JAR) file from your package (or any other
    collection of files).
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use *jar*.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The *jar* archiver is Java’s standard tool for building archives. Archives
    serve the same purpose as the program libraries that some other programming languages
    use. Java normally loads its standard classes from archives, a fact you can verify
    by running a simple “Hello, World” program with the `-verbose` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Creating an archive is a simple process. The *jar* tool takes several command-line
    arguments: the most common are `c` for create, `t` for table of contents, and
    `x` for extract. The archive name is specified with `-f` and a filename. The options
    are followed by the files and directories to be archived, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The dot at the end is important; it means the current directory. This command
    creates an archive of all files in the current directory and its subdirectories
    into the file */tmp/MyClasses.jar*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most applications of JAR files depend on an extra file that is always present
    in a true JAR file, called a *manifest*. This file always lists the contents of
    the JAR and their attributes; you can add extra information into it. The attributes
    are in the form `name`: `value`, as used in email headers, properties files (see
    [Recipe 7.10](ch07.html#javacook-structure-SECT-7)), and elsewhere. Some attributes
    are required by the application, whereas others are optional. For example, [Recipe
    15.6](#javacook-packages-SECT-7) discusses running a main program directly from
    a JAR; this requires a `Main-Program` header. You can even invent your own attributes,
    such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You store this in a file called, say, *manifest.stub*,^([2](ch15.html#idm45290634169336))
    and pass it to *jar* with the `-m` switch. *jar* includes your attributes in the
    manifest file it creates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The *jar* program and related tools add additional information to the manifest,
    including a listing of all the other files included in the archive.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you use a tool like Maven (see [Recipe 1.7](ch01.html#javacook-getstarted-maven)),
    it automatically creates a JAR file from your source project just by saying `mvn`
    `package`.
  prefs: []
  type: TYPE_NORMAL
- en: 15.6 Running a Program from a JAR
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to distribute a single large file containing all the classes of your
    application and run the main program from within the JAR.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a JAR file with a `Main-Class`: line in the manifest; run the program
    with the `java -jar` option.'
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The *java* command has a `-jar` option that tells it to run the main program
    found within a JAR file. In this case, it will also find classes it needs to load
    from within the same JAR file. How does it know which class to run? You must tell
    it. Create a one-line entry like this, noting that the attribute fields are case-sensitive
    and that the colon must be followed by a space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Place that in a file called, say, *manifest.stub*, and assuming that you want
    to run the program `HelloWorld` from the given package. You can then use the following
    commands to package your app and run it from the JAR file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: You can now copy the JAR file anywhere and run it the same way. You do not need
    to add it to your `CLASSPATH` or list the name of the main class.
  prefs: []
  type: TYPE_NORMAL
- en: On GUI platforms that support it, you can also launch this application by double-clicking
    the JAR file. This works on macOS, Microsoft Windows, and many X Windows desktops.
  prefs: []
  type: TYPE_NORMAL
- en: 'In real life you would probably automate this with Maven, where your POM file
    would contain, among other things, the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'With this in place, `mvn package` will build a runnable JAR file. However,
    if your class has external dependencies, the preceding steps will not package
    them, and you will get a missing class exception when you run it. For this, you
    need to use the Maven assembly plug-in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now, the invocation `mvn package assembly:single` will produce a runnable JAR
    with all dependencies. Note that your *target* folder will contain both *foo-0.0.1-SNAPSHOT.jar*
    and *foo-0.0.1-SNAPSHOT-jar-with-dependencies.jar*; the latter is the one you
    need.
  prefs: []
  type: TYPE_NORMAL
- en: The *jpackage* tool (mentioned in this chapter’s introduction) will do much
    the same job as *assembly:single*, and is expected to ship with Java 14.
  prefs: []
  type: TYPE_NORMAL
- en: 15.7 Packaging Web Tier Components into a WAR File
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have some web-tier resources and want to package them into a single file
    for deploying to the server.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use *jar* to make a web archive (WAR) file. Or, as mentioned earlier, use Maven
    with `packaging=*war*`.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Servlets are server-side components for use in web servers. They can be packaged
    for easy installation into a web server. A *web application* in the Servlet API
    specification is a collection of HTML and/or JSP pages, servlets, and other resources.
    A typical directory structure might include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have prepared the files in this way, you just package them up with
    a build tool. Using Maven, with `<packaging>war</packaging>`, your tree might
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Then `mvn package` will compile things, put them in place, and create the WAR
    file for you, leaving it under *target*. Gradle users would use a similar directory
    structure.
  prefs: []
  type: TYPE_NORMAL
- en: You could also invoke *jar* manually, though this has little to recommend it.
    You then deploy the resulting WAR file into your web server. For details on the
    deployment step, consult the documentation on the particular server you’re using.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For more information on signing and permissions, see *[Java Security](http://shop.oreilly.com/product/9780596001575.do)*
    by Scott Oaks. For more information on the JDK tools mentioned here, see the documentation
    that accompanies the JDK you are using.
  prefs: []
  type: TYPE_NORMAL
- en: 15.8 Creating a Smaller Distribution with jlink
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You are distributing your application to end users, and you want to minimize
    the size of your download.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Modularize your application (see [Recipe 15.9](#javacook-packages-creating-JPMS-modules)),
    use `jdeps` to get a complete list of the modules it uses, then use `jlink` to
    create the mini-Java, and distribute that to your users.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`jlink` is a command-line tool introduced in Java 9 that can make up a mini-Java
    distribution containing only your application and the JDK classes it uses. That
    is, it omits any of the thousands of JDK classes that your app will never use.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you need to compile and package your `module-info` and your application
    code. You can use Maven or Gradle, or just use the JDK tools directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'If you wish to see the list of modules that will be included, you can optionally
    run the `jdeps` tool to get this list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the classes have been compiled, you can run the `jlink` tool to build
    a mini-java distribution with your demo app imbedded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `--launcher *name*=*module/main*` argument asks `jlink` to create a script
    file named *name* to run the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you got no errors, you should be able to run it either with the *java* command
    or with the generated shell script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: You might want to copy the entire mini-Java folder to a machine that doesn’t
    have a regular Java installation and run it there in order to be sure you don’t
    have any missing dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The concept of a mini-distribution is appealing, but you must consider these
    issues:'
  prefs: []
  type: TYPE_NORMAL
- en: There is no upgrade mechanism for such mini-Javas. These are quite suitable
    for microservice deployments where you rebuild often. For applications shipped
    to customers, though, you’d have to regenerate them and get your customers to
    download and reinstall (on short notice whenever there’s a security update).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disk space is generally no longer expensive relative to the cost of your time
    in maintaining such a distribution.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thus, you have to decide if this is worthwhile for your application.
  prefs: []
  type: TYPE_NORMAL
- en: 15.9 Using JPMS to Create a Module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want your packaged archive to work smoothly with the Java Modules System
    (JPMS).
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a *module-info.java* file in the root of the source directory.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The file *module-info.java* was introduced in Java 9 to provide the compiler
    and tools with information about your library’s needs and what it provides. Note
    that this is not even a valid Java class filename because it contains a minus
    sign. The module also has a group of pseudokeywords, which only have their special
    meaning inside a module file. The simplest *module-info* is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'But just as a Java class with no members won’t get you very far in the real
    world, neither will this empty module file. We need to provide some additional
    information. For this example, I will modularize my `darwinsys-api`, a collection
    of 40 or so randomly accumulated classes that I reuse sometimes. Remember that
    Jigsaw (the module system’s early name) was initially proposed as a way of modularizing
    the overgrown JDK itself. Most applications will need the module `java.base` (which
    is always included). If they need AWT, Swing, or certain other desktop-application-related
    classes, they also need `java.desktop`. Thus I add the following line into the
    module definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This code also has some JUnit-annotated classes and makes use of JavaMail API,
    so we need those as well. JUnit, however, is only needed at test time. While Maven
    offers `scope`s for compile, test, and runtime, the modules system does not. Thus
    we could omit JUnit from the POM file and add it to Eclipse. But then `maven test`
    will not work.
  prefs: []
  type: TYPE_NORMAL
- en: 'And unfortunately, as of this writing, there does not appear to be modularized
    version of JavaMail either. Fortunately, there is a feature known as *automatic
    modules*, by which if you place a JAR file on the module path that doesn’t declare
    a module, its JAR filename will be used as the basis of an automatically generated
    module. So we’ll also add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, when we compile, Maven’s Java Compiler module spits out this
    scary-looking warning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Given that there are so many public Java API libraries out there, and that
    most of them depend on other libraries in turn, I wonder: how is that state supposed
    to end? Nonetheless, I have heeded that warning, and so people will continue to
    use the auto-module version of `com.darwinsys.api` until I stumble across modularized
    JavaMail and JUnit4 APIs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The *module-info* also lists any packages that your module desires to make
    available, that is, its public API. So we need a series of export commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: By default, packages that are exported can not be examined using the Reflection
    API. To allow a module to introspect (use the Reflection API) on another, say,
    a domain model used with JPA, use `opens`.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the points of Java interfaces is to allow multiple implementations of
    a service. This is supported in JPMS by the service feature. Where an API is defined
    as one or more interfaces in one module, and multiple implementations are provided,
    each in its own module, the implementation module(s) can define an implementation
    using `provides ... with`, as in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The completed *module-info* for the `darwinsys-api` module is shown in [Example 15-3](#javacook-packages-modules-1).
  prefs: []
  type: TYPE_NORMAL
- en: Example 15-3\. DarwinSys-API module-info
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'A module wanting to use the lock interface feature would need a `requires com.darwinsys`
    and might do something like this in code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The `Optional` interface is described in [Recipe 8.6](ch08.html#javacook-oo-SECT-Optionals).
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JPMS is relatively new, and library providers are still learning to use it
    properly. An early posting was [*https://openjdk.java.net/projects/jigsaw/quick-start*](https://openjdk.java.net/projects/jigsaw/quick-start).
    A plan for migrating to modules can be found at [*http://tutorials.jenkov.com/java/modules.html#migrating-to-java-9*](http://tutorials.jenkov.com/java/modules.html#migrating-to-java-9).
    A discussion about preparing a multi-module Maven application is at [*https://www.baeldung.com/maven-multi-module-project-java-jpms*](https://www.baeldung.com/maven-multi-module-project-java-jpms).
    The book [*Java 9 Modularity: Patterns and Practices for Developing Maintainable
    Applications*](http://shop.oreilly.com/product/0636920049494.do) by Sander Mak
    and Paul Bakker is probably the most comprehensive treatment of JPMS.'
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch15.html#idm45290635070328-marker)) This is not strictly true. On Unix
    in C, at least, there is a distinction between normal include files and those
    in the *sys* subdirectory, and many structures have names beginning with one or
    two letters and an underscore in the password structure, like `pw_name`, `pw_passwd`,
    and `pw_home`. But this is nowhere near as consistent as Java’s `java.*` naming
    conventions.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch15.html#idm45290634169336-marker)) Some people like to use names like
    *MyPackage.mf* so that it’s clear which package it is for; the extension *.mf*
    is arbitrary, but it’s a good convention for identifying manifest files.
  prefs: []
  type: TYPE_NORMAL
