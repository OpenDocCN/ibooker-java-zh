["```java\n// Create some collections to work with.\nCollection<String> c = new HashSet<>();  // An empty set\n\n// We'll see these utility methods later. Be aware that there are\n// some subtleties to watch out for when using them\nCollection<String> d = Arrays.asList(\"one\", \"two\");\nCollection<String> e = Collections.singleton(\"three\");\n\n// Add elements to a collection. These methods return true\n// if the collection changes, which is useful with Sets that\n// don't allow duplicates.\nc.add(\"zero\");           // Add a single element\nc.addAll(d);             // Add all of the elements in d\n\n// Copy a collection: most implementations have a copy constructor\nCollection<String> copy = new ArrayList<String>(c);\n\n// Remove elements from a collection.\n// All but clear return true if the collection changes.\nc.remove(\"zero\");        // Remove a single element\nc.removeAll(e);          // Remove a collection of elements\nc.retainAll(d);          // Remove all elements that are not in d\nc.clear();               // Remove all elements from the collection\n\n// Querying collection size\nboolean b = c.isEmpty(); // c is now empty, so true\nint s = c.size();        // Size of c is now 0.\n\n// Restore collection from the copy we made\nc.addAll(copy);\n\n// Test membership in the collection. Membership is based on\n// the equals method, not the == operator.\nb = c.contains(\"zero\");  // true\nb = c.containsAll(d);    // true\n\n// Most Collection implementations have a useful toString()  method\nSystem.out.println(c);\n\n// Obtain an array of collection elements.  If the iterator guarantees\n// an order, this array has the same order. The Object array is a new\n// instance, containing references to the same objects as the original\n// collection `c` (aka a shallow copy).\nObject[] elements = c.toArray();\n\n// If we want the elements in a String[], we must pass one in\nString[] strings = c.toArray(new String[c.size()]);\n\n// Or we can pass an empty String[] just to specify the type and\n// the toArray method will allocate an array for us\nstrings = c.toArray(new String[0]);\n```", "```java\npublic static void testSortedSet(String[] args) {\n    // Create a SortedSet\n    SortedSet<String> s = new TreeSet<>(Arrays.asList(args));\n\n    // Iterate set: elements are automatically sorted\n    for (String word : s) {\n        System.out.println(word);\n    }\n\n    // Special elements\n    String first = s.first();  // First element\n    String last = s.last();    // Last element\n\n    // all elements but first\n    SortedSet<String> tail = s.tailSet(first + '\\0');\n    System.out.println(tail);\n\n    // all elements but last\n    SortedSet<String> head = s.headSet(last);\n    System.out.println(head);\n\n    SortedSet<String> middle = s.subSet(first+'\\0', last);\n    System.out.println(middle);\n}\n```", "```java\nSet<String> set = Set.of(\"Hello\", \"World\");\n```", "```java\n// Create lists to work with\nList<String> l = new ArrayList<String>(Arrays.asList(args));\nList<String> words = Arrays.asList(\"hello\", \"world\");\nList<String> words2 = List.of(\"hello\", \"world\");\n\n// Querying and setting elements by index\nString first = l.get(0);             // First element of list\nString last = l.get(l.size() - 1);   // Last element of list\nl.set(0, last);                      // The last shall be first\n\n// Adding and inserting elements.  add  can append or insert\nl.add(first);       // Append the first word at end of list\nl.add(0, first);    // Insert first at the start of the list again\nl.addAll(words);    // Append a collection at the end of the list\nl.addAll(1, words); // Insert collection after first word\n\n// Sublists: backed by the original list\nList<String> sub = l.subList(1,3);  // second and third elements\nsub.set(0, \"hi\");                   // modifies 2nd element of l\n\n// Sublists can restrict operations to a subrange of backing list\nString s = Collections.min(l.subList(0,4));\nCollections.sort(l.subList(0,4));\n\n// Independent copies of a sublist don't affect the parent list.\nList<String> subcopy = new ArrayList<String>(l.subList(1,3));\nsubcopy.clear();\n\n// Searching lists\nint p = l.indexOf(last);  // Where does the last word appear?\np = l.lastIndexOf(last);  // Search backward\n\n// Print the index of all occurrences of last in l.  Note subList\nint n = l.size();\np = 0;\nwhile (p < n) {\n    // Get a view of the list that includes only the elements we\n    // haven't searched yet.\n    List<String> list = l.subList(p, n);\n    int q = list.indexOf(last);\n    if (q == -1) break;\n    System.out.printf(\"Found '%s' at index %d%n\", last, p+q);\n    p += q+1;\n}\n\n// Removing elements from a list\nl.remove(last);         // Remove first occurrence of the element\nl.remove(0);            // Remove element at specified index\nl.subList(0,2).clear(); // Remove a range of elements using subList\nl.retainAll(words);     // Remove all but elements in words\nl.removeAll(words);     // Remove all occurrences of elements in words\nl.clear();              // Remove everything\n```", "```java\nList<String> c = new ArrayList<String>();\n// ... add some Strings to c\n\nfor(String word : c) {\n    System.out.println(word);\n}\n```", "```java\n// Iteration with a for loop\nfor(Iterator<String> i = c.iterator(); i.hasNext();) {\n    System.out.println(i.next());\n}\n```", "```java\n// Iterate through collection elements with a while loop.\n// Some implementations (such as lists) guarantee an order of iteration\n// Others make no guarantees.\nIterator<String> iterator = c.iterator();\nwhile (iterator.hasNext()) {\n    System.out.println(iterator.next());\n}\n```", "```java\npublic interface Iterator<E> {\n     boolean hasNext();\n     E next();\n     void remove();\n}\n```", "```java\npublic interface Iterable<E> {\n     java.util.Iterator<E> iterator();\n}\n```", "```java\nList<String> l = new ArrayList<>(List.of(\"one\", \"two\", \"three\"));\nfor (String x : l) {\n    if (x.equals(\"one\")) {\n        l.remove(\"one\");  // throws ConcurrentModificationException\n    }\n}\n```", "```java\n// Arbitrary list we're passed to manipulate\nList<?> l = ...;\n\n// Ensure we can do efficient random access.  If not, use a copy\n// constructor to make a random-access copy of the list before\n// manipulating it.\nif (!(l instanceof RandomAccess)) l = new ArrayList<?>(l);\n```", "```java\nList<String> words = ...;  // Get a list to iterate\n\n// Iterate just all elements of the list but the first\nfor(String word : words.subList(1, words.size()))\n    System.out.println(word);\n```", "```java\n// New, empty map\nMap<String,Integer> m = new HashMap<>();\n\n// Immutable Map containing a single key/value pair\nMap<String,Integer> singleton = Collections.singletonMap(\"test\", -1);\n\n// Note this rarely used syntax to explicitly specify the parameter\n// types of the generic emptyMap method. The returned map is immutable\nMap<String,Integer> empty = Collections.<String,Integer>emptyMap();\n\n// Populate the map using the put method to define mappings\n// from array elements to the index at which each element appears\nString[] words = { \"this\", \"is\", \"a\", \"test\" };\nfor(int i = 0; i < words.length; i++) {\n    m.put(words[i], i);  // Note autoboxing of int to Integer\n}\n\n// Each key must map to a single value. But keys may map to the\n// same value\nfor(int i = 0; i < words.length; i++) {\n    m.put(words[i].toUpperCase(), i);\n}\n\n// The putAll() method copies mappings from another Map\nm.putAll(singleton);\n\n// Query the mappings with the get()  method\nfor(int i = 0; i < words.length; i++) {\n    if (m.get(words[i]) != i) throw new AssertionError();\n}\n\n// Key and value membership testing\nm.containsKey(words[0]);        // true\nm.containsValue(words.length);  // false\n\n// Map keys, values, and entries can be viewed as collections\nSet<String> keys = m.keySet();\nCollection<Integer> values = m.values();\nSet<Map.Entry<String,Integer>> entries = m.entrySet();\n\n// The Map and its collection views typically have useful\n// toString  methods\nSystem.out.printf(\"Map: %s%nKeys: %s%nValues: %s%nEntries: %s%n\",\n                  m, keys, values, entries);\n\n// These collections can be iterated.\n// Most maps have an undefined iteration order (but see SortedMap)\nfor(String key : m.keySet()) System.out.println(key);\nfor(Integer value: m.values()) System.out.println(value);\n\n// The Map.Entry<K,V> type represents a single key/value pair in a map\nfor(Map.Entry<String,Integer> pair : m.entrySet()) {\n    // Print out mappings\n    System.out.printf(\"'%s' ==> %d%n\", pair.getKey(), pair.getValue());\n    // And increment the value of each Entry\n    pair.setValue(pair.getValue() + 1);\n}\n\n// Removing mappings\nm.put(\"testing\", null);   // Mapping to null can \"erase\" a mapping:\nm.get(\"testing\");         // Returns null\nm.containsKey(\"testing\"); // Returns true: mapping still exists\nm.remove(\"testing\");      // Deletes the mapping altogether\nm.get(\"testing\");         // Still returns null\nm.containsKey(\"testing\"); // Now returns false.\n\n// Deletions may also be made via the collection views of a map.\n// Additions to the map may not be made this way, however.\nm.keySet().remove(words[0]);  // Same as m.remove(words[0]);\n\n// Removes one mapping to the value 2 - usually inefficient and of\n// limited use\nm.values().remove(2);\n// Remove all mappings to 4\nm.values().removeAll(Collections.singleton(4));\n// Keep only mappings to 2 & 3\nm.values().retainAll(Arrays.asList(2, 3));\n\n// Deletions can also be done via iterators\nIterator<Map.Entry<String,Integer>> iter = m.entrySet().iterator();\nwhile(iter.hasNext()) {\n    Map.Entry<String,Integer> e = iter.next();\n    if (e.getValue() == 2) iter.remove();\n}\n\n// Find values that appear in both of two maps.  In general, addAll()\n// and retainAll() with keySet() and values() allow union and\n// intersection\nSet<Integer> v = new HashSet<>(m.values());\nv.retainAll(singleton.values());\n\n// Miscellaneous methods\nm.clear();                // Deletes all mappings\nm.size();                 // Returns number of mappings: currently 0\nm.isEmpty();              // Returns true\nm.equals(empty);          // true: Maps implementations override equals\n```", "```java\nMap<String, Double> cities =\n        Map.of(\n          \"Barcelona\", 22.5,\n          \"New York\", 28.3);\n```", "```java\nMap<String, Double> cities =\n        Map.ofEntries(\n          entry(\"Barcelona\", 22.5),\n          entry(\"New York\", 28.3));\n```", "```java\nList<String> list =\n    Collections.synchronizedList(new ArrayList<>());\nSet<Integer> set =\n    Collections.synchronizedSet(new HashSet<>());\nMap<String,Integer> map =\n    Collections.synchronizedMap(new HashMap<>());\n```", "```java\nList<Integer> primes = new ArrayList<>();\nList<Integer> readonly = Collections.unmodifiableList(primes);\n// We can modify the list through primes\nprimes.addAll(Arrays.asList(2, 3, 5, 7, 11, 13, 17, 19));\n// But we can't modify through the read-only wrapper\nreadonly.add(23);  // UnsupportedOperationException\n```", "```java\nCollections.sort(list);\n// list must be sorted first\nint pos = Collections.binarySearch(list, \"key\");\n```", "```java\n// Copy list2 into list1, overwriting list1\nCollections.copy(list1, list2);\n// Fill list with Object o\nCollections.fill(list, o);\n// Find the largest element in Collection c\nCollections.max(c);\n// Find the smallest element in Collection c\nCollections.min(c);\n\nCollections.reverse(list);      // Reverse list\nCollections.shuffle(list);      // Mix up list\n```", "```java\nSet<Integer> si = Collections.emptySet();\nList<String> ss = Collections.emptyList();\nMap<String, Integer> m = Collections.emptyMap();\n```", "```java\nSet<Integer> si = Set.of();\nList<String> ss = List.of();\nMap<String, Integer> m = Map.of();\n```", "```java\nSet<Integer> si = Set.of(1);\nList<String> ss = List.of(\"string\");\nMap<String, Integer> m = Map.of(\"one\", 1);\n```", "```java\nList<Integer> tenzeros = Collections.nCopies(10, 0);\n```", "```java\nString[] a = { \"this\", \"is\", \"a\", \"test\" };  // An array\n// View array as an ungrowable list\nList<String> l = Arrays.asList(a);\n// Make a growable copy of the view\nList<String> m = new ArrayList<>(l);\n\n// asList() is a varargs method so we can do this, too:\nSet<Character> abc =\n    new HashSet<Character>(Arrays.asList('a', 'b', 'c'));\n\n// Collection defines a toArray method. The no-args version creates\n// an Object[] array, copies collection elements to it and returns it\n// Get set elements as an array\nObject[] members = set.toArray();\n// Get list elements as an array\nObject[] items = list.toArray();\n// Get map key objects as an array\nObject[] keys = map.keySet().toArray();\n// Get map value objects as an array\nObject[] values = map.values().toArray();\n\n// If you want the return value to be something other than Object[],\n// pass in an array of the appropriate type. If the array is not\n// big enough, another one of the same type will be allocated.\n// If the array is too big, the collection elements copied to it\n// will be null-filled\nString[] c = l.toArray(new String[0]);\n```", "```java\nchar[] text = \"Now is the time\".toCharArray();\nchar[] copy = new char[100];\n// Copy 10 characters from element 4 of text into copy,\n// starting at copy[0]\nSystem.arraycopy(text, 4, copy, 0, 10);\n\n// Move some of the text to later elements, making room for\n// insertions If target and source are the same, this will involve\n// copying to a temporary array\nSystem.arraycopy(copy, 3, copy, 6, 7);\n```", "```java\nint[] intarray = new int[] { 10, 5, 7, -3 }; // An array of integers\nArrays.sort(intarray);                       // Sort it in place\n// Value 7 is found at index 2\nint pos = Arrays.binarySearch(intarray, 7);\n// Not found: negative return value\npos = Arrays.binarySearch(intarray, 12);\n\n// Arrays of objects can be sorted and searched too\nString[] strarray = new String[] { \"now\", \"is\", \"the\", \"time\" };\nArrays.sort(strarray);   // sorted to: { \"is\", \"now\", \"the\", \"time\" }\n\n// Arrays.equals compares all elements of two arrays\nString[] clone = (String[]) strarray.clone();\nboolean b1 = Arrays.equals(strarray, clone);  // Yes, they're equal\n\n// Arrays.fill  initializes array elements\n// An empty array; elements set to 0\nbyte[] data = new byte[100];\n// Set them all to -1\nArrays.fill(data, (byte) -1);\n// Set elements 5, 6, 7, 8, 9 to -2\nArrays.fill(data, 5, 10, (byte) -2);\n\n// Creates a new array with elements copied into it\nint[] copied = Arrays.copyOf(new int[] { 1, 2, 3 }, 2);\n```", "```java\nClass type = o.getClass();\nif (type.isArray()) {\n  Class elementType = type.getComponentType();\n}\n```", "```java\nList<String> cats = List.of(\"tiger\", \"cat\", \"TIGER\", \"leopard\");\nString search = \"tiger\";\nString tigers = cats.stream()\n                    .filter(s -> s.equalsIgnoreCase(search))\n                    .collect(Collectors.joining(\", \"));\nSystem.out.println(tigers);\n```", "```java\nPredicate<String> p = s -> s.equalsIgnoreCase(search);\nPredicate<String> combined = p.or(s -> s.equals(\"leopard\"));\nString pride = cats.stream()\n                   .filter(combined)\n                   .collect(Collectors.joining(\", \"));\nSystem.out.println(pride);\n```", "```java\nList<Integer> namesLength = cats.stream()\n                .map(String::length)\n                .toList();\nSystem.out.println(namesLength);\n```", "```java\nList<String> pets =\n  List.of(\"dog\", \"cat\", \"fish\", \"iguana\", \"ferret\");\npets.stream().forEach(System.out::println);\n```", "```java\ns -> System.out.println(s);\n```", "```java\nT reduce(T identity, BinaryOperator<T> aggregator);\n```", "```java\npublic T reduce(T identity, BinaryOperator<T> aggregator) {\n    T runningTotal = identity;\n    for (T element : myStream) {\n        runningTotal = aggregator.apply(runningTotal, element);\n    }\n\n    return runningTotal;\n}\n```", "```java\ndouble sumPrimes = List.of(2, 3, 5, 7, 11, 13, 17, 19, 23)\n        .stream()\n        .reduce(0, (x, y) -> x + y);\nSystem.out.println(\"Sum of some primes: \" + sumPrimes);\n```", "```java\n        stream()   filter()   map()   collect()\nCollection -> Stream -> Stream -> Stream -> Collection\n```", "```java\npublic class SquareGenerator implements IntSupplier {\n    private int current = 1;\n\n    @Override\n    public synchronized int getAsInt() {\n        int thisResult = current * current;\n        current++;\n        return thisResult;\n    }\n}\n\nIntStream squares = IntStream.generate(new SquareGenerator());\nPrimitiveIterator.OfInt stepThrough = squares.iterator();\nfor (int i = 0; i < 10; i++) {\n    System.out.println(stepThrough.nextInt());\n}\nSystem.out.println(\"First iterator done...\");\n\n// We can go on as long as we like...\nfor (int i = 0; i < 10; i++) {\n    System.out.println(stepThrough.nextInt());\n}\n```", "```java\n    @Override\n    public synchronized int getAsInt() {\n        int thisResult = current * current;\n        System.out.print(String.format(\"%d... \", thisResult));\n        current++;\n        return thisResult;\n    }\n```", "```java\n1... 1\n4... 4\n9... 9\n16... 16\n25... 25\n36... 36\n49... 49\n64... 64\n81... 81\n100... 100\nFirst iterator done...\n121... 121\n...\n```", "```java\nList.of(1, 2, 3, 4, 5)\n    .stream()\n    .map((i) - > {\n        System.out.println(i);\n        return i;\n    });\n```", "```java\n// Distinct elements only\nStream.of(1, 2, 1, 2, 3, 4)\n      .distinct();\n// Results in  [1, 2, 3, 4]\n\n// Ignores items until predicate matches, then returns remainder\n// Note that later elements aren't required to match the predicate.\nStream.of(1, 2, 3, 4, 5, 3)\n      .dropWhile((i) -> i < 4);\n// Results in [4, 5, 3]\n\n// Returns items from the stream until the predicate stops matching.\n// Note that later elements matching the predicate aren't returned.\nStream.of(1, 2, 3, 4, 3)\n      .takeWhile((i) -> i < 4);\n// Results in [1, 2, 3]\n\n// Skips the first N items in the stream\nStream.of(1, 2, 3, 4, 5)\n      .skip(2);\n// Results in [3, 4, 5]\n\n// Limits items taken from stream to an exact value\n// Useful with infinite streams to set boundaries\nStream.of(1, 2, 3, 4, 5)\n      .limit(3);\n// Results in [1, 2, 3]\n```", "```java\n// Are all the items odd?\nStream.of(1, 1, 3, 5)\n      .allMatch((i) -> i % 2 == 1);\n// Returns true\n\n// Are none of the items even?\nStream.of(1, 1, 3, 5)\n      .noneMatch((i) -> i % 2 == 0);\n// Returns true\n\n// Is at least one item even?\nStream.of(1, 1, 3, 5, 6)\n      .anyMatch((i) -> i % 2 == 0);\n// Returns true\n```", "```java\nvar lines = Stream.of(\n    \"For Brutus is an honourable man\",\n    \"Give me your hands if we be friends and Robin shall restore amends\",\n    \"Misery acquaints a man with strange bedfellows\");\n\nlines.map((s) -> s.split(\" +\"));\n// Returns Stream.of(new String[] { \"For\", \"Brutus\",...},\n//                   new String[] { \"Give\", \"me\", \"your\", ... },\n//                   new String[] { \"Misery\", \"acquaints\", \"a\", ... },\n```", "```java\nlines.flatMap((s) -> Arrays.stream(s.split(\" +\")));\n// Returns Stream.of(\"For\", \"Brutus\", \"is\", \"an\", ...)\n```", "```java\n// Immutable list returned\nList<Integer> list =\n    Stream.of(1, 2, 3, 4, 5).toList();\n\n// Note the return type is `Object[]`\nObject[] array =\n    Stream.of(1, 2, 3, 4, 5).toArray();\n```", "```java\n// In earlier versions of Java, Stream#toList() didn't exist\n// This was the commonly used approach so you'll still see it often\nList<Integer> list =\n    Stream.of(1,2,3,4,5)\n          .collect(Collectors.toList());\n\n// Create a standard Set (no duplicates)\nSet<Integer> set =\n    Stream.of(1,2,3,4,5)\n          .collect(Collectors.toSet());\n\n// For Collection types that don't have a specific method, we can\n// use toCollection with a function that creates our empty instance\n// Each item will be added to that collection\nTreeSet<Integer> collection =\n    Stream.of(1,2,3,4,5)\n          .collect(Collectors.toCollection(TreeSet::new));\n\n// When creating maps we must provide two functions\n// The first constructs the key for each element, the second the value\n// Here, each int is its own key and the value is its toString()\nMap<Integer, String> map =\n    Stream.of(1,2,3,4,5)\n          .collect(Collectors.toMap(\n                      (i) -> i,\n                      Object::toString));\n```", "```java\nMap<Character, List<Integer>> grouped =\n        Stream.of(10, 11, 12, 20, 30)\n                .collect(Collectors.groupingBy((i) -> {\n                    return i.toString().charAt(0);\n                }));\n// Returns map with {\"1\"=[10, 11, 12], \"2\"=[20], \"3\"=[30]}\n```", "```java\nvar count = Stream.of(1,2,3).count();\nvar max = Stream.of(1,2,3).max(Integer::compareTo);\nvar min = Stream.of(1,2,3).min(Integer::compareTo);\n```", "```java\nvar average =\n    Stream.of(1,2,3)\n          .collect(Collectors.averagingInt(Integer::intValue));\n\nvar sum =\n    Stream.of(1,2,3)\n          .collect(Collectors.summingInt(Integer::intValue));\n\nvar summary =\n    Stream.of(1,2,3)\n          .collect(Collectors.summarizingInt(Integer::intValue));\n// IntSummaryStatistics{count=3, sum=6, min=1, average=2.0, max=3}\n```", "```java\nvar words = Stream.of(\"This\", \"is\", \"some\", \"text\");\nvar csv = words.collect(Collectors.joining(\", \"));\n// Returns string \"This, is, some, text\"\n```", "```java\n// Essentially just forwards to the helper method in Collections\npublic default void sort(Comparator<? super E> c) {\n    Collections.<E>sort(this, c);\n}\n```"]