["```java\npublic class RecommendationsTests {\n\n    private final DistanceCalculator distanceCalculator =\n        mock(DistanceCalculator.class);\n    private final FeaturedDestinations featuredDestinations =\n        mock(FeaturedDestinations.class);\n    private final Recommendations recommendations = new Recommendations(\n        featuredDestinations::findCloseTo,\n        distanceCalculator::distanceInMetersBetween\n    );\n    ...\n}\n```", "```java\n@Test\npublic void returns_recommendations_for_single_location() {\n    givenFeaturedDestinationsFor(paris,\n        List.of(\n            eiffelTower,\n            louvre\n        ));\n    givenADistanceBetween(paris, eiffelTower, 5000);\n    givenADistanceBetween(paris, louvre, 1000);\n\n    assertEquals(\n        List.of(\n            new FeaturedDestinationSuggestion(paris, louvre, 1000),\n            new FeaturedDestinationSuggestion(paris, eiffelTower, 5000)\n        ),\n        recommendations.recommendationsFor(Set.of(paris))\n    );\n}\n```", "```java\nprivate void givenADistanceBetween(\n    Location location,\n    FeaturedDestination destination,\n    int result\n) {\n    when(\n        distanceCalculator.distanceInMetersBetween(\n            location,\n            destination.getLocation())\n    ).thenReturn(result);\n}\n```", "```java\nclass RecommendationsTests {\n    private val distanceCalculator = mock(DistanceCalculator::class.java)\n    private val featuredDestinations = mock(FeaturedDestinations::class.java)\n\n    private val recommendations = Recommendations(\n        featuredDestinations::findCloseTo,\n        distanceCalculator::distanceInMetersBetween\n    )\n    ...\n```", "```java\nprivate fun givenFeaturedDestinationsFor(\n    location: Location,\n    result: List<FeaturedDestination>\n) {\n    Mockito.`when`(featuredDestinations.findCloseTo(location))\n        .thenReturn(result)\n}\n```", "```java\nprivate val featuredDestinations =\n    mutableMapOf<Location, List<FeaturedDestination>>()\n        .withDefault { emptyList() }\n```", "```java\nprivate fun givenFeaturedDestinationsFor(\n    location: Location,\n    destinations: List<FeaturedDestination>\n) {\n    featuredDestinations[location] = destinations.toList()\n}\n```", "```java\nprivate val recommendations =\n    Recommendations(\n        featuredDestinations::getValue,\n        distanceCalculator::distanceInMetersBetween\n    )\n```", "```java\nclass RecommendationsTests {\n\n    private val featuredDestinations =\n        mutableMapOf<Location, List<FeaturedDestination>>()\n            .withDefault { emptyList() }\n    private val distanceInMetersBetween =\n        mutableMapOf<Pair<Location, Location>, Int>()\n            .withDefault { -1 }\n\n    private val recommendations =\n        Recommendations(\n            featuredDestinations::getValue,\n            { l1, l2 -> distanceInMetersBetween.getValue(l1 to l2) }\n        )\n    ...\n}\n```", "```java\nprivate fun givenADistanceFrom(\n    location: Location,\n    destination: FeaturedDestination,\n    distanceInMeters: Int\n) {\n    distanceInMetersBetween[location to destination.location] =\n        distanceInMeters\n}\n```", "```java\nprivate fun <K1, K2, V> Map<Pair<K1, K2>, V>.getValue(k1: K1, k2: K2) =\n    getValue(k1 to k2)\n```", "```java\nprivate val recommendations =\n    Recommendations(\n        featuredDestinations::getValue,\n        distanceInMetersBetween::getValue\n    )\n```", "```java\n@Test\nfun deduplicates_using_smallest_distance() {\n    givenFeaturedDestinationsFor(\n        alton,\n        flowerFarm, watercressLine\n    )\n    givenFeaturedDestinationsFor(\n        froyle,\n        flowerFarm, watercressLine\n    )\n    givenADistanceFrom(alton, flowerFarm, 5300)\n    givenADistanceFrom(alton, watercressLine, 320)\n    givenADistanceFrom(froyle, flowerFarm, 0)\n    givenADistanceFrom(froyle, watercressLine, 6300)\n    assertEquals(\n        listOf(\n            FeaturedDestinationSuggestion(froyle, flowerFarm, 0),\n            FeaturedDestinationSuggestion(alton, watercressLine, 320)\n        ),\n        recommendations.recommendationsFor(setOf(alton, froyle))\n    )\n}\n```", "```java\n@Test\nfun deduplicates_using_smallest_distance() {\n    givenFeaturedDestinationsFor(alton, of(flowerFarm, watercressLine))\n    givenADistanceFrom(alton, to = flowerFarm, of = 5300)\n    givenADistanceFrom(alton, to = watercressLine, of = 320)\n\n    givenFeaturedDestinationsFor(froyle, of(flowerFarm, watercressLine))\n    givenADistanceFrom(froyle, to = flowerFarm, of = 0)\n    givenADistanceFrom(froyle, to = watercressLine, of = 6300)\n\n    assertEquals(\n        listOf(\n            FeaturedDestinationSuggestion(froyle, flowerFarm, 0),\n            FeaturedDestinationSuggestion(alton, watercressLine, 320)\n        ),\n        recommendations.recommendationsFor(setOf(alton, froyle))\n    )\n}\n```", "```java\nprivate fun of(vararg destination: FeaturedDestination)\n    = destination.toList()\n```", "```java\ninline fun <reified T> fake(): T =\n    Proxy.newProxyInstance(\n        T::class.java.classLoader,\n        arrayOf(T::class.java)\n    ) { _, _, _ ->\n        TODO(\"not implemented\")\n    } as T\n\nval sentEmails = mutableListOf<Email>()\nval testCollaborator: EmailSystem =\n    object : EmailSystem by fake() {\n        override fun send(email: Email) {\n            sentEmails.add(email)\n        }\n    }\n```", "```java\nprivate fun subjectFor(\n    featuredDestinations: Map<Location, List<FeaturedDestination>>,\n    distances: Map<Pair<Location, Location>, Int>\n): Recommendations {\n    val destinationsLookup = featuredDestinations.withDefault { emptyList() }\n    val distanceLookup = distances.withDefault { -1 }\n    return Recommendations(destinationsLookup::getValue, distanceLookup::getValue)\n}\n```", "```java\nprivate fun resultFor(\n    featuredDestinations: Map<Location, List<FeaturedDestination>>,\n    distances: Map<Pair<Location, Location>, Int>,\n    locations: Set<Location>\n): List<FeaturedDestinationSuggestion> {\n    val subject = subjectFor(featuredDestinations, distances)\n    return subject.recommendationsFor(locations)\n}\n```", "```java\nprivate fun check(\n    featuredDestinations: Map<Location, List<FeaturedDestination>>,\n    distances: Map<Pair<Location, Location>, Int>,\n    recommendations: Set<Location>,\n    shouldReturn: List<FeaturedDestinationSuggestion>\n) {\n    assertEquals(\n        shouldReturn,\n        resultFor(featuredDestinations, distances, recommendations)\n    )\n}\n```", "```java\nclass RecommendationsTests {\n    companion object {\n        val distances = mapOf(\n            (paris to eiffelTower.location) to 5000,\n            (paris to louvre.location) to 1000,\n            (alton to flowerFarm.location) to 5300,\n            (alton to watercressLine.location) to 320,\n            (froyle to flowerFarm.location) to 0,\n            (froyle to watercressLine.location) to 6300\n        )\n    }\n\n    ...\n\n    @Test\n    fun returns_no_recommendations_when_no_featured() {\n        check(\n            featuredDestinations = emptyMap(),\n            distances = distances,\n            recommendations = setOf(paris),\n            shouldReturn = emptyList()\n        )\n    }\n\n    ...\n\n    @Test\n    fun returns_recommendations_for_multi_location() {\n        check(\n            featuredDestinations = mapOf(\n                paris to listOf(eiffelTower, louvre),\n                alton to listOf(flowerFarm, watercressLine),\n            ),\n            distances = distances,\n            recommendations = setOf(paris, alton),\n            shouldReturn = listOf(\n                FeaturedDestinationSuggestion(alton, watercressLine, 320),\n                FeaturedDestinationSuggestion(paris, louvre, 1000),\n                FeaturedDestinationSuggestion(paris, eiffelTower, 5000),\n                FeaturedDestinationSuggestion(alton, flowerFarm, 5300)\n            )\n        )\n    }\n    ...\n}\n```", "```java\n@Test\npublic void returns_recommendations_for_multi_location() {\n    givenFeaturedDestinationsFor(paris,\n        List.of(\n            eiffelTower,\n            louvre\n        ));\n    givenADistanceBetween(paris, eiffelTower, 5000);\n    givenADistanceBetween(paris, louvre, 1000);\n\n    givenFeaturedDestinationsFor(alton,\n        List.of(\n            flowerFarm,\n            watercressLine\n        ));\n    givenADistanceBetween(alton, flowerFarm, 5300);\n    givenADistanceBetween(alton, watercressLine, 320);\n\n    assertEquals(\n        List.of(\n            new FeaturedDestinationSuggestion(alton, watercressLine, 320),\n            new FeaturedDestinationSuggestion(paris, louvre, 1000),\n            new FeaturedDestinationSuggestion(paris, eiffelTower, 5000),\n            new FeaturedDestinationSuggestion(alton, flowerFarm, 5300)\n        ),\n        recommendations.recommendationsFor(Set.of(paris, alton))\n    );\n}\n```"]