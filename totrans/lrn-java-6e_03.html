<html><head></head><body><section data-pdf-bookmark="Chapter 3. Tools of the Trade" data-type="chapter" epub:type="chapter"><div class="chapter" id="learnjava6-CHP-3">&#13;
<h1><span class="label">Chapter 3. </span>Tools of the Trade</h1>&#13;
&#13;
&#13;
<p>While you will almost certainly do the majority of your Java development in an IDE such as VS Code or IntelliJ IDEA, all of the core tools you need to build Java applications are included in the JDK that you downloaded in <a data-type="xref" href="ch02.html#learnjava6-CHP-2-SECT-1.1">“Installing the JDK”</a>. When we write Java source code, it is the Java compiler—<em>javac</em>—that turns our source into usable bytecode. When we want to test that bytecode, it is the Java command itself—<em>java</em>—that we use to execute our programs. <a data-primary="JAR file package" data-type="indexterm" id="id818"/>When we have all of our classes compiled and working together, it is the Java archive tool—<em>jar</em>—that allows us to bundle up those classes for distribution.  In this chapter, we’ll discuss some of these command-line tools that you can use to compile, run, and package Java applications. <a data-primary="javap command" data-type="indexterm" id="id819"/><a data-primary="jshell" data-type="indexterm" id="id820"/>There are many additional developer tools included in the JDK, such as <em>jshell</em> for interactive work or <em>javap</em> for decompiling class files. We won’t have time to discuss all of them in this book, but anywhere another tool might be useful, we’ll mention it. (And we will definitely be looking at <em>jshell</em>. It’s great for quickly trying out a new class or method.)</p>&#13;
&#13;
<p>We want you to be comfortable with these command-line tools even if you don’t typically work in a terminal or command window. Some features of these tools aren’t easily accessible through IDEs. You may also encounter times where an IDE is impractical or downright unavailable. System administrators and DevOps engineers, for example, often have only limited, text-based connections to their servers running in fancy data centers. If you need to fix a Java problem over such a connection, these command-line tools will be essential.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="JDK Environment" data-type="sect1"><div class="sect1" id="learnjava6-CHP-3-SECT-1">&#13;
<h1>JDK Environment</h1>&#13;
&#13;
<p>After you install the <a data-primary="Java Development Kit (JDK)" data-type="indexterm" id="id821"/><a data-primary="JDK (Java Development Kit)" data-type="indexterm" id="id822"/><a data-primary="java runtime command" data-type="indexterm" id="id823"/>JDK, the core <em>java</em> runtime command usually appears in your path (available to run) automatically, although not always. Additionally, many of the other commands provided with the JDK may not be available unless you add the Java <em>bin</em> directory to your execution path. To make sure you have access to all the tools, regardless of your setup, the following commands show how to correctly configure your development environment on Linux, macOS, and Windows. <a data-primary="environment variables" data-type="indexterm" id="id824"/>You define a new environment variable for Java’s location and append that <em>bin</em> folder to the existing path variable. (Operating systems use <em>environment variables</em> to store bits of information that applications can use and potentially share as they run.) You will, of course, have to change the paths in our examples to match the version of Java you have installed:</p>&#13;
&#13;
<pre data-type="programlisting"># Linux&#13;
export JAVA_HOME=/usr/lib/jvm/jdk-21-ea14&#13;
export PATH=$PATH:$JAVA_HOME/bin&#13;
&#13;
# Mac OS X&#13;
export JAVA_HOME=/Users/marc/jdks/jdk-21-ea14/Contents/Home&#13;
export PATH=$PATH:$JAVA_HOME/bin&#13;
&#13;
# Windows&#13;
set JAVA_HOME=c:\Program Files\Java\jdk21&#13;
set PATH=%PATH%;%JAVA_HOME%\bin</pre>&#13;
&#13;
<p>On macOS, the situation may be more confusing because recent versions of the operating system ship with “stubs” for the Java commands installed. Apple no longer provides its own implementation of Java, so if you attempt to run one of these commands, the OS will prompt you to download Java at that time.</p>&#13;
&#13;
<p>When in doubt, your go-to test for determining if Java is installed, and which version of the tools you are using, is to use the <code>-version</code> flag on the <em>java</em> and <em>javac</em> commands:</p>&#13;
&#13;
<pre data-type="programlisting">% java -version&#13;
&#13;
openjdk version "21-ea" 2023-09-19&#13;
OpenJDK Runtime Environment (build 21-ea+14-1161)&#13;
OpenJDK 64-Bit Server VM (build 21-ea+14-1161, mixed mode, sharing)&#13;
&#13;
% javac -version&#13;
&#13;
javac 21-ea</pre>&#13;
&#13;
<p>The <code>ea</code> in our version output indicates this is an “early access” release. (Java 21 is still being tested as we write this edition.)</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The Java VM" data-type="sect1"><div class="sect1" id="learnjava6-CHP-3-SECT-2">&#13;
<h1>The Java VM</h1>&#13;
&#13;
<p>A <a data-primary="Java Virtual Machine (JVM)" data-type="indexterm" id="id825"/><a data-primary="JVM (Java Virtual Machine)" data-type="indexterm" id="id826"/>Java virtual machine (VM) is software that implements the Java runtime system and executes Java applications. <a data-primary="java command" data-type="indexterm" id="id827"/>It can be a standalone application like the <em>java</em> command that comes with the JDK or built into a larger application like a web browser. Usually the interpreter itself is a native application, supplied for each platform, which then bootstraps other tools written in the Java language. Tools such as Java compilers and IDEs are often implemented directly in Java to maximize their portability and extensibility. Eclipse, for example, is a pure Java application.</p>&#13;
&#13;
<p>The <a data-primary="classes" data-secondary="loading from JVM" data-type="indexterm" id="id828"/>Java VM performs all the runtime activities of Java. It loads Java class files, verifies classes from untrusted sources, and executes the compiled bytecode. It manages memory and system resources. Good implementations also perform dynamic optimization, compiling Java bytecode into native machine instructions.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Running Java Applications" data-type="sect1"><div class="sect1" id="learnjava6-CHP-3-SECT-3">&#13;
<h1>Running Java Applications</h1>&#13;
&#13;
<p>A standalone <a data-primary="main() method" data-type="indexterm" id="id829"/><a data-primary="classes" data-secondary="naming main() method's class" data-type="indexterm" id="id830"/><a data-primary="applications" data-secondary="running" data-type="indexterm" id="ix_apps_running"/><a data-primary="arguments" data-secondary="running applications" data-type="indexterm" id="ix_arg_run_app"/>Java application must have at least one class containing a method called <code>main()</code>, which is the first code to be executed upon startup. To run the application, start the VM, specifying that class as an argument. You can also specify options to the interpreter as well as arguments to be passed to the application:</p>&#13;
&#13;
<pre data-type="programlisting">% java [interpreter options] class_name [program arguments]</pre>&#13;
&#13;
<p>The <a data-primary="packages" data-secondary="naming" data-type="indexterm" id="id831"/><a data-primary="fully qualified name, Java library packages" data-type="indexterm" id="id832"/>class should be specified as a fully qualified class name, including the package name, if any. Note, however, that you don’t include the <em>.class</em> file extension. Here are a couple of examples that you can try from the terminal in the <em>ch03/examples</em> folder:</p>&#13;
&#13;
<pre data-type="programlisting">% cd ch03/examples&#13;
% java animals.birds.BigBird&#13;
% java MyTest</pre>&#13;
&#13;
<p>The interpreter searches for the class in the <em>classpath</em>, a list of directories and archive files where classes are stored. You can specify the classpath either by an environment variable similar to <code>JAVA_HOME</code> above, or with the command-line option <em><code>-classpath</code></em>. If both are present, Java uses the command-line option. We’ll discuss the classpath in detail in the next section.</p>&#13;
&#13;
<p>You can also use the <em>java</em> command to launch an “executable” Java ARchive (JAR) file:</p>&#13;
&#13;
<pre data-type="programlisting">% java -jar spaceblaster.jar</pre>&#13;
&#13;
<p>In this case, the JAR file includes metadata with the name of the startup class containing the <code>main()</code> method, and the classpath becomes the JAR file itself. We’ll look more closely at JAR files in <a data-type="xref" href="#learnjava6-CHP-3-SECT-7">“JAR Files”</a>.</p>&#13;
&#13;
<p>If you’re working primarily in an IDE, remember that you can still try those previous commands using the built-in terminal options we mentioned in <a data-type="xref" href="ch02.html#learnjava6-CHP-2-SECT-1.3">“Running the Project”</a>.</p>&#13;
&#13;
<p>After loading the first class and executing its <code>main()</code> method, the application can reference other classes, start additional threads, and create its user interface or other structures, as shown in <a data-type="xref" href="#learnjava6-CHP-3-FIG-1">Figure 3-1</a>.</p>&#13;
&#13;
<figure><div class="figure" id="learnjava6-CHP-3-FIG-1">&#13;
<img alt="ljv6 0301" src="assets/ljv6_0301.png"/>&#13;
<h6><span class="label">Figure 3-1. </span>Starting a Java application</h6>&#13;
</div></figure>&#13;
&#13;
<p>The <code>main()</code> method <a data-primary="method signature" data-type="indexterm" id="id833"/>must have the right <em>method signature</em>. A method signature is the set of information that defines the method. It includes the method’s name, arguments, and return type, as well as type and visibility modifiers. The <code>main()</code> method must be a <code>public</code>, <code>static</code> method that takes an array of <code>String</code> objects as its argument and does not return any value (<code>void</code>):</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">  </code><code class="kd">public</code><code class="w"> </code><code class="kd">static</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">main</code><code class="w"> </code><code class="p">(</code><code class="n">String</code><code class="w"> </code><code class="o">[]</code><code class="w"> </code><code class="n">myArgs</code><code class="p">)</code><code class="w"/></pre>&#13;
&#13;
<p>The fact that <code>main()</code> is a <code>public</code> and <code>static</code> method simply means that it is globally accessible and that it can be called directly by name. We’ll discuss the implications of visibility modifiers such as <code>public</code> and the meaning of <code>static</code> in <a data-type="xref" href="ch04.html#learnjava6-CHP-4">Chapter 4</a> and <a data-type="xref" href="ch05.html#learnjava6-CHP-5">Chapter 5</a>.</p>&#13;
&#13;
<p>The <code>main()</code> method’s single argument, the array of <code>String</code> objects, holds the command-line arguments passed to the application. The name of the parameter doesn’t matter; only the type is important. In Java, the content of <code>myArgs</code> is an array. (More on arrays in <a data-type="xref" href="ch04.html#learnjava6-CHP-4">Chapter 4</a>.) In Java, arrays know how many elements they contain and can happily provide that information:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="kt">int</code><code class="w"> </code><code class="n">numArgs</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">myArgs</code><code class="p">.</code><code class="na">length</code><code class="p">;</code><code class="w"/></pre>&#13;
&#13;
<p><code>myArgs[0]</code> is the first command-line argument, and so on.</p>&#13;
&#13;
<p>The Java interpreter continues to run until the <code>main()</code> method of the initial class file returns and until any threads that it has started also exit. (More on threads in <a data-type="xref" href="ch09.html#learnjava6-CHP-9">Chapter 9</a>.) Special threads designated as <em>daemon</em> threads are automatically terminated when the rest of the application has completed.<a data-primary="" data-startref="ix_apps_running" data-type="indexterm" id="id834"/><a data-primary="" data-startref="ix_arg_run_app" data-type="indexterm" id="id835"/></p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="System Properties" data-type="sect2"><div class="sect2" id="learnjava6-CHP-3-SECT-3.1">&#13;
<h2>System Properties</h2>&#13;
&#13;
<p>Although it is <a data-primary="system properties, JVM" data-type="indexterm" id="id836"/>possible to read host environment variables from Java, Oracle discourages using them for application configuration. Instead, Java allows you to pass any number of <em>system property</em> values to the application when the VM is started. System properties are simply name-value string pairs that are available to the application through the static <code>System.getProperty()</code> method. You can use these properties as a more structured and portable alternative to command-line arguments and environment variables for providing general configuration information to your application at startup. You pass each system property to the interpreter on the command line using the <em><code>-D</code></em> option followed by <em><code>name</code></em><code>=</code><em><code>value</code></em>. For example:</p>&#13;
&#13;
<pre data-type="programlisting">% java -Dstreet=sesame -Dscene=alley animals.birds.BigBird</pre>&#13;
&#13;
<p>You can then access the value of the <code>street</code> property inside your program this way:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="n">String</code><code class="w"> </code><code class="n">street</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">System</code><code class="p">.</code><code class="na">getProperty</code><code class="p">(</code><code class="s">"street"</code><code class="p">);</code><code class="w"/></pre>&#13;
&#13;
<p>An application can get its configuration in a myriad of other ways, of course, including via files or or over the network at runtime.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The Classpath" data-type="sect1"><div class="sect1" id="learnjava6-CHP-3-SECT-4">&#13;
<h1>The Classpath</h1>&#13;
&#13;
<p>The <a data-primary="path" data-secondary="classpath" data-type="indexterm" id="ix_path_classpath_ch3"/><a data-primary="classpath" data-type="indexterm" id="ix_class_path_ch3"/><a data-primary="CLASSPATH environment variable" data-type="indexterm" id="id837"/>concept of a <em>path</em> should be familiar to anyone who has worked on a DOS or Unix platform. It’s an environment variable that provides an application with a list of places to look for some resource. The most common example is a path for executable programs. In a Unix shell, the <code>PATH</code> environment variable is a colon-separated list of directories that are searched, in order, when the user types the name of a command. The Java <code>CLASSPATH</code> environment variable, similarly, is a list of locations that both the interpreter and the compiler will search for packages and Java classes.</p>&#13;
&#13;
<p>An <a data-primary="JAR file package" data-type="indexterm" id="id838"/>element of the classpath can be a directory or a JAR file. JARs are simple archives that include extra files (metadata) that describe each archive’s contents. JAR files are created with the JDK’s <em>jar</em> utility. Many tools for creating ZIP archives are publicly available and can be used to inspect or create JAR files as well.<sup><a data-type="noteref" href="ch03.html#id839" id="id839-marker">1</a></sup> The archive format enables large groups of classes and their resources to be distributed in a single, compact file; the Java runtime automatically extracts individual class files from the archive, as needed. We’ll look more closely at JARs and the <em>jar</em> command in <a data-type="xref" href="#learnjava6-CHP-3-SECT-7.1">“The jar Utility”</a>.</p>&#13;
&#13;
<p>The precise means and format for setting the classpath vary from system to system. Let’s take a look at how to do it.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="CLASSPATH on Unix and macOS" data-type="sect2"><div class="sect2" id="learnjava6-CHP-3-SECT-4.1">&#13;
<h2>CLASSPATH on Unix and macOS</h2>&#13;
&#13;
<p>On a <a data-primary="macOS" data-type="indexterm" id="id840"/><a data-primary="Unix, CLASSPATH on" data-type="indexterm" id="id841"/>Unix system (including macOS), you set the <code>CLASSPATH</code> environment variable with a colon-separated list of directories and class archive files:</p>&#13;
&#13;
<pre data-code-language="sh" data-type="programlisting">%<code class="w"> </code><code class="nb">export</code><code class="w"> </code><code class="nv">CLASSPATH</code><code class="o">=</code>/home/vicky/Java/classes:/home/josh/lib/foo.jar:.<code class="w"/></pre>&#13;
&#13;
<p>This <a data-primary="dot (.) notation/operator" data-secondary="classpath in Unix/macOS" data-type="indexterm" id="id842"/>example specifies a classpath with three locations: a directory in the user’s home, a JAR file in another user’s directory, and the current directory, which is always specified with a dot (<code>.</code>). The last component of the classpath, the current directory, is useful when you are tinkering with classes.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="CLASSPATH on Windows" data-type="sect2"><div class="sect2" id="learnjava6-CHP-3-SECT-4.2">&#13;
<h2>CLASSPATH on Windows</h2>&#13;
&#13;
<p>On a <a data-primary="Windows" data-type="indexterm" id="id843"/>Windows system, the <code>CLASSPATH</code> environment variable is set with a semicolon-separated list of directories and class archive files:</p>&#13;
&#13;
<pre data-type="programlisting">C:\&gt; set CLASSPATH=C:\home\vicky\Java\classes;C:\home\josh\lib\foo.jar;.</pre>&#13;
&#13;
<p>The Java <a data-primary="core classes" data-type="indexterm" id="id844"/>launcher and the other command-line tools know how to find the <em>core classes</em>, which are the classes included in every Java installation. The classes in the <code>java.lang</code>, <code>java.io</code>, <code>java.net</code>, and <code>javax.swing</code> packages, for example, are all core classes, so you do not need to include a library or directory for these classes in your classpath.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="CLASSPATH Wildcards" data-type="sect2"><div class="sect2" id="learnjava6-CHP-3-SECT-4.3">&#13;
<h2>CLASSPATH Wildcards</h2>&#13;
&#13;
<p>The <code>CLASSPATH</code> environment <a data-primary="wildcard (*) type" data-type="indexterm" id="id845"/><a data-primary="* (asterisk)" data-secondary="wildcard type" data-type="indexterm" id="id846"/><a data-primary="asterisk (*)" data-secondary="wildcard type" data-type="indexterm" id="id847"/>variable may also include “*” wildcards that match all JAR files within a directory. For example:</p>&#13;
&#13;
<pre data-code-language="sh" data-type="programlisting">%<code class="w"> </code><code class="nb">export</code><code class="w"> </code><code class="nv">CLASSPATH</code><code class="o">=</code>/home/sarah/libs/*<code class="w"/></pre>&#13;
&#13;
<p>To find other classes, the Java interpreter searches the elements of the classpath in the order they are listed. The search combines the path location and the components of the fully qualified class name. For example, consider a search for the class <code>animals.birds.BigBird</code>, as shown in <a data-type="xref" href="#learnjava6-CHP-3-FIG-classpath">Figure 3-2</a>. Searching the classpath directory <em>/usr/lib/java</em> means that the interpreter looks for an individual class file at <em>/usr/lib/java/animals/birds/BigBird.class</em>. Searching a ZIP or JAR archive on the classpath, say <em>/home/sarah/zoo.jar</em>, means that the interpreter looks for the file &#13;
<span class="keep-together"><em>animals/birds/BigBird.class</em></span> within that archive.</p>&#13;
&#13;
<figure><div class="figure" id="learnjava6-CHP-3-FIG-classpath">&#13;
<img alt="ljv6 0302" src="assets/ljv6_0302.png"/>&#13;
<h6><span class="label">Figure 3-2. </span>Finding a fully qualified name in the classpath</h6>&#13;
</div></figure>&#13;
&#13;
<p>For the Java runtime, <em>java</em>, and the Java compiler, <em>javac</em>, the classpath can also be specified with the <em><code>-classpath</code></em> option. On a Linux or macOS machine, for example:</p>&#13;
&#13;
<pre data-type="programlisting">% javac -classpath /home/pat/classes:/utils/utils.jar:. Foo.java</pre>&#13;
&#13;
<p>It’s essentially the same on Windows, but you have to follow the system path separator (a semicolon) and use drive letters to start absolute paths.</p>&#13;
&#13;
<p>If you don’t specify the <code>CLASSPATH</code> environment variable or command-line option, the classpath defaults to the current directory (<code>.</code>); this means that the files in your current directory are normally available. If you change the classpath and don’t include the current directory, these files will no longer be accessible.</p>&#13;
&#13;
<p>We suspect that many of the problems that newcomers have when first learning Java are classpath related. Pay particular attention to setting and checking the classpath when getting started. If you’re working inside an IDE, it may remove some or all of the burden of managing the classpath. Ultimately, however, understanding the classpath and knowing exactly what is in it when your application runs is very important to your long-term sanity.<a data-primary="" data-startref="ix_class_path_ch3" data-type="indexterm" id="id848"/><a data-primary="" data-startref="ix_path_classpath_ch3" data-type="indexterm" id="id849"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Modules" data-type="sect2"><div class="sect2" id="learnjava6-CHP-3-SECT-4.4">&#13;
<h2>Modules</h2>&#13;
&#13;
<p>Java 9 introduced the <em>modules</em> <a data-primary="modules, classpath" data-type="indexterm" id="id850"/>approach to Java applications. Modules allow for more fine-grained, performant application deployments—even when the application in question is (very) large. (Modules are not required, even for large applications. You can continue using the classic classpath approach if it fits your needs.) Using modules requires extra setup so we won’t be tackling them in this book, but larger, commercially distributed apps may be module based. You can check out <a href="https://oreil.ly/Wjs1q"><em>Java 9 Modularity</em></a> by Paul Bakker and Sander Mak (O’Reilly) for more details and help modularizing your own large projects if you start looking to share your work beyond just posting source code to public repositories.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The Java Compiler" data-type="sect1"><div class="sect1" id="learnjava6-CHP-3-SECT-5">&#13;
<h1>The Java Compiler</h1>&#13;
&#13;
<p>The <em>javac</em> command-line utility is the <a data-primary="javac command-line utility" data-type="indexterm" id="ix_javac_utility"/><a data-primary="compiler" data-type="indexterm" id="ix_compiler_ch3"/>compiler in the JDK. The compiler is written entirely in Java, so it’s available for any platform that supports the Java runtime system. <em>javac</em> turns Java source code into a compiled class that contains Java bytecode. By convention, source files are named with a <em>.java</em> extension; the resulting class files have a <em>.class</em> extension. Each source code file is considered a single compilation unit. (As you’ll see in <a data-type="xref" href="ch05.html#learnjava6-CHP-5">Chapter 5</a>, classes in a given compilation unit share certain features, such as <code>package</code> and <code>import</code> statements.)</p>&#13;
&#13;
<p><em>javac</em> allows one public class per file and insists that the file must have the same name as the class. If the filename and class name don’t match, <em>javac</em> issues a compilation error. A single file can contain multiple classes, as long as only one of the classes is public and is named for the file. Avoid packing too many classes into a single source file. Packing classes together in a <em>.java</em> file only superficially associates them.</p>&#13;
&#13;
<p>Go ahead and create a new file named <em>Bluebird.java</em> in the <em>ch03/examples/animals/birds</em> folder. You can use your IDE for this step, or you can just open any old text editor and make a new file. Once you have created the file, place the following source code in the file:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kn">package</code><code class="w"> </code><code class="nn">animals.birds</code><code class="p">;</code><code class="w"/>&#13;
&#13;
<code class="kd">public</code><code class="w"> </code><code class="kd">class</code> <code class="nc">Bluebird</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>Next, compile it with:</p>&#13;
&#13;
<pre data-type="programlisting">% cd ch03/examples&#13;
% javac animals/birds/Bluebird.java</pre>&#13;
&#13;
<p>Our tiny file doesn’t do anything yet, but compiling it should work fine. You should not see any errors.</p>&#13;
&#13;
<p>Unlike the Java interpreter, which takes just a class name as its argument, <em>javac</em> needs a filename (including the <em>.java</em> extension) to process. The previous command produces the class file <em>Bluebird.class</em> in the same directory as the source file. While it’s nice to see the class file in the same directory as the source for this example, for most real applications, you need to store the class file in an appropriate place in the classpath.</p>&#13;
&#13;
<p>You can use the <em><code>-d</code></em> option with <em>javac</em> to specify an alternative directory for storing the class files <em>javac</em> generates. The specified directory is used as the root of the class hierarchy, so <em>.class</em> files are placed in this directory or in a subdirectory, depending on whether the class is contained in a package. (The compiler creates intermediate subdirectories automatically, if necessary.) For example, we could use the following command to create the <em>Bluebird.class</em> file at <em>/home/vicky/Java/classes/animals/birds/Bluebird.class</em>:</p>&#13;
&#13;
<pre data-type="programlisting">% javac -d /home/vicky/Java/classes Bluebird.java</pre>&#13;
&#13;
<p>You can specify <a data-primary="references" data-secondary="from classes" data-secondary-sortas="classes" data-type="indexterm" id="id851"/>multiple <em>.java</em> files in a single <em>javac</em> command; the compiler creates a class file for each source file given. But you don’t need to list the other classes your class references as long as they are in the classpath in either source or compiled form. During compilation, Java resolves all other class references using the classpath.</p>&#13;
&#13;
<p class="pagebreak-before">The Java compiler is more intelligent than your average compiler. For example, <em>javac</em> compares the modification times of the source and class files for all classes and recompiles them as necessary. A compiled Java class remembers the source file from which it was compiled, and as long as the source file is available, <em>javac</em> can recompile it, if necessary. If, in the previous example, class <code>BigBird</code> references another class, say, <code>animals.furry.Grover</code>, <em>javac</em> looks for the source file <em>Grover.java</em> in an <code>animals.furry</code> package and recompiles the file, if necessary, to bring the <em>Grover.class</em> class file up-to-date.</p>&#13;
&#13;
<p>By default, however, <em>javac</em> checks only source files that are referenced directly from other source files. This means that if you have an out-of-date class file that is referenced only by an up-to-date class file, it may not be noticed and recompiled. For that and many other reasons, most projects use a real build utility such as <a href="https://gradle.org">Gradle</a> to manage builds, packaging, and more.</p>&#13;
&#13;
<p>Finally, it’s important to note that <em>javac</em> can compile an application even if only the compiled (binary) versions of some of the classes are available. You don’t need source code for all your objects. Java class files contain all the data type and method signature information that source files contain, so compiling against binary class files is as good as compiling with Java source code. (If you need to make changes, of course, you still need source files.)<a data-primary="" data-startref="ix_compiler_ch3" data-type="indexterm" id="id852"/><a data-primary="" data-startref="ix_javac_utility" data-type="indexterm" id="id853"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Trying Java" data-type="sect1"><div class="sect1" id="learnjava6-CHP-3-SECT-6">&#13;
<h1>Trying Java</h1>&#13;
&#13;
<p>Java 9 introduced a <a data-primary="REPL (Read Eval Print Loop)" data-type="indexterm" id="ix_repl_read_eval"/><a data-primary="jshell" data-type="indexterm" id="ix_jshell_ch3"/><a data-primary="Read Eval Print Loop (REPL)" data-type="indexterm" id="ix_read_eval_repl"/>utility called <em>jshell</em>, which allows you to try out bits of Java code and see the results immediately. <em>jshell</em> is a REPL—a Read-Evaluate-Print Loop. Many languages have them, and prior to Java 9 there were many third-party variations available, but nothing was built into the JDK itself. Let’s look a little more carefully at its capabilities.</p>&#13;
&#13;
<p>You can use a terminal or command window from your operating system, or you can open a terminal tab in IntelliJ IDEA, as shown in <a data-type="xref" href="#learnjava6-CHP-3-FIG-2">Figure 3-3</a>. Just type <strong><code>jshell</code></strong> at your command prompt and you’ll see a bit of version information along with a quick reminder about how to view help from within the REPL.</p>&#13;
&#13;
<figure><div class="figure" id="learnjava6-CHP-3-FIG-2">&#13;
<img alt="ljv6 0303" src="assets/ljv6_0303.png"/>&#13;
<h6><span class="label">Figure 3-3. </span>Starting jshell inside IDEA</h6>&#13;
</div></figure>&#13;
&#13;
<p>Let’s go ahead and try that help command now:</p>&#13;
&#13;
<pre class="jshell" data-type="programlisting">|  Welcome to JShell -- Version 19.0.1&#13;
|  For an introduction type: /help intro&#13;
&#13;
jshell&gt; /help intro&#13;
|&#13;
|                                   intro&#13;
|                                   =====&#13;
|&#13;
|  The jshell tool allows you to execute Java code, getting immediate results.&#13;
|  You can enter a Java definition (variable, method, class, etc),&#13;
|  like:  int x = 8&#13;
|  or a Java expression, like:  x + x&#13;
|  or a Java statement or import.&#13;
|  These little chunks of Java code are called 'snippets'.&#13;
|&#13;
|  There are also the jshell tool commands that allow you to understand and&#13;
|  control what you are doing, like:  /list&#13;
|&#13;
|  For a list of commands: /help</pre>&#13;
&#13;
<p class="pagebreak-before"><em>jshell</em> is quite powerful, and we won’t be using all of its features in this book. However, we will certainly be using it to try Java code here and throughout most of the remaining chapters. Think back to our <code>HelloJava2</code> example, <a data-type="xref" href="ch02.html#learnjava6-CHP-2-SECT-3">“HelloJava2: The Sequel”</a>. You can create UI elements like that <code>JFrame</code> right in the REPL and then manipulate them—all while getting immediate feedback! No need to save, compile, run, edit, save, compile, run, etc. Let’s try:</p>&#13;
&#13;
<pre class="jshell" data-type="programlisting">jshell&gt; JFrame frame = new JFrame("HelloJava2")&#13;
|  Error:&#13;
|  cannot find symbol&#13;
|    symbol:   class JFrame&#13;
|  JFrame frame = new JFrame("HelloJava2");&#13;
|  ^----^&#13;
|  Error:&#13;
|  cannot find symbol&#13;
|    symbol:   class JFrame&#13;
|  JFrame frame = new JFrame("HelloJava2");&#13;
|                     ^----^</pre>&#13;
&#13;
<p>Oops! <em>jshell</em> is smart and feature rich, but it is also quite literal. Remember that if you want to use a class not included in the default package, you have to import it. That’s true in Java source files, and it’s true when using <em>jshell</em>. Let’s try again:</p>&#13;
&#13;
<pre class="jshell" data-type="programlisting">jshell&gt; import javax.swing.*&#13;
&#13;
jshell&gt; JFrame frame = new JFrame("HelloJava2")&#13;
frame ==&gt; javax.swing.JFrame[frame0,0,23,0x0,invalid,hidden ... led=true]</pre>&#13;
&#13;
<p>That’s better. A little strange, probably, but better. Our <code>frame</code> object has been created. That extra information after the <code>==&gt;</code> arrow is just the details about our <code>JFrame</code>, such as its size (<code>0x0</code>) and position on-screen (<code>0,23</code>). Other types of objects will show other details. Let’s give our frame some width and height like we did before and get our frame on the screen where we can see it:</p>&#13;
&#13;
<pre class="jshell" data-type="programlisting">jshell&gt; frame.setSize(300,200)&#13;
&#13;
jshell&gt; frame.setLocation(400,400)&#13;
&#13;
jshell&gt; frame.setVisible(true)</pre>&#13;
&#13;
<p>You should see a window pop up right before your very eyes! It will be resplendent in modern finery, as shown in <a data-type="xref" href="#learnjava6-CHP-3-FIG-3">Figure 3-4</a>.</p>&#13;
&#13;
<figure class="width-75"><div class="figure" id="learnjava6-CHP-3-FIG-3">&#13;
<img alt="ljv6 0304" src="assets/ljv6_0304.png"/>&#13;
<h6><span class="label">Figure 3-4. </span>Showing a <code>JFrame</code> from jshell</h6>&#13;
</div></figure>&#13;
&#13;
<p>By the way, don’t worry about making mistakes in the REPL. You’ll see an error message, but you can just correct whatever was wrong and keep going. As a quick example, imagine making a typo when trying to change the size of the frame:</p>&#13;
&#13;
<pre class="jshell" data-type="programlisting">jshell&gt; frame.setsize(300,100)&#13;
|  Error:&#13;
|  cannot find symbol&#13;
|    symbol:   method setsize(int,int)&#13;
|  frame.setsize(300,100)&#13;
|  ^-----------^</pre>&#13;
&#13;
<p>Java is case-sensitive so <code>setSize()</code> is not the same as <code>setsize()</code>. <em>jshell</em> gives you the same kind of error information that the Java compiler would but presents it inline. Correct that mistake and watch the frame get a little smaller (<a data-type="xref" href="#learnjava6-CHP-3-FIG-4">Figure 3-5</a>)!</p>&#13;
&#13;
<figure class="width-75"><div class="figure" id="learnjava6-CHP-3-FIG-4">&#13;
<img alt="ljv6 0305" src="assets/ljv6_0305.png"/>&#13;
<h6><span class="label">Figure 3-5. </span>Changing the size of our frame</h6>&#13;
</div></figure>&#13;
&#13;
<p>Amazing! Well, all right, perhaps it is less than useful, but we’re just starting. Let’s add some text using the <code>JLabel</code> class:</p>&#13;
&#13;
<pre class="jshell" data-type="programlisting">jshell&gt; JLabel label = new JLabel("Hi jshell!")&#13;
label ==&gt; javax.swing.JLabel[,0,0,0x0, ...rticalTextPosition=CENTER]&#13;
&#13;
jshell&gt; frame.add(label)&#13;
$8 ==&gt; javax.swing.JLabel[,0,0,0x0, ...text=Hi, ...]</pre>&#13;
&#13;
<p>Neat, but why didn’t our label show up in the frame? We’ll go into much more detail on this in <a data-type="xref" href="ch11.html#learnjava6-CHP-11">Chapter 11</a>, but Java allows some graphical changes to build up before realizing them on your screen. This can be an immensely efficient trick, but it can sometimes catch you off guard. Let’s force the frame to redraw itself  (<a data-type="xref" href="#learnjava6-CHP-3-FIG-5">Figure 3-6</a>):</p>&#13;
&#13;
<pre class="jshell" data-type="programlisting">jshell&gt; frame.revalidate()&#13;
&#13;
jshell&gt; frame.repaint()</pre>&#13;
&#13;
<figure class="width-75"><div class="figure" id="learnjava6-CHP-3-FIG-5">&#13;
<img alt="ljv6 0306" src="assets/ljv6_0306.png"/>&#13;
<h6><span class="label">Figure 3-6. </span>Adding a <code>JLabel</code> to our frame</h6>&#13;
</div></figure>&#13;
&#13;
<p>Now we can see our label. Some actions will automatically trigger a call to &#13;
<span class="keep-together"><code>revalidate()</code></span> or <code>repaint()</code>. Any component already added to our frame before we make it visible, for example, would appear right away when we do show the frame. Or we can remove the label similarly to how we added it. Watch again to see what happens when we change the size of the frame immediately after removing our label (<a data-type="xref" href="#learnjava6-CHP-3-FIG-6">Figure 3-7</a>):</p>&#13;
&#13;
<pre class="jshell" data-type="programlisting">jshell&gt; frame.remove(label) // as with add(), things don't change immediately&#13;
&#13;
jshell&gt; frame.setSize(400,150)</pre>&#13;
&#13;
<figure><div class="figure" id="learnjava6-CHP-3-FIG-6">&#13;
<img alt="ljv6 0307" src="assets/ljv6_0307.png"/>&#13;
<h6><span class="label">Figure 3-7. </span>Removing a label and resizing our frame</h6>&#13;
</div></figure>&#13;
&#13;
<p>See? We have a new, slimmer window and no label—all without forced repainting. We’ll do more work with UI elements in later chapters, but let’s try one more tweak to our label just to show you how easy it is to try out new ideas or methods you looked up in the documentation. We can center the label’s text, for example, resulting in something like <a data-type="xref" href="#learnjava6-CHP-3-FIG-7">Figure 3-8</a>:</p>&#13;
&#13;
<pre class="jshell" data-type="programlisting">jshell&gt; frame.add(label)&#13;
$45 ==&gt; javax.swing.JLabel[,0,0,300x278,...,text=Hi jshell!,...]&#13;
&#13;
jshell&gt; frame.revalidate()&#13;
&#13;
jshell&gt; frame.repaint()&#13;
&#13;
jshell&gt; label.setHorizontalAlignment(JLabel.CENTER)</pre>&#13;
&#13;
<figure><div class="figure" id="learnjava6-CHP-3-FIG-7">&#13;
<img alt="ljv6 0308" src="assets/ljv6_0308.png"/>&#13;
<h6><span class="label">Figure 3-8. </span>Centering the text on our label</h6>&#13;
</div></figure>&#13;
&#13;
<p>We know this was another whirlwind tour with several bits of code that might not make sense yet. Why is <code>CENTER</code> in all caps? Why is the class name <code>JLabel</code> used before our center alignment? We can’t answer every question right now, but we hope that typing along, probably making a few small mistakes, correcting them, and seeing the results make you want to know more. We want to make sure you have the tools to continue playing along as you go through the rest of this book. Like so many other skills, programming benefits from doing, in addition to reading!<a data-primary="" data-startref="ix_read_eval_repl" data-type="indexterm" id="id854"/><a data-primary="" data-startref="ix_repl_read_eval" data-type="indexterm" id="id855"/><a data-primary="" data-startref="ix_jshell_ch3" data-type="indexterm" id="id856"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="JAR Files" data-type="sect1"><div class="sect1" id="learnjava6-CHP-3-SECT-7">&#13;
<h1>JAR Files</h1>&#13;
&#13;
<p>Java <a data-primary="JAR file package" data-type="indexterm" id="ix_jar_file_pkg"/><a data-primary="classes" data-secondary="loading from archive (JAR)" data-type="indexterm" id="id857"/>ARchive (JAR) files are Java’s suitcases. They are the standard and portable way to pack up all the parts of your Java application into a compact bundle for distribution or installation. You can put whatever you want into a JAR file: Java class files, serialized objects, data files, images, audio, etc. A JAR file can also carry one or more digital signatures that attest to its integrity and authenticity, attached to the file as a whole or to individual items in the file.</p>&#13;
&#13;
<p>The <a data-primary="getResource() method" data-type="indexterm" id="id858"/>Java runtime system can load class files directly from an archive in your <code>CLASSPATH</code> environment variable, as described earlier. Nonclass files (data, images, etc.) contained in your JAR file can also be retrieved from the classpath by your &#13;
<span class="keep-together">application</span> using the <code>getResource()</code> method. Using this feature, your code doesn’t have to know whether any resource is in a plain file or a member of a JAR archive. Whether a given class or data file is an item in a JAR file or an individual file on the classpath, you can always refer to it in a standard way and let Java’s class loader resolve the location.</p>&#13;
&#13;
<p>Items <a data-primary="ZIP file compression" data-type="indexterm" id="id859"/>stored in JAR files are compressed with the standard ZIP file compression.<sup><a data-type="noteref" href="ch03.html#id860" id="id860-marker">2</a></sup> Compression makes downloading classes over a network much faster. A quick survey of the standard Java distribution shows that a typical class file shrinks by about 40% when it is compressed. Text files containing English words, such as HTML or ASCII, often compress to one-tenth their original size or less. (On the other hand, image files don’t normally get smaller when compressed, as most common image formats are themselves compression formats.)</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The jar Utility" data-type="sect2"><div class="sect2" id="learnjava6-CHP-3-SECT-7.1">&#13;
<h2>The jar Utility</h2>&#13;
&#13;
<p>The <em>jar</em> utility <a data-primary="jar command-line utility" data-type="indexterm" id="ix_jar_util"/>provided with the JDK is a simple tool for creating and reading JAR files. Its user interface isn’t particularly friendly. It mimics the Unix tape archive command, <em>tar</em>. If you’re familiar with <em>tar</em>, you’ll recognize the following incantations which all share the form laid out in <a data-type="xref" href="#learnjava6-CHP-3-FIG-jar-arguments">Figure 3-9</a>:</p>&#13;
<dl>&#13;
<dt><code>jar -cvf jarFile path [ path ] [ …​ ]</code></dt>&#13;
<dd>&#13;
<p>Create <em><code>jarFile</code></em> containing <em><code>path</code></em>(s).</p>&#13;
</dd>&#13;
<dt><code>jar -tvf jarFile [ path ] [ …​ ]</code></dt>&#13;
<dd>&#13;
<p>List the contents of <em><code>jarFile</code></em>, optionally showing just <em><code>path</code></em>(s).</p>&#13;
</dd>&#13;
<dt><code>jar -xvf jarFile [ path ] [ …​ ]</code></dt>&#13;
<dd>&#13;
<p>Extract the contents of <em><code>jarFile</code></em>, optionally extracting just <em><code>path</code></em>(s).</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<figure><div class="figure" id="learnjava6-CHP-3-FIG-jar-arguments">&#13;
<img alt="ljv6 0309" src="assets/ljv6_0309.png"/>&#13;
<h6><span class="label">Figure 3-9. </span>Important elements of the jar command-line utility</h6>&#13;
</div></figure>&#13;
&#13;
<p>In these commands, the flag letters <code>c</code>, <code>t</code>, and <code>x</code> tell <em>jar</em> whether it is creating an archive, listing an archive’s contents, or extracting files from an archive. The <code>f</code> flag means that the next argument is the name of the JAR file on which to operate.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>The optional <code>v</code> flag tells the <em>jar</em> command to be verbose when displaying information about files. In verbose mode, you get information about file sizes, modification times, and compression ratios.</p>&#13;
</div>&#13;
&#13;
<p>Subsequent items on the command line (pretty much anything aside from the letters telling <em>jar</em> what to do and the file on which <em>jar</em> should operate) are taken as names of archive items. If you’re creating an archive, the files and directories you list are placed in it. If you’re extracting, only the filenames you list are extracted from the archive. (If you don’t list any files, <em>jar</em> extracts everything in the archive.)</p>&#13;
&#13;
<p>For example, let’s say we have just completed our new game, Space Blaster. All the files associated with the game are in three directories. The Java classes themselves are in the <em>spaceblaster/game</em> directory, <em>spaceblaster/images</em> contains the game’s images, and <em>spaceblaster/docs</em> contains associated game data. We can pack all this in an archive with this command:</p>&#13;
&#13;
<pre data-type="programlisting">% jar -cvf spaceblaster.jar spaceblaster/</pre>&#13;
&#13;
<p>Because we requested verbose output, <em>jar</em> tells us what it is doing:</p>&#13;
&#13;
<pre data-type="programlisting">added manifest&#13;
adding: spaceblaster/(in = 0) (out= 0)(stored 0%)&#13;
adding: spaceblaster/docs/(in = 0) (out= 0)(stored 0%)&#13;
adding: spaceblaster/docs/help1.html(in = 502) (out= 327)(deflated 34%)&#13;
adding: spaceblaster/docs/help2.html(in = 562) (out= 360)(deflated 35%)&#13;
adding: spaceblaster/game/(in = 0) (out= 0)(stored 0%)&#13;
adding: spaceblaster/game/Game.class(in = 362) (out= 270)(deflated 25%)&#13;
adding: spaceblaster/game/Planetoid.class(in = 606) (out= 418)(deflated 31%)&#13;
adding: spaceblaster/game/SpaceShip.class(in = 1084) (out= 629)(deflated 41%)&#13;
adding: spaceblaster/images/(in = 0) (out= 0)(stored 0%)&#13;
adding: spaceblaster/images/planetoid.png(in = 3434) (out= 3439)(deflated 0%)&#13;
adding: spaceblaster/images/spaceship.png(in = 2760) (out= 2765)(deflated 0%)</pre>&#13;
&#13;
<p><em>jar</em> creates the file <em>spaceblaster.jar</em> and adds the directory <em>spaceblaster</em>, adding the directories and files within <em>spaceblaster</em> to the archive. In verbose mode, <em>jar</em> reports the savings gained by compressing the files in the archive.</p>&#13;
&#13;
<p>We can unpack the archive with this command:</p>&#13;
&#13;
<pre data-type="programlisting">% jar -xvf spaceblaster.jar</pre>&#13;
&#13;
<p>Unpacking a JAR file is just like unzipping a ZIP file. The folders get created where you issued the command, and the files are placed in the correct hierarchy. We can also extract an individual file or directory by supplying one more command-line argument:</p>&#13;
&#13;
<pre data-type="programlisting">% jar -xvf spaceblaster.jar spaceblaster/docs/help2.html</pre>&#13;
&#13;
<p>This will extract the <em>help2.html</em> file, but it will be placed in the <em>spaceblaster/docs</em> folder—both of which may be created if need be. Of course, you normally don’t have to unpack a JAR file to use its contents; Java tools know how to extract files from archives automatically. If you just want to see what is inside a JAR file, you can list the contents of our JAR with the command:</p>&#13;
&#13;
<pre data-type="programlisting">% jar -tvf spaceblaster.jar</pre>&#13;
&#13;
<p>Here’s the output. It lists all the files, their sizes, and their creation times:</p>&#13;
&#13;
<pre data-type="programlisting">     0 Tue Feb 07 18:33:20 EST 2023 META-INF/&#13;
    63 Tue Feb 07 18:33:20 EST 2023 META-INF/MANIFEST.MF&#13;
     0 Mon Feb 06 19:21:24 EST 2023 spaceblaster/&#13;
     0 Mon Feb 06 19:31:30 EST 2023 spaceblaster/docs/&#13;
   502 Mon Feb 06 19:31:30 EST 2023 spaceblaster/docs/help1.html&#13;
   562 Mon Feb 06 19:30:52 EST 2023 spaceblaster/docs/help2.html&#13;
     0 Mon Feb 06 19:41:14 EST 2023 spaceblaster/game/&#13;
   362 Mon Feb 06 19:40:22 EST 2023 spaceblaster/game/Game.class&#13;
   606 Mon Feb 06 19:40:22 EST 2023 spaceblaster/game/Planetoid.class&#13;
  1084 Mon Feb 06 19:40:22 EST 2023 spaceblaster/game/SpaceShip.class&#13;
     0 Mon Feb 06 16:30:06 EST 2023 spaceblaster/images/&#13;
  3434 Mon Feb 06 16:30:06 EST 2023 spaceblaster/images/planetoid.png&#13;
  2760 Mon Feb 06 16:27:26 EST 2023 spaceblaster/images/spaceship.png</pre>&#13;
&#13;
<p>If you leave out the verbose flag for the extraction or creation actions, you won’t see any output at all (unless something goes wrong). Leaving out the verbose flag for the table-of-contents action simply prints the path and name of each file or directory without any extra information.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="JAR manifests" data-type="sect3"><div class="sect3" id="learnjava6-CHP-3-SECT-7.1.1">&#13;
<h3>JAR manifests</h3>&#13;
&#13;
<p>Note <a data-primary="META-INF directory" data-type="indexterm" id="id861"/><a data-primary="manifest, JAR file" data-type="indexterm" id="ix_manifest_jar"/>that the <em>jar</em> command automatically adds a directory called <em>META-INF</em> to our archive. The <em>META-INF</em> directory holds files describing the contents of the JAR file. It always contains at least one file: <em>MANIFEST.MF.</em> The <em>MANIFEST.MF</em> file usually contains a “packing list” naming important files in the archive, along with a user-definable set of attributes for each entry.</p>&#13;
&#13;
<p>The <a data-primary="attributes" data-secondary="in JAR manifests" data-secondary-sortas="JAR manifests" data-type="indexterm" id="id862"/>manifest is a text file containing a set of lines in the form <code>keyword: value</code>. The manifest is, by default, mostly empty and contains only JAR file version information:</p>&#13;
&#13;
<pre data-type="programlisting">Manifest-Version: 1.0&#13;
Created-By: 1.7.0_07 (Oracle Corporation)</pre>&#13;
&#13;
<p>It is also possible to sign JAR files with a digital signature. When you do this, digest (checksum) information is added to the manifest for each archived item (as shown next), and the <em>META-INF</em> directory holds digital signature files for items in the archive:</p>&#13;
&#13;
<pre data-type="programlisting">Name: com/oreilly/Test.class&#13;
SHA1-Digest: dF2GZt8G11dXY2p4olzzIc5RjP3=&#13;
...</pre>&#13;
&#13;
<p>You can add your own information to the manifest descriptions by specifying your own supplemental, manifest file when you create the archive. This is one possible place to store other simple kinds of attribute information about the files in the archive, perhaps version or authorship information.</p>&#13;
&#13;
<p>For example, we can create a file with the following <em>keyword: value</em> lines:</p>&#13;
&#13;
<pre data-type="programlisting">Name: spaceblaster/images/planetoid.gif&#13;
RevisionNumber: 42.7&#13;
Artist-Temperament: moody</pre>&#13;
&#13;
<p>To add this information to the manifest in our archive, place it in a file called <em>myManifest.mf</em><sup><a data-type="noteref" href="ch03.html#id863" id="id863-marker">3</a></sup> in your current directory and give the following <em>jar</em> command:</p>&#13;
&#13;
<pre data-type="programlisting">% jar -cvmf myManifest.mf spaceblaster.jar spaceblaster</pre>&#13;
&#13;
<p>Notice we included an additional option in the compact list of flags, <code>m</code>, which specifies that <em>jar</em> should read additional manifest information from the file given on the command line. How does <em>jar</em> know which file is which? Because <code>m</code> is before <code>f</code>, it expects to find the manifest file name information before the name of the JAR file it will create. If you think that’s awkward, you’re right; get the names in the wrong order, and <em>jar</em> does the wrong thing. Happily, it is easy to correct: simply delete the incorrect file and create a new one with the names in the right order.</p>&#13;
&#13;
<p>If you’re curious, an <a data-primary="Manifest class" data-type="indexterm" id="id864"/>application can read its own manifest information from a JAR file using the <code>java.util.jar.Manifest</code> class. Its details are beyond the scope of what we need for this book, but feel free to check out the <code>java.util.jar</code> package in the documentation. Java applications can do quite a bit with the contents of JAR files.<a data-primary="" data-startref="ix_manifest_jar" data-type="indexterm" id="id865"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Making a JAR file runnable" data-type="sect3"><div class="sect3" id="learnjava6-CHP-3-SECT-7.1.2">&#13;
<h3>Making a JAR file runnable</h3>&#13;
&#13;
<p>Now back to our new manifest file. Aside from attributes, you can put a few special values in the manifest file. One of these, <code>Main-Class</code>, allows you to specify one class containing the primary <code>main()</code> method for an application contained in the JAR:</p>&#13;
&#13;
<pre data-type="programlisting">Main-Class: spaceblaster.game.Game</pre>&#13;
&#13;
<p><a data-type="xref" href="ch05.html#learnjava6-CHP-5">Chapter 5</a> has more information on package names. If you add this to your JAR file manifest (using the <code>m</code> option described earlier), you can run the application directly from the JAR:</p>&#13;
&#13;
<pre data-type="programlisting">% java -jar spaceblaster.jar</pre>&#13;
&#13;
<p>Sadly, most operating systems have dropped the ability to double-click a JAR application from their file browsers. Professional desktop applications written in Java these days typically have an executable wrapper (such as a <em>.bat</em> file in Windows or a <em>.sh</em> file in Linux or macOS) for better compatibility.<a data-primary="" data-startref="ix_jar_file_pkg" data-type="indexterm" id="id866"/><a data-primary="" data-startref="ix_jar_util" data-type="indexterm" id="id867"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Tool Wrap-Up" data-type="sect1"><div class="sect1" id="learnjava6-CHP-3-SECT-8">&#13;
<h1>Tool Wrap-Up</h1>&#13;
&#13;
<p>There are obviously quite a few tools in the Java ecosystem—they got the name right with the initial bundling of everything into the Java Development “Kit.” You won’t use every tool mentioned above right away, so don’t worry if the list of utilities seems a little overwhelming. We will focus on using the <em>javac</em> compiler and the <em>jshell</em> interactive utility as you wade farther into the Java waters. Our goal for this chapter is to make sure you know what tools are out there so that you can come back for details when you need them.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Review Questions" data-type="sect2"><div class="sect2" id="learnjava6-CHP-3-SECT-8.1">&#13;
<h2>Review Questions</h2>&#13;
<ol>&#13;
<li>&#13;
<p>What statement gives you access to the Swing components in you application?</p>&#13;
</li>&#13;
<li>&#13;
<p>What environment variable determines where Java will look for class files when compiling or executing?</p>&#13;
</li>&#13;
<li>&#13;
<p>What options do you use to look at the contents of a JAR file without &#13;
<span class="keep-together">unpacking it</span>?</p>&#13;
</li>&#13;
<li>&#13;
<p>What entry is required in the <em>MANIFEST.MF</em> file to make a JAR file executable?</p>&#13;
</li>&#13;
<li>&#13;
<p>What tool allows you to try out Java code in an interactive fashion?</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Code Exercises" data-type="sect2"><div class="sect2" id="learnjava6-CHP-3-SECT-8.2">&#13;
<h2>Code Exercises</h2>&#13;
&#13;
<p>Your programming challenges for this chapter don’t require any programming. Instead, we want to look at creating and executing JAR files. This exercise allows you to practice launching a Java application from a JAR file. First, locate the interactive review application, <em>lj6review.jar</em>, in the <em>quiz</em> folder wherever you installed the examples. Use the <code>-jar</code> flag with the <em>java</em> command (Java 17 or higher) to start the review app:</p>&#13;
&#13;
<pre data-type="programlisting">% cd quiz&#13;
% java -jar lj6review.jar</pre>&#13;
&#13;
<p>Once it starts, you can test your memory and your new skills by answering the review questions from all of the chapters in this book. Not all at once, of course! But you can keep coming back to the review app as you read further. The app presents the same questions found at the end of each chapter in a multiple-choice format. If you get an answer wrong, we’ve included some brief explanations that will help point you in the right direction.</p>&#13;
&#13;
<p>The source code for this small review application is included in the <em>quiz/src</em> folder if you want to take a look behind the scenes.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Advanced Code Exercises" data-type="sect2"><div class="sect2" id="learnjava6-CHP-3-SECT-8.3">&#13;
<h2>Advanced Code Exercises</h2>&#13;
&#13;
<p>For an extra challenge, create an executable JAR file. Compile <em>HelloJar.java</em> and include the resulting class files (there should be two) along with the <em>manifest.mf</em> file in your archive. Name the JAR file <em>hello.jar</em>. You do need to make one modification: you’ll have to update the <em>manifest.mf</em> file to indicate the main class. In this application, the <code>HelloJar</code> class contains the <code>main()</code> method required to launch. When this is completed, you should be able to execute the following command from a terminal window or the terminal tab in your IDE:<sup><a data-type="noteref" href="ch03.html#id868" id="id868-marker">4</a></sup></p>&#13;
&#13;
<pre data-type="programlisting">% java -jar hello.jar</pre>&#13;
&#13;
<p>A friendly graphical greeting similar to our <code>HelloComponent</code> example from <a data-type="xref" href="ch02.html#learnjava6-CHP-2-SECT-2.5">“HelloComponent”</a> should pop up on your screen. Don’t cheat! We use some of the methods mentioned in <a data-type="xref" href="#learnjava6-CHP-3-SECT-7.1.1">“JAR manifests”</a> to read the contents of the manifest file. If you simply compile and run the application without making a JAR file, your greeting will not be quite as congratulatory.</p>&#13;
&#13;
<p>Finally, look at the source code of the program if you like. It includes a few new elements of Java that we’ll be tackling in the next chapter.</p>&#13;
</div></section>&#13;
</div></section>&#13;
<div data-type="footnotes"><p data-type="footnote" id="id839"><sup><a href="ch03.html#id839-marker">1</a></sup> JAR files are mostly conventional ZIP files with that extra metadata. As such, Java also supports archives in the conventional ZIP format, but that is rarely used.</p><p data-type="footnote" id="id860"><sup><a href="ch03.html#id860-marker">2</a></sup> You can even use standard ZIP utilities to inspect or unpack JAR files.</p><p data-type="footnote" id="id863"><sup><a href="ch03.html#id863-marker">3</a></sup> The actual name is entirely up to you, but the <em>.mf</em> file extension is common.</p><p data-type="footnote" id="id868"><sup><a href="ch03.html#id868-marker">4</a></sup> If you have any trouble building this JAR file, the exercise solutions in <a data-type="xref" href="app02.html#learnjava6-APP-B">Appendix B</a> contain more detailed steps to help.</p></div></div></section></body></html>