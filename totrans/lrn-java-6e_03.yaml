- en: Chapter 3\. Tools of the Trade
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三章 工具介绍
- en: While you will almost certainly do the majority of your Java development in
    an IDE such as VS Code or IntelliJ IDEA, all of the core tools you need to build
    Java applications are included in the JDK that you downloaded in [“Installing
    the JDK”](ch02.html#learnjava6-CHP-2-SECT-1.1). When we write Java source code,
    it is the Java compiler—*javac*—that turns our source into usable bytecode. When
    we want to test that bytecode, it is the Java command itself—*java*—that we use
    to execute our programs. When we have all of our classes compiled and working
    together, it is the Java archive tool—*jar*—that allows us to bundle up those
    classes for distribution. In this chapter, we’ll discuss some of these command-line
    tools that you can use to compile, run, and package Java applications. There are
    many additional developer tools included in the JDK, such as *jshell* for interactive
    work or *javap* for decompiling class files. We won’t have time to discuss all
    of them in this book, but anywhere another tool might be useful, we’ll mention
    it. (And we will definitely be looking at *jshell*. It’s great for quickly trying
    out a new class or method.)
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您几乎可以肯定大部分 Java 开发都会在诸如 VS Code 或 IntelliJ IDEA 的 IDE 中进行，但您下载的 JDK 中包含了构建
    Java 应用程序所需的所有核心工具。当我们编写 Java 源代码时，Java 编译器—*javac*—将我们的源代码转换为可用的字节码。当我们想要测试该字节码时，Java
    命令本身—*java*—是我们用来执行程序的工具。当我们编译并使所有类一起工作时，Java 存档工具—*jar*—允许我们将这些类捆绑起来进行分发。在本章中，我们将讨论一些这些命令行工具，您可以使用它们来编译、运行和打包
    Java 应用程序。JDK 中还包含许多其他开发工具，例如用于交互式工作的 *jshell* 或用于反编译类文件的 *javap*。我们无法在本书中讨论所有这些工具，但无论何时另一个工具可能有用，我们都会提到它。（而且我们肯定会看看
    *jshell*。它非常适合快速尝试新的类或方法。）
- en: We want you to be comfortable with these command-line tools even if you don’t
    typically work in a terminal or command window. Some features of these tools aren’t
    easily accessible through IDEs. You may also encounter times where an IDE is impractical
    or downright unavailable. System administrators and DevOps engineers, for example,
    often have only limited, text-based connections to their servers running in fancy
    data centers. If you need to fix a Java problem over such a connection, these
    command-line tools will be essential.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望您能熟悉这些命令行工具，即使您通常不在终端或命令窗口中工作。这些工具的一些功能在 IDE 中不易访问。您可能还会遇到 IDE 不实用或根本无法使用的情况。例如，系统管理员和
    DevOps 工程师通常只能通过文本连接访问其在时髦数据中心运行的服务器。如果您需要通过这种连接修复 Java 问题，这些命令行工具将是必不可少的。
- en: JDK Environment
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JDK 环境
- en: 'After you install the JDK, the core *java* runtime command usually appears
    in your path (available to run) automatically, although not always. Additionally,
    many of the other commands provided with the JDK may not be available unless you
    add the Java *bin* directory to your execution path. To make sure you have access
    to all the tools, regardless of your setup, the following commands show how to
    correctly configure your development environment on Linux, macOS, and Windows.
    You define a new environment variable for Java’s location and append that *bin*
    folder to the existing path variable. (Operating systems use *environment variables*
    to store bits of information that applications can use and potentially share as
    they run.) You will, of course, have to change the paths in our examples to match
    the version of Java you have installed:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 JDK 后，*java* 运行命令通常会自动出现在您的路径中（可用于运行），尽管并非总是如此。此外，除非将 Java 的 *bin* 目录添加到执行路径中，否则
    JDK 提供的许多其他命令可能不可用。为确保无论您的设置如何都能访问所有工具，以下命令展示了如何在 Linux、macOS 和 Windows 上正确配置开发环境。您需要为
    Java 的位置定义一个新的环境变量，并将该 *bin* 文件夹追加到现有的路径变量中。（操作系统使用 *环境变量* 存储应用程序运行时可以使用和可能共享的信息碎片。）当然，您需要根据您安装的
    Java 版本更改我们示例中的路径：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: On macOS, the situation may be more confusing because recent versions of the
    operating system ship with “stubs” for the Java commands installed. Apple no longer
    provides its own implementation of Java, so if you attempt to run one of these
    commands, the OS will prompt you to download Java at that time.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在 macOS 上，情况可能更加混乱，因为操作系统的最新版本预装了 Java 命令的“存根”。苹果不再提供自己的 Java 实现，因此如果您尝试运行这些命令之一，操作系统将提示您在那时下载
    Java。
- en: 'When in doubt, your go-to test for determining if Java is installed, and which
    version of the tools you are using, is to use the `-version` flag on the *java*
    and *javac* commands:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有疑问，确定Java是否已安装以及您正在使用的工具版本的首选测试是在*java*和*javac*命令上使用`-version`标志：
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `ea` in our version output indicates this is an “early access” release.
    (Java 21 is still being tested as we write this edition.)
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们版本输出中的`ea`表示这是一个“早期访问”版本。（在我们撰写本版本时，Java 21仍在测试中。）
- en: The Java VM
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java虚拟机
- en: A Java virtual machine (VM) is software that implements the Java runtime system
    and executes Java applications. It can be a standalone application like the *java*
    command that comes with the JDK or built into a larger application like a web
    browser. Usually the interpreter itself is a native application, supplied for
    each platform, which then bootstraps other tools written in the Java language.
    Tools such as Java compilers and IDEs are often implemented directly in Java to
    maximize their portability and extensibility. Eclipse, for example, is a pure
    Java application.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Java虚拟机（VM）是实现Java运行时系统并执行Java应用程序的软件。它可以是像JDK附带的*java*命令一样的独立应用程序，也可以内置到像Web浏览器这样的较大应用程序中。通常，解释器本身是一个本地应用程序，为每个平台提供，然后启动用Java语言编写的其他工具。例如，Java编译器和IDE通常直接使用Java实现，以最大化其可移植性和可扩展性。例如，Eclipse是一个纯Java应用程序。
- en: The Java VM performs all the runtime activities of Java. It loads Java class
    files, verifies classes from untrusted sources, and executes the compiled bytecode.
    It manages memory and system resources. Good implementations also perform dynamic
    optimization, compiling Java bytecode into native machine instructions.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Java虚拟机执行Java的所有运行时活动。它加载Java类文件，验证来自不受信任来源的类，并执行编译后的字节码。它管理内存和系统资源。良好的实现还执行动态优化，将Java字节码编译成本机机器指令。
- en: Running Java Applications
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行Java应用程序
- en: 'A standalone Java application must have at least one class containing a method
    called `main()`, which is the first code to be executed upon startup. To run the
    application, start the VM, specifying that class as an argument. You can also
    specify options to the interpreter as well as arguments to be passed to the application:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 独立Java应用程序必须至少有一个包含名为`main()`的方法的类，这是启动时要执行的第一段代码。要运行应用程序，请启动VM，将该类指定为参数。您还可以指定要传递给应用程序的选项以及解释器的参数：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The class should be specified as a fully qualified class name, including the
    package name, if any. Note, however, that you don’t include the *.class* file
    extension. Here are a couple of examples that you can try from the terminal in
    the *ch03/examples* folder:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 类应指定为完全限定的类名，包括包名（如果有）。但是，请注意，不要包含*.class*文件扩展名。以下是您可以在*ch03/examples*文件夹中终端中尝试的一些示例：
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The interpreter searches for the class in the *classpath*, a list of directories
    and archive files where classes are stored. You can specify the classpath either
    by an environment variable similar to `JAVA_HOME` above, or with the command-line
    option *`-classpath`*. If both are present, Java uses the command-line option.
    We’ll discuss the classpath in detail in the next section.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 解释器在*classpath*中搜索类，*classpath*是存储类的目录和存档文件的列表。您可以通过类似于上面的`JAVA_HOME`的环境变量或使用命令行选项*`-classpath`*指定类路径。如果两者都存在，则Java使用命令行选项。我们将在下一节详细讨论类路径。
- en: 'You can also use the *java* command to launch an “executable” Java ARchive
    (JAR) file:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用*java*命令启动“可执行”Java ARchive（JAR）文件：
- en: '[PRE4]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this case, the JAR file includes metadata with the name of the startup class
    containing the `main()` method, and the classpath becomes the JAR file itself.
    We’ll look more closely at JAR files in [“JAR Files”](#learnjava6-CHP-3-SECT-7).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，JAR文件包含有启动类的元数据，该启动类包含`main()`方法的名称，并且类路径变为JAR文件本身。我们将在[“JAR文件”](#learnjava6-CHP-3-SECT-7)中更详细地讨论JAR文件。
- en: If you’re working primarily in an IDE, remember that you can still try those
    previous commands using the built-in terminal options we mentioned in [“Running
    the Project”](ch02.html#learnjava6-CHP-2-SECT-1.3).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您主要在IDE中工作，请记住，您仍然可以使用我们在[“运行项目”](ch02.html#learnjava6-CHP-2-SECT-1.3)中提到的内置终端选项尝试之前的命令。
- en: After loading the first class and executing its `main()` method, the application
    can reference other classes, start additional threads, and create its user interface
    or other structures, as shown in [Figure 3-1](#learnjava6-CHP-3-FIG-1).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 加载第一个类并执行其`main()`方法后，应用程序可以引用其他类，启动其他线程，并创建其用户界面或其他结构，如[图3-1](#learnjava6-CHP-3-FIG-1)所示。
- en: '![ljv6 0301](assets/ljv6_0301.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 0301](assets/ljv6_0301.png)'
- en: Figure 3-1\. Starting a Java application
  id: totrans-25
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-1。启动 Java 应用程序
- en: 'The `main()` method must have the right *method signature*. A method signature
    is the set of information that defines the method. It includes the method’s name,
    arguments, and return type, as well as type and visibility modifiers. The `main()`
    method must be a `public`, `static` method that takes an array of `String` objects
    as its argument and does not return any value (`void`):'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()` 方法必须具有正确的*方法签名*。方法签名是定义方法的一组信息。它包括方法的名称、参数和返回类型，以及类型和可见性修饰符。`main()`
    方法必须是一个 `public`、`static` 方法，它以 `String` 对象数组作为参数，并且不返回任何值（`void`）：'
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The fact that `main()` is a `public` and `static` method simply means that it
    is globally accessible and that it can be called directly by name. We’ll discuss
    the implications of visibility modifiers such as `public` and the meaning of `static`
    in [Chapter 4](ch04.html#learnjava6-CHP-4) and [Chapter 5](ch05.html#learnjava6-CHP-5).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()` 是一个 `public` 和 `static` 方法的事实仅意味着它是全局可访问的，并且可以直接按名称调用。我们将在[第四章](ch04.html#learnjava6-CHP-4)和[第五章](ch05.html#learnjava6-CHP-5)讨论可见性修饰符如
    `public` 的含义和 `static` 的含义。'
- en: 'The `main()` method’s single argument, the array of `String` objects, holds
    the command-line arguments passed to the application. The name of the parameter
    doesn’t matter; only the type is important. In Java, the content of `myArgs` is
    an array. (More on arrays in [Chapter 4](ch04.html#learnjava6-CHP-4).) In Java,
    arrays know how many elements they contain and can happily provide that information:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()` 方法的单个参数，`String` 对象数组，保存传递给应用程序的命令行参数。参数的名称无关紧要；只有类型是重要的。在 Java 中，`myArgs`
    的内容是一个数组。（关于数组的更多信息，请参阅[第四章](ch04.html#learnjava6-CHP-4)。）在 Java 中，数组知道它们包含多少个元素，并且可以愉快地提供该信息：'
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`myArgs[0]` is the first command-line argument, and so on.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`myArgs[0]` 是第一个命令行参数，依此类推。'
- en: The Java interpreter continues to run until the `main()` method of the initial
    class file returns and until any threads that it has started also exit. (More
    on threads in [Chapter 9](ch09.html#learnjava6-CHP-9).) Special threads designated
    as *daemon* threads are automatically terminated when the rest of the application
    has completed.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Java 解释器继续运行，直到初始类文件的 `main()` 方法返回，以及它启动的任何线程也退出。（关于线程的更多信息，请参阅[第九章](ch09.html#learnjava6-CHP-9)。）被指定为*守护*线程的特殊线程在应用程序的其余部分完成时自动终止。
- en: System Properties
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 系统属性
- en: 'Although it is possible to read host environment variables from Java, Oracle
    discourages using them for application configuration. Instead, Java allows you
    to pass any number of *system property* values to the application when the VM
    is started. System properties are simply name-value string pairs that are available
    to the application through the static `System.getProperty()` method. You can use
    these properties as a more structured and portable alternative to command-line
    arguments and environment variables for providing general configuration information
    to your application at startup. You pass each system property to the interpreter
    on the command line using the *`-D`* option followed by *`name`*`=`*`value`*.
    For example:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以从 Java 中读取主机环境变量，但 Oracle 不建议将其用于应用程序配置。相反，Java 允许您在启动 VM 时向应用程序传递任意数量的*系统属性*值。系统属性只是可通过静态
    `System.getProperty()` 方法对应用程序可用的名称-值字符串对。您可以使用这些属性作为为应用程序提供一般配置信息的更结构化和可移植的替代方案，而不是使用命令行参数和环境变量。您可以使用命令行将每个系统属性传递给解释器，使用
    `-D` 选项后跟 `name`=`value`。例如：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can then access the value of the `street` property inside your program
    this way:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以通过以下方式在程序中访问 `street` 属性的值：
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: An application can get its configuration in a myriad of other ways, of course,
    including via files or or over the network at runtime.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，应用程序可以以无数其他方式获取其配置，包括通过文件或在运行时通过网络。
- en: The Classpath
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类路径
- en: The concept of a *path* should be familiar to anyone who has worked on a DOS
    or Unix platform. It’s an environment variable that provides an application with
    a list of places to look for some resource. The most common example is a path
    for executable programs. In a Unix shell, the `PATH` environment variable is a
    colon-separated list of directories that are searched, in order, when the user
    types the name of a command. The Java `CLASSPATH` environment variable, similarly,
    is a list of locations that both the interpreter and the compiler will search
    for packages and Java classes.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*路径*的概念应该对于任何在 DOS 或 Unix 平台工作过的人都很熟悉。它是一个环境变量，为应用程序提供了一个查找资源的位置列表。最常见的例子是可执行程序的路径。在
    Unix shell 中，`PATH` 环境变量是一个由冒号分隔的目录列表，用户键入命令名称时按顺序搜索这些目录。类似地，Java 的 `CLASSPATH`
    环境变量是一个包和 Java 类搜索的位置列表。'
- en: An element of the classpath can be a directory or a JAR file. JARs are simple
    archives that include extra files (metadata) that describe each archive’s contents.
    JAR files are created with the JDK’s *jar* utility. Many tools for creating ZIP
    archives are publicly available and can be used to inspect or create JAR files
    as well.^([1](ch03.html#id839)) The archive format enables large groups of classes
    and their resources to be distributed in a single, compact file; the Java runtime
    automatically extracts individual class files from the archive, as needed. We’ll
    look more closely at JARs and the *jar* command in [“The jar Utility”](#learnjava6-CHP-3-SECT-7.1).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 类路径的一个元素可以是目录或 JAR 文件。JAR 文件是简单的归档文件，包括描述每个归档内容的额外文件（元数据）。JAR 文件是使用 JDK 的 *jar*
    实用程序创建的。许多用于创建 ZIP 归档的工具都是公开可用的，可以用来检查或创建 JAR 文件[^1]。归档格式使得大量类及其资源可以分发在一个单一的、紧凑的文件中；Java
    运行时根据需要自动从归档中提取单个类文件。我们将在 [“jar 实用程序”](#learnjava6-CHP-3-SECT-7.1) 中更详细地了解 JAR
    文件和 *jar* 命令。
- en: The precise means and format for setting the classpath vary from system to system.
    Let’s take a look at how to do it.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 设置类路径的具体方法和格式因系统而异。我们来看看如何做到这一点。
- en: CLASSPATH on Unix and macOS
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Unix 和 macOS 上的 CLASSPATH
- en: 'On a Unix system (including macOS), you set the `CLASSPATH` environment variable
    with a colon-separated list of directories and class archive files:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Unix 系统上（包括 macOS），你可以使用冒号分隔的目录和类存档文件设置 `CLASSPATH` 环境变量：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This example specifies a classpath with three locations: a directory in the
    user’s home, a JAR file in another user’s directory, and the current directory,
    which is always specified with a dot (`.`). The last component of the classpath,
    the current directory, is useful when you are tinkering with classes.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例指定了一个类路径，其中包括三个位置：用户主目录中的一个目录，另一个用户目录中的一个 JAR 文件，以及当前目录，通常用点 (`.`) 表示。类路径的最后一个组件，当前目录，在你进行类调试时非常有用。
- en: CLASSPATH on Windows
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Windows 上的 CLASSPATH
- en: 'On a Windows system, the `CLASSPATH` environment variable is set with a semicolon-separated
    list of directories and class archive files:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 系统上，`CLASSPATH` 环境变量是由分号分隔的目录和类存档文件列表：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The Java launcher and the other command-line tools know how to find the *core
    classes*, which are the classes included in every Java installation. The classes
    in the `java.lang`, `java.io`, `java.net`, and `javax.swing` packages, for example,
    are all core classes, so you do not need to include a library or directory for
    these classes in your classpath.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Java 启动器和其他命令行工具知道如何找到*核心类*，即每个 Java 安装中包含的类。例如 `java.lang`、`java.io`、`java.net`
    和 `javax.swing` 包中的类都是核心类，因此你不需要在类路径中包含这些类的库或目录。
- en: CLASSPATH Wildcards
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CLASSPATH 通配符
- en: 'The `CLASSPATH` environment variable may also include “*” wildcards that match
    all JAR files within a directory. For example:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`CLASSPATH` 环境变量也可以包括“*”通配符，匹配目录中的所有 JAR 文件。例如：'
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: To find other classes, the Java interpreter searches the elements of the classpath
    in the order they are listed. The search combines the path location and the components
    of the fully qualified class name. For example, consider a search for the class
    `animals.birds.BigBird`, as shown in [Figure 3-2](#learnjava6-CHP-3-FIG-classpath).
    Searching the classpath directory */usr/lib/java* means that the interpreter looks
    for an individual class file at */usr/lib/java/animals/birds/BigBird.class*. Searching
    a ZIP or JAR archive on the classpath, say */home/sarah/zoo.jar*, means that the
    interpreter looks for the file *animals/birds/BigBird.class* within that archive.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到其他类，Java解释器按照它们列出的顺序搜索类路径中的元素。搜索结合了路径位置和完全限定类名的组成部分。例如，考虑对`animals.birds.BigBird`类的搜索，如[图 3-2](#learnjava6-CHP-3-FIG-classpath)所示。搜索类路径目录*/usr/lib/java*意味着解释器在*/usr/lib/java/animals/birds/BigBird.class*寻找单个类文件。在类路径上搜索ZIP或JAR归档，比如*/home/sarah/zoo.jar*，意味着解释器在该归档中查找*animals/birds/BigBird.class*文件。
- en: '![ljv6 0302](assets/ljv6_0302.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 0302](assets/ljv6_0302.png)'
- en: Figure 3-2\. Finding a fully qualified name in the classpath
  id: totrans-56
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-2\. 在类路径中查找完全限定名称
- en: 'For the Java runtime, *java*, and the Java compiler, *javac*, the classpath
    can also be specified with the *`-classpath`* option. On a Linux or macOS machine,
    for example:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Java运行时的*java*和Java编译器*javac*，类路径也可以使用*`-classpath`*选项指定。例如，在Linux或macOS机器上：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: It’s essentially the same on Windows, but you have to follow the system path
    separator (a semicolon) and use drive letters to start absolute paths.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上基本相同，但您必须遵循系统路径分隔符（分号）并使用驱动器字母来启动绝对路径。
- en: If you don’t specify the `CLASSPATH` environment variable or command-line option,
    the classpath defaults to the current directory (`.`); this means that the files
    in your current directory are normally available. If you change the classpath
    and don’t include the current directory, these files will no longer be accessible.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您未指定`CLASSPATH`环境变量或命令行选项，则类路径默认为当前目录（`.`）；这意味着当前目录中的文件通常是可用的。如果更改类路径并且不包括当前目录，则这些文件将不再可访问。
- en: We suspect that many of the problems that newcomers have when first learning
    Java are classpath related. Pay particular attention to setting and checking the
    classpath when getting started. If you’re working inside an IDE, it may remove
    some or all of the burden of managing the classpath. Ultimately, however, understanding
    the classpath and knowing exactly what is in it when your application runs is
    very important to your long-term sanity.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们怀疑许多新手学习Java时遇到的问题与类路径有关。特别注意在开始时设置和检查类路径。如果您在IDE中工作，可能会减轻部分或全部管理类路径的负担。然而，理解类路径并确切知道在应用程序运行时其中包含什么，对您的长期心理健康非常重要。
- en: Modules
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块
- en: Java 9 introduced the *modules* approach to Java applications. Modules allow
    for more fine-grained, performant application deployments—even when the application
    in question is (very) large. (Modules are not required, even for large applications.
    You can continue using the classic classpath approach if it fits your needs.)
    Using modules requires extra setup so we won’t be tackling them in this book,
    but larger, commercially distributed apps may be module based. You can check out
    [*Java 9 Modularity*](https://oreil.ly/Wjs1q) by Paul Bakker and Sander Mak (O’Reilly)
    for more details and help modularizing your own large projects if you start looking
    to share your work beyond just posting source code to public repositories.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9引入了*模块*方法用于Java应用程序。模块允许更精细的、高性能的应用程序部署，即使应用程序非常大。 （对于大型应用程序，模块并不是必需的。如果符合您的需求，可以继续使用经典的类路径方法。）使用模块需要额外的设置，因此我们不会在本书中详细讨论它们，但是更大的、商业分发的应用程序可能是基于模块的。如果开始考虑将工作分享到公共存储库之外，请查看[*Java
    9模块化*](https://oreil.ly/Wjs1q)（Paul Bakker和Sander Mak著，O’Reilly）以获取更多详细信息和帮助模块化您自己的大型项目。
- en: The Java Compiler
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java编译器
- en: The *javac* command-line utility is the compiler in the JDK. The compiler is
    written entirely in Java, so it’s available for any platform that supports the
    Java runtime system. *javac* turns Java source code into a compiled class that
    contains Java bytecode. By convention, source files are named with a *.java* extension;
    the resulting class files have a *.class* extension. Each source code file is
    considered a single compilation unit. (As you’ll see in [Chapter 5](ch05.html#learnjava6-CHP-5),
    classes in a given compilation unit share certain features, such as `package`
    and `import` statements.)
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*javac* 命令行实用程序是 JDK 中的编译器。该编译器完全用 Java 编写，因此适用于支持 Java 运行时系统的任何平台。*javac*
    将 Java 源代码转换为包含 Java 字节码的编译类。按照惯例，源文件以 *.java* 扩展名命名；生成的类文件以 *.class* 扩展名结尾。每个源代码文件被视为单个编译单元。（如你将在[第5章](ch05.html#learnjava6-CHP-5)中看到，给定编译单元中的类共享某些特性，如
    `package` 和 `import` 语句。）'
- en: '*javac* allows one public class per file and insists that the file must have
    the same name as the class. If the filename and class name don’t match, *javac*
    issues a compilation error. A single file can contain multiple classes, as long
    as only one of the classes is public and is named for the file. Avoid packing
    too many classes into a single source file. Packing classes together in a *.java*
    file only superficially associates them.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*javac* 允许每个文件一个公共类，并坚持文件必须与类名相同。如果文件名和类名不匹配，*javac* 将发出编译错误。单个文件可以包含多个类，只要这些类中只有一个是公共的，并且命名与文件名相同。避免将太多类打包到单个源文件中。在
    *.java* 文件中将类打包在一起只是表面上将它们关联起来。'
- en: 'Go ahead and create a new file named *Bluebird.java* in the *ch03/examples/animals/birds*
    folder. You can use your IDE for this step, or you can just open any old text
    editor and make a new file. Once you have created the file, place the following
    source code in the file:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 继续，在 *ch03/examples/animals/birds* 文件夹中创建一个名为 *Bluebird.java* 的新文件。你可以使用你的集成开发环境（IDE）完成此步骤，或者你可以打开任何旧文本编辑器并创建一个新文件。创建文件后，将以下源代码放入文件中：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, compile it with:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用以下命令进行编译：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Our tiny file doesn’t do anything yet, but compiling it should work fine. You
    should not see any errors.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的小文件目前什么都没做，但编译应该正常工作。你不应该看到任何错误。
- en: Unlike the Java interpreter, which takes just a class name as its argument,
    *javac* needs a filename (including the *.java* extension) to process. The previous
    command produces the class file *Bluebird.class* in the same directory as the
    source file. While it’s nice to see the class file in the same directory as the
    source for this example, for most real applications, you need to store the class
    file in an appropriate place in the classpath.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 与Java解释器不同，它只需类名作为参数，*javac* 需要一个文件名（包括 *.java* 扩展名）来处理。前述命令会在与源文件相同的目录下生成类文件
    *Bluebird.class*。尽管在这个例子中看到类文件与源文件在同一目录下很好，但对于大多数真实应用程序，你需要将类文件存储在类路径中的适当位置。
- en: 'You can use the *`-d`* option with *javac* to specify an alternative directory
    for storing the class files *javac* generates. The specified directory is used
    as the root of the class hierarchy, so *.class* files are placed in this directory
    or in a subdirectory, depending on whether the class is contained in a package.
    (The compiler creates intermediate subdirectories automatically, if necessary.)
    For example, we could use the following command to create the *Bluebird.class*
    file at */home/vicky/Java/classes/animals/birds/Bluebird.class*:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 *javac* 的 *`-d`* 选项来指定用于存储 *javac* 生成的类文件的替代目录。指定的目录被用作类层次结构的根，因此 *.class*
    文件被放置在此目录或其子目录中，这取决于类是否包含在包中。（如果需要，编译器会自动创建中间子目录。）例如，我们可以使用以下命令将 *Bluebird.class*
    文件创建在 */home/vicky/Java/classes/animals/birds/Bluebird.class*：
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You can specify multiple *.java* files in a single *javac* command; the compiler
    creates a class file for each source file given. But you don’t need to list the
    other classes your class references as long as they are in the classpath in either
    source or compiled form. During compilation, Java resolves all other class references
    using the classpath.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在单个 *javac* 命令中指定多个 *.java* 文件；编译器为每个给定的源文件创建一个类文件。只要这些类在类路径中以源代码或编译形式存在，你不需要列出类引用的其他类。在编译期间，Java使用类路径解析所有其他类引用。
- en: The Java compiler is more intelligent than your average compiler. For example,
    *javac* compares the modification times of the source and class files for all
    classes and recompiles them as necessary. A compiled Java class remembers the
    source file from which it was compiled, and as long as the source file is available,
    *javac* can recompile it, if necessary. If, in the previous example, class `BigBird`
    references another class, say, `animals.furry.Grover`, *javac* looks for the source
    file *Grover.java* in an `animals.furry` package and recompiles the file, if necessary,
    to bring the *Grover.class* class file up-to-date.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Java编译器比一般的编译器更智能。例如，*javac* 比较所有类的源文件和类文件的修改时间，并根据需要重新编译它们。已编译的Java类会记住它编译自哪个源文件，只要源文件可用，*javac*
    就可以在需要时重新编译它。在前面的例子中，如果类`BigBird`引用另一个类，比如`animals.furry.Grover`，*javac* 就会在`animals.furry`包中寻找源文件*Grover.java*，如果需要的话，会重新编译该文件，以更新*Grover.class*类文件。
- en: By default, however, *javac* checks only source files that are referenced directly
    from other source files. This means that if you have an out-of-date class file
    that is referenced only by an up-to-date class file, it may not be noticed and
    recompiled. For that and many other reasons, most projects use a real build utility
    such as [Gradle](https://gradle.org) to manage builds, packaging, and more.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，*javac* 只检查直接从其他源文件引用的源文件。这意味着，如果你有一个过时的类文件，只有一个更新的类文件引用它，可能不会被注意到并重新编译。因此，大多数项目使用像[Gradle](https://gradle.org)这样的实际构建工具来管理构建、打包等等，有很多其他的理由也是如此。
- en: Finally, it’s important to note that *javac* can compile an application even
    if only the compiled (binary) versions of some of the classes are available. You
    don’t need source code for all your objects. Java class files contain all the
    data type and method signature information that source files contain, so compiling
    against binary class files is as good as compiling with Java source code. (If
    you need to make changes, of course, you still need source files.)
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，需要注意的是，*javac* 可以编译应用程序，即使只有一些类的编译（二进制）版本可用。你不需要所有对象的源代码。Java类文件包含源文件包含的所有数据类型和方法签名信息，因此针对二进制类文件进行编译和针对Java源代码进行编译一样好。（当然，如果需要进行更改，你仍然需要源文件。）
- en: Trying Java
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试Java
- en: Java 9 introduced a utility called *jshell*, which allows you to try out bits
    of Java code and see the results immediately. *jshell* is a REPL—a Read-Evaluate-Print
    Loop. Many languages have them, and prior to Java 9 there were many third-party
    variations available, but nothing was built into the JDK itself. Let’s look a
    little more carefully at its capabilities.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9 引入了一个叫做*jshell*的实用工具，允许你尝试Java代码的片段并立即看到结果。*jshell* 是一个 REPL—即读取-求值-输出循环。许多语言都有它们，在Java
    9之前有许多第三方变体可用，但没有一个内置在JDK本身。让我们更仔细地看看它的能力。
- en: You can use a terminal or command window from your operating system, or you
    can open a terminal tab in IntelliJ IDEA, as shown in [Figure 3-3](#learnjava6-CHP-3-FIG-2).
    Just type **`jshell`** at your command prompt and you’ll see a bit of version
    information along with a quick reminder about how to view help from within the
    REPL.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用操作系统中的终端或命令窗口，或者在IntelliJ IDEA中打开一个终端选项卡，如图[Figure 3-3](#learnjava6-CHP-3-FIG-2)所示。只需在命令提示符处输入**`jshell`**，你将看到一些版本信息以及如何在REPL中查看帮助的快速提醒。
- en: '![ljv6 0303](assets/ljv6_0303.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 0303](assets/ljv6_0303.png)'
- en: Figure 3-3\. Starting jshell inside IDEA
  id: totrans-83
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3-3\. 在IDEA中启动jshell
- en: 'Let’s go ahead and try that help command now:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续尝试那个帮助命令：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*jshell* is quite powerful, and we won’t be using all of its features in this
    book. However, we will certainly be using it to try Java code here and throughout
    most of the remaining chapters. Think back to our `HelloJava2` example, [“HelloJava2:
    The Sequel”](ch02.html#learnjava6-CHP-2-SECT-3). You can create UI elements like
    that `JFrame` right in the REPL and then manipulate them—all while getting immediate
    feedback! No need to save, compile, run, edit, save, compile, run, etc. Let’s
    try:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*jshell* 非常强大，虽然在本书中我们不会使用它的所有功能。但是，在剩余大部分章节中，我们肯定会用它来尝试Java代码。回想一下我们的`HelloJava2`示例，[“HelloJava2:
    The Sequel”](ch02.html#learnjava6-CHP-2-SECT-3)。你可以直接在REPL中创建像`JFrame`这样的UI元素，然后操作它们，同时得到即时反馈！无需保存、编译、运行、编辑、保存、编译、运行等等。让我们试一试：'
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Oops! *jshell* is smart and feature rich, but it is also quite literal. Remember
    that if you want to use a class not included in the default package, you have
    to import it. That’s true in Java source files, and it’s true when using *jshell*.
    Let’s try again:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 糟糕！*jshell*很聪明，功能丰富，但也非常字面。记住，如果你想使用默认包中没有包含的类，你必须导入它。这在Java源文件中是真实的，在使用*jshell*时也是如此。让我们再试一次：
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'That’s better. A little strange, probably, but better. Our `frame` object has
    been created. That extra information after the `==>` arrow is just the details
    about our `JFrame`, such as its size (`0x0`) and position on-screen (`0,23`).
    Other types of objects will show other details. Let’s give our frame some width
    and height like we did before and get our frame on the screen where we can see
    it:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 好多了。可能有点奇怪，但比以前好多了。我们的`frame`对象已经创建了。`==>`箭头后面的额外信息只是关于我们的`JFrame`的细节，比如它的大小（`0x0`）和屏幕上的位置（`0,23`）。其他类型的对象将显示其他细节。让我们像之前一样给我们的框架设置宽度和高度，并将我们的框架显示在屏幕上，以便我们可以看到它：
- en: '[PRE19]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You should see a window pop up right before your very eyes! It will be resplendent
    in modern finery, as shown in [Figure 3-4](#learnjava6-CHP-3-FIG-3).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到一个窗口在你眼前弹出！它将会展示现代的装饰，如[图 3-4](#learnjava6-CHP-3-FIG-3)所示。
- en: '![ljv6 0304](assets/ljv6_0304.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 0304](assets/ljv6_0304.png)'
- en: Figure 3-4\. Showing a `JFrame` from jshell
  id: totrans-94
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-4\. 从jshell显示`JFrame`
- en: 'By the way, don’t worry about making mistakes in the REPL. You’ll see an error
    message, but you can just correct whatever was wrong and keep going. As a quick
    example, imagine making a typo when trying to change the size of the frame:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，在REPL中不要担心犯错。你会看到一个错误消息，但你可以纠正错误并继续。举个例子，想象一下试图在改变框架大小时打字错误：
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Java is case-sensitive so `setSize()` is not the same as `setsize()`. *jshell*
    gives you the same kind of error information that the Java compiler would but
    presents it inline. Correct that mistake and watch the frame get a little smaller
    ([Figure 3-5](#learnjava6-CHP-3-FIG-4))!
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Java区分大小写，所以`setSize()`和`setsize()`不一样。*jshell*提供与Java编译器类似的错误信息，但是在线呈现。纠正这个错误，并观察框架变小一点（[图 3-5](#learnjava6-CHP-3-FIG-4))！
- en: '![ljv6 0305](assets/ljv6_0305.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 0305](assets/ljv6_0305.png)'
- en: Figure 3-5\. Changing the size of our frame
  id: totrans-99
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-5\. 改变我们的框架大小
- en: 'Amazing! Well, all right, perhaps it is less than useful, but we’re just starting.
    Let’s add some text using the `JLabel` class:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 真棒！嗯，也许这不那么有用，但我们刚刚开始。让我们使用`JLabel`类添加一些文本：
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Neat, but why didn’t our label show up in the frame? We’ll go into much more
    detail on this in [Chapter 11](ch11.html#learnjava6-CHP-11), but Java allows some
    graphical changes to build up before realizing them on your screen. This can be
    an immensely efficient trick, but it can sometimes catch you off guard. Let’s
    force the frame to redraw itself ([Figure 3-6](#learnjava6-CHP-3-FIG-5)):'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Neat, but why didn’t our label show up in the frame? We’ll go into much more
    detail on this in [第11章](ch11.html#learnjava6-CHP-11)，但在Java中，有些图形变化在显示到屏幕上之前会先积累起来。这是一个非常高效的技巧，但有时会让你措手不及。让我们强制框架重新绘制自己（[图 3-6](#learnjava6-CHP-3-FIG-5)）：
- en: '[PRE22]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '![ljv6 0306](assets/ljv6_0306.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 0306](assets/ljv6_0306.png)'
- en: Figure 3-6\. Adding a `JLabel` to our frame
  id: totrans-105
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-6\. 向我们的框架添加`JLabel`
- en: 'Now we can see our label. Some actions will automatically trigger a call to
    `revalidate()` or `repaint()`. Any component already added to our frame before
    we make it visible, for example, would appear right away when we do show the frame.
    Or we can remove the label similarly to how we added it. Watch again to see what
    happens when we change the size of the frame immediately after removing our label
    ([Figure 3-7](#learnjava6-CHP-3-FIG-6)):'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以看到我们的标签了。有些操作会自动触发对`revalidate()`或`repaint()`的调用。例如，在我们显示框架之前添加到框架的任何组件，将会在我们显示框架时立即出现。或者我们可以类似地删除标签。再次观察，看看当我们立即在删除标签后改变框架大小时会发生什么（[图 3-7](#learnjava6-CHP-3-FIG-6)）：
- en: '[PRE23]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '![ljv6 0307](assets/ljv6_0307.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 0307](assets/ljv6_0307.png)'
- en: Figure 3-7\. Removing a label and resizing our frame
  id: totrans-109
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-7\. 删除标签并调整我们的框架大小
- en: 'See? We have a new, slimmer window and no label—all without forced repainting.
    We’ll do more work with UI elements in later chapters, but let’s try one more
    tweak to our label just to show you how easy it is to try out new ideas or methods
    you looked up in the documentation. We can center the label’s text, for example,
    resulting in something like [Figure 3-8](#learnjava6-CHP-3-FIG-7):'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 看到了吗？我们有了一个新的、更苗条的窗口，没有标签——全部都没有强制重绘。我们将在后面的章节中继续处理UI元素，但让我们尝试对标签做一些微调，只是为了向你展示在文档中查找的新想法或方法有多容易。例如，我们可以使标签的文本居中，结果就像[图 3-8](#learnjava6-CHP-3-FIG-7)那样：
- en: '[PRE24]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '![ljv6 0308](assets/ljv6_0308.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 0308](assets/ljv6_0308.png)'
- en: Figure 3-8\. Centering the text on our label
  id: totrans-113
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-8\. 将文本居中显示在我们的标签上
- en: We know this was another whirlwind tour with several bits of code that might
    not make sense yet. Why is `CENTER` in all caps? Why is the class name `JLabel`
    used before our center alignment? We can’t answer every question right now, but
    we hope that typing along, probably making a few small mistakes, correcting them,
    and seeing the results make you want to know more. We want to make sure you have
    the tools to continue playing along as you go through the rest of this book. Like
    so many other skills, programming benefits from doing, in addition to reading!
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道这又是一次快速浏览，其中包含几段代码可能还不太容易理解。为什么 `CENTER` 全部大写？为什么在我们的居中对齐之前使用类名 `JLabel`？我们现在无法回答每一个问题，但我们希望您跟着输入，可能会犯一些小错误，然后纠正它们，看到结果会让您想要了解更多。我们希望确保您拥有在阅读本书的其余部分时继续参与的工具。就像许多其他技能一样，编程除了阅读之外还受益于实践！
- en: JAR Files
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JAR 文件
- en: 'Java ARchive (JAR) files are Java’s suitcases. They are the standard and portable
    way to pack up all the parts of your Java application into a compact bundle for
    distribution or installation. You can put whatever you want into a JAR file: Java
    class files, serialized objects, data files, images, audio, etc. A JAR file can
    also carry one or more digital signatures that attest to its integrity and authenticity,
    attached to the file as a whole or to individual items in the file.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Java ARchive（JAR）文件是 Java 的手提箱。它们是将 Java 应用程序的所有部分打包成一个紧凑的包用于分发或安装的标准和可移植的方式。您可以将任何东西放入
    JAR 文件中：Java 类文件、序列化对象、数据文件、图像、音频等。JAR 文件还可以携带一个或多个数字签名，以证明其完整性和真实性，附加到文件整体或文件中的单个项目上。
- en: The Java runtime system can load class files directly from an archive in your
    `CLASSPATH` environment variable, as described earlier. Nonclass files (data,
    images, etc.) contained in your JAR file can also be retrieved from the classpath
    by your application using the `getResource()` method. Using this feature, your
    code doesn’t have to know whether any resource is in a plain file or a member
    of a JAR archive. Whether a given class or data file is an item in a JAR file
    or an individual file on the classpath, you can always refer to it in a standard
    way and let Java’s class loader resolve the location.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Java 运行时系统可以直接从 `CLASSPATH` 环境变量中的归档文件加载类文件，如前所述。包含在您的 JAR 文件中的非类文件（数据、图像等）也可以通过应用程序使用
    `getResource()` 方法从类路径中检索。使用此功能，您的代码不需要知道任何资源是普通文件还是 JAR 归档的成员。无论给定的类或数据文件是 JAR
    文件中的项目还是类路径上的单个文件，您始终可以以标准方式引用它，并让 Java 的类加载器解析其位置。
- en: Items stored in JAR files are compressed with the standard ZIP file compression.^([2](ch03.html#id860))
    Compression makes downloading classes over a network much faster. A quick survey
    of the standard Java distribution shows that a typical class file shrinks by about
    40% when it is compressed. Text files containing English words, such as HTML or
    ASCII, often compress to one-tenth their original size or less. (On the other
    hand, image files don’t normally get smaller when compressed, as most common image
    formats are themselves compression formats.)
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在 JAR 文件中的项目使用标准 ZIP 文件压缩进行压缩。^([2](ch03.html#id860)) 压缩使得通过网络下载类文件变得更快。快速调查标准
    Java 发行版显示，典型的类文件在压缩时可以缩小约 40%。包含英文单词的文本文件，如 HTML 或 ASCII，通常可以压缩至原始大小的十分之一或更少。（另一方面，图像文件通常在压缩时不会变小，因为大多数常见的图像格式本身就是压缩格式。）
- en: The jar Utility
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: jar 实用程序
- en: 'The *jar* utility provided with the JDK is a simple tool for creating and reading
    JAR files. Its user interface isn’t particularly friendly. It mimics the Unix
    tape archive command, *tar*. If you’re familiar with *tar*, you’ll recognize the
    following incantations which all share the form laid out in [Figure 3-9](#learnjava6-CHP-3-FIG-jar-arguments):'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: JDK 提供的 *jar* 实用程序是用于创建和读取 JAR 文件的简单工具。其用户界面并不特别友好。它模仿 Unix 的磁带归档命令 *tar*。如果您熟悉
    *tar*，您将会认出以下命令，它们都采用了 [图 3-9](#learnjava6-CHP-3-FIG-jar-arguments) 中的格式：
- en: '`jar -cvf jarFile path [ path ] [ …​ ]`'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`jar -cvf jar文件路径 [ 路径 ] [ …​ ]`'
- en: Create *`jarFile`* containing *`path`*(s).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 创建包含 *`路径`*(们) 的 *`jar文件`*。
- en: '`jar -tvf jarFile [ path ] [ …​ ]`'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`jar -tvf jar文件 [ 路径 ] [ …​ ]`'
- en: List the contents of *`jarFile`*, optionally showing just *`path`*(s).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 列出 *`jar文件`* 的内容，可选地仅显示 *`路径`*(们)。
- en: '`jar -xvf jarFile [ path ] [ …​ ]`'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`jar -xvf jar文件 [ 路径 ] [ …​ ]`'
- en: Extract the contents of *`jarFile`*, optionally extracting just *`path`*(s).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 提取 *`jar文件`* 的内容，可选地仅提取 *`路径`*(们)。
- en: '![ljv6 0309](assets/ljv6_0309.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 0309](assets/ljv6_0309.png)'
- en: Figure 3-9\. Important elements of the jar command-line utility
  id: totrans-128
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-9\. *jar* 命令行工具的重要元素
- en: In these commands, the flag letters `c`, `t`, and `x` tell *jar* whether it
    is creating an archive, listing an archive’s contents, or extracting files from
    an archive. The `f` flag means that the next argument is the name of the JAR file
    on which to operate.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些命令中，标志字母 `c`、`t` 和 `x` 告诉 *jar* 它是在创建归档、列出归档内容还是从归档中提取文件。`f` 标志表示接下来的参数是要操作的
    JAR 文件的名称。
- en: Tip
  id: totrans-130
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: The optional `v` flag tells the *jar* command to be verbose when displaying
    information about files. In verbose mode, you get information about file sizes,
    modification times, and compression ratios.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 可选的 `v` 标志告诉 *jar* 命令在显示有关文件信息时要详细。在详细模式下，你将获得有关文件大小、修改时间和压缩比率的信息。
- en: Subsequent items on the command line (pretty much anything aside from the letters
    telling *jar* what to do and the file on which *jar* should operate) are taken
    as names of archive items. If you’re creating an archive, the files and directories
    you list are placed in it. If you’re extracting, only the filenames you list are
    extracted from the archive. (If you don’t list any files, *jar* extracts everything
    in the archive.)
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行中的后续项目（除了告诉 *jar* 要做什么以及 *jar* 应该操作的文件之外的几乎所有内容）被视为归档项目的名称。如果你正在创建一个归档，你列出的文件和目录将被放入其中。如果你正在提取，只有你列出的文件名会从归档中提取。（如果你没有列出任何文件，则
    *jar* 会提取归档中的所有内容。）
- en: 'For example, let’s say we have just completed our new game, Space Blaster.
    All the files associated with the game are in three directories. The Java classes
    themselves are in the *spaceblaster/game* directory, *spaceblaster/images* contains
    the game’s images, and *spaceblaster/docs* contains associated game data. We can
    pack all this in an archive with this command:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们刚刚完成了我们的新游戏“Space Blaster”。与游戏相关的所有文件都在三个目录中。Java 类本身位于 *spaceblaster/game*
    目录中，*spaceblaster/images* 包含游戏的图像，*spaceblaster/docs* 包含相关游戏数据。我们可以用这个命令将所有这些打包成一个归档：
- en: '[PRE25]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Because we requested verbose output, *jar* tells us what it is doing:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们请求了详细输出，*jar* 告诉我们它正在做什么：
- en: '[PRE26]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*jar* creates the file *spaceblaster.jar* and adds the directory *spaceblaster*,
    adding the directories and files within *spaceblaster* to the archive. In verbose
    mode, *jar* reports the savings gained by compressing the files in the archive.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '*jar* 创建了文件 *spaceblaster.jar* 并添加了目录 *spaceblaster*，将 *spaceblaster* 中的目录和文件添加到了归档中。在详细模式下，*jar*
    报告了通过压缩归档文件获得的节省。'
- en: 'We can unpack the archive with this command:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用这个命令解包归档：
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Unpacking a JAR file is just like unzipping a ZIP file. The folders get created
    where you issued the command, and the files are placed in the correct hierarchy.
    We can also extract an individual file or directory by supplying one more command-line
    argument:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 解压 JAR 文件就像解压 ZIP 文件一样。文件夹会在命令发出的位置创建，文件会按照正确的层次结构放置。我们还可以通过提供一个额外的命令行参数来提取单个文件或目录：
- en: '[PRE28]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This will extract the *help2.html* file, but it will be placed in the *spaceblaster/docs*
    folder—both of which may be created if need be. Of course, you normally don’t
    have to unpack a JAR file to use its contents; Java tools know how to extract
    files from archives automatically. If you just want to see what is inside a JAR
    file, you can list the contents of our JAR with the command:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这将提取 *help2.html* 文件，但它将被放置在 *spaceblaster/docs* 文件夹中——这两者如有需要将被创建。当然，通常你不必解压
    JAR 文件来使用其内容；Java 工具知道如何自动从归档中提取文件。如果你只想看看 JAR 文件里面有什么，可以用下面的命令列出我们 JAR 文件的内容：
- en: '[PRE29]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Here’s the output. It lists all the files, their sizes, and their creation
    times:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出结果。它列出了所有文件、它们的大小和创建时间：
- en: '[PRE30]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: If you leave out the verbose flag for the extraction or creation actions, you
    won’t see any output at all (unless something goes wrong). Leaving out the verbose
    flag for the table-of-contents action simply prints the path and name of each
    file or directory without any extra information.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在解压或创建操作中省略详细标志，你将看不到任何输出（除非出现问题）。对于目录内容操作，如果省略详细标志，它只会简单打印每个文件或目录的路径和名称，不提供任何额外信息。
- en: JAR manifests
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JAR 清单
- en: 'Note that the *jar* command automatically adds a directory called *META-INF*
    to our archive. The *META-INF* directory holds files describing the contents of
    the JAR file. It always contains at least one file: *MANIFEST.MF.* The *MANIFEST.MF*
    file usually contains a “packing list” naming important files in the archive,
    along with a user-definable set of attributes for each entry.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，*jar*命令会自动向我们的存档中添加一个名为*META-INF*的目录。*META-INF*目录包含描述JAR文件内容的文件。它始终至少包含一个文件：*MANIFEST.MF*。*MANIFEST.MF*文件通常包含一个“打包列表”，列出存档中的重要文件，以及每个条目的可定义属性集。
- en: 'The manifest is a text file containing a set of lines in the form `keyword:
    value`. The manifest is, by default, mostly empty and contains only JAR file version
    information:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '清单是一个包含一组以`关键字: 值`形式的行的文本文件。清单默认情况下大部分是空的，只包含JAR文件版本信息：'
- en: '[PRE31]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'It is also possible to sign JAR files with a digital signature. When you do
    this, digest (checksum) information is added to the manifest for each archived
    item (as shown next), and the *META-INF* directory holds digital signature files
    for items in the archive:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以使用数字签名对JAR文件进行签名。这样做时，为存档中的每个项目向清单添加摘要（校验和）信息（如下所示），*META-INF*目录将包含存档中项目的数字签名文件：
- en: '[PRE32]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: You can add your own information to the manifest descriptions by specifying
    your own supplemental, manifest file when you create the archive. This is one
    possible place to store other simple kinds of attribute information about the
    files in the archive, perhaps version or authorship information.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建存档时，可以通过指定自己的补充清单文件来向清单描述中添加自己的信息。这是存储关于存档文件的其他简单属性信息的一种可能的位置，例如版本或作者信息。
- en: 'For example, we can create a file with the following *keyword: value* lines:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '例如，我们可以创建一个包含以下`关键字: 值`行的文件：'
- en: '[PRE33]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To add this information to the manifest in our archive, place it in a file
    called *myManifest.mf*^([3](ch03.html#id863)) in your current directory and give
    the following *jar* command:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 要将此信息添加到我们存档中的清单中，请将其放在当前目录中名为*myManifest.mf*^([3](ch03.html#id863))的文件中，并执行以下*jar*命令：
- en: '[PRE34]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Notice we included an additional option in the compact list of flags, `m`,
    which specifies that *jar* should read additional manifest information from the
    file given on the command line. How does *jar* know which file is which? Because
    `m` is before `f`, it expects to find the manifest file name information before
    the name of the JAR file it will create. If you think that’s awkward, you’re right;
    get the names in the wrong order, and *jar* does the wrong thing. Happily, it
    is easy to correct: simply delete the incorrect file and create a new one with
    the names in the right order.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在紧凑的标志列表中，我们包含了一个额外的选项`m`，它指定*jar*应从命令行给定的文件中读取额外的清单信息。*jar*如何知道哪个文件是哪个文件？因为`m`位于`f`之前，它期望在创建的JAR文件名称之前找到清单文件名称信息。如果您认为这很笨拙，那么您是对的；如果名称顺序不对，*jar*会执行错误操作。幸运的是，更正起来很容易：只需删除不正确的文件，并使用正确顺序的名称创建一个新文件。
- en: If you’re curious, an application can read its own manifest information from
    a JAR file using the `java.util.jar.Manifest` class. Its details are beyond the
    scope of what we need for this book, but feel free to check out the `java.util.jar`
    package in the documentation. Java applications can do quite a bit with the contents
    of JAR files.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你感兴趣，应用程序可以使用`java.util.jar.Manifest`类从JAR文件中读取自己的清单信息。其详细信息超出了我们本书所需的范围，但可以自由查阅文档中的`java.util.jar`包。Java
    应用程序可以对JAR文件的内容进行相当多的操作。
- en: Making a JAR file runnable
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使JAR文件可运行
- en: 'Now back to our new manifest file. Aside from attributes, you can put a few
    special values in the manifest file. One of these, `Main-Class`, allows you to
    specify one class containing the primary `main()` method for an application contained
    in the JAR:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在回到我们的新清单文件。除了属性之外，您还可以在清单文件中放入几个特殊值。其中之一是`Main-Class`，允许您指定一个包含JAR中主`main()`方法的类：
- en: '[PRE35]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[Chapter 5](ch05.html#learnjava6-CHP-5) has more information on package names.
    If you add this to your JAR file manifest (using the `m` option described earlier),
    you can run the application directly from the JAR:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '[第五章](ch05.html#learnjava6-CHP-5)有关于包名称的更多信息。如果将此信息添加到您的JAR文件清单中（使用前面描述的`m`选项），则可以直接从JAR运行应用程序：'
- en: '[PRE36]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Sadly, most operating systems have dropped the ability to double-click a JAR
    application from their file browsers. Professional desktop applications written
    in Java these days typically have an executable wrapper (such as a *.bat* file
    in Windows or a *.sh* file in Linux or macOS) for better compatibility.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 遗憾的是，大多数操作系统已经放弃了从文件浏览器中双击 JAR 应用程序的能力。这些天，用 Java 编写的专业桌面应用程序通常具有可执行包装器（例如 Windows
    中的 *.bat* 文件或 Linux 或 macOS 中的 *.sh* 文件）以获得更好的兼容性。
- en: Tool Wrap-Up
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工具总结
- en: There are obviously quite a few tools in the Java ecosystem—they got the name
    right with the initial bundling of everything into the Java Development “Kit.”
    You won’t use every tool mentioned above right away, so don’t worry if the list
    of utilities seems a little overwhelming. We will focus on using the *javac* compiler
    and the *jshell* interactive utility as you wade farther into the Java waters.
    Our goal for this chapter is to make sure you know what tools are out there so
    that you can come back for details when you need them.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 生态系统中显然有很多工具——它们在最初将所有内容捆绑到 Java 开发“套件”中时就已经取得了正确的名称。您不会立即使用上述所有工具，因此如果工具列表看起来有点令人不知所措，请不要担心。当您需要时，我们将专注于使用
    *javac* 编译器和 *jshell* 交互式实用工具。本章的目标是确保您知道现有的工具，以便在需要时可以返回查看详细信息。
- en: Review Questions
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复习问题
- en: What statement gives you access to the Swing components in you application?
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个语句允许您访问您的应用程序中的 Swing 组件？
- en: What environment variable determines where Java will look for class files when
    compiling or executing?
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个环境变量决定 Java 编译或执行时查找类文件的位置？
- en: What options do you use to look at the contents of a JAR file without unpacking
    it?
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不解压即可查看 JAR 文件内容的选项是什么？
- en: What entry is required in the *MANIFEST.MF* file to make a JAR file executable?
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 *MANIFEST.MF* 文件中需要哪个条目才能使 JAR 文件可执行？
- en: What tool allows you to try out Java code in an interactive fashion?
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么工具允许您以交互方式尝试 Java 代码？
- en: Code Exercises
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码练习
- en: 'Your programming challenges for this chapter don’t require any programming.
    Instead, we want to look at creating and executing JAR files. This exercise allows
    you to practice launching a Java application from a JAR file. First, locate the
    interactive review application, *lj6review.jar*, in the *quiz* folder wherever
    you installed the examples. Use the `-jar` flag with the *java* command (Java
    17 or higher) to start the review app:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的编程挑战不需要任何编程。相反，我们想看看如何创建和执行 JAR 文件。此练习允许您练习从 JAR 文件启动 Java 应用程序。首先，在您安装示例的任何位置的
    *quiz* 文件夹中找到交互式复习应用程序 *lj6review.jar*。使用 *java* 命令（Java 17 或更高版本）的 `-jar` 标志启动复习应用程序：
- en: '[PRE37]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Once it starts, you can test your memory and your new skills by answering the
    review questions from all of the chapters in this book. Not all at once, of course!
    But you can keep coming back to the review app as you read further. The app presents
    the same questions found at the end of each chapter in a multiple-choice format.
    If you get an answer wrong, we’ve included some brief explanations that will help
    point you in the right direction.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦开始，您可以通过回答本书所有章节的复习问题来测试您的记忆和新技能。当然不是一次性完成！但是随着您的阅读进展，您可以继续返回复习应用程序。该应用程序以多项选择题的形式呈现每章末尾的相同问题。如果您答错了，我们还提供了一些简要的解释，这将帮助您指出正确的方向。
- en: The source code for this small review application is included in the *quiz/src*
    folder if you want to take a look behind the scenes.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想查看幕后情况，这个小型复习应用程序的源代码包含在 *quiz/src* 文件夹中。
- en: Advanced Code Exercises
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高级代码练习
- en: 'For an extra challenge, create an executable JAR file. Compile *HelloJar.java*
    and include the resulting class files (there should be two) along with the *manifest.mf*
    file in your archive. Name the JAR file *hello.jar*. You do need to make one modification:
    you’ll have to update the *manifest.mf* file to indicate the main class. In this
    application, the `HelloJar` class contains the `main()` method required to launch.
    When this is completed, you should be able to execute the following command from
    a terminal window or the terminal tab in your IDE:^([4](ch03.html#id868))'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 对于额外的挑战，创建一个可执行的 JAR 文件。编译 *HelloJar.java* 并将生成的类文件（应该有两个）与 *manifest.mf* 文件一起放入您的归档文件中。将
    JAR 文件命名为 *hello.jar*。您需要进行一些修改：您将需要更新 *manifest.mf* 文件以指示主类。在这个应用程序中，`HelloJar`
    类包含启动所需的 `main()` 方法。完成后，您应该能够从终端窗口或 IDE 中的终端选项卡执行以下命令：
- en: '[PRE38]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: A friendly graphical greeting similar to our `HelloComponent` example from [“HelloComponent”](ch02.html#learnjava6-CHP-2-SECT-2.5)
    should pop up on your screen. Don’t cheat! We use some of the methods mentioned
    in [“JAR manifests”](#learnjava6-CHP-3-SECT-7.1.1) to read the contents of the
    manifest file. If you simply compile and run the application without making a
    JAR file, your greeting will not be quite as congratulatory.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 一个友好的图形化问候，类似于我们的`HelloComponent`示例从[“HelloComponent”](ch02.html#learnjava6-CHP-2-SECT-2.5)应该会在您的屏幕上弹出。不要偷懒！我们使用了[“JAR清单”](#learnjava6-CHP-3-SECT-7.1.1)中提到的一些方法来读取清单文件的内容。如果您仅编译和运行应用程序而不创建JAR文件，您的问候将不会那么称赞。
- en: Finally, look at the source code of the program if you like. It includes a few
    new elements of Java that we’ll be tackling in the next chapter.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果您喜欢，可以查看程序的源代码。它包含了我们将在下一章中讨论的一些Java的新元素。
- en: ^([1](ch03.html#id839-marker)) JAR files are mostly conventional ZIP files with
    that extra metadata. As such, Java also supports archives in the conventional
    ZIP format, but that is rarely used.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch03.html#id839-marker)) JAR文件基本上是带有额外元数据的传统ZIP文件。因此，Java也支持传统ZIP格式的存档，但这种情况很少见。
- en: ^([2](ch03.html#id860-marker)) You can even use standard ZIP utilities to inspect
    or unpack JAR files.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch03.html#id860-marker)) 您甚至可以使用标准的ZIP实用程序来检查或解压JAR文件。
- en: ^([3](ch03.html#id863-marker)) The actual name is entirely up to you, but the
    *.mf* file extension is common.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch03.html#id863-marker)) 实际名称完全由您决定，但*.mf*文件扩展名是常见的。
- en: ^([4](ch03.html#id868-marker)) If you have any trouble building this JAR file,
    the exercise solutions in [Appendix B](app02.html#learnjava6-APP-B) contain more
    detailed steps to help.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch03.html#id868-marker)) 如果您在构建这个JAR文件时遇到任何问题，附录[B](app02.html#learnjava6-APP-B)中的练习解决方案包含更详细的步骤帮助您。
