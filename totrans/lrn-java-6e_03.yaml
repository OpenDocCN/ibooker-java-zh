- en: Chapter 3\. Tools of the Trade
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While you will almost certainly do the majority of your Java development in
    an IDE such as VS Code or IntelliJ IDEA, all of the core tools you need to build
    Java applications are included in the JDK that you downloaded in [“Installing
    the JDK”](ch02.html#learnjava6-CHP-2-SECT-1.1). When we write Java source code,
    it is the Java compiler—*javac*—that turns our source into usable bytecode. When
    we want to test that bytecode, it is the Java command itself—*java*—that we use
    to execute our programs. When we have all of our classes compiled and working
    together, it is the Java archive tool—*jar*—that allows us to bundle up those
    classes for distribution. In this chapter, we’ll discuss some of these command-line
    tools that you can use to compile, run, and package Java applications. There are
    many additional developer tools included in the JDK, such as *jshell* for interactive
    work or *javap* for decompiling class files. We won’t have time to discuss all
    of them in this book, but anywhere another tool might be useful, we’ll mention
    it. (And we will definitely be looking at *jshell*. It’s great for quickly trying
    out a new class or method.)
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: We want you to be comfortable with these command-line tools even if you don’t
    typically work in a terminal or command window. Some features of these tools aren’t
    easily accessible through IDEs. You may also encounter times where an IDE is impractical
    or downright unavailable. System administrators and DevOps engineers, for example,
    often have only limited, text-based connections to their servers running in fancy
    data centers. If you need to fix a Java problem over such a connection, these
    command-line tools will be essential.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: JDK Environment
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After you install the JDK, the core *java* runtime command usually appears
    in your path (available to run) automatically, although not always. Additionally,
    many of the other commands provided with the JDK may not be available unless you
    add the Java *bin* directory to your execution path. To make sure you have access
    to all the tools, regardless of your setup, the following commands show how to
    correctly configure your development environment on Linux, macOS, and Windows.
    You define a new environment variable for Java’s location and append that *bin*
    folder to the existing path variable. (Operating systems use *environment variables*
    to store bits of information that applications can use and potentially share as
    they run.) You will, of course, have to change the paths in our examples to match
    the version of Java you have installed:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: On macOS, the situation may be more confusing because recent versions of the
    operating system ship with “stubs” for the Java commands installed. Apple no longer
    provides its own implementation of Java, so if you attempt to run one of these
    commands, the OS will prompt you to download Java at that time.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: 'When in doubt, your go-to test for determining if Java is installed, and which
    version of the tools you are using, is to use the `-version` flag on the *java*
    and *javac* commands:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `ea` in our version output indicates this is an “early access” release.
    (Java 21 is still being tested as we write this edition.)
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: The Java VM
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Java virtual machine (VM) is software that implements the Java runtime system
    and executes Java applications. It can be a standalone application like the *java*
    command that comes with the JDK or built into a larger application like a web
    browser. Usually the interpreter itself is a native application, supplied for
    each platform, which then bootstraps other tools written in the Java language.
    Tools such as Java compilers and IDEs are often implemented directly in Java to
    maximize their portability and extensibility. Eclipse, for example, is a pure
    Java application.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: The Java VM performs all the runtime activities of Java. It loads Java class
    files, verifies classes from untrusted sources, and executes the compiled bytecode.
    It manages memory and system resources. Good implementations also perform dynamic
    optimization, compiling Java bytecode into native machine instructions.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Running Java Applications
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A standalone Java application must have at least one class containing a method
    called `main()`, which is the first code to be executed upon startup. To run the
    application, start the VM, specifying that class as an argument. You can also
    specify options to the interpreter as well as arguments to be passed to the application:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The class should be specified as a fully qualified class name, including the
    package name, if any. Note, however, that you don’t include the *.class* file
    extension. Here are a couple of examples that you can try from the terminal in
    the *ch03/examples* folder:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The interpreter searches for the class in the *classpath*, a list of directories
    and archive files where classes are stored. You can specify the classpath either
    by an environment variable similar to `JAVA_HOME` above, or with the command-line
    option *`-classpath`*. If both are present, Java uses the command-line option.
    We’ll discuss the classpath in detail in the next section.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use the *java* command to launch an “executable” Java ARchive
    (JAR) file:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this case, the JAR file includes metadata with the name of the startup class
    containing the `main()` method, and the classpath becomes the JAR file itself.
    We’ll look more closely at JAR files in [“JAR Files”](#learnjava6-CHP-3-SECT-7).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: If you’re working primarily in an IDE, remember that you can still try those
    previous commands using the built-in terminal options we mentioned in [“Running
    the Project”](ch02.html#learnjava6-CHP-2-SECT-1.3).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: After loading the first class and executing its `main()` method, the application
    can reference other classes, start additional threads, and create its user interface
    or other structures, as shown in [Figure 3-1](#learnjava6-CHP-3-FIG-1).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '![ljv6 0301](assets/ljv6_0301.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
- en: Figure 3-1\. Starting a Java application
  id: totrans-25
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The `main()` method must have the right *method signature*. A method signature
    is the set of information that defines the method. It includes the method’s name,
    arguments, and return type, as well as type and visibility modifiers. The `main()`
    method must be a `public`, `static` method that takes an array of `String` objects
    as its argument and does not return any value (`void`):'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The fact that `main()` is a `public` and `static` method simply means that it
    is globally accessible and that it can be called directly by name. We’ll discuss
    the implications of visibility modifiers such as `public` and the meaning of `static`
    in [Chapter 4](ch04.html#learnjava6-CHP-4) and [Chapter 5](ch05.html#learnjava6-CHP-5).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: 'The `main()` method’s single argument, the array of `String` objects, holds
    the command-line arguments passed to the application. The name of the parameter
    doesn’t matter; only the type is important. In Java, the content of `myArgs` is
    an array. (More on arrays in [Chapter 4](ch04.html#learnjava6-CHP-4).) In Java,
    arrays know how many elements they contain and can happily provide that information:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`myArgs[0]` is the first command-line argument, and so on.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: The Java interpreter continues to run until the `main()` method of the initial
    class file returns and until any threads that it has started also exit. (More
    on threads in [Chapter 9](ch09.html#learnjava6-CHP-9).) Special threads designated
    as *daemon* threads are automatically terminated when the rest of the application
    has completed.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: System Properties
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Although it is possible to read host environment variables from Java, Oracle
    discourages using them for application configuration. Instead, Java allows you
    to pass any number of *system property* values to the application when the VM
    is started. System properties are simply name-value string pairs that are available
    to the application through the static `System.getProperty()` method. You can use
    these properties as a more structured and portable alternative to command-line
    arguments and environment variables for providing general configuration information
    to your application at startup. You pass each system property to the interpreter
    on the command line using the *`-D`* option followed by *`name`*`=`*`value`*.
    For example:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can then access the value of the `street` property inside your program
    this way:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: An application can get its configuration in a myriad of other ways, of course,
    including via files or or over the network at runtime.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: The Classpath
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The concept of a *path* should be familiar to anyone who has worked on a DOS
    or Unix platform. It’s an environment variable that provides an application with
    a list of places to look for some resource. The most common example is a path
    for executable programs. In a Unix shell, the `PATH` environment variable is a
    colon-separated list of directories that are searched, in order, when the user
    types the name of a command. The Java `CLASSPATH` environment variable, similarly,
    is a list of locations that both the interpreter and the compiler will search
    for packages and Java classes.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: An element of the classpath can be a directory or a JAR file. JARs are simple
    archives that include extra files (metadata) that describe each archive’s contents.
    JAR files are created with the JDK’s *jar* utility. Many tools for creating ZIP
    archives are publicly available and can be used to inspect or create JAR files
    as well.^([1](ch03.html#id839)) The archive format enables large groups of classes
    and their resources to be distributed in a single, compact file; the Java runtime
    automatically extracts individual class files from the archive, as needed. We’ll
    look more closely at JARs and the *jar* command in [“The jar Utility”](#learnjava6-CHP-3-SECT-7.1).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: The precise means and format for setting the classpath vary from system to system.
    Let’s take a look at how to do it.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: CLASSPATH on Unix and macOS
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'On a Unix system (including macOS), you set the `CLASSPATH` environment variable
    with a colon-separated list of directories and class archive files:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This example specifies a classpath with three locations: a directory in the
    user’s home, a JAR file in another user’s directory, and the current directory,
    which is always specified with a dot (`.`). The last component of the classpath,
    the current directory, is useful when you are tinkering with classes.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: CLASSPATH on Windows
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'On a Windows system, the `CLASSPATH` environment variable is set with a semicolon-separated
    list of directories and class archive files:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The Java launcher and the other command-line tools know how to find the *core
    classes*, which are the classes included in every Java installation. The classes
    in the `java.lang`, `java.io`, `java.net`, and `javax.swing` packages, for example,
    are all core classes, so you do not need to include a library or directory for
    these classes in your classpath.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: CLASSPATH Wildcards
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `CLASSPATH` environment variable may also include “*” wildcards that match
    all JAR files within a directory. For example:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: To find other classes, the Java interpreter searches the elements of the classpath
    in the order they are listed. The search combines the path location and the components
    of the fully qualified class name. For example, consider a search for the class
    `animals.birds.BigBird`, as shown in [Figure 3-2](#learnjava6-CHP-3-FIG-classpath).
    Searching the classpath directory */usr/lib/java* means that the interpreter looks
    for an individual class file at */usr/lib/java/animals/birds/BigBird.class*. Searching
    a ZIP or JAR archive on the classpath, say */home/sarah/zoo.jar*, means that the
    interpreter looks for the file *animals/birds/BigBird.class* within that archive.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '![ljv6 0302](assets/ljv6_0302.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
- en: Figure 3-2\. Finding a fully qualified name in the classpath
  id: totrans-56
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'For the Java runtime, *java*, and the Java compiler, *javac*, the classpath
    can also be specified with the *`-classpath`* option. On a Linux or macOS machine,
    for example:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: It’s essentially the same on Windows, but you have to follow the system path
    separator (a semicolon) and use drive letters to start absolute paths.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t specify the `CLASSPATH` environment variable or command-line option,
    the classpath defaults to the current directory (`.`); this means that the files
    in your current directory are normally available. If you change the classpath
    and don’t include the current directory, these files will no longer be accessible.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: We suspect that many of the problems that newcomers have when first learning
    Java are classpath related. Pay particular attention to setting and checking the
    classpath when getting started. If you’re working inside an IDE, it may remove
    some or all of the burden of managing the classpath. Ultimately, however, understanding
    the classpath and knowing exactly what is in it when your application runs is
    very important to your long-term sanity.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Modules
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Java 9 introduced the *modules* approach to Java applications. Modules allow
    for more fine-grained, performant application deployments—even when the application
    in question is (very) large. (Modules are not required, even for large applications.
    You can continue using the classic classpath approach if it fits your needs.)
    Using modules requires extra setup so we won’t be tackling them in this book,
    but larger, commercially distributed apps may be module based. You can check out
    [*Java 9 Modularity*](https://oreil.ly/Wjs1q) by Paul Bakker and Sander Mak (O’Reilly)
    for more details and help modularizing your own large projects if you start looking
    to share your work beyond just posting source code to public repositories.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: The Java Compiler
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *javac* command-line utility is the compiler in the JDK. The compiler is
    written entirely in Java, so it’s available for any platform that supports the
    Java runtime system. *javac* turns Java source code into a compiled class that
    contains Java bytecode. By convention, source files are named with a *.java* extension;
    the resulting class files have a *.class* extension. Each source code file is
    considered a single compilation unit. (As you’ll see in [Chapter 5](ch05.html#learnjava6-CHP-5),
    classes in a given compilation unit share certain features, such as `package`
    and `import` statements.)
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '*javac* allows one public class per file and insists that the file must have
    the same name as the class. If the filename and class name don’t match, *javac*
    issues a compilation error. A single file can contain multiple classes, as long
    as only one of the classes is public and is named for the file. Avoid packing
    too many classes into a single source file. Packing classes together in a *.java*
    file only superficially associates them.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: 'Go ahead and create a new file named *Bluebird.java* in the *ch03/examples/animals/birds*
    folder. You can use your IDE for this step, or you can just open any old text
    editor and make a new file. Once you have created the file, place the following
    source code in the file:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, compile it with:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Our tiny file doesn’t do anything yet, but compiling it should work fine. You
    should not see any errors.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the Java interpreter, which takes just a class name as its argument,
    *javac* needs a filename (including the *.java* extension) to process. The previous
    command produces the class file *Bluebird.class* in the same directory as the
    source file. While it’s nice to see the class file in the same directory as the
    source for this example, for most real applications, you need to store the class
    file in an appropriate place in the classpath.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the *`-d`* option with *javac* to specify an alternative directory
    for storing the class files *javac* generates. The specified directory is used
    as the root of the class hierarchy, so *.class* files are placed in this directory
    or in a subdirectory, depending on whether the class is contained in a package.
    (The compiler creates intermediate subdirectories automatically, if necessary.)
    For example, we could use the following command to create the *Bluebird.class*
    file at */home/vicky/Java/classes/animals/birds/Bluebird.class*:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You can specify multiple *.java* files in a single *javac* command; the compiler
    creates a class file for each source file given. But you don’t need to list the
    other classes your class references as long as they are in the classpath in either
    source or compiled form. During compilation, Java resolves all other class references
    using the classpath.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: The Java compiler is more intelligent than your average compiler. For example,
    *javac* compares the modification times of the source and class files for all
    classes and recompiles them as necessary. A compiled Java class remembers the
    source file from which it was compiled, and as long as the source file is available,
    *javac* can recompile it, if necessary. If, in the previous example, class `BigBird`
    references another class, say, `animals.furry.Grover`, *javac* looks for the source
    file *Grover.java* in an `animals.furry` package and recompiles the file, if necessary,
    to bring the *Grover.class* class file up-to-date.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: By default, however, *javac* checks only source files that are referenced directly
    from other source files. This means that if you have an out-of-date class file
    that is referenced only by an up-to-date class file, it may not be noticed and
    recompiled. For that and many other reasons, most projects use a real build utility
    such as [Gradle](https://gradle.org) to manage builds, packaging, and more.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Finally, it’s important to note that *javac* can compile an application even
    if only the compiled (binary) versions of some of the classes are available. You
    don’t need source code for all your objects. Java class files contain all the
    data type and method signature information that source files contain, so compiling
    against binary class files is as good as compiling with Java source code. (If
    you need to make changes, of course, you still need source files.)
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: Trying Java
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java 9 introduced a utility called *jshell*, which allows you to try out bits
    of Java code and see the results immediately. *jshell* is a REPL—a Read-Evaluate-Print
    Loop. Many languages have them, and prior to Java 9 there were many third-party
    variations available, but nothing was built into the JDK itself. Let’s look a
    little more carefully at its capabilities.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: You can use a terminal or command window from your operating system, or you
    can open a terminal tab in IntelliJ IDEA, as shown in [Figure 3-3](#learnjava6-CHP-3-FIG-2).
    Just type **`jshell`** at your command prompt and you’ll see a bit of version
    information along with a quick reminder about how to view help from within the
    REPL.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '![ljv6 0303](assets/ljv6_0303.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
- en: Figure 3-3\. Starting jshell inside IDEA
  id: totrans-83
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Let’s go ahead and try that help command now:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*jshell* is quite powerful, and we won’t be using all of its features in this
    book. However, we will certainly be using it to try Java code here and throughout
    most of the remaining chapters. Think back to our `HelloJava2` example, [“HelloJava2:
    The Sequel”](ch02.html#learnjava6-CHP-2-SECT-3). You can create UI elements like
    that `JFrame` right in the REPL and then manipulate them—all while getting immediate
    feedback! No need to save, compile, run, edit, save, compile, run, etc. Let’s
    try:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Oops! *jshell* is smart and feature rich, but it is also quite literal. Remember
    that if you want to use a class not included in the default package, you have
    to import it. That’s true in Java source files, and it’s true when using *jshell*.
    Let’s try again:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'That’s better. A little strange, probably, but better. Our `frame` object has
    been created. That extra information after the `==>` arrow is just the details
    about our `JFrame`, such as its size (`0x0`) and position on-screen (`0,23`).
    Other types of objects will show other details. Let’s give our frame some width
    and height like we did before and get our frame on the screen where we can see
    it:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You should see a window pop up right before your very eyes! It will be resplendent
    in modern finery, as shown in [Figure 3-4](#learnjava6-CHP-3-FIG-3).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '![ljv6 0304](assets/ljv6_0304.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
- en: Figure 3-4\. Showing a `JFrame` from jshell
  id: totrans-94
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'By the way, don’t worry about making mistakes in the REPL. You’ll see an error
    message, but you can just correct whatever was wrong and keep going. As a quick
    example, imagine making a typo when trying to change the size of the frame:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Java is case-sensitive so `setSize()` is not the same as `setsize()`. *jshell*
    gives you the same kind of error information that the Java compiler would but
    presents it inline. Correct that mistake and watch the frame get a little smaller
    ([Figure 3-5](#learnjava6-CHP-3-FIG-4))!
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '![ljv6 0305](assets/ljv6_0305.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
- en: Figure 3-5\. Changing the size of our frame
  id: totrans-99
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Amazing! Well, all right, perhaps it is less than useful, but we’re just starting.
    Let’s add some text using the `JLabel` class:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Neat, but why didn’t our label show up in the frame? We’ll go into much more
    detail on this in [Chapter 11](ch11.html#learnjava6-CHP-11), but Java allows some
    graphical changes to build up before realizing them on your screen. This can be
    an immensely efficient trick, but it can sometimes catch you off guard. Let’s
    force the frame to redraw itself ([Figure 3-6](#learnjava6-CHP-3-FIG-5)):'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '![ljv6 0306](assets/ljv6_0306.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
- en: Figure 3-6\. Adding a `JLabel` to our frame
  id: totrans-105
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Now we can see our label. Some actions will automatically trigger a call to
    `revalidate()` or `repaint()`. Any component already added to our frame before
    we make it visible, for example, would appear right away when we do show the frame.
    Or we can remove the label similarly to how we added it. Watch again to see what
    happens when we change the size of the frame immediately after removing our label
    ([Figure 3-7](#learnjava6-CHP-3-FIG-6)):'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '![ljv6 0307](assets/ljv6_0307.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
- en: Figure 3-7\. Removing a label and resizing our frame
  id: totrans-109
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'See? We have a new, slimmer window and no label—all without forced repainting.
    We’ll do more work with UI elements in later chapters, but let’s try one more
    tweak to our label just to show you how easy it is to try out new ideas or methods
    you looked up in the documentation. We can center the label’s text, for example,
    resulting in something like [Figure 3-8](#learnjava6-CHP-3-FIG-7):'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '![ljv6 0308](assets/ljv6_0308.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
- en: Figure 3-8\. Centering the text on our label
  id: totrans-113
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We know this was another whirlwind tour with several bits of code that might
    not make sense yet. Why is `CENTER` in all caps? Why is the class name `JLabel`
    used before our center alignment? We can’t answer every question right now, but
    we hope that typing along, probably making a few small mistakes, correcting them,
    and seeing the results make you want to know more. We want to make sure you have
    the tools to continue playing along as you go through the rest of this book. Like
    so many other skills, programming benefits from doing, in addition to reading!
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: JAR Files
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Java ARchive (JAR) files are Java’s suitcases. They are the standard and portable
    way to pack up all the parts of your Java application into a compact bundle for
    distribution or installation. You can put whatever you want into a JAR file: Java
    class files, serialized objects, data files, images, audio, etc. A JAR file can
    also carry one or more digital signatures that attest to its integrity and authenticity,
    attached to the file as a whole or to individual items in the file.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: The Java runtime system can load class files directly from an archive in your
    `CLASSPATH` environment variable, as described earlier. Nonclass files (data,
    images, etc.) contained in your JAR file can also be retrieved from the classpath
    by your application using the `getResource()` method. Using this feature, your
    code doesn’t have to know whether any resource is in a plain file or a member
    of a JAR archive. Whether a given class or data file is an item in a JAR file
    or an individual file on the classpath, you can always refer to it in a standard
    way and let Java’s class loader resolve the location.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Items stored in JAR files are compressed with the standard ZIP file compression.^([2](ch03.html#id860))
    Compression makes downloading classes over a network much faster. A quick survey
    of the standard Java distribution shows that a typical class file shrinks by about
    40% when it is compressed. Text files containing English words, such as HTML or
    ASCII, often compress to one-tenth their original size or less. (On the other
    hand, image files don’t normally get smaller when compressed, as most common image
    formats are themselves compression formats.)
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: The jar Utility
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The *jar* utility provided with the JDK is a simple tool for creating and reading
    JAR files. Its user interface isn’t particularly friendly. It mimics the Unix
    tape archive command, *tar*. If you’re familiar with *tar*, you’ll recognize the
    following incantations which all share the form laid out in [Figure 3-9](#learnjava6-CHP-3-FIG-jar-arguments):'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '`jar -cvf jarFile path [ path ] [ …​ ]`'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Create *`jarFile`* containing *`path`*(s).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '`jar -tvf jarFile [ path ] [ …​ ]`'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: List the contents of *`jarFile`*, optionally showing just *`path`*(s).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '`jar -xvf jarFile [ path ] [ …​ ]`'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Extract the contents of *`jarFile`*, optionally extracting just *`path`*(s).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '![ljv6 0309](assets/ljv6_0309.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
- en: Figure 3-9\. Important elements of the jar command-line utility
  id: totrans-128
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In these commands, the flag letters `c`, `t`, and `x` tell *jar* whether it
    is creating an archive, listing an archive’s contents, or extracting files from
    an archive. The `f` flag means that the next argument is the name of the JAR file
    on which to operate.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-130
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The optional `v` flag tells the *jar* command to be verbose when displaying
    information about files. In verbose mode, you get information about file sizes,
    modification times, and compression ratios.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Subsequent items on the command line (pretty much anything aside from the letters
    telling *jar* what to do and the file on which *jar* should operate) are taken
    as names of archive items. If you’re creating an archive, the files and directories
    you list are placed in it. If you’re extracting, only the filenames you list are
    extracted from the archive. (If you don’t list any files, *jar* extracts everything
    in the archive.)
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let’s say we have just completed our new game, Space Blaster.
    All the files associated with the game are in three directories. The Java classes
    themselves are in the *spaceblaster/game* directory, *spaceblaster/images* contains
    the game’s images, and *spaceblaster/docs* contains associated game data. We can
    pack all this in an archive with this command:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Because we requested verbose output, *jar* tells us what it is doing:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*jar* creates the file *spaceblaster.jar* and adds the directory *spaceblaster*,
    adding the directories and files within *spaceblaster* to the archive. In verbose
    mode, *jar* reports the savings gained by compressing the files in the archive.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'We can unpack the archive with this command:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Unpacking a JAR file is just like unzipping a ZIP file. The folders get created
    where you issued the command, and the files are placed in the correct hierarchy.
    We can also extract an individual file or directory by supplying one more command-line
    argument:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This will extract the *help2.html* file, but it will be placed in the *spaceblaster/docs*
    folder—both of which may be created if need be. Of course, you normally don’t
    have to unpack a JAR file to use its contents; Java tools know how to extract
    files from archives automatically. If you just want to see what is inside a JAR
    file, you can list the contents of our JAR with the command:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Here’s the output. It lists all the files, their sizes, and their creation
    times:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: If you leave out the verbose flag for the extraction or creation actions, you
    won’t see any output at all (unless something goes wrong). Leaving out the verbose
    flag for the table-of-contents action simply prints the path and name of each
    file or directory without any extra information.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: JAR manifests
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note that the *jar* command automatically adds a directory called *META-INF*
    to our archive. The *META-INF* directory holds files describing the contents of
    the JAR file. It always contains at least one file: *MANIFEST.MF.* The *MANIFEST.MF*
    file usually contains a “packing list” naming important files in the archive,
    along with a user-definable set of attributes for each entry.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: 'The manifest is a text file containing a set of lines in the form `keyword:
    value`. The manifest is, by default, mostly empty and contains only JAR file version
    information:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'It is also possible to sign JAR files with a digital signature. When you do
    this, digest (checksum) information is added to the manifest for each archived
    item (as shown next), and the *META-INF* directory holds digital signature files
    for items in the archive:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: You can add your own information to the manifest descriptions by specifying
    your own supplemental, manifest file when you create the archive. This is one
    possible place to store other simple kinds of attribute information about the
    files in the archive, perhaps version or authorship information.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can create a file with the following *keyword: value* lines:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To add this information to the manifest in our archive, place it in a file
    called *myManifest.mf*^([3](ch03.html#id863)) in your current directory and give
    the following *jar* command:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Notice we included an additional option in the compact list of flags, `m`,
    which specifies that *jar* should read additional manifest information from the
    file given on the command line. How does *jar* know which file is which? Because
    `m` is before `f`, it expects to find the manifest file name information before
    the name of the JAR file it will create. If you think that’s awkward, you’re right;
    get the names in the wrong order, and *jar* does the wrong thing. Happily, it
    is easy to correct: simply delete the incorrect file and create a new one with
    the names in the right order.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: If you’re curious, an application can read its own manifest information from
    a JAR file using the `java.util.jar.Manifest` class. Its details are beyond the
    scope of what we need for this book, but feel free to check out the `java.util.jar`
    package in the documentation. Java applications can do quite a bit with the contents
    of JAR files.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Making a JAR file runnable
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now back to our new manifest file. Aside from attributes, you can put a few
    special values in the manifest file. One of these, `Main-Class`, allows you to
    specify one class containing the primary `main()` method for an application contained
    in the JAR:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[Chapter 5](ch05.html#learnjava6-CHP-5) has more information on package names.
    If you add this to your JAR file manifest (using the `m` option described earlier),
    you can run the application directly from the JAR:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Sadly, most operating systems have dropped the ability to double-click a JAR
    application from their file browsers. Professional desktop applications written
    in Java these days typically have an executable wrapper (such as a *.bat* file
    in Windows or a *.sh* file in Linux or macOS) for better compatibility.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Tool Wrap-Up
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are obviously quite a few tools in the Java ecosystem—they got the name
    right with the initial bundling of everything into the Java Development “Kit.”
    You won’t use every tool mentioned above right away, so don’t worry if the list
    of utilities seems a little overwhelming. We will focus on using the *javac* compiler
    and the *jshell* interactive utility as you wade farther into the Java waters.
    Our goal for this chapter is to make sure you know what tools are out there so
    that you can come back for details when you need them.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Review Questions
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What statement gives you access to the Swing components in you application?
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What environment variable determines where Java will look for class files when
    compiling or executing?
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What options do you use to look at the contents of a JAR file without unpacking
    it?
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What entry is required in the *MANIFEST.MF* file to make a JAR file executable?
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What tool allows you to try out Java code in an interactive fashion?
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Code Exercises
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Your programming challenges for this chapter don’t require any programming.
    Instead, we want to look at creating and executing JAR files. This exercise allows
    you to practice launching a Java application from a JAR file. First, locate the
    interactive review application, *lj6review.jar*, in the *quiz* folder wherever
    you installed the examples. Use the `-jar` flag with the *java* command (Java
    17 or higher) to start the review app:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Once it starts, you can test your memory and your new skills by answering the
    review questions from all of the chapters in this book. Not all at once, of course!
    But you can keep coming back to the review app as you read further. The app presents
    the same questions found at the end of each chapter in a multiple-choice format.
    If you get an answer wrong, we’ve included some brief explanations that will help
    point you in the right direction.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: The source code for this small review application is included in the *quiz/src*
    folder if you want to take a look behind the scenes.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Advanced Code Exercises
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For an extra challenge, create an executable JAR file. Compile *HelloJar.java*
    and include the resulting class files (there should be two) along with the *manifest.mf*
    file in your archive. Name the JAR file *hello.jar*. You do need to make one modification:
    you’ll have to update the *manifest.mf* file to indicate the main class. In this
    application, the `HelloJar` class contains the `main()` method required to launch.
    When this is completed, you should be able to execute the following command from
    a terminal window or the terminal tab in your IDE:^([4](ch03.html#id868))'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: A friendly graphical greeting similar to our `HelloComponent` example from [“HelloComponent”](ch02.html#learnjava6-CHP-2-SECT-2.5)
    should pop up on your screen. Don’t cheat! We use some of the methods mentioned
    in [“JAR manifests”](#learnjava6-CHP-3-SECT-7.1.1) to read the contents of the
    manifest file. If you simply compile and run the application without making a
    JAR file, your greeting will not be quite as congratulatory.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 一个友好的图形化问候，类似于我们的`HelloComponent`示例从[“HelloComponent”](ch02.html#learnjava6-CHP-2-SECT-2.5)应该会在您的屏幕上弹出。不要偷懒！我们使用了[“JAR清单”](#learnjava6-CHP-3-SECT-7.1.1)中提到的一些方法来读取清单文件的内容。如果您仅编译和运行应用程序而不创建JAR文件，您的问候将不会那么称赞。
- en: Finally, look at the source code of the program if you like. It includes a few
    new elements of Java that we’ll be tackling in the next chapter.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果您喜欢，可以查看程序的源代码。它包含了我们将在下一章中讨论的一些Java的新元素。
- en: ^([1](ch03.html#id839-marker)) JAR files are mostly conventional ZIP files with
    that extra metadata. As such, Java also supports archives in the conventional
    ZIP format, but that is rarely used.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch03.html#id839-marker)) JAR文件基本上是带有额外元数据的传统ZIP文件。因此，Java也支持传统ZIP格式的存档，但这种情况很少见。
- en: ^([2](ch03.html#id860-marker)) You can even use standard ZIP utilities to inspect
    or unpack JAR files.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch03.html#id860-marker)) 您甚至可以使用标准的ZIP实用程序来检查或解压JAR文件。
- en: ^([3](ch03.html#id863-marker)) The actual name is entirely up to you, but the
    *.mf* file extension is common.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch03.html#id863-marker)) 实际名称完全由您决定，但*.mf*文件扩展名是常见的。
- en: ^([4](ch03.html#id868-marker)) If you have any trouble building this JAR file,
    the exercise solutions in [Appendix B](app02.html#learnjava6-APP-B) contain more
    detailed steps to help.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch03.html#id868-marker)) 如果您在构建这个JAR文件时遇到任何问题，附录[B](app02.html#learnjava6-APP-B)中的练习解决方案包含更详细的步骤帮助您。
