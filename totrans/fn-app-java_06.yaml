- en: Chapter 4\. Immutability
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章 不可变性
- en: Dealing with data structures — constructs dedicated to storing and organizing
    data values — is a core task of almost any program. In OOP, this usually means
    dealing with a *mutable* program state, often encapsulated in objects. For a functional
    approach, however, *immutability* is the preferred way of handling data and a
    prerequisite for many of its concepts.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 处理数据结构 — 专门用于存储和组织数据值的结构 — 是几乎所有程序的核心任务。在面向对象编程中，这通常意味着处理*可变*的程序状态，通常封装在对象中。然而，在函数式方法中，*不可变性*是处理数据的首选方式，也是许多概念的先决条件。
- en: In functional programming languages like Haskell or even multi-paradigm but
    more functionally inclined ones like Scala, immutability is treated as a prevalent
    feature. In those languages, immutability is a necessity and often strictly enforced,
    not just an afterthought to their design. Like most other principles introduced
    in this book, immutability isn’t restricted to functional programming and provides
    many benefits, regardless of your chosen paradigm.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在像 Haskell 这样的函数式编程语言，甚至是像 Scala 这样的多范式但更倾向于函数式编程的语言中，不可变性被视为一种突出的特性。在这些语言中，不可变性是必要的，并且通常严格执行，而不仅仅是设计时的附加思考。与本书介绍的大多数其他原则一样，不可变性并不限于函数式编程，并且无论你选择的范式如何，都提供许多好处。
- en: In this chapter, you will learn about immutable types already available in the
    JDK and how to make your data structures immutable to avoid side effects, either
    with the tools provided by the JDK or with the help of third-party libraries.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习 JDK 中已经可用的不可变类型，以及如何通过 JDK 提供的工具或第三方库使您的数据结构不可变，以避免副作用。
- en: Note
  id: totrans-4
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The term “data structure” used in this chapter represents any construct that
    stores and organizes data, like collections, or custom objects.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的术语“数据结构”代表任何存储和组织数据的构造，例如集合或自定义对象。
- en: Mutability and Data Structures in OOP
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向对象编程中的可变性和数据结构
- en: As an object-oriented inclined language, typical Java code encapsulates an object’s
    state in a mutable form. Its state is usually mutable by using “setter” methods.
    This approach makes the program state *ephemeral*, meaning any change to an existing
    data structure updates its current state in-place, which also affects anyone else
    who references it, and the previous state is lost.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个面向对象的倾向语言，典型的 Java 代码以可变形式封装对象的状态。通常使用“setter”方法使其状态可变。这种方法使得程序状态*短暂*，意味着对现有数据结构的任何更改都会原地更新其当前状态，这也会影响任何引用它的人，并且丢失了先前的状态。
- en: 'Let’s take a look at the most common forms used to handle mutable state in
    OOP Java code: *JavaBeans* and *Plain Old Java Objects (POJO)*. A lot of confusion
    exists about those two data structures and their distinct properties. In a sense,
    they are both ordinary Java objects supposed to create reusability between components
    by encapsulating all relevant states. They have similar goals, although their
    design philosophy and rules differ.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下在面向对象的 Java 代码中处理可变状态最常见的形式：*JavaBeans* 和 *Plain Old Java Objects (POJO)*。关于这两种数据结构及其各自特性存在许多混淆。在某种意义上，它们都是普通的
    Java 对象，旨在通过封装所有相关状态来创建组件之间的可重用性。它们有着相似的目标，尽管它们的设计哲学和规则有所不同。
- en: POJOs don’t have any restrictions regarding their design. They are supposed
    to “just” encapsulate the business logic state, and you can even design them to
    be immutable. How you implement them is up to you and what matches your environment
    best. They usually provide “getters” and “setters” for their fields to be more
    flexible in an object-oriented context with a mutable state.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: POJOs 对其设计没有任何限制。它们被认为“只是”封装业务逻辑状态，并且您甚至可以设计它们为不可变的。您如何实现它们取决于您和什么最适合您的环境。它们通常为其字段提供“getter”和“setter”，以在面向对象的上下文中更灵活地处理可变状态。
- en: JavaBeans, on the other hand, are a special kind of POJO that allows easier
    introspection and reusability, which requires them to oblige certain rules. These
    rules are necessary because JavaBeans were initially designed to be a standardized
    shareable machine-readable state between components, like a UI widget in your
    IDE^([1](ch04.xhtml#idm45115247823168)). The differences between POJOs and JavaBeans
    are listed in [Table 4-1](#_02-data-structures_pojo-vs-bean).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，JavaBeans 是 POJO 的一种特殊类型，允许更容易地内省和重用，这要求它们遵守某些规则。这些规则是必要的，因为 JavaBeans
    最初被设计为在组件之间共享标准化的可共享的机器可读状态，例如您 IDE 中的 UI 组件^([1](ch04.xhtml#idm45115247823168))。POJOs
    和 JavaBeans 之间的区别列在 [表 4-1](#_02-data-structures_pojo-vs-bean) 中。
- en: Table 4-1\. POJOs versus JavaBeans
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4-1\. POJO vs JavaBeans
- en: '|  | POJO | JavaBean |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '|  | POJO | JavaBean |'
- en: '| --- | --- | --- |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| General Restrictions | Only those imposed by the Java language itself | Imposed
    by JavaBean API specification |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| 一般限制 | 仅限于Java语言本身强加的限制 | 受JavaBean API规范强加的限制 |'
- en: '| Serialization | Optional | Must implement `java.io.Serializable` |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| 序列化 | 可选 | 必须实现`java.io.Serializable` |'
- en: '| Field Visibility | No restrictions | `private` only |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 字段可见性 | 无限制 | 仅限`private` |'
- en: '| Field Access | No restrictions | Only accessible via getters and setters
    |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| 字段访问 | 无限制 | 只能通过getter和setter访问 |'
- en: '| Constructors | No restrictions | No-arg constructor must exist. |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 构造函数 | 无限制 | 必须存在无参构造函数。 |'
- en: Many of the available data structures in the JDK, like the *collections framework*⁠^([2](ch04.xhtml#idm45115247804480))
    are mostly built around the concept of mutable state and in-place changes. Take
    `List<E>` for an example. Its mutating methods, like `add(E value)` or `remove(E
    value)`, only return a `boolean` to indicate that a change occurred, and change
    the collection in place, so the previous state is lost. You might not need to
    think much about it in a local context, but as soon as a data structure leaves
    your direct sphere of influence, it’s no longer guaranteed to remain in its current
    state as long as you hold a reference to it.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: JDK中许多可用的数据结构，如*集合框架*⁠^([2](ch04.xhtml#idm45115247804480))，大多围绕可变状态和原地修改的概念构建。以`List<E>`为例。它的变异方法，如`add(E
    value)`或`remove(E value)`，只返回一个`boolean`以指示发生了变化，并在原地修改集合，因此前一个状态丢失。在局部环境中，您可能不需要过多考虑，但一旦数据结构超出您的直接影响范围，就无法保证它将保持当前状态，只要您持有对它的引用。
- en: Mutable state breeds complexity and uncertainty. You must include all possible
    state changes in your mental model at any time to understand and reason with your
    code. This isn’t restricted to a single component, though. Sharing mutable state
    increases the complexity to cover the lifetime of any components having access
    to such shared state. Especially concurrent programming suffers under the complexities
    of shared state, where many problems originate in mutability and require intricate
    and often misused solutions like access synchronization and atomic references.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 可变状态孕育了复杂性和不确定性。您必须随时将所有可能的状态变化包含在您的思维模型中，以理解和推理您的代码。然而，这不仅限于单个组件。共享可变状态增加了覆盖任何访问此类共享状态的组件的生命周期的复杂性。特别是在并发编程中，共享状态的复杂性导致许多问题，这些问题源于可变性，并且需要复杂且常常被误用的解决方案，如访问同步和原子引用。
- en: Ensuring the correctness of your code and shared state becomes a Sisyphean task
    of endless unit tests and state validation. And the required additional work multiplies
    as soon as mutable state interacts with more mutable components, resulting in
    even more verification of their behavior.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您的代码和共享状态的正确性成为一个无休止的任务，需要无数的单元测试和状态验证。当可变状态与更多可变组件交互时，所需的额外工作随之增加，进而需要对其行为进行更多的验证。
- en: That’s where immutability provides another approach to handling data structures
    and restoring reasonability.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是不可变性提供另一种处理数据结构和恢复合理性的方法。
- en: Immutability (not only) in FP
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不可变性（不仅限于）在FP中
- en: 'The core idea of immutability is simple: data structures can no longer change
    after their creation. Many functional programming languages support it by design
    at their core. The concept isn’t bound to functional programming per se, and it
    has many advantages in any paradigm.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变性的核心思想很简单：数据结构在创建后不能再更改。许多函数式编程语言在其核心设计中支持此概念。该概念并不仅限于函数式编程范式，并且在任何范式中都具有许多优势。
- en: Note
  id: totrans-25
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Immutability provides elegant solutions to many problems, even outside of programming
    languages. For example, the distributed version control system *Git* essentially
    uses a tree of pointers to immutable blobs and diffs to provide a robust representation
    of historical changes.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变性为许多问题提供了优雅的解决方案，即使在编程语言之外也是如此。例如，分布式版本控制系统*Git*基本上使用不可变blob和diff的指针树来提供历史变更的强大表示。
- en: Immutable data structures are *persistent* views of their data without a direct
    option to change it. To “mutate” such a data structure, you must create a new
    copy with the intended changes. Not being able to mutate data “in place” can feel
    weird in Java at first. Compared to the usually mutable nature of object-oriented
    code, why should you take the extra steps necessary to simply change a value?
    Such creation of new instances by copying data incurs a particular overhead that
    accumulates quickly for naive implementations of immutability.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变数据结构是它们的数据的*持久*视图，没有直接选项来更改它。要“改变”这样的数据结构，你必须创建一个带有预期更改的新副本。在 Java 中无法“原地”改变数据可能一开始会感觉奇怪。与面向对象代码通常的可变性相比，为什么你应该采取额外的步骤来简单地改变一个值呢？通过复制数据创建新实例会导致特定的开销，这对不可变性的简单实现来说很快就会累积起来。
- en: 'Despite the overhead and initial weirdness of not being able to change data
    in place, the benefits of immutability can make it worthwhile even without a more
    functional approach to Java:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管不能在原地更改数据会带来一些开销和初始的不适，但不可变性的好处即使在没有更多对 Java 的函数式方法的支持的情况下也是值得的：
- en: Predictability
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 可预测性
- en: Data structures won’t change without you noticing because they simply can’t.
    As long as you reference a data structure, you know it is the same as at the time
    of its creation. Even if you share that reference or use it in a concurrent fashion,
    no one can change your copy of it.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 数据结构不会在你不知情的情况下改变，因为它们根本无法改变。只要你引用一个数据结构，你就知道它与创建时是相同的。即使你分享了那个引用或以并发方式使用它，也没有人可以改变你的副本。
- en: Validity
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 有效性
- en: After initialization, a data structure is *complete*. It only needs to be verified
    once and stays valid (or invalid) indefinitely. If you need to build a data structure
    in multiple steps, the *builder-pattern*, shown later in [“Step-by-Step Creation”](ch05.xhtml#_01-immutables_step-by-step),
    decouples the building and initialization of a data structure.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化后，数据结构就*完整*了。它只需要被验证一次，并且在此后保持有效（或无效）。如果你需要在多个步骤中构建一个数据结构，那么稍后在[“逐步创建”](ch05.xhtml#_01-immutables_step-by-step)中显示的*构建器模式*将分离数据结构的构建和初始化。
- en: No hidden side effects
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 没有隐藏的副作用
- en: Dealing with side effects is a really tough problem in programming — besides
    naming and cache invalidation^([3](ch04.xhtml#idm45115247787824)). A byproduct
    of immutable data structures is the elimination of side effects; they’re always
    *as-is*. Even if moved around a lot through different parts of your code or using
    it in a third-party library out of your control, they won’t change their values
    or surprise you with an unintended side effect.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 处理副作用是编程中的一个非常棘手的问题 — 除了命名和缓存失效^([3](ch04.xhtml#idm45115247787824))。不可变数据结构的一个副产品是副作用的消除；它们总是*保持不变*。即使通过代码的不同部分频繁移动或在你无法控制的第三方库中使用它，它们也不会改变其值或用意外副作用来使你感到惊讶。
- en: Thread-safety
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 线程安全
- en: Without side effects, immutable data structures can move freely between thread
    boundaries. No thread can change them, so reasoning about your program becomes
    more straightforward due to no more unexpected changes or race conditions.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 没有副作用，不可变数据结构可以在线程边界之间自由移动。没有线程可以改变它们，因此由于没有意外更改或竞态条件，对程序的推理变得更加直观。
- en: Cacheability and optimization
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 可缓存性和优化
- en: Because they are *as-is* right after creation, you can cache immutable data
    structures with ease of mind. Optimization techniques, like memoization, are only
    possible with immutable data structures, as discussed in [Chapter 2](ch02.xhtml#_01-functional-java).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 因为它们在创建后就*保持不变*，所以你可以放心地缓存不可变数据结构。像记忆化这样的优化技术只有在不可变数据结构中才可能实现，正如[第2章](ch02.xhtml#_01-functional-java)所讨论的那样。
- en: Change tracking
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 变更跟踪
- en: If every change results in a whole new data structure, you can track their history
    by storing the previous references. You no longer need to intricately track single
    property changes to support an *undo* feature. Restoring a previous state is as
    simple as using a prior reference to the data structure.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果每次更改都会导致一个全新的数据结构，那么你可以通过存储先前的引用来跟踪它们的历史。你不再需要精心跟踪单个属性的变化以支持“撤销”功能。恢复先前的状态就像使用对数据结构的先前引用一样简单。
- en: Remember, all these benefits are independent of the chosen programming paradigm.
    Even if you decide that a functional approach might not be the right solution
    for your codebase, your data handling can still benefit immensely from immutability.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，所有这些优点都与所选择的编程范式无关。即使你认为函数式方法可能不适合你的代码库，你的数据处理仍然可以从不可变性中获益良多。
- en: The State of Java Immutability
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java 不可变性的现状
- en: 'Java’s initial design didn’t include immutability as a deeply integrated language
    feature or a variety of immutable data structures. Certain aspects of the language
    and its types were always immutable, but it was nowhere close to the level of
    support in other more functional languages. This all changed when Java 14 was
    released and introduced *Records*, a built-in language-level immutable data structure:
    *Records*.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Java最初的设计并没有将不可变性作为深度集成的语言特性或多种不可变数据结构。语言和其类型的某些方面始终是不可变的，但这与其他更功能丰富的语言中的支持水平相去甚远。一切都在Java
    14发布并引入*Records*后改变了，这是一种内置的语言级不可变数据结构：*Records*。
- en: Even if you might not know it yet, you’re already using immutable types in all
    your Java programs. The reasons behind their immutability might differ, like runtime
    optimizations or ensuring their correct usage, but regardless of their intentions,
    they’ll make your code safer and less error-prone.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你可能还不知道，你在所有的Java程序中都已经在使用不可变类型。它们之所以不可变的原因可能不同，比如运行时优化或确保其正确使用，但不管其意图如何，它们都会使你的代码更安全，减少错误。
- en: Let’s take a look at all the different immutable parts available in the JDK
    today.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当今JDK中提供的所有不可变部分。
- en: java.lang.String
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: java.lang.String
- en: One of the first types every Java developer learns about is the `String` type.
    Strings are everywhere! That’s why it needs to be a highly optimized and safe
    type. One of these optimizations is that it’s immutable.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Java开发者都会学习的第一种类型之一是`String`类型。字符串无处不在！这就是为什么它需要是一个高度优化和安全的类型。其中一个优化是它是不可变的。
- en: '`String` is not a primitive value-based type, like `int` or `char`. Still,
    it supports the + (plus) operator to concatenate a `String` with another value:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`String`并不是一个像`int`或`char`这样的基本值类型，但它支持使用+（加号）操作符将`String`与另一个值连接起来：'
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Like any other expression, concatenating strings creates a result, and in this
    case, a new object. That’s why Java developers are taught early not to overuse
    manual `String` concatenation. Each time you concatenate strings by using the
    + (plus) operator, a new `String` instance is created on the heap, occupying memory,
    as depicted in [Figure 4-1](#_02-data-structures_string-allocation). These newly
    created instances can add up quickly, especially if concatenation is done in a
    loop statement like `for` or `while`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 像任何其他表达式一样，连接字符串会产生一个结果，在这种情况下是一个新对象。这就是为什么Java开发者早就被教导不要过度使用手动的`String`连接。每次通过使用+（加号）操作符连接字符串时，都会在堆上创建一个新的`String`实例，占用内存，正如[图 4-1](#_02-data-structures_string-allocation)所示。这些新创建的实例可能会快速累积，特别是如果连接操作在像`for`或`while`这样的循环语句中执行时。
- en: '![String memory allocation](assets/afaj_0401.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![字符串内存分配](assets/afaj_0401.png)'
- en: Figure 4-1\. String memory allocation
  id: totrans-52
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4-1\. 字符串内存分配
- en: Even though the JVM will garbage-collect no longer needed instances, the memory
    overhead of endless `String` creation can be a real burden on the runtime. That’s
    why the JVM uses multiple optimization techniques “behind the scenes” to reduce
    `String` creation, like replacing concatenations with a `java.lang.StringBuilder`,
    or even using the opcode `invokedynamic` to support multiple optimization strategies^([4](ch04.xhtml#idm45115247700816)).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 即使JVM会垃圾回收不再需要的实例，无限创建`String`会导致运行时的内存开销成为真正的负担。这就是为什么JVM在“幕后”使用多种优化技术来减少`String`的创建，比如用`java.lang.StringBuilder`替换连接，甚至使用`invokedynamic`操作码支持多种优化策略^([4](ch04.xhtml#idm45115247700816))。
- en: Because `String` is such a fundamental type, it is sensible to make it immutable
    for multiple reasons. Having such a base type being thread-safe by design solves
    issues associated with concurrency, like synchronization, before they even exist.
    Concurrency is hard enough without worrying about a `String` to change without
    notice. Immutability removes the risk of race conditions, side effects, or a simple
    unintended change.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`String`是如此基础的类型，所以将其设为不可变是合理的，原因有多个。通过设计使这样一个基本类型是线程安全的解决了与并发相关的问题，比如在问题出现之前就解决了同步问题。并发本身已经足够困难，不用担心`String`在不知情的情况下发生更改。不可变性消除了竞态条件、副作用或简单的意外更改的风险。
- en: '`String` literals also get special treatment from the JVM. Thanks to *string
    pooling*, identical literals are only stored once and reused to save precious
    heap space. If a `String` could change, it would change for everyone using a reference
    to it in the pool. It’s possible to allocate a new `String` by explicitly calling
    one of its constructors instead of creating a literal to circumvent pooling. The
    other way around is possible, too. By calling `intern()` on any instance, which
    returns a `String` with the same content from the string pool.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`String` 字面值在 JVM 中也得到特殊处理。由于*字符串池*的存在，相同的字面值只会被存储一次，并且重复使用以节省宝贵的堆空间。如果一个 `String`
    可以改变，那么使用引用它的所有人都会受到影响。可以通过显式调用其构造函数之一而不是创建字面值来分配一个新的 `String` 以避免池化。反过来也是可能的。通过在任何实例上调用
    `intern()` 方法，它将从字符串池返回具有相同内容的 `String`。'
- en: String Equality
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串相等性
- en: The specialized handling of `String` instances and literals is why you should
    *never* use the equality operator `==` (double-equal) to compare Strings. That’s
    why you should always use either the `equals` or `equalsIgnoreCase` method to
    test for equality.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 对 `String` 实例和字面值的专门处理是为什么你永远不应该使用等号 `==`（双等号）来比较字符串的原因。这就是为什么你应该总是使用 `equals`
    或 `equalsIgnoreCase` 方法来测试相等性。
- en: 'However, the `String` type isn’t “completely” immutable, at least from a technical
    point of view. It calculates its `hashCode` lazily due to performance considerations
    because it needs to read the whole `String` to calculate it. Still, it’s a pure
    function: the same `String` will always result in the same `hashCode`.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，从技术角度来看，`String` 类型并非完全不可变的。由于性能考虑，它会延迟计算其 `hashCode`，因为它需要读取整个 `String`
    来计算它。但它仍然是一个纯函数：相同的 `String` 总是得到相同的 `hashCode`。
- en: Using lazy evaluation to hide expensive just-in-time calculations to achieve
    logical immutability requires extra care during the design and implementation
    of a type to ensure it remains thread-safe and predictable.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用惰性评估来隐藏昂贵的即时计算以实现逻辑上的不可变性在类型的设计和实现过程中需要额外的注意，以确保它保持线程安全和可预测性。
- en: All these properties make `String` something between a primitive and an object
    type, at least from a usability standpoint. Performance optimization possibilities
    and safety might have been the main reasons for its immutability, but the implicit
    advantages of immutability are still a welcome addition to such a fundamental
    type.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些特性使得 `String` 在可用性角度来看介于原始类型和对象类型之间。性能优化可能是其不可变性的主要原因，但不可变性的隐含优势仍然是这样一个基础类型的一个受欢迎的补充。
- en: Immutable Collections
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不可变集合
- en: Another fundamental and ubiquitous group of types that benefit significantly
    from immutability is collections, like `Set`, `List`, `Map`, etc.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 另一组从不可变性中显著受益的基本且无处不在的类型是集合，如 `Set`、`List`、`Map` 等。
- en: 'Although Java’s collection framework wasn’t designed with immutability as a
    core principle, it still has a way of providing a certain degree of immutability
    with three options:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Java 的集合框架并不是以不可变性作为核心原则设计的，但它仍然有三种方式来提供一定程度的不可变性：
- en: Unmodifiable collections
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可修改的集合
- en: Immutable collection factory methods (Java 9+)
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可变集合工厂方法（Java 9+）
- en: Immutable copies (Java 10+)
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可变副本（Java 10+）
- en: All options aren’t `public` types you can instantiate directly using the `new`
    keyword. Instead, the relevant types have `static` convenience methods to create
    the necessary instances. Also, they’re only *shallowly* immutable, meaning that
    you can not add or remove any elements, but the elements themselves aren’t guaranteed
    to be immutable. Anyone holding a reference to an element can change it without
    the knowledge of the collection it currently resides in.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些选项都不是可以直接使用 `new` 关键字实例化的`public` 类型。相反，相关类型有 `static` 便利方法来创建必要的实例。此外，它们只是*浅层*不可变的，这意味着你不能添加或删除任何元素，但元素本身不能保证是不可变的。任何持有元素引用的人都可以在不知情的情况下更改它，而不知道它当前存在于哪个集合中。
- en: Shallow immutability
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 浅不可变性
- en: Shallowly immutable data structures only provide immutability at their topmost
    level. This means that the *reference* to the data structure itself can’t be changed.
    The referenced data structure, however, in the case of a Collection, its elements — can
    still be mutated.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 浅不可变数据结构只在其最顶层提供不可变性。这意味着数据结构本身的*引用*是不能改变的。然而，在集合的情况下，引用的数据结构的元素仍然可以被修改。
- en: To have a fully immutable collection, you need to use only fully immutable elements,
    too. Nevertheless, the three options still provide you with a helpful tool against
    unintended modification.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要拥有完全不可变的集合，您也需要仅使用完全不可变的元素。尽管如此，这三个选项仍为您提供了一种防止意外修改的有用工具。
- en: Unmodifiable Collections
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不可修改集合
- en: 'The first option, *unmodifiable collections*, is created from an existing collection
    by calling one of the following generic `static` methods of `java.util.Collections`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个选项，*不可修改集合*，是通过调用`java.util.Collections`的以下通用`static`方法之一从现有集合创建的：
- en: '`Collection<T> unmodifiableCollection(Collection<? extends T> c))`'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Collection<T> unmodifiableCollection(Collection<? extends T> c))`'
- en: '`Set<T> unmodifiableSet(Set<? extends T> s)`'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Set<T> unmodifiableSet(Set<? extends T> s)`'
- en: '`List<T> unmodifiableList(List<? extends T> list)`'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`List<T> unmodifiableList(List<? extends T> list)`'
- en: '`Map<K,V> unmodifiableMap(Map<? extends K, ? extends V> m)`'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Map<K,V> unmodifiableMap(Map<? extends K, ? extends V> m)`'
- en: '`SortedSet<T> unmodifiableSortedSet(SortedSet<T> s)`'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SortedSet<T> unmodifiableSortedSet(SortedSet<T> s)`'
- en: '`SortedMap<K, V> unmodifiableSortedMap(SortedMap<K, ? extends V> m)`'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SortedMap<K, V> unmodifiableSortedMap(SortedMap<K, ? extends V> m)`'
- en: '`NavigableSet<T> unmodifiableNavigableSet(NavigableSet<T> s)`'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NavigableSet<T> unmodifiableNavigableSet(NavigableSet<T> s)`'
- en: '`NavigableMap<K, V> unmodifiableNavigableMap(NavigableMap<K, V> m)`'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NavigableMap<K, V> unmodifiableNavigableMap(NavigableMap<K, V> m)`'
- en: 'As you can see, each method returns the same type as was provided for the method’s
    single argument. The difference between the original and the returned instance
    is that any attempt to modify the returned instance will throw an `UnsupportedOperationException`,
    as demonstrated in the following code:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，每个方法返回与方法的单个参数提供的类型相同的类型。原始实例和返回实例之间的区别在于，任何修改返回的实例的尝试都将抛出`UnsupportedOperationException`，如以下代码所示：
- en: '[PRE1]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The obvious downside of an “unmodifiable view” is that it’s only an abstraction
    over an existing collection. The following code shows how the underlying collection
    is still modifiable and affects the unmodifiable view:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: “不可修改视图”的明显缺点是，它只是现有集合的一个抽象。以下代码显示了基础集合仍可修改且会影响不可修改视图的方式：
- en: '[PRE2]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The reason for still being modifiable via the original reference is how the
    data structure is stored in memory, as illustrated in [Figure 4-2](#_02-data-structures_unmodifiable-memory).
    The unmodified version is only a view of the original list, so any changes directly
    to the original circumvent the intended unmodifiable nature of the view.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 之所以仍然可以通过原始引用进行修改，是由于数据结构存储在内存中的方式，如[图 4-2](#_02-data-structures_unmodifiable-memory)所示。未修改版本仅是原始列表的视图，因此直接对原始列表的任何更改都会绕过视图的预期不可修改性。
- en: '![Memory layout of unmodifiable Collections](assets/afaj_0402.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![不可修改集合的内存布局](assets/afaj_0402.png)'
- en: Figure 4-2\. Memory layout of unmodifiable Collections
  id: totrans-87
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-2\. 不可修改集合的内存布局
- en: The common use for unmodifiable views is to freeze collections for unwanted
    modification before using them as a return value.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 不可修改视图的常见用途是在将其用作返回值之前冻结集合以防止意外修改。
- en: Immutable Collection Factory Methods
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不可变集合工厂方法
- en: 'The second option — *immutable collection factory methods* — has been available
    since Java 9 and isn’t based on preexisting collections. Instead, the elements
    must be provided directly to the `static` convenience methods available on the
    following collection types:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个选择 — *不可变集合工厂方法* — 自 Java 9 起可用，不基于预先存在的集合。相反，元素必须直接提供给以下集合类型上的`static`便利方法：
- en: '`List.of(E e1, …​)`'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`List.of(E e1, …​)`'
- en: '`Set.of(E e1, …​)`'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Set.of(E e1, …​)`'
- en: '`Map.of(K k1, V v1, …​)`'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Map.of(K k1, V v1, …​)`'
- en: Each `of` method exists with zero or more elements and uses an optimized internal
    collection type based on the number of elements used.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`of`方法存在于零个或多个元素，并根据使用的元素数量使用优化的内部集合类型。
- en: Immutable Copies
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不可变副本
- en: 'The third option, *immutable copies*, is available in Java 10+ and provides
    a deeper level of immutability by calling the `static copyOf` method on the following
    three types:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个选项，*不可变副本*，自 Java 10+ 起可用，并通过在以下三种类型上调用`static copyOf`方法提供了更深层次的不可变性：
- en: '`Set<E> copyOf(Collection<? extends E> coll)`'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Set<E> copyOf(Collection<? extends E> coll)`'
- en: '`List<E> copyOf(Collection<? extends E> coll)`'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`List<E> copyOf(Collection<? extends E> coll)`'
- en: '`Map<K, V> copyOf(Map<? extends K, ? extends V> map)`'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Map<K, V> copyOf(Map<? extends K, ? extends V> map)`'
- en: 'Instead of being a mere view, `copyOf` creates a new list holding its own references
    to the elements:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 而不仅仅是一个视图，`copyOf`创建一个持有自己元素引用的新列表：
- en: '[PRE3]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The copied collection prevents any addition or removal of elements through the
    original list, but the actual elements are still shared, as illustrated in [Figure 4-3](#_02-data-structures_copyOf-memory),
    and open to changes.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 复制的集合阻止通过原始列表添加或删除任何元素，但实际元素仍然是共享的，如[图4-3](#_02-data-structures_copyOf-memory)所示，并且可以更改。
- en: '![Memory layout of copied Collections](assets/afaj_0403.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![复制集合的内存布局](assets/afaj_0403.png)'
- en: Figure 4-3\. Memory layout of copied Collections
  id: totrans-104
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4-3\. 复制集合的内存布局
- en: Which option of immutable collections to choose depends on your context and
    intentions. If a collection can’t be created in a single call, like in a `for`-loop,
    an unmodifiable view or immutable copy is a sensible approach. Use a mutable collection
    locally and “freeze” it by returning an unmodifiable view or copy it when the
    data leaves your current scope. Immutable collection factory methods don’t support
    an intermediary collection that might get modified but require you to know all
    the elements beforehand.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 选择不可变集合的选项取决于您的上下文和意图。如果集合无法在单个调用中创建，例如在`for`循环中，则返回不可修改的视图或复制是一个明智的方法。在本地使用可变集合，并在数据离开当前作用域时“冻结”它，返回不可修改的视图或复制它。不可变集合工厂方法不支持可能被修改的中间集合，而要求您事先知道所有元素。
- en: Primitives & Primitive Wrappers
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原始类型和原始包装器
- en: So far, you’ve learned mostly about immutable object types, but not everything
    in Java is an object. Java’s *primitive* types — `byte`, `char`, `short`, `int`,
    `long`, `float`, `double`, `boolean` — are handled differently from object types.
    They are simple values that are initialized by either a literal or an expression.
    Representing only a single value, they are practically immutable.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您主要了解了不可变对象类型，但并非Java中的所有内容都是对象。Java的*原始*类型 — `byte`、`char`、`short`、`int`、`long`、`float`、`double`、`boolean` — 与对象类型处理方式不同。它们是由字面值或表达式初始化的简单值。它们只表示一个单一值，实际上是不可变的。
- en: Besides the primitive types themselves, Java provides corresponding object wrapper
    types. They encapsulate their respective primitives in a concrete object type
    to make them usable in scenarios where primitives aren’t allowed (yet), like generics.
    Otherwise, *autoboxing* — the automatic conversion between the object wrapper
    types and their corresponding primitive type — could lead to inconsistent behavior.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 除了原始类型本身外，Java还提供了相应的对象包装器类型。它们在具体对象类型中封装了它们各自的原始类型，使它们可以在不允许原始类型（尚未）的情况下使用，如泛型。否则，*自动装箱* — 对象包装器类型与其对应的原始类型之间的自动转换 — 可能导致不一致的行为。
- en: Immutable Math
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不可变数学
- en: 'Most simple calculations in Java rely on *primitives* types like `int` or `long`
    for whole numbers, and `float` or `double` for floating-point calculations. The
    package `java.math`, however, has two immutable alternatives for safer and more
    precise integer and decimal calculations, which are both immutable: `java.math.BigInteger`
    and `java.math.BigDecimal`.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数Java中的简单计算依赖于*原始*类型，如`int`或`long`用于整数，以及`float`或`double`用于浮点计算。然而，`java.math`包提供了两个不可变的替代品，用于更安全和更精确的整数和十进制计算，它们分别是不可变的：`java.math.BigInteger`和`java.math.BigDecimal`。
- en: Note
  id: totrans-111
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: In this context, “integer” means a number without a fractional component and
    not Java’s `int` or `Integer` type. The word integer comes from Latin and is used
    in mathematics as a colloquial term to represent whole numbers in the range from
    <math alttext="negative normal infinity"><mrow><mo>-</mo> <mi>∞</mi></mrow></math>
    to <math alttext="plus normal infinity"><mrow><mo>+</mo> <mi>∞</mi></mrow></math>
    , including zero.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个背景下，“整数”意味着一个没有分数部分的数字，并不是Java的`int`或`Integer`类型。整数一词源自拉丁语，在数学中作为一个口语术语表示从<math
    alttext="negative normal infinity"><mrow><mo>-</mo> <mi>∞</mi></mrow></math>到<math
    alttext="plus normal infinity"><mrow><mo>+</mo> <mi>∞</mi></mrow></math>的整数范围，包括零。
- en: Just like with `String`, why should you burden your code with the overhead of
    immutability? Because they allow side-effect-free calculations in a greater range
    with higher precision.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`String`一样，为什么要在代码中增加不可变性的开销？因为它们允许在更大范围内以更高精度进行无副作用的计算。
- en: 'The pitfall of using immutable math objects, though, is the possibility of
    simply forgetting to use the actual result of a calculation. Even though method
    names like `add` or `subtract` suggest modification, at least in an OO context,
    the `java.math` types return a new object with the result, as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用不可变数学对象的一个陷阱是简单地忘记使用计算的实际结果。尽管像`add`或`subtract`这样的方法名称暗示了修改，在面向对象的上下文中，`java.math`类型返回一个新对象作为结果，如下所示：
- en: '[PRE4]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The immutable math types are still objects with the usual overhead and use more
    memory to achieve their precisions. Nevertheless, if calculation speed is not
    your limiting factor, you should always prefer the `BigDecimal` type for floating-point
    arithmetic due to its arbitrary precision^([5](ch04.xhtml#idm45115247276768)).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: The `BigInteger` type is the integer equivalent to `BigDecimal`, also with built-in
    immutability. Another advantage is the extended range of at least^([6](ch04.xhtml#idm45115247274704))
    from -2^(2,147,483,647) up to 2^(2,147,483,647) (both exclusive), compared to
    the range of `int` from -2^(31) to 2^(31).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Java Time API (JSR-310)
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Java 8 introduced the Java Time API ([JSR-310](https://jcp.org/en/jsr/detail?id=310)),
    which was designed with immutability as a core tenet. Before its release, you
    only had three^([7](ch04.xhtml#idm45115247268240)) types in the package `java.util`
    at your disposal for all your date- and time-related needs: `Date`, `Calendar`,
    and `TimeZone`. Performing calculations were a chore and error-prone. That’s why
    [Joda Time library](https://www.joda.org/joda-time/) became the de-facto standard
    for date and time classes before Java 8 and subsequently became the conceptual
    foundation for JSR-310.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-120
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Like with immutable math, any calculation with methods such as `plus` or `minus`
    won’t affect the object they’re called on. Instead, you have to use the return
    value.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Rather than the previous three types in `java.util`, there now are multiple
    date- and time-related types with different precisions, with and without timezones,
    available in the `java.time` package. They are all immutable, giving them all
    the related advantages like no side effects and safe use in concurrent environments.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Enums
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Java enums are special types consisting of constants. And constants are, well,
    *constant*, and therefore immutable. Besides the constant values, an enum can
    contain additional fields which aren’t implicitly constant.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Usually, `final` primitives or Strings are used for these fields, but no one
    stops you from using a mutable object type or a setter for a primitive. It will
    most likely lead to problems, and I strongly advise against it. Also, it’s considered
    a *code smell*⁠^([8](ch04.xhtml#idm45115247213936)).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: The final keyword
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since Java’s inception, the `final` keyword provides a certain form of immutability
    depending on its context, but it’s not a magic keyword to make any data structure
    immutable. So what exactly does it mean for a reference, method, or class to be
    `final`?
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'The `final` keyword is similar to the `const` keyword of the programming language
    `C`. It has several implications if applied to classes, methods, fields, or references:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '`final` classes cannot be subclassed.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`final` methods cannot be overridden.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`final` fields must be assigned *exactly* once — either by the constructors
    or on declaration — and can never be reassigned.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`final` variable references behave like a field by being assignable *exactly*
    once — at declaration. It only affects the reference itself, not the referenced
    variable content.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`final`变量引用的行为类似于字段，只能在声明时被分配*一次*。它仅影响引用本身，而不是引用的变量内容。'
- en: The `final` keyword grants a particular form of immutability for fields and
    variables. However, their immutability might not be what you expect because the
    reference *itself* becomes immutable but not the underlying data structure. That
    means you can’t reassign the reference but still change the data structure, as
    shown in [Example 4-1](#_02-data-structures_final_01).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`final`关键字为字段和变量提供了一种特殊形式的不可变性。然而，它们的不可变性可能不是您期望的，因为引用*本身*变为不可变，但底层数据结构并未变为不可变。这意味着您不能重新分配引用，但仍然可以更改数据结构，如[示例4-1](#_02-data-structures_final_01)所示。'
- en: Example 4-1\. Collections and `final` References
  id: totrans-134
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例4-1\. 集合和`final`引用
- en: '[PRE5]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[![1](assets/1.png)](#co_immutability_CO1-1)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_immutability_CO1-1)'
- en: The `final` keyword only affects the reference `fruits`, not the actually referenced
    `ArrayList`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`final`关键字仅影响引用`fruits`，而不是实际引用的`ArrayList`。'
- en: '[![2](assets/2.png)](#co_immutability_CO1-2)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_immutability_CO1-2)'
- en: The `ArrayList` itself doesn’t have any concept of immutability, so you can
    freely add new items to it, even if its reference is `final`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`ArrayList`本身并没有任何不可变性的概念，因此您可以自由地向其添加新项，即使其引用是`final`的。'
- en: '[![3](assets/3.png)](#co_immutability_CO1-3)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_immutability_CO1-3)'
- en: Re-assigning a `final` reference is prohibited.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 禁止重新分配`final`引用。
- en: As I discussed in [“Effectively final”](ch02.xhtml#_01-functions_lambdas_effectively-final),
    having effectively `final` references are a necessity for lambda expressions.
    Making every reference in your code `final` is an option, however, I wouldn’t
    recommend it. The compiler detects automatically if a reference behaves like a
    `final` reference even without adding an explicit keyword. Most problems created
    by the lack of immutability come from the underlying data structure itself and
    not reassigned references anyway. To make sure a data structure won’t change unexpectedly
    as long as it’s in active use, you must choose an immutable data structure from
    the get-go. The newest addition to Java to achieve this goal is *Records*.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在[“有效final”](ch02.xhtml#_01-functions_lambdas_effectively-final)中所讨论的，对于lambda表达式，具有有效`final`引用是必需的。将代码中的每个引用都设为`final`是一个选择，但我不推荐这样做。即使不添加显式关键字，编译器也会自动检测引用是否像`final`引用一样行为。由于缺乏不可变性所造成的大多数问题来自底层数据结构本身，而不是重新分配引用，因此，为了确保一个数据结构在使用过程中不会出现意外更改，您必须从一开始就选择一个不可变的数据结构。Java为实现这一目标新增了最新的功能——*Records*。
- en: Records
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Records
- en: 'In 2020, Java 14 introduced a new type of class with its own keyword to complement
    or even replace POJOs and JavaBeans in certain instances: *Records*.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 2020年，Java 14引入了一种新类型的类，其具有自己的关键字，用于在某些情况下补充甚至取代POJO和JavaBeans：*Records*。
- en: 'Records are “plain data” aggregates with less ceremony than POJOs or Java beans.
    Their feature set is reduced to an absolute minimum to serve that purpose, making
    them as concise as they are:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Records是“纯数据”聚合，比POJOs或Java bean少些仪式感。它们的功能集被减少到绝对最小限度以满足这一目的，使它们既简洁又：
- en: '[PRE6]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Records are shallowly immutable data carriers primarily consisting of their
    state’s declaration. Without any additional code, the `Address` record provides
    automatically generated getters for the named components, equality comparison,
    `toString()` and `hashCode()`, and more.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Records是浅不可变的数据载体，主要由其状态的声明组成。没有任何额外的代码，`Address`记录提供了自动生成的getter方法用于命名组件，相等比较，`toString()`和`hashCode()`等等。
- en: '[Chapter 5](ch05.xhtml#_02-records) will deep-dive into Records on how to create
    and use them in different scenarios.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '[第5章](ch05.xhtml#_02-records)将深入探讨Records在不同场景下的创建和使用方法。'
- en: How to Achieve Immutability
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现不可变性
- en: Now that you know about the immutable parts the JVM provides, it’s time to look
    at how to combine them to achieve immutability for your program state.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了JVM提供的不可变部分，是时候看看如何将它们结合起来实现程序状态的不可变性了。
- en: The easiest way to make a type immutable is by not giving it a chance to change
    in the first place. Without any setters, a data structure with `final` fields
    won’t change after creation because it can’t. For real-world code, though, the
    solution might not be as simple as that.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 使类型不可变的最简单方法是一开始就不给它改变的机会。没有任何setter，一个具有`final`字段的数据结构在创建后不会改变，因为它不能。然而，对于真实世界的代码来说，解决方案可能并不像那么简单。
- en: Immutability requires a new way of thinking about data creation because many
    shared data structures are seldom created in one fell swoop. Instead of mutating
    a single data structure over time, you should work with immutable constructs along
    the way, if possible, and compose a “final” and immutable data structure in the
    end. [Figure 4-4](#_02-data-structures_record-data-holders) depicts the general
    idea of different data components contributing to a “final” immutable Record.
    Even if the individual components aren’t immutable, you should always strive to
    wrap them in an immutable shell, Record or otherwise.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数据不可变性，需要一种新的数据创建思维方式，因为许多共享数据结构很少一次性创建。如果可能的话，不要随着时间的推移改变单个数据结构，而是应该一路使用不可变构造，并最终组合成“最终”的不可变数据结构。[图 4-4](#_02-data-structures_record-data-holders)
    描述了不同数据组件贡献于“最终”不可变记录的一般概念。即使各个组件不是不可变的，你也应始终努力将它们包装在不可变的外壳中，记录或其他形式。
- en: '![Records as Data Holders](assets/afaj_0404.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![记录作为数据持有者](assets/afaj_0404.png)'
- en: Figure 4-4\. Records as Data Holders
  id: totrans-154
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-4\. 记录作为数据持有者
- en: Keeping track of the required components and their validation might be challenging
    in more complicated data structures. In [Chapter 5](ch05.xhtml#_02-records), I’ll
    discuss tools and techniques that improve data structure creation and reduce the
    required cognitive complexity.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在更复杂的数据结构中跟踪所需组件及其验证可能具有挑战性。在[第 5 章](ch05.xhtml#_02-records)中，我将讨论改进数据结构创建和减少认知复杂性所需的工具和技术。
- en: Common Practices
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见做法
- en: Like the functional approach in general, immutability doesn’t have to be an
    all-or-nothing approach. Due to their advantages, having only immutable data structures
    sounds intriguing, and your key goal should be to use immutable data structures
    and references as your default approach. Converting existing mutable data structures
    to immutable ones, though, is often a pretty complex task requiring a lot of refactoring
    or conceptual redesign. Instead, you could introduce immutability gradually by
    following common practices and treating your data as if it were already immutable.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 与一般的函数式方法一样，不可变性不必是全盘接受的方式。由于其优势，仅拥有不可变的数据结构听起来很吸引人，你的关键目标应该是将不可变的数据结构和引用作为默认的方法。然而，将现有的可变数据结构转换为不可变数据结构通常是一项相当复杂的任务，需要大量的重构或概念重设计。相反，你可以通过遵循常见做法逐步引入不可变性，并将数据视为已经不可变。
- en: Immutability by default
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下是不可变的
- en: Any new data structure, like data-transfer objects, value objects, or any kind
    of state, should be designed as immutable. If the JDK or another framework or
    library you’re using provides an immutable alternative, you should consider it
    over a mutable type. Dealing with immutability right from the start with a new
    type will influence and shape any code that will use it.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 任何新的数据结构，如数据传输对象、值对象或任何类型的状态，都应设计为不可变。如果 JDK 或其他框架或库提供了不可变的替代方案，应优先考虑使用它们而不是可变类型。从开始就处理不可变性对于新类型会影响并塑造任何将使用它的代码。
- en: Always expect Immutability
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 始终期待不可变性
- en: Assume all data structures are immutable unless you created them or it’s stated
    explicitly otherwise, especially when dealing with Collections. If you need to
    change them, it’s safer to create a new one based on them.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 假设除非你创建它们或明确声明否，则所有数据结构都是不可变的，尤其是在处理集合时。如果需要更改它们，最安全的方法是基于它们创建一个新的数据结构。
- en: Modifying existing types
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 修改现有类型
- en: Even if a pre-existing type isn’t immutable, new additions should be, if possible.
    There might be reasons for making it mutable, but unnecessary mutability increases
    the bug surface, and all the advantages of immutability vanish instantly.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 即使预先存在的类型不是不可变的，如果可能的话，新的添加应该是不可变的。可能会有理由使其可变，但不必要的可变性会增加 bug 的风险，而不可变性的所有优势也会立即消失。
- en: Break immutability if necessary
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如有必要，打破不可变性
- en: If it doesn’t fit, don’t force it, especially in legacy codebases. The main
    goal of immutability is providing safer, more reasonable data structures, which
    requires their environment to support them accordingly.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不适合，请不要强制，特别是在传统代码库中。不可变性的主要目标是提供更安全、更合理的数据结构，这要求它们的环境相应地支持它们。
- en: Treat foreign data structures as immutable
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 将外部数据结构视为不可变的
- en: Always treat any data structure not under your scope’s control as immutable.
    For example, receiving a collection as a method argument should be considered
    immutable. Instead of manipulating it directly, create a mutable wrapper view
    for any changes, and return an unmodifiable collection type. This approach keeps
    the method pure and prevents any unintended changes the callee hasn’t expected.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 始终将不在您控制范围内的任何数据结构视为不可变的。例如，将集合作为方法参数接收应视为不可变。而不是直接操作它，为任何更改创建可变的包装视图，并返回不可修改的集合类型。这种方法保持方法的纯净性，并防止调用方未预期的任何意外更改。
- en: Following these common practices will make it easier to create immutable data
    structures from the start or gradually transition to a more immutable program
    state along the way.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循这些常见做法将使从一开始就创建不可变数据结构或逐步过渡到更不可变程序状态变得更容易。
- en: Takeaways
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 要点
- en: Immutability is a simple concept but requires a new mindset and approach to
    handling data and change.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可变性是一个简单的概念，但需要一种新的思维方式和处理数据和变更的方法。
- en: Lots of JDK types are already designed with immutability in mind
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JDK 中的许多类型已经设计成具备不可变性。
- en: Records provide a new and concise way to reduce boilerplate for creating immutable
    data structures but deliberately lack certain flexibility to be as transparent
    and straightforward as possible.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录提供了一种新的简洁方式来减少创建不可变数据结构时的样板代码，但故意缺少某些灵活性，以使其尽可能透明和直接。
- en: You can achieve immutability with the built-in tools of the JDK, and third-party
    libraries can provide simple solutions to the missing pieces.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以通过 JDK 的内置工具实现不可变性，第三方库可以提供缺失部分的简单解决方案。
- en: Introducing immutability into your code doesn’t have to be an all-or-nothing
    approach. You can gradually apply common immutability practices to your existing
    code to reduce state-related bugs and ease refactoring efforts.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您的代码中引入不可变性并不一定是一刀切的方法。您可以逐步应用常见的不可变性实践到您现有的代码中，以减少与状态相关的错误并简化重构工作。
- en: ^([1](ch04.xhtml#idm45115247823168-marker)) JavaBeans are specified in the official
    [JavaBeans API specification 1.01](https://download.oracle.com/otndocs/jcp/7224-javabeans-1.01-fr-spec-oth-JSpec/),
    which is over a hundred pages long. For the scope of this book, however, you don’t
    need to know all of it, but the mentioned differences to other data structures.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch04.xhtml#idm45115247823168-marker)) JavaBeans 在官方的 [JavaBeans API 规范
    1.01](https://download.oracle.com/otndocs/jcp/7224-javabeans-1.01-fr-spec-oth-JSpec/)
    中进行了详细说明，该规范超过一百页。然而，在本书的范围内，你不需要了解其中所有内容，只需了解与其他数据结构的差异即可。
- en: ^([2](ch04.xhtml#idm45115247804480-marker)) Since Java 1.2, the Java collections
    framework provides a multitude of common reusable data structures, like `List<E>`,
    `Set<E>`, etc. The [Oracle Java documentation](https://docs.oracle.com/javase/8/docs/technotes/guides/collections/overview.xhtml)
    has an overview of the available types included in the framework.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch04.xhtml#idm45115247804480-marker)) 自 Java 1.2 以来，Java 集合框架提供了多种常用的可重用数据结构，如
    `List<E>`、`Set<E>` 等。[Oracle Java 文档](https://docs.oracle.com/javase/8/docs/technotes/guides/collections/overview.xhtml)
    概述了框架中包含的可用类型。
- en: '^([3](ch04.xhtml#idm45115247787824-marker)) Phil Karton, an accomplished software
    engineer who for many years as a principal developer at Xerox PARC, Digital, Silicon
    Graphics, and Netscape, coined the quote, “There are only two hard things in Computer
    Science: cache invalidation and naming things.” It became a mainstream joke in
    the software community over the years and is often amended by adding “one-off
    errors” without changing the count of two.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch04.xhtml#idm45115247787824-marker)) Phil Karton，一位成就卓越的软件工程师，在 Xerox
    PARC、Digital、Silicon Graphics 和 Netscape 担任首席开发人员多年，创造了“在计算机科学中只有两件难事：缓存失效和起名字”这句话。多年来，它在软件社区中成为一种主流笑话，并经常通过添加“一次性错误”来修正，但不改变两个难事的数量。
- en: ^([4](ch04.xhtml#idm45115247700816-marker)) The JDK Enhancement Proposal (JEP)
    280, [“Indify String Concatenation”](http://openjdk.java.net/jeps/280), describes
    the reasoning behind using `invokedynamic` in more detail.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch04.xhtml#idm45115247700816-marker)) JDK 增强提案 (JEP) 280，“Indify String
    Concatenation”，更详细地描述了在更多场景中使用 `invokedynamic` 的原因。
- en: ^([5](ch04.xhtml#idm45115247276768-marker)) Arbitrary-precision arithmetic — also
    known as bignum arithmetic, multiple-precision arithmetic, or sometimes infinite-precision
    arithmetic — performs calculations on numbers whose digits of precision are only
    limited by the available memory, not a fixed number.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch04.xhtml#idm45115247276768-marker)) 任意精度算术，也称为大数算术、多精度算术，有时是无限精度算术，可以对数字进行计算，其精度仅受可用内存限制，而不是固定数字。
- en: ^([6](ch04.xhtml#idm45115247274704-marker)) The actual range of `BigInteger`
    depends on the actual implementation of the used JDK, as stated in an implementation
    note in the [offical documentation](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/math/BigInteger.xhtml).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch04.xhtml#idm45115247274704-marker)) `BigInteger` 的实际范围取决于所使用的 JDK 的实际实现，正如在[官方文档](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/math/BigInteger.xhtml)的一个实现说明中所述。
- en: ^([7](ch04.xhtml#idm45115247268240-marker)) Technically there’s a forth type,
    `java.sql.Date`, which is a thin wrapper to improve JDBC support.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: ^([7](ch04.xhtml#idm45115247268240-marker)) 技术上还有第四种类型，`java.sql.Date`，它是一个薄包装器，用于改进
    JDBC 的支持。
- en: ^([8](ch04.xhtml#idm45115247213936-marker)) A *code smell* is a known code characteristic
    that might indicate a deeper problem. It’s not a bug or error *per se*, but it
    might cause trouble in the long run. These *smells* are subjective and vary by
    programming language, developer, and paradigms. [SonarSource](https://www.sonarsource.com/),
    the well-known company that develops open-source software for continuous code
    quality and security, lists mutable enums as rule [RSPEC-3066](https://rules.sonarsource.com/java/RSPEC-3066)
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: ^([8](ch04.xhtml#idm45115247213936-marker)) *代码异味*是一种已知的代码特征，可能表明存在更深层次的问题。这并不是一个明显的
    bug 或错误，但长期来看可能会引起麻烦。这些 *异味* 是主观的，根据编程语言、开发者和编程范式而异。[SonarSource](https://www.sonarsource.com/)，这家臭名昭著的公司开发了开源软件，用于持续代码质量和安全性，将可变枚举列为规则
    [RSPEC-3066](https://rules.sonarsource.com/java/RSPEC-3066)。
