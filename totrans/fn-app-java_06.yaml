- en: Chapter 4\. Immutability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dealing with data structures — constructs dedicated to storing and organizing
    data values — is a core task of almost any program. In OOP, this usually means
    dealing with a *mutable* program state, often encapsulated in objects. For a functional
    approach, however, *immutability* is the preferred way of handling data and a
    prerequisite for many of its concepts.
  prefs: []
  type: TYPE_NORMAL
- en: In functional programming languages like Haskell or even multi-paradigm but
    more functionally inclined ones like Scala, immutability is treated as a prevalent
    feature. In those languages, immutability is a necessity and often strictly enforced,
    not just an afterthought to their design. Like most other principles introduced
    in this book, immutability isn’t restricted to functional programming and provides
    many benefits, regardless of your chosen paradigm.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn about immutable types already available in the
    JDK and how to make your data structures immutable to avoid side effects, either
    with the tools provided by the JDK or with the help of third-party libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The term “data structure” used in this chapter represents any construct that
    stores and organizes data, like collections, or custom objects.
  prefs: []
  type: TYPE_NORMAL
- en: Mutability and Data Structures in OOP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As an object-oriented inclined language, typical Java code encapsulates an object’s
    state in a mutable form. Its state is usually mutable by using “setter” methods.
    This approach makes the program state *ephemeral*, meaning any change to an existing
    data structure updates its current state in-place, which also affects anyone else
    who references it, and the previous state is lost.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at the most common forms used to handle mutable state in
    OOP Java code: *JavaBeans* and *Plain Old Java Objects (POJO)*. A lot of confusion
    exists about those two data structures and their distinct properties. In a sense,
    they are both ordinary Java objects supposed to create reusability between components
    by encapsulating all relevant states. They have similar goals, although their
    design philosophy and rules differ.'
  prefs: []
  type: TYPE_NORMAL
- en: POJOs don’t have any restrictions regarding their design. They are supposed
    to “just” encapsulate the business logic state, and you can even design them to
    be immutable. How you implement them is up to you and what matches your environment
    best. They usually provide “getters” and “setters” for their fields to be more
    flexible in an object-oriented context with a mutable state.
  prefs: []
  type: TYPE_NORMAL
- en: JavaBeans, on the other hand, are a special kind of POJO that allows easier
    introspection and reusability, which requires them to oblige certain rules. These
    rules are necessary because JavaBeans were initially designed to be a standardized
    shareable machine-readable state between components, like a UI widget in your
    IDE^([1](ch04.xhtml#idm45115247823168)). The differences between POJOs and JavaBeans
    are listed in [Table 4-1](#_02-data-structures_pojo-vs-bean).
  prefs: []
  type: TYPE_NORMAL
- en: Table 4-1\. POJOs versus JavaBeans
  prefs: []
  type: TYPE_NORMAL
- en: '|  | POJO | JavaBean |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| General Restrictions | Only those imposed by the Java language itself | Imposed
    by JavaBean API specification |'
  prefs: []
  type: TYPE_TB
- en: '| Serialization | Optional | Must implement `java.io.Serializable` |'
  prefs: []
  type: TYPE_TB
- en: '| Field Visibility | No restrictions | `private` only |'
  prefs: []
  type: TYPE_TB
- en: '| Field Access | No restrictions | Only accessible via getters and setters
    |'
  prefs: []
  type: TYPE_TB
- en: '| Constructors | No restrictions | No-arg constructor must exist. |'
  prefs: []
  type: TYPE_TB
- en: Many of the available data structures in the JDK, like the *collections framework*⁠^([2](ch04.xhtml#idm45115247804480))
    are mostly built around the concept of mutable state and in-place changes. Take
    `List<E>` for an example. Its mutating methods, like `add(E value)` or `remove(E
    value)`, only return a `boolean` to indicate that a change occurred, and change
    the collection in place, so the previous state is lost. You might not need to
    think much about it in a local context, but as soon as a data structure leaves
    your direct sphere of influence, it’s no longer guaranteed to remain in its current
    state as long as you hold a reference to it.
  prefs: []
  type: TYPE_NORMAL
- en: Mutable state breeds complexity and uncertainty. You must include all possible
    state changes in your mental model at any time to understand and reason with your
    code. This isn’t restricted to a single component, though. Sharing mutable state
    increases the complexity to cover the lifetime of any components having access
    to such shared state. Especially concurrent programming suffers under the complexities
    of shared state, where many problems originate in mutability and require intricate
    and often misused solutions like access synchronization and atomic references.
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring the correctness of your code and shared state becomes a Sisyphean task
    of endless unit tests and state validation. And the required additional work multiplies
    as soon as mutable state interacts with more mutable components, resulting in
    even more verification of their behavior.
  prefs: []
  type: TYPE_NORMAL
- en: That’s where immutability provides another approach to handling data structures
    and restoring reasonability.
  prefs: []
  type: TYPE_NORMAL
- en: Immutability (not only) in FP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The core idea of immutability is simple: data structures can no longer change
    after their creation. Many functional programming languages support it by design
    at their core. The concept isn’t bound to functional programming per se, and it
    has many advantages in any paradigm.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Immutability provides elegant solutions to many problems, even outside of programming
    languages. For example, the distributed version control system *Git* essentially
    uses a tree of pointers to immutable blobs and diffs to provide a robust representation
    of historical changes.
  prefs: []
  type: TYPE_NORMAL
- en: Immutable data structures are *persistent* views of their data without a direct
    option to change it. To “mutate” such a data structure, you must create a new
    copy with the intended changes. Not being able to mutate data “in place” can feel
    weird in Java at first. Compared to the usually mutable nature of object-oriented
    code, why should you take the extra steps necessary to simply change a value?
    Such creation of new instances by copying data incurs a particular overhead that
    accumulates quickly for naive implementations of immutability.
  prefs: []
  type: TYPE_NORMAL
- en: 'Despite the overhead and initial weirdness of not being able to change data
    in place, the benefits of immutability can make it worthwhile even without a more
    functional approach to Java:'
  prefs: []
  type: TYPE_NORMAL
- en: Predictability
  prefs: []
  type: TYPE_NORMAL
- en: Data structures won’t change without you noticing because they simply can’t.
    As long as you reference a data structure, you know it is the same as at the time
    of its creation. Even if you share that reference or use it in a concurrent fashion,
    no one can change your copy of it.
  prefs: []
  type: TYPE_NORMAL
- en: Validity
  prefs: []
  type: TYPE_NORMAL
- en: After initialization, a data structure is *complete*. It only needs to be verified
    once and stays valid (or invalid) indefinitely. If you need to build a data structure
    in multiple steps, the *builder-pattern*, shown later in [“Step-by-Step Creation”](ch05.xhtml#_01-immutables_step-by-step),
    decouples the building and initialization of a data structure.
  prefs: []
  type: TYPE_NORMAL
- en: No hidden side effects
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with side effects is a really tough problem in programming — besides
    naming and cache invalidation^([3](ch04.xhtml#idm45115247787824)). A byproduct
    of immutable data structures is the elimination of side effects; they’re always
    *as-is*. Even if moved around a lot through different parts of your code or using
    it in a third-party library out of your control, they won’t change their values
    or surprise you with an unintended side effect.
  prefs: []
  type: TYPE_NORMAL
- en: Thread-safety
  prefs: []
  type: TYPE_NORMAL
- en: Without side effects, immutable data structures can move freely between thread
    boundaries. No thread can change them, so reasoning about your program becomes
    more straightforward due to no more unexpected changes or race conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Cacheability and optimization
  prefs: []
  type: TYPE_NORMAL
- en: Because they are *as-is* right after creation, you can cache immutable data
    structures with ease of mind. Optimization techniques, like memoization, are only
    possible with immutable data structures, as discussed in [Chapter 2](ch02.xhtml#_01-functional-java).
  prefs: []
  type: TYPE_NORMAL
- en: Change tracking
  prefs: []
  type: TYPE_NORMAL
- en: If every change results in a whole new data structure, you can track their history
    by storing the previous references. You no longer need to intricately track single
    property changes to support an *undo* feature. Restoring a previous state is as
    simple as using a prior reference to the data structure.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, all these benefits are independent of the chosen programming paradigm.
    Even if you decide that a functional approach might not be the right solution
    for your codebase, your data handling can still benefit immensely from immutability.
  prefs: []
  type: TYPE_NORMAL
- en: The State of Java Immutability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Java’s initial design didn’t include immutability as a deeply integrated language
    feature or a variety of immutable data structures. Certain aspects of the language
    and its types were always immutable, but it was nowhere close to the level of
    support in other more functional languages. This all changed when Java 14 was
    released and introduced *Records*, a built-in language-level immutable data structure:
    *Records*.'
  prefs: []
  type: TYPE_NORMAL
- en: Even if you might not know it yet, you’re already using immutable types in all
    your Java programs. The reasons behind their immutability might differ, like runtime
    optimizations or ensuring their correct usage, but regardless of their intentions,
    they’ll make your code safer and less error-prone.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a look at all the different immutable parts available in the JDK
    today.
  prefs: []
  type: TYPE_NORMAL
- en: java.lang.String
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the first types every Java developer learns about is the `String` type.
    Strings are everywhere! That’s why it needs to be a highly optimized and safe
    type. One of these optimizations is that it’s immutable.
  prefs: []
  type: TYPE_NORMAL
- en: '`String` is not a primitive value-based type, like `int` or `char`. Still,
    it supports the + (plus) operator to concatenate a `String` with another value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Like any other expression, concatenating strings creates a result, and in this
    case, a new object. That’s why Java developers are taught early not to overuse
    manual `String` concatenation. Each time you concatenate strings by using the
    + (plus) operator, a new `String` instance is created on the heap, occupying memory,
    as depicted in [Figure 4-1](#_02-data-structures_string-allocation). These newly
    created instances can add up quickly, especially if concatenation is done in a
    loop statement like `for` or `while`.
  prefs: []
  type: TYPE_NORMAL
- en: '![String memory allocation](assets/afaj_0401.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-1\. String memory allocation
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Even though the JVM will garbage-collect no longer needed instances, the memory
    overhead of endless `String` creation can be a real burden on the runtime. That’s
    why the JVM uses multiple optimization techniques “behind the scenes” to reduce
    `String` creation, like replacing concatenations with a `java.lang.StringBuilder`,
    or even using the opcode `invokedynamic` to support multiple optimization strategies^([4](ch04.xhtml#idm45115247700816)).
  prefs: []
  type: TYPE_NORMAL
- en: Because `String` is such a fundamental type, it is sensible to make it immutable
    for multiple reasons. Having such a base type being thread-safe by design solves
    issues associated with concurrency, like synchronization, before they even exist.
    Concurrency is hard enough without worrying about a `String` to change without
    notice. Immutability removes the risk of race conditions, side effects, or a simple
    unintended change.
  prefs: []
  type: TYPE_NORMAL
- en: '`String` literals also get special treatment from the JVM. Thanks to *string
    pooling*, identical literals are only stored once and reused to save precious
    heap space. If a `String` could change, it would change for everyone using a reference
    to it in the pool. It’s possible to allocate a new `String` by explicitly calling
    one of its constructors instead of creating a literal to circumvent pooling. The
    other way around is possible, too. By calling `intern()` on any instance, which
    returns a `String` with the same content from the string pool.'
  prefs: []
  type: TYPE_NORMAL
- en: String Equality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The specialized handling of `String` instances and literals is why you should
    *never* use the equality operator `==` (double-equal) to compare Strings. That’s
    why you should always use either the `equals` or `equalsIgnoreCase` method to
    test for equality.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the `String` type isn’t “completely” immutable, at least from a technical
    point of view. It calculates its `hashCode` lazily due to performance considerations
    because it needs to read the whole `String` to calculate it. Still, it’s a pure
    function: the same `String` will always result in the same `hashCode`.'
  prefs: []
  type: TYPE_NORMAL
- en: Using lazy evaluation to hide expensive just-in-time calculations to achieve
    logical immutability requires extra care during the design and implementation
    of a type to ensure it remains thread-safe and predictable.
  prefs: []
  type: TYPE_NORMAL
- en: All these properties make `String` something between a primitive and an object
    type, at least from a usability standpoint. Performance optimization possibilities
    and safety might have been the main reasons for its immutability, but the implicit
    advantages of immutability are still a welcome addition to such a fundamental
    type.
  prefs: []
  type: TYPE_NORMAL
- en: Immutable Collections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another fundamental and ubiquitous group of types that benefit significantly
    from immutability is collections, like `Set`, `List`, `Map`, etc.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although Java’s collection framework wasn’t designed with immutability as a
    core principle, it still has a way of providing a certain degree of immutability
    with three options:'
  prefs: []
  type: TYPE_NORMAL
- en: Unmodifiable collections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Immutable collection factory methods (Java 9+)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Immutable copies (Java 10+)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All options aren’t `public` types you can instantiate directly using the `new`
    keyword. Instead, the relevant types have `static` convenience methods to create
    the necessary instances. Also, they’re only *shallowly* immutable, meaning that
    you can not add or remove any elements, but the elements themselves aren’t guaranteed
    to be immutable. Anyone holding a reference to an element can change it without
    the knowledge of the collection it currently resides in.
  prefs: []
  type: TYPE_NORMAL
- en: Shallow immutability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Shallowly immutable data structures only provide immutability at their topmost
    level. This means that the *reference* to the data structure itself can’t be changed.
    The referenced data structure, however, in the case of a Collection, its elements — can
    still be mutated.
  prefs: []
  type: TYPE_NORMAL
- en: To have a fully immutable collection, you need to use only fully immutable elements,
    too. Nevertheless, the three options still provide you with a helpful tool against
    unintended modification.
  prefs: []
  type: TYPE_NORMAL
- en: Unmodifiable Collections
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first option, *unmodifiable collections*, is created from an existing collection
    by calling one of the following generic `static` methods of `java.util.Collections`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Collection<T> unmodifiableCollection(Collection<? extends T> c))`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Set<T> unmodifiableSet(Set<? extends T> s)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`List<T> unmodifiableList(List<? extends T> list)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Map<K,V> unmodifiableMap(Map<? extends K, ? extends V> m)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SortedSet<T> unmodifiableSortedSet(SortedSet<T> s)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SortedMap<K, V> unmodifiableSortedMap(SortedMap<K, ? extends V> m)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NavigableSet<T> unmodifiableNavigableSet(NavigableSet<T> s)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NavigableMap<K, V> unmodifiableNavigableMap(NavigableMap<K, V> m)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As you can see, each method returns the same type as was provided for the method’s
    single argument. The difference between the original and the returned instance
    is that any attempt to modify the returned instance will throw an `UnsupportedOperationException`,
    as demonstrated in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The obvious downside of an “unmodifiable view” is that it’s only an abstraction
    over an existing collection. The following code shows how the underlying collection
    is still modifiable and affects the unmodifiable view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The reason for still being modifiable via the original reference is how the
    data structure is stored in memory, as illustrated in [Figure 4-2](#_02-data-structures_unmodifiable-memory).
    The unmodified version is only a view of the original list, so any changes directly
    to the original circumvent the intended unmodifiable nature of the view.
  prefs: []
  type: TYPE_NORMAL
- en: '![Memory layout of unmodifiable Collections](assets/afaj_0402.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-2\. Memory layout of unmodifiable Collections
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The common use for unmodifiable views is to freeze collections for unwanted
    modification before using them as a return value.
  prefs: []
  type: TYPE_NORMAL
- en: Immutable Collection Factory Methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The second option — *immutable collection factory methods* — has been available
    since Java 9 and isn’t based on preexisting collections. Instead, the elements
    must be provided directly to the `static` convenience methods available on the
    following collection types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`List.of(E e1, …​)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Set.of(E e1, …​)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Map.of(K k1, V v1, …​)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each `of` method exists with zero or more elements and uses an optimized internal
    collection type based on the number of elements used.
  prefs: []
  type: TYPE_NORMAL
- en: Immutable Copies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The third option, *immutable copies*, is available in Java 10+ and provides
    a deeper level of immutability by calling the `static copyOf` method on the following
    three types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Set<E> copyOf(Collection<? extends E> coll)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`List<E> copyOf(Collection<? extends E> coll)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Map<K, V> copyOf(Map<? extends K, ? extends V> map)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Instead of being a mere view, `copyOf` creates a new list holding its own references
    to the elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The copied collection prevents any addition or removal of elements through the
    original list, but the actual elements are still shared, as illustrated in [Figure 4-3](#_02-data-structures_copyOf-memory),
    and open to changes.
  prefs: []
  type: TYPE_NORMAL
- en: '![Memory layout of copied Collections](assets/afaj_0403.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-3\. Memory layout of copied Collections
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Which option of immutable collections to choose depends on your context and
    intentions. If a collection can’t be created in a single call, like in a `for`-loop,
    an unmodifiable view or immutable copy is a sensible approach. Use a mutable collection
    locally and “freeze” it by returning an unmodifiable view or copy it when the
    data leaves your current scope. Immutable collection factory methods don’t support
    an intermediary collection that might get modified but require you to know all
    the elements beforehand.
  prefs: []
  type: TYPE_NORMAL
- en: Primitives & Primitive Wrappers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, you’ve learned mostly about immutable object types, but not everything
    in Java is an object. Java’s *primitive* types — `byte`, `char`, `short`, `int`,
    `long`, `float`, `double`, `boolean` — are handled differently from object types.
    They are simple values that are initialized by either a literal or an expression.
    Representing only a single value, they are practically immutable.
  prefs: []
  type: TYPE_NORMAL
- en: Besides the primitive types themselves, Java provides corresponding object wrapper
    types. They encapsulate their respective primitives in a concrete object type
    to make them usable in scenarios where primitives aren’t allowed (yet), like generics.
    Otherwise, *autoboxing* — the automatic conversion between the object wrapper
    types and their corresponding primitive type — could lead to inconsistent behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Immutable Math
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Most simple calculations in Java rely on *primitives* types like `int` or `long`
    for whole numbers, and `float` or `double` for floating-point calculations. The
    package `java.math`, however, has two immutable alternatives for safer and more
    precise integer and decimal calculations, which are both immutable: `java.math.BigInteger`
    and `java.math.BigDecimal`.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In this context, “integer” means a number without a fractional component and
    not Java’s `int` or `Integer` type. The word integer comes from Latin and is used
    in mathematics as a colloquial term to represent whole numbers in the range from
    <math alttext="negative normal infinity"><mrow><mo>-</mo> <mi>∞</mi></mrow></math>
    to <math alttext="plus normal infinity"><mrow><mo>+</mo> <mi>∞</mi></mrow></math>
    , including zero.
  prefs: []
  type: TYPE_NORMAL
- en: Just like with `String`, why should you burden your code with the overhead of
    immutability? Because they allow side-effect-free calculations in a greater range
    with higher precision.
  prefs: []
  type: TYPE_NORMAL
- en: 'The pitfall of using immutable math objects, though, is the possibility of
    simply forgetting to use the actual result of a calculation. Even though method
    names like `add` or `subtract` suggest modification, at least in an OO context,
    the `java.math` types return a new object with the result, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The immutable math types are still objects with the usual overhead and use more
    memory to achieve their precisions. Nevertheless, if calculation speed is not
    your limiting factor, you should always prefer the `BigDecimal` type for floating-point
    arithmetic due to its arbitrary precision^([5](ch04.xhtml#idm45115247276768)).
  prefs: []
  type: TYPE_NORMAL
- en: The `BigInteger` type is the integer equivalent to `BigDecimal`, also with built-in
    immutability. Another advantage is the extended range of at least^([6](ch04.xhtml#idm45115247274704))
    from -2^(2,147,483,647) up to 2^(2,147,483,647) (both exclusive), compared to
    the range of `int` from -2^(31) to 2^(31).
  prefs: []
  type: TYPE_NORMAL
- en: Java Time API (JSR-310)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Java 8 introduced the Java Time API ([JSR-310](https://jcp.org/en/jsr/detail?id=310)),
    which was designed with immutability as a core tenet. Before its release, you
    only had three^([7](ch04.xhtml#idm45115247268240)) types in the package `java.util`
    at your disposal for all your date- and time-related needs: `Date`, `Calendar`,
    and `TimeZone`. Performing calculations were a chore and error-prone. That’s why
    [Joda Time library](https://www.joda.org/joda-time/) became the de-facto standard
    for date and time classes before Java 8 and subsequently became the conceptual
    foundation for JSR-310.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Like with immutable math, any calculation with methods such as `plus` or `minus`
    won’t affect the object they’re called on. Instead, you have to use the return
    value.
  prefs: []
  type: TYPE_NORMAL
- en: Rather than the previous three types in `java.util`, there now are multiple
    date- and time-related types with different precisions, with and without timezones,
    available in the `java.time` package. They are all immutable, giving them all
    the related advantages like no side effects and safe use in concurrent environments.
  prefs: []
  type: TYPE_NORMAL
- en: Enums
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Java enums are special types consisting of constants. And constants are, well,
    *constant*, and therefore immutable. Besides the constant values, an enum can
    contain additional fields which aren’t implicitly constant.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, `final` primitives or Strings are used for these fields, but no one
    stops you from using a mutable object type or a setter for a primitive. It will
    most likely lead to problems, and I strongly advise against it. Also, it’s considered
    a *code smell*⁠^([8](ch04.xhtml#idm45115247213936)).
  prefs: []
  type: TYPE_NORMAL
- en: The final keyword
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since Java’s inception, the `final` keyword provides a certain form of immutability
    depending on its context, but it’s not a magic keyword to make any data structure
    immutable. So what exactly does it mean for a reference, method, or class to be
    `final`?
  prefs: []
  type: TYPE_NORMAL
- en: 'The `final` keyword is similar to the `const` keyword of the programming language
    `C`. It has several implications if applied to classes, methods, fields, or references:'
  prefs: []
  type: TYPE_NORMAL
- en: '`final` classes cannot be subclassed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`final` methods cannot be overridden.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`final` fields must be assigned *exactly* once — either by the constructors
    or on declaration — and can never be reassigned.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`final` variable references behave like a field by being assignable *exactly*
    once — at declaration. It only affects the reference itself, not the referenced
    variable content.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `final` keyword grants a particular form of immutability for fields and
    variables. However, their immutability might not be what you expect because the
    reference *itself* becomes immutable but not the underlying data structure. That
    means you can’t reassign the reference but still change the data structure, as
    shown in [Example 4-1](#_02-data-structures_final_01).
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-1\. Collections and `final` References
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_immutability_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The `final` keyword only affects the reference `fruits`, not the actually referenced
    `ArrayList`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_immutability_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The `ArrayList` itself doesn’t have any concept of immutability, so you can
    freely add new items to it, even if its reference is `final`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_immutability_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Re-assigning a `final` reference is prohibited.
  prefs: []
  type: TYPE_NORMAL
- en: As I discussed in [“Effectively final”](ch02.xhtml#_01-functions_lambdas_effectively-final),
    having effectively `final` references are a necessity for lambda expressions.
    Making every reference in your code `final` is an option, however, I wouldn’t
    recommend it. The compiler detects automatically if a reference behaves like a
    `final` reference even without adding an explicit keyword. Most problems created
    by the lack of immutability come from the underlying data structure itself and
    not reassigned references anyway. To make sure a data structure won’t change unexpectedly
    as long as it’s in active use, you must choose an immutable data structure from
    the get-go. The newest addition to Java to achieve this goal is *Records*.
  prefs: []
  type: TYPE_NORMAL
- en: Records
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In 2020, Java 14 introduced a new type of class with its own keyword to complement
    or even replace POJOs and JavaBeans in certain instances: *Records*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Records are “plain data” aggregates with less ceremony than POJOs or Java beans.
    Their feature set is reduced to an absolute minimum to serve that purpose, making
    them as concise as they are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Records are shallowly immutable data carriers primarily consisting of their
    state’s declaration. Without any additional code, the `Address` record provides
    automatically generated getters for the named components, equality comparison,
    `toString()` and `hashCode()`, and more.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 5](ch05.xhtml#_02-records) will deep-dive into Records on how to create
    and use them in different scenarios.'
  prefs: []
  type: TYPE_NORMAL
- en: How to Achieve Immutability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you know about the immutable parts the JVM provides, it’s time to look
    at how to combine them to achieve immutability for your program state.
  prefs: []
  type: TYPE_NORMAL
- en: The easiest way to make a type immutable is by not giving it a chance to change
    in the first place. Without any setters, a data structure with `final` fields
    won’t change after creation because it can’t. For real-world code, though, the
    solution might not be as simple as that.
  prefs: []
  type: TYPE_NORMAL
- en: Immutability requires a new way of thinking about data creation because many
    shared data structures are seldom created in one fell swoop. Instead of mutating
    a single data structure over time, you should work with immutable constructs along
    the way, if possible, and compose a “final” and immutable data structure in the
    end. [Figure 4-4](#_02-data-structures_record-data-holders) depicts the general
    idea of different data components contributing to a “final” immutable Record.
    Even if the individual components aren’t immutable, you should always strive to
    wrap them in an immutable shell, Record or otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: '![Records as Data Holders](assets/afaj_0404.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-4\. Records as Data Holders
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Keeping track of the required components and their validation might be challenging
    in more complicated data structures. In [Chapter 5](ch05.xhtml#_02-records), I’ll
    discuss tools and techniques that improve data structure creation and reduce the
    required cognitive complexity.
  prefs: []
  type: TYPE_NORMAL
- en: Common Practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like the functional approach in general, immutability doesn’t have to be an
    all-or-nothing approach. Due to their advantages, having only immutable data structures
    sounds intriguing, and your key goal should be to use immutable data structures
    and references as your default approach. Converting existing mutable data structures
    to immutable ones, though, is often a pretty complex task requiring a lot of refactoring
    or conceptual redesign. Instead, you could introduce immutability gradually by
    following common practices and treating your data as if it were already immutable.
  prefs: []
  type: TYPE_NORMAL
- en: Immutability by default
  prefs: []
  type: TYPE_NORMAL
- en: Any new data structure, like data-transfer objects, value objects, or any kind
    of state, should be designed as immutable. If the JDK or another framework or
    library you’re using provides an immutable alternative, you should consider it
    over a mutable type. Dealing with immutability right from the start with a new
    type will influence and shape any code that will use it.
  prefs: []
  type: TYPE_NORMAL
- en: Always expect Immutability
  prefs: []
  type: TYPE_NORMAL
- en: Assume all data structures are immutable unless you created them or it’s stated
    explicitly otherwise, especially when dealing with Collections. If you need to
    change them, it’s safer to create a new one based on them.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying existing types
  prefs: []
  type: TYPE_NORMAL
- en: Even if a pre-existing type isn’t immutable, new additions should be, if possible.
    There might be reasons for making it mutable, but unnecessary mutability increases
    the bug surface, and all the advantages of immutability vanish instantly.
  prefs: []
  type: TYPE_NORMAL
- en: Break immutability if necessary
  prefs: []
  type: TYPE_NORMAL
- en: If it doesn’t fit, don’t force it, especially in legacy codebases. The main
    goal of immutability is providing safer, more reasonable data structures, which
    requires their environment to support them accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Treat foreign data structures as immutable
  prefs: []
  type: TYPE_NORMAL
- en: Always treat any data structure not under your scope’s control as immutable.
    For example, receiving a collection as a method argument should be considered
    immutable. Instead of manipulating it directly, create a mutable wrapper view
    for any changes, and return an unmodifiable collection type. This approach keeps
    the method pure and prevents any unintended changes the callee hasn’t expected.
  prefs: []
  type: TYPE_NORMAL
- en: Following these common practices will make it easier to create immutable data
    structures from the start or gradually transition to a more immutable program
    state along the way.
  prefs: []
  type: TYPE_NORMAL
- en: Takeaways
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Immutability is a simple concept but requires a new mindset and approach to
    handling data and change.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lots of JDK types are already designed with immutability in mind
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Records provide a new and concise way to reduce boilerplate for creating immutable
    data structures but deliberately lack certain flexibility to be as transparent
    and straightforward as possible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can achieve immutability with the built-in tools of the JDK, and third-party
    libraries can provide simple solutions to the missing pieces.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing immutability into your code doesn’t have to be an all-or-nothing
    approach. You can gradually apply common immutability practices to your existing
    code to reduce state-related bugs and ease refactoring efforts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ^([1](ch04.xhtml#idm45115247823168-marker)) JavaBeans are specified in the official
    [JavaBeans API specification 1.01](https://download.oracle.com/otndocs/jcp/7224-javabeans-1.01-fr-spec-oth-JSpec/),
    which is over a hundred pages long. For the scope of this book, however, you don’t
    need to know all of it, but the mentioned differences to other data structures.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch04.xhtml#idm45115247804480-marker)) Since Java 1.2, the Java collections
    framework provides a multitude of common reusable data structures, like `List<E>`,
    `Set<E>`, etc. The [Oracle Java documentation](https://docs.oracle.com/javase/8/docs/technotes/guides/collections/overview.xhtml)
    has an overview of the available types included in the framework.
  prefs: []
  type: TYPE_NORMAL
- en: '^([3](ch04.xhtml#idm45115247787824-marker)) Phil Karton, an accomplished software
    engineer who for many years as a principal developer at Xerox PARC, Digital, Silicon
    Graphics, and Netscape, coined the quote, “There are only two hard things in Computer
    Science: cache invalidation and naming things.” It became a mainstream joke in
    the software community over the years and is often amended by adding “one-off
    errors” without changing the count of two.'
  prefs: []
  type: TYPE_NORMAL
- en: ^([4](ch04.xhtml#idm45115247700816-marker)) The JDK Enhancement Proposal (JEP)
    280, [“Indify String Concatenation”](http://openjdk.java.net/jeps/280), describes
    the reasoning behind using `invokedynamic` in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: ^([5](ch04.xhtml#idm45115247276768-marker)) Arbitrary-precision arithmetic — also
    known as bignum arithmetic, multiple-precision arithmetic, or sometimes infinite-precision
    arithmetic — performs calculations on numbers whose digits of precision are only
    limited by the available memory, not a fixed number.
  prefs: []
  type: TYPE_NORMAL
- en: ^([6](ch04.xhtml#idm45115247274704-marker)) The actual range of `BigInteger`
    depends on the actual implementation of the used JDK, as stated in an implementation
    note in the [offical documentation](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/math/BigInteger.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: ^([7](ch04.xhtml#idm45115247268240-marker)) Technically there’s a forth type,
    `java.sql.Date`, which is a thin wrapper to improve JDBC support.
  prefs: []
  type: TYPE_NORMAL
- en: ^([8](ch04.xhtml#idm45115247213936-marker)) A *code smell* is a known code characteristic
    that might indicate a deeper problem. It’s not a bug or error *per se*, but it
    might cause trouble in the long run. These *smells* are subjective and vary by
    programming language, developer, and paradigms. [SonarSource](https://www.sonarsource.com/),
    the well-known company that develops open-source software for continuous code
    quality and security, lists mutable enums as rule [RSPEC-3066](https://rules.sonarsource.com/java/RSPEC-3066)
  prefs: []
  type: TYPE_NORMAL
