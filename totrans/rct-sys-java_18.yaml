- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have come to the end of this book. We have covered the principles behind
    reactive architectures and the technical practices to implement them with Quarkus.
  prefs: []
  type: TYPE_NORMAL
- en: A Brief Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Part II](part02.html#reactive-part), we explored reactive architectures.
    Reactive systems ([Chapter 4](ch04.html#reactive-systems)) propose a different
    way to build distributed systems ([Chapter 3](ch03.html#distributed-system)).
    The use of message passing between the various components forming the system enables
    elasticity and resilience, two characteristics essential for modern applications
    deployed in the cloud or running in containers. But that’s not all. Reactive applications
    must also handle the workload in a timely fashion and use resources efficiently.
    This last point pushes reactive applications to use nonblocking I/O and avoids
    creating too many OS threads ([“The Role of Nonblocking Input/Output”](ch04.html#reactive-system::non-blocking)).
    The resulting execution model provides better response time and improves memory
    consumption. However, it does not come for free. To write such an application,
    you must change the way you write code. You must never block the I/O threads and
    so must write your code using a continuation-passing style. In this book, we have
    looked at reactive programming and Mutiny ([Chapter 5](ch05.html#reactive-programming),
    [Chapter 7](ch07.html#mutiny)).
  prefs: []
  type: TYPE_NORMAL
- en: We also covered Quarkus, a stack to write applications in Java tailored for
    the cloud and containers ([Chapter 2](ch02.html#quarkus)). Quarkus runs on top
    of a reactive engine dealing with the network and nonblocking I/O. In addition,
    Quarkus offers a large set of reactive APIs. The combination of the engine and
    the API creates a breeding ground to build reactive applications ([Chapter 6](ch06.html#quarkus-reactive)).
    Quarkus provides reactive APIs to serve HTTP endpoints ([Chapter 8](ch08.html#http)),
    as well as to interact with data sources ([Chapter 9](ch09.html#data)) and consume
    HTTP services ([Chapter 12](ch12.html#http-client)).
  prefs: []
  type: TYPE_NORMAL
- en: Quarkus also provides the connective tissue for building reactive systems ([Chapter 10](ch10.html#messaging)).
    This book covered Kafka and AMQP 1.0, but many more possibilities are available
    ([Chapter 11](ch11.html#event-bus)).
  prefs: []
  type: TYPE_NORMAL
- en: Quarkus lets you design, build, and operate reactive systems. Observability
    is a key component for distributed systems and not a feature to be tacked on at
    the end of development ([Chapter 13](ch13.html#observability)). Reactive systems
    are distributed systems, and failures are inevitable. Being able to observe, detect
    issues, emit alerts, and react is essential to keep the system running and serve
    its purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Is That All?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This book did not offer a silver-bullet solution to build reactive systems.
    We have covered the principles and the building blocks to build them. But, as
    with everything in software, the ideal solutions always depend on the problem.
    We’ve showed you a toolbox, but it’s up to you to select the best tool for your
    application, assemble your system following the reactive principles, and profit.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this book, we have shown many features to implement reactive applications
    and systems with Quarkus, but we’ve only scratched the surface. Quarkus offers
    a lot more reactive features.
  prefs: []
  type: TYPE_NORMAL
- en: We explained how you can deal with HTTP in a reactive fashion. But there are
    alternatives to HTTP. gRPC, for example, is a secure, polyglot, and performant
    RPC protocol that can replace most HTTP interactions. It uses a contract-first
    approach (written using Protobuf), and supports unidirectional and bidirectional
    streams. Quarkus lets you implement gRPC services and consume them. It relies
    on the reactive engine and therefore offers excellent performance and resource
    utilization. In addition, it integrates with the Mutiny API.
  prefs: []
  type: TYPE_NORMAL
- en: We have also covered the data space, explaining how you can interact with various
    databases from within your Quarkus application. Quarkus offers reactive access
    to databases such as PostgreSQL, MySQL, Db2, SQL Server, and Oracle. Quarkus also
    provides reactive APIs to interact with many NoSQL databases such as Neo4j, Cassandra,
    Redis, and MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to build reactive systems, you often need a message broker, or a way
    to exchange messages asynchronously. In this book, we used Apache Kafka and Apache
    ActiveMQ. Quarkus offers a lot more. You can integrate with MQTT, RabbitMQ, or
    JMS. Quarkus can be combined with Apache Camel to interact with virtually any
    existing system without preventing *reactiveness*.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, Quarkus offers a complete toolbox that lets you build reactive
    applications for many contexts and use cases. You have endless possibilities.
  prefs: []
  type: TYPE_NORMAL
- en: The Future of Reactive Systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It’s impossible to predict the future with a high degree of certainty. The best
    we can do is track meaningful trends and prepare for change. The following are
    some trends that we think are important to track.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP is evolving. HTTP/3 comes with a better flow-control approach and parallel
    request transmission, improving overall communication across the system.
  prefs: []
  type: TYPE_NORMAL
- en: The use of message brokers is growing tremendously. New brokers are emerging,
    such as Apache Pulsar, NATS, and KubeMQ. The last two are built with Kubernetes
    in mind and integrate well in such an environment. Several revolutionizing projects
    are changing how to process messages and derive knowledge from event streams.
    Apache Pinot, to cite one, allows querying data coming from event streams such
    as Apache Kafka.
  prefs: []
  type: TYPE_NORMAL
- en: As in many other domains, the rise of machine learning and AI also influence
    the construction of reactive systems. Machine learning algorithms can help understand
    the system and adapt it to handle failures or peaks of demands. Already today,
    you can see Kubernetes operators collecting metrics about a system and adapting
    it to face the current workload.
  prefs: []
  type: TYPE_NORMAL
- en: At the code level, Project Loom is promising. It will drastically reduce the
    complexity of writing efficient reactive applications. Approaches to express structured
    concurrency such as Ballerina and Joli are still niched but may become more popular
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: There are many more trends. Keep an eye on the technologies that embrace the
    reactive principles we explained in this book.
  prefs: []
  type: TYPE_NORMAL
- en: The End of the Beginning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You now have all the tools to build *better* distributed systems that are more
    robust and more efficient. Quarkus, a Java stack tailored for the cloud, will
    let you embrace the reactive system paradigm smoothly, one step at a time. Go
    ahead!
  prefs: []
  type: TYPE_NORMAL
- en: We hope you enjoyed this journey. Now it’s time for you to start a new one by
    using what you’ve learned.
  prefs: []
  type: TYPE_NORMAL
