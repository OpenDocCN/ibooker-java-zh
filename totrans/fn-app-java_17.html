<html><head></head><body>
<div id="sbo-rt-content"><section data-pdf-bookmark="Chapter 15. A Functional Approach to Java" data-type="chapter" epub:type="chapter"><div class="chapter" id="_02-a-functional-mindset_v2">
<h1><span class="label">Chapter 15. </span>A Functional Approach to Java</h1>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45115212535824">
<h1>A Note for Early Release Readers</h1>
<p>With Early Release ebooks, you get books in their earliest form—the author’s raw and unedited content as they write—so you can take advantage of these technologies long before the official release of these titles.</p>
<p>This will be the 15th chapter of the final book. Please note that the GitHub repo will be made active later on.</p>
<p>If you have comments about how we might improve the content and/or examples in this book, or if you notice missing material within this chapter, please reach out to the editor at <em>rfernando@oreilly.com</em>.</p>
</div></aside>
<p>Many programming languages support both a functional and imperative code style.
However, the syntax and facilities of a language typically incentivize specific approaches to common problems.
Even with all the functional additions to the JDK discussed in this book, Java still favors imperative and object-oriented programming, with most of the core libraries’ available types and data structures reflecting this preference.</p>
<p>However, as I’ve discussed throughout this book, that doesn’t mean it has to be an “either-or” kind of situation.
You can augment your OO code with functional principals without going fully functional.
Why not have the best of both worlds?
To do so, you need to adopt a functional mindset.</p>
<p>This chapter pulls together what you’ve learned in this book so far and highlights the most important aspects that will influence your functional mindset.
It also shows a practical application of functional programming techniques on an architectural level that fits right into an object-oriented environment.</p>
<section data-pdf-bookmark="OOP Versus FP Principles" data-type="sect1"><div class="sect1" id="idm45115212531616">
<h1>OOP Versus FP Principles</h1>
<p>To better understand where functional principles can improve your code, it makes sense to revisit the underlying principles of both paradigms — object-oriented and functional — to recognize their dissimilarities and possible interconnection points.
This builds the base knowledge to identify opportunities to incorporate a functional approach into your OO code and where it doesn’t make sense to force it.</p>
<p><em>Object-oriented</em> programming’s main concerns are encapsulating data and behavior, polymorphism, and abstraction.
It’s a <em>metaphor-based</em> approach to solving problems where its objects and connecting code mimic a particular problem domain.
These objects interact by messaging through public contracts, like interfaces, and each has responsibilities and usually manages its own state.
Using such metaphors bridges the gap between the computer, which requires a set of instructions, and the developer, which can express their intent in a straightforward manner.
OOP is an excellent approach to structuring and organizing imperative code after the “real world” and its constant and endless changes.</p>
<p><em>Functional programming</em>, however, uses mathematical principles to solve problems, utilizing a <em>declarative</em> code style.
Instead of requiring a metaphor to model your code like the “real world”, its foundation — <em>lambda calculus</em> — only cares about data structures and their transformation using high-level abstractions.
Functions take an input and create an output, that’s about it!
Data and behavior aren’t encapsulated; functions and data structures <em>just are</em>.
FP circumvents many typical OOP and Java problems, like handling mutable state in a concurrent environment or unexpected side effects, by trying not to have any side effects, to begin with.</p>
<p>These two short summaries already highlight the dissimilarity of the core principles of object-oriented and functional programming.
OOP tries to tame complexity by encapsulating the moving parts of your code in a familiar domain, whereas FP strives to have fewer parts in total by adhering to mathematical principles.
The more abstract way of thinking in FP is why OOP is often the preferred first approach to teaching and learning Java.</p>
<p>As I discussed in <a data-type="xref" href="ch14.xhtml#_02-design-patterns">Chapter 14</a>, both paradigms are just divergent approaches able to solve the same problems coming from different directions.
It would be foolish to declare that one principle is, no pun intended, objectively better than the other.
Metaphors in OO are a powerful tool to make code feel more natural to non-programmers and programmers alike.
Some complex problems benefit from a good metaphorical representation way more than a maybe more concise but highly abstracted functional approach.</p>
</div></section>
<section data-pdf-bookmark="A Functional Mindset" data-type="sect1"><div class="sect1" id="idm45115212524992">
<h1>A Functional Mindset</h1>
<blockquote>
<p>Any fool can write code that a computer can understand.
Good programmers write code that humans can understand.</p>
<p data-type="attribution">Martin Fowler, <cite>Refactoring: Improving the Design of Existing Code</cite></p>
</blockquote>
<p>You can have all the functional tools available at your fingertips, but using them efficiently requires the right mindset to do so.
Having a functional mindset involves having the reasoning to identify code that could be improved with a functional approach, be it going fully functional, or just injecting a few functional techniques and principles at critical, and appropriate, places.
This mindset won’t come overnight; you have to hone it with practice to gain experience and intimation</p>
<p>Developing this functional mindset starts with wanting to eliminate or reduce any accidental complexity in your code.
The techniques and principles you use to solve your problems should lead to code that is reasonable and easier to understand.</p>
<p>To reason with a complex system means grasping and figuring out any code with only the information that’s <em>right in front of you</em> rather than relying on hidden-away implementation details or maybe outdated comments, without any surprises waiting for you.
You don’t need to look across multiple files or types to understand the problem that is solved, or don’t need to ponder about many of the decisions that went into the code itself.</p>
<p>The correctness of your code is informally proven because any claim about its functionality is backed up by its reasonability and accompanying comments.
Anyone using such code can make strong assumptions about it and rely on its public contracts.
The opaque nature of OOP and its encapsulation of behavior and data often makes it harder to reason with than alternative approaches.</p>
<p>Let’s revisit the different aspects of functional programming that will influence your decision when to apply a functional approach.</p>
<section data-pdf-bookmark="Functions are First-Class Citizens" data-type="sect2"><div class="sect2" id="idm45115212519056">
<h2>Functions are First-Class Citizens</h2>
<p>Functional programming is all about functions and their <em>first-class citizenship</em>.
That means that functions are tantamount to other constructs of the language because you can:</p>
<ul>
<li>
<p>Assign functions to variables</p>
</li>
<li>
<p>Pass functions as arguments to another function/method</p>
</li>
<li>
<p>Return a function from a function/method</p>
</li>
<li>
<p>Create anonymous functions without a name</p>
</li>
</ul>
<p>These properties are pretty similar to how anonymous classes are usable in Java, even before the introduction of lambda expressions.
Unlike anonymous classes, though, functional interfaces — Java’s representation of the concept of functions — are conceptionally more generalized and usually detached from an explicit class or domain type.
Furthermore, the JVM uses them differently thanks to the <code>invokedynamic</code> opcode, as explained in <a data-type="xref" href="ch02.xhtml#_01-functional-java_invokedynamic">“The <code>invokedynamic</code> Instruction”</a>, which allows for a greater variety of optimizations compared to anonymous classes.</p>
<p>Even though Java doesn’t have “on the fly” types and requires any lambda expression to be represented by concrete functional interfaces, it still manages to allow you to use one of the big differentiators between OO and FP because it provides a higher level of abstraction.
Functional abstractions are on a higher level than their OO counterparts.
That means that FP focuses on values instead of discrete domain-specific types with rigid data structures.</p>
<p>Think of functions and their higher level of abstraction as small cogs in a machine.
Object-oriented cogs are bigger and specifically designed for a narrower scope of tasks; they only fit into specific parts of the machine.
The smaller functional cogs, however, are more uniform and generalized, and therefore, easier to use throughout the machine.
They can then be composed into groups, going from a singular simple task toward a complex and more complete one.
The bigger task is the sum of all its smaller parts, with the parts themselves being as small and generic as possible, reusable, and easily testable.
This way, you can build a library of reusable functions to be composed as necessary.</p>
<p>Still, Java’s dependence on functional interfaces to represent functions and lambdas is both a blessing and a curse.</p>
<p>It’s a curse because you can’t have a detached lambda that’s only based on its arguments and return type without a corresponding functional interface.
Type inference eases the pain but at some point, the actual type must be available for the compiler to infer the type down the line.</p>
<p>It’s also a blessing because it’s the perfect way of bridging between Java’s static type system and the predominantly imperative object-oriented code style and a new way of thinking without breaking backward compatibility.</p>
</div></section>
<section data-pdf-bookmark="Avoiding Side Effects" data-type="sect2"><div class="sect2" id="idm45115212509024">
<h2>Avoiding Side Effects</h2>
<blockquote>
<p>Asking a question shouldn’t change the answer.</p>
<p data-type="attribution">Bertrand Meyer, <cite>French academic</cite></p>
</blockquote>
<p>Having a functional mindset also involves avoiding side effects.
From a functional point of view, side effects refer to the modification of any kind of state which can have many forms.
It doesn’t have to be hidden or unexpected, quite the contrary.
Many forms of side effects, like accessing a database, or doing any kind of I/O, are intended actions and are a crucial part of almost every system.
Nevertheless, fewer side effects usually mean fewer surprises in your code and a smaller bug surface.</p>
<p>There are several functional ways to reduce the number of side effects, or at least make them more manageable.</p>
<section data-pdf-bookmark="Pure Functions" data-type="sect3"><div class="sect3" id="idm45115212504912">
<h3>Pure Functions</h3>
<p>The most basic approach to avoid side effects is using the functional programming concept of <em>pure functions</em> because they rely on two elemental guarantees:</p>
<ul>
<li>
<p>The same input will <em>always</em> create the same output.</p>
</li>
<li>
<p>Pure functions are <em>self-contained</em> without any side effects.</p>
</li>
</ul>
<p>Seems simple enough.</p>
<p>In reality, however, there are more aspects you have to look out for when improving the purity of your Java code.</p>
<p>Any pure function can only rely on the declared input arguments to produce its result.
Any hidden state or invisible dependencies are a big no-no.</p>
<p>Think of a function that creates a greeting for a <code>User</code> instance with a method signature as follows:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="n">String</code> <code class="nf">buildGreeting</code><code class="p">(</code><code class="n">User</code> <code class="n">user</code><code class="p">)</code></pre>
<p>The method signature, its public contract, discloses a singular dependency: the <code>User</code> argument.
If you don’t know the actual implementation, it would be safe to assume that this is a pure function that produces the same salutation for repeated calls with the same user.</p>
<p>Let’s take a look at its implementation:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="n">String</code> <code class="nf">buildGreeting</code><code class="p">(</code><code class="n">User</code> <code class="n">user</code><code class="p">)</code> <code class="p">{</code>
  <code class="n">String</code> <code class="n">greeting</code><code class="p">;</code>
  <code class="k">if</code> <code class="p">(</code><code class="n">LocalTime</code><code class="p">.</code><code class="na">now</code><code class="p">().</code><code class="na">getHour</code><code class="p">()</code> <code class="o">&lt;</code> <code class="mi">12</code><code class="p">)</code> <code class="p">{</code>
    <code class="n">greeting</code> <code class="o">=</code> <code class="s">"Good morning"</code><code class="p">;</code>
  <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>
    <code class="n">greeting</code> <code class="o">=</code> <code class="s">"Hello"</code>
  <code class="p">}</code>

  <code class="k">return</code> <code class="n">String</code><code class="p">.</code><code class="na">format</code><code class="p">(</code><code class="s">"%s, %s"</code><code class="p">,</code> <code class="n">greeting</code><code class="p">,</code> <code class="n">user</code><code class="p">.</code><code class="na">name</code><code class="p">());</code>
<code class="p">}</code></pre>
<p>Checking out the implementation, however, a second dependency reveals itself: the time of day.
This invisible dependency that relies on an out-of-context state makes the whole method impure.</p>
<p>To regain purity, the second internal dependency must be made part of the public contract instead:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="n">String</code> <code class="nf">buildGreeting</code><code class="p">(</code><code class="n">User</code> <code class="n">user</code><code class="p">,</code> <code class="n">LocalTime</code> <code class="n">time</code><code class="p">)</code></pre>
<p>Purity is restored and the public contract no longer hides the internal dependency on the time of day and communicates it clearly, without requiring any documentation.</p>
<p>The method signature could still be simplified further.
Why bind the method to the <code>User</code> type if only its <code>name</code> is used?
Why use <code>LocalTime</code> if only its hour is used?
Creating a more versatile <code>buildGreeting</code> method would accept only the <code>name</code> and not a whole <code>User</code> instance.</p>
<p>The lowest common denominator of arguments will give the most versatile and broadly applicate pure function possible.
Try to avoid nested calls to broaden the applicability of a method by going closer to the actual required value instead of relying on specific domain types.</p>
<p>The best way to think about pure functions is to see them totally isolated in their own space-time continuum detached from the rest of the system.
That’s why they need to receive all of their requirements explicitly as values, preferably with as few intermediate objects as possible.
However, such a higher abstraction forfeits some of the method signature’s expressiveness, so you must find an acceptable balance.</p>
<p>Pure functions are a cornerstone of functional programming.
Reducing a task to “same input + processing → same output” makes method signatures more meaningful and easier to comprehend.</p>
</div></section>
<section data-pdf-bookmark="Pure Object Methods" data-type="sect3"><div class="sect3" id="idm45115212504288">
<h3>Pure Object Methods</h3>
<p>Pure functions only exist within their own context which is why they can only rely on their input arguments to create their output.
Translating this principle into an object-oriented environment is a little bit more difficult.</p>
<p>Looking deeper at the two guarantees of pure functions from the point of view of an object-oriented programmer, they reveal the possibility of applying them in a broader sense to create a more hybrid approach I call <em>pure object methods</em>.</p>
<p>If a method on an object type is truly <em>pure</em> in the previously discussed sense, it could be made <code>static</code> and doesn’t even need to be in the object type anymore.
Still, binding methods to their related type that’s a part of their input is an advantage and won’t go away anytime soon.</p>
<p>Take the <code>buildGreeting</code> method from the previous section as an example.
Even though it can be made a pure function in the form of a <code>static</code> method, adding it directly to the <code>User</code> type as an instance method makes sense.
However, this will harm reusability because it doesn’t exist in complete isolation anymore and is interconnected with its surrounding type itself.
This relationship doesn’t mean it can’t be “as pure as possible,” though.</p>
<p>As good object types do, the <code>User</code> type encapsulates its state and creates its own microcosmos mostly disconnected from the outside.
A <em>pure object method</em> might access that microcosmos and treat them as additional input arguments.
The main caveat, though, is the non-reusable nature of methods bound to specific types.</p>
<p>Other multi-paradigm languages supporting an object-oriented programming style, like Python, make this approach more visible, as the following code shows:</p>
<pre class="pagebreak-before" data-code-language="python" data-type="programlisting"><code class="k">class</code> <code class="nc">User</code><code class="p">:</code>

  <code class="n">name</code> <code class="o">=</code> <code class="s1">''</code>

  <code class="k">def</code> <code class="fm">__init__</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code> <code class="n">name</code><code class="p">):</code>
    <code class="bp">self</code><code class="o">.</code><code class="n">name</code> <code class="o">=</code> <code class="n">name</code>

  <code class="k">def</code> <code class="nf">buildGreeting</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code> <code class="n">time</code><code class="p">):</code>
    <code class="c1"># ...</code></pre>
<p>Using <code>self</code> — Python’s equivalent to Java’s <code>this</code> — as an explicit input parameter on each method highlights the interdependence between the method on the instance itself.
Even if an object’s method affects its state, it can still be a “pure object method” as it doesn’t have any side effects besides its internal state.
The object itself becomes part of the input, as it encapsulates the side effect, and its state after the call makes them the output.</p>
<p>The functional design principles of pure functions are still useful if you have to deal with object types and can’t refactor them to a new design.
The same rules apply, but the object state counts as an input argument.
That’s why further dependencies like <code>time</code> in <code>buildGreeting</code> shouldn’t be hidden away from anyone using the method.
Calling the same method with the same input on two identical objects should result in an equal output or new object state.</p>
<p>Pure object methods might not bring in all the advantages of a fully functional approach with pure functions and immutable data structures, especially regarding reusability.
Still, the functional mindset injected into the object-oriented style gives you more approachable, safer, more predictable, and therefore, more reasonable types.</p>
</div></section>
<section data-pdf-bookmark="Isolating with Side Effects" data-type="sect3"><div class="sect3" id="idm45115212322416">
<h3>Isolating with Side Effects</h3>
<p>It’s impossible to write applications with absolutely zero side effects.
OOP, or imperative code in general, is usually intertwined with mutable states and side effects.
Still, side effects affecting your state are often invisible at the surface, easily breaking the reasonability of code and introducing subtle bugs if used incorrectly.
If you can’t completely avoid a side effect with techniques such as <em>pure functions</em>, they should be <em>isolated</em>, preferably on the edges of your logical units, instead of littering them throughout the code.
By splitting bigger units of code into smaller tasks, the possible side effects will be restricted to and affect only some of the tasks and not the overall unit.</p>
<p>This mindset is also present in the <em>Unix philosophy</em>, originated by Ken Thompson, the co-creator of the UNIX operating system.
Doug McIlroy — head of the Bell Labs Computing Sciences Research Center at the time and inventor of the <em>Unix pipe</em> — summarized<sup><a data-type="noteref" href="ch15.xhtml#idm45115212232256" id="idm45115212232256-marker">1</a></sup> it as such:</p>
<blockquote>
<p>Write programs that do one thing and do it well.
Write programs to work together.</p>
<p data-type="attribution">Doug McIlroy</p>
</blockquote>
<p>Transferring this philosophy to a functional approach means that functions should strive to do one thing only and do it well without affecting their environment.
Design your functions to be as small as possible but as large as necessary.
A complex task is better served by multiple composed functions that preserve pureness as long as possible than a bigger function that is impure from the start.</p>
<p>I/O is a classical case of side effects.
Loading files, talking a database, etc., are impure operations and should therefore be separated from pure functions.
To encapsulate a side effect you must think about the seams between the actual side effect and the processing of its result.
Instead of loading a file and processing its content as a singular operation, it’s better two separate them into the side effect of loading a file, and processing the actual data, as illustrated in <a data-type="xref" href="#_02-functional-mindset_side-effects_separation">Figure 15-1</a>.</p>
<figure><div class="figure" id="_02-functional-mindset_side-effects_separation">
<img alt="Splitting operations into discrete functions" height="435" src="assets/afaj_1501.png" width="600"/>
<h6><span class="label">Figure 15-1. </span>Splitting operations into discrete functions</h6>
</div></figure>
<p>The data processing is no longer bound to the file loading, or files in general, rather than only processing the incoming data.
This makes the operation a pure and reusable function, with the side effect restricted to the <code>loadFile</code> method, with the returned <code>Optional&lt;String&gt;</code> giving you a functional bridge to it.</p>
<p>If side effects can’t be avoided, split up the task into smaller and preferably pure functions to isolate and encapsulate any remaining side effects.</p>
</div></section>
<section data-pdf-bookmark="Favor Expression Over Statements" data-type="sect3"><div class="sect3" id="idm45115212224832">
<h3>Favor Expression Over Statements</h3>
<p>As discussed in <a data-type="xref" href="ch01.xhtml#_01-an-introduction">Chapter 1</a>, a key differentiator separator between an object-oriented and a functional approach is the prevalence of either statements and expressions.
To recapitulate, statements perform actions, like assigning a variable or control statements, and are therefore literal side effects.
Expressions, on the other hand, evaluate their input to <em>just</em> yield output.</p>
<p>If you want to reduce side effects, using expressions leads to safer and more reasonable code, based on the following rationale:</p>
<ul>
<li>
<p>Pure expressions, like pure functions, don’t have any side effects.</p>
</li>
<li>
<p>Expressions are (mostly) definable in code; the types of available statements are predefined by the language.</p>
</li>
<li>
<p>Evaluating pure expressions multiple times will yield the same output, ensuring predictability and enabling certain caching techniques, such as <em>memoization</em>.</p>
</li>
<li>
<p>Expressions can be small to remain pure and still be composed with other expressions to solve a bigger task.</p>
</li>
</ul>
<p>The control flow <code>if</code>-<code>else</code> statements are often a good candidate for replacing it with a more functional approach, especially to assign variables or create.
The previous <code>buildGreeting</code> method becomes more concise and straightforward by using the ternary operator for the pretty simplistic decision of which greeting to choose, as seen as follows:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="n">String</code> <code class="nf">buildGreeting</code><code class="p">(</code><code class="n">User</code> <code class="n">user</code><code class="p">,</code> <code class="n">LocalTime</code> <code class="n">time</code><code class="p">)</code> <code class="p">{</code>

  <code class="n">String</code> <code class="n">greeting</code> <code class="o">=</code> <code class="n">time</code><code class="p">.</code><code class="na">getHour</code><code class="p">()</code> <code class="o">&lt;</code> <code class="mi">12</code> <code class="o">?</code> <code class="s">"Good Morning"</code>
                                        <code class="p">:</code> <code class="s">"Hello"</code><code class="p">;</code>

  <code class="k">return</code> <code class="n">String</code><code class="p">.</code><code class="na">format</code><code class="p">(</code><code class="s">"%s, %s"</code><code class="p">,</code> <code class="n">greeting</code><code class="p">,</code> <code class="n">user</code><code class="p">.</code><code class="na">name</code><code class="p">());</code>
<code class="p">}</code></pre>
<p>The ternary operator gives you two other advantages.</p>
<p>First, the variable <code>greeting</code> is declared and initialized in a single expression instead of it being uninitialized outside of the <code>if</code>-<code>else</code>-block.</p>
<p>Second, the variable is effectively <code>final</code>.
In this particular case, it doesn’t matter.
Still, there having a variable that can be easily used in a lambda expression is better than requiring you to refactor your code when you eventually need a variable to be effectively <code>final</code>.</p>
<p>Breaking down complex statement lists and blocks into smaller expressions makes code more concise and easier to reason with, plus the added benefit of effectively <code>final</code> variables, which is as you may remember from earlier chapters a non-negotiable requirement for using variables in lambda expressions.</p>
<p>Expressions are often preferable over statements because they are a combination of values and functions intended to create a new value.
They’re usually more compact and isolated than statements, making them safer to use.
Statements, on the other hand, are more of a standalone unit to execute a side effect.</p>
</div></section>
<section data-pdf-bookmark="Moving Towards Immutability" data-type="sect3"><div class="sect3" id="_02-functional-architecture_prefer-immutability">
<h3>Moving Towards Immutability</h3>
<blockquote>
<p>If it is not necessary to change, it is necessary not to change.</p>
<p data-type="attribution">Lucius Cary, <cite>2nd Viscount Falkland</cite></p>
</blockquote>
<p>Another way to avoid unintended change, thus side effects and potential bugs, is to embrace <em>immutability</em> whenever possible and sensible.
Even without utilizing any other functional principles, your codebase will become more robust thanks to immutability by eliminating the source of way too many bugs: <em>unintented change</em>.</p>
<p>To prevent any unforeseen mutations, immutability should be the default approach to any type and collections used in your programs, especially in concurrent environments, as discussed more deeply in <a data-type="xref" href="ch04.xhtml#_02-data-structures">Chapter 4</a>.
You don’t have to reinvent the wheel for many use cases, as the JDK provides you with multiple options for immutable data structures:</p>
<dl>
<dt>Immutable Collections</dt>
<dd>
<p>Even though Java doesn’t provide “fully” immutable collection types, it still has structurally immutable ones where you can’t add or remove elements.
The concept of <em>unmodifiable</em> views of Collections was expanded in Java 9 by <code>static</code> factory methods like <code>List.of</code> to easily create structurally immutable Collections, as discussed in <a data-type="xref" href="#_02-functional-architecture_prefer-immutability">“Moving Towards Immutability”</a>.</p>
</dd>
<dt>Immutable Math</dt>
<dd>
<p>The package <code>java.math</code> and its two immutable arbitrary-precision types, <code>BigInteger</code> and <code>BigDecimal</code>, are safe and immutable options for doing high-precision calculations.</p>
</dd>
<dt>Records (<a href="https://openjdk.java.net/jeps/395">JEP 395</a>)</dt>
<dd>
<p>Introduced as a preview feature in Java 14 and refined in 15, Records provide a completely new data structure as an easy-to-use data aggregation type.
They’re a great alternative for POJOs and sometimes Java Beans, or you could use them as small, localized immutable data holders, as discussed in <a data-type="xref" href="ch05.xhtml#_02-records">Chapter 5</a>.</p>
</dd>
<dt>Java Date and Time API (<a href="https://jcp.org/en/jsr/detail?id=310">JSR-310</a>)</dt>
<dd>
<p>Java 8 also introduced a new way to store and manipulate dates and times with immutable types from the ground up.
The API gives you a fluent, explicit, and straightforward way of dealing with anything related to date and time.</p>
</dd>
</dl>
<p>As you can see, more and more Java APIs are built on are at least improving their support for immutability, and so should you.
Designing your data structures and code with immutability in mind from the get-go saves you a lot of headaches in the long run.
No more worrying about unintended or unexpected changes, and no more worries about thread safety in concurrent environments.</p>
<p>However, one thing to remember, is that immutability is suited best for, well, immutable data.
Creating a new immutable data structure for any change becomes cumbersome really quickly regarding the required code and memory consumption by all those new objects.</p>
<p>Immutability is one of the most important aspects you can introduce into your codebase, regardless of a functional approach.
An “immutable first” mindset, gives you safer and more reasonable data structures.
Still, your usual modus operandi might not fit into the new challenges that data management with immutability incurs.
Remember though, it’s easier to (partially) break immutability if there’s no other option available than to retroactively tack-on immutability in a mature code base.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="Functional Data Processing with Map-Filter-Reduce" data-type="sect2"><div class="sect2" id="idm45115212096208">
<h2>Functional Data Processing with Map-Filter-Reduce</h2>
<p>Most data problems boil down to iterating over a sequence of elements, choosing the correct one, maybe manipulating them, performing an action, or gathering them into a new data structure.
The following example — iterating over a list of users, filtering the correct ones, and notifying them — is a typical example of these basic steps:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">List</code><code class="o">&lt;</code><code class="n">User</code><code class="o">&gt;</code> <code class="n">usersToNotify</code> <code class="o">=</code> <code class="k">new</code> <code class="n">ArrayList</code><code class="o">&lt;&gt;</code><code class="p">();</code>

<code class="k">for</code> <code class="p">(</code><code class="kd">var</code> <code class="n">users</code> <code class="p">:</code> <code class="n">availableUsers</code><code class="p">)</code> <code class="p">{</code>
  <code class="k">if</code> <code class="p">(</code><code class="n">user</code><code class="p">.</code><code class="na">hasValidSubscription</code><code class="p">())</code> <code class="p">{</code>
    <code class="k">continue</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="n">usersToNotify</code><code class="p">.</code><code class="na">add</code><code class="p">(</code><code class="n">user</code><code class="p">);</code>
<code class="p">}</code>

<code class="n">notify</code><code class="p">(</code><code class="n">usersToNotify</code><code class="p">);</code></pre>
<p>Such problems are a perfect match for a functional approach with Streams and <em>map-filter-reduce</em>, as discussed in <a data-type="xref" href="ch06.xhtml#_02-data-processing_map-filter-reduce">“Map/Filter/Reduce”</a>.</p>
<p>Instead of explicitly iterating over the users with a <code>for</code>-loop and collecting the correct elements in a previously defined <code>List</code>, a Stream pipeline does the whole task in a fluent, declarative call:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">List</code><code class="o">&lt;</code><code class="n">User</code><code class="o">&gt;</code> <code class="n">usersToNotify</code> <code class="o">=</code> <code class="n">availableUsers</code><code class="p">.</code><code class="na">stream</code><code class="p">()</code>
                                         <code class="p">.</code><code class="na">filter</code><code class="p">(</code><code class="n">User</code><code class="p">::</code><code class="n">hasValidSubscription</code><code class="p">)</code>
                                         <code class="p">.</code><code class="na">toList</code><code class="p">();</code>

<code class="n">notify</code><code class="p">(</code><code class="n">usersToNotify</code><code class="p">);</code></pre>
<p>Stream pipelines express <em>what</em> to do without the boilerplate of <em>how</em> to iterate over the elements.
They are a perfect scaffold for converting statement-based data filtering and transformation to a functional pipeline.
The fluent call concisely describes the steps necessary to solve the problem, especially if you use method references or method calls returning the required functional interface.</p>
</div></section>
<section data-pdf-bookmark="Abstractions Guide Implementations" data-type="sect2"><div class="sect2" id="idm45115211939648">
<h2>Abstractions Guide Implementations</h2>
<p>Every project is built upon abstractions designed after the requirements.</p>
<p><em>Object-oriented</em> design uses low-level abstractions in the form of powerful metaphors, defining the characteristics and constraints of a system.
This domain-based approach is quite expressive and powerful but also restricts the versatility of types and how easy it is to introduce change.
As requirements usually change over time, too restrictive abstractions lead to misalignment between different parts of your systems.
Misaligned abstractions create friction and subtle bugs and might require a lot of work to realign.</p>
<p><em>Functional programming</em> tries to avoid misaligned abstractions by using higher abstractions not bound to a specific domain.
<a data-type="xref" href="ch14.xhtml#_02-design-patterns">Chapter 14</a> reflects that by almost unconditionally replacing commonly used object-oriented abstractions with generalized functional interfaces of the JDK instead.
This decoupling of abstractions from the original problem context creates simpler and easy-to-reuse components that are combined and mixed as necessary, enabling easier change of any functional system.</p>
<p>Object-oriented and imperative code is a good match for encapsulating functionality, object-state, and representing a problem domain.
Functional concepts are an excellent choice for implementation logic and higher-level abstractions.
Not every data structure must be represented in the problem domain, so using more versatile functional types instead creates reusable and broader types that are driven by their use cases instead of the domain concept.</p>
<p>To resolve this problem, you must find a balance between the two levels of abstraction if you want to use both in the same system.
In <a data-type="xref" href="#_02-functional-mindeset_functional-architecture">“Functional Architecture in an Imperative World”</a>, I discuss how to combine both as an architectural decision that gives the benefits of high-level functional abstractions wrapped in a familiar imperative layer.</p>
</div></section>
<section data-pdf-bookmark="Building Functional Bridges" data-type="sect2"><div class="sect2" id="idm45115211932992">
<h2>Building Functional Bridges</h2>
<p>A functional approach means your code most likely lives in an imperative and object-oriented environment that needs to work hand-in-hand with any functional technique or concept you want to integrate.
Later in this chapter, in <a data-type="xref" href="#_02-functional-mindeset_functional-architecture">“Functional Architecture in an Imperative World”</a>, I will discuss how to integrate functional code into an imperative environment.</p>
<p>But first, let’s look at how to bridge the gap between your existing code to the new functional APIs.</p>
<section data-pdf-bookmark="Method References-Friendly Signatures" data-type="sect3"><div class="sect3" id="idm45115211930256">
<h3>Method References-Friendly Signatures</h3>
<p>Every method, <code>static</code> or not, and any constructor is a potential method reference to be used in higher-order functions or represented by a functional interface.
That’s why it can make sense to design your APIs with other functional APIs in mind.</p>
<p>For example, the commonly used Stream operations <code>map</code>, <code>filter</code>, and <code>sort</code> accept a <code>Function&lt;T, R&gt;</code>, <code>Predicate&lt;T&gt;</code>, and <code>Comparator&lt;T&gt;</code>, respectively, that translate well into simple method signatures.</p>
<p>Look at the required functional interface’s SAM; it’s the blueprint for the required method signature.
As long as the input arguments and the return type match, you can name your method any way you want.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>One exception to simply mapping a SAM signature to a method reference is unbound non-<code>static</code> method reference.
As the method is referenced via the type itself and isn’t bound to a specific instance, the underlying lambda expression accepts the type as its first argument.</p>
<p>For example, <code>String::toLowerCase</code> accepts a <code>String</code> and returns a <code>String</code>, and is, therefore, a <code>Function&lt;String, String&gt;</code>, despite <code>toLowerCase</code> not having any arguments.</p>
</div>
<p>When designing any API, it makes sense to think about how it might be used by functional API and provide method reference-friendly signatures.
Your methods still have expressive names depending on their surrounding context, but also build a bridge to functional API with simple method references.</p>
</div></section>
<section data-pdf-bookmark="Using Retroactive Functional Interfaces" data-type="sect3"><div class="sect3" id="idm45115211920160">
<h3>Using Retroactive Functional Interfaces</h3>
<p>Functional interfaces usually have marked with the <code>@FunctionalInterface</code> annotation.
Still, as long as they fulfill the general requirements, as explained in <a data-type="xref" href="ch02.xhtml#_01-functions_functional-interfaces">“Functional Interfaces”</a>, an interface is automatically a functional interface.
Therefore, already existing code can benefit from the conciseness of lambdas and method references, and their
specialized handling by the JVM.</p>
<p>Many longstanding interfaces of the JDK are now marked with <code>@FunctionaInterface</code>, but your code might not have adapted yet and benefit from these changes.
The following “now functional” interfaces were widely used even before Java 8:</p>
<ul>
<li>
<p><code>java.lang.Comparable&lt;T&gt;</code></p>
</li>
<li>
<p><code>java.lang.Runnable</code></p>
</li>
<li>
<p><code>java.util.Comparator&lt;T&gt;</code></p>
</li>
<li>
<p><code>java.util.concurrent.Callable&lt;V&gt;</code></p>
</li>
</ul>
<p>For example, before lambdas, sorting a Collection was quite a handful because of all the boilerplate code:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">users</code><code class="p">.</code><code class="na">sort</code><code class="p">(</code><code class="k">new</code> <code class="n">Comparator</code><code class="o">&lt;</code><code class="n">User</code><code class="o">&gt;</code><code class="p">()</code> <code class="p">{</code>

  <code class="nd">@Override</code>
  <code class="kd">public</code> <code class="kt">int</code> <code class="nf">compare</code><code class="p">(</code><code class="n">User</code> <code class="n">lhs</code><code class="p">,</code> <code class="n">User</code> <code class="n">rhs</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="n">lhs</code><code class="p">.</code><code class="na">email</code><code class="p">().</code><code class="na">compareTo</code><code class="p">(</code><code class="n">rhs</code><code class="p">.</code><code class="na">email</code><code class="p">());</code>
  <code class="p">}</code>
<code class="p">});</code></pre>
<p>The lambda variant tames the boilerplate quite a bit:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">users</code><code class="p">.</code><code class="na">sort</code><code class="p">((</code><code class="n">lhs</code><code class="p">,</code> <code class="n">rhs</code><code class="p">)</code> <code class="o">-&gt;</code> <code class="n">lhs</code><code class="p">.</code><code class="na">email</code><code class="p">().</code><code class="na">compareTo</code><code class="p">(</code><code class="n">rhs</code><code class="p">.</code><code class="na">email</code><code class="p">()));</code></pre>
<p>But why stop here?
If you check out the functional interface <code>Comparator&lt;T&gt;</code>, you will find <code>static</code> and non-<code>static</code> helper methods to make the overall call even more concise without losing any expressiveness:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">users</code><code class="p">.</code><code class="na">sort</code><code class="p">(</code><code class="n">Comparator</code><code class="p">.</code><code class="na">comparing</code><code class="p">(</code><code class="n">User</code><code class="p">::</code><code class="n">email</code><code class="p">));</code></pre>
<p>Java 8 not only introduced new functional interfaces but improved existing interfaces so they fit nicely into the new APIs with lots of <code>default</code> and <code>static</code> methods.
Always check out the non-SAM methods available in functional interfaces to find hidden gems to simplify your code with functional composition, or common tasks that can be condensed into a declarative call chain.</p>
</div></section>
<section data-pdf-bookmark="Lambda Factories for Common Operations" data-type="sect3"><div class="sect3" id="idm45115211788112">
<h3>Lambda Factories for Common Operations</h3>
<p>Designing your APIs to match other functional APIs so you can use method references isn’t always a possibility.
That doesn’t mean that you can provide lambda factories to simplify the use of higher-order functions, though.</p>
<p>For example, if a method doesn’t match a particular functional interface, because it requires additional arguments, you can use <em>partial application</em> to make it fit the method signature of a higher-order function.</p>
<p>Image a <code>ProductCategory</code> type that has a method for a localized description as follows:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">class</code> <code class="nc">ProductCategory</code> <code class="p">{</code>

  <code class="kd">public</code> <code class="n">String</code> <code class="nf">localizedDescription</code><code class="p">(</code><code class="n">Locale</code> <code class="n">locale</code><code class="p">)</code> <code class="p">{</code>
    <code class="c1">// ...</code>
  <code class="p">}</code>
<code class="p">}</code></pre>
<p>The method is representable by a <code>BiFunction&lt;ProductCategory, Locale, String&gt;</code>, so you can’t use it for the Stream’s <code>map</code> operation and have to rely on a lambda expression:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">var</code> <code class="n">locale</code> <code class="o">=</code> <code class="n">Locale</code><code class="p">.</code><code class="na">GERMAN</code><code class="p">;</code>

<code class="n">List</code><code class="o">&lt;</code><code class="n">ProductCategory</code><code class="o">&gt;</code> <code class="n">categories</code> <code class="o">=</code> <code class="p">...;</code>

<code class="n">categories</code><code class="p">.</code><code class="na">stream</code><code class="p">()</code>
          <code class="p">.</code><code class="na">map</code><code class="p">(</code><code class="n">category</code> <code class="o">-&gt;</code> <code class="n">category</code><code class="p">.</code><code class="na">localizedDescription</code><code class="p">(</code><code class="n">locale</code><code class="p">))</code>
          <code class="p">...;</code></pre>
<p>Adding a <code>static</code> helper to <code>ProductCategory</code> that accepts a <code>Locale</code> and returns a <code>Function&lt;ProductCategory, String&gt;</code> allows you to use it instead of creating a lambda expression:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">class</code> <code class="nc">ProductCategory</code> <code class="p">{</code>

  <code class="kd">public</code> <code class="kd">static</code> <code class="n">Function</code><code class="o">&lt;</code><code class="n">ProductCategory</code><code class="p">,</code> <code class="n">String</code><code class="o">&gt;</code>
                <code class="nf">localizedDescriptionMapper</code><code class="p">(</code><code class="n">Locale</code> <code class="n">locale</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="n">category</code> <code class="o">-&gt;</code> <code class="n">category</code><code class="p">.</code><code class="na">localizedDescription</code><code class="p">(</code><code class="n">locale</code><code class="p">);</code>
  <code class="p">}</code>

  <code class="c1">// ...</code>
<code class="p">}</code></pre>
<p>This way, the <code>ProductCategory</code> is still responsible for creating a localized mapper function that it expects.
However, the call is simpler, and reusable, as follows:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">categories</code><code class="p">.</code><code class="na">stream</code><code class="p">()</code>
          <code class="p">.</code><code class="na">map</code><code class="p">(</code><code class="n">ProductCategory</code><code class="p">.</code><code class="na">localizedDescriptionMapper</code><code class="p">(</code><code class="n">locale</code><code class="p">))</code>
          <code class="p">...;</code></pre>
<p>Providing lambda operations for common operations by binding factory methods to their related type gives you a pre-defined set of intended tasks and saves the caller the repetitive creation of identical lambda expressions.</p>
</div></section>
<section data-pdf-bookmark="Implementing Functional Interfaces Explicitly" data-type="sect3"><div class="sect3" id="idm45115211757184">
<h3>Implementing Functional Interfaces Explicitly</h3>
<p>The most common functional interfaces, discussed in <a data-type="xref" href="ch03.xhtml#_01-functions_the-big-four">“The Big Four Functional Interface Categories”</a>, go a long way before you need to create your own specialized types, especially if you include multi-arity variants.
Still, creating your own functional interfaces has a big advantage: a more expressive domain.</p>
<p>Looking at an argument or return type alone, a <code>Function&lt;Path, Path&gt;</code> could represent anything.
A type named <code>VideoConvertJob</code>, however, tells you exactly what’s going on.
To use such a type in a functional approach, though, it has to be a functional interface.
Instead of creating a new and isolated functional interface, you should extend an existing one:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">interface</code> <code class="nc">VideoConverterJob</code> <code class="kd">extends</code> <code class="n">Function</code><code class="o">&lt;</code><code class="n">Path</code><code class="p">,</code> <code class="n">Path</code><code class="o">&gt;</code> <code class="p">{</code>
  <code class="c1">// ...</code>
<code class="p">}</code></pre>
<p>By choosing an existing functional interface as the baseline, your specialized variant is now compatible with <code>Function&lt;Path, Path&gt;</code> and inherits the two <code>default</code> methods <code>andThen</code> and <code>compose</code> to support functional composition out-of-the-box.
The custom variant narrows down the domain and is compatible with its ancestor.
Extending an existing interface also inherits the SAM signature.</p>
<p>To improve the domain even further, you could add a <code>default</code> method to create an expressive API:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">interface</code> <code class="nc">VideoConverterJob</code> <code class="kd">extends</code> <code class="n">Function</code><code class="o">&lt;</code><code class="n">Path</code><code class="p">,</code> <code class="n">Path</code><code class="o">&gt;</code> <code class="p">{</code>

  <code class="n">Path</code> <code class="nf">convert</code><code class="p">(</code><code class="n">Path</code> <code class="n">sourceFile</code><code class="p">);</code>

  <code class="k">default</code> <code class="n">Path</code> <code class="nf">apply</code><code class="p">(</code><code class="n">Path</code> <code class="n">sourceFile</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="n">convert</code><code class="p">(</code><code class="n">sourceFile</code><code class="p">);</code>
  <code class="p">}</code>

  <code class="c1">// ...</code>
<code class="p">}</code></pre>
<p>Adding a <code>default</code> method to implement a SAM is also the approach to make an existing interface conform to a functional interface without changing the original public contract, except for the additional functionality provided by the functional interface.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45115211362992">
<h1>Compatibility of Functional Interfaces</h1>
<p>Designing APIs using types that extend functional interfaces requires some considerations due to Java’s inheritance rules.
Even though both interfaces are structurally equal concerning <code>Function&lt;Path, Path&gt;</code> compatibility, the types aren’t interchangeable.</p>
<p><code>VideoConverterJob</code> is a <code>Function&lt;Path, Path&gt;</code> by definition and, therefore, usable wherever an argument requires a <code>Function&lt;Path, Path&gt;</code>.
<code>Function&lt;Path, Path&gt;</code>, on the other hand, can’t be used for an argument of type <code>VideoConverterJob</code>.</p>
<p>Therefore, a simple rule to follow when using types that extend functional interfaces in method signatures: always return a type as specific as possible, in this case, <code>VideoConverterJob</code>, but accept only a type as distinct as necessary, like <code>Function&lt;Path, Path&gt;</code></p>
</div></aside>
<p>Making your interfaces extend a functional interface, or letting your classes explicitly implement a functional interface bridges between existing types and higher-order functions.
There are still considerations to be made to satisfy Java’s type hierarchy rules, but accepting the least common denominator as input and returning the most specific type possible is a good rule of thumb.</p>
</div></section>
<section data-pdf-bookmark="Functional null Handling with Optionals" data-type="sect3"><div class="sect3" id="idm45115211504160">
<h3>Functional null Handling with Optionals</h3>
<p>Optionals are an elegant way to deal with (possible) <code>null</code> values.
That alone is a big plus in many scenarios.
Another one of its advantages is its capability to provide a functional starting point between a possible <code>null</code> value and subsequent operations.</p>
<p>Where a <code>null</code> reference was previously a dead end requiring additional code to not explode with a <code>NullPointException</code>, an Optional gives you a declarative pipeline replacing the usual boilerplate required to handle <code>null</code> values:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="n">Optional</code><code class="o">&lt;</code><code class="n">User</code><code class="o">&gt;</code> <code class="nf">tryLoadUser</code><code class="p">(</code><code class="kt">long</code> <code class="n">id</code><code class="p">)</code> <code class="p">{</code>
  <code class="c1">// ...</code>
<code class="p">}</code>

<code class="kt">boolean</code> <code class="n">isAdminUser</code> <code class="o">=</code>
  <code class="n">tryLoadUser</code><code class="p">(</code><code class="mi">23L</code><code class="p">).</code><code class="na">map</code><code class="p">(</code><code class="n">User</code><code class="p">::</code><code class="n">getPermissions</code><code class="p">)</code>
                  <code class="p">.</code><code class="na">filter</code><code class="p">(</code><code class="n">Predicate</code><code class="p">.</code><code class="na">not</code><code class="p">(</code><code class="n">Permissions</code><code class="p">::</code><code class="n">isEmpty</code><code class="p">))</code>
                  <code class="p">.</code><code class="na">map</code><code class="p">(</code><code class="n">Permissions</code><code class="p">::</code><code class="n">getGroup</code><code class="p">)</code>
                  <code class="p">.</code><code class="na">flatMap</code><code class="p">(</code><code class="n">Group</code><code class="p">::</code><code class="n">getAdmin</code><code class="p">)</code>
                  <code class="p">.</code><code class="na">map</code><code class="p">(</code><code class="n">User</code><code class="p">::</code><code class="n">isActive</code><code class="p">)</code>
                  <code class="p">.</code><code class="na">orElse</code><code class="p">(</code><code class="n">Boolean</code><code class="p">.</code><code class="na">FALSE</code><code class="p">);</code></pre>
<p>This pipeline replaces two <code>null</code>-checks (initial and <code>Group::getAdmin</code>), an <code>if</code>-statement (the <code>filter</code> operation), plus accessing the required properties and providing a sensible fallback.
The overall task is directly expressed in the fluent declarative call over six lines instead of a more complex and harder-to-follow block of individual statements.</p>
<p>It’s hard to argue against the reduction of control statements combined with being a functional jump-off point and will likely increase your desire to (over)use Optionals, as it did for me in the beginning.
Remember that Optionals were designed as a specialized <em>return</em> type, not as a ubiquitous replacement for <code>null</code>-related code.
Not every value needs to be wrapped in an Optional, especially simple <code>null</code>-checks:</p>
<pre data-code-language="java" data-type="programlisting"><code class="c1">// BAD: wrapping a value for a simple lookup</code>

<code class="kd">var</code> <code class="n">nicknameOptional</code> <code class="o">=</code> <code class="n">Optional</code><code class="p">.</code><code class="na">ofNullable</code><code class="p">(</code><code class="n">customer</code><code class="p">.</code><code class="na">getNickname</code><code class="p">())</code>
                               <code class="p">.</code><code class="na">orElse</code><code class="p">(</code><code class="s">"Anonymous"</code><code class="p">);</code>


<code class="c1">// BETTER: simpler null-check</code>

<code class="kd">var</code> <code class="n">nicknameTernary</code> <code class="o">=</code> <code class="n">customer</code><code class="p">.</code><code class="na">getNickname</code><code class="p">()</code> <code class="o">!=</code> <code class="kc">null</code> <code class="o">?</code> <code class="n">customer</code><code class="p">.</code><code class="na">getNickname</code><code class="p">()</code>
                                                     <code class="p">:</code> <code class="s">"Anonymous"</code><code class="p">;</code></pre>
<p>Using an Optional might <em>feel</em> cleaner — easier to follow the flow, no control structure, no two <code>null</code> — but as a normal Java type, creating an Optional isn’t free.
Each operation requires checking for <code>null</code> to do its intended job and might create a new Optional instance.
The ternary operator might not be as appealing as an Optional, but it sure requires fewer resources.</p>
<p>Since Java 9, the utility class <code>java.util.Objects</code> got two additions to do simple <code>null</code>-checks with a single method call that doesn’t create additional instances, which are the preferred alternative to an Optional with only an <code>orElse</code> or <code>orElseGet</code> operation:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">var</code> <code class="n">nickname</code> <code class="o">=</code> <code class="n">Objects</code><code class="p">.</code><code class="na">requireNonNullElse</code><code class="p">(</code><code class="n">customer</code><code class="p">.</code><code class="na">getNickname</code><code class="p">(),</code> <code class="s">"Anonymous"</code><code class="p">);</code>

<code class="kd">var</code> <code class="n">nicknameWithSupplier</code> <code class="o">=</code> <code class="n">Objects</code><code class="p">.</code><code class="na">requireNonNullElse</code><code class="p">(</code><code class="n">customer</code><code class="p">.</code><code class="na">getNickname</code><code class="p">(),</code>
                                                      <code class="p">()</code> <code class="o">-&gt;</code> <code class="s">"Anonymous"</code><code class="p">);</code></pre>
<p>Using Optionals should be restricted to their intended use case as improved return containers for possible <code>null</code> values, and, in my opinion, intricate Optional pipelines with multiple operations.
You shouldn’t use them in your code to perform simple <code>null</code>-checks, nor should methods accept them directly as their arguments.
Method overloading provides a better alternative if an argument isn’t always required.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="Parallelism and Concurrency Made Easy" data-type="sect2"><div class="sect2" id="idm45115211042656">
<h2>Parallelism and Concurrency Made Easy</h2>
<p>Writing concurrent or parallel programs isn’t easy.
Creating additional threads is the simple part.
However, coordinating more than one thread can become quite complicated.
The most common root of all problems related to parallelism and concurrency is sharing data between different threads.</p>
<p>Shared data across multiple threads comes with its own requirements you don’t have to consider in sequential programs, like synchronization and locks to ensure data integrity and to prevent data races and deadlocks.</p>
<p>Functional programming creates a lot of opportunities to use concurrency and parallelism safely thanks to the principles functional principles are built on, most evidently the following:</p>
<dl>
<dt>Immutability</dt>
<dd>
<p>Without change, there can’t be data races or deadlocks.
Data structures can safely traverse thread boundaries.</p>
</dd>
<dt>Pure functions</dt>
<dd>
<p>Without side effects, pure functions are isolated and can be called from any thread, as they only rely on their input to generate their output.</p>
</dd>
</dl>
<p>Essentially, functional techniques don’t concern themselves with the distinction of sequential or concurrent execution because FP, at its most strict interpretation, doesn’t allow for an environment where a distinction is necessary.</p>
<p>Java’s concurrency features like parallel Streams (<a data-type="xref" href="ch08.xhtml#_01-parallel-streams">Chapter 8</a>) and <code>CompletableFuture</code> (<a data-type="xref" href="ch13.xhtml#_02-completable-future">Chapter 13</a>) still require thread coordination even with fully functional code and data structures.
However, the JDK will do it for you in a way that fits most scenarios.</p>
</div></section>
<section data-pdf-bookmark="Be Mindful of Potential Overhead" data-type="sect2"><div class="sect2" id="idm45115211077008">
<h2>Be Mindful of Potential Overhead</h2>
<p>Functional techniques provide a great productivity boost and make your code more expressive and robust.
That doesn’t automagically mean that it’s more performant, though, or even at the same performance level as imperative and object-oriented code.</p>
<p>Java is such a versatile language that’s trusted by many companies and individuals because its backward compatibility and general API stability are among the best.
However, this comes at the steep price of fewer changes to the language itself, at least compared to others.
That’s why many features covered in this book, like Streams, CompleteFutures, or Optionals, aren’t native language features but are implemented in the JDK with ordinary Java code, instead.
Even Records, a totally new construct with distinct semantics, boils down to a typical class extending <code>java.lang.Record</code>, similar to how Enums work, with the compiler generating the required code behind the scenes.
Still, that doesn’t mean these features aren’t optimized in any way.
They still profit from all the optimizations available to all Java code.
In addition, lambdas are a language feature utilizing a specialized opcode in the JVM, with multiple optimization techniques.</p>
<p>I know that using functional structures like Streams and Optionals for every single data processing or <code>null</code>-check is quite tempting because I fell for it after years of Java language stagnation.
Even though they are excellent and highly optimized tools, you have to remember they aren’t <em>free</em> to use and will incur c certain unavoidable overhead.</p>
<p>Usually, the overhead is negligible compared to the productivity gains and more concise and straightforward code.
Always remember the quote by Kent Beck: “first make it work, then make it right, and, finally, make it fast.”
Don’t forgo functional features and APIs in fear of the potential overhead without knowing it affected your code negatively in the first place.
If in doubt, measure first, refactor second.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="Functional Architecture in an Imperative World" data-type="sect1"><div class="sect1" id="_02-functional-mindeset_functional-architecture">
<h1>Functional Architecture in an Imperative World</h1>
<p>Choosing a particular architecture isn’t an easy endeavor and has far-reaching consequences for any project.
It’s a significant decision that can’t be changed without much effort.
If you want to apply a more functional approach on an architectural level, it has to fit into an existing imperative and object-oriented code base without disrupting the status quo (too much).</p>
<p>Unsurprisingly, <em>functions</em> are the most basic and essential unit in functional architectures, representing isolated chunks of business logic.
These chunks are the building blocks of workflows by being composed as needed.
Each workflow represents a bigger logical unit, like a feature, a use case, a business requirement, etc.</p>
<p>A typical architectural approach to utilizing FP in an OO world is to separate the business logic from how it communicates with the outside world with well-defined boundaries.
The <em>functional core, imperative shell</em> (FC/IS) approach to architecture is one that’s flexible in size and can be as low-impact as you want.</p>
<p>Although it’s feasible to build a system from scratch with an FC/IS design, it’s also possible to integrate the design into an existing code base.
An FC/IS is an excellent choice for gradual rewrites and refactoring to introduce functional principles and techniques into your OO project.</p>
<p>If you think about code and its actual purpose detached from any paradigms or concepts, it falls into two distinct groups: <em>doing</em> the work, and <em>coordinating</em> it.
Instead of organizing the code and its responsibilities into a single paradigm, FC/IS draws a distinct line of separation between the two involved paradigms, as shown in <a data-type="xref" href="#_02-functional-architecture_func-core_imp-shell">Figure 15-2</a>.</p>
<figure><div class="figure" id="_02-functional-architecture_func-core_imp-shell">
<img alt="Basic layout of a Functional Core, Imperative Shell" height="564" src="assets/afaj_1502.png" width="600"/>
<h6><span class="label">Figure 15-2. </span>Basic layout of Functional Core, Imperative Shell</h6>
</div></figure>
<p>The <em>functional core</em> encapsulates the business logic and decisions in isolated and purely functional units.
It utilizes all that FP has to offer and does what it does best: working directly with data without worrying about side effects or state-related problems thanks to pure functions and immutability.
This <em>core</em> is then wrapped by an <em>imperative shell</em>, a thin layer to protect it from the outside world, encapsulating all the side effects and any mutable state.</p>
<p>The <em>shell</em> contains the dependencies to other parts of the system and provides the public contract to interact with the FC/IS from the outside.
Everything non-functional is kept away from the <em>core</em> and restricted to the <em>shell</em>.
To keep the <em>shell</em> as thin as possible, most of the decisions remain in the <em>core</em>, so the <em>shell</em> only needs to delegate the work through its boundary and interpret the <em>core’s</em> results.
It’s a glue layer handling the “real world” with all its dependencies and mutable state but as few paths and decisions as possible.</p>
<p>One of the main advantages of this design is the clear-cut split of responsibilities by encapsulation that occurs almost naturally as a side effect of a functional approach.
The business logic is encapsulated in the <em>core</em>, built with <em>pure functions</em>, <em>immutability</em>, etc., making it easy to reason with, modular, and maintainable.
Conversely, anything <em>impure</em> or <em>mutable</em>, or any contact with other systems, is restricted to the <em>shell</em> which isn’t allowed to make many decisions by itself.</p>
<section data-pdf-bookmark="From Objects to Values" data-type="sect2"><div class="sect2" id="idm45115211009600">
<h2>From Objects to Values</h2>
<p>From the outside, only the <em>imperative shell</em> is visible and provides a low level of abstraction with problem domain-specific types.
It looks and feels like any other layer in a <em>usual</em> object-oriented Java project.
The <em>functional core</em>, however, doesn’t need to know about the <em>shell</em> and its public contracts at all.
Instead, it relies solely on high-level abstractions and the exchange of values rather than objects and how they interact with each other.</p>
<p>This shift from objects to values is required to keep the <em>core</em> functional and independent by leveraging all available functional tools.
But it also highlights the split in responsibilities.
To keep the core <em>pure</em>, any mutability, state, or side effects must happen beyond the boundary in the <em>shell</em>, outside of the actual business logic.
In its most refined form, that means that <em>anything</em> traversing the boundary needs to be a value, even eventual side effects!
That’s why separating side effects from pure functions is so important to regain more control.
Programming languages that are “more functional” than Java usually have specialized data structures to handle side effects, like for example Scala’s <code>Maybe</code> or <code>Try</code> types.</p>
<p>Java’s closest type for handling a side effect is the <code>Optional&lt;T&gt;</code> type, which is capable of representing two states in a single type.
In <a data-type="xref" href="ch10.xhtml#_02-exception-handling">Chapter 10</a>, I also discussed how to recreate Scala’s Try/Success/Failure pattern in Java to handle control-flow disruptions due to Exceptions in a more functional manner.
Still, the additional code and boilerplate required to tame side effects is a clear indicator that they should be handled in the <em>imperative shell</em> where the appropriate tools and constructs are available, unlike in the <em>functional core</em>, where it’s at least not desirable to do so.</p>
</div></section>
<section data-pdf-bookmark="Separation of Concerns" data-type="sect2"><div class="sect2" id="idm45115211000368">
<h2>Separation of Concerns</h2>
<p>Functions come to their conclusions solely based on their arguments, without accessing or changing the world around them.
Still, at some point, change might be necessary, like persisting data, mutating state in the <em>shell</em>.</p>
<p>The <em>core</em> is only responsible for decision-making but not acting on such decisions.
That’s why all changes, even side effects, must be representable as values, too.</p>
<p>Imagine you want to scrape a website for certain information and store it in a database.
The overall task consists broadly speaking of the following steps:</p>
<ol>
<li>
<p>Load content of a website</p>
</li>
<li>
<p>Extract the necessary information</p>
</li>
<li>
<p>Decide if the information is relevant</p>
</li>
<li>
<p>Persist data in a database</p>
</li>
</ol>
<p>To fit the task into an FC/IS system, you first need to categorize them by their responsibilities.</p>
<p>Loading the content and persisting the data is clearly I/O, which includes side effects, and therefore, belongs into the <em>shell</em>.
Information extraction and deciding if it’s relevant is data processing that fits into the <em>core</em>.
This categorization leads to the separation of tasks as illustrated in <a data-type="xref" href="#_02-functional-architecture_func-core_imp-shell_scraping">Figure 15-3</a>.</p>
<figure><div class="figure" id="_02-functional-architecture_func-core_imp-shell_scraping">
<img alt="Web-scraping responsibilities in FCIS" height="458" src="assets/afaj_1503.png" width="419"/>
<h6><span class="label">Figure 15-3. </span>Web-scraping responsibilities in FCIS</h6>
</div></figure>
<p>As you can see in the figure, the <em>shell</em> interacts with the network and passes the content immediately to the <em>core</em>.
The <em>core</em> receives an immutable <code>String</code> value and returns an <code>Optional&lt;String&gt;</code> to indicate if the information is relevant based on its business logic.
If a value is received back in the <em>shell</em>, it persists the value and any other information it still has access to in its context.</p>
<p>The separation of concerns brings another advantage to the code.
From a modularity standpoint, the <em>core</em> is capable of using any input source, not just a website.
This makes data processing more flexible and reusable.
For example, instead of scraping a single site and passing its content directly to the <em>core</em> for processing, multiple pages could be scraped beforehand and persisted in a database for later processing.
The <em>core</em> doesn’t care and doesn’t even need to know where the content comes from; it’s entirely focused on its isolated task: extracting and evaluating information.
So even if the overall requirements change, the <em>core</em> doesn’t necessarily have to change, too.
And if it does, you can recombine the existing small logical units as needed.</p>
</div></section>
<section data-pdf-bookmark="The Different Sizes of an FC/IS" data-type="sect2"><div class="sect2" id="idm45115210999712">
<h2>The Different Sizes of an FC/IS</h2>
<p>An FC/IS might seem like a singular organizational layout that your system is built around.
That’s one way to do it, yet there’s a more flexible way to integrate the FC/IS architecture into a system: multiple FC/IS with different sizes.</p>
<p>Unlike other architectural designs, it doesn’t have to define or dominate a project.
It doesn’t matter if your whole application is built around a singular or multiple FC/IS.
Even creating an FC/IS for a sole task is possible.
As long as an <em>imperative shell</em> integrates with the rest of the system, you’re good to go!</p>
<p>The dynamic sizing and integration of FC/IS allow for a gradual transition toward more functional logic in your codebase without breaking pre-existing structures.
Creating multiple FC/IS, as seen in <a data-type="xref" href="#_02-functional-architecture_multi-func-core_imp-shell">Figure 15-4</a>, can coexist and interact with prior systems without anyone even noticing it from the outside.</p>
<figure><div class="figure" id="_02-functional-architecture_multi-func-core_imp-shell">
<img alt="Multiple FI/CS interacting with an existing system" height="447" src="assets/afaj_1504.png" width="593"/>
<h6><span class="label">Figure 15-4. </span>Multiple FI/CS interacting with an existing system</h6>
</div></figure>
<p>A sensible approach for sizing an FC/IS is thinking about its context and capabilities.
The boundaries to the outside world — the <em>shell’s</em> surface — are the first indicator of the required size.
Reducing the coupling between different systems ensures modularity, extensibility, and maintainability over time.
The context is defined by the encapsulated specialized domain knowledge represented in the <em>core</em>, and by extension, the public contract of the <em>shell</em>.</p>
<p>Defining the correct context and appropriate boundaries is crucial and gets easier with experience.
An FC/IS should be as small as possible but as big as necessary.
Functional units or whole functional groups of a core can be reused in other FC/IS to facilitate multiple small but specialized FC/IS instead of a singular “all-inclusive” one.
With these smaller and isolated FC/IS it’s easier to start replacing and integrating them into even complex pre-existing systems step-by-step.</p>
</div></section>
<section data-pdf-bookmark="Testing an FC/IS" data-type="sect2"><div class="sect2" id="idm45115210973952">
<h2>Testing an FC/IS</h2>
<p>As with any other refactoring effort, when you adopt an FC/IS design, you should verify your new structures with appropriate testing, such as unit and integration tests.
If your code has dependencies, or I/O like a database, testing usually requires mocks or stubs to better isolate the tested components.</p>
<p>While libraries are available to streamline creating such replacements, the whole concept comes with some drawbacks:</p>
<dl>
<dt>Knowledge of implementation details</dt>
<dd>
<p>Mocks often require detailed implementation knowledge to work as intended.
Such details might change over time, and every refactor attempt tends to break the mocks and stubs mimicking them, even without changing the public contracts or the test logic.</p>
</dd>
<dt>Incidental testing</dt>
<dd>
<p>Tests should be on point, only testing the absolute minimum to ensure correctness.
Dependencies create additional layers to consider, though, even if the intended story of the test hides underneath.
Debugging such tests can be a nuisance because you no longer only debug the test and functionality itself but also any other layer present.</p>
</dd>
<dt>Fictional testing</dt>
<dd>
<p>Typically, a dependency is correctly initialized and in a guaranteed meaningful state.
On the other hand, Mocks and stubs are essentially fictional implementations to reduce the coupling between components and fulfill the minimal set of requirements for the test.</p>
</dd>
</dl>
<p>The FC/IS architecture reduces these usual drawbacks thanks to its clear separation of responsibilities which is mirrored in its testability.</p>
<p>The <em>functional core</em> — the business logic of the system — consisting of pure functions which are often naturally isolated, is a perfect match for unit testing.
The same test input needs to fulfill the same assertions.
That’s why the core is usually easy to verify with small and on-point unit tests without test doubles compared to larger interconnected systems with more complex setup requirements.
This general lack of dependencies eliminates the need for mocks and stubs.</p>
<p>The <em>imperative shell</em> still has dependencies and side effects and is, obviously not as easily testable as the <em>core</em>; it still needs integration tests.
However, having most of the logic in the <em>core</em> that’s easily unit-testable, requires fewer tests to verify the <em>shell</em>.
Any new FC/IS can rely on tested and verified functional code that’s easy to reason with, with only a new <em>shell</em> needing to be verified.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="Final Thoughts on a Functional Approach to Java" data-type="sect1"><div class="sect1" id="idm45115211025792">
<h1>Final Thoughts on a Functional Approach to Java</h1>
<p>Although I’m obviously a proponent of functional techniques wherever possible and sensible, my day-to-day Java work is still shaped by primarily imperative and object-oriented code.
You may also be in a similar situation.
In my company, Java 8 and its successors allowed us to introduce functional techniques step-by-step and at our own pace without the need to rewrite the whole architecture or codebase.</p>
<p>For example, slowly establishing immutability throughout the code and as the new baseline for data structures eliminated a whole category of problems that is usually present in an OO approach.
Even hybrid approaches, like the previously mentioned partially immutable <code>SessionState</code> type eliminated certain unfavorable scenarios that could introduce subtle and hard-to-debug problems.</p>
<p>Another significant improvement was designing method signatures with Optionals in mind.
It made the intent of a method more evident, communicating the possibility of missing values clearly with the caller, resulting in fewer <code>NullPointerException</code> without requiring an abundance of <code>null</code>-checks.</p>
<p>Functional idioms, concepts, and techniques aren’t that far out from object-oriented ones as it’s often proclaimed.
Sure, they are different approaches to solving similar problems.
Most benefits of functional programming can be reaped in object-oriented and imperative environments, too.</p>
<p>Java, as a language, might be lacking support for certain functional constructs.
However, Java, the platform with a vast ecosystem brings in so many benefits regardless of the chosen paradigm.</p>
<p>Fundamentally, functional programming is a thought process, not a specific language per se.
You don’t have to start a system from scratch to benefit from it.
Starting from scratch often focuses on productivity instead of required breadth.
Due to an ever-changing and evolving codebase, it’s easy to overlook necessary edge cases and non-common constructs most systems rely on.
Instead of going back to square one, you can reduce the overall complexity by gradually rewriting, refactoring, and injecting a <em>functional mindset</em> step-by-step.</p>
<p>Still, not every data structure needs to be redesigned, and not each type to be made fully functional.
The way to build a <em>functional mindset</em> is to exercise it.
Start small, and don’t force it.
The more you use functional constructs, the easier you will identify code that can benefit from the functional tools that Java provides.</p>
<p>The overarching goal of a functional approach is reducing the required cognitive capacity to understand and reason with your code.
More concise and safer constructs, like pure functions and immutable data structures, improve reliability and long-term maintainability.
Software development is about controlling complexity with the right tools, and in my opinion, the functional toolset that Java 8+ provides is quite powerful to tame your imperative and object-oriented Java code.</p>
<p>No matter which functional techniques and concepts you integrate into your projects, the most important lesson that I hope you take away from my book, in my opinion, is that it doesn’t actually matter if you do OOP or FP.
Brian Goetz, the Java Language Architect at Oracle, said it quite well in one of his talks:</p>
<blockquote>
<p>Don’t be a functional programmer.<br/>
Don’t be an object-oriented programmer.
Be a better programmer.</p>
<p data-type="attribution">Brian Goetz, <cite>FP vs OO: Choose Two</cite></p>
</blockquote>
<p>Software development is about choosing the most appropriate tool for a given problem.
Incorporating the functional concepts and techniques available to us as Java developers in our day-to-day work adds invaluable new tools to our toolbox, which create more readable, reasonable, maintainable, and testable code.</p>
</div></section>
<section data-pdf-bookmark="Takeaways" data-type="sect1"><div class="sect1" id="idm45115210952784">
<h1>Takeaways</h1>
<ul>
<li>
<p>OOP and FP are quite dissimilar in their core concepts.
However, most of their concepts aren’t mutually exclusive or completely orthogonal.
Both can solve the same problems but with different approaches.</p>
</li>
<li>
<p>Reasonable code is the ultimate goal, and a <em>functional mindset</em> helps achieve it.</p>
</li>
<li>
<p>A <em>functional mindest</em> starts small with steps, like avoiding <em>side effects</em> with the help of <em>pure functions</em> or embracing <em>immutability</em>.</p>
</li>
<li>
<p>Functional principles can also be part of architectural decisions, like separating concerns by splitting the business logic and the exposed <em>surface</em> to other systems with designs like a <em>functional core, imperative shell</em>.</p>
</li>
<li>
<p>The <em>functional core, imperative shell</em> design is an excellent tool for gradually introducing functional principles and concepts into existing code.</p>
</li>
</ul>
</div></section>
<div data-type="footnotes"><p data-type="footnote" id="idm45115212232256"><sup><a href="ch15.xhtml#idm45115212232256-marker">1</a></sup> Salus, Peter H. 1994. “A Quarter-Century of Unix.” Addison-Wesley. ISBN 0-201-54777-5.</p></div></div></section></div>

<div id="sbo-rt-content"><section class="abouttheauthor" data-pdf-bookmark="About the Author" data-type="colophon" epub:type="colophon"><div class="colophon" id="idm45115212536816">
<h1>About the Author</h1>
<p>
    Using his first computer at the age of four, <strong>Ben Weidig</strong> is a self-taught
    developer with almost two decades of experience in professional web, mobile,
    and systems programming in various languages.
  </p>
<p>
    After learning the ropes of professional software development and project
    management at an international clinical research organization, he became a
    self-employed software developer.
    He merged with a SaaS company after prolonged and close collaboration on
    multiple projects. As co-director, he shapes the company’s general
    direction, is involved in all aspects of their Java-based main product, and
    oversees and implements its mobile strategy.
  </p>
<p>
    In his free time, he shares his expertise and experiences by writing
    articles about Java, functional programming, best practices, and code-style
    in general.
    He also participates in Open-Source, either as a committer to established
    projects or releasing code of his own.
  </p>
</div></section></div></body></html>