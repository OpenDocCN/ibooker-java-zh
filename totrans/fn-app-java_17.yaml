- en: Chapter 15\. A Functional Approach to Java
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第15章. Java的函数式方法
- en: Many programming languages support both a functional and imperative code style.
    However, the syntax and facilities of a language typically incentivize specific
    approaches to common problems. Even with all the functional additions to the JDK
    discussed in this book, Java still favors imperative and object-oriented programming,
    with most of the core libraries’ available types and data structures reflecting
    this preference.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 许多编程语言支持函数式和命令式的代码风格。然而，语言的语法和工具通常会鼓励特定的解决常见问题的方法。尽管本书讨论了JDK中所有的函数式扩展，Java仍然偏向于命令式和面向对象编程，大多数核心库中提供的类型和数据结构反映了这种偏好。
- en: However, as I’ve discussed throughout this book, that doesn’t mean it has to
    be an “either-or” kind of situation. You can augment your OO code with functional
    principals without going fully functional. Why not have the best of both worlds?
    To do so, you need to adopt a functional mindset.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如我在本书中一直讨论的那样，这并不意味着必须是“非此即彼”的情况。您可以在不完全过渡到函数式的情况下用面向对象的代码增强函数式原则。为什么不两者兼得呢？要做到这一点，您需要采纳函数式的思维方式。
- en: This chapter pulls together what you’ve learned in this book so far and highlights
    the most important aspects that will influence your functional mindset. It also
    shows a practical application of functional programming techniques on an architectural
    level that fits right into an object-oriented environment.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将本书迄今为止学到的内容汇总，并突出显示将影响您的函数式思维方式最重要的方面。它还展示了如何在适合面向对象环境的架构层次上应用函数式编程技术。
- en: OOP Versus FP Principles
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向对象与函数式原则
- en: To better understand where functional principles can improve your code, it makes
    sense to revisit the underlying principles of both paradigms — object-oriented
    and functional — to recognize their dissimilarities and possible interconnection
    points. This builds the base knowledge to identify opportunities to incorporate
    a functional approach into your OO code and where it doesn’t make sense to force
    it.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 要更好地理解函数式原则如何改善您的代码，有必要重新审视面向对象和函数式这两种范式的基本原则，以识别它们的不同之处和可能的连接点。这构建了基础知识，以确定在您的面向对象代码中纳入函数式方法的机会以及强行纳入它可能不合适的地方。
- en: '*Object-oriented* programming’s main concerns are encapsulating data and behavior,
    polymorphism, and abstraction. It’s a *metaphor-based* approach to solving problems
    where its objects and connecting code mimic a particular problem domain. These
    objects interact by messaging through public contracts, like interfaces, and each
    has responsibilities and usually manages its own state. Using such metaphors bridges
    the gap between the computer, which requires a set of instructions, and the developer,
    which can express their intent in a straightforward manner. OOP is an excellent
    approach to structuring and organizing imperative code after the “real world”
    and its constant and endless changes.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*面向对象* 编程的主要关注点是封装数据和行为、多态性和抽象化。它是一种基于*隐喻*的解决问题的方法，其中对象和连接代码模仿特定的问题域。这些对象通过公共合约（如接口）进行消息传递，每个对象有责任并通常管理自己的状态。使用这样的隐喻可以弥合计算机（需要一组指令）和开发者（可以以直接的方式表达其意图）之间的差距。面向对象编程是在“真实世界”及其不断和无尽的变化之后组织和管理命令式代码的优秀方法。'
- en: '*Functional programming*, however, uses mathematical principles to solve problems,
    utilizing a *declarative* code style. Instead of requiring a metaphor to model
    your code like the “real world”, its foundation — *lambda calculus* — only cares
    about data structures and their transformation using high-level abstractions.
    Functions take an input and create an output, that’s about it! Data and behavior
    aren’t encapsulated; functions and data structures *just are*. FP circumvents
    many typical OOP and Java problems, like handling mutable state in a concurrent
    environment or unexpected side effects, by trying not to have any side effects,
    to begin with.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*函数式编程* 则利用数学原理解决问题，采用*声明式*的代码风格。与需要模拟“真实世界”来建模代码的隐喻不同，函数式编程的基础——*λ演算*——只关心数据结构及其使用高级抽象进行的转换。函数接收输入并产生输出，就是这样！数据和行为没有被封装起来；函数和数据结构*就是*。函数式编程通过避免副作用来绕过许多典型的面向对象编程和Java问题，比如在并发环境中处理可变状态或意外的副作用，因为它试图一开始就不产生任何副作用。'
- en: These two short summaries already highlight the dissimilarity of the core principles
    of object-oriented and functional programming. OOP tries to tame complexity by
    encapsulating the moving parts of your code in a familiar domain, whereas FP strives
    to have fewer parts in total by adhering to mathematical principles. The more
    abstract way of thinking in FP is why OOP is often the preferred first approach
    to teaching and learning Java.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个简短的摘要已经突显了面向对象和函数式编程核心原则的不同之处。面向对象编程试图通过将代码的移动部分封装在熟悉的域中来驯服复杂性，而函数式编程则通过遵循数学原理来减少总体部分。函数式编程中更抽象的思维方式是为什么面向对象编程通常是首选的Java教学和学习方法。
- en: As I discussed in [Chapter 14](ch14.xhtml#_02-design-patterns), both paradigms
    are just divergent approaches able to solve the same problems coming from different
    directions. It would be foolish to declare that one principle is, no pun intended,
    objectively better than the other. Metaphors in OO are a powerful tool to make
    code feel more natural to non-programmers and programmers alike. Some complex
    problems benefit from a good metaphorical representation way more than a maybe
    more concise but highly abstracted functional approach.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在[第14章](ch14.xhtml#_02-design-patterns)中讨论的，面向对象和函数式编程这两种范式只是解决相同问题的不同方法。它们都是能够从不同方向解决同一问题的不同方法。如果宣称其中一种原则比另一种更好，无论是否打趣，都是愚蠢的。在面向对象编程中，比喻是一个强大的工具，使代码对非程序员和程序员感觉更自然。有些复杂的问题比起可能更简洁但高度抽象的功能性方法，更受益于一个良好的比喻性表达方式。
- en: A Functional Mindset
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能性心态
- en: Any fool can write code that a computer can understand. Good programmers write
    code that humans can understand.
  id: totrans-11
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 任何傻瓜都能写出计算机能理解的代码。优秀的程序员编写的是人类能理解的代码。
- en: ''
  id: totrans-12
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Martin Fowler, Refactoring: Improving the Design of Existing Code'
  id: totrans-13
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Martin Fowler，《重构：改善既有代码的设计》
- en: You can have all the functional tools available at your fingertips, but using
    them efficiently requires the right mindset to do so. Having a functional mindset
    involves having the reasoning to identify code that could be improved with a functional
    approach, be it going fully functional, or just injecting a few functional techniques
    and principles at critical, and appropriate, places. This mindset won’t come overnight;
    you have to hone it with practice to gain experience and intimation
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 手头可以使用所有的功能工具，但要有效地使用它们需要正确的心态。拥有功能性心态意味着有理由识别那些可以通过功能性方法改进的代码，无论是完全采用功能性，还是在关键和适当的地方注入一些功能性技术和原则。这种心态不会一夜之间形成；你必须通过实践来磨练以获取经验和直觉。
- en: Developing this functional mindset starts with wanting to eliminate or reduce
    any accidental complexity in your code. The techniques and principles you use
    to solve your problems should lead to code that is reasonable and easier to understand.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 发展这种功能性心态始于希望消除或减少代码中的任意复杂性。您用于解决问题的技术和原则应该导致代码合理且更容易理解。
- en: To reason with a complex system means grasping and figuring out any code with
    only the information that’s *right in front of you* rather than relying on hidden-away
    implementation details or maybe outdated comments, without any surprises waiting
    for you. You don’t need to look across multiple files or types to understand the
    problem that is solved, or don’t need to ponder about many of the decisions that
    went into the code itself.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要与复杂系统进行推理意味着只凭手头的信息来理解和解决任何代码，而不依赖于隐藏的实现细节或可能过时的注释，不会有任何等待你的意外。你不需要查看多个文件或类型来理解解决的问题，或者不需要思考代码本身所涉及的许多决策。
- en: The correctness of your code is informally proven because any claim about its
    functionality is backed up by its reasonability and accompanying comments. Anyone
    using such code can make strong assumptions about it and rely on its public contracts.
    The opaque nature of OOP and its encapsulation of behavior and data often makes
    it harder to reason with than alternative approaches.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你的代码正确性得到了非正式的证明，因为关于其功能的任何声明都得到了其合理性和随附的评论的支持。使用这样的代码的任何人都可以对其进行强有力的假设，并依赖其公共契约。面向对象编程的不透明性和其对行为和数据的封装通常使其比替代方法更难以推理。
- en: Let’s revisit the different aspects of functional programming that will influence
    your decision when to apply a functional approach.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新审视在何时应用功能性方法时将影响您决策的不同方面。
- en: Functions are First-Class Citizens
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数是第一类公民
- en: 'Functional programming is all about functions and their *first-class citizenship*.
    That means that functions are tantamount to other constructs of the language because
    you can:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程关乎函数及其*头等公民的地位*。这意味着函数与语言的其他构造一样重要，因为你可以：
- en: Assign functions to variables
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将函数赋值给变量
- en: Pass functions as arguments to another function/method
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将函数作为参数传递给另一个函数/方法
- en: Return a function from a function/method
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从函数/方法返回一个函数
- en: Create anonymous functions without a name
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建没有名称的匿名函数
- en: These properties are pretty similar to how anonymous classes are usable in Java,
    even before the introduction of lambda expressions. Unlike anonymous classes,
    though, functional interfaces — Java’s representation of the concept of functions — are
    conceptionally more generalized and usually detached from an explicit class or
    domain type. Furthermore, the JVM uses them differently thanks to the `invokedynamic`
    opcode, as explained in [“The `invokedynamic` Instruction”](ch02.xhtml#_01-functional-java_invokedynamic),
    which allows for a greater variety of optimizations compared to anonymous classes.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这些特性与Java中匿名类的使用方式非常相似，甚至在引入lambda表达式之前也是如此。不过，与匿名类不同的是，函数接口——Java中函数概念的表示——在概念上更加通用化，并且通常与显式的类或领域类型分离。此外，JVM利用`invokedynamic`操作码的方式也不同，如
    [“`invokedynamic`指令”](ch02.xhtml#_01-functional-java_invokedynamic) 所解释的，这允许进行比匿名类更多样的优化。
- en: Even though Java doesn’t have “on the fly” types and requires any lambda expression
    to be represented by concrete functional interfaces, it still manages to allow
    you to use one of the big differentiators between OO and FP because it provides
    a higher level of abstraction. Functional abstractions are on a higher level than
    their OO counterparts. That means that FP focuses on values instead of discrete
    domain-specific types with rigid data structures.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Java没有“即时”类型，并要求任何lambda表达式都由具体的函数接口表示，但它仍然可以让你使用OO和FP之间的主要差异之一，因为它提供了更高层次的抽象。函数抽象比它们的面向对象对应物更高级别。这意味着FP关注的是值，而不是具有严格数据结构的离散领域特定类型。
- en: Think of functions and their higher level of abstraction as small cogs in a
    machine. Object-oriented cogs are bigger and specifically designed for a narrower
    scope of tasks; they only fit into specific parts of the machine. The smaller
    functional cogs, however, are more uniform and generalized, and therefore, easier
    to use throughout the machine. They can then be composed into groups, going from
    a singular simple task toward a complex and more complete one. The bigger task
    is the sum of all its smaller parts, with the parts themselves being as small
    and generic as possible, reusable, and easily testable. This way, you can build
    a library of reusable functions to be composed as necessary.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 把函数及其更高级别的抽象看作机器中的小齿轮。面向对象的齿轮更大，并且专门设计用于更窄范围的任务；它们只适合于机器的特定部分。然而，更小的函数式齿轮更加统一和通用化，因此更容易在整个机器中使用。然后，它们可以组成群组，从一个单一简单的任务向复杂和更完整的任务发展。更大的任务是其所有更小部分的总和，而部分本身尽可能小而通用，可重用且易于测试。通过这种方式，你可以构建一个可按需组合的可重用函数库。
- en: Still, Java’s dependence on functional interfaces to represent functions and
    lambdas is both a blessing and a curse.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Java依赖于函数接口来表示函数和lambda既是福音也是诅咒。
- en: It’s a curse because you can’t have a detached lambda that’s only based on its
    arguments and return type without a corresponding functional interface. Type inference
    eases the pain but at some point, the actual type must be available for the compiler
    to infer the type down the line.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个诅咒，因为你不能有一个仅基于其参数和返回类型而没有相应函数接口的分离lambda。类型推断减轻了痛苦，但在某些时候，实际类型必须对编译器可推断的类型有所了解。
- en: It’s also a blessing because it’s the perfect way of bridging between Java’s
    static type system and the predominantly imperative object-oriented code style
    and a new way of thinking without breaking backward compatibility.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 它也是一种福音，因为它是在不破坏向后兼容性的情况下在Java的静态类型系统和主要的命令式面向对象代码风格之间架起桥梁的完美方式，也是一种新的思维方式。
- en: Avoiding Side Effects
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免副作用
- en: Asking a question shouldn’t change the answer.
  id: totrans-32
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 提问不应该改变答案。
- en: ''
  id: totrans-33
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Bertrand Meyer, French academic
  id: totrans-34
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 法国学者Bertrand Meyer
- en: Having a functional mindset also involves avoiding side effects. From a functional
    point of view, side effects refer to the modification of any kind of state which
    can have many forms. It doesn’t have to be hidden or unexpected, quite the contrary.
    Many forms of side effects, like accessing a database, or doing any kind of I/O,
    are intended actions and are a crucial part of almost every system. Nevertheless,
    fewer side effects usually mean fewer surprises in your code and a smaller bug
    surface.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有功能性思维方式还包括避免副作用。从功能性的角度来看，副作用是指修改任何类型的状态，它可以有许多形式。它不必是隐藏的或意外的，恰恰相反。许多形式的副作用，如访问数据库或进行任何I/O操作，都是有意的行为，并且是几乎每个系统的重要部分。然而，更少的副作用通常意味着代码中更少的意外和更小的bug表面。
- en: There are several functional ways to reduce the number of side effects, or at
    least make them more manageable.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种功能性方法可以减少副作用的数量，或者至少使它们更易管理。
- en: Pure Functions
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 纯函数
- en: 'The most basic approach to avoid side effects is using the functional programming
    concept of *pure functions* because they rely on two elemental guarantees:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 避免副作用的最基本方法是使用功能编程概念中的*纯函数*，因为它们依赖于两个基本保证：
- en: The same input will *always* create the same output.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相同的输入*总是*会产生相同的输出。
- en: Pure functions are *self-contained* without any side effects.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纯函数*自包含*，没有任何副作用。
- en: Seems simple enough.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来足够简单。
- en: In reality, however, there are more aspects you have to look out for when improving
    the purity of your Java code.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，实际上，在改善Java代码的纯度时，还有更多需要注意的方面。
- en: Any pure function can only rely on the declared input arguments to produce its
    result. Any hidden state or invisible dependencies are a big no-no.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 任何纯函数只能依赖于声明的输入参数来生成其结果。任何隐藏状态或不可见依赖都是大忌。
- en: 'Think of a function that creates a greeting for a `User` instance with a method
    signature as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个为`User`实例创建问候语的函数，方法签名如下：
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The method signature, its public contract, discloses a singular dependency:
    the `User` argument. If you don’t know the actual implementation, it would be
    safe to assume that this is a pure function that produces the same salutation
    for repeated calls with the same user.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 方法签名及其公共契约揭示了一个单一的依赖：`User`参数。如果您不知道实际实现情况，可以安全地假定这是一个纯函数，对于重复调用相同的用户，会产生相同的问候语。
- en: 'Let’s take a look at its implementation:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下它的实现：
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Checking out the implementation, however, a second dependency reveals itself:
    the time of day. This invisible dependency that relies on an out-of-context state
    makes the whole method impure.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在检查实现时，第二个依赖项显露出来：时间。这种依赖不可见，依赖于上下文之外的状态，使整个方法不纯净。
- en: 'To regain purity, the second internal dependency must be made part of the public
    contract instead:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要恢复纯度，第二个内部依赖项必须成为公共契约的一部分：
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Purity is restored and the public contract no longer hides the internal dependency
    on the time of day and communicates it clearly, without requiring any documentation.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 纯度被恢复，公共契约不再隐藏对白天时间的内部依赖，并清楚地传达它，而无需任何文档。
- en: The method signature could still be simplified further. Why bind the method
    to the `User` type if only its `name` is used? Why use `LocalTime` if only its
    hour is used? Creating a more versatile `buildGreeting` method would accept only
    the `name` and not a whole `User` instance.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 方法签名仍然可以进一步简化。如果仅使用其`name`，为什么将方法绑定到`User`类型？如果仅使用其小时，为什么使用`LocalTime`？创建一个更多功能的`buildGreeting`方法将只接受`name`而不是整个`User`实例。
- en: The lowest common denominator of arguments will give the most versatile and
    broadly applicate pure function possible. Try to avoid nested calls to broaden
    the applicability of a method by going closer to the actual required value instead
    of relying on specific domain types.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 参数的最低公共分母将给出可能的最通用和广泛应用的纯函数。尝试避免嵌套调用，通过更接近实际需要的值来扩展方法的适用性，而不是依赖于特定的领域类型。
- en: The best way to think about pure functions is to see them totally isolated in
    their own space-time continuum detached from the rest of the system. That’s why
    they need to receive all of their requirements explicitly as values, preferably
    with as few intermediate objects as possible. However, such a higher abstraction
    forfeits some of the method signature’s expressiveness, so you must find an acceptable
    balance.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 想要理解纯函数的最佳方式是将它们视为完全隔离在它们自己的时空连续体中，与系统的其他部分分离开来。这就是为什么它们需要明确地接收所有的需求作为值传递，最好尽量减少中间对象。然而，这种更高的抽象会损失部分方法签名的表达力，所以你必须找到一个可接受的平衡点。
- en: Pure functions are a cornerstone of functional programming. Reducing a task
    to “same input + processing → same output” makes method signatures more meaningful
    and easier to comprehend.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数是函数式编程的基石。将任务简化为“相同的输入 + 处理 → 相同的输出”使方法签名更具有意义，更易于理解。
- en: Pure Object Methods
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 纯对象方法
- en: Pure functions only exist within their own context which is why they can only
    rely on their input arguments to create their output. Translating this principle
    into an object-oriented environment is a little bit more difficult.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数仅存在于它们自己的上下文中，这就是为什么它们只能依赖它们的输入参数来生成它们的输出。在面向对象的环境中将这个原则转化是有点困难的。
- en: Looking deeper at the two guarantees of pure functions from the point of view
    of an object-oriented programmer, they reveal the possibility of applying them
    in a broader sense to create a more hybrid approach I call *pure object methods*.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 从面向对象程序员的角度深入探讨纯函数的两个保证，它们揭示了在更广义上应用它们以创建更混合的方法的可能性，我称之为*纯对象方法*。
- en: If a method on an object type is truly *pure* in the previously discussed sense,
    it could be made `static` and doesn’t even need to be in the object type anymore.
    Still, binding methods to their related type that’s a part of their input is an
    advantage and won’t go away anytime soon.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个对象类型的方法在先前讨论的意义上真正是*纯粹*的，它可以被定义为`static`，甚至不需要再属于对象类型。但是，将方法绑定到它们相关的类型，这是它们的一部分，是一种优势，并且不会很快消失。
- en: Take the `buildGreeting` method from the previous section as an example. Even
    though it can be made a pure function in the form of a `static` method, adding
    it directly to the `User` type as an instance method makes sense. However, this
    will harm reusability because it doesn’t exist in complete isolation anymore and
    is interconnected with its surrounding type itself. This relationship doesn’t
    mean it can’t be “as pure as possible,” though.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以前一节中的`buildGreeting`方法为例。尽管它可以作为`static`方法变成一个纯函数，但直接将其添加到`User`类型作为实例方法也是有意义的。然而，这样做会损害可重用性，因为它不再完全隔离，而是与其周围的类型相互关联。然而，这种关系并不意味着它不能“尽可能纯净”。
- en: As good object types do, the `User` type encapsulates its state and creates
    its own microcosmos mostly disconnected from the outside. A *pure object method*
    might access that microcosmos and treat them as additional input arguments. The
    main caveat, though, is the non-reusable nature of methods bound to specific types.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 像良好的对象类型一样，`User`类型封装了它的状态并创建了自己的微观宇宙，大部分与外部分离。一个*纯对象方法*可能会访问这个微观宇宙，并将它们视为附加的输入参数。然而，主要的警告是这些方法绑定到特定类型的不可重用性。
- en: 'Other multi-paradigm languages supporting an object-oriented programming style,
    like Python, make this approach more visible, as the following code shows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 其他支持面向对象编程风格的多范式语言，比如Python，更加突显了这种方法，正如下面的代码所示：
- en: '[PRE3]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Using `self` — Python’s equivalent to Java’s `this` — as an explicit input parameter
    on each method highlights the interdependence between the method on the instance
    itself. Even if an object’s method affects its state, it can still be a “pure
    object method” as it doesn’t have any side effects besides its internal state.
    The object itself becomes part of the input, as it encapsulates the side effect,
    and its state after the call makes them the output.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个方法中将`self`作为显式输入参数使用，突显了方法对实例本身的依赖关系，就像Java中的`this`一样。即使对象的方法会影响其状态，只要除了其内部状态之外没有其他副作用，它仍然可以被称为“纯对象方法”。对象本身成为输入的一部分，因为它封装了副作用，并且调用后的状态使它们成为输出。
- en: The functional design principles of pure functions are still useful if you have
    to deal with object types and can’t refactor them to a new design. The same rules
    apply, but the object state counts as an input argument. That’s why further dependencies
    like `time` in `buildGreeting` shouldn’t be hidden away from anyone using the
    method. Calling the same method with the same input on two identical objects should
    result in an equal output or new object state.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数的功能设计原则仍然非常有用，如果你必须处理对象类型并且无法将其重构为新设计。相同规则适用，但对象状态视为输入参数。这就是为什么像`buildGreeting`中的`time`等进一步依赖项不应该隐藏在任何使用该方法的人员之外。对两个相同对象使用相同输入调用相同方法应产生相等的输出或新对象状态。
- en: Pure object methods might not bring in all the advantages of a fully functional
    approach with pure functions and immutable data structures, especially regarding
    reusability. Still, the functional mindset injected into the object-oriented style
    gives you more approachable, safer, more predictable, and therefore, more reasonable
    types.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 纯对象方法可能无法带来全功能方法和不可变数据结构的所有优势，尤其是在可重用性方面。尽管如此，将功能思维注入面向对象风格中，使类型更具可接近性、更安全、更可预测，因此更合理。
- en: Isolating with Side Effects
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 具有副作用的隔离
- en: It’s impossible to write applications with absolutely zero side effects. OOP,
    or imperative code in general, is usually intertwined with mutable states and
    side effects. Still, side effects affecting your state are often invisible at
    the surface, easily breaking the reasonability of code and introducing subtle
    bugs if used incorrectly. If you can’t completely avoid a side effect with techniques
    such as *pure functions*, they should be *isolated*, preferably on the edges of
    your logical units, instead of littering them throughout the code. By splitting
    bigger units of code into smaller tasks, the possible side effects will be restricted
    to and affect only some of the tasks and not the overall unit.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 完全避免副作用是不可能的。面向对象编程（OOP）或一般的命令式代码通常与可变状态和副作用交织在一起。然而，影响状态的副作用通常在表面上是看不见的，如果使用不当，很容易破坏代码的合理性并引入微妙的错误。如果无法通过*纯函数*等技术完全避免副作用，则应该将其*隔离*，最好在逻辑单元的边缘，而不是在整个代码中随意散布。通过将较大的代码单元拆分为较小的任务，可以将可能的副作用限制在一些任务中，并且不会影响整体单元。
- en: 'This mindset is also present in the *Unix philosophy*, originated by Ken Thompson,
    the co-creator of the UNIX operating system. Doug McIlroy — head of the Bell Labs
    Computing Sciences Research Center at the time and inventor of the *Unix pipe* — summarized^([1](ch15.xhtml#idm45115212232256))
    it as such:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这种思维方式也存在于*Unix哲学*中，由Unix操作系统共同创造者Ken Thompson发起。当时贝尔实验室计算科学研究中心主任Doug McIlroy，也是*Unix管道*的发明者，对其进行了如下总结^([1](ch15.xhtml#idm45115212232256))：
- en: Write programs that do one thing and do it well. Write programs to work together.
  id: totrans-71
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 编写只做一件事并且做得好的程序。编写可以相互协作的程序。
- en: ''
  id: totrans-72
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Doug McIlroy
  id: totrans-73
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Doug McIlroy
- en: Transferring this philosophy to a functional approach means that functions should
    strive to do one thing only and do it well without affecting their environment.
    Design your functions to be as small as possible but as large as necessary. A
    complex task is better served by multiple composed functions that preserve pureness
    as long as possible than a bigger function that is impure from the start.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 将这种哲学转移到功能方法中意味着函数应该努力只做一件事，并且做到最好，而不影响其环境。设计你的函数尽可能小，但必要时尽可能大。复杂任务最好由多个组合的函数来完成，尽可能保持纯净性，而不是一个从一开始就是不纯的大函数。
- en: I/O is a classical case of side effects. Loading files, talking a database,
    etc., are impure operations and should therefore be separated from pure functions.
    To encapsulate a side effect you must think about the seams between the actual
    side effect and the processing of its result. Instead of loading a file and processing
    its content as a singular operation, it’s better two separate them into the side
    effect of loading a file, and processing the actual data, as illustrated in [Figure 15-1](#_02-functional-mindset_side-effects_separation).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: I/O是副作用的一个典型案例。加载文件，与数据库通信等，都是不纯的操作，因此应与纯函数分离开来。要封装一个副作用，你必须考虑实际副作用与处理其结果之间的缝隙。与其将加载文件和处理其内容作为一个单一操作，不如将其分成加载文件的副作用和处理实际数据的过程，如[图15-1](#_02-functional-mindset_side-effects_separation)所示。
- en: '![Splitting operations into discrete functions](assets/afaj_1501.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![将操作分解为离散函数](assets/afaj_1501.png)'
- en: Figure 15-1\. Splitting operations into discrete functions
  id: totrans-77
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图15-1\. 将操作拆分为离散函数
- en: The data processing is no longer bound to the file loading, or files in general,
    rather than only processing the incoming data. This makes the operation a pure
    and reusable function, with the side effect restricted to the `loadFile` method,
    with the returned `Optional<String>` giving you a functional bridge to it.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 数据处理不再局限于文件加载或通常的文件，而是仅处理传入的数据。这使得操作成为一个纯的、可重复使用的函数，副作用仅限于`loadFile`方法，返回的`Optional<String>`为你提供了与之的功能桥接。
- en: If side effects can’t be avoided, split up the task into smaller and preferably
    pure functions to isolate and encapsulate any remaining side effects.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果无法避免副作用，将任务分解为更小且最好是纯函数，以隔离和封装任何剩余的副作用。
- en: Favor Expression Over Statements
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 偏爱表达式而非语句
- en: As discussed in [Chapter 1](ch01.xhtml#_01-an-introduction), a key differentiator
    separator between an object-oriented and a functional approach is the prevalence
    of either statements and expressions. To recapitulate, statements perform actions,
    like assigning a variable or control statements, and are therefore literal side
    effects. Expressions, on the other hand, evaluate their input to *just* yield
    output.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第1章](ch01.xhtml#_01-an-introduction)所述，面向对象和函数式方法之间的关键区别是语句和表达式的普遍性。回顾一下，语句执行动作，如分配变量或控制语句，因此具有字面上的副作用。而表达式则评估它们的输入*仅仅*产生输出。
- en: 'If you want to reduce side effects, using expressions leads to safer and more
    reasonable code, based on the following rationale:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果想减少副作用，使用表达式会导致更安全和更合理的代码，基于以下理由：
- en: Pure expressions, like pure functions, don’t have any side effects.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纯表达式，如纯函数，没有任何副作用。
- en: Expressions are (mostly) definable in code; the types of available statements
    are predefined by the language.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表达式（大多数时候）可以在代码中定义；可用语句的类型由语言预定义。
- en: Evaluating pure expressions multiple times will yield the same output, ensuring
    predictability and enabling certain caching techniques, such as *memoization*.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多次评估纯表达式将产生相同的输出，确保可预测性并启用某些缓存技术，如*记忆化*。
- en: Expressions can be small to remain pure and still be composed with other expressions
    to solve a bigger task.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表达式可以很小，以保持纯粹性，并且仍然可以与其他表达式组合以解决更大的任务。
- en: 'The control flow `if`-`else` statements are often a good candidate for replacing
    it with a more functional approach, especially to assign variables or create.
    The previous `buildGreeting` method becomes more concise and straightforward by
    using the ternary operator for the pretty simplistic decision of which greeting
    to choose, as seen as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 控制流`if`-`else`语句通常是用更功能化方法替换的一个好选择，特别是用于分配变量或创建。通过使用三元运算符来选择要使用的问候语，前面的`buildGreeting`方法变得更简洁、更直接。
- en: '[PRE4]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The ternary operator gives you two other advantages.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 三元运算符给您带来了另外两个优势。
- en: First, the variable `greeting` is declared and initialized in a single expression
    instead of it being uninitialized outside of the `if`-`else`-block.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在单个表达式中声明并初始化变量`greeting`，而不是在`if`-`else`块之外未初始化。
- en: Second, the variable is effectively `final`. In this particular case, it doesn’t
    matter. Still, there having a variable that can be easily used in a lambda expression
    is better than requiring you to refactor your code when you eventually need a
    variable to be effectively `final`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，变量是有效地`final`。在这种特定情况下，这并不重要。但是，当您最终需要一个变量有效地`final`时，而不是要求您重构代码时，使用lambda表达式更好。
- en: Breaking down complex statement lists and blocks into smaller expressions makes
    code more concise and easier to reason with, plus the added benefit of effectively
    `final` variables, which is as you may remember from earlier chapters a non-negotiable
    requirement for using variables in lambda expressions.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 将复杂的语句列表和块拆分为较小的表达式，使代码更简洁、更易理解，并且能有效地使用`final`变量，正如你可能记得的早期章节中，使用变量在lambda表达式中是一个不可妥协的要求。
- en: Expressions are often preferable over statements because they are a combination
    of values and functions intended to create a new value. They’re usually more compact
    and isolated than statements, making them safer to use. Statements, on the other
    hand, are more of a standalone unit to execute a side effect.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式通常优于语句，因为它们是值和函数的组合，旨在创建一个新值。它们通常比语句更紧凑和隔离，因此更安全使用。而语句则更像是一个独立的单元，用于执行副作用。
- en: Moving Towards Immutability
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 迈向不可变性
- en: If it is not necessary to change, it is necessary not to change.
  id: totrans-95
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果没有必要进行改变，那就需要不进行改变。
- en: ''
  id: totrans-96
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Lucius Cary, 2nd Viscount Falkland
  id: totrans-97
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 卢修斯·凯里，第二代福克兰子爵
- en: 'Another way to avoid unintended change, thus side effects and potential bugs,
    is to embrace *immutability* whenever possible and sensible. Even without utilizing
    any other functional principles, your codebase will become more robust thanks
    to immutability by eliminating the source of way too many bugs: *unintented change*.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种避免意外更改、从而避免副作用和潜在错误的方法是在可能和合理的情况下采用*不可变性*。即使不利用其他功能性原则，由于消除了*意外更改*作为太多错误的源头，你的代码库也会因不可变性而变得更加健壮。
- en: 'To prevent any unforeseen mutations, immutability should be the default approach
    to any type and collections used in your programs, especially in concurrent environments,
    as discussed more deeply in [Chapter 4](ch04.xhtml#_02-data-structures). You don’t
    have to reinvent the wheel for many use cases, as the JDK provides you with multiple
    options for immutable data structures:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止任何未预见的变化，不可变性应该是程序中任何类型和集合的默认方法，特别是在并发环境中，详细讨论见 [第 4 章](ch04.xhtml#_02-data-structures)。在许多使用案例中，你无需重新发明轮子，因为
    JDK 为你提供了多种不可变数据结构的选项：
- en: Immutable Collections
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变集合
- en: Even though Java doesn’t provide “fully” immutable collection types, it still
    has structurally immutable ones where you can’t add or remove elements. The concept
    of *unmodifiable* views of Collections was expanded in Java 9 by `static` factory
    methods like `List.of` to easily create structurally immutable Collections, as
    discussed in [“Moving Towards Immutability”](#_02-functional-architecture_prefer-immutability).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Java 并没有提供“完全”不可变的集合类型，但仍然有结构上不可变的类型，其中无法添加或删除元素。Java 9 中通过 `static` 工厂方法如
    `List.of` 扩展了对集合的*不可修改*视图的概念，可以轻松创建结构上不可变的集合，详见 [“迈向不可变性”](#_02-functional-architecture_prefer-immutability)。
- en: Immutable Math
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变数学
- en: The package `java.math` and its two immutable arbitrary-precision types, `BigInteger`
    and `BigDecimal`, are safe and immutable options for doing high-precision calculations.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 包 `java.math` 及其两种不可变的任意精度类型 `BigInteger` 和 `BigDecimal`，是进行高精度计算的安全和不可变选项。
- en: Records ([JEP 395](https://openjdk.java.net/jeps/395))
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 记录（[JEP 395](https://openjdk.java.net/jeps/395)）
- en: Introduced as a preview feature in Java 14 and refined in 15, Records provide
    a completely new data structure as an easy-to-use data aggregation type. They’re
    a great alternative for POJOs and sometimes Java Beans, or you could use them
    as small, localized immutable data holders, as discussed in [Chapter 5](ch05.xhtml#_02-records).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 14 中作为预览功能引入，并在 15 中进一步完善，Records 提供了一种全新的数据结构作为易于使用的数据聚合类型。它们是 POJO
    和有时 Java Beans 的良好替代品，或者你可以将它们用作小型、局部的不可变数据持有者，详见 [第 5 章](ch05.xhtml#_02-records)。
- en: Java Date and Time API ([JSR-310](https://jcp.org/en/jsr/detail?id=310))
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Java 日期和时间 API（[JSR-310](https://jcp.org/en/jsr/detail?id=310)）
- en: Java 8 also introduced a new way to store and manipulate dates and times with
    immutable types from the ground up. The API gives you a fluent, explicit, and
    straightforward way of dealing with anything related to date and time.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8 还引入了一种从根本上存储和操作日期和时间的新方法，使用不可变类型。该 API 为处理与日期和时间相关的任何事务提供了流畅、明确和简单的方式。
- en: As you can see, more and more Java APIs are built on are at least improving
    their support for immutability, and so should you. Designing your data structures
    and code with immutability in mind from the get-go saves you a lot of headaches
    in the long run. No more worrying about unintended or unexpected changes, and
    no more worries about thread safety in concurrent environments.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，越来越多的 Java API 构建或至少改进了对不可变性的支持，你也应该这样做。从一开始就考虑不可变性来设计你的数据结构和代码，可以在长期运行中为你节省大量烦恼。不再担心意外或未预期的变化，也不再担心并发环境下的线程安全问题。
- en: However, one thing to remember, is that immutability is suited best for, well,
    immutable data. Creating a new immutable data structure for any change becomes
    cumbersome really quickly regarding the required code and memory consumption by
    all those new objects.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，需要记住的一件事是，不可变性最适合于不可变数据。为任何更改创建一个新的不可变数据结构变得非常快速，需要的代码和内存消耗也会迅速增加。
- en: Immutability is one of the most important aspects you can introduce into your
    codebase, regardless of a functional approach. An “immutable first” mindset, gives
    you safer and more reasonable data structures. Still, your usual modus operandi
    might not fit into the new challenges that data management with immutability incurs.
    Remember though, it’s easier to (partially) break immutability if there’s no other
    option available than to retroactively tack-on immutability in a mature code base.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变性是您可以引入到代码库中的最重要的方面之一，无论采用何种函数方法。“不变性优先”的思维方式给您提供了更安全和更合理的数据结构。然而，您通常的操作模式可能无法适应使用不变性管理数据所带来的新挑战。但请记住，如果没有其他选择，部分地违反不变性要比在成熟的代码库中事后添加不变性更容易。
- en: Functional Data Processing with Map-Filter-Reduce
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Map-Filter-Reduce 进行函数数据处理
- en: 'Most data problems boil down to iterating over a sequence of elements, choosing
    the correct one, maybe manipulating them, performing an action, or gathering them
    into a new data structure. The following example — iterating over a list of users,
    filtering the correct ones, and notifying them — is a typical example of these
    basic steps:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数数据问题归结为迭代一系列元素，选择正确的元素，可能对它们进行操作或将它们收集到新数据结构中。以下示例——遍历用户列表，过滤正确用户并通知他们——是这些基本步骤的典型示例：
- en: '[PRE5]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Such problems are a perfect match for a functional approach with Streams and
    *map-filter-reduce*, as discussed in [“Map/Filter/Reduce”](ch06.xhtml#_02-data-processing_map-filter-reduce).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题非常适合使用流和*map-filter-reduce*的功能方法来解决，如[“Map/Filter/Reduce”](ch06.xhtml#_02-data-processing_map-filter-reduce)所讨论的。
- en: 'Instead of explicitly iterating over the users with a `for`-loop and collecting
    the correct elements in a previously defined `List`, a Stream pipeline does the
    whole task in a fluent, declarative call:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 不再通过`for`循环显式迭代用户并在先前定义的`List`中收集正确的元素，Stream 管道在流畅的声明式调用中完成整个任务：
- en: '[PRE6]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Stream pipelines express *what* to do without the boilerplate of *how* to iterate
    over the elements. They are a perfect scaffold for converting statement-based
    data filtering and transformation to a functional pipeline. The fluent call concisely
    describes the steps necessary to solve the problem, especially if you use method
    references or method calls returning the required functional interface.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Stream 管道表达了*做什么*而不需要*如何*迭代元素的样板代码。它们是将基于语句的数据过滤和转换转换为功能管道的完美支架。流畅的调用简洁地描述了解决问题所需的步骤，特别是如果使用方法引用或返回所需功能接口的方法调用。
- en: Abstractions Guide Implementations
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抽象指导实现
- en: Every project is built upon abstractions designed after the requirements.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 每个项目都是在需求之后设计的抽象基础上构建的。
- en: '*Object-oriented* design uses low-level abstractions in the form of powerful
    metaphors, defining the characteristics and constraints of a system. This domain-based
    approach is quite expressive and powerful but also restricts the versatility of
    types and how easy it is to introduce change. As requirements usually change over
    time, too restrictive abstractions lead to misalignment between different parts
    of your systems. Misaligned abstractions create friction and subtle bugs and might
    require a lot of work to realign.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*面向对象*设计使用低级抽象，形成强大的隐喻，定义系统的特性和约束。这种基于领域的方法非常表达力和强大，但也限制了类型的多样性和引入变更的易用性。由于需求通常随时间变化，过于严格的抽象导致系统不同部分之间不对齐。不对齐的抽象会导致摩擦和隐微错误，并可能需要大量工作来重新对齐。'
- en: '*Functional programming* tries to avoid misaligned abstractions by using higher
    abstractions not bound to a specific domain. [Chapter 14](ch14.xhtml#_02-design-patterns)
    reflects that by almost unconditionally replacing commonly used object-oriented
    abstractions with generalized functional interfaces of the JDK instead. This decoupling
    of abstractions from the original problem context creates simpler and easy-to-reuse
    components that are combined and mixed as necessary, enabling easier change of
    any functional system.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*函数式编程*试图通过使用不绑定于特定领域的更高级抽象来避免不对齐的抽象。[第 14 章](ch14.xhtml#_02-design-patterns)
    几乎无条件地用 JDK 的广义函数接口替换常用的面向对象抽象，从而反映出这一点。将抽象从原始问题上下文中分离出来，创建更简单易复用的组件，并根据需要进行组合和混合，更容易修改任何函数系统。'
- en: Object-oriented and imperative code is a good match for encapsulating functionality,
    object-state, and representing a problem domain. Functional concepts are an excellent
    choice for implementation logic and higher-level abstractions. Not every data
    structure must be represented in the problem domain, so using more versatile functional
    types instead creates reusable and broader types that are driven by their use
    cases instead of the domain concept.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象和命令式代码很适合封装功能、对象状态和表示问题域。函数式概念是实现逻辑和更高级别抽象的优秀选择。并非每个数据结构都必须在问题域中表示，因此使用更通用的函数式类型创建可重用和更广泛的类型，这些类型由其用例驱动，而不是由域概念驱动。
- en: To resolve this problem, you must find a balance between the two levels of abstraction
    if you want to use both in the same system. In [“Functional Architecture in an
    Imperative World”](#_02-functional-mindeset_functional-architecture), I discuss
    how to combine both as an architectural decision that gives the benefits of high-level
    functional abstractions wrapped in a familiar imperative layer.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决这个问题，如果你想在同一个系统中同时使用两个抽象级别，你必须找到两个抽象级别之间的平衡。在[“在命令式世界中的函数式架构”](#_02-functional-mindeset_functional-architecture)中，我讨论了如何将两者结合起来作为一种架构决策，从而使高级函数式抽象包装在熟悉的命令式层中带来好处。
- en: Building Functional Bridges
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建函数式桥梁
- en: A functional approach means your code most likely lives in an imperative and
    object-oriented environment that needs to work hand-in-hand with any functional
    technique or concept you want to integrate. Later in this chapter, in [“Functional
    Architecture in an Imperative World”](#_02-functional-mindeset_functional-architecture),
    I will discuss how to integrate functional code into an imperative environment.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式方法意味着你的代码很可能存在于一个需要与任何你想要集成的函数式技术或概念一起工作的命令式和面向对象的环境中。本章后面，在[“在命令式世界中的函数式架构”](#_02-functional-mindeset_functional-architecture)中，我将讨论如何将函数式代码集成到命令式环境中。
- en: But first, let’s look at how to bridge the gap between your existing code to
    the new functional APIs.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，让我们看看如何弥合你现有的代码与新的函数式 API 之间的差距。
- en: Method References-Friendly Signatures
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 方法引用友好的签名
- en: Every method, `static` or not, and any constructor is a potential method reference
    to be used in higher-order functions or represented by a functional interface.
    That’s why it can make sense to design your APIs with other functional APIs in
    mind.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 每一种方法，`static` 或者非静态的，以及任何构造函数都可以作为高阶函数中的潜在方法引用或者被函数接口表示。这就是为什么在设计你的 API 时考虑其他函数式
    API 是有意义的。
- en: For example, the commonly used Stream operations `map`, `filter`, and `sort`
    accept a `Function<T, R>`, `Predicate<T>`, and `Comparator<T>`, respectively,
    that translate well into simple method signatures.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，常用的 Stream 操作 `map`、`filter` 和 `sort` 分别接受一个 `Function<T, R>`、`Predicate<T>`
    和 `Comparator<T>`，它们很好地转换成简单的方法签名。
- en: Look at the required functional interface’s SAM; it’s the blueprint for the
    required method signature. As long as the input arguments and the return type
    match, you can name your method any way you want.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 查看所需的函数接口的 SAM；它是所需方法签名的蓝图。只要输入参数和返回类型匹配，你可以任意命名你的方法。
- en: Warning
  id: totrans-131
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: One exception to simply mapping a SAM signature to a method reference is unbound
    non-`static` method reference. As the method is referenced via the type itself
    and isn’t bound to a specific instance, the underlying lambda expression accepts
    the type as its first argument.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 将 SAM 签名简单地映射到方法引用的一个例外是未绑定的非`static`方法引用。由于该方法是通过类型本身引用的，而不是绑定到特定实例的，因此底层 lambda
    表达式接受类型作为其第一个参数。
- en: For example, `String::toLowerCase` accepts a `String` and returns a `String`,
    and is, therefore, a `Function<String, String>`, despite `toLowerCase` not having
    any arguments.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`String::toLowerCase` 接受一个 `String` 并返回一个 `String`，因此是一个 `Function<String,
    String>`，尽管 `toLowerCase` 没有任何参数。
- en: When designing any API, it makes sense to think about how it might be used by
    functional API and provide method reference-friendly signatures. Your methods
    still have expressive names depending on their surrounding context, but also build
    a bridge to functional API with simple method references.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计任何 API 时，考虑它可能如何被函数式 API 使用并提供方法引用友好的签名是有意义的。你的方法仍然根据其周围的上下文具有表达力的名称，但也建立了一个与函数式
    API 的简单方法引用的桥梁。
- en: Using Retroactive Functional Interfaces
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用反向函数接口
- en: Functional interfaces usually have marked with the `@FunctionalInterface` annotation.
    Still, as long as they fulfill the general requirements, as explained in [“Functional
    Interfaces”](ch02.xhtml#_01-functions_functional-interfaces), an interface is
    automatically a functional interface. Therefore, already existing code can benefit
    from the conciseness of lambdas and method references, and their specialized handling
    by the JVM.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 功能接口通常都标有`@FunctionalInterface`注解。只要它们满足通用要求，如 [“功能接口”](ch02.xhtml#_01-functions_functional-interfaces)
    所述，接口就自动成为功能接口。因此，已有的代码可以受益于 lambda 和方法引用的简洁性，以及 JVM 的专业处理。
- en: 'Many longstanding interfaces of the JDK are now marked with `@FunctionaInterface`,
    but your code might not have adapted yet and benefit from these changes. The following
    “now functional” interfaces were widely used even before Java 8:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: JDK 的许多长期界面现在都标有`@FunctionaInterface`，但您的代码可能尚未适应这些变化，无法从中受益。即使在 Java 8 之前，以下“现在可用的功能接口”已被广泛使用：
- en: '`java.lang.Comparable<T>`'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.lang.Comparable<T>`'
- en: '`java.lang.Runnable`'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.lang.Runnable`'
- en: '`java.util.Comparator<T>`'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.Comparator<T>`'
- en: '`java.util.concurrent.Callable<V>`'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.concurrent.Callable<V>`'
- en: 'For example, before lambdas, sorting a Collection was quite a handful because
    of all the boilerplate code:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在 lambda 出现之前，由于所有样板代码，对集合进行排序是相当麻烦的：
- en: '[PRE7]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The lambda variant tames the boilerplate quite a bit:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 变体大大简化了样板代码：
- en: '[PRE8]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'But why stop here? If you check out the functional interface `Comparator<T>`,
    you will find `static` and non-`static` helper methods to make the overall call
    even more concise without losing any expressiveness:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 但为什么要止步于此呢？如果您查看功能接口`Comparator<T>`，您将发现`static`和非`static`助手方法，可以使整体调用更加简洁，而不会失去任何表达能力：
- en: '[PRE9]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Java 8 not only introduced new functional interfaces but improved existing interfaces
    so they fit nicely into the new APIs with lots of `default` and `static` methods.
    Always check out the non-SAM methods available in functional interfaces to find
    hidden gems to simplify your code with functional composition, or common tasks
    that can be condensed into a declarative call chain.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8 不仅引入了新的功能接口，还改进了现有接口，使其可以很好地适应具有许多`default`和`static`方法的新 API。始终查看功能接口中的非
    SAM 方法，以找到可以通过功能组合简化代码或将常见任务简化为声明性调用链的隐藏宝石。
- en: Lambda Factories for Common Operations
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用于常见操作的 Lambda 工厂
- en: Designing your APIs to match other functional APIs so you can use method references
    isn’t always a possibility. That doesn’t mean that you can provide lambda factories
    to simplify the use of higher-order functions, though.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 设计您的 API 以匹配其他功能 API，这样您就可以使用方法引用并非总是可能的。这并不意味着您不能提供 lambda 工厂来简化高阶函数的使用。
- en: For example, if a method doesn’t match a particular functional interface, because
    it requires additional arguments, you can use *partial application* to make it
    fit the method signature of a higher-order function.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果一个方法不符合特定的功能接口，因为它需要额外的参数，您可以使用*部分应用*使其适应高阶函数的方法签名。
- en: 'Image a `ProductCategory` type that has a method for a localized description
    as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有一个`ProductCategory`类型，其方法返回本地化描述如下：
- en: '[PRE10]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The method is representable by a `BiFunction<ProductCategory, Locale, String>`,
    so you can’t use it for the Stream’s `map` operation and have to rely on a lambda
    expression:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法可由`BiFunction<ProductCategory, Locale, String>`表示，因此您无法将其用于 Stream 的`map`操作，并必须依赖
    lambda 表达式：
- en: '[PRE11]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Adding a `static` helper to `ProductCategory` that accepts a `Locale` and returns
    a `Function<ProductCategory, String>` allows you to use it instead of creating
    a lambda expression:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 将接受`Locale`并返回`Function<ProductCategory, String>`的`static`助手添加到`ProductCategory`中，可以使用它来代替创建
    lambda 表达式：
- en: '[PRE12]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This way, the `ProductCategory` is still responsible for creating a localized
    mapper function that it expects. However, the call is simpler, and reusable, as
    follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方式，`ProductCategory`仍然负责创建其预期的本地化映射函数。但调用更简单且可重用，如下所示：
- en: '[PRE13]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Providing lambda operations for common operations by binding factory methods
    to their related type gives you a pre-defined set of intended tasks and saves
    the caller the repetitive creation of identical lambda expressions.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将工厂方法绑定到其相关类型来提供常见操作的 lambda 操作，可以为您提供一组预定义的预期任务，并节省调用者重复创建相同 lambda 表达式的时间。
- en: Implementing Functional Interfaces Explicitly
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 显式实现功能接口
- en: 'The most common functional interfaces, discussed in [“The Big Four Functional
    Interface Categories”](ch03.xhtml#_01-functions_the-big-four), go a long way before
    you need to create your own specialized types, especially if you include multi-arity
    variants. Still, creating your own functional interfaces has a big advantage:
    a more expressive domain.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 讨论中最常见的功能接口，在[“The Big Four Functional Interface Categories”](ch03.xhtml#_01-functions_the-big-four)中有详细描述，这在您需要创建自己的专用类型之前已经足够长了，特别是如果包括多元性变体。然而，创建自己的功能接口有一个巨大的优势：更具表现力的域。
- en: 'Looking at an argument or return type alone, a `Function<Path, Path>` could
    represent anything. A type named `VideoConvertJob`, however, tells you exactly
    what’s going on. To use such a type in a functional approach, though, it has to
    be a functional interface. Instead of creating a new and isolated functional interface,
    you should extend an existing one:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 单看参数或返回类型，`Function<Path, Path>`可以代表任何东西。然而，一个名为`VideoConvertJob`的类型告诉您确切地正在发生什么。然而，要在功能方法中使用这种类型，它必须是一个功能接口。与创建新的孤立功能接口不同，您应该扩展现有的功能接口：
- en: '[PRE14]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: By choosing an existing functional interface as the baseline, your specialized
    variant is now compatible with `Function<Path, Path>` and inherits the two `default`
    methods `andThen` and `compose` to support functional composition out-of-the-box.
    The custom variant narrows down the domain and is compatible with its ancestor.
    Extending an existing interface also inherits the SAM signature.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 通过选择现有的功能接口作为基线，您的专用变体现在与`Function<Path, Path>`兼容，并继承了两个`default`方法`andThen`和`compose`以支持功能组合的开箱即用。定制变体缩小了域，并与其祖先兼容。扩展现有接口还继承了SAM签名。
- en: 'To improve the domain even further, you could add a `default` method to create
    an expressive API:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步改进域，您可以添加一个`default`方法来创建一个富有表现力的API：
- en: '[PRE15]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Adding a `default` method to implement a SAM is also the approach to make an
    existing interface conform to a functional interface without changing the original
    public contract, except for the additional functionality provided by the functional
    interface.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现SAM的方法，向现有接口添加`default`方法是一种方法，使其符合函数接口而不改变原始的公共契约，除了函数接口提供的额外功能。
- en: Making your interfaces extend a functional interface, or letting your classes
    explicitly implement a functional interface bridges between existing types and
    higher-order functions. There are still considerations to be made to satisfy Java’s
    type hierarchy rules, but accepting the least common denominator as input and
    returning the most specific type possible is a good rule of thumb.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 使您的接口扩展一个功能接口，或者让您的类显式实现一个功能接口，可以在现有类型和高阶函数之间建立桥梁。仍然需要考虑Java的类型层次结构规则，但接受输入的最低公分母并返回可能的最具体类型是一个很好的经验法则。
- en: Functional null Handling with Optionals
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Optional进行功能性空值处理
- en: Optionals are an elegant way to deal with (possible) `null` values. That alone
    is a big plus in many scenarios. Another one of its advantages is its capability
    to provide a functional starting point between a possible `null` value and subsequent
    operations.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Optional是处理（可能的）`null`值的一种优雅方式。在许多情况下，这本身就是一个巨大的优势。其另一个优点是它能够提供从可能的`null`值到后续操作之间的功能起点。
- en: 'Where a `null` reference was previously a dead end requiring additional code
    to not explode with a `NullPointException`, an Optional gives you a declarative
    pipeline replacing the usual boilerplate required to handle `null` values:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在以前`null`引用是一个死胡同，需要额外的代码来避免`NullPointException`的情况下，Optional给您提供了一个声明性流水线，替换了处理`null`值所需的通常样板代码：
- en: '[PRE16]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This pipeline replaces two `null`-checks (initial and `Group::getAdmin`), an
    `if`-statement (the `filter` operation), plus accessing the required properties
    and providing a sensible fallback. The overall task is directly expressed in the
    fluent declarative call over six lines instead of a more complex and harder-to-follow
    block of individual statements.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这个流水线取代了两个`null`检查（初始和`Group::getAdmin`）、一个`if`语句（`filter`操作），以及访问所需属性并提供合理的回退。总体任务在六行的流畅声明式调用中直接表达，而不是一个更复杂和难以跟踪的单独语句块。
- en: 'It’s hard to argue against the reduction of control statements combined with
    being a functional jump-off point and will likely increase your desire to (over)use
    Optionals, as it did for me in the beginning. Remember that Optionals were designed
    as a specialized *return* type, not as a ubiquitous replacement for `null`-related
    code. Not every value needs to be wrapped in an Optional, especially simple `null`-checks:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 很难反对控制语句的减少，结合成为一个功能性的起点，很可能会增加您对 (过度) 使用 Optional 的欲望，就像在我开始时一样。请记住，Optionals
    被设计为一种专门的 *返回* 类型，而不是用于 `null` 相关代码的普遍替代品。并不是每个值都需要包装在 Optional 中，特别是简单的 `null`
    检查：
- en: '[PRE17]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Using an Optional might *feel* cleaner — easier to follow the flow, no control
    structure, no two `null` — but as a normal Java type, creating an Optional isn’t
    free. Each operation requires checking for `null` to do its intended job and might
    create a new Optional instance. The ternary operator might not be as appealing
    as an Optional, but it sure requires fewer resources.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Optional 或许 *感觉* 更清晰 —— 更容易遵循流程，没有控制结构，没有两个 `null` —— 但作为普通的 Java 类型，创建一个
    Optional 并不是免费的。每个操作都需要检查 `null` 来执行其预期的工作，并可能创建一个新的 Optional 实例。三元操作符可能不如 Optional
    吸引人，但肯定需要更少的资源。
- en: 'Since Java 9, the utility class `java.util.Objects` got two additions to do
    simple `null`-checks with a single method call that doesn’t create additional
    instances, which are the preferred alternative to an Optional with only an `orElse`
    or `orElseGet` operation:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 自 Java 9 以来，实用类 `java.util.Objects` 增加了两个方法来进行简单的 `null` 检查，只需一个方法调用，而不创建额外的实例，这是
    Optional 的首选替代品，仅具有 `orElse` 或 `orElseGet` 操作：
- en: '[PRE18]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Using Optionals should be restricted to their intended use case as improved
    return containers for possible `null` values, and, in my opinion, intricate Optional
    pipelines with multiple operations. You shouldn’t use them in your code to perform
    simple `null`-checks, nor should methods accept them directly as their arguments.
    Method overloading provides a better alternative if an argument isn’t always required.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 应该限制使用 Optional 作为可能的 `null` 值的改进返回容器的预期用例，并且在我看来，复杂的 Optional 流水线与多个操作。您不应该在代码中使用它们来执行简单的
    `null` 检查，方法也不应直接接受它们作为参数。方法重载提供了一个更好的选择，如果参数并不总是需要。
- en: Parallelism and Concurrency Made Easy
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并行和并发变得容易
- en: Writing concurrent or parallel programs isn’t easy. Creating additional threads
    is the simple part. However, coordinating more than one thread can become quite
    complicated. The most common root of all problems related to parallelism and concurrency
    is sharing data between different threads.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 编写并发或并行程序并不容易。创建额外的线程是简单的部分。然而，协调超过一个线程可能会变得非常复杂。与并行性和并发性相关的所有问题的最常见根源是在不同线程之间共享数据。
- en: Shared data across multiple threads comes with its own requirements you don’t
    have to consider in sequential programs, like synchronization and locks to ensure
    data integrity and to prevent data races and deadlocks.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 跨多个线程共享数据会带来自己的要求，在顺序程序中无需考虑，如同步和锁以确保数据完整性并防止数据竞争和死锁。
- en: 'Functional programming creates a lot of opportunities to use concurrency and
    parallelism safely thanks to the principles functional principles are built on,
    most evidently the following:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程通过建立在函数式原则上的原则为安全地使用并发和并行创建了许多机会，最显著的是以下几点：
- en: Immutability
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变性
- en: Without change, there can’t be data races or deadlocks. Data structures can
    safely traverse thread boundaries.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 没有改变，就不会有数据竞争或死锁。数据结构可以安全地遍历线程边界。
- en: Pure functions
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数
- en: Without side effects, pure functions are isolated and can be called from any
    thread, as they only rely on their input to generate their output.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 没有副作用，纯函数是隔离的，并且可以从任何线程调用，因为它们仅依赖于它们的输入来生成它们的输出。
- en: Essentially, functional techniques don’t concern themselves with the distinction
    of sequential or concurrent execution because FP, at its most strict interpretation,
    doesn’t allow for an environment where a distinction is necessary.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，函数式技术并不关心顺序执行或并发执行的区别，因为在其最严格的解释下，函数式编程不允许存在需要区分的环境。
- en: Java’s concurrency features like parallel Streams ([Chapter 8](ch08.xhtml#_01-parallel-streams))
    and `CompletableFuture` ([Chapter 13](ch13.xhtml#_02-completable-future)) still
    require thread coordination even with fully functional code and data structures.
    However, the JDK will do it for you in a way that fits most scenarios.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Java 的并发特性，如并行流（[第 8 章](ch08.xhtml#_01-parallel-streams)）和 `CompletableFuture`
    （[第 13 章](ch13.xhtml#_02-completable-future)），即使在完全功能的代码和数据结构中，仍需要线程协调。不过，JDK
    会以适合大多数场景的方式为您完成这些工作。
- en: Be Mindful of Potential Overhead
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 要谨慎考虑潜在的开销。
- en: Functional techniques provide a great productivity boost and make your code
    more expressive and robust. That doesn’t automagically mean that it’s more performant,
    though, or even at the same performance level as imperative and object-oriented
    code.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式技术提供了巨大的生产力提升，并使您的代码更具表现力和健壮性。不过，并不意味着它自动更具性能，或者与命令式和面向对象的代码处于相同的性能水平。
- en: Java is such a versatile language that’s trusted by many companies and individuals
    because its backward compatibility and general API stability are among the best.
    However, this comes at the steep price of fewer changes to the language itself,
    at least compared to others. That’s why many features covered in this book, like
    Streams, CompleteFutures, or Optionals, aren’t native language features but are
    implemented in the JDK with ordinary Java code, instead. Even Records, a totally
    new construct with distinct semantics, boils down to a typical class extending
    `java.lang.Record`, similar to how Enums work, with the compiler generating the
    required code behind the scenes. Still, that doesn’t mean these features aren’t
    optimized in any way. They still profit from all the optimizations available to
    all Java code. In addition, lambdas are a language feature utilizing a specialized
    opcode in the JVM, with multiple optimization techniques.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Java 是一种非常多才多艺的语言，被许多公司和个人信赖，因为它的向后兼容性和通用 API 的稳定性是最好的之一。不过，这也以较少的语言本身变更为代价，至少与其他语言相比如此。这就是为什么本书涵盖的许多功能，如
    Streams、CompleteFutures 或 Optionals，并非是本地语言功能，而是使用普通的 Java 代码在 JDK 中实现的原因。即使是
    Records，作为一种完全具有独特语义的新构造，归根结底也只是扩展 `java.lang.Record` 的典型类，类似于枚举的工作方式，编译器在幕后生成所需的代码。不过，这并不意味着这些功能没有经过任何优化。它们仍然能够从所有
    Java 代码可用的优化中受益。此外，Lambda 是一种利用 JVM 中专用操作码的语言特性，具有多种优化技术。
- en: I know that using functional structures like Streams and Optionals for every
    single data processing or `null`-check is quite tempting because I fell for it
    after years of Java language stagnation. Even though they are excellent and highly
    optimized tools, you have to remember they aren’t *free* to use and will incur
    c certain unavoidable overhead.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道，像 Streams 和 Optionals 这样的函数结构，对于每一个数据处理或 `null` 检查都非常诱人，因为在多年的 Java 语言停滞后，我也曾如此。尽管它们是优秀且高度优化的工具，但您必须记住，它们并非免费使用，并将产生一定不可避免的开销。
- en: 'Usually, the overhead is negligible compared to the productivity gains and
    more concise and straightforward code. Always remember the quote by Kent Beck:
    “first make it work, then make it right, and, finally, make it fast.” Don’t forgo
    functional features and APIs in fear of the potential overhead without knowing
    it affected your code negatively in the first place. If in doubt, measure first,
    refactor second.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，与生产力收益和更简洁、更直接的代码相比，开销是可以忽略不计的。永远记住肯特·贝克（Kent Beck）的一句话：“首先让它能够运行，然后让它正确，最后让它快。”不要因为担心潜在的开销而放弃函数式特性和
    API，而不知道它们是否在首次影响您的代码。如果有疑问，先测量，再重构。
- en: Functional Architecture in an Imperative World
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在命令式世界中的函数式架构。
- en: Choosing a particular architecture isn’t an easy endeavor and has far-reaching
    consequences for any project. It’s a significant decision that can’t be changed
    without much effort. If you want to apply a more functional approach on an architectural
    level, it has to fit into an existing imperative and object-oriented code base
    without disrupting the status quo (too much).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 选择特定的架构并不是一件容易的事情，并对任何项目都有深远的影响。这是一个重大的决定，不能轻易改变。如果您想在架构层面应用更多的函数式方法，它必须适应现有的命令式和面向对象的代码库，而不会过多地破坏现状。
- en: Unsurprisingly, *functions* are the most basic and essential unit in functional
    architectures, representing isolated chunks of business logic. These chunks are
    the building blocks of workflows by being composed as needed. Each workflow represents
    a bigger logical unit, like a feature, a use case, a business requirement, etc.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 函数（*functions*）作为功能架构中最基本和必不可少的单元，毫不奇怪地代表了业务逻辑的独立块。这些块通过按需组合作为工作流的构建块。每个工作流代表一个更大的逻辑单元，比如一个特性、一个用例、一个业务需求等。
- en: A typical architectural approach to utilizing FP in an OO world is to separate
    the business logic from how it communicates with the outside world with well-defined
    boundaries. The *functional core, imperative shell* (FC/IS) approach to architecture
    is one that’s flexible in size and can be as low-impact as you want.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象的世界中，使用函数式编程的典型架构方法是通过良好定义的边界将业务逻辑与与外界通信的方式分离开来。*功能核心、命令式外壳*（FC/IS）架构方法是一种尺寸灵活且可以低影响的方法。
- en: Although it’s feasible to build a system from scratch with an FC/IS design,
    it’s also possible to integrate the design into an existing code base. An FC/IS
    is an excellent choice for gradual rewrites and refactoring to introduce functional
    principles and techniques into your OO project.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用FC/IS设计从头开始构建系统是可行的，但也可以将这种设计集成到现有代码库中。FC/IS是逐步重写和重构的绝佳选择，以引入函数式原则和技术到你的面向对象项目中。
- en: 'If you think about code and its actual purpose detached from any paradigms
    or concepts, it falls into two distinct groups: *doing* the work, and *coordinating*
    it. Instead of organizing the code and its responsibilities into a single paradigm,
    FC/IS draws a distinct line of separation between the two involved paradigms,
    as shown in [Figure 15-2](#_02-functional-architecture_func-core_imp-shell).'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你考虑代码及其实际目的，独立于任何范例或概念，它分为两个明显的组：*执行*工作和*协调*它。FC/IS并没有将代码及其责任组织成单一范式，而是在涉及的两个范式之间划清了明显的界线，如[图
    15-2](#_02-functional-architecture_func-core_imp-shell)所示。
- en: '![Basic layout of a Functional Core, Imperative Shell](assets/afaj_1502.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![功能核心、命令式外壳的基本布局](assets/afaj_1502.png)'
- en: Figure 15-2\. Basic layout of Functional Core, Imperative Shell
  id: totrans-203
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 15-2\. 功能核心、命令式外壳的基本布局
- en: 'The *functional core* encapsulates the business logic and decisions in isolated
    and purely functional units. It utilizes all that FP has to offer and does what
    it does best: working directly with data without worrying about side effects or
    state-related problems thanks to pure functions and immutability. This *core*
    is then wrapped by an *imperative shell*, a thin layer to protect it from the
    outside world, encapsulating all the side effects and any mutable state.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '*功能核心*将业务逻辑和决策封装在独立和纯函数单元中。它充分利用了函数式编程的所有优势，并且以其所长：直接处理数据，不用担心由于纯函数和不可变性而产生的副作用或状态相关问题。这个*核心*然后被*命令式外壳*包裹，一个薄层用来保护它免受外界干扰，封装所有的副作用和可变状态。'
- en: The *shell* contains the dependencies to other parts of the system and provides
    the public contract to interact with the FC/IS from the outside. Everything non-functional
    is kept away from the *core* and restricted to the *shell*. To keep the *shell*
    as thin as possible, most of the decisions remain in the *core*, so the *shell*
    only needs to delegate the work through its boundary and interpret the *core’s*
    results. It’s a glue layer handling the “real world” with all its dependencies
    and mutable state but as few paths and decisions as possible.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '*外壳*包含系统其他部分的依赖关系，并提供与外部交互的公共契约以访问 FC/IS。所有非功能性的东西都远离*核心*，并限制在*外壳*中。为了尽可能保持*外壳*的薄度，大部分决策留在*核心*中，因此*外壳*只需通过其边界委派工作并解释*核心*的结果。它是一个处理“真实世界”的胶水层，处理所有依赖项和可变状态，但尽可能少地进行路径和决策。'
- en: One of the main advantages of this design is the clear-cut split of responsibilities
    by encapsulation that occurs almost naturally as a side effect of a functional
    approach. The business logic is encapsulated in the *core*, built with *pure functions*,
    *immutability*, etc., making it easy to reason with, modular, and maintainable.
    Conversely, anything *impure* or *mutable*, or any contact with other systems,
    is restricted to the *shell* which isn’t allowed to make many decisions by itself.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计的主要优点之一是通过封装而几乎自然发生的职责明确分割。业务逻辑封装在*核心*中，使用*纯函数*、*不可变性*等构建，使得它易于推理、模块化和可维护。相反，任何*不纯的*或*可变的*东西，或者与其他系统的任何接触，都限制在*外壳*中，不能自行做出许多决策。
- en: From Objects to Values
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从对象到值
- en: From the outside, only the *imperative shell* is visible and provides a low
    level of abstraction with problem domain-specific types. It looks and feels like
    any other layer in a *usual* object-oriented Java project. The *functional core*,
    however, doesn’t need to know about the *shell* and its public contracts at all.
    Instead, it relies solely on high-level abstractions and the exchange of values
    rather than objects and how they interact with each other.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 从外部看，只有*命令式外壳*是可见的，并提供了特定于问题域类型的低抽象级别。它看起来和感觉像*通常*的面向对象Java项目中的任何其他层。然而，*函数核心*则不需要了解*外壳*及其公共契约。相反，它仅依赖于高级抽象和值的交换，而不是对象及其相互作用方式。
- en: This shift from objects to values is required to keep the *core* functional
    and independent by leveraging all available functional tools. But it also highlights
    the split in responsibilities. To keep the core *pure*, any mutability, state,
    or side effects must happen beyond the boundary in the *shell*, outside of the
    actual business logic. In its most refined form, that means that *anything* traversing
    the boundary needs to be a value, even eventual side effects! That’s why separating
    side effects from pure functions is so important to regain more control. Programming
    languages that are “more functional” than Java usually have specialized data structures
    to handle side effects, like for example Scala’s `Maybe` or `Try` types.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这种从对象到值的转变是为了通过利用所有可用的函数工具保持*核心*的功能性和独立性所必需的。但它也突显了责任的分离。为了保持*纯粹*，任何可变性、状态或副作用都必须发生在*外壳*的边界之外，而不是实际业务逻辑之内。在其最精炼的形式中，这意味着穿越边界的任何东西都必须是一个值，甚至是最终的副作用！这就是为什么将副作用与纯函数分离以重新获得更多控制是如此重要的原因。比Java“更函数化”的编程语言通常有专门的数据结构来处理副作用，比如Scala的`Maybe`或`Try`类型。
- en: Java’s closest type for handling a side effect is the `Optional<T>` type, which
    is capable of representing two states in a single type. In [Chapter 10](ch10.xhtml#_02-exception-handling),
    I also discussed how to recreate Scala’s Try/Success/Failure pattern in Java to
    handle control-flow disruptions due to Exceptions in a more functional manner.
    Still, the additional code and boilerplate required to tame side effects is a
    clear indicator that they should be handled in the *imperative shell* where the
    appropriate tools and constructs are available, unlike in the *functional core*,
    where it’s at least not desirable to do so.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Java 处理副作用最接近的类型是`Optional<T>`类型，能够在单一类型中表示两种状态。在[第10章](ch10.xhtml#_02-exception-handling)中，我还讨论了如何在Java中重新创建Scala的Try/Success/Failure模式，以更函数式的方式处理由于异常而导致的控制流中断。然而，驯服副作用所需的额外代码和样板文件清晰地表明它们应在*命令式外壳*中处理，这里有适当的工具和结构，不像在*函数核心*中那样是至少不希望这样做的。
- en: Separation of Concerns
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关注点分离
- en: Functions come to their conclusions solely based on their arguments, without
    accessing or changing the world around them. Still, at some point, change might
    be necessary, like persisting data, mutating state in the *shell*.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 函数仅基于其参数得出结论，而不访问或改变其周围的世界。然而，改变可能是必要的，比如在*外壳*中持久化数据、改变状态。
- en: The *core* is only responsible for decision-making but not acting on such decisions.
    That’s why all changes, even side effects, must be representable as values, too.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '*核心*仅负责决策，而不是对这些决策采取行动。这就是为什么所有的变化，甚至是副作用，也必须能够作为值来表示。'
- en: 'Imagine you want to scrape a website for certain information and store it in
    a database. The overall task consists broadly speaking of the following steps:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，您想要从网站上爬取某些信息并将其存储在数据库中。总体任务大致包括以下步骤：
- en: Load content of a website
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载网站内容
- en: Extract the necessary information
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提取必要的信息
- en: Decide if the information is relevant
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 决定信息是否相关
- en: Persist data in a database
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在数据库中持久化数据
- en: To fit the task into an FC/IS system, you first need to categorize them by their
    responsibilities.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 要将任务适应FC/IS系统，首先需要根据其责任对其进行分类。
- en: Loading the content and persisting the data is clearly I/O, which includes side
    effects, and therefore, belongs into the *shell*. Information extraction and deciding
    if it’s relevant is data processing that fits into the *core*. This categorization
    leads to the separation of tasks as illustrated in [Figure 15-3](#_02-functional-architecture_func-core_imp-shell_scraping).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 加载内容和持久化数据显然是 I/O 操作，包括副作用，因此属于*shell*。信息提取和决定其是否相关是数据处理，适合*core*。这种分类导致了任务分离，如[图
    15-3](#_02-functional-architecture_func-core_imp-shell_scraping)所示。
- en: '![Web-scraping responsibilities in FCIS](assets/afaj_1503.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![FCIS 中的网页抓取责任](assets/afaj_1503.png)'
- en: Figure 15-3\. Web-scraping responsibilities in FCIS
  id: totrans-222
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 15-3\. FCIS 中的网页抓取责任
- en: As you can see in the figure, the *shell* interacts with the network and passes
    the content immediately to the *core*. The *core* receives an immutable `String`
    value and returns an `Optional<String>` to indicate if the information is relevant
    based on its business logic. If a value is received back in the *shell*, it persists
    the value and any other information it still has access to in its context.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如图所示，*shell* 与网络交互，并立即将内容传递到*core*。*core* 接收一个不可变的 `String` 值，并返回一个 `Optional<String>`，以表明根据其业务逻辑信息是否相关。如果*shell*
    收到一个值，它将持久化该值以及它在上下文中仍然可以访问的任何其他信息。
- en: 'The separation of concerns brings another advantage to the code. From a modularity
    standpoint, the *core* is capable of using any input source, not just a website.
    This makes data processing more flexible and reusable. For example, instead of
    scraping a single site and passing its content directly to the *core* for processing,
    multiple pages could be scraped beforehand and persisted in a database for later
    processing. The *core* doesn’t care and doesn’t even need to know where the content
    comes from; it’s entirely focused on its isolated task: extracting and evaluating
    information. So even if the overall requirements change, the *core* doesn’t necessarily
    have to change, too. And if it does, you can recombine the existing small logical
    units as needed.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 关注点分离为代码带来另一个优势。从模块化的角度来看，*core* 能够使用任何输入源，而不仅仅是一个网站。这使得数据处理更加灵活和可重用。例如，可以先抓取多个页面并将其持久化在数据库中以供后续处理，而不是直接将其内容传递给*core*进行处理。*core*
    不关心数据的来源，甚至不需要知道内容从何而来；它完全专注于其孤立的任务：提取和评估信息。因此，即使整体要求发生变化，*core* 也不一定需要改变。如果确实需要改变，可以根据需要重新组合现有的小逻辑单元。
- en: The Different Sizes of an FC/IS
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FC/IS 的不同尺寸
- en: 'An FC/IS might seem like a singular organizational layout that your system
    is built around. That’s one way to do it, yet there’s a more flexible way to integrate
    the FC/IS architecture into a system: multiple FC/IS with different sizes.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: FC/IS 可能看起来像是你的系统围绕的一个独特的组织布局。这是一种做法，但有一种更灵活的方式将 FC/IS 架构集成到系统中：使用不同尺寸的多个 FC/IS。
- en: Unlike other architectural designs, it doesn’t have to define or dominate a
    project. It doesn’t matter if your whole application is built around a singular
    or multiple FC/IS. Even creating an FC/IS for a sole task is possible. As long
    as an *imperative shell* integrates with the rest of the system, you’re good to
    go!
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他架构设计不同，它不必定义或主导一个项目。不管你的整个应用程序是围绕单个还是多个 FC/IS 构建的，甚至创建一个 FC/IS 用于单一任务也是可能的。只要*命令式
    shell* 与系统的其余部分集成，你就可以顺利进行！
- en: The dynamic sizing and integration of FC/IS allow for a gradual transition toward
    more functional logic in your codebase without breaking pre-existing structures.
    Creating multiple FC/IS, as seen in [Figure 15-4](#_02-functional-architecture_multi-func-core_imp-shell),
    can coexist and interact with prior systems without anyone even noticing it from
    the outside.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: FC/IS 的动态大小和集成允许在代码库中向更功能逻辑的逐步过渡，而不会破坏现有的结构。创建多个 FC/IS，如[图 15-4](#_02-functional-architecture_multi-func-core_imp-shell)，可以与之前的系统共存并相互交互，而外部用户甚至可能察觉不到这一点。
- en: '![Multiple FI/CS interacting with an existing system](assets/afaj_1504.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![与现有系统交互的多个 FI/CS](assets/afaj_1504.png)'
- en: Figure 15-4\. Multiple FI/CS interacting with an existing system
  id: totrans-230
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 15-4\. 与现有系统交互的多个 FI/CS
- en: A sensible approach for sizing an FC/IS is thinking about its context and capabilities.
    The boundaries to the outside world — the *shell’s* surface — are the first indicator
    of the required size. Reducing the coupling between different systems ensures
    modularity, extensibility, and maintainability over time. The context is defined
    by the encapsulated specialized domain knowledge represented in the *core*, and
    by extension, the public contract of the *shell*.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 对于确定 FC/IS 的大小，一个明智的方法是考虑其上下文和能力。与外界的边界 — *外壳的* 表面 — 是所需大小的第一个指标。减少不同系统之间的耦合确保模块化、可扩展性和可维护性。
- en: Defining the correct context and appropriate boundaries is crucial and gets
    easier with experience. An FC/IS should be as small as possible but as big as
    necessary. Functional units or whole functional groups of a core can be reused
    in other FC/IS to facilitate multiple small but specialized FC/IS instead of a
    singular “all-inclusive” one. With these smaller and isolated FC/IS it’s easier
    to start replacing and integrating them into even complex pre-existing systems
    step-by-step.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 定义正确的上下文和适当的边界对经验来说至关重要，并且随着经验的积累变得更加容易。一个 FC/IS 应该尽可能小，但也要尽可能大。核心的功能单元或整个功能组可以在其他
    FC/IS 中重复使用，以便于逐步在甚至是复杂的预先存在的系统中替换和集成它们。
- en: Testing an FC/IS
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试一个 FC/IS
- en: As with any other refactoring effort, when you adopt an FC/IS design, you should
    verify your new structures with appropriate testing, such as unit and integration
    tests. If your code has dependencies, or I/O like a database, testing usually
    requires mocks or stubs to better isolate the tested components.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何其他重构工作一样，当您采用 FC/IS 设计时，应该使用适当的测试（如单元测试和集成测试）验证新结构。如果您的代码有依赖关系或像数据库这样的 I/O，则通常需要使用模拟或存根来更好地隔离测试的组件。
- en: 'While libraries are available to streamline creating such replacements, the
    whole concept comes with some drawbacks:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有库可以简化创建这种替代方案，但整个概念也带来了一些缺点：
- en: Knowledge of implementation details
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 实施细节的了解
- en: Mocks often require detailed implementation knowledge to work as intended. Such
    details might change over time, and every refactor attempt tends to break the
    mocks and stubs mimicking them, even without changing the public contracts or
    the test logic.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟通常需要详细的实现知识才能按预期工作。这些细节可能会随着时间的推移而发生变化，即使不改变公共契约或测试逻辑，每次重构尝试也会破坏模仿它们的模拟和存根。
- en: Incidental testing
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 偶发性测试
- en: Tests should be on point, only testing the absolute minimum to ensure correctness.
    Dependencies create additional layers to consider, though, even if the intended
    story of the test hides underneath. Debugging such tests can be a nuisance because
    you no longer only debug the test and functionality itself but also any other
    layer present.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 测试应该精确到点，仅测试绝对最小限度以确保正确性。依赖关系会创建额外的考虑层，即使测试的预期故事隐藏在下面。调试这样的测试可能很麻烦，因为你不仅需要调试测试本身和功能本身，还需要考虑其他任何层次的存在。
- en: Fictional testing
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文由封装的专业领域知识在 *核心* 中和由此扩展的 *外壳* 的公共契约表示。
- en: Typically, a dependency is correctly initialized and in a guaranteed meaningful
    state. On the other hand, Mocks and stubs are essentially fictional implementations
    to reduce the coupling between components and fulfill the minimal set of requirements
    for the test.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，依赖项会正确初始化并处于保证的有意义状态。另一方面，模拟和存根基本上是虚构的实现，用于减少组件之间的耦合并满足测试的最小要求集。
- en: The FC/IS architecture reduces these usual drawbacks thanks to its clear separation
    of responsibilities which is mirrored in its testability.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: FC/IS 架构通过其责任的明确分离显著减少了这些通常的缺点，这种分离在其可测试性中得到了体现。
- en: The *functional core* — the business logic of the system — consisting of pure
    functions which are often naturally isolated, is a perfect match for unit testing.
    The same test input needs to fulfill the same assertions. That’s why the core
    is usually easy to verify with small and on-point unit tests without test doubles
    compared to larger interconnected systems with more complex setup requirements.
    This general lack of dependencies eliminates the need for mocks and stubs.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '*功能核心* — 系统的业务逻辑 — 由纯函数组成，这些函数通常是自然隔离的，非常适合单元测试。相同的测试输入需要满足相同的断言。因此，与具有更复杂设置要求的更大互联系统相比，核心通常很容易通过小型和精准的单元测试来验证，而无需使用测试替身。这种一般性的无依赖性消除了模拟和存根的需求。'
- en: The *imperative shell* still has dependencies and side effects and is, obviously
    not as easily testable as the *core*; it still needs integration tests. However,
    having most of the logic in the *core* that’s easily unit-testable, requires fewer
    tests to verify the *shell*. Any new FC/IS can rely on tested and verified functional
    code that’s easy to reason with, with only a new *shell* needing to be verified.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '*命令式外壳*仍然具有依赖性和副作用，并且显然不像*核心*那样易于测试；它仍然需要集成测试。然而，将大部分逻辑放在易于单元测试的*核心*中，需要较少的测试来验证*外壳*。任何新的FC/IS都可以依赖于经过测试和验证的函数式代码，易于理解，只需验证新的*外壳*。'
- en: Final Thoughts on a Functional Approach to Java
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对Java函数式方法的最终思考
- en: Although I’m obviously a proponent of functional techniques wherever possible
    and sensible, my day-to-day Java work is still shaped by primarily imperative
    and object-oriented code. You may also be in a similar situation. In my company,
    Java 8 and its successors allowed us to introduce functional techniques step-by-step
    and at our own pace without the need to rewrite the whole architecture or codebase.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管显然我是函数式技术的支持者，在可能和合理的地方，我的日常Java工作仍然主要受命令式和面向对象编码的影响。你可能也处于类似的情况。在我们公司，Java
    8及其后续版本使我们能够逐步引入函数式技术，而无需重写整个架构或代码库。
- en: For example, slowly establishing immutability throughout the code and as the
    new baseline for data structures eliminated a whole category of problems that
    is usually present in an OO approach. Even hybrid approaches, like the previously
    mentioned partially immutable `SessionState` type eliminated certain unfavorable
    scenarios that could introduce subtle and hard-to-debug problems.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，逐步在整个代码中建立不变性，作为数据结构的新基线，消除了通常在面向对象方法中存在的一整类问题。甚至是混合方法，比如前面提到的部分不可变的`SessionState`类型，也消除了可能引入微妙且难以调试问题的某些不利场景。
- en: Another significant improvement was designing method signatures with Optionals
    in mind. It made the intent of a method more evident, communicating the possibility
    of missing values clearly with the caller, resulting in fewer `NullPointerException`
    without requiring an abundance of `null`-checks.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的改进是设计方法签名时考虑了Optionals。它使方法的意图更明显，与调用者清晰地传达可能缺失值的可能性，从而减少了`NullPointerException`，而无需大量的`null`检查。
- en: Functional idioms, concepts, and techniques aren’t that far out from object-oriented
    ones as it’s often proclaimed. Sure, they are different approaches to solving
    similar problems. Most benefits of functional programming can be reaped in object-oriented
    and imperative environments, too.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式习语、概念和技术与面向对象的并不那么遥远，如人们经常宣称的那样。当然，它们是解决类似问题的不同方法。函数式编程的大多数优点也可以在面向对象和命令式环境中获得。
- en: Java, as a language, might be lacking support for certain functional constructs.
    However, Java, the platform with a vast ecosystem brings in so many benefits regardless
    of the chosen paradigm.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: Java作为一种语言，可能缺乏对某些函数式构造的支持。然而，作为一个生态系统广泛的平台，Java带来了许多好处，无论选择哪种编程范式。
- en: Fundamentally, functional programming is a thought process, not a specific language
    per se. You don’t have to start a system from scratch to benefit from it. Starting
    from scratch often focuses on productivity instead of required breadth. Due to
    an ever-changing and evolving codebase, it’s easy to overlook necessary edge cases
    and non-common constructs most systems rely on. Instead of going back to square
    one, you can reduce the overall complexity by gradually rewriting, refactoring,
    and injecting a *functional mindset* step-by-step.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 从根本上说，函数式编程是一种思维过程，而不是特定的语言。你不必从零开始建立系统来受益。从头开始往往关注的是生产力而不是所需的广度。由于代码库不断变化和演变，很容易忽视必要的边缘情况和大多数系统依赖的非常见结构。与其回到原点，不如逐步重写、重构和逐步注入*函数式思维*来减少总体复杂性。
- en: Still, not every data structure needs to be redesigned, and not each type to
    be made fully functional. The way to build a *functional mindset* is to exercise
    it. Start small, and don’t force it. The more you use functional constructs, the
    easier you will identify code that can benefit from the functional tools that
    Java provides.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，并非每种数据结构都需要重新设计，也不是每种类型都需要完全功能化。建立*函数式思维*的方法是实践它。从小事做起，不要强迫。你使用函数式构造的越多，就越容易识别可以从Java提供的函数式工具中受益的代码。
- en: The overarching goal of a functional approach is reducing the required cognitive
    capacity to understand and reason with your code. More concise and safer constructs,
    like pure functions and immutable data structures, improve reliability and long-term
    maintainability. Software development is about controlling complexity with the
    right tools, and in my opinion, the functional toolset that Java 8+ provides is
    quite powerful to tame your imperative and object-oriented Java code.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式方法的首要目标是减少理解和推理代码所需的认知能力。更简洁和更安全的构造，比如纯函数和不可变数据结构，提高了可靠性和长期可维护性。软件开发是关于用正确的工具控制复杂性，在我看来，Java
    8+提供的函数式工具集非常强大，可以驯服你的命令式和面向对象的Java代码。
- en: 'No matter which functional techniques and concepts you integrate into your
    projects, the most important lesson that I hope you take away from my book, in
    my opinion, is that it doesn’t actually matter if you do OOP or FP. Brian Goetz,
    the Java Language Architect at Oracle, said it quite well in one of his talks:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您将哪些函数式技术和概念集成到您的项目中，我希望您从我的书中学到的最重要的一课，在我看来，就是无论您选择面向对象编程还是函数式编程都没有关系。Oracle的Java语言架构师Brian
    Goetz在其中一次演讲中说得很好：
- en: Don’t be a functional programmer.
  id: totrans-255
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 不要成为一个函数式程序员。
- en: Don’t be an object-oriented programmer. Be a better programmer.
  id: totrans-256
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 不要成为一个面向对象的程序员。成为一个更好的程序员。
- en: ''
  id: totrans-257
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Brian Goetz, FP vs OO: Choose Two'
  id: totrans-258
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Brian Goetz，FP vs OO：选择两者
- en: Software development is about choosing the most appropriate tool for a given
    problem. Incorporating the functional concepts and techniques available to us
    as Java developers in our day-to-day work adds invaluable new tools to our toolbox,
    which create more readable, reasonable, maintainable, and testable code.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发是关于选择最合适的工具来解决特定的问题。在我们作为Java开发人员日常工作中，将函数式概念和技术纳入我们工具箱是一种宝贵的新工具，它可以创建更可读，更合理，更易维护和可测试的代码。
- en: Takeaways
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 要点
- en: OOP and FP are quite dissimilar in their core concepts. However, most of their
    concepts aren’t mutually exclusive or completely orthogonal. Both can solve the
    same problems but with different approaches.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向对象编程（OOP）和函数式编程（FP）在其核心概念上有很大不同。然而，它们大多数概念并非互斥或完全正交。两者都可以用不同的方法解决同样的问题。
- en: Reasonable code is the ultimate goal, and a *functional mindset* helps achieve
    it.
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合理的代码是最终目标，*函数式思维方式*有助于实现这一目标。
- en: A *functional mindest* starts small with steps, like avoiding *side effects*
    with the help of *pure functions* or embracing *immutability*.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*函数式思维方式*从小事做起，比如通过*纯函数*避免*副作用*或者接受*不可变性*。'
- en: Functional principles can also be part of architectural decisions, like separating
    concerns by splitting the business logic and the exposed *surface* to other systems
    with designs like a *functional core, imperative shell*.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式原则也可以成为架构决策的一部分，比如通过将业务逻辑和暴露给其他系统的*表面*分离，采用类似*函数核心，命令式外壳*的设计。
- en: The *functional core, imperative shell* design is an excellent tool for gradually
    introducing functional principles and concepts into existing code.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*函数核心，命令式外壳*设计是逐渐将函数式原则和概念引入现有代码的极好工具。'
- en: ^([1](ch15.xhtml#idm45115212232256-marker)) Salus, Peter H. 1994\. “A Quarter-Century
    of Unix.” Addison-Wesley. ISBN 0-201-54777-5.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch15.xhtml#idm45115212232256-marker)) Salus, Peter H. 1994\. “A Quarter-Century
    of Unix.” Addison-Wesley. ISBN 0-201-54777-5.
- en: About the Author
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 作者简介
- en: Using his first computer at the age of four, **Ben Weidig** is a self-taught
    developer with almost two decades of experience in professional web, mobile, and
    systems programming in various languages.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在四岁时使用他的第一台计算机开始，**Ben Weidig**是一位自学成才的开发人员，在职业网页，移动和系统编程中拥有近20年的经验，使用多种语言。
- en: After learning the ropes of professional software development and project management
    at an international clinical research organization, he became a self-employed
    software developer. He merged with a SaaS company after prolonged and close collaboration
    on multiple projects. As co-director, he shapes the company’s general direction,
    is involved in all aspects of their Java-based main product, and oversees and
    implements its mobile strategy.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在国际临床研究组织学习专业软件开发和项目管理经验后，他成为一名自由职业软件开发人员。在多个项目上经过长时间而密切的合作后，他与一家SaaS公司合并。作为联合主管，他塑造了公司的总体方向，参与了其基于Java的主要产品的所有方面，并监督并实施其移动战略。
- en: In his free time, he shares his expertise and experiences by writing articles
    about Java, functional programming, best practices, and code-style in general.
    He also participates in Open-Source, either as a committer to established projects
    or releasing code of his own.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在业余时间，他通过撰写关于Java、函数式编程、最佳实践以及一般代码风格的文章，分享他的专业知识和经验。他还参与开源项目，不论是作为已建立项目的提交者，还是发布自己的代码。
