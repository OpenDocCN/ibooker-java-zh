- en: Chapter 15\. A Functional Approach to Java
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many programming languages support both a functional and imperative code style.
    However, the syntax and facilities of a language typically incentivize specific
    approaches to common problems. Even with all the functional additions to the JDK
    discussed in this book, Java still favors imperative and object-oriented programming,
    with most of the core libraries’ available types and data structures reflecting
    this preference.
  prefs: []
  type: TYPE_NORMAL
- en: However, as I’ve discussed throughout this book, that doesn’t mean it has to
    be an “either-or” kind of situation. You can augment your OO code with functional
    principals without going fully functional. Why not have the best of both worlds?
    To do so, you need to adopt a functional mindset.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter pulls together what you’ve learned in this book so far and highlights
    the most important aspects that will influence your functional mindset. It also
    shows a practical application of functional programming techniques on an architectural
    level that fits right into an object-oriented environment.
  prefs: []
  type: TYPE_NORMAL
- en: OOP Versus FP Principles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To better understand where functional principles can improve your code, it makes
    sense to revisit the underlying principles of both paradigms — object-oriented
    and functional — to recognize their dissimilarities and possible interconnection
    points. This builds the base knowledge to identify opportunities to incorporate
    a functional approach into your OO code and where it doesn’t make sense to force
    it.
  prefs: []
  type: TYPE_NORMAL
- en: '*Object-oriented* programming’s main concerns are encapsulating data and behavior,
    polymorphism, and abstraction. It’s a *metaphor-based* approach to solving problems
    where its objects and connecting code mimic a particular problem domain. These
    objects interact by messaging through public contracts, like interfaces, and each
    has responsibilities and usually manages its own state. Using such metaphors bridges
    the gap between the computer, which requires a set of instructions, and the developer,
    which can express their intent in a straightforward manner. OOP is an excellent
    approach to structuring and organizing imperative code after the “real world”
    and its constant and endless changes.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Functional programming*, however, uses mathematical principles to solve problems,
    utilizing a *declarative* code style. Instead of requiring a metaphor to model
    your code like the “real world”, its foundation — *lambda calculus* — only cares
    about data structures and their transformation using high-level abstractions.
    Functions take an input and create an output, that’s about it! Data and behavior
    aren’t encapsulated; functions and data structures *just are*. FP circumvents
    many typical OOP and Java problems, like handling mutable state in a concurrent
    environment or unexpected side effects, by trying not to have any side effects,
    to begin with.'
  prefs: []
  type: TYPE_NORMAL
- en: These two short summaries already highlight the dissimilarity of the core principles
    of object-oriented and functional programming. OOP tries to tame complexity by
    encapsulating the moving parts of your code in a familiar domain, whereas FP strives
    to have fewer parts in total by adhering to mathematical principles. The more
    abstract way of thinking in FP is why OOP is often the preferred first approach
    to teaching and learning Java.
  prefs: []
  type: TYPE_NORMAL
- en: As I discussed in [Chapter 14](ch14.xhtml#_02-design-patterns), both paradigms
    are just divergent approaches able to solve the same problems coming from different
    directions. It would be foolish to declare that one principle is, no pun intended,
    objectively better than the other. Metaphors in OO are a powerful tool to make
    code feel more natural to non-programmers and programmers alike. Some complex
    problems benefit from a good metaphorical representation way more than a maybe
    more concise but highly abstracted functional approach.
  prefs: []
  type: TYPE_NORMAL
- en: A Functional Mindset
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any fool can write code that a computer can understand. Good programmers write
    code that humans can understand.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Martin Fowler, Refactoring: Improving the Design of Existing Code'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: You can have all the functional tools available at your fingertips, but using
    them efficiently requires the right mindset to do so. Having a functional mindset
    involves having the reasoning to identify code that could be improved with a functional
    approach, be it going fully functional, or just injecting a few functional techniques
    and principles at critical, and appropriate, places. This mindset won’t come overnight;
    you have to hone it with practice to gain experience and intimation
  prefs: []
  type: TYPE_NORMAL
- en: Developing this functional mindset starts with wanting to eliminate or reduce
    any accidental complexity in your code. The techniques and principles you use
    to solve your problems should lead to code that is reasonable and easier to understand.
  prefs: []
  type: TYPE_NORMAL
- en: To reason with a complex system means grasping and figuring out any code with
    only the information that’s *right in front of you* rather than relying on hidden-away
    implementation details or maybe outdated comments, without any surprises waiting
    for you. You don’t need to look across multiple files or types to understand the
    problem that is solved, or don’t need to ponder about many of the decisions that
    went into the code itself.
  prefs: []
  type: TYPE_NORMAL
- en: The correctness of your code is informally proven because any claim about its
    functionality is backed up by its reasonability and accompanying comments. Anyone
    using such code can make strong assumptions about it and rely on its public contracts.
    The opaque nature of OOP and its encapsulation of behavior and data often makes
    it harder to reason with than alternative approaches.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s revisit the different aspects of functional programming that will influence
    your decision when to apply a functional approach.
  prefs: []
  type: TYPE_NORMAL
- en: Functions are First-Class Citizens
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Functional programming is all about functions and their *first-class citizenship*.
    That means that functions are tantamount to other constructs of the language because
    you can:'
  prefs: []
  type: TYPE_NORMAL
- en: Assign functions to variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pass functions as arguments to another function/method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return a function from a function/method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create anonymous functions without a name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These properties are pretty similar to how anonymous classes are usable in Java,
    even before the introduction of lambda expressions. Unlike anonymous classes,
    though, functional interfaces — Java’s representation of the concept of functions — are
    conceptionally more generalized and usually detached from an explicit class or
    domain type. Furthermore, the JVM uses them differently thanks to the `invokedynamic`
    opcode, as explained in [“The `invokedynamic` Instruction”](ch02.xhtml#_01-functional-java_invokedynamic),
    which allows for a greater variety of optimizations compared to anonymous classes.
  prefs: []
  type: TYPE_NORMAL
- en: Even though Java doesn’t have “on the fly” types and requires any lambda expression
    to be represented by concrete functional interfaces, it still manages to allow
    you to use one of the big differentiators between OO and FP because it provides
    a higher level of abstraction. Functional abstractions are on a higher level than
    their OO counterparts. That means that FP focuses on values instead of discrete
    domain-specific types with rigid data structures.
  prefs: []
  type: TYPE_NORMAL
- en: Think of functions and their higher level of abstraction as small cogs in a
    machine. Object-oriented cogs are bigger and specifically designed for a narrower
    scope of tasks; they only fit into specific parts of the machine. The smaller
    functional cogs, however, are more uniform and generalized, and therefore, easier
    to use throughout the machine. They can then be composed into groups, going from
    a singular simple task toward a complex and more complete one. The bigger task
    is the sum of all its smaller parts, with the parts themselves being as small
    and generic as possible, reusable, and easily testable. This way, you can build
    a library of reusable functions to be composed as necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Still, Java’s dependence on functional interfaces to represent functions and
    lambdas is both a blessing and a curse.
  prefs: []
  type: TYPE_NORMAL
- en: It’s a curse because you can’t have a detached lambda that’s only based on its
    arguments and return type without a corresponding functional interface. Type inference
    eases the pain but at some point, the actual type must be available for the compiler
    to infer the type down the line.
  prefs: []
  type: TYPE_NORMAL
- en: It’s also a blessing because it’s the perfect way of bridging between Java’s
    static type system and the predominantly imperative object-oriented code style
    and a new way of thinking without breaking backward compatibility.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding Side Effects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Asking a question shouldn’t change the answer.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Bertrand Meyer, French academic
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Having a functional mindset also involves avoiding side effects. From a functional
    point of view, side effects refer to the modification of any kind of state which
    can have many forms. It doesn’t have to be hidden or unexpected, quite the contrary.
    Many forms of side effects, like accessing a database, or doing any kind of I/O,
    are intended actions and are a crucial part of almost every system. Nevertheless,
    fewer side effects usually mean fewer surprises in your code and a smaller bug
    surface.
  prefs: []
  type: TYPE_NORMAL
- en: There are several functional ways to reduce the number of side effects, or at
    least make them more manageable.
  prefs: []
  type: TYPE_NORMAL
- en: Pure Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The most basic approach to avoid side effects is using the functional programming
    concept of *pure functions* because they rely on two elemental guarantees:'
  prefs: []
  type: TYPE_NORMAL
- en: The same input will *always* create the same output.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pure functions are *self-contained* without any side effects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Seems simple enough.
  prefs: []
  type: TYPE_NORMAL
- en: In reality, however, there are more aspects you have to look out for when improving
    the purity of your Java code.
  prefs: []
  type: TYPE_NORMAL
- en: Any pure function can only rely on the declared input arguments to produce its
    result. Any hidden state or invisible dependencies are a big no-no.
  prefs: []
  type: TYPE_NORMAL
- en: 'Think of a function that creates a greeting for a `User` instance with a method
    signature as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The method signature, its public contract, discloses a singular dependency:
    the `User` argument. If you don’t know the actual implementation, it would be
    safe to assume that this is a pure function that produces the same salutation
    for repeated calls with the same user.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at its implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Checking out the implementation, however, a second dependency reveals itself:
    the time of day. This invisible dependency that relies on an out-of-context state
    makes the whole method impure.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To regain purity, the second internal dependency must be made part of the public
    contract instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Purity is restored and the public contract no longer hides the internal dependency
    on the time of day and communicates it clearly, without requiring any documentation.
  prefs: []
  type: TYPE_NORMAL
- en: The method signature could still be simplified further. Why bind the method
    to the `User` type if only its `name` is used? Why use `LocalTime` if only its
    hour is used? Creating a more versatile `buildGreeting` method would accept only
    the `name` and not a whole `User` instance.
  prefs: []
  type: TYPE_NORMAL
- en: The lowest common denominator of arguments will give the most versatile and
    broadly applicate pure function possible. Try to avoid nested calls to broaden
    the applicability of a method by going closer to the actual required value instead
    of relying on specific domain types.
  prefs: []
  type: TYPE_NORMAL
- en: The best way to think about pure functions is to see them totally isolated in
    their own space-time continuum detached from the rest of the system. That’s why
    they need to receive all of their requirements explicitly as values, preferably
    with as few intermediate objects as possible. However, such a higher abstraction
    forfeits some of the method signature’s expressiveness, so you must find an acceptable
    balance.
  prefs: []
  type: TYPE_NORMAL
- en: Pure functions are a cornerstone of functional programming. Reducing a task
    to “same input + processing → same output” makes method signatures more meaningful
    and easier to comprehend.
  prefs: []
  type: TYPE_NORMAL
- en: Pure Object Methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Pure functions only exist within their own context which is why they can only
    rely on their input arguments to create their output. Translating this principle
    into an object-oriented environment is a little bit more difficult.
  prefs: []
  type: TYPE_NORMAL
- en: Looking deeper at the two guarantees of pure functions from the point of view
    of an object-oriented programmer, they reveal the possibility of applying them
    in a broader sense to create a more hybrid approach I call *pure object methods*.
  prefs: []
  type: TYPE_NORMAL
- en: If a method on an object type is truly *pure* in the previously discussed sense,
    it could be made `static` and doesn’t even need to be in the object type anymore.
    Still, binding methods to their related type that’s a part of their input is an
    advantage and won’t go away anytime soon.
  prefs: []
  type: TYPE_NORMAL
- en: Take the `buildGreeting` method from the previous section as an example. Even
    though it can be made a pure function in the form of a `static` method, adding
    it directly to the `User` type as an instance method makes sense. However, this
    will harm reusability because it doesn’t exist in complete isolation anymore and
    is interconnected with its surrounding type itself. This relationship doesn’t
    mean it can’t be “as pure as possible,” though.
  prefs: []
  type: TYPE_NORMAL
- en: As good object types do, the `User` type encapsulates its state and creates
    its own microcosmos mostly disconnected from the outside. A *pure object method*
    might access that microcosmos and treat them as additional input arguments. The
    main caveat, though, is the non-reusable nature of methods bound to specific types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other multi-paradigm languages supporting an object-oriented programming style,
    like Python, make this approach more visible, as the following code shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Using `self` — Python’s equivalent to Java’s `this` — as an explicit input parameter
    on each method highlights the interdependence between the method on the instance
    itself. Even if an object’s method affects its state, it can still be a “pure
    object method” as it doesn’t have any side effects besides its internal state.
    The object itself becomes part of the input, as it encapsulates the side effect,
    and its state after the call makes them the output.
  prefs: []
  type: TYPE_NORMAL
- en: The functional design principles of pure functions are still useful if you have
    to deal with object types and can’t refactor them to a new design. The same rules
    apply, but the object state counts as an input argument. That’s why further dependencies
    like `time` in `buildGreeting` shouldn’t be hidden away from anyone using the
    method. Calling the same method with the same input on two identical objects should
    result in an equal output or new object state.
  prefs: []
  type: TYPE_NORMAL
- en: Pure object methods might not bring in all the advantages of a fully functional
    approach with pure functions and immutable data structures, especially regarding
    reusability. Still, the functional mindset injected into the object-oriented style
    gives you more approachable, safer, more predictable, and therefore, more reasonable
    types.
  prefs: []
  type: TYPE_NORMAL
- en: Isolating with Side Effects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s impossible to write applications with absolutely zero side effects. OOP,
    or imperative code in general, is usually intertwined with mutable states and
    side effects. Still, side effects affecting your state are often invisible at
    the surface, easily breaking the reasonability of code and introducing subtle
    bugs if used incorrectly. If you can’t completely avoid a side effect with techniques
    such as *pure functions*, they should be *isolated*, preferably on the edges of
    your logical units, instead of littering them throughout the code. By splitting
    bigger units of code into smaller tasks, the possible side effects will be restricted
    to and affect only some of the tasks and not the overall unit.
  prefs: []
  type: TYPE_NORMAL
- en: 'This mindset is also present in the *Unix philosophy*, originated by Ken Thompson,
    the co-creator of the UNIX operating system. Doug McIlroy — head of the Bell Labs
    Computing Sciences Research Center at the time and inventor of the *Unix pipe* — summarized^([1](ch15.xhtml#idm45115212232256))
    it as such:'
  prefs: []
  type: TYPE_NORMAL
- en: Write programs that do one thing and do it well. Write programs to work together.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Doug McIlroy
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Transferring this philosophy to a functional approach means that functions should
    strive to do one thing only and do it well without affecting their environment.
    Design your functions to be as small as possible but as large as necessary. A
    complex task is better served by multiple composed functions that preserve pureness
    as long as possible than a bigger function that is impure from the start.
  prefs: []
  type: TYPE_NORMAL
- en: I/O is a classical case of side effects. Loading files, talking a database,
    etc., are impure operations and should therefore be separated from pure functions.
    To encapsulate a side effect you must think about the seams between the actual
    side effect and the processing of its result. Instead of loading a file and processing
    its content as a singular operation, it’s better two separate them into the side
    effect of loading a file, and processing the actual data, as illustrated in [Figure 15-1](#_02-functional-mindset_side-effects_separation).
  prefs: []
  type: TYPE_NORMAL
- en: '![Splitting operations into discrete functions](assets/afaj_1501.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15-1\. Splitting operations into discrete functions
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The data processing is no longer bound to the file loading, or files in general,
    rather than only processing the incoming data. This makes the operation a pure
    and reusable function, with the side effect restricted to the `loadFile` method,
    with the returned `Optional<String>` giving you a functional bridge to it.
  prefs: []
  type: TYPE_NORMAL
- en: If side effects can’t be avoided, split up the task into smaller and preferably
    pure functions to isolate and encapsulate any remaining side effects.
  prefs: []
  type: TYPE_NORMAL
- en: Favor Expression Over Statements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As discussed in [Chapter 1](ch01.xhtml#_01-an-introduction), a key differentiator
    separator between an object-oriented and a functional approach is the prevalence
    of either statements and expressions. To recapitulate, statements perform actions,
    like assigning a variable or control statements, and are therefore literal side
    effects. Expressions, on the other hand, evaluate their input to *just* yield
    output.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to reduce side effects, using expressions leads to safer and more
    reasonable code, based on the following rationale:'
  prefs: []
  type: TYPE_NORMAL
- en: Pure expressions, like pure functions, don’t have any side effects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expressions are (mostly) definable in code; the types of available statements
    are predefined by the language.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Evaluating pure expressions multiple times will yield the same output, ensuring
    predictability and enabling certain caching techniques, such as *memoization*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expressions can be small to remain pure and still be composed with other expressions
    to solve a bigger task.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The control flow `if`-`else` statements are often a good candidate for replacing
    it with a more functional approach, especially to assign variables or create.
    The previous `buildGreeting` method becomes more concise and straightforward by
    using the ternary operator for the pretty simplistic decision of which greeting
    to choose, as seen as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The ternary operator gives you two other advantages.
  prefs: []
  type: TYPE_NORMAL
- en: First, the variable `greeting` is declared and initialized in a single expression
    instead of it being uninitialized outside of the `if`-`else`-block.
  prefs: []
  type: TYPE_NORMAL
- en: Second, the variable is effectively `final`. In this particular case, it doesn’t
    matter. Still, there having a variable that can be easily used in a lambda expression
    is better than requiring you to refactor your code when you eventually need a
    variable to be effectively `final`.
  prefs: []
  type: TYPE_NORMAL
- en: Breaking down complex statement lists and blocks into smaller expressions makes
    code more concise and easier to reason with, plus the added benefit of effectively
    `final` variables, which is as you may remember from earlier chapters a non-negotiable
    requirement for using variables in lambda expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Expressions are often preferable over statements because they are a combination
    of values and functions intended to create a new value. They’re usually more compact
    and isolated than statements, making them safer to use. Statements, on the other
    hand, are more of a standalone unit to execute a side effect.
  prefs: []
  type: TYPE_NORMAL
- en: Moving Towards Immutability
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If it is not necessary to change, it is necessary not to change.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Lucius Cary, 2nd Viscount Falkland
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Another way to avoid unintended change, thus side effects and potential bugs,
    is to embrace *immutability* whenever possible and sensible. Even without utilizing
    any other functional principles, your codebase will become more robust thanks
    to immutability by eliminating the source of way too many bugs: *unintented change*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To prevent any unforeseen mutations, immutability should be the default approach
    to any type and collections used in your programs, especially in concurrent environments,
    as discussed more deeply in [Chapter 4](ch04.xhtml#_02-data-structures). You don’t
    have to reinvent the wheel for many use cases, as the JDK provides you with multiple
    options for immutable data structures:'
  prefs: []
  type: TYPE_NORMAL
- en: Immutable Collections
  prefs: []
  type: TYPE_NORMAL
- en: Even though Java doesn’t provide “fully” immutable collection types, it still
    has structurally immutable ones where you can’t add or remove elements. The concept
    of *unmodifiable* views of Collections was expanded in Java 9 by `static` factory
    methods like `List.of` to easily create structurally immutable Collections, as
    discussed in [“Moving Towards Immutability”](#_02-functional-architecture_prefer-immutability).
  prefs: []
  type: TYPE_NORMAL
- en: Immutable Math
  prefs: []
  type: TYPE_NORMAL
- en: The package `java.math` and its two immutable arbitrary-precision types, `BigInteger`
    and `BigDecimal`, are safe and immutable options for doing high-precision calculations.
  prefs: []
  type: TYPE_NORMAL
- en: Records ([JEP 395](https://openjdk.java.net/jeps/395))
  prefs: []
  type: TYPE_NORMAL
- en: Introduced as a preview feature in Java 14 and refined in 15, Records provide
    a completely new data structure as an easy-to-use data aggregation type. They’re
    a great alternative for POJOs and sometimes Java Beans, or you could use them
    as small, localized immutable data holders, as discussed in [Chapter 5](ch05.xhtml#_02-records).
  prefs: []
  type: TYPE_NORMAL
- en: Java Date and Time API ([JSR-310](https://jcp.org/en/jsr/detail?id=310))
  prefs: []
  type: TYPE_NORMAL
- en: Java 8 also introduced a new way to store and manipulate dates and times with
    immutable types from the ground up. The API gives you a fluent, explicit, and
    straightforward way of dealing with anything related to date and time.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, more and more Java APIs are built on are at least improving
    their support for immutability, and so should you. Designing your data structures
    and code with immutability in mind from the get-go saves you a lot of headaches
    in the long run. No more worrying about unintended or unexpected changes, and
    no more worries about thread safety in concurrent environments.
  prefs: []
  type: TYPE_NORMAL
- en: However, one thing to remember, is that immutability is suited best for, well,
    immutable data. Creating a new immutable data structure for any change becomes
    cumbersome really quickly regarding the required code and memory consumption by
    all those new objects.
  prefs: []
  type: TYPE_NORMAL
- en: Immutability is one of the most important aspects you can introduce into your
    codebase, regardless of a functional approach. An “immutable first” mindset, gives
    you safer and more reasonable data structures. Still, your usual modus operandi
    might not fit into the new challenges that data management with immutability incurs.
    Remember though, it’s easier to (partially) break immutability if there’s no other
    option available than to retroactively tack-on immutability in a mature code base.
  prefs: []
  type: TYPE_NORMAL
- en: Functional Data Processing with Map-Filter-Reduce
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Most data problems boil down to iterating over a sequence of elements, choosing
    the correct one, maybe manipulating them, performing an action, or gathering them
    into a new data structure. The following example — iterating over a list of users,
    filtering the correct ones, and notifying them — is a typical example of these
    basic steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Such problems are a perfect match for a functional approach with Streams and
    *map-filter-reduce*, as discussed in [“Map/Filter/Reduce”](ch06.xhtml#_02-data-processing_map-filter-reduce).
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of explicitly iterating over the users with a `for`-loop and collecting
    the correct elements in a previously defined `List`, a Stream pipeline does the
    whole task in a fluent, declarative call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Stream pipelines express *what* to do without the boilerplate of *how* to iterate
    over the elements. They are a perfect scaffold for converting statement-based
    data filtering and transformation to a functional pipeline. The fluent call concisely
    describes the steps necessary to solve the problem, especially if you use method
    references or method calls returning the required functional interface.
  prefs: []
  type: TYPE_NORMAL
- en: Abstractions Guide Implementations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every project is built upon abstractions designed after the requirements.
  prefs: []
  type: TYPE_NORMAL
- en: '*Object-oriented* design uses low-level abstractions in the form of powerful
    metaphors, defining the characteristics and constraints of a system. This domain-based
    approach is quite expressive and powerful but also restricts the versatility of
    types and how easy it is to introduce change. As requirements usually change over
    time, too restrictive abstractions lead to misalignment between different parts
    of your systems. Misaligned abstractions create friction and subtle bugs and might
    require a lot of work to realign.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Functional programming* tries to avoid misaligned abstractions by using higher
    abstractions not bound to a specific domain. [Chapter 14](ch14.xhtml#_02-design-patterns)
    reflects that by almost unconditionally replacing commonly used object-oriented
    abstractions with generalized functional interfaces of the JDK instead. This decoupling
    of abstractions from the original problem context creates simpler and easy-to-reuse
    components that are combined and mixed as necessary, enabling easier change of
    any functional system.'
  prefs: []
  type: TYPE_NORMAL
- en: Object-oriented and imperative code is a good match for encapsulating functionality,
    object-state, and representing a problem domain. Functional concepts are an excellent
    choice for implementation logic and higher-level abstractions. Not every data
    structure must be represented in the problem domain, so using more versatile functional
    types instead creates reusable and broader types that are driven by their use
    cases instead of the domain concept.
  prefs: []
  type: TYPE_NORMAL
- en: To resolve this problem, you must find a balance between the two levels of abstraction
    if you want to use both in the same system. In [“Functional Architecture in an
    Imperative World”](#_02-functional-mindeset_functional-architecture), I discuss
    how to combine both as an architectural decision that gives the benefits of high-level
    functional abstractions wrapped in a familiar imperative layer.
  prefs: []
  type: TYPE_NORMAL
- en: Building Functional Bridges
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A functional approach means your code most likely lives in an imperative and
    object-oriented environment that needs to work hand-in-hand with any functional
    technique or concept you want to integrate. Later in this chapter, in [“Functional
    Architecture in an Imperative World”](#_02-functional-mindeset_functional-architecture),
    I will discuss how to integrate functional code into an imperative environment.
  prefs: []
  type: TYPE_NORMAL
- en: But first, let’s look at how to bridge the gap between your existing code to
    the new functional APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Method References-Friendly Signatures
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Every method, `static` or not, and any constructor is a potential method reference
    to be used in higher-order functions or represented by a functional interface.
    That’s why it can make sense to design your APIs with other functional APIs in
    mind.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the commonly used Stream operations `map`, `filter`, and `sort`
    accept a `Function<T, R>`, `Predicate<T>`, and `Comparator<T>`, respectively,
    that translate well into simple method signatures.
  prefs: []
  type: TYPE_NORMAL
- en: Look at the required functional interface’s SAM; it’s the blueprint for the
    required method signature. As long as the input arguments and the return type
    match, you can name your method any way you want.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: One exception to simply mapping a SAM signature to a method reference is unbound
    non-`static` method reference. As the method is referenced via the type itself
    and isn’t bound to a specific instance, the underlying lambda expression accepts
    the type as its first argument.
  prefs: []
  type: TYPE_NORMAL
- en: For example, `String::toLowerCase` accepts a `String` and returns a `String`,
    and is, therefore, a `Function<String, String>`, despite `toLowerCase` not having
    any arguments.
  prefs: []
  type: TYPE_NORMAL
- en: When designing any API, it makes sense to think about how it might be used by
    functional API and provide method reference-friendly signatures. Your methods
    still have expressive names depending on their surrounding context, but also build
    a bridge to functional API with simple method references.
  prefs: []
  type: TYPE_NORMAL
- en: Using Retroactive Functional Interfaces
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Functional interfaces usually have marked with the `@FunctionalInterface` annotation.
    Still, as long as they fulfill the general requirements, as explained in [“Functional
    Interfaces”](ch02.xhtml#_01-functions_functional-interfaces), an interface is
    automatically a functional interface. Therefore, already existing code can benefit
    from the conciseness of lambdas and method references, and their specialized handling
    by the JVM.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many longstanding interfaces of the JDK are now marked with `@FunctionaInterface`,
    but your code might not have adapted yet and benefit from these changes. The following
    “now functional” interfaces were widely used even before Java 8:'
  prefs: []
  type: TYPE_NORMAL
- en: '`java.lang.Comparable<T>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.lang.Runnable`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.util.Comparator<T>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.util.concurrent.Callable<V>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, before lambdas, sorting a Collection was quite a handful because
    of all the boilerplate code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The lambda variant tames the boilerplate quite a bit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'But why stop here? If you check out the functional interface `Comparator<T>`,
    you will find `static` and non-`static` helper methods to make the overall call
    even more concise without losing any expressiveness:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Java 8 not only introduced new functional interfaces but improved existing interfaces
    so they fit nicely into the new APIs with lots of `default` and `static` methods.
    Always check out the non-SAM methods available in functional interfaces to find
    hidden gems to simplify your code with functional composition, or common tasks
    that can be condensed into a declarative call chain.
  prefs: []
  type: TYPE_NORMAL
- en: Lambda Factories for Common Operations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Designing your APIs to match other functional APIs so you can use method references
    isn’t always a possibility. That doesn’t mean that you can provide lambda factories
    to simplify the use of higher-order functions, though.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if a method doesn’t match a particular functional interface, because
    it requires additional arguments, you can use *partial application* to make it
    fit the method signature of a higher-order function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Image a `ProductCategory` type that has a method for a localized description
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The method is representable by a `BiFunction<ProductCategory, Locale, String>`,
    so you can’t use it for the Stream’s `map` operation and have to rely on a lambda
    expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding a `static` helper to `ProductCategory` that accepts a `Locale` and returns
    a `Function<ProductCategory, String>` allows you to use it instead of creating
    a lambda expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This way, the `ProductCategory` is still responsible for creating a localized
    mapper function that it expects. However, the call is simpler, and reusable, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Providing lambda operations for common operations by binding factory methods
    to their related type gives you a pre-defined set of intended tasks and saves
    the caller the repetitive creation of identical lambda expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Functional Interfaces Explicitly
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The most common functional interfaces, discussed in [“The Big Four Functional
    Interface Categories”](ch03.xhtml#_01-functions_the-big-four), go a long way before
    you need to create your own specialized types, especially if you include multi-arity
    variants. Still, creating your own functional interfaces has a big advantage:
    a more expressive domain.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at an argument or return type alone, a `Function<Path, Path>` could
    represent anything. A type named `VideoConvertJob`, however, tells you exactly
    what’s going on. To use such a type in a functional approach, though, it has to
    be a functional interface. Instead of creating a new and isolated functional interface,
    you should extend an existing one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: By choosing an existing functional interface as the baseline, your specialized
    variant is now compatible with `Function<Path, Path>` and inherits the two `default`
    methods `andThen` and `compose` to support functional composition out-of-the-box.
    The custom variant narrows down the domain and is compatible with its ancestor.
    Extending an existing interface also inherits the SAM signature.
  prefs: []
  type: TYPE_NORMAL
- en: 'To improve the domain even further, you could add a `default` method to create
    an expressive API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Adding a `default` method to implement a SAM is also the approach to make an
    existing interface conform to a functional interface without changing the original
    public contract, except for the additional functionality provided by the functional
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: Making your interfaces extend a functional interface, or letting your classes
    explicitly implement a functional interface bridges between existing types and
    higher-order functions. There are still considerations to be made to satisfy Java’s
    type hierarchy rules, but accepting the least common denominator as input and
    returning the most specific type possible is a good rule of thumb.
  prefs: []
  type: TYPE_NORMAL
- en: Functional null Handling with Optionals
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Optionals are an elegant way to deal with (possible) `null` values. That alone
    is a big plus in many scenarios. Another one of its advantages is its capability
    to provide a functional starting point between a possible `null` value and subsequent
    operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Where a `null` reference was previously a dead end requiring additional code
    to not explode with a `NullPointException`, an Optional gives you a declarative
    pipeline replacing the usual boilerplate required to handle `null` values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This pipeline replaces two `null`-checks (initial and `Group::getAdmin`), an
    `if`-statement (the `filter` operation), plus accessing the required properties
    and providing a sensible fallback. The overall task is directly expressed in the
    fluent declarative call over six lines instead of a more complex and harder-to-follow
    block of individual statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s hard to argue against the reduction of control statements combined with
    being a functional jump-off point and will likely increase your desire to (over)use
    Optionals, as it did for me in the beginning. Remember that Optionals were designed
    as a specialized *return* type, not as a ubiquitous replacement for `null`-related
    code. Not every value needs to be wrapped in an Optional, especially simple `null`-checks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Using an Optional might *feel* cleaner — easier to follow the flow, no control
    structure, no two `null` — but as a normal Java type, creating an Optional isn’t
    free. Each operation requires checking for `null` to do its intended job and might
    create a new Optional instance. The ternary operator might not be as appealing
    as an Optional, but it sure requires fewer resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since Java 9, the utility class `java.util.Objects` got two additions to do
    simple `null`-checks with a single method call that doesn’t create additional
    instances, which are the preferred alternative to an Optional with only an `orElse`
    or `orElseGet` operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Using Optionals should be restricted to their intended use case as improved
    return containers for possible `null` values, and, in my opinion, intricate Optional
    pipelines with multiple operations. You shouldn’t use them in your code to perform
    simple `null`-checks, nor should methods accept them directly as their arguments.
    Method overloading provides a better alternative if an argument isn’t always required.
  prefs: []
  type: TYPE_NORMAL
- en: Parallelism and Concurrency Made Easy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Writing concurrent or parallel programs isn’t easy. Creating additional threads
    is the simple part. However, coordinating more than one thread can become quite
    complicated. The most common root of all problems related to parallelism and concurrency
    is sharing data between different threads.
  prefs: []
  type: TYPE_NORMAL
- en: Shared data across multiple threads comes with its own requirements you don’t
    have to consider in sequential programs, like synchronization and locks to ensure
    data integrity and to prevent data races and deadlocks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Functional programming creates a lot of opportunities to use concurrency and
    parallelism safely thanks to the principles functional principles are built on,
    most evidently the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Immutability
  prefs: []
  type: TYPE_NORMAL
- en: Without change, there can’t be data races or deadlocks. Data structures can
    safely traverse thread boundaries.
  prefs: []
  type: TYPE_NORMAL
- en: Pure functions
  prefs: []
  type: TYPE_NORMAL
- en: Without side effects, pure functions are isolated and can be called from any
    thread, as they only rely on their input to generate their output.
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, functional techniques don’t concern themselves with the distinction
    of sequential or concurrent execution because FP, at its most strict interpretation,
    doesn’t allow for an environment where a distinction is necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Java’s concurrency features like parallel Streams ([Chapter 8](ch08.xhtml#_01-parallel-streams))
    and `CompletableFuture` ([Chapter 13](ch13.xhtml#_02-completable-future)) still
    require thread coordination even with fully functional code and data structures.
    However, the JDK will do it for you in a way that fits most scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Be Mindful of Potential Overhead
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Functional techniques provide a great productivity boost and make your code
    more expressive and robust. That doesn’t automagically mean that it’s more performant,
    though, or even at the same performance level as imperative and object-oriented
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Java is such a versatile language that’s trusted by many companies and individuals
    because its backward compatibility and general API stability are among the best.
    However, this comes at the steep price of fewer changes to the language itself,
    at least compared to others. That’s why many features covered in this book, like
    Streams, CompleteFutures, or Optionals, aren’t native language features but are
    implemented in the JDK with ordinary Java code, instead. Even Records, a totally
    new construct with distinct semantics, boils down to a typical class extending
    `java.lang.Record`, similar to how Enums work, with the compiler generating the
    required code behind the scenes. Still, that doesn’t mean these features aren’t
    optimized in any way. They still profit from all the optimizations available to
    all Java code. In addition, lambdas are a language feature utilizing a specialized
    opcode in the JVM, with multiple optimization techniques.
  prefs: []
  type: TYPE_NORMAL
- en: I know that using functional structures like Streams and Optionals for every
    single data processing or `null`-check is quite tempting because I fell for it
    after years of Java language stagnation. Even though they are excellent and highly
    optimized tools, you have to remember they aren’t *free* to use and will incur
    c certain unavoidable overhead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Usually, the overhead is negligible compared to the productivity gains and
    more concise and straightforward code. Always remember the quote by Kent Beck:
    “first make it work, then make it right, and, finally, make it fast.” Don’t forgo
    functional features and APIs in fear of the potential overhead without knowing
    it affected your code negatively in the first place. If in doubt, measure first,
    refactor second.'
  prefs: []
  type: TYPE_NORMAL
- en: Functional Architecture in an Imperative World
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Choosing a particular architecture isn’t an easy endeavor and has far-reaching
    consequences for any project. It’s a significant decision that can’t be changed
    without much effort. If you want to apply a more functional approach on an architectural
    level, it has to fit into an existing imperative and object-oriented code base
    without disrupting the status quo (too much).
  prefs: []
  type: TYPE_NORMAL
- en: Unsurprisingly, *functions* are the most basic and essential unit in functional
    architectures, representing isolated chunks of business logic. These chunks are
    the building blocks of workflows by being composed as needed. Each workflow represents
    a bigger logical unit, like a feature, a use case, a business requirement, etc.
  prefs: []
  type: TYPE_NORMAL
- en: A typical architectural approach to utilizing FP in an OO world is to separate
    the business logic from how it communicates with the outside world with well-defined
    boundaries. The *functional core, imperative shell* (FC/IS) approach to architecture
    is one that’s flexible in size and can be as low-impact as you want.
  prefs: []
  type: TYPE_NORMAL
- en: Although it’s feasible to build a system from scratch with an FC/IS design,
    it’s also possible to integrate the design into an existing code base. An FC/IS
    is an excellent choice for gradual rewrites and refactoring to introduce functional
    principles and techniques into your OO project.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you think about code and its actual purpose detached from any paradigms
    or concepts, it falls into two distinct groups: *doing* the work, and *coordinating*
    it. Instead of organizing the code and its responsibilities into a single paradigm,
    FC/IS draws a distinct line of separation between the two involved paradigms,
    as shown in [Figure 15-2](#_02-functional-architecture_func-core_imp-shell).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Basic layout of a Functional Core, Imperative Shell](assets/afaj_1502.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15-2\. Basic layout of Functional Core, Imperative Shell
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The *functional core* encapsulates the business logic and decisions in isolated
    and purely functional units. It utilizes all that FP has to offer and does what
    it does best: working directly with data without worrying about side effects or
    state-related problems thanks to pure functions and immutability. This *core*
    is then wrapped by an *imperative shell*, a thin layer to protect it from the
    outside world, encapsulating all the side effects and any mutable state.'
  prefs: []
  type: TYPE_NORMAL
- en: The *shell* contains the dependencies to other parts of the system and provides
    the public contract to interact with the FC/IS from the outside. Everything non-functional
    is kept away from the *core* and restricted to the *shell*. To keep the *shell*
    as thin as possible, most of the decisions remain in the *core*, so the *shell*
    only needs to delegate the work through its boundary and interpret the *core’s*
    results. It’s a glue layer handling the “real world” with all its dependencies
    and mutable state but as few paths and decisions as possible.
  prefs: []
  type: TYPE_NORMAL
- en: One of the main advantages of this design is the clear-cut split of responsibilities
    by encapsulation that occurs almost naturally as a side effect of a functional
    approach. The business logic is encapsulated in the *core*, built with *pure functions*,
    *immutability*, etc., making it easy to reason with, modular, and maintainable.
    Conversely, anything *impure* or *mutable*, or any contact with other systems,
    is restricted to the *shell* which isn’t allowed to make many decisions by itself.
  prefs: []
  type: TYPE_NORMAL
- en: From Objects to Values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From the outside, only the *imperative shell* is visible and provides a low
    level of abstraction with problem domain-specific types. It looks and feels like
    any other layer in a *usual* object-oriented Java project. The *functional core*,
    however, doesn’t need to know about the *shell* and its public contracts at all.
    Instead, it relies solely on high-level abstractions and the exchange of values
    rather than objects and how they interact with each other.
  prefs: []
  type: TYPE_NORMAL
- en: This shift from objects to values is required to keep the *core* functional
    and independent by leveraging all available functional tools. But it also highlights
    the split in responsibilities. To keep the core *pure*, any mutability, state,
    or side effects must happen beyond the boundary in the *shell*, outside of the
    actual business logic. In its most refined form, that means that *anything* traversing
    the boundary needs to be a value, even eventual side effects! That’s why separating
    side effects from pure functions is so important to regain more control. Programming
    languages that are “more functional” than Java usually have specialized data structures
    to handle side effects, like for example Scala’s `Maybe` or `Try` types.
  prefs: []
  type: TYPE_NORMAL
- en: Java’s closest type for handling a side effect is the `Optional<T>` type, which
    is capable of representing two states in a single type. In [Chapter 10](ch10.xhtml#_02-exception-handling),
    I also discussed how to recreate Scala’s Try/Success/Failure pattern in Java to
    handle control-flow disruptions due to Exceptions in a more functional manner.
    Still, the additional code and boilerplate required to tame side effects is a
    clear indicator that they should be handled in the *imperative shell* where the
    appropriate tools and constructs are available, unlike in the *functional core*,
    where it’s at least not desirable to do so.
  prefs: []
  type: TYPE_NORMAL
- en: Separation of Concerns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Functions come to their conclusions solely based on their arguments, without
    accessing or changing the world around them. Still, at some point, change might
    be necessary, like persisting data, mutating state in the *shell*.
  prefs: []
  type: TYPE_NORMAL
- en: The *core* is only responsible for decision-making but not acting on such decisions.
    That’s why all changes, even side effects, must be representable as values, too.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine you want to scrape a website for certain information and store it in
    a database. The overall task consists broadly speaking of the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Load content of a website
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extract the necessary information
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Decide if the information is relevant
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Persist data in a database
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To fit the task into an FC/IS system, you first need to categorize them by their
    responsibilities.
  prefs: []
  type: TYPE_NORMAL
- en: Loading the content and persisting the data is clearly I/O, which includes side
    effects, and therefore, belongs into the *shell*. Information extraction and deciding
    if it’s relevant is data processing that fits into the *core*. This categorization
    leads to the separation of tasks as illustrated in [Figure 15-3](#_02-functional-architecture_func-core_imp-shell_scraping).
  prefs: []
  type: TYPE_NORMAL
- en: '![Web-scraping responsibilities in FCIS](assets/afaj_1503.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15-3\. Web-scraping responsibilities in FCIS
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As you can see in the figure, the *shell* interacts with the network and passes
    the content immediately to the *core*. The *core* receives an immutable `String`
    value and returns an `Optional<String>` to indicate if the information is relevant
    based on its business logic. If a value is received back in the *shell*, it persists
    the value and any other information it still has access to in its context.
  prefs: []
  type: TYPE_NORMAL
- en: 'The separation of concerns brings another advantage to the code. From a modularity
    standpoint, the *core* is capable of using any input source, not just a website.
    This makes data processing more flexible and reusable. For example, instead of
    scraping a single site and passing its content directly to the *core* for processing,
    multiple pages could be scraped beforehand and persisted in a database for later
    processing. The *core* doesn’t care and doesn’t even need to know where the content
    comes from; it’s entirely focused on its isolated task: extracting and evaluating
    information. So even if the overall requirements change, the *core* doesn’t necessarily
    have to change, too. And if it does, you can recombine the existing small logical
    units as needed.'
  prefs: []
  type: TYPE_NORMAL
- en: The Different Sizes of an FC/IS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An FC/IS might seem like a singular organizational layout that your system
    is built around. That’s one way to do it, yet there’s a more flexible way to integrate
    the FC/IS architecture into a system: multiple FC/IS with different sizes.'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike other architectural designs, it doesn’t have to define or dominate a
    project. It doesn’t matter if your whole application is built around a singular
    or multiple FC/IS. Even creating an FC/IS for a sole task is possible. As long
    as an *imperative shell* integrates with the rest of the system, you’re good to
    go!
  prefs: []
  type: TYPE_NORMAL
- en: The dynamic sizing and integration of FC/IS allow for a gradual transition toward
    more functional logic in your codebase without breaking pre-existing structures.
    Creating multiple FC/IS, as seen in [Figure 15-4](#_02-functional-architecture_multi-func-core_imp-shell),
    can coexist and interact with prior systems without anyone even noticing it from
    the outside.
  prefs: []
  type: TYPE_NORMAL
- en: '![Multiple FI/CS interacting with an existing system](assets/afaj_1504.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15-4\. Multiple FI/CS interacting with an existing system
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: A sensible approach for sizing an FC/IS is thinking about its context and capabilities.
    The boundaries to the outside world — the *shell’s* surface — are the first indicator
    of the required size. Reducing the coupling between different systems ensures
    modularity, extensibility, and maintainability over time. The context is defined
    by the encapsulated specialized domain knowledge represented in the *core*, and
    by extension, the public contract of the *shell*.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the correct context and appropriate boundaries is crucial and gets
    easier with experience. An FC/IS should be as small as possible but as big as
    necessary. Functional units or whole functional groups of a core can be reused
    in other FC/IS to facilitate multiple small but specialized FC/IS instead of a
    singular “all-inclusive” one. With these smaller and isolated FC/IS it’s easier
    to start replacing and integrating them into even complex pre-existing systems
    step-by-step.
  prefs: []
  type: TYPE_NORMAL
- en: Testing an FC/IS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As with any other refactoring effort, when you adopt an FC/IS design, you should
    verify your new structures with appropriate testing, such as unit and integration
    tests. If your code has dependencies, or I/O like a database, testing usually
    requires mocks or stubs to better isolate the tested components.
  prefs: []
  type: TYPE_NORMAL
- en: 'While libraries are available to streamline creating such replacements, the
    whole concept comes with some drawbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: Knowledge of implementation details
  prefs: []
  type: TYPE_NORMAL
- en: Mocks often require detailed implementation knowledge to work as intended. Such
    details might change over time, and every refactor attempt tends to break the
    mocks and stubs mimicking them, even without changing the public contracts or
    the test logic.
  prefs: []
  type: TYPE_NORMAL
- en: Incidental testing
  prefs: []
  type: TYPE_NORMAL
- en: Tests should be on point, only testing the absolute minimum to ensure correctness.
    Dependencies create additional layers to consider, though, even if the intended
    story of the test hides underneath. Debugging such tests can be a nuisance because
    you no longer only debug the test and functionality itself but also any other
    layer present.
  prefs: []
  type: TYPE_NORMAL
- en: Fictional testing
  prefs: []
  type: TYPE_NORMAL
- en: Typically, a dependency is correctly initialized and in a guaranteed meaningful
    state. On the other hand, Mocks and stubs are essentially fictional implementations
    to reduce the coupling between components and fulfill the minimal set of requirements
    for the test.
  prefs: []
  type: TYPE_NORMAL
- en: The FC/IS architecture reduces these usual drawbacks thanks to its clear separation
    of responsibilities which is mirrored in its testability.
  prefs: []
  type: TYPE_NORMAL
- en: The *functional core* — the business logic of the system — consisting of pure
    functions which are often naturally isolated, is a perfect match for unit testing.
    The same test input needs to fulfill the same assertions. That’s why the core
    is usually easy to verify with small and on-point unit tests without test doubles
    compared to larger interconnected systems with more complex setup requirements.
    This general lack of dependencies eliminates the need for mocks and stubs.
  prefs: []
  type: TYPE_NORMAL
- en: The *imperative shell* still has dependencies and side effects and is, obviously
    not as easily testable as the *core*; it still needs integration tests. However,
    having most of the logic in the *core* that’s easily unit-testable, requires fewer
    tests to verify the *shell*. Any new FC/IS can rely on tested and verified functional
    code that’s easy to reason with, with only a new *shell* needing to be verified.
  prefs: []
  type: TYPE_NORMAL
- en: Final Thoughts on a Functional Approach to Java
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although I’m obviously a proponent of functional techniques wherever possible
    and sensible, my day-to-day Java work is still shaped by primarily imperative
    and object-oriented code. You may also be in a similar situation. In my company,
    Java 8 and its successors allowed us to introduce functional techniques step-by-step
    and at our own pace without the need to rewrite the whole architecture or codebase.
  prefs: []
  type: TYPE_NORMAL
- en: For example, slowly establishing immutability throughout the code and as the
    new baseline for data structures eliminated a whole category of problems that
    is usually present in an OO approach. Even hybrid approaches, like the previously
    mentioned partially immutable `SessionState` type eliminated certain unfavorable
    scenarios that could introduce subtle and hard-to-debug problems.
  prefs: []
  type: TYPE_NORMAL
- en: Another significant improvement was designing method signatures with Optionals
    in mind. It made the intent of a method more evident, communicating the possibility
    of missing values clearly with the caller, resulting in fewer `NullPointerException`
    without requiring an abundance of `null`-checks.
  prefs: []
  type: TYPE_NORMAL
- en: Functional idioms, concepts, and techniques aren’t that far out from object-oriented
    ones as it’s often proclaimed. Sure, they are different approaches to solving
    similar problems. Most benefits of functional programming can be reaped in object-oriented
    and imperative environments, too.
  prefs: []
  type: TYPE_NORMAL
- en: Java, as a language, might be lacking support for certain functional constructs.
    However, Java, the platform with a vast ecosystem brings in so many benefits regardless
    of the chosen paradigm.
  prefs: []
  type: TYPE_NORMAL
- en: Fundamentally, functional programming is a thought process, not a specific language
    per se. You don’t have to start a system from scratch to benefit from it. Starting
    from scratch often focuses on productivity instead of required breadth. Due to
    an ever-changing and evolving codebase, it’s easy to overlook necessary edge cases
    and non-common constructs most systems rely on. Instead of going back to square
    one, you can reduce the overall complexity by gradually rewriting, refactoring,
    and injecting a *functional mindset* step-by-step.
  prefs: []
  type: TYPE_NORMAL
- en: Still, not every data structure needs to be redesigned, and not each type to
    be made fully functional. The way to build a *functional mindset* is to exercise
    it. Start small, and don’t force it. The more you use functional constructs, the
    easier you will identify code that can benefit from the functional tools that
    Java provides.
  prefs: []
  type: TYPE_NORMAL
- en: The overarching goal of a functional approach is reducing the required cognitive
    capacity to understand and reason with your code. More concise and safer constructs,
    like pure functions and immutable data structures, improve reliability and long-term
    maintainability. Software development is about controlling complexity with the
    right tools, and in my opinion, the functional toolset that Java 8+ provides is
    quite powerful to tame your imperative and object-oriented Java code.
  prefs: []
  type: TYPE_NORMAL
- en: 'No matter which functional techniques and concepts you integrate into your
    projects, the most important lesson that I hope you take away from my book, in
    my opinion, is that it doesn’t actually matter if you do OOP or FP. Brian Goetz,
    the Java Language Architect at Oracle, said it quite well in one of his talks:'
  prefs: []
  type: TYPE_NORMAL
- en: Don’t be a functional programmer.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Don’t be an object-oriented programmer. Be a better programmer.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Brian Goetz, FP vs OO: Choose Two'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Software development is about choosing the most appropriate tool for a given
    problem. Incorporating the functional concepts and techniques available to us
    as Java developers in our day-to-day work adds invaluable new tools to our toolbox,
    which create more readable, reasonable, maintainable, and testable code.
  prefs: []
  type: TYPE_NORMAL
- en: Takeaways
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OOP and FP are quite dissimilar in their core concepts. However, most of their
    concepts aren’t mutually exclusive or completely orthogonal. Both can solve the
    same problems but with different approaches.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reasonable code is the ultimate goal, and a *functional mindset* helps achieve
    it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A *functional mindest* starts small with steps, like avoiding *side effects*
    with the help of *pure functions* or embracing *immutability*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional principles can also be part of architectural decisions, like separating
    concerns by splitting the business logic and the exposed *surface* to other systems
    with designs like a *functional core, imperative shell*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *functional core, imperative shell* design is an excellent tool for gradually
    introducing functional principles and concepts into existing code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ^([1](ch15.xhtml#idm45115212232256-marker)) Salus, Peter H. 1994\. “A Quarter-Century
    of Unix.” Addison-Wesley. ISBN 0-201-54777-5.
  prefs: []
  type: TYPE_NORMAL
- en: About the Author
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using his first computer at the age of four, **Ben Weidig** is a self-taught
    developer with almost two decades of experience in professional web, mobile, and
    systems programming in various languages.
  prefs: []
  type: TYPE_NORMAL
- en: After learning the ropes of professional software development and project management
    at an international clinical research organization, he became a self-employed
    software developer. He merged with a SaaS company after prolonged and close collaboration
    on multiple projects. As co-director, he shapes the company’s general direction,
    is involved in all aspects of their Java-based main product, and oversees and
    implements its mobile strategy.
  prefs: []
  type: TYPE_NORMAL
- en: In his free time, he shares his expertise and experiences by writing articles
    about Java, functional programming, best practices, and code-style in general.
    He also participates in Open-Source, either as a committer to established projects
    or releasing code of his own.
  prefs: []
  type: TYPE_NORMAL
