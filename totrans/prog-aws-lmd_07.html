<html><head></head><body><section data-pdf-bookmark="Chapter 7. Logging, Metrics, and Tracing" data-type="chapter" epub:type="chapter"><div class="chapter" id="ch07">&#13;
<h1><span class="label">Chapter 7. </span>Logging, Metrics, and Tracing</h1>&#13;
&#13;
&#13;
<p>In this chapter, we’ll explore how to enhance the observability of Lambda functions through logging, metrics, and tracing.&#13;
Through<a data-primary="logging" data-secondary="benefits of" data-type="indexterm" id="idm46222414821160"/> logging, you’ll learn how to gain information from specific events occuring during the execution of your Lambda functions.&#13;
Platform<a data-primary="metrics" data-secondary="benefits of tracking" data-type="indexterm" id="idm46222414819912"/> and business metrics will give insight into the operational health of our serverless application.&#13;
Finally, distributed<a data-primary="tracing" data-secondary="benefits of" data-type="indexterm" id="idm46222414818712"/> tracing will let you see how requests flow to the different managed services and components that make up our <span class="keep-together">architecture</span>.</p>&#13;
&#13;
<p>We’ll use the Weather API from <a data-type="xref" href="ch05.html#ch05">Chapter 5</a> to explore the wide variety of logging, metrics, and tracing options available for serverless applications on AWS.&#13;
Similar to the data pipeline changes we made in <a data-type="xref" href="ch06.html#ch06">Chapter 6</a>, you’ll notice that the Weather API Lambda functions have been refactored to use the <code>aws-lambda-java-events</code> library.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Logging" data-type="sect1"><div class="sect1" id="logging">&#13;
<h1>Logging</h1>&#13;
&#13;
<p>Given<a data-primary="logging" data-secondary="creating high-value log messages" data-type="indexterm" id="idm46222414812008"/> the following log message, what can we infer about the state of the application that generated it?</p>&#13;
&#13;
<pre data-type="programlisting">Recorded a temperature of 78 F from Brooklyn, NY</pre>&#13;
&#13;
<p>We know the values of some of the data (the temperature measurement and location), but not much else.&#13;
When was this data received or processed?&#13;
In the larger context of our application, what request generated this data?&#13;
Which Java class and method produced this log message?&#13;
How can we correlate this with other, possibly related, log messages?</p>&#13;
&#13;
<p>Fundamentally, this is an unhelpful log message.&#13;
It lacks context and specificity.&#13;
If a message like this was repeated hundreds or thousands of times (perhaps with different temperature or location values), it would lose meaning.&#13;
When our log messages are prose (e.g., a sentence or phrase), they are more difficult to parse without resorting to regular expressions or pattern matching.</p>&#13;
&#13;
<p>As we explore logging in our Lambda functions, keep in mind a few properties of high-value log messages:</p>&#13;
<dl>&#13;
<dt>Data rich</dt>&#13;
<dd>&#13;
<p>We want to capture as much data as is feasible and cost-effective. The more data we have, the more questions we can ask without having to go back and add more logging after that fact.</p>&#13;
</dd>&#13;
<dt>High cardinality</dt>&#13;
<dd>&#13;
<p>Data values that make a particular log message unique are especially important.&#13;
For example, a field like Request ID will have a large number of unique values, whereas a field like Thread Priority may not (especially in a single-threaded Lambda function).</p>&#13;
</dd>&#13;
<dt>Machine readable</dt>&#13;
<dd>&#13;
<p>Using JSON or another standardized format that is easily machine readable (without custom parsing logic) will ease analysis by downstream tools.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="CloudWatch Logs" data-type="sect2"><div class="sect2" id="idm46222414802696">&#13;
<h2>CloudWatch Logs</h2>&#13;
&#13;
<p>CloudWatch Logs<a data-primary="logging" data-secondary="CloudWatch Logs" data-type="indexterm" id="idm46222414801368"/><a data-primary="CloudWatch Logs" data-secondary="components of" data-type="indexterm" id="idm46222414800360"/> is, as the name would suggest, AWS’s log collection, aggregation, and processing service.&#13;
Through a variety of mechanisms, it receives log data from applications and other AWS services and makes that data accessible through a web console as well as via an API.</p>&#13;
&#13;
<p>The two main organizational components of CloudWatch Logs are log groups and log streams.&#13;
A log group is a top-level grouping for a set of related log streams.&#13;
A log stream is a list of log messages, usually originating from a single application or function instance.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Lambda and CloudWatch Logs" data-type="sect3"><div class="sect3" id="lambda-and-cloudwatch-logs">&#13;
<h3>Lambda and CloudWatch Logs</h3>&#13;
&#13;
<p>In<a data-primary="Lambda functions" data-secondary="CloudWatch Logs and" data-type="indexterm" id="idm46222414796504"/> a serverless application, by default there is one log group per Lambda function, which contains many log streams. Each log stream contains the log messages for all the  function invocations for a particular function instance.&#13;
Recall from <a data-type="xref" href="ch03.html#ch03">Chapter 3</a> that the Lambda runtime captures anything written to standard output (<code>System.out</code> in Java) or standard error (<code>System.err</code>), and forwards that information to CloudWatch Logs.</p>&#13;
&#13;
<p>The log output for a Lambda function looks something like this:</p>&#13;
&#13;
<pre data-type="programlisting">START RequestId: 6127fe67-a406-11e8-9030-69649c02a345&#13;
  Version: $LATEST&#13;
Recorded a temperature of 78 F from Brooklyn, NY&#13;
END RequestId: 6127fe67-a406-11e8-9030-69649c02a345&#13;
REPORT RequestId: 6127fe67-a406-11e8-9030-69649c02a345&#13;
  Duration: 2001.52 ms&#13;
  Billed Duration: 2000 ms&#13;
  Memory Size: 512 MB&#13;
  Max Memory Used: 51 MB</pre>&#13;
&#13;
<p>The <code>START</code>, <code>END</code>, and <code>REPORT</code> lines are automatically added by the Lambda platform.&#13;
Of particular interest is the UUID value labeled <code>RequestId</code>.&#13;
This is an identifier that’s unique for each <em>requested</em> Lambda function invocation.&#13;
The most common source of repeated <code>RequestId</code> values in logs is when our functions have an error and the platform retries the execution (see <a data-type="xref" href="ch08.html#error-handling">“Error Handling”</a>).&#13;
Aside from that, since the Lambda platform (like most distributed systems) has “at least once” semantics, the platform may occasionally invoke a function with the same <code>RequestId</code> more than once even when there are no errors (we examine “at least once” behavior in <a data-type="xref" href="ch09.html#at-least-once-delivery">“At-Least-Once Delivery”</a>).</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="LambdaLogger" data-type="sect2"><div class="sect2" id="idm46222414785992">&#13;
<h2>LambdaLogger</h2>&#13;
&#13;
<p>The<a data-primary="logging" data-secondary="LambdaLogger" data-type="indexterm" id="Llambda07"/><a data-primary="LambdaLogger" data-type="indexterm" id="llog07"/> log line between the <code>START</code> and <code>END</code> lines above was generated using <span class="keep-together"><code>System.out.println</code></span>.&#13;
This is a perfectly reasonable way to get started with logging from simple Lambda functions, but there are several other options that provide a combination of sensible behavior and customization.&#13;
The first of these options is the <a href="https://oreil.ly/lXGJB"><code>LambdaLogger</code></a> class that AWS provides.</p>&#13;
&#13;
<p>This logger is accessed via the Lambda <code>Context</code> object, so we’ll have to alter our <code>WeatherEvent</code> Lambda handler function to include that parameter, as follows:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">class</code> <code class="nc">WeatherEventLambda</code> <code class="o">{</code>&#13;
  <code class="err">…</code>&#13;
  <code class="kd">public</code> <code class="n">APIGatewayProxyResponseEvent</code> <code class="nf">handler</code><code class="o">(</code>&#13;
      <code class="n">APIGatewayProxyRequestEvent</code> <code class="n">request</code><code class="o">,</code>&#13;
      <code class="n">Context</code> <code class="n">context</code>&#13;
       <code class="o">)</code> <code class="kd">throws</code> <code class="n">IOException</code> <code class="o">{</code>&#13;
&#13;
    <code class="n">context</code><code class="o">.</code><code class="na">getLogger</code><code class="o">().</code><code class="na">log</code><code class="o">(</code><code class="s">"Request received"</code><code class="o">);</code>&#13;
    <code class="err">…</code>&#13;
  <code class="o">}</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p>The<a data-primary="System.out.println" data-type="indexterm" id="idm46222414774984"/> output of this log statement looks just as if it had been generated using <code>System.out.println</code>:</p>&#13;
&#13;
<pre data-type="programlisting">START RequestId: 4f40a12b-1112-4b3a-94a9-89031d57defa Version: $LATEST&#13;
Request received&#13;
END RequestId: 4f40a12b-1112-4b3a-94a9-89031d57defa</pre>&#13;
&#13;
<p>You can see the difference between <code>LambdaLogger</code> and the <code>System println</code> methods when we have output that includes newlines, like a stack trace:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">class</code> <code class="nc">WeatherEventLambda</code> <code class="o">{</code>&#13;
  <code class="err">…</code>&#13;
  <code class="kd">public</code> <code class="n">APIGatewayProxyResponseEvent</code> <code class="nf">handler</code><code class="o">(</code>&#13;
      <code class="n">APIGatewayProxyRequestEvent</code> <code class="n">request</code><code class="o">,</code>&#13;
      <code class="n">Context</code> <code class="n">context</code>&#13;
       <code class="o">)</code> <code class="kd">throws</code> <code class="n">IOException</code> <code class="o">{</code>&#13;
&#13;
    <code class="n">StringWriter</code> <code class="n">stringWriter</code> <code class="o">=</code> <code class="k">new</code> <code class="n">StringWriter</code><code class="o">();</code>&#13;
    <code class="n">Exception</code> <code class="n">e</code> <code class="o">=</code> <code class="k">new</code> <code class="n">Exception</code><code class="o">();</code>&#13;
    <code class="n">e</code><code class="o">.</code><code class="na">printStackTrace</code><code class="o">(</code><code class="k">new</code> <code class="n">PrintWriter</code><code class="o">(</code><code class="n">stringWriter</code><code class="o">));</code>&#13;
&#13;
    <code class="n">context</code><code class="o">.</code><code class="na">getLogger</code><code class="o">().</code><code class="na">log</code><code class="o">(</code><code class="n">stringWriter</code><code class="o">);</code>&#13;
    <code class="err">…</code>&#13;
  <code class="o">}</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p>Using<a data-primary="System.err.println" data-type="indexterm" id="idm46222414749112"/> <code>System.err.println</code> the stack trace is printed on multiple lines, as multiple CloudWatch Logs entries (<a data-type="xref" href="#stack-trace-system-err">Figure 7-1</a>).</p>&#13;
&#13;
<figure><div class="figure" id="stack-trace-system-err">&#13;
<img alt="images/ch07_image01.png" src="assets/awsl_0701.png"/>&#13;
<h6><span class="label">Figure 7-1. </span>Stack trace output in CloudWatch Logs using System.err.println</h6>&#13;
</div></figure>&#13;
&#13;
<p>Using LambdaLogger, that stack trace is a single entry (which can be expanded in the web console, as shown in <a data-type="xref" href="#stack-trace-lambda-logger">Figure 7-2</a>).</p>&#13;
&#13;
<p>This feature alone is a compelling reason to use <code>LambdaLogger</code> instead of <span class="keep-together"><code>System.out.println</code></span> or <code>System.err.println</code>, especially when printing exception stack traces.<a data-primary="" data-startref="Llambda07" data-type="indexterm" id="idm46222414653432"/><a data-primary="" data-startref="llog07" data-type="indexterm" id="idm46222414652456"/></p>&#13;
&#13;
<figure><div class="figure" id="stack-trace-lambda-logger">&#13;
<img alt="images/ch07_image02.png" src="assets/awsl_0702.png"/>&#13;
<h6><span class="label">Figure 7-2. </span>Stack trace output in CloudWatch Logs using LambdaLogger</h6>&#13;
</div></figure>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Java Logging Frameworks" data-type="sect2"><div class="sect2" id="idm46222414785400">&#13;
<h2>Java Logging Frameworks</h2>&#13;
&#13;
<p><code>LambdaLogger</code> is<a data-primary="logging" data-secondary="Java logging frameworks" data-type="indexterm" id="Ljava07"/><a data-primary="Java" data-secondary="logging frameworks" data-type="indexterm" id="Jlog07"/> often sufficient for simple Lambda functions.&#13;
However, as you’ll see later in this chapter, it’s often useful to customize log output to meet specific requirements, like capturing business metrics or generating application alerts.&#13;
While it’s certainly possible to generate this kind of output using Java’s standard library, like <a href="https://oreil.ly/9qlLO"><code>String.format</code></a>, it’s easier to use an existing logging framework like<a data-primary="Log4J" data-type="indexterm" id="idm46222414643512"/><a data-primary="Java Commons Logging" data-type="indexterm" id="idm46222414642840"/> Log4J or Java Commons Logging.&#13;
These frameworks provide conveniences like log levels, property or file-based configuration, and a variety of output formats.&#13;
They also make it easy to include relevant system and application context (like the AWS request ID) with each log message.</p>&#13;
&#13;
<p>When Lambda was first made available, AWS provided a custom appender for a very old, unsupported version of Log4J.&#13;
Using this old version of a popular logging framework made it challenging to integrate newer logging features in Lambda-based serverless applications.&#13;
As<a data-primary="lambda-monitoring" data-type="indexterm" id="idm46222414641064"/> a result, we spent a fair amount of time and effort to build a more modern logging solution for Lambda functions called <code>lambda-monitoring</code>, which uses<a data-primary="SLF4J" data-type="indexterm" id="idm46222414639704"/> SLF4J and<a data-primary="Logback" data-type="indexterm" id="idm46222414638840"/> Logback.</p>&#13;
&#13;
<p>However, AWS now provides a <a href="https://oreil.ly/rywdy">library</a> with a<a data-primary="logging" data-secondary="custom log appender" data-type="indexterm" id="idm46222414636680"/> custom log appender, <a href="https://oreil.ly/CrRoX">which uses <code>LambdaLogger</code> under the covers</a>, for the most recent version of <a href="https://oreil.ly/8UEaw">Log4J2</a>.&#13;
We now recommend using this setup as AWS has outlined in the <a href="https://oreil.ly/2YP8h">Java logging section</a> of the Lambda documentation.&#13;
Setting up this method of logging simply involves adding a few additional dependencies, adding a <em>log4j2.xml</em> configuration file, and then using <code>org.apache.logging.log4j.Logger</code> in our code.</p>&#13;
&#13;
<p class="pagebreak-before">Here are the <em>pom.xml</em> additions for our Weather API project:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;dependencies&gt;</code>&#13;
  <code class="nt">&lt;dependency&gt;</code>&#13;
    <code class="nt">&lt;groupId&gt;</code>com.amazonaws<code class="nt">&lt;/groupId&gt;</code>&#13;
    <code class="nt">&lt;artifactId&gt;</code>aws-lambda-java-log4j2<code class="nt">&lt;/artifactId&gt;</code>&#13;
    <code class="nt">&lt;version&gt;</code>1.1.0<code class="nt">&lt;/version&gt;</code>&#13;
  <code class="nt">&lt;/dependency&gt;</code>&#13;
  <code class="nt">&lt;dependency&gt;</code>&#13;
    <code class="nt">&lt;groupId&gt;</code>org.apache.logging.log4j<code class="nt">&lt;/groupId&gt;</code>&#13;
    <code class="nt">&lt;artifactId&gt;</code>log4j-core<code class="nt">&lt;/artifactId&gt;</code>&#13;
    <code class="nt">&lt;version&gt;</code>2.12.1<code class="nt">&lt;/version&gt;</code>&#13;
    <code class="nt">&lt;/dependency&gt;</code>&#13;
  <code class="nt">&lt;dependency&gt;</code>&#13;
    <code class="nt">&lt;groupId&gt;</code>org.apache.logging.log4j<code class="nt">&lt;/groupId&gt;</code>&#13;
    <code class="nt">&lt;artifactId&gt;</code>log4j-api<code class="nt">&lt;/artifactId&gt;</code>&#13;
    <code class="nt">&lt;version&gt;</code>2.12.1<code class="nt">&lt;/version&gt;</code>&#13;
  <code class="nt">&lt;/dependency&gt;</code>&#13;
<code class="nt">&lt;/dependencies&gt;</code></pre>&#13;
&#13;
<p>The <em>log4j2.xml</em> configuration file should be familiar to anyone who has used Log4J.&#13;
It uses the <code>Lambda</code> appender provided by AWS, and allows customization of the log <span class="keep-together">pattern</span>:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="cp">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</code>&#13;
<code class="nt">&lt;Configuration</code> <code class="na">packages=</code><code class="s">"com.amazonaws.services.lambda.runtime.log4j2"</code><code class="nt">&gt;</code>&#13;
  <code class="nt">&lt;Appenders&gt;</code>&#13;
    <code class="nt">&lt;Lambda</code> <code class="na">name=</code><code class="s">"Lambda"</code><code class="nt">&gt;</code>&#13;
      <code class="nt">&lt;PatternLayout&gt;</code>&#13;
        <code class="nt">&lt;pattern&gt;</code>&#13;
          %d{yyyy-MM-dd HH:mm:ss} %X{AWSRequestId} %-5p %c{1}:%L—%m%n&#13;
        <code class="nt">&lt;/pattern&gt;</code>&#13;
      <code class="nt">&lt;/PatternLayout&gt;</code>&#13;
    <code class="nt">&lt;/Lambda&gt;</code>&#13;
  <code class="nt">&lt;/Appenders&gt;</code>&#13;
  <code class="nt">&lt;Loggers&gt;</code>&#13;
    <code class="nt">&lt;Root</code> <code class="na">level=</code><code class="s">"info"</code><code class="nt">&gt;</code>&#13;
      <code class="nt">&lt;AppenderRef</code> <code class="na">ref=</code><code class="s">"Lambda"</code><code class="nt">/&gt;</code>&#13;
    <code class="nt">&lt;/Root&gt;</code>&#13;
  <code class="nt">&lt;/Loggers&gt;</code>&#13;
<code class="nt">&lt;/Configuration&gt;</code></pre>&#13;
&#13;
<p>Notice that the log pattern includes the Lambda request ID (<code>%X{AWSRequestId}</code>).&#13;
In our previous logging examples, that request ID wasn’t included in most output lines—it just showed up at the beginning and end of an invocation.&#13;
By including it in every line, we can tie each piece of output to a specific request, which is helpful if we inspect these logs using another tool or download them for offline analysis.</p>&#13;
&#13;
<p class="pagebreak-before">In our Lambda function, we set up the logger and use its <code>error</code> method to log out a message at <a href="https://oreil.ly/pygbx"><code>ERROR</code> level</a>, as well as the exception:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kn">import</code> <code class="nn">org.apache.logging.log4j.LogManager</code><code class="o">;</code>&#13;
<code class="kn">import</code> <code class="nn">org.apache.logging.log4j.Logger</code><code class="o">;</code>&#13;
&#13;
<code class="kd">public</code> <code class="kd">class</code> <code class="nc">WeatherEventLambda</code> <code class="o">{</code>&#13;
  <code class="kd">private</code> <code class="kd">static</code> <code class="n">Logger</code> <code class="n">logger</code> <code class="o">=</code> <code class="n">LogManager</code><code class="o">.</code><code class="na">getLogger</code><code class="o">();</code>&#13;
  <code class="err">…</code>&#13;
  <code class="kd">public</code> <code class="n">APIGatewayProxyResponseEvent</code> <code class="nf">handler</code><code class="o">(</code>&#13;
    <code class="n">APIGatewayProxyRequestEvent</code> <code class="n">request</code><code class="o">,</code> <code class="n">Context</code> <code class="n">context</code><code class="o">)</code>&#13;
    <code class="kd">throws</code> <code class="n">IOException</code> <code class="o">{</code>&#13;
&#13;
    <code class="n">Exception</code> <code class="n">e</code> <code class="o">=</code> <code class="k">new</code> <code class="n">Exception</code><code class="o">(</code><code class="s">"Test exception"</code><code class="o">);</code>&#13;
    <code class="n">logger</code><code class="o">.</code><code class="na">error</code><code class="o">(</code><code class="s">"Log4J logger"</code><code class="o">,</code> <code class="n">e</code><code class="o">);</code>&#13;
    <code class="o">...</code>&#13;
  <code class="o">}</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p>The output from the Lambda Log4J2 appender is shown in <a data-type="xref" href="#log4j2-logger-output">Figure 7-3</a>.</p>&#13;
&#13;
<figure><div class="figure" id="log4j2-logger-output">&#13;
<img alt="images/ch07_image03.png" src="assets/awsl_0703.png"/>&#13;
<h6><span class="label">Figure 7-3. </span>Stack trace output in CloudWatch Logs using Log4J2</h6>&#13;
</div></figure>&#13;
&#13;
<p>It includes the timestamp, the AWS request ID, the log level (<code>ERROR</code> in this case), the file and line that called the logging method, and a correctly formatted exception.&#13;
We can use Log4J-provided bridge libraries to route log messages from other logging frameworks to our Log4J appender.&#13;
The most useful application of this technique, at least for our <code>WeatherEventLambda</code>, is to gain insight into the behavior of the AWS Java SDK, which uses Apache Commons Logging (previously known as Jakarta Commons Logging, or JCL).</p>&#13;
&#13;
<p class="pagebreak-before">First, we add the Log4J JCL bridge library to the <code>dependencies</code> section of our <em>pom.xml</em> file:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;dependency&gt;</code>&#13;
  <code class="nt">&lt;groupId&gt;</code>org.apache.logging.log4j<code class="nt">&lt;/groupId&gt;</code>&#13;
  <code class="nt">&lt;artifactId&gt;</code>log4j-jcl<code class="nt">&lt;/artifactId&gt;</code>&#13;
  <code class="nt">&lt;version&gt;</code>2.12.1<code class="nt">&lt;/version&gt;</code>&#13;
<code class="nt">&lt;/dependency&gt;</code></pre>&#13;
&#13;
<p>Next, we enable debug logging in the <code>Loggers</code> section of our <em>log4j2.xml</em> file:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;Loggers&gt;</code>&#13;
  <code class="nt">&lt;Root</code> <code class="na">level=</code><code class="s">"debug"</code><code class="nt">&gt;</code>&#13;
    <code class="nt">&lt;AppenderRef</code> <code class="na">ref=</code><code class="s">"Lambda"</code><code class="nt">/&gt;</code>&#13;
  <code class="nt">&lt;/Root&gt;</code>&#13;
<code class="nt">&lt;/Loggers&gt;</code></pre>&#13;
&#13;
<p>Now we can see detailed log information from the AWS Java SDK (<a data-type="xref" href="#log4j2-jcl-bridge">Figure 7-4</a>).</p>&#13;
&#13;
<figure><div class="figure" id="log4j2-jcl-bridge">&#13;
<img alt="images/ch07_image04.png" src="assets/awsl_0704.png"/>&#13;
<h6><span class="label">Figure 7-4. </span>Detailed debug logging from the AWS SDK</h6>&#13;
</div></figure>&#13;
&#13;
<p>We probably don’t want this information all the time, but it’s useful for debugging if there’s a problem—in this case we see exactly what the body of the DynamoDB <span class="keep-together"><code>PutItem</code></span> API call contains.</p>&#13;
&#13;
<p>By using more sophisticated logging frameworks, we gain additional insight into the context surrounding our log output.&#13;
We can separate the logs for different Lambda requests using the request ID.&#13;
Using the log level, we can understand if some log lines represent errors, or warnings about the state of our application, or if other lines might be ignored (or analyzed later) because they contain voluminous but less relevant debugging information.<a data-primary="" data-startref="Ljava07" data-type="indexterm" id="idm46222414397944"/><a data-primary="" data-startref="Jlog07" data-type="indexterm" id="idm46222414325928"/></p>&#13;
<aside class="pagebreak-before less_space" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46222414324856">&#13;
<h5>CloudWatch Logs Costs</h5>&#13;
<p>One<a data-primary="CloudWatch Logs" data-secondary="costs of" data-type="indexterm" id="idm46222414323320"/><a data-primary="costs" data-secondary="CloudWatch Logs" data-type="indexterm" id="idm46222414322312"/> word of caution—the cost of logging at high volume from Lambda functions is often surprising.&#13;
At the time of writing, CloudWatch Logs costs $0.50 per GB of data ingested.&#13;
If your Lambda functions generate 100KB of log output per invocation (perhaps by processing a batch of one thousand records from Kinesis and generating a single line of output for each record), and are invoked 1M times, that’s 100GB of log output, which will cost $50.&#13;
At 1M invocations per day, that’s $1,500 of CloudWatch Logs in a month!</p>&#13;
&#13;
<p>The admonition here is not to eliminate logging from your Lambda functions but to generate meaningful log output that’s worth the cost.&#13;
We’ll discuss how to gain maximum value from log output in the next section.</p>&#13;
</div></aside>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Structured Logging" data-type="sect2"><div class="sect2" id="idm46222414648696">&#13;
<h2>Structured Logging</h2>&#13;
&#13;
<p>Our<a data-primary="logging" data-secondary="structured logging" data-type="indexterm" id="Lstruct07"/><a data-primary="structured logging" data-type="indexterm" id="struclog07"/> logging system as described in the previous section is capturing a great deal of useful information and context, ready to be used to inspect and improve our <span class="keep-together">application</span>.</p>&#13;
&#13;
<p>However, when it comes time to extract some value from this great store of log data, it’s often difficult to access, it’s tricky to query, and because the actual messages are still essentially free-form text, you usually have to resort to a series of inscrutable regular expressions to find exactly the lines you’re looking for.&#13;
There are some standardized formats that have established conventions for the values of certain space or tab-delimited fields, but inevitably the regexes make an appearance in downstream processes and tooling.</p>&#13;
&#13;
<p>Rather than continue with the free-text free-for-all, we can use a technique called <em>structured logging</em> to standardize our log output and make all of it easily searchable via a standard query language.</p>&#13;
&#13;
<p>Take this JSON log entry as an example:</p>&#13;
&#13;
<pre data-code-language="json" data-type="programlisting"><code class="p">{</code>&#13;
  <code class="nt">"thread"</code><code class="p">:</code> <code class="s2">"main"</code><code class="p">,</code>&#13;
  <code class="nt">"level"</code><code class="p">:</code> <code class="s2">"INFO"</code><code class="p">,</code>&#13;
  <code class="nt">"loggerName"</code><code class="p">:</code> <code class="s2">"book.api.WeatherEventLambda"</code><code class="p">,</code>&#13;
  <code class="nt">"message"</code><code class="p">:</code> <code class="p">{</code>&#13;
    <code class="nt">"locationName"</code><code class="p">:</code> <code class="s2">"Brooklyn, NY"</code><code class="p">,</code>&#13;
    <code class="nt">"action"</code><code class="p">:</code> <code class="s2">"record"</code><code class="p">,</code>&#13;
    <code class="nt">"temperature"</code><code class="p">:</code> <code class="mi">78</code><code class="p">,</code>&#13;
    <code class="nt">"timestamp"</code><code class="p">:</code> <code class="mi">1564506117</code>&#13;
  <code class="p">},</code>&#13;
  <code class="nt">"endOfBatch"</code><code class="p">:</code> <code class="kc">false</code><code class="p">,</code>&#13;
  <code class="nt">"loggerFqcn"</code><code class="p">:</code> <code class="s2">"org.apache.logging.log4j.spi.AbstractLogger"</code><code class="p">,</code>&#13;
  <code class="nt">"instant"</code><code class="p">:</code> <code class="p">{</code>&#13;
    <code class="nt">"epochSecond"</code><code class="p">:</code> <code class="mi">1564506117</code><code class="p">,</code>&#13;
    <code class="nt">"nanoOfSecond"</code><code class="p">:</code> <code class="mi">400000000</code>&#13;
  <code class="p">},</code>&#13;
  <code class="nt">"contextMap"</code><code class="p">:</code> <code class="p">{</code>&#13;
    <code class="nt">"AWSRequestId"</code><code class="p">:</code> <code class="s2">"d814bbbe-559b-4798-aee0-31ddf9235a76"</code>&#13;
  <code class="p">},</code>&#13;
  <code class="nt">"threadId"</code><code class="p">:</code> <code class="mi">1</code><code class="p">,</code>&#13;
  <code class="nt">"threadPriority"</code><code class="p">:</code> <code class="mi">5</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Rather than relying on an ordering of fields to extract information, we can use JSON path specifications.&#13;
For example, if we want to extract the <code>temperature</code> field, we can use the JSON path <code>.message.temperature</code>.&#13;
The CloudWatch Logs service supports this both for searching in the web console (see <a data-type="xref" href="#cloudwatch-logs-web-console">Figure 7-5</a>), and for creating Metric Filters, which we’ll discuss later in this chapter.</p>&#13;
&#13;
<figure><div class="figure" id="cloudwatch-logs-web-console">&#13;
<img alt="images/ch07_image05.png" src="assets/awsl_0705.png"/>&#13;
<h6><span class="label">Figure 7-5. </span>Using JSON Path expressions to search in the CloudWatch Logs web console</h6>&#13;
</div></figure>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Structured Logging in Java" data-type="sect2"><div class="sect2" id="idm46222414227176">&#13;
<h2>Structured Logging in Java</h2>&#13;
&#13;
<p>Now<a data-primary="Java" data-secondary="structured logging in" data-type="indexterm" id="Jstruct07"/> that we understand the benefit of structured logging using the JSON format, we unfortunately run into immediate difficulty in trying to log JSON from our Java-based Lambda functions.&#13;
JSON handling in Java is notoriously verbose, and adding a large amount of boilerplate code to construct log output doesn’t feel like the right way to go.</p>&#13;
&#13;
<p>Fortunately, we can use<a data-primary="Log4J2" data-type="indexterm" id="idm46222414223336"/> Log4J2 to generate JSON log output (<a href="https://oreil.ly/G4EYb">Log4J2 <code>JSONLayout</code></a>).&#13;
The following <em>log4j2.xml</em> configuration will enable JSON-formatted output to <code>STDOUT</code>, which for our Lambda functions means that the output will be sent to CloudWatch Logs:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="cp">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</code>&#13;
<code class="nt">&lt;Configuration</code> <code class="na">packages=</code><code class="s">"com.amazonaws.services.lambda.runtime.log4j2"</code><code class="nt">&gt;</code>&#13;
  <code class="nt">&lt;Appenders&gt;</code>&#13;
    <code class="nt">&lt;Lambda</code> <code class="na">name=</code><code class="s">"Lambda"</code><code class="nt">&gt;</code>&#13;
      <code class="nt">&lt;JsonLayout</code>&#13;
        <code class="na">compact=</code><code class="s">"true"</code>&#13;
        <code class="na">eventEol=</code><code class="s">"true"</code>&#13;
        <code class="na">objectMessageAsJsonObject=</code><code class="s">"true"</code>&#13;
        <code class="na">properties=</code><code class="s">"true"</code><code class="nt">/&gt;</code>&#13;
    <code class="nt">&lt;/Lambda&gt;</code>&#13;
  <code class="nt">&lt;/Appenders&gt;</code>&#13;
  <code class="nt">&lt;Loggers&gt;</code>&#13;
    <code class="nt">&lt;Root</code> <code class="na">level=</code><code class="s">"info"</code><code class="nt">&gt;</code>&#13;
      <code class="nt">&lt;AppenderRef</code> <code class="na">ref=</code><code class="s">"Lambda"</code><code class="nt">/&gt;</code>&#13;
    <code class="nt">&lt;/Root&gt;</code>&#13;
  <code class="nt">&lt;/Loggers&gt;</code>&#13;
<code class="nt">&lt;/Configuration&gt;</code></pre>&#13;
&#13;
<p>In our Lambda code, we set up the Log4J2 logger as a static field:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="o">...</code>&#13;
<code class="kd">private</code> <code class="kd">static</code> <code class="n">Logger</code> <code class="n">logger</code> <code class="o">=</code> <code class="n">LogManager</code><code class="o">.</code><code class="na">getLogger</code><code class="o">();</code>&#13;
<code class="o">...</code></pre>&#13;
&#13;
<p>Rather than logging a string like <code>Recorded a temperature of 78 F from Brooklyn, NY</code>, we’ll instead build up a <code>Map</code> with keys and values, as follows:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="n">HashMap</code><code class="o">&lt;</code><code class="n">Object</code><code class="o">,</code> <code class="n">Object</code><code class="o">&gt;</code> <code class="n">message</code> <code class="o">=</code> <code class="k">new</code> <code class="n">HashMap</code><code class="o">&lt;&gt;();</code>&#13;
<code class="n">message</code><code class="o">.</code><code class="na">put</code><code class="o">(</code><code class="s">"action"</code><code class="o">,</code> <code class="s">"record"</code><code class="o">);</code>&#13;
<code class="n">message</code><code class="o">.</code><code class="na">put</code><code class="o">(</code><code class="s">"locationName"</code><code class="o">,</code> <code class="n">weatherEvent</code><code class="o">.</code><code class="na">locationName</code><code class="o">);</code>&#13;
<code class="n">message</code><code class="o">.</code><code class="na">put</code><code class="o">(</code><code class="s">"temperature"</code><code class="o">,</code> <code class="n">weatherEvent</code><code class="o">.</code><code class="na">temperature</code><code class="o">);</code>&#13;
<code class="n">message</code><code class="o">.</code><code class="na">put</code><code class="o">(</code><code class="s">"timestamp"</code><code class="o">,</code> <code class="n">weatherEvent</code><code class="o">.</code><code class="na">timestamp</code><code class="o">);</code>&#13;
&#13;
<code class="n">logger</code><code class="o">.</code><code class="na">info</code><code class="o">(</code><code class="k">new</code> <code class="n">ObjectMessage</code><code class="o">(</code><code class="n">message</code><code class="o">));</code></pre>&#13;
&#13;
<p>Here’s the output from that log line:</p>&#13;
&#13;
<pre data-code-language="json" data-type="programlisting"><code class="p">{</code>&#13;
  <code class="nt">"thread"</code><code class="p">:</code> <code class="s2">"main"</code><code class="p">,</code>&#13;
  <code class="nt">"level"</code><code class="p">:</code> <code class="s2">"INFO"</code><code class="p">,</code>&#13;
  <code class="nt">"loggerName"</code><code class="p">:</code> <code class="s2">"book.api.WeatherEventLambda"</code><code class="p">,</code>&#13;
  <code class="nt">"message"</code><code class="p">:</code> <code class="p">{</code>&#13;
    <code class="nt">"locationName"</code><code class="p">:</code> <code class="s2">"Brooklyn, NY"</code><code class="p">,</code>&#13;
    <code class="nt">"action"</code><code class="p">:</code> <code class="s2">"record"</code><code class="p">,</code>&#13;
    <code class="nt">"temperature"</code><code class="p">:</code> <code class="mi">78</code><code class="p">,</code>&#13;
    <code class="nt">"timestamp"</code><code class="p">:</code> <code class="mi">1564506117</code>&#13;
  <code class="p">},</code>&#13;
  <code class="nt">"endOfBatch"</code><code class="p">:</code> <code class="kc">false</code><code class="p">,</code>&#13;
  <code class="nt">"loggerFqcn"</code><code class="p">:</code> <code class="s2">"org.apache.logging.log4j.spi.AbstractLogger"</code><code class="p">,</code>&#13;
  <code class="nt">"instant"</code><code class="p">:</code> <code class="p">{</code>&#13;
    <code class="nt">"epochSecond"</code><code class="p">:</code> <code class="mi">1564506117</code><code class="p">,</code>&#13;
    <code class="nt">"nanoOfSecond"</code><code class="p">:</code> <code class="mi">400000000</code>&#13;
  <code class="p">},</code>&#13;
  <code class="nt">"contextMap"</code><code class="p">:</code> <code class="p">{</code>&#13;
    <code class="nt">"AWSRequestId"</code><code class="p">:</code> <code class="s2">"d814bbbe-559b-4798-aee0-31ddf9235a76"</code>&#13;
  <code class="p">},</code>&#13;
  <code class="nt">"threadId"</code><code class="p">:</code> <code class="mi">1</code><code class="p">,</code>&#13;
  <code class="nt">"threadPriority"</code><code class="p">:</code> <code class="mi">5</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>A caveat worth noting—the information relevant to our application is there under the <code>message</code> key, but it’s buried in a sea of other output.&#13;
Unfortunately, most of that output is baked into the Log4J2 <code>JsonLayout</code>, so we can’t remove it without some work.&#13;
As we’ll see in the next section, however, the benefits of JSON-formatted log events are well worth the increase in verbosity.<a data-primary="" data-startref="Lstruct07" data-type="indexterm" id="idm46222413957624"/><a data-primary="" data-startref="struclog07" data-type="indexterm" id="idm46222413956968"/><a data-primary="" data-startref="Jstruct07" data-type="indexterm" id="idm46222413956024"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="CloudWatch Logs Insights" data-type="sect2"><div class="sect2" id="idm46222414226680">&#13;
<h2>CloudWatch Logs Insights</h2>&#13;
&#13;
<p>Structured logging<a data-primary="CloudWatch Logs Insights" data-type="indexterm" id="cwatchin07"/><a data-primary="logging" data-secondary="CloudWatch Logs Insights" data-type="indexterm" id="Lcloudin07"/> enables us to use far more sophisticated tools to analyze our logs, both in real time as well as after incidents.&#13;
While the original CloudWatch Logs web console has some support for using JSONPath expressions to query log data (as shown earlier), truly sophisticated analysis has, until recently, required either downloading logs directly, or forwarding them to another service.</p>&#13;
&#13;
<p><a href="https://oreil.ly/mPqKe">CloudWatch Logs Insights</a> is a new addition to the CloudWatch Logs ecosystem, providing a powerful search engine and purpose-built query language ideally suited to analyzing structured logs.&#13;
Taking our example JSON log line from the previous section, let’s now imagine that we had a month’s worth of hourly data that has been logged out to CloudWatch Logs.&#13;
We might want to do some quick analysis of that log data to see what the minimum, average, and maximum temperatures for each day was, but only for Brooklyn.</p>&#13;
&#13;
<p>The following CloudWatch Logs Insights query accomplishes just that:</p>&#13;
&#13;
<pre data-type="programlisting">filter message.action = "record"&#13;
    and message.locationName = "Brooklyn, NY"&#13;
| fields date_floor(concat(message.timestamp, "000"), 1d) as Day,&#13;
    message.temperature&#13;
| stats min(message.temperature) as Low,&#13;
    avg(message.temperature) as Average,&#13;
    max(message.temperature) as High by Day&#13;
| order by Day asc</pre>&#13;
&#13;
<p>Let’s look at what this query is doing, line by line:</p>&#13;
<ol>&#13;
<li>&#13;
<p>First we filter the data down to log events that have a value of <code>record</code> in the <code>message.action</code> field, and a value of “Brooklyn, NY” in the <code>message.locationName</code> field.</p>&#13;
</li>&#13;
<li>&#13;
<p>In the second line, we pick out the <code>message.timestamp</code> field and add three zeroes to the end before passing it to the <code>date_floor</code> method, which will replace a <span class="keep-together">timestamp</span> value (in milliseconds, hence needing to add zeroes) with the earliest timestamp value for the given day.&#13;
We also pick out the <code>message.temperature</code> field.</p>&#13;
</li>&#13;
<li>&#13;
<p>The third line calculates the minimum, average, and maximum value of the <code>message.temperature</code> field, for a day’s worth of log events.</p>&#13;
</li>&#13;
<li>&#13;
<p>The last line orders the data by day, starting with the earliest day.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>We can see the results of this query in the CloudWatch Logs Insights web console (<a data-type="xref" href="#cw-logs-insights">Figure 7-6</a>).</p>&#13;
&#13;
<figure><div class="figure" id="cw-logs-insights">&#13;
<img alt="images/ch07_image06.png" src="assets/awsl_0706.png"/>&#13;
<h6><span class="label">Figure 7-6. </span>CloudWatch Logs Insights</h6>&#13;
</div></figure>&#13;
&#13;
<p>These results can be exported as a CSV file, or graphed using the built-in visualization tool (<a data-type="xref" href="#cw-logs-insights-visualization">Figure 7-7</a>).</p>&#13;
&#13;
<p>There are a few caveats to keep in mind with regard to CloudWatch Logs Insights.&#13;
First, while the tool can be used quite effectively for ad hoc exploration of log data, it cannot (yet) be used to directly generate additional custom metrics or other data products (although we’ll see how to generate custom metrics from JSON log data in the next section!).&#13;
There is an API interface for running queries and accessing results, however, so it is possible to roll your own solution.&#13;
Last but not least, pricing for queries is based on the amount of data scanned.<a data-primary="" data-startref="Lcloudin07" data-type="indexterm" id="idm46222413916392"/><a data-primary="" data-startref="cwatchin07" data-type="indexterm" id="idm46222413915416"/></p>&#13;
&#13;
<figure><div class="figure" id="cw-logs-insights-visualization">&#13;
<img alt="images/ch07_image07.png" src="assets/awsl_0707.png"/>&#13;
<h6><span class="label">Figure 7-7. </span>CloudWatch Logs Insights visualization</h6>&#13;
</div></figure>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Metrics" data-type="sect1"><div class="sect1" id="metrics">&#13;
<h1>Metrics</h1>&#13;
&#13;
<p>Log messages<a data-primary="metrics" data-secondary="versus log messages" data-secondary-sortas="log messages" data-type="indexterm" id="idm46222413911048"/><a data-primary="logging" data-secondary="versus metrics" data-type="indexterm" id="idm46222413909768"/> are discrete snapshots into the state of a system at a given point in time.&#13;
Metrics, on the other hand, are meant to produce a higher-level view of the state of a system over a period of time.&#13;
While an individual metric is a snapshot in time, a series of metrics shows trends and behaviors of a system as it runs, over long periods of time.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="CloudWatch Metrics" data-type="sect2"><div class="sect2" id="idm46222413908216">&#13;
<h2>CloudWatch Metrics</h2>&#13;
&#13;
<p>CloudWatch Metrics<a data-primary="metrics" data-secondary="CloudWatch Metrics" data-type="indexterm" id="idm46222413906920"/><a data-primary="CloudWatch Metrics" data-type="indexterm" id="idm46222413905912"/> is AWS’s metrics repository service.&#13;
It receives metrics from most AWS services.&#13;
At the most fundamental level, a metric is simply a set of time-ordered data points.&#13;
For example, at a given moment, the CPU load of a traditional server might be 64%.&#13;
A few seconds later, it might be 65%.&#13;
Over a given time period, a minimum, a maximum, and other statistics (such as percentiles) can be calculated for the metric.</p>&#13;
&#13;
<p>Metrics are grouped by namespace (e.g., <code>/aws/lambda</code>), and then by metric name (e.g., <code>WeatherEventLambda</code>).&#13;
Metrics can also have associated dimensions, which are simply more granular identifiers—for example given a metric tracking application errors in a nonserverless application, one dimension might be server IP.</p>&#13;
&#13;
<p>CloudWatch metrics are a primary tool for monitoring the behavior of AWS’s services as well as our own applications.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Lambda Platform Metrics" data-type="sect2"><div class="sect2" id="idm46222413902392">&#13;
<h2>Lambda Platform Metrics</h2>&#13;
&#13;
<p>Right<a data-primary="metrics" data-secondary="Lambda platform metrics" data-type="indexterm" id="idm46222413900824"/><a data-primary="AWS Lambda" data-secondary="Lambda platform metrics" data-type="indexterm" id="idm46222413899816"/><a data-primary="platform metrics" data-type="indexterm" id="idm46222413898872"/> out of the box, AWS provides a myriad of function and account-level metrics with which to monitor the overall health and availability of your serverless applications.&#13;
We’ll refer to these as platform metrics, because they’re provided by the Lambda platform without requiring any extra configuration from us.</p>&#13;
&#13;
<p>For individual functions, the Lambda platform provides the following metrics:</p>&#13;
<dl>&#13;
<dt><code>Invocations</code></dt>&#13;
<dd>&#13;
<p>The number of times a function is invoked (whether successful or not).</p>&#13;
</dd>&#13;
<dt><code>Throttles</code></dt>&#13;
<dd>&#13;
<p>The number of times an invocation attempt is throttled by the platform.</p>&#13;
</dd>&#13;
<dt><code>Errors</code></dt>&#13;
<dd>&#13;
<p>The number of times a function invocation returns an error.</p>&#13;
</dd>&#13;
<dt><code>Duration</code></dt>&#13;
<dd>&#13;
<p>The number of milliseconds of “elapsed wall clock time” from when a function begins executing to when it stops.&#13;
This metric also supports <a href="https://oreil.ly/-Njgn">percentiles</a>.</p>&#13;
</dd>&#13;
<dt><code>ConcurrentExecutions</code></dt>&#13;
<dd>&#13;
<p>How many concurrent executions of a function are happening at a given point in time.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>For<a data-primary="IteratorAge metric" data-type="indexterm" id="idm46222413888216"/> functions that are invoked by Kinesis or DynamoDB stream event sources, an <code>IteratorAge</code> metric tracks the number of milliseconds between when the function received a batch of records and the time the last record in that batch was written to the stream.&#13;
Effectively, this metric shows you how far behind the stream a Lambda function is at a given point in time.</p>&#13;
&#13;
<p>For functions configured with a dead letter queue (DLQ), a <code>DeadLetterErrors</code> metric is incremented when the function is unable to write a message to the DLQ (see <a data-type="xref" href="ch08.html#error-handling">“Error Handling”</a> for more about DLQs).</p>&#13;
&#13;
<p>Additionally, the platform aggregates the <code>Invocations</code>, <code>Throttles</code>, <code>Errors</code>, <code>Duration</code>, and <code>ConcurrentExecutions</code> metrics across all functions in the account and region.&#13;
An <code>UnreservedConcurrentExecutions</code> metric aggregates the concurrent executions for all functions in the account and region that do not have a custom concurrency limit specified.</p>&#13;
&#13;
<p>Metrics that are generated by the Lambda platform include the following extra dimensions: <code>FunctionName</code>, <code>Resource</code> (e.g., function version or alias)  and <code>ExecutedVersion</code> (for alias invocations, which are discussed in the next chapter).&#13;
Each of the per-function metrics mentioned can have these dimensions.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Business Metrics" data-type="sect2"><div class="sect2" id="idm46222413879416">&#13;
<h2>Business Metrics</h2>&#13;
&#13;
<p>Platform metrics<a data-primary="metrics" data-secondary="business metrics" data-type="indexterm" id="idm46222413877688"/><a data-primary="business metrics" data-type="indexterm" id="idm46222413876680"/> and application logging are important tools for monitoring our serverless applications, but neither is useful in assessing whether our application is performing its business functions correctly and completely.&#13;
For example, a metric capturing the duration of a Lambda execution is useful to catch unexpected performance issues, but it doesn’t tell us if the Lambda function (or the application as a whole) is processing events correctly for our customers.&#13;
On the other hand, a metric capturing the number of weather events successfully processed for our most popular location tells us that the application (or at least the part related to processing weather events) is working correctly, regardless of the underlying technical implementation.</p>&#13;
&#13;
<p>These <em>business metrics</em> can serve not only as a finger on the pulse of our business logic but also as an aggregate metric that’s not tied to specifics of an implementation or platform.&#13;
Using our earlier example, what does it mean if Lambda execution time increases?&#13;
Are we simply processing more data, or did a configuration or code change impact the performance of our function?&#13;
Does it even matter?&#13;
However, if the number of weather events our application processes decreases unexpectedly, we know something is wrong and it warrants an immediate investigation.</p>&#13;
&#13;
<p>In<a data-primary="PutMetricData API calls" data-type="indexterm" id="idm46222413873304"/> a traditional application, we might use the CloudWatch Metrics API directly, by using the <a href="https://oreil.ly/zLHuA"><code>PutMetricData</code> API call</a> to proactively push these custom metrics as they’re generated.&#13;
More sophisticated applications might push small batches of metrics at regular intervals instead.</p>&#13;
&#13;
<p>Lambda functions have two qualities that make the <code>PutMetricData</code> approach untenable.&#13;
First, a Lambda function can scale to hundreds or thousands of concurrent executions very quickly.&#13;
The CloudWatch Metrics API will throttle the <code>PutMetricData</code> call (<a href="https://oreil.ly/q2jmF">CloudWatch limits</a>), so there’s a danger that the very action that’s attempting to persist important data may in fact cause a dropout of metrics.&#13;
Second, because Lambda functions are ephemeral, there is little opportunity or benefit to batching metrics during a single execution.&#13;
There is no guarantee that a subsequent execution will take place in the same runtime instance, so batching across invocations isn’t <span class="keep-together">reliable</span>.</p>&#13;
&#13;
<p>Fortunately, there<a data-primary="CloudWatch Embedded Metric Format" data-type="indexterm" id="idm46222413867416"/> are two features of CloudWatch metrics that handle this situation in a scalable and reliable manner by moving the generation of CloudWatch metrics data outside of the Lambda execution entirely.&#13;
The first and newest, called the <a href="https://oreil.ly/pkNXB">CloudWatch Embedded Metric Format</a>, uses a special log format to automatically create metrics.&#13;
This special log format isn’t yet supported by Log4J (without a lot of extra work), so we won’t use it here, but in other cases this is the preferred method for generating metrics in Lambda.</p>&#13;
&#13;
<p>The<a data-primary="CloudWatch Metric Filters" data-type="indexterm" id="idm46222413805080"/> other feature, <a href="https://oreil.ly/beOVU">CloudWatch metric filters</a>, can also use CloudWatch Logs data to generate metrics.&#13;
Unlike the embedded metric format, it can access data in columnar and arbitrarily nested JSON structures.&#13;
This makes it a better choice for situations like ours where we can’t easily add JSON keys to the top level of our log statements.&#13;
It generates metric data by scraping CloudWatch Logs and pushing metrics in batches to the CloudWatch Metrics service.</p>&#13;
&#13;
<p>Our use of structured logging makes setting up a metric filter trivial, using the following addition to our <em>template.yaml</em> file:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">BrooklynWeatherMetricFilter</code><code class="p">:</code>&#13;
  <code class="nt">Type</code><code class="p">:</code> <code class="l-Scalar-Plain">AWS::Logs::MetricFilter</code>&#13;
  <code class="nt">Properties</code><code class="p">:</code>&#13;
    <code class="nt">LogGroupName</code><code class="p">:</code> <code class="kt">!Sub</code> <code class="s">"/aws/lambda/${WeatherEventLambda}"</code>&#13;
    <code class="nt">FilterPattern</code><code class="p">:</code> <code class="s">'{$.message.locationName</code><code class="nv"> </code><code class="s">=</code><code class="nv"> </code><code class="s">"Brooklyn,</code><code class="nv"> </code><code class="s">NY"}'</code>&#13;
    <code class="nt">MetricTransformations</code><code class="p">:</code>&#13;
      <code class="nt">— MetricValue</code><code class="p">:</code> <code class="s">"1"</code>&#13;
    <code class="nt">MetricNamespace</code><code class="p">:</code> <code class="l-Scalar-Plain">WeatherApi</code>&#13;
    <code class="nt">MetricName</code><code class="p">:</code> <code class="l-Scalar-Plain">BrooklynWeatherEventCount</code>&#13;
    <code class="nt">DefaultValue</code><code class="p">:</code> <code class="s">"0"</code></pre>&#13;
&#13;
<p>This metric filter will increment the <code>BrooklynWeatherEventCount</code> metric every time a JSON log line contains a <code>message.locationName</code> field with a “Brooklyn, NY” value.&#13;
We can access and visualize this metric via the CloudWatch Metrics web console, and we can configure CloudWatch alarms and actions just as with regular platform <span class="keep-together">metrics</span>.</p>&#13;
&#13;
<p>In this example we’re effectively incrementing a counter every time an event occurs, but it’s also possible (when it makes sense to do so with the data) to use an actual value from the captured log line.&#13;
See the <a href="https://oreil.ly/ksKJu"><code>MetricFilter MetricTransformation</code> documentation</a> for more details.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Alarms" data-type="sect2"><div class="sect2" id="cloudwatch-alarms">&#13;
<h2>Alarms</h2>&#13;
&#13;
<p>As<a data-primary="metrics" data-secondary="building alarms" data-type="indexterm" id="idm46222413759784"/><a data-primary="alarms, building for metrics" data-type="indexterm" id="idm46222413758776"/> with all CloudWatch metrics, we can use the data to build out alarms to warn us in case something is going wrong.&#13;
At a minimum, we recommend setting alarms for the <code>Errors</code> and <code>Throttles</code> platform metrics, if not on a per-account basis, then certainly for production functions.</p>&#13;
&#13;
<p>For<a data-primary="IteratorAge metric" data-type="indexterm" id="idm46222413756424"/> functions invoked by Kinesis or DynamoDB stream event sources, the <code>IteratorAge</code> metric is a critical indication of whether a function is keeping up with the number of events in the stream (which is a function of the number of shards in the stream, the batch size configured in the Lambda event source, the <a href="https://oreil.ly/ogUdK"><code>ParallelizationFactor</code></a>, and the performance of the Lambda function itself).</p>&#13;
&#13;
<p>Given the <code>BrooklynWeatherEventCount</code> metric we configured in the previous section, here’s how the associated CloudWatch alarm is configured. This alarm will alert us (via an SNS message) if that metric value drops to zero (indicating we’ve stopped receiving weather events for “Brooklyn, NY”) for longer than 60 seconds:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">BrooklynWeatherAlarm</code><code class="p">:</code>&#13;
  <code class="nt">Type</code><code class="p">:</code> <code class="l-Scalar-Plain">AWS::CloudWatch::Alarm</code>&#13;
  <code class="nt">Properties</code><code class="p">:</code>&#13;
    <code class="nt">Namespace</code><code class="p">:</code> <code class="l-Scalar-Plain">WeatherApi</code>&#13;
    <code class="nt">MetricName</code><code class="p">:</code> <code class="l-Scalar-Plain">BrooklynWeatherEventCount</code>&#13;
    <code class="nt">Statistic</code><code class="p">:</code> <code class="l-Scalar-Plain">Sum</code>&#13;
    <code class="nt">ComparisonOperator</code><code class="p">:</code> <code class="l-Scalar-Plain">LessThanThreshold</code>&#13;
    <code class="nt">Threshold</code><code class="p">:</code> <code class="l-Scalar-Plain">1</code>&#13;
    <code class="nt">Period</code><code class="p">:</code> <code class="l-Scalar-Plain">60</code>&#13;
    <code class="nt">EvaluationPeriods</code><code class="p">:</code> <code class="l-Scalar-Plain">1</code>&#13;
    <code class="nt">TreatMissingData</code><code class="p">:</code> <code class="l-Scalar-Plain">breaching</code>&#13;
    <code class="nt">ActionsEnabled</code><code class="p">:</code> <code class="l-Scalar-Plain">True</code>&#13;
    <code class="nt">AlarmActions</code><code class="p">:</code>&#13;
      <code class="l-Scalar-Plain">— !Ref BrooklynWeatherAlarmTopic</code>&#13;
&#13;
<code class="nt">BrooklynWeatherAlarmTopic</code><code class="p">:</code>&#13;
  <code class="nt">Type</code><code class="p">:</code> <code class="l-Scalar-Plain">AWS::SNS::Topic</code></pre>&#13;
&#13;
<p><a data-type="xref" href="#cloudwatch-alarm">Figure 7-8</a> shows a view of that alarm in the CloudWatch web console.</p>&#13;
&#13;
<figure><div class="figure" id="cloudwatch-alarm">&#13;
<img alt="images/ch07_image08.png" src="assets/awsl_0708.png"/>&#13;
<h6><span class="label">Figure 7-8. </span>BrooklynWeatherAlarm CloudWatch alarm</h6>&#13;
</div></figure>&#13;
&#13;
<p>The<a data-primary="Simple Notification Service (SNS)" data-type="indexterm" id="idm46222413675880"/> SNS message generated when the previous alarm is “breached” can be used to send a notification email, or to trigger a third-party alert system like <a href="https://www.pagerduty.com">PagerDuty</a>.</p>&#13;
&#13;
<p>As with application components like Lambda functions and DynamoDB tables, we strongly recommend keeping CloudWatch metric filters, alarms, and all other infrastructure in the same <em>template.yaml</em> file as everything else.&#13;
This not only allows us to take advantage of intra-template references and dependencies, but it also keeps our metrics and alarm configurations tied closely to the application itself.&#13;
If you don’t want to generate these operational resources for development versions of your stacks, you can use <a href="https://oreil.ly/iXXkw">CloudFormation’s <code>Conditions</code> functionality</a>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="pagebreak-before less_space" data-pdf-bookmark="Distributed Tracing" data-type="sect2"><div class="sect2" id="distributed-tracing">&#13;
<h2>Distributed Tracing</h2>&#13;
&#13;
<p>The<a data-primary="metrics" data-secondary="distributed tracing" data-type="indexterm" id="Mdisttrac07"/><a data-primary="tracing" data-secondary="distributed tracing" data-type="indexterm" id="Tdistt07"/><a data-primary="distributed tracing service" data-type="indexterm" id="dtrace07"/><a data-primary="X-Ray" data-type="indexterm" id="xray07"/> metrics and logging capabilities that we’ve covered thus far provide insight into individual application components like Lambda functions.&#13;
However, in the case of nontrivial applications with many components, we would have a hard time piecing together the log output and metrics for a request flow that might involve an API Gateway, two Lambda functions, and a DynamoDB table.</p>&#13;
&#13;
<p>Fortunately, this use case is covered by AWS’s distributed tracing service, X-Ray.&#13;
This service will essentially “tag” events either coming into or generated by our application and will keep track of those events as they flow through our application.&#13;
When a tagged event triggers a Lambda function, X-Ray can then keep track of external service calls that the Lambda function makes and add information about those calls to the trace.&#13;
If the called service is also X-Ray enabled, the tracing will continue through.&#13;
In this way, X-Ray not only traces specific events but generates a service map of all of the components in our application and how they interact with each other.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="servicelens">&#13;
<h5>CloudWatch ServiceLens</h5>&#13;
<p><a href="https://oreil.ly/kRn0I">CloudWatch ServiceLens</a> is<a data-primary="CloudWatch ServiceLens" data-type="indexterm" id="idm46222413661112"/> a new service (at the time of writing) that integrates CloudWatch and X-Ray to provide a comprehensive, end-to-end overview of your application.&#13;
In general, almost everything that can be done from the X-Ray console can now also be achieved through ServiceLens.</p>&#13;
&#13;
<p>Over time, we anticipate that this will supersede the X-Ray console, so we encourage you to try it! <a href="https://oreil.ly/Vr1AX">This AWS blog post</a> offers an excellent overview of ServiceLens’ capabilities and usage.</p>&#13;
</div></aside>&#13;
&#13;
<p>For AWS Lambda, there are two modes for <a href="https://oreil.ly/juSOL">X-Ray tracing</a>.&#13;
The first is <code>PassThrough</code>, which means that if an event triggering a Lambda function has already been “tagged” by X-Ray, the invocation of the Lambda function will be tracked by X-Ray.&#13;
If a triggering event hasn’t been tagged, then no trace information will be recorded from Lambda.&#13;
Conversely, <code>Active</code> tracing proactively adds X-Ray trace IDs to all Lambda invocations.</p>&#13;
&#13;
<p>In the following example, we’ve enabled tracing in our API Gateway, which will tag incoming events with an X-Ray trace ID.&#13;
The Lambda function is configured in <code>PassThrough</code> mode, so when it’s triggered by a tagged event from the API Gateway, it will propagate that trace ID to downstream services.&#13;
Note that <em>PassThrough</em> mode is enabled by default if the Lambda’s IAM execution role has permission to send data to the X-Ray service; otherwise, it can be configured explicitly as we’ve done here (in which case SAM adds the appropriate permissions to the Lambda execution role).</p>&#13;
&#13;
<p>Here’s the <code>Globals</code> section from our SAM <em>template.yaml</em> file from <a data-type="xref" href="ch05.html#ch05">Chapter 5</a>, updated to enabled API Gateway tracing:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">Globals</code><code class="p">:</code>&#13;
  <code class="nt">Function</code><code class="p">:</code>&#13;
    <code class="nt">Runtime</code><code class="p">:</code> <code class="l-Scalar-Plain">java8</code>&#13;
    <code class="nt">MemorySize</code><code class="p">:</code> <code class="l-Scalar-Plain">512</code>&#13;
    <code class="nt">Timeout</code><code class="p">:</code> <code class="l-Scalar-Plain">25</code>&#13;
    <code class="nt">Environment</code><code class="p">:</code>&#13;
      <code class="nt">Variables</code><code class="p">:</code>&#13;
        <code class="nt">LOCATIONS_TABLE</code><code class="p">:</code> <code class="kt">!Ref</code> <code class="l-Scalar-Plain">LocationsTable</code>&#13;
    <code class="nt">Tracing</code><code class="p">:</code> <code class="l-Scalar-Plain">PassThrough</code>&#13;
  <code class="nt">Api</code><code class="p">:</code>&#13;
    <code class="nt">OpenApiVersion</code><code class="p">:</code> <code class="s">'3.0.1'</code>&#13;
    <code class="nt">TracingEnabled</code><code class="p">:</code> <code class="l-Scalar-Plain">true</code></pre>&#13;
&#13;
<p>With tracing enabled, we can also add the X-Ray libraries to our <em>pom.xml</em> file.&#13;
By adding these libraries, we’ll get the benefit of X-Ray tracing for all of the interactions our Lambda function has with services like DynamoDB and SNS, without having to make any changes to our Java code.</p>&#13;
&#13;
<p>Like the AWS SDK, X-Ray provides a<a data-primary="BOM (bill of materials) feature" data-secondary="aws-xray-recorder-sdk-bom" data-type="indexterm" id="idm46222413585608"/> bill of materials (BOM), which keeps version numbers in sync across whichever X-Ray libraries we end up using in our project.&#13;
To<a data-primary="X-Ray" data-secondary="X-Ray BOM" data-type="indexterm" id="idm46222413584488"/> use the X-Ray BOM, add it to the <code>&lt;dependencyManagement&gt;</code> section of the top-level <em>pom.xml</em> file:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;dependency&gt;</code>&#13;
  <code class="nt">&lt;groupId&gt;</code>com.amazonaws<code class="nt">&lt;/groupId&gt;</code>&#13;
  <code class="nt">&lt;artifactId&gt;</code>aws-xray-recorder-sdk-bom<code class="nt">&lt;/artifactId&gt;</code>&#13;
  <code class="nt">&lt;version&gt;</code>2.3.0<code class="nt">&lt;/version&gt;</code>&#13;
  <code class="nt">&lt;type&gt;</code>pom<code class="nt">&lt;/type&gt;</code>&#13;
  <code class="nt">&lt;scope&gt;</code>import<code class="nt">&lt;/scope&gt;</code>&#13;
<code class="nt">&lt;/dependency&gt;</code></pre>&#13;
&#13;
<p>Now we need to add the three X-Ray libraries that will instrument our Java-based Lambda functions:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;dependency&gt;</code>&#13;
  <code class="nt">&lt;groupId&gt;</code>com.amazonaws<code class="nt">&lt;/groupId&gt;</code>&#13;
  <code class="nt">&lt;artifactId&gt;</code>aws-xray-recorder-sdk-core<code class="nt">&lt;/artifactId&gt;</code>&#13;
<code class="nt">&lt;/dependency&gt;</code>&#13;
<code class="nt">&lt;dependency&gt;</code>&#13;
  <code class="nt">&lt;groupId&gt;</code>com.amazonaws<code class="nt">&lt;/groupId&gt;</code>&#13;
  <code class="nt">&lt;artifactId&gt;</code>aws-xray-recorder-sdk-aws-sdk<code class="nt">&lt;/artifactId&gt;</code>&#13;
<code class="nt">&lt;/dependency&gt;</code>&#13;
<code class="nt">&lt;dependency&gt;</code>&#13;
  <code class="nt">&lt;groupId&gt;</code>com.amazonaws<code class="nt">&lt;/groupId&gt;</code>&#13;
  <code class="nt">&lt;artifactId&gt;</code>aws-xray-recorder-sdk-aws-sdk-instrumentor<code class="nt">&lt;/artifactId&gt;</code>&#13;
<code class="nt">&lt;/dependency&gt;</code></pre>&#13;
&#13;
<p class="pagebreak-before"><a data-type="xref" href="#x-ray-service-map">Figure 7-9</a> shows the X-Ray service map for our API from <a data-type="xref" href="ch05.html#ch05">Chapter 5</a>, showing the API Gateway, Lambda platform, Lambda function, and DynamoDB table:</p>&#13;
&#13;
<figure><div class="figure" id="x-ray-service-map">&#13;
<img alt="images/ch07_image09.png" src="assets/awsl_0709.png"/>&#13;
<h6><span class="label">Figure 7-9. </span>X-Ray service map</h6>&#13;
</div></figure>&#13;
&#13;
<p>We can also view a trace for an individual event (in this case, our HTTP POST), which traversed the API Gateway, Lambda, and DynamoDB (<a data-type="xref" href="#x-ray-trace">Figure 7-10</a>).</p>&#13;
&#13;
<figure><div class="figure" id="x-ray-trace">&#13;
<img alt="images/ch07_image10.png" src="assets/awsl_0710.png"/>&#13;
<h6><span class="label">Figure 7-10. </span>X-Ray trace</h6>&#13;
</div></figure>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Finding Errors" data-type="sect2"><div class="sect2" id="finding-errors">&#13;
<h2>Finding Errors</h2>&#13;
&#13;
<p>What<a data-primary="error handling" data-secondary="finding and investigating" data-type="indexterm" id="idm46222413475096"/><a data-primary="Lambda functions" data-secondary="finding and investigating errors" data-type="indexterm" id="idm46222413474120"/> happens when our Lambda function throws an error?&#13;
We can investigate errors via the X-Ray console, through both the service map and the traces interface.</p>&#13;
&#13;
<p class="pagebreak-before">First, let’s introduce an error into the <code>WeatherEvent</code> Lambda, by removing that Lambda’s permission to access DynamoDB:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting">  <code class="nt">WeatherEventLambda</code><code class="p">:</code>&#13;
    <code class="nt">Type</code><code class="p">:</code> <code class="l-Scalar-Plain">AWS::Serverless::Function</code>&#13;
    <code class="nt">Properties</code><code class="p">:</code>&#13;
      <code class="nt">CodeUri</code><code class="p">:</code> <code class="l-Scalar-Plain">target/lambda.zip</code>&#13;
      <code class="nt">Handler</code><code class="p">:</code> <code class="l-Scalar-Plain">book.api.WeatherEventLambda::handler</code>&#13;
 <code class="c1">#      Policies:</code>&#13;
 <code class="c1">#        — DynamoDBCrudPolicy:</code>&#13;
 <code class="c1">#            TableName: !Ref LocationsTable</code>&#13;
      <code class="nt">Events</code><code class="p">:</code>&#13;
        <code class="nt">ApiEvents</code><code class="p">:</code>&#13;
          <code class="nt">Type</code><code class="p">:</code> <code class="l-Scalar-Plain">Api</code>&#13;
          <code class="nt">Properties</code><code class="p">:</code>&#13;
            <code class="nt">Path</code><code class="p">:</code> <code class="l-Scalar-Plain">/events</code>&#13;
            <code class="nt">Method</code><code class="p">:</code> <code class="l-Scalar-Plain">POST</code></pre>&#13;
&#13;
<p>After deploying our serverless application stack, we can send an HTTP POST event to the <code>/events</code> endpoint.&#13;
When the <code>WeatherEvent</code> Lambda attempts to write that event to DynamoDB, it fails and throws an exception.&#13;
<a data-type="xref" href="#x-ray-service-map-error">Figure 7-11</a> shows what the <span class="keep-together">X-Ray</span> service map looks like after that happens.</p>&#13;
&#13;
<figure><div class="figure" id="x-ray-service-map-error">&#13;
<img alt="images/ch07_image11.png" src="assets/awsl_0711.png"/>&#13;
<h6><span class="label">Figure 7-11. </span>X-Ray service map showing an error</h6>&#13;
</div></figure>&#13;
&#13;
<p class="pagebreak-before">And when we drill into the specific request that caused the error, we can see that our POST request returned an HTTP 502 error (<a data-type="xref" href="#x-ray-trace-map-error">Figure 7-12</a>).</p>&#13;
&#13;
<figure><div class="figure" id="x-ray-trace-map-error">&#13;
<img alt="images/ch07_image12.png" src="assets/awsl_0712.png"/>&#13;
<h6><span class="label">Figure 7-12. </span>X-Ray trace showing an error</h6>&#13;
</div></figure>&#13;
&#13;
<p>We can then easily see the specific Java exception that caused the Lambda function to fail by hovering on the error icon next to the portion of the trace that shows the Lambda invocation (<a data-type="xref" href="#x-ray-trace-hover-exception">Figure 7-13</a>).</p>&#13;
&#13;
<figure><div class="figure" id="x-ray-trace-hover-exception">&#13;
<img alt="images/ch07_image13.png" src="assets/awsl_0713.png"/>&#13;
<h6><span class="label">Figure 7-13. </span>X-Ray trace showing a Java exception</h6>&#13;
</div></figure>&#13;
&#13;
<p class="pagebreak-before">Clicking<a data-primary="" data-startref="xray07" data-type="indexterm" id="idm46222413405496"/><a data-primary="" data-startref="dtrace07" data-type="indexterm" id="idm46222413404488"/><a data-primary="" data-startref="Tdistt07" data-type="indexterm" id="idm46222413403544"/><a data-primary="" data-startref="Mdisttrac07" data-type="indexterm" id="idm46222413402600"/> through will then show us the full stack trace, right from the X-Ray trace console (<a data-type="xref" href="#x-ray-trace-stack">Figure 7-14</a>).</p>&#13;
&#13;
<figure><div class="figure" id="x-ray-trace-stack">&#13;
<img alt="images/ch07_image14.png" src="assets/awsl_0714.png"/>&#13;
<h6><span class="label">Figure 7-14. </span>X-Ray showing a Java exception stack trace</h6>&#13;
</div></figure>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="idm46222413476440">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>In this chapter, we covered the variety of ways we can gain insight into exactly how our serverless application is performing and functioning, both at the individual function or component level and as a complete application. We showed how using structured JSON logging enables observability and gives us the ability to surface meaningful business metrics from our highly scalable Lambda functions without overwhelming the CloudWatch API.</p>&#13;
&#13;
<p>Finally, we added a few dependencies to our Maven <em>pom.xml</em> and unlocked fully featured distributed tracing capabilities, which not only trace individual requests but also automatically build out a map of all the components of our serverless application and allow us to easily drill into errors or unexpected behavior.</p>&#13;
&#13;
<p>With the basics now covered, in the next chapter we’ll dive into the advanced Lambda techniques that will make our production serverless systems robust and reliable.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Exercises" data-type="sect1"><div class="sect1" id="idm46222413394936">&#13;
<h1>Exercises</h1>&#13;
<ol>&#13;
<li>&#13;
<p>This<a data-primary="exercises" data-secondary="logging, metrics, and tracing" data-type="indexterm" id="idm46222413392872"/> chapter builds on the API Gateway code from <a data-type="xref" href="ch05.html#ch05">Chapter 5</a>.&#13;
Add X-Ray instrumentation to the updated data pipeline code from <a data-type="xref" href="ch06.html#ch06">Chapter 6</a>, and observe how the interactions with SNS and S3 show up in the X-Ray console.</p>&#13;
</li>&#13;
<li>&#13;
<p>In addition to incrementing a metric as we’ve done in this chapter, CloudWatch Logs metric filters can parse a metric value from a log line.&#13;
Use this technique to generate a CloudWatch Logs metric for the temperature in Brooklyn, NY.&#13;
For extra credit, add an alarm for when the the temperature goes below 32 degrees Fahrenheit!</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section></body></html>