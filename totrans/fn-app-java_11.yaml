- en: Chapter 9\. Handling null with Optionals
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章\. 使用Optionals处理null
- en: 'As a Java developer, you’ve most likely encountered your fair share of `NullPointerExceptions`,
    and then some. Many people call the `null` reference a *billion-dollar mistake*.
    Actually, the inventor of `null` itself originally coined that phrase:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 作为Java开发者，你很可能遇到过大量的`NullPointerExceptions`，甚至更多。许多人称`null`引用为*亿美元错误*。事实上，`null`本身的发明者最初就是这样称呼它的：
- en: I call it my billion-dollar mistake.
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我称之为我的亿美元错误。
- en: ''
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It was the invention of the `null` reference in 1965. At that time, I was designing
    the first comprehensive type system for references in an object-oriented language
    (ALGOL W). My goal was to ensure that all use of references should be absolutely
    safe, with checking performed automatically by the compiler. But I couldn’t resist
    the temptation to put in a `null` reference simply because it was so easy to implement.
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这是在1965年发明的`null`引用。当时，我正在设计第一个综合型对象导向语言(ALGOL W)的引用类型系统。我的目标是确保所有引用的使用都是绝对安全的，由编译器自动执行检查。但我无法抵挡诱惑，只是因为它太容易实现，就加入了一个`null`引用。
- en: ''
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This has led to innumerable errors, vulnerabilities, and system crashes, which
    have probably caused a billion dollars of pain and damage in the last forty years.
  id: totrans-6
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这导致了无数的错误、漏洞和系统崩溃，在过去的四十年里，这可能造成了数十亿美元的痛苦和损失。
- en: ''
  id: totrans-7
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Sir Charles Antony Richard Hoare, QCon London 2009
  id: totrans-8
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 查尔斯·安东尼·理查德·霍尔爵士，QCon伦敦2009
- en: Although there is no absolute consensus on how to deal with this “mistake,”
    many programming languages have a proper and idiomatic way of handling `null`
    references, often directly integrated into the language itself.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如何处理这个“错误”还没有绝对的共识，但许多编程语言都有处理`null`引用的正确和惯用方法，通常直接集成到语言本身中。
- en: This chapter will show you how Java handles `null` references and how to improve
    it in your code with the `Optional<T>` type and its functional API, and learn
    how, when, and when not to use Optionals.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将向您展示Java如何处理`null`引用，以及如何使用`Optional<T>`类型及其功能API在代码中改进它，并学习何时以及何时不使用Optionals。
- en: The Problem with null References
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于null引用的问题
- en: Java’s handling of the absence of a value depends on the type. All primitive
    types have default values, e.g., a zero-equivalent for numeric types and `false`
    for `boolean`. Non-primitive types, like classes, interfaces, and arrays, use
    `null` as their default value if unassigned, meaning the variable isn’t referencing
    any object.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Java对于值的缺失的处理取决于类型。所有原始类型都有默认值，例如，数值类型的零等价物和`boolean`类型的`false`。非原始类型，如类、接口和数组，如果未分配，则使用`null`作为它们的默认值，这意味着变量不引用任何对象。
- en: Note
  id: totrans-13
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The concept of reference types may seem similar to C/C++ pointers, but Java
    references are a specialized type inside the JVM called `reference`. The JVM strictly
    controls them to ensure type-safety and safe-guarding memory access.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 引用类型的概念可能看起来与C/C++指针相似，但Java引用是JVM内的一个专门类型，称为`reference`。JVM严格控制它们以确保类型安全和内存访问的安全性。
- en: A `null` reference isn’t just “nothing”; it’s a *special state* because `null`
    is a generalized type that can be used for any object reference, regardless of
    the actual type. If you attempt to access such a `null` reference, the JVM will
    throw a `NullPointerException`, and the current thread will crash if you don’t
    handle it appropriately. This is usually mitigated by a defensive programming
    approach, requiring `null` checks *everywhere* at runtime, as seen in [Example 9-1](#_02-optionals-minefield).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`null`引用不只是“空”，它是一个*特殊状态*，因为`null`是一个广义类型，可以用于任何对象引用，无论实际类型如何。如果尝试访问这样的`null`引用，JVM将抛出`NullPointerException`，如果不适当处理，当前线程将崩溃。通常通过防御性编程方法来缓解这个问题，在运行时*随处*需要`null`检查，如[示例 9-1](#_02-optionals-minefield)中所示。
- en: Example 9-1\. A minefield of possible nulls
  id: totrans-16
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 9-1\. 可能存在空指针的地雷区
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[![1](assets/1.png)](#co_handling_null_with_optionals_CO1-1)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_handling_null_with_optionals_CO1-1)'
- en: '`String.format` accepts `null` values as long its not the sole value for arguments^([1](ch09.xhtml#idm45115229846656))
    after the format string. It translates to the string “null,” regardless of the
    chosen format specifier, even for numeric ones.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`String.format`接受`null`值，只要它不是格式字符串之后的唯一值^([1](ch09.xhtml#idm45115229846656))。它会翻译为字符串“null”，无论所选的格式说明符如何，甚至对于数值类型也是如此。'
- en: '[![2](assets/2.png)](#co_handling_null_with_optionals_CO1-2)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_handling_null_with_optionals_CO1-2)'
- en: Using `null` as an argument in a method call might not crash the current thread.
    however, calling a method on a `null` reference certainly does.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法调用中使用 `null` 作为参数可能不会导致当前线程崩溃。但是，在 `null` 引用上调用方法肯定会崩溃。
- en: The previous example highlights two major problems in dealing with `null`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子突显了处理 `null` 中的两个主要问题。
- en: First, `null` references are valid values for variables, arguments, and return
    values. That doesn’t mean that `null` is the expected, correct, or even acceptable
    value for each of them and might not be handled correctly down the line.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`null` 引用是变量、参数和返回值的有效值。这并不意味着 `null` 是每个情况下的预期、正确或甚至可接受的值，并且可能在处理过程中未被正确处理。
- en: For example, calling `getFullname` on `user` in the previous example worked
    fine with a `null` reference for `lastname`, but the output — “Ben null" — is
    most likely not what’s intended. So even if your code and data structures can
    handle `null` values superficially, you still might need to check for them to
    ensure a correct outcome.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在前面的例子中，对 `user` 调用 `getFullname` 函数时，使用 `null` 引用作为 `lastname` 是可以正常工作的，但输出“Ben
    null”很可能不是预期的结果。因此，即使您的代码和数据结构可以表面上处理 `null` 值，您仍然可能需要检查它们以确保正确的结果。
- en: 'The second problem of `null` references is one of their main features: type
    ambiguity. They can represent any type without actually being that particular
    type. That unique property is necessary, so a single keyword can represent the
    generalized concept of “absence of value” throughout your code without resorting
    to different types or keywords for different object types. Even though a `null`
    reference is usable just like the type it represents, it still *isn’t* the type
    itself, as seen in [Example 9-2](#_02-optionals-null-type-ambiguity).'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`null` 引用的第二个问题是它们的一个主要特性：类型模糊性。它们可以表示任何类型，而不实际成为该特定类型。这种独特的属性是必要的，因此可以在整个代码中使用单个关键字表示“缺少值”的泛化概念，而不需要为不同的对象类型使用不同的类型或关键字。尽管
    `null` 引用可以像它表示的类型一样使用，但它仍然*不是*该类型本身，正如在[示例 9-2](#_02-optionals-null-type-ambiguity)中所见。'
- en: Example 9-2\. null type ambiguity
  id: totrans-26
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 9-2\. null 类型模糊性
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[![1](assets/1.png)](#co_handling_null_with_optionals_CO2-1)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_handling_null_with_optionals_CO2-1)'
- en: '`null` can represent any object type and, therefore, is a valid value for any
    non-primitive argument.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`null` 可以表示任何对象类型，因此对于任何非原始类型的参数，它都是一个有效的值。'
- en: '[![2](assets/2.png)](#co_handling_null_with_optionals_CO2-2)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_handling_null_with_optionals_CO2-2)'
- en: A variable referencing `null` is like any other variable of that type. Except
    for any call on it will result in a `NullPointerException`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 引用 `null` 的变量就像该类型的任何其他变量一样。但任何对它的调用都将导致 `NullPointerException`。
- en: '[![3](assets/3.png)](#co_handling_null_with_optionals_CO2-3)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_handling_null_with_optionals_CO2-3)'
- en: Testing a variable with `instanceof` will always evaluate to `false` regardless
    of the type. Even if it’s explicitly cast into the required type, the `instanceof`
    operator tests the underlying value itself. Therefore, it tests against the typeless
    value `null`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `instanceof` 测试变量将始终评估为 `false`，而不管类型如何。即使它被显式地强制转换为所需的类型，`instanceof` 运算符也会测试基础值本身。因此，它针对无类型值
    `null` 进行测试。
- en: These are the most apparent sore points with `null`. Not to worry; there are
    ways to ease the pain.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是处理 `null` 的最明显的痛点。不要担心，有方法可以减轻这种痛苦。
- en: How to handle null in Java (before Optionals)
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何处理 Java 中的空值（在使用 Optional 之前）
- en: Dealing with `null` in Java is an essential and necessary part of every developer’s
    work, even if it can be cumbersome. Encountering an unexpected and unhandled `NullPointerException`
    is the root cause of many problems and must be dealt with accordingly.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 中处理 `null` 是每个开发人员工作中必不可少的重要部分，尽管它可能很麻烦。遇到意外且未处理的 `NullPointerException`
    是许多问题的根源，必须相应地处理。
- en: Other languages, like [Swift](https://www.swift.org), provide dedicated operators
    and idioms, in the form of a safe navigation^([2](ch09.xhtml#idm45115229645008))
    or `null` coalesce operator^([3](ch09.xhtml#idm45115229642560)) to make dealing
    with `null` easier. Java doesn’t provide such built-in tools to handle `null`
    references, though.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 其他语言，如[Swift](https://www.swift.org)，提供了专用运算符和习语，如安全导航^([2](ch09.xhtml#idm45115229645008))或
    `null` 合并运算符^([3](ch09.xhtml#idm45115229642560))，以便更轻松地处理 `null`。然而，Java 并没有提供这样的内置工具来处理
    `null` 引用。
- en: 'There were three different ways to deal with `null` references before Optionals:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 Optional 之前，有三种不同的方法来处理 `null` 引用：
- en: Best practices
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最佳实践
- en: Tool-assisted `null`-checks
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工具辅助的 `null` 检查
- en: Specialized types like Optional
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Optional 等专门类型
- en: As you will see later, handling `null` references shouldn’t rely solely on Optionals.
    They are a great addition to the prior techniques by providing a standardized
    and readily available specialized type within the JDK. Still, they’re not the
    final thought on how to manage `null` throughout your code, and knowing about
    all available techniques is a valuable addition to your skills toolkit.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您稍后将看到的那样，处理`null`引用不应仅依赖于Optional。它们是前述技术的重要补充，通过在JDK中提供标准化和便捷的专用类型。然而，它们并不是如何在整个代码中管理`null`的最终想法，了解所有可用技术将是您技能工具包中的宝贵补充。
- en: Best Practices for Handling null
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理`null`的最佳实践
- en: If a language doesn’t provide integrated `null` handling, you must resort to
    *best practices* and *informal rules* to `null`-proof your code. That’s why many
    companies, teams, and projects develop their own coding style or adapt existing
    ones to their needs to provide guidelines to write consistent and safer code,
    not only regarding `null`. By adhering to these self-imposed practices and rules,
    they’re able to write more predictable and less error-prone code consistently.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果语言不提供集成的`null`处理，您必须依靠*最佳实践*和*非正式规则*来使您的代码免于`null`。这就是为什么许多公司、团队和项目开发自己的编码风格或适应现有的风格以提供编写一致和更安全代码的指南，不仅限于`null`。通过遵循这些自我规定的实践和规则，他们能够始终编写更可预测和不易出错的代码。
- en: 'You don’t have to develop or adapt a full-blown style guide defining every
    aspect of your Java code. Instead, following these four rules are a good starting
    point for handling `null` references:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 您不必开发或适应全面的样式指南来定义您的Java代码的每个方面。相反，遵循这四条规则是处理`null`引用的良好起点：
- en: Don’t Initialize a Variable to null
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不要将变量初始化为null
- en: Variables should always have a non-`null` value. If the value depends on a decision-making
    block like an `if`-`else`-statement, you should consider either refactoring it
    into a method or, if it’s a simple decision, using the ternary operator.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 变量应始终具有非`null`值。如果值取决于决策块（如`if-else`语句），您应考虑将其重构为方法，或者如果它是一个简单的决策，则使用三元运算符。
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The additional benefit is that it makes the variable effectively `final` if
    you don’t reassign it later, so you can use them as out-of-body variables in lambda
    expressions.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 其额外好处是如果稍后不再重新分配变量，则使变量实际上成为`final`，因此您可以将它们用作lambda表达式中的局部变量。
- en: Don’t Pass, Accept, or Return null
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不要传递、接受或返回`null`
- en: 'As variables shouldn’t be `null`, so should any arguments and return values
    avoid being `null`. Non-required arguments being `null` can be avoided by overloading
    a method or constructor:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 变量不应为`null`，因此任何参数和返回值也应避免为`null`。通过方法或构造函数的重载可以避免非必需参数为`null`的情况：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If method signatures clash due to identical argument types, you can always resort
    `static` methods with more explicit names instead.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于相同的参数类型而导致方法签名冲突，您始终可以改用更明确名称的`static`方法。
- en: 'After providing specific methods and constructors for optional values, you
    shouldn’t accept `null` in the original ones if it’s appropriate. The easiest
    way to do this is using the `static` `requireNonNull` method available on `java.util.Objects`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 提供了针对可选值的特定方法和构造函数后，如果适当的话，原始方法中就不应接受`null`。最简单的方法是使用`java.util.Objects`上可用的`static`
    `requireNonNull`方法：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `requireNionNull` call does the `null`-check for you and throws a `NullPointerException`
    if appropriate. Since Java 14, any `NullPointerException` includes the name of
    the variable that was `null`, thanks to [JEP 358](https://openjdk.org/jeps/358).
    If you want to include a specific message or target a previous Java version, you
    can add a `String` as the second argument to the call.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`requireNonNull`调用会为您执行`null`检查，并在适当时抛出`NullPointerException`。自Java 14以来，任何`NullPointerException`都包含变量的名称，感谢[JEP
    358](https://openjdk.org/jeps/358)。如果要包含特定消息或针对较早的Java版本进行定位，可以将`String`作为调用的第二个参数添加。'
- en: Check Everything Outside Your Control
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查一切不在您控制之外的事情
- en: Even if you adhere to your own rules, you can’t rely on others to do, too. Using
    non-familiar code, especially if not stated explicitly in the documentation, should
    always be assumed to be possibly `null` and needs to be checked.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 即使遵循自己的规则，也不能依赖他人也这样做。始终假设使用非熟悉代码（特别是如果文档中未明确说明）可能为`null`，并且需要进行检查。
- en: null Is Acceptable as an Implementation Detail
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`null`作为实现细节是可以接受的'
- en: Avoiding `null` is essential for the `public` surface of your code but is still
    sensible as an implementation detail. Internally, a method might use `null` as
    much as needed as long as it won’t return it to the callee.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 避免`null`对于代码的`public`接口至关重要，但作为实现细节仍然是明智的。在内部，一个方法可以根据需要使用`null`，只要不将其返回给调用者即可。
- en: When and When Not to Follow the Rules
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 何时遵循规则，何时不遵循规则
- en: These rules aim at reducing the general use of `null` whenever possible if code
    is intersecting, like API surfaces, because less exposure leads to fewer required
    `null`-checks and possible `NullPointerExceptions`. But that doesn’t mean you
    should avoid `null` altogether. For example, in isolated contexts, like local
    variables or non-`public` API, using `null` isn’t as problematic and might even
    simplify your code as long as used deliberately and with care.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这些规则旨在尽可能减少`null`的一般使用，特别是在代码交集处，如API表面，因为更少的暴露会导致更少的必需`null`检查和可能的`NullPointerExceptions`。但这并不意味着你应该完全避免`null`。例如，在隔离的上下文中，如局部变量或非`public`的API中，使用`null`并不那么问题，甚至可能简化您的代码，只要谨慎使用即可。
- en: You can’t expect everyone to follow the same rules as you or be as diligent,
    so you need to be defensive with code, especially outside of your control. This
    is all the more reason to consistently stick to your best practices and also encourage
    others to do the same. They will improve your overall code quality, regardless
    of `null`. But it’s not a silver bullet and requires discipline among your team
    to gain the most benefits. Manually handling `null` and adding a few `null`-checks
    is preferable to getting the unwelcome surprise in the form of a `NullPointerException`
    because you assumed something could “never” be `null`. The JIT compiler^([4](ch09.xhtml#idm45115229323040))
    will even perform "`null` check elimination” to remove many explicit `null` checks
    from optimized Assembly code thanks to its greater knowledge at runtime.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能期望每个人都遵循与你相同的规则或者一样细心，因此你需要在代码中保持防御性，尤其是在你控制范围之外的情况下。这更加理由让你始终坚持最佳实践，并鼓励其他人也这样做。它们将提高你的整体代码质量，不论`null`如何。但这不是银弹，需要团队的纪律才能获得最大的好处。手动处理`null`并添加一些`null`检查优于因为假设某些东西“永远”不可能为`null`而导致意外的`NullPointerException`。即使是JIT编译器^([4](ch09.xhtml#idm45115229323040))也会执行“`null`检查消除”，从优化的汇编代码中删除许多显式的`null`检查，这要归功于其在运行时的更多知识。
- en: Tool-Assisted null-checks
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工具辅助的空值检查
- en: A logical extension of the best practices and informal rules approach is to
    use third-party tools to enforce them automatically. For `null` references in
    Java, an established best practice is to use annotations to mark variables, arguments,
    and method return types as either `@Nullable` or `@NonNull`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳实践和非正式规则方法的逻辑扩展是使用第三方工具自动强制执行它们。对于Java中的`null`引用，一个既定的最佳实践是使用注解将变量、参数和方法返回类型标记为`@Nullable`或`@NonNull`。
- en: Before such annotations, the only place to document nullability was JavaDoc.
    With these annotations, static code analysis tools can find possible problems
    with `null` at compile time. Even better, adding these annotations to your code
    gives your method signatures and type definitions a more evident intent of how
    to use them and what to expect, as seen in [Example 9-3](#_02-optionals-annotations).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在此类注解之前，唯一可以记录空值的地方是JavaDoc。通过这些注解，静态代码分析工具可以在编译时发现可能的`null`问题。更好的是，将这些注解添加到您的代码中，可以更明确地表达方法签名和类型定义的意图，如在[示例 9-3](#_02-optionals-annotations)中所见。
- en: Example 9-3\. Null handling with annotation
  id: totrans-67
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 9-3\. 带注解的空值处理
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[![1](assets/1.png)](#co_handling_null_with_optionals_CO3-1)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_handling_null_with_optionals_CO3-1)'
- en: Returns a non-`null` `List` of possible `null` `String` objects.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个可能为`null`的`List`，其中包含非`null`的`String`对象。
- en: '[![2](assets/2.png)](#co_handling_null_with_optionals_CO3-2)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_handling_null_with_optionals_CO3-2)'
- en: Returns a possible `null` `List` containing non-`null` `String` objects.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 返回可能为`null`的`List`，其中包含非`null`的`String`对象。
- en: '[![3](assets/3.png)](#co_handling_null_with_optionals_CO3-3)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_handling_null_with_optionals_CO3-3)'
- en: The method argument `identifier` is allowed to be `null`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 方法参数`identifier`允许为`null`。
- en: The JDK doesn’t include these annotations, though, and the corresponding [JSR
    305](https://jcp.org/en/jsr/detail?id=305) state has been “dormant” since 2012.
    Nevertheless, it’s still the *de facto* community standard and is widely adopted
    by libraries, frameworks, and IDEs. Several libraries^([5](ch09.xhtml#idm45115229213376))
    provide the missing annotations, and most tools support multiple variants of them.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: JDK 不包括这些注解，对应的 [JSR 305](https://jcp.org/en/jsr/detail?id=305) 自 2012 年以来一直处于“休眠”状态。尽管如此，它仍然是事实上的社区标准，并被许多库、框架和
    IDE 广泛采用。几个库^([5](ch09.xhtml#idm45115229213376))提供了缺失的注解，大多数工具支持多种变体。
- en: Warning
  id: totrans-76
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Even though the behavior of `@NonNull` and `@Nullable` seems evident on the
    surface, the actual implementation might differ between tools, especially in edge
    cases^([6](ch09.xhtml#idm45115229208080)).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 `@NonNull` 和 `@Nullable` 的行为在表面上似乎显而易见，但实际实现可能因工具不同而有所不同，特别是在边缘情况下^([6](ch09.xhtml#idm45115229208080))。
- en: The general problem with a tool-assisted approach is the reliance on the tool
    itself. If it’s too intrusive, you might end up with code that won’t run without
    it, especially if the tool involves code generation “behind the scenes.” In the
    case of `null`-related annotations, however, you don’t have to worry much. Your
    code will still run without a tool interpreting the annotations, and your variables
    and method signatures will still clearly communicate their requirements to anyone
    using them, even if unenforced.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 工具辅助方法的一般问题在于对工具本身的依赖。如果它过于侵入式，你可能最终会得到无法运行的代码，特别是如果工具在“幕后”生成代码。然而，在涉及 `null`
    相关注解的情况下，你不必过于担心。你的代码仍然可以在没有工具解释注解的情况下运行，并且你的变量和方法签名仍然能够清晰地传达它们的要求给任何使用它们的人，即使没有强制执行。
- en: Specialized Types like Optional
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 像 Optional 这样的专门类型
- en: A tool-assisted approach gives you compile-time `null`-checks, whereas specialized
    types give you safer `null`-handling at runtime. Before Java introduced its own
    `Optional` type, this gap in missing functionality was bridged by different libraries,
    like the rudimentary `Optional` type provided by the [Google Guava framework](https://github.com/google/guava/wiki/Release10)
    since 2011.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 工具辅助方法给你编译时的 `null` 检查，而专门类型则在运行时提供更安全的 `null` 处理。在 Java 引入自己的 `Optional` 类型之前，不同的库填补了这个缺失功能，比如自
    2011 年起由 [Google Guava 框架](https://github.com/google/guava/wiki/Release10) 提供的基本的
    `Optional` 类型。
- en: Even though there’s now an integrated solution available in the JDK, Guava doesn’t
    plan to deprecate the class in the foreseeable future^([7](ch09.xhtml#idm45115229199920)).
    Still, they gently recommend that you prefer the new, standard Java `Optional<T>`
    whenever possible.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 JDK 现在提供了一个集成的解决方案，Guava 在可预见的未来不打算弃用这个类^([7](ch09.xhtml#idm45115229199920))。然而，他们温和建议你在可能的情况下优先选择新的、标准的
    Java `Optional<T>`。
- en: Optionals to the Rescue
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Optional 来拯救
- en: Java 8’s new `Optional<T>` isn’t only a specialized type to deal with `null`
    consistently; it’s also a functional-akin pipeline benefiting from all the functional
    additions available in the JDK.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8 新的 `Optional<T>` 不仅仅是一个专门处理 `null` 的类型，它还是一个功能类似管道，从 JDK 中所有可用的功能补充中受益。
- en: What’s an Optional?
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是 Optional？
- en: The simplest way to think of the `Optional<T>` type is to see it as a box containing
    an actual value that might be `null`. Instead of passing around a possible `null`
    reference, you use the box, as seen in [Figure 9-1](#_02-optionals-variable-versus-optional).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 想象 `Optional<T>` 类型最简单的方法是把它看作一个可能包含 `null` 的值的盒子。你可以使用这个盒子来替代传递可能为 `null` 的引用，如在
    [图 9-1](#_02-optionals-variable-versus-optional) 中所见。
- en: '![Variable versus Optional<T>](assets/afaj_0901.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![可变 vs 可选<T>](assets/afaj_0901.png)'
- en: Figure 9-1\. Variable versus Optional<T>
  id: totrans-87
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 9-1\. 可变 vs 可选<T>
- en: The box provides a safe wrapper around its inner value. Optionals do not only
    wrap a value, though. Starting from this box, you can build intricate call chains
    that depend on a value’s existence or absence. They can manage the whole lifecycle
    of a possible value until the box is unwrapped, including a fallback if no value
    is present, in such a call chain.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这个盒子提供了一个安全的包装器围绕它的内部值。但是 Optional 不仅仅包装一个值。从这个盒子开始，你可以构建复杂的调用链，这些调用链依赖于值的存在或缺失。它们可以管理可能值的整个生命周期，直到盒子被解封，包括在这样一个调用链中没有值时的回退。
- en: The downside of using a wrapper, though, is having to actually look and reach
    into the box if you want to use its inner value. Like Streams, the additional
    wrapper also creates an unavoidable overhead regarding method calls and their
    additional stack frames. On the other hand, the box provides additional functionality
    for more concise and straightforward code for common workflows with possible `null`
    values.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用包装器的缺点在于如果想要使用其内部值，必须实际查看和获取箱子。与流类似，额外的包装器还会在方法调用及其额外的栈帧方面产生无法避免的开销。另一方面，该箱提供了额外的功能，用于处理可能为`null`值的常见工作流的更简洁和直接的代码。
- en: As an example, let’s look at the workflow of loading content by an identifier.
    The numbers in [Figure 9-2](#_02-optionals-example-intro) correspond to the upcoming
    code in [Example 9-5](#_01-optional-call-chain).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们看一下通过标识符加载内容的工作流程。[图 9-2](#_02-optionals-example-intro)中的数字对应于[示例 9-5](#_01-optional-call-chain)中即将出现的代码。
- en: '![Loading Content](assets/afaj_0902.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![加载内容中](assets/afaj_0902.png)'
- en: Figure 9-2\. Workflow of loading content
  id: totrans-92
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 9-2\. 加载内容的工作流程
- en: The workflow is simplified and doesn’t handle all edge cases, but it’s a straightforward
    example of converting a multi-step workflow into an Optional call chain. In [Example 9-4](#_01-optional-call-chain_0),
    you see the workflow implemented without the help of Optionals first.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 该工作流程简化了，并且未处理所有边缘情况，但它是将多步工作流转换为可选调用链的简单示例。在[示例 9-4](#_01-optional-call-chain_0)中，您可以先看到未使用可选的工作流程实现。
- en: Example 9-4\. Loading content without Optionals
  id: totrans-94
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 9-4\. 使用非可选加载内容
- en: '[PRE6]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The example is exaggerated to make a point, but still mostly reflects a typical
    approach to defensive `null`-handling.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 例如是夸张的，但仍大多反映了防御性`null`处理的典型方法。
- en: There are three explicit `null`-checks, plus two decisions to be made about
    a current value and two temporary variables. Even though it’s not much code, the
    overall flow isn’t easily graspable with its many `if`-blocks and early returns.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有三个明确的`null`检查，再加上关于当前值和两个临时变量的两个决策。尽管代码量不多，但总体流程由于其中许多`if`块和早期返回而不易理解。
- en: Let’s convert the code to a single Optional call chain, as shown in [Example 9-5](#_01-optional-call-chain).
    Don’t worry! The upcoming sections will explain the different kinds of operations
    in detail.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将代码转换为单个可选调用链，如[示例 9-5](#_01-optional-call-chain)所示。别担心！接下来的章节将详细解释不同类型的操作。
- en: Example 9-5\. Loading content with an Optional call chain
  id: totrans-99
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 9-5\. 使用可选调用链加载内容
- en: '[PRE7]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[![1](assets/1.png)](#co_handling_null_with_optionals_CO4-1)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_handling_null_with_optionals_CO4-1)'
- en: The first possible `null`-check is done by using the `ofNullable` creation method.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个可能的`null`检查是使用`ofNullable`创建方法完成的。
- en: '[![2](assets/2.png)](#co_handling_null_with_optionals_CO4-2)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_handling_null_with_optionals_CO4-2)'
- en: The next `if`-block is replaced by a `filter` operation.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个`if`块被`filter`操作替换。
- en: '[![3](assets/3.png)](#co_handling_null_with_optionals_CO4-3)'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_handling_null_with_optionals_CO4-3)'
- en: Instead of using temporary variables, the `map` operation transforms the value
    to match the next call.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是使用临时变量，`map`操作将值转换为匹配下一个调用的形式。
- en: '[![4](assets/4.png)](#co_handling_null_with_optionals_CO4-4)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_handling_null_with_optionals_CO4-4)'
- en: The content is also retrievable by a `map` operation.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 该内容也可以通过`map`操作来检索。
- en: '[![5](assets/5.png)](#co_handling_null_with_optionals_CO4-5)'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_handling_null_with_optionals_CO4-5)'
- en: Load the content from the database if no value is present in the pipeline. This
    call will return another Optional so that the call chain can continue.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果管道中不存在值，则从数据库加载内容。此调用将返回另一个可选项，以便调用链可以继续。
- en: '[![6](assets/6.png)](#co_handling_null_with_optionals_CO4-6)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_handling_null_with_optionals_CO4-6)'
- en: Ensure only published content is available.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 确保只有发布的内容可用。
- en: The Optional call chain condenses the overall code to one operation per line,
    making the overall flow easily graspable. It perfectly highlights the difference
    between using an Optional call chain and the “traditional” way of `null` checking
    everything.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 可选调用链将整体代码压缩到每行一个操作，使整体流程易于理解。它完美地突显了使用可选调用链和“传统”方式检查`null`之间的差异。
- en: Let’s take a look at the different steps of creating and working with Optional
    pipelines.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看创建和使用可选流水线的不同步骤。
- en: Building Optional Pipelines
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建可选流水线
- en: 'As of Java 17, `Optional<T>` provides three `static` and 15 instance methods
    belonging to one of four groups representing different parts of an Optional pipeline:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 截至 Java 17，`Optional<T>` 提供了三个 `static` 和 15 个属于四个组的实例方法，表示 Optional 管道的不同部分：
- en: Creating a new `Optional<T>` instance
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的 `Optional<T>` 实例
- en: Checking for values or reacting to the presence or absence of a value
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查值或对值的存在或不存在做出反应
- en: Filtering and transforming a value
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过滤和转换值
- en: Getting the value or having a backup plan
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取值或制定备用计划
- en: These operations can build a fluent pipeline, similar to Streams. Contrary to
    Streams, though, they are *not* lazily connected until a *terminal*-like operation
    is added to the pipeline, as I discussed in [“Streams as Functional Data Pipelines”](ch06.xhtml#_02-data-processing-what-is-a-stream).
    Every operation resolves as soon as it’s added to the fluent call. Optionals only
    appear lazy because they might return an empty Optional or a fallback value and
    skip transforming or filtering steps altogether. Still, that doesn’t make the
    call chain itself lazy. However, the executed work is as minimal as possible if
    a `null`-value is encountered, regardless of the operation count.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作可以构建一个流畅的管道，类似于 Streams。与 Streams 不同的是，它们 *不* 被惰性连接，直到向管道添加了类似 *terminal*
    的操作，正如我在 [“作为函数式数据流的流”](ch06.xhtml#_02-data-processing-what-is-a-stream) 中讨论的那样。每个操作一旦添加到流畅的调用中，就会立即解析。Optional
    之所以看起来懒散，是因为它们可能返回一个空的 Optional 或一个备用值，并跳过转换或过滤步骤。但是，这并不会使调用链本身变得懒散。然而，如果遇到 `null`
    值，无论操作数量如何，执行的工作都是尽可能少的。
- en: You can think of an Optional call chain as two train tracks, as illustrated
    in [Figure 9-3](#_02-optionals-fasttrack).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将 Optional 调用链想象成两条火车轨道，如 [图 9-3](#_02-optionals-fasttrack) 所示。
- en: '![Optional Train Tracks](assets/afaj_0903.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![Optional 火车轨道](assets/afaj_0903.png)'
- en: Figure 9-3\. Optional Train Tracks
  id: totrans-124
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 9-3\. Optional 火车轨道
- en: 'In this analogy, we have two train tracks: the Optional call chain track that
    leads to returning an `Optional<T>` with an inner value and the “empty express
    track” that leads to an empty `Optional<T>`. A train always starts on the `Optional<T>`
    call train track. When it encounters a track switch (an Optional operation), it
    looks for a `null` value, in which case, the train will switch to the empty express
    track. Once on the express track, there is no chance of returning to the Optional
    call chain track, at least not until Java 9, as you’ll see in [“Getting a (fallback)
    value”](#_02-optionals_getting-a-value).'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类比中，我们有两条火车轨道：Optional 调用链轨道，通向返回具有内部值的 `Optional<T>`，和“空快车轨道”，通向空的 `Optional<T>`。火车始终在
    `Optional<T>` 调用火车轨道上启动。当它遇到轨道切换（Optional 操作）时，它会寻找一个 `null` 值，这种情况下，火车将切换到空快车轨道。一旦进入快车轨道，就没有返回到
    Optional 调用链轨道的机会，至少在 Java 9 之前是这样的，您将在 [“获取（备用）值”](#_02-optionals_getting-a-value)
    中看到。
- en: Technically, it will still call each method on the Optional call chain after
    switching to the empty express track, but it’ll just validate parameters and move
    on. If the train didn’t encounter a `null` value by the time it reaches the end
    of its route, it returns a non-empty `Optional<T>`. If it encounters a `null`
    value at any point along the route, it will return an empty `Optional<T>`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，它仍然会在切换到空快车轨道后在 Optional 调用链上调用每个方法，但它只会验证参数并继续前进。如果火车在到达路线终点之前没有遇到 `null`
    值，它将返回一个非空的 `Optional<T>`。如果它在路线上的任何时候遇到 `null` 值，它将返回一个空的 `Optional<T>`。
- en: To get the train rolling, let’s create some Optionals.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让火车动起来，让我们创建一些 Optionals。
- en: Creating an Optional
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个 Optional
- en: 'There are no `public` constructors available on the `Optional<T>` type. Instead,
    it gives you three `static` factory methods to create new instances. Which one
    to use depends on your use case and prior knowledge of the inner value:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Optional<T>` 类型上没有`public`构造函数可用。相反，它为您提供了三个 `static` 工厂方法来创建新实例。使用哪一个取决于您的用例和对内部值的先验知识：
- en: '`Optional.ofNullable(T value)` if the value might be `null`'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果值可能是 `null`，则使用 `Optional.ofNullable(T value)`
- en: If you know a value might be `null` or don’t care if it might be empty, use
    the method `Optional.ofNullable(…​)` to create a new instance with a possible
    inner `null` value. It’s the simplest and most bullet-proof form of creating an
    `Optional<T>`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您知道一个值可能是 `null`，或者不在乎它可能为空，可以使用方法 `Optional.ofNullable(…​)` 创建一个可能具有内部 `null`
    值的新实例。这是创建 `Optional<T>` 的最简单、最可靠的形式。
- en: '[PRE8]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`Optional.of(T value)` if the value must be non-`null`'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果值必须为非`null`，则使用 `Optional.of(T value)`
- en: Even though Optionals are a great way to deal with `null` and prevent a `NullPointerException`,
    what if you have to make sure you have a value? For example, you already handled
    any edge cases in your code — which returned empty Optionals — and now you definitely
    have a value. The method `Optional.of(…​)` ensures that the value is non-`null`
    and throws an `NullPointerException` otherwise. This way, the exception signifies
    a real problem in your code. Maybe you missed an edge case, or a particular external
    method call has changed and returns `null` now. Using `Optional.of(…​)` in such
    a context makes your code more future-proof and resilient against unwanted changes
    in behavior.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 即使 Optionals 是处理 `null` 并防止 `NullPointerException` 的好方法，但如果你确保有一个值怎么办？例如，你已经处理了代码中的所有边缘情况，返回了空的
    Optionals，并且现在你肯定有一个值。`Optional.of(…​)` 方法确保该值非`null`，否则会抛出 `NullPointerException`。这样，异常表明了代码中的真实问题。也许你忽略了一个边缘情况，或者某个外部方法调用现在返回
    `null`。在这种情况下使用 `Optional.of(…​)` 可以使你的代码更加具有未来可扩展性，对行为不期而遇的变化更加鲁棒。
- en: '[PRE9]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`Optional.empty()` if there’s no value'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有值，则为 `Optional.empty()`。
- en: If you already know there’s no value at all, you can use the `static` method
    `Optional.empty()`. The call `Optional.ofNullable(null)` is unnecessary because
    there will be just an unnecessary `null` check before calling `empty()` itself.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经知道根本没有值，可以使用静态方法 `Optional.empty()`。调用 `Optional.ofNullable(null)` 是不必要的，因为在调用
    `empty()` 本身之前会进行不必要的 `null` 检查。
- en: '[PRE10]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Warning
  id: totrans-139
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: The JDK documentation explicitly mentions that the value returned by the `static`
    `Optional.empty` method isn’t guaranteed to be a singleton object. So you shouldn’t
    compare empty Optionals with `==` (double-equals), and use `equals(Object obj)`
    or compare the result of the `isEmpty` method instead.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: JDK 文档明确提到，由 `static` `Optional.empty` 方法返回的值不保证是单例对象。因此，你不应该使用 `==` （双等号）比较空的
    Optionals，而是应该使用 `equals(Object obj)` 或比较 `isEmpty` 方法的结果。
- en: Using `Optional.ofNullable(T value)` might be the most `null`-tolerant creation
    method, but you should strive to use the most fitting one to represent your use
    case and context knowledge. Code might get refactored or rewritten over time,
    and it’s better to have your code throw a `NullPointerException` for a suddenly
    missing value that’s actually required as an additional safeguard, even if the
    API itself is using Optionals.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Optional.ofNullable(T value)` 可能是最容忍 `null` 的创建方法，但你应该努力使用最适合表示你用例和上下文知识的方法。随着时间的推移，代码可能会被重构或重写，最好让你的代码为突然丢失的必需值抛出
    `NullPointerException`，即使 API 本身正在使用 Optionals。
- en: Checking for and Reacting to Values
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查和响应值
- en: Optionals are meant to wrap a value and represent its existence or absence.
    They are implemented as a Java type and are, therefore, a runtime-level feature
    and incur an unavoidable overhead associated with object creation. To compensate
    for this, checking for values should be as straightforward as possible.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Optionals 用于包装一个值并表示其存在或不存在。它们作为 Java 类型实现，并且因此在运行时级别具有不可避免的对象创建开销。为了补偿这一点，检查值应尽可能简单直接。
- en: 'There are four methods available for checking for and reacting to values or
    their absence. They are prefixed with "`is`" for checks and "`if`" for reactive
    higher-order functions:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 有四种方法可用于检查和响应值或其缺失。它们以“`is`”为前缀用于检查和以“`if`”为前缀用于响应的高阶函数：
- en: '`boolean isPresent()`'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean isPresent()`'
- en: '`boolean isEmpty()` (Java 11+)'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean isEmpty()`（Java 11+）'
- en: Solely checking for a value has its purposes, but checking, retrieving, and
    using a value requires three separate steps when you use "`is`" methods.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅检查值有其用途，但当你使用“`is`”方法时，检查、检索和使用值需要三个单独的步骤。
- en: 'That’s why the higher-order "`if`" methods consume a value directly:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么高阶“`if`”方法直接消耗一个值：
- en: '`void ifPresent(Consumer<? super T> action)`'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void ifPresent(Consumer<? super T> action)`'
- en: '`void ifPresentOrElse(Consumer<? super T> action, Runnable emptyAction)`'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void ifPresentOrElse(Consumer<? super T> action, Runnable emptyAction)`'
- en: Both methods only perform the given `action` if a value is present. The second
    method runs the `emptyAction` if no value is present. `null` actions aren’t allowed
    and throw a `NullPointerException`. There are no `ifEmpty…​` equivalents available.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 两种方法只有在存在值时才执行给定的 `action`。第二种方法在没有值时运行 `emptyAction`。不允许使用 `null` 作为动作，并会抛出
    `NullPointerException`。没有 `ifEmpty…​` 的等效方法可用。
- en: Let’s look at how to use these methods in [Example 9-6](#_02-optionals_checking).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在 [示例 9-6](#_02-optionals_checking) 中使用这些方法。
- en: Example 9-6\. Checking for Optional values
  id: totrans-153
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 9-6\. 检查 Optional 值的示例
- en: '[PRE11]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Both "`ifPresent`" methods perform side-effects-only code due to a lack of a
    return type. Even though pure functions are generally preferable in a functional
    approach, Optionals live somewhere between accepting functional code and fitting
    right into imperative code.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 由于缺少返回类型，两个`ifPresent`方法仅执行副作用代码。尽管在功能性方法中通常更可取，但Optionals处于接受功能性代码和完全适合命令式代码之间。
- en: Filtering and Mapping
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 过滤和映射
- en: Safely handling possible `null` values already removes a considerable burden
    from any developer, but Optionals allow for more than just checking for the presence
    or absence of a value.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 安全处理可能的`null`值已经从任何开发者身上卸下了相当大的负担，但Optionals不仅仅是用来检查值的存在或缺失。
- en: 'Similar to Streams, you build a pipeline with intermediate-like operations.
    There are three operations for filtering and mapping Optionals:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于流，你可以使用中间操作构建一个管道。这里有三个操作用于过滤和映射Optionals：
- en: '`Optional<T> filter(Predicate<? super T> predicate)`'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Optional<T> filter(Predicate<? super T> predicate)`'
- en: '`<U> Optional<U> map(Function<? super T, ? extends U> mapper)`'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<U> Optional<U> map(Function<? super T, ? extends U> mapper)`'
- en: '`<U> Optional<U> flatMap(Function<? super T, ? extends Optional<? extends U>>
    mapper)`'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<U> Optional<U> flatMap(Function<? super T, ? extends Optional<? extends U>>
    mapper)`'
- en: The `filter` operation returns `this` if a value is present and matches the
    given predicate. If no value is present or the predicate doesn’t match the value,
    an empty Optional is returned.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter`操作在存在值并且符合给定条件的情况下返回`this`。如果不存在值或者条件不匹配，则返回一个空的Optional。'
- en: The `map` operation transforms a present value with the provided mapper function,
    returning a new nullable Optional containing the mapped value. If no value is
    present, the operation returns an empty `Optional<U>` instead.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`map`操作使用提供的映射函数转换现有值，返回一个包含映射值的新的可空Optional。如果不存在值，则操作返回一个空的`Optional<U>`。'
- en: The `flatMap` is used if the mapping function returns an `Optional<U>` instead
    of a concrete value of type `U`. If you would use the `map` in this case, the
    return value would be an `Optional<Optional<U>>`. That’s why the `flatMap` returns
    the mapped value directly instead of wrapping it into another Optional.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果映射函数返回的是`Optional<U>`而不是类型为`U`的具体值，则使用`flatMap`。在这种情况下如果使用`map`，返回值将是`Optional<Optional<U>>`。这就是为什么`flatMap`直接返回映射值而不是将其再次包装为另一个Optional的原因。
- en: '[Example 9-7](#_02-optionals_intermediate-ops) shows an Optional call chain
    and the non-Optional equivalent for a hypothetical permissions container and its
    sub-types. The code callouts are attached to both versions to show the corresponding
    operations, but their descriptions are for the Optional version.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 9-7](#_02-optionals_intermediate-ops)展示了一个Optional调用链及其在假设的权限容器及其子类型中的非Optional等效形式。代码调用均附有对应的操作，但其描述适用于Optional版本。'
- en: Example 9-7\. Intermediate operations to find an active admin
  id: totrans-166
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例9-7。寻找活跃管理员的中间操作
- en: '[PRE12]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[![1](assets/1.png)](#co_handling_null_with_optionals_CO5-1)'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_handling_null_with_optionals_CO5-1)'
- en: The initial `null`-check is covered by creating an `Optional<Permissions>`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 初始的`null`检查通过创建一个`Optional<Permissions>`来处理。
- en: '[![2](assets/2.png)](#co_handling_null_with_optionals_CO5-2)'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_handling_null_with_optionals_CO5-2)'
- en: Filter for non-empty permissions. With the help of the `static` `Predicate.not`
    method, the lambda `permissions → !permissions.isEmpty()` is replaced with a more
    readable wrapped method reference.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤非空权限。借助`static`的`Predicate.not`方法，lambda表达式`permissions → !permissions.isEmpty()`被替换为一个更易读的包装方法引用。
- en: '[![3](assets/3.png)](#co_handling_null_with_optionals_CO5-3)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_handling_null_with_optionals_CO5-3)'
- en: Get the group of the permissions object. It doesn’t matter if the `Permissions::group`
    returns `null` because the Optional call chain will figuratively skip to its value-retrieving
    operation if that’s the case. In reality, an empty Optional is passing through
    the fluent calls.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 获取权限对象的组。如果`Permissions::group`返回`null`，Optional调用链将会在需要时跳过其取值操作。实际上，空的Optional会在流畅的调用中传递。
- en: '[![4](assets/4.png)](#co_handling_null_with_optionals_CO5-4)'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_handling_null_with_optionals_CO5-4)'
- en: The group might not have an admin. That’s why it returns an `Optional<User>`.
    If you simply use `map(Group::admin)`, you will have an `Optional<Optional<User>>`
    in the next step. Thanks to `flatMap(Group::admin)`, no unnecessarily nested Optional
    is created.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 组可能没有管理员。这就是为什么它返回一个`Optional<User>`。如果简单地使用`map(Group::admin)`，在下一步中会得到一个`Optional<Optional<User>>`。而借助于`flatMap(Group::admin)`，不会创建不必要的嵌套Optional。
- en: '[![5](assets/5.png)](#co_handling_null_with_optionals_CO5-5)'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_handling_null_with_optionals_CO5-5)'
- en: With the `User` object, you can filter out non-active ones.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `User` 对象，可以过滤掉非活动用户。
- en: '[![6](assets/6.png)](#co_handling_null_with_optionals_CO5-6)'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_handling_null_with_optionals_CO5-6)'
- en: If any method of the call chain returns an empty Optional, e.g., the group was
    `null`, the last operation returns the fallback value `Boolean.FALSE`. The next
    section will explain the different types of value-retrieval operations.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果调用链的任何方法返回空的 Optional，例如，组是 `null`，则最后一个操作返回回退值 `Boolean.FALSE`。下一节将解释不同类型的值检索操作。
- en: Every step of the underlying problem that needs to be solved is laid out in
    clear, isolated, and directly connected steps. Any validation and decision-making,
    like `null` or empty-checks, is wrapped up in dedicated operations built on method
    references. The intent and flow of the problem to be solved are clearly visible
    and easy to grasp.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 解决底层问题的每个步骤都清晰、分离且直接连接。任何验证和决策，如 `null` 或空检查，都包含在基于方法引用的专用操作中。解决问题的意图和流程清晰可见，易于理解。
- en: Doing the same thing without Optionals results in a nested mess of code, as
    seen in [Example 9-8](#_02-optionals_intermediate-ops_non-optional).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有 Optional，做同样的事情会导致嵌套的代码混乱，如 [示例 9-8](#_02-optionals_intermediate-ops_non-optional)
    所示。
- en: Example 9-8\. Finding an active admin without Optionals
  id: totrans-182
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 9-8\. 在没有 Optional 的情况下查找活动管理员
- en: '[PRE13]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The difference between the two versions is quite noticeable.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 两个版本之间的差异非常明显。
- en: The non-Optional version can’t delegate any conditions or checks and relies
    on explicit `if`-statements. That creates deeply nested flow structures, increasing
    the *cyclomatic complexity* of your code. It’s harder to understand the overall
    intent of the code block, and it is not as concise as with an Optional call chain.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 非 Optional 版本无法委托任何条件或检查，并依赖显式的 `if` 语句。这会创建深度嵌套的流程结构，增加代码的 *Cyclomatic Complexity*。很难理解代码块的整体意图，并且不如使用
    Optional 调用链那样简洁。
- en: Note
  id: totrans-186
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '*Cyclomatic Complexity^([8](ch09.xhtml#idm45115228055056))* is a metric used
    to determine code complexity. It’s based on the number of branching paths — or
    decisions — in your code. The general idea is that straight, non-nested statements
    and expressions are more accessible to follow and less error-prone than deeply
    nested decision branches, like nested `if`-statements.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '*Cyclomatic Complexity^([8](ch09.xhtml#idm45115228055056))* 是用于确定代码复杂性的度量标准。它基于代码中的分支路径数或决策。总体思想是，直接的、非嵌套的语句和表达式更容易跟踪，比深度嵌套的决策分支，如嵌套的
    `if` 语句，更不容易出错。'
- en: Getting a (fallback) value
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取（回退）值
- en: Optionals might provide a safe wrapper for possible `null` values, but you might
    need an actual value at some point. There are multiple ways to retrieve an Optional’s
    inner value, ranging from “brute force” to providing fallback values.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Optional 可能为可能的 `null` 值提供了一个安全的包装器，但是在某些情况下，你可能需要一个实际的值。有多种方法可以检索 Optional
    的内部值，从“蛮力”到提供回退值。
- en: 'The first method doesn’t concern itself with any safety checks:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个方法不关心任何安全检查：
- en: '`T get()`'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`T get()`'
- en: The Optional is unwrapped forcefully, and if no value is present, a `NoSuchElementException`
    is thrown, so make sure to check that a value exists beforehand.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 强制解包 Optional，并且如果没有值，会抛出 `NoSuchElementException` 异常，因此请确保在此之前检查值是否存在。
- en: 'The next two methods provide a fallback value if no value is present:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两种方法在没有值时提供一个回退值：
- en: '`T orElse(T other)`'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`T orElse(T other)`'
- en: '`T orElseGet(Supplier<? extends T> supplier)`'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`T orElseGet(Supplier<? extends T> supplier)`'
- en: The `Supplier`-based variant allows for lazily getting a fallback, which is
    immensely useful if creating it is resource intensive.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 基于 `Supplier` 的变体允许延迟获取回退值，如果创建它需要大量资源，则非常有用。
- en: 'There are two methods available to throw Exceptions:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以抛出异常：
- en: '`<X extends Throwable> T orElseThrow(Supplier<? extends X> exceptionSupplier)`'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<X extends Throwable> T orElseThrow(Supplier<? extends X> exceptionSupplier)`'
- en: '`T orElseThrow()` (Java 10+)'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`T orElseThrow()`（Java 10+）'
- en: Even though one of the main advantages of Optionals is preventing `NullPointerException`,
    sometimes you still need a domain-specific exception if there’s no value present.
    With the `orElseThrow` operation, you have fine-grained control about handling
    a missing value and what exception to throw, too. The second method, `orElseThrow`,
    was added as a semantically correct and preferred alternative to the `get` operation.
    Even though the call isn’t as concise, it better fits into the overall naming
    scheme and confers that an Exception might be thrown.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Optional 的主要优点之一是防止 `NullPointerException`，但有时如果没有值，你仍然需要一个特定的域异常。通过 `orElseThrow`
    操作，你可以对缺失值的处理和要抛出的异常进行精细控制。第二个方法 `orElseThrow` 被添加为语义上正确和首选的 `get` 操作的替代方法。尽管调用不那么简洁，但它更符合整体命名方案，并表明可能会抛出异常。
- en: 'Java 9 added two additional methods for providing another `Optional<T>` as
    a fallback or a `Stream<T>`. These allow more complex call chains than before:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9 为提供另一个 `Optional<T>` 或 `Stream<T>` 作为回退添加了两个额外的方法。这些方法允许比以前更复杂的调用链：
- en: The first one, `Optional<T> or(Supplier<? extends Optional<? extends T>> supplier)`,
    lazily returns another Optional if no value is present. This way, you can continue
    an Optional call chain, even if no value was present before calling `or`. To go
    back to the “train track” analogy, the `or` operation is a way to provide a track
    switch back from the empty express track by creating a new starting point on the
    Optional call chain track.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个方法，`Optional<T> or(Supplier<? extends Optional<? extends T>> supplier)`，在没有值时懒惰地返回另一个
    Optional。这样，即使在调用 `or` 之前没有值，你也可以继续进行 Optional 调用链。回到“火车轨道”的比喻，`or` 操作是一种通过在 Optional
    调用链轨道上创建一个新的起点来提供从空快速轨道返回的轨道切换的方法。
- en: The other one, `Stream<T> stream()`, returns a Stream containing the value as
    its sole element or an empty Stream if no value is present. Usually used in the
    intermediate Stream operation `flatMap` as a method reference. The Optional `stream`
    operation plays a broader role in the interoperability with the Stream API I discussed
    in [Chapter 7](ch07.xhtml#_02-streams).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个方法，`Stream<T> stream()`，返回一个包含值作为其唯一元素的流，或者如果没有值，则返回一个空流。通常在中间流操作 `flatMap`
    中使用，作为方法引用。Optional `stream` 操作在与我在 [第七章](ch07.xhtml#_02-streams) 讨论的 Stream API
    的互操作性中发挥更广泛的作用。
- en: Optionals and Streams
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选项和流
- en: As discussed in previous chapters, Streams are pipelines that filter and transform
    elements into the desired outcome. Optionals fit right in as a functional wrapper
    for possible `null` references, but they must play by the rules of Stream pipelines
    when used as elements and confer their state to the pipeline.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如前几章所述，流是过滤和转换元素以获得所需结果的管道。Optional 作为可能的 `null` 引用的函数包装器正好适用，但在作为元素使用时必须遵循流管道的规则，并将其状态传递给管道。
- en: Optionals as Stream Elements
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选项作为流元素
- en: With Streams, elements are excluded from further processing by using a filtering
    operation to discard them. In essence, Optionals themselves represent a kind of
    filtering operation, although not directly compatible with how Streams expect
    elements to behave.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 使用流，通过使用过滤操作排除元素以进行进一步处理。基本上，Optional 本身表示一种过滤操作，尽管不直接与流期望元素的行为兼容。
- en: If a Stream element is excluded by a `filter` operation, it won’t traverse the
    Stream further. This could be achieved by using `Optional::isPresent` as the `filter`
    operation’s argument. However, the resulting Stream in the case of an inner value,
    `Stream<Optional<User>>`, isn’t what you want.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个流元素被 `filter` 操作排除，它将不会继续遍历流。这可以通过使用 `Optional::isPresent` 作为 `filter` 操作的参数来实现。然而，在内部值的情况下，结果流
    `Stream<Optional<User>>` 并不是你想要的。
- en: To restore “normal” Stream semantics, you need to map the Stream from `Stream<Optional<User>>`
    to `Stream<User>`, as seen in [Example 9-9](#_02-optionals_streams_with_optionals).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 要恢复“正常”的 Stream 语义，需要将 Stream 从 `Stream<Optional<User>>` 映射到 `Stream<User>`，如
    [示例 9-9](#_02-optionals_streams_with_optionals) 所示。
- en: Example 9-9\. Optionals as Stream elements
  id: totrans-210
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 9-9\. 选项作为流元素
- en: '[PRE14]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[![1](assets/1.png)](#co_handling_null_with_optionals_CO6-1)'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_handling_null_with_optionals_CO6-1)'
- en: The `Group::admin` method reference returns an `Optional<User>`. At this point,
    the Stream becomes a `Stream<Optional<User>>`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`Group::admin` 方法引用返回一个 `Optional<User>`。此时，Stream 变为 `Stream<Optional<User>>`。'
- en: '[![2](assets/2.png)](#co_handling_null_with_optionals_CO6-2)'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_handling_null_with_optionals_CO6-2)'
- en: The Stream pipeline requires multiple operations to check for a value and safely
    unwrap it from its `Optional`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: Stream 管道需要多个操作来检查值并安全地从其 `Optional` 中解包它。
- en: Filtering and mapping an `Optional<T>` is such a standard use case for Optionals
    in Streams that Java 9 added the `stream` method to the `Optional<T>` type. It
    returns a `Stream<T>` containing the inner value if present as its sole element,
    or otherwise, an empty `Stream<T>`. This makes it the most concise way to combine
    the power of Optionals and Streams by using the Stream’s `flatMap` operation instead
    of a dedicated `filter` and `map` operation, as seen in [Example 9-10](#_02-optionals_streams-with-optionals-flatmap).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Streams 中，对 `Optional<T>` 进行过滤和映射是 Optionals 的标准用例，以至于 Java 9 添加了 `stream`
    方法到 `Optional<T>` 类型中。如果存在，它返回包含内部值的 `Stream<T>` 作为其唯一元素，否则返回空的 `Stream<T>`。这使得通过使用
    Stream 的 `flatMap` 操作而不是专门的 `filter` 和 `map` 操作来结合 Optionals 和 Streams 的能力成为最简洁的方法，如在
    [Example 9-10](#_02-optionals_streams-with-optionals-flatmap) 中所见。
- en: Example 9-10\. Optionals as Stream elements with flatMap
  id: totrans-217
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 9-10\. 可选项作为流元素与 flatMap
- en: '[PRE15]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: A singular `flatMap` call replaces the previous `filter` and `map` operations.
    Even if you only save a single method call — one `flatMap` instead of `filter`
    plus `map` operation --⁠, the resulting code is easier to reason with and better
    illustrates the desired workflow. The `flatMap` operation conveys all the necessary
    information for understanding the Stream pipeline without adding any complexity
    by requiring additional steps. Handling Optionals is a necessity, and it should
    be done as concisely as possible so that the overall Stream pipeline is as understandable
    and straightforward.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 单一的 `flatMap` 调用取代了之前的 `filter` 和 `map` 操作。即使你只节省了一个方法调用 —— 一个 `flatMap` 替代
    `filter` 加 `map` 操作 —— 结果代码更易于理解，并更好地说明了期望的工作流程。`flatMap` 操作传达了理解 Stream 管道所需的所有必要信息，而不需要通过需要额外步骤来增加任何复杂性。处理
    Optionals 是必要的，应尽可能简洁地完成，以便整体的 Stream 管道尽可能易于理解和直接。
- en: There’s no reason to design your APIs without Optionals just to avoid `flatMap`
    operations in Streams. If `Group::getAdmin` would return `null`, you would still
    have to add a `null-check` in another `filter` operation anyways. Replacing a
    `flatMap` operation with a `filter` operation gains you nothing, except the `admin`
    call now requires explicit `null`-handling afterwards, even if it’s no longer
    obvious from its signature.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 没有理由在设计 API 时不使用 Optionals，只是为了避免在 Streams 中使用 `flatMap` 操作。如果 `Group::getAdmin`
    返回 `null`，你仍然必须在另一个 `filter` 操作中添加 `null-check`。用 `filter` 操作替换 `flatMap` 操作并没有任何好处，除非
    `admin` 调用现在需要在其签名中明确处理 `null`，即使不再显而易见。
- en: Terminal Stream Operations
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 终端 Stream 操作
- en: Using Optionals in Streams isn’t restricted to intermediate operations. Five
    of the Stream API’s terminal operations return an `Optional<T>` to provide an
    improved representation of their return value. All of them try to either find
    an element or reduce the Stream. In the case of an empty Stream, these operations
    need a sensible representation of an absentee value. Optionals exemplify this
    concept, so it was the logical choice to use them instead of returning `null`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Streams 中使用 Optionals 不仅限于中间操作。流 API 的五个终端操作返回 `Optional<T>`，以提供其返回值的改进表示。它们都试图找到一个元素或减少
    Stream。在空 Stream 的情况下，这些操作需要一个合理的缺席值的表示。Optionals 典型地展示了这一概念，因此使用它们而不是返回 `null`
    是合乎逻辑的选择。
- en: Finding an Element
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 寻找元素
- en: 'In the Stream API, the prefix "`find`" represents, as you might have guessed
    by its name, “finding” an element based on its existence. There are two "`find`"
    operations available with distinct semantics depending on the Stream being parallel
    or serial:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Stream API 中，前缀 "`find`" 表示，“找到”一个基于其存在的元素。根据流是否并行，有两种 "`find`" 操作可用，具有不同的语义：
- en: '`Optional<T> findFirst()`'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`Optional<T> findFirst()`'
- en: Returns an Optional of the first element of a Stream or an empty Optional if
    the Stream is empty. There’s no difference between parallel and serial Streams.
    Any element might be returned if the Stream lacks an encounter order.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 返回流的第一个元素的 Optional，如果流为空则返回空的 Optional。并行和串行流之间没有区别。如果流缺乏相遇顺序，则可能返回任何元素。
- en: '`Optional<T> findAny()`'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`Optional<T> findAny()`'
- en: Returns an Optional of any element of a Stream or an empty Optional if the Stream
    is empty. The returned element is non-deterministic to maximize performance in
    parallel streams. The first element is returned in most cases, but there’s no
    guarantee for this behavior! So use `findFirst` instead for a consistent return
    element.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 返回流的任何元素的Optional，如果流为空则返回空的Optional。返回的元素是非确定性的，以最大化并行流的性能。在大多数情况下返回第一个元素，但无法保证此行为！因此，对于一致返回元素，请改用`findFirst`。
- en: 'The "`find`" operations work solely on the concept of existence, so you need
    to filter the Stream elements accordingly beforehand. If you only want to know
    if a particular element exists and don’t need the element itself, you can use
    one of the corresponding "`match`" methods:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '"`find`"操作仅适用于存在的概念，因此您需要相应地对流元素进行过滤。如果您只想知道特定元素是否存在，并且不需要元素本身，则可以使用相应的"`match`"方法之一：'
- en: '`boolean anyMatch(Predicate<? super T> predicate)`'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean anyMatch(Predicate<? super T> predicate)`'
- en: '`boolean noneMatch(Predicate<? super T> predicate)`'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean noneMatch(Predicate<? super T> predicate)`'
- en: These terminal operations include the filtering operation and avoid creating
    an unnecessary `Optional<T>` instance.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这些终端操作包括过滤操作，并避免创建不必要的`Optional<T>`实例。
- en: Reducing to a Single Value
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 减少到单一值
- en: Reducing a Stream by combining or accumulating its elements into a new data
    structure is one of a Stream’s primary purposes. And just like the `find` operations,
    reducing operators have to deal with empty Streams.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 将流通过组合或累积其元素减少到新数据结构是流的主要目的之一。并且与`find`操作一样，减少操作符必须处理空流。
- en: 'That’s why there are three terminal `reduce` operations available for Streams,
    with one returning an Optional: `Optional<T> reduce(BinaryOperator<T> accumulator)`'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么流有三个终端的`reduce`操作，其中一个返回一个Optional：`Optional<T> reduce(BinaryOperator<T>
    accumulator)`
- en: It reduces the elements of the Stream using the provided `accumulator` operator.
    The returned value is the result of the reduction, or an empty Optional if the
    Stream is empty.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 使用提供的`accumulator`运算符对流的元素进行规约。返回值是规约的结果，如果流为空，则返回一个空的Optional。
- en: See [Example 9-11](#_02-optionals_streams-reduce) for an equivalent pseudo-code
    example from the official documentation^([9](ch09.xhtml#idm45115227642032)).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 详见[示例 9-11](#_02-optionals_streams-reduce)以获取来自官方文档的等效伪代码示例^([9](ch09.xhtml#idm45115227642032))。
- en: Example 9-11\. Pseudo-code equivalent to the `reduce` operation
  id: totrans-238
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 9-11\. Pseudo-code equivalent to the `reduce` operation
- en: '[PRE16]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The two other `reduce` methods require an initial value to combine the stream
    elements with, so a concrete value can be returned instead of an Optional. See
    [“Reducing Elements”](ch06.xhtml#_02-data-processing_reduce) for a more detailed
    explanation and examples of how to use them in Streams.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 另外两个`reduce`方法需要一个初始值来与流元素结合，以便返回一个具体的值，而不是一个Optional。详见[“减少元素”](ch06.xhtml#_02-data-processing_reduce)以获取更详细的解释和使用示例。
- en: 'Besides the generic `reduce` methods, there are also two common use cases of
    reduction available as methods:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 除了通用的`reduce`方法，还有两种常见的减少用例作为方法可用：
- en: '`Optional<T> min​(Comparator<? super T> comparator)`'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Optional<T> min​(Comparator<? super T> comparator)`'
- en: '`Optional<T> max(Comparator<? super T> comparator)`'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Optional<T> max(Comparator<? super T> comparator)`'
- en: These methods return the “minimal” or “maximal” element based on the provided
    comparator or an empty Optional if the Stream is empty.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法基于提供的比较器返回“最小”或“最大”元素，如果流为空则返回空的Optional。
- en: An `Optional<T>` is the only suitable type to be returned by `min`/`max`. You
    have to check anyway if there’s a result of the operation. Adding additional `min`/`max`
    methods with a fallback value as an argument would clutter up the Stream interface.
    Thanks to the returned `Optional`, you can easily check if a result exists or
    resort to a fallback value or exception instead.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`Optional<T>`是唯一适合由`min`/`max`返回的类型。无论如何，您都必须检查操作是否有结果。添加带有回退值作为参数的额外`min`/`max`方法将混乱流接口。由于返回的`Optional`，您可以轻松检查是否存在结果，或者改用回退值或异常。'
- en: Optional Primitives
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原始可选项
- en: You might ask yourself why you might even need an Optional of a primitive because
    a primitive variable can never be `null`. If not initialized, any primitive has
    a value equivalent to zero for their respective type.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会问自己为什么需要原始的Optional，因为原始变量永远不会是`null`。如果未初始化，任何原始变量都具有与其相应类型的零值。
- en: Even though that’s technically correct, Optionals aren’t simply about preventing
    values from being `null`. They also represent an actual state of “nothingness" — an
    absence of a value — that primitives lack.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在技术上是正确的，但Optional并不只是防止值为`null`。它们还表示一种“无存在值”的实际状态，而这是原始类型所缺乏的。
- en: 'In many cases, the default values of primitive types are adequate, like representing
    a networking port: zero is an invalid port number, so you have to deal with it
    anyway. if zero is a valid value, though, expressing its actual absence becomes
    more difficult.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，原始类型的默认值是足够的，比如表示网络端口：零是一个无效的端口号，因此你必须处理它。但如果零是一个有效的值，表达它的实际缺失变得更加困难。
- en: 'Using primitives directly with the `Optional<T>` type is a no-go because primitives
    can’t be generic types. However, just like with Streams, there are two ways to
    deal with optional primitives values: autoboxing or specialized types.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 直接使用`Optional<T>`类型与原始类型是行不通的，因为原始类型不能是泛型类型。然而，就像使用流一样，处理可选的原始值有两种方式：自动装箱或专用类型。
- en: '[“Primitive Types”](ch03.xhtml#_01-functional_primitives) highlighted the problems
    of using object-wrapper classes and the overhead they introduce. On the other
    hand, autoboxing isn’t free either.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '[“原始类型”](ch03.xhtml#_01-functional_primitives)突显了使用对象包装类及其引入的开销问题。另一方面，自动装箱也不是免费的。'
- en: 'The usual primitive types are available as dedicated Optional variants:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 通常的原始类型都有专门的Optional变体：
- en: '`java.util.OptionalInt`'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.OptionalInt`'
- en: '`java.util.OptionalLong`'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.OptionalLong`'
- en: '`java.util.OptionalDouble`'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.OptionalDouble`'
- en: Their semantics are almost identical to their generic counterpart, but they
    do *not* inherit from `Optional<T>` or share a common interface. The features
    aren’t identical either, as multiple operations, like `filter`, `map`, or `flatMap`,
    are missing.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 它们的语义几乎与它们的通用对应物相同，但它们既不继承自`Optional<T>`也没有共同的接口。它们的特性也不相同，如缺少`filter`、`map`或`flatMap`等多个操作。
- en: The primitive Optional types may remove unnecessary autoboxing, which can improve
    performance but lack the full functionality that `Optional<T>` offers. Also, unlike
    the primitive Stream variants I discussed in [“Primitive Streams”](ch07.xhtml#_02-streams-primitives-streams),
    there’s no way to easily convert between a primitive Optional variant and its
    corresponding `Optional<T>` equivalent.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的Optional类型可以消除不必要的自动装箱，这可以提高性能，但缺乏`Optional<T>`提供的全部功能。此外，与我在[“原始流”](ch07.xhtml#_02-streams-primitives-streams)中讨论的原始流变体不同，没有一种简单的方法可以在原始Optional变体和其对应的`Optional<T>`等效型之间进行转换。
- en: Even though it would be easy to create your own wrapper type to improve the
    handling of Optional values, especially for primitives, I wouldn’t recommend doing
    it under most circumstances. For internal or `private` implementations, you can
    use any wrapper you want or need. But the `public` seams of your code should always
    strive to stick to the most anticipated and available types. Usually, that means
    what’s already included in the JDK.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管创建自己的包装类型以改进Optional值的处理（特别是对于原始类型）很容易，但在大多数情况下我不建议这样做。对于内部或`private`实现，可以使用任何所需的包装类型。但是代码的`public`接口应始终坚持使用最受期待和可用的类型。通常情况下，这意味着JDK中已经包含的内容。
- en: Caveats
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注意事项
- en: Optionals can enormously improve `null` handling for the JDK by providing a
    versatile “box” to hold possible `null` values and a (partially) functional API
    to build pipelines dealing with the presence or absence of that value. Although
    the upsides are certainly useful, it also comes with some noteworthy downsides
    you need to be aware of to use them correctly and without any unexpected surprises.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: Optional可以通过提供一个多功能的“盒子”来极大地改善JDK中的`null`处理，用于保存可能的`null`值，并提供（部分）功能性API来构建处理该值存在与否的管道。尽管优势显而易见，但它也伴随着一些显著的缺点，你需要了解这些缺点，以正确地使用它们，并避免任何意外的惊喜。
- en: Optionals are ordinary types
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Optional是普通类型
- en: The most obvious downside of `Optional<T>` and its primitive variants is that
    they’re ordinary types. Without deeper integration into Java’s syntax, such as
    the new syntax for lambda expressions, they suffer from the same `null` reference
    problems as any other type in the JDK.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`Optional<T>`及其原始变体最明显的缺点之一是它们是普通类型。没有更深入地融入Java语法，比如新的lambda表达式语法，它们会遇到与JDK中任何其他类型相同的`null`引用问题。'
- en: That’s why you must still adhere to best practices and informal rules to not
    counter-act the benefits of using Optionals in the first place. If you design
    an API and decide to use Optionals as a return type, you *must not* return `null`
    for it under any circumstances! Returning an Optional is a clear signal that anyone
    using the API will receive at least a “box” that *might* contain a value instead
    of a possible `null` value. If no value is possible, always use an empty Optional
    or the primitive equivalent instead.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你仍然必须遵循最佳实践和非正式规则，以免抵消使用 Optionals 的好处。如果你设计一个 API 并决定使用 Optionals 作为返回类型，在任何情况下都*不能*返回
    `null`！返回 Optional 是一个明确的信号，表明使用 API 的任何人至少会收到一个“盒子”，*可能*包含一个值，而不是可能的 `null` 值。如果没有可能的值，始终使用空的
    Optional 或者等效的基本类型。
- en: This essential design requirement has to be enforced by convention, though.
    The compiler won’t help you there without additional tools, like [SonarSource](https://www.sonarsource.com/)^([10](ch09.xhtml#idm45115227431008)).
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，这个基本的设计要求必须通过约定来执行。没有额外的工具，如 [SonarSource](https://www.sonarsource.com/)^([10](ch09.xhtml#idm45115227431008))，编译器不会帮助你。
- en: Identity-sensitive Methods
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 敏感于身份的方法
- en: Even though Optionals *are* ordinary types, the identity-sensitive methods might
    work differently from what you expect. This includes the reference equality operator
    `==` (double-equals), using the `hashCode` method, or using an instance for thread
    synchronization.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Optionals *是* 普通类型，但是与你预期的可能不同的是，一些敏感于身份的方法。这包括引用相等性运算符 `==`（双等号），使用 `hashCode`
    方法，或者使用实例进行线程同步。
- en: Note
  id: totrans-267
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Object identity tells you whether two different objects share the same memory
    address and are, therefore, the same object. This is tested by the reference equality
    operator `==` (double-equals). Equality of two objects, which is tested with their
    `equals` method, means they contain the same state.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 对象标识告诉你两个不同对象是否共享相同的内存地址，因此是同一个对象。这可以通过引用相等性运算符 `==`（双等号）来测试。两个对象的相等性，通过它们的
    `equals` 方法来测试，意味着它们包含相同的状态。
- en: Two identical objects are also equal, but the reverse isn’t necessarily true.
    Just because two objects contain the same state doesn’t automatically mean they
    also share the same memory address.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 两个相同的对象也是相等的，但反过来不一定成立。仅因为两个对象包含相同的状态并不意味着它们也共享相同的内存地址。
- en: The difference in behavior lies in Optional’s nature of being *value-based*
    type, meaning its inner value is its primary concern. Methods like `equals`, `hashCode`,
    and `toString` are solely based on the inner value and ignore the actual object
    identity. That’s why you should treat Optional instances as interchangeable and
    unsuited for identity-related operations like synchronizing concurrent code, as
    stated in the official documentation^([11](ch09.xhtml#idm45115227420480)).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 行为上的差异在于 Optional 是*基于值*的类型，意味着其内部值是其主要关注点。像 `equals`、`hashCode` 和 `toString`
    这样的方法仅基于内部值，并忽略实际对象标识。因此，你应该将 Optional 实例视为可互换的，并且不适合用于像同步并发代码这样的身份相关操作，正如官方文档所述^([11](ch09.xhtml#idm45115227420480))。
- en: Performance-Overhead
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能开销
- en: Another point to consider when using Optionals is the performance implications,
    especially outside their primary design goal as return types.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Optionals 时另一个需要考虑的点是性能影响，特别是在它们作为返回类型之外的主要设计目标时。
- en: 'Optionals are easy to (mis-)use for simple `null`-checks and provide a fallback
    value if no inner value is present:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 对于简单的 `null` 检查来说，Optionals 容易被误用，并提供一个回退值，如果内部值不存在：
- en: '[PRE17]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Such simple Optional pipelines require a new `Optional` instance, and every
    method call creates a new stack frame that the JVM can’t optimize your code as
    easily as a simple `null`-check. Creating an Optional doesn’t make much sense
    without additional operations besides checking for existence or providing a fallback.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这样简单的 Optional 流水线需要一个新的 `Optional` 实例，每个方法调用都会创建一个新的堆栈帧，这使得 JVM 不能像简单的 `null`
    检查那样轻松优化你的代码。创建 Optional 除了检查存在性或提供回退外，并没有太多意义。
- en: 'Using alternatives like the ternary operator or a direct `null`-check should
    be your preferred solution:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 使用三元运算符或直接的 `null` 检查应该是你的首选解决方案：
- en: '[PRE18]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Using an Optional instead of a ternary operator might look nicer and saves you
    from repeating `maybeNull`. Reducing the number of instance creations and method
    invocations is usually preferable.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Optional 而不是三元运算符可能看起来更美观，避免重复使用 `maybeNull`。减少实例创建和方法调用通常是可取的。
- en: 'If you still want a more visually pleasing alternative to the ternary operator,
    Java 9 introduced two `static` helper methods on `java.util.Objects` wrapping
    the task of checking for `null` and providing an alternative value:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仍然想要一个更美观的替代三元运算符的方法，Java 9 在 `java.util.Objects` 上引入了两个 `static` 帮助方法，用于检查`null`并提供替代值：
- en: '`T requireNonNullElse(T obj, T defaultObj)`'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`T requireNonNullElse(T obj, T defaultObj)`'
- en: '`T requireNonNullElseGet(T obj, Supplier<? extends T> supplier)`'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`T requireNonNullElseGet(T obj, Supplier<? extends T> supplier)`'
- en: The fallback value, or in the case of the second method, the result of the `Supplier`,
    must be non-`null`, too.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 回退值，或者在第二种方法中，`Supplier` 的结果，也必须是非`null`的。
- en: Saving a few CPU cycles means nothing compared to a crash due to an unexpected
    `NullPointerException`. Just like with Streams, there’s a trade-off to be made
    between performance and safer and more straightforward code. You need to find
    the balance between those based on your requirements.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免由于意外的`NullPointerException`导致的崩溃，节省几个 CPU 循环毫无意义。就像流一样，性能和更安全、更简单的代码之间存在权衡。你需要根据你的需求找到这些之间的平衡。
- en: Special Considerations for Collections
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合的特殊考虑
- en: '`null` is the technical representation of the absence of a value. Optionals
    give you a tool to represent this absence safely with an actual object that allows
    further transformation, filtering, and more. Collection-based types, though, can
    already represent an absence of their inner values.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`null` 是值缺失的技术表示。Optionals为你提供了一种工具，可以安全地表示这种缺失，并使用实际对象进行进一步的转换、过滤等操作。然而，基于集合的类型已经可以表示其内部值的缺失。'
- en: A collection type is already a “box” that handles values, so wrapping it in
    an `Optional<T>` creates yet another layer you must deal with. An empty collection
    already indicates the absence of inner values, so using an empty collection as
    the alternative to `null` eliminates a possible `NullPointerException` *and* the
    need for an additional layer by using an Optional.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 集合类型已经是一个处理值的“盒子”，所以将其包装在`Optional<T>`中将创建另一个必须处理的层。空集合已经表示内部值的缺失，因此使用空集合作为`null`的替代品消除了可能的`NullPointerException`
    *以及* 使用Optional时的额外层次。
- en: Of course, you still have to deal with the absence of the collection itself,
    meaning a `null` reference. If possible, you shouldn’t use `null` for collections
    at all, neither as arguments nor return values. Designing your code to always
    use an empty collection instead of `null` will have the same effect as an Optional.
    If you still need to discern between `null` and an empty collection, or the related
    code isn’t under your control or can’t be changed, a `null`-check might still
    be preferable to introducing another layer to deal with.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你仍然必须处理集合本身的缺失，意味着一个`null`引用。如果可能的话，你不应该对集合使用`null`，无论是作为参数还是返回值。设计你的代码始终使用空集合而不是`null`将具有与Optional相同的效果。如果你仍然需要区分`null`和空集合，或者相关的代码不在你的控制范围内或无法更改，那么使用`null`检查可能仍然优于引入另一层来处理。
- en: Optionals and Serialization
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Optionals 和序列化
- en: The `Optional<T>` type and the primitive variants don’t implement `java.io.Serializable`,
    making them unsuited for private fields in serializable types. This decision was
    made deliberately by its design group because Optionals are supposed to provide
    the possibility of an optional return value, not be a general-purpose solution
    for nullability. Making `Optional<T>` serializable would encourage use cases far
    beyond its intended design goal.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '`Optional<T>` 类型和原始变体不实现 `java.io.Serializable`，因此它们不适用于可序列化类型中的私有字段。这个决定是设计小组故意做出的，因为
    Optionals 应该提供可选返回值的可能性，而不是成为空引用的通用解决方案。使`Optional<T>`可序列化将鼓励超出其预期设计目标的用例。'
- en: To still reap the benefits of Optionals in your object and maintain serializability,
    you can use them for your `public` API but use non-Optional fields as an implementation
    detail, as shown in [Example 9-12](#_02-optionals_serialization)
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 为了仍然在你的对象中获得 Optionals 的好处并保持可序列化性，你可以将它们用于你的`public` API，但在实现细节中使用非 Optional
    字段，就像[示例 9-12](#_02-optionals_serialization) 中所示的那样
- en: Example 9-12\. Using Optionals in Serializable types
  id: totrans-291
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 例子 9-12\. 在可序列化类型中使用 Optionals
- en: '[PRE19]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: By relying only on an Optional in the getter for `lastLogin`, the type remains
    serializable but still provides an Optional API.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 通过仅依赖于获取器对`lastLogin`的 Optional，在类型保持可序列化的同时仍提供 Optional API。
- en: Final Thoughts on null References
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对空引用的最终思考
- en: Although it’s called a *billion-dollar mistake*, `null` isn’t inherently evil.
    Sir Charles Antony Richard Hoare, the inventor of `null`, believes that programming
    language designers should be responsible for errors in programs written in their
    language^([12](ch09.xhtml#idm45115227195568)).
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管被称为“价值十亿美元的错误”，`null` 本身并不邪恶。`null` 的发明者，查尔斯·安东尼·理查德·霍尔爵士（Sir Charles Antony
    Richard Hoare）认为，编程语言设计者应对使用其语言编写的程序中的错误负责^([12](ch09.xhtml#idm45115227195568))。
- en: A language should provide a solid foundation with a good deal of ingenuity and
    control. Allowing `null` references is one of many design choices for Java, nothing
    more. Java’s *catch or specify requirement*, as explained in [Chapter 10](ch10.xhtml#_02-exception-handling),
    and `try`-`catch`-blocks provide you with tools against apparent errors. But with
    `null` being a valid value for any type, every reference is a possible crash waiting
    to happen. Even if you think something can *never* be `null`, experience tells
    us that it may be possible at some point in time.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 一种语言应该提供一个坚实的基础，具有很多创造性和控制性。允许存在 `null` 引用只是 Java 的许多设计选择之一，不过也不仅仅是这样。正如在[第10章](ch10.xhtml#_02-exception-handling)中解释的“捕获或声明要求”和
    `try`-`catch` 块为你提供了应对明显错误的工具一样。但是由于 `null` 是任何类型的有效值，每个引用都可能会导致崩溃。即使你认为某些东西永远不会是
    `null`，经验告诉我们，某个时刻可能是可能的。
- en: The existence of `null` references doesn’t qualify a language as poorly designed.
    `null` has its place, but it requires you to be more attentive to your code. This
    doesn’t mean you should replace every single variable and argument in your code
    with Optionals, either.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 存在 `null` 引用并不能使一种语言被认为设计不良。`null` 有其存在的理由，但这要求你对自己的代码更加注意。这并不意味着你应该将代码中的每个变量和参数都用
    Optionals 替换。
- en: Optionals were intended to provide a limited mechanism for optional return values,
    so don’t over- or misuse them just because it seems convenient. In code under
    your control, you can make more assumptions and guarantees about the possible
    nullability of references and deal with it accordingly, even without Optionals.
    If you follow the other principles highlighted in this book — like small, self-contained,
    pure functions without side effects — it’s way easier to make sure your code won’t
    return a `null` reference unexpectedly.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: Optionals 的初衷是提供一个有限的机制来处理可选的返回值，所以不要因为方便而过度使用或误用它们。在你控制的代码中，你可以对引用的可能为空性做更多的假设和保证，并相应地处理它，即使没有
    Optionals 也可以。如果你遵循本书中强调的其他原则，比如小型、自包含、无副作用的纯函数，那么确保你的代码不会意外返回 `null` 引用就更容易了。
- en: Takeaways
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: There’s no language-level or special syntax available for `null`-handling in
    Java.
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 中没有语言级别或特殊语法可用于处理 `null`。
- en: '`null` is a special case that can represent both the states of “doesn’t exist”
    and “undefined” without you being able to distinguish them.'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`null` 是一个特殊情况，可以代表“不存在”和“未定义”两种状态，而你无法区分它们。'
- en: The `Optional<T>` type allows for dedicated `null`-handling these states with
    operation chains and fallbacks.
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Optional<T>` 类型允许使用操作链和后备来专门处理这些状态。'
- en: Specialized types for primitives are also available, although they don’t provide
    feature parity.
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还有针对基本类型的专门类型，尽管它们不提供功能平等性。
- en: Other approaches for `null`-handling exist, like annotations or best practices.
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他处理 `null` 的方法也存在，比如注解或最佳实践。
- en: Not everything is a good fit for Optionals. If a data structure already has
    a concept of emptiness, like collections, adding another layer is contra-productive.
    You shouldn’t wrap it into an Optional unless you are required to represent an
    “undefined” state, too.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并非所有情况都适合使用 Optional。如果数据结构已经有了空值的概念，比如集合，再添加一层反而会适得其反。除非需要表示“未定义”状态，否则不应该将其包装成
    Optional。
- en: Optionals and Streams are interoperable without much friction.
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Optionals 和 Streams 之间的互操作性很好，几乎没有摩擦。
- en: Optionals aren’t serializable, so don’t use them as private fields if you need
    to serialize your type. Instead, use Optionals as return values for getters.
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Optionals 不可序列化，所以如果需要序列化类型，则不要将它们用作私有字段。相反，将 Optionals 用作 getter 的返回值。
- en: Alternative implementations exist, like in the [Google Guava framework](https://github.com/google/guava),
    even though Google itself recommends using Java’s Optional instead.
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存在替代实现，比如[Google Guava 框架](https://github.com/google/guava)，尽管 Google 自己建议使用
    Java 的 Optional。
- en: '`null` isn’t evil per se. Don’t replace every variable with Optionals without
    a good reason.'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`null` 本身并不邪恶。不要没有充分理由就用 Optional 替换每个变量。'
- en: '^([1](ch09.xhtml#idm45115229846656-marker)) Varargs don’t accept `null` as
    a sole argument because it’s an inexact argument type, because it might represent
    `Object` or `Object[]`. To pass a single `null` to a vararg you need to wrap it
    in an array: `new Object[]{ null }`.'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch09.xhtml#idm45115229846656-marker)) 变长参数不接受单独的`null`作为参数，因为它是不精确的参数类型，可能代表`Object`或`Object[]`。要向变长参数传递单个`null`，需要将其包装在数组中：`new
    Object[]{ null }`。
- en: ^([2](ch09.xhtml#idm45115229645008-marker)) Many programming languages have
    a dedicated operator to safely call fields or methods on possible `null` references.
    The [Wikipedia article on the safe-navigation operator](https://en.wikipedia.org/wiki/Safe_navigation_operator)
    has an in-depth explanation and examples in many languages.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch09.xhtml#idm45115229645008-marker)) 许多编程语言都有专门的运算符，用于在可能为`null`的引用上安全调用字段或方法。[安全导航运算符维基百科文章](https://en.wikipedia.org/wiki/Safe_navigation_operator)中详细说明并提供了多种语言的示例。
- en: '^([3](ch09.xhtml#idm45115229642560-marker)) The `null` coalescing operator
    is like a shortened ternary operator. The expression `x != null ? x : y` is shortened
    to `x ?: y`, with `?:` (question-mark colon) being the operator. Not all languages
    use the same operator, though. The [Wikipedia article](https://en.wikipedia.org/wiki/Null_coalescing_operator)
    gives an overview of different programming languages supporting which operator
    form.'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '^([3](ch09.xhtml#idm45115229642560-marker)) `null`合并运算符类似于缩短的三元运算符。表达式`x !=
    null ? x : y`缩短为`x ?: y`，其中`?:`（问号冒号）是运算符。不过，并非所有语言使用相同的运算符。[维基百科文章](https://en.wikipedia.org/wiki/Null_coalescing_operator)概述了支持哪种运算符形式的不同编程语言。'
- en: ^([4](ch09.xhtml#idm45115229323040-marker)) Java’s JIT (just-in-time) compiler
    performs a myriad of optimizations to improve the executed code. If necessary,
    it recompiles code when more information about how it’s executed becomes available.
    An overview of possible optimization is available on the [Open JDK Wiki](https://wiki.openjdk.org/display/HotSpot/PerformanceTechniques).
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch09.xhtml#idm45115229323040-marker)) Java的JIT（即时）编译器执行多种优化以改善执行代码。必要时，当有更多关于其执行方式的信息时，它会重新编译代码。有关可能的优化概述可在[Open
    JDK Wiki](https://wiki.openjdk.org/display/HotSpot/PerformanceTechniques)上找到。
- en: ^([5](ch09.xhtml#idm45115229213376-marker)) The most common libraries to provide
    the marker annotation are [FindBugz](http://findbugs.sourceforge.net/) (up to
    Java 8), and its spiritual successor [SpotBugz](https://spotbugs.github.io/).
    JetBrains, the creator of the IntelliJ IDE and the JVM language *Kotlin*, also
    [provide a package containing the annotations](https://github.com/JetBrains/java-annotations).
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch09.xhtml#idm45115229213376-marker)) 提供标记注释最常见的库是[FindBugz](http://findbugs.sourceforge.net/)（适用于Java
    8及以前），以及其精神继承者[SpotBugz](https://spotbugs.github.io/)。JetBrains，IntelliJ IDE和JVM语言*Kotlin*的创建者，也[提供了一个包含注解的包](https://github.com/JetBrains/java-annotations)。
- en: ^([6](ch09.xhtml#idm45115229208080-marker)) The [Checker Framework](https://checkerframework.org)
    has [an example](https://checkerframework.org/manual/#findbugs-nullable) of such
    “non-standard” behavior between different tools.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch09.xhtml#idm45115229208080-marker)) [Checker Framework](https://checkerframework.org)提供了这种在不同工具之间的“非标准”行为的[示例](https://checkerframework.org/manual/#findbugs-nullable)。
- en: ^([7](ch09.xhtml#idm45115229199920-marker)) The [documentation of Guava’s `Optional<T>`](https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/base/Optional.xhtml)
    explicitly mentions that the JDK variant should be preferred.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: ^([7](ch09.xhtml#idm45115229199920-marker)) Guava的[Optional<T>文档](https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/base/Optional.xhtml)明确提到应优先使用JDK的变体。
- en: ^([8](ch09.xhtml#idm45115228055056-marker)) McCabe, TJ. 1976\. “A Complexity
    Measure” [IEEE Transactions on Software Engineering, December 1976, Vol. SE-2
    No. 4, 308–320](https://doi.org/10.1109/TSE.1976.233837).
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: ^([8](ch09.xhtml#idm45115228055056-marker)) McCabe, TJ. 1976\. “A Complexity
    Measure” [IEEE Transactions on Software Engineering, December 1976, Vol. SE-2
    No. 4, 308–320](https://doi.org/10.1109/TSE.1976.233837)。
- en: ^([9](ch09.xhtml#idm45115227642032-marker)) [Documentation for `Optional<T>
    reduce​(BinaryOperator<T> accumulator)`](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/stream/Stream.xhtml#reduce(java.util.function.BinaryOperator)).
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: ^([9](ch09.xhtml#idm45115227642032-marker)) [Optional<T> reduce​(BinaryOperator<T>
    accumulator)文档](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/stream/Stream.xhtml#reduce(java.util.function.BinaryOperator))。
- en: ^([10](ch09.xhtml#idm45115227431008-marker)) The [SonarSource](https://www.sonarsource.com/)
    rule [RSPEC-2789](https://rules.sonarsource.com/java/RSPEC-2789) checks for Optionals
    being `null`.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: ^([10](ch09.xhtml#idm45115227431008-marker)) [SonarSource](https://www.sonarsource.com/)规则[RSPEC-2789](https://rules.sonarsource.com/java/RSPEC-2789)检查Optional是否为`null`。
- en: ^([11](ch09.xhtml#idm45115227420480-marker)) The [official doumentation](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Optional.xhtml)
    explicitly mentions unpredictable identity method behavior as an “API Note.”
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: ^([11](ch09.xhtml#idm45115227420480-marker)) [官方文档](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Optional.xhtml)
    明确提到了不可预测的标识方法行为作为“API 注释”。
- en: '^([12](ch09.xhtml#idm45115227195568-marker)) Sir Charles Antony Richard Hoare
    expressed this view in his talk [“Null References: The Billion Dollar Mistake”](https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare/)
    at [QCon London](https://qconlondon.com/london-2009/qconlondon.com/london-2009/presentation/Null%2bReferences_%2bThe%2bBillion%2bDollar%2bMistake.xhtml)
    in 2009.'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: ^([12](ch09.xhtml#idm45115227195568-marker)) 查尔斯·安东尼·理查德·霍尔爵士在2009年的 [“空引用：十亿美元的错误”](https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare/)
    演讲中表达了这一观点。
