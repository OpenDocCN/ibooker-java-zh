- en: Chapter 9\. Handling null with Optionals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As a Java developer, you’ve most likely encountered your fair share of `NullPointerExceptions`,
    and then some. Many people call the `null` reference a *billion-dollar mistake*.
    Actually, the inventor of `null` itself originally coined that phrase:'
  prefs: []
  type: TYPE_NORMAL
- en: I call it my billion-dollar mistake.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It was the invention of the `null` reference in 1965. At that time, I was designing
    the first comprehensive type system for references in an object-oriented language
    (ALGOL W). My goal was to ensure that all use of references should be absolutely
    safe, with checking performed automatically by the compiler. But I couldn’t resist
    the temptation to put in a `null` reference simply because it was so easy to implement.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This has led to innumerable errors, vulnerabilities, and system crashes, which
    have probably caused a billion dollars of pain and damage in the last forty years.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Sir Charles Antony Richard Hoare, QCon London 2009
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Although there is no absolute consensus on how to deal with this “mistake,”
    many programming languages have a proper and idiomatic way of handling `null`
    references, often directly integrated into the language itself.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will show you how Java handles `null` references and how to improve
    it in your code with the `Optional<T>` type and its functional API, and learn
    how, when, and when not to use Optionals.
  prefs: []
  type: TYPE_NORMAL
- en: The Problem with null References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java’s handling of the absence of a value depends on the type. All primitive
    types have default values, e.g., a zero-equivalent for numeric types and `false`
    for `boolean`. Non-primitive types, like classes, interfaces, and arrays, use
    `null` as their default value if unassigned, meaning the variable isn’t referencing
    any object.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The concept of reference types may seem similar to C/C++ pointers, but Java
    references are a specialized type inside the JVM called `reference`. The JVM strictly
    controls them to ensure type-safety and safe-guarding memory access.
  prefs: []
  type: TYPE_NORMAL
- en: A `null` reference isn’t just “nothing”; it’s a *special state* because `null`
    is a generalized type that can be used for any object reference, regardless of
    the actual type. If you attempt to access such a `null` reference, the JVM will
    throw a `NullPointerException`, and the current thread will crash if you don’t
    handle it appropriately. This is usually mitigated by a defensive programming
    approach, requiring `null` checks *everywhere* at runtime, as seen in [Example 9-1](#_02-optionals-minefield).
  prefs: []
  type: TYPE_NORMAL
- en: Example 9-1\. A minefield of possible nulls
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_handling_null_with_optionals_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: '`String.format` accepts `null` values as long its not the sole value for arguments^([1](ch09.xhtml#idm45115229846656))
    after the format string. It translates to the string “null,” regardless of the
    chosen format specifier, even for numeric ones.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_handling_null_with_optionals_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Using `null` as an argument in a method call might not crash the current thread.
    however, calling a method on a `null` reference certainly does.
  prefs: []
  type: TYPE_NORMAL
- en: The previous example highlights two major problems in dealing with `null`.
  prefs: []
  type: TYPE_NORMAL
- en: First, `null` references are valid values for variables, arguments, and return
    values. That doesn’t mean that `null` is the expected, correct, or even acceptable
    value for each of them and might not be handled correctly down the line.
  prefs: []
  type: TYPE_NORMAL
- en: For example, calling `getFullname` on `user` in the previous example worked
    fine with a `null` reference for `lastname`, but the output — “Ben null" — is
    most likely not what’s intended. So even if your code and data structures can
    handle `null` values superficially, you still might need to check for them to
    ensure a correct outcome.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second problem of `null` references is one of their main features: type
    ambiguity. They can represent any type without actually being that particular
    type. That unique property is necessary, so a single keyword can represent the
    generalized concept of “absence of value” throughout your code without resorting
    to different types or keywords for different object types. Even though a `null`
    reference is usable just like the type it represents, it still *isn’t* the type
    itself, as seen in [Example 9-2](#_02-optionals-null-type-ambiguity).'
  prefs: []
  type: TYPE_NORMAL
- en: Example 9-2\. null type ambiguity
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_handling_null_with_optionals_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: '`null` can represent any object type and, therefore, is a valid value for any
    non-primitive argument.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_handling_null_with_optionals_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: A variable referencing `null` is like any other variable of that type. Except
    for any call on it will result in a `NullPointerException`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_handling_null_with_optionals_CO2-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Testing a variable with `instanceof` will always evaluate to `false` regardless
    of the type. Even if it’s explicitly cast into the required type, the `instanceof`
    operator tests the underlying value itself. Therefore, it tests against the typeless
    value `null`.
  prefs: []
  type: TYPE_NORMAL
- en: These are the most apparent sore points with `null`. Not to worry; there are
    ways to ease the pain.
  prefs: []
  type: TYPE_NORMAL
- en: How to handle null in Java (before Optionals)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dealing with `null` in Java is an essential and necessary part of every developer’s
    work, even if it can be cumbersome. Encountering an unexpected and unhandled `NullPointerException`
    is the root cause of many problems and must be dealt with accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Other languages, like [Swift](https://www.swift.org), provide dedicated operators
    and idioms, in the form of a safe navigation^([2](ch09.xhtml#idm45115229645008))
    or `null` coalesce operator^([3](ch09.xhtml#idm45115229642560)) to make dealing
    with `null` easier. Java doesn’t provide such built-in tools to handle `null`
    references, though.
  prefs: []
  type: TYPE_NORMAL
- en: 'There were three different ways to deal with `null` references before Optionals:'
  prefs: []
  type: TYPE_NORMAL
- en: Best practices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tool-assisted `null`-checks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specialized types like Optional
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you will see later, handling `null` references shouldn’t rely solely on Optionals.
    They are a great addition to the prior techniques by providing a standardized
    and readily available specialized type within the JDK. Still, they’re not the
    final thought on how to manage `null` throughout your code, and knowing about
    all available techniques is a valuable addition to your skills toolkit.
  prefs: []
  type: TYPE_NORMAL
- en: Best Practices for Handling null
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If a language doesn’t provide integrated `null` handling, you must resort to
    *best practices* and *informal rules* to `null`-proof your code. That’s why many
    companies, teams, and projects develop their own coding style or adapt existing
    ones to their needs to provide guidelines to write consistent and safer code,
    not only regarding `null`. By adhering to these self-imposed practices and rules,
    they’re able to write more predictable and less error-prone code consistently.
  prefs: []
  type: TYPE_NORMAL
- en: 'You don’t have to develop or adapt a full-blown style guide defining every
    aspect of your Java code. Instead, following these four rules are a good starting
    point for handling `null` references:'
  prefs: []
  type: TYPE_NORMAL
- en: Don’t Initialize a Variable to null
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Variables should always have a non-`null` value. If the value depends on a decision-making
    block like an `if`-`else`-statement, you should consider either refactoring it
    into a method or, if it’s a simple decision, using the ternary operator.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The additional benefit is that it makes the variable effectively `final` if
    you don’t reassign it later, so you can use them as out-of-body variables in lambda
    expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Don’t Pass, Accept, or Return null
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As variables shouldn’t be `null`, so should any arguments and return values
    avoid being `null`. Non-required arguments being `null` can be avoided by overloading
    a method or constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If method signatures clash due to identical argument types, you can always resort
    `static` methods with more explicit names instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'After providing specific methods and constructors for optional values, you
    shouldn’t accept `null` in the original ones if it’s appropriate. The easiest
    way to do this is using the `static` `requireNonNull` method available on `java.util.Objects`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `requireNionNull` call does the `null`-check for you and throws a `NullPointerException`
    if appropriate. Since Java 14, any `NullPointerException` includes the name of
    the variable that was `null`, thanks to [JEP 358](https://openjdk.org/jeps/358).
    If you want to include a specific message or target a previous Java version, you
    can add a `String` as the second argument to the call.
  prefs: []
  type: TYPE_NORMAL
- en: Check Everything Outside Your Control
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Even if you adhere to your own rules, you can’t rely on others to do, too. Using
    non-familiar code, especially if not stated explicitly in the documentation, should
    always be assumed to be possibly `null` and needs to be checked.
  prefs: []
  type: TYPE_NORMAL
- en: null Is Acceptable as an Implementation Detail
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Avoiding `null` is essential for the `public` surface of your code but is still
    sensible as an implementation detail. Internally, a method might use `null` as
    much as needed as long as it won’t return it to the callee.
  prefs: []
  type: TYPE_NORMAL
- en: When and When Not to Follow the Rules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These rules aim at reducing the general use of `null` whenever possible if code
    is intersecting, like API surfaces, because less exposure leads to fewer required
    `null`-checks and possible `NullPointerExceptions`. But that doesn’t mean you
    should avoid `null` altogether. For example, in isolated contexts, like local
    variables or non-`public` API, using `null` isn’t as problematic and might even
    simplify your code as long as used deliberately and with care.
  prefs: []
  type: TYPE_NORMAL
- en: You can’t expect everyone to follow the same rules as you or be as diligent,
    so you need to be defensive with code, especially outside of your control. This
    is all the more reason to consistently stick to your best practices and also encourage
    others to do the same. They will improve your overall code quality, regardless
    of `null`. But it’s not a silver bullet and requires discipline among your team
    to gain the most benefits. Manually handling `null` and adding a few `null`-checks
    is preferable to getting the unwelcome surprise in the form of a `NullPointerException`
    because you assumed something could “never” be `null`. The JIT compiler^([4](ch09.xhtml#idm45115229323040))
    will even perform "`null` check elimination” to remove many explicit `null` checks
    from optimized Assembly code thanks to its greater knowledge at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Tool-Assisted null-checks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A logical extension of the best practices and informal rules approach is to
    use third-party tools to enforce them automatically. For `null` references in
    Java, an established best practice is to use annotations to mark variables, arguments,
    and method return types as either `@Nullable` or `@NonNull`.
  prefs: []
  type: TYPE_NORMAL
- en: Before such annotations, the only place to document nullability was JavaDoc.
    With these annotations, static code analysis tools can find possible problems
    with `null` at compile time. Even better, adding these annotations to your code
    gives your method signatures and type definitions a more evident intent of how
    to use them and what to expect, as seen in [Example 9-3](#_02-optionals-annotations).
  prefs: []
  type: TYPE_NORMAL
- en: Example 9-3\. Null handling with annotation
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_handling_null_with_optionals_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Returns a non-`null` `List` of possible `null` `String` objects.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_handling_null_with_optionals_CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Returns a possible `null` `List` containing non-`null` `String` objects.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_handling_null_with_optionals_CO3-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The method argument `identifier` is allowed to be `null`.
  prefs: []
  type: TYPE_NORMAL
- en: The JDK doesn’t include these annotations, though, and the corresponding [JSR
    305](https://jcp.org/en/jsr/detail?id=305) state has been “dormant” since 2012.
    Nevertheless, it’s still the *de facto* community standard and is widely adopted
    by libraries, frameworks, and IDEs. Several libraries^([5](ch09.xhtml#idm45115229213376))
    provide the missing annotations, and most tools support multiple variants of them.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Even though the behavior of `@NonNull` and `@Nullable` seems evident on the
    surface, the actual implementation might differ between tools, especially in edge
    cases^([6](ch09.xhtml#idm45115229208080)).
  prefs: []
  type: TYPE_NORMAL
- en: The general problem with a tool-assisted approach is the reliance on the tool
    itself. If it’s too intrusive, you might end up with code that won’t run without
    it, especially if the tool involves code generation “behind the scenes.” In the
    case of `null`-related annotations, however, you don’t have to worry much. Your
    code will still run without a tool interpreting the annotations, and your variables
    and method signatures will still clearly communicate their requirements to anyone
    using them, even if unenforced.
  prefs: []
  type: TYPE_NORMAL
- en: Specialized Types like Optional
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A tool-assisted approach gives you compile-time `null`-checks, whereas specialized
    types give you safer `null`-handling at runtime. Before Java introduced its own
    `Optional` type, this gap in missing functionality was bridged by different libraries,
    like the rudimentary `Optional` type provided by the [Google Guava framework](https://github.com/google/guava/wiki/Release10)
    since 2011.
  prefs: []
  type: TYPE_NORMAL
- en: Even though there’s now an integrated solution available in the JDK, Guava doesn’t
    plan to deprecate the class in the foreseeable future^([7](ch09.xhtml#idm45115229199920)).
    Still, they gently recommend that you prefer the new, standard Java `Optional<T>`
    whenever possible.
  prefs: []
  type: TYPE_NORMAL
- en: Optionals to the Rescue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java 8’s new `Optional<T>` isn’t only a specialized type to deal with `null`
    consistently; it’s also a functional-akin pipeline benefiting from all the functional
    additions available in the JDK.
  prefs: []
  type: TYPE_NORMAL
- en: What’s an Optional?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The simplest way to think of the `Optional<T>` type is to see it as a box containing
    an actual value that might be `null`. Instead of passing around a possible `null`
    reference, you use the box, as seen in [Figure 9-1](#_02-optionals-variable-versus-optional).
  prefs: []
  type: TYPE_NORMAL
- en: '![Variable versus Optional<T>](assets/afaj_0901.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-1\. Variable versus Optional<T>
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The box provides a safe wrapper around its inner value. Optionals do not only
    wrap a value, though. Starting from this box, you can build intricate call chains
    that depend on a value’s existence or absence. They can manage the whole lifecycle
    of a possible value until the box is unwrapped, including a fallback if no value
    is present, in such a call chain.
  prefs: []
  type: TYPE_NORMAL
- en: The downside of using a wrapper, though, is having to actually look and reach
    into the box if you want to use its inner value. Like Streams, the additional
    wrapper also creates an unavoidable overhead regarding method calls and their
    additional stack frames. On the other hand, the box provides additional functionality
    for more concise and straightforward code for common workflows with possible `null`
    values.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, let’s look at the workflow of loading content by an identifier.
    The numbers in [Figure 9-2](#_02-optionals-example-intro) correspond to the upcoming
    code in [Example 9-5](#_01-optional-call-chain).
  prefs: []
  type: TYPE_NORMAL
- en: '![Loading Content](assets/afaj_0902.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-2\. Workflow of loading content
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The workflow is simplified and doesn’t handle all edge cases, but it’s a straightforward
    example of converting a multi-step workflow into an Optional call chain. In [Example 9-4](#_01-optional-call-chain_0),
    you see the workflow implemented without the help of Optionals first.
  prefs: []
  type: TYPE_NORMAL
- en: Example 9-4\. Loading content without Optionals
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The example is exaggerated to make a point, but still mostly reflects a typical
    approach to defensive `null`-handling.
  prefs: []
  type: TYPE_NORMAL
- en: There are three explicit `null`-checks, plus two decisions to be made about
    a current value and two temporary variables. Even though it’s not much code, the
    overall flow isn’t easily graspable with its many `if`-blocks and early returns.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s convert the code to a single Optional call chain, as shown in [Example 9-5](#_01-optional-call-chain).
    Don’t worry! The upcoming sections will explain the different kinds of operations
    in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Example 9-5\. Loading content with an Optional call chain
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_handling_null_with_optionals_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The first possible `null`-check is done by using the `ofNullable` creation method.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_handling_null_with_optionals_CO4-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The next `if`-block is replaced by a `filter` operation.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_handling_null_with_optionals_CO4-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of using temporary variables, the `map` operation transforms the value
    to match the next call.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_handling_null_with_optionals_CO4-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The content is also retrievable by a `map` operation.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_handling_null_with_optionals_CO4-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Load the content from the database if no value is present in the pipeline. This
    call will return another Optional so that the call chain can continue.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_handling_null_with_optionals_CO4-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Ensure only published content is available.
  prefs: []
  type: TYPE_NORMAL
- en: The Optional call chain condenses the overall code to one operation per line,
    making the overall flow easily graspable. It perfectly highlights the difference
    between using an Optional call chain and the “traditional” way of `null` checking
    everything.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a look at the different steps of creating and working with Optional
    pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: Building Optional Pipelines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As of Java 17, `Optional<T>` provides three `static` and 15 instance methods
    belonging to one of four groups representing different parts of an Optional pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new `Optional<T>` instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking for values or reacting to the presence or absence of a value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering and transforming a value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting the value or having a backup plan
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These operations can build a fluent pipeline, similar to Streams. Contrary to
    Streams, though, they are *not* lazily connected until a *terminal*-like operation
    is added to the pipeline, as I discussed in [“Streams as Functional Data Pipelines”](ch06.xhtml#_02-data-processing-what-is-a-stream).
    Every operation resolves as soon as it’s added to the fluent call. Optionals only
    appear lazy because they might return an empty Optional or a fallback value and
    skip transforming or filtering steps altogether. Still, that doesn’t make the
    call chain itself lazy. However, the executed work is as minimal as possible if
    a `null`-value is encountered, regardless of the operation count.
  prefs: []
  type: TYPE_NORMAL
- en: You can think of an Optional call chain as two train tracks, as illustrated
    in [Figure 9-3](#_02-optionals-fasttrack).
  prefs: []
  type: TYPE_NORMAL
- en: '![Optional Train Tracks](assets/afaj_0903.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-3\. Optional Train Tracks
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In this analogy, we have two train tracks: the Optional call chain track that
    leads to returning an `Optional<T>` with an inner value and the “empty express
    track” that leads to an empty `Optional<T>`. A train always starts on the `Optional<T>`
    call train track. When it encounters a track switch (an Optional operation), it
    looks for a `null` value, in which case, the train will switch to the empty express
    track. Once on the express track, there is no chance of returning to the Optional
    call chain track, at least not until Java 9, as you’ll see in [“Getting a (fallback)
    value”](#_02-optionals_getting-a-value).'
  prefs: []
  type: TYPE_NORMAL
- en: Technically, it will still call each method on the Optional call chain after
    switching to the empty express track, but it’ll just validate parameters and move
    on. If the train didn’t encounter a `null` value by the time it reaches the end
    of its route, it returns a non-empty `Optional<T>`. If it encounters a `null`
    value at any point along the route, it will return an empty `Optional<T>`.
  prefs: []
  type: TYPE_NORMAL
- en: To get the train rolling, let’s create some Optionals.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Optional
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are no `public` constructors available on the `Optional<T>` type. Instead,
    it gives you three `static` factory methods to create new instances. Which one
    to use depends on your use case and prior knowledge of the inner value:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Optional.ofNullable(T value)` if the value might be `null`'
  prefs: []
  type: TYPE_NORMAL
- en: If you know a value might be `null` or don’t care if it might be empty, use
    the method `Optional.ofNullable(…​)` to create a new instance with a possible
    inner `null` value. It’s the simplest and most bullet-proof form of creating an
    `Optional<T>`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`Optional.of(T value)` if the value must be non-`null`'
  prefs: []
  type: TYPE_NORMAL
- en: Even though Optionals are a great way to deal with `null` and prevent a `NullPointerException`,
    what if you have to make sure you have a value? For example, you already handled
    any edge cases in your code — which returned empty Optionals — and now you definitely
    have a value. The method `Optional.of(…​)` ensures that the value is non-`null`
    and throws an `NullPointerException` otherwise. This way, the exception signifies
    a real problem in your code. Maybe you missed an edge case, or a particular external
    method call has changed and returns `null` now. Using `Optional.of(…​)` in such
    a context makes your code more future-proof and resilient against unwanted changes
    in behavior.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`Optional.empty()` if there’s no value'
  prefs: []
  type: TYPE_NORMAL
- en: If you already know there’s no value at all, you can use the `static` method
    `Optional.empty()`. The call `Optional.ofNullable(null)` is unnecessary because
    there will be just an unnecessary `null` check before calling `empty()` itself.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The JDK documentation explicitly mentions that the value returned by the `static`
    `Optional.empty` method isn’t guaranteed to be a singleton object. So you shouldn’t
    compare empty Optionals with `==` (double-equals), and use `equals(Object obj)`
    or compare the result of the `isEmpty` method instead.
  prefs: []
  type: TYPE_NORMAL
- en: Using `Optional.ofNullable(T value)` might be the most `null`-tolerant creation
    method, but you should strive to use the most fitting one to represent your use
    case and context knowledge. Code might get refactored or rewritten over time,
    and it’s better to have your code throw a `NullPointerException` for a suddenly
    missing value that’s actually required as an additional safeguard, even if the
    API itself is using Optionals.
  prefs: []
  type: TYPE_NORMAL
- en: Checking for and Reacting to Values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Optionals are meant to wrap a value and represent its existence or absence.
    They are implemented as a Java type and are, therefore, a runtime-level feature
    and incur an unavoidable overhead associated with object creation. To compensate
    for this, checking for values should be as straightforward as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are four methods available for checking for and reacting to values or
    their absence. They are prefixed with "`is`" for checks and "`if`" for reactive
    higher-order functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`boolean isPresent()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean isEmpty()` (Java 11+)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Solely checking for a value has its purposes, but checking, retrieving, and
    using a value requires three separate steps when you use "`is`" methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s why the higher-order "`if`" methods consume a value directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '`void ifPresent(Consumer<? super T> action)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void ifPresentOrElse(Consumer<? super T> action, Runnable emptyAction)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both methods only perform the given `action` if a value is present. The second
    method runs the `emptyAction` if no value is present. `null` actions aren’t allowed
    and throw a `NullPointerException`. There are no `ifEmpty…​` equivalents available.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at how to use these methods in [Example 9-6](#_02-optionals_checking).
  prefs: []
  type: TYPE_NORMAL
- en: Example 9-6\. Checking for Optional values
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Both "`ifPresent`" methods perform side-effects-only code due to a lack of a
    return type. Even though pure functions are generally preferable in a functional
    approach, Optionals live somewhere between accepting functional code and fitting
    right into imperative code.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering and Mapping
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Safely handling possible `null` values already removes a considerable burden
    from any developer, but Optionals allow for more than just checking for the presence
    or absence of a value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to Streams, you build a pipeline with intermediate-like operations.
    There are three operations for filtering and mapping Optionals:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Optional<T> filter(Predicate<? super T> predicate)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<U> Optional<U> map(Function<? super T, ? extends U> mapper)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<U> Optional<U> flatMap(Function<? super T, ? extends Optional<? extends U>>
    mapper)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `filter` operation returns `this` if a value is present and matches the
    given predicate. If no value is present or the predicate doesn’t match the value,
    an empty Optional is returned.
  prefs: []
  type: TYPE_NORMAL
- en: The `map` operation transforms a present value with the provided mapper function,
    returning a new nullable Optional containing the mapped value. If no value is
    present, the operation returns an empty `Optional<U>` instead.
  prefs: []
  type: TYPE_NORMAL
- en: The `flatMap` is used if the mapping function returns an `Optional<U>` instead
    of a concrete value of type `U`. If you would use the `map` in this case, the
    return value would be an `Optional<Optional<U>>`. That’s why the `flatMap` returns
    the mapped value directly instead of wrapping it into another Optional.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 9-7](#_02-optionals_intermediate-ops) shows an Optional call chain
    and the non-Optional equivalent for a hypothetical permissions container and its
    sub-types. The code callouts are attached to both versions to show the corresponding
    operations, but their descriptions are for the Optional version.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 9-7\. Intermediate operations to find an active admin
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_handling_null_with_optionals_CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The initial `null`-check is covered by creating an `Optional<Permissions>`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_handling_null_with_optionals_CO5-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Filter for non-empty permissions. With the help of the `static` `Predicate.not`
    method, the lambda `permissions → !permissions.isEmpty()` is replaced with a more
    readable wrapped method reference.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_handling_null_with_optionals_CO5-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Get the group of the permissions object. It doesn’t matter if the `Permissions::group`
    returns `null` because the Optional call chain will figuratively skip to its value-retrieving
    operation if that’s the case. In reality, an empty Optional is passing through
    the fluent calls.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_handling_null_with_optionals_CO5-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The group might not have an admin. That’s why it returns an `Optional<User>`.
    If you simply use `map(Group::admin)`, you will have an `Optional<Optional<User>>`
    in the next step. Thanks to `flatMap(Group::admin)`, no unnecessarily nested Optional
    is created.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_handling_null_with_optionals_CO5-5)'
  prefs: []
  type: TYPE_NORMAL
- en: With the `User` object, you can filter out non-active ones.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_handling_null_with_optionals_CO5-6)'
  prefs: []
  type: TYPE_NORMAL
- en: If any method of the call chain returns an empty Optional, e.g., the group was
    `null`, the last operation returns the fallback value `Boolean.FALSE`. The next
    section will explain the different types of value-retrieval operations.
  prefs: []
  type: TYPE_NORMAL
- en: Every step of the underlying problem that needs to be solved is laid out in
    clear, isolated, and directly connected steps. Any validation and decision-making,
    like `null` or empty-checks, is wrapped up in dedicated operations built on method
    references. The intent and flow of the problem to be solved are clearly visible
    and easy to grasp.
  prefs: []
  type: TYPE_NORMAL
- en: Doing the same thing without Optionals results in a nested mess of code, as
    seen in [Example 9-8](#_02-optionals_intermediate-ops_non-optional).
  prefs: []
  type: TYPE_NORMAL
- en: Example 9-8\. Finding an active admin without Optionals
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The difference between the two versions is quite noticeable.
  prefs: []
  type: TYPE_NORMAL
- en: The non-Optional version can’t delegate any conditions or checks and relies
    on explicit `if`-statements. That creates deeply nested flow structures, increasing
    the *cyclomatic complexity* of your code. It’s harder to understand the overall
    intent of the code block, and it is not as concise as with an Optional call chain.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '*Cyclomatic Complexity^([8](ch09.xhtml#idm45115228055056))* is a metric used
    to determine code complexity. It’s based on the number of branching paths — or
    decisions — in your code. The general idea is that straight, non-nested statements
    and expressions are more accessible to follow and less error-prone than deeply
    nested decision branches, like nested `if`-statements.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting a (fallback) value
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Optionals might provide a safe wrapper for possible `null` values, but you might
    need an actual value at some point. There are multiple ways to retrieve an Optional’s
    inner value, ranging from “brute force” to providing fallback values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first method doesn’t concern itself with any safety checks:'
  prefs: []
  type: TYPE_NORMAL
- en: '`T get()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Optional is unwrapped forcefully, and if no value is present, a `NoSuchElementException`
    is thrown, so make sure to check that a value exists beforehand.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next two methods provide a fallback value if no value is present:'
  prefs: []
  type: TYPE_NORMAL
- en: '`T orElse(T other)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`T orElseGet(Supplier<? extends T> supplier)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Supplier`-based variant allows for lazily getting a fallback, which is
    immensely useful if creating it is resource intensive.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two methods available to throw Exceptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<X extends Throwable> T orElseThrow(Supplier<? extends X> exceptionSupplier)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`T orElseThrow()` (Java 10+)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even though one of the main advantages of Optionals is preventing `NullPointerException`,
    sometimes you still need a domain-specific exception if there’s no value present.
    With the `orElseThrow` operation, you have fine-grained control about handling
    a missing value and what exception to throw, too. The second method, `orElseThrow`,
    was added as a semantically correct and preferred alternative to the `get` operation.
    Even though the call isn’t as concise, it better fits into the overall naming
    scheme and confers that an Exception might be thrown.
  prefs: []
  type: TYPE_NORMAL
- en: 'Java 9 added two additional methods for providing another `Optional<T>` as
    a fallback or a `Stream<T>`. These allow more complex call chains than before:'
  prefs: []
  type: TYPE_NORMAL
- en: The first one, `Optional<T> or(Supplier<? extends Optional<? extends T>> supplier)`,
    lazily returns another Optional if no value is present. This way, you can continue
    an Optional call chain, even if no value was present before calling `or`. To go
    back to the “train track” analogy, the `or` operation is a way to provide a track
    switch back from the empty express track by creating a new starting point on the
    Optional call chain track.
  prefs: []
  type: TYPE_NORMAL
- en: The other one, `Stream<T> stream()`, returns a Stream containing the value as
    its sole element or an empty Stream if no value is present. Usually used in the
    intermediate Stream operation `flatMap` as a method reference. The Optional `stream`
    operation plays a broader role in the interoperability with the Stream API I discussed
    in [Chapter 7](ch07.xhtml#_02-streams).
  prefs: []
  type: TYPE_NORMAL
- en: Optionals and Streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As discussed in previous chapters, Streams are pipelines that filter and transform
    elements into the desired outcome. Optionals fit right in as a functional wrapper
    for possible `null` references, but they must play by the rules of Stream pipelines
    when used as elements and confer their state to the pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Optionals as Stream Elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With Streams, elements are excluded from further processing by using a filtering
    operation to discard them. In essence, Optionals themselves represent a kind of
    filtering operation, although not directly compatible with how Streams expect
    elements to behave.
  prefs: []
  type: TYPE_NORMAL
- en: If a Stream element is excluded by a `filter` operation, it won’t traverse the
    Stream further. This could be achieved by using `Optional::isPresent` as the `filter`
    operation’s argument. However, the resulting Stream in the case of an inner value,
    `Stream<Optional<User>>`, isn’t what you want.
  prefs: []
  type: TYPE_NORMAL
- en: To restore “normal” Stream semantics, you need to map the Stream from `Stream<Optional<User>>`
    to `Stream<User>`, as seen in [Example 9-9](#_02-optionals_streams_with_optionals).
  prefs: []
  type: TYPE_NORMAL
- en: Example 9-9\. Optionals as Stream elements
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_handling_null_with_optionals_CO6-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The `Group::admin` method reference returns an `Optional<User>`. At this point,
    the Stream becomes a `Stream<Optional<User>>`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_handling_null_with_optionals_CO6-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The Stream pipeline requires multiple operations to check for a value and safely
    unwrap it from its `Optional`.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering and mapping an `Optional<T>` is such a standard use case for Optionals
    in Streams that Java 9 added the `stream` method to the `Optional<T>` type. It
    returns a `Stream<T>` containing the inner value if present as its sole element,
    or otherwise, an empty `Stream<T>`. This makes it the most concise way to combine
    the power of Optionals and Streams by using the Stream’s `flatMap` operation instead
    of a dedicated `filter` and `map` operation, as seen in [Example 9-10](#_02-optionals_streams-with-optionals-flatmap).
  prefs: []
  type: TYPE_NORMAL
- en: Example 9-10\. Optionals as Stream elements with flatMap
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: A singular `flatMap` call replaces the previous `filter` and `map` operations.
    Even if you only save a single method call — one `flatMap` instead of `filter`
    plus `map` operation --⁠, the resulting code is easier to reason with and better
    illustrates the desired workflow. The `flatMap` operation conveys all the necessary
    information for understanding the Stream pipeline without adding any complexity
    by requiring additional steps. Handling Optionals is a necessity, and it should
    be done as concisely as possible so that the overall Stream pipeline is as understandable
    and straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: There’s no reason to design your APIs without Optionals just to avoid `flatMap`
    operations in Streams. If `Group::getAdmin` would return `null`, you would still
    have to add a `null-check` in another `filter` operation anyways. Replacing a
    `flatMap` operation with a `filter` operation gains you nothing, except the `admin`
    call now requires explicit `null`-handling afterwards, even if it’s no longer
    obvious from its signature.
  prefs: []
  type: TYPE_NORMAL
- en: Terminal Stream Operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using Optionals in Streams isn’t restricted to intermediate operations. Five
    of the Stream API’s terminal operations return an `Optional<T>` to provide an
    improved representation of their return value. All of them try to either find
    an element or reduce the Stream. In the case of an empty Stream, these operations
    need a sensible representation of an absentee value. Optionals exemplify this
    concept, so it was the logical choice to use them instead of returning `null`.
  prefs: []
  type: TYPE_NORMAL
- en: Finding an Element
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the Stream API, the prefix "`find`" represents, as you might have guessed
    by its name, “finding” an element based on its existence. There are two "`find`"
    operations available with distinct semantics depending on the Stream being parallel
    or serial:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Optional<T> findFirst()`'
  prefs: []
  type: TYPE_NORMAL
- en: Returns an Optional of the first element of a Stream or an empty Optional if
    the Stream is empty. There’s no difference between parallel and serial Streams.
    Any element might be returned if the Stream lacks an encounter order.
  prefs: []
  type: TYPE_NORMAL
- en: '`Optional<T> findAny()`'
  prefs: []
  type: TYPE_NORMAL
- en: Returns an Optional of any element of a Stream or an empty Optional if the Stream
    is empty. The returned element is non-deterministic to maximize performance in
    parallel streams. The first element is returned in most cases, but there’s no
    guarantee for this behavior! So use `findFirst` instead for a consistent return
    element.
  prefs: []
  type: TYPE_NORMAL
- en: 'The "`find`" operations work solely on the concept of existence, so you need
    to filter the Stream elements accordingly beforehand. If you only want to know
    if a particular element exists and don’t need the element itself, you can use
    one of the corresponding "`match`" methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`boolean anyMatch(Predicate<? super T> predicate)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean noneMatch(Predicate<? super T> predicate)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These terminal operations include the filtering operation and avoid creating
    an unnecessary `Optional<T>` instance.
  prefs: []
  type: TYPE_NORMAL
- en: Reducing to a Single Value
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reducing a Stream by combining or accumulating its elements into a new data
    structure is one of a Stream’s primary purposes. And just like the `find` operations,
    reducing operators have to deal with empty Streams.
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s why there are three terminal `reduce` operations available for Streams,
    with one returning an Optional: `Optional<T> reduce(BinaryOperator<T> accumulator)`'
  prefs: []
  type: TYPE_NORMAL
- en: It reduces the elements of the Stream using the provided `accumulator` operator.
    The returned value is the result of the reduction, or an empty Optional if the
    Stream is empty.
  prefs: []
  type: TYPE_NORMAL
- en: See [Example 9-11](#_02-optionals_streams-reduce) for an equivalent pseudo-code
    example from the official documentation^([9](ch09.xhtml#idm45115227642032)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 9-11\. Pseudo-code equivalent to the `reduce` operation
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The two other `reduce` methods require an initial value to combine the stream
    elements with, so a concrete value can be returned instead of an Optional. See
    [“Reducing Elements”](ch06.xhtml#_02-data-processing_reduce) for a more detailed
    explanation and examples of how to use them in Streams.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides the generic `reduce` methods, there are also two common use cases of
    reduction available as methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Optional<T> min​(Comparator<? super T> comparator)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Optional<T> max(Comparator<? super T> comparator)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These methods return the “minimal” or “maximal” element based on the provided
    comparator or an empty Optional if the Stream is empty.
  prefs: []
  type: TYPE_NORMAL
- en: An `Optional<T>` is the only suitable type to be returned by `min`/`max`. You
    have to check anyway if there’s a result of the operation. Adding additional `min`/`max`
    methods with a fallback value as an argument would clutter up the Stream interface.
    Thanks to the returned `Optional`, you can easily check if a result exists or
    resort to a fallback value or exception instead.
  prefs: []
  type: TYPE_NORMAL
- en: Optional Primitives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You might ask yourself why you might even need an Optional of a primitive because
    a primitive variable can never be `null`. If not initialized, any primitive has
    a value equivalent to zero for their respective type.
  prefs: []
  type: TYPE_NORMAL
- en: Even though that’s technically correct, Optionals aren’t simply about preventing
    values from being `null`. They also represent an actual state of “nothingness" — an
    absence of a value — that primitives lack.
  prefs: []
  type: TYPE_NORMAL
- en: 'In many cases, the default values of primitive types are adequate, like representing
    a networking port: zero is an invalid port number, so you have to deal with it
    anyway. if zero is a valid value, though, expressing its actual absence becomes
    more difficult.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using primitives directly with the `Optional<T>` type is a no-go because primitives
    can’t be generic types. However, just like with Streams, there are two ways to
    deal with optional primitives values: autoboxing or specialized types.'
  prefs: []
  type: TYPE_NORMAL
- en: '[“Primitive Types”](ch03.xhtml#_01-functional_primitives) highlighted the problems
    of using object-wrapper classes and the overhead they introduce. On the other
    hand, autoboxing isn’t free either.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The usual primitive types are available as dedicated Optional variants:'
  prefs: []
  type: TYPE_NORMAL
- en: '`java.util.OptionalInt`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.util.OptionalLong`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.util.OptionalDouble`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Their semantics are almost identical to their generic counterpart, but they
    do *not* inherit from `Optional<T>` or share a common interface. The features
    aren’t identical either, as multiple operations, like `filter`, `map`, or `flatMap`,
    are missing.
  prefs: []
  type: TYPE_NORMAL
- en: The primitive Optional types may remove unnecessary autoboxing, which can improve
    performance but lack the full functionality that `Optional<T>` offers. Also, unlike
    the primitive Stream variants I discussed in [“Primitive Streams”](ch07.xhtml#_02-streams-primitives-streams),
    there’s no way to easily convert between a primitive Optional variant and its
    corresponding `Optional<T>` equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: Even though it would be easy to create your own wrapper type to improve the
    handling of Optional values, especially for primitives, I wouldn’t recommend doing
    it under most circumstances. For internal or `private` implementations, you can
    use any wrapper you want or need. But the `public` seams of your code should always
    strive to stick to the most anticipated and available types. Usually, that means
    what’s already included in the JDK.
  prefs: []
  type: TYPE_NORMAL
- en: Caveats
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Optionals can enormously improve `null` handling for the JDK by providing a
    versatile “box” to hold possible `null` values and a (partially) functional API
    to build pipelines dealing with the presence or absence of that value. Although
    the upsides are certainly useful, it also comes with some noteworthy downsides
    you need to be aware of to use them correctly and without any unexpected surprises.
  prefs: []
  type: TYPE_NORMAL
- en: Optionals are ordinary types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most obvious downside of `Optional<T>` and its primitive variants is that
    they’re ordinary types. Without deeper integration into Java’s syntax, such as
    the new syntax for lambda expressions, they suffer from the same `null` reference
    problems as any other type in the JDK.
  prefs: []
  type: TYPE_NORMAL
- en: That’s why you must still adhere to best practices and informal rules to not
    counter-act the benefits of using Optionals in the first place. If you design
    an API and decide to use Optionals as a return type, you *must not* return `null`
    for it under any circumstances! Returning an Optional is a clear signal that anyone
    using the API will receive at least a “box” that *might* contain a value instead
    of a possible `null` value. If no value is possible, always use an empty Optional
    or the primitive equivalent instead.
  prefs: []
  type: TYPE_NORMAL
- en: This essential design requirement has to be enforced by convention, though.
    The compiler won’t help you there without additional tools, like [SonarSource](https://www.sonarsource.com/)^([10](ch09.xhtml#idm45115227431008)).
  prefs: []
  type: TYPE_NORMAL
- en: Identity-sensitive Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Even though Optionals *are* ordinary types, the identity-sensitive methods might
    work differently from what you expect. This includes the reference equality operator
    `==` (double-equals), using the `hashCode` method, or using an instance for thread
    synchronization.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Object identity tells you whether two different objects share the same memory
    address and are, therefore, the same object. This is tested by the reference equality
    operator `==` (double-equals). Equality of two objects, which is tested with their
    `equals` method, means they contain the same state.
  prefs: []
  type: TYPE_NORMAL
- en: Two identical objects are also equal, but the reverse isn’t necessarily true.
    Just because two objects contain the same state doesn’t automatically mean they
    also share the same memory address.
  prefs: []
  type: TYPE_NORMAL
- en: The difference in behavior lies in Optional’s nature of being *value-based*
    type, meaning its inner value is its primary concern. Methods like `equals`, `hashCode`,
    and `toString` are solely based on the inner value and ignore the actual object
    identity. That’s why you should treat Optional instances as interchangeable and
    unsuited for identity-related operations like synchronizing concurrent code, as
    stated in the official documentation^([11](ch09.xhtml#idm45115227420480)).
  prefs: []
  type: TYPE_NORMAL
- en: Performance-Overhead
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another point to consider when using Optionals is the performance implications,
    especially outside their primary design goal as return types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Optionals are easy to (mis-)use for simple `null`-checks and provide a fallback
    value if no inner value is present:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Such simple Optional pipelines require a new `Optional` instance, and every
    method call creates a new stack frame that the JVM can’t optimize your code as
    easily as a simple `null`-check. Creating an Optional doesn’t make much sense
    without additional operations besides checking for existence or providing a fallback.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using alternatives like the ternary operator or a direct `null`-check should
    be your preferred solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Using an Optional instead of a ternary operator might look nicer and saves you
    from repeating `maybeNull`. Reducing the number of instance creations and method
    invocations is usually preferable.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you still want a more visually pleasing alternative to the ternary operator,
    Java 9 introduced two `static` helper methods on `java.util.Objects` wrapping
    the task of checking for `null` and providing an alternative value:'
  prefs: []
  type: TYPE_NORMAL
- en: '`T requireNonNullElse(T obj, T defaultObj)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`T requireNonNullElseGet(T obj, Supplier<? extends T> supplier)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fallback value, or in the case of the second method, the result of the `Supplier`,
    must be non-`null`, too.
  prefs: []
  type: TYPE_NORMAL
- en: Saving a few CPU cycles means nothing compared to a crash due to an unexpected
    `NullPointerException`. Just like with Streams, there’s a trade-off to be made
    between performance and safer and more straightforward code. You need to find
    the balance between those based on your requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Special Considerations for Collections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`null` is the technical representation of the absence of a value. Optionals
    give you a tool to represent this absence safely with an actual object that allows
    further transformation, filtering, and more. Collection-based types, though, can
    already represent an absence of their inner values.'
  prefs: []
  type: TYPE_NORMAL
- en: A collection type is already a “box” that handles values, so wrapping it in
    an `Optional<T>` creates yet another layer you must deal with. An empty collection
    already indicates the absence of inner values, so using an empty collection as
    the alternative to `null` eliminates a possible `NullPointerException` *and* the
    need for an additional layer by using an Optional.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, you still have to deal with the absence of the collection itself,
    meaning a `null` reference. If possible, you shouldn’t use `null` for collections
    at all, neither as arguments nor return values. Designing your code to always
    use an empty collection instead of `null` will have the same effect as an Optional.
    If you still need to discern between `null` and an empty collection, or the related
    code isn’t under your control or can’t be changed, a `null`-check might still
    be preferable to introducing another layer to deal with.
  prefs: []
  type: TYPE_NORMAL
- en: Optionals and Serialization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Optional<T>` type and the primitive variants don’t implement `java.io.Serializable`,
    making them unsuited for private fields in serializable types. This decision was
    made deliberately by its design group because Optionals are supposed to provide
    the possibility of an optional return value, not be a general-purpose solution
    for nullability. Making `Optional<T>` serializable would encourage use cases far
    beyond its intended design goal.
  prefs: []
  type: TYPE_NORMAL
- en: To still reap the benefits of Optionals in your object and maintain serializability,
    you can use them for your `public` API but use non-Optional fields as an implementation
    detail, as shown in [Example 9-12](#_02-optionals_serialization)
  prefs: []
  type: TYPE_NORMAL
- en: Example 9-12\. Using Optionals in Serializable types
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: By relying only on an Optional in the getter for `lastLogin`, the type remains
    serializable but still provides an Optional API.
  prefs: []
  type: TYPE_NORMAL
- en: Final Thoughts on null References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although it’s called a *billion-dollar mistake*, `null` isn’t inherently evil.
    Sir Charles Antony Richard Hoare, the inventor of `null`, believes that programming
    language designers should be responsible for errors in programs written in their
    language^([12](ch09.xhtml#idm45115227195568)).
  prefs: []
  type: TYPE_NORMAL
- en: A language should provide a solid foundation with a good deal of ingenuity and
    control. Allowing `null` references is one of many design choices for Java, nothing
    more. Java’s *catch or specify requirement*, as explained in [Chapter 10](ch10.xhtml#_02-exception-handling),
    and `try`-`catch`-blocks provide you with tools against apparent errors. But with
    `null` being a valid value for any type, every reference is a possible crash waiting
    to happen. Even if you think something can *never* be `null`, experience tells
    us that it may be possible at some point in time.
  prefs: []
  type: TYPE_NORMAL
- en: The existence of `null` references doesn’t qualify a language as poorly designed.
    `null` has its place, but it requires you to be more attentive to your code. This
    doesn’t mean you should replace every single variable and argument in your code
    with Optionals, either.
  prefs: []
  type: TYPE_NORMAL
- en: Optionals were intended to provide a limited mechanism for optional return values,
    so don’t over- or misuse them just because it seems convenient. In code under
    your control, you can make more assumptions and guarantees about the possible
    nullability of references and deal with it accordingly, even without Optionals.
    If you follow the other principles highlighted in this book — like small, self-contained,
    pure functions without side effects — it’s way easier to make sure your code won’t
    return a `null` reference unexpectedly.
  prefs: []
  type: TYPE_NORMAL
- en: Takeaways
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There’s no language-level or special syntax available for `null`-handling in
    Java.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`null` is a special case that can represent both the states of “doesn’t exist”
    and “undefined” without you being able to distinguish them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Optional<T>` type allows for dedicated `null`-handling these states with
    operation chains and fallbacks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specialized types for primitives are also available, although they don’t provide
    feature parity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other approaches for `null`-handling exist, like annotations or best practices.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not everything is a good fit for Optionals. If a data structure already has
    a concept of emptiness, like collections, adding another layer is contra-productive.
    You shouldn’t wrap it into an Optional unless you are required to represent an
    “undefined” state, too.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optionals and Streams are interoperable without much friction.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optionals aren’t serializable, so don’t use them as private fields if you need
    to serialize your type. Instead, use Optionals as return values for getters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alternative implementations exist, like in the [Google Guava framework](https://github.com/google/guava),
    even though Google itself recommends using Java’s Optional instead.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`null` isn’t evil per se. Don’t replace every variable with Optionals without
    a good reason.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '^([1](ch09.xhtml#idm45115229846656-marker)) Varargs don’t accept `null` as
    a sole argument because it’s an inexact argument type, because it might represent
    `Object` or `Object[]`. To pass a single `null` to a vararg you need to wrap it
    in an array: `new Object[]{ null }`.'
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch09.xhtml#idm45115229645008-marker)) Many programming languages have
    a dedicated operator to safely call fields or methods on possible `null` references.
    The [Wikipedia article on the safe-navigation operator](https://en.wikipedia.org/wiki/Safe_navigation_operator)
    has an in-depth explanation and examples in many languages.
  prefs: []
  type: TYPE_NORMAL
- en: '^([3](ch09.xhtml#idm45115229642560-marker)) The `null` coalescing operator
    is like a shortened ternary operator. The expression `x != null ? x : y` is shortened
    to `x ?: y`, with `?:` (question-mark colon) being the operator. Not all languages
    use the same operator, though. The [Wikipedia article](https://en.wikipedia.org/wiki/Null_coalescing_operator)
    gives an overview of different programming languages supporting which operator
    form.'
  prefs: []
  type: TYPE_NORMAL
- en: ^([4](ch09.xhtml#idm45115229323040-marker)) Java’s JIT (just-in-time) compiler
    performs a myriad of optimizations to improve the executed code. If necessary,
    it recompiles code when more information about how it’s executed becomes available.
    An overview of possible optimization is available on the [Open JDK Wiki](https://wiki.openjdk.org/display/HotSpot/PerformanceTechniques).
  prefs: []
  type: TYPE_NORMAL
- en: ^([5](ch09.xhtml#idm45115229213376-marker)) The most common libraries to provide
    the marker annotation are [FindBugz](http://findbugs.sourceforge.net/) (up to
    Java 8), and its spiritual successor [SpotBugz](https://spotbugs.github.io/).
    JetBrains, the creator of the IntelliJ IDE and the JVM language *Kotlin*, also
    [provide a package containing the annotations](https://github.com/JetBrains/java-annotations).
  prefs: []
  type: TYPE_NORMAL
- en: ^([6](ch09.xhtml#idm45115229208080-marker)) The [Checker Framework](https://checkerframework.org)
    has [an example](https://checkerframework.org/manual/#findbugs-nullable) of such
    “non-standard” behavior between different tools.
  prefs: []
  type: TYPE_NORMAL
- en: ^([7](ch09.xhtml#idm45115229199920-marker)) The [documentation of Guava’s `Optional<T>`](https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/base/Optional.xhtml)
    explicitly mentions that the JDK variant should be preferred.
  prefs: []
  type: TYPE_NORMAL
- en: ^([8](ch09.xhtml#idm45115228055056-marker)) McCabe, TJ. 1976\. “A Complexity
    Measure” [IEEE Transactions on Software Engineering, December 1976, Vol. SE-2
    No. 4, 308–320](https://doi.org/10.1109/TSE.1976.233837).
  prefs: []
  type: TYPE_NORMAL
- en: ^([9](ch09.xhtml#idm45115227642032-marker)) [Documentation for `Optional<T>
    reduce​(BinaryOperator<T> accumulator)`](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/stream/Stream.xhtml#reduce(java.util.function.BinaryOperator)).
  prefs: []
  type: TYPE_NORMAL
- en: ^([10](ch09.xhtml#idm45115227431008-marker)) The [SonarSource](https://www.sonarsource.com/)
    rule [RSPEC-2789](https://rules.sonarsource.com/java/RSPEC-2789) checks for Optionals
    being `null`.
  prefs: []
  type: TYPE_NORMAL
- en: ^([11](ch09.xhtml#idm45115227420480-marker)) The [official doumentation](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Optional.xhtml)
    explicitly mentions unpredictable identity method behavior as an “API Note.”
  prefs: []
  type: TYPE_NORMAL
- en: '^([12](ch09.xhtml#idm45115227195568-marker)) Sir Charles Antony Richard Hoare
    expressed this view in his talk [“Null References: The Billion Dollar Mistake”](https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare/)
    at [QCon London](https://qconlondon.com/london-2009/qconlondon.com/london-2009/presentation/Null%2bReferences_%2bThe%2bBillion%2bDollar%2bMistake.xhtml)
    in 2009.'
  prefs: []
  type: TYPE_NORMAL
