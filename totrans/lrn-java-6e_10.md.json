["```java\n    InputStream stdin = System.in;\n    OutputStream stdout = System.out;\n    OutputStream stderr = System.err;\n```", "```java\n    try {\n      int val = System.in.read();\n    } catch (IOException e) {\n      // ...\n    }\n```", "```java\n    try {\n      int val;\n      while((val=System.in.read()) != -1) {\n        System.out.println((byte)val);\n      }\n    } catch (IOException e) {\n      // Oops. Handle the error or print an error message\n    }\n```", "```java\n    byte [] buff = new byte [1024];\n    int got = System.in.read(buff);\n```", "```java\n    int waiting = System.in.available();\n    if (waiting > 0) {\n      byte [] data = new byte [ waiting ];\n      System.in.read(data);\n      // ...\n    }\n```", "```java\n// file: ch10/examples/ParseKeyboard.java\n\n    try {\n      InputStream in = System.in;\n      InputStreamReader charsIn = new InputStreamReader(in);\n      BufferedReader bufferedCharsIn = new BufferedReader(charsIn);\n\n      String line = bufferedCharsIn.readLine();\n      int i = NumberFormat.getInstance().parse(line).intValue();\n      // ...\n    } catch (IOException e) {\n      // ...\n    } catch (ParseException pe) {\n      // ...\n    }\n```", "```java\n    InputStreamReader reader = new InputStreamReader(System.in, \"UTF-8\");\n```", "```java\n    InputStream bufferedIn = new BufferedInputStream(System.in);\n```", "```java\n    DataInputStream dis = new DataInputStream(System.in);\n    double d = dis.readDouble();\n```", "```java\n    double d = 3.1415926;\n    DataOutputStream dos = new DataOutputStream(System.out);\n    dos.writeDouble(d);\n```", "```java\n    BufferedInputStream bis = new BufferedInputStream(myInputStream, 32768);\n    // bis will store up to 32K of data from myInputStream at a time\n    // we can then read from bis at any time\n    byte b = bis.read();\n```", "```java\n    System.out.print(\"Hello, world...\\n\");\n    System.out.println(\"Hello, world...\");\n    System.out.printf(\"The answer is %d\\n\", 17);\n    System.out.println(3.14);\n```", "```java\n    // Stream automatically flushes after a newline.\n    PrintWriter pw = new PrintWriter(myOutputStream, true);\n    pw.println(\"Hello!\");\n```", "```java\n    System.out.println(reallyLongString);\n    if (System.out.checkError()) {\n      // uh oh\n    }\n```", "```java\n    File fooFile = new File(\"/tmp/foo.txt\");\n    File barDir = new File(\"/tmp/bar\");\n```", "```java\n    File f = new File(\"foo\");\n```", "```java\n    System.getProperty(\"user.dir\"); // e.g.,\"/Users/pat\"\n```", "```java\n    File fooFile = new File(\"/tmp\", \"foo.txt\");\n```", "```java\n    File tmpDir = new File(\"/tmp\"); // File for directory /tmp\n    File fooFile = new File (tmpDir, \"foo.txt\");\n```", "```java\n    // we'll use forward slash as our standard\n    String path = \"mail/2023/june\";\n    path = path.replace('/', File.separatorChar);\n    File mailbox = new File(path);\n```", "```java\n    String [] path = { \"mail\", \"2004\", \"june\", \"merle\" };\n\n    StringBuffer sb = new StringBuffer(path[0]);\n    for (int i=1; i< path.length; i++) {\n      sb.append(File.separator + path[i]);\n    }\n    File mailbox = new File(sb.toString());\n```", "```java\njshell> import java.io.File;\n\n// On a Linux box:\njshell> File.listRoots()\n$2 ==> File[1] { / }\n\n// On Windows:\njshell> File.listRoots()\n$3 ==> File[2] { C:\\, D:\\ }\n```", "```java\n    File fooFile = new File(\"/tmp/foo.txt\");\n\n    String type = fooFile.isFile() ? \"File \" : \"Directory \";\n    String name = fooFile.getName();\n    long len = fooFile.length();\n    System.out.println(type + name + \", \" + len + \" bytes \");\n```", "```java\n    File tmpDir = new File(\"/tmp\");\n    String [] fileNames = tmpDir.list();\n    File [] files = tmpDir.listFiles();\n```", "```java\n    List list = Arrays.asList(fileNames);\n    Collections.sort(list);\n```", "```java\n    FileInputStream in = new FileInputStream(\"/etc/motd\");\n```", "```java\n  try (FileInputStream fin = new FileInputStream(\"/etc/motd\") ) {\n    // ....\n    // fin will be closed automatically if needed\n    // upon exiting the try clause.\n  }\n```", "```java\n//file: ch10/examples/ListIt.java\nimport java.io.*;\n\nclass ListIt {\n  public static void main (String args[]) throws Exception {\n    File file =  new File(args[0]);\n\n    if (!file.exists() || !file.canRead()) {\n      System.out.println(\"Can't read \" + file);\n      return;\n    }\n\n    if (file.isDirectory()) {\n      String [] files = file.list();\n      for (String file : files)\n        System.out.println(file);\n    } else {\n      try {\n        Reader ir = new InputStreamReader(\n            new FileInputStream(file) );\n\n        BufferedReader in = new BufferedReader(ir);\n        String line;\n        while ((line = in.readLine()) != null)\n          System.out.println(line);\n      }\n      catch (FileNotFoundException e) {\n          System.out.println(\"File Disappeared\");\n      }\n    }\n  }\n}\n```", "```java\n    FileOutputStream fooOut =\n        new FileOutputStream(fooFile); // overwrite fooFile\n    FileOutputStream pwdOut =\n        new FileOutputStream(\"/etc/passwd\", true); // append\n```", "```java\n    String s = new BufferedReader(\n        new InputStreamReader(System.in) ).readLine();\n    File out = new File(\"/tmp/foo.txt\");\n    FileWriter fw = new FileWriter (out);\n    PrintWriter pw = new PrintWriter(fw);\n    pw.println(s);\n    pw.close();\n```", "```java\n    try {\n      RandomAccessFile users = new RandomAccessFile(\"Users\", \"rw\")\n    } catch (IOException e) { ... }\n```", "```java\n    users.seek(userNum * RECORDSIZE);\n    users.writeUTF(userName);\n    users.writeInt(userID);\n```", "```java\n    // The default host computer filesystem\n    FileSystem fs = FileSystems.getDefault();\n\n    // A custom filesystem for ZIP files, no special properties\n    Map<String,String> props = new HashMap<>();\n    URI zipURI = URI.create(\"jar:file:/Users/pat/tmp/MyArchive.zip\");\n    FileSystem zipfs = FileSystems.newFileSystem(zipURI, props);\n```", "```java\n    Path fooPath = fs.getPath(\"/tmp/foo.txt\");\n    OutputStream out = Files.newOutputStream(fooPath);\n```", "```java\n    Path patPath =  fs.getPath(\"/User/pat/\");\n\n    Path patTmp = patPath.resolve(\"tmp\"); // \"/User/pat/tmp\"\n\n    // Same as above, using a Path\n    Path tmpPath = fs.getPath(\"tmp\");\n    Path patTmp = patPath.resolve(tmpPath); // \"/User/pat/tmp\"\n\n    // Resolving a given absolute path against any path just yields given path\n    Path absPath = patPath.resolve(\"/tmp\"); // \"/tmp\"\n\n    // Resolve sibling to Pat (same parent)\n    Path danPath = patPath.resolveSibling(\"dan\"); // \"/Users/dan\"\n```", "```java\n    Path tmpPath = fs.getPath(\"/tmp\");\n    File file = tmpPath.toFile();\n    File tmpFile = new File(\"/tmp\");\n    Path path = tmpFile.toPath();\n```", "```java\n    // Move the file /tmp/foo.txt to /tmp/bar.txt\n    Path foo = fs.getPath(\"/tmp/foo.txt\");\n    Files.move(foo, foo.resolveSibling(\"bar.txt\"));\n```", "```java\n    // Read and write collection of String (e.g., lines of text)\n    Charset asciiCharset = Charset.forName(\"US-ASCII\");\n    List<String> csvData = Files.readAllLines(csvPath, asciiCharset);\n    Files.write(newCSVPath, csvData, asciiCharset);\n\n    // Read and write bytes\n    byte [] data = Files.readAllBytes(dataPath);\n    Files.write(newDataPath, data);\n```", "```java\n    mark <= position <= limit <= capacity\n```", "```java\n    ByteBuffer buff = ...\n    while (inChannel.read(buff) > 0) { // position = ?\n      buff.flip();    // limit = position; position = 0;\n      outChannel.write(buff);\n      buff.rewind();  // position = 0\n      outChannel2.write(buff);\n      buff.clear();   // position = 0; limit = capacity\n    }\n```", "```java\n    byte get()\n    char getChar()\n    short getShort()\n    int getInt()\n    long getLong()\n    float getFloat()\n    double getDouble()\n\n    void put(byte b)\n    void put(ByteBuffer src)\n    void put(byte[] src, int offset, int length)\n    void put(byte[] src)\n    void putChar(char value)\n    void putShort(short value)\n    void putInt(int value)\n    void putLong(long value)\n    void putFloat(float value)\n    void putDouble(double value)\n```", "```java\n    getLong(int index)\n    putLong(int index, long value)\n```", "```java\n    byteArray.order(ByteOrder.BIG_ENDIAN);\n```", "```java\njshell> import java.nio.ByteOrder;\n\njshell> ByteOrder.nativeOrder()\n$4 ==> LITTLE_ENDIAN\n```", "```java\n    CharBuffer cbuf = CharBuffer.allocate(64*1024);\n    ByteBuffer bbuf = ByteBuffer.wrap(someExistingArray);\n```", "```java\n    ByteBuffer bbuf2 = ByteBuffer.allocateDirect(64*1024);\n```", "```java\n    Charset charset = Charset.forName(\"US-ASCII\");\n    CharBuffer charBuff = charset.decode(byteBuff);  // to ascii\n    ByteBuffer byteBuff = charset.encode(charBuff);  // and back\n```", "```java\n    Map map = Charset.availableCharsets();\n    Iterator it = map.keySet().iterator();\n    while (it.hasNext())\n      System.out.println(it.next());\n```", "```java\n    CharsetDecoder decoder = Charset.forName(\"US-ASCII\").newDecoder();\n\n    boolean done = false;\n    while (!done) {\n      bbuff.clear();\n      done = (in.read(bbuff) == -1);\n      bbuff.flip();\n      decoder.decode(bbuff, cbuff, done);\n    }\n    cbuff.flip();\n    // use cbuff. . .\n```", "```java\n    FileSystem fs = FileSystems.getDefault();\n    Path p = fs.getPath(\"/tmp/foo.txt\");\n\n    // Open default for reading\n    try (FileChannel channel = FileChannel.open(p)) {\n      // read from the channel ...\n    }\n\n    // Open with options for writing\n    import static java.nio.file.StandardOpenOption.*;\n\n    try (FileChannel channel =\n        FileChannel.open(p, WRITE, APPEND, ...) ) {\n      // append to foo.txt if it already exists,\n      // otherwise, create it and start writing ...\n    }\n```", "```java\n    FileChannel readOnlyFc = new FileInputStream(\"file.txt\")\n        .getChannel();\n    FileChannel readWriteFc = new RandomAccessFile(\"file.txt\", \"rw\")\n        .getChannel();\n```", "```java\n    ByteBuffer bbuf = ByteBuffer.allocate(...);\n    bbuf.clear();\n    readOnlyFc.position(index);\n    readOnlyFc.read(bbuf);\n    bbuf.flip();\n    readWriteFc.write(bbuf);\n```", "```java\n    readWriteFc.read(bbuf, index)\n    readWriteFc.write(bbuf, index2);\n```", "```java\n    FileLock bigLock = fileChannel.lock();\n\n    int start = 0, len = fileChannel2.size();\n    FileLock readLock = fileChannel2.lock(start, len, true);\n```", "```java\n    bigLock.release();\n```", "```java\n  try (FileChannel channel = FileChannel.open(p, WRITE) ) {\n    channel.lock();\n    // ...\n  }\n```", "```java\npublic class AccessNIO {\n  String accessFileName = \"access.txt\";\n  Path   accessFilePath = Path.of(accessFileName);\n  int    accessCount = 0;\n  FileChannel accessChannel;\n\n  public AccessNIO() {\n    // ...\n    boolean initial = !Files.exists(accessFilePath);\n    accessChannel = FileChannel.open(accessFilePath, CREATE, READ, WRITE);\n    // ...\n  }\n}\n```", "```java\n    if (initial) {\n      String msg = buildMessage(); // helper for consistency\n      accessChannel.write(ByteBuffer.wrap(msg.getBytes()));\n      accessChannel.position(0);\n    }\n```", "```java\n  public boolean isReady() {\n    return (accessChannel != null && accessChannel.isOpen());\n  }\n```", "```java\n    int fsize = (int)accessChannel.size();\n    // Give ourselves extra room in case the count\n    // goes over a digit boundary (9 -> 10, 99 -> 100, etc.)\n    ByteBuffer in = ByteBuffer.allocate(fsize + 2);\n    accessChannel.read(in);\n    String current = new String(in.array());\n```", "```java\n    int countStart = 28;\n    // We know where the count number starts, so get\n    // everything from that position to the next space\n    String rawCount = current.substring(countStart,\n        current.indexOf(\" \", countStart));\n    accessCount = Integer.parseInt(rawCount) + 1;\n```", "```java\n    String msg = buildMessage();\n    accessChannel.position(0);\n    accessChannel.write(ByteBuffer.wrap(msg.getBytes()));\n    accessChannel.truncate(accessChannel.position());\n    accessChannel.close();\n```", "```java\n    C:\\> java Count ../examples/ListIt.java\n    Analyzing ListIt.java\n      Size: 1011 bytes\n    ```", "```java\n    C:\\> java Count ../examples/ListIt.java\n    Analyzing ListIt.java\n      Size: 1011 bytes\n      Lines: 36\n      Words: 178\n    ```", "```java\n    2023-02-02 08:14:25 Count1.java  36  147  1002\n    ```"]