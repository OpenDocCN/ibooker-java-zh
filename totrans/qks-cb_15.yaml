- en: Chapter 15\. Working with a Reactive Programming Model
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第15章。 使用响应式编程模型
- en: We are all familiar with the client-server architecture that has dominated enterprise
    software development for decades. However, we have recently had a shift in architecture
    styles. In addition to the standard client-server approach, we have message-driven
    applications, microservices, reactive applications, and even serverless! All of
    these types of applications are possible to create using Quarkus. In the follow
    recipes, you’ll learn about reactive programming models, message buses, and streaming.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都熟悉主导企业软件开发数十年的客户端-服务器架构。然而，最近我们的架构风格发生了变化。除了标准的客户端-服务器方法外，我们还有消息驱动的应用程序，微服务，响应式应用程序甚至无服务器！使用
    Quarkus 可以创建所有这些类型的应用程序。在接下来的示例中，您将了解有关响应式编程模型，消息总线和流式传输的信息。
- en: Note
  id: totrans-2
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Quarkus (and this book!) makes use of SmallRye Mutiny for its reactive library.
    You can read more about Mutiny at [SmallRye Mutiny](https://oreil.ly/nBP7H). There
    is also support for RxJava and Reactor, but they are not the preferred choice.
    To use either of them, you will need to use converters from Mutiny.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Quarkus（以及本书！）使用 SmallRye Mutiny 作为其响应式库。您可以在 [SmallRye Mutiny](https://oreil.ly/nBP7H)
    上阅读更多信息。还支持 RxJava 和 Reactor，但它们不是首选选择。要使用它们中的任何一个，您需要使用从 Mutiny 转换器。
- en: 15.1 Creating Async HTTP Endpoints
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 15.1 创建异步 HTTP 端点
- en: Problem
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to create an async HTTP endpoint.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望创建异步 HTTP 端点。
- en: Solution
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Quarkus has integrations with Java Streams, the Eclipse MicroProfile Reactive
    spec, and SmallRye Mutiny. These integrations make it easy to support an asynchronous
    HTTP endpoint. The first thing you will need to do is determine which libraries
    you wish to use. If you wish to use native Streams or the MicroProfile Reactive
    specification, you will need to add the `quarkus-smallrye-reactive-streams-operators`
    extension. If you want to use SmallRye Mutiny, add the `quarkus-resteasy-mutiny`
    extension to your project.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Quarkus 与 Java Streams，Eclipse MicroProfile 响应式规范和 SmallRye Mutiny 集成。这些集成使得支持异步
    HTTP 端点变得非常容易。您首先需要确定希望使用哪些库。如果您希望使用原生 Streams 或 MicroProfile 响应式规范，您需要添加 `quarkus-smallrye-reactive-streams-operators`
    扩展。如果您想使用 SmallRye Mutiny，则需要向项目添加 `quarkus-resteasy-mutiny` 扩展。
- en: Note
  id: totrans-9
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Going forward, Mutiny will be the preferred library within Quarkus for all things
    reactive.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，Mutiny 将是 Quarkus 内所有响应式相关内容的首选库。
- en: 'Once the extension is in place, all you need to do with your HTTP endpoints
    is return a reactive class:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦扩展位于适当位置，您需要做的就是在您的 HTTP 端点中返回一个响应式类：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[![1](Images/1.png)](#co_working_with_a_reactive___span_class__keep_together__programming_model__span__CO1-1)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_working_with_a_reactive___span_class__keep_together__programming_model__span__CO1-1)'
- en: Naturally, any valid `MediaType` is valid; for simplicity, we used plain text
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，任何有效的 `MediaType` 都是有效的；为简单起见，我们使用了纯文本
- en: '[![2](Images/2.png)](#co_working_with_a_reactive___span_class__keep_together__programming_model__span__CO1-2)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_working_with_a_reactive___span_class__keep_together__programming_model__span__CO1-2)'
- en: '`CompletionStage` comes from the `java.util.concurrent` package'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`CompletionStage` 来自 `java.util.concurrent` 包'
- en: 'For Mutiny, this example becomes the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Mutiny，这个示例变成了以下内容：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: See Also
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'For more information, visit the following websites:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解更多信息，请访问以下网站：
- en: '[SmallRye Mutiny](https://oreil.ly/nBP7H)'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SmallRye Mutiny](https://oreil.ly/nBP7H)'
- en: '[SmallRye Reactive Streams Operators](https://oreil.ly/Ab8eo)'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SmallRye 响应式流操作符](https://oreil.ly/Ab8eo)'
- en: '[Reactive Streams](https://oreil.ly/pgyMk)'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[响应式流](https://oreil.ly/pgyMk)'
- en: 15.2 Streaming Data Asynchronously
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 15.2 异步流式处理数据
- en: Problem
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to stream data in an async way.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望以异步方式流式传输数据。
- en: Solution
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Very similar to creating an asynchronous HTTP endpoint, Quarkus allows you
    to stream events from your application using server-sent events or server-side
    events (SSE). What you will need to do in this case is to return a `Publisher`
    and tell JAX-RS that your endpoint produces `MediaType.SERVER_SENT_EVENTS`. Here’s
    an example that streams a `long` every 500 milliseconds:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 与创建异步 HTTP 端点非常相似，Quarkus 允许您使用服务器发送事件（SSE）或服务器端事件从应用程序中流式传输事件。在这种情况下，您需要返回一个
    `Publisher` 并告诉 JAX-RS 您的端点生成 `MediaType.SERVER_SENT_EVENTS`。以下是每500毫秒流式传输 `long`
    的示例：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[![1](Images/1.png)](#co_working_with_a_reactive___span_class__keep_together__programming_model__span__CO2-1)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_working_with_a_reactive___span_class__keep_together__programming_model__span__CO2-1)'
- en: Make sure you tell JAX-RS you are using SSEs
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 确保告诉 JAX-RS 你在使用 SSEs
- en: '[![2](Images/2.png)](#co_working_with_a_reactive___span_class__keep_together__programming_model__span__CO2-2)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_working_with_a_reactive___span_class__keep_together__programming_model__span__CO2-2)'
- en: The return type for the method must be a `org.reactivestream.Publisher` from
    the Reactive Streams library
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 方法的返回类型必须是来自 Reactive Streams 库的 `org.reactivestream.Publisher`
- en: With Mutiny, a `Multi` is a `Publisher`, making this even easier by simply returning
    a `Multi`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Mutiny，一个 `Multi` 是一个 `Publisher`，这样做更加简单，只需返回一个 `Multi`。
- en: See Also
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参见
- en: 'For more information, visit the following websites:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息，请访问以下网站：
- en: '[Wikiwand: Server-Sent Events](https://oreil.ly/m0cAC)'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Wikiwand：服务器发送事件](https://oreil.ly/m0cAC)'
- en: '[MDN Web Docs: Using server-sent events](https://oreil.ly/ZIX4X)'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[MDN Web Docs：使用服务器发送事件](https://oreil.ly/ZIX4X)'
- en: 15.3 Using Messaging to Decouple Components
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 15.3 使用消息传递来解耦组件
- en: Problem
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to use messaging to decouple components.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你想使用消息传递来解耦组件。
- en: Solution
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: One of the underlying/bundled frameworks used by Quarkus is Vert.x. Vert.x is
    a framework for building asynchronous, event-driven, reactive applications, much
    like Quarkus! Quarkus makes use of the Vert.x Event Bus for sending and receiving
    events/messages with decoupled classes.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Quarkus 使用的一个底层/捆绑框架是 Vert.x。Vert.x 是一个用于构建异步、事件驱动、响应式应用的框架，类似于 Quarkus！Quarkus
    利用 Vert.x 事件总线发送和接收事件/消息，类之间是解耦的。
- en: To make use of Vert.x, just like many features with Quarkus, you will need to
    add the proper extension to your application. The name for the Vert.x extension
    is `vertx`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Vert.x，就像许多 Quarkus 的特性一样，你需要将适当的扩展添加到你的应用中。Vert.x 扩展的名称是 `vertx`。
- en: Handling events/messages
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理事件/消息
- en: 'We’ll first take a look at listening to or consuming events. The easiest way
    to consume events in Quarkus is to use the `io.quarkus.vertx.ConsumeEvent` annotation.
    `@ConsumeEvent` has attributes, which we’ll get to, but let’s see it in action:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先看一下监听或消费事件。 在 Quarkus 中消费事件的最简单方式是使用 `io.quarkus.vertx.ConsumeEvent` 注解。`@ConsumeEvent`
    有一些属性，我们稍后会讲到，但让我们先看看它的实际应用：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[![1](Images/1.png)](#co_working_with_a_reactive___span_class__keep_together__programming_model__span__CO3-1)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_working_with_a_reactive___span_class__keep_together__programming_model__span__CO3-1)'
- en: With no value set, the address of the event is the fully qualified name of the
    bean; in this case, it would be `com.acme.vertx.GreetingService`
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有设置值，事件的地址是 bean 的完全限定名；在这种情况下，应该是 `com.acme.vertx.GreetingService`
- en: '[![2](Images/2.png)](#co_working_with_a_reactive___span_class__keep_together__programming_model__span__CO3-2)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_working_with_a_reactive___span_class__keep_together__programming_model__span__CO3-2)'
- en: The parameter for the consumer is the message body; if the method returns anything,
    it is packaged as the message response
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 消费者的参数是消息体；如果方法返回任何内容，它会被封装为消息响应。
- en: Sending events/messages
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发送事件/消息
- en: 'To send an event, you will be interacting with the Vert.x Event Bus. You can
    obtain the instance via injection: `@Inject io.vertx.axle.core.eventbus.EventBus
    bus`. You will be primarily making use of two methods on the event bus:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 要发送事件，你将与 Vert.x 事件总线进行交互。你可以通过注入获取实例：`@Inject io.vertx.axle.core.eventbus.EventBus
    bus`。你将主要使用事件总线上两个方法：
- en: '`send`'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`send`'
- en: Sends a message and optionally expects a reply
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 发送消息并可选地期待回复
- en: '`publish`'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`publish`'
- en: Publishes a message to each listener
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 向每个监听器发布消息
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[![1](Images/1.png)](#co_working_with_a_reactive___span_class__keep_together__programming_model__span__CO4-1)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_working_with_a_reactive___span_class__keep_together__programming_model__span__CO4-1)'
- en: Send a message to a specific address, and a single consumer receives it, then
    forget about the response.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 向特定地址发送消息，一个消费者接收后，便忽略响应。
- en: '[![2](Images/2.png)](#co_working_with_a_reactive___span_class__keep_together__programming_model__span__CO4-2)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_working_with_a_reactive___span_class__keep_together__programming_model__span__CO4-2)'
- en: Publish a message to a specific address, and all consumers receive the message.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 向特定地址发布消息，所有消费者都接收该消息。
- en: '[![3](Images/3.png)](#co_working_with_a_reactive___span_class__keep_together__programming_model__span__CO4-3)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_working_with_a_reactive___span_class__keep_together__programming_model__span__CO4-3)'
- en: Send a message to a specific address, and expect a reply.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 向特定地址发送消息，并期待回复。
- en: You should have enough information to create your own version of the Greeting
    Service using Vert.x Eventing!
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该已经有足够的信息来使用 Vert.x 事件机制创建你自己的问候服务版本！
- en: Discussion
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: You can also return a `CompletionStage` to handle events in asynchronous fashion.
    Lastly, if you wish to use the `io.vertx.axle.core.eventbus.Message` as the method
    param, you may do so and get access to the rest of the message within your event
    handler.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以返回 `CompletionStage` 以异步方式处理事件。最后，如果希望使用 `io.vertx.axle.core.eventbus.Message`
    作为方法参数，可以这样做，并在事件处理程序中访问消息的其余部分。
- en: Fire-and-forget style interactions are just as easy—simply return `void` from
    your method.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 火而忘交互方式同样简单——只需从您的方法返回 `void` 即可。
- en: Warning
  id: totrans-69
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: The method consuming an event is called on the Vert.x event loop. The first
    tenet of Vert.x is to never block the event loop. Your code *must* be nonblocking.
    *If* you need the method to block, set the `blocking` attribute on `@ConsumeEvent`
    to `true`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Vert.x 事件循环上调用消耗事件的方法。Vert.x 的第一个原则是永不阻塞事件循环。您的代码 *必须* 是非阻塞的。 *如果* 需要方法阻塞，将
    `@ConsumeEvent` 上的 `blocking` 属性设置为 `true`。
- en: 'To configure the name or address of the event handler, use the `value` parameter:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置事件处理程序的名称或地址，请使用 `value` 参数：
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: See Also
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'For more information, visit the following websites:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解更多信息，请访问以下网站：
- en: '[Vert.x](https://www.vertx.io)'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Vert.x](https://www.vertx.io)'
- en: '[Vert.x: The Event Bus](https://oreil.ly/TAnxk)'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Vert.x：事件总线](https://oreil.ly/TAnxk)'
- en: 15.4 Reacting to Apache Kafka Messages
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 15.4 响应 Apache Kafka 消息
- en: Problem
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to react to Apache Kafka messages.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望响应 Apache Kafka 消息。
- en: Solution
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Quarkus makes use of Eclipse MicroProfile Reactive Messaging to interact with
    Apache Kafka.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Quarkus 利用 Eclipse MicroProfile Reactive Messaging 与 Apache Kafka 进行交互。
- en: 'The Reactive Messaging specification is built on top of three main concepts:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 反应式消息规范是建立在三个主要概念之上的：
- en: '`Message`'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Message`'
- en: '`@Incoming`'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`@Incoming`'
- en: '`@Outgoing`'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`@Outgoing`'
- en: This recipe focuses on `Message` and `@Incoming`; see [Recipe 15.5](#sending_message_apache)
    if you need to go the other direction.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方专注于 `Message` 和 `@Incoming`；如果您需要进行反向操作，请参阅[配方 15.5](#sending_message_apache)。
- en: Message
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 消息
- en: In short, a `Message` is an envelope around a payload. The envelope also carries
    with it optional metadata, though more often than not, you care only about the
    payload.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，`Message` 是围绕有效载荷的封套。封套还携带可选的元数据，尽管更多时候，您只关心有效载荷。
- en: '@Incoming annotation'
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '@Incoming 注解'
- en: 'This annotation (`org.eclipse.microprofile.reactive.messaging.Incoming`) indicates
    that the method consumes a stream of messages. The only attribute is the name
    of the name of the stream or topic. Methods are annotated this way for the end
    of a processing chain, also known as a *sink*. The following are a couple of uses
    within Quarkus:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 此注解 (`org.eclipse.microprofile.reactive.messaging.Incoming`) 表示该方法消耗消息流。唯一的属性是流或主题的名称。方法以此方式注解是为了处理链的末端，也称为
    *sink*。以下是在 Quarkus 中的几个用法：
- en: '[PRE6]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You can see that either method works; however, in the case of `processKafkaCharacter`
    it takes a `Message` and returns a `CompletionStage`. If your method receives
    a `Message` as the parameter, it *must* return a `CompletionStage`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到两种方法都可以运行；但是，在 `processKafkaCharacter` 的情况下，它接收一个 `Message` 并返回一个 `CompletionStage`。如果您的方法接收
    `Message` 作为参数，则 *必须* 返回 `CompletionStage`。
- en: If you are interested only in the payload, you don’t need to worry about any
    of that and can simply accept the type of the payload and return void, as is demonstrated
    in `processCharacter` in the previous code.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您仅对有效载荷感兴趣，则无需担心其中任何内容，可以简单接受有效载荷的类型并返回 void，就像前一个代码中的 `processCharacter`
    演示的那样。
- en: Configuration
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置
- en: 'As expected, you will need to configure your application to talk to Apache
    Kafka:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 预期地，您需要配置应用程序以与 Apache Kafka 进行通信：
- en: '[PRE7]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding code, we have multiple subscribers, so we need to use `broadcast=true`.
    The `broadcast` attribute lets MicroProfile Reactive Messaging (SmallRye is an
    implementation) know that messages received can be dispatched to more than one
    subscriber.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述代码中，我们有多个订阅者，因此需要使用 `broadcast=true`。`broadcast` 属性让 MicroProfile Reactive
    Messaging（SmallRye 是一个实现）知道接收到的消息可以分发给多个订阅者。
- en: 'The syntax of the configuration is as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 配置的语法如下：
- en: '[PRE8]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The value in the `channel-name` segment must match the value set in `@Incoming`
    (and @`Outgoing`, which is covered in the next recipe).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`channel-name` 段中的值必须与 `@Incoming` 中设置的值匹配（以及在下一个配方中涵盖的 @`Outgoing`）。'
- en: 'There are some sensible defaults that you can see in [SmallRye Reactive Messaging:
    Apache Kafka](https://oreil.ly/L5WHK).'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '您可以在 [SmallRye Reactive Messaging: Apache Kafka](https://oreil.ly/L5WHK) 中看到一些合理的默认值。'
- en: Discussion
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'To get up and running quickly with Apache Kafka in a development environment,
    you can visit the websites listed in [“See Also”](#see_also), or use the following
    *docker-compose.yml* file along with `docker-compose`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要快速在开发环境中使用 Apache Kafka，您可以访问 [“另请参阅”](#see_also) 中列出的网站，或者使用以下 *docker-compose.yml*
    文件以及 `docker-compose`：
- en: '[PRE9]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: See Also
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'For more information, visit the following:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解更多信息，请访问以下网址：
- en: '[GitHub: Reactive Messaging for MicroProfile](https://oreil.ly/DSu7u)'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[GitHub：MicroProfile 的响应式消息传递](https://oreil.ly/DSu7u)'
- en: '[SmallRye Reactive Messaging](https://oreil.ly/QlGHK)'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SmallRye 响应式消息传递](https://oreil.ly/QlGHK)'
- en: '[Apache Kafka](https://oreil.ly/6xsAP)'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Apache Kafka](https://oreil.ly/6xsAP)'
- en: '[Apache Kafka: Consumer Configs](https://oreil.ly/iE8aU)'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Apache Kafka：消费者配置](https://oreil.ly/iE8aU)'
- en: '[Vert.x Kafka client](https://oreil.ly/zFD5J)'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Vert.x Kafka 客户端](https://oreil.ly/zFD5J)'
- en: 15.5 Sending Messages to Apache Kafka
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 15.5 向 Apache Kafka 发送消息
- en: Problem
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to send messages to Apache Kafka.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 您想要发送消息到 Apache Kafka。
- en: Solution
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: First, you’ll need to add the `quarkus-smallrye-reactive-messaging-kafka` extension
    to your project. In this example, we’re also using SmallRye Mutiny, so add the
    `io.smallrye.reactive:mutiny` dependency as well.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要将 `quarkus-smallrye-reactive-messaging-kafka` 扩展添加到您的项目中。在本示例中，我们还使用了
    SmallRye Mutiny，因此还需添加 `io.smallrye.reactive:mutiny` 依赖项。
- en: To send messages to Apache Kafka, use the `@Outgoing` annotation from Eclipse
    MicroProfile Reactive Messaging.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 要将消息发送到 Apache Kafka，请使用来自 Eclipse MicroProfile Reactive Messaging 的 `@Outgoing`
    注解。
- en: When you generate data to send to Apache Kafka, you will annotate your methods
    with `org.eclipse.microprofile.reactive.messaging.Outgoing`. You can send either
    a stream of messages or a single message. If you wish to publish a stream of messages,
    you must return a `org.reactivestreams.Publisher` or a `org.eclipse.microprofile.reactive.streams.operators.PublisherBuilder`.
    If you wish to publish a single message, return a `org.eclipse.microprofile.reactive.messaging.Message`,
    `java.util.concurrent.CompletionStage`, or the corresponding type for your message
    payload.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当您生成要发送到 Apache Kafka 的数据时，您将使用 `org.eclipse.microprofile.reactive.messaging.Outgoing`
    注解您的方法。您可以发送一系列消息或单个消息。如果您希望发布一系列消息，则必须返回 `org.reactivestreams.Publisher` 或 `org.eclipse.microprofile.reactive.streams.operators.PublisherBuilder`。如果您希望发布单个消息，请返回
    `org.eclipse.microprofile.reactive.messaging.Message`、`java.util.concurrent.CompletionStage`
    或您消息负载的相应类型。
- en: 'The following is a basic example that creates a new ASCII character every second
    and sends it to the “letter-out” channel:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个基本示例，每秒创建一个新的 ASCII 字符并将其发送到 “letter-out” 通道：
- en: '[PRE10]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The value attribute for `@Outgoing` is required and is the name of the outbound
    channel. In this example, we used SmallRye Mutiny, but you could use anything
    that returns an instance of `org.reactivestreams.Publisher`; a `Flowable` from
    RXJava2, for example, would also work well.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Outgoing` 的 value 属性是必需的，是出站通道的名称。在本示例中，我们使用了 SmallRye Mutiny，但您也可以使用任何返回
    `org.reactivestreams.Publisher` 实例的内容；例如，来自 RXJava2 的 `Flowable` 也可以很好地工作。'
- en: 'The following configuration is also necessary:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要以下配置：
- en: '[PRE11]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Discussion
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'If you find yourself needing to send a message in an imperative way, you can
    use an `org.eclipse.microprofile.reactive.messaging.Emitter` injected into your
    application:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您发现自己需要以命令的方式发送消息，您可以在应用程序中注入一个 `org.eclipse.microprofile.reactive.messaging.Emitter`：
- en: '[PRE12]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: See Also
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'For more information, check out the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解更多信息，请查看以下内容：
- en: '[Recipe 15.4](#reacting_apache_kafka_messages)'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[配方 15.4](#reacting_apache_kafka_messages)'
- en: '[Apache Kafka: Producer Configs](https://oreil.ly/hZ9Bm)'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Apache Kafka：生产者配置](https://oreil.ly/hZ9Bm)'
- en: '[SmallRye Reactive Messaging](https://oreil.ly/QlGHK)'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SmallRye 响应式消息传递](https://oreil.ly/QlGHK)'
- en: 15.6 Marshalling POJOs into/out of Kafka
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 15.6 将 POJOs 编组到/从 Kafka
- en: Problem
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to serialize/deserialize POJOs into Kafka.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望将 POJOs 序列化/反序列化到 Kafka。
- en: Solution
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Quarkus has capabilities to work with JSON Kafka messages; you will need to
    select either JSONB or Jackson as an implementation. The required extensions are
    either `quarkus-resteasy-jsonb` or `quarkus-resteasy-jackson`, depending on your
    preference.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Quarkus 具有处理 JSON Kafka 消息的功能；您需要选择 JSONB 或 Jackson 作为实现。所需的扩展名为 `quarkus-resteasy-jsonb`
    或 `quarkus-resteasy-jackson`，具体取决于您的偏好。
- en: 'You will then need to create a deserializer. The easiest way to do this is
    to extend either the `JsonDeserializer` for JSONB or the `ObjectMapperDeserializer`
    for Jackson. Here is the `Book` class and its deserializer:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您需要创建一个反序列化器。最简单的方法是扩展 JSONB 的 `JsonDeserializer` 或 Jackson 的 `ObjectMapperDeserializer`。这是
    `Book` 类及其反序列化器：
- en: '[PRE13]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'For JSONB, the deserializer looks like this:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 JSONB，反序列化器如下所示：
- en: '[PRE14]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'For Jackson, it is also just as easy:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 对于杰克逊来说，这同样容易：
- en: '[PRE15]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The last bit you will need to do is to add your deserializer and the default
    serializer to the Quarkus configuration:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要做的最后一件事是将您的反序列化器和默认序列化器添加到Quarkus配置中：
- en: '[PRE16]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Or, for Jackson:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，对于Jackson：
- en: '[PRE17]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Discussion
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: If you are using JSONB and you do not wish to create a deserializer for each
    POJO sent over the wire, you can use the generic `io.vertx.kafka.client.serialization.JsonObjectDeserializer`.
    The resulting object returned will be a `javax.json.JsonObject`. Here, we have
    chosen to use the default serializers.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用JSONB并且不希望为每个通过电线发送的POJO创建反序列化器，您可以使用通用的`io.vertx.kafka.client.serialization.JsonObjectDeserializer`。返回的对象将是一个`javax.json.JsonObject`。在这里，我们选择使用默认的序列化器。
- en: You can also create your own serializers if you need something more than the
    basic functionality.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要比基本功能更多的东西，您还可以创建自己的序列化器。
- en: 15.7 Using Kafka Streams API
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 15.7 使用Kafka Streams API
- en: Problem
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to use the Kafka Streams API for querying data.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望使用Kafka Streams API来查询数据。
- en: Solution
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'The Apache Kafka extension in Quarkus (`quarkus-smallrye-reactive-messaging-kafka`)
    has integration with the Apache Kafka Streams API. This example is a bit in depth
    and requires some additional moving parts. You’ll of course need an Apache Kafka
    instance up and running. We recommend you set up an Apache Kafka instance using
    Kubernetes if you don’t already have one available. If you simply need something
    for development, you can use the following *docker-compose.yml* file:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Quarkus中的Apache Kafka扩展(`quarkus-smallrye-reactive-messaging-kafka`)与Apache
    Kafka Streams API集成。这个例子有点深奥，需要一些额外的移动部件。当然，您需要一个运行中的Apache Kafka实例。如果您还没有可用的实例，我们建议您使用Kubernetes设置一个Apache
    Kafka实例。如果您只是需要开发用的东西，您可以使用以下*docker-compose.yml*文件：
- en: '[PRE18]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The next part in this solution is to create a producer that generates values
    and sends those generated values to a Kafka topic. We’ll be using the idea of
    a jukebox for this. Our jukebox will contain a number of songs and their artists,
    as well as the number of times a song was played. Each of those will be sent to
    a different topic and then aggregated together by another service:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 此解决方案的下一部分是创建一个生成值并将这些生成的值发送到Kafka主题的生产者。我们将使用一个点唱机的概念。我们的点唱机将包含多首歌曲及其艺术家，以及歌曲播放次数。每个都将发送到不同的主题，然后由另一个服务聚合在一起：
- en: '[PRE19]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Every 500 milliseconds, a new message containing the song and the times it was
    played, along with a time stamp, is sent out to the `songs` topic. We’ll forgo
    the extra configuration—you can see steps for that in the [Recipe 15.5](#sending_message_apache)
    recipe.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 每500毫秒，一个包含歌曲及其播放次数以及时间戳的新消息将发送到`songs`主题。我们将跳过额外的配置——您可以在[食谱15.5](#sending_message_apache)中查看详细步骤。
- en: 'Next, we need to build the pipeline. The first step is to create some value
    holders:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要构建管道。第一步是创建一些值持有者：
- en: '[PRE20]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now we need a holder for a play count:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要一个播放计数器：
- en: '[PRE21]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Last, for the value holders is an object to track the aggregation of values
    while the messages are processed in the pipeline:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于值持有者，这是一个对象，用于在管道中处理消息时跟踪值的聚合：
- en: '[PRE22]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, on to the magic! The last part of the puzzle is streaming the query implementation.
    We only need to define a method that is a CDI producer that returns an Apache
    Kafka Stream `Topology`. Quarkus will take care of the configuration, and the
    life cycle will take care of the Kafka Streams engine:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，进入魔法部分！拼图的最后一部分是流式查询实现。我们只需要定义一个作为CDI生产者的方法，返回一个Apache Kafka Stream `Topology`。Quarkus将负责配置，生命周期将处理Kafka
    Streams引擎：
- en: '[PRE23]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Explaining all of what is happening is beyond the scope of this recipe, but
    the Kafka Streams site, linked to in [“See Also”](#see-also-15-7), has entire
    tutorials and videos dedicated to this topic. In a nutshell, this connects to
    the previous `songs` and `song-values` topic then merges the values together based
    on song ID. The play count values then have some aggregation performed on them,
    and the output is sent back to Apache Kafka on a new topic.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 解释所有发生的事情超出了本教程的范围，但是Kafka Streams站点在[“另请参阅”](#see-also-15-7)中链接了完整的教程和视频专门讨论此主题。简而言之，这将连接到先前的`songs`和`song-values`主题，然后根据歌曲ID合并值。然后对播放计数值执行一些聚合操作，并将输出发送回Apache
    Kafka到一个新主题。
- en: Discussion
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: We recommend using the `kafkacat` utility for seeing the messages as they are
    sent to the topics.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议使用`kafkacat`工具来查看发送到主题的消息。
- en: Important
  id: totrans-170
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 重要
- en: In both of the examples with Apache Kafka we connected with only a single client
    and machine. This is not a limitation of Quarkus but something we have done to
    help simplify the examples.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个Apache Kafka示例中，我们仅连接了单个客户端和机器。这不是Quarkus的限制，而是我们为了简化示例而做的。
- en: See Also
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'For more information, visit the following websites:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 欲知详情，请访问以下网站：
- en: '[Apache Kafka: Kafka Streams](https://oreil.ly/gNAof)'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Apache Kafka：Kafka Streams](https://oreil.ly/gNAof)'
- en: '[Confluent: kafkacat Utility](https://oreil.ly/bgIT_)'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Confluent：kafkacat 实用工具](https://oreil.ly/bgIT_)'
- en: 15.8 Using AMQP with Quarkus
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 15.8 使用 AMQP 与 Quarkus
- en: Problem
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to use AMQP (Advanced Message Queuing Protocol) as the messaging system.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望使用AMQP（高级消息队列协议）作为消息系统。
- en: Solution
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the `quarkus-smallrye-reactive-messaging-amqp` extension.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`quarkus-smallrye-reactive-messaging-amqp`扩展。
- en: Just like the Kafka integration, Quarkus uses Eclipse MicroProfile Reactive
    Messaging as the facade around all messaging interactions. By adding the `quarkus-smallrye-reactive-messaging-amqp`
    extension to your project, you will get the SmallRye AMQP connector and associated
    dependencies. This will allow `@Outbound`, `@Inbound`, `@Broadcast`, and other
    Eclipse MicroProfile Reactive Messaging annotations and concepts to work with
    AMQP.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 就像Kafka集成一样，Quarkus使用Eclipse MicroProfile Reactive Messaging作为所有消息交互的外观。通过向您的项目添加`quarkus-smallrye-reactive-messaging-amqp`扩展，您将获得SmallRye
    AMQP连接器及其相关依赖项。这将使得`@Outbound`、`@Inbound`、`@Broadcast`和其他Eclipse MicroProfile
    Reactive Messaging注解和概念可以与AMQP一起工作。
- en: Warning
  id: totrans-182
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: These annotations work with AMQP 1.0, not 0.9.x.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这些注解适用于AMQP 1.0，不适用于0.9.x。
- en: 'You will also need to set the channel connector to `smallrye-amqp` in the *application.properties*
    file. Remember that the syntax for those configurations is the following:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要在*application.properties*文件中将通道连接器设置为`smallrye-amqp`。请记住，这些配置的语法如下：
- en: '[PRE24]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You can also set the username and password for AMQP connections globally via
    the following:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过以下方式全局设置AMQP连接的用户名和密码：
- en: '[PRE25]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Or, if you need to talk to different instances with their own credentials, you
    may set those on a per-channel basis. Please see the SmallRye documentation for
    further properties.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果您需要与具有自己凭据的不同实例通信，可以在每个通道上设置这些凭据。详细属性请参阅SmallRye文档。
- en: The code from [Recipe 15.5](#sending_message_apache) will work exactly the same
    with AMQP as it will with Kafka, assuming that the channels are the same name
    and that the rest of the AMQP setup and connection information are correct.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 从[Recipe 15.5](#sending_message_apache)中的代码，无论是用AMQP还是Kafka，只要通道名称相同且AMQP设置和连接信息正确，都能正常工作。
- en: See Also
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'For more information, visit the following website:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 欲知详情，请访问以下网站：
- en: '[SmallRye Reactive Messaging: AMQP 1.0](https://oreil.ly/ViPyo)'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SmallRye 响应式消息传递：AMQP 1.0](https://oreil.ly/ViPyo)'
- en: 15.9 Using MQTT
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 15.9 使用 MQTT
- en: Problem
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to use MQTT (MQ Telemetry Transport) as the messaging system.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望使用MQTT（MQ Telemetry Transport）作为消息系统。
- en: Solution
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the `quarkus-smallrye-reactive-messaging-mqtt` extension.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`quarkus-smallrye-reactive-messaging-mqtt`扩展。
- en: Just like the Kafka and AMQP integration, Quarkus uses Eclipse MicroProfile
    Reactive Messaging as the facade around all messaging interactions. By adding
    the `quarkus-smallrye-reactive-messaging-mqtt` extension to your project, you
    will get the SmallRye MQTT connector and associated dependencies. This will allow
    `@Outbound`, `@Inbound`, `@Broadcast`, and other Eclipse MicroProfile Reactive
    Messaging annotations and concepts to work with MQTT.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 就像Kafka和AMQP集成一样，Quarkus使用Eclipse MicroProfile Reactive Messaging作为所有消息交互的外观。通过向您的项目添加`quarkus-smallrye-reactive-messaging-mqtt`扩展，您将获得SmallRye
    MQTT连接器及其相关依赖项。这将使得`@Outbound`、`@Inbound`、`@Broadcast`和其他Eclipse MicroProfile
    Reactive Messaging注解和概念可以与MQTT一起工作。
- en: 'You will also need to set the channel connector to `smallrye-mqtt` in the *application.properties*
    file. Remember, the syntax for those configurations is the following:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要在*application.properties*文件中将通道连接器设置为`smallrye-mqtt`。请记住，这些配置的语法如下：
- en: '[PRE26]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Connection and credentials can be set on a channel-by-channel basis. Please
    see the SmallRye documentation for further properties.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 连接和凭据可以按通道设置。详细属性请参阅SmallRye文档。
- en: The code from [Recipe 15.4](#reacting_apache_kafka_messages) will work exactly
    the same with MQTT as it will with Kafka, assuming that the channels have the
    same name and that the rest of the MQTT setup is correct along with the connection
    information.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '[配方15.4](#reacting_apache_kafka_messages)的代码与MQTT一样适用于Kafka，假设通道名称相同，并且其余的MQTT设置及连接信息正确。'
- en: Discussion
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: There is also support for acting as an MQTT server; however, it is not a fully
    featured MQTT server. For example, it will handle only publish requests and their
    acknowledgment; it does not handle subscription requests.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 还支持作为MQTT服务器使用；但是，它不是一个完整功能的MQTT服务器。例如，它只处理发布请求及其确认；不处理订阅请求。
- en: See Also
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'For more information, visit the following website:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解更多信息，请访问以下网站：
- en: '[SmallRye Reactive Messaging: MQTT](https://oreil.ly/QmkVY)'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SmallRye响应式消息传递：MQTT](https://oreil.ly/QmkVY)'
- en: 15.10 Query Using Reactive SQL
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 15.10 使用响应式SQL进行查询
- en: Problem
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to query data using the PostgreSQL reactive client.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望使用PostgreSQL响应式客户端查询数据。
- en: Solution
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Quarkus integrates with the Vert.x Reactive SQL client, which works with MySQL/MariaDB,
    and PostgreSQL. In this recipe, we will be demonstrating this with PostgreSQL;
    in the following recipe we will use MariaDB.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: Quarkus集成了Vert.x响应式SQL客户端，可与MySQL/MariaDB和PostgreSQL配合使用。在这个示例中，我们将演示与PostgreSQL的集成；在下一个示例中，我们将使用MariaDB。
- en: 'Naturally, you will need to add an extension to utilize the reactive SQL client.
    Currently, there are two of them: `quarkus-reactive-pg-client` and `quarkus-reactive-mysql-client`,
    respective to the two databases. You will also need to ensure that the following
    extensions are in your project (if you are using JAX-RS):'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，您需要添加扩展以利用响应式SQL客户端。目前有两个扩展：`quarkus-reactive-pg-client`和`quarkus-reactive-mysql-client`，分别适用于这两个数据库。如果您正在使用JAX-RS，则还需要确保项目中包含以下扩展：
- en: '`quarkus-resteasy`'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`quarkus-resteasy`'
- en: '`quarkus-resteasy-jsonb` or `quarkus-resteasy-jackson`'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`quarkus-resteasy-jsonb`或`quarkus-resteasy-jackson`'
- en: '`quarkus-resteasy-mutiny`'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`quarkus-resteasy-mutiny`'
- en: 'Just as with any data store, you will need to configure access:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 就像使用任何数据存储一样，您需要配置访问：
- en: '[PRE27]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now you can use the client:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以使用客户端：
- en: '[PRE28]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[![1](Images/1.png)](#co_working_with_a_reactive___span_class__keep_together__programming_model__span__CO5-1)'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_working_with_a_reactive___span_class__keep_together__programming_model__span__CO5-1)'
- en: Query the database, returning a `Uni<RowSet<Row>>`
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 查询数据库，返回`Uni<RowSet<Row>>`
- en: '[![2](Images/2.png)](#co_working_with_a_reactive___span_class__keep_together__programming_model__span__CO5-2)'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_working_with_a_reactive___span_class__keep_together__programming_model__span__CO5-2)'
- en: Create a `Multi<Row>` once the query returns
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦查询返回，创建`Multi<Row>`
- en: '[![3](Images/3.png)](#co_working_with_a_reactive___span_class__keep_together__programming_model__span__CO5-3)'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_working_with_a_reactive___span_class__keep_together__programming_model__span__CO5-3)'
- en: Map each row into a `Book` instance
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 将每一行映射为`Book`实例
- en: 'To complete the exercise, you can use the RESTful endpoint:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成练习，您可以使用RESTful端点：
- en: '[PRE29]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Discussion
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'You can also use prepared queries by using the `preparedQuery` method and the
    `Tuple` class:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过使用`preparedQuery`方法和`Tuple`类来使用预准备查询：
- en: '[PRE30]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[![1](Images/1.png)](#co_working_with_a_reactive___span_class__keep_together__programming_model__span__CO6-1)'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_working_with_a_reactive___span_class__keep_together__programming_model__span__CO6-1)'
- en: Using metadata, return from the `RowSet` instance to verify the row was deleted
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 使用元数据从`RowSet`实例返回以验证已删除的行
- en: See Also
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'The underlying implementation can be found at [Vert.x: Reactive PostgreSQL
    Client](https://oreil.ly/0nuDM).'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '底层实现可以在[Vert.x: 响应式PostgreSQL客户端](https://oreil.ly/0nuDM)找到。'
- en: 15.11 Insert Using Reactive SQL Client
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 15.11 使用响应式SQL客户端进行插入
- en: Problem
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to insert data using the MySQL reactive client.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望使用MySQL响应式客户端插入数据。
- en: Solution
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Similar to the previous recipe using PostgreSQL, data insertion can be done
    with a reactive MySQL client. The same extensions need to be used to changed the
    `quarkus-reactive-pg-client` for `quarkus-reactive-mysql-client`:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用PostgreSQL的上一个示例类似，可以使用响应式MySQL客户端进行数据插入。需要使用相同的扩展来将`quarkus-reactive-pg-client`更改为`quarkus-reactive-mysql-client`：
- en: '`quarkus-resteasy`'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`quarkus-resteasy`'
- en: '`quarkus-resteasy-jsonb` or `quarkus-resteasy-jackson`'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`quarkus-resteasy-jsonb`或`quarkus-resteasy-jackson`'
- en: '`quarkus-resteasy-mutiny`'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`quarkus-resteasy-mutiny`'
- en: 'You will, of course, need to set up the datasource:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您需要设置数据源：
- en: '[PRE31]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You will see very similar themes in the `Book.save` method as you did in the
    previous recipe:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在`Book.save`方法中看到与上一个示例中相似的主题：
- en: '[PRE32]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[![1](Images/1.png)](#co_working_with_a_reactive___span_class__keep_together__programming_model__span__CO7-1)'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_working_with_a_reactive___span_class__keep_together__programming_model__span__CO7-1)'
- en: Use the property from the `RowSet` to get the inserted ID.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`RowSet`的属性获取插入的 ID。
- en: By now, you should be able to put together the appropriate POST method for the
    `BookResource` endpoint, calling the `save` method on the new `Book` instance
    received from the user.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您应该能够为`BookResource`端点编写适当的 POST 方法，调用从用户接收到的新`Book`实例的`save`方法。
- en: See Also
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'For more information, visit the following website:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解更多信息，请访问以下网站：
- en: '[Vert.x: Reactive MySQL Client](https://oreil.ly/UHxfh)'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Vert.x：Reactive MySQL 客户端](https://oreil.ly/UHxfh)'
- en: 15.12 Using the Reactive MongoDB Client
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 15.12 使用反应式 MongoDB 客户端
- en: Problem
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to use the Reactive MongoDB client.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 您想要使用反应式 MongoDB 客户端。
- en: Solution
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'The MongoDB Quarkus extension also includes a reactive MongoDB client. As was
    shown in [Recipe 7.21](ch07.xhtml#working_mongodb), you will need to add the `quarkus-mongodb-client`.
    You will also need to add the following extensions to your project:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB Quarkus 扩展还包括反应式 MongoDB 客户端。如[配方 7.21](ch07.xhtml#working_mongodb)所示，您需要添加`quarkus-mongodb-client`。您还需要向项目添加以下扩展：
- en: '`quarkus-resteasy-mutiny`'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`quarkus-resteasy-mutiny`'
- en: To return and interact with Mutiny for endpoint returns.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 为了返回和与 Mutiny 交互以进行端点返回。
- en: '`quarkus-smallrye-context-propagation`'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`quarkus-smallrye-context-propagation`'
- en: This allows things like injection and transactions to work with async code.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许像注入和事务这样的事情与异步代码一起工作。
- en: 'The rest of the integration is pretty straightforward. Here are the versions
    of the service and the resource classes from the previous MongoDB recipe, but
    written in a reactive way:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 集成的其余部分非常简单。这里是从先前的 MongoDB 配方中的服务和资源类的版本，但以反应式方式编写：
- en: '[PRE33]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Besides imports and moving from an imperative to a reactive approach with Mutiny,
    nothing has changed. The same can be seen for the REST endpoint:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 除了导入和从命令式转变为反应式使用 Mutiny，没有什么改变。同样适用于 REST 终点：
- en: '[PRE34]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: See Also
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'For more information, visit the following website:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解更多信息，请访问以下网站：
- en: '[Quarkus: Context Propagation in Quarkus](https://oreil.ly/bd9hA)'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Quarkus：Quarkus 中的上下文传播](https://oreil.ly/bd9hA)'
- en: 15.13 Using the Reactive Neo4j Client
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 15.13 使用反应式 Neo4j 客户端
- en: Problem
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to use the reactive Neo4j client.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 您想要使用反应式 Neo4j 客户端。
- en: Solution
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: The Neo4j Quarkus extension has support for the reactive driver.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: Neo4j Quarkus 扩展支持反应式驱动程序。
- en: 'You will need to use version 4 or higher of Neo4j to go fully reactive. You
    will also need to add the `quarkus-resteasy-mutiny` extension to your project.
    Following up from [Recipe 7.23](ch07.xhtml#neo4j_with_quarkus), there isn’t much
    that has changed, besides using an `RxSession` from the driver and using Mutiny:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要使用 4 版或更高版本的 Neo4j 完全反应式。您还需要向项目添加`quarkus-resteasy-mutiny`扩展。从[配方 7.23](ch07.xhtml#neo4j_with_quarkus)继续，除了使用驱动程序的`RxSession`和使用
    Mutiny 外，没有太多改变：
- en: '[PRE35]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[![1](Images/1.png)](#co_working_with_a_reactive___span_class__keep_together__programming_model__span__CO8-3)'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_working_with_a_reactive___span_class__keep_together__programming_model__span__CO8-3)'
- en: Get an `RxSession` from the driver
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 从驱动程序获取`RxSession`
- en: '[![2](Images/2.png)](#co_working_with_a_reactive___span_class__keep_together__programming_model__span__CO8-2)'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_working_with_a_reactive___span_class__keep_together__programming_model__span__CO8-2)'
- en: Use Mutiny to interact with the ReactiveStreams `Publisher`
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Mutiny 与 ReactiveStreams `Publisher` 进行交互
- en: '[![3](Images/3.png)](#co_working_with_a_reactive___span_class__keep_together__programming_model__span__CO8-1)'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_working_with_a_reactive___span_class__keep_together__programming_model__span__CO8-1)'
- en: Stream the results back to the user
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 将结果流式传输回用户
- en: '[![4](Images/4.png)](#co_working_with_a_reactive___span_class__keep_together__programming_model__span__CO8-4)'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](Images/4.png)](#co_working_with_a_reactive___span_class__keep_together__programming_model__span__CO8-4)'
- en: Close the session at the very end
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后关闭会话
