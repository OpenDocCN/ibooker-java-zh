- en: Chapter 15\. Working with a Reactive Programming Model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are all familiar with the client-server architecture that has dominated enterprise
    software development for decades. However, we have recently had a shift in architecture
    styles. In addition to the standard client-server approach, we have message-driven
    applications, microservices, reactive applications, and even serverless! All of
    these types of applications are possible to create using Quarkus. In the follow
    recipes, you’ll learn about reactive programming models, message buses, and streaming.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Quarkus (and this book!) makes use of SmallRye Mutiny for its reactive library.
    You can read more about Mutiny at [SmallRye Mutiny](https://oreil.ly/nBP7H). There
    is also support for RxJava and Reactor, but they are not the preferred choice.
    To use either of them, you will need to use converters from Mutiny.
  prefs: []
  type: TYPE_NORMAL
- en: 15.1 Creating Async HTTP Endpoints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to create an async HTTP endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Quarkus has integrations with Java Streams, the Eclipse MicroProfile Reactive
    spec, and SmallRye Mutiny. These integrations make it easy to support an asynchronous
    HTTP endpoint. The first thing you will need to do is determine which libraries
    you wish to use. If you wish to use native Streams or the MicroProfile Reactive
    specification, you will need to add the `quarkus-smallrye-reactive-streams-operators`
    extension. If you want to use SmallRye Mutiny, add the `quarkus-resteasy-mutiny`
    extension to your project.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Going forward, Mutiny will be the preferred library within Quarkus for all things
    reactive.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the extension is in place, all you need to do with your HTTP endpoints
    is return a reactive class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_working_with_a_reactive___span_class__keep_together__programming_model__span__CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Naturally, any valid `MediaType` is valid; for simplicity, we used plain text
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_working_with_a_reactive___span_class__keep_together__programming_model__span__CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: '`CompletionStage` comes from the `java.util.concurrent` package'
  prefs: []
  type: TYPE_NORMAL
- en: 'For Mutiny, this example becomes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For more information, visit the following websites:'
  prefs: []
  type: TYPE_NORMAL
- en: '[SmallRye Mutiny](https://oreil.ly/nBP7H)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[SmallRye Reactive Streams Operators](https://oreil.ly/Ab8eo)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Reactive Streams](https://oreil.ly/pgyMk)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 15.2 Streaming Data Asynchronously
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to stream data in an async way.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Very similar to creating an asynchronous HTTP endpoint, Quarkus allows you
    to stream events from your application using server-sent events or server-side
    events (SSE). What you will need to do in this case is to return a `Publisher`
    and tell JAX-RS that your endpoint produces `MediaType.SERVER_SENT_EVENTS`. Here’s
    an example that streams a `long` every 500 milliseconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_working_with_a_reactive___span_class__keep_together__programming_model__span__CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you tell JAX-RS you are using SSEs
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_working_with_a_reactive___span_class__keep_together__programming_model__span__CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The return type for the method must be a `org.reactivestream.Publisher` from
    the Reactive Streams library
  prefs: []
  type: TYPE_NORMAL
- en: With Mutiny, a `Multi` is a `Publisher`, making this even easier by simply returning
    a `Multi`.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For more information, visit the following websites:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Wikiwand: Server-Sent Events](https://oreil.ly/m0cAC)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[MDN Web Docs: Using server-sent events](https://oreil.ly/ZIX4X)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 15.3 Using Messaging to Decouple Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to use messaging to decouple components.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the underlying/bundled frameworks used by Quarkus is Vert.x. Vert.x is
    a framework for building asynchronous, event-driven, reactive applications, much
    like Quarkus! Quarkus makes use of the Vert.x Event Bus for sending and receiving
    events/messages with decoupled classes.
  prefs: []
  type: TYPE_NORMAL
- en: To make use of Vert.x, just like many features with Quarkus, you will need to
    add the proper extension to your application. The name for the Vert.x extension
    is `vertx`.
  prefs: []
  type: TYPE_NORMAL
- en: Handling events/messages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We’ll first take a look at listening to or consuming events. The easiest way
    to consume events in Quarkus is to use the `io.quarkus.vertx.ConsumeEvent` annotation.
    `@ConsumeEvent` has attributes, which we’ll get to, but let’s see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_working_with_a_reactive___span_class__keep_together__programming_model__span__CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: With no value set, the address of the event is the fully qualified name of the
    bean; in this case, it would be `com.acme.vertx.GreetingService`
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_working_with_a_reactive___span_class__keep_together__programming_model__span__CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The parameter for the consumer is the message body; if the method returns anything,
    it is packaged as the message response
  prefs: []
  type: TYPE_NORMAL
- en: Sending events/messages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To send an event, you will be interacting with the Vert.x Event Bus. You can
    obtain the instance via injection: `@Inject io.vertx.axle.core.eventbus.EventBus
    bus`. You will be primarily making use of two methods on the event bus:'
  prefs: []
  type: TYPE_NORMAL
- en: '`send`'
  prefs: []
  type: TYPE_NORMAL
- en: Sends a message and optionally expects a reply
  prefs: []
  type: TYPE_NORMAL
- en: '`publish`'
  prefs: []
  type: TYPE_NORMAL
- en: Publishes a message to each listener
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_working_with_a_reactive___span_class__keep_together__programming_model__span__CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Send a message to a specific address, and a single consumer receives it, then
    forget about the response.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_working_with_a_reactive___span_class__keep_together__programming_model__span__CO4-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Publish a message to a specific address, and all consumers receive the message.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_working_with_a_reactive___span_class__keep_together__programming_model__span__CO4-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Send a message to a specific address, and expect a reply.
  prefs: []
  type: TYPE_NORMAL
- en: You should have enough information to create your own version of the Greeting
    Service using Vert.x Eventing!
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can also return a `CompletionStage` to handle events in asynchronous fashion.
    Lastly, if you wish to use the `io.vertx.axle.core.eventbus.Message` as the method
    param, you may do so and get access to the rest of the message within your event
    handler.
  prefs: []
  type: TYPE_NORMAL
- en: Fire-and-forget style interactions are just as easy—simply return `void` from
    your method.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The method consuming an event is called on the Vert.x event loop. The first
    tenet of Vert.x is to never block the event loop. Your code *must* be nonblocking.
    *If* you need the method to block, set the `blocking` attribute on `@ConsumeEvent`
    to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To configure the name or address of the event handler, use the `value` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For more information, visit the following websites:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Vert.x](https://www.vertx.io)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Vert.x: The Event Bus](https://oreil.ly/TAnxk)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 15.4 Reacting to Apache Kafka Messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to react to Apache Kafka messages.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Quarkus makes use of Eclipse MicroProfile Reactive Messaging to interact with
    Apache Kafka.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Reactive Messaging specification is built on top of three main concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Message`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`@Incoming`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`@Outgoing`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This recipe focuses on `Message` and `@Incoming`; see [Recipe 15.5](#sending_message_apache)
    if you need to go the other direction.
  prefs: []
  type: TYPE_NORMAL
- en: Message
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In short, a `Message` is an envelope around a payload. The envelope also carries
    with it optional metadata, though more often than not, you care only about the
    payload.
  prefs: []
  type: TYPE_NORMAL
- en: '@Incoming annotation'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This annotation (`org.eclipse.microprofile.reactive.messaging.Incoming`) indicates
    that the method consumes a stream of messages. The only attribute is the name
    of the name of the stream or topic. Methods are annotated this way for the end
    of a processing chain, also known as a *sink*. The following are a couple of uses
    within Quarkus:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: You can see that either method works; however, in the case of `processKafkaCharacter`
    it takes a `Message` and returns a `CompletionStage`. If your method receives
    a `Message` as the parameter, it *must* return a `CompletionStage`.
  prefs: []
  type: TYPE_NORMAL
- en: If you are interested only in the payload, you don’t need to worry about any
    of that and can simply accept the type of the payload and return void, as is demonstrated
    in `processCharacter` in the previous code.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As expected, you will need to configure your application to talk to Apache
    Kafka:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have multiple subscribers, so we need to use `broadcast=true`.
    The `broadcast` attribute lets MicroProfile Reactive Messaging (SmallRye is an
    implementation) know that messages received can be dispatched to more than one
    subscriber.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax of the configuration is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The value in the `channel-name` segment must match the value set in `@Incoming`
    (and @`Outgoing`, which is covered in the next recipe).
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some sensible defaults that you can see in [SmallRye Reactive Messaging:
    Apache Kafka](https://oreil.ly/L5WHK).'
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To get up and running quickly with Apache Kafka in a development environment,
    you can visit the websites listed in [“See Also”](#see_also), or use the following
    *docker-compose.yml* file along with `docker-compose`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For more information, visit the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[GitHub: Reactive Messaging for MicroProfile](https://oreil.ly/DSu7u)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[SmallRye Reactive Messaging](https://oreil.ly/QlGHK)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Apache Kafka](https://oreil.ly/6xsAP)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Apache Kafka: Consumer Configs](https://oreil.ly/iE8aU)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Vert.x Kafka client](https://oreil.ly/zFD5J)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 15.5 Sending Messages to Apache Kafka
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to send messages to Apache Kafka.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, you’ll need to add the `quarkus-smallrye-reactive-messaging-kafka` extension
    to your project. In this example, we’re also using SmallRye Mutiny, so add the
    `io.smallrye.reactive:mutiny` dependency as well.
  prefs: []
  type: TYPE_NORMAL
- en: To send messages to Apache Kafka, use the `@Outgoing` annotation from Eclipse
    MicroProfile Reactive Messaging.
  prefs: []
  type: TYPE_NORMAL
- en: When you generate data to send to Apache Kafka, you will annotate your methods
    with `org.eclipse.microprofile.reactive.messaging.Outgoing`. You can send either
    a stream of messages or a single message. If you wish to publish a stream of messages,
    you must return a `org.reactivestreams.Publisher` or a `org.eclipse.microprofile.reactive.streams.operators.PublisherBuilder`.
    If you wish to publish a single message, return a `org.eclipse.microprofile.reactive.messaging.Message`,
    `java.util.concurrent.CompletionStage`, or the corresponding type for your message
    payload.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a basic example that creates a new ASCII character every second
    and sends it to the “letter-out” channel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The value attribute for `@Outgoing` is required and is the name of the outbound
    channel. In this example, we used SmallRye Mutiny, but you could use anything
    that returns an instance of `org.reactivestreams.Publisher`; a `Flowable` from
    RXJava2, for example, would also work well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following configuration is also necessary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you find yourself needing to send a message in an imperative way, you can
    use an `org.eclipse.microprofile.reactive.messaging.Emitter` injected into your
    application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For more information, check out the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Recipe 15.4](#reacting_apache_kafka_messages)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Apache Kafka: Producer Configs](https://oreil.ly/hZ9Bm)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[SmallRye Reactive Messaging](https://oreil.ly/QlGHK)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 15.6 Marshalling POJOs into/out of Kafka
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to serialize/deserialize POJOs into Kafka.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Quarkus has capabilities to work with JSON Kafka messages; you will need to
    select either JSONB or Jackson as an implementation. The required extensions are
    either `quarkus-resteasy-jsonb` or `quarkus-resteasy-jackson`, depending on your
    preference.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will then need to create a deserializer. The easiest way to do this is
    to extend either the `JsonDeserializer` for JSONB or the `ObjectMapperDeserializer`
    for Jackson. Here is the `Book` class and its deserializer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'For JSONB, the deserializer looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'For Jackson, it is also just as easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The last bit you will need to do is to add your deserializer and the default
    serializer to the Quarkus configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, for Jackson:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you are using JSONB and you do not wish to create a deserializer for each
    POJO sent over the wire, you can use the generic `io.vertx.kafka.client.serialization.JsonObjectDeserializer`.
    The resulting object returned will be a `javax.json.JsonObject`. Here, we have
    chosen to use the default serializers.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create your own serializers if you need something more than the
    basic functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 15.7 Using Kafka Streams API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to use the Kafka Streams API for querying data.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Apache Kafka extension in Quarkus (`quarkus-smallrye-reactive-messaging-kafka`)
    has integration with the Apache Kafka Streams API. This example is a bit in depth
    and requires some additional moving parts. You’ll of course need an Apache Kafka
    instance up and running. We recommend you set up an Apache Kafka instance using
    Kubernetes if you don’t already have one available. If you simply need something
    for development, you can use the following *docker-compose.yml* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The next part in this solution is to create a producer that generates values
    and sends those generated values to a Kafka topic. We’ll be using the idea of
    a jukebox for this. Our jukebox will contain a number of songs and their artists,
    as well as the number of times a song was played. Each of those will be sent to
    a different topic and then aggregated together by another service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Every 500 milliseconds, a new message containing the song and the times it was
    played, along with a time stamp, is sent out to the `songs` topic. We’ll forgo
    the extra configuration—you can see steps for that in the [Recipe 15.5](#sending_message_apache)
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to build the pipeline. The first step is to create some value
    holders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need a holder for a play count:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Last, for the value holders is an object to track the aggregation of values
    while the messages are processed in the pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, on to the magic! The last part of the puzzle is streaming the query implementation.
    We only need to define a method that is a CDI producer that returns an Apache
    Kafka Stream `Topology`. Quarkus will take care of the configuration, and the
    life cycle will take care of the Kafka Streams engine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Explaining all of what is happening is beyond the scope of this recipe, but
    the Kafka Streams site, linked to in [“See Also”](#see-also-15-7), has entire
    tutorials and videos dedicated to this topic. In a nutshell, this connects to
    the previous `songs` and `song-values` topic then merges the values together based
    on song ID. The play count values then have some aggregation performed on them,
    and the output is sent back to Apache Kafka on a new topic.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We recommend using the `kafkacat` utility for seeing the messages as they are
    sent to the topics.
  prefs: []
  type: TYPE_NORMAL
- en: Important
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In both of the examples with Apache Kafka we connected with only a single client
    and machine. This is not a limitation of Quarkus but something we have done to
    help simplify the examples.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For more information, visit the following websites:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Apache Kafka: Kafka Streams](https://oreil.ly/gNAof)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Confluent: kafkacat Utility](https://oreil.ly/bgIT_)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 15.8 Using AMQP with Quarkus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to use AMQP (Advanced Message Queuing Protocol) as the messaging system.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the `quarkus-smallrye-reactive-messaging-amqp` extension.
  prefs: []
  type: TYPE_NORMAL
- en: Just like the Kafka integration, Quarkus uses Eclipse MicroProfile Reactive
    Messaging as the facade around all messaging interactions. By adding the `quarkus-smallrye-reactive-messaging-amqp`
    extension to your project, you will get the SmallRye AMQP connector and associated
    dependencies. This will allow `@Outbound`, `@Inbound`, `@Broadcast`, and other
    Eclipse MicroProfile Reactive Messaging annotations and concepts to work with
    AMQP.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: These annotations work with AMQP 1.0, not 0.9.x.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will also need to set the channel connector to `smallrye-amqp` in the *application.properties*
    file. Remember that the syntax for those configurations is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also set the username and password for AMQP connections globally via
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Or, if you need to talk to different instances with their own credentials, you
    may set those on a per-channel basis. Please see the SmallRye documentation for
    further properties.
  prefs: []
  type: TYPE_NORMAL
- en: The code from [Recipe 15.5](#sending_message_apache) will work exactly the same
    with AMQP as it will with Kafka, assuming that the channels are the same name
    and that the rest of the AMQP setup and connection information are correct.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For more information, visit the following website:'
  prefs: []
  type: TYPE_NORMAL
- en: '[SmallRye Reactive Messaging: AMQP 1.0](https://oreil.ly/ViPyo)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 15.9 Using MQTT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to use MQTT (MQ Telemetry Transport) as the messaging system.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the `quarkus-smallrye-reactive-messaging-mqtt` extension.
  prefs: []
  type: TYPE_NORMAL
- en: Just like the Kafka and AMQP integration, Quarkus uses Eclipse MicroProfile
    Reactive Messaging as the facade around all messaging interactions. By adding
    the `quarkus-smallrye-reactive-messaging-mqtt` extension to your project, you
    will get the SmallRye MQTT connector and associated dependencies. This will allow
    `@Outbound`, `@Inbound`, `@Broadcast`, and other Eclipse MicroProfile Reactive
    Messaging annotations and concepts to work with MQTT.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will also need to set the channel connector to `smallrye-mqtt` in the *application.properties*
    file. Remember, the syntax for those configurations is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Connection and credentials can be set on a channel-by-channel basis. Please
    see the SmallRye documentation for further properties.
  prefs: []
  type: TYPE_NORMAL
- en: The code from [Recipe 15.4](#reacting_apache_kafka_messages) will work exactly
    the same with MQTT as it will with Kafka, assuming that the channels have the
    same name and that the rest of the MQTT setup is correct along with the connection
    information.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is also support for acting as an MQTT server; however, it is not a fully
    featured MQTT server. For example, it will handle only publish requests and their
    acknowledgment; it does not handle subscription requests.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For more information, visit the following website:'
  prefs: []
  type: TYPE_NORMAL
- en: '[SmallRye Reactive Messaging: MQTT](https://oreil.ly/QmkVY)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 15.10 Query Using Reactive SQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to query data using the PostgreSQL reactive client.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Quarkus integrates with the Vert.x Reactive SQL client, which works with MySQL/MariaDB,
    and PostgreSQL. In this recipe, we will be demonstrating this with PostgreSQL;
    in the following recipe we will use MariaDB.
  prefs: []
  type: TYPE_NORMAL
- en: 'Naturally, you will need to add an extension to utilize the reactive SQL client.
    Currently, there are two of them: `quarkus-reactive-pg-client` and `quarkus-reactive-mysql-client`,
    respective to the two databases. You will also need to ensure that the following
    extensions are in your project (if you are using JAX-RS):'
  prefs: []
  type: TYPE_NORMAL
- en: '`quarkus-resteasy`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`quarkus-resteasy-jsonb` or `quarkus-resteasy-jackson`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`quarkus-resteasy-mutiny`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Just as with any data store, you will need to configure access:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can use the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_working_with_a_reactive___span_class__keep_together__programming_model__span__CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Query the database, returning a `Uni<RowSet<Row>>`
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_working_with_a_reactive___span_class__keep_together__programming_model__span__CO5-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `Multi<Row>` once the query returns
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_working_with_a_reactive___span_class__keep_together__programming_model__span__CO5-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Map each row into a `Book` instance
  prefs: []
  type: TYPE_NORMAL
- en: 'To complete the exercise, you can use the RESTful endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can also use prepared queries by using the `preparedQuery` method and the
    `Tuple` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_working_with_a_reactive___span_class__keep_together__programming_model__span__CO6-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Using metadata, return from the `RowSet` instance to verify the row was deleted
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The underlying implementation can be found at [Vert.x: Reactive PostgreSQL
    Client](https://oreil.ly/0nuDM).'
  prefs: []
  type: TYPE_NORMAL
- en: 15.11 Insert Using Reactive SQL Client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to insert data using the MySQL reactive client.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Similar to the previous recipe using PostgreSQL, data insertion can be done
    with a reactive MySQL client. The same extensions need to be used to changed the
    `quarkus-reactive-pg-client` for `quarkus-reactive-mysql-client`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`quarkus-resteasy`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`quarkus-resteasy-jsonb` or `quarkus-resteasy-jackson`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`quarkus-resteasy-mutiny`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You will, of course, need to set up the datasource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see very similar themes in the `Book.save` method as you did in the
    previous recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_working_with_a_reactive___span_class__keep_together__programming_model__span__CO7-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Use the property from the `RowSet` to get the inserted ID.
  prefs: []
  type: TYPE_NORMAL
- en: By now, you should be able to put together the appropriate POST method for the
    `BookResource` endpoint, calling the `save` method on the new `Book` instance
    received from the user.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For more information, visit the following website:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Vert.x: Reactive MySQL Client](https://oreil.ly/UHxfh)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 15.12 Using the Reactive MongoDB Client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to use the Reactive MongoDB client.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The MongoDB Quarkus extension also includes a reactive MongoDB client. As was
    shown in [Recipe 7.21](ch07.xhtml#working_mongodb), you will need to add the `quarkus-mongodb-client`.
    You will also need to add the following extensions to your project:'
  prefs: []
  type: TYPE_NORMAL
- en: '`quarkus-resteasy-mutiny`'
  prefs: []
  type: TYPE_NORMAL
- en: To return and interact with Mutiny for endpoint returns.
  prefs: []
  type: TYPE_NORMAL
- en: '`quarkus-smallrye-context-propagation`'
  prefs: []
  type: TYPE_NORMAL
- en: This allows things like injection and transactions to work with async code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rest of the integration is pretty straightforward. Here are the versions
    of the service and the resource classes from the previous MongoDB recipe, but
    written in a reactive way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Besides imports and moving from an imperative to a reactive approach with Mutiny,
    nothing has changed. The same can be seen for the REST endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For more information, visit the following website:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Quarkus: Context Propagation in Quarkus](https://oreil.ly/bd9hA)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 15.13 Using the Reactive Neo4j Client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to use the reactive Neo4j client.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Neo4j Quarkus extension has support for the reactive driver.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will need to use version 4 or higher of Neo4j to go fully reactive. You
    will also need to add the `quarkus-resteasy-mutiny` extension to your project.
    Following up from [Recipe 7.23](ch07.xhtml#neo4j_with_quarkus), there isn’t much
    that has changed, besides using an `RxSession` from the driver and using Mutiny:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_working_with_a_reactive___span_class__keep_together__programming_model__span__CO8-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Get an `RxSession` from the driver
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_working_with_a_reactive___span_class__keep_together__programming_model__span__CO8-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Use Mutiny to interact with the ReactiveStreams `Publisher`
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_working_with_a_reactive___span_class__keep_together__programming_model__span__CO8-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Stream the results back to the user
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_working_with_a_reactive___span_class__keep_together__programming_model__span__CO8-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Close the session at the very end
  prefs: []
  type: TYPE_NORMAL
