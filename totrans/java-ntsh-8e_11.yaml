- en: Chapter 9\. Handling Common Data Formats
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第九章。处理常见数据格式
- en: Most of programming is handling data in various formats. In this chapter, we
    will introduce Java’s support for handling two big classes of data—text and numbers.
    The second half of the chapter will focus on handling date and time information.
    This is of particular interest, as Java 8 shipped a completely new API for handling
    date and time. We cover this interface in some depth before finishing the chapter
    by briefly discussing Java’s original date and time API.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编程是处理各种格式的数据。在本章中，我们将介绍Java处理两类重要数据——文本和数字的支持。本章的后半部分将专注于处理日期和时间信息。这尤其重要，因为Java
    8发布了完全新的API来处理日期和时间。在讨论Java的原始日期和时间API之前，我们会对这个接口进行深入讨论。
- en: Many applications are still using the legacy APIs, so developers need to be
    aware of the old way of doing things, but the new APIs are so much better that
    we recommend converting as soon as possible. Before we get to those more complex
    formats, let’s get under way by talking about textual data and strings.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 许多应用程序仍在使用旧的API，因此开发人员需要了解旧方法，但新的API要好得多，我们建议尽快转换。在我们开始处理更复杂的格式之前，让我们先讨论文本数据和字符串。
- en: Text
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文本
- en: We have already met Java’s strings on many occasions. They consist of sequences
    of Unicode characters and are represented as instances of the `String` class.
    Strings are one of the most common types of data that Java programs process (a
    claim you can investigate for yourself by using the `jmap` tool that we’ll meet
    in [Chapter 13](ch13.xhtml#javanut8-CHP-13)).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在许多场合见过Java的字符串。它们由Unicode字符序列组成，并表示为`String`类的实例。字符串是Java程序处理的最常见数据类型之一（您可以通过使用我们将在[第13章](ch13.xhtml#javanut8-CHP-13)中介绍的`jmap`工具自行验证这一点）。
- en: In this section, we’ll meet the `String` class in some more depth and understand
    why it is in a rather unique position within the Java language. Later in the section,
    we’ll introduce regular expressions, a very common abstraction for searching text
    for patterns (and a classic tool in the programmer’s arsenal, regardless of language).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将更深入地了解`String`类，并理解它在Java语言中处于相当独特的位置。在本节的后面，我们将介绍正则表达式，这是一种非常常见的用于搜索文本模式的抽象（无论编程语言如何，都是程序员工具箱中的经典工具）。
- en: Special Syntax for Strings
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串的特殊语法
- en: The `String` class is handled in a somewhat special way by the Java language.
    This is because, despite not being a primitive type, strings are so common that
    it makes sense for Java to have a number of special syntax features designed to
    make handling strings easy. Let’s look at some examples of special syntax features
    for strings that Java provides.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '`String`类在Java语言中以一种略微特殊的方式处理。这是因为尽管它不是原始类型，但字符串是如此常见，以至于Java具有许多特殊的语法功能，旨在使字符串处理变得容易。让我们看看Java为字符串提供的一些特殊语法功能的示例。'
- en: String literals
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串字面量
- en: 'As we saw in [Chapter 2](ch02.xhtml#javanut8-CHP-2), Java allows a sequence
    of characters to be placed in double quotes to create a literal string object.
    Like this:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第2章](ch02.xhtml#javanut8-CHP-2)中看到的，Java允许将一系列字符放置在双引号中以创建文字字符串对象。就像这样：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Without this special syntax, we would have to write acres of horrible code
    like this:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有这种特殊语法，我们将不得不编写像这样可怕的大量代码：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This would get tedious extremely quickly, so it’s no surprise that Java, like
    all modern programming languages, provides a simple string literal syntax. The
    string literals are perfectly sound objects, so code like this is completely legal:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法很快就会变得枯燥乏味，所以毫无意外，像所有现代编程语言一样，Java 提供了简单的字符串字面量语法。字符串字面量是完全合法的对象，因此像下面这样的代码完全合法：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Strings using basic double quotes cannot span multiple lines, but recent versions
    of Java have included multiline text blocks with the `"""` syntax. The resulting
    string objects are created at compile-time and are no different than a `"` quoted
    string, just easier to express:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基本双引号的字符串不能跨越多行，但是最近版本的Java已经包括了使用`"""`语法的多行文本块。生成的字符串对象在编译时创建，并且与`"`引号括起来的字符串没有区别，只是更易于表达：
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: See [“String literals”](ch02.xhtml#javanut8-CHP-2-SECT-7.5) for complete coverage
    of string literals in Java.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[“字符串字面量”](ch02.xhtml#javanut8-CHP-2-SECT-7.5)了解Java中字符串字面量的完整覆盖。
- en: toString()
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: toString()
- en: 'This method is defined on `Object` and is designed to allow easy conversion
    of any object to a string. This makes it easy to print out any object, by using
    the method `System.out.println()`. This method is actually `PrintStream::println`
    because `System.out` is a static field of type `PrintStream`. Let’s see how this
    method is defined:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法在`Object`上定义，旨在允许将任何对象轻松转换为字符串。这使得可以通过使用`System.out.println()`方法轻松打印出任何对象。实际上，该方法是`PrintStream::println`，因为`System.out`是一个类型为`PrintStream`的静态字段。让我们看看该方法的定义：
- en: '[PRE4]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This creates a new string by using the static method `String::valueOf()`:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这通过使用静态方法`String::valueOf()`创建一个新的字符串：
- en: '[PRE5]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-23
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The static `valueOf()` method is used instead of `toString()` directly, to avoid
    a `NullPointerException` in the case where `obj` is `null`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 静态的`valueOf()`方法用于代替直接调用`toString()`，以避免在`obj`为`null`时抛出`NullPointerException`。
- en: 'This construction means that `toString()` is always available for any object,
    and this comes in very handy for another major syntax feature that Java provides:
    string concatenation.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这种构造方式意味着`toString()`对于任何对象始终可用，这对Java提供的另一个主要语法特性非常有用：字符串连接。
- en: String concatenation
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串连接
- en: Java allows us to create new strings by “adding” the characters from one string
    onto the end of another. This is called *string concatenation* and uses the operator
    `+`. In versions of Java up to and including Java 8, it works by first creating
    a “working area” in the form of a `StringBuilder` object that contains the same
    sequence of characters as the original string.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Java允许我们通过将一个字符串的字符“添加”到另一个字符串的末尾来创建新的字符串。这称为*字符串连接*，并使用`+`运算符。在Java 8及以下版本中，它的工作原理是首先创建一个`StringBuilder`对象作为“工作区”，其中包含与原始字符串相同的字符序列。
- en: Note
  id: totrans-28
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Java 9 introduced a new mechanism that uses the `invokedynamic` instruction
    instead of `StringBuilder` directly. This is an advanced piece of functionality
    and out of scope for this discussion, but it doesn’t change the behavior visible
    to the Java developer.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9 引入了一种新的机制，使用`invokedynamic`指令而不是直接使用`StringBuilder`。这是一种高级功能，超出了本讨论的范围，但不会改变对Java开发人员可见的行为。
- en: The builder object is then updated and the characters from the additional string
    are added onto the end. Finally, `toString()` is called on the `StringBuilder`
    object (which now contains the characters from both strings). This gives us a
    new string with all the characters in it. All of this code is created automatically
    by `javac` whenever we use the `+` operator to concatenate strings.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然后更新构建器对象，并将附加字符串的字符添加到末尾。最后，在`StringBuilder`对象上调用`toString()`（现在包含来自两个字符串的字符）。这给了我们一个包含所有字符的新字符串。无论何时使用`+`运算符连接字符串，`javac`都会自动创建所有这些代码。
- en: 'The concatenation process returns a completely new `String` object, as we can
    see in this example:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 连接过程返回一个全新的`String`对象，正如我们在这个例子中所见：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The concatenation example directly shows that the `+` operator is not altering
    (or *mutating*) `s1` in place. This is an example of a more general principle:
    Java’s strings are immutable. This means that once the characters that make up
    the string have been chosen and the `String` object has been created, the `String`
    cannot be changed. This is an important language principle in Java, so let’s look
    at it in a little more depth.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 连接示例直接显示了`+`运算符不会直接修改（或*突变*）`s1`。这是一个更一般的原则示例：Java的字符串是不可变的。这意味着一旦选择了组成字符串的字符并创建了`String`对象，那么这个`String`就不能被改变。这是Java中一个重要的语言原则，让我们稍微深入了解一下。
- en: String Immutability
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串的不可变性
- en: 'To “change” a string, as we saw when we discussed string concatenation, we
    actually need to create an intermediate `StringBuilder` object to act as a temporary
    scratch area, and then call `toString()` on it, to bake it into a new instance
    of `String`. Let’s see how this works in code:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要“改变”一个字符串，就像我们讨论字符串连接时看到的那样，实际上需要创建一个中间的`StringBuilder`对象作为临时的工作区，并在其上调用`toString()`，以将其转换为一个新的`String`实例。让我们看看代码是如何工作的：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Code like this behaves equivalently to the following, although in Java 9 and
    above the actual bytecode sequences will differ:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样的代码在行为上等效于以下内容，尽管在Java 9及以上版本中实际的字节码序列将有所不同：
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Of course, as well as being used under the hood by `javac`, the `StringBuilder`
    class can also be used directly in application code, as we’ve seen.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，除了在`javac`下使用之外，`StringBuilder`类也可以直接在应用程序代码中使用，我们已经看到了这一点。
- en: Warning
  id: totrans-40
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Along with `StringBuilder`, Java also has a `StringBuffer` class. This comes
    from the oldest versions of Java and should not be used for new development—use
    `StringBuilder` instead, unless you really need to share the construction of a
    new string between multiple threads.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `StringBuilder`，Java 还有一个 `StringBuffer` 类。这来自 Java 的最古老版本，不应该用于新开发——应该使用
    `StringBuilder`，除非你确实需要在多个线程之间共享新字符串的构造。
- en: String immutability is an extremely useful language feature. For example, suppose
    the `+` changed a string instead of creating a new one; then, whenever any thread
    concatenated two strings, all other threads would also see the change. This is
    unlikely to be a useful behavior for most programs, and so immutability makes
    good sense.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串的不可变性是一种非常有用的语言特性。例如，假设 `+` 修改了字符串而不是创建新的字符串；那么，每当任何线程连接两个字符串时，所有其他线程也会看到这种变化。对于大多数程序来说，这不太可能是有用的行为，因此不可变性是合理的选择。
- en: Hash codes and effective immutability
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 哈希码和有效不可变性
- en: 'We have already met the `hashCode()` method in [Chapter 5](ch05.xhtml#javanut8-CHP-5),
    where we described the contract that the method must satisfy. Let’s take a look
    at the JDK source code and see how the method `String::hashCode()` is defined:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在 [第5章](ch05.xhtml#javanut8-CHP-5) 中遇到了 `hashCode()` 方法，我们描述了该方法必须满足的合约。让我们看一下
    JDK 源代码，看看 `String::hashCode()` 方法是如何定义的：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The field `hash` holds the hash code of the string, and the field `value` is
    a `char[]` that holds the characters that actually make up the string. As we can
    see from the code, Java computes the hash by looping over all the characters of
    the string. It therefore takes a number of machine instructions proportional to
    the number of characters in the string. For very large strings, this could take
    a bit of time. Rather than precompute the hash value, Java calculates it only
    when it is needed.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 字段 `hash` 存储了字符串的哈希码，而字段 `value` 是一个 `char[]`，存储了构成字符串的实际字符。从代码中可以看出，Java 通过循环遍历字符串的所有字符来计算哈希值。因此，计算机指令的数量与字符串中的字符数成正比。对于非常大的字符串，这可能需要一些时间。Java
    不会预先计算哈希值，而是在需要时才计算。
- en: When the method runs, the hash is computed by stepping through the array of
    characters. At the end of the array, we exit the `for` loop and write the computed
    hash back into the field `hash`. Now, when this method is called again, the value
    has already been computed, so we can just use the cached value and subsequent
    calls to `hashCode()` return immediately.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当方法运行时，通过遍历字符数组来计算哈希值。在数组的末尾，我们退出 `for` 循环并将计算得到的哈希值写回到 `hash` 字段中。现在，当再次调用此方法时，值已经被计算过了，所以我们可以直接使用缓存的值，后续调用
    `hashCode()` 将立即返回。
- en: Note
  id: totrans-48
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The computation of a string’s hash code is an example of a *benign data race*.
    In a program with multiple threads, they could race to compute the hash code.
    However, they would all eventually arrive at exactly the same answer—hence the
    term *benign*.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串的哈希码计算是一个*良性数据竞争*的例子。在具有多个线程的程序中，它们可能会竞争计算哈希码。但是，它们最终会得出完全相同的答案，因此称为*良性*。
- en: All of the fields of the `String` class are final, except for `hash`. So Java’s
    strings are not, strictly speaking, immutable. However, because the `hash` field
    is just a cache of a value that is deterministically computed from the other fields,
    which are all immutable then, provided `String` has been coded correctly, it will
    behave as if it were immutable. Classes that have this property are called *effectively
    immutable*—they are quite rare in practice, and working programmers can usually
    ignore the distinction between truly immutable and effectively immutable data.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`String` 类的所有字段都是 `final` 的，除了 `hash`。因此，Java 的字符串严格来说并不是不可变的。但是，因为 `hash`
    字段只是从其他所有不可变字段中确定性计算的值的缓存，只要 `String` 类被正确编码，它就会表现得像是不可变的。具有这种属性的类称为*有效不可变*——它们在实践中非常罕见，工作程序员通常可以忽略真正不可变和有效不可变数据之间的区别。'
- en: String Formatting
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串格式化
- en: In [“String concatenation”](#javanut8-CHP-9-string-concatenation), we saw how
    Java supports building strings from smaller strings by joining them. While this
    works, it can often be tedious and error prone when constructing more elaborate
    output strings. Java provides a number of other methods and classes for doing
    richer string formatting.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [“字符串连接”](#javanut8-CHP-9-string-concatenation) 中，我们看到 Java 如何支持通过连接较小的字符串来构建更大的字符串。虽然这很有效，但在构造更复杂的输出字符串时，这往往会变得单调和容易出错。Java
    提供了许多其他方法和类来进行更丰富的字符串格式化。
- en: 'The static method `format` on the `String` class allows us to specify a template
    and then dynamically plug in various values:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`String`类上的静态方法`format`允许我们指定一个模板，然后动态地插入各种值：'
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Placeholders in the format string where values will be introduced start with
    the `%` character. In this example, we substitute an integer with `%d`, a string
    with `%s`, a boolean with `%b`, and finally end the string with a newline via
    `%n`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 格式字符串中的占位符，其中将引入值，以`%`字符开始。在这个例子中，我们用`%d`替换整数，用`%s`替换字符串，用`%b`替换布尔值，并最终用`%n`换行。
- en: Those with a background in C or similar languages will recognize this format
    from the venerable `printf` function. Java supports many, though not all, of the
    same formats with a wide variety of options. Java’s `printf` also provides more
    sophisticated date and time formatting as seen in C’s `strftime` function. See
    the Java documentation on `java.util.Formatter` for the full list of options available.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 那些在C或类似语言中有背景的人会从这个受人尊敬的`printf`函数中认识到这种格式。Java支持许多相同的格式，尽管不是全部，具有各种各样的选项。Java的`printf`还提供了更复杂的日期和时间格式化，就像在C的`strftime`函数中看到的一样。请参阅Java文档中的`java.util.Formatter`，了解可用的所有选项的完整列表。
- en: Java also improves on the experience using these format strings by throwing
    exceptions on invalid conditions such as mismatched numbers of placeholders to
    values, or unrecognized `%` values.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Java还通过在出现无效条件时抛出异常来改进使用这些格式字符串的体验，比如占位符与值的数量不匹配，或者无法识别的`%`值。
- en: '`String.format()` provides powerful tools for constructing complex strings
    but, particularly when making output correct across countries, more assistance
    is needed. `NumberFormat` is an example of classes Java provides to support more
    complex, locale-aware formatting of values. Other formatters are also available
    under `java.text`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`String.format()`提供了构建复杂字符串的强大工具，但是，特别是在使输出在各个国家正确时，需要更多的帮助。 `NumberFormat`是Java提供的支持更复杂的、与区域设置相关的值格式化的类的一个示例。其他格式化程序也可以在`java.text`下找到：'
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Regular Expressions
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 正则表达式
- en: Java has support for *regular* *expressions* (often shortened to *regex* or
    *regexp*). These are a representation of a search pattern used to scan and match
    text. A regex is a sequence of characters that we want to search for. They can
    be very simple—for example, `abc` means that we’re looking for *a*, followed immediately
    by *b*, followed immediately by *c*, anywhere within the text we’re searching.
    Note that a search pattern may match an input text in zero, one, or more places.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Java支持*正则表达式*（通常缩写为*regex*或*regexp*）。这些是用于扫描和匹配文本的搜索模式的表示。正则表达式是我们要搜索的字符序列。它们可以非常简单——例如，`abc`表示我们正在搜索的文本中的任何位置的*a*，后面紧跟着*b*，后面紧跟着*c*。请注意，搜索模式可能在输入文本中匹配零个、一个或多个位置。
- en: 'The simplest regexes are just sequences of literal characters, like `abc`.
    However, the language of regexes can express more complex and subtle ideas than
    just literal sequences. For example, a regex can represent patterns to match like:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的正则表达式只是文本的字面字符序列，比如`abc`。然而，正则表达式的语言可以表达比字面序列更复杂、更微妙的想法。例如，正则表达式可以表示如下所示的匹配模式：
- en: A numeric digit
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字字符
- en: Any letter
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任意字母
- en: Any number of letters, which must all be in the range *a* to *j* but can be
    upper- or lowercase
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任意数量的字母，它们必须都在*a*到*j*的范围内，但可以是大写或小写
- en: '*a* followed by any four characters, followed by *b*'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*a*后面跟着任意四个字符，然后是*b*'
- en: The syntax we use to write regular expressions is simple, but because we can
    build complex patterns, it is often possible to write an expression that does
    not implement precisely what we wanted. When using regexes, it is very important
    to always test them fully. This should include both test cases that should pass
    and cases that should fail.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用来编写正则表达式的语法很简单，但是由于我们可以构建复杂的模式，通常可以编写一个没有精确实现我们想要的内容的表达式。在使用正则表达式时，全面测试它们非常重要。这应该包括应该通过的测试用例和应该失败的情况。
- en: 'To express these more complex patterns, regexes use *metacharacters*. These
    are special characters that indicate special processing is required. This can
    be thought of as similar to the use of the `*` character in operating system shells.
    In those circumstances, it is understood that the `*` is not to be interpreted
    literally but instead means “anything.” If we wanted to list all the Java source
    files in the current directory on Unix, we would issue the command:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了表达这些更复杂的模式，正则表达式使用*元字符*。这些是指示需要特殊处理的特殊字符。这可以类比于操作系统 shell 中使用 `*` 字符的用法。在这些情况下，理解
    `*` 不是字面上解释，而是表示“任何东西”。如果我们想在 Unix 的当前目录中列出所有的 Java 源文件，我们会发出以下命令：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The metacharacters of regexes are similar, but there are far more of them, and
    they are far more flexible than the set available in shells. They also have different
    meanings than they do in shell scripts, so don’t get confused.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式的元字符是相似的，但它们的数量要多得多，并且比 shell 中可用的集合要灵活得多。它们的含义也不同于它们在 shell 脚本中的含义，因此不要感到困惑。
- en: Warning
  id: totrans-71
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Many different flavors of regular expression patterns exist in the world. Java’s
    is PCRE-compatible, supporting a common set of metacharacters popularized by the
    Perl programming language. Be aware though that a random regex found online may
    or may not actually work, whatever regex libraries you are using.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 世界上存在许多不同的正则表达式模式。Java 的正则表达式与 PCRE 兼容，支持一组常见的 Perl 编程语言中广泛使用的元字符。但请注意，网上找到的随机正则表达式可能实际上可能有效，也可能无效，取决于你使用的正则表达式库。
- en: Let’s meet a couple of examples. Suppose we want to have a spell-checking program
    that is relaxed about the difference in spelling between British and American
    English. This means that *honor* and *honour* should both be accepted as valid
    spelling choices. This is easy to do with regular expressions.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看几个例子。假设我们想要一个拼写检查程序，它对英式英语和美式英语之间的拼写差异宽松。这意味着 *honor* 和 *honour* 都应该被接受为有效的拼写选择。这在正则表达式中很容易做到。
- en: 'Java uses a class called `Pattern` (from the package `java.util.regex`) to
    represent a regex. This class can’t be directly instantiated, however. Instead,
    new instances are created by using a static factory method, `compile()`. From
    a pattern, we then derive a `Matcher` for a particular input string that we can
    use to explore the input string. For example, let’s examine a bit of Shakespeare
    from the play *Julius Caesar*:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Java 使用一个称为 `Pattern`（来自包 `java.util.regex`）的类来表示正则表达式。但是，这个类不能直接实例化。相反，通过使用静态工厂方法
    `compile()` 来创建新实例。然后，从模式派生一个 `Matcher` 用于特定输入字符串，我们可以用它来探索输入字符串。例如，让我们来看一下莎士比亚戏剧
    *凯撒大帝* 中的一部分：
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note
  id: totrans-76
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Be careful when using `Matcher`, as it has a method called `matches()`. However,
    this method indicates whether the pattern can cover the entire input string. It
    will return `false` if the pattern starts matching only in the middle of the string.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `Matcher` 时要小心，因为它有一个名为 `matches()` 的方法。但是，这个方法指示模式是否可以覆盖整个输入字符串。如果模式只在字符串中间开始匹配，它将返回
    `false`。
- en: 'The last example introduces our first regex metacharacter `?`, in the pattern
    `honou?r`. This means “the preceding character is optional”—so both `honour` and
    `honor` will match. Let’s look at another example. Suppose we want to match both
    *minimize* and *minimise* (the latter spelling is more common in British English).
    We can use square brackets to indicate that any character from a set (but only
    one alternative) `[]` can be used—like this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个示例介绍了我们的第一个正则表达式元字符 `?`，在模式 `honou?r` 中。这意味着“前面的字符是可选的”——所以 `honour` 和 `honor`
    都将匹配。让我们看另一个例子。假设我们想匹配 *minimize* 和 *minimise*（后一种拼写在英国英语中更常见）。我们可以使用方括号来指示可以从集合中选择任何一个字符（但只能有一个备选项）`[]`——就像这样：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[Table 9-1](#javanut8-CHP-9-TABLE-1) provides an expanded list of metacharacters
    available for Java regexes.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 9-1](#javanut8-CHP-9-TABLE-1)提供了Java正则表达式中可用的扩展元字符列表。'
- en: Table 9-1\. Regex metacharacters
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 表 9-1\. 正则表达式元字符
- en: '| Metacharacter | Meaning | Notes |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| 元字符 | 含义 | 注释 |'
- en: '| --- | --- | --- |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `?` | Optional character—zero or one instance |  |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `?` | 可选字符——零个或一个实例 |  |'
- en: '| `*` | Zero or more of preceding character |  |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `*` | 前面字符的零个或多个 |  |'
- en: '| `+` | One or more of preceding character |  |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `+` | 前面字符的一个或多个 |  |'
- en: '| `{M,N}` | Between `M` and `N` instances of preceding character |  |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `{M,N}` | 在前面字符的 `M` 和 `N` 个实例之间 |  |'
- en: '| `\d` | A digit |  |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `\d` | 一个数字 |  |'
- en: '| `\D` | A nondigit character |  |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `\D` | 一个非数字字符 |  |'
- en: '| `\w` | A word character | Digits, letters, and `_` |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `\w` | 一个单词字符 | 数字，字母和 `_` |'
- en: '| `\W` | A nonword character |  |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `\W` | 一个非单词字符 |  |'
- en: '| `\s` | A whitespace character |  |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `\s` | 空白字符 |  |'
- en: '| `\S` | A nonwhitespace character |  |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `\S` | 非空白字符 |  |'
- en: '| `\n` | Newline character |  |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `\n` | 换行符 |  |'
- en: '| `\t` | Tab character |  |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `\t` | 制表符 |  |'
- en: '| `.` | Any single character | Does not include newline in Java |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `.` | 任意单个字符 | 在Java中不包括换行符 |'
- en: '| `[ ]` | Any character contained with the brackets | Called a character class
    |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `[ ]` | 方括号中的任何字符 | 称为字符类 |'
- en: '| `[^ ]` | Any character not contained with the brackets | Called a negated
    character class |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `[^ ]` | 不在方括号中的任何字符 | 称为否定字符类 |'
- en: '| `( )` | Build up a group of pattern elements | Called a group (or capturing
    group) |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `( )` | 构建模式元素组 | 称为组（或捕获组） |'
- en: '| `&#124;` | Define alternative possibilities | Implements logical `OR` |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `&#124;` | 定义替代可能性 | 实现逻辑`OR` |'
- en: '| `^` | Start of string |  |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `^` | 字符串开头 |  |'
- en: '| `$` | End of string |  |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `$` | 字符串结尾 |  |'
- en: '| `\\` | Literal escape (`\`) char |  |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `\\` | 字面转义（`\\`）字符 |  |'
- en: 'There are a few more, but this is the basic list. The `java.util.regex.Pattern`
    Java documentation is a good source for all the details. From this, we can construct
    more complex expressions for matching such as the examples given earlier in this
    section:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些其他内容，但这是基本列表。`java.util.regex.Pattern`的Java文档是获取所有详细信息的良好来源。通过这些信息，我们可以构建更复杂的匹配表达式，比如本节前面提到的示例：
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Regexes are extremely useful for determining when a string matches a given
    pattern, but they also allow for extracting bits and pieces from the strings as
    well. This is done through the *group* mechanism, which is represented in the
    patterns by `()`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式极其有用，可以确定字符串是否与给定模式匹配，还可以从字符串中提取片段。这是通过*组*机制完成的，模式中通过`()`表示：
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The call to `Matcher.group(1)` returns the text that the regex matched in the
    `(\\d*)` of our pattern. Multiple groups are allowed, along with syntax for naming
    groups rather than using them by position. See the Java documentation for full
    details.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`Matcher.group(1)`返回我们模式中`(\\d*)`匹配的文本。允许多个组，还有通过名称而非位置使用组的语法。详细信息请参阅Java文档。
- en: 'A common difficulty working with regular expressions is the need to use escape
    characters for both the Java string and the regular expression. Where text blocks
    have less escaping—such as quote characters—they can provide for less cluttered
    expressions:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 处理正则表达式时的一个常见困难是需要同时为Java字符串和正则表达式使用转义字符。文本块中少了一些转义字符，比如引号字符，它们可以提供更清晰的表达：
- en: '[PRE17]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let’s conclude our quick tour of regular expressions by meeting a new method
    that was added to `Pattern` as part of Java 8: `asPredicate()`. This method is
    present to allow us to easily bridge from regular expressions to the Java Collections
    and their new support for lambda expressions.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过介绍Java 8中作为`Pattern`的一部分新增的方法`asPredicate()`来结束我们对正则表达式的快速导览。该方法的存在使我们能够轻松地从正则表达式过渡到Java集合及其对lambda表达式的新支持。
- en: 'For example, suppose we have a regex and a collection of strings. It’s very
    natural to ask the question: “Which strings match against the regex?” We do this
    by using the filter idiom and by converting the regex to a `Predicate` using the
    helper method, like this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有一个正则表达式和一组字符串。很自然地会问一个问题：“哪些字符串与该正则表达式匹配？”我们可以使用过滤惯用法，并使用辅助方法将正则表达式转换为`Predicate`，像这样：
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Java’s built-in support for text processing is more than adequate for the majority
    of text-processing tasks that business applications normally require. More advanced
    tasks, such as the search and processing of very large data sets, or complex parsing
    (including formal grammars), are outside the scope of this book, but Java has
    a large ecosystem of helpful libraries and bindings to specialized technologies
    for text processing and analysis.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Java内置的文本处理支持对于大多数商业应用通常需要的文本处理任务已经足够。更高级的任务，例如搜索和处理非常大的数据集，或复杂的解析（包括形式语法），超出了本书的范围，但Java拥有大量有用的库和专门技术的绑定，用于文本处理和分析。
- en: Numbers and Math
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数字和数学
- en: In this section, we will discuss Java’s support for numeric types in some more
    detail. In particular, we’ll discuss the two’s complement representation of integral
    types that Java uses. We’ll introduce floating-point representations and touch
    on some of the problems they can cause. We’ll also work through examples that
    use some of Java’s library functions for standard mathematical operations.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们将更详细地讨论Java对数值类型的支持。特别是，我们将讨论Java使用的整数类型的二进制补码表示。我们将介绍浮点数的表示方式，并涉及它们可能引起的一些问题。我们还将通过一些使用Java标准数学操作库函数的示例来说明。
- en: How Java Represents Integer Types
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Java如何表示整数类型
- en: Java’s integer types are all signed, as we first mentioned in [“Primitive Data
    Types”](ch02.xhtml#javanut8-CHP-2-SECT-3). This means that all integer types can
    represent both positive and negative numbers. As computers work with binary, this
    means that the only really logical way to represent this is to split the possible
    bit patterns and use half of them to represent negative numbers.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Java的整数类型都是有符号的，正如我们在[“原始数据类型”](ch02.xhtml#javanut8-CHP-2-SECT-3)中首次提到的那样。这意味着所有整数类型都可以表示正数和负数。由于计算机使用二进制，这意味着表示这些数字的唯一合理方式是分割可能的位模式并使用其中一半来表示负数。
- en: 'Let’s work with Java’s `byte` type to investigate how Java represents integers.
    This has 8 bits so can represent 256 different numbers (i.e., 128 negative and
    128 nonnegative numbers). It’s logical to use the pattern `0b0000_0000` to represent
    zero (recall that Java has the syntax `0b<binary digits>` to represent numbers
    as binary), and then it’s easy to figure out the bit patterns for the positive
    numbers:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用Java的`byte`类型来研究Java如何表示整数。它有8位，因此可以表示256个不同的数字（即128个负数和128个非负数）。用`0b0000_0000`模式表示零是合乎逻辑的（回忆一下Java使用`0b<二进制数字>`的语法来表示二进制数），然后可以轻松地找出正数的位模式：
- en: '[PRE19]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: When we set the first bit of the byte, the sign should change (as we have now
    used up all of the bit patterns that we’ve set aside for nonnegative numbers).
    So the pattern `0b1000_0000` should represent some negative number—but which one?
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们设置字节的第一个位时，符号会改变（因为我们已经用完了为非负数保留的所有位模式）。所以模式`0b1000_0000`应该表示某个负数——但是具体是哪个呢？
- en: Note
  id: totrans-122
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'As a consequence of how we’ve defined things, in this representation we have
    a very simple way to identify whether a bit pattern corresponds to a negative
    number: if the high-end bit of a bit pattern is a `1`, then the number being represented
    is negative.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们定义的方式，我们可以很简单地识别出一个位模式是否表示负数：如果位模式的最高位是`1`，则表示的数字是负数。
- en: 'Consider the bit pattern consisting of all set bits: `0b1111_1111`. If we add
    `1` to this number, then the result will overflow the 8 bits of storage that a
    `byte` has, resulting in `0b1_0000_0000`. If we want to constrain this to fit
    within the `byte` data type, then we should ignore the overflow, so this becomes
    `0b0000_0000`, otherwise known as zero. It is therefore natural to adopt the representation
    that “all set bits represent `-1`.” This allows for natural arithmetic behavior,
    like this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个由所有位设置为1的位模式：`0b1111_1111`。如果我们给这个数字加上`1`，结果会溢出一个`byte`类型的8位存储空间，导致`0b1_0000_0000`。如果我们希望将其限制在`byte`数据类型内，则应忽略溢出，因此这变为`0b0000_0000`，也就是零。因此，自然地采用“所有位设置为1表示`-1`”的表示方式。这样可以实现自然的算术行为，如下所示：
- en: '[PRE20]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Finally, let’s look at the number that `0b1000_0000` represents. It’s the most
    negative number that the type can represent, so for `byte`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看一下`0b1000_0000`表示的数字。它是该类型可以表示的最负的数字，所以对于`byte`类型：
- en: '[PRE21]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This representation, called *two’s complement*, is the most common representation
    for signed integers. To use it effectively, you need to remember only two points:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这种表示方式被称为*二进制补码*，是有符号整数最常见的表示方式。要有效使用它，你只需记住两点：
- en: A bit pattern of all 1’s is the representation for −1.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个所有位为1的模式表示为-1。
- en: If the high bit is set, the number is negative.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果最高位设置为1，则数字为负数。
- en: Java’s other integer types (`short`, `int`, and `long`) behave in very similar
    ways but with more bits in their representation. The `char` data type is different
    because it represents a Unicode character, but in some ways it behaves as an unsigned
    16-bit numeric type. It is not normally regarded as an integer type by Java programmers.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Java的其他整数类型（`short`、`int`和`long`）的行为方式非常相似，但其表示中包含更多的位数。`char`数据类型不同，因为它表示Unicode字符，但在某些方面它的行为类似于无符号的16位数值类型。在Java程序员眼中，它通常不被视为整数类型。
- en: Java and Floating-Point Numbers
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Java 和浮点数
- en: 'Computers represent numbers using binary. We’ve seen how Java uses the two’s
    complement representation for integers. But what about fractions or decimals?
    Java, like almost all modern programming languages, represents them using *floating-point*
    *arithmetic*. Let’s take a look at how this works, first in base-10 (regular decimal)
    and then in binary. Java defines the two most important mathematical constants,
    `e` and `π` (pi), as constants in `java.lang.Math` like this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机使用二进制表示数字。我们已经看到Java如何使用补码表示整数。但是对于分数或小数呢？Java和几乎所有现代编程语言一样，使用*浮点算术*来表示它们。让我们首先看看这是如何工作的，首先是十进制，然后是二进制。Java将两个最重要的数学常数，`e`和`π`（pi），定义为`java.lang.Math`中的常量，如下：
- en: '[PRE22]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Of course, these constants are actually *irrational numbers* and cannot be
    precisely expressed as a fraction, or by any finite decimal number.^([1](ch09.xhtml#idm45927717366112))
    This means that whenever we try to represent them in a computer, there is always
    rounding error. Let’s suppose we only want to deal with eight digits of π, and
    we want to represent the digits as a whole number. We can use a representation
    like this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这些常数实际上是*无理数*，不能精确地表示为分数或任何有限小数。^([1](ch09.xhtml#idm45927717366112)) 这意味着每当我们尝试在计算机中表示它们时，总会存在舍入误差。假设我们只想处理π的八位数，我们希望将这些数字表示为一个整数。我们可以使用以下表示方法：
- en: '`314159265 • 10^(–8)`'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`314159265 • 10^(–8)`'
- en: '[PRE23]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: double d = 0.3;
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: double d = 0.3;
- en: System.out.println(d); // Special-cased to avoid ugly representation
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(d); // 为了避免丑陋的表示而特别处理
- en: double d2 = 0.2;
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: double d2 = 0.2;
- en: // Should be -0.1 but prints -0.09999999999999998
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: // 应该是 -0.1，但打印出 -0.09999999999999998
- en: System.out.println(d2 - d);
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(d2 - d);
- en: '[PRE24]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: double d = 0.3;
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: double d = 0.3;
- en: System.out.println(d);
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(d);
- en: BigDecimal bd = new BigDecimal(d);
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: BigDecimal bd = new BigDecimal(d);
- en: System.out.println(bd);
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(bd);
- en: bd = new BigDecimal("0.3");
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: bd = new BigDecimal("0.3");
- en: System.out.println(bd);
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(bd);
- en: '[PRE25]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: bd = new BigDecimal(BigInteger.ONE);
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: bd = new BigDecimal(BigInteger.ONE);
- en: bd.divide(new BigDecimal(3.0));
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: bd.divide(new BigDecimal(3.0));
- en: System.out.println(bd); // Should be 1/3
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(bd); // 应该是 1/3
- en: '[PRE26]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Java’s Standard Library of Mathematical Functions
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Java的标准数学函数库
- en: 'To conclude this look at Java’s support for numeric data and math, let’s take
    a quick tour of the standard library of functions that Java ships with. These
    are mostly static helper methods that are located on the class `java.lang.Math`
    and include functions like:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 结束对Java对数值数据和数学支持的探索，让我们快速浏览一下Java附带的标准库函数。这些主要是静态辅助方法，位于`java.lang.Math`类上，包括函数如下：
- en: '`abs()`'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`abs()`'
- en: Returns the absolute value of a number. Has overloaded forms for various primitive
    types.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个数的绝对值。具有多种基本类型的重载形式。
- en: Trigonometric functions
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 三角函数
- en: Basic functions for computing the sine, cosine, tangent, and so on. Java also
    includes hyperbolic versions and the inverse functions (such as arc sine).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 计算正弦、余弦、正切等的基本函数。Java还包括双曲函数版本和反函数（如反正弦）。
- en: '`max()`, `min()`'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`max()`，`min()`'
- en: Overloaded functions to return the greater and smaller of two arguments (both
    of the same numeric type).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 重载函数用于返回两个参数中较大和较小的一个（相同的数值类型）。
- en: '`ceil()`, `floor()`'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`ceil()`，`floor()`'
- en: Used for rounding to integers. `floor()` returns the largest integer smaller
    than the argument (which is a double). `ceil()` returns the smallest integer larger
    than the argument.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 用于舍入到整数。`floor()`返回小于参数的最大整数（参数为double）。`ceil()`返回大于参数的最小整数。
- en: '`pow()`, `exp()`, `log()`'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`pow()`，`exp()`，`log()`'
- en: Functions for raising one number to the power of another and for computing exponentials
    and natural logarithms. `log10()` provides logarithms to base-10, rather than
    the natural base.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 用于计算一个数的幂以及计算指数和自然对数的函数。`log10()`提供以10为底的对数，而不是自然底数。
- en: 'Let’s look at some simple examples of how to use these functions:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些如何使用这些函数的简单示例：
- en: '[PRE27]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'To conclude this section, let’s briefly discuss Java’s `random()` function.
    When this is first called, it sets up a new instance of `java.util.Random`. This
    is a *pseudorandom number generator* (PRNG)—a deterministic piece of code that
    produces numbers that *look* random but are actually produced by a mathematical
    formula.^([2](ch09.xhtml#idm45927716685824)) In Java’s case, the formula used
    for the PRNG is pretty simple, for example:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 结束本节时，让我们简要讨论一下 Java 的 `random()` 函数。第一次调用时，它设置一个新的 `java.util.Random` 实例。这是一个
    *伪随机数生成器*（PRNG）—一个通过数学公式产生 *看起来* 随机但实际上是由公式产生的确定性代码片段。^([2](ch09.xhtml#idm45927716685824))
    在 Java 的情况下，用于 PRNG 的公式非常简单，例如：
- en: '[PRE28]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If the sequence of pseudorandom numbers always starts at the same place, then
    exactly the same stream of numbers will be produced. To get around this problem,
    the PRNG is seeded by a value that should contain as much true randomness as possible.
    For this source of randomness for the seed value, Java uses a CPU counter value
    that is normally used for high-precision timing.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果伪随机数的序列总是从同一位置开始，那么将生成完全相同的数字流。为了解决这个问题，伪随机数生成器的种子由一个应包含尽可能多真实随机性的值来设置。对于这种随机性来源于种子值的来源，Java
    使用通常用于高精度计时的 CPU 计数器值。
- en: Warning
  id: totrans-172
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: While Java’s built-in pseudorandom numbers are fine for most general applications,
    some specialist applications (notably cryptography and some types of simulations)
    have much more stringent requirements. If you are working on an application of
    that sort, seek expert advice from programmers who are already working in the
    area.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Java 内置的伪随机数对大多数一般应用来说足够了，但某些专业应用（尤其是密码学和某些类型的模拟）对随机数有更严格的要求。如果你正在开发这类应用，请寻求已在该领域工作的程序员的专家建议。
- en: 'Now that we’ve looked at text and numeric data, let’s move on to look at another
    of the most frequently encountered kinds of data: date and time information.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看过了文本和数值数据，让我们继续看一下另一种最常见的数据类型：日期和时间信息。
- en: Date and Time
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日期和时间
- en: Almost all business software applications have some notion of date and time.
    When modeling real-world events or interactions, collecting a point at which the
    event occurred is critical for future reporting or comparison of domain objects.
    Java 8 brought a complete overhaul to the way that developers work with date and
    time. This section introduces those concepts. In earlier versions, the only support
    is via classes such as `java.util.Date` that do not model the concepts. Code that
    uses the older APIs should move as soon as possible.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有的业务软件应用都涉及到日期和时间的概念。在建模真实世界的事件或交互时，收集事件发生时间点对未来的报告或领域对象比较至关重要。Java 8 对开发者处理日期和时间的方式进行了彻底的改革。本节介绍了这些概念。在早期版本中，唯一的支持是通过类似
    `java.util.Date` 的类，这些类不能很好地建模这些概念。使用旧的 API 的代码应尽快迁移。
- en: Introducing the Java 8 Date and Time API
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引入 Java 8 日期和时间 API
- en: 'Java 8 introduced the new package `java.time`, which contains the core classes
    that most developers work with. It also contains four subpackages:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8 引入了新的包 `java.time`，其中包含大多数开发者使用的核心类。它还包含四个子包：
- en: '`java.time.chrono`'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.time.chrono`'
- en: Alternative chronologies that developers using calendaring systems that do not
    follow the ISO standard will interact with. An example would be a Japanese calendaring
    system.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者使用非 ISO 标准的日历系统时将与之交互的备选年表。例如，日本的日历系统。
- en: '`java.time.format`'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.time.format`'
- en: Contains the `DateTimeFormatter` used for converting date and time objects into
    a `String` and also for parsing strings into the data and time objects.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 包含用于将日期和时间对象转换为 `String`，以及将字符串解析为日期和时间对象的 `DateTimeFormatter`。
- en: '`java.time.temporal`'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.time.temporal`'
- en: Contains the interfaces required by the core date and time classes and also
    abstractions (such as queries and adjusters) for advanced operations with dates.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 包含核心日期和时间类所需的接口，还包括用于日期高级操作的抽象（如查询和调整器）。
- en: '`java.time.zone`'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.time.zone`'
- en: Classes used for the underlying time zone rules; most developers won’t require
    this package.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 用于底层时区规则的类；大多数开发者不需要这个包。
- en: 'One of the most important concepts when representing time is the idea of an
    instantaneous point on the timeline of some entity. While this concept is well
    defined within, for example, Special Relativity, representing it within a computer
    requires us to make some assumptions. In Java, we represent a single point in
    time as an `Instant`, which has these key assumptions:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在表示时间时，最重要的概念之一是某个实体时间线上瞬时点的概念。虽然这个概念在例如特殊相对论中有明确定义，但在计算机中表示它需要我们做出一些假设。在 Java
    中，我们将时间的单个点表示为`Instant`，它有以下关键假设：
- en: We cannot represent more seconds than can fit into a `long`.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们无法表示超过`long`类型可以容纳的秒数。
- en: We cannot represent time more precisely than nanosecond precision.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们无法以比纳秒精度更精确地表示时间。
- en: This means that we are restricting ourselves to modeling time in a manner that
    is consistent with the capabilities of current computer systems. However, another
    fundamental concept should also be introduced.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们限制自己以一种与当前计算机系统能力相一致的方式来建模时间。然而，还应引入另一个基本概念。
- en: An `Instant` is about a single event in space-time. However, it is far from
    uncommon for programmers to have to deal with intervals between two events, and
    so Java also contains the `java.time.Duration` class. This class ignores calendar
    effects that might arise (e.g., from daylight saving time). With this basic conception
    of instants and durations between events, let’s move on to unpack the possible
    ways of thinking about an instant.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`Instant`是关于时空中单个事件的概念。然而，程序员经常需要处理两个事件之间的间隔，因此 Java 还包含了`java.time.Duration`类。该类忽略了可能出现的日历效应（例如夏令时）。通过这种对瞬时事件和事件之间持续时间的基本理解，让我们继续探讨关于瞬时事件的可能思考方式。
- en: The parts of a timestamp
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 时间戳的部分
- en: In [Figure 9-1](#javanut8-CHP-9-FIG-1), we show the breakdown of the different
    parts of a timestamp in a number of possible ways.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 9-1](#javanut8-CHP-9-FIG-1)中，我们展示了时间戳的不同部分在多种可能的方式下的分解。
- en: '![JN7 0901](assets/jns8_0901.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![JN7 0901](assets/jns8_0901.png)'
- en: Figure 9-1\. Breaking apart a timestamp
  id: totrans-195
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 9-1\. 时间戳的分解
- en: The key concept here is that a number of different abstractions might be appropriate
    at different times. For example, there are applications where a `LocalDate` is
    key to business processing, where the needed granularity is a business day. Alternatively,
    some applications require subsecond, or even millisecond, precision. Developers
    should be aware of their domain and use a suitable representation within their
    application.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的关键概念是在不同的时间可能适用于多种不同的抽象。例如，有些应用程序中，`LocalDate`对业务处理至关重要，所需的粒度是工作日。另外，有些应用程序要求亚秒甚至毫秒的精度。开发人员应了解他们的领域，并在应用程序中使用合适的表示。
- en: Example
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例
- en: 'The date and time API can be a lot to take in at first glance, so let’s start
    by looking at an example and discussing a diary class that keeps track of birthdays.
    If you happen to be very forgetful about birthdays, then a class like this (and
    especially methods like `getBirthdaysInNextMonth()`) might be very helpful:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 日期和时间 API 一开始可能会让人感到困惑，所以让我们从看一个示例开始，并讨论一个日记类，用于跟踪生日。如果你对生日很健忘，那么这样的类（特别是像`getBirthdaysInNextMonth()`这样的方法）可能会非常有帮助：
- en: '[PRE29]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This class shows how to use the low-level API to build up useful functionality.
    It also uses innovations such as the Java Streams API and demonstrates how to
    use `LocalDate` as an immutable class and how dates should be treated as values.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这个课程展示了如何使用低级 API 来构建有用的功能。它还使用了像 Java Streams API 这样的创新技术，并演示了如何将`LocalDate`作为不可变类使用，以及如何将日期视为值进行处理。
- en: Queries
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询
- en: 'Under a wide variety of circumstances, we may find ourselves wanting to answer
    a question about a particular temporal object. Some example questions we may want
    answers to are:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在广泛的情况下，我们可能会发现自己想要回答有关特定时间对象的问题。一些可能需要回答的示例问题包括：
- en: Is the date before March 1st?
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日期是否在三月一日之前？
- en: Is the date in a leap year?
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日期是否在闰年中？
- en: How many days is it from today until my next birthday?
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从今天到我的下一个生日还有多少天？
- en: 'This is achieved by the use of the `TemporalQuery` interface, which is defined
    like this:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过使用`TemporalQuery`接口来实现的，其定义如下：
- en: '[PRE30]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The parameter to `queryFrom()` should not be `null`, but if the result indicates
    that a value was not found, `null` could be used as a return value.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`queryFrom()`的参数不应为`null`，但如果结果表明未找到值，则可以使用`null`作为返回值。'
- en: Note
  id: totrans-209
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The `Predicate` interface can be thought of as a query that can only represent
    answers to yes-or-no questions. Temporal queries are more general and can return
    a value of “How many?” or “Which?” instead of just “yes” or “no.”
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`Predicate` 接口可以被视为只能代表是或否问题的查询。时间查询更为通用，可以返回“多少？”或“哪个？”的值，而不仅仅是“是”或“否”。'
- en: 'Let’s look at an example of a query in action, by considering a query that
    answers the following question: “Which quarter of the year is this date in?” Java
    does not support the concept of a quarter directly. Instead, code like this is
    used:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过考虑一个回答以下问题的查询来看一个查询的示例在操作中的应用：“这个日期属于一年的哪个季度？”Java 不直接支持季度的概念。而是使用这样的代码：
- en: '[PRE31]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This still doesn’t give quarter as a separate abstraction and instead special
    case code is still needed. So let’s slightly extend the JDK support by defining
    this enum type:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这仍然没有提供季度作为一个单独的抽象，而是仍然需要特殊的情况代码。所以让我们通过定义这个枚举类型稍微扩展 JDK 的支持：
- en: '[PRE32]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, the query can be written as:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，查询可以写为：
- en: '[PRE33]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '`TemporalQuery` objects can be used directly or indirectly. Let’s look at an
    example of each:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`TemporalQuery` 对象可以直接或间接使用。让我们分别看一些示例：'
- en: '[PRE34]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Under most circumstances, it is better to use the indirect approach, where the
    query object is passed as a parameter to `query()`. This is because it is normally
    a lot clearer to read in code.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，最好使用间接方法，其中查询对象作为参数传递给 `query()`。因为这样在代码中通常更容易阅读。
- en: Adjusters
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调整器
- en: 'Adjusters modify date and time objects. Suppose, for example, that we want
    to return the first day of a quarter that contains a particular timestamp:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 调整器修改日期和时间对象。例如，假设我们想返回包含特定时间戳的季度的第一天：
- en: '[PRE35]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Let’s look at an example of how to use an adjuster:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个使用调整器的例子：
- en: '[PRE36]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The key here is the `with()` method, and the code should be read as taking in
    one `Temporal` object and returning another object that has been modified. This
    is completely normal for APIs that work with immutable objects.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的关键是 `with()` 方法，代码应该被解读为接受一个 `Temporal` 对象并返回另一个已修改的对象。对于处理不可变对象的 API 来说，这是完全正常的。
- en: Timezones
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 时区
- en: If you work with code that cares about dates, you will almost certainly encounter
    complications from timezones. Beyond the simple problems of presenting information
    clearly to users, timezones cause problems because they change. Whether from daylight
    savings moves or governments reassigning the zone for a given territory, the definition
    of timezones today isn’t guaranteed to be the same next month.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你处理关于日期的代码，几乎肯定会遇到来自时区的复杂性。除了向用户清晰地展示信息的简单问题之外，时区还会引起问题，因为它们会变化。无论是来自夏令时的调整还是政府重新分配给定领土的区域，今天的时区定义不能保证下个月相同。
- en: The JVM brings its own copy of the standard IANA timezone data, so getting timezone
    updates typically requires a JDK upgrade. For those who need changes more frequently,
    Oracle publishes a [`tzupdater` tool](https://oreil.ly/RIMLr) that can be used
    to modify a JDK installation in-place with newer data.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: JVM 自带标准 IANA 时区数据的副本，因此通常需要 JDK 升级来获取时区更新。对于那些需要更频繁变更的人，Oracle 发布了一个 [`tzupdater`
    工具](https://oreil.ly/RIMLr)，可用于在原地修改 JDK 安装以使用更新的数据。
- en: Legacy Date and Time
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遗留日期和时间
- en: Unfortunately, many applications are not yet converted to use the superior date
    and time libraries that shipped with Java 8\. So, for completeness, we briefly
    mention the legacy date and time support (which is based on `java.util.Date`).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，许多应用程序尚未转换为使用随 Java 8 一起提供的优秀日期和时间库。因此，为了完整起见，我们简要提到了基于 `java.util.Date`
    的遗留日期和时间支持。
- en: Warning
  id: totrans-231
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: The legacy date and time classes, especially `java.util.Date`, should *not*
    be used in modern Java environments. Consider refactoring or rewriting any code
    that still uses the legacy classes.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 遗留的日期和时间类，特别是 `java.util.Date`，不应在现代 Java 环境中使用。考虑重构或重新编写任何仍使用旧类的代码。
- en: In older versions of Java, `java.time` is not available. Instead, programmers
    rely upon the legacy and rudimentary support provided by `java.util.Date`. Historically,
    this was the only way to represent timestamps, and although named `Date` this
    class actually consisted of both a date and a time component—and this led to a
    lot of confusion for many programmers.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在旧版 Java 中，`java.time` 不可用。相反，程序员依赖于由 `java.util.Date` 提供的传统和基础支持。从历史上看，这是表示时间戳的唯一方法，尽管被称为
    `Date`，但实际上这个类包含了日期和时间组件 —— 这导致许多程序员感到困惑。
- en: 'There are many problems with the legacy support provided by `Date`, for example:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`Date`提供的遗留支持存在许多问题，例如：'
- en: The `Date` class is incorrectly factored. It doesn’t actually refer to a date
    and instead is more like a timestamp. It turns out that we need different representations
    for a date, versus a date and time, versus an instantaneous timestamp.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Date`类的设计有误。它实际上并不指代一个日期，而更像是一个时间戳。事实证明，我们需要不同的表示形式来表示日期、日期时间和瞬时时间戳。'
- en: '`Date` is mutable. We can obtain a reference to a date and then change when
    it refers to.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Date`是可变的。我们可以获得一个日期的引用，然后改变它所指向的日期。'
- en: The `Date` class doesn’t actually accept ISO-8601, the universal ISO date standard,
    as being a valid date.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Date`类实际上不接受ISO-8601，即通用的ISO日期标准，作为有效的日期。'
- en: '`Date` has a very large number of deprecated methods.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Date`类有大量被弃用的方法。'
- en: The current JDK uses two constructors for `Date`—the `void` constructor that
    is intended to be the “now constructor,” and a constructor that takes a number
    of milliseconds since epoch.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的JDK为`Date`使用了两个构造函数——一个是旨在成为“现在构造函数”的`void`构造函数，另一个是接受自纪元以来的毫秒数的构造函数。
- en: 'If you cannot avoid `java.util.Date`, you can still take advantage of the newer
    APIs by converting with code like the following example:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果无法避免使用`java.util.Date`，你仍然可以通过像以下示例中的代码进行转换，以利用更新的API：
- en: '[PRE37]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Summary
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we’ve met several different classes of data. Textual and numeric
    data are the most obvious examples, but as working programmers we will meet a
    large number of different sorts of data. Let’s move on to look at whole files
    of data and new ways to work with I/O and networking. Fortunately, Java provides
    good support for dealing with many of these abstractions.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们遇到了几种不同类别的数据。文本和数字数据是最明显的例子，但作为工作程序员，我们将遇到许多不同类型的数据。让我们继续看看如何处理整个数据文件以及使用新的I/O和网络工作方式。幸运的是，Java提供了处理许多这些抽象的良好支持。
- en: ^([1](ch09.xhtml#idm45927717366112-marker)) In fact, they are actually two of
    the known examples of *transcendental numbers*.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch09.xhtml#idm45927717366112-marker)) 实际上，它们实际上是*超越数*的两个已知例子之一。
- en: ^([2](ch09.xhtml#idm45927716685824-marker)) It is very difficult to get computers
    to produce true random numbers, and in the rare cases where this is done, specialized
    hardware is usually necessary.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch09.xhtml#idm45927716685824-marker)) 让计算机产生真正的随机数是非常困难的，在确实需要这样做的罕见情况下，通常需要专门的硬件。
