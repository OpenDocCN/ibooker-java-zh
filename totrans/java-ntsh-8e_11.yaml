- en: Chapter 9\. Handling Common Data Formats
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of programming is handling data in various formats. In this chapter, we
    will introduce Java’s support for handling two big classes of data—text and numbers.
    The second half of the chapter will focus on handling date and time information.
    This is of particular interest, as Java 8 shipped a completely new API for handling
    date and time. We cover this interface in some depth before finishing the chapter
    by briefly discussing Java’s original date and time API.
  prefs: []
  type: TYPE_NORMAL
- en: Many applications are still using the legacy APIs, so developers need to be
    aware of the old way of doing things, but the new APIs are so much better that
    we recommend converting as soon as possible. Before we get to those more complex
    formats, let’s get under way by talking about textual data and strings.
  prefs: []
  type: TYPE_NORMAL
- en: Text
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already met Java’s strings on many occasions. They consist of sequences
    of Unicode characters and are represented as instances of the `String` class.
    Strings are one of the most common types of data that Java programs process (a
    claim you can investigate for yourself by using the `jmap` tool that we’ll meet
    in [Chapter 13](ch13.xhtml#javanut8-CHP-13)).
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll meet the `String` class in some more depth and understand
    why it is in a rather unique position within the Java language. Later in the section,
    we’ll introduce regular expressions, a very common abstraction for searching text
    for patterns (and a classic tool in the programmer’s arsenal, regardless of language).
  prefs: []
  type: TYPE_NORMAL
- en: Special Syntax for Strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `String` class is handled in a somewhat special way by the Java language.
    This is because, despite not being a primitive type, strings are so common that
    it makes sense for Java to have a number of special syntax features designed to
    make handling strings easy. Let’s look at some examples of special syntax features
    for strings that Java provides.
  prefs: []
  type: TYPE_NORMAL
- en: String literals
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As we saw in [Chapter 2](ch02.xhtml#javanut8-CHP-2), Java allows a sequence
    of characters to be placed in double quotes to create a literal string object.
    Like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Without this special syntax, we would have to write acres of horrible code
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This would get tedious extremely quickly, so it’s no surprise that Java, like
    all modern programming languages, provides a simple string literal syntax. The
    string literals are perfectly sound objects, so code like this is completely legal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Strings using basic double quotes cannot span multiple lines, but recent versions
    of Java have included multiline text blocks with the `"""` syntax. The resulting
    string objects are created at compile-time and are no different than a `"` quoted
    string, just easier to express:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: See [“String literals”](ch02.xhtml#javanut8-CHP-2-SECT-7.5) for complete coverage
    of string literals in Java.
  prefs: []
  type: TYPE_NORMAL
- en: toString()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This method is defined on `Object` and is designed to allow easy conversion
    of any object to a string. This makes it easy to print out any object, by using
    the method `System.out.println()`. This method is actually `PrintStream::println`
    because `System.out` is a static field of type `PrintStream`. Let’s see how this
    method is defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a new string by using the static method `String::valueOf()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The static `valueOf()` method is used instead of `toString()` directly, to avoid
    a `NullPointerException` in the case where `obj` is `null`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This construction means that `toString()` is always available for any object,
    and this comes in very handy for another major syntax feature that Java provides:
    string concatenation.'
  prefs: []
  type: TYPE_NORMAL
- en: String concatenation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Java allows us to create new strings by “adding” the characters from one string
    onto the end of another. This is called *string concatenation* and uses the operator
    `+`. In versions of Java up to and including Java 8, it works by first creating
    a “working area” in the form of a `StringBuilder` object that contains the same
    sequence of characters as the original string.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Java 9 introduced a new mechanism that uses the `invokedynamic` instruction
    instead of `StringBuilder` directly. This is an advanced piece of functionality
    and out of scope for this discussion, but it doesn’t change the behavior visible
    to the Java developer.
  prefs: []
  type: TYPE_NORMAL
- en: The builder object is then updated and the characters from the additional string
    are added onto the end. Finally, `toString()` is called on the `StringBuilder`
    object (which now contains the characters from both strings). This gives us a
    new string with all the characters in it. All of this code is created automatically
    by `javac` whenever we use the `+` operator to concatenate strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'The concatenation process returns a completely new `String` object, as we can
    see in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The concatenation example directly shows that the `+` operator is not altering
    (or *mutating*) `s1` in place. This is an example of a more general principle:
    Java’s strings are immutable. This means that once the characters that make up
    the string have been chosen and the `String` object has been created, the `String`
    cannot be changed. This is an important language principle in Java, so let’s look
    at it in a little more depth.'
  prefs: []
  type: TYPE_NORMAL
- en: String Immutability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To “change” a string, as we saw when we discussed string concatenation, we
    actually need to create an intermediate `StringBuilder` object to act as a temporary
    scratch area, and then call `toString()` on it, to bake it into a new instance
    of `String`. Let’s see how this works in code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Code like this behaves equivalently to the following, although in Java 9 and
    above the actual bytecode sequences will differ:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Of course, as well as being used under the hood by `javac`, the `StringBuilder`
    class can also be used directly in application code, as we’ve seen.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Along with `StringBuilder`, Java also has a `StringBuffer` class. This comes
    from the oldest versions of Java and should not be used for new development—use
    `StringBuilder` instead, unless you really need to share the construction of a
    new string between multiple threads.
  prefs: []
  type: TYPE_NORMAL
- en: String immutability is an extremely useful language feature. For example, suppose
    the `+` changed a string instead of creating a new one; then, whenever any thread
    concatenated two strings, all other threads would also see the change. This is
    unlikely to be a useful behavior for most programs, and so immutability makes
    good sense.
  prefs: []
  type: TYPE_NORMAL
- en: Hash codes and effective immutability
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We have already met the `hashCode()` method in [Chapter 5](ch05.xhtml#javanut8-CHP-5),
    where we described the contract that the method must satisfy. Let’s take a look
    at the JDK source code and see how the method `String::hashCode()` is defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The field `hash` holds the hash code of the string, and the field `value` is
    a `char[]` that holds the characters that actually make up the string. As we can
    see from the code, Java computes the hash by looping over all the characters of
    the string. It therefore takes a number of machine instructions proportional to
    the number of characters in the string. For very large strings, this could take
    a bit of time. Rather than precompute the hash value, Java calculates it only
    when it is needed.
  prefs: []
  type: TYPE_NORMAL
- en: When the method runs, the hash is computed by stepping through the array of
    characters. At the end of the array, we exit the `for` loop and write the computed
    hash back into the field `hash`. Now, when this method is called again, the value
    has already been computed, so we can just use the cached value and subsequent
    calls to `hashCode()` return immediately.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The computation of a string’s hash code is an example of a *benign data race*.
    In a program with multiple threads, they could race to compute the hash code.
    However, they would all eventually arrive at exactly the same answer—hence the
    term *benign*.
  prefs: []
  type: TYPE_NORMAL
- en: All of the fields of the `String` class are final, except for `hash`. So Java’s
    strings are not, strictly speaking, immutable. However, because the `hash` field
    is just a cache of a value that is deterministically computed from the other fields,
    which are all immutable then, provided `String` has been coded correctly, it will
    behave as if it were immutable. Classes that have this property are called *effectively
    immutable*—they are quite rare in practice, and working programmers can usually
    ignore the distinction between truly immutable and effectively immutable data.
  prefs: []
  type: TYPE_NORMAL
- en: String Formatting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [“String concatenation”](#javanut8-CHP-9-string-concatenation), we saw how
    Java supports building strings from smaller strings by joining them. While this
    works, it can often be tedious and error prone when constructing more elaborate
    output strings. Java provides a number of other methods and classes for doing
    richer string formatting.
  prefs: []
  type: TYPE_NORMAL
- en: 'The static method `format` on the `String` class allows us to specify a template
    and then dynamically plug in various values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Placeholders in the format string where values will be introduced start with
    the `%` character. In this example, we substitute an integer with `%d`, a string
    with `%s`, a boolean with `%b`, and finally end the string with a newline via
    `%n`.
  prefs: []
  type: TYPE_NORMAL
- en: Those with a background in C or similar languages will recognize this format
    from the venerable `printf` function. Java supports many, though not all, of the
    same formats with a wide variety of options. Java’s `printf` also provides more
    sophisticated date and time formatting as seen in C’s `strftime` function. See
    the Java documentation on `java.util.Formatter` for the full list of options available.
  prefs: []
  type: TYPE_NORMAL
- en: Java also improves on the experience using these format strings by throwing
    exceptions on invalid conditions such as mismatched numbers of placeholders to
    values, or unrecognized `%` values.
  prefs: []
  type: TYPE_NORMAL
- en: '`String.format()` provides powerful tools for constructing complex strings
    but, particularly when making output correct across countries, more assistance
    is needed. `NumberFormat` is an example of classes Java provides to support more
    complex, locale-aware formatting of values. Other formatters are also available
    under `java.text`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Regular Expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Java has support for *regular* *expressions* (often shortened to *regex* or
    *regexp*). These are a representation of a search pattern used to scan and match
    text. A regex is a sequence of characters that we want to search for. They can
    be very simple—for example, `abc` means that we’re looking for *a*, followed immediately
    by *b*, followed immediately by *c*, anywhere within the text we’re searching.
    Note that a search pattern may match an input text in zero, one, or more places.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest regexes are just sequences of literal characters, like `abc`.
    However, the language of regexes can express more complex and subtle ideas than
    just literal sequences. For example, a regex can represent patterns to match like:'
  prefs: []
  type: TYPE_NORMAL
- en: A numeric digit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any letter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any number of letters, which must all be in the range *a* to *j* but can be
    upper- or lowercase
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*a* followed by any four characters, followed by *b*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The syntax we use to write regular expressions is simple, but because we can
    build complex patterns, it is often possible to write an expression that does
    not implement precisely what we wanted. When using regexes, it is very important
    to always test them fully. This should include both test cases that should pass
    and cases that should fail.
  prefs: []
  type: TYPE_NORMAL
- en: 'To express these more complex patterns, regexes use *metacharacters*. These
    are special characters that indicate special processing is required. This can
    be thought of as similar to the use of the `*` character in operating system shells.
    In those circumstances, it is understood that the `*` is not to be interpreted
    literally but instead means “anything.” If we wanted to list all the Java source
    files in the current directory on Unix, we would issue the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The metacharacters of regexes are similar, but there are far more of them, and
    they are far more flexible than the set available in shells. They also have different
    meanings than they do in shell scripts, so don’t get confused.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Many different flavors of regular expression patterns exist in the world. Java’s
    is PCRE-compatible, supporting a common set of metacharacters popularized by the
    Perl programming language. Be aware though that a random regex found online may
    or may not actually work, whatever regex libraries you are using.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s meet a couple of examples. Suppose we want to have a spell-checking program
    that is relaxed about the difference in spelling between British and American
    English. This means that *honor* and *honour* should both be accepted as valid
    spelling choices. This is easy to do with regular expressions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Java uses a class called `Pattern` (from the package `java.util.regex`) to
    represent a regex. This class can’t be directly instantiated, however. Instead,
    new instances are created by using a static factory method, `compile()`. From
    a pattern, we then derive a `Matcher` for a particular input string that we can
    use to explore the input string. For example, let’s examine a bit of Shakespeare
    from the play *Julius Caesar*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Be careful when using `Matcher`, as it has a method called `matches()`. However,
    this method indicates whether the pattern can cover the entire input string. It
    will return `false` if the pattern starts matching only in the middle of the string.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last example introduces our first regex metacharacter `?`, in the pattern
    `honou?r`. This means “the preceding character is optional”—so both `honour` and
    `honor` will match. Let’s look at another example. Suppose we want to match both
    *minimize* and *minimise* (the latter spelling is more common in British English).
    We can use square brackets to indicate that any character from a set (but only
    one alternative) `[]` can be used—like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[Table 9-1](#javanut8-CHP-9-TABLE-1) provides an expanded list of metacharacters
    available for Java regexes.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 9-1\. Regex metacharacters
  prefs: []
  type: TYPE_NORMAL
- en: '| Metacharacter | Meaning | Notes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `?` | Optional character—zero or one instance |  |'
  prefs: []
  type: TYPE_TB
- en: '| `*` | Zero or more of preceding character |  |'
  prefs: []
  type: TYPE_TB
- en: '| `+` | One or more of preceding character |  |'
  prefs: []
  type: TYPE_TB
- en: '| `{M,N}` | Between `M` and `N` instances of preceding character |  |'
  prefs: []
  type: TYPE_TB
- en: '| `\d` | A digit |  |'
  prefs: []
  type: TYPE_TB
- en: '| `\D` | A nondigit character |  |'
  prefs: []
  type: TYPE_TB
- en: '| `\w` | A word character | Digits, letters, and `_` |'
  prefs: []
  type: TYPE_TB
- en: '| `\W` | A nonword character |  |'
  prefs: []
  type: TYPE_TB
- en: '| `\s` | A whitespace character |  |'
  prefs: []
  type: TYPE_TB
- en: '| `\S` | A nonwhitespace character |  |'
  prefs: []
  type: TYPE_TB
- en: '| `\n` | Newline character |  |'
  prefs: []
  type: TYPE_TB
- en: '| `\t` | Tab character |  |'
  prefs: []
  type: TYPE_TB
- en: '| `.` | Any single character | Does not include newline in Java |'
  prefs: []
  type: TYPE_TB
- en: '| `[ ]` | Any character contained with the brackets | Called a character class
    |'
  prefs: []
  type: TYPE_TB
- en: '| `[^ ]` | Any character not contained with the brackets | Called a negated
    character class |'
  prefs: []
  type: TYPE_TB
- en: '| `( )` | Build up a group of pattern elements | Called a group (or capturing
    group) |'
  prefs: []
  type: TYPE_TB
- en: '| `&#124;` | Define alternative possibilities | Implements logical `OR` |'
  prefs: []
  type: TYPE_TB
- en: '| `^` | Start of string |  |'
  prefs: []
  type: TYPE_TB
- en: '| `$` | End of string |  |'
  prefs: []
  type: TYPE_TB
- en: '| `\\` | Literal escape (`\`) char |  |'
  prefs: []
  type: TYPE_TB
- en: 'There are a few more, but this is the basic list. The `java.util.regex.Pattern`
    Java documentation is a good source for all the details. From this, we can construct
    more complex expressions for matching such as the examples given earlier in this
    section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Regexes are extremely useful for determining when a string matches a given
    pattern, but they also allow for extracting bits and pieces from the strings as
    well. This is done through the *group* mechanism, which is represented in the
    patterns by `()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The call to `Matcher.group(1)` returns the text that the regex matched in the
    `(\\d*)` of our pattern. Multiple groups are allowed, along with syntax for naming
    groups rather than using them by position. See the Java documentation for full
    details.
  prefs: []
  type: TYPE_NORMAL
- en: 'A common difficulty working with regular expressions is the need to use escape
    characters for both the Java string and the regular expression. Where text blocks
    have less escaping—such as quote characters—they can provide for less cluttered
    expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s conclude our quick tour of regular expressions by meeting a new method
    that was added to `Pattern` as part of Java 8: `asPredicate()`. This method is
    present to allow us to easily bridge from regular expressions to the Java Collections
    and their new support for lambda expressions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, suppose we have a regex and a collection of strings. It’s very
    natural to ask the question: “Which strings match against the regex?” We do this
    by using the filter idiom and by converting the regex to a `Predicate` using the
    helper method, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Java’s built-in support for text processing is more than adequate for the majority
    of text-processing tasks that business applications normally require. More advanced
    tasks, such as the search and processing of very large data sets, or complex parsing
    (including formal grammars), are outside the scope of this book, but Java has
    a large ecosystem of helpful libraries and bindings to specialized technologies
    for text processing and analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Numbers and Math
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will discuss Java’s support for numeric types in some more
    detail. In particular, we’ll discuss the two’s complement representation of integral
    types that Java uses. We’ll introduce floating-point representations and touch
    on some of the problems they can cause. We’ll also work through examples that
    use some of Java’s library functions for standard mathematical operations.
  prefs: []
  type: TYPE_NORMAL
- en: How Java Represents Integer Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Java’s integer types are all signed, as we first mentioned in [“Primitive Data
    Types”](ch02.xhtml#javanut8-CHP-2-SECT-3). This means that all integer types can
    represent both positive and negative numbers. As computers work with binary, this
    means that the only really logical way to represent this is to split the possible
    bit patterns and use half of them to represent negative numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s work with Java’s `byte` type to investigate how Java represents integers.
    This has 8 bits so can represent 256 different numbers (i.e., 128 negative and
    128 nonnegative numbers). It’s logical to use the pattern `0b0000_0000` to represent
    zero (recall that Java has the syntax `0b<binary digits>` to represent numbers
    as binary), and then it’s easy to figure out the bit patterns for the positive
    numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: When we set the first bit of the byte, the sign should change (as we have now
    used up all of the bit patterns that we’ve set aside for nonnegative numbers).
    So the pattern `0b1000_0000` should represent some negative number—but which one?
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'As a consequence of how we’ve defined things, in this representation we have
    a very simple way to identify whether a bit pattern corresponds to a negative
    number: if the high-end bit of a bit pattern is a `1`, then the number being represented
    is negative.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the bit pattern consisting of all set bits: `0b1111_1111`. If we add
    `1` to this number, then the result will overflow the 8 bits of storage that a
    `byte` has, resulting in `0b1_0000_0000`. If we want to constrain this to fit
    within the `byte` data type, then we should ignore the overflow, so this becomes
    `0b0000_0000`, otherwise known as zero. It is therefore natural to adopt the representation
    that “all set bits represent `-1`.” This allows for natural arithmetic behavior,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let’s look at the number that `0b1000_0000` represents. It’s the most
    negative number that the type can represent, so for `byte`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This representation, called *two’s complement*, is the most common representation
    for signed integers. To use it effectively, you need to remember only two points:'
  prefs: []
  type: TYPE_NORMAL
- en: A bit pattern of all 1’s is the representation for −1.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the high bit is set, the number is negative.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java’s other integer types (`short`, `int`, and `long`) behave in very similar
    ways but with more bits in their representation. The `char` data type is different
    because it represents a Unicode character, but in some ways it behaves as an unsigned
    16-bit numeric type. It is not normally regarded as an integer type by Java programmers.
  prefs: []
  type: TYPE_NORMAL
- en: Java and Floating-Point Numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Computers represent numbers using binary. We’ve seen how Java uses the two’s
    complement representation for integers. But what about fractions or decimals?
    Java, like almost all modern programming languages, represents them using *floating-point*
    *arithmetic*. Let’s take a look at how this works, first in base-10 (regular decimal)
    and then in binary. Java defines the two most important mathematical constants,
    `e` and `π` (pi), as constants in `java.lang.Math` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, these constants are actually *irrational numbers* and cannot be
    precisely expressed as a fraction, or by any finite decimal number.^([1](ch09.xhtml#idm45927717366112))
    This means that whenever we try to represent them in a computer, there is always
    rounding error. Let’s suppose we only want to deal with eight digits of π, and
    we want to represent the digits as a whole number. We can use a representation
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`314159265 • 10^(–8)`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: double d = 0.3;
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(d); // Special-cased to avoid ugly representation
  prefs: []
  type: TYPE_NORMAL
- en: double d2 = 0.2;
  prefs: []
  type: TYPE_NORMAL
- en: // Should be -0.1 but prints -0.09999999999999998
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(d2 - d);
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: double d = 0.3;
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(d);
  prefs: []
  type: TYPE_NORMAL
- en: BigDecimal bd = new BigDecimal(d);
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(bd);
  prefs: []
  type: TYPE_NORMAL
- en: bd = new BigDecimal("0.3");
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(bd);
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: bd = new BigDecimal(BigInteger.ONE);
  prefs: []
  type: TYPE_NORMAL
- en: bd.divide(new BigDecimal(3.0));
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(bd); // Should be 1/3
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Java’s Standard Library of Mathematical Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To conclude this look at Java’s support for numeric data and math, let’s take
    a quick tour of the standard library of functions that Java ships with. These
    are mostly static helper methods that are located on the class `java.lang.Math`
    and include functions like:'
  prefs: []
  type: TYPE_NORMAL
- en: '`abs()`'
  prefs: []
  type: TYPE_NORMAL
- en: Returns the absolute value of a number. Has overloaded forms for various primitive
    types.
  prefs: []
  type: TYPE_NORMAL
- en: Trigonometric functions
  prefs: []
  type: TYPE_NORMAL
- en: Basic functions for computing the sine, cosine, tangent, and so on. Java also
    includes hyperbolic versions and the inverse functions (such as arc sine).
  prefs: []
  type: TYPE_NORMAL
- en: '`max()`, `min()`'
  prefs: []
  type: TYPE_NORMAL
- en: Overloaded functions to return the greater and smaller of two arguments (both
    of the same numeric type).
  prefs: []
  type: TYPE_NORMAL
- en: '`ceil()`, `floor()`'
  prefs: []
  type: TYPE_NORMAL
- en: Used for rounding to integers. `floor()` returns the largest integer smaller
    than the argument (which is a double). `ceil()` returns the smallest integer larger
    than the argument.
  prefs: []
  type: TYPE_NORMAL
- en: '`pow()`, `exp()`, `log()`'
  prefs: []
  type: TYPE_NORMAL
- en: Functions for raising one number to the power of another and for computing exponentials
    and natural logarithms. `log10()` provides logarithms to base-10, rather than
    the natural base.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at some simple examples of how to use these functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'To conclude this section, let’s briefly discuss Java’s `random()` function.
    When this is first called, it sets up a new instance of `java.util.Random`. This
    is a *pseudorandom number generator* (PRNG)—a deterministic piece of code that
    produces numbers that *look* random but are actually produced by a mathematical
    formula.^([2](ch09.xhtml#idm45927716685824)) In Java’s case, the formula used
    for the PRNG is pretty simple, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: If the sequence of pseudorandom numbers always starts at the same place, then
    exactly the same stream of numbers will be produced. To get around this problem,
    the PRNG is seeded by a value that should contain as much true randomness as possible.
    For this source of randomness for the seed value, Java uses a CPU counter value
    that is normally used for high-precision timing.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: While Java’s built-in pseudorandom numbers are fine for most general applications,
    some specialist applications (notably cryptography and some types of simulations)
    have much more stringent requirements. If you are working on an application of
    that sort, seek expert advice from programmers who are already working in the
    area.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we’ve looked at text and numeric data, let’s move on to look at another
    of the most frequently encountered kinds of data: date and time information.'
  prefs: []
  type: TYPE_NORMAL
- en: Date and Time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Almost all business software applications have some notion of date and time.
    When modeling real-world events or interactions, collecting a point at which the
    event occurred is critical for future reporting or comparison of domain objects.
    Java 8 brought a complete overhaul to the way that developers work with date and
    time. This section introduces those concepts. In earlier versions, the only support
    is via classes such as `java.util.Date` that do not model the concepts. Code that
    uses the older APIs should move as soon as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the Java 8 Date and Time API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Java 8 introduced the new package `java.time`, which contains the core classes
    that most developers work with. It also contains four subpackages:'
  prefs: []
  type: TYPE_NORMAL
- en: '`java.time.chrono`'
  prefs: []
  type: TYPE_NORMAL
- en: Alternative chronologies that developers using calendaring systems that do not
    follow the ISO standard will interact with. An example would be a Japanese calendaring
    system.
  prefs: []
  type: TYPE_NORMAL
- en: '`java.time.format`'
  prefs: []
  type: TYPE_NORMAL
- en: Contains the `DateTimeFormatter` used for converting date and time objects into
    a `String` and also for parsing strings into the data and time objects.
  prefs: []
  type: TYPE_NORMAL
- en: '`java.time.temporal`'
  prefs: []
  type: TYPE_NORMAL
- en: Contains the interfaces required by the core date and time classes and also
    abstractions (such as queries and adjusters) for advanced operations with dates.
  prefs: []
  type: TYPE_NORMAL
- en: '`java.time.zone`'
  prefs: []
  type: TYPE_NORMAL
- en: Classes used for the underlying time zone rules; most developers won’t require
    this package.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the most important concepts when representing time is the idea of an
    instantaneous point on the timeline of some entity. While this concept is well
    defined within, for example, Special Relativity, representing it within a computer
    requires us to make some assumptions. In Java, we represent a single point in
    time as an `Instant`, which has these key assumptions:'
  prefs: []
  type: TYPE_NORMAL
- en: We cannot represent more seconds than can fit into a `long`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We cannot represent time more precisely than nanosecond precision.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This means that we are restricting ourselves to modeling time in a manner that
    is consistent with the capabilities of current computer systems. However, another
    fundamental concept should also be introduced.
  prefs: []
  type: TYPE_NORMAL
- en: An `Instant` is about a single event in space-time. However, it is far from
    uncommon for programmers to have to deal with intervals between two events, and
    so Java also contains the `java.time.Duration` class. This class ignores calendar
    effects that might arise (e.g., from daylight saving time). With this basic conception
    of instants and durations between events, let’s move on to unpack the possible
    ways of thinking about an instant.
  prefs: []
  type: TYPE_NORMAL
- en: The parts of a timestamp
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In [Figure 9-1](#javanut8-CHP-9-FIG-1), we show the breakdown of the different
    parts of a timestamp in a number of possible ways.
  prefs: []
  type: TYPE_NORMAL
- en: '![JN7 0901](assets/jns8_0901.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-1\. Breaking apart a timestamp
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The key concept here is that a number of different abstractions might be appropriate
    at different times. For example, there are applications where a `LocalDate` is
    key to business processing, where the needed granularity is a business day. Alternatively,
    some applications require subsecond, or even millisecond, precision. Developers
    should be aware of their domain and use a suitable representation within their
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The date and time API can be a lot to take in at first glance, so let’s start
    by looking at an example and discussing a diary class that keeps track of birthdays.
    If you happen to be very forgetful about birthdays, then a class like this (and
    especially methods like `getBirthdaysInNextMonth()`) might be very helpful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This class shows how to use the low-level API to build up useful functionality.
    It also uses innovations such as the Java Streams API and demonstrates how to
    use `LocalDate` as an immutable class and how dates should be treated as values.
  prefs: []
  type: TYPE_NORMAL
- en: Queries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Under a wide variety of circumstances, we may find ourselves wanting to answer
    a question about a particular temporal object. Some example questions we may want
    answers to are:'
  prefs: []
  type: TYPE_NORMAL
- en: Is the date before March 1st?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is the date in a leap year?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How many days is it from today until my next birthday?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is achieved by the use of the `TemporalQuery` interface, which is defined
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The parameter to `queryFrom()` should not be `null`, but if the result indicates
    that a value was not found, `null` could be used as a return value.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `Predicate` interface can be thought of as a query that can only represent
    answers to yes-or-no questions. Temporal queries are more general and can return
    a value of “How many?” or “Which?” instead of just “yes” or “no.”
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example of a query in action, by considering a query that
    answers the following question: “Which quarter of the year is this date in?” Java
    does not support the concept of a quarter directly. Instead, code like this is
    used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This still doesn’t give quarter as a separate abstraction and instead special
    case code is still needed. So let’s slightly extend the JDK support by defining
    this enum type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the query can be written as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '`TemporalQuery` objects can be used directly or indirectly. Let’s look at an
    example of each:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Under most circumstances, it is better to use the indirect approach, where the
    query object is passed as a parameter to `query()`. This is because it is normally
    a lot clearer to read in code.
  prefs: []
  type: TYPE_NORMAL
- en: Adjusters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Adjusters modify date and time objects. Suppose, for example, that we want
    to return the first day of a quarter that contains a particular timestamp:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s look at an example of how to use an adjuster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The key here is the `with()` method, and the code should be read as taking in
    one `Temporal` object and returning another object that has been modified. This
    is completely normal for APIs that work with immutable objects.
  prefs: []
  type: TYPE_NORMAL
- en: Timezones
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you work with code that cares about dates, you will almost certainly encounter
    complications from timezones. Beyond the simple problems of presenting information
    clearly to users, timezones cause problems because they change. Whether from daylight
    savings moves or governments reassigning the zone for a given territory, the definition
    of timezones today isn’t guaranteed to be the same next month.
  prefs: []
  type: TYPE_NORMAL
- en: The JVM brings its own copy of the standard IANA timezone data, so getting timezone
    updates typically requires a JDK upgrade. For those who need changes more frequently,
    Oracle publishes a [`tzupdater` tool](https://oreil.ly/RIMLr) that can be used
    to modify a JDK installation in-place with newer data.
  prefs: []
  type: TYPE_NORMAL
- en: Legacy Date and Time
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unfortunately, many applications are not yet converted to use the superior date
    and time libraries that shipped with Java 8\. So, for completeness, we briefly
    mention the legacy date and time support (which is based on `java.util.Date`).
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The legacy date and time classes, especially `java.util.Date`, should *not*
    be used in modern Java environments. Consider refactoring or rewriting any code
    that still uses the legacy classes.
  prefs: []
  type: TYPE_NORMAL
- en: In older versions of Java, `java.time` is not available. Instead, programmers
    rely upon the legacy and rudimentary support provided by `java.util.Date`. Historically,
    this was the only way to represent timestamps, and although named `Date` this
    class actually consisted of both a date and a time component—and this led to a
    lot of confusion for many programmers.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many problems with the legacy support provided by `Date`, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Date` class is incorrectly factored. It doesn’t actually refer to a date
    and instead is more like a timestamp. It turns out that we need different representations
    for a date, versus a date and time, versus an instantaneous timestamp.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Date` is mutable. We can obtain a reference to a date and then change when
    it refers to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Date` class doesn’t actually accept ISO-8601, the universal ISO date standard,
    as being a valid date.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Date` has a very large number of deprecated methods.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The current JDK uses two constructors for `Date`—the `void` constructor that
    is intended to be the “now constructor,” and a constructor that takes a number
    of milliseconds since epoch.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you cannot avoid `java.util.Date`, you can still take advantage of the newer
    APIs by converting with code like the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we’ve met several different classes of data. Textual and numeric
    data are the most obvious examples, but as working programmers we will meet a
    large number of different sorts of data. Let’s move on to look at whole files
    of data and new ways to work with I/O and networking. Fortunately, Java provides
    good support for dealing with many of these abstractions.
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch09.xhtml#idm45927717366112-marker)) In fact, they are actually two of
    the known examples of *transcendental numbers*.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch09.xhtml#idm45927716685824-marker)) It is very difficult to get computers
    to produce true random numbers, and in the rare cases where this is done, specialized
    hardware is usually necessary.
  prefs: []
  type: TYPE_NORMAL
