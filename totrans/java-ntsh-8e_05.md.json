["```java\ninterface Centered {\n  void setCenter(double x, double y);\n  double getCenterX();\n  double getCenterY();\n}\n```", "```java\ninterface Positionable extends Centered {\n  void setUpperRightCorner(double x, double y);\n  double getUpperRightX();\n  double getUpperRightY();\n}\ninterface Transformable extends Scalable, Translatable, Rotatable {}\ninterface SuperShape extends Positionable, Transformable {}\n```", "```java\npublic class CenteredRectangle extends Rectangle implements Centered {\n  // New instance fields\n  private double cx, cy;\n\n  // A constructor\n  public CenteredRectangle(double cx, double cy, double w, double h) {\n    super(w, h);\n    this.cx = cx;\n    this.cy = cy;\n  }\n\n  // We inherit all the methods of Rectangle but must\n  // provide implementations of all the Centered methods.\n  public void setCenter(double x, double y) { cx = x; cy = y; }\n  public double getCenterX() { return cx; }\n  public double getCenterY() { return cy; }\n}\n```", "```java\nShape[] shapes = new Shape[3];      // Create an array to hold shapes\n\n// Create some centered shapes, and store them in the Shape[]\n// No cast necessary: these are all compatible assignments\nshapes[0] = new CenteredCircle(1.0, 1.0, 1.0);\nshapes[1] = new CenteredSquare(2.5, 2, 3);\nshapes[2] = new CenteredRectangle(2.3, 4.5, 3, 4);\n\n// Compute average area of the shapes and\n// average distance from the origin\ndouble totalArea = 0;\ndouble totalDistance = 0;\nfor(int i = 0; i < shapes.length; i = i + 1) {\n  totalArea += shapes[i].area();   // Compute the area of the shapes\n\n  // Be careful, in general, the use of instanceof to determine the\n  // runtime type of an object is quite often an indication of a\n  // problem with the design\n  if (shapes[i] instanceof Centered) { // The shape is a Centered shape\n    // Note the required cast from Shape to Centered (no cast would\n    // be required to go from CenteredSquare to Centered, however).\n    Centered c = (Centered) shapes[i];\n\n    double cx = c.getCenterX();    // Get coordinates of the center\n    double cy = c.getCenterY();    // Compute distance from origin\n    totalDistance += Math.sqrt(cx*cx + cy*cy);\n  }\n}\nSystem.out.println(\"Average area: \" + totalArea/shapes.length);\nSystem.out.println(\"Average distance: \" + totalDistance/shapes.length);\n```", "```java\ninterface Translatable {\n    Translatable deltaX(double dx);\n    Translatable deltaY(double dy);\n    Translatable delta(double dx, double dy);\n}\n```", "```java\npublic record Point(double x, double y) implements Translatable {\n    public Translatable deltaX(double dx) {\n        return delta(dx, 0.0);\n    }\n\n    public Translatable deltaY(double dy) {\n        return delta(0.0, dy);\n    }\n\n    public Translatable delta(double dx, double dy) {\n        return new Point(x + dx, y + dy);\n    }\n}\n```", "```java\nsealed interface Rotate90 permits Circle, Rectangle {\n    void clockwise();\n    void antiClockwise();\n}\n```", "```java\npublic final class Circle extends Shape implements Rotate90 {\n    // ...\n\n    @Override\n    public void clockwise() {\n        // No-op, circles are rotation-invariant\n    }\n\n    @Override\n    public void antiClockwise() {\n        // No-op, circles are rotation-invariant\n    }\n\n    // ...\n}\n```", "```java\npublic final class Rectangle extends Shape implements Rotate90 {\n    // ...\n\n    @Override\n    public void clockwise() {\n        // Swap width and height\n        double tmp = w;\n        w = h;\n        h = tmp;\n    }\n\n    @Override\n    public void antiClockwise() {\n        // Swap width and height\n        double tmp = w;\n        w = h;\n        h = tmp;\n    }\n\n    // ...\n}\n```", "```java\npublic interface Positionable extends Centered {\n  void setUpperRightCorner(double x, double y);\n  double getUpperRightX();\n  double getUpperRightY();\n  void setLowerLeftCorner(double x, double y);\n  double getLowerLeftX();\n  double getLowerLeftY();\n}\n```", "```java\n// The <E> syntax is Java's way of writing a generic type - see\n// the next section for full details. If you aren't familiar with\n// generics, just ignore that syntax for now.\ninterface List<E> {\n  // Other members omitted\n\n  public default void sort(Comparator<? super E> c) {\n    Collections.<E>sort(this, c);\n  }\n}\n```", "```java\ninterface Vocal {\n  default void call() {\n    System.out.println(\"Hello!\");\n  }\n}\n\ninterface Caller {\n  default void call() {\n    Switchboard.placeCall(this);\n  }\n}\n\npublic class Person implements Vocal, Caller {\n  // ... which default is used?\n}\n```", "```java\npublic class Person implements Vocal, Caller {\n\n    public void call() {\n        // Can do our own thing\n        // or delegate to either interface\n        // e.g.,\n        // Vocal.super.call();\n        // or\n        // Caller.super.call();\n    }\n}\n```", "```java\n// Before sorting the elements of a long arbitrary list, we may want\n// to make sure that the list allows fast random access.  If not,\n// it may be quicker to make a random-access copy of the list before\n// sorting it. Note that this is not necessary when using\n// java.util.Collections.sort().\nList l = ...;  // Some arbitrary list we're given\nif (l.size() > 2 && !(l instanceof RandomAccess)) {\n    l = new ArrayList(l);\n}\nsortListInPlace(l);\n```", "```java\nList shapes = new ArrayList();   // Create a List to hold shapes\n\n// Create some centered shapes, and store them in the list\nshapes.add(new CenteredCircle(1.0, 1.0, 1.0));\n// This is legal Java-but is a very bad design choice\nshapes.add(new CenteredSquare(2.5, 2, 3));\n\n// List::get() returns Object, so to get back a\n// CenteredCircle we must cast\nCenteredCircle c = (CenteredCircle)shapes.get(0);\n\n// Next line causes a runtime failure\nCenteredCircle c = (CenteredCircle)shapes.get(1);\n```", "```java\n// Create a List-of-CenteredCircle\nList<CenteredCircle> shapes = new ArrayList<CenteredCircle>();\n\n// Create some centered shapes, and store them in the list\nshapes.add(new CenteredCircle(1.0, 1.0, 1.0));\n\n// Next line will cause a compilation error\nshapes.add(new CenteredSquare(2.5, 2, 3));\n\n// List<CenteredCircle>::get() returns a CenteredCircle, no cast needed\nCenteredCircle c = shapes.get(0);\n```", "```java\ninterface Box<T> {\n  void box(T t);\n  T unbox();\n}\n```", "```java\ninterface List<E> extends Collection<E> {\n  boolean add(E e);\n  E get(int index);\n  // other methods omitted\n}\n```", "```java\n// Create a List-of-CenteredCircle using diamond syntax\nList<CenteredCircle> shapes = new ArrayList<>();\n```", "```java\nList someThings = getSomeThings();\n// Unsafe cast, but we know that the\n// contents of someThings are really strings\nList<String> myStrings = (List<String>)someThings;\n```", "```java\n// Won't compile\ninterface OrderCounter {\n  // Name maps to list of order numbers\n  int totalOrders(Map<String, List<String>> orders);\n\n  // Name maps to total orders made so far\n  int totalOrders(Map<String, Integer> orders);\n}\n```", "```java\n  int totalOrders(Map);\n```", "```java\npublic class Box<T> {\n    protected T value;\n\n    public void box(T t) {\n        value = t;\n    }\n\n    public T unbox() {\n        T t = value;\n        value = null;\n        return t;\n    }\n}\n```", "```java\npublic class NumberBox<T extends Number> extends Box<T> {\n    public int intValue() {\n        return value.intValue();\n    }\n}\n```", "```java\nNumberBox<Integer> ni = new NumberBox<>(); // This compiles fine\n\nNumberBox<Object> no = new NumberBox<>(); // Won't compile\n```", "```java\n// Compiles\nNumberBox n = new NumberBox();\n// This is very dangerous\nn.box(new Object());\n// Runtime error\nSystem.out.println(n.intValue());\n```", "```java\npublic class ComparingBox<T extends Comparable<T>> extends Box<T>\n                            implements Comparable<ComparingBox<T>> {\n    @Override\n    public int compareTo(ComparingBox<T> o) {\n        if (value == null)\n            return o.value == null ? 0 : -1;\n        return value.compareTo(o.value);\n    }\n}\n```", "```java\nString[] words = {\"Hello World!\"};\nObject[] objects = words;\n```", "```java\nArrays.sort(Object[] a);\n```", "```java\nString[] words = {\"Hello\", \"World!\"};\nObject[] objects = words;\n\n// Oh, dear, runtime error\nobjects[0] = new Integer(42);\n```", "```java\n// Is this legal?\nList<Object> objects = new ArrayList<String>();\n```", "```java\n// Is this legal?\nList<Object> objects = new ArrayList<String>();\n\n// What do we do about this?\nobjects.add(new Object());\n```", "```java\nObject o = new String(\"X\");\n```", "```java\n// Won't compile\nList<Object> objects = new ArrayList<String>();\n```", "```java\nArrayList<?> mysteryList = unknownList();\nObject o = mysteryList.get(0);\n```", "```java\n// Won't compile\nmysteryList.add(new Object());\n```", "```java\n// Won't compile\nList<?> unknowns = new ArrayList<?>();\n```", "```java\n// Perfectly legal\nList<?> objects = new ArrayList<String>();\n```", "```java\nList<Cat> cats = new ArrayList<Cat>();\nList<? extends Pet> pets = cats;\n```", "```java\npets.add(new Cat()); // won't compile\npets.add(new Pet()); // won't compile\ncats.add(new Cat());\n```", "```java\nPet p = pets.get(0);\n```", "```java\n// Note that this class is not generic\npublic class Utils {\n  public static <T> T comma(T a, T b) {\n    return b;\n  }\n}\n```", "```java\n@SuppressWarnings(\"unchecked\")\npublic <T> T[] toArray(T[] a) {\n    if (a.length < size)\n        // Make a new array of a's runtime type, but my contents:\n        return (T[]) Arrays.copyOf(elementData, size, a.getClass());\n    System.arraycopy(elementData, 0, a, 0, size);\n    if (a.length > size)\n        a[size] = null;\n    return a;\n}\n```", "```java\nList<String> l = new ArrayList<>();\nSystem.out.println(l);\n```", "```java\npublic enum PrimaryColor {\n  // The ; is not required at the end of the list of instances\n  RED, GREEN, BLUE\n}\n```", "```java\npublic enum Suit {\n    // ; at the end of list required for enums with parameters\n    HEART('♥'),\n    CLUB('♣'),\n    DIAMOND('♦'),\n    SPADE('♠');\n\n    private char symbol;\n    private char letter;\n\n    public char getSymbol() {\n        return symbol;\n    }\n\n    public char getLetter() {\n        return letter;\n    }\n\n    private Suit(char symbol) {\n        this.symbol = symbol;\n        this.letter = switch (symbol) {\n            case '♥' -> 'H';\n            case '♣' -> 'C';\n            case '♦' -> 'D';\n            case '♠' -> 'S';\n            default -> throw new RuntimeException(\"Illegal:\" + symbol);\n        };\n    }\n}\n```", "```java\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Nickname {\n    String[] value() default {};\n}\n```", "```java\n@NotNull String safeString = getMyString();\n```", "```java\n(p, q) -> { /* method body */ }\n```", "```java\nRunnable r  = () -> System.out.println(\"Hello\");\n```", "```java\n@FunctionalInterface\npublic interface FilenameFilter {\n    boolean accept(File dir, String name);\n}\n```", "```java\nFile dir = new File(\"/src\");      // The directory to list\n\nString[] filelist = dir.list((d, fName) -> fName.endsWith(\".java\"));\n```", "```java\n// In real code this would probably be\n// shorter because of type inference\n(MyObject myObj) -> myObj.toString()\n```", "```java\nMyObject::toString\n```", "```java\npublic interface IntHolder {\n    public int getValue();\n}\n\npublic class Weird {\n    public static void main(String[] args) {\n        IntHolder[] holders = new IntHolder[10];\n        for (int i = 0; i < 10; i++) {\n            final int fi = i;\n\n            holders[i] = () -> {\n                return fi;\n            };\n        }\n  // The lambda is now out of scope, but we have 10 valid instances\n  // of the class the lambda has been converted to in our array.\n  // The local variable fi is not in our scope here, but is still\n  // in scope for the getValue() method of each of those 10 objects.\n  // So call getValue() for each object and print it out.\n  // This prints the digits 0 to 9.\n        for (int i = 0; i < 10; i++) {\n            System.out.println(holders[i].getValue());\n        }\n    }\n}\n```", "```java\nfor (int i = 0; i < 10; i++) {\n    int fi = i;\n    holders[i] = () -> fi;\n}\n```", "```java\npublic interface Map<K, V> {\n    // ...\n\n    Set<Map.Entry<K, V>> entrySet();\n\n    // All nested interfaces are automatically static\n    interface Entry<K, V> {\n        K getKey();\n        V getValue();\n        V setValue(V value);\n\n        // other members elided\n    }\n\n    // other members elided\n}\n```", "```java\nimport java.util.Map.Entry;\n```", "```java\nimport java.util.Iterator;\n\npublic class LinkedStack {\n\n    // Our static member interface\n    public interface Linkable {\n        public Linkable getNext();\n        public void setNext(Linkable node);\n    }\n\n    // The head of the list\n    private Linkable head;\n\n    // Method bodies omitted here\n    public void push(Linkable node) { ... }\n    public Linkable pop() { ... }\n\n    // This method returns an Iterator object for this LinkedStack\n    public Iterator<Linkable> iterator() { return new LinkedIterator(); }\n\n    // Here is the implementation of the Iterator interface,\n    // defined as a nonstatic member class.\n    protected class LinkedIterator implements Iterator<Linkable> {\n        Linkable current;\n\n        // The constructor uses a private field of the containing class\n        public LinkedIterator() { current = head; }\n\n        // The following three methods are defined\n        // by the Iterator interface\n        public boolean hasNext() {  return current != null; }\n\n        public Linkable next() {\n            if (current == null)\n              throw new java.util.NoSuchElementException();\n            Linkable value = current;\n            current = current.getNext();\n            return value;\n        }\n\n        public void remove() { throw new UnsupportedOperationException(); }\n    }\n}\n```", "```java\npublic LinkedIterator() { current = head; }\n```", "```java\npublic LinkedIterator() { this.current = LinkedStack.this.head; }\n```", "```java\n// This method returns an Iterator object for this LinkedStack\npublic Iterator<Linkable> iterator() {\n    // Here's the definition of LinkedIterator as a local class\n    class LinkedIterator implements Iterator<Linkable> {\n        Linkable current;\n\n        // The constructor uses a private field of the containing class\n        public LinkedIterator() { current = head; }\n\n        // The following three methods are defined\n        // by the Iterator interface\n        public boolean hasNext() {  return current != null; }\n\n        public Linkable next() {\n            if (current == null)\n              throw new java.util.NoSuchElementException();\n            Linkable value = current;\n            current = current.getNext();\n            return value;\n        }\n\n        public void remove() { throw new UnsupportedOperationException(); }\n    }\n\n    // Create and return an instance of the class we just defined\n    return new LinkedIterator();\n}\n```", "```java\nclass A { protected char a = 'a'; }\nclass B { protected char b = 'b'; }\n\npublic class C extends A {\n  private char c = 'c';         // Private fields visible to local class\n  public static char d = 'd';\n  public void createLocalObject(final char e)\n  {\n    final char f = 'f';\n    int i = 0;                  // i not final; not usable by local class\n    class Local extends B\n    {\n      char g = 'g';\n      public void printVars()\n      {\n        // All of these fields and variables are accessible to this class\n        System.out.println(g);  // (this.g) g is a field of this class\n        System.out.println(f);  // f is a final local variable\n        System.out.println(e);  // e is a final local parameter\n        System.out.println(d);  // (C.this.d) d field of containing class\n        System.out.println(c);  // (C.this.c) c field of containing class\n        System.out.println(b);  // b is inherited by this class\n        System.out.println(a);  // a is inherited by the containing class\n      }\n    }\n    Local l = new Local();      // Create an instance of the local class\n    l.printVars();              // and call its printVars() method.\n  }\n}\n```", "```java\npublic Iterator<Linkable> iterator() {\n    // The anonymous class is defined as part of the return statement\n    return new Iterator<Linkable>() {\n        Linkable current;\n        // Replace constructor with an instance initializer\n        { current = head; }\n\n        // The following three methods are defined\n        // by the Iterator interface\n        public boolean hasNext() {  return current != null; }\n        public Linkable next() {\n            if (current == null)\n              throw new java.util.NoSuchElementException();\n            Linkable value = current;\n            current = current.getNext();\n            return value;\n        }\n        public void remove() { throw new UnsupportedOperationException(); }\n    };  // Note the required semicolon. It terminates the return statement\n}\n```", "```java\n@FunctionalInterface\npublic interface MyRunnable {\n    void run();\n}\n```", "```java\nMyRunnable myR = () -> System.out.println(\"Hello\");\nRunnable r = (Runnable)myR;\nr.run();\n```", "```java\n@FunctionalInterface\npublic interface MyIntProvider {\n    int run() throws InterruptedException;\n}\n```", "```java\nMyIntProvider prov       = () -> 42;\nSupplier<Integer> sup    = () -> 42;\nCallable<Integer> callMe = () -> 42;\n```", "```java\nvar ls = new ArrayList<String>();\n```", "```java\npublic class Test {\n    public static void main(String[] args) {\n        (new Object() {\n            public void bar() {\n                System.out.println(\"bar!\");\n            }\n        }).bar();\n    }\n}\n```", "```java\nvar o = new Object() {\n    public void bar() {\n        System.out.println(\"bar!\");\n    }\n};\n\no.bar();\n```"]