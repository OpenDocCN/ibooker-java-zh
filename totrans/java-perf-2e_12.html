<html><head></head><body><section data-pdf-bookmark="Chapter 12. Java SE API Tips" data-type="chapter" epub:type="chapter"><div class="chapter" id="Misc">&#13;
<h1><span class="label">Chapter 12. </span>Java SE API Tips</h1>&#13;
&#13;
&#13;
<p><a data-primary="Java SE (Standard Edition) API" data-type="indexterm" id="ix_ch12-asciidoc0"/>This chapter covers areas of the Java SE API that have implementation&#13;
quirks affecting their performance. Many such implementation&#13;
details exist throughout the JDK; these are the areas where I consistently&#13;
uncover performance issues (even in my own code). This chapter includes details on the best&#13;
way to handle strings (and especially duplicate strings); ways to properly&#13;
buffer I/O; classloading and ways to improve startup of applications that&#13;
use a lot of classes; proper use of collections; and JDK 8 features like&#13;
lambdas and streams.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Strings" data-type="sect1"><div class="sect1" id="StringHandling">&#13;
<h1>Strings</h1>&#13;
&#13;
<p><a data-primary="Java SE (Standard Edition) API" data-secondary="strings" data-type="indexterm" id="ix_ch12-asciidoc1"/><a data-primary="strings" data-type="indexterm" id="ix_ch12-asciidoc2"/>Strings are (unsurprisingly) the most common Java object. In this section,&#13;
we’ll look at a variety of ways to handle all the memory consumed by string&#13;
objects; these techniques can often significantly reduce the amount of&#13;
heap your program requires. We’ll also cover a new JDK 11 feature of strings&#13;
involving concatenation.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Compact Strings" data-type="sect2"><div class="sect2" id="CompactStrings">&#13;
<h2>Compact Strings</h2>&#13;
&#13;
<p><a data-primary="compact strings" data-type="indexterm" id="idm45775544138696"/><a data-primary="strings" data-secondary="compact" data-type="indexterm" id="idm45775544137992"/>In Java 8, all strings are encoded as arrays of 16-bit characters, regardless&#13;
of the encoding of the string. This is wasteful: most Western locales&#13;
can encode strings into 8-bit byte arrays, and even in a locale that requires&#13;
16 bits for all characters, strings like program constants&#13;
 often can be encoded as 8-bit bytes.</p>&#13;
&#13;
<p>In Java 11, strings are encoded as arrays of 8-bit bytes unless they&#13;
explicitly need&#13;
16-bit characters; these strings are known as <em>compact strings</em>. A similar (experimental) feature in Java 6 was known as <em>compressed strings</em>;&#13;
compact strings are conceptually the same but differ greatly in implementation.</p>&#13;
&#13;
<p>Hence, the size of an average Java string in Java 11 is&#13;
roughly half the size of the same string in Java 8. This generally is a huge&#13;
savings: on average, 50% of a typical Java heap may be consumed by string&#13;
objects. Programs will vary, of course, but on average the heap requirement&#13;
of such a program running with Java 11 is only 75% of that same program&#13;
running in Java 8.</p>&#13;
&#13;
<p>It’s easy enough to construct examples where this has an outsize benefit.&#13;
One can run a program in Java 8 that spends an enormous time performing&#13;
garbage collection. Running that same program in Java 11 with the same size&#13;
heap could require virtually no time in the collector, leading to reported&#13;
gains of three to ten times in performance. Take claims like that with a&#13;
grain of salt: you’re typically not going to run any Java program in such&#13;
a constrained heap. All things being equal, though, you will see a&#13;
reduction in the amount of time spent in garbage collection.</p>&#13;
&#13;
<p>For a well-tuned application, the real benefit is in memory usage: you&#13;
can immediately reduce the maximum heap size of the average program by 25%&#13;
and still get the same performance. Conversely, if you leave the heap size&#13;
unchanged, you should be able to introduce more load into the application&#13;
and not experience any GC bottlenecks (though the rest of the application&#13;
must be able to handle the increased load).</p>&#13;
&#13;
<p><a data-primary="-XX:+CompactStrings" data-type="indexterm" id="idm45775544082440"/>This feature is controlled by the&#13;
<span class="keep-together"><code>-XX:+CompactStrings</code></span>&#13;
flag, which is <code>true</code> by default. But unlike the compressed strings in&#13;
Java 6, compact strings are robust and well-performing; you’ll almost always&#13;
want to keep the default setting. One possible exception is in a program&#13;
in which all the strings require 16-bit encodings: operations on&#13;
those strings can be slightly longer in compacted strings than in&#13;
uncompacted strings.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Duplicate Strings and String Interning" data-type="sect2"><div class="sect2" id="StringInterning">&#13;
<h2>Duplicate Strings and String Interning</h2>&#13;
&#13;
<p><a data-primary="strings" data-secondary="duplicate strings/string interning" data-type="indexterm" id="ix_ch12-asciidoc3"/>It is common to create many string objects that contain the same sequence of&#13;
characters. These objects unnecessarily take space in the heap; since strings&#13;
are immutable, it is often better to reuse the existing strings. We&#13;
discussed a general case of this in <a data-type="xref" href="ch07.html#Memory">Chapter 7</a> for arbitrary objects with&#13;
a canonical representation; this section expands on that idea in&#13;
relation to strings.</p>&#13;
&#13;
<p>Knowing if you have a large number of duplicate strings requires&#13;
heap analysis. Here’s one way to do that with the Eclipse Memory Analyzer:</p>&#13;
<ol>&#13;
<li>&#13;
<p>Load the heap dump.</p>&#13;
</li>&#13;
<li>&#13;
<p>From the Query Browser, select Java Basics → Group By Value.</p>&#13;
</li>&#13;
<li>&#13;
<p>For the <code>objects</code> argument, type in <strong><code>java.lang.String</code></strong>.</p>&#13;
</li>&#13;
<li>&#13;
<p>Click the Finish button.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>The result is shown in <a data-type="xref" href="#FigureStringIntern">Figure 12-1</a>. We have&#13;
more than 300,000 copies of each of the strings <code>Name</code>, <code>Memnor</code>, and&#13;
<code>Parent Name</code>. Several other strings have multiple copies as well; in all,&#13;
this heap has more than 2.3 million duplicate strings.</p>&#13;
&#13;
<figure><div class="figure" id="FigureStringIntern">&#13;
<img alt="Duplicate String and their memory sizes." src="assets/jp2e_1201.png"/>&#13;
<h6><span class="label">Figure 12-1. </span>Memory consumed by duplicate strings</h6>&#13;
</div></figure>&#13;
&#13;
<p>The duplicate strings can be removed in three ways:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Performing automatic deduplication via G1 GC</p>&#13;
</li>&#13;
<li>&#13;
<p>Using the <code>intern()</code> method of the <code>String</code> class to create the canonical version of the string</p>&#13;
</li>&#13;
<li>&#13;
<p>Using a custom method to create a canonical version of the string</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="String deduplication" data-type="sect3"><div class="sect3" id="idm45775544060808">&#13;
<h3>String deduplication</h3>&#13;
&#13;
<p><a data-primary="deduplication (String)" data-type="indexterm" id="ix_ch12-asciidoc4"/><a data-primary="strings" data-secondary="deduplication" data-type="indexterm" id="ix_ch12-asciidoc5"/>The simplest mechanism is to let the JVM find the duplicate strings and&#13;
<em>deduplicate</em> them: arrange for all references to point to a single copy and&#13;
then free the remaining copies. <a data-primary="-XX:+UseStringDeduplication" data-type="indexterm" id="idm45775544056232"/>This is possible only when using&#13;
G1 GC and only when specifying the&#13;
<span class="keep-together"><code>-XX:+UseStringDeduplication</code></span>&#13;
flag (which by default is <code>false</code>). This feature exists in Java 8 only after&#13;
version 20, and all releases of Java 11.</p>&#13;
&#13;
<p>This feature is not enabled by default for three reasons.&#13;
First, it requires extra processing&#13;
during the young and mixed phases of G1 GC, making them slightly longer.&#13;
Second, it&#13;
requires an extra thread that runs concurrently with the application,&#13;
potentially taking CPU cycles away from application threads. And third,&#13;
if there are few deduplicated strings, the memory use of&#13;
the application will be higher (instead of lower); this extra memory comes&#13;
from the bookkeeping involved in tracking all the strings to look for&#13;
duplications.</p>&#13;
&#13;
<p>This is the sort of option that needs thorough testing before enabling&#13;
in production: it may help your application,&#13;
though in some cases it will make things worse. Odds are in your&#13;
favor, though: Java engineers estimate that the expected benefit of enabling&#13;
string deduplication is 10%.</p>&#13;
&#13;
<p><a data-primary="-Xlog:gc+stringdedup*=debug" data-type="indexterm" id="idm45775544052328"/><a data-primary="-XX:+PrintStringDeduplicationStatistics" data-type="indexterm" id="idm45775544051608"/>If you want to see how string deduplication is behaving in your application,&#13;
run it with the&#13;
<span class="keep-together"><code>-XX:+PrintStringDeduplicationStatistics</code></span>&#13;
flag in Java 8, or the&#13;
<span class="keep-together"><code>-Xlog:gc+stringdedup*=debug</code></span>&#13;
flag in Java 11. The resulting log will look something like this:</p>&#13;
&#13;
<pre data-type="programlisting">[0.896s][debug][gc,stringdedup]   Last Exec: 110.434ms, Idle: 729.700ms,&#13;
                                  Blocked: 0/0.000ms&#13;
[0.896s][debug][gc,stringdedup]     Inspected:           62420&#13;
[0.896s][debug][gc,stringdedup]       Skipped:               0(  0.0%)&#13;
[0.896s][debug][gc,stringdedup]       Hashed:            62420(100.0%)&#13;
[0.896s][debug][gc,stringdedup]       Known:                 0(  0.0%)&#13;
[0.896s][debug][gc,stringdedup]       New:               62420(100.0%)&#13;
                                                         3291.7K&#13;
[0.896s][debug][gc,stringdedup]     Deduplicated:        15604( 25.0%)&#13;
                                                         731.4K( 22.2%)&#13;
[0.896s][debug][gc,stringdedup]       Young:                 0(  0.0%)&#13;
                                                         0.0B(  0.0%)&#13;
[0.896s][debug][gc,stringdedup]       Old:               15604(100.0%)&#13;
                                                         731.4K(100.0%)</pre>&#13;
&#13;
<p>This pass of the string deduplication thread lasted 110 ms, during which&#13;
it found 15,604 duplicated strings (out of the 62,420 strings that had been&#13;
identified as candidates for deduplication). The total memory saved from that&#13;
was 731.4K—around the 10% we would hope for from this optimization.</p>&#13;
&#13;
<p>The code that produced this log was set up so that 25% of the strings were&#13;
duplicates, which is what the JVM engineers say is typical for a Java&#13;
application. (In my experience—as I mentioned previously—the proportion of&#13;
strings in a heap is closer to 50%; chacun à son goût.)<sup><a data-type="noteref" href="ch12.html#idm45775544045928" id="idm45775544045928-marker">1</a></sup>&#13;
The reason that we&#13;
didn’t save 25% of string memory is that this optimization arranges for&#13;
only the backing character or byte array of the string to be shared; the rest of&#13;
the string object is not shared. A string object has a 24- to 32-byte&#13;
overhead for its other fields (the difference is due to platform&#13;
implementations). Hence, two identical strings of 16 characters&#13;
will occupy 44 (or 52) bytes each before they are deduplicated for a total of&#13;
80 bytes; after deduplication, they will occupy 64 bytes. If the strings&#13;
were interned (as discussed in the following section), they would occupy only 40 bytes.</p>&#13;
&#13;
<p><a data-primary="canonical objects" data-secondary="strings" data-type="indexterm" id="idm45775544043608"/>As I mentioned, this processing of the strings occurred concurrently with&#13;
the application threads. But it’s actually the last stage in the&#13;
process. During a young collection, all strings in the young generation are&#13;
examined. Those that are promoted into the old generation become the&#13;
candidates that the background thread examines (once the young collection has&#13;
completed). In addition, recall the discussion from <a data-type="xref" href="ch06.html#Collectors">Chapter 6</a> about the&#13;
tenuring of objects within the survivor spaces of the young generation:&#13;
objects can ping-pong between the survivor spaces for a while before being&#13;
promoted to the old generation. Strings that have a tenuring age of (by&#13;
default)&#13;
three—meaning they have been copied into a survivor space three times—also&#13;
become candidates for deduplication and will be processed by that background&#13;
thread.</p>&#13;
&#13;
<p>This has the effect that short-lived strings are not deduplicated, which is likely <span class="keep-together">a good thing:</span> you probably don’t want to spend the CPU cycles and memory to deduplicate something that is about to be thrown away. Like tuning the tenuring cycle <span class="keep-together">in general,</span> changing the point at which this happens requires a lot of testing and <span class="keep-together">is done</span> only in unusual circumstances. But for the record, <a data-primary="-XX:StringDeduplicationAgeThreshold=N" data-type="indexterm" id="idm45775544037960"/>the point at which  <span class="keep-together">the tenured string</span> is eligible for collection is controlled via the&#13;
<span class="keep-together"><code>-XX:StringDeduplicationAgeThreshold=<em>N</em></code></span> flag, which has a default value of 3.<a data-startref="ix_ch12-asciidoc5" data-type="indexterm" id="idm45775544035176"/><a data-startref="ix_ch12-asciidoc4" data-type="indexterm" id="idm45775544034536"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="String interning" data-type="sect3"><div class="sect3" id="idm45775544060184">&#13;
<h3>String interning</h3>&#13;
&#13;
<p><a data-primary="interned strings" data-secondary="basics" data-type="indexterm" id="ix_ch12-asciidoc6"/>The typical way to handle duplicate strings at a programmatic level is&#13;
to use the&#13;
<span class="keep-together"><code>intern()</code></span>&#13;
method of the <code>String</code> class.</p>&#13;
&#13;
<p>Like most optimizations, interning strings shouldn’t be&#13;
done arbitrarily, but it can be effective if lots of duplicate&#13;
strings are occupying a significant portion of the heap. But it does often&#13;
require special tuning (and in the next section, we’ll explore a&#13;
custom way that is beneficial in some circumstances).</p>&#13;
&#13;
<p>Interned strings are held in a special hash table that is in native memory&#13;
(though the strings themselves are in the heap). This hash table differs&#13;
from the hash table and hash maps you are familiar with in Java because this&#13;
native hash table has a fixed size: 60,013 in Java 8 and 65,536 in Java 11.&#13;
(If you’re on a 32-bit Windows JVM, the size is 1,009.) That means you&#13;
can store only about 32,000 interned strings before the hash table starts to&#13;
have collisions.</p>&#13;
&#13;
<p><a data-primary="-XX:+StringTableSize=N" data-type="indexterm" id="idm45775544027848"/>The size of this table can be set when&#13;
the JVM starts by using the flag&#13;
<span class="keep-together"><code>-XX:StringTableSize=</code><em><code>N</code></em></span>&#13;
(which defaults to&#13;
1,009, 60,013, or 65,536 as previously mentioned). If an application will&#13;
intern a lot&#13;
of strings, this&#13;
number should be increased. The string intern table will operate most&#13;
efficiently if&#13;
that value is a prime number.</p>&#13;
<aside class="less_space pagebreak-before" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45775544025368">&#13;
<h5>Fixed-Size Hash Tables</h5>&#13;
<p><a data-primary="fixed-size hash tables" data-type="indexterm" id="idm45775544023704"/><a data-primary="hash tables, fixed-size" data-type="indexterm" id="idm45775544023000"/>If you’re not familiar with the basic structure of hash tables and hash maps,&#13;
you may be wondering what is meant by a <em>fixed-size hash table</em> (particularly&#13;
since the Java implementations of those classes are not of fixed size).</p>&#13;
&#13;
<p>Conceptually, a hash table contains an array that can hold a certain number of&#13;
entries (each element in the array is called a <em>bucket</em>). When something is&#13;
stored in a&#13;
hash table, the index it is stored at is calculated from its  <code>hashCode % numberOfBuckets</code>. It is quite possible for two objects&#13;
with different hash values to map to the same bucket in this scheme,&#13;
so&#13;
each bucket is really a linked list of all the stored items that map to that&#13;
bucket. When two objects map to the same bucket, it is called a <em>collision</em>.</p>&#13;
&#13;
<p>As more and more objects are inserted into this table, more and&#13;
more collisions occur; more items get stored into each linked list.&#13;
Finding an item then becomes a matter of searching through a linked list.&#13;
That can be very slow, particularly as the list gets longer.</p>&#13;
&#13;
<p>The way around this is to size the hash table so that it has more buckets&#13;
(and, as a result, fewer collisions). Many implementations do that&#13;
dynamically; in fact, that is the way the Java&#13;
<span class="keep-together"><code>Hashtable</code></span>&#13;
and&#13;
<span class="keep-together"><code>HashMap</code></span>&#13;
classes work.</p>&#13;
&#13;
<p>But other implementations—like the one internal to the JVM&#13;
being discussed here—cannot&#13;
resize themselves; the size of their array is fixed when the map is created.</p>&#13;
</div></aside>&#13;
&#13;
<p>The performance of the&#13;
<span class="keep-together"><code>intern()</code></span>&#13;
method is dominated by how well&#13;
the string table size is tuned. As an example, <a data-type="xref" href="#TableStringIntern">Table 12-1</a> shows the total time to&#13;
create and intern 1 million randomly created strings with and without that&#13;
tuning.</p>&#13;
<table id="TableStringIntern">&#13;
<caption><span class="label">Table 12-1. </span>Time to intern 1 million strings</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Tuning</th>&#13;
<th>100% hit rate</th>&#13;
<th>0% hit rate</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p>String table size 60013</p></td>&#13;
<td><p>4.992 ± 2.9 seconds</p></td>&#13;
<td><p>2.759 ± 0.13 seconds</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>String table size 1 million</p></td>&#13;
<td><p>2.446 ± 0.6 seconds</p></td>&#13;
<td><p>2.737 ± 0.36 seconds</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>Note the severe penalty for the improperly sized string intern table when&#13;
there is a 100% hit rate.&#13;
Once the table is sized according to the expected data, performance is&#13;
drastically improved.</p>&#13;
&#13;
<p>The 0% hit rate table may be a little surprising because the performance with and&#13;
without the tuning is essentially the same. In this test case, the strings&#13;
are discarded immediately after being interned. The internal string table&#13;
functions as if the keys are weak references, so when the string is&#13;
discarded, the string table can clear it. Hence, in this test case the&#13;
string table never actually fills up; it ends up having just a few entries&#13;
(since only a few strings are strongly held at any time).</p>&#13;
&#13;
<p><a data-primary="-XX:+PrintStringTableStatistics" data-type="indexterm" id="idm45775544003704"/>In order to see how the string table is performing, run your&#13;
application with the&#13;
<span class="keep-together"><code>-XX:+PrintStringTableStatistics</code></span>&#13;
argument (which is <code>false</code> by default). When the&#13;
JVM exits, it will print out a table like this:</p>&#13;
&#13;
<pre data-type="programlisting">StringTable statistics:&#13;
Number of buckets       :     60013 =    480104 bytes, avg   8.000&#13;
Number of entries       :   2002784 =  48066816 bytes, avg  24.000&#13;
Number of literals      :   2002784 = 606291264 bytes, avg 302.724&#13;
Total footprint         :           = 654838184 bytes&#13;
Average bucket size     :    33.373&#13;
Variance of bucket size :    33.459&#13;
Std. dev. of bucket size:     5.784&#13;
Maximum bucket size     :        60</pre>&#13;
&#13;
<p>This output is from the 100% hit rate example. After an iteration of that,&#13;
there are&#13;
2,002,784 interned strings (2 million are from our test with one warm-up and&#13;
one measurement cycle; the remainder are from <code>jmh</code> and the JDK classes).&#13;
The entries that most concern us are the average and maximum bucket size:&#13;
we have to traverse on average 33 and at most 60 entries in a linked list&#13;
to search an entry in the hash table. Ideally, the average length should be&#13;
less than one and the maximum close to one. That’s what we see in the 0%&#13;
hit rate&#13;
case:</p>&#13;
&#13;
<pre data-type="programlisting">Number of buckets       :     60013 =    480104 bytes, avg   8.000&#13;
Number of entries       :      2753 =     66072 bytes, avg  24.000&#13;
Number of literals      :      2753 =    197408 bytes, avg  71.707&#13;
Total footprint         :           =    743584 bytes&#13;
Average bucket size     :     0.046&#13;
Variance of bucket size :     0.046&#13;
Std. dev. of bucket size:     0.214&#13;
Maximum bucket size     :         3</pre>&#13;
&#13;
<p>Because the strings are quickly freed from the table, we end up with only 2,753&#13;
entries in the table, which is fine for the default size of 60,013.</p>&#13;
&#13;
<p>The number of interned strings an application has allocated&#13;
(and their total size) can also be obtained using the <code>jmap</code> command:</p>&#13;
<pre data-type="programlisting">&#13;
% <strong>jmap -heap process_id</strong>&#13;
... other output ...&#13;
36361 interned Strings occupying 3247040 bytes.&#13;
</pre>&#13;
&#13;
<p>The penalty for setting the size of the string table too high is minimal:&#13;
each bucket takes only 8 bytes,&#13;
so&#13;
having a few thousand more entries than optimal is a one-time cost of a few&#13;
kilobytes of native (not heap) memory.</p>&#13;
<aside class="less_space pagebreak-before" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45775543994488">&#13;
<h5>String Interning and Equals</h5>&#13;
<p><a data-primary="interned strings" data-secondary="String.equals versus == operator" data-type="indexterm" id="idm45775543992984"/>On the topic of interning strings, what about using the&#13;
<span class="keep-together"><code>intern()</code></span>&#13;
method to make the program run faster,&#13;
since interned strings can be compared via the <code>==</code> operator?&#13;
That is a popular thought, though in most cases it turns out&#13;
to be a myth. The&#13;
<span class="keep-together"><code>String.equals()</code></span>&#13;
method is pretty fast. It starts by knowing that&#13;
unequal-length strings are never equal, though if the strings have&#13;
equal length, it must scan the string and compare all the characters (at&#13;
least until it finds that the strings do not match). Comparing&#13;
strings via the <code>==</code> operation is undeniably faster, but&#13;
the cost of interning the string must also be taken into consideration.&#13;
That requires (among other things) calculating&#13;
the string’s hash code, which means scanning the entire string and performing&#13;
an operation on each of its characters (just as the&#13;
<span class="keep-together"><code>equals()</code></span>&#13;
method must do).</p>&#13;
&#13;
<p>The only time a benefit in string comparison&#13;
can be expected from using the&#13;
<span class="keep-together"><code>intern()</code></span>&#13;
method is if an application&#13;
performs a lot&#13;
of repeated comparisons on a set of strings of the same length. If <em>both</em>&#13;
strings have been&#13;
previously interned, the <code>==</code> comparison is faster;&#13;
the cost of calling the&#13;
<span class="keep-together"><code>intern()</code></span>&#13;
method needn’t be counted more than once.&#13;
But in the general case, the costs are mostly the same.<a data-startref="ix_ch12-asciidoc6" data-type="indexterm" id="idm45775543984568"/></p>&#13;
</div></aside>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Custom string interning" data-type="sect3"><div class="sect3" id="idm45775544033400">&#13;
<h3>Custom string interning</h3>&#13;
&#13;
<p><a data-primary="interned strings" data-secondary="custom" data-type="indexterm" id="idm45775543982360"/>Tuning a string table is a bit awkward; could we do better by just using&#13;
a custom interning scheme that keeps the important strings in a&#13;
hash map? The code for that was also outlined in <a data-type="xref" href="ch02.html#SampleApplications">Chapter 2</a>.</p>&#13;
&#13;
<p><a data-type="xref" href="#TableCustomIntern">Table 12-2</a> points us to the answer to that question. In addition&#13;
to using a regular <code>ConcurrentHashMap</code> to hold the interned strings, that&#13;
table also shows the use of a <code>CustomConcurrentHashMap</code> from the extra classes&#13;
developed as part of JSR166. That custom map allows us to have weak references&#13;
for the keys, so its behavior more closely mimics the string intern table.</p>&#13;
<table id="TableCustomIntern">&#13;
<caption><span class="label">Table 12-2. </span>Time to intern 1 million strings via custom code</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Implementation</th>&#13;
<th>100% hit rate</th>&#13;
<th>0% hit rate</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p><code>ConcurrentHashMap</code></p></td>&#13;
<td><p>7.665 ± 6.9 seconds</p></td>&#13;
<td><p>5.490 ± 2.462 seconds</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>CustomConcurrentHashMap</code></p></td>&#13;
<td><p>2.743 ± 0.4 seconds</p></td>&#13;
<td><p>3.684 ± 0.5 seconds</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>In the 100% hit rate test, <code>ConcurrentHashMap</code> suffers from the same&#13;
issues we saw with the internal string table: a lot of GC pressure&#13;
from the entries is building up over each iteration. This is from a test with&#13;
a 30 GB heap; smaller heaps will give even worse results.</p>&#13;
&#13;
<p>As with all microbenchmarks, think deeply about the use case here. The&#13;
<code>Concurren⁠t​HashMap</code> can be explicitly managed rather than the setup we&#13;
have here, which keeps stuffing newly created strings into it.&#13;
Depending on the application, that may or may not be easy to do; if it is&#13;
easy enough, the <code>ConcurrentHashMap</code> test will show the same benefits&#13;
as regular interning or the <code>CustomConcurrentHashMap</code> test. And in a real&#13;
application, the GC pressure is really the point: we’re going to&#13;
use this method only to remove duplicate strings in an attempt to save GC cycles.</p>&#13;
&#13;
<p>Still, neither case is really better than the test with a properly tuned&#13;
string table. The advantage of the custom map is that it didn’t need&#13;
to have a size set in advance: it could resize itself as needed. Hence, it&#13;
is far more adaptable to a range of applications than using the&#13;
<code>intern()</code> method and tuning the string table size in an application-dependent&#13;
manner.<a data-startref="ix_ch12-asciidoc3" data-type="indexterm" id="idm45775543965256"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="String Concatenation" data-type="sect2"><div class="sect2" id="idm45775544079416">&#13;
<h2>String Concatenation</h2>&#13;
&#13;
<p><a data-primary="concatenation" data-type="indexterm" id="ix_ch12-asciidoc7"/><a data-primary="strings" data-secondary="concatenation" data-type="indexterm" id="ix_ch12-asciidoc8"/>String concatenation is another area of potential performance&#13;
pitfalls. Consider a simple string concatenation like this:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="n">String</code> <code class="n">answer</code> <code class="o">=</code> <code class="n">integerPart</code> <code class="o">+</code> <code class="s">"."</code> <code class="o">+</code> <code class="n">mantissa</code><code class="o">;</code></pre>&#13;
&#13;
<p>Special optimizations in Java can handle this construct (though&#13;
the details differ between releases).</p>&#13;
&#13;
<p>In Java 8, the <code>javac</code> compiler turns that statement into this code:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="n">String</code> <code class="n">answer</code> <code class="o">=</code> <code class="k">new</code> <code class="n">StringBuilder</code><code class="o">(</code><code class="n">integerPart</code><code class="o">).</code><code class="na">append</code><code class="o">(</code><code class="s">"."</code><code class="o">)</code>&#13;
                         <code class="o">.</code><code class="na">append</code><code class="o">(</code><code class="n">mantissa</code><code class="o">).</code><code class="na">toString</code><code class="o">();</code></pre>&#13;
&#13;
<p><a data-primary="-XX:+OptimizeStringConcat" data-type="indexterm" id="idm45775543926696"/>The JVM has special code to handle this kind of construct (which is&#13;
controlled by setting the&#13;
<code class="keep-together">-XX:+OptimizeStringConcat</code>&#13;
flag, which is <code>true</code> by default).</p>&#13;
&#13;
<p>In Java 11, the <code>javac</code> compiler produces quite different bytecode; that&#13;
code calls a special method within the JVM itself that optimizes&#13;
the string concatenation.</p>&#13;
&#13;
<p>This is one of the few times where the bytecode between releases matter.&#13;
Typically, when you move to a newer release, there’s no need to recompile&#13;
old code: the bytecode will be the same. (You’ll want to compile new code&#13;
with the new compiler to use new language features, of course.) But this&#13;
particular optimization depends on the actual bytecode. If you compile code&#13;
that performs string concatenation with Java 8 and run it with Java 11,&#13;
the Java 11 JDK will apply the same optimization it did in Java 8. The&#13;
code will still be optimized and run quite fast.</p>&#13;
&#13;
<p>If you recompile the code under Java 11, though, the bytecode will use the&#13;
new optimizations and potentially be even faster.</p>&#13;
&#13;
<p>Let’s consider the following three cases that concatenate two strings:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="nd">@Benchmark</code>&#13;
<code class="kd">public</code> <code class="kt">void</code> <code class="nf">testSingleStringBuilder</code><code class="o">(</code><code class="n">Blackhole</code> <code class="n">bh</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="n">String</code> <code class="n">s</code> <code class="o">=</code> <code class="k">new</code> <code class="n">StringBuilder</code><code class="o">(</code><code class="n">prefix</code><code class="o">).</code><code class="na">append</code><code class="o">(</code><code class="n">strings</code><code class="o">[</code><code class="mi">0</code><code class="o">]).</code><code class="na">toString</code><code class="o">();</code>&#13;
    <code class="n">bh</code><code class="o">.</code><code class="na">consume</code><code class="o">(</code><code class="n">s</code><code class="o">);</code>&#13;
<code class="o">}</code>&#13;
&#13;
<code class="nd">@Benchmark</code>&#13;
<code class="kd">public</code> <code class="kt">void</code> <code class="nf">testSingleJDK11Style</code><code class="o">(</code><code class="n">Blackhole</code> <code class="n">bh</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="n">String</code> <code class="n">s</code> <code class="o">=</code> <code class="n">prefix</code> <code class="o">+</code> <code class="n">strings</code><code class="o">[</code><code class="mi">0</code><code class="o">];</code>&#13;
    <code class="n">bh</code><code class="o">.</code><code class="na">consume</code><code class="o">(</code><code class="n">s</code><code class="o">);</code>&#13;
<code class="o">}</code>&#13;
&#13;
<code class="nd">@Benchmark</code>&#13;
<code class="kd">public</code> <code class="kt">void</code> <code class="nf">testSingleJDK8Style</code><code class="o">(</code><code class="n">Blackhole</code> <code class="n">bh</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="n">String</code> <code class="n">s</code> <code class="o">=</code> <code class="k">new</code> <code class="n">StringBuilder</code><code class="o">().</code><code class="na">append</code><code class="o">(</code><code class="n">prefix</code><code class="o">).</code><code class="na">append</code><code class="o">(</code><code class="n">strings</code><code class="o">[</code><code class="mi">0</code><code class="o">]).</code><code class="na">toString</code><code class="o">();</code>&#13;
    <code class="n">bh</code><code class="o">.</code><code class="na">consume</code><code class="o">(</code><code class="n">s</code><code class="o">);</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p>The first method is how we would code this operation by hand. The second&#13;
method (when compiled with Java 11) will produce the latest optimizations, and&#13;
the final method (no matter which compiler is used) will be optimized the same&#13;
way in Java 8 and Java 11.</p>&#13;
&#13;
<p><a data-type="xref" href="#TableSingleConcat">Table 12-3</a> shows the results of these operations.</p>&#13;
<table id="TableSingleConcat">&#13;
<caption><span class="label">Table 12-3. </span>Performance of single concatenation</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Mode</th>&#13;
<th>Time per operation</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p>JDK 11 optimization</p></td>&#13;
<td><p>47.7 ± 0.3 ns</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>JDK 8 optimization</p></td>&#13;
<td><p>42.9 ± 0.3 ns</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>String builder</p></td>&#13;
<td><p>87.8 ± 0.7 ns</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>In this case, there’s little real difference between old (Java 8) and new&#13;
(Java 11)&#13;
concatenation optimizations; though <code>jmh</code> tells us that the difference is&#13;
statistically significant, they are not particularly important.&#13;
The key point is that both&#13;
optimizations are better than handcoding this simple&#13;
case. This is somewhat surprising, since the handcoded case appears to be&#13;
simpler: it contains&#13;
one less call to the <code>append()</code> method than the JDK 8 case and so is&#13;
performing nominally less work. But the string concatenation optimization within the JVM&#13;
doesn’t pick up that particular pattern, so it ends up being slower.</p>&#13;
&#13;
<p>The Java 8 optimization doesn’t carry over for all concatenations, though.&#13;
We can slightly alter our tests like this:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="nd">@Benchmark</code>&#13;
<code class="kd">public</code> <code class="kt">void</code> <code class="nf">testDoubleJDK11Style</code><code class="o">(</code><code class="n">Blackhole</code> <code class="n">bh</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="kt">double</code> <code class="n">d</code> <code class="o">=</code> <code class="mf">1.0</code><code class="o">;</code>&#13;
    <code class="n">String</code> <code class="n">s</code> <code class="o">=</code> <code class="n">prefix</code> <code class="o">+</code> <code class="n">strings</code><code class="o">[</code><code class="mi">0</code><code class="o">]</code> <code class="o">+</code> <code class="n">d</code><code class="o">;</code>&#13;
    <code class="n">bh</code><code class="o">.</code><code class="na">consume</code><code class="o">(</code><code class="n">s</code><code class="o">);</code>&#13;
<code class="o">}</code>&#13;
&#13;
<code class="nd">@Benchmark</code>&#13;
<code class="kd">public</code> <code class="kt">void</code> <code class="nf">testDoubleJDK8Style</code><code class="o">(</code><code class="n">Blackhole</code> <code class="n">bh</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="kt">double</code> <code class="n">d</code> <code class="o">=</code> <code class="mf">1.0</code><code class="o">;</code>&#13;
    <code class="n">String</code> <code class="n">s</code> <code class="o">=</code> <code class="k">new</code> <code class="n">StringBuilder</code><code class="o">().</code><code class="na">append</code><code class="o">(</code><code class="n">prefix</code><code class="o">).</code>&#13;
                   <code class="n">append</code><code class="o">(</code><code class="n">strings</code><code class="o">[</code><code class="mi">0</code><code class="o">]).</code><code class="na">append</code><code class="o">(</code><code class="n">d</code><code class="o">).</code><code class="na">toString</code><code class="o">();</code>&#13;
    <code class="n">bh</code><code class="o">.</code><code class="na">consume</code><code class="o">(</code><code class="n">s</code><code class="o">);</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p>Now the performance is different, as <a data-type="xref" href="#TableDoubleConcat">Table 12-4</a> shows.</p>&#13;
<table id="TableDoubleConcat">&#13;
<caption><span class="label">Table 12-4. </span>Performance of concatenation with a double value</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Mode</th>&#13;
<th>Time per operation</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p>JDK 11 optimization</p></td>&#13;
<td><p>49.4 ± 0.6 ns</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>JDK 8 optimization</p></td>&#13;
<td><p>77.0 ± 1.9 ns</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>The JDK 11 time is similar to the last example,&#13;
even though we’re appending a new value and&#13;
doing slightly more work.&#13;
But the JDK 8 time is much worse—it is about 50% slower. This is&#13;
not really because of the extra concatenation; it’s because of the <em>type</em> of&#13;
that concatenation. The JDK 8 optimization works well with strings and&#13;
integers, but it cannot handle doubles (and most other kinds of data).&#13;
In those cases, the JDK 8 code skips the special optimization and behaves&#13;
like the previous handcoded test.</p>&#13;
&#13;
<p>Neither of these optimizations carries over when we do multiple concatenation&#13;
operations, particularly those within a loop. Consider these tests:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting">    <code class="nd">@Benchmark</code>&#13;
    <code class="kd">public</code> <code class="kt">void</code> <code class="nf">testJDK11Style</code><code class="o">(</code><code class="n">Blackhole</code> <code class="n">bh</code><code class="o">)</code> <code class="o">{</code>&#13;
        <code class="n">String</code> <code class="n">s</code> <code class="o">=</code> <code class="s">""</code><code class="o">;</code>&#13;
        <code class="k">for</code> <code class="o">(</code><code class="kt">int</code> <code class="n">i</code> <code class="o">=</code> <code class="mi">0</code><code class="o">;</code> <code class="n">i</code> <code class="o">&lt;</code> <code class="n">nStrings</code><code class="o">;</code> <code class="n">i</code><code class="o">++)</code> <code class="o">{</code>&#13;
            <code class="n">s</code> <code class="o">=</code> <code class="n">s</code> <code class="o">+</code> <code class="n">strings</code><code class="o">[</code><code class="n">i</code><code class="o">];</code>&#13;
        <code class="o">}</code>&#13;
        <code class="n">bh</code><code class="o">.</code><code class="na">consume</code><code class="o">(</code><code class="n">s</code><code class="o">);</code>&#13;
    <code class="o">}</code>&#13;
&#13;
    <code class="nd">@Benchmark</code>&#13;
    <code class="kd">public</code> <code class="kt">void</code> <code class="nf">testJDK8Style</code><code class="o">(</code><code class="n">Blackhole</code> <code class="n">bh</code><code class="o">)</code> <code class="o">{</code>&#13;
        <code class="n">String</code> <code class="n">s</code> <code class="o">=</code> <code class="s">""</code><code class="o">;</code>&#13;
        <code class="k">for</code> <code class="o">(</code><code class="kt">int</code> <code class="n">i</code> <code class="o">=</code> <code class="mi">0</code><code class="o">;</code> <code class="n">i</code> <code class="o">&lt;</code> <code class="n">nStrings</code><code class="o">;</code> <code class="n">i</code><code class="o">++)</code> <code class="o">{</code>&#13;
            <code class="n">s</code> <code class="o">=</code> <code class="k">new</code> <code class="n">StringBuilder</code><code class="o">().</code><code class="na">append</code><code class="o">(</code><code class="n">s</code><code class="o">).</code><code class="na">append</code><code class="o">(</code><code class="n">strings</code><code class="o">[</code><code class="n">i</code><code class="o">]).</code><code class="na">toString</code><code class="o">();</code>&#13;
        <code class="o">}</code>&#13;
        <code class="n">bh</code><code class="o">.</code><code class="na">consume</code><code class="o">(</code><code class="n">s</code><code class="o">);</code>&#13;
    <code class="o">}</code>&#13;
&#13;
    <code class="nd">@Benchmark</code>&#13;
    <code class="kd">public</code> <code class="kt">void</code> <code class="nf">testStringBuilder</code><code class="o">(</code><code class="n">Blackhole</code> <code class="n">bh</code><code class="o">)</code> <code class="o">{</code>&#13;
        <code class="n">StringBuilder</code> <code class="n">sb</code> <code class="o">=</code> <code class="k">new</code> <code class="n">StringBuilder</code><code class="o">();</code>&#13;
        <code class="k">for</code> <code class="o">(</code><code class="kt">int</code> <code class="n">i</code> <code class="o">=</code> <code class="mi">0</code><code class="o">;</code> <code class="n">i</code> <code class="o">&lt;</code> <code class="n">nStrings</code><code class="o">;</code> <code class="n">i</code><code class="o">++)</code> <code class="o">{</code>&#13;
            <code class="n">sb</code><code class="o">.</code><code class="na">append</code><code class="o">(</code><code class="n">strings</code><code class="o">[</code><code class="n">i</code><code class="o">]);</code>&#13;
        <code class="o">}</code>&#13;
        <code class="n">bh</code><code class="o">.</code><code class="na">consume</code><code class="o">(</code><code class="n">sb</code><code class="o">.</code><code class="na">toString</code><code class="o">());</code>&#13;
    <code class="o">}</code></pre>&#13;
&#13;
<p>Now the results favor handcoding, which makes sense. The Java 8 implementation,&#13;
in particular, has to create a new <code>StringBuilder</code> operation on each iteration&#13;
of the loop, and even in Java 11, the overhead of creating a string on each&#13;
loop (rather than building up in the string builder) takes its toll. These&#13;
results are in <a data-type="xref" href="#TableStringConcatLoop">Table 12-5</a>.</p>&#13;
<table id="TableStringConcatLoop">&#13;
<caption><span class="label">Table 12-5. </span>Performance of multiple string concatenations</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Mode</th>&#13;
<th>10 strings</th>&#13;
<th>1,000 strings</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p>JDK 11 code</p></td>&#13;
<td><p>613 ± 8 ns</p></td>&#13;
<td><p>2,463 ± 55 μs</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>JDK 8 code</p></td>&#13;
<td><p>584 ± 8 ns</p></td>&#13;
<td><p>2,602 ± 209 μs</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>String builder</p></td>&#13;
<td><p>412 ± 2 ns</p></td>&#13;
<td><p>38 ± 211 μs</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>Bottom line: Don’t be afraid to use concatenation when it can&#13;
be done on a single (logical) line, but never use string concatenation&#13;
inside a loop&#13;
unless the concatenated string is not used on the next loop iteration.&#13;
Otherwise, always explicitly use a&#13;
<code class="keep-together">StringBuilder</code>&#13;
object&#13;
for better performance. In <a data-type="xref" href="ch01.html#Introduction">Chapter 1</a>, I argued that there&#13;
are times to “prematurely” optimize, when that phrase is used in a context&#13;
meaning simply “write good code.” This is a prime example.</p>&#13;
<div data-type="tip"><h1>Quick Summary</h1>&#13;
<ul>&#13;
<li>&#13;
<p>One-line concatenation of strings yields good performance.</p>&#13;
</li>&#13;
<li>&#13;
<p>For multiple concatenation operations, make sure to use <code>StringBuilder</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>One-line concatenation of strings involving certain types will be significantly faster when recompiled in JDK 11<a data-startref="ix_ch12-asciidoc8" data-type="indexterm" id="idm45775543439304"/><a data-startref="ix_ch12-asciidoc7" data-type="indexterm" id="idm45775543438600"/>.<a data-startref="ix_ch12-asciidoc2" data-type="indexterm" id="idm45775543437800"/><a data-startref="ix_ch12-asciidoc1" data-type="indexterm" id="idm45775543437096"/></p>&#13;
</li>&#13;
</ul>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Buffered I/O" data-type="sect1"><div class="sect1" id="idm45775543963640">&#13;
<h1>Buffered I/O</h1>&#13;
&#13;
<p><a data-primary="buffered I/O" data-type="indexterm" id="ix_ch12-asciidoc9"/><a data-primary="I/O performance" data-secondary="buffered I/O" data-type="indexterm" id="ix_ch12-asciidoc10"/><a data-primary="Java SE (Standard Edition) API" data-secondary="buffered I/O" data-type="indexterm" id="ix_ch12-asciidoc11"/>When I joined the Java Performance Group in 2000, my boss had just&#13;
published the first ever book on Java performance, and one of the hottest&#13;
topics in those&#13;
days was buffered I/O. Fourteen years later, I was prepared to assume the&#13;
topic was old hat and leave it out of the first edition of this book. Then,&#13;
in the week I&#13;
started the outline for the first edition, I filed bugs against two unrelated&#13;
projects in which unbuffered I/O was greatly hampering performance. A few months&#13;
later, as I was working on an example for the first edition, I scratched my head as&#13;
I wondered why my “optimization” was so slow. Then I realized: stupid, you&#13;
forgot to buffer the I/O correctly.</p>&#13;
&#13;
<p>As for the second edition: in the two weeks before I revisited this section,&#13;
three colleagues came to me who had made the same mistake in buffering I/O as I had in the example for the first edition.</p>&#13;
&#13;
<p>So let’s talk about buffered I/O performance. The&#13;
<code class="keep-together">InputStream.read()</code>&#13;
and&#13;
<code class="keep-together">OutputStream.write()</code>&#13;
methods operate on a single character. Depending&#13;
on the resource they are accessing, these methods can be very slow. A&#13;
<code class="keep-together">FileInputStream</code>&#13;
that uses the&#13;
<code class="keep-together">read()</code>&#13;
method will be excruciatingly slow:&#13;
each method invocation requires a trip into the kernel to fetch 1 byte&#13;
of data. On most operating systems, the kernel will have buffered the&#13;
I/O, so (luckily) this scenario doesn’t trigger a disk read for each&#13;
invocation of the&#13;
<code class="keep-together">read()</code>&#13;
method. But that buffer is held in the kernel,&#13;
not the application, and reading a single byte at a time means making an&#13;
expensive system call for each method invocation.</p>&#13;
&#13;
<p>The same is true of writing data: using the&#13;
<code class="keep-together">write()</code>&#13;
method to send a single byte to a&#13;
<code class="keep-together">FileOutputStream</code>&#13;
requires a system call to store the&#13;
byte in a kernel buffer. Eventually (when the file is closed or flushed),&#13;
the kernel will write out that buffer to the disk.</p>&#13;
&#13;
<p>For file-based I/O using binary data, always use&#13;
<code class="keep-together">BufferedInputStream</code>&#13;
or&#13;
<code class="keep-together">BufferedOutputStream</code>&#13;
to wrap the underlying file stream. For file-based&#13;
I/O using character (string) data, always wrap the underlying stream&#13;
with&#13;
<code class="keep-together">BufferedReader</code>&#13;
or&#13;
<code class="keep-together">BufferedWriter</code>.</p>&#13;
&#13;
<p>Although this performance issue is most easily understood when discussing&#13;
file I/O, it is a general issue that applies to almost every sort of I/O.&#13;
The streams returned from a socket (via the&#13;
<code class="keep-together">getInputStream()</code>&#13;
or&#13;
<code class="keep-together">getOutputStream()</code>&#13;
methods) operate in the same manner, and performing I/O one&#13;
byte at a time over a socket is quite slow. Here, too, always make sure that&#13;
the streams are appropriately wrapped with a buffering filter stream.</p>&#13;
&#13;
<p>There are more subtle issues when using the&#13;
<code class="keep-together">ByteArrayInputStream</code>&#13;
and&#13;
<code class="keep-together">ByteArrayOutputStream</code>&#13;
classes. These classes are essentially just big&#13;
in-memory buffers to begin with. In many cases, wrapping them with a buffering&#13;
filter stream means that data is copied twice: once to the buffer in the&#13;
filter stream and once to the buffer in the&#13;
<code class="keep-together">ByteArrayInputStream</code>&#13;
(or&#13;
vice versa for output streams). Absent the involvement of any other streams,&#13;
buffered I/O should be avoided in that&#13;
case.</p>&#13;
&#13;
<p>When other filtering streams are involved, the question of whether&#13;
to buffer becomes more complicated. Later in this chapter, you’ll see an&#13;
example of object serialization that involves multiple filtering streams&#13;
using the&#13;
<code class="keep-together">ByteArrayOutputStream</code>,&#13;
<code class="keep-together">ObjectOutputStream</code>, and&#13;
<code class="keep-together">GZIPOutputStream</code> classes.</p>&#13;
&#13;
<p class="pagebreak-before">Without the compressing output stream, the filters for that example&#13;
 look like this:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">protected</code> <code class="kt">void</code> <code class="nf">makePrices</code><code class="o">()</code> <code class="kd">throws</code> <code class="n">IOException</code> <code class="o">{</code>&#13;
    <code class="n">ByteArrayOutputStream</code> <code class="n">baos</code> <code class="o">=</code> <code class="k">new</code> <code class="n">ByteArrayOutputStream</code><code class="o">();</code>&#13;
    <code class="n">ObjectOutputStream</code> <code class="n">oos</code> <code class="o">=</code> <code class="k">new</code> <code class="n">ObjectOutputStream</code><code class="o">(</code><code class="n">baos</code><code class="o">);</code>&#13;
    <code class="n">oos</code><code class="o">.</code><code class="na">writeObject</code><code class="o">(</code><code class="n">prices</code><code class="o">);</code>&#13;
    <code class="n">oos</code><code class="o">.</code><code class="na">close</code><code class="o">();</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p>In this case, wrapping the&#13;
<code class="keep-together">baos</code>&#13;
stream in a&#13;
<code class="keep-together">BufferedOutputStream</code>&#13;
would suffer a performance penalty from copying the data one extra time.</p>&#13;
&#13;
<p>Once we add compression, though, the best way to write the code is like this:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">protected</code> <code class="kt">void</code> <code class="nf">makeZippedPrices</code><code class="o">()</code> <code class="kd">throws</code> <code class="n">IOException</code> <code class="o">{</code>&#13;
    <code class="n">ByteArrayOutputStream</code> <code class="n">baos</code> <code class="o">=</code> <code class="k">new</code> <code class="n">ByteArrayOutputStream</code><code class="o">();</code>&#13;
    <code class="n">GZIPOutputStream</code> <code class="n">zip</code> <code class="o">=</code> <code class="k">new</code> <code class="n">GZIPOutputStream</code><code class="o">(</code><code class="n">baos</code><code class="o">);</code>&#13;
    <code class="n">BufferedOutputStream</code> <code class="n">bos</code> <code class="o">=</code> <code class="k">new</code> <code class="n">BufferedOutputStream</code><code class="o">(</code><code class="n">zip</code><code class="o">);</code>&#13;
    <code class="n">ObjectOutputStream</code> <code class="n">oos</code> <code class="o">=</code> <code class="k">new</code> <code class="n">ObjectOutputStream</code><code class="o">(</code><code class="n">bos</code><code class="o">);</code>&#13;
    <code class="n">oos</code><code class="o">.</code><code class="na">writeObject</code><code class="o">(</code><code class="n">prices</code><code class="o">);</code>&#13;
    <code class="n">oos</code><code class="o">.</code><code class="na">close</code><code class="o">();</code>&#13;
    <code class="n">zip</code><code class="o">.</code><code class="na">close</code><code class="o">();</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p>Now it is necessary to buffer the output stream, because&#13;
<code class="keep-together">GZIPOutputStream</code>&#13;
operates more efficiently on a block of data than it does on single bytes of&#13;
data. In either case,&#13;
<code class="keep-together">ObjectOutputStream</code>&#13;
will send single bytes of&#13;
data to the next stream. If that next stream is the ultimate destination—the&#13;
<code class="keep-together">ByteArrayOutputStream</code>—no buffering is necessary. If&#13;
another filtering stream is in the middle (such as&#13;
<code class="keep-together">GZIPOutputStream</code>&#13;
in&#13;
this example), buffering is often necessary.</p>&#13;
&#13;
<p>No general rule exists about when to use a buffered stream interposed between&#13;
two other streams. Ultimately, it will depend&#13;
on the type of streams involved, but the likely cases will all&#13;
operate better if they are fed a block of bytes (from the buffered stream)&#13;
rather than a series of single bytes (from&#13;
<span class="keep-together"><code>ObjectOutputStream</code>).</span></p>&#13;
&#13;
<p>The same situation applies to input streams. In this specific case, <code class="keep-together">GZIPInputStream</code>&#13;
will operate more efficiently on a block of bytes; in&#13;
the general case, streams that are interposed between&#13;
<code class="keep-together">ObjectInputStream</code>&#13;
and the original byte source will also be better off with a  block of bytes.</p>&#13;
&#13;
<p>Note that this case applies in particular to stream encoders and&#13;
decoders. When you convert between bytes and characters, operating on as large&#13;
a piece of data as possible will provide the best performance. If&#13;
single bytes or characters are fed to encoders and decoders, they will&#13;
suffer from bad performance.</p>&#13;
&#13;
<p>For the record, not buffering the gzip streams is exactly&#13;
the mistake I made when writing that compression example. It was a costly&#13;
mistake, as the data in <a data-type="xref" href="#TableBufferedIO">Table 12-6</a> shows.</p>&#13;
<table id="TableBufferedIO">&#13;
<caption><span class="label">Table 12-6. </span>Time to serialize and deserialize <code>Stock</code> object with compression</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Mode</th>&#13;
<th>Time</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p>Unbuffered compression/decompression</p></td>&#13;
<td><p>21.3 ± 8 ms</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Buffered compression/decompression</p></td>&#13;
<td><p>5.7 ± 0.08 ms</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>The failure to properly buffer the I/O resulted in as much as&#13;
a four times performance penalty.</p>&#13;
<div data-type="tip"><h1>Quick Summary</h1>&#13;
<ul>&#13;
<li>&#13;
<p>Issues around buffered I/O are common because of the default implementation of the simple input and output stream classes.</p>&#13;
</li>&#13;
<li>&#13;
<p>I/O must be properly buffered for files and sockets, as well as for internal operations like compression and string encoding.<a data-startref="ix_ch12-asciidoc11" data-type="indexterm" id="idm45775543219704"/><a data-startref="ix_ch12-asciidoc10" data-type="indexterm" id="idm45775543219000"/><a data-startref="ix_ch12-asciidoc9" data-type="indexterm" id="idm45775543218328"/></p>&#13;
</li>&#13;
</ul>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Classloading" data-type="sect1"><div class="sect1" id="idm45775543435128">&#13;
<h1>Classloading</h1>&#13;
&#13;
<p><a data-primary="classloading" data-type="indexterm" id="ix_ch12-asciidoc12"/><a data-primary="Java SE (Standard Edition) API" data-secondary="classloading" data-type="indexterm" id="ix_ch12-asciidoc13"/>The performance of classloading is the bane of anyone attempting to optimize&#13;
either program startup or deployment of new code in a dynamic&#13;
system.</p>&#13;
&#13;
<p>There are many reasons for that. To begin, the&#13;
class data (i.e., the Java bytecode) is typically not quickly accessible.&#13;
That data must be loaded from disk or from the network, it must be found in one of&#13;
several JAR files on the classpath, and it must be found in one of several&#13;
classloaders. There are some ways to help this along: some frameworks&#13;
cache&#13;
classes they read from the network into a hidden directory so that next time&#13;
it starts the same application, it can read the classes more quickly.&#13;
Packaging an application into fewer JAR&#13;
files will also speed up its classloading performance.</p>&#13;
&#13;
<p>In this section, we’ll look at a new feature of Java 11 to speed up&#13;
classloading.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Class Data Sharing" data-type="sect2"><div class="sect2" id="ClassDataSharing">&#13;
<h2>Class Data Sharing</h2>&#13;
&#13;
<p><a data-primary="class data sharing (CDS)" data-type="indexterm" id="ix_ch12-asciidoc14"/><a data-primary="classloading" data-secondary="class data sharing" data-type="indexterm" id="ix_ch12-asciidoc15"/><a data-primary="metadata (class)" data-type="indexterm" id="ix_ch12-asciidoc16"/><a data-primary="class metadata" data-type="indexterm" id="ix_ch12-asciidoc16a"/><em>Class data sharing</em> (<em>CDS</em>) is a mechanism whereby the metadata for classes can be&#13;
shared between JVMs. This can be useful for saving memory when running multiple&#13;
JVMs: normally, each&#13;
JVM would have its own class metadata, and the separate copies would occupy&#13;
some physical memory. If that metadata is shared, only one copy needs&#13;
to reside in memory.</p>&#13;
&#13;
<p>It turns out that CDS is very useful for single JVMs because it can also improve&#13;
their startup time.</p>&#13;
&#13;
<p class="pagebreak-before">Class data sharing is available in Java 8 (and previous releases),&#13;
but with the restriction that it&#13;
applies only to the classes in <em>rt.jar</em> and only when the serial collector&#13;
is used with the client JVM. In other words, it helps somewhat on&#13;
32-bit, single-CPU, Windows desktop machines.</p>&#13;
&#13;
<p>In Java 11, CDS is generally available on all platforms, though it doesn’t&#13;
work out of the box because there is no default shared archive of the&#13;
class metadata. Java 12 does have a default shared archive of the common&#13;
JDK classes, so all applications will by default get some startup&#13;
(and memory)&#13;
benefits. In either case, we can do better by generating a more complete&#13;
shared archive for our application, because in Java 11,&#13;
CDS can work with any set of classes, no matter which classloader loads&#13;
them and which JAR or module they are loaded from. One restriction applies:&#13;
CDS works only for classes loaded from modules or JAR files. You cannot share&#13;
(or quickly load) classes from a filesystem or network URL.</p>&#13;
&#13;
<p>In a sense, this means there are two flavors of CDS: <em>regular CDS</em> (which&#13;
shares the default JDK classes) and <em>application class data&#13;
sharing</em>, which shares any set of classes. Application class data sharing&#13;
was actually introduced in Java 10, and it worked differently&#13;
than regular CDS: there were different command-line arguments for programs&#13;
to use it. That distinction is now obsolete, and CDS in Java 11 and beyond&#13;
works the same way regardless of the classes being shared.</p>&#13;
&#13;
<p>The first thing required to use CDS is a shared archive of classes. As I&#13;
mentioned, Java&#13;
12 comes with a default shared archive of classes, which is located in&#13;
<em>$JAVA_HOME/lib/server/classes.jsa</em> (or <em>%JAVA_HOME%\bin\server\classes.jsa</em>&#13;
on Windows). That archive has data for 12,000 JDK classes, so its&#13;
coverage of the core classes is pretty broad. To generate your own&#13;
archive, you will first need a list of all the classes for which you want to enable&#13;
sharing (and hence fast loading). That list can include JDK classes&#13;
and application-level classes.</p>&#13;
&#13;
<p><a data-primary="-XX:+DumpLoadedClassList=filename" data-type="indexterm" id="idm45775543198024"/>There are many ways to get such a list, but the easiest is to&#13;
run your application with the&#13;
<code class="keep-together">-XX:+DumpLoadedClassList=filename</code>&#13;
flag, which will produce (in <em>filename</em>) a list of all the classes that&#13;
your application has loaded.</p>&#13;
&#13;
<p>The second step is to use that class list to generate the shared archive&#13;
like this:</p>&#13;
&#13;
<pre data-type="programlisting">$ java -Xshare:dump -XX:SharedClassListFile=filename \&#13;
    -XX:SharedArchiveFile=myclasses.jsa \&#13;
    ... classpath arguments ...</pre>&#13;
&#13;
<p>This will create a new shared archive file with the given name&#13;
(here, <em>myclasses.jsa</em>) based on the list of files. You must also set up the&#13;
classpath the same as you would to run the application (i.e., using either&#13;
the <code>-cp</code> or <code>-jar</code> argument you would normally use to run the application).</p>&#13;
&#13;
<p class="pagebreak-before">This command will generate a lot of warnings about classes it cannot find.&#13;
That is expected since this command cannot find&#13;
dynamically generated classes: proxy classes,&#13;
reflection-based classes, and so on. If you see a warning for a class you&#13;
expected to be loaded, try adjusting the classpath for that command. Not&#13;
finding all the classes isn’t a problem; it just means they will be loaded&#13;
normally (from the classpath) rather than from the shared archive. Loading&#13;
that particular class will hence be a little slower, but&#13;
a few such classes like&#13;
that isn’t going to be noticeable, so don’t sweat everything at this step.</p>&#13;
&#13;
<p>Finally, you use the shared archive to run the application:</p>&#13;
&#13;
<pre data-type="programlisting">$ java -Xshare:auto -XX:SharedArchiveFile=myclasses.jsa ... other args ...</pre>&#13;
&#13;
<p>A few remarks about this command. First, the <code>-Xshare</code> command has three&#13;
possible values:</p>&#13;
<dl>&#13;
<dt><code>off</code></dt>&#13;
<dd>&#13;
<p>Don’t use class data sharing.</p>&#13;
</dd>&#13;
<dt><code>on</code></dt>&#13;
<dd>&#13;
<p>Always use class data sharing.</p>&#13;
</dd>&#13;
<dt><code>auto</code></dt>&#13;
<dd>&#13;
<p>Attempt to use class data sharing.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>CDS depends on mapping the shared archive into a memory region, and under&#13;
certain (mostly rare) circumstances, that can fail.&#13;
If <code>-Xshare:on</code> is specified,&#13;
the application will not run if that happens. Hence, the default value is&#13;
<code>-Xshare:auto</code>, which means that CDS will normally be used, but if&#13;
for some reason the archive&#13;
cannot be mapped, the application will proceed without it. Since the default&#13;
for this flag is <code>auto</code>, we don’t actually have to specify it in the preceding command.</p>&#13;
&#13;
<p>Second, this command gives the location of the shared archive. <a data-primary="-XX:SharedArchiveFile" data-type="indexterm" id="idm45775543139816"/>The default&#13;
value for the <code>SharedArchiveFile</code> flag is the <em>classes.jsa</em> path mentioned&#13;
earlier (within the JDK <em>server</em> directory). So in Java 12 (where that file&#13;
is present), we needn’t give any command-line arguments if we just want to&#13;
use the (JDK-only) default shared archive.</p>&#13;
&#13;
<p>In one common case, loading the shared archive can fail: the&#13;
classpath used to generate the shared archive must be a subset of the&#13;
classpath used to run an application, and the JAR files must not have&#13;
changed since the shared archive was created. So you don’t want to generate&#13;
a shared archive of classes other than the JDK and put that in the default&#13;
location, since the classpath for arbitrary commands will not match.</p>&#13;
&#13;
<p>Also beware of changing the JAR files. If you use the default setting of&#13;
<code>-Xshare:auto</code> and the JAR file is changed, the application will still run,&#13;
even though the shared archive is not being used. Worse, there will be no&#13;
warning about that; the only effect you’ll see is that the application starts&#13;
more slowly. That’s a reason to consider specifying <code>-Xshare:on</code> instead of&#13;
the default, though there are other reasons the shared archive could fail.</p>&#13;
&#13;
<p>To validate that classes are being loaded from the shared archive, include&#13;
class loading logging (<code>-Xlog:class+load=info</code>) in your command line; you’ll&#13;
see the usual classloading output, and classes that are loaded from the&#13;
shared archive will show up like this:</p>&#13;
&#13;
<pre data-type="programlisting">[0.080s][info][class,load] java.lang.Comparable source: shared objects file</pre>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Class data sharing benefits" data-type="sect3"><div class="sect3" id="idm45775543133112">&#13;
<h3>Class data sharing benefits</h3>&#13;
&#13;
<p>The benefit of class data sharing for startup time depends, obviously, on&#13;
the number of classes to be loaded. <a data-type="xref" href="#TableCDS">Table 12-7</a> shows the time required to&#13;
start the sample stock server application in the book examples; that&#13;
requires loading 6,314 classes.</p>&#13;
<table id="TableCDS">&#13;
<caption><span class="label">Table 12-7. </span>Time to start an application with CDS</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>CDS mode</th>&#13;
<th>Startup time</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p><code>-Xshare:off</code></p></td>&#13;
<td><p>8.9 seconds</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>-Xshare:on</code> (default)</p></td>&#13;
<td><p>9.1 seconds</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>-Xshare:on</code> (custom)</p></td>&#13;
<td><p>7.0 seconds</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>In the default case, we’re using only the shared archive for the JDK; the last&#13;
row is the custom shared archive of all the application classes. In this&#13;
case, CDS saves us 30% in startup time.</p>&#13;
&#13;
<p>CDS will also save us some memory since the class data will be shared among&#13;
processes. Overall, as you saw in the examples in <a data-type="xref" href="ch08.html#NativeMemory">Chapter 8</a>, the class&#13;
data in native memory is proportionately small, particularly compared to the&#13;
application heap. In a large program with lots of classes, CDS will save more&#13;
memory, though a large program is likely to need an even larger heap, making&#13;
the proportional savings still small. Still, in an environment where you are&#13;
particularly starved for native memory and running multiple copies of the JVM&#13;
that are using a significant number of the same classes, CDS will offer&#13;
some benefit for memory savings as well.</p>&#13;
<div data-type="tip"><h1>Quick Summary</h1>&#13;
<ul>&#13;
<li>&#13;
<p>The best way to speed up classloading is to create a class data sharing&#13;
archive for the application. Luckily, this requires no programming changes<a data-startref="ix_ch12-asciidoc16" data-type="indexterm" id="idm45775543116920"/><a data-startref="ix_ch12-asciidoc16a" data-type="indexterm" id="idm45775543116216"/><a data-startref="ix_ch12-asciidoc15" data-type="indexterm" id="idm45775543115544"/><a data-startref="ix_ch12-asciidoc14" data-type="indexterm" id="idm45775543114872"/>.<a data-startref="ix_ch12-asciidoc13" data-type="indexterm" id="idm45775543114072"/><a data-startref="ix_ch12-asciidoc12" data-type="indexterm" id="idm45775543113368"/></p>&#13;
</li>&#13;
</ul>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="less_space pagebreak-before" data-pdf-bookmark="Random Numbers" data-type="sect1"><div class="sect1" id="idm45775543211240">&#13;
<h1>Random Numbers</h1>&#13;
&#13;
<p><a data-primary="Java SE (Standard Edition) API" data-secondary="random number generation" data-type="indexterm" id="ix_ch12-asciidoc17"/><a data-primary="random number generation" data-type="indexterm" id="ix_ch12-asciidoc18"/>The next set of APIs we’ll look at involve random number generation.&#13;
Java comes with three standard random number generator classes:&#13;
<code class="keep-together">java.util.Random</code>,&#13;
<code class="keep-together">java.util.concurrent.ThreadLocalRandom</code>, and&#13;
<code>java.security.SecureRandom</code>.&#13;
These three classes have important performance differences.</p>&#13;
&#13;
<p>The difference between the&#13;
<code class="keep-together">Random</code>&#13;
and&#13;
<code class="keep-together">ThreadLocalRandom</code>&#13;
classes is that the main&#13;
operation (the&#13;
<code class="keep-together">nextGaussian()</code>&#13;
method) of the&#13;
<code class="keep-together">Random</code>&#13;
class&#13;
is synchronized. That method is used by any method that retrieves a random&#13;
value, so that lock can become contended no matter how the random number&#13;
generator is used:&#13;
if two threads use the same random number generator at the same&#13;
time, one will have to wait for the other to complete its operation. This&#13;
is why the thread-local version is available: when each thread has its own&#13;
random number generator,&#13;
the synchronization of the&#13;
<code class="keep-together">Random</code>&#13;
class is no longer an issue. (As discussed in <a data-type="xref" href="ch07.html#Memory">Chapter 7</a>, the thread-local version&#13;
also provides significant performance benefits because it is reusing an&#13;
expensive-to-create object.)</p>&#13;
&#13;
<p>The difference between those classes and the&#13;
<code class="keep-together">SecureRandom</code>&#13;
class lies in the algorithm used.&#13;
The&#13;
<code class="keep-together">Random</code>&#13;
class (and the&#13;
<code class="keep-together">ThreadLocalRandom</code>&#13;
class, via inheritance) implements a&#13;
typical pseudorandom algorithm. While those&#13;
algorithms are quite sophisticated, they are in the end deterministic.&#13;
If the initial seed is known, it is possible to determine the exact&#13;
series of numbers the engine will generate. That means hackers are able to&#13;
look at series of numbers from a particular generator and (eventually)&#13;
figure out what the next number will be. Although good pseudorandom number&#13;
generators can emit series of <span class="keep-together">numbers</span> that look really random (and that&#13;
even fit probabilistic expectations of randomness), they are not truly random.</p>&#13;
&#13;
<p>The&#13;
<code class="keep-together">SecureRandom</code>&#13;
class, on the other hand, uses a system interface to obtain a seed for its&#13;
random data. The way that data is generated is operating-system-specific, but&#13;
in general this source provides data based on truly random events (such as when&#13;
the mouse is moved). This is known as <em>entropy-based randomness</em> and is much&#13;
more secure for operations that rely on random numbers.</p>&#13;
&#13;
<p>Java distinguishes two sources of random numbers: one to generate seeds&#13;
and one to generate random numbers themselves. Seeds are used to create&#13;
public and private keys, such as the keys that you use to access a system&#13;
via SSH or PuTTY. Those keys are long-lived, so they require the strongest&#13;
possible cryptographic algorithm. Secure random numbers are also used to seed&#13;
regular random number streams, including those used by default implementations&#13;
of Java’s SSL libraries.</p>&#13;
&#13;
<p>On Linux systems, these two sources are <em>/dev/random</em> (for seeds) and&#13;
<em>/dev/urandom</em> (for random numbers). These systems are both based on sources&#13;
of entropy within the machine: truly random things, such as mouse movement&#13;
or keyboard strokes. The amount of entropy is limited and is regenerated&#13;
randomly, so it is undependable as a true source of randomness. The two&#13;
systems handle that differently: <em>/dev/random</em> will block until it has enough&#13;
system events to generate the random data, and <em>/dev/urandom</em> will fall back&#13;
to a pseudorandom number generator (PRNG). The PRNG will&#13;
have been initialized from a truly random source, so it is usually just as&#13;
strong as the stream from <em>/dev/random</em>. However, entropy to generate the&#13;
seed itself may be unavailable, in which case the stream from <em>/dev/urandom</em>&#13;
can theoretically be compromised. There are arguments on both sides of&#13;
this issue as to strength of this stream, but the common&#13;
consensus—use <em>/dev/random</em> for seeds and <em>/dev/urandom</em> for everything else—is the&#13;
one adopted by Java.</p>&#13;
&#13;
<p>The upshot is that getting a lot of random number seeds can take a long time.&#13;
Calls to the&#13;
<code class="keep-together">generatedSeed()</code>&#13;
method of the&#13;
<code class="keep-together">SecureRandom</code>&#13;
class will take an&#13;
indeterminate amount of time, based on how much unused entropy the system&#13;
has. If no entropy is available, the call will appear to hang, possibly&#13;
as long as seconds at a time,&#13;
until the required entropy is available.&#13;
That makes performance timing quite difficult: the performance itself&#13;
becomes random.</p>&#13;
&#13;
<p>On the other hand, the <code>generateSeed()</code> method is used for only two operations.&#13;
First, some algorithms use it to get a seed for future calls to the&#13;
<code>nextRandom()</code> method. This usually needs to be done only once, or at most&#13;
periodically during the lifetime of an application. Second, this method is&#13;
used when creating a long-lived key, which also is a fairly rare operation.</p>&#13;
&#13;
<p>Since those operations are limited, most applications will not run out&#13;
of entropy. Still, limited entropy can be a problem for applications&#13;
that create ciphers at&#13;
startup time, particularly in cloud environments where the host OS random&#13;
number device is shared among a number of virtual machines and/or Docker&#13;
containers. In that case,&#13;
timings of program activities will have a&#13;
very large amount of variance, and since the use of secure seeds occurs most&#13;
often while programs are initializing, the startup of applications in this&#13;
sphere can be quite slow.</p>&#13;
&#13;
<p>We have a few ways to deal with this situation.&#13;
In a pinch, and where the code can be changed, an alternative to this&#13;
problem is to run performance tests&#13;
using the&#13;
<code class="keep-together">Random</code>&#13;
class, even though the&#13;
<code class="keep-together">SecureRandom</code>&#13;
class will be used in production. If the performance tests are module-level&#13;
tests, that can make sense: those tests will need more random seeds&#13;
than the production system will need during the same period&#13;
of time. But eventually, the expected load must be tested with the&#13;
<code class="keep-together">SecureRandom</code>&#13;
class to determine if the load on the production system can obtain a sufficient&#13;
number of random seeds.</p>&#13;
&#13;
<p>A second option is to configure Java’s secure random number generator to use <span class="keep-together"><em>/dev/urandom</em></span> for seeds as well as for random numbers. This can&#13;
be accomplished <span class="keep-together">in two ways:</span> first, you can set the system property&#13;
<code>-Djava.security​.egd=file:/dev/urandom</code>.<sup><a data-type="noteref" href="ch12.html#idm45775543079160" id="idm45775543079160-marker">2</a></sup></p>&#13;
&#13;
<p>A third option is to change this setting in <em>$JAVA_HOME/jre/lib/security/java.security</em>:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="n">securerandom</code><code class="o">.</code><code class="na">source</code><code class="o">=</code><code class="nl">file:</code><code class="o">/</code><code class="n">dev</code><code class="o">/</code><code class="n">random</code></pre>&#13;
&#13;
<p>That line defines the interface used for seeding operations and can be&#13;
set to <em>/dev/urandom</em> if you want to ensure that the secure random number&#13;
generator never blocks.</p>&#13;
&#13;
<p>However, the better solution is to set up the operating system so that it&#13;
supplies&#13;
more entropy, which is done by running the <code>rngd</code> daemon. Just make sure&#13;
that the <code>rngd</code> daemon is configured to use reliable hardware sources&#13;
of entropy (e.g., <em>/dev/hwrng</em> if it is available) and not something like&#13;
<em>/dev/urandom</em>. This solution has the advantage of solving entropy issues for&#13;
all programs on the machine, not just Java programs.</p>&#13;
<div data-type="tip"><h1>Quick Summary</h1>&#13;
<ul>&#13;
<li>&#13;
<p>Java’s default&#13;
<code class="keep-together">Random</code> class is expensive to&#13;
initialize, but once initialized, it can be reused.</p>&#13;
</li>&#13;
<li>&#13;
<p>In multithreaded code, the&#13;
<code class="keep-together">ThreadLocalRandom</code> class is&#13;
<span class="keep-together">preferred.</span></p>&#13;
</li>&#13;
<li>&#13;
<p>Sometimes, the&#13;
<code class="keep-together">SecureRandom</code> class will show&#13;
arbitrary, completely random performance. Performance tests on code using&#13;
that class must be carefully planned.</p>&#13;
</li>&#13;
<li>&#13;
<p>Issues with the&#13;
<code class="keep-together">SecureRandom</code> class blocking&#13;
can be avoided with configuration changes, but it is better to solve them&#13;
at the OS level by adding entropy to the system.<a data-startref="ix_ch12-asciidoc18" data-type="indexterm" id="idm45775543053736"/><a data-startref="ix_ch12-asciidoc17" data-type="indexterm" id="idm45775543053032"/></p>&#13;
</li>&#13;
</ul>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Java Native Interface" data-type="sect1"><div class="sect1" id="idm45775543112056">&#13;
<h1>Java Native Interface</h1>&#13;
&#13;
<p><a data-primary="Java Native Interface (JNI)" data-type="indexterm" id="ix_ch12-asciidoc19"/><a data-primary="Java SE (Standard Edition) API" data-secondary="Java Native Interface" data-type="indexterm" id="ix_ch12-asciidoc20"/><a data-primary="JNI (Java Native Interface)" data-type="indexterm" id="ix_ch12-asciidoc21"/>Performance tips about Java SE (particularly in the early days of Java) often&#13;
say that if you want really fast code, you should use native code. In truth,&#13;
if you are interested in writing the fastest possible code, avoid the&#13;
Java Native Interface (JNI).</p>&#13;
&#13;
<p>Well-written Java code will run at least as fast on current versions of&#13;
the JVM as corresponding C or C++ code (it is not 1996 anymore).&#13;
Language purists will continue to debate the relative performance merits of&#13;
Java and&#13;
other languages, and you can find doubtless examples of an&#13;
application written in another language that is faster than the same application&#13;
written in Java (though often those examples contain poorly written Java code).&#13;
However, that debate misses the point of this section: when an application&#13;
is already written&#13;
in Java, calling native code for performance reasons is almost always a bad&#13;
idea.</p>&#13;
&#13;
<p>Still, at times JNI is quite useful. The Java platform provides&#13;
many common features of operating systems, but if access to a special,&#13;
operating-system-specific function is required, so is JNI. And why build&#13;
your own library to perform an operation, when a commercial (native) version&#13;
of the code is readily available? In these and other cases, the question&#13;
becomes how to write the most efficient JNI code.</p>&#13;
&#13;
<p>The answer is to avoid making calls from Java to C as much as possible.&#13;
Crossing the JNI boundary (the term for making the cross-language call) is&#13;
 expensive.&#13;
Because calling an existing C library requires writing glue code in the&#13;
first place, take the time to create new, coarse-grained interfaces via&#13;
that glue code:  perform many, multiple calls into the C library in one&#13;
shot.</p>&#13;
&#13;
<p>Interestingly, the reverse is not necessarily true: C code that calls back into&#13;
Java does not suffer a large performance penalty (depending on the parameters&#13;
involved). For example, consider the following code excerpt:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="nd">@Benchmark</code>&#13;
<code class="kd">public</code> <code class="kt">void</code> <code class="nf">testJavaJavaJava</code><code class="o">(</code><code class="n">Blackhole</code> <code class="n">bh</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="kt">long</code> <code class="n">l</code> <code class="o">=</code> <code class="mi">0</code><code class="o">;</code>&#13;
    <code class="k">for</code> <code class="o">(</code><code class="kt">int</code> <code class="n">i</code> <code class="o">=</code> <code class="mi">0</code><code class="o">;</code> <code class="n">i</code> <code class="o">&lt;</code> <code class="n">nTrials</code><code class="o">;</code> <code class="n">i</code><code class="o">++)</code> <code class="o">{</code>&#13;
        <code class="kt">long</code> <code class="n">a</code> <code class="o">=</code> <code class="n">calcJavaJava</code><code class="o">(</code><code class="n">nValues</code><code class="o">);</code>&#13;
        <code class="n">l</code> <code class="o">+=</code> <code class="n">a</code> <code class="o">/</code> <code class="n">nTrials</code><code class="o">;</code>&#13;
    <code class="o">}</code>&#13;
    <code class="n">bh</code><code class="o">.</code><code class="na">consume</code><code class="o">(</code><code class="n">l</code><code class="o">);</code>&#13;
<code class="o">}</code>&#13;
&#13;
<code class="kd">private</code> <code class="kt">long</code> <code class="nf">calcJavaJava</code><code class="o">(</code><code class="kt">int</code> <code class="n">nValues</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="kt">long</code> <code class="n">l</code> <code class="o">=</code> <code class="mi">0</code><code class="o">;</code>&#13;
    <code class="k">for</code> <code class="o">(</code><code class="kt">int</code> <code class="n">i</code> <code class="o">=</code> <code class="mi">0</code><code class="o">;</code> <code class="n">i</code> <code class="o">&lt;</code> <code class="n">nValues</code><code class="o">;</code> <code class="n">i</code><code class="o">++)</code> <code class="o">{</code>&#13;
        <code class="n">l</code> <code class="o">+=</code> <code class="n">calcJava</code><code class="o">(</code><code class="n">i</code><code class="o">);</code>&#13;
    <code class="o">}</code>&#13;
    <code class="kt">long</code> <code class="n">a</code> <code class="o">=</code> <code class="n">l</code> <code class="o">/</code> <code class="n">nValues</code><code class="o">;</code>&#13;
    <code class="k">return</code> <code class="n">a</code><code class="o">;</code>&#13;
<code class="o">}</code>&#13;
&#13;
<code class="kd">private</code> <code class="kt">long</code> <code class="nf">calcJava</code><code class="o">(</code><code class="kt">int</code> <code class="n">i</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="k">return</code> <code class="n">i</code> <code class="o">*</code> <code class="mi">3</code> <code class="o">+</code> <code class="mi">15</code><code class="o">;</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p>This (completely nonsensical) code has two main loops: one inside the&#13;
benchmark method and then one inside the <code>calcJavaJava()</code> method. That&#13;
is all Java code, but we can choose instead to use a native interface&#13;
and write the outer calculation method in C:</p>&#13;
&#13;
<pre data-type="programlisting">@Benchmark&#13;
public void testJavaCC(Blackhole bh) {&#13;
    long l = 0;&#13;
    for (int i = 0; i &lt; nTrials; i++) {&#13;
        long a = calcCC(nValues);&#13;
        l += 50 - a;&#13;
    }&#13;
    bh.consume(l);&#13;
}&#13;
&#13;
private native long calcCC(int nValues);</pre>&#13;
&#13;
<p>Or we could just implement the inner call in C (the code for which should&#13;
be <span class="keep-together">obvious).</span></p>&#13;
&#13;
<p><a data-type="xref" href="#TableJNI">Table 12-8</a> shows the performance from&#13;
various permutations, given 10,000 trials and 10,000 values.</p>&#13;
<table id="TableJNI">&#13;
<caption><span class="label">Table 12-8. </span>Time to calculate across the JNI boundary</caption>&#13;
<thead>&#13;
<tr>&#13;
<th><code>calculateError</code></th>&#13;
<th>Calc</th>&#13;
<th>Random</th>&#13;
<th>JNI transitions</th>&#13;
<th>Total time</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p>Java</p></td>&#13;
<td><p>Java</p></td>&#13;
<td><p>Java</p></td>&#13;
<td><p>0</p></td>&#13;
<td><p>0.104 ± 0.01 seconds</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Java</p></td>&#13;
<td><p>Java</p></td>&#13;
<td><p>C</p></td>&#13;
<td><p>10,000,000</p></td>&#13;
<td><p>1.96 ± 0.1 seconds</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Java</p></td>&#13;
<td><p>C</p></td>&#13;
<td><p>C</p></td>&#13;
<td><p>10,000</p></td>&#13;
<td><p>0.132 ± 0.01 seconds</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>C</p></td>&#13;
<td><p>C</p></td>&#13;
<td><p>C</p></td>&#13;
<td><p>0</p></td>&#13;
<td><p>0.139 ± 0.01 seconds</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>Implementing only the innermost method in C provides the most&#13;
crossings of the JNI boundary (<code>numberOfTrials × numberOfLoops</code>, or&#13;
10 million). Reducing the number of crossings to <code>numberOfTrials</code>&#13;
(10,000) reduces that overhead substantially, and reducing it further to&#13;
0 provides the best performance.</p>&#13;
&#13;
<p>JNI code performs worse if the parameters involved are not simple primitives.&#13;
Two aspects are involved in this overhead. First, for simple references, an&#13;
address translation is needed.&#13;
Second, operations on array-based data are subject to special handling in&#13;
native code. This includes&#13;
<code class="keep-together">String</code>&#13;
objects, since the string data is&#13;
essentially a character array. To access the individual elements of these&#13;
arrays, a special call must be made to pin the object in memory (and&#13;
for&#13;
<code class="keep-together">String</code>&#13;
objects, to convert from Java’s UTF-16 encoding into UTF-8 in JDK 8).&#13;
When the array is no longer needed, it must be explicitly released in the JNI&#13;
code.</p>&#13;
&#13;
<p>While the array is pinned, the garbage collector cannot run—so&#13;
one of the most expensive mistakes in JNI code is to pin a string or array&#13;
in code that is long-running. That prevents the garbage collector from running,&#13;
effectively blocking all the application threads until the JNI code&#13;
completes. It is extremely important to make the critical section&#13;
where the array is&#13;
pinned as short as possible.</p>&#13;
&#13;
<p><a data-primary="GC Locker Initiated GC" data-type="indexterm" id="idm45775542890328"/>Often, you will see the term <code>GC Locker Initiated GC</code> in your GC logs.&#13;
That’s an indication that the garbage collector needed to run but it&#13;
couldn’t, because a thread had pinned data in a JNI call. As soon as&#13;
that data is unpinned, the garbage collector will run. If you see&#13;
this GC cause frequently, look into making the JNI code faster; your&#13;
other application threads are experiencing delays waiting for GC to run.</p>&#13;
&#13;
<p>Sometimes, the goal of pinning objects for a short period of time&#13;
conflicts with the goal of reducing&#13;
the calls that cross the JNI boundary. In that case, the latter goal is&#13;
 more important even if it means making multiple crossings of the&#13;
JNI boundary, so make the sections that pin arrays and strings as short as&#13;
possible.</p>&#13;
<div data-type="tip"><h1>Quick Summary</h1>&#13;
<ul>&#13;
<li>&#13;
<p>JNI is not a solution to performance problems. Java code will almost always run faster than calling into native code.</p>&#13;
</li>&#13;
<li>&#13;
<p>When JNI is used, limit the number of calls from Java to C; crossing the JNI boundary is expensive.</p>&#13;
</li>&#13;
<li>&#13;
<p>JNI code that uses arrays or strings must pin those objects; limit the length of time they are pinned so that the garbage collector is not impacted.<a data-startref="ix_ch12-asciidoc21" data-type="indexterm" id="idm45775542883912"/><a data-startref="ix_ch12-asciidoc20" data-type="indexterm" id="idm45775542883208"/><a data-startref="ix_ch12-asciidoc19" data-type="indexterm" id="idm45775542882536"/></p>&#13;
</li>&#13;
</ul>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Exceptions" data-type="sect1"><div class="sect1" id="Exceptions">&#13;
<h1>Exceptions</h1>&#13;
&#13;
<p><a data-primary="exception processing" data-type="indexterm" id="ix_ch12-asciidoc22"/><a data-primary="Java SE (Standard Edition) API" data-secondary="exception processing" data-type="indexterm" id="ix_ch12-asciidoc23"/>Java exception processing has the reputation of being expensive.&#13;
It is somewhat more expensive than processing regular control flows, though&#13;
in most cases, the extra cost isn’t worth the effort to attempt to bypass it.&#13;
On the other hand, because it isn’t free, exception processing shouldn’t&#13;
be used as a general mechanism either. The guideline is to use&#13;
exceptions according to the general principles of good program design:&#13;
mainly, code should throw an exception only to indicate something&#13;
unexpected has happened. Following good code design means that your Java&#13;
code will not be slowed down by exception processing.</p>&#13;
&#13;
<p>Two things can affect the general performance of exception processing.&#13;
First is the code block itself: is it expensive to set up a&#13;
try-catch block? While that might have been the case a long time ago,&#13;
it has not been the case for years. Still, because the internet has a long&#13;
memory, you will sometimes see recommendations to avoid exceptions simply&#13;
because of the try-catch block. Those recommendations are out-of-date;&#13;
modern JVMs can generate code that handles exceptions quite efficiently.</p>&#13;
&#13;
<p>The second aspect is that exceptions involve obtaining a stack trace&#13;
at the point of the exception (though you’ll see an exception to that&#13;
later in this section). This operation can be expensive,&#13;
particularly if the stack trace is deep.</p>&#13;
&#13;
<p>Let’s look at an example. Here are three implementations of a particular&#13;
method to consider:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">private</code> <code class="kd">static</code> <code class="kd">class</code> <code class="nc">CheckedExceptionTester</code> <code class="kd">implements</code> <code class="n">ExceptionTester</code> <code class="o">{</code>&#13;
    <code class="kd">public</code> <code class="kt">void</code> <code class="nf">test</code><code class="o">(</code><code class="kt">int</code> <code class="n">nLoops</code><code class="o">,</code> <code class="kt">int</code> <code class="n">pctError</code><code class="o">,</code> <code class="n">Blackhole</code> <code class="n">bh</code><code class="o">)</code> <code class="o">{</code>&#13;
        <code class="n">ArrayList</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code> <code class="n">al</code> <code class="o">=</code> <code class="k">new</code> <code class="n">ArrayList</code><code class="o">&lt;&gt;();</code>&#13;
        <code class="k">for</code> <code class="o">(</code><code class="kt">int</code> <code class="n">i</code> <code class="o">=</code> <code class="mi">0</code><code class="o">;</code> <code class="n">i</code> <code class="o">&lt;</code> <code class="n">nLoops</code><code class="o">;</code> <code class="n">i</code><code class="o">++)</code> <code class="o">{</code>&#13;
            <code class="k">try</code> <code class="o">{</code>&#13;
                <code class="k">if</code> <code class="o">((</code><code class="n">i</code> <code class="o">%</code> <code class="n">pctError</code><code class="o">)</code> <code class="o">==</code> <code class="mi">0</code><code class="o">)</code> <code class="o">{</code>&#13;
                    <code class="k">throw</code> <code class="k">new</code> <code class="nf">CheckedException</code><code class="o">(</code><code class="s">"Failed"</code><code class="o">);</code>&#13;
                <code class="o">}</code>&#13;
                <code class="n">Object</code> <code class="n">o</code> <code class="o">=</code> <code class="k">new</code> <code class="n">Object</code><code class="o">();</code>&#13;
                <code class="n">al</code><code class="o">.</code><code class="na">add</code><code class="o">(</code><code class="n">o</code><code class="o">.</code><code class="na">toString</code><code class="o">());</code>&#13;
            <code class="o">}</code> <code class="k">catch</code> <code class="o">(</code><code class="n">CheckedException</code> <code class="n">ce</code><code class="o">)</code> <code class="o">{</code>&#13;
                <code class="c1">// continue</code>&#13;
            <code class="o">}</code>&#13;
        <code class="o">}</code>&#13;
        <code class="n">bh</code><code class="o">.</code><code class="na">consume</code><code class="o">(</code><code class="n">al</code><code class="o">);</code>&#13;
    <code class="o">}</code>&#13;
<code class="o">}</code>&#13;
&#13;
<code class="kd">private</code> <code class="kd">static</code> <code class="kd">class</code> <code class="nc">UncheckedExceptionTester</code> <code class="kd">implements</code> <code class="n">ExceptionTester</code> <code class="o">{</code>&#13;
    <code class="kd">public</code> <code class="kt">void</code> <code class="nf">test</code><code class="o">(</code><code class="kt">int</code> <code class="n">nLoops</code><code class="o">,</code> <code class="kt">int</code> <code class="n">pctError</code><code class="o">,</code> <code class="n">Blackhole</code> <code class="n">bh</code><code class="o">)</code> <code class="o">{</code>&#13;
        <code class="n">ArrayList</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code> <code class="n">al</code> <code class="o">=</code> <code class="k">new</code> <code class="n">ArrayList</code><code class="o">&lt;&gt;();</code>&#13;
        <code class="k">for</code> <code class="o">(</code><code class="kt">int</code> <code class="n">i</code> <code class="o">=</code> <code class="mi">0</code><code class="o">;</code> <code class="n">i</code> <code class="o">&lt;</code> <code class="n">nLoops</code><code class="o">;</code> <code class="n">i</code><code class="o">++)</code> <code class="o">{</code>&#13;
            <code class="n">Object</code> <code class="n">o</code> <code class="o">=</code> <code class="kc">null</code><code class="o">;</code>&#13;
            <code class="k">if</code> <code class="o">((</code><code class="n">i</code> <code class="o">%</code> <code class="n">pctError</code><code class="o">)</code> <code class="o">!=</code> <code class="mi">0</code><code class="o">)</code> <code class="o">{</code>&#13;
                <code class="n">o</code> <code class="o">=</code> <code class="k">new</code> <code class="n">Object</code><code class="o">();</code>&#13;
            <code class="o">}</code>&#13;
            <code class="k">try</code> <code class="o">{</code>&#13;
                <code class="n">al</code><code class="o">.</code><code class="na">add</code><code class="o">(</code><code class="n">o</code><code class="o">.</code><code class="na">toString</code><code class="o">());</code>&#13;
            <code class="o">}</code> <code class="k">catch</code> <code class="o">(</code><code class="n">NullPointerException</code> <code class="n">npe</code><code class="o">)</code> <code class="o">{</code>&#13;
                <code class="c1">// continue</code>&#13;
            <code class="o">}</code>&#13;
        <code class="o">}</code>&#13;
        <code class="n">bh</code><code class="o">.</code><code class="na">consume</code><code class="o">(</code><code class="n">al</code><code class="o">);</code>&#13;
    <code class="o">}</code>&#13;
<code class="o">}</code>&#13;
&#13;
<code class="kd">private</code> <code class="kd">static</code> <code class="kd">class</code> <code class="nc">DefensiveExceptionTester</code> <code class="kd">implements</code> <code class="n">ExceptionTester</code> <code class="o">{</code>&#13;
    <code class="kd">public</code> <code class="kt">void</code> <code class="nf">test</code><code class="o">(</code><code class="kt">int</code> <code class="n">nLoops</code><code class="o">,</code> <code class="kt">int</code> <code class="n">pctError</code><code class="o">,</code> <code class="n">Blackhole</code> <code class="n">bh</code><code class="o">)</code> <code class="o">{</code>&#13;
        <code class="n">ArrayList</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code> <code class="n">al</code> <code class="o">=</code> <code class="k">new</code> <code class="n">ArrayList</code><code class="o">&lt;&gt;();</code>&#13;
        <code class="k">for</code> <code class="o">(</code><code class="kt">int</code> <code class="n">i</code> <code class="o">=</code> <code class="mi">0</code><code class="o">;</code> <code class="n">i</code> <code class="o">&lt;</code> <code class="n">nLoops</code><code class="o">;</code> <code class="n">i</code><code class="o">++)</code> <code class="o">{</code>&#13;
            <code class="n">Object</code> <code class="n">o</code> <code class="o">=</code> <code class="kc">null</code><code class="o">;</code>&#13;
            <code class="k">if</code> <code class="o">((</code><code class="n">i</code> <code class="o">%</code> <code class="n">pctError</code><code class="o">)</code> <code class="o">!=</code> <code class="mi">0</code><code class="o">)</code> <code class="o">{</code>&#13;
                <code class="n">o</code> <code class="o">=</code> <code class="k">new</code> <code class="n">Object</code><code class="o">();</code>&#13;
            <code class="o">}</code>&#13;
            <code class="k">if</code> <code class="o">(</code><code class="n">o</code> <code class="o">!=</code> <code class="kc">null</code><code class="o">)</code> <code class="o">{</code>&#13;
                <code class="n">al</code><code class="o">.</code><code class="na">add</code><code class="o">(</code><code class="n">o</code><code class="o">.</code><code class="na">toString</code><code class="o">());</code>&#13;
            <code class="o">}</code>&#13;
        <code class="o">}</code>&#13;
        <code class="n">bh</code><code class="o">.</code><code class="na">consume</code><code class="o">(</code><code class="n">al</code><code class="o">);</code>&#13;
    <code class="o">}</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p>Each method here creates an array of arbitrary strings from newly created&#13;
objects. The size of that array will vary, based on the desired number of&#13;
exceptions to be thrown.</p>&#13;
&#13;
<p><a data-type="xref" href="#TableExceptions1">Table 12-9</a> shows the time to complete each method for 100,000&#13;
iterations given the worst case—a&#13;
<code class="keep-together">pctError</code>&#13;
of 1 (each call&#13;
generates an exception, and the result is an empty list). The example&#13;
code here is either shallow (meaning that the method in question is called&#13;
when only 3 classes are on the stack) or deep (meaning that the&#13;
method in question is called when 100 classes are on the stack).</p>&#13;
<table id="TableExceptions1">&#13;
<caption><span class="label">Table 12-9. </span>Time to process exceptions at 100%</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Method</th>&#13;
<th>Shallow time</th>&#13;
<th>Deep time</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p>Checked exception</p></td>&#13;
<td><p>24031 ± 127 μs</p></td>&#13;
<td><p>30613 ± 329 μs</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Unchecked exception</p></td>&#13;
<td><p>21181 ± 278 μs</p></td>&#13;
<td><p>21550 ± 323 μs</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Defensive programming</p></td>&#13;
<td><p>21088 ± 255 μs</p></td>&#13;
<td><p>21262 ± 622 μs</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>This table presents three interesting points. First, in the case of checked&#13;
exceptions, there is a significant difference of time between the shallow case&#13;
and the deep case.&#13;
Constructing that stack trace takes&#13;
time, which is dependent on the stack depth.</p>&#13;
&#13;
<p>But the second case involves unchecked exceptions, where&#13;
the JVM creates the exception&#13;
when the null pointer is <span class="keep-together">deref</span>erenced.&#13;
What’s happening is that&#13;
at some point, the compiler has optimized the&#13;
system-generated exception case; the JVM begins to reuse the same exception&#13;
object rather than creating a new one each time it is needed. That object&#13;
is reused each&#13;
time the code in question is executed, no matter what the calling stack is,&#13;
and the exception does not actually contain a call stack (i.e., the&#13;
<code class="keep-together">printStackTrace()</code>&#13;
method returns no output). This optimization doesn’t&#13;
occur until the full stack exception has been thrown for quite a long&#13;
time, so if your test case doesn’t include a sufficient warm-up cycle, you will&#13;
not see its effects.</p>&#13;
&#13;
<p>Finally, consider the case where no exception is thrown: notice that it has pretty much&#13;
the same performance as the unchecked exception case. This case serves as&#13;
a control in this experiment: the test does a fair amount of work to create&#13;
the objects. The difference between the defensive case and any other case&#13;
is the actual time spent creating, throwing, and catching the exception.&#13;
So the overall time is quite small.&#13;
Averaged out over 100,000 calls, the&#13;
individual execution time differences will barely register (and recall that&#13;
this is the worst-case example).</p>&#13;
&#13;
<p>So performance penalties for using exceptions injudiciously is smaller than&#13;
might be expected, and the penalty for having lots of the same system exception&#13;
is almost nonexistent.&#13;
Still, in some cases you will run into code that&#13;
is simply creating too many exceptions. <a data-primary="-XX:-StackTraceInThrowable" data-type="indexterm" id="idm45775542450856"/>Since the performance penalty&#13;
comes from filling in the stack traces, the&#13;
<code class="keep-together">-XX:-StackTraceInThrowable</code>&#13;
flag (which is <code>true</code> by default) can be set to disable the generation&#13;
of the stack traces.</p>&#13;
&#13;
<p>This is rarely a good idea: the stack traces are present&#13;
to enable analysis of what unexpectedly went wrong. That capability&#13;
is lost when this flag is enabled. And there is code that actually examines&#13;
the stack traces and determines how to recover from the exception based on&#13;
what it finds there. That’s problematic in itself, but the upshot is that&#13;
disabling the stack trace can mysteriously break code.</p>&#13;
&#13;
<p>There are some APIs in the JDK itself where exception handling can lead to&#13;
performance issues. Many collection classes will throw an exception when&#13;
nonexistent items are retrieved from them. The&#13;
<code class="keep-together">Stack</code>&#13;
class, for example,&#13;
throws an&#13;
<code class="keep-together">EmptyStackException</code>&#13;
if the stack is empty when the&#13;
<code class="keep-together">pop()</code>&#13;
method&#13;
is called. It is usually better to utilize defensive programming in that&#13;
case by checking the stack length first. (On the other hand, unlike&#13;
many collection classes, the <code>Stack</code> class supports <code>null</code> objects, so&#13;
it’s not as if the <code>pop()</code> method could return <code>null</code> to indicate an empty&#13;
stack.)</p>&#13;
&#13;
<p>The most notorious example within the JDK of questionable use of&#13;
exceptions is <span class="keep-together">in classloading</span>: the&#13;
<code class="keep-together">loadClass()</code>&#13;
method of the&#13;
<code class="keep-together">ClassLoader</code>&#13;
class throws a&#13;
<code class="keep-together">ClassNotFoundException</code>&#13;
when&#13;
asked to load a class that it cannot find. That’s not actually an exceptional&#13;
condition. An individual classloader is not expected to know how to load&#13;
every class in an application, which is why there are hierarchies of&#13;
<span class="keep-together">classloaders.</span></p>&#13;
&#13;
<p>In an environment with dozens&#13;
of classloaders, this means a lot of exceptions are <span class="keep-together">created</span> as the classloader hierarchy is searched for the one classloader that knows how to&#13;
load the given class. In very large application servers I’ve worked with,&#13;
disabling stack trace generation can speed up start time by as much as 3%.&#13;
Those servers load more than 30,000 classes from hundreds of JAR files; this&#13;
is certainly a YMMV kind of thing.<sup><a data-type="noteref" href="ch12.html#idm45775542437672" id="idm45775542437672-marker">3</a></sup></p>&#13;
<div data-type="tip"><h1>Quick Summary</h1>&#13;
<ul>&#13;
<li>&#13;
<p>Exceptions are not necessarily expensive to process, though they should be used only when appropriate.</p>&#13;
</li>&#13;
<li>&#13;
<p>The deeper the stack, the more expensive to process <span class="keep-together">exceptions.</span></p>&#13;
</li>&#13;
<li>&#13;
<p>The JVM will optimize away the stack penalty for frequently created system exceptions.</p>&#13;
</li>&#13;
<li>&#13;
<p>Disabling stack traces in exceptions can sometimes help performance, though crucial information is often lost in the <span class="keep-together">process.</span><a data-startref="ix_ch12-asciidoc23" data-type="indexterm" id="idm45775542430712"/><a data-startref="ix_ch12-asciidoc22" data-type="indexterm" id="idm45775542430008"/></p>&#13;
</li>&#13;
</ul>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Logging" data-type="sect1"><div class="sect1" id="idm45775542880888">&#13;
<h1>Logging</h1>&#13;
&#13;
<p><a data-primary="Java SE (Standard Edition) API" data-secondary="logging" data-type="indexterm" id="ix_ch12-asciidoc24"/><a data-primary="logging" data-secondary="and Java SE API" data-type="indexterm" id="ix_ch12-asciidoc25"/>Logging is one of those things that performance engineers either love or&#13;
hate—or (usually) both. Whenever I’m asked why a program is running badly,&#13;
the first thing I ask for are any available logs, with the hope that logs&#13;
produced by the application will have clues as to what the application was&#13;
doing. Whenever I’m asked to review the performance of working code, I&#13;
immediately recommend that all logging statements be turned off.</p>&#13;
&#13;
<p>Multiple logs are in question here. The JVM produces its&#13;
own logging statements, of which the most important is the GC&#13;
log (see <a data-type="xref" href="ch06.html#Collectors">Chapter 6</a>). That logging&#13;
can be directed into a distinct&#13;
file, the size of which can <span class="keep-together">be managed</span> by the JVM. Even in production code,&#13;
GC logging (even with detailed logging enabled)&#13;
has such low&#13;
overhead and such an expected large benefit if something goes wrong that&#13;
it should always be turned on.</p>&#13;
&#13;
<p>HTTP servers generate an access log that is updated&#13;
on every request. This log generally has a noticeable impact: turning&#13;
off that logging will definitely improve the performance of whatever test&#13;
is run against the application server. From a diagnosability standpoint,&#13;
those logs are (in my experience) not terribly helpful when something goes wrong. However, in terms of&#13;
business requirements, that log is often crucial, in which case it must&#13;
be left enabled.</p>&#13;
&#13;
<p>Although it is not a Java standard, many&#13;
HTTP servers support the Apache <code>mod_log_config</code> convention, which allows&#13;
you to specify exactly what information is logged for each request (and&#13;
servers that don’t follow the <code>mod_log_config</code> syntax will typically support&#13;
another log customization). The key is to log as little information&#13;
as possible and still meet the business requirements. The performance of the&#13;
log is subject to the amount of data written.</p>&#13;
&#13;
<p>In HTTP access logs in particular (and in general, in any kind of log), it is&#13;
a good idea to log all information numerically: IP addresses rather than&#13;
hostnames, timestamps (e.g., seconds since the epoch) rather than string data (e.g., “Monday, June 3, 2019 17:23:00 -0600”), and so on. Minimize any&#13;
data conversion that will take time and memory to compute so that the&#13;
effect on the system is also minimized. Logs can always be postprocessed&#13;
to provide converted data.</p>&#13;
&#13;
<p>We should keep three basic principles in mind for application logs. First&#13;
is to keep a balance between the data to be logged and level at which it&#13;
is logged. The JDK has seven standard logging levels in the JDK, and&#13;
loggers by default are configured to output three of those levels&#13;
<span class="keep-together">(<code>INFO</code></span>&#13;
and greater).&#13;
This often leads to confusion within projects: <code class="keep-together">INFO</code>-level messages sound like&#13;
they should be fairly common and should provide a description of the flow&#13;
of an application (“now I’m processing task A,” “now I’m doing task B,” and&#13;
so on). Particularly for applications that are heavily threaded and scalable,&#13;
that much logging will have&#13;
a detrimental effect on performance (not to mention running the risk of being&#13;
too chatty to be useful). Don’t be afraid to use the lower-level logging&#13;
statements.</p>&#13;
&#13;
<p>Similarly, when code is checked into a group repository, consider the needs&#13;
of the user of the project rather than your needs as a developer. We’d all&#13;
like to have a lot of good feedback about how our code works after it is&#13;
integrated into a larger system and run through a battery of tests, but if a&#13;
message isn’t going to make sense to an end user or system administrator,&#13;
it’s not helpful to enable it by default. It is merely going to&#13;
slow down the system (and confuse the end user).</p>&#13;
&#13;
<p>The second principle is to use fine-grained loggers. Having a logger per class&#13;
can be tedious to configure, but having greater control over the logging output&#13;
often makes this worthwhile. Sharing a logger for a set of classes in a small&#13;
module is a good compromise. Keep in mind that&#13;
production problems—and particularly production problems that occur under&#13;
load or are otherwise performance related—are tricky to reproduce if&#13;
the environment changes significantly. Turning on too much logging often&#13;
changes the environment such that the original issue no longer manifests&#13;
itself.</p>&#13;
&#13;
<p>Hence, you must be able to turn on logging&#13;
only for a small set of code (and, at least initially, a small set of logging&#13;
statements at the&#13;
<code class="keep-together">FINE</code>&#13;
level, followed by more at the&#13;
<code class="keep-together">FINER</code>&#13;
and&#13;
<code class="keep-together">FINEST</code>&#13;
levels) so that the performance of the code is not&#13;
affected.</p>&#13;
&#13;
<p>Between these two principles, it should be possible to enable small subsets&#13;
of messages in a production environment without affecting the performance&#13;
of the system. That is usually a requirement anyway: the production system&#13;
administrators probably aren’t going to enable logging if it slows the&#13;
system, and if the system does slow down, then the likelihood of&#13;
reproducing the issue is reduced.</p>&#13;
&#13;
<p class="pagebreak-before">The third principle to keep in mind when introducing logging to code is&#13;
to remember that it is easy to write logging code that has unintended&#13;
side effects, even if the <span class="keep-together">logging</span> is not enabled. This is another case where&#13;
“prematurely” optimizing code is a good thing: as the example from&#13;
<a data-type="xref" href="ch01.html#Introduction">Chapter 1</a> shows, remember to use the&#13;
<code class="keep-together">isLoggable()</code>&#13;
method anytime&#13;
the information to be logged contains a method call, a string concatenation,&#13;
or any other sort of allocation (for example, allocation of an&#13;
<code class="keep-together">Object</code>&#13;
array for a&#13;
<code class="keep-together">MessageFormat</code>&#13;
argument).</p>&#13;
<div data-type="tip"><h1>Quick Summary</h1>&#13;
<ul>&#13;
<li>&#13;
<p>Code should contain lots of logging to enable users to figure out what it does, but none of that should be enabled by default.</p>&#13;
</li>&#13;
<li>&#13;
<p>Don’t forget to test for the logging level before calling the logger if the arguments to the logger require method calls or object allocation.<a data-startref="ix_ch12-asciidoc25" data-type="indexterm" id="idm45775542402376"/><a data-startref="ix_ch12-asciidoc24" data-type="indexterm" id="idm45775542401672"/></p>&#13;
</li>&#13;
</ul>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Java Collections API" data-type="sect1"><div class="sect1" id="idm45775542428424">&#13;
<h1>Java Collections API</h1>&#13;
&#13;
<p><a data-primary="Java Collections API" data-type="indexterm" id="ix_ch12-asciidoc26"/><a data-primary="Java SE (Standard Edition) API" data-secondary="Java Collections API" data-type="indexterm" id="ix_ch12-asciidoc27"/>Java’s collections API is extensive; it has at least 58&#13;
collection classes. Using an appropriate collection class—as well as using collection classes appropriately—is an important&#13;
performance consideration in writing an application.</p>&#13;
&#13;
<p>The first rule in using a collection class is to use one suitable for the&#13;
algorithmic needs of an application. This advice is not specific to Java;&#13;
it is essentially Data Structures 101. A&#13;
<code class="keep-together">LinkedList</code>&#13;
is not suitable&#13;
for searching; if access to a random piece of data is required, store the&#13;
collection in a&#13;
<code class="keep-together">HashMap</code>.&#13;
If the data needs to remain sorted, use a&#13;
<code class="keep-together">TreeMap</code>&#13;
rather than attempting to sort the data in the application. Use an&#13;
<code class="keep-together">ArrayList</code>&#13;
if the data will be accessed by index, but not if data frequently needs to&#13;
be inserted into the middle of the array. And so on…the algorithmic choice&#13;
of which collection class is crucial, but the choice in Java isn’t different&#13;
from the choice in any other programming language.</p>&#13;
&#13;
<p>There are, however, some idiosyncrasies to consider when using Java&#13;
collections.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Synchronized Versus Unsynchronized" data-type="sect2"><div class="sect2" id="idm45775542392392">&#13;
<h2>Synchronized Versus Unsynchronized</h2>&#13;
&#13;
<p><a data-primary="collection classes" data-secondary="synchronized" data-type="indexterm" id="idm45775542390984"/><a data-primary="Java Collections API" data-secondary="synchronized versus unsynchronized" data-type="indexterm" id="idm45775542390008"/>By default, virtually all Java collections are unsynchronized (the major&#13;
exceptions are&#13;
<code class="keep-together">Hashtable</code>,&#13;
<code class="keep-together">Vector</code>,&#13;
and their related classes).</p>&#13;
<aside class="less_space pagebreak-before" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45775542387256">&#13;
<h5>Synchronized Collection Classes</h5>&#13;
<p><a data-primary="classes" data-secondary="synchronized collection classes" data-type="indexterm" id="idm45775542385512"/><a data-primary="Java Collections API" data-secondary="synchronized collection classes" data-type="indexterm" id="idm45775542384472"/>If you’ve ever wondered why the&#13;
<code class="keep-together">Vector</code>&#13;
and&#13;
<code class="keep-together">Hashtable</code>&#13;
(and related)&#13;
classes are synchronized, here’s a bit of history.</p>&#13;
&#13;
<p>In the early days of Java, these were the only collection classes&#13;
in the JDK. Back then (before Java 1.2), there was no formal&#13;
definition of the Collections Framework; these were just useful classes&#13;
that the original Java platform provided.</p>&#13;
&#13;
<p>When Java was first released, threading was poorly understood by most&#13;
developers, and Java attempted to make it easier for developers to avoid&#13;
some of the pitfalls of coding in a threaded environment. Hence,&#13;
these classes were thread-safe.</p>&#13;
&#13;
<p>Unfortunately, synchronization—even uncontended synchronization—was&#13;
a huge performance problem in early versions of Java, so when the first&#13;
major revision to the platform came out, the Collections Framework took the&#13;
opposite approach: all new collection classes would be unsynchronized by&#13;
default. Even though synchronization performance has drastically improved since&#13;
then, it still is not free, and having the option of unsynchronized collections&#13;
helps everyone write faster programs (with the occasional bug caused&#13;
by concurrently modifying an unsynchronized collection).</p>&#13;
</div></aside>&#13;
&#13;
<p><a data-type="xref" href="ch09.html#ThreadPerformance">Chapter 9</a> posited a microbenchmark to compare CAS-based&#13;
protection to traditional synchronization. That proved to be impractical in&#13;
the threaded case, but&#13;
what if the data in question will always&#13;
be accessed by a single thread—what would be the effect of not using&#13;
any synchronization at all? <a data-type="xref" href="#TableUnsync">Table 12-10</a> shows that comparison.&#13;
Because there is no attempt to model the contention, the microbenchmark in&#13;
this case is valid in this one circumstance: when&#13;
there can be no contention, and the question at hand is what the penalty is&#13;
for “oversynchronizing” access to the resource.</p>&#13;
<table id="TableUnsync">&#13;
<caption><span class="label">Table 12-10. </span>Performance of synchronized and unsynchronized access</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Mode</th>&#13;
<th>Single access</th>&#13;
<th>10,000 accesses</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p>CAS operation</p></td>&#13;
<td><p>22.1 ± 11 ns</p></td>&#13;
<td><p>209 ± 90 μs</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Synchronized method</p></td>&#13;
<td><p>20.8 ± 9 ns</p></td>&#13;
<td><p>179 ± 95 μs</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Unsynchronized method</p></td>&#13;
<td><p>15.8 ± 5 ns</p></td>&#13;
<td><p>104 ± 55 μs</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>There is a small penalty when using any data protection technique as opposed&#13;
to simple&#13;
unsynchronized access.&#13;
As usual with a microbenchmark, the difference is tiny:&#13;
on the order of 5–8 nanoseconds. If the operation in question is executed&#13;
frequently enough in the target application, the performance penalty will be&#13;
somewhat noticeable. In most cases, the difference will be outweighed by far&#13;
larger inefficiencies in other areas of the application. Remember also that&#13;
the absolute number here is completely determined by the target machine the&#13;
test was run on (my home machine with an AMD processor); to get a more&#13;
realistic measurement, the test would need to be run on hardware that is the&#13;
same as the target environment.</p>&#13;
&#13;
<p>So, given a choice between a synchronized&#13;
list (e.g., returned from the <code>synchronizedList()</code> method of the <code>Collections</code>&#13;
class)&#13;
and an unsynchronized&#13;
<code class="keep-together">ArrayList</code>,&#13;
which should be used? Access to the&#13;
<code class="keep-together">ArrayList</code>&#13;
will be&#13;
slightly faster, and depending on how often the list is accessed, a measurable performance difference can result. (As noted in&#13;
<a data-type="xref" href="ch09.html#ThreadPerformance">Chapter 9</a>, excessive calls to the synchronized method can be&#13;
 painful for performance on certain hardware platforms as well.)</p>&#13;
&#13;
<p>On the other hand, this assumes that the code will never be accessed by&#13;
more than one thread. That may be true today, but what about tomorrow?&#13;
If that might change,&#13;
 it is better to use&#13;
the synchronized collection now and mitigate any performance impact that&#13;
results. This is a design choice, and whether future-proofing code to be&#13;
thread-safe is worth the time and effort will depend on the circumstances&#13;
of the application being developed.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Collection Sizing" data-type="sect2"><div class="sect2" id="idm45775542360888">&#13;
<h2>Collection Sizing</h2>&#13;
&#13;
<p><a data-primary="collection classes" data-secondary="sizing" data-type="indexterm" id="ix_ch12-asciidoc28a"/><a data-primary="Java Collections API" data-secondary="collection sizing" data-type="indexterm" id="ix_ch12-asciidoc28"/><a data-primary="sizing" data-secondary="collections" data-type="indexterm" id="ix_ch12-asciidoc29"/>Collection classes are designed to hold an arbitrary number of data elements&#13;
and to expand as necessary, as new items are added to the collection. Sizing&#13;
the collection appropriately can be important for their overall performance.</p>&#13;
&#13;
<p>Although the data types provided by collection classes in Java are quite rich,&#13;
at a basic level those classes must hold their data using only Java&#13;
primitive data types: numbers (<code>integer</code>s, <code>double</code>s, and so on),&#13;
object references, and arrays of those types. Hence, an&#13;
<code class="keep-together">ArrayList</code> contains an actual array:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">private</code> <code class="kd">transient</code> <code class="n">Object</code><code class="o">[]</code> <code class="n">elementData</code><code class="o">;</code></pre>&#13;
&#13;
<p>As items are added and removed from the&#13;
<code class="keep-together">ArrayList</code>,&#13;
they are stored at the&#13;
desired location within the&#13;
<code class="keep-together">elementData</code>&#13;
array (possibly causing other&#13;
items in the array to shift). Similarly, a&#13;
<code class="keep-together">HashMap</code>&#13;
contains an array of&#13;
an internal data type called&#13;
<code class="keep-together">HashMap$Entry</code>,&#13;
which maps each key-value pair&#13;
to a location in the array specified by the hash code of the key.</p>&#13;
&#13;
<p>Not all collections use an array to hold their elements; a&#13;
<code class="keep-together">LinkedList</code>,&#13;
for example, holds each data element in an internally defined&#13;
<code class="keep-together">Node</code>&#13;
class.&#13;
But collection classes that do use an array to hold their elements are&#13;
subject to special sizing considerations. You can tell if a particular&#13;
class falls into this category by looking at its constructors: if it has&#13;
a constructor that allows the initial size of the collection to be specified,&#13;
 it is internally using an array to store the items.</p>&#13;
&#13;
<p>For those collection classes, it is important to accurately&#13;
specify the initial size.&#13;
Take the simple example of an&#13;
<code class="keep-together">ArrayList</code>:&#13;
the&#13;
<code class="keep-together">elementData</code>&#13;
array will (by default) start out with an initial size of 10. When&#13;
the 11th item is inserted into an&#13;
<code class="keep-together">ArrayList</code>,&#13;
the list must expand the&#13;
<code class="keep-together">elementData</code> array.&#13;
This means allocating a new array, copying the original contents&#13;
into that array, and then adding in the new item. The data structure and&#13;
algorithm used by, say, the&#13;
<code class="keep-together">HashMap</code>&#13;
class is much more complicated, but&#13;
the principle is the same: at some point, those internal structures must be&#13;
resized.</p>&#13;
&#13;
<p>The&#13;
<code class="keep-together">ArrayList</code>&#13;
class chooses to resize the array by adding roughly half&#13;
of the existing size, so the size of the&#13;
<code class="keep-together">elementData</code>&#13;
array will first&#13;
be 10, then 15, then 22, then 33, and so on. Whatever algorithm is used to&#13;
resize the array (see sidebar), this results in wasted memory (which&#13;
in turn will affect the time the application spends performing GC).&#13;
Additionally, each time the array must be resized, an expensive array&#13;
copy operation must occur to transfer the contents from the old array to&#13;
the new array.</p>&#13;
&#13;
<p>To minimize those performance penalties, make sure to construct the collection&#13;
with as accurate an estimate of its ultimate size as possible.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45775542330472">&#13;
<h5>Data Expansion in Noncollection Classes</h5>&#13;
<p><a data-primary="Java Collections API" data-secondary="data expansion in noncollection classes" data-type="indexterm" id="idm45775542329304"/>Many noncollection classes also store lots of data in an internal array.&#13;
For example, the&#13;
<code class="keep-together">ByteArrayOutputStream</code>&#13;
class must store all data written&#13;
to the stream into an internal buffer; the&#13;
<code class="keep-together">StringBuilder</code>&#13;
and&#13;
<code class="keep-together">StringBuffer</code>&#13;
classes must similarly store all their characters in an internal&#13;
<code class="keep-together">char</code>&#13;
array.</p>&#13;
&#13;
<p>Most of these classes use the same algorithm to resize the internal&#13;
array: it is doubled each time it needs to be resized. This means that,&#13;
on average, the internal array will be 25% larger than the data it currently&#13;
contains.</p>&#13;
&#13;
<p>The performance considerations here are similar: the amount of memory&#13;
used is larger than in the&#13;
<code class="keep-together">ArrayList</code>&#13;
example, and the number of times&#13;
data must be copied is fewer, but the principle is the same. Whenever you are&#13;
given the option to size an object when it is constructed and it is feasible&#13;
to estimate how much&#13;
data the object will eventually hold, use the constructor that takes&#13;
a size parameter.<a data-startref="ix_ch12-asciidoc29" data-type="indexterm" id="idm45775542305992"/><a data-startref="ix_ch12-asciidoc28a" data-type="indexterm" id="idm45775542305288"/><a data-startref="ix_ch12-asciidoc28" data-type="indexterm" id="idm45775542304616"/></p>&#13;
</div></aside>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Collections and Memory Efficiency" data-type="sect2"><div class="sect2" id="idm45775542360264">&#13;
<h2>Collections and Memory Efficiency</h2>&#13;
&#13;
<p><a data-primary="Java Collections API" data-secondary="collections and memory efficiency" data-type="indexterm" id="idm45775542302440"/><a data-primary="memory" data-secondary="collections and memory efficiency" data-type="indexterm" id="idm45775542301448"/>You’ve just seen one example where the memory efficiency of collections can&#13;
be suboptimal: there is often some wasted memory in the backing store&#13;
used to hold the elements in the collection.</p>&#13;
&#13;
<p>This can be particularly problematic for sparsely used collections: those&#13;
with one or two elements. These sparsely used collections can waste&#13;
a lot of memory if they are used extensively. One way to deal with&#13;
that is to size the collection when it is created. Another&#13;
way is to consider whether a collection is really needed in that case at all.</p>&#13;
&#13;
<p>When most developers are asked how to quickly sort any array, they&#13;
will offer up quicksort as the answer. Good performance engineers will want&#13;
to know the size of the array: if the array is small enough, the&#13;
fastest way to sort it will be to use insertion sort.<sup><a data-type="noteref" href="ch12.html#idm45775542298712" id="idm45775542298712-marker">4</a></sup> Size matters.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45775542297192">&#13;
<h5>Collection Memory Sizes</h5>&#13;
<p><a data-primary="Java Collections API" data-secondary="collection memory sizes" data-type="indexterm" id="idm45775542295992"/><a data-primary="memory" data-secondary="collection memory sizes" data-type="indexterm" id="idm45775542295016"/>Because underused collections are problematic in many applications,&#13;
Java optimized (starting in Java 8 and late versions of Java 7) the&#13;
<code class="keep-together">ArrayList</code>&#13;
and&#13;
<code class="keep-together">HashMap</code>&#13;
implementations. By default (e.g., when no size parameter is used in the&#13;
constructor), these classes do not allocate any backing store for the&#13;
data. The backing store is allocated only when the first item is added&#13;
to the collection.</p>&#13;
&#13;
<p>This is an example of the lazy-initialization technique discussed in&#13;
<a data-type="xref" href="ch07.html#Memory">Chapter 7</a>, and when this change was introduced in Java 7, testing of&#13;
several common applications resulted in&#13;
an improvement in performance due to reduced need for GC.&#13;
These applications had a lot of such collections&#13;
that were never used; lazily allocating the backing store for those collections&#13;
was a performance win. Because the size of the backing store already&#13;
had to be checked on every access, there was no performance penalty for&#13;
checking to see if the backing store had already been allocated (though&#13;
the time required to create the initial backing store did move from&#13;
when the object was created to when data was first inserted into&#13;
the object).</p>&#13;
</div></aside>&#13;
&#13;
<p>Similarly,&#13;
<code class="keep-together">HashMap</code>&#13;
is the fastest way to look up items based on a&#13;
key value, but if there is only one key,&#13;
<code class="keep-together">HashMap</code>&#13;
is overkill&#13;
compared to using a simple object reference. Even if there are a few keys,&#13;
maintaining a few object references will consume much less memory than a&#13;
full&#13;
<code class="keep-together">HashMap</code>&#13;
object, with the resulting (positive) effect on GC.</p>&#13;
<div data-type="tip"><h1>Quick Summary</h1>&#13;
<ul>&#13;
<li>&#13;
<p>Carefully consider how collections will be accessed and choose the&#13;
right type of synchronization for them. However, the penalty for uncontended&#13;
access to a memory-protected collection (particularly one using CAS-based&#13;
protections) is minimal; sometimes it is better to be safe than sorry.</p>&#13;
</li>&#13;
<li>&#13;
<p>Sizing of collections can have a large impact on performance: either&#13;
slowing down the garbage collector if the collection is too large or&#13;
causing lots of copying and resizing if it is too small.<a data-startref="ix_ch12-asciidoc27" data-type="indexterm" id="idm45775542284040"/><a data-startref="ix_ch12-asciidoc26" data-type="indexterm" id="idm45775542283336"/></p>&#13;
</li>&#13;
</ul>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Lambdas and Anonymous Classes" data-type="sect1"><div class="sect1" id="idm45775542282152">&#13;
<h1>Lambdas and Anonymous Classes</h1>&#13;
&#13;
<p><a data-primary="anonymous classes" data-type="indexterm" id="ix_ch12-asciidoc30"/><a data-primary="Java SE (Standard Edition) API" data-secondary="lambdas/anonymous classes" data-type="indexterm" id="ix_ch12-asciidoc31"/><a data-primary="lambdas" data-type="indexterm" id="ix_ch12-asciidoc32"/>For many developers, the most exciting feature of Java 8 was the addition&#13;
of lambdas.&#13;
There is no denying that lambdas have a hugely positive&#13;
impact on the productivity of Java developers, though of course that benefit&#13;
is difficult to quantify. But we can examine the performance of code using lambda&#13;
constructs.</p>&#13;
&#13;
<p>The most basic question about the performance of lambdas is how they compare to&#13;
their replacement, anonymous classes. There turns out to be little difference.</p>&#13;
&#13;
<p>The usual example of how to use a lambda class begins with code that creates&#13;
anonymous inner classes (the usual example often uses a <code>Stream</code>&#13;
rather than the iterator shown here; information about the <code>Stream</code> class comes later in&#13;
this section):</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kt">void</code> <code class="nf">calc</code><code class="o">()</code> <code class="o">{</code>&#13;
    <code class="n">IntegerInterface</code> <code class="n">a1</code> <code class="o">=</code> <code class="k">new</code> <code class="n">IntegerInterface</code><code class="o">()</code> <code class="o">{</code>&#13;
        <code class="kd">public</code> <code class="kt">int</code> <code class="nf">getInt</code><code class="o">()</code> <code class="o">{</code>&#13;
            <code class="k">return</code> <code class="mi">1</code><code class="o">;</code>&#13;
        <code class="o">}</code>&#13;
    <code class="o">};</code>&#13;
    <code class="n">IntegerInterface</code> <code class="n">a2</code> <code class="o">=</code> <code class="k">new</code> <code class="n">IntegerInterface</code><code class="o">()</code> <code class="o">{</code>&#13;
        <code class="kd">public</code> <code class="kt">int</code> <code class="nf">getInt</code><code class="o">()</code> <code class="o">{</code>&#13;
            <code class="k">return</code> <code class="mi">2</code><code class="o">;</code>&#13;
        <code class="o">}</code>&#13;
    <code class="o">};</code>&#13;
    <code class="n">IntegerInterface</code> <code class="n">a3</code> <code class="o">=</code> <code class="k">new</code> <code class="n">IntegerInterface</code><code class="o">()</code> <code class="o">{</code>&#13;
        <code class="kd">public</code> <code class="kt">int</code> <code class="nf">getInt</code><code class="o">()</code> <code class="o">{</code>&#13;
            <code class="k">return</code> <code class="mi">3</code><code class="o">;</code>&#13;
        <code class="o">}</code>&#13;
    <code class="o">};</code>&#13;
    <code class="n">sum</code> <code class="o">=</code> <code class="n">a1</code><code class="o">.</code><code class="na">get</code><code class="o">()</code> <code class="o">+</code> <code class="n">a2</code><code class="o">.</code><code class="na">get</code><code class="o">()</code> <code class="o">+</code> <code class="n">a3</code><code class="o">.</code><code class="na">get</code><code class="o">();</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p>That is compared to the following code using lambdas:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kt">int</code> <code class="nf">calc</code><code class="o">()</code> <code class="o">{</code>&#13;
   <code class="n">IntegerInterface</code> <code class="n">a3</code> <code class="o">=</code> <code class="o">()</code> <code class="o">-&gt;</code> <code class="o">{</code> <code class="k">return</code> <code class="mi">3</code><code class="o">;</code> <code class="o">};</code>&#13;
   <code class="n">IntegerInterface</code> <code class="n">a2</code> <code class="o">=</code> <code class="o">()</code> <code class="o">-&gt;</code> <code class="o">{</code> <code class="k">return</code> <code class="mi">2</code><code class="o">;</code> <code class="o">};</code>&#13;
   <code class="n">IntegerInterface</code> <code class="n">a1</code> <code class="o">=</code> <code class="o">()</code> <code class="o">-&gt;</code> <code class="o">{</code> <code class="k">return</code> <code class="mi">1</code><code class="o">;</code> <code class="o">};</code>&#13;
    <code class="k">return</code> <code class="n">a3</code><code class="o">.</code><code class="na">getInt</code><code class="o">()</code> <code class="o">+</code> <code class="n">a2</code><code class="o">.</code><code class="na">getInt</code><code class="o">()</code> <code class="o">+</code> <code class="n">a1</code><code class="o">.</code><code class="na">getInt</code><code class="o">();</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p>The body of the lambda or anonymous class is crucial: if that body performs&#13;
any significant operations, the time spent in the operation is going to&#13;
overwhelm any small difference in the implementations of the lambda or the&#13;
anonymous class. However, even in this minimal case, the time to perform this&#13;
operation is essentially the same, as <a data-type="xref" href="#TableLambda1">Table 12-11</a> shows, though as&#13;
the number of expressions (i.e., classes/lambdas) increases, small differences&#13;
do emerge.</p>&#13;
<table id="TableLambda1">&#13;
<caption><span class="label">Table 12-11. </span>Time to execute the <code>calc()</code> method using lambdas and anonymous classes</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Implementation</th>&#13;
<th>1,024 expressions</th>&#13;
<th>3 expressions</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p>Anonymous classes</p></td>&#13;
<td><p>781 ± 50 μs</p></td>&#13;
<td><p>10 ± 1 ns</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Lambda</p></td>&#13;
<td><p>587 ± 27 μs</p></td>&#13;
<td><p>10 ± 2 ns</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Static classes</p></td>&#13;
<td><p>734 ± 21 μs</p></td>&#13;
<td><p>10 ± 1 ns</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>One interesting thing about the typical usage in this example is that the code&#13;
that uses the anonymous class creates&#13;
a new object every time the method is called. If the method is called a lot (as&#13;
 it must be in a benchmark to measure its performance),&#13;
many instances of that&#13;
anonymous class are quickly created and discarded. As you saw in&#13;
<a data-type="xref" href="ch05.html#GC">Chapter 5</a>, that kind of usage often has little impact on performance.&#13;
There is a very&#13;
small cost to allocate (and, more important, to initialize) the objects, and because&#13;
they are discarded quickly, they do not really slow down the garbage collector.&#13;
Yet when we’re measuring in the nanosecond range, those small times do add up.</p>&#13;
&#13;
<p>The last row in the table uses preconstructed objects rather than&#13;
anonymous classes:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">private</code> <code class="n">IntegerInterface</code> <code class="n">a1</code> <code class="o">=</code> <code class="k">new</code> <code class="n">IntegerInterface</code><code class="o">()</code> <code class="o">{</code>&#13;
    <code class="kd">public</code> <code class="kt">int</code> <code class="nf">getInt</code><code class="o">()</code> <code class="o">{</code>&#13;
        <code class="k">return</code> <code class="mi">1</code><code class="o">;</code>&#13;
    <code class="o">}</code>&#13;
<code class="o">};</code>&#13;
<code class="o">...</code> <code class="n">Similarly</code> <code class="k">for</code> <code class="n">the</code> <code class="n">other</code> <code class="n">interfaces</code><code class="o">....</code>&#13;
<code class="kd">public</code> <code class="kt">void</code> <code class="nf">calc</code><code class="o">()</code> <code class="o">{</code>&#13;
       <code class="k">return</code> <code class="n">a1</code><code class="o">.</code><code class="na">get</code><code class="o">()</code> <code class="o">+</code> <code class="n">a2</code><code class="o">.</code><code class="na">get</code><code class="o">()</code> <code class="o">+</code> <code class="n">a3</code><code class="o">.</code><code class="na">get</code><code class="o">();</code>&#13;
   <code class="o">}</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p>The typical usage of the lambda does not create a new object on each iteration&#13;
of the loop—making this an area where some corner cases can favor the&#13;
performance of the lambda usage. Even in this example, though, the differences&#13;
are minimal.</p>&#13;
<aside class="less_space pagebreak-before" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45775541952920">&#13;
<h5>Lambdas and Anonymous Classloading</h5>&#13;
<p><a data-primary="anonymous classloading" data-type="indexterm" id="idm45775541951672"/><a data-primary="classloading" data-secondary="lambdas and anonymous classloading" data-type="indexterm" id="idm45775541950968"/>One corner case where this difference comes into play is in startup and&#13;
classloading. It is tempting to look at the code for a lambda and conclude that&#13;
it is syntactic sugar around creating an anonymous class.&#13;
But that is not how it works—the&#13;
code for a lambda creates a static method that is called through a special helper&#13;
class. The anonymous class is an actual Java class; it has a separate&#13;
class file and will be loaded from the classloader.</p>&#13;
&#13;
<p>As you saw previously in this chapter, classloading performance can be important,&#13;
particularly if there is a long classpath. So startup of programs with lots&#13;
of anonymous classes (as opposed to lots of lambdas) may show a somewhat wider&#13;
difference than you’ve seen here.</p>&#13;
</div></aside>&#13;
<div data-type="tip"><h1>Quick Summary</h1>&#13;
<ul>&#13;
<li>&#13;
<p>The choice between using a lambda or an anonymous class should be dictated by&#13;
ease of programming, since there is no difference between their performance.</p>&#13;
</li>&#13;
<li>&#13;
<p>Lambdas are not implemented as anonymous classes, so one exception to that rule is&#13;
in environments where classloading behavior is important; lambdas will be slightly&#13;
faster in that case.<a data-startref="ix_ch12-asciidoc32" data-type="indexterm" id="idm45775541945480"/><a data-startref="ix_ch12-asciidoc31" data-type="indexterm" id="idm45775541944776"/><a data-startref="ix_ch12-asciidoc30" data-type="indexterm" id="idm45775541944104"/></p>&#13;
</li>&#13;
</ul>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Stream and Filter Performance" data-type="sect1"><div class="sect1" id="idm45775542281560">&#13;
<h1>Stream and Filter Performance</h1>&#13;
&#13;
<p><a data-primary="Java SE (Standard Edition) API" data-secondary="stream/filter performance" data-type="indexterm" id="ix_ch12-asciidoc33"/><a data-primary="Stream facility" data-type="indexterm" id="ix_ch12-asciidoc34"/><a data-primary="streams" data-type="indexterm" id="ix_ch12-asciidoc35"/>One other key feature of Java 8, and one that is frequently used in conjunction&#13;
with lambdas, is the new&#13;
<span class="keep-together"><code>Stream</code></span>&#13;
facility. One important performance feature of streams is that they can&#13;
automatically parallelize code. Information about parallel streams can&#13;
be found in&#13;
<a data-type="xref" href="ch09.html#ThreadPerformance">Chapter 9</a>; this section discusses general performance&#13;
features of streams and filters.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Lazy Traversal" data-type="sect2"><div class="sect2" id="idm45775541936664">&#13;
<h2>Lazy Traversal</h2>&#13;
&#13;
<p><a data-primary="lazy traversal" data-type="indexterm" id="ix_ch12-asciidoc36"/>The first performance benefit from streams is that they are implemented as&#13;
lazy data structures. Say we have a list of stock&#13;
symbols, and the goal is to find the first symbol in the list that does not&#13;
contain the letter <code>A</code>. The code to do that through a stream looks like this:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="nd">@Benchmark</code>&#13;
<code class="kd">public</code> <code class="kt">void</code> <code class="nf">calcMulti</code><code class="o">(</code><code class="n">Blackhole</code> <code class="n">bh</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="n">Stream</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code> <code class="n">stream</code> <code class="o">=</code> <code class="n">al</code><code class="o">.</code><code class="na">stream</code><code class="o">();</code>&#13;
    <code class="n">Optional</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code> <code class="n">t</code> <code class="o">=</code> <code class="n">stream</code><code class="o">.</code><code class="na">filter</code><code class="o">(</code><code class="n">symbol</code> <code class="o">-&gt;</code> <code class="n">symbol</code><code class="o">.</code><code class="na">charAt</code><code class="o">(</code><code class="mi">0</code><code class="o">)</code> <code class="o">!=</code> <code class="sc">'A'</code><code class="o">).</code>&#13;
        <code class="n">filter</code><code class="o">(</code><code class="n">symbol</code> <code class="o">-&gt;</code> <code class="n">symbol</code><code class="o">.</code><code class="na">charAt</code><code class="o">(</code><code class="mi">1</code><code class="o">)</code> <code class="o">!=</code> <code class="sc">'A'</code><code class="o">).</code>&#13;
        <code class="n">filter</code><code class="o">(</code><code class="n">symbol</code> <code class="o">-&gt;</code> <code class="n">symbol</code><code class="o">.</code><code class="na">charAt</code><code class="o">(</code><code class="mi">2</code><code class="o">)</code> <code class="o">!=</code> <code class="sc">'A'</code><code class="o">).</code>&#13;
        <code class="n">filter</code><code class="o">(</code><code class="n">symbol</code> <code class="o">-&gt;</code> <code class="n">symbol</code><code class="o">.</code><code class="na">charAt</code><code class="o">(</code><code class="mi">3</code><code class="o">)</code> <code class="o">!=</code> <code class="sc">'A'</code><code class="o">).</code><code class="na">findFirst</code><code class="o">();</code>&#13;
    <code class="n">String</code> <code class="n">answer</code> <code class="o">=</code> <code class="n">t</code><code class="o">.</code><code class="na">get</code><code class="o">();</code>&#13;
    <code class="n">bh</code><code class="o">.</code><code class="na">consume</code><code class="o">(</code><code class="n">answer</code><code class="o">);</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p>There’s obviously a better way to implement this using a single filter, but&#13;
we’ll save that discussion for later in this section. For now, consider what it means for the&#13;
stream to be implemented lazily in this example. <a data-primary="filter() method" data-type="indexterm" id="idm45775541930856"/>Each&#13;
<span class="keep-together"><code>filter()</code></span>&#13;
method returns a new stream, so there are, in effect, four logical streams here.</p>&#13;
&#13;
<p>The&#13;
<span class="keep-together"><code>filter()</code></span>&#13;
method, it turns out, doesn’t really do anything except set up a series of&#13;
pointers. The effect of that is when the&#13;
<span class="keep-together"><code>findFirst()</code></span>&#13;
method is invoked on the stream, no data processing has been performed—no&#13;
comparisons of data to the character <code>A</code> have yet been made.</p>&#13;
&#13;
<p>Instead,&#13;
<span class="keep-together"><code>findFirst()</code></span>&#13;
asks the previous stream (returned from filter 4) for an element. That stream&#13;
has no elements yet, so it calls back to the stream produced by filter 3, and&#13;
so on. Filter 1 will grab the first element from the array list (from the&#13;
stream, technically) and test whether its first character is <code>A</code>. If so, it&#13;
completes the callback and returns that element downstream; otherwise, it&#13;
continues to iterate through the array until it finds a matching element (or&#13;
exhausts the array). Filter 2 behaves similarly—when the callback to filter&#13;
1 returns, it tests whether the second character is not <code>A</code>. If so, it completes&#13;
its callback and passes the symbol downstream; if not, it makes another callback&#13;
to filter 1 to get the next symbol.</p>&#13;
&#13;
<p>All those callbacks may sound inefficient, but consider the alternative. An&#13;
algorithm to process the streams eagerly would look something like this:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">private</code> <code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code> <code class="n">ArrayList</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code> <code class="n">calcArray</code><code class="o">(</code><code class="n">List</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code> <code class="n">src</code><code class="o">,</code> <code class="n">Predicate</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code> <code class="n">p</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="n">ArrayList</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code> <code class="n">dst</code> <code class="o">=</code> <code class="k">new</code> <code class="n">ArrayList</code><code class="o">&lt;&gt;();</code>&#13;
    <code class="k">for</code> <code class="o">(</code><code class="n">T</code> <code class="n">s</code> <code class="o">:</code> <code class="n">src</code><code class="o">)</code> <code class="o">{</code>&#13;
        <code class="k">if</code> <code class="o">(</code><code class="n">p</code><code class="o">.</code><code class="na">test</code><code class="o">(</code><code class="n">s</code><code class="o">))</code>&#13;
            <code class="n">dst</code><code class="o">.</code><code class="na">add</code><code class="o">(</code><code class="n">s</code><code class="o">);</code>&#13;
    <code class="o">}</code>&#13;
    <code class="k">return</code> <code class="n">dst</code><code class="o">;</code>&#13;
<code class="o">}</code>&#13;
&#13;
<code class="nd">@Benchmark</code>&#13;
<code class="kd">public</code> <code class="kt">void</code> <code class="nf">calcEager</code><code class="o">(</code><code class="n">Blackhole</code> <code class="n">bh</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="n">ArrayList</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code> <code class="n">al1</code> <code class="o">=</code> <code class="n">calcArray</code><code class="o">(</code><code class="n">al</code><code class="o">,</code> <code class="mi">0</code><code class="o">,</code> <code class="sc">'A'</code><code class="o">);</code>&#13;
    <code class="n">ArrayList</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code> <code class="n">al2</code> <code class="o">=</code> <code class="n">calcArray</code><code class="o">(</code><code class="n">al1</code><code class="o">,</code> <code class="mi">1</code><code class="o">,</code> <code class="sc">'A'</code><code class="o">);</code>&#13;
    <code class="n">ArrayList</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code> <code class="n">al3</code> <code class="o">=</code> <code class="n">calcArray</code><code class="o">(</code><code class="n">al2</code><code class="o">,</code> <code class="mi">2</code><code class="o">,</code> <code class="sc">'A'</code><code class="o">);</code>&#13;
    <code class="n">ArrayList</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code> <code class="n">al4</code> <code class="o">=</code> <code class="n">calcArray</code><code class="o">(</code><code class="n">al3</code><code class="o">,</code> <code class="mi">3</code><code class="o">,</code> <code class="sc">'A'</code><code class="o">);</code>&#13;
    <code class="n">String</code> <code class="n">answer</code> <code class="o">=</code> <code class="n">al4</code><code class="o">.</code><code class="na">get</code><code class="o">(</code><code class="mi">0</code><code class="o">);</code>&#13;
    <code class="n">bh</code><code class="o">.</code><code class="na">consume</code><code class="o">(</code><code class="n">answer</code><code class="o">);</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p>There are two reasons this alternative is less efficient than the lazy&#13;
implementation that Java actually adopted. First, it requires the creation&#13;
of a lot of temporary instances of the&#13;
<span class="keep-together"><code>ArrayList</code></span>&#13;
class. Second, in the lazy implementation, processing can stop as soon as&#13;
the&#13;
<span class="keep-together"><code>findFirst()</code></span>&#13;
method gets an element. That means only a subset of the items must actually&#13;
pass through the filters. The eager implementation, on the other hand, must&#13;
process the entire list several times until the last list is created.</p>&#13;
&#13;
<p>Hence, it should come as no surprise that the lazy implementation is far&#13;
more performant than the alternative in this example. In this case, the&#13;
test is processing a list of 456,976 four-letter symbols, which are sorted&#13;
in alphabetical order. The eager implementation&#13;
processes only 18,278 of those before it encounters the symbol <code>BBBB</code>,&#13;
at which point it can stop. It takes the iterator two orders of magnitude longer&#13;
to find that answer, as shown in <a data-type="xref" href="#TableFilter">Table 12-12</a>.</p>&#13;
<table id="TableFilter">&#13;
<caption><span class="label">Table 12-12. </span>Time to process lazy versus eager filters</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Implementation</th>&#13;
<th>Seconds</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p>Filter/<code>findFirst</code></p></td>&#13;
<td><p>0.76 ± 0.047 ms</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Iterator/<code>findFirst</code></p></td>&#13;
<td><p>108.4 ± 4 ms</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>One reason, then, that filters can be so much faster than iterators is simply&#13;
that they can take advantage of algorithmic opportunities for optimizations:&#13;
the lazy filter implementation can end processing whenever it has done what&#13;
it needs to do, processing less data.</p>&#13;
&#13;
<p>What if the entire set of data must be processed? What is the basic performance&#13;
of filters versus iterators in that case? For this example, we’ll change the&#13;
test slightly. The previous example made a good teaching point about how&#13;
multiple filters worked, but ideally it was obvious that the code would&#13;
perform better with a single filter:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="nd">@Benchmark</code>&#13;
<code class="kd">public</code> <code class="kt">void</code> <code class="nf">countFilter</code><code class="o">(</code><code class="n">Blackhole</code> <code class="n">bh</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="n">count</code> <code class="o">=</code> <code class="mi">0</code><code class="o">;</code>&#13;
    <code class="n">Stream</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code> <code class="n">stream</code> <code class="o">=</code> <code class="n">al</code><code class="o">.</code><code class="na">stream</code><code class="o">();</code>&#13;
    <code class="n">stream</code><code class="o">.</code><code class="na">filter</code><code class="o">(</code>&#13;
        <code class="n">symbol</code> <code class="o">-&gt;</code> <code class="n">symbol</code><code class="o">.</code><code class="na">charAt</code><code class="o">(</code><code class="mi">0</code><code class="o">)</code> <code class="o">!=</code> <code class="sc">'A'</code> <code class="o">&amp;&amp;</code>&#13;
        <code class="n">symbol</code><code class="o">.</code><code class="na">charAt</code><code class="o">(</code><code class="mi">1</code><code class="o">)</code> <code class="o">!=</code> <code class="sc">'A'</code> <code class="o">&amp;&amp;</code>&#13;
        <code class="n">symbol</code><code class="o">.</code><code class="na">charAt</code><code class="o">(</code><code class="mi">2</code><code class="o">)</code> <code class="o">!=</code> <code class="sc">'A'</code> <code class="o">&amp;&amp;</code>&#13;
        <code class="n">symbol</code><code class="o">.</code><code class="na">charAt</code><code class="o">(</code><code class="mi">3</code><code class="o">)</code> <code class="o">!=</code> <code class="sc">'A'</code><code class="o">).</code>&#13;
          <code class="n">forEach</code><code class="o">(</code><code class="n">symbol</code> <code class="o">-&gt;</code> <code class="o">{</code> <code class="n">count</code><code class="o">++;</code> <code class="o">});</code>&#13;
    <code class="n">bh</code><code class="o">.</code><code class="na">consume</code><code class="o">(</code><code class="n">count</code><code class="o">);</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p>This example also changes the final code to count the symbols, so that the&#13;
entire list will be processed. On the flip side, the eager implementation can&#13;
now use an iterator directly:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="nd">@Benchmark</code>&#13;
<code class="kd">public</code> <code class="kt">void</code> <code class="nf">countIterator</code><code class="o">(</code><code class="n">Blackhole</code> <code class="n">bh</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="kt">int</code> <code class="n">count</code> <code class="o">=</code> <code class="mi">0</code><code class="o">;</code>&#13;
    <code class="k">for</code> <code class="o">(</code><code class="n">String</code> <code class="n">symbol</code> <code class="o">:</code> <code class="n">al</code><code class="o">)</code> <code class="o">{</code>&#13;
      <code class="k">if</code> <code class="o">(</code><code class="n">symbol</code><code class="o">.</code><code class="na">charAt</code><code class="o">(</code><code class="mi">0</code><code class="o">)</code> <code class="o">!=</code> <code class="sc">'A'</code> <code class="o">&amp;&amp;</code>&#13;
          <code class="n">symbol</code><code class="o">.</code><code class="na">charAt</code><code class="o">(</code><code class="mi">1</code><code class="o">)</code> <code class="o">!=</code> <code class="sc">'A'</code> <code class="o">&amp;&amp;</code>&#13;
          <code class="n">symbol</code><code class="o">.</code><code class="na">charAt</code><code class="o">(</code><code class="mi">2</code><code class="o">)</code> <code class="o">!=</code> <code class="sc">'A'</code> <code class="o">&amp;&amp;</code>&#13;
          <code class="n">symbol</code><code class="o">.</code><code class="na">charAt</code><code class="o">(</code><code class="mi">3</code><code class="o">)</code> <code class="o">!=</code> <code class="sc">'A'</code><code class="o">)</code>&#13;
          <code class="n">count</code><code class="o">++;</code>&#13;
      <code class="o">}</code>&#13;
    <code class="n">bh</code><code class="o">.</code><code class="na">consume</code><code class="o">(</code><code class="n">count</code><code class="o">);</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p>Even in this case, the lazy filter implementation is faster than the iterator (see <a data-type="xref" href="#TableFilterOpt">Table 12-13</a>).<a data-startref="ix_ch12-asciidoc36" data-type="indexterm" id="idm45775541544808"/></p>&#13;
<table id="TableFilterOpt">&#13;
<caption><span class="label">Table 12-13. </span>Time to process single filter versus an iterator</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Implementation</th>&#13;
<th>Time required</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p>Filters</p></td>&#13;
<td><p>7 ± 0.6 ms</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Iterator</p></td>&#13;
<td><p>7.4 ± 3 ms</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<div data-type="tip"><h1>Quick Summary</h1>&#13;
<ul>&#13;
<li>&#13;
<p>Filters offer a significant performance advantage by allowing processing to end in the middle of iterating through the data.</p>&#13;
</li>&#13;
<li>&#13;
<p>Even when the entire data set is processed, a single filter will slightly outperform an iterator.</p>&#13;
</li>&#13;
<li>&#13;
<p>Multiple filters have overhead; make sure to write good filters.<a data-startref="ix_ch12-asciidoc35" data-type="indexterm" id="idm45775541328024"/><a data-startref="ix_ch12-asciidoc34" data-type="indexterm" id="idm45775541327320"/><a data-startref="ix_ch12-asciidoc33" data-type="indexterm" id="idm45775541326648"/></p>&#13;
</li>&#13;
</ul>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Object Serialization" data-type="sect1"><div class="sect1" id="Object_Serialization">&#13;
<h1>Object Serialization</h1>&#13;
&#13;
<p><a data-primary="Java SE (Standard Edition) API" data-secondary="object serialization" data-type="indexterm" id="ix_ch12-asciidoc37"/><a data-primary="object serialization" data-type="indexterm" id="ix_ch12-asciidoc38"/><a data-primary="serialization" data-secondary="object serialization" data-type="indexterm" id="ix_ch12-asciidoc39"/><em>Object serialization</em> is a way to write out the binary state of an object&#13;
such that it can be re-created later.&#13;
The JDK provides a default mechanism to serialize objects that&#13;
implement either the&#13;
<code class="keep-together">Serializable</code>&#13;
or&#13;
<code class="keep-together">Externalizable</code>&#13;
interface.&#13;
The serialization performance of practically every object&#13;
imaginable can be improved from the default serialization code, but this is&#13;
definitely one of those times when it would be unwise&#13;
to perform that optimization prematurely. The special code to serialize and&#13;
deserialize the object will take a fair amount of time to write,&#13;
and the code will be&#13;
harder to maintain than code that uses default serialization.&#13;
Serialization code&#13;
can also be a little tricky to write correctly, so attempting to optimize it&#13;
increases the risk of producing incorrect code.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Transient Fields" data-type="sect2"><div class="sect2" id="idm45775541317720">&#13;
<h2>Transient Fields</h2>&#13;
&#13;
<p><a data-primary="object serialization" data-secondary="transient fields" data-type="indexterm" id="idm45775541316520"/><a data-primary="transient fields" data-type="indexterm" id="idm45775541315320"/>In general, the way to improve object serialization cost is to serialize&#13;
less data. This is done by marking fields as&#13;
<span class="keep-together"><code>transient</code></span>,&#13;
in which case&#13;
they are not serialized by default.&#13;
Then the class can supply special&#13;
<code class="keep-together">writeObject()</code>&#13;
and&#13;
<code class="keep-together">readObject()</code>&#13;
methods&#13;
to handle that data. If the data isn’t needed, marking it as <code>transient</code> is sufficient.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Overriding Default Serialization" data-type="sect2"><div class="sect2" id="idm45775541311656">&#13;
<h2>Overriding Default Serialization</h2>&#13;
&#13;
<p><a data-primary="object serialization" data-secondary="overriding default serialization" data-type="indexterm" id="ix_ch12-asciidoc40"/>The&#13;
<code class="keep-together">writeObject()</code>&#13;
and&#13;
<code class="keep-together">readObject()</code>&#13;
methods allow complete control over how data is serialized. With great&#13;
control comes great responsibility: it’s easy to get this wrong.</p>&#13;
&#13;
<p>To get an idea of why serialization optimizations are tricky, take&#13;
the case of a simple <code>Point</code> object that represents a location:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">class</code> <code class="nc">Point</code> <code class="kd">implements</code> <code class="n">Serializable</code> <code class="o">{</code>&#13;
    <code class="kd">private</code> <code class="kt">int</code> <code class="n">x</code><code class="o">;</code>&#13;
    <code class="kd">private</code> <code class="kt">int</code> <code class="n">y</code><code class="o">;</code>&#13;
    <code class="o">...</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p>That code could be written to perform special serialization like this:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">class</code> <code class="nc">Point</code> <code class="kd">implements</code> <code class="n">Serializable</code> <code class="o">{</code>&#13;
    <code class="kd">private</code> <code class="kd">transient</code> <code class="kt">int</code> <code class="n">x</code><code class="o">;</code>&#13;
    <code class="kd">private</code> <code class="kd">transient</code> <code class="kt">int</code> <code class="n">y</code><code class="o">;</code>&#13;
    <code class="o">....</code>&#13;
    <code class="kd">private</code> <code class="kt">void</code> <code class="nf">writeObject</code><code class="o">(</code><code class="n">ObjectOutputStream</code> <code class="n">oos</code><code class="o">)</code> <code class="kd">throws</code> <code class="n">IOException</code> <code class="o">{</code>&#13;
        <code class="n">oos</code><code class="o">.</code><code class="na">defaultWriteObject</code><code class="o">();</code>&#13;
	<code class="n">oos</code><code class="o">.</code><code class="na">writeInt</code><code class="o">(</code><code class="n">x</code><code class="o">);</code>&#13;
	<code class="n">oos</code><code class="o">.</code><code class="na">writeInt</code><code class="o">(</code><code class="n">y</code><code class="o">);</code>&#13;
    <code class="o">}</code>&#13;
    <code class="kd">private</code> <code class="kt">void</code> <code class="nf">readObject</code><code class="o">(</code><code class="n">ObjectInputStream</code> <code class="n">ois</code><code class="o">)</code>&#13;
	                        <code class="kd">throws</code> <code class="n">IOException</code><code class="o">,</code> <code class="n">ClassNotFoundException</code> <code class="o">{</code>&#13;
        <code class="n">ois</code><code class="o">.</code><code class="na">defaultReadObject</code><code class="o">();</code>&#13;
	<code class="n">x</code> <code class="o">=</code> <code class="n">ois</code><code class="o">.</code><code class="na">readInt</code><code class="o">();</code>&#13;
	<code class="n">y</code> <code class="o">=</code> <code class="n">ois</code><code class="o">.</code><code class="na">readInt</code><code class="o">();</code>&#13;
    <code class="o">}</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p>In a simple example like this, the more complex code isn’t going to be&#13;
any faster, but it is still functionally correct.&#13;
But beware of using this technique in the general case:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">class</code> <code class="nc">TripHistory</code> <code class="kd">implements</code> <code class="n">Serializable</code> <code class="o">{</code>&#13;
    <code class="kd">private</code> <code class="kd">transient</code> <code class="n">Point</code><code class="o">[]</code> <code class="n">airportsVisited</code><code class="o">;</code>&#13;
    <code class="o">....</code>&#13;
    <code class="c1">// THIS CODE IS NOT FUNCTIONALLY CORRECT</code>&#13;
    <code class="kd">private</code> <code class="kt">void</code> <code class="nf">writeObject</code><code class="o">(</code><code class="n">ObjectOutputStream</code> <code class="n">oos</code><code class="o">)</code> <code class="kd">throws</code> <code class="n">IOException</code> <code class="o">{</code>&#13;
        <code class="n">oos</code><code class="o">.</code><code class="na">defaultWriteObject</code><code class="o">();</code>&#13;
        <code class="n">oos</code><code class="o">.</code><code class="na">writeInt</code><code class="o">(</code><code class="n">airportsVisited</code><code class="o">.</code><code class="na">length</code><code class="o">);</code>&#13;
        <code class="k">for</code> <code class="o">(</code><code class="kt">int</code> <code class="n">i</code> <code class="o">=</code> <code class="mi">0</code><code class="o">;</code> <code class="n">i</code> <code class="o">&lt;</code> <code class="n">airportsVisited</code><code class="o">.</code><code class="na">length</code><code class="o">;</code> <code class="n">i</code><code class="o">++)</code> <code class="o">{</code>&#13;
            <code class="n">oos</code><code class="o">.</code><code class="na">writeInt</code><code class="o">(</code><code class="n">airportsVisited</code><code class="o">[</code><code class="n">i</code><code class="o">].</code><code class="na">getX</code><code class="o">());</code>&#13;
            <code class="n">oos</code><code class="o">.</code><code class="na">writeInt</code><code class="o">(</code><code class="n">airportsVisited</code><code class="o">[</code><code class="n">i</code><code class="o">].</code><code class="na">getY</code><code class="o">());</code>&#13;
        <code class="o">}</code>&#13;
    <code class="o">}</code>&#13;
&#13;
    <code class="kd">private</code> <code class="kt">void</code> <code class="nf">readObject</code><code class="o">(</code><code class="n">ObjectInputStream</code> <code class="n">ois</code><code class="o">)</code>&#13;
	                        <code class="kd">throws</code> <code class="n">IOException</code><code class="o">,</code> <code class="n">ClassNotFoundException</code> <code class="o">{</code>&#13;
        <code class="n">ois</code><code class="o">.</code><code class="na">defaultReadObject</code><code class="o">();</code>&#13;
        <code class="kt">int</code> <code class="n">length</code> <code class="o">=</code> <code class="n">ois</code><code class="o">.</code><code class="na">readInt</code><code class="o">();</code>&#13;
        <code class="n">airportsVisited</code> <code class="o">=</code> <code class="k">new</code> <code class="n">Point</code><code class="o">[</code><code class="n">length</code><code class="o">];</code>&#13;
        <code class="k">for</code> <code class="o">(</code><code class="kt">int</code> <code class="n">i</code> <code class="o">=</code> <code class="mi">0</code><code class="o">;</code> <code class="n">i</code> <code class="o">&lt;</code> <code class="n">length</code><code class="o">;</code> <code class="n">i</code><code class="o">++)</code> <code class="o">{</code>&#13;
            <code class="n">airportsVisited</code><code class="o">[</code><code class="n">i</code><code class="o">]</code> <code class="o">=</code> <code class="k">new</code> <code class="n">Point</code><code class="o">(</code><code class="n">ois</code><code class="o">.</code><code class="na">readInt</code><code class="o">(),</code> <code class="n">ois</code><code class="o">.</code><code class="na">readInt</code><code class="o">();</code>&#13;
        <code class="o">}</code>&#13;
    <code class="o">}</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p>Here, the&#13;
<code class="keep-together">airportsVisited</code>&#13;
field is an array of all the airports I’ve&#13;
ever flown to or from, in the order in which I visited them. So certain&#13;
airports, like JFK, appear frequently in the array; SYD appears only once&#13;
(so far).</p>&#13;
&#13;
<p>Because it is expensive to write object references, this code would&#13;
certainly perform faster than the default serialization mechanism for that&#13;
array: an array of 100,000&#13;
<code class="keep-together">Point</code>&#13;
objects takes 15.5 ± 0.3 ms seconds to serialize&#13;
on my machine and 10.9 ± 0.5 ms to deserialize. Using this “optimization,”&#13;
it takes only 1 ± .600 ms seconds to serialize and&#13;
0.85 ± 0.2 μs to deserialize.</p>&#13;
&#13;
<p>This code, however, is incorrect. Before serialization, a single&#13;
object represents JFK, and the reference to that object appears multiple&#13;
times in the&#13;
array. After the array is serialized and then deserialized, multiple&#13;
objects represent JFK. This changes the behavior of the application.</p>&#13;
&#13;
<p>When the array is deserialized in this example, those JFK references&#13;
end up as separate,&#13;
different objects. Now when one&#13;
of those objects is changed, only that object is changed,&#13;
and it ends up with different data than the remaining objects that refer&#13;
to JFK.</p>&#13;
&#13;
<p>This is an important principle to keep in mind, because optimizing&#13;
serialization is often about performing special handling for object&#13;
references. Done correctly, that can greatly increase the performance of&#13;
serialization code. Done incorrectly, it can introduce subtle&#13;
bugs.</p>&#13;
&#13;
<p>With that in mind, let’s explore the serialization of the&#13;
<code class="keep-together">StockPriceHistory</code>&#13;
class to see how serialization optimizations can be made. The fields in&#13;
that class include the <span class="keep-together">following</span>:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">class</code> <code class="nc">StockPriceHistoryImpl</code> <code class="kd">implements</code> <code class="n">StockPriceHistory</code> <code class="o">{</code>&#13;
    <code class="kd">private</code> <code class="n">String</code> <code class="n">symbol</code><code class="o">;</code>&#13;
    <code class="kd">protected</code> <code class="n">SortedMap</code><code class="o">&lt;</code><code class="n">Date</code><code class="o">,</code> <code class="n">StockPrice</code><code class="o">&gt;</code> <code class="n">prices</code> <code class="o">=</code> <code class="k">new</code> <code class="n">TreeMap</code><code class="o">&lt;&gt;();</code>&#13;
    <code class="kd">protected</code> <code class="n">Date</code> <code class="n">firstDate</code><code class="o">;</code>&#13;
    <code class="kd">protected</code> <code class="n">Date</code> <code class="n">lastDate</code><code class="o">;</code>&#13;
    <code class="kd">protected</code> <code class="kt">boolean</code> <code class="n">needsCalc</code> <code class="o">=</code> <code class="kc">true</code><code class="o">;</code>&#13;
    <code class="kd">protected</code> <code class="n">BigDecimal</code> <code class="n">highPrice</code><code class="o">;</code>&#13;
    <code class="kd">protected</code> <code class="n">BigDecimal</code> <code class="n">lowPrice</code><code class="o">;</code>&#13;
    <code class="kd">protected</code> <code class="n">BigDecimal</code> <code class="n">averagePrice</code><code class="o">;</code>&#13;
    <code class="kd">protected</code> <code class="n">BigDecimal</code> <code class="n">stdDev</code><code class="o">;</code>&#13;
    <code class="kd">private</code> <code class="n">Map</code><code class="o">&lt;</code><code class="n">BigDecimal</code><code class="o">,</code> <code class="n">ArrayList</code><code class="o">&lt;</code><code class="n">Date</code><code class="o">&gt;&gt;</code> <code class="n">histogram</code><code class="o">;</code>&#13;
    <code class="o">....</code>&#13;
    <code class="kd">public</code> <code class="nf">StockPriceHistoryImpl</code><code class="o">(</code><code class="n">String</code> <code class="n">s</code><code class="o">,</code> <code class="n">Date</code> <code class="n">firstDate</code><code class="o">,</code> <code class="n">Date</code> <code class="n">lastDate</code><code class="o">)</code> <code class="o">{</code>&#13;
        <code class="n">prices</code> <code class="o">=</code> <code class="o">....</code>&#13;
    <code class="o">}</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p>When the history for a stock is constructed for a given symbol <code>s</code>, the&#13;
object creates and stores a sorted map of&#13;
<code class="keep-together">prices</code>&#13;
keyed by date of all&#13;
the prices between&#13;
<code class="keep-together">start</code> and&#13;
<code class="keep-together">end</code>.&#13;
The code also saves the&#13;
<code class="keep-together">firstDate</code>&#13;
and the&#13;
<code class="keep-together">lastDate</code>.&#13;
The&#13;
constructor doesn’t fill in any other fields; they are initialized lazily.&#13;
When a getter on any of those fields is called, the getter&#13;
checks if&#13;
<code class="keep-together">needsCalc</code>&#13;
is&#13;
<code class="keep-together">true</code>.&#13;
If it is, it calculates the appropriate&#13;
values for the remaining fields if necessary (all at once).</p>&#13;
&#13;
<p>This calculation includes creating the&#13;
<code class="keep-together">histogram</code>,&#13;
which&#13;
records how many days the stock closed at a particular price. The histogram&#13;
contains the same data (in terms of&#13;
<code class="keep-together">BigDecimal</code>&#13;
and&#13;
<code class="keep-together">Date</code>&#13;
objects)&#13;
as is found in the&#13;
<code class="keep-together">prices</code>&#13;
map; it is just a different way of looking&#13;
at the data.</p>&#13;
&#13;
<p>Because all of the lazily initialized fields can be calculated from&#13;
the&#13;
<code class="keep-together">prices</code>&#13;
array, they can all be marked&#13;
<code class="keep-together">transient</code>,&#13;
and no special work&#13;
is required to serialize or deserialize them. The example is easy in this&#13;
case because the code was already doing lazy initialization of the fields;&#13;
it can repeat that lazy initialization when receiving the data.&#13;
Even if the code eagerly initialized these fields, it could still&#13;
mark&#13;
any calculated fields&#13;
<code class="keep-together">transient</code>&#13;
and recalculate their values in the&#13;
<code class="keep-together">readObject()</code>&#13;
method of the class.</p>&#13;
&#13;
<p>Note too that this preserves the object relationship between the&#13;
<code class="keep-together">prices</code>&#13;
and&#13;
<code class="keep-together">histogram</code>&#13;
objects: when the histogram is recalculated, it will&#13;
just insert existing objects into the new map.</p>&#13;
&#13;
<p>This kind of optimization is almost always a good thing, but in some&#13;
cases it can hurt performance. <a data-type="xref" href="#TableTransientHist">Table 12-14</a>&#13;
shows the time it takes to serialize and deserialize this case where the&#13;
<code class="keep-together">histogram</code>&#13;
object is transient versus nontransient, as well as the size&#13;
of the serialized data for each case.</p>&#13;
<table id="TableTransientHist">&#13;
<caption><span class="label">Table 12-14. </span>Time to serialize and deserialize objects with transient fields</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Object</th>&#13;
<th>Serialization time</th>&#13;
<th>Deserialization time</th>&#13;
<th>Size of data</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p>No transient fields</p></td>&#13;
<td><p>19.1 ± 0.1 ms</p></td>&#13;
<td><p>16.8 ± 0.4 ms</p></td>&#13;
<td><p>785,395 bytes</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Transient histogram</p></td>&#13;
<td><p>16.7 ± 0.2 ms</p></td>&#13;
<td><p>14.4 ± 0.2 ms</p></td>&#13;
<td><p>754,227 bytes</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>So far, the example saves about 15% of the total time to serialize and&#13;
deserialize the object. But this test has not actually re-created&#13;
the&#13;
<code class="keep-together">histogram</code>&#13;
object on the receiving side. That object will be created&#13;
when the receiving code first accesses it.</p>&#13;
&#13;
<p>Sometimes the&#13;
<code class="keep-together">histogram</code>&#13;
object&#13;
will not be needed; the receiver may be interested in only the prices&#13;
on particular days, and not the histogram. That is where the more&#13;
unusual case comes in: if the&#13;
<code class="keep-together">histogram</code>&#13;
will always be needed and if it takes&#13;
more than 2.4 milliseconds to calculate the histogram, then&#13;
the case with the lazily initialized fields will actually have&#13;
a net performance decrease.</p>&#13;
&#13;
<p>In this case, calculating the&#13;
histogram does not fall into that category—it is a very fast operation.&#13;
In general, it may be hard to find a case&#13;
where recalculating a piece of data is more expensive than&#13;
serializing and deserializing that data. But&#13;
it is something to consider as code is optimized.</p>&#13;
&#13;
<p>This test is not actually transmitting data; the data is&#13;
written to and read from preallocated byte arrays so that it measures&#13;
only the time for serialization and deserialization. Still,&#13;
notice that making the&#13;
<code>histogram</code>&#13;
field transient has also&#13;
saved about 13% in the size of the data. That will be quite important if&#13;
the data is to be transmitted via a network.<a data-startref="ix_ch12-asciidoc40" data-type="indexterm" id="idm45775540875560"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Compressing Serialized Data" data-type="sect2"><div class="sect2" id="idm45775541310680">&#13;
<h2>Compressing Serialized Data</h2>&#13;
&#13;
<p><a data-primary="compression, serialized data" data-type="indexterm" id="ix_ch12-asciidoc41"/><a data-primary="object serialization" data-secondary="compressing serialized data" data-type="indexterm" id="ix_ch12-asciidoc42"/><a data-primary="serialization" data-secondary="compressing serialized data" data-type="indexterm" id="ix_ch12-asciidoc43"/>Serialization performance of code can be improved in a third way: compress the serialized&#13;
data so it is faster to transmit.  In the&#13;
stock history class, that is done by compressing the <code>prices</code> map during&#13;
serialization:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">class</code> <code class="nc">StockPriceHistoryCompress</code>&#13;
	<code class="kd">implements</code> <code class="n">StockPriceHistory</code><code class="o">,</code> <code class="n">Serializable</code> <code class="o">{</code>&#13;
&#13;
    <code class="kd">private</code> <code class="kt">byte</code><code class="o">[]</code> <code class="n">zippedPrices</code><code class="o">;</code>&#13;
    <code class="kd">private</code> <code class="kd">transient</code> <code class="n">SortedMap</code><code class="o">&lt;</code><code class="n">Date</code><code class="o">,</code> <code class="n">StockPrice</code><code class="o">&gt;</code> <code class="n">prices</code><code class="o">;</code>&#13;
&#13;
    <code class="kd">private</code> <code class="kt">void</code> <code class="nf">writeObject</code><code class="o">(</code><code class="n">ObjectOutputStream</code> <code class="n">out</code><code class="o">)</code>&#13;
    		<code class="kd">throws</code> <code class="n">IOException</code> <code class="o">{</code>&#13;
        <code class="k">if</code> <code class="o">(</code><code class="n">zippedPrices</code> <code class="o">==</code> <code class="kc">null</code><code class="o">)</code> <code class="o">{</code>&#13;
	    <code class="n">makeZippedPrices</code><code class="o">();</code>&#13;
	<code class="o">}</code>&#13;
	<code class="n">out</code><code class="o">.</code><code class="na">defaultWriteObject</code><code class="o">();</code>&#13;
    <code class="o">}</code>&#13;
&#13;
    <code class="kd">private</code> <code class="kt">void</code> <code class="nf">readObject</code><code class="o">(</code><code class="n">ObjectInputStream</code> <code class="n">in</code><code class="o">)</code>&#13;
    		<code class="kd">throws</code> <code class="n">IOException</code><code class="o">,</code> <code class="n">ClassNotFoundException</code> <code class="o">{</code>&#13;
        <code class="n">in</code><code class="o">.</code><code class="na">defaultReadObject</code><code class="o">();</code>&#13;
        <code class="n">unzipPrices</code><code class="o">();</code>&#13;
    <code class="o">}</code>&#13;
&#13;
    <code class="kd">protected</code> <code class="kt">void</code> <code class="nf">makeZippedPrices</code><code class="o">()</code> <code class="kd">throws</code> <code class="n">IOException</code> <code class="o">{</code>&#13;
        <code class="n">ByteArrayOutputStream</code> <code class="n">baos</code> <code class="o">=</code> <code class="k">new</code> <code class="n">ByteArrayOutputStream</code><code class="o">();</code>&#13;
        <code class="n">GZIPOutputStream</code> <code class="n">zip</code> <code class="o">=</code> <code class="k">new</code> <code class="n">GZIPOutputStream</code><code class="o">(</code><code class="n">baos</code><code class="o">);</code>&#13;
        <code class="n">ObjectOutputStream</code> <code class="n">oos</code> <code class="o">=</code> <code class="k">new</code> <code class="n">ObjectOutputStream</code><code class="o">(</code>&#13;
		<code class="k">new</code> <code class="nf">BufferedOutputStream</code><code class="o">(</code><code class="n">zip</code><code class="o">));</code>&#13;
        <code class="n">oos</code><code class="o">.</code><code class="na">writeObject</code><code class="o">(</code><code class="n">prices</code><code class="o">);</code>&#13;
        <code class="n">oos</code><code class="o">.</code><code class="na">close</code><code class="o">();</code>&#13;
        <code class="n">zip</code><code class="o">.</code><code class="na">close</code><code class="o">();</code>&#13;
        <code class="n">zippedPrices</code> <code class="o">=</code> <code class="n">baos</code><code class="o">.</code><code class="na">toByteArray</code><code class="o">();</code>&#13;
    <code class="o">}</code>&#13;
&#13;
    <code class="kd">protected</code> <code class="kt">void</code> <code class="nf">unzipPrices</code><code class="o">()</code>&#13;
    		<code class="kd">throws</code> <code class="n">IOException</code><code class="o">,</code> <code class="n">ClassNotFoundException</code> <code class="o">{</code>&#13;
        <code class="n">ByteArrayInputStream</code> <code class="n">bais</code> <code class="o">=</code> <code class="k">new</code> <code class="n">ByteArrayInputStream</code><code class="o">(</code><code class="n">zippedPrices</code><code class="o">);</code>&#13;
        <code class="n">GZIPInputStream</code> <code class="n">zip</code> <code class="o">=</code> <code class="k">new</code> <code class="n">GZIPInputStream</code><code class="o">(</code><code class="n">bais</code><code class="o">);</code>&#13;
        <code class="n">ObjectInputStream</code> <code class="n">ois</code> <code class="o">=</code> <code class="k">new</code> <code class="n">ObjectInputStream</code><code class="o">(</code>&#13;
		<code class="k">new</code> <code class="nf">BufferedInputStream</code><code class="o">(</code><code class="n">zip</code><code class="o">));</code>&#13;
        <code class="n">prices</code> <code class="o">=</code> <code class="o">(</code><code class="n">SortedMap</code><code class="o">&lt;</code><code class="n">Date</code><code class="o">,</code> <code class="n">StockPrice</code><code class="o">&gt;)</code> <code class="n">ois</code><code class="o">.</code><code class="na">readObject</code><code class="o">();</code>&#13;
        <code class="n">ois</code><code class="o">.</code><code class="na">close</code><code class="o">();</code>&#13;
        <code class="n">zip</code><code class="o">.</code><code class="na">close</code><code class="o">();</code>&#13;
    <code class="o">}</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p>The&#13;
<code class="keep-together">zipPrices()</code>&#13;
method serializes the map of prices to a byte array&#13;
and saves the resulting bytes, which are then serialized normally in the&#13;
<code class="keep-together">writeObject()</code>&#13;
method when it calls the&#13;
<code class="keep-together">defaultWriteObject()</code>&#13;
method. (In&#13;
fact, as long as the serialization is being customized, it will be&#13;
ever-so-slightly better to make the <code>zippedPrices</code> array transient and&#13;
write out its length and bytes directly. But this example code is a little&#13;
clearer, and simpler is better.) On deserialization, the reverse operation&#13;
is performed.</p>&#13;
&#13;
<p>If the goal is to serialize to a byte stream (as in the original sample&#13;
code), this is a losing proposition.&#13;
That isn’t surprising; the time required to compress the bytes is much&#13;
longer than the time to write them to a local byte array. Those times&#13;
are shown in <a data-type="xref" href="#TableSerializeCompress">Table 12-15</a>.</p>&#13;
<table id="TableSerializeCompress">&#13;
<caption><span class="label">Table 12-15. </span>Time to serialize and deserialize 10,000 objects with compression</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Use case</th>&#13;
<th>Serialization time</th>&#13;
<th>Deserialization time</th>&#13;
<th>Size of data</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p>No compression</p></td>&#13;
<td><p>16.7 ± 0.2 ms</p></td>&#13;
<td><p>14.4 ± 0.2 ms</p></td>&#13;
<td><p>754,227 bytes</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Compression/decompression</p></td>&#13;
<td><p>43.6 ± 0.2 ms</p></td>&#13;
<td><p>18.7 ± 0.5 ms</p></td>&#13;
<td><p>231,844 bytes</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Compression only</p></td>&#13;
<td><p>43.6 ± 0.2 ms</p></td>&#13;
<td><p>.720 ± 0.3 ms</p></td>&#13;
<td><p>231,844 bytes</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>The most interesting point about this table is the last row. In that&#13;
test, the data&#13;
is compressed before sending, but the&#13;
<code class="keep-together">unzipPrices()</code>&#13;
method isn’t called&#13;
in the&#13;
<code class="keep-together">readObject()</code>&#13;
method. Instead, it is called when needed, which will be&#13;
the first time the receiver calls the&#13;
<code class="keep-together">getPrice()</code>&#13;
method. Absent that call, there are only a few&#13;
<code class="keep-together">BigDecimal</code>&#13;
objects to deserialize, which is quite fast.</p>&#13;
&#13;
<p>In this&#13;
example, the receiver might never need the actual prices: the receiver may&#13;
 need only to&#13;
call the&#13;
<code class="keep-together">getHighPrice()</code>&#13;
and similar methods to retrieve aggregate information&#13;
about the data. As long as those methods are all that is needed,&#13;
a lot of time can be saved by lazily decompressing the&#13;
<code class="keep-together">prices</code>&#13;
information.&#13;
This lazy decompression is also useful if the object in question is&#13;
being persisted (e.g., if it is HTTP session state that is being stored&#13;
as a backup copy in case the application server fails). Lazily decompressing&#13;
the data saves both CPU time (from skipping the decompression) and memory&#13;
(since the compressed data takes up less space).</p>&#13;
&#13;
<p>Hence—particularly if the goal is to save memory rather than time—compressing data for serialization and then lazily decompressing it can be&#13;
 useful.</p>&#13;
&#13;
<p>If the point of the serialization is to transfer data over the&#13;
network, we have the usual trade-offs based on the network speed.&#13;
On a fast network, the time for compression can easily be&#13;
longer than the time saved while transmitting less data; on slower networks,&#13;
the opposite might be true. In this case, we are transferring roughly&#13;
500,000 fewer bytes, so we can calculate the penalty or savings based on the&#13;
average time to transfer that much data. In this example, we will spend about&#13;
40 milliseconds to compress the data, which will mean we have to transmit&#13;
about 500,000 fewer bytes. A network with 100 Mbit/second would break even&#13;
in that case, meaning that slow public WiFi would benefit with the compression&#13;
enabled, but faster networks would not.<a data-startref="ix_ch12-asciidoc43" data-type="indexterm" id="idm45775540483736"/><a data-startref="ix_ch12-asciidoc42" data-type="indexterm" id="idm45775540483032"/><a data-startref="ix_ch12-asciidoc41" data-type="indexterm" id="idm45775540482360"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Keeping Track of Duplicate Objects" data-type="sect2"><div class="sect2" id="idm45775540874600">&#13;
<h2>Keeping Track of Duplicate Objects</h2>&#13;
&#13;
<p><a data-primary="duplicate objects" data-type="indexterm" id="ix_ch12-asciidoc44"/><a data-primary="object serialization" data-secondary="keeping track of duplicate objects" data-type="indexterm" id="ix_ch12-asciidoc45"/><a data-primary="objects" data-secondary="keeping track of duplicate objects" data-type="indexterm" id="ix_ch12-asciidoc46"/><a data-type="xref" href="#Object_Serialization">“Object Serialization”</a> began with an example of how not to serialize data that&#13;
contains object references, lest the object references be compromised when&#13;
the data is deserialized.&#13;
However, one of the more powerful optimizations&#13;
possible in the&#13;
<code class="keep-together">writeObject()</code>&#13;
method is to not write out duplicate object&#13;
references. In the case of the&#13;
<code class="keep-together">StockPriceHistoryImpl</code>&#13;
class, that means not writing&#13;
out the duplicate references of the&#13;
<code class="keep-together">prices</code>&#13;
map. Because the example uses a&#13;
standard JDK class for that map, we don’t have to worry about that:&#13;
the JDK classes&#13;
are already written to optimally serialize their data. Still, it is&#13;
instructive to look at how those classes perform their optimizations&#13;
in order to understand what is possible.</p>&#13;
&#13;
<p>In the&#13;
<code class="keep-together">StockPriceHistoryImpl</code>&#13;
class, the key structure is a&#13;
<code class="keep-together">TreeMap</code>.&#13;
A simplified version of that map appears in <a data-type="xref" href="#FigureTreeMap">Figure 12-2</a>. With default&#13;
serialization, the JVM would write out the primitive data fields for node A;&#13;
then it would recursively call the&#13;
<code class="keep-together">writeObject()</code>&#13;
method for node B (and then&#13;
for node C). The code for node B would write out its primitive data fields&#13;
and then recursively write out the data for its&#13;
<code class="keep-together">parent</code>&#13;
field.</p>&#13;
&#13;
<figure><div class="figure" id="FigureTreeMap">&#13;
<img alt="Tree Map Structure" src="assets/jp2e_1202.png"/>&#13;
<h6><span class="label">Figure 12-2. </span>Simple <code>TreeMap</code> structure</h6>&#13;
</div></figure>&#13;
&#13;
<p>But wait a&#13;
minute—that&#13;
<code class="keep-together">parent</code>&#13;
field is node A, which has already been written. The object&#13;
serialization code is smart enough to realize that: it doesn’t rewrite the&#13;
data for node A. Instead, it simply adds an object reference&#13;
to the previously written data.</p>&#13;
&#13;
<p>Keeping track of that set of previously written objects, as well as all that&#13;
recursion, adds a small performance hit to object serialization. However,&#13;
as demonstrated in the example with an array of&#13;
<code class="keep-together">Point</code>&#13;
objects, it can’t&#13;
be avoided: code must keep&#13;
track of the previously written objects and reconstitute the correct&#13;
object references. However, it is possible to perform smart&#13;
optimizations by suppressing object references that&#13;
can be easily re-created when the object is deserialized.</p>&#13;
&#13;
<p>Different collection classes handle this differently. The&#13;
<code class="keep-together">TreeMap</code>&#13;
class,&#13;
for example, simply iterates through the tree and writes only the keys&#13;
and values; serialization discards all information about the relationship&#13;
between the keys (i.e., their sort order). When the data has been&#13;
deserialized, the&#13;
<code class="keep-together">readObject()</code>&#13;
method then re-sorts the data to produce a tree. Although sorting the&#13;
objects again sounds like&#13;
it would be expensive, it is not: that process is about 20% faster on a&#13;
set of 10,000 stock objects than&#13;
using the default object serialization, which chases all the object&#13;
references.</p>&#13;
&#13;
<p>The&#13;
<code class="keep-together">TreeMap</code>&#13;
class also benefits from this optimization because it can&#13;
write out fewer objects. A node (or in JDK language, an&#13;
<span class="keep-together"><code>Entry</code>)</span>&#13;
within a map&#13;
contains two objects: the&#13;
key and the value. Because the map cannot contain two identical nodes,&#13;
the serialization code doesn’t need to worry about preserving object&#13;
references to nodes. In this case, it can skip writing the node object itself&#13;
and simply write the key and value objects directly. So the&#13;
<code class="keep-together">writeObject()</code>&#13;
method ends up looking something like this (syntax adapted&#13;
for ease of reading):</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">private</code> <code class="kt">void</code> <code class="nf">writeObject</code><code class="o">(</code><code class="n">ObjectOutputStream</code> <code class="n">oos</code><code class="o">)</code> <code class="kd">throws</code> <code class="n">IOException</code> <code class="o">{</code>&#13;
    <code class="o">....</code>&#13;
    <code class="k">for</code> <code class="o">(</code><code class="n">Map</code><code class="o">.</code><code class="na">Entry</code><code class="o">&lt;</code><code class="n">K</code><code class="o">,</code><code class="n">V</code><code class="o">&gt;</code> <code class="n">e</code> <code class="o">:</code> <code class="n">entrySet</code><code class="o">())</code> <code class="o">{</code>&#13;
        <code class="n">oos</code><code class="o">.</code><code class="na">writeObject</code><code class="o">(</code><code class="n">e</code><code class="o">.</code><code class="na">getKey</code><code class="o">());</code>&#13;
        <code class="n">oos</code><code class="o">.</code><code class="na">writeObject</code><code class="o">(</code><code class="n">e</code><code class="o">.</code><code class="na">getValue</code><code class="o">());</code>&#13;
    <code class="o">}</code>&#13;
    <code class="o">....</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p>This looks very much like the code that didn’t work for the&#13;
<code class="keep-together">Point</code>&#13;
example.&#13;
The difference&#13;
in this case is that the code still writes out object when those objects&#13;
can be the same.&#13;
A&#13;
<code class="keep-together">TreeMap</code>&#13;
cannot have two nodes that are the same, so there is no need to write out&#13;
node references. The&#13;
<code class="keep-together">TreeMap</code>&#13;
<em>can</em> have two values that are the same, so the values must be written out&#13;
as object references.</p>&#13;
&#13;
<p>This brings us full circle: as I stated&#13;
at the beginning of this section, getting object serialization optimizations&#13;
correct can be tricky. But when object serialization is a <span class="keep-together">significant</span>&#13;
bottleneck in an application, optimizing it correctly can offer&#13;
important <span class="keep-together">benefits</span>.<a data-startref="ix_ch12-asciidoc46" data-type="indexterm" id="idm45775540409448"/><a data-startref="ix_ch12-asciidoc45" data-type="indexterm" id="idm45775540408712"/><a data-startref="ix_ch12-asciidoc44" data-type="indexterm" id="idm45775540408040"/></p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45775540407240">&#13;
<h5>What About Externalizable?</h5>&#13;
<p><a data-primary="Externalizable interface" data-type="indexterm" id="idm45775540406104"/>Another approach to optimizing&#13;
object serialization&#13;
is to implement the&#13;
<code class="keep-together">Externalizable</code>&#13;
interface rather than the&#13;
<code class="keep-together">Serializable</code>&#13;
interface.</p>&#13;
&#13;
<p>The practical difference between these two interfaces is in the way they handle&#13;
nontransient fields. The&#13;
<code class="keep-together">Serializable</code>&#13;
interface writes out nontransient fields&#13;
when the&#13;
<code class="keep-together">writeObject()</code>&#13;
method calls&#13;
the&#13;
<code class="keep-together">defaultWriteObject()</code>&#13;
method. The&#13;
<code class="keep-together">Externalizable</code>&#13;
interface has no such method. An&#13;
<code class="keep-together">Externalizable</code>&#13;
class&#13;
must explicitly write out all fields, transient or not, that it is interested in transmitting.</p>&#13;
&#13;
<p>Even if all the fields in an object are transient, it is better&#13;
to implement the&#13;
<code class="keep-together">Serializable</code>&#13;
interface and call the&#13;
<code class="keep-together">defaultWriteObject()</code>&#13;
method. That path leads to code that is much easier&#13;
to maintain as fields are added to (and deleted from) the code. And&#13;
there is no inherent benefit to the&#13;
<code class="keep-together">Externalizable</code>&#13;
interface from a&#13;
performance point of view: in the end, what matters is the amount of&#13;
data that is <span class="keep-together">written.</span></p>&#13;
</div></aside>&#13;
<div data-type="tip"><h1>Quick Summary</h1>&#13;
<ul>&#13;
<li>&#13;
<p>Serialization of data can be a big performance bottleneck.</p>&#13;
</li>&#13;
<li>&#13;
<p>Marking instance variables <code>transient</code> will make serialization faster and reduce the amount of data to be transmitted. Both are usually big performance wins, unless re-creating the data on the receiver takes a long time.</p>&#13;
</li>&#13;
<li>&#13;
<p>Other optimizations via the <code>writeObject()</code> and <code>readObject()</code> methods can significantly speed up serialization. Approach them with caution, since it is easy to make a mistake and introduce a subtle bug.</p>&#13;
</li>&#13;
<li>&#13;
<p>Compressing serialized data is often beneficial, even if the data will not travel across a slow network.<a data-startref="ix_ch12-asciidoc39" data-type="indexterm" id="idm45775540389832"/><a data-startref="ix_ch12-asciidoc38" data-type="indexterm" id="idm45775540389128"/><a data-startref="ix_ch12-asciidoc37" data-type="indexterm" id="idm45775540388456"/></p>&#13;
</li>&#13;
</ul>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="idm45775540481096">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>This look into key areas of the Java SE JDK concludes&#13;
our examination of Java performance. One interesting theme of most of&#13;
the topics of this chapter is that they show the evolution of the&#13;
performance of the JDK itself. As Java developed and matured as a platform,&#13;
its developers discovered that repeatedly generated exceptions didn’t need&#13;
to spend time providing thread stacks; that using a thread-local variable to&#13;
avoid synchronization of the random number generator was a good thing; that&#13;
the default size of a&#13;
<code class="keep-together">ConcurrentHashMap</code>&#13;
was too large; and so on.</p>&#13;
&#13;
<p>This continual process of successive improvement is what Java performance&#13;
tuning is all about. From tuning the compiler and garbage collector, to&#13;
using memory effectively, to understanding key performance differences in the&#13;
APIs, and more, the tools and processes in this book will allow you to&#13;
provide similar ongoing improvements in your own code.<a data-startref="ix_ch12-asciidoc0" data-type="indexterm" id="idm45775540384104"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<div data-type="footnotes"><p data-type="footnote" id="idm45775544045928"><sup><a href="ch12.html#idm45775544045928-marker">1</a></sup> <em>Chacun à son goût</em> is (with apologies to Johann Strauss Jr.) the opera-lover’s way of saying <em>YMMV</em> (your mileage may vary).</p><p data-type="footnote" id="idm45775543079160"><sup><a href="ch12.html#idm45775543079160-marker">2</a></sup> Because of a bug in earlier versions of Java, it is sometimes recommended to set this flag to <em>/dev/./urandom</em> or other variations. In Java 8 and later JVMs, you can simply use <em>/dev/urandom</em>.</p><p data-type="footnote" id="idm45775542437672"><sup><a href="ch12.html#idm45775542437672-marker">3</a></sup> Or should I say: <em>Chacun à son goût</em>.</p><p data-type="footnote" id="idm45775542298712"><sup><a href="ch12.html#idm45775542298712-marker">4</a></sup> Implementations of quicksort will usually use insertion sort for small arrays anyway; in the case of Java, the implementation of the <code>Arrays.sort()</code> method assumes that any array with fewer than 47 elements will be sorted faster with insertion sort than with quicksort.</p></div></div></section></body></html>