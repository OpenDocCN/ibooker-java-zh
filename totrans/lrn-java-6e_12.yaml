- en: Chapter 12\. Desktop Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java leapt to fame and glory on the power of applets—amazing, *interactive*
    elements on a web page. Sounds mundane these days, but at the time it was nothing
    short of a marvel. Java also had cross-platform support up its sleeve and could
    run the same code on Windows, Unix, and macOS systems. The early JDKs had a rudimentary
    set of graphical components collectively known as the Abstract Window Toolkit
    (AWT). The “abstract” in AWT comes from the use of common classes (`Button`, `Window`,
    etc.) with native implementations. You write AWT applications with abstract, cross-platform
    code; your computer runs your application and provides concrete, native components.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, that nifty combination of abstract and native comes with some
    pretty serious limitations. In the abstract realm, you encounter “lowest common
    denominator” designs that only give you access to features available on every
    platform supported by the JDK. In the native implementations, even some features
    roughly available everywhere were distinctly different when actually rendered
    on the screen. Many desktop developers working with Java in those early days joked
    that the “write once, run everywhere” tagline was really “write once, debug everywhere.”
    The Java Swing package set out to ameliorate this woeful state. While Swing didn’t
    solve every problem of cross-platform application delivery, it did make serious
    desktop application development possible in Java. You can find many quality open
    source projects and even some commercial applications written in Swing. Indeed,
    the IDE we detail in [Appendix A](app01.html#learnjava6-APP-A), IntelliJ IDEA,
    is a Swing application! It clearly goes toe-to-toe with native IDEs on both performance
    and usability.^([1](ch12.html#id2307))
  prefs: []
  type: TYPE_NORMAL
- en: If you look at the documentation for the `javax.swing`^([2](ch12.html#id2309))
    package, you will see it contains a multitude of classes. You will still need
    some pieces of the original `java.awt` realm as well. There are entire books on
    AWT ([*Java AWT Reference*](https://oreil.ly/ppyCu), Zukowski, O’Reilly) and on
    Swing ([*Java Swing*](https://oreil.ly/bO7g6), Loy, et al., O’Reilly), and even
    on subpackages of the AWT, such as 2D graphics ([*Java 2D Graphics*](https://oreil.ly/o3YxN),
    Knudsen, O’Reilly). In this chapter, we’ll stick to covering some popular components
    like buttons and text fields. We’ll look at how to lay them out in your application
    window and how to interact with them. You may be surprised by how sophisticated
    your application can get with these simple starting topics. If you do more desktop
    development after reading this book, you may also be surprised by how much more
    graphical user interface (GUI, or just UI) content is out there for Java. We want
    to whet your appetite while acknowledging that there are many, *many* more UI
    discussions we must leave for you to discover later. With that said, let the whirlwind
    tour commence!
  prefs: []
  type: TYPE_NORMAL
- en: Buttons and Sliders and Text Fields, Oh My!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So where to begin? We have a bit of a “chicken and the egg” problem: we need
    to discuss the “things” to put on the screen, such as the `JLabel` objects we
    used in [“HelloJava”](ch02.html#learnjava6-CHP-2-SECT-2). But we also need to
    discuss what you put those things into. And *where* you put those things also
    merits discussion, as it’s a nontrivial process. We actually seem to have a chicken,
    egg, and brunch problem. Grab a cup of coffee or a mimosa, and we’ll get started.
    We will cover some popular components (the “things”) first, then their containers,
    and finally the topic of laying out your components in those containers. Once
    you can put a nice set of widgets on the screen, we’ll discuss how to interact
    with them as well as how to handle user interfaces in a multithreaded world.'
  prefs: []
  type: TYPE_NORMAL
- en: Component Hierarchies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we’ve discussed in previous chapters, Java classes are designed and extended
    in a hierarchical fashion. `JComponent` and `JContainer` sit at the top of the
    Swing class hierarchy, as shown in [Figure 12-1](#learnjava6-CHP-12-FIG-1). We
    won’t cover these two classes in much detail, but remember their names. You will
    find several common attributes and methods in these classes as you read the Swing
    documentation. As you advance in your programming endeavors, you’ll likely want
    to build your own component. `JComponent` is a great starting point. We used `JComponent`
    when building our graphical `Hello` `Component` back in [Chapter 2](ch02.html#learnjava6-CHP-2).
  prefs: []
  type: TYPE_NORMAL
- en: '![ljv6 1201](assets/ljv6_1201.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-1\. Partial (very partial) Swing class hierarchy
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We will be covering most of the other classes mentioned in the abridged hierarchy
    above, but you will definitely want to visit the [online documentation](https://oreil.ly/H7KhT)
    to see the many components we had to leave out.
  prefs: []
  type: TYPE_NORMAL
- en: Model View Controller Architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At the base of Swing’s notion of “things” is a design pattern known as Model
    View Controller (MVC). The Swing package authors worked hard to consistently apply
    this pattern so that when you encounter new components, their behavior and usage
    should feel familiar. MVC architecture aims to compartmentalize what you see (the
    view) from the behind-the-scenes state (the model) and from the collection of
    interactions (the controller) that change those parts. This separation of concerns
    allows you to concentrate on getting each piece right. Network traffic can update
    the model behind the scenes. The view can be synchronized at regular intervals
    that feel smooth and responsive to the user. MVC provides a powerful yet manageable
    framework to use when building any desktop application.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we look at our small selection of components, we’ll highlight the model
    and the view elements. We’ll then go into more detail on the controllers in [“Events”](#learnjava6-CHP-12-SECT-3).
    If you find the notion of programming patterns intriguing, [*Design Patterns:
    Elements of Reusable Object-Oriented Software*](https://oreil.ly/gt4Pt) (Addison-Wesley)
    by Gamma, Helm, Johnson, and Vlissides (the renowned Gang of Four) is the classic
    work. For more details on the use of the MVC pattern in Swing specifically, see
    the introductory chapter of [*Java Swing*](https://oreil.ly/ADKQq), by Loy et
    al.'
  prefs: []
  type: TYPE_NORMAL
- en: Labels and Buttons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The simplest UI component is not surprisingly one of the most popular. Labels
    are used all over the place to indicate functionality, display status, and draw
    focus. We used a label for our first graphical application back in [Chapter 2](ch02.html#learnjava6-CHP-2).
    We’ll use many more labels as we continue building more interesting programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `JLabel` component is a versatile tool. Let’s look at some examples of
    how to use `JLabel` and customize its many attributes. We’ll start by revisiting
    our “Hello, Java” program with a few preparatory tweaks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Briefly, the interesting parts are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[![1](assets/1.png)](#co_desktop_applications_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Setting the layout manager for use by the frame.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_desktop_applications_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Setting the action taken when using the operating system’s “close” button (in
    this case, the red dot in the upper-left corner of the window). The action we
    selected here exits the application.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_desktop_applications_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Creating our simple label and adding it to the frame.
  prefs: []
  type: TYPE_NORMAL
- en: You declare and initialize the label, then add it to the frame. That should
    be familiar. What is likely new is our use of a `FlowLayout` instance, which helps
    us produce the screenshot shown in [Figure 12-2](#learnjava6-CHP-12-FIG-2).
  prefs: []
  type: TYPE_NORMAL
- en: '![ljv6 1202](assets/ljv6_1202.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-2\. A single, simple `JLabel`
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We’ll go over layout managers in much more detail in [“Containers and Layouts”](#learnjava6-CHP-12-SECT-2),
    but we need something to get us off the ground that also allows us to add multiple
    components to a single container. The `FlowLayout` class fills a container by
    horizontally centering components at the top, adding from left to right until
    that “row” runs out of room, then continuing on a new row below. This type of
    arrangement won’t be of much use in larger applications, but it is ideal for getting
    several things on the screen quickly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s prove that point by adding a few more labels to the frame. Check out
    the results shown in [Figure 12-3](#learnjava6-CHP-12-FIG-3):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![ljv6 1203](assets/ljv6_1203.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-3\. Several basic `JLabel` objects
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Neat, right? Again, this simple layout is not meant for most types of content
    you find in production applications, but it’s definitely useful as you get started.
    One more point about layouts that we want to make, as you’ll encounter this idea
    later: `FlowLayout` also deals with the size of the labels. That can be hard to
    notice in this example because labels have a transparent background by default.
    If we import the `java.awt.Color` class, we can use that class to help make them
    opaque and give them a specific background color:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If we do the same for all of our labels, we can now see their true sizes and
    the gaps between them in [Figure 12-4](#learnjava6-CHP-12-FIG-4). But if we can
    control the background color of labels, what else can we do? Can we change the
    foreground color? (Yes.) Can we change the font? (Yes.) Can we change the alignment?
    (Yes.) Can we add icons? (Yes.) Can we create self-aware labels that eventually
    build Skynet and bring about the end of humanity? (Maybe, but probably not, and
    certainly not easily. Just as well.) [Figure 12-5](#learnjava6-CHP-12-FIG-5) shows
    some of these possible tweaks.
  prefs: []
  type: TYPE_NORMAL
- en: '![ljv6 1204](assets/ljv6_1204.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-4\. Opaque, colored labels
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '![ljv6 1205](assets/ljv6_1205.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-5\. More labels with fancier options
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'And here is the relevant source code that built this added variety:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We used a few other classes to help out, such as `java.awt.Font` and `javax.swing.ImageIcon`.
    We could review many more options, but we need to look at some other components.
    If you want to play around with these labels and try out more of the options you
    see in the Java documentation, try importing a helper we built for *jshell* and
    playing around.^([3](ch12.html#id2325)) The results of our few lines are shown
    in [Figure 12-6](#learnjava6-CHP-12-FIG-6):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![ljv6 1206](assets/ljv6_1206.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-6\. Using our `Widget` class in *jshell*
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We hope you see how easy it is now to create a label (or other components, such
    as the buttons that we’ll be exploring next) and tweak its parameters interactively.
    This is a great way to familiarize yourself with the building blocks you have
    at your disposal for creating Java desktop applications. If you use our `Widget`
    much, you may find its `reset()` method handy. This method removes all of the
    current components and refreshes the window so you can start over quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Buttons
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The other near-universal component you’ll need for graphical applications is
    the button. The `JButton` class is your go-to button in Swing. (You’ll also find
    other popular button types, such as `JCheckbox` and `JToggleButton`, in the documentation.)
    Creating a button is very similar to creating a label, as shown in [Figure 12-7](#learnjava6-CHP-12-FIG-7).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '![ljv6 1207](assets/ljv6_1207.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-7\. A simple `JButton`
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can control the colors, text and image alignment, font, and so on for buttons
    in much the same way as you do for labels. The difference, of course, is that
    you can click on a button and react to that click in your program, whereas labels
    are mostly static displays. Try running this example and clicking on the button.
    It should change color and feel “pressed,” even though it does not perform any
    other function in our program yet. We want to go through a few more components
    before tackling that notion of “reacting” to a button click (an “event” in Swing-speak),
    but you can jump to [“Events”](#learnjava6-CHP-12-SECT-3) if you can’t wait!
  prefs: []
  type: TYPE_NORMAL
- en: Text Components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It would be impossible to imagine a desktop or web application today without
    the text input fields. These input elements allow for free-form entry of information
    and are nearly ubiquitous in online forms. You can grab names, email addresses,
    phone numbers, and credit card numbers. You can do all that in languages that
    compose their characters, or others that read from right to left. Swing has three
    big text components: `JTextField`, `JTextArea`, and `JTextPane`; all extended
    from a common parent, `JTextComponent`. `JTextField` is a classic text field meant
    for brief, single-word or single-line input. `JTextArea` allows for much more
    input spread across multiple lines. `JTextPane` is a specialized component meant
    for editing rich text.'
  prefs: []
  type: TYPE_NORMAL
- en: Text fields
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s get an example of text input running in our simple, flowing application.
    We’ll pare things back to two labels and corresponding text fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Notice in [Figure 12-8](#learnjava6-CHP-12-FIG-8) that the size of a text field
    is dictated by the number of columns we specify in its constructor. That’s not
    the only way to initialize a text field, but it is useful when there are no other
    layout mechanisms dictating the width of the field. (Here, the `FlowLayout` failed
    us a bit—the `“Email:”` label did not stay on the same line as the email text
    field. We’ll fix that soon as we learn more about layouts.) Go ahead and type
    something! You can enter and delete text; highlight stuff inside the field with
    your mouse; and cut, copy, and paste as you’d expect.
  prefs: []
  type: TYPE_NORMAL
- en: '![ljv6 1208](assets/ljv6_1208.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-8\. Simple labels and `JTextField`s
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you add a text field to our demo app in *jshell*, as shown in [Figure 12-9](#learnjava6-CHP-12-FIG-9),
    you can call its `getText()` method to see that the content is indeed available
    to you.
  prefs: []
  type: TYPE_NORMAL
- en: '![ljv6 1209](assets/ljv6_1209.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-9\. Retrieving the contents of a `JTextField`
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `text` property is read-write. You can call `setText()` on your
    text field to change its content programmatically. This can be great for setting
    default values, auto-formatting things like phone numbers, or prefilling a form
    from information you gather over the network. Try it out in *jshell*.
  prefs: []
  type: TYPE_NORMAL
- en: Text areas
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you need room for more than simple words or even long URL entries, you’ll
    likely turn to `JTextArea` to give the user multiple lines of input space. You
    can create an empty text area with a constructor similar to `JTextField`. For
    `JTextArea`, you specify the number of rows in addition to the number of columns.
    Take a look at the code to add a text area to our text input demo app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The results are shown in [Figure 12-10](#learnjava6-CHP-12-FIG-10). You can
    see we have room for multiple lines of text. Go ahead and run this new version
    and try it yourself. What happens if you type past the end of a line? What happens
    when you press the Return key? Do you get the behaviors you’re familiar with?
    You still have access to its content just like you do with a text field.
  prefs: []
  type: TYPE_NORMAL
- en: '![ljv6 1210](assets/ljv6_1210.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-10\. Adding a `JTextArea`
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Let’s add a text area to our widget in *jshell* so that we can play with its
    properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Great! We can see that the Return key we typed to produce our three lines in
    [Figure 12-11](#learnjava6-CHP-12-FIG-11) gets encoded as the `\n` character in
    the string we retrieve.
  prefs: []
  type: TYPE_NORMAL
- en: '![ljv6 1211](assets/ljv6_1211.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-11\. Retrieving the contents of a `JTextArea`
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: But what happens if you try to type a long, run-on sentence that runs past the
    end of the line? You may get an odd text area that expanded to the size of your
    window and beyond, as shown in [Figure 12-12](#learnjava6-CHP-12-FIG-12).
  prefs: []
  type: TYPE_NORMAL
- en: '![ljv6 1212](assets/ljv6_1212.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-12\. An overly long line in a simple `JTextArea`
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We can fix that incorrect sizing behavior by looking at a pair of properties
    of `JText``Area`, shown in [Table 12-1](#learnjava6-CHP-12-TABLE-1).
  prefs: []
  type: TYPE_NORMAL
- en: Table 12-1\. Wrap properties of `JTextArea`
  prefs: []
  type: TYPE_NORMAL
- en: '| Property | Default | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `lineWrap` | `false` | Whether lines longer than the table should wrap at
    all |'
  prefs: []
  type: TYPE_TB
- en: '| `wrapStyleWord` | `false` | If lines do wrap, whether the line breaks should
    be on word or character boundaries |'
  prefs: []
  type: TYPE_TB
- en: So let’s start fresh and turn on the word wrap. We can use `setLineWrap(true)`
    to make sure the text wraps. But that’s probably not enough. We’ll add a call
    to `setWrapStyleWord(true)` to make sure the text area doesn’t just break words
    in the middle. That should look similar to [Figure 12-13](#learnjava6-CHP-12-FIG-13).
  prefs: []
  type: TYPE_NORMAL
- en: '![ljv6 1213](assets/ljv6_1213.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-13\. A wrapping line in a simple `JTextArea`
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can try that yourself in *jshell* or in your own app. When you retrieve
    the text from the `bodyArea` object, you should *not* see a line break (`\n`)
    in line three between the second “on” and the “but.”
  prefs: []
  type: TYPE_NORMAL
- en: Text scrolling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What happens if we have too many rows? On its own, `JTextArea` does that odd
    “grow until it can’t” trick, as shown in [Figure 12-14](#learnjava6-CHP-12-FIG-14).
  prefs: []
  type: TYPE_NORMAL
- en: '![ljv6 1214](assets/ljv6_1214.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-14\. Too many lines in a simple `JTextArea`
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'To fix this problem, we need to call in some support from a standard Swing
    helper component: `JScrollPane`. This is a general-purpose container that makes
    it easy to present large components in confined spaces. To show you just how easy
    this is, let’s fix our text area:^([4](ch12.html#id2349))'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see in [Figure 12-15](#learnjava6-CHP-12-FIG-15) that the text area
    no longer grows beyond the bounds of the frame. You can also see the standard
    scroll bars along the side and bottom. If you just need simple scrolling, you’re
    done! But like most other components in Swing, `JScrollPane` has many fine details
    you can adjust as needed. We won’t cover most of those here, but we do want to
    show you how to tackle a common setup for text areas: line wrapping (breaking
    on words) with vertical scrolling—meaning no horizontal scrolling.'
  prefs: []
  type: TYPE_NORMAL
- en: '![ljv6 1215](assets/ljv6_1215.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-15\. Too many lines in a `JTextArea` embedded in a `JScrollPane`
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: You should end up with a text area like the one shown in [Figure 12-16](#learnjava6-CHP-12-FIG-16).
  prefs: []
  type: TYPE_NORMAL
- en: '![ljv6 1216](assets/ljv6_1216.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-16\. A well-formed `JTextArea` in a `JScrollPane`
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Hooray! You now have a taste of the most common Swing components, including
    labels, buttons, and text fields. But we really have just scratched the surface
    of these components. Look over the Java documentation and play around with each
    of these components in *jshell* or in your own mini applications.
  prefs: []
  type: TYPE_NORMAL
- en: Getting comfortable with UI design takes practice. We encourage you to look
    up other books and online resources if you will be building desktop applications,
    but nothing beats time spent at the keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: Other Components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you’ve already looked at the documentation on the `javax.swing` package,
    you know several dozen other components are available. Within that large list,
    there are a few that we want to highlight.^([5](ch12.html#id2356))
  prefs: []
  type: TYPE_NORMAL
- en: JSlider
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sliders are a nifty, efficient input component when you want the user to choose
    from a range of values: for instance, things like font size selectors, color pickers,
    and zoom selectors. Sliders are perfect for the angle and force values we need
    in our apple tossing game. Our angles range from 0 to 180, and our force value
    ranges from 0 to 20 (an arbitrary maximum). [Figure 12-17](#learnjava6-CHP-12-FIG-17)
    shows these sliders in place (ignore how we achieved the layout for now).'
  prefs: []
  type: TYPE_NORMAL
- en: '![ljv6 1217](assets/ljv6_1217.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-17\. Using `JSlider` in our apple tossing game
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'To create a new slider, you provide three values: the minimum (`0` for our
    angle slider), the maximum (`180`), and the initial value (start in the middle
    for the game at `90`). You can add such a slider to our *jshell* playground like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Scoot the slider around like you see in [Figure 12-18](#learnjava6-CHP-12-FIG-18),
    then look at its current value using the `getValue()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '![ljv6 1218](assets/ljv6_1218.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-18\. A simple `JSlider` in *jshell*
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In [“Events”](#learnjava6-CHP-12-SECT-3), we’ll see how to receive those values
    in real time as the user changes them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `JSlider` constructors use integers for the minimum and maximum values,
    and `getValue()` returns an integer. If you need fractional values, that falls
    to you. The force slider in our game, for example, would benefit from supporting
    more than 21 discrete levels. We can address that by building the slider with
    a larger range of integers, then dividing the current value by an appropriate
    scale factor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: JList
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you have a discrete set of values but those values are not a simple, contiguous
    range of numbers, the “list” UI element is a great choice. `JList` is the Swing
    implementation of this input type. You can set it to allow single or multiple
    selections, and if you dig deeper into Swing’s features, you can produce custom
    views that display the items in your list with extra information or details. (For
    example, you can make lists of icons, or icons and text, or multiline text, and
    so on.)
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the other components we’ve seen so far, `JList` requires a little more
    information to get started. To make a useful list component, you need to use one
    of the constructors that takes the data you intend to show. The simplest such
    constructor accepts an `Object` array. While you can pass an array of objects
    of any type, the default behavior of `JList` will be to show the output of your
    objects’ `toString()` method in the list. Using an array of `String` objects is
    very common and produces the expected results. [Figure 12-19](#learnjava6-CHP-12-FIG-19)
    shows a simple list of cities.
  prefs: []
  type: TYPE_NORMAL
- en: '![ljv6 1219](assets/ljv6_1219.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-19\. A simple `JList` of four cities in *jshell*
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We use the same `<String>` type information with the constructor as we do when
    creating parameterized collection objects, such as `ArrayList` (see [“Type Limitations”](ch07.html#learnjava6-CHP-7-SECT-2)).
    As Swing was added well before generics, you may encounter examples online or
    in books that do not add the type information. Omitting it doesn’t stop your code
    from compiling or running, but you will receive the same `unchecked` warning message
    at compile time that you saw with the collection classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to getting the current value of a slider, you can retrieve the selected
    item or items in a list at any time using one of four methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`getSelectedIndex()`'
  prefs: []
  type: TYPE_NORMAL
- en: For single-select lists, returns an `int`
  prefs: []
  type: TYPE_NORMAL
- en: '`getSelectedIndices()`'
  prefs: []
  type: TYPE_NORMAL
- en: For multiselect lists, returns an array of `int`
  prefs: []
  type: TYPE_NORMAL
- en: '`getSelectedValue()`'
  prefs: []
  type: TYPE_NORMAL
- en: For single-select lists, returns an object
  prefs: []
  type: TYPE_NORMAL
- en: '`getSelectedValues()`'
  prefs: []
  type: TYPE_NORMAL
- en: For multiselect lists, returns an array of objects
  prefs: []
  type: TYPE_NORMAL
- en: 'The main difference is whether the index of the selected item(s) or the actual
    value(s) is more useful to you. Playing with our city list in *jshell*, we can
    pull out a selected city like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: For large lists, you’ll probably want a scroll bar. Swing promotes reusability
    in its code, so you can use a `JScrollPane` with `JList` just like we did for
    text areas.
  prefs: []
  type: TYPE_NORMAL
- en: Containers and Layouts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: That formidable list of components is only a subset of the widgets available.
    In this section, you’ll be laying out the components we’ve discussed into useful
    arrangements. Those arrangements happen inside a *container*, which is Java’s
    term for a component that can have (or “contain”) other components. Let’s start
    by looking at the most common containers.
  prefs: []
  type: TYPE_NORMAL
- en: Frames and Windows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every desktop application needs at least one window. This term predates Swing
    and is used by most graphical interfaces available on the three big operating
    systems—including Windows (no relation). Swing does provide a low-level `JWindow`
    class if you need it, but most likely you will build your application inside a
    `JFrame`. [Figure 12-20](#learnjava6-CHP-12-FIG-20) illustrates the class hierarchy
    of `JFrame`. We will stick to its basic features, but as your applications become
    richer, you may want to create customized windows using elements higher up in
    the hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: '![ljv6 1220](assets/ljv6_1220.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-20\. The `JFrame` class hierarchy
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Let’s revisit the creation of that first graphical application from [Chapter 2](ch02.html#learnjava6-CHP-2)
    and focus a bit more on the `JFrame` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The string we pass to the `JFrame` constructor becomes the title of the window.
    We then set a few specific properties on our object. We make sure that when the
    user closes the window, we quit our program. (That might seem obvious, but complex
    applications might have multiple windows, such as tool palettes or support for
    multiple documents. Closing one window in these applications may not mean “quit.”)
  prefs: []
  type: TYPE_NORMAL
- en: We then pick a starting size for the window and add our actual label component
    to the frame (which in turn places the label in its *content pane*, more on that
    in a minute). Once the component is added, we make the window visible, and the
    result is [Figure 12-21](#learnjava6-CHP-12-FIG-21).
  prefs: []
  type: TYPE_NORMAL
- en: '![ljv6 1221](assets/ljv6_1221.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-21\. A simple `JFrame` with an added label
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This basic process is the foundation of every Swing application. The interesting
    part of your application comes from what you do with that content pane.
  prefs: []
  type: TYPE_NORMAL
- en: But what *is* that content pane? The frame uses its own set of containers that
    hold various parts of typical applications. You can set your own content pane
    to be any object descended from `java.awt.Container`, but we’ll be sticking with
    the default for now.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are also using a shortcut to add our label. The `JFrame` version of `add()`
    will delegate to the content pane’s `add()`. The following snippet shows how to
    add the label without the shortcut:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `JFrame` class does not have shortcuts for everything, however. Read the
    documentation and use a shortcut if it exists. If not, don’t hesitate to grab
    a reference via `getContentPane()` and then configure or tweak that container
    as needed.
  prefs: []
  type: TYPE_NORMAL
- en: JPanel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The default content pane is a `JPanel`, the go-to container in Swing. It is
    a component just like `JButton` or `JLabel`, so your panels can contain other
    panels. Such nesting often plays a big role in application layout. For example,
    you could create a `JPanel` to house the formatting buttons of a text editor in
    a “toolbar,” then add that toolbar to the content pane. This arrangement makes
    it easy for users to show, hide, or move it around.
  prefs: []
  type: TYPE_NORMAL
- en: '`JPanel` lets you add and remove components from the screen. (The methods are
    inherited from the `Container` class, but we access them through our `JPanel`
    objects.) You can also `repaint()` a panel if something has changed and you want
    to update your UI.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see the effects of the `add()` and `remove()` methods shown in [Figure 12-22](#learnjava6-CHP-12-FIG-22)
    using our playground widget in *jshell*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Try it yourself! Most applications don’t add and remove components willy-nilly.
    You’ll usually build your interface by adding what you need and then leave it
    alone. You might enable or disable some buttons along the way, but try not to
    surprise the user with disappearing parts or new elements popping up.
  prefs: []
  type: TYPE_NORMAL
- en: '![ljv6 1222](assets/ljv6_1222.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-22\. Adding and removing components in a `JPanel`
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Layout Managers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Containers like `JPanel` are responsible for laying out the components you add.
    Java provides several *layout managers* to help you achieve your desired results.
  prefs: []
  type: TYPE_NORMAL
- en: BorderLayout
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You’ve already seen the `FlowLayout` in action. You were using another layout
    manager without really knowing it: the content pane of a `JFrame` uses `BorderLayout`
    by default. [Figure 12-23](#learnjava6-CHP-12-FIG-23) shows the five areas controlled
    by `BorderLayout`, along with their regions. Notice that the `NORTH` and `SOUTH`
    regions are as wide as the application window but only as tall as required to
    fit the label. Similarly, the `EAST` and `WEST` regions fill the vertical gap
    between the `NORTH` and `SOUTH` regions but are only as wide as required, leaving
    the remaining space to be filled both horizontally and vertically by the `CENTER`
    region:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '![ljv6 1223](assets/ljv6_1223.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-23\. The regions available with `BorderLayout`
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `add()` method in this case takes an extra argument and passes it to the
    layout manager. (Not all managers need this argument, as you saw with `FlowLayout`.)
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 12-24](#learnjava6-CHP-12-FIG-24) shows an example of nesting `JPanel`
    objects within an application. We use a text area for a large message in the center
    and then add some action buttons to a panel along the bottom. Again, without the
    events we’ll cover in the next section, none of these buttons do anything, but
    we want to show you how to work with multiple containers. And you could continue
    nesting `JPanel` objects if you wanted.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes a better top-level layout choice makes your app both more maintainable
    and more performant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '![ljv6 1224](assets/ljv6_1224.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-24\. A simple nested container example
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Two things to note in this example. First, you might see that we did not specify
    the number of rows or columns when creating our `JTextArea` object. Unlike `FlowLayout`,
    `BorderLayout` will set the size of its components when possible. For the top
    and bottom, this means using the component’s own height, similar to how `FlowLayout`
    works, but then setting the width of the component to fill the frame. The sides
    use their components’ width, but the layout manager sets the height. `BorderLayout`
    sets both the width and height of the component in the center.
  prefs: []
  type: TYPE_NORMAL
- en: Second, when we add the `messageArea` and `buttonPanel` objects to the `frame`,
    we specify the extra “where” argument to the frame’s `add()` method. However,
    when we are adding the buttons themselves to `buttonPanel`, we use the simpler
    version of `add()` with only the component argument. The container’s layout manager
    dictates which variation of `add()` we need. So even though the `buttonPanel`
    is in the `SOUTH` region of the frame using `BorderLayout`, the `saveButton` and
    its compatriots are in an enclosing container of their own and don’t know or care
    about what is happening outside that container.
  prefs: []
  type: TYPE_NORMAL
- en: GridLayout
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Many times you need (or want) your components or labels to occupy symmetric
    spaces. Think of the Yes, No, and Cancel buttons along the bottom of a confirmation
    dialog. (Swing can make those dialogs, too; more on that in [“Modals and Pop-Ups”](#learnjava6-CHP-12-SECT-5.2).)
    The `GridLayout` class can help with such even spacing. Let’s try using `GridLayout`
    for those buttons in our previous example. All we have to do is change one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The calls to `add()` remain exactly the same; no separate constraint argument
    is needed.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in [Figure 12-25](#learnjava6-CHP-12-FIG-25), the `GridLayout`
    buttons are the same size, even though the text of the Cancel button is a bit
    longer than the others.
  prefs: []
  type: TYPE_NORMAL
- en: '![ljv6 1225](assets/ljv6_1225.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-25\. Using `GridLayout` for a row of buttons
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In creating the layout manager, we told it we want exactly one row, with no
    restrictions on how many columns `(1, 0)`. Grids can also be two-dimensional with
    multiple rows and columns. [Figure 12-26](#learnjava6-CHP-12-FIG-26) shows the
    classic phone-keypad layout as an example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Adding the buttons in order from left to right, top to bottom, should result
    in the app you see in [Figure 12-26](#learnjava6-CHP-12-FIG-26).
  prefs: []
  type: TYPE_NORMAL
- en: '![ljv6 1226](assets/ljv6_1226.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-26\. A two-dimensional grid layout for a phone pad
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Very handy and very easy if you need perfectly symmetric elements. But what
    if you want a *mostly* symmetric layout? Think of popular web forms with a column
    of labels on the left and a column of text fields on the right. `GridLayout` could
    handle a basic, two-column form like that, but many times your labels are short
    and simple, while your text fields are wider, giving the user more space to type.
    How does Java accommodate those layouts?
  prefs: []
  type: TYPE_NORMAL
- en: GridBagLayout
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you need a more interesting layout but don’t want to nest lots of panels,
    consider `GridBagLayout`. It’s more complex to set up, but it allows for intricate
    layouts that still keep elements aesthetically aligned and sized. Similar to `BorderLayout`,
    you add components with an extra argument. The argument for `GridBagLayout`, however,
    is a rich `GridBagConstraints` object rather than a simple `String`.
  prefs: []
  type: TYPE_NORMAL
- en: The “grid” in `GridBagLayout` is exactly that, a rectangular container divvied
    up into various rows and columns. The “bag” part, though, comes from a grab-bag
    notion of how you use the cells created by those rows and columns. The rows and
    columns can have their own height or width, and components can occupy any rectangular
    collection of cells. We can take advantage of this flexibility to build out our
    game interface with a single `JPanel` rather than with several nested panes. [Figure 12-27](#learnjava6-CHP-12-FIG-27)
    shows one way of carving up the screen into four rows and three columns, and then
    placing the components.
  prefs: []
  type: TYPE_NORMAL
- en: '![ljv6 1227](assets/ljv6_1227.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-27\. An example grid for use with `GridBagLayout`
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can see the different row heights and column widths. Some components occupy
    more than one cell. This type of arrangement won’t work for every application,
    but it is powerful and works for many UIs that need more than simple layouts.
  prefs: []
  type: TYPE_NORMAL
- en: 'To build an application with a `GridBagLayout`, you need to keep a couple of
    references around as you add components. Let’s set up the grid first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This step requires a little planning on your part, but it’s easy to adjust
    once you get a few components on the screen. To add those components, you need
    to create and configure a `GridBagConstraints` object. Fortunately, you can reuse
    the same object for all of your components—you just need to repeat the configuration
    portion before adding each element. Here’s an example of how you could add the
    main playing field component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Notice how we set which cells the field will occupy. We specify the upper-left
    corner of a rectangle by giving the row (`gridy`) and column (`gridx`). Then we
    specify how many rows our field will occupy (`gridheight`) and how many columns
    (`gridwidth`). This is the core of configuring grid bag constraints.
  prefs: []
  type: TYPE_NORMAL
- en: You can also adjust things like how a component will fill the cells it occupies
    (`fill`) and how much of a margin each component gets. We’ve settled on simply
    filling all of the space available in a group of cells (“both” a horizontal fill
    and a vertical fill), but you can read about more options in the [documentation
    for `GridBagConstraints`](https://oreil.ly/XwdXt).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add a scorekeeping label at the top:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'For this second component, do you see how similar the setup of the constraints
    is to how we handled the game field? Any time you see similarities like this,
    consider pulling those similar steps into a function you can reuse:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Then you could rewrite the earlier blocks of code for the score label and game
    field, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'With that function in place, you can quickly add the various other components
    and labels to complete the game interface. For example, the toss button in the
    lower-right corner of [Figure 12-27](#learnjava6-CHP-12-FIG-27) can be set up
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Much cleaner! We simply continue creating our components and placing them on
    the correct row and column, with the appropriate spans. In the end we have a reasonably
    interesting set of components laid out in a single container.
  prefs: []
  type: TYPE_NORMAL
- en: As with other sections in this chapter, we don’t have time to cover every layout
    manager, or even every feature of the layout managers we do discuss. Be sure to
    check the Java documentation and try creating a few dummy apps to play with the
    different layouts. As a starting point, `BoxLayout` is a nice upgrade to the grid
    idea, and `GroupLayout` can produce data-entry forms. For now, though, we’re going
    to move on. Time to get all these components “hooked up” and responding to all
    the typing and clicking and button pushing—actions that are encoded in Java as
    events.
  prefs: []
  type: TYPE_NORMAL
- en: Events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As discussed in [“Model View Controller Architecture”](#learnjava6-CHP-12-SECT-1.2),
    the model and view elements of MVC designs are straightforward. But what about
    the controller aspect? In Swing (and Java more generally), interaction between
    users and components is communicated via events. An *event* contains general information,
    such as when the interaction occurred, as well as information specific to the
    event type, such as the point on your screen where you clicked your mouse, or
    which key you typed on your keyboard. A *listener* (or *handler*) picks up the
    message and can respond in some useful way. Connecting components to listeners
    is what allows users to control your application.
  prefs: []
  type: TYPE_NORMAL
- en: Mouse Events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The easiest way to get started is just to generate and handle an event. Let’s
    follow in the footsteps of our first, quick applications with a `HelloMouse` application
    and focus on handling mouse events. When we click our mouse, we’ll use that click
    event to determine the position of our `JLabel`. (This will require removing the
    layout manager, by the way. We want to set the coordinates of our label manually.)
  prefs: []
  type: TYPE_NORMAL
- en: 'As you look at the source code for this example, pay attention to a few particular
    items, noted with the numbered callouts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_desktop_applications_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: As you click, Java picks up low-level events from your hardware (computer, mouse,
    keyboard) and hands them to an appropriate listener. Listeners are interfaces.
    You can make special classes just to implement the interface, or you can implement
    listeners as part of your main application class, like we did here. Where you
    choose to handle events really depends on what actions you need to take in response
    to them. You’ll see a number of examples of both approaches throughout the rest
    of this book.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_desktop_applications_CO2-3)'
  prefs: []
  type: TYPE_NORMAL
- en: 'We implemented the `MouseListener` interface in addition to extending `JFrame`.
    We had to provide a body for every method listed in `MouseListener`, but we do
    our real work in `mouseClicked()`. This method takes the coordinates of the click
    from the `event` object and uses them to change the position of the label. The
    `MouseEvent` class contains a wealth of information about the event: when it occurred,
    which component it occurred on, which mouse button was involved, the (x,y) coordinate
    where the event occurred, and so on. Try printing some of that information in
    some of the unimplemented methods, such as `mouseDown()`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_desktop_applications_CO2-4)'
  prefs: []
  type: TYPE_NORMAL
- en: We added quite a few methods for other types of mouse events that we didn’t
    use. That’s common with lower-level events, such as mouse and keyboard events.
    The listener interfaces are designed to give you a central collecting point for
    related events. You have to implement every method in the interface, but you can
    respond to the particular events you care about and leave the other methods empty.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_desktop_applications_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The other critical bit of new code is the call to `addMouseListener()` for our
    content pane. The syntax may look a little odd, but it’s a standard approach.
    Using `getContentPane()` says “this is the component generating events,” and using
    `this` as the argument says “this is the class receiving (handling) the events.”
    In this example, the events from the frame’s content pane will be delivered back
    to the same class, which is where we put all of the mouse-handling code.
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and run the application. You’ll get a variation on the familiar “Hello,
    World” graphical application, shown in [Figure 12-28](#learnjava6-CHP-12-FIG-28).
    The friendly message should follow your mouse as you click around.
  prefs: []
  type: TYPE_NORMAL
- en: '![ljv6 1228](assets/ljv6_1228.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-28\. Using a `MouseEvent` to position a label
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Mouse adapters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you want to try the helper-class approach, you could add a separate class
    to the file and implement `MouseListener` in that class. If so, you can take advantage
    of a shortcut Swing provides for many listeners. The `MouseAdapter` class is a
    simple implementation of the `MouseListener` interface, with empty methods written
    for every event. When you `extend` this class, you override only the methods you
    care about. That makes for a clean, concise handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Remember that helper classes need to have a reference to every object they touch.
    We passed our label to the constructor of our adapter. That’s a popular way to
    establish the necessary connections, but you could certainly add the required
    access later—as long as the handler has a reference to every object it needs before
    it starts receiving events.
  prefs: []
  type: TYPE_NORMAL
- en: Action Events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While low-level mouse and keyboard events are available on just about every
    Swing component, they can be a little tedious. Most UI libraries provide higher-level
    events that are simpler to think about. Swing is no exception. The `JButton` class,
    for example, supports an `ActionEvent` that lets you know the button has been
    clicked. Most of the time this is exactly what you want. But the mouse events
    are still available if you need some special behavior, such as reacting to clicks
    from different mouse buttons or distinguishing between a long and a short press
    on a touch screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'A popular way to demonstrate the button click event is to build a simple counter,
    like the one you see in [Figure 12-29](#learnjava6-CHP-12-FIG-29). Each time you
    click the button, the program updates the label. This simple proof of concept
    shows that you can receive and respond to UI events. Let’s see the wiring required
    for this demo:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '![ljv6 1229](assets/ljv6_1229.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-29\. Using `ActionEvent` to increment a counter
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We update a simple counter variable and display the result inside the `actionPerformed()`
    method, which is where `ActionListener` objects receive their events. We used
    the direct listener implementation approach, but we could just as easily have
    created a helper class as we did with the `LabelMover` example in [“Mouse Events”](#learnjava6-CHP-12-SECT-3.1).
  prefs: []
  type: TYPE_NORMAL
- en: Action events are straightforward; they don’t have as many details available
    as mouse events, but they do carry a “command” property. The command in question
    is just an arbitrary string. It doesn’t mean anything to Java, but you can customize
    this property for your own use. For buttons, Java defaults to using the text of
    the button’s label. The `JTextField` class also generates an action event if you
    press the Return key while typing in the text field. In this case, however, the
    text currently in the field is used for the command. [Figure 12-30](#learnjava6-CHP-12-FIG-30)
    shows how to hook up a button and a text field to a label.
  prefs: []
  type: TYPE_NORMAL
- en: '![ljv6 1230](assets/ljv6_1230.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-30\. Using `ActionEvent`s from different sources
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice we used one `ActionListener` object to handle the events for *both*
    the button and the text field. This is a great feature of Swing’s listener approach
    to handling events: any component that generates a given type of event can report
    to any listener that receives that type. Sometimes your event handlers are unique
    and you’ll build a separate handler for each component. But many applications
    offer multiple ways to accomplish the same task. You can often handle those different
    input sources with a single listener. And the less code you have, the less that
    can go wrong!'
  prefs: []
  type: TYPE_NORMAL
- en: Change Events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another event type that appears in several Swing components is `ChangeEvent`.
    This is a simple event that lets you know something has, well, changed. The `JSlider`
    class uses this mechanism to report changes to the position of the slider. The
    `ChangeEvent` class has a reference to the component that changed (the event’s
    *source*) but no details on what might have changed within that component. It’s
    up to you to go ask the component for those details. That listen-then-query process
    might seem tedious, but it does allow for efficient notifications that updates
    are necessary, without creating hundreds of classes with thousands of methods
    to cover all the event variations that might come up.
  prefs: []
  type: TYPE_NORMAL
- en: 'We won’t reproduce the entire application here, but let’s take a look at how
    the `AppleToss` class uses `ChangeListener` to map the aiming slider to our physicist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In this snippet, we use a factory pattern to create our slider and return it
    for use in the `add()` method of our `gamePane` container. We create a simple
    anonymous inner class. Changing our aiming slider has one effect, and there is
    only one way to aim the apple. Since there is no possibility of class reuse, we
    chose an anonymous inner class. There is nothing wrong with creating a complete
    helper class and passing it the `player1` and `field` elements as arguments to
    a constructor or initialization method, but you will find the approach used above
    quite often in the wild.
  prefs: []
  type: TYPE_NORMAL
- en: We want to point out one other option for handling simple events like `ChangeEvent`
    and `ActionEvent`. The listeners for these events have a single abstract method.
    Does that phrase ring a bell? That’s how Oracle describes its functional interfaces.
    So we can use a lambda!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, many listeners handle a spectrum of related events. You can’t
    use a lambda with any listener interface that has more than one method. But lambdas
    work with buttons and menu items, so they can still play a big role in your graphical
    application if you find them appealing.
  prefs: []
  type: TYPE_NORMAL
- en: Our `Widget` isn’t really good for trying event-related code in *jshell*. While
    you certainly can write an anonymous inner class or a multiline lambda at a command
    line, it can be tedious and prone to errors that are not easy to fix from that
    same command line. It’s usually simpler to write small, focused demo apps, like
    many of the examples in this chapter. While we encourage you to fire up the apple
    tossing game to play with the slider shown in the code above, you should also
    try your hand at a few original apps.
  prefs: []
  type: TYPE_NORMAL
- en: Other Events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are dozens of other events and listeners spread across the `java.awt.event`
    and `javax.swing.event` packages. It’s worth peeking at the documentation just
    to get a sense of the other types of events you might run into. [Table 12-2](#learnjava6-CHP-12-TABLE-2)
    shows the events and listeners associated with the components we’ve discussed
    so far in this chapter, as well as a few that are worth checking out as you work
    more with Swing.
  prefs: []
  type: TYPE_NORMAL
- en: Table 12-2\. Swing and AWT events and associated listeners
  prefs: []
  type: TYPE_NORMAL
- en: '| S/A | Event class | Listener interface | Generating components |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| A | `ActionEvent` | `ActionListener` | `JButton`, `JMenuItem`, `JTextField`
    |'
  prefs: []
  type: TYPE_TB
- en: '| S | `ChangeEvent` | `ChangeListener` | `JSlider` |'
  prefs: []
  type: TYPE_TB
- en: '| A | `ItemEvent` | `ItemListener` | `JCheckBox`, `JRadioButton` |'
  prefs: []
  type: TYPE_TB
- en: '| A | `KeyEvent` | `KeyListener` | Descendants of `Component` |'
  prefs: []
  type: TYPE_TB
- en: '| S | `ListSelectionEvent` | `ListSelectionListener` | `JList` |'
  prefs: []
  type: TYPE_TB
- en: '| A | `MouseEvent` | `MouseListener` | Descendants of `Component` |'
  prefs: []
  type: TYPE_TB
- en: '| A | `MouseMotionEvent` | `MouseMotionListener` | Descendants of `Component`
    |'
  prefs: []
  type: TYPE_TB
- en: '| AWT events (A) from `java.awt.event`, Swing events (S) from `javax.swing.event`
    |'
  prefs: []
  type: TYPE_TB
- en: If you’re unsure what events a particular component supports, check its documentation
    for methods that look like `addXYZListener()`. Whatever stands in for `XYZ` is
    a clue about where else in the documentation to look. Recall that our slider uses
    `addChangeListener()`. So that `XYZ` is `Change` in this case. You can infer the
    event name (`ChangeEvent`) and the listener interface (`ChangeListener`) from
    that clue. Once you have the documentation for the listener, try implementing
    every method and simply printing which event is reported. You can learn a lot
    about how the various Swing components react to keyboard and mouse events this
    way.
  prefs: []
  type: TYPE_NORMAL
- en: Threading Considerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have read any of the JDK documentation on Swing as you’ve been working
    through this chapter, you may have come across a warning that Swing components
    are not thread-safe. As you learned in [Chapter 9](ch09.html#learnjava6-CHP-9),
    Java supports multiple threads of execution to take advantage of modern computer
    processing power. Multithreaded applications run the risk of allowing two threads
    to fight over the same resource or update the same variable at the same time but
    with different values. Not knowing if your data is correct can severely decrease
    your ability to debug a program or even just trust its output. For Swing components,
    this warning reminds programmers that their UI elements could be subject to this
    type of corruption.
  prefs: []
  type: TYPE_NORMAL
- en: To help maintain a consistent UI, Swing encourages you to update your components
    on the AWT *event dispatch thread*. This is the thread that naturally handles
    things like button clicks. If you update a component in response to an event (such
    as our counter button and label in [“Action Events”](#learnjava6-CHP-12-SECT-3.2)),
    you are all set. The idea is that if every other thread in your application sends
    UI updates to the sole event dispatch thread, no component can be adversely affected
    by simultaneous, possibly conflicting changes.
  prefs: []
  type: TYPE_NORMAL
- en: A common example of threading in graphical applications is the animated spinner
    that sits on your screen while you wait for a large file to download. But what
    if you get impatient? What if it seems like the download has failed but the spinner
    is still going? If your long-running task is using the event dispatch thread,
    your user won’t be able to click a Cancel button or take any action at all. Long-running
    tasks should be handled by separate threads that can run in the background, leaving
    your application responsive and available. But then how do we update the UI when
    that background thread finishes? Swing has a helper class ready for you.
  prefs: []
  type: TYPE_NORMAL
- en: SwingUtilities and Component Updates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can use the `SwingUtilities` class from any thread to perform updates to
    your UI components in a safe, stable manner. There are two static methods you
    can use to communicate with your UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '`invokeAndWait()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`invokeLater()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As their names imply, the first method runs some UI update code and makes the
    current thread wait for that update to finish before continuing. The second method
    hands off some UI update code to the event dispatch thread and then immediately
    resumes executing on the current thread. (The event dispatch thread is sometimes
    called the *event dispatch queue*. You can append events or updates and the event
    dispatch thread will get to them in roughly the order they were added, like in
    a queue.) Which one you use really depends on whether your background thread needs
    to know the state of the UI before continuing. For example, if you are adding
    a new button to your interface, you might want to use `invokeAndWait()` so that
    by the time your background thread continues, it can be sure that future updates
    will actually have a button to update.
  prefs: []
  type: TYPE_NORMAL
- en: If you aren’t as concerned about when something gets updated, but still want
    it to be handled safely by the dispatch thread, `invokeLater()` is perfect. Think
    about updating a progress bar as a large file is downloading. Your code might
    fire off several updates as more and more of the download completes. You don’t
    need to wait for those graphical updates to finish before resuming your download.
    If a progress update gets delayed or runs very close to a second update, there’s
    no real harm. But you don’t want a busy graphical interface to interrupt your
    download—especially if the server is sensitive to pauses.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll see several examples of this type of network/UI interaction in [Chapter 13](ch13.html#learnjava6-CHP-13),
    but let’s fake some network traffic and update a small label to show off `SwingUtilities`.
    We can set up a Start button that will update a status label with a simple percentage
    display and kick off a background thread that sleeps for one second, then increments
    the progress. Each time the thread wakes up, it will update the label using `invokeLater()`
    to correctly set the label’s text. First, let’s set up our demo:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Most of this should look familiar, but look at how we create our thread. We
    pass a `new ProgressPretender()` as the argument to our `Thread` constructor.
    We could have broken that call into separate parts, but since we do not refer
    directly to our `ProgressPretender` object again, we can stick with this tidier,
    denser approach. We *do* refer to the thread itself, however, so we make a proper
    variable for it. We can then start our thread running in the `ActionListener`
    for our button. We also disable our Start button at that point. We don’t want
    the user trying to (re)start a thread that is already running!
  prefs: []
  type: TYPE_NORMAL
- en: We added a text field for you to type in. While the progress is being updated,
    your application should continue responding to user input like typing. Try it!
    The text field isn’t connected to anything, but you should be able to enter and
    delete text while watching the progress counter slowly climb up, as shown in [Figure 12-31](#learnjava6-CHP-12-FIG-35).
  prefs: []
  type: TYPE_NORMAL
- en: '![ljv6 1231](assets/ljv6_1231.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-31\. Thread-safe updates to a progress label
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'So how did we update that label without locking up the application? Let’s look
    at the `ProgressPretender` class and inspect the `run()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'In this class, we store the label passed to our constructor so we know where
    to display our updated progress. The `run()` method has three basic steps: 1)
    update the label, 2) sleep for 1,000 milliseconds, and 3) increment our progress.'
  prefs: []
  type: TYPE_NORMAL
- en: In step 1, the lambda argument we pass to `invokeLater()` is based on the `Runnable`
    interface in [Chapter 9](ch09.html#learnjava6-CHP-9). We could have used an inner
    class or an anonymous inner class, but for such a simple task, a lambda is perfect.
    The lambda body updates the label with our current progress value. The event dispatch
    thread will execute the lambda. This is the magic that leaves the text field responsive
    even though our “progress” thread is sleeping most of the time.
  prefs: []
  type: TYPE_NORMAL
- en: Step 2 is standard-issue thread sleeping. The `sleep()` method knows it can
    be interrupted, so the compiler will make sure you supply a `try/catch` block
    like we’ve done above. There are many ways to handle the interruption, but in
    this case we chose to simply `break` out of the loop.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we increment our progress counter and start the whole process over.
    Once we hit 100, the loop ends and our progress label should stop changing. If
    you wait patiently, you’ll see that final value. The app itself should remain
    active, though. You can still type in the text field. Our download is complete
    and all is well with the world!
  prefs: []
  type: TYPE_NORMAL
- en: Timers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Swing library includes a timer that is designed to work in the UI space.
    The `javax.swing.Timer` class is fairly straightforward. It waits a specified
    period of time and then fires off an action event (the same type of event as clicking
    a button). It can fire that action once or repeatedly. You’ll find many reasons
    to use timers with graphical applications. Besides providing an alternative way
    to drive an animation loop, you might want to automatically cancel some action,
    like loading a network resource if it is taking too long. Conversely, you might
    put up a little “please wait” spinner or dialog to let the user know the operation
    is ongoing. You might want to take down a dialog prompt if the user doesn’t respond
    within a specified time span. Swing’s `Timer` can handle all of these scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Animation with Timer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s modify our flying apples from [“Revisiting Animation with Threads”](ch09.html#learnjava6-CHP-9-SECT-1.3)
    and try implementing the animation with an instance of `Timer`. The `Timer` class
    takes care of that detail for us. We can still use our `step()` method in the
    `Apple` class from our first pass at animation. We just need to alter the start
    method and keep a suitable variable around for the timer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: There are two nice things about this approach. It’s definitely easier to read
    because we are not responsible for the pauses between actions. We create the `Timer`
    by passing to the constructor the time interval between events and an `ActionListener`
    to receive the events—our `Field` class in this case. We give the timer a simple
    but unique action command, make it a repeating timer, and start it up!
  prefs: []
  type: TYPE_NORMAL
- en: 'The other nice thing is specific to Swing and graphical applications: `javax.swing.Timer`
    fires its action events *on the event dispatch thread*. You do not need to wrap
    any of your response in `invokeAndWait()` or `invokeLater()`. Just put your timer-based
    code in the `actionPerformed()` method of an attached listener and you are good
    to go!'
  prefs: []
  type: TYPE_NORMAL
- en: Because several components generate `ActionEvent` objects, we did take a little
    precaution against collisions by setting the `actionCommand` attribute for our
    timer. This step is not strictly necessary in our case, but it leaves room for
    the `Field` class to handle other events down the road without breaking our animation.
  prefs: []
  type: TYPE_NORMAL
- en: Other Timer uses
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Mature, polished applications have a variety of small moments where it helps
    to have a one-time timer. Our apple game is simple by comparison to most commercial
    apps or games, but even here we can add a little “realism” with a timer: after
    tossing an apple, we can pause before allowing the physicist to fire another apple.
    Maybe the physicist has to bend down and grab another apple from a bucket before
    aiming or tossing. This kind of delay is another perfect spot for a `Timer`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add this pause to the bit of code in the `Field` class where we toss
    the apple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice this time that we set the timer to run only once with the `setRepeats(false)`
    call. This means that after a little less than a second, a single event will be
    fired off to our physicist. The `Physicist` class, in turn, needs to add the `implements
    Action` `Listener` portion to the class definition and include an appropriate
    `actionPerformed()` function, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Using `Timer` isn’t the only way to accomplish such tasks, but in Swing, the
    combination of efficient timed events and automatic use of the event dispatch
    thread make it worth considering. If nothing else, it makes prototyping easy.
    You can always come back and refactor your application to use custom threading
    code, if needed.
  prefs: []
  type: TYPE_NORMAL
- en: But Wait, There’s More
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we noted at the beginning of the chapter, there are many, many more discussions
    and topics and explorations available in the world of Java graphical applications.
    Java has an entire package devoted to storing [user preferences](https://oreil.ly/Vrbfz),
    for example. And O’Reilly has an entire book by Jonathan Knudsen devoted to [*Java
    2D Graphics*](https://oreil.ly/4xYdN). We’ll leave it to you to do that exploring
    but wanted to go through at least a few key topics worth focusing on first if
    you have plans for a desktop app.
  prefs: []
  type: TYPE_NORMAL
- en: Menus
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While not technically required, most desktop applications have an application-wide
    menu of common tasks, such as saving changed files or setting preferences. Apps
    with specific features, like spreadsheets, might have menus for sorting the data
    in a column or selection. The `JMenu`, `JMenuBar`, and `JMenuItem` classes help
    you add this functionality to your Swing apps. Menus go inside a menu bar, and
    menu items go inside menus. Swing has three prebuilt menu item classes: `JMenuItem`
    for basic menu entries, `JCheckBoxMenuItem` for option items, and `JRadioButtonMenuItem`
    for grouped menu items like the currently selected font or color theme. The `JMenu`
    class is itself a valid menu item so you can build nested menus. `JMenuItem` behaves
    like a button (as do its radio and checkbox compatriots), and you can catch menu
    events using the same listeners.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 12-32](#learnjava6-CHP-12-FIG-36) shows an example of a simple menu
    bar populated with some menus and items.'
  prefs: []
  type: TYPE_NORMAL
- en: '![ljv6 1232](assets/ljv6_1232.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-32\. `JMenu` and `JMenuItem` on macOS and Linux
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Here’s the source code for this demonstration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: We obviously don’t do much with the menu item actions here, but they illustrate
    how you can start building out the expected parts of a professional application.
  prefs: []
  type: TYPE_NORMAL
- en: Modals and Pop-Ups
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Events let the user get your attention, or at least the attention of some method
    in your application. But what if you need to get the user’s attention? A popular
    UI mechanism for this task is the pop-up window. You’ll often hear such a window
    referred to as a *modal* or *dialog* or even *modal dialog*. The term *dialog*
    comes from the fact that these pop-ups present some information to the user and
    expect—or require—a response. Perhaps this quick question and answer process is
    not as lofty as a Socratic symposium, but still. The *modal* name refers to the
    fact that some of those dialogs that require a response will actually disable
    the rest of the application—putting it in a restricted mode—until you provide
    that response. You may have experienced such a dialog yourself in other desktop
    applications. If your software requires you to stay up-to-date with the latest
    release, for example, it might “gray out” the application, indicating you can’t
    use it, and then show you a modal dialog with a button that initiates the update
    process.
  prefs: []
  type: TYPE_NORMAL
- en: The term *pop-up* is more general. While you can certainly have modal pop-ups,
    you can also have plain (“modeless”) pop-ups that do not block you from using
    the rest of the application. Think of a search dialog in a word-processing application
    that you can leave available and just scoot off to the side of your main window.
  prefs: []
  type: TYPE_NORMAL
- en: Swing provides a bare `JDialog` class that you can use to create custom dialog
    windows. For typical pop-up interactions with your users, including alerts, confirmations,
    and input dialogs, the `JOptionPane` class has some really handy shortcuts. For
    simple alerts and error messages, you can use the `showMessageDialog()` call.
    This type of dialog includes a customizable title, some text, and a button to
    acknowledge (and dismiss) the pop-up. If you need the user to make a yes-or-no
    choice, `showConfirmDialog()` is perfect. And if you need short, text-based answers
    from the user, you’ll want to use `showInputDialog()`. [Figure 12-33](#learnjava6-CHP-12-FIG-modals)
    shows an example of these three dialogs.
  prefs: []
  type: TYPE_NORMAL
- en: '![ljv6 1233](assets/ljv6_1233.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-33\. The main variations of JOptionPane pop-up windows
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'To create a message dialog, you have to supply four arguments. The first argument
    refers to the frame or window “owning” the pop-up. `JOptionPane` will attempt
    to center the dialog over its owner when shown. You can also specify `null` for
    this argument, which tells `JOptionPane` there is no primary window, so center
    the pop-up on the user’s screen. The second and third arguments are `String`s
    for the dialog’s message and title, respectively. The final argument indicates
    the “type” of pop-up, which mostly affects the icon you see. You can specify several
    types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ERROR_MESSAGE`, red Stop icon'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`INFORMATION_MESSAGE`, Duke^([6](ch12.html#id2462)) icon'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WARNING_MESSAGE`, yellow triangle icon'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QUESTION_MESSAGE`, Duke icon'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PLAIN_MESSAGE`, no icon'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Head back to your *jshell* and try creating a message pop-up. You can use the
    handy `null` option for the owner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Another common task for pop-ups is verifying the user’s intent. Many applications
    ask if you’re sure you want to quit or delete something. `JOptionPane` has you
    covered. You can try out this confirmation dialog in *jshell*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The two-argument version of the `showConfirmDialog()` method produces a pop-up
    with Yes, No, and Cancel buttons. You can determine which answer the user selected
    by keeping the return value (an `int`). We clicked the Yes button, which returns
    `0`, but you don’t have to memorize the return values. `JOptionPane` has constants
    covering the various responses:'
  prefs: []
  type: TYPE_NORMAL
- en: '`YES_OPTION`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NO_OPTION`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CANCEL_OPTION`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OK_OPTION`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CLOSED_OPTION`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`JOptionPane` returns the `CLOSED_OPTION` value if the user closes the dialog
    using the window controls rather than clicking on any of the available buttons
    within the dialog. You also have a modicum of control over those buttons. You
    can use a four-argument version that takes a title and a button choice with one
    of the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`YES_NO_OPTION`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OK_CANCEL_OPTION`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`YES_NO_CANCEL_OPTION`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In most situations, having both a “No” and a “Cancel” in the same dialog confuses
    users. We recommend using one of the first two options. (The user can always close
    the dialog using the standard window controls if they do not want to make a selection.)
    Let’s try creating a Yes/No dialog:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Some pop-ups ask for a quick bit of input. You can use the `showInputDialog()`
    method to ask a question and allow the user to type in an answer. That answer
    (a `String`) can be stored the same way you keep the confirmation choice. Let’s
    try one more pop-up in *jshell*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Input dialogs are handy for one-off requests, but we don’t recommend them if
    you have a series of questions to ask the user. You should keep modals confined
    to quick, infrequent tasks. They interrupt the user—by design. Sometimes that
    interruption is exactly what you need. If you abuse the user’s attention, however,
    you’re likely to annoy the user, and they’ll learn to simply ignore every pop-up
    from your application.
  prefs: []
  type: TYPE_NORMAL
- en: The file *ch12/examples/ModalDemo.java* contains a small application that can
    create a variety of modal dialogs. Feel free to play around with it and try out
    the different message types or confirmation button options. And don’t be afraid
    of modifying these example applications! Sometimes tweaking a simple app and recompiling
    is easier than trying to type multiline examples into *jshell*.
  prefs: []
  type: TYPE_NORMAL
- en: User Interface and User Experience
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This was a whirlwind tour of some of the more common UI elements for desktop
    applications, such as `JButton`, `JLabel`, and `JTextField`. We discussed how
    to arrange those components using layout managers in containers and introduced
    several other components.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, desktop applications are only part of the story. [Chapter 13](ch13.html#learnjava6-CHP-13)
    covers networking basics, including getting content from the web and simple client/server
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Review Questions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Which component would you use to display some text to the user?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which component(s) would you use to allow the user to enter text?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What event does clicking a button generate?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which listener should you attach to `JList` if you want to know when the user
    changes the selected item?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the default layout manager for `JPanel`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which thread is responsible for processing events in Java?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What method would you use to update a component like `JLabel` after a background
    task completes?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What container holds `JMenuItem` objects?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Code Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a calculator interface with buttons and a text display. You can use the
    starter `Calculator` class in the *ch12/exercises* folder. It extends `JFrame`
    and implements the `ActionListener` interface. The display element should go at
    the top of the calculator and show right-justified text. The buttons should include
    the digits 0-9, a decimal point, addition, subtraction, multiplication, division,
    and an “equals” for showing the results. You can see what it should look like
    in [Figure 12-34](#learnjava6-CHP-12-FIG-calc-ui).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![ljv6 1234](assets/ljv6_1234.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 12-34\. An example calculator interface
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: Don’t worry about hooking up the buttons to make the calculator work—yet. We’ll
    tackle that in the advanced exercise.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The apple tossing game in the *ch12/exercises/game* folder has sliders and buttons
    to aim and toss apples. Right now those apples simply fly in an arc and eventually
    go outside the bounds of our window. Add the necessary code to catch collisions
    between an apple and an obstacle, like a tree or a hedge. Your solution should
    remove both the apple and the obstacle and then refresh the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Advanced Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Take the visual shell you created for a calculator in the first code exercise
    and connect the buttons to make it functional. Clicking number buttons should
    put the corresponding digit in the display. Clicking an operation button (like
    addition or division) should store the operation to perform and allow the user
    to enter a second number. Clicking the “=” button should show the results of the
    operation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This exercise pulls together several discussions from past chapters. Make incremental
    changes and don’t be afraid to look in [“Advanced Exercises”](app02.html#learnjava6-APP-B-SECT-12.2)
    for hints on how to proceed.
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch12.html#id2307-marker)) If you are curious about this topic and want
    to see behind the curtains of a commercial, desktop Java application, JetBrains
    publishes the [source code](https://oreil.ly/YleE5) for the Community Edition.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch12.html#id2309-marker)) The `javax` package prefix was introduced early
    by Sun to accommodate packages that were distributed with Java but were not “core.”
    The decision was modestly controversial, but `javax` has stuck and has been used
    with other packages as well.
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch12.html#id2325-marker)) You’ll need to start *jshell* from the top-level
    directory containing the compiled examples for the book. If you are using IntelliJ
    IDEA, you can start its terminal and switch directories using **`cd out/production/LearningJava6e`**,
    and then start *jshell*.
  prefs: []
  type: TYPE_NORMAL
- en: ^([4](ch12.html#id2349-marker)) As we create Swing components for use in these
    *jshell* examples, we’ll be omitting much of the resulting output for the sake
    of space. *jshell* prints a lot of information about each component, although
    it also uses ellipses when things get too extreme. Don’t be alarmed if you see
    extra details about an element’s attributes while you’re experimenting.
  prefs: []
  type: TYPE_NORMAL
- en: ^([5](ch12.html#id2356-marker)) We should also note that there are many open
    source projects with even fancier components for handling things like syntax highlighting
    in text, various selection helpers, graphs and charts, and composite inputs like
    date or time pickers.
  prefs: []
  type: TYPE_NORMAL
- en: ^([6](ch12.html#id2462-marker)) “Duke” is the official Java mascot. You can
    find out more at [the OpenJDK wiki](https://oreil.ly/jahxA).
  prefs: []
  type: TYPE_NORMAL
