- en: Chapter 16\. Additional Quarkus Features
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter contains features of Quarkus that don’t fit into any other chapter.
    That, of course, doesn’t make them any less useful! In this chapter, you’ll learn
    about the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Quarkus’s templating solution, Qute
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OpenAPI integration
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending emails
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scheduling functions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application data caching
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.1 Creating Templates with the Qute Template Engine
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to create templates and render them with specific data.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the Qute template engine.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Qute is a templating engine designed specifically to meet the Quarkus needs
    of minimizing the usage of reflection and supporting the imperative and reactive
    style of coding.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Qute can be used as a standalone library (generating reports to disk or generating
    e-mail body messages) or together with JAX-RS to deliver HTML content.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: 'To start using Qute with JAX-RS, add the `resteasy-qute` extension:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: By default, templates are stored at the *src/main/resources/templates* directory
    and its subdirectories.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: 'The following might be a simple template as a plain-text file:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The template is a simple sentence parametrized with the `name` parameter.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'To render the template with concrete data, you just need to inject the `io.quarkus.qute.Template`
    instance and provide the template parameters:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[![1](Images/1.png)](#co_additional_quarkus_features_CO1-1)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '`Template` instance defines the operations to do in a template'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_additional_quarkus_features_CO1-2)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: By default, the field name is used to locate the template; in this case, the
    template path is *src/main/resources/templates/hello.txt*
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_additional_quarkus_features_CO1-3)'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Rendering is not necessary because RESTEasy integrates with the `TemplateInstance`
    object to render the content
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_additional_quarkus_features_CO1-4)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '`data` method is used to set the template parameters'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the project, you’ll be able to see how the template is rendered:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Discussion
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Qute supports more syntax (e.g., `include` and `insert` fragments, injecting
    CDI beans directly, or variant templates) as well as integration with other Quarkus
    parts like email or schedule tasks.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Visit the following website to learn more about Qute:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[Quarkus: Qute Reference Guide](https://oreil.ly/R1A1S)'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.2 Rending HTML Using Qute
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to render HTML using Qute.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Qute will render HTML just as easily as text. All that needs to happen is for
    Quarkus to find the template that matches your injection. The actual content of
    the template doesn’t matter much.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s render an HTML page with more complex structures on the template. A simple
    HTML report is rendered in this case. Create a POJO class containing the parameters
    of the report:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[![1](Images/1.png)](#co_additional_quarkus_features_CO2-1)'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: This annotation allows Quarkus to avoid using reflection to access the object
    at runtime
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_additional_quarkus_features_CO2-2)'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Custom method
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following are some details of the HTML template that are worth explaining.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part to look at is an optional header that you can put in any template
    to help Quarkus validate all the expressions at compile time:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[![1](Images/1.png)](#co_additional_quarkus_features_CO3-1)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Parameter declaration; this is not mandatory, but it helps Quarkus to validate
    your template for type safety
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: 'Basic syntax like conditionals or loops are supported:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[![1](Images/1.png)](#co_additional_quarkus_features_CO4-1)'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Conditional with a numeric type
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_additional_quarkus_features_CO4-2)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Else part
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_additional_quarkus_features_CO4-3)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Conditional with a string type using `is`
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_additional_quarkus_features_CO4-4)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Elvis operator; if the parameter is `null`, the default value is used
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](Images/5.png)](#co_additional_quarkus_features_CO4-5)'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Iterate over all characters
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](Images/6.png)](#co_additional_quarkus_features_CO4-6)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Show the character info
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](Images/7.png)](#co_additional_quarkus_features_CO4-7)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '`hasNext` is a special attribute that checks if there are more elements'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[![8](Images/8.png)](#co_additional_quarkus_features_CO4-8)'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Method call defined in the POJO; iterates the number of times defined in the
    call
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-72
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Inside a loop, the following implicit variables can be used: `hasNext`, `count`,
    `index`, `odd`, and `even`.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  id: totrans-74
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: At this time, it is possible to use only `Iterable`, `Map.Entry`, `Set`, `Integer`,
    and `Stream`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 16.3 Changing the Location of Qute Templates
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to change the location Qute uses to find templates.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can customize the template location (still within *src/main/resources/templates*
    and output to the *templates* directory in your application deployable) by using
    the `io.quarkus.qute.api.ResourcePath` annotation:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[![1](Images/1.png)](#co_additional_quarkus_features_CO5-1)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Sets the path of the template to *src/main/resources/templates/movies/detail.html*
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the application again (or if already running, let live reloading do its
    job), and then open a browser and enter this URL: [*http://localhost:8080/movie*](http://localhost:8080/movie).'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: 16.4 Extending Qute Data Classes
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to extend the functionality of a Qute data class.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A template extension method must follow the following rules:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Must be static.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Must not return void.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Must contain at least one parameter. The first parameter is used to match the
    base data object.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  id: totrans-93
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can use *template extensions* to add methods specifically for reporting
    purposes when you do not have access to data object source code.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 'You can implement *template extension methods* by using the `@io.quarkus.qute.TemplateExtension`
    annotation. In this case, let’s implement a method that rounds the `rating` number:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[![1](Images/1.png)](#co_additional_quarkus_features_CO6-1)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: First parameter is the POJO data object
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_additional_quarkus_features_CO6-2)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Custom parameters can be set
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: From the template engine, `movie` has a `roundStars` method with one argument,
    which is the number of decimals to round.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 从模板引擎，`movie` 有一个 `roundStars` 方法，带有一个参数，该参数是要舍入的小数位数。
- en: 'In a template you can now call the following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在模板中可以调用以下内容：
- en: '[PRE9]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[![1](Images/1.png)](#co_additional_quarkus_features_CO7-1)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_additional_quarkus_features_CO7-1)'
- en: '`Movie` class doesn’t define a `roundStars` method, but it is accessible because
    it is a template extension'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`Movie` 类没有定义 `roundStars` 方法，但因为它是模板扩展，所以可以访问它'
- en: 'Run the application again (or if already running, let live reloading do its
    job), and then open a browser and enter the URL: *[*http://localhost:8080/movie*](http://localhost:8080/movie)*.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行应用程序（或者如果已经在运行，请让实时重载完成其工作），然后打开浏览器，输入以下 URL：[*http://localhost:8080/movie*](http://localhost:8080/movie)。
- en: The output should be similar to the output shown in [Figure 16-1](#htmloutput).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应与[图 16-1](#htmloutput)中显示的输出类似。
- en: '![qucb 1601](Images/qucb_1601.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![qucb 1601](Images/qucb_1601.png)'
- en: Figure 16-1\. HTML output
  id: totrans-109
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 16-1\. HTML 输出
- en: 16.5 Describing Endpoints with OpenAPI
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 16.5 描述带有 OpenAPI 的端点
- en: Problem
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to describe your REST API with OpenAPI.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望使用 OpenAPI 描述您的 REST API。
- en: Solution
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the SmallRye OpenAPI extension.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 SmallRye OpenAPI 扩展。
- en: 'Once you have a RESTful API created with Quarkus, all you need to do is add
    the `openapi` extension:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您使用 Quarkus 创建了一个 RESTful API，您只需要添加 `openapi` 扩展：
- en: '[PRE10]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then restart the application for everything to take effect:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 然后重新启动应用程序，使所有内容生效：
- en: '[PRE11]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The specification of the API is available at */openapi* by default. To change
    this, use the `quarkus.smallrye-openapi.path` configuration:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，API 的规范位于 */openapi*。要更改此设置，请使用 `quarkus.smallrye-openapi.path` 配置：
- en: '[PRE12]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can get to the specification at *[*http://localhost:8080/openapi*](http://localhost:8080/openapi)*:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过[*http://localhost:8080/openapi*](http://localhost:8080/openapi)访问规范：
- en: '[PRE13]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Based on the previous spec, there are GET, POST, and DELETE endpoints. You can
    also see that there is a task object required for DELETE and POST. The task requires
    a boolean, string, and a date-time. This is simple and easy to understand.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 基于之前的规范，有 GET、POST 和 DELETE 端点。您还可以看到 DELETE 和 POST 需要一个任务对象。任务需要一个布尔值、一个字符串和一个日期时间。这非常简单易懂。
- en: Discussion
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: It is very easy to create an OpenAPI specification using the SmallRye OpenAPI
    extension in Quarkus. This gives you an easy-to-use and easy-to-read view into
    your RESTful APIs.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Quarkus 中的 SmallRye OpenAPI 扩展非常容易创建 OpenAPI 规范。这使您能够轻松查看和理解您的 RESTful API。
- en: SmallRye OpenAPI is an implementation of the Eclipse MicroProfile OpenAPI. The
    OpenAPI Specification is a standard, language-agnostic means of describing and
    discovering RESTful APIs. It is readable by both humans and machines. An OpenAPI
    document is defined either as JSON or YAML.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: SmallRye OpenAPI 是 Eclipse MicroProfile OpenAPI 的实现。OpenAPI 规范是一种标准的、与语言无关的描述和发现
    RESTful API 的方式。它既可由人类阅读，也可由机器处理。OpenAPI 文档定义为 JSON 或 YAML。
- en: See Also
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'For more information, visit the following pages on GitHub:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解更多信息，请访问 GitHub 上的以下页面：
- en: '[Eclipse MicroProfile OpenAPI](https://oreil.ly/hczN4)'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Eclipse MicroProfile OpenAPI](https://oreil.ly/hczN4)'
- en: '[MicroProfile OpenAPI Specification](https://oreil.ly/ufzr6)'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[MicroProfile OpenAPI 规范](https://oreil.ly/ufzr6)'
- en: '[OpenAPI Specification](https://oreil.ly/uslyb)'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[OpenAPI 规范](https://oreil.ly/uslyb)'
- en: In [Recipe 16.6](#customizing_openapi) you will learn how to use the annotations
    from SmallRye OpenAPI to customize the resulting spec.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 16.6](#customizing_openapi)中，您将学习如何使用 SmallRye OpenAPI 的注解来自定义生成的规范。
- en: 16.6 Customizing OpenAPI Spec
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 16.6 自定义 OpenAPI 规范
- en: Problem
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to customize the generated API spec.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望自定义生成的 API 规范。
- en: Solution
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use OpenAPI annotations from the SmallRye OpenAPI extension.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 SmallRye OpenAPI 扩展的 OpenAPI 注解。
- en: 'Reusing the task API created in the previous recipe, [Recipe 16.5](#endpoints_with_openapi)
    it is easy to make use of the OpenAPI annotations to add customizations and further
    documentation to your API:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 重用上一个示例中创建的任务 API，[示例 16.5](#endpoints_with_openapi)，可以轻松使用 OpenAPI 注解来添加自定义和进一步的
    API 文档：
- en: '[PRE14]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The previous code will create the following spec:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将创建以下规范：
- en: '[PRE16]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Based on the previous spec, there are GET, POST, and DELETE endpoints. You can
    also see that there is a task object required for DELETE and POST. The task requires
    a boolean, string, and a date-time. This is simple and easy to understand.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 基于之前的规范，有 GET、POST 和 DELETE 端点。您还可以看到 DELETE 和 POST 需要一个任务对象。任务需要一个布尔值、一个字符串和一个日期时间。这非常简单易懂。
- en: Discussion
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Various OpenAPI annotations are used to provide additional information about
    the API, including descriptions, summaries, and examples. More information can
    be found about these annotations in the spec and at the links in the “See Also”
    section.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Further customization of the generated OpenAPI specification is very easy with
    Quarkus. For ultimate customization, Quarkus supports serving a static file OpenAPI
    spec. To do this, you need to place your valid OpenAPI spec file at *META-INF/openapi.yml*
    or at *META-INF/openapi.json*. Quarkus will then combine the two and serve a combined
    static and dynamic spec. To disable the dynamic spec generation, just use the
    `mp.openapi.scan.disable=true` configuration in the *applications.properties*
    file.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For more information, visit the following pages on GitHub:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[Eclipse MicroProfile OpenAPI Specification](https://oreil.ly/i47k_)'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Eclipse MicroProfile OpenAPI: Annotation Samples](https://oreil.ly/ITXQz)'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Swagger 2.X Annotations: OpenAPI Annotations](https://oreil.ly/ol6nb)'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.7 Sending Email Synchronously
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to synchronously send an email.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make use of the Quarkus mailer extension.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 'Quarkus makes it very intuitive to send emails in both plain text and HTML,
    and to add attachments. There is also an easy-to-use method for testing whether
    emails have been properly sent without having to setup your own relay. Add the
    Email Quarkus extension to an existing project:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Quarkus uses the Vert.x Mail client, though there are two wrappers for ease
    of use:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `Mailer` class uses standard blocking and synchronous API calls, and the
    `ReactiveMailer`, as expected, uses nonblocking and asynchronous API calls. The
    `ReactiveMailer` will be discussed in the following recipe; both classes offer
    the same features. To send an email, simply use the `withText` or `withHtml` methods.
    You will need to supply a recipient, a subject, and a body. If you need to add
    things such as CC, BCC, and attachments, you can do so on the actual `Mail` instance.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: 'You will also need to configure the SMTP provider (in this case, we’re using
    Gmail TLS):'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[![1](Images/1.png)](#co_additional_quarkus_features_CO8-1)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: These can also be set with system properties and/or environment properties
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'Testing of the email component is done easily by making use of the `MockMailbox`
    component. It is a simple component consisting of three methods:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '`getMessagesSentTo`'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`clear`'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getTotalMessagesSent`'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following test demonstrates all three of these methods:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[![1](Images/1.png)](#co_additional_quarkus_features_CO9-1)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: We clear out the mailbox before the start of each test
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_additional_quarkus_features_CO9-2)'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Use `getTotalMessagesSent` to verify how many messages Quarkus sent out
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_additional_quarkus_features_CO9-3)'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Verify the messages sent to a particular address
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Both regular attachments and inline attachments are supported. Here is a simple
    example of an inline attachment:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[![1](Images/1.png)](#co_additional_quarkus_features_CO10-1)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Be sure to reference the inline attachment by the `content-id`
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_additional_quarkus_features_CO10-2)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: The `content-id` of the attachment
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For more information, see the following:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[Recipe 16.8](#email_reactively)'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Vert.x Mail client (SMTP client implementation)](https://oreil.ly/aqGZU)'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.8 Sending Email Reactively
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to send an email in a nonblocking, reactive fashion.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make use of the Quarkus mailer extension.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous section details the basics. To do this reactively, simply inject
    the `ReactiveMailer` component and use it instead. The methods are the same; they
    simply return reactive counterparts instead of synchronous ones:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This test is exactly the same as the one in the previous section; the only difference
    is turning the `CompletionStage` to a `CompletableFuture` and calling `join` to
    get back to an imperative style for the test.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Qute integrates with Mailer extension so the body content of the message is
    rendered from a template.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: 'You need only the `qute` extension this time because no RESTEasy integration
    is required:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The main class is the `io.quarkus.mailer.MailTemplate`, and it is used in the
    same way as the `io.quarkus.qute.Template`, but the first one contains methods
    that are specific to mail logic:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[![1](Images/1.png)](#co_additional_quarkus_features_CO11-1)'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Template placed at *src/main/resources/templates/mail/welcome.txt*
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_additional_quarkus_features_CO11-2)'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Sends the email rendering the body from the template file with provided data
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: The reactive way of sending emails follows the exact same method names and usage,
    instead using reactive classes. This makes it very easy to switch and understand.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For more information, see the following:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[Recipe 16.7](#email_synchronously)'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Recipe 16.1](#templates_qute_template)'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.9 Creating Scheduled Jobs
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want some tasks to run on a schedule.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Scheduling tasks in Quarkus is fast and easy yet provides a high level of control
    and customization. Quarkus has a `scheduler` extension that integrates with Quartz.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating scheduled jobs is very easy: simply add the `@io.quarkus.scheduler.Scheduled`
    annotation to an application-scoped bean. There are two attributes available for
    specifying the schedule for the task: `cron` and `every`.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: The `cron` attribute uses the Quartz cron syntax. If you are not familiar with
    Quartz, please note that there are some differences to standard cron syntax. You
    can learn more about this at the link in [“See Also”](#scheduled_jobs_see_also).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: The `every` attribute is probably the easiest to use, though it has some nuances.
    `every` parses the string using `Duration#parse`. If the expression starts with
    a digit, the `PT` prefix is automatically added.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Both `every` and `cron` will do a config look up for an expression started with
    `{` and ended with `}`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: There is a `delay` attribute that takes a long, and there is a `delayUnit` attribute
    that takes a `TimeUnit`. Used together, these will specify a delay, after which
    the trigger is started. By default, the trigger starts when it is registered.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a demonstration of a very simple usage:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Discussion
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Qute can be used to periodically generate reports.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'You need only the `qute` extension because no RESTEasy integration is required:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now the `render()` method must be called manually to get the result:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: See Also
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For more information, see the following:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[Quartz: Cron Trigger Tutorial](https://oreil.ly/XdQ7r)'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Recipe 16.1](#templates_qute_template)'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.10 Using Application Data Caching
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to avoid waiting time when methods take a long time to respond.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use application data caching.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: There are some cases in which a method might take more time than expected to
    respond, maybe because it is making a request to an external system or because
    the logic being executed takes a long time to execute.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: One way to improve this situation is by using application data caches. The idea
    is to save the result of a method call so that further calls with the same *inputs*
    to that method return the previously calculated result.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: Quarkus integrates with [Caffeine](https://oreil.ly/1NjlX) as a caching provider.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: 'To start using application data caching, add the `cache` extension:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Here is a method that simulates a long execution time:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[![1](Images/1.png)](#co_additional_quarkus_features_CO12-1)'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: This logic has a random sleep time
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the project, you’ll be able to see this delay:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Let’s cache the `getMessage()` method call by using the `@io.quarkus.cache.CacheResult`
    annotation:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[![1](Images/1.png)](#co_additional_quarkus_features_CO13-1)'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: Creates a new cache for this method call
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the application again (or if it is already running, let live reloading
    do its job) and repeat the calls to *[*http://localhost:8080/hello*](http://localhost:8080/hello)*:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The second time the method is called, the method is never invoked but is returned
    from the cache. Quarkus computes for every call a cache key and checks for a hit
    in the cache system.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: To calculate the cache key, Quarkus uses all argument values by default. If
    there are no argument methods, the key is derived from the cache name.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `@io.quarkus.cache.CacheKey` annotation can be used in method arguments
    to specify exactly which arguments must be used for cache key calculation—for
    example the `public String myMethod(@CacheKey String keyElement1, String notPartOfTheKey)`.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: Important
  id: totrans-260
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The @io.quarkus.cache.CacheKey annotation cannot be used on a method returning
    `void`.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: The `@io.quarkus.cache.CacheInvalidate` annotation can be used to invalidate
    an entry from the cache. When a method annotated with `@CacheInvalidate` is invoked,
    the cache key is calculated and used to remove an existing entry from the cache.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: The `@io.quarkus.cache.CacheInvalidateAll` annotation is used to invalidate
    all cache entries.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of the data caching options can be configured individually in the *application.properties*
    file:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 每个数据缓存选项都可以在*application.properties*文件中单独配置：
- en: '[PRE33]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[![1](Images/1.png)](#co_additional_quarkus_features_CO14-1)'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_additional_quarkus_features_CO14-1)'
- en: Minimum total size for the internal data structures of the `greeting-cache`
    cache
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '`greeting-cache`缓存的内部数据结构的最小总大小'
- en: '[![2](Images/2.png)](#co_additional_quarkus_features_CO14-2)'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_additional_quarkus_features_CO14-2)'
- en: Sets the expiration time, counting after the write operation of `greeting-cache`
    cache
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 设置过期时间，在对`greeting-cache`缓存进行写操作后开始计时
- en: 'Run the application again (or if it is already running, let live reloading
    do its job) and repeat the calls to *[*http://localhost:8080/hello*](http://localhost:8080/hello)*:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行应用程序（或者如果已经运行，请让实时重新加载完成其工作），并重复调用*[*http://localhost:8080/hello*](http://localhost:8080/hello)*：
- en: '[PRE34]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Tip
  id: totrans-272
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: The `quarkus.cache.caffeine."greeting-cache".expire-after-access` property can
    be used to set the expiration time of the cache to an amount of time after the
    most recent read or write of the cache value.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`quarkus.cache.caffeine."greeting-cache".expire-after-access`属性可用于将缓存的过期时间设置为最近一次读取或写入缓存值后的一段时间。'
