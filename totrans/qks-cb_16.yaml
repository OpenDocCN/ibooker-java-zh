- en: Chapter 16\. Additional Quarkus Features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter contains features of Quarkus that don’t fit into any other chapter.
    That, of course, doesn’t make them any less useful! In this chapter, you’ll learn
    about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Quarkus’s templating solution, Qute
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OpenAPI integration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending emails
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scheduling functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application data caching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.1 Creating Templates with the Qute Template Engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to create templates and render them with specific data.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the Qute template engine.
  prefs: []
  type: TYPE_NORMAL
- en: Qute is a templating engine designed specifically to meet the Quarkus needs
    of minimizing the usage of reflection and supporting the imperative and reactive
    style of coding.
  prefs: []
  type: TYPE_NORMAL
- en: Qute can be used as a standalone library (generating reports to disk or generating
    e-mail body messages) or together with JAX-RS to deliver HTML content.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start using Qute with JAX-RS, add the `resteasy-qute` extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: By default, templates are stored at the *src/main/resources/templates* directory
    and its subdirectories.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following might be a simple template as a plain-text file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The template is a simple sentence parametrized with the `name` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'To render the template with concrete data, you just need to inject the `io.quarkus.qute.Template`
    instance and provide the template parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_additional_quarkus_features_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: '`Template` instance defines the operations to do in a template'
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_additional_quarkus_features_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: By default, the field name is used to locate the template; in this case, the
    template path is *src/main/resources/templates/hello.txt*
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_additional_quarkus_features_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Rendering is not necessary because RESTEasy integrates with the `TemplateInstance`
    object to render the content
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_additional_quarkus_features_CO1-4)'
  prefs: []
  type: TYPE_NORMAL
- en: '`data` method is used to set the template parameters'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the project, you’ll be able to see how the template is rendered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Qute supports more syntax (e.g., `include` and `insert` fragments, injecting
    CDI beans directly, or variant templates) as well as integration with other Quarkus
    parts like email or schedule tasks.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Visit the following website to learn more about Qute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Quarkus: Qute Reference Guide](https://oreil.ly/R1A1S)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.2 Rending HTML Using Qute
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to render HTML using Qute.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Qute will render HTML just as easily as text. All that needs to happen is for
    Quarkus to find the template that matches your injection. The actual content of
    the template doesn’t matter much.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s render an HTML page with more complex structures on the template. A simple
    HTML report is rendered in this case. Create a POJO class containing the parameters
    of the report:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_additional_quarkus_features_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: This annotation allows Quarkus to avoid using reflection to access the object
    at runtime
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_additional_quarkus_features_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Custom method
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following are some details of the HTML template that are worth explaining.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part to look at is an optional header that you can put in any template
    to help Quarkus validate all the expressions at compile time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_additional_quarkus_features_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Parameter declaration; this is not mandatory, but it helps Quarkus to validate
    your template for type safety
  prefs: []
  type: TYPE_NORMAL
- en: 'Basic syntax like conditionals or loops are supported:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_additional_quarkus_features_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Conditional with a numeric type
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_additional_quarkus_features_CO4-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Else part
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_additional_quarkus_features_CO4-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Conditional with a string type using `is`
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_additional_quarkus_features_CO4-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Elvis operator; if the parameter is `null`, the default value is used
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](Images/5.png)](#co_additional_quarkus_features_CO4-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Iterate over all characters
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](Images/6.png)](#co_additional_quarkus_features_CO4-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Show the character info
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](Images/7.png)](#co_additional_quarkus_features_CO4-7)'
  prefs: []
  type: TYPE_NORMAL
- en: '`hasNext` is a special attribute that checks if there are more elements'
  prefs: []
  type: TYPE_NORMAL
- en: '[![8](Images/8.png)](#co_additional_quarkus_features_CO4-8)'
  prefs: []
  type: TYPE_NORMAL
- en: Method call defined in the POJO; iterates the number of times defined in the
    call
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Inside a loop, the following implicit variables can be used: `hasNext`, `count`,
    `index`, `odd`, and `even`.'
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: At this time, it is possible to use only `Iterable`, `Map.Entry`, `Set`, `Integer`,
    and `Stream`.
  prefs: []
  type: TYPE_NORMAL
- en: 16.3 Changing the Location of Qute Templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to change the location Qute uses to find templates.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can customize the template location (still within *src/main/resources/templates*
    and output to the *templates* directory in your application deployable) by using
    the `io.quarkus.qute.api.ResourcePath` annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_additional_quarkus_features_CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets the path of the template to *src/main/resources/templates/movies/detail.html*
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the application again (or if already running, let live reloading do its
    job), and then open a browser and enter this URL: [*http://localhost:8080/movie*](http://localhost:8080/movie).'
  prefs: []
  type: TYPE_NORMAL
- en: 16.4 Extending Qute Data Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to extend the functionality of a Qute data class.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A template extension method must follow the following rules:'
  prefs: []
  type: TYPE_NORMAL
- en: Must be static.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Must not return void.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Must contain at least one parameter. The first parameter is used to match the
    base data object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can use *template extensions* to add methods specifically for reporting
    purposes when you do not have access to data object source code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can implement *template extension methods* by using the `@io.quarkus.qute.TemplateExtension`
    annotation. In this case, let’s implement a method that rounds the `rating` number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_additional_quarkus_features_CO6-1)'
  prefs: []
  type: TYPE_NORMAL
- en: First parameter is the POJO data object
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_additional_quarkus_features_CO6-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Custom parameters can be set
  prefs: []
  type: TYPE_NORMAL
- en: From the template engine, `movie` has a `roundStars` method with one argument,
    which is the number of decimals to round.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a template you can now call the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_additional_quarkus_features_CO7-1)'
  prefs: []
  type: TYPE_NORMAL
- en: '`Movie` class doesn’t define a `roundStars` method, but it is accessible because
    it is a template extension'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the application again (or if already running, let live reloading do its
    job), and then open a browser and enter the URL: *[*http://localhost:8080/movie*](http://localhost:8080/movie)*.'
  prefs: []
  type: TYPE_NORMAL
- en: The output should be similar to the output shown in [Figure 16-1](#htmloutput).
  prefs: []
  type: TYPE_NORMAL
- en: '![qucb 1601](Images/qucb_1601.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16-1\. HTML output
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 16.5 Describing Endpoints with OpenAPI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to describe your REST API with OpenAPI.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the SmallRye OpenAPI extension.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have a RESTful API created with Quarkus, all you need to do is add
    the `openapi` extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Then restart the application for everything to take effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The specification of the API is available at */openapi* by default. To change
    this, use the `quarkus.smallrye-openapi.path` configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You can get to the specification at *[*http://localhost:8080/openapi*](http://localhost:8080/openapi)*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Based on the previous spec, there are GET, POST, and DELETE endpoints. You can
    also see that there is a task object required for DELETE and POST. The task requires
    a boolean, string, and a date-time. This is simple and easy to understand.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is very easy to create an OpenAPI specification using the SmallRye OpenAPI
    extension in Quarkus. This gives you an easy-to-use and easy-to-read view into
    your RESTful APIs.
  prefs: []
  type: TYPE_NORMAL
- en: SmallRye OpenAPI is an implementation of the Eclipse MicroProfile OpenAPI. The
    OpenAPI Specification is a standard, language-agnostic means of describing and
    discovering RESTful APIs. It is readable by both humans and machines. An OpenAPI
    document is defined either as JSON or YAML.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For more information, visit the following pages on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Eclipse MicroProfile OpenAPI](https://oreil.ly/hczN4)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[MicroProfile OpenAPI Specification](https://oreil.ly/ufzr6)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[OpenAPI Specification](https://oreil.ly/uslyb)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In [Recipe 16.6](#customizing_openapi) you will learn how to use the annotations
    from SmallRye OpenAPI to customize the resulting spec.
  prefs: []
  type: TYPE_NORMAL
- en: 16.6 Customizing OpenAPI Spec
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to customize the generated API spec.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use OpenAPI annotations from the SmallRye OpenAPI extension.
  prefs: []
  type: TYPE_NORMAL
- en: 'Reusing the task API created in the previous recipe, [Recipe 16.5](#endpoints_with_openapi)
    it is easy to make use of the OpenAPI annotations to add customizations and further
    documentation to your API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code will create the following spec:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Based on the previous spec, there are GET, POST, and DELETE endpoints. You can
    also see that there is a task object required for DELETE and POST. The task requires
    a boolean, string, and a date-time. This is simple and easy to understand.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Various OpenAPI annotations are used to provide additional information about
    the API, including descriptions, summaries, and examples. More information can
    be found about these annotations in the spec and at the links in the “See Also”
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Further customization of the generated OpenAPI specification is very easy with
    Quarkus. For ultimate customization, Quarkus supports serving a static file OpenAPI
    spec. To do this, you need to place your valid OpenAPI spec file at *META-INF/openapi.yml*
    or at *META-INF/openapi.json*. Quarkus will then combine the two and serve a combined
    static and dynamic spec. To disable the dynamic spec generation, just use the
    `mp.openapi.scan.disable=true` configuration in the *applications.properties*
    file.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For more information, visit the following pages on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Eclipse MicroProfile OpenAPI Specification](https://oreil.ly/i47k_)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Eclipse MicroProfile OpenAPI: Annotation Samples](https://oreil.ly/ITXQz)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Swagger 2.X Annotations: OpenAPI Annotations](https://oreil.ly/ol6nb)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.7 Sending Email Synchronously
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to synchronously send an email.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make use of the Quarkus mailer extension.
  prefs: []
  type: TYPE_NORMAL
- en: 'Quarkus makes it very intuitive to send emails in both plain text and HTML,
    and to add attachments. There is also an easy-to-use method for testing whether
    emails have been properly sent without having to setup your own relay. Add the
    Email Quarkus extension to an existing project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Quarkus uses the Vert.x Mail client, though there are two wrappers for ease
    of use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `Mailer` class uses standard blocking and synchronous API calls, and the
    `ReactiveMailer`, as expected, uses nonblocking and asynchronous API calls. The
    `ReactiveMailer` will be discussed in the following recipe; both classes offer
    the same features. To send an email, simply use the `withText` or `withHtml` methods.
    You will need to supply a recipient, a subject, and a body. If you need to add
    things such as CC, BCC, and attachments, you can do so on the actual `Mail` instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will also need to configure the SMTP provider (in this case, we’re using
    Gmail TLS):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_additional_quarkus_features_CO8-1)'
  prefs: []
  type: TYPE_NORMAL
- en: These can also be set with system properties and/or environment properties
  prefs: []
  type: TYPE_NORMAL
- en: 'Testing of the email component is done easily by making use of the `MockMailbox`
    component. It is a simple component consisting of three methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`getMessagesSentTo`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`clear`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getTotalMessagesSent`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following test demonstrates all three of these methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_additional_quarkus_features_CO9-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We clear out the mailbox before the start of each test
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_additional_quarkus_features_CO9-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Use `getTotalMessagesSent` to verify how many messages Quarkus sent out
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_additional_quarkus_features_CO9-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Verify the messages sent to a particular address
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Both regular attachments and inline attachments are supported. Here is a simple
    example of an inline attachment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_additional_quarkus_features_CO10-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Be sure to reference the inline attachment by the `content-id`
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_additional_quarkus_features_CO10-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The `content-id` of the attachment
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For more information, see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Recipe 16.8](#email_reactively)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Vert.x Mail client (SMTP client implementation)](https://oreil.ly/aqGZU)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.8 Sending Email Reactively
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to send an email in a nonblocking, reactive fashion.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make use of the Quarkus mailer extension.
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous section details the basics. To do this reactively, simply inject
    the `ReactiveMailer` component and use it instead. The methods are the same; they
    simply return reactive counterparts instead of synchronous ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This test is exactly the same as the one in the previous section; the only difference
    is turning the `CompletionStage` to a `CompletableFuture` and calling `join` to
    get back to an imperative style for the test.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Qute integrates with Mailer extension so the body content of the message is
    rendered from a template.
  prefs: []
  type: TYPE_NORMAL
- en: 'You need only the `qute` extension this time because no RESTEasy integration
    is required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The main class is the `io.quarkus.mailer.MailTemplate`, and it is used in the
    same way as the `io.quarkus.qute.Template`, but the first one contains methods
    that are specific to mail logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_additional_quarkus_features_CO11-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Template placed at *src/main/resources/templates/mail/welcome.txt*
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_additional_quarkus_features_CO11-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Sends the email rendering the body from the template file with provided data
  prefs: []
  type: TYPE_NORMAL
- en: The reactive way of sending emails follows the exact same method names and usage,
    instead using reactive classes. This makes it very easy to switch and understand.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For more information, see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Recipe 16.7](#email_synchronously)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Recipe 16.1](#templates_qute_template)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.9 Creating Scheduled Jobs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want some tasks to run on a schedule.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Scheduling tasks in Quarkus is fast and easy yet provides a high level of control
    and customization. Quarkus has a `scheduler` extension that integrates with Quartz.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating scheduled jobs is very easy: simply add the `@io.quarkus.scheduler.Scheduled`
    annotation to an application-scoped bean. There are two attributes available for
    specifying the schedule for the task: `cron` and `every`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `cron` attribute uses the Quartz cron syntax. If you are not familiar with
    Quartz, please note that there are some differences to standard cron syntax. You
    can learn more about this at the link in [“See Also”](#scheduled_jobs_see_also).
  prefs: []
  type: TYPE_NORMAL
- en: The `every` attribute is probably the easiest to use, though it has some nuances.
    `every` parses the string using `Duration#parse`. If the expression starts with
    a digit, the `PT` prefix is automatically added.
  prefs: []
  type: TYPE_NORMAL
- en: Both `every` and `cron` will do a config look up for an expression started with
    `{` and ended with `}`.
  prefs: []
  type: TYPE_NORMAL
- en: There is a `delay` attribute that takes a long, and there is a `delayUnit` attribute
    that takes a `TimeUnit`. Used together, these will specify a delay, after which
    the trigger is started. By default, the trigger starts when it is registered.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a demonstration of a very simple usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Qute can be used to periodically generate reports.
  prefs: []
  type: TYPE_NORMAL
- en: 'You need only the `qute` extension because no RESTEasy integration is required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the `render()` method must be called manually to get the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For more information, see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Quartz: Cron Trigger Tutorial](https://oreil.ly/XdQ7r)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Recipe 16.1](#templates_qute_template)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.10 Using Application Data Caching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to avoid waiting time when methods take a long time to respond.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use application data caching.
  prefs: []
  type: TYPE_NORMAL
- en: There are some cases in which a method might take more time than expected to
    respond, maybe because it is making a request to an external system or because
    the logic being executed takes a long time to execute.
  prefs: []
  type: TYPE_NORMAL
- en: One way to improve this situation is by using application data caches. The idea
    is to save the result of a method call so that further calls with the same *inputs*
    to that method return the previously calculated result.
  prefs: []
  type: TYPE_NORMAL
- en: Quarkus integrates with [Caffeine](https://oreil.ly/1NjlX) as a caching provider.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start using application data caching, add the `cache` extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a method that simulates a long execution time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_additional_quarkus_features_CO12-1)'
  prefs: []
  type: TYPE_NORMAL
- en: This logic has a random sleep time
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the project, you’ll be able to see this delay:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s cache the `getMessage()` method call by using the `@io.quarkus.cache.CacheResult`
    annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_additional_quarkus_features_CO13-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Creates a new cache for this method call
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the application again (or if it is already running, let live reloading
    do its job) and repeat the calls to *[*http://localhost:8080/hello*](http://localhost:8080/hello)*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The second time the method is called, the method is never invoked but is returned
    from the cache. Quarkus computes for every call a cache key and checks for a hit
    in the cache system.
  prefs: []
  type: TYPE_NORMAL
- en: To calculate the cache key, Quarkus uses all argument values by default. If
    there are no argument methods, the key is derived from the cache name.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `@io.quarkus.cache.CacheKey` annotation can be used in method arguments
    to specify exactly which arguments must be used for cache key calculation—for
    example the `public String myMethod(@CacheKey String keyElement1, String notPartOfTheKey)`.
  prefs: []
  type: TYPE_NORMAL
- en: Important
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The @io.quarkus.cache.CacheKey annotation cannot be used on a method returning
    `void`.
  prefs: []
  type: TYPE_NORMAL
- en: The `@io.quarkus.cache.CacheInvalidate` annotation can be used to invalidate
    an entry from the cache. When a method annotated with `@CacheInvalidate` is invoked,
    the cache key is calculated and used to remove an existing entry from the cache.
  prefs: []
  type: TYPE_NORMAL
- en: The `@io.quarkus.cache.CacheInvalidateAll` annotation is used to invalidate
    all cache entries.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of the data caching options can be configured individually in the *application.properties*
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_additional_quarkus_features_CO14-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Minimum total size for the internal data structures of the `greeting-cache`
    cache
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_additional_quarkus_features_CO14-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets the expiration time, counting after the write operation of `greeting-cache`
    cache
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the application again (or if it is already running, let live reloading
    do its job) and repeat the calls to *[*http://localhost:8080/hello*](http://localhost:8080/hello)*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `quarkus.cache.caffeine."greeting-cache".expire-after-access` property can
    be used to set the expiration time of the cache to an amount of time after the
    most recent read or write of the cache value.
  prefs: []
  type: TYPE_NORMAL
