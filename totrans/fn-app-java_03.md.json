["```java\n() -> System.out.println(\"Hello, lambda!\")\n```", "```java\n(<parameters>) -> { <body> };\n```", "```java\n(String input) -> { ![1](assets/1.png)\n  return input != null;\n}\n\ninput -> { ![2](assets/2.png)\n  return input != null;\n}\n\n(String input) -> input != null; ![3](assets/3.png)\n\ninput -> input != null; ![4](assets/4.png)\n```", "```java\npackage java.util.function;\n\n@FunctionalInterface ![1](assets/1.png)\npublic interface Predicate<T> {\n\n  boolean test(T t); ![2](assets/2.png)\n\n  default Predicate<T> and(Predicate<? super T> other) { ![3](assets/3.png)\n    // ...\n  }\n\n  default Predicate<T> negate() { ![3](assets/3.png)\n    // ...\n  }\n\n  default Predicate<T> or(Predicate<? super T> other) { ![3](assets/3.png)\n    // ...\n  }\n\n  static <T> Predicate<T> isEqual(Object targetRef) { ![4](assets/4.png)\n    // ...\n  }\n\n  static <T> Predicate<T> not(Predicate<? super T> target) { ![4](assets/4.png)\n    // ...\n  }\n}\n```", "```java\nvoid capture() {\n\n  var theAnswer = 42; ![1](assets/1.png)\n\n  Runnable printAnswer =\n    () -> System.out.println(\"the answer is \" + theAnswer); ![2](assets/2.png)\n\n  run(printAnswer); ![3](assets/3.png)\n}\n\nvoid run(Runnable r) {\n  r.run();\n}\n\ncapture();\n// OUTPUT:\n// the answer is 42\n```", "```java\nfinal List<String> wordList = new ArrayList<>(); ![1](assets/1.png)\n\n// COMPILES FINE\nRunnable addItemInLambda = () ->\n  wordList.add(\"adding is fine\"); ![2](assets/2.png)\n\n// WON'T COMPILE\nwordList = List.of(\"assigning\", \"another\", \"List\", \"is\", \"not\"); ![3](assets/3.png)\n```", "```java\nvar nonEffectivelyFinal = 1_000L; ![1](assets/1.png)\nnonEffectivelyFinal = 9_000L; ![2](assets/2.png)\n\nvar finalAgain = nonEffectivelyFinal; ![3](assets/3.png)\n\nPredicate<Long> isOver9000 = input -> input > finalAgain;\n```", "```java\n// FUNCTIONAL INTERFACE (implicit)\n\ninterface HelloWorld {\n  String sayHello(String name);\n}\n\n// AS ANONYMOUS CLASS\n\nvar helloWorld = new HelloWorld() {\n\n  @Override\n  public String sayHello(String name) {\n    return \"hello, \" + name + \"!\";\n  }\n};\n\n// AS LAMBDA\n\nHelloWorld helloWorldLambda = name -> \"hello, \" + name + \"!\";\n```", "```java\n// ANONYMOUS CLASS\n\n0: new #7 // class HelloWorldAnonymous$1 ![1](assets/1.png)\n3: dup\n4: invokespecial #9 // Method HelloWorldAnonymous$1.\"<init>\":()V ![2](assets/2.png)\n7: astore_1\n8: return\n\n// LAMBDA\n\n0: invokedynamic #7, 0 // InvokeDynamic #0:sayHello:()LHelloWorld; ![3](assets/3.png)\n5: astore_1\n6: return\n```", "```java\nPredicate<String> isNull = value -> value == null;\n```", "```java\n// WON'T COMPILE\nvar isNull = (String value) -> value == null;\n```", "```java\nboolean test(String input)\n```", "```java\ninterface LikePredicate<T> {\n  boolean test(T value);\n}\n```", "```java\nLikePredicate<String> isNull = value -> value == null; ![1](assets/1.png)\n\nPredicate<String> wontCompile = isNull; ![2](assets/2.png)\n// Error:\n// incompatible types: LikePredicate<java.lang.String> cannot be converted\n// to java.util.function.Predicate<java.lang.String>\n```", "```java\nList<String> filter1(List<String> values,\n                     Predicate<String> predicate) {\n  // ...\n}\n\nList<String> filter2(List<String> values,\n                     LikePredicate<String> predicate) {\n  // ...\n}\n\nvar values = Arrays.asList(\"a\", null, \"c\");\n\nvar result1 = filter1(values,\n                      value -> value != null);\n\nvar result2 = filter2(values,\n                      value -> value != null);\n```", "```java\nPredicate<Integer> isGreaterThan(int value) {\n  return compareValue -> compareValue > value;\n}\n```", "```java\nlet helloWorldJs = name => `hello, ${name}!`\n\nlet resultJs = helloWorldJs('Ben')\n```", "```java\nFunction<String, String> helloWorld = name -> \"hello, \" + name + \"!\";\n\nvar result = helloWorld.apply(\"Ben\"); ![2](assets/2.png)\n```", "```java\nList<Customer> customers = ...;\n\n// LAMBDAS\n\ncustomers.stream()\n         .filter(customer -> customer.isActive())\n         .map(customer -> customer.getName())\n         .map(name -> name.toUpperCase())\n         .peek(name -> System.out.println(name))\n         .toArray(count -> new String[count]);\n\n// METHOD-REFERENCES\n\ncustomers.stream()\n         .filter(Customer::isActive)\n         .map(Customer::getName)\n         .map(String::toUpperCase)\n         .peek(System.out::println)\n         .toArray(String[]::new);\n```", "```java\n// EXCERPT FROM java.lang.Integer\npublic class Integer extends Number {\n\n  public static String toHexString(int i) {\n    // ..\n  }\n}\n\n// LAMBDA\nFunction<Integer, String> asLambda = i -> Integer.toHexString(i);\n\n// STATIC METHOD REFERENCE\nFunction<Integer, String> asRef = Integer::toHexString;\n```", "```java\nvar now = LocalDate.now();\n\n// LAMBDA BASED ON EXISTING OBJECT\nPredicate<LocalDate> isAfterNowAsLambda = date -> $.isAfter(now);\n\n// BOUND NON-STATIC METHOD REFERENCE\nPredicate<LocalDate> isAfterNowAsRef = now::isAfter;\n```", "```java\n// BIND RETURN VALUE\nPredicate<LocalDate> isAfterNowAsRef = LocalDate.now()::isAfter;\n\n// BIND STATIC FIELD\nFunction<Object, String> castToStr = String.class::cast;\n```", "```java\npublic class SuperClass {\n\n  public String doWork(String input) {\n    return \"super: \" + input;\n  }\n}\n\npublic class SubClass extends SuperClass {\n\n  @Override\n  public String doWork(String input){\n    return \"this: \" + input;\n  }\n\n  public void superAndThis(String input) {\n\n    Function<String, String> thisWorker = this::doWork;\n    var thisResult = thisWorker.apply(input);\n    System.out.println(thisResult);\n\n    Function<String, String> superWorker = SubClass.super::doWork;\n    var superResult = superWorker.apply(input);\n    System.out.println(superResult);\n  }\n}\n\nnew SubClass().superAndThis(\"hello, World!\");\n// OUTPUT:\n// this: hello, World!\n// super: hello, World!\n```", "```java\n// EXCERPT FROM java.lang.String\npublic class String implements ... {\n\n  public String toLowerCase() {\n    // ...\n  }\n}\n\n// LAMBDA\nFunction<String, String> toLowerCaseLambda = str -> str.toLowerCase();\n\n// UNBOUND NON-STATIC METHOD REFERENCE\nFunction<String, String> toLowerCaseRef = String::toLowerCase;\n```", "```java\n// LAMBDA\nFunction<String, Locale> newLocaleLambda = language -> new Locale(language);\n\n// CONSTRUCTOR REFERENCE\nFunction<String, Locale> newLocaleLambda = Locale::new;\n```", "```java\nMap<String, Object> cache = new HashMap<>(); ![1](assets/1.png)\n\n<T> T memoize(String identifier, Supplier<T> fn) { ![2](assets/2.png)\n  return (T) cache.computeIfAbschent(identifier,\n                                   key -> fn.get());\n}\n\nInteger expensiveCall(String arg0, int arg1) { ![3](assets/3.png)\n    // ...\n}\n\nInteger memoizedCall(String arg0, int arg1) { ![4](assets/4.png)\n  var compoundKey = String.format(\"expensiveCall:%s-%d\", arg0, arg1);\n\n  return memoize(compoundKey,\n                 () -> expensiveCall(arg0, arg1));\n}\n\nvar calculated = memoizedCall(\"hello, world!\", 42); ![5](assets/5.png)\n\nvar cached = memoizedCall(\"hello, world!\", 42); ![6](assets/6.png)\n```", "```java\n// VARIABLE ASSIGNMENT\n\nUnaryOperator<Integer> quadraticFn = x -> x * x; ![1](assets/1.png)\n\nquadraticFn.apply(5); ![2](assets/2.png)\n// => 25\n\n// METHOD ARGUMENT\n\npublic Integer apply(Integer input,\n                     UnaryOperator<Integer> operation) {\n  return operation.apply(input); ![3](assets/3.png)\n}\n\n// RETURN VALUE\n\npublic UnaryOperator<Integer> multiplyWith(Integer multiplier) {\n  return x -> multiplier * x; ![4](assets/4.png)\n}\n\nUnaryOperator<Integer> multiplyWithFive = multiplyWith(5);\n\nmultiplyWithFive.apply(6);\n// => 30\n```", "```java\nvar result1 = simple() && complex();\n\nvar result2 = simple() || complex();\n```"]