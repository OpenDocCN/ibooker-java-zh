["```java\nrecord Book(String title, int year, Genre genre) {\n  // NO BODY\n}\n\n// DATA PREPARATION\n\nList<Book> books = ...; ![1](assets/1.png)\n\nCollections.sort(books, Comparator.comparing(Book::title)); ![2](assets/2.png)\n\n// FOR-LOOP\n\nList<String> result = new ArrayList<>();\n\nfor (var book : books) {\n\n    if (book.year() >= 1970) { ![3](assets/3.png)\n        continue;\n    }\n\n    if (book.genre() != Genre.SCIENCE_FICTION) { ![3](assets/3.png)\n        continue;\n    }\n\n    var title = book.title(); ![4](assets/4.png)\n    result.add(title);\n\n    if (result.size() == 3) { ![5](assets/5.png)\n        break;\n    }\n}\n```", "```java\nList<Book> books = ...; ![1](assets/1.png)\n\nList<String> result =\n  books.stream()\n       .filter(book -> book.year() < 1970) ![2](assets/2.png)\n       .filter(book -> book.genre() == Genre.SCIENCE_FICTION) ![3](assets/3.png)\n       .map(Book::title) ![4](assets/4.png)\n       .sorted() ![5](assets/5.png)\n       .limit(3) ![6](assets/6.png)\n       .collect(Collectors.toList()); ![7](assets/7.png)\n```", "```java\npublic interface Spliterator<T> {\n\n    // CHARACTERISTICS\n    int characteristics();\n    default boolean hasCharacteristics(int characteristics) {\n        // ...\n    }\n\n    // ITERATION\n\n    boolean tryAdvance(Consumer<? super T> action);\n    default void forEachRemaining(Consumer<? super T> action)Â {\n        // ...\n    }\n\n    // SPLITTING\n    Spliterator<T> trySplit();\n\n    // SIZE\n    long estimateSize();\n    default long getExactSizeIfKnown() {\n        // ...\n    }\n\n    // COMPARATOR\n    default Comparator<? super T> getComparator() {\n        // ...\n    }\n}\n```", "```java\npublic int characteristics() {\n    return (fence < 0 || est == map.size ? Spliterator.SIZED : 0) |\n                Spliterator.DISTINCT;\n}\n```", "```java\n<T> Spliterator<T> spliterator(Iterator<? extends T> iterator,\n                               long size,\n                               int characteristics)\n```", "```java\npublic interface Collection<E> extends Iterable<E> {\n\n  default Stream<E> stream() {\n    return StreamSupport.stream(spliterator(), false);\n  }\n\n  default Stream<E> parallelStream() {\n    return StreamSupport.stream(spliterator(), true);\n  }\n\n  @Override\n  default Spliterator<E> spliterator() {\n    return Spliterators.spliterator(this, 0);\n  }\n\n  // ...\n}\n```", "```java\npublic record Shape(int corners) implements Comparable<Shape> {\n\n  // HELPER METHODS\n\n  public boolean hasCorners() {\n    return corners() > 0;\n  }\n\n  public List<Shape> twice() {\n    return List.of(this, this);\n  }\n\n  @Override\n  public int compareTo(Shape o) {\n    return Integer.compare(corners(), o.corners());\n  }\n\n  // FACTORY METHODS\n\n  public static Shape circle() {\n    return new Shape(0);\n  }\n\n  public static Shape triangle() {\n    return new Shape(3);\n  }\n\n  public static Shape square() {\n    return new Shape(4);\n  }\n}\n```", "```java\n// FLATMAP\n\nStream<Shape> flatMap =\n  Stream.of(Shape.square(), Shape.triangle(), Shape.circle())\n        .map(Shape::twice)\n        .flatMap(List::stream);\n\n// MAPMULTI\n\nStream<Shape> mapMulti =\n  Stream.of(Shape.square(), Shape.triangle(), Shape.circle())\n        .mapMulti((shape, downstream) -> shape.twice()\n                                              .forEach(downstream::accept));\n```", "```java\nList<Shape> result =\n  Stream.of(Shape.square(), Shape.triangle(), Shape.circle())\n        .map(Shape::twice)\n        .flatMap(List::stream)\n        .peek(shape -> System.out.println(\"current: \" + shape))\n        .filter(shape -> shape.corners() < 4)\n        .collect(Collectors.toList());\n\n// OUTPUT\n// current: Shape[corners=4]\n// current: Shape[corners=4]\n// current: Shape[corners=3]\n// current: Shape[corners=3]\n// current: Shape[corners=0]\n// current: Shape[corners=0]\n```", "```java\nInteger max(Collection<Integer> numbers) {\n  int result = Integer.MIN_VALUE; ![1](assets/1.png)\n\n  for (var value : numbers) { ![2](assets/2.png)\n    result = Math.max(result, value); ![3](assets/3.png)\n  }\n\n  return result; ![4](assets/4.png)\n}\n```", "```java\n<T> T reduce(Collection<T> elements,\n             T initialValue,\n             BinaryOperator<T> accumulator) {\n\n  T result = initialValue;\n\n  for (T element : elements) {\n    result = accumulator.apply(result, element);\n  }\n\n  return result;\n}\n```", "```java\nInteger max(Collection<Integer> numbers) {\n  return reduce(elements,\n                Integer.MIN_VALUE,\n                Math::max);\n}\n```", "```java\nvar reduceOnly = Stream.of(\"apple\", \"orange\", \"banana\")\n                       .reduce(0,\n                               (acc, str) -> acc + str.length(),\n                               Integer::sum);\n\nvar mapReduce = Stream.of(\"apple\", \"orange\", \"banana\")\n                      .mapToInt(String::length)\n                      .reduce(0, (acc, length) -> acc + length);\n```", "```java\nvar fruits = Stream.of(\"apple\", \"orange\", \"banana\", \"peach\")\n                   ...\n                   .reduce(new ArrayList<>(), ![1](assets/1.png)\n                           (acc, fruit) -> {\n                             var list = new ArrayList<>(acc); ![2](assets/2.png)\n                             list.add(fruit);\n                             return list;\n                   },\n                   (lhs, rhs) -> { ![3](assets/3.png)\n                     var list = new ArrayList<>(lhs);\n                     list.addAll(rhs);\n                     return list;\n                   });\n```", "```java\nvar numbers = List.of(1, 2, 3, 4, 5, 6);\n\nint total = numbers.stream()\n                   .reduce(0, ![1](assets/1.png)\n                           Integer::sum); ![2](assets/2.png)\n```", "```java\nvar strings = List.of(\"a\", \"b\", \"c\", \"d\", \"e\");\n\n// STREAM REDUCE\n\nvar reduced = strings.stream()\n                     .reduce(\"\", ![1](assets/1.png)\n                             String::concat); ![2](assets/2.png)\n\n// STREAM COLLECT - CUSTOM\n\nvar joiner =strings.stream()\n                   .collect(Collector.of(() -> new StringJoiner(\"\"), ![3](assets/3.png)\n                                         StringJoiner::add, ![4](assets/4.png)\n                                         StringJoiner::merge, ![5](assets/5.png)\n                                         StringJoiner::toString)); ![6](assets/6.png)\n\n// STREAM COLLECT - PRE-DEFINED\n\nvar collectWithCollectors = strings.stream()\n                                   .collect(Collectors.joining()); ![7](assets/7.png)\n```", "```java\nString[] fruits = Stream.of(\"apple\", \"orange\", \"banana\", \"peach\")\n                        ...\n                        .toArray(String[]::new);\n```", "```java\nStream.of(\"ananas\", \"oranges\", \"apple\", \"pear\", \"banana\")\n      .map(String::toUpperCase) ![1](assets/1.png)\n      .sorted() ![2](assets/2.png)\n      .filter(s -> s.startsWith(\"A\")) ![3](assets/3.png)\n      .forEach(System.out::println); ![4](assets/4.png)\n```", "```java\nStream.of(\"ananas\", \"oranges\", \"apple\", \"pear\", \"banana\")\n      .filter(s -> s.startsWith(\"a\")) ![1](assets/1.png)\n      .map(String::toUpperCase) ![2](assets/2.png)\n      .sorted() ![3](assets/3.png)\n      .forEach(System.out::println); ![4](assets/4.png)\n```", "```java\nvar result = Stream.of(\"apple\", \"orange\", \"banana\", \"melon\")\n                   .peek(str -> System.out.println(\"peek 1: \" + str))\n                   .map(str -> {\n                     System.out.println(\"map: \" + str);\n                     return str.toUpperCase();\n                   })\n                   .peek(str -> System.out.println(\"peek 2: \" + str))\n                   .count();\n// NO OUTPUT\n```", "```java\nvar result = Stream.of(\"apple\", \"orange\", \"banana\", \"melon\")\n                   .filter(str -> str.contains(\"e\"))\n                   .peek(str -> System.out.println(\"peek 1: \" + str))\n                   .map(str -> {\n                     System.out.println(\"map: \" + str);\n                     return str.toUpperCase();\n                   })\n                   .peek(str -> System.out.println(\"peek 2: \" + str))\n                   .count();\n// OUTPUT\n// peek 1: apple\n// map: apple\n// peek 2: APPLE\n// peek 1: orange\n// map: orange\n// peek 2: ORANGE\n// peek 1: melon\n// map: melon\n// peek 2: MELON\n```"]