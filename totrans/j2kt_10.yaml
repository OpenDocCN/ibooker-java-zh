- en: Chapter 10\. Functions to Extension Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kotlin has a special kind of procedure called an extension function, that is
    called like a method but is in fact (usually) a top-level function. It’s easy
    to convert from a normal function to an extension function and back. When should
    we prefer one to the other?
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Functions and Methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Object-oriented programming is the art of solving problems by sending messages
    to objects. Want to know the length of `myString`? Ask it by sending it a message
    `myString.length()`. Want to print that string to the console? Put the string
    in a message and ask another object representing the console to print it for you:
    `System.out.println(myString)`. In classic OO languages, we define how an object
    reacts to a message by defining methods on classes. Methods are bound to their
    class and have access to the members (fields and other methods) associated with
    a particular instance. When we invoke a method, the runtime arranges for the correct
    version to be called (depending on the runtime type of the object), and for it
    to have access to instance state.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In contrast, in functional programming, we solve problems by calling functions
    with values. We find the length of `myString` by passing it to a function: `length(myString)`.
    We print to the console with `println(myString)`, and if we wanted to print somewhere
    else, we would pass that to the function: `println(myString, System.err)`. Functions
    are not defined *on* a type; function parameters and results *have* a type.'
  prefs: []
  type: TYPE_NORMAL
- en: The paradigms have pros and cons, but for now let’s just consider discoverability
    and extensibility.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a `Customer` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a class, so straightaway we know that we can send messages to ask for
    the `id`, `givenName`, and `familyName`. What about other operations? In a class-based
    system, we only have to scroll down to see another message that we can send:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Often we don’t even get as far as looking at the definition. If we have a variable
    `val customer: Customer`, we can type `customer.` and our IDE will eagerly tell
    us that we can call `id`, `givenName`, `familyName`, or `fullName`. In fact, this
    auto-complete is in many ways better than looking at the class definition, because
    it also shows us other operations (`equals`, `copy`, and so on) that are defined
    in supertypes or implicit in the language.'
  prefs: []
  type: TYPE_NORMAL
- en: In a functional decomposition, `fullName` would be a function, and, if we suspect
    it exists, we would have to search our codebase for it. In this case it will be
    a function where the only argument is of type `Customer`. It’s surprisingly hard
    to get IntelliJ to help us. “Find Usages” grouped by parameter type will do the
    job, but it’s hardly convenient. In practice, we expect to find the definition
    of `Customer` and its fundamental operations close together in the source, perhaps
    in the same file or at least namespace, so we might navigate there and find the
    functions where we expect them, but our tools haven’t been very helpful.
  prefs: []
  type: TYPE_NORMAL
- en: Score one to OO for discoverability then. What about extensibility? What happens
    when we want to add an operation to `Customer`? Marketing would like to render
    the name reversed with the `familyName` in uppercase for some report or other.
    (You may notice that whenever we need a simple but arbitrary example, we blame
    marketing.)
  prefs: []
  type: TYPE_NORMAL
- en: 'If we own the code, we can just add a method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If we don’t own the code, then we can’t add a method, so we have to fall back
    on a function. In Java we might have a collection of these static functions in
    a class called `Marketing`, or `CustomerUtils`. In Kotlin we can make them top-level
    functions (see [Chapter 8](ch08.html#static-methods-to-top-level-functions)),
    but the principle is the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'What of the functional solution? Well, this is the functional solution, too.
    So the functional solution is arguably better for extensibility, because extension
    operations are indistinguishable from those (like `fullName`) provided by the
    original authors, whereas the OO solution makes us look for two different types
    of implementation: methods and functions.'
  prefs: []
  type: TYPE_NORMAL
- en: Even if we *do* own the code for the `Customer` class, we should be wary of
    adding methods like `nameForMarketing`. If the class `Customer` is a fundamental
    domain class in our application, lots of other code will depend on it. Adding
    a report for marketing shouldn’t force us to recompile and retest everything,
    but it will if we add a method. So it’s better that we keep `Customer` as small
    as possible and have noncore operations as external functions, even if this means
    they are not as discoverable as methods.
  prefs: []
  type: TYPE_NORMAL
- en: In Kotlin, those functions don’t have to be as hard to find as we’ve made out,
    though; they can be extension functions.
  prefs: []
  type: TYPE_NORMAL
- en: Extension Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kotlin’s extension functions look like methods, but are in fact just functions.
    (As we saw in [Chapter 8](ch08.html#static-methods-to-top-level-functions), technically
    they are *also* methods, because on the JVM all code has to be defined in a method.
    In [“Extension Functions as Methods”](#extension-functions-as-methods), we’ll
    see that extension functions can in fact also be nonstatic methods of another
    class.)
  prefs: []
  type: TYPE_NORMAL
- en: As their name implies, extension functions give us the ability to *extend* the
    operations available on a type. They do this while supporting the intuitive, dot-means-send-a-message
    calling convention of methods, which allows them to be discoverable in the same
    Ctrl-Space way.
  prefs: []
  type: TYPE_NORMAL
- en: 'So we can define an extension function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can call it as if it is a method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: IntelliJ will auto-suggest extension functions along with the actual methods,
    even if they need to be imported to bring them into scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'Java isn’t quite so helpful—it just sees the extension function as a static
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`MarketingStuffKt` is the name of the class containing our top-level declarations
    as static methods; see [Chapter 8](ch08.html#static-methods-to-top-level-functions).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Interestingly, we can’t call the function in the same way from Kotlin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This fails to compile, with the error:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Unresolved reference. None of the following candidates is applicable because
    of receiver type mismatch: public fun Customer.nameForMarketing(): String ...`.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Receiver*, by the way, is the term that Kotlin uses for the object named `this`
    in an extension function (or normal method): the object that receives messages.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that extension functions don’t have any special access to the private members
    of the class that they are extending; they only have the same privileges as normal
    functions in their scope.
  prefs: []
  type: TYPE_NORMAL
- en: Extensions and Function Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Although we can’t call extension functions as normal functions in Kotlin, we
    can assign them to normal function references. So the following compiles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We can invoke these as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use the *with-receiver* references as if they took the receiver
    as the first argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We cannot, however, call the plain references as if they had a receiver. Both
    of these lines fail to compile, with an `Unresolved reference` error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Extension Properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kotlin also supports extension properties. As we discuss in [Chapter 11](ch11.html#methods-to-properties),
    Kotlin property accessors are actually method calls. In the same way that extension
    functions are static functions that are called like methods, extension properties
    are static functions that are called like properties, which are in turn methods.
    Extension properties can’t store any data because they don’t really add fields
    to their class—their value can only be computed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `nameForMarketing` function could have been defined as an extension *property*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In fact, it probably *should* be a property, as we will discuss in [Chapter 11](ch11.html#methods-to-properties).
  prefs: []
  type: TYPE_NORMAL
- en: Most of what we have to say about extension functions applies to extension properties
    unless we specifically distinguish between them.
  prefs: []
  type: TYPE_NORMAL
- en: Extensions Are Not Polymorphic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although invoking an extension function looks like a method call, it is not,
    in fact, sending a message to an object. For polymorphic method calls, Kotlin
    uses the dynamic type of the receiver at runtime to select the method to execute.
    For extensions, Kotlin uses the static type of the receiver at compile time to
    select the function to call.
  prefs: []
  type: TYPE_NORMAL
- en: If we need to use extensions in a polymorphic way, we can often achieve this
    by calling polymorphic methods from our extension functions.
  prefs: []
  type: TYPE_NORMAL
- en: Conversions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have seen extension functions adding operations to a type. Conversions
    from one type to another are a common case. Travelator needs to convert customer
    details to and from JSON and XML. How should we convert from `JsonNode` to `Customer`?
  prefs: []
  type: TYPE_NORMAL
- en: 'We could add a constructor: `Customer(JsonNode)` that knows how to extract
    the relevant data, but it really doesn’t feel right to pollute our `Customer`
    class with dependencies on a specific JSON library, and then maybe an XML parser,
    and then what? The same argument applies to adding conversions to the `JsonNode`
    class. Even if we *could* change its code, pretty soon it would be unmanageable
    with all the `JsonNode.toMyDomainType()` methods.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java, we would write a class of utility functions of the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Or with Nat and Duncan’s preferred naming convention:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling the conversions individually isn’t too horrible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If we need to combine functions, though, things start to go awry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We’re all developers here, and used to reading function invocations. So it’s
    easy to underestimate the cognitive load of searching for the innermost call and
    working your way out through function and method calls to compute how an expression
    evaluates. Not what it evaluates to, just the order in which it evaluates. In
    Kotlin, we can write the conversion as an extension on `JsonNode` and enjoy a
    soothing flow from left to right:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Ahh…that’s much more readable.
  prefs: []
  type: TYPE_NORMAL
- en: Nullable Parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Extensions really come into their own when we work with optional data. When
    we are sending messages to a potentially `null` object, we can use the safe-call
    operator `?.` that we saw in [Chapter 4](ch04.html#optional-to-nullable). That
    doesn’t help with parameters though; to pass a nullable reference as an argument
    to a function that takes a nonnull parameter, we have to wrap the call in conditional
    logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Kotlin’s *scoping functions*, such as `let`, `apply`, and `also`, can help
    here. In particular, `let` converts its receiver into a lambda parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Here the `?.` ensures that `let` is only called when the customer is not `null`,
    meaning that the lambda parameter, `it`, is never null, and can be passed to the
    function within the lambda body. You can think of `?.let` as a safe-call operator
    for (single) arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a function returns a nullable result, and we must pass that result to another
    function that expects a nonnull parameter, the scoping functions start to get
    cumbersome:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Even when we can flatten nested null checks into a pipeline of calls to `let`,
    all this additional mechanism adds syntactic noise and obscures the *intent* of
    the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If we convert the problematic parameters to extension function receivers, we
    can chain calls directly, bringing the application logic to the fore:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: When Nat and Duncan first adopted Kotlin, they soon found that extensions and
    nullability form a virtuous circle. It was easier to process optional data with
    extension functions, so they extracted extensions private to the file or refactored
    functions into extensions where it made logic easier to write. They found that
    the names of these extensions could be more concise than that of an equivalent
    function without obscuring intent. As a result, they wrote more extensions to
    make their application logic concise. Private extensions often proved to be useful
    elsewhere, so they moved them into common modules where they could easily be shared.
    This made it easier to use optional data in other parts of the application, which
    led them to write more extensions, which made application logic more concise…and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: Although extensions are promoted as a way to extend third-party types, the concise
    naming they allow, and nullability in the type system, encourage us to define
    extensions on our own types as well. Part of the grain of Kotlin is the way these
    features interact to smooth our way.
  prefs: []
  type: TYPE_NORMAL
- en: Nullable Receivers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One major difference between invoking a method and calling a function is in
    the treatment of `null` references. If we have a reference that is `null`, we
    can’t send a message to it, because there is nothing to send a message to—the
    JVM throws a `Null​Poin⁠terException` if we try. In contrast, we are able to have
    `null` *parameters*. We may not know what to do with them, but they don’t prevent
    the runtime from finding code to invoke.
  prefs: []
  type: TYPE_NORMAL
- en: Because the receiver in an extension function is actually a parameter, it *can*
    be `null`. So while `anObject.method()` and `anObject.extensionFunction()` look
    like equivalent calls, `method` can never be called if `anObject` is `null`, whereas
    `extensionFunction` can be called with `null`, if the receiver is nullable.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could use this to extract out the steps that generate the reminder in the
    previous pipeline, into an extension on `Trip?`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Note that we have to use the safe-call operator to dereference `this` inside
    the extension. Although `this` is never `null` inside a method, it can be inside
    an extension of a nullable type. A `null` `this` can be surprising if you’re coming
    from Java, where it can never happen, but for extensions, Kotlin treats `this`
    as just another nullable parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can call this function on a nullable `Trip` without the noise of the `?.`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: On the other hand, we’ve made the flow of nullability in the calling function
    harder to understand, because although type-checked, it is not visible in the
    code of the pipelines that calls the extension.
  prefs: []
  type: TYPE_NORMAL
- en: '`Trip?.reminderAt` has another, more obtrusive, drawback: the return type is
    always the nullable `String?` even if called on a nonnullable `Trip`. In that
    case we will find ourselves writing code like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This a bug waiting to happen when code around it changes, because we’ve made
    it impossible for the type checker to detect an incompatible change.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Don’t write extensions on nullable types that return `null` if the receiver
    is `null`. Write an extension on the nonnullable type and use the safe-call operator
    to invoke it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Extensions on nullable types can be useful though, when they return a nonnullable
    result. They act as an escape route from the realm of nullable values back to
    the realm of nonnullable values, terminating a pipeline of safe calls. For example,
    we can make the `reminderAt` extension return some meaningful text even when the
    customer doesn’t have a next trip:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, here are two extension functions that we probably should have introduced
    in [Chapter 4](ch04.html#optional-to-nullable). The first is defined on any nullable
    type, but always returns a nonnull result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This neatly brings up the subject of generic extensions.
  prefs: []
  type: TYPE_NORMAL
- en: Generics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just as with normal functions, extensions can have generic parameters, and things
    become really interesting when the receiver is generic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a useful extension function that for some reason isn’t part of the standard
    library. It is defined as an extension on any type, including `null` references:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use this when we want to debug the value of an expression in place.
    For example, remember this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'If we need to see the value of the customer for debugging, we would normally
    need to pull out a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'With `printed`, we have a function that prints the value of the receiver and
    returns it unchanged, so that we can write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: which is much less disruption and easy to search for before we check in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that even if we had been able to add a method to `Any?`, there is no way
    for a method to say that it returns the same type as its receiver. Had we written:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: the return type would have been `Any`, so we could not then invoke `nameForMarketing()`
    etc. on the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also define extension functions for specialized generic types, for example,
    `Iterable<Customer>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This extension function is applicable to any `Collection<Customer>` but not
    to collections of other types. This allows us to use collections to represent
    domain concepts rather than defining our own types, as we will see in [Chapter 15](ch15.html#encapsulated-collections-to-typealiases).
    We can also extract parts of collections pipelines into named operations; see
    [“Extracting Part of a Pipeline”](ch13.html#extracting-part-of-a-pipeline).
  prefs: []
  type: TYPE_NORMAL
- en: Extension Functions as Methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We normally define extension functions as top-level functions. They can, though,
    be defined *inside* a class definition. In this case they can access the members
    of their own class and *extend* another type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Here `Customer.toJson` has access to two values of `this`. It can refer to
    the `Customer` receiver of the extension function or the `JsonWriter` instance
    of the method. In longhand, the function is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This isn’t a technique that we should use too often (it can be hard to interpret
    which receiver applies without IDE assistance), but it can simplify code by allowing
    the simple left-to-right reading of extension functions while hiding details that
    would complicate things. In particular, it allows DSLs to hide details (like the
    `ObjectMapper`) that clients shouldn’t be bothered by.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring to Extension Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The actual mechanics of converting a static method to an extension function
    are simple, but we have to hone a sense for where an extension function will make
    things better. Let’s work our way through a part of Travelator and see how we
    do.
  prefs: []
  type: TYPE_NORMAL
- en: 'Those clever people in marketing have come up with a spreadsheet that gives
    customers a score according to how valuable they are to the company: their expected
    future spending. They’re constantly tweaking the algorithm, so they don’t want
    us to automate that. Instead, they export a tab-separated file of customer data,
    score, and spend, and we produce a summary report from that file. Here are our
    tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 10.1 [extensions.0:src/test/java/travelator/marketing/HighValueCustomersReportTests.java]](https://java-to-kotlin.dev/code.html?ref=10.1&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=10.1&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that we haven’t gone to town on these, because the people in marketing
    do have a habit of changing their minds, but in essence the report needs to list
    the customers who have a score of 10 or more, sorted by spend, with a final total
    line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 10.2 [extensions.0:src/main/java/travelator/marketing/HighValueCustomersReport.java]](https://java-to-kotlin.dev/code.html?ref=10.2&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=10.2&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that this is already quite a functional (as opposed to object-oriented)
    expression of the solution. This will make it easy to convert to top-level functions,
    and top-level functions are easy to convert to extension functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'But first, here is `CustomerData`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 10.3 [extensions.0:src/main/java/travelator/marketing/CustomerData.java]](https://java-to-kotlin.dev/code.html?ref=10.3&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=10.3&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: This isn’t trying to represent everything about a customer, just the data we
    care about for this report, which is why whoever wrote it just used fields. ([Chapter 11](ch11.html#methods-to-properties)
    discusses this trade-off.) I doubt we (erm, whoever wrote it) would even have
    bothered with `equals` and `hashCode` had it not been for the `emptySpendIs0`
    test. That `double` for spend looks suspicious too, but it hasn’t caused us any
    problems yet, so we’ll suspend our disbelief and just convert the whole thing
    to a Kotlin data class (see [Chapter 5](ch05.html#beans-to-values)) before we
    go on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Normally, that would be a really simple job because of the excellent interop,
    but it turns out that (at the time of writing) the converter cannot believe that
    anyone would stoop to raw field access. So it doesn’t update Java that accesses,
    for example, `customerData.score` to call `customerData.getScore()` (the Kotlin
    property), resulting in a slew of compile failures. Rather than fixing those,
    we revert, and use the “Encapsulate Fields” refactor to convert all the fields
    and field accesses in `Customer` to getters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 10.4 [extensions.1:src/main/java/travelator/marketing/CustomerData.java]](https://java-to-kotlin.dev/code.html?ref=10.4&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=10.4&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The refactoring has also updated the client code to call the getters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 10.5 [extensions.1:src/main/java/travelator/marketing/HighValueCustomersReport.java]](https://java-to-kotlin.dev/code.html?ref=10.5&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=10.5&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The getters allow us to convert `CustomerData` to a Kotlin data class without
    breaking the Java. “Convert Java File to Kotlin File”, followed by adding the
    `data` modifier and deleting the `equals` and `hashCode` overrides, gives us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 10.6 [extensions.2:src/main/java/travelator/marketing/CustomerData.kt]](https://java-to-kotlin.dev/code.html?ref=10.6&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=10.6&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can go ahead and convert `HighValueCustomerReport` to Kotlin, too; it’s
    entirely self-contained. That doesn’t go brilliantly, because `customerDataFrom`
    doesn’t compile after the conversion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 10.7 [extensions.3:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=10.7&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=10.7&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: '[![1](assets/1.png)](#co_introduction_CO18-1)'
  prefs: []
  type: TYPE_NORMAL
- en: '`The integer literal does not conform to the expected type Double`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_introduction_CO18-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Odd formatting.
  prefs: []
  type: TYPE_NORMAL
- en: 'The converter hasn’t been smart enough to know that Kotlin doesn’t coerce the
    integer 0 to double, leading to a compile error. Let’s help IntelliJ out by clicking
    the error and Alt-Entering to fix it, in the hope that it will return the favor
    when the machines rule the world. After a reformat, this gives us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 10.8 [extensions.4:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=10.8&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=10.8&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: As we discussed in [Chapter 8](ch08.html#static-methods-to-top-level-functions),
    the conversion has placed the functions into an `object HighValueCustomersReport`
    so that Java code can still find them. If we try to convert them to top-level
    functions using the techniques in that chapter, we find that dependencies between
    the methods mean that the code doesn’t compile at times. We can solve the problem
    either by moving the private methods first or by just ignoring the compiler until
    the `HighValueCustomersReport` is emptied and removed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 10.9 [extensions.5:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=10.9&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=10.9&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'OK, it’s time to look for places where extension functions can improve the
    code. At the end is the `marketingNameFor` that we saw (a slightly different version
    of) earlier. If we Alt-Enter on the `customer` parameter, IntelliJ will offer
    to “Convert parameter to receiver”. This gives:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 10.10 [extensions.6:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=10.10&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=10.10&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'That `For` in `marketingNameFor` is confusing now that we’ve moved the parameter
    to be the receiver, because the `For` doesn’t have a subject. Let’s “Convert function
    to property” named `marketingName` ([Chapter 11](ch11.html#methods-to-properties)
    explains how and why) and then “Convert to expression body”. Oh, and “Convert
    concatenation to template” on both strings! Phew, that flurry of Alt-Entering
    gives:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 10.11 [extensions.7:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=10.11&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=10.11&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now `formatMoney` is letting us down, so again we can “Convert parameter to
    receiver”, rename to `toMoneyString`, and “Convert to expression body”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 10.12 [extensions.8:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=10.12&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=10.12&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `String.format` rankles a bit. Kotlin would allow us to write `"%#.2f".format(this)`,
    but we prefer swapping the parameter and receiver to give:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 10.13 [extensions.9:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=10.13&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=10.13&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: '`Double.formattedAs` is the first extension function we’ve written that had
    a parameter as well as its receiver. That’s because the others have been very
    specific conversions, but this one is more general. While we’re thinking general,
    `formattedAs` can equally well apply to any type, including `null`, so we can
    upgrade it to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 10.14 [extensions.10:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=10.14&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=10.14&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: It now feels like a good candidate for moving into our library of generally
    useful Kotlin functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, `customerDataFrom` is in our sights. It is currently:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 10.15 [extensions.11:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=10.15&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=10.15&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: Before we go on, let’s observe that `CharSequence.split()`, `String.toRegex()`,
    `Collection<T>.toTypedArray()`, `String.toDouble()`, and `String.toInt()` are
    all extension functions provided by the Kotlin standard library.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s a lot we can tidy up before we address the signature of `customerDataFrom`.
    Kotlin has a `CharSequence.split(delimiters)` that we can use in place of the
    regex. Then we can inline `spend`, followed by Alt-Enter and “Add names to call
    arguments” to help make sense of the constructor call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 10.16 [extensions.12:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=10.16&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=10.16&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 9](ch09.html#multi-to-single-expression-functions) argues in favor
    of single-expression functions. This certainly doesn’t *need* to be a single expression,
    but let’s practice anyway:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 10.17 [extensions.13:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=10.17&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=10.17&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'At last, we can get around to converting to an extension function. Again we
    change the name (to `toCustomerData`) to make sense at the call site:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 10.18 [extensions.14:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=10.18&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=10.18&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the Java in our tests can still call this as a static method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 10.19 [extensions.14:src/test/java/travelator/marketing/HighValueCustomersReportTests.java]](https://java-to-kotlin.dev/code.html?ref=10.19&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=10.19&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s address `summaryFor`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 10.20 [extensions.15:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=10.20&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=10.20&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'That destructuring is odd, but we can get rid of it by hand-converting the
    stream to Kotlin. This isn’t a thing that IntelliJ can do when we wrote this,
    but we give guidance in [Chapter 13](ch13.html#streams-to-sequences). We’ll remove
    the string concatenation while we’re there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 10.21 [extensions.16:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=10.21&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=10.21&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now the familiar combination of converting to an appropriately named single-expression
    extension function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 10.22 [extensions.17:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=10.22&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=10.22&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'At this stage, only `generate` is left unimproved:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 10.23 [extensions.18:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=10.23&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=10.23&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, we currently have to convert Java streams to Kotlin list operations
    by hand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 10.24 [extensions.19:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=10.24&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=10.24&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: '`Appendable.appendLine()` is another extension function that allows us to simplify
    the output stage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 10.25 [extensions.20:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=10.25&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=10.25&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'It feels like we should be able to remove that `// header` comment by extracting
    a function. [“Extracting Part of a Pipeline”](ch13.html#extracting-part-of-a-pipeline)
    details how to extract a function from a chain, but look at what happens when
    we try that technique but don’t convert `withoutHeader` to an extension function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 10.26 [extensions.21:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=10.26&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=10.26&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve lost the nice pipeline flow from left to right, top to bottom: `withoutHeader`
    comes before the `readLines` in the text but after it in execution order. Alt-Enter
    on the `list` parameter in `withoutHeader` and “Convert Parameter to Receiver”
    restores the flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 10.27 [extensions.22:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=10.27&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=10.27&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can make this even more expressive with two more extensions, `List<String>.​to⁠Val⁠uableCustomers()`
    and `CustomerData.outputLine`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 10.28 [extensions.23:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=10.28&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=10.28&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'This still isn’t quite as sweet as we might like, but we’ve proved the point
    of extension functions. Chapters [20](ch20.html#performing-io-to-passing-data)
    and [21](ch21.html#exceptions-to-values) will complete this refactoring. In the
    meantime, here’s the whole file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 10.29 [extensions.23:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=10.29&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=10.29&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: Note that every function except the entry point is a single-expression extension
    function. We haven’t made `generate` an extension function because there isn’t
    a natural parameter to make the receiver; it doesn’t feel like a natural operation
    on `Reader` or `Writer`. That may change when we continue refactoring this code
    in [Chapter 20](ch20.html#performing-io-to-passing-data). Let’s see, shall we?
  prefs: []
  type: TYPE_NORMAL
- en: Moving On
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Extension functions and properties are the unsung heroes of the Kotlin language.
    Their canonical use is to add operations to types we cannot modify ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: However, Kotlin language features and tooling combine to encourage us—quite
    insistently—to write extension functions for our *own* types as well. Kotlin’s
    safe call operator makes it more convenient to call an extension function through
    a potentially null reference than to pass the reference to a function as a parameter
    when it is nonnull. The type of a freestanding generic extension can express relationships
    between the receiver and its result that cannot be expressed by open methods.
    Autocompletion in IntelliJ includes extension functions along with the methods
    that can call on a value, but it does not show you functions that you can pass
    the value to as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, extension functions allow us to write code that is more easily
    discovered, understood, and maintained. Many of the other techniques presented
    in this book build on extension functions, as we will see in [Chapter 15, *Encapsulated
    Collections to Type Aliases*](ch15.html#encapsulated-collections-to-typealiases),
    [Chapter 18, *Open to Sealed Classes*](ch18.html#open-to-sealed-classes), and
    others.
  prefs: []
  type: TYPE_NORMAL
