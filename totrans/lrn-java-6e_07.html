<html><head></head><body><section data-pdf-bookmark="Chapter 7. Collections and Generics" data-type="chapter" epub:type="chapter"><div class="chapter" id="learnjava6-CHP-7">&#13;
<h1><span class="label">Chapter 7. </span>Collections and Generics</h1>&#13;
&#13;
&#13;
<p>As we start to use our growing knowledge of objects to handle more and more interesting problems, one recurring question will emerge. How do we store the data we’re manipulating in the course of solving those problems? We’ll definitely use variables of all the different types, but we’ll also need bigger, fancier storage options. <a data-primary="arrays" data-secondary="and collections" data-secondary-sortas="collections" data-type="indexterm" id="id1384"/><a data-primary="collections framework" data-secondary="and arrays" data-secondary-sortas="arrays" data-type="indexterm" id="id1385"/>The arrays we discussed back in <a data-type="xref" href="ch04.html#learnjava6-CHP-4-SECT-6">“Arrays”</a> are a start, but arrays have some limitations. In this chapter we will see how to get efficient, flexible access to large amounts of data using Java’s idea of collections. We’ll also see how to deal with the various types of data we want to store in these big containers like we do with individual values in variables. That’s where generics come in. We’ll get to those in <a data-type="xref" href="#learnjava6-CHP-7-SECT-2">“Type Limitations”</a>.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Collections" data-type="sect1"><div class="sect1" id="learnjava6-CHP-7-SECT-1">&#13;
<h1>Collections</h1>&#13;
&#13;
<p><em>Collections</em> are <a data-primary="collections framework" data-type="indexterm" id="ix_collect_ch7"/>data structures that are fundamental to all types of programming. Whenever we need to refer to a group of objects, we have some kind of collection. At the core language level, Java supports collections in the form of arrays. <a data-primary="Hashtable class" data-type="indexterm" id="id1386"/><a data-primary="java.util package" data-type="indexterm" id="id1387"/><a data-primary="Vector class" data-type="indexterm" id="id1388"/>But arrays are static, and because they have a fixed length, they are awkward for groups of things that grow and shrink over the lifetime of an application. Arrays are also bad at representing abstract relationships between objects. In the early days, the Java platform had only two basic classes to address these needs: the <code>java.util.Vector</code> class, which represents a dynamic list of objects, and the <code>java.util.Hashtable</code> class, which holds a map of key/value pairs. Today, Java has a more comprehensive approach called the <em>collections framework</em>. The framework standardizes how you work with a variety of collections. The older classes still exist, but they have been retrofitted into the framework (with some eccentricities) and are generally no longer used.</p>&#13;
&#13;
<p>Though conceptually simple, collections are one of the most powerful parts of any programming language. They implement data structures that lie at the heart of managing complex problems. A great deal of basic computer science is devoted to describing the most efficient ways to implement certain types of algorithms over collections. (How do you quickly find something in a large collection? How do you sort items in a collection? How do you add or remove items efficiently?) Having these tools at your disposal and understanding how to use them can make your code both much smaller and faster. It can also save you from reinventing the wheel.</p>&#13;
&#13;
<p>The original collections framework had two major drawbacks. The first was that collections were by necessity untyped and worked only with undifferentiated <code>Object</code>s instead of specific types like <code>Date</code>s and <code>String</code>s. This meant that you had to perform a type cast every time you took an object out of a collection. This flew in the face of Java’s compile-time type safety. But in practice, this was less a problem than it was just plain cumbersome and tedious. The second issue was that, for practical reasons, collections could work only with objects and not with primitive types. This meant that any time you wanted to put a number or other primitive type into a collection, you had to store it in a wrapper class first and unpack it later upon retrieving it. This combination of factors made code working with collections less readable and more dangerous.</p>&#13;
&#13;
<p>Generic types (again, more on this in <a data-type="xref" href="#learnjava6-CHP-7-SECT-2">“Type Limitations”</a>) make it possible for truly type-safe collections to be under the control of the programmer. Alongside generics, autoboxing and unboxing of primitive types means that you can generally treat objects and primitives as equals where collections are concerned. The combination of these new features adds a bit of safety and can significantly reduce the amount of code you write. As we’ll see, all of the collections classes now take advantage of these features.</p>&#13;
&#13;
<p>The collections framework is based around a handful of interfaces in the <code>java.util</code> package. <a data-primary="Collection interface" data-type="indexterm" id="id1389"/><a data-primary="collections framework" data-secondary="Collection interface" data-type="indexterm" id="id1390"/><a data-primary="java.util package" data-secondary="Collection interface" data-type="indexterm" id="id1391"/>These interfaces are divided into two hierarchies. The first hierarchy descends from the <code>Collection</code> interface. This interface (and its descendants) represents a container that holds other objects. The second, separate hierarchy is based on the <code>Map</code> interface, another container that represents a group of key/value pairs where the key can be used to retrieve the value in an efficient way.<a data-primary="" data-startref="ix_collect_api_ch7" data-type="indexterm" id="id1392"/></p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The Collection Interface" data-type="sect2"><div class="sect2" id="learnjava6-CHP-7-SECT-1.1">&#13;
<h2>The Collection Interface</h2>&#13;
&#13;
<p>The mother of all collections is an interface appropriately named <code>Collection</code>. It serves as a container that holds other objects, its <em>elements</em>. It doesn’t specify exactly how the objects are organized; it doesn’t say, for example, whether duplicate objects are allowed or whether the objects are ordered in any way. These kinds of details are left to child interfaces or implementing classes. Nevertheless, the <code>Collection</code> interface defines some basic operations common to all collections:</p>&#13;
<dl>&#13;
<dt><code>public boolean add(</code> <em><code>element</code></em> <code>)</code></dt>&#13;
<dd>&#13;
<p>Adds the <a data-primary="add() method" data-secondary="Collection" data-type="indexterm" id="id1393"/>supplied object to this collection. If the operation succeeds, this method returns <code>true</code>. If the object already exists in this collection and the collection does not permit duplicates, <code>false</code> is returned. Furthermore, some collections are read-only. Those collections throw an <code>UnsupportedOperationException</code> if this method is called.</p>&#13;
</dd>&#13;
<dt><code>public boolean remove(</code> <em><code>element</code></em> <code>)</code></dt>&#13;
<dd>&#13;
<p>Removes the <a data-primary="remove() method" data-secondary="Collection" data-type="indexterm" id="id1394"/>specified object from this collection. Like the <code>add()</code> method, this method returns <code>true</code> if the object is removed from the collection. If the object doesn’t exist in this collection, <code>false</code> is returned. Read-only collections throw an <code>UnsupportedOperationException</code> if this method is called.</p>&#13;
</dd>&#13;
<dt><code>public boolean contains(</code> <em><code>element</code></em> <code>)</code></dt>&#13;
<dd>&#13;
<p>Returns <code>true</code> if the <a data-primary="contains() method" data-secondary="Collection" data-type="indexterm" id="id1395"/>collection contains the specified object.</p>&#13;
</dd>&#13;
<dt><code>public int size()</code></dt>&#13;
<dd>&#13;
<p>Returns the <a data-primary="int size() method" data-secondary="Collection" data-type="indexterm" id="id1396"/>number of elements in this collection.</p>&#13;
</dd>&#13;
<dt><code>public boolean isEmpty()</code></dt>&#13;
<dd>&#13;
<p>Returns <code>true</code> if this <a data-primary="isEmpty() method, Collection" data-type="indexterm" id="id1397"/>collection has no elements.</p>&#13;
</dd>&#13;
<dt><code>public Iterator iterator()</code></dt>&#13;
<dd>&#13;
<p>Examines all the <a data-primary="iterator() method, Collection" data-type="indexterm" id="id1398"/>elements in this collection. This method returns an <code>Iterator</code>, which is an object you can use to step through the collection’s elements. We’ll talk more about iterators in the next section.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>Additionally, the <a data-primary="addAll() method, Collection" data-type="indexterm" id="id1399"/><a data-primary="containsAll() method, Collection" data-type="indexterm" id="id1400"/><a data-primary="removeAll() method, Collection" data-type="indexterm" id="id1401"/>methods <code>addAll()</code>, <code>removeAll()</code>, and <code>containsAll()</code> accept another <code>Collection</code> and add, remove, or test for all of the elements of the supplied collection.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Collection Types" data-type="sect2"><div class="sect2" id="learnjava6-CHP-7-SECT-1.2">&#13;
<h2>Collection Types</h2>&#13;
&#13;
<p>The <code>Collection</code> interface has three child <a data-primary="type system" data-secondary="collections" data-type="indexterm" id="ix_type_collect"/><a data-primary="collections framework" data-secondary="types" data-type="indexterm" id="ix_collect_types"/><a data-primary="Set interface" data-type="indexterm" id="id1402"/>interfaces. <code>Set</code> represents a collection in which duplicate elements are not allowed. <code>List</code> is a collection whose elements have a specific order. The <code>Queue</code> interface is a buffer for objects with a notion of a “head” element that’s next in line for processing.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Set" data-type="sect3"><div class="sect3" id="learnjava6-CHP-7-SECT-1.2.1">&#13;
<h3>Set</h3>&#13;
&#13;
<p><code>Set</code> has no <a data-primary="headSet() method" data-type="indexterm" id="id1403"/><a data-primary="SortedSet class" data-type="indexterm" id="id1404"/><a data-primary="subSet() method" data-type="indexterm" id="id1405"/><a data-primary="tailSet() method" data-type="indexterm" id="id1406"/><a data-primary="first() set call" data-type="indexterm" id="id1407"/><a data-primary="last() set call" data-type="indexterm" id="id1408"/>methods besides the ones it inherits from <code>Collection</code>. It simply enforces its no-duplicates rule. If you try to add an element that already exists in a <code>Set</code>, the <code>add()</code> method simply returns <code>false</code>. <code>SortedSet</code> maintains elements in a prescribed order; like a sorted list that cannot contain duplicates. You can retrieve subsets (which are also sorted) using the <code>subSet()</code>, <code>headSet()</code>, and <code>tailSet()</code> methods. These methods accept one or two elements that mark the boundaries. The <code>first()</code> and <code>last()</code> calls provide access to the first and last elements, respectively. <a data-primary="comparator() method, Set" data-type="indexterm" id="id1409"/>And the <code>comparator()</code> method returns the object used to compare elements (more on this in <a data-type="xref" href="#learnjava6-CHP-7-SECT-7">“A Closer Look: The sort() Method”</a>).</p>&#13;
&#13;
<p><code>NavigableSet</code> extends <code>SortedSet</code> and adds <a data-primary="SortedSet class" data-type="indexterm" id="id1410"/><a data-primary="NavigableSet class" data-type="indexterm" id="id1411"/>methods for finding the closest match greater or lesser than a target value within the sort order of the <code>Set</code>. You can implement this interface efficiently using techniques such as skip lists, which make finding ordered elements fast.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="List" data-type="sect3"><div class="sect3" id="learnjava6-CHP-7-SECT-1.2.2">&#13;
<h3>List</h3>&#13;
&#13;
<p>The next <a data-primary="List interface" data-type="indexterm" id="id1412"/>child interface of <code>Collection</code> is <code>List</code>. A <code>List</code> is an ordered collection, similar to an array but with methods for manipulating the position of elements in &#13;
<span class="keep-together">the list</span>:</p>&#13;
<dl>&#13;
<dt><code>public boolean add(E</code> <em><code>element</code></em> <code>)</code></dt>&#13;
<dd>&#13;
<p>Adds the <a data-primary="add() method" data-secondary="List" data-type="indexterm" id="id1413"/>specified element to the end of the list.</p>&#13;
</dd>&#13;
<dt><code>public void add(int</code> <em><code>index</code></em> <code>, E</code> <em><code>element</code></em> <code>)</code></dt>&#13;
<dd>&#13;
<p>Inserts the given <a data-primary="void add() method, List" data-type="indexterm" id="id1414"/>object at the supplied position in the list. If the position is less than zero or greater than the list length, an <code>IndexOutOfBoundsException</code> will be thrown. The element that was previously at the supplied position, and all elements after it, are moved up one index position.</p>&#13;
</dd>&#13;
<dt><code>public void remove(int</code> <em><code>index</code></em> <code>)</code></dt>&#13;
<dd>&#13;
<p>Removes the <a data-primary="remove() method" data-secondary="List" data-type="indexterm" id="id1415"/>element at the specified position. All subsequent elements move down one index position.</p>&#13;
</dd>&#13;
<dt><code>public E get(int</code> <em><code>index</code></em> <code>)</code></dt>&#13;
<dd>&#13;
<p>Returns the <a data-primary="get() method" data-secondary="List" data-type="indexterm" id="id1416"/>element at the given position but does not change the list.</p>&#13;
</dd>&#13;
<dt><code>public Object set(int</code> <em><code>index</code></em> <code>, E</code> <em><code>element</code></em> <code>)</code></dt>&#13;
<dd>&#13;
<p>Changes the <a data-primary="Object set() method, List" data-type="indexterm" id="id1417"/>element at the given position to the specified object. There must already be an object at the index or else an <code>IndexOutOfBoundsException</code> is thrown. No other elements of the list are affected.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>The <a data-primary="E element type" data-type="indexterm" id="id1418"/><a data-primary="parameterized types" data-type="indexterm" id="id1419"/><a data-primary="type system" data-secondary="parameterized types" data-type="indexterm" id="id1420"/>type <code>E</code> in these methods refers to the parameterized element type of the <code>List</code> class. <code>Collection</code>, <code>Set</code>, and <code>List</code> are all interface types. This is an example of the Generics feature we hinted at in the introduction to this chapter, and we’ll look at concrete implementations of these shortly.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Queue" data-type="sect3"><div class="sect3" id="learnjava6-CHP-7-SECT-1.2.3">&#13;
<h3>Queue</h3>&#13;
&#13;
<p>A <code>Queue</code> is a collection that acts like a buffer for elements. The queue maintains the insertion order of items placed into it and has the notion of a “head” item. <a data-primary="FIFO (first in, first out), queues" data-type="indexterm" id="id1421"/><a data-primary="first in, first out (FIFO), queues" data-type="indexterm" id="id1422"/><a data-primary="last in, first out (LIFO), queues" data-type="indexterm" id="id1423"/><a data-primary="LIFO (last in, first out), queues" data-type="indexterm" id="id1424"/>Queues may be first in, first out (FIFO or “in order”) or last in, first out (LIFO, sometimes “most recent” or “reverse” order), depending on the implementation:</p>&#13;
<dl>&#13;
<dt><code>public boolean offer(E element)</code>, <code>public boolean add(E element)</code></dt>&#13;
<dd>&#13;
<p>The <code>offer()</code> method <a data-primary="add() method" data-secondary="Queue" data-type="indexterm" id="id1425"/><a data-primary="offer() method, Queue" data-type="indexterm" id="id1426"/>attempts to place the element into the queue, returning <code>true</code> if successful. Different <code>Queue</code> types may have different limits or restrictions on element types (including capacity). This method differs from the <code>add()</code> method inherited from <code>Collection</code> in that it returns a Boolean value instead of throwing an exception to indicate that the collection cannot accept the element.</p>&#13;
</dd>&#13;
<dt><code>public E</code> <code>poll()</code>, <code>public E remove()</code></dt>&#13;
<dd>&#13;
<p>The <code>poll()</code> method <a data-primary="poll() method, Queue" data-type="indexterm" id="id1427"/><a data-primary="remove() method" data-secondary="Queue" data-type="indexterm" id="id1428"/>removes the element at the head of the queue and returns it. This method differs from the <code>Collection</code> method <code>remove()</code> in that if the queue is empty, <code>null</code> is returned instead of throwing an exception.</p>&#13;
</dd>&#13;
<dt><code>public E</code> <code>peek()</code></dt>&#13;
<dd>&#13;
<p>Returns the <a data-primary="peek() method, Queue" data-type="indexterm" id="id1429"/>head element <em>without</em> removing it from the queue. If the queue is empty, <code>null</code> is returned.<a data-primary="" data-startref="ix_collect_types" data-type="indexterm" id="id1430"/><a data-primary="" data-startref="ix_type_collect" data-type="indexterm" id="id1431"/></p>&#13;
</dd>&#13;
</dl>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The Map Interface" data-type="sect2"><div class="sect2" id="learnjava6-CHP-7-SECT-1.3">&#13;
<h2>The Map Interface</h2>&#13;
&#13;
<p>The <a data-primary="Map interface" data-type="indexterm" id="ix_map_inter"/><a data-primary="java.util package" data-secondary="Map interface" data-type="indexterm" id="ix_java_util_map"/><a data-primary="collections framework" data-secondary="Map interface" data-type="indexterm" id="ix_collect_map"/>collections framework also includes the <code>java.util.Map</code>, which is a collection of key/value pairs. Other names for a map are “dictionary” or “associative array.” Maps store and retrieve elements with key values; they are very useful for things like caches and minimalist databases. When you store a value in a map, you associate a key object with that value. When you need to look up the value, the map retrieves it using &#13;
<span class="keep-together">the key</span>.</p>&#13;
&#13;
<p>With generics (that <code>E</code> type again), a <code>Map</code> type is parameterized with two types: one for the keys and one for the values. The following snippet uses a <code>HashMap</code>, which is an efficient but unordered type of map implementation that we’ll discuss later:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="n">Map</code><code class="o">&lt;</code><code class="n">String</code><code class="p">,</code><code class="w"> </code><code class="n">Date</code><code class="o">&gt;</code><code class="w"> </code><code class="n">dateMap</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">HashMap</code><code class="o">&lt;</code><code class="n">String</code><code class="p">,</code><code class="w"> </code><code class="n">Date</code><code class="o">&gt;</code><code class="p">();</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">dateMap</code><code class="p">.</code><code class="na">put</code><code class="p">(</code><code class="s">"today"</code><code class="p">,</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">Date</code><code class="p">());</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">Date</code><code class="w"> </code><code class="n">today</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">dateMap</code><code class="p">.</code><code class="na">get</code><code class="p">(</code><code class="s">"today"</code><code class="p">);</code><code class="w"/></pre>&#13;
&#13;
<p>In legacy code, maps simply map <code>Object</code> types to <code>Object</code> types and require an appropriate cast to retrieve values.</p>&#13;
&#13;
<p>The basic operations on <code>Map</code> are straightforward. In the following methods, the type <code>K</code> refers to the key parameter type, and the type <code>V</code> refers to the value parameter type:</p>&#13;
<dl>&#13;
<dt><code>public V put(K</code> <em><code>key</code></em> <code>, V</code> <em><code>value</code></em> <code>)</code></dt>&#13;
<dd>&#13;
<p>Adds the <a data-primary="put() method" data-secondary="Map" data-type="indexterm" id="id1432"/>specified key/value pair to the map. If the map already contains a value for the specified key, the old value is replaced and returned as the result.</p>&#13;
</dd>&#13;
<dt><code>public V get(K</code> <em><code>key</code></em> <code>)</code></dt>&#13;
<dd>&#13;
<p>Retrieves the <a data-primary="get() method" data-secondary="Map" data-type="indexterm" id="id1433"/>value corresponding to <code>key</code> from the map.</p>&#13;
</dd>&#13;
<dt><code>public V remove(K</code> <em><code>key</code></em> <code>)</code></dt>&#13;
<dd>&#13;
<p>Removes the <a data-primary="remove() method" data-secondary="Map" data-type="indexterm" id="id1434"/>value corresponding to <code>key</code> from the map. The value removed is returned.</p>&#13;
</dd>&#13;
<dt><code>public int size()</code></dt>&#13;
<dd>&#13;
<p>Returns the <a data-primary="int size() method" data-secondary="Map" data-type="indexterm" id="id1435"/>number of key/value pairs in this map.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>You can retrieve all the keys or values in the map using the following methods:</p>&#13;
<dl>&#13;
<dt><code>public Set keySet()</code></dt>&#13;
<dd>&#13;
<p>This <a data-primary="keySet() method, Map" data-type="indexterm" id="id1436"/>method returns a <code>Set</code> that contains all the keys in this map.</p>&#13;
</dd>&#13;
<dt><code>public Collection values()</code></dt>&#13;
<dd>&#13;
<p>Use this <a data-primary="values() method, Map" data-type="indexterm" id="id1437"/>method to retrieve all the values in this map. The returned <code>Collection</code> can contain duplicate elements.</p>&#13;
</dd>&#13;
<dt><code>public Set entrySet()</code></dt>&#13;
<dd>&#13;
<p>This <a data-primary="entrySet() method" data-secondary="Map" data-type="indexterm" id="id1438"/>method returns a <code>Set</code> that contains all the key/value pairs (as <code>Map.Entry</code> objects) in this map.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p><code>Map</code> has one <a data-primary="SortedMap class" data-type="indexterm" id="id1439"/>child interface, <code>SortedMap</code>. A <code>SortedMap</code> maintains its key/value pairs sorted in a particular order according to the keys. <a data-primary="subMap() method" data-type="indexterm" id="id1440"/><a data-primary="tailMap() method" data-type="indexterm" id="id1441"/><a data-primary="comparator() method, Set" data-type="indexterm" id="id1442"/><a data-primary="headMap() method" data-type="indexterm" id="id1443"/>It provides the <code>subMap()</code>, <code>headMap()</code>, and <code>tailMap()</code> methods for retrieving sorted map subsets. Like <code>SortedSet</code>, it also provides a <code>comparator()</code> method, which returns an object that determines how the map keys are sorted. We’ll talk more about that in <a data-type="xref" href="#learnjava6-CHP-7-SECT-7">“A Closer Look: The sort() Method”</a>. <a data-primary="NavigableMap class" data-type="indexterm" id="id1444"/>Java 7 added a <code>NavigableMap</code> with functionality parallel to that of <code>NavigableSet</code>; namely, it adds methods to search the sorted elements for an element greater or lesser than a target value.</p>&#13;
&#13;
<p>Finally, we should make it clear that although they’re related, <code>Map</code> is not literally a type of <code>Collection</code> (<code>Map</code> does not extend the <code>Collection</code> interface). You might wonder why. All of the methods of the <code>Collection</code> interface would appear to make sense for <code>Map</code>, except for <code>iterator()</code>. A <code>Map</code>, again, has two sets of objects: keys and values, and separate iterators for each. This is why a <code>Map</code> does not implement a <code>Collection</code>. If you do want a <code>Collection</code>-like view of a <code>Map</code> with both keys and values, you can use the <code>entrySet()</code> method.</p>&#13;
&#13;
<p>One more note about maps: <a data-primary="null reference (value)" data-type="indexterm" id="id1445"/>some map implementations (including Java’s standard <code>HashMap</code>) allow <code>null</code> to be used as a key or value, but others do not.<a data-primary="" data-startref="ix_collect_map" data-type="indexterm" id="id1446"/><a data-primary="" data-startref="ix_java_util_map" data-type="indexterm" id="id1447"/><a data-primary="" data-startref="ix_map_inter" data-type="indexterm" id="id1448"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Type Limitations" data-type="sect1"><div class="sect1" id="learnjava6-CHP-7-SECT-2">&#13;
<h1>Type Limitations</h1>&#13;
&#13;
<p>Generics are about <a data-primary="type system" data-secondary="limitations on types in collections" data-type="indexterm" id="ix_type_limit_collect"/><a data-primary="generics" data-type="indexterm" id="id1449"/><a data-primary="collections framework" data-secondary="limitations on types" data-type="indexterm" id="ix_collect_type_limit"/>abstraction. Generics let you create classes and methods that work in the same way on different types of objects. The term <em>generic</em> comes from the idea that we’d like to be able to write general algorithms that can be broadly reused for many types of objects rather than having to adapt our code to fit each circumstance. This concept is not new; it is the impetus behind object-oriented programming itself. Java generics do not so much add new capabilities to the language as they make reusable Java code easier to write and easier to read.</p>&#13;
&#13;
<p>Generics take <a data-primary="parameterized types" data-type="indexterm" id="id1450"/><a data-primary="type system" data-secondary="parameterized types" data-type="indexterm" id="id1451"/>reuse to the next level by making the <em>type</em> of the objects we work with an explicit parameter of the generic code. For this reason, generics are also referred to as <em>parameterized types</em>. In the case of a generic class, the developer specifies a type as a parameter (an argument) whenever they use the generic type. The class is parameterized by the supplied type to which the code adapts itself.</p>&#13;
&#13;
<p>In other languages, <a data-primary="templates" data-type="indexterm" id="id1452"/>generics are sometimes referred to as <em>templates</em>, which is more of an implementation term. Templates are like intermediate classes, waiting for their type parameters so that they can be used. Java takes a different path, which has both benefits and drawbacks that we’ll describe in detail in this chapter.</p>&#13;
&#13;
<p>There is much to say about Java generics. Some of the fine points may seem a bit obscure at first, but don’t get discouraged. The vast majority of what you’ll do with generics—using existing classes such as <code>List</code> and <code>Set</code>, for example—is easy and intuitive. Designing and creating your own generics requires a more careful understanding and will come with a little patience and tinkering.</p>&#13;
&#13;
<p>We begin our discussion in that intuitive space with the most compelling case for generics: the container classes and collections we just covered. Next, we take a step back and look at the good, bad, and ugly of how Java generics work. We conclude by looking at a couple of real-world generic classes in Java.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Containers: Building a Better Mousetrap" data-type="sect2"><div class="sect2" id="learnjava6-CHP-7-SECT-2.1">&#13;
<h2>Containers: Building a Better Mousetrap</h2>&#13;
&#13;
<p>Recall that in an <a data-primary="containers" data-type="indexterm" id="ix_contain_ch7"/><a data-primary="polymorphism" data-type="indexterm" id="id1453"/>object-oriented programming language like Java, <em>polymorphism</em> means that objects are always interchangeable to some degree. Any child of a type of object can serve in place of its parent type and, ultimately, every object is a child of <code>java.lang.Object</code>: the object-oriented “Eve,” so to speak.</p>&#13;
&#13;
<p>It is <a data-primary="java.lang package" data-secondary="Object interface" data-type="indexterm" id="id1454"/><a data-primary="key-value pairs, Map" data-type="indexterm" id="id1455"/>natural for the most general types of containers in Java to work with the type <code>Object</code> so that they can hold just about anything. By <em>containers</em>, we mean classes that hold instances of other classes in some way. The Java collections framework we looked at in the previous section is the best example of containers. <code>List</code>, to recap, holds an ordered collection of elements of type <code>Object</code>. And <code>Map</code> holds an association of key/value pairs, with the keys and values also being of the most general type, <code>Object</code>. With a little help from wrappers for primitive types, this arrangement has served us well. But (not to get too Zen on you), a “collection of any type” is also a “collection of no type,” and working with <code>Object</code>s pushes a great deal of responsibility onto the developer.</p>&#13;
&#13;
<p>It’s kind of like a costume party for objects where everybody is wearing the same mask and disappears into the crowd of the collection. Once objects are dressed as the <code>Object</code> type, the compiler can no longer see the real types and loses track of them. It’s up to the user to pierce the anonymity of the objects later by using a type cast. And like attempting to yank off a partygoer’s fake beard, you’d better have the cast correct or you’ll get an unwelcome surprise:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="n">Date</code><code class="w"> </code><code class="n">date</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">Date</code><code class="p">();</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">List</code><code class="w"> </code><code class="n">list</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">ArrayList</code><code class="p">();</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">list</code><code class="p">.</code><code class="na">add</code><code class="p">(</code><code class="n">date</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="c1">// other code that might add or remove elements ...</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">Date</code><code class="w"> </code><code class="n">firstElement</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">(</code><code class="n">Date</code><code class="p">)</code><code class="n">list</code><code class="p">.</code><code class="na">get</code><code class="p">(</code><code class="mi">0</code><code class="p">);</code><code class="w"> </code><code class="c1">// Is the cast correct? Maybe.</code><code class="w"/></pre>&#13;
&#13;
<p>The <code>List</code> interface has an <code>add()</code> method <a data-primary="ArrayList" data-type="indexterm" id="id1456"/><a data-primary="collections framework" data-secondary="ArrayList" data-type="indexterm" id="id1457"/><a data-primary="add() method" data-secondary="List" data-type="indexterm" id="id1458"/>that accepts any type of <code>Object</code>. Here, we assigned an instance of <code>ArrayList</code>, which is simply an implementation of the <code>List</code> interface, and added a <code>Date</code> object. Is the cast in this example correct? It depends on what happens in the elided “other code” period of time.</p>&#13;
&#13;
<p>The Java compiler knows this type of activity is fraught and currently issues warnings when you add elements to a simple <code>ArrayList</code>, as above. We can see this with a little <em>jshell</em> detour. After importing from the <code>java.util</code> and <code>javax.swing</code> packages, try creating an <code>ArrayList</code> and add a few disparate elements:</p>&#13;
&#13;
<pre class="jshell" data-type="programlisting">jshell&gt; import java.util.ArrayList;&#13;
&#13;
jshell&gt; import javax.swing.JLabel;&#13;
&#13;
jshell&gt; ArrayList things = new ArrayList();&#13;
things ==&gt; []&#13;
&#13;
jshell&gt; things.add("Hi there");&#13;
|  Warning:&#13;
|  unchecked call to add(E) as a member of the raw type java.util.ArrayList&#13;
|  things.add("Hi there");&#13;
|  ^--------------------^&#13;
$3 ==&gt; true&#13;
&#13;
jshell&gt; things.add(new JLabel("Hi there"));&#13;
|  Warning:&#13;
|  unchecked call to add(E) as a member of the raw type java.util.ArrayList&#13;
|  things.add(new JLabel("Hi there"));&#13;
|  ^--------------------------------^&#13;
$5 ==&gt; true&#13;
&#13;
jshell&gt; things&#13;
things ==&gt; [Hi there, javax.swing.JLabel[...,text=Hi there,...]]</pre>&#13;
&#13;
<p>You can see that the warning is the same no matter what type of object you <code>add()</code>. In the last step, where we display the contents of <code>things</code>, both the plain <code>String</code> object and the <code>JLabel</code> object are happily in the list. The compiler is not worried about using disparate types; it is helpfully warning you that it will not know whether casts such as the <code>(Date)</code> cast above will work at runtime.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Can Containers Be Fixed?" data-type="sect2"><div class="sect2" id="learnjava6-CHP-7-SECT-2.2">&#13;
<h2>Can Containers Be Fixed?</h2>&#13;
&#13;
<p>It’s natural to ask if there is a way to make this situation better. What if we know that we are only going to put <code>Date</code>s into our list? Can’t we just make our own list that only accepts <code>Date</code> objects, get rid of the cast, and let the compiler help us again? The answer, perhaps surprisingly, is no. At least, not in a very satisfying way.</p>&#13;
&#13;
<p>Our first instinct may be to try to “override” the methods of <code>ArrayList</code> in a subclass. But of course, rewriting the <code>add()</code> method in a subclass would not actually override anything; it would add a new <em>overloaded</em> method:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="kd">public</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">add</code><code class="p">(</code><code class="n">Object</code><code class="w"> </code><code class="n">o</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="p">...</code><code class="w"> </code><code class="p">}</code><code class="w"> </code><code class="c1">// still here</code><code class="w"/>&#13;
<code class="w">    </code><code class="kd">public</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">add</code><code class="p">(</code><code class="n">Date</code><code class="w"> </code><code class="n">d</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="p">...</code><code class="w"> </code><code class="p">}</code><code class="w">   </code><code class="c1">// overloaded method</code><code class="w"/></pre>&#13;
&#13;
<p>The resulting object still accepts any kind of object—it just invokes different methods to get there.</p>&#13;
&#13;
<p>Moving along, we might take on a bigger task. For example, we might write our own <code>DateList</code> class that does not extend <code>ArrayList</code> but rather delegates the guts of its methods to the <code>ArrayList</code> implementation. With a fair amount of tedious work, that would get us an object that does everything a <code>List</code> does but works with <code>Date</code>s in a way that both the compiler and the runtime environment can understand and enforce. However, we’ve now shot ourselves in the foot because our container is no longer an implementation of <code>List</code>. That means we can’t use it interoperably with all of the utilities that deal with collections, such as <code>Collections</code>.<code>sort()</code>, or add it to another collection with the <code>Collection addAll()</code> method.</p>&#13;
&#13;
<p>To generalize, the problem is that instead of refining the behavior of our objects, what we really want to do is to change their contract with the user. We want to adapt their method signatures to a more specific type, and polymorphism doesn’t allow that. So are we stuck with <code>Object</code>s for our collections? That’s where generics come in.<a data-primary="" data-startref="ix_collect_ch7" data-type="indexterm" id="id1459"/><a data-primary="" data-startref="ix_collect_type_limit" data-type="indexterm" id="id1460"/><a data-primary="" data-startref="ix_contain_ch7" data-type="indexterm" id="id1461"/><a data-primary="" data-startref="ix_type_limit_collect" data-type="indexterm" id="id1462"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Enter Generics" data-type="sect1"><div class="sect1" id="learnjava6-CHP-7-SECT-3">&#13;
<h1>Enter Generics</h1>&#13;
&#13;
<p>As we <a data-primary="type parameters" data-seealso="parameterized types" data-type="indexterm" id="id1463"/><a data-primary="generics" data-type="indexterm" id="ix_generics_ch7"/><a data-primary="type parameters, generics" data-type="indexterm" id="id1464"/><a data-primary="type system" data-secondary="generics in" data-type="indexterm" id="type_generics"/><a data-primary="generics" data-secondary="types in" data-type="indexterm" id="ix_generic_type"/>noted when introducing the type limitations in the previous section, generics enhance the syntax of classes that allow us to specialize the class for a given type or set of types. A generic class requires one or more <em>type parameters</em> wherever we refer to the class type. It uses them to customize itself.</p>&#13;
&#13;
<p>If you look at the <a data-primary="List interface" data-secondary="and generics" data-secondary-sortas="generics" data-type="indexterm" id="ix_list_generic"/>source or Javadoc for the <code>List</code> class, for example, you’ll see it defines something like this:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code><code class="w"> </code><code class="kd">class</code> <code class="nc">List</code><code class="o">&lt;</code><code class="w"> </code><code class="n">E</code><code class="w"> </code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="c1">// ...</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">public</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">add</code><code class="p">(</code><code class="n">E</code><code class="w"> </code><code class="n">element</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="p">...</code><code class="w"> </code><code class="p">}</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">public</code><code class="w"> </code><code class="n">E</code><code class="w"> </code><code class="nf">get</code><code class="p">(</code><code class="kt">int</code><code class="w"> </code><code class="n">i</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="p">...</code><code class="w"> </code><code class="p">}</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>The identifier <code>E</code> between the angle brackets (<code>&lt;&gt;</code>) is a <em>type parameter</em>.<sup><a data-type="noteref" href="ch07.html#id1465" id="id1465-marker">1</a></sup> It indicates that the class <code>List</code> is generic and requires a Java type as an argument to make it complete. The name <code>E</code> is arbitrary, but there are conventions that we’ll see as we go on. In this case, the type parameter <code>E</code> represents the type of elements we want to store in the list. The <code>List</code> class refers to the type parameter within its body and methods as if it were a real type, to be substituted later. The type parameter may be used to declare instance variables, arguments to methods, and the return type of methods. In this case, <code>E</code> is used as the type for the elements we’ll be adding via the <code>add()</code> method and for the return type of the <code>get()</code> method. Let’s see how to use it.</p>&#13;
&#13;
<p>The same angle bracket syntax supplies the type parameter when we want to use the <code>List</code> type:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="n">List</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code><code class="w"> </code><code class="n">listOfStrings</code><code class="p">;</code><code class="w"/></pre>&#13;
&#13;
<p>In this snippet, we declared a variable called <code>listOfStrings</code> using the generic type <code>List</code> with a type parameter of <code>String</code>. <code>String</code> refers to the <code>String</code> class, but we could have a specialized <code>List</code> with any Java class type. For example:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="n">List</code><code class="o">&lt;</code><code class="n">Date</code><code class="o">&gt;</code><code class="w"> </code><code class="n">dates</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">List</code><code class="o">&lt;</code><code class="n">java</code><code class="p">.</code><code class="na">math</code><code class="p">.</code><code class="na">BigDecimal</code><code class="o">&gt;</code><code class="w"> </code><code class="n">decimals</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">List</code><code class="o">&lt;</code><code class="n">HelloJava</code><code class="o">&gt;</code><code class="w"> </code><code class="n">greetings</code><code class="p">;</code><code class="w"/></pre>&#13;
&#13;
<p>Completing the <a data-primary="instantiating the type" data-type="indexterm" id="id1466"/><a data-primary="invoking the type" data-type="indexterm" id="id1467"/>type by supplying its type parameter is called <em>instantiating the type</em>. It is also sometimes called <em>invoking the type</em>, by analogy with invoking a method and supplying its arguments. Whereas with a regular Java type we simply refer to the type by name, a generic type like <code>List&lt;&gt;</code> must be instantiated with parameters wherever it is used.<sup><a data-type="noteref" href="ch07.html#id1468" id="id1468-marker">2</a></sup> Specifically, this means that we must instantiate the type everywhere types can appear: as the declared type of a variable (as shown in this code snippet), as the type of a method parameter, as the return type of a method, or in an object allocation expression using the <code>new</code> keyword.</p>&#13;
&#13;
<p>Returning to our <code>listOfStrings</code>, what we have now is effectively a <code>List</code> in which the type <code>String</code> has been substituted for the type variable <code>E</code> in the class body:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code><code class="w"> </code><code class="kd">class</code> <code class="nc">List</code><code class="o">&lt;</code><code class="w"> </code><code class="n">String</code><code class="w"> </code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="c1">// ...</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">public</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">add</code><code class="p">(</code><code class="n">String</code><code class="w"> </code><code class="n">element</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="p">...</code><code class="w"> </code><code class="p">}</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">public</code><code class="w"> </code><code class="n">String</code><code class="w"> </code><code class="nf">get</code><code class="p">(</code><code class="kt">int</code><code class="w"> </code><code class="n">i</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="p">...</code><code class="w"> </code><code class="p">}</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>We have specialized the <code>List</code> class to work with elements of type <code>String</code> and <em>only</em> elements of type <code>String</code>. This method signature is no longer capable of accepting an arbitrary <code>Object</code> type.</p>&#13;
&#13;
<p><code>List</code> is just an interface. <a data-primary="ArrayList" data-type="indexterm" id="id1469"/><a data-primary="collections framework" data-secondary="ArrayList" data-type="indexterm" id="id1470"/>To use the variable, we’ll need to create an instance of some actual implementation of <code>List</code>. As we did in our introduction, we’ll use <code>ArrayList</code>. As before, <code>ArrayList</code> is a class that implements the <code>List</code> interface, but in this case, both <code>List</code> and <code>ArrayList</code> are generic classes. As such, they require type parameters to instantiate them where they are used. Of course, we’ll create our <code>ArrayList</code> to hold <code>String</code> elements to match our <code>List</code> of <code>String</code>s:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="n">List</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code><code class="w"> </code><code class="n">listOfStrings</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">ArrayList</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code><code class="p">();</code><code class="w"/>&#13;
<code class="w">    </code><code class="c1">// Or shorthand in Java 7.0 and later</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">List</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code><code class="w"> </code><code class="n">listOfStrings</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">ArrayList</code><code class="o">&lt;&gt;</code><code class="p">();</code><code class="w"/></pre>&#13;
&#13;
<p>As always, the <code>new</code> keyword takes a <a data-primary="&lt;String&gt; object" data-type="indexterm" id="id1471"/>Java type and parentheses with possible arguments for the class’s constructor. In this case, the type is <code>ArrayList&lt;String&gt;</code>—the generic <code>ArrayList</code> type instantiated with the <code>String</code> type.</p>&#13;
&#13;
<p>Declaring variables (as shown in the first line of the preceding example) is a bit cumbersome because it requires us to provide the generic parameter type twice: once on the left side in the variable type and once on the right in the initialing expression. And in complicated cases, the generic types can get very lengthy and nested within one another.</p>&#13;
&#13;
<p>The <a data-primary="generic type inference" data-type="indexterm" id="id1472"/><a data-primary="&lt;&gt; (angle brackets), type parameter" data-type="indexterm" id="id1473"/><a data-primary="angle brackets (&lt;&gt;), type parameter" data-type="indexterm" id="id1474"/>compiler is smart enough to infer the type of the initializing expression from the type of the variable to which you are assigning it. This is called <em>generic type inference</em> and boils down to the fact that you can use shorthand on the right side of your variable declarations by leaving out the contents of the <code>&lt;&gt;</code> notation, as shown in the example’s second version.</p>&#13;
&#13;
<p>We can now use our specialized <code>List</code> with strings. The compiler prevents us from even trying to put anything other than a <code>String</code> object (or a subtype of <code>String</code> if there were any) into the list. It also allows us to fetch <code>String</code> objects with the <code>get()</code> method without requiring any cast:<a data-primary="" data-startref="ix_list_generic" data-type="indexterm" id="id1475"/></p>&#13;
&#13;
<pre class="jshell" data-type="programlisting">jshell&gt; ArrayList&lt;String&gt; listOfStrings = new ArrayList&lt;&gt;();&#13;
listOfStrings ==&gt; []&#13;
&#13;
jshell&gt; listOfStrings.add("Hey!");&#13;
$8 ==&gt; true&#13;
&#13;
jshell&gt; listOfStrings.add(new JLabel("Hey there"));&#13;
|  Error:&#13;
|  incompatible types: javax.swing.JLabel cannot be converted to java.lang.String&#13;
|  listOfStrings.add(new JLabel("Hey there"));&#13;
|                    ^---------------------^&#13;
&#13;
jshell&gt; String s = strings.get(0);&#13;
s ==&gt; "Hey!"</pre>&#13;
&#13;
<p>Let’s take another example from the Collections API. The <code>Map</code> interface provides a dictionary-like mapping that associates key objects with value objects. Keys and values do not have to be of the same type. The generic <code>Map</code> interface requires two type parameters: one for the key type and one for the value type. The Javadoc looks &#13;
<span class="keep-together">like this</span>:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code><code class="w"> </code><code class="kd">class</code> <code class="nc">Map</code><code class="o">&lt;</code><code class="w"> </code><code class="n">K</code><code class="p">,</code><code class="w"> </code><code class="n">V</code><code class="w"> </code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="c1">// ...</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">public</code><code class="w"> </code><code class="n">V</code><code class="w"> </code><code class="nf">put</code><code class="p">(</code><code class="n">K</code><code class="w"> </code><code class="n">key</code><code class="p">,</code><code class="w"> </code><code class="n">V</code><code class="w"> </code><code class="n">value</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="p">...</code><code class="w"> </code><code class="p">}</code><code class="w"> </code><code class="c1">// returns any old value</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">public</code><code class="w"> </code><code class="n">V</code><code class="w"> </code><code class="nf">get</code><code class="p">(</code><code class="n">K</code><code class="w"> </code><code class="n">key</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="p">...</code><code class="w"> </code><code class="p">}</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>We can make a <code>Map</code> that stores <code>Employee</code> objects by <code>Integer</code> “employee ID” numbers, like this:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="n">Map</code><code class="o">&lt;</code><code class="w"> </code><code class="n">Integer</code><code class="p">,</code><code class="w"> </code><code class="n">Employee</code><code class="w"> </code><code class="o">&gt;</code><code class="w"> </code><code class="n">employees</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">HashMap</code><code class="o">&lt;</code><code class="n">Integer</code><code class="p">,</code><code class="w"> </code><code class="n">Employee</code><code class="o">&gt;</code><code class="p">();</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">Integer</code><code class="w"> </code><code class="n">bobsId</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">314</code><code class="p">;</code><code class="w"> </code><code class="c1">// hooray for autoboxing!</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">Employee</code><code class="w"> </code><code class="n">bob</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">Employee</code><code class="p">(</code><code class="s">"Bob"</code><code class="p">,</code><code class="w"> </code><code class="p">...);</code><code class="w"/>&#13;
&#13;
<code class="w">    </code><code class="n">employees</code><code class="p">.</code><code class="na">put</code><code class="p">(</code><code class="n">bobsId</code><code class="p">,</code><code class="w"> </code><code class="n">bob</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">Employee</code><code class="w"> </code><code class="n">employee</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">employees</code><code class="p">.</code><code class="na">get</code><code class="p">(</code><code class="n">bobsId</code><code class="p">);</code><code class="w"/></pre>&#13;
&#13;
<p>Here, we <a data-primary="HashMap class" data-type="indexterm" id="id1476"/><a data-primary="Map interface" data-type="indexterm" id="id1477"/>used <code>HashMap</code>, which is a generic class that implements the <code>Map</code> interface. We instantiated both types with the type parameters <code>Integer</code> and <code>Employee</code>. The <code>Map</code> now works only with keys of type <code>Integer</code> and holds values of type <code>Employee</code>.</p>&#13;
&#13;
<p>The <a data-primary="autoboxing" data-type="indexterm" id="id1478"/>reason we used <code>Integer</code> here to hold our number is that the type parameters to a generic class must be class types. We can’t parameterize a generic class with a primitive type, such as <code>int</code> or <code>boolean</code>. Fortunately, autoboxing of primitives in Java (see <a data-type="xref" href="ch05.html#learnjava6-CHP-5-SECT-2.6">“Wrappers for Primitive Types”</a>) almost makes it appear as if we can by allowing us to use primitive types as though they were wrapper types.</p>&#13;
&#13;
<p>Dozens of other APIs beyond Collections use generics to let you adapt them to specific types. We’ll talk about them as they occur throughout the book.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Talking About Types" data-type="sect2"><div class="sect2" id="learnjava6-CHP-7-SECT-3.1">&#13;
<h2>Talking About Types</h2>&#13;
&#13;
<p>Before we move on to more important things, we should say a few words about the way we describe a particular parameterization of a generic class. Because the most common and compelling case for generics is for container-like objects, it’s common to think in terms of a generic type “holding” a parameter type. In our example, we called our <code>List&lt;String&gt;</code> a “list of strings” because, sure enough, that’s what it was. Similarly, we might have called our employee map a “Map of Employee IDs to Employee Objects.” However, these descriptions focus a little more on what the classes <em>do</em> than on the type itself.</p>&#13;
&#13;
<p>Take instead a single object container called <code>Trap&lt; E &gt;</code> that could be instantiated on an object of type <code>Mouse</code> or of type <code>Bear</code>; that is, <code>Trap&lt;Mouse&gt;</code> or <code>Trap&lt;Bear&gt;</code>. Our instinct is to call the new type a “mouse trap” or “bear trap.” We can think of our list of strings as a new type, as well. We could talk about a “string list” or describe our employee map as a new “integer employee object map” type. You may use whatever verbiage you prefer, but these latter descriptions focus more on the notion of the generic as a <em>type</em> and may help you keep the terms straight when we discuss how generic types are related in the type system. There we’ll see that the container terminology turns out to be a little counterintuitive.</p>&#13;
&#13;
<p>In the following section, we’ll discuss generic types in Java from a different perspective. We’ve seen a little of what they can do; now we need to talk about how they do it.<a data-primary="" data-startref="type_generics" data-type="indexterm" id="id1479"/><a data-primary="" data-startref="ix_generic_type" data-type="indexterm" id="id1480"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="“There Is No Spoon”" data-type="sect1"><div class="sect1" id="learnjava6-CHP-7-SECT-4">&#13;
<h1>“There Is No Spoon”</h1>&#13;
&#13;
<p>In the movie <em>The Matrix</em>,<sup><a data-type="noteref" href="ch07.html#id1481" id="id1481-marker">3</a></sup> the hero Neo is offered a choice: take the blue pill and remain in the world of fantasy, or take the red pill and see things as they really are. In dealing with generics in Java, we are faced with a similar ontological dilemma. We can go only so far in any discussion of generics before we are forced to confront the reality of how they are implemented. Our fantasy world is one created by the compiler to make our lives writing code easier to accept. Our reality (though not quite the dystopian nightmare in the movie) is a harsher place, filled with unseen dangers and questions. Why don’t casts and tests work properly with generics? Why can’t I implement what appear to be two different generic interfaces in one class? Why can I declare an array of generic types, even though there is no way in Java to create such an array?!?</p>&#13;
&#13;
<p>We’ll answer these questions and more in the rest of this chapter, and you won’t even have to wait for the sequel. You’ll be bending spoons (well, types) in no time. Let’s get started.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Erasure" data-type="sect2"><div class="sect2" id="learnjava6-CHP-7-SECT-4.1">&#13;
<h2>Erasure</h2>&#13;
&#13;
<p>The design <a data-primary="generics" data-secondary="erasure" data-type="indexterm" id="ix_generic_erasure_ch7"/><a data-primary="erasure" data-type="indexterm" id="ix_erasure_ch7"/>goals for Java generics were formidable: add a radical new syntax to the language that safely introduces parameterized types with no impact on performance and, oh, by the way, make it backward compatible with all existing Java code and don’t change the compiled classes in any serious way. It’s amazing that they actually satisfied these conditions and no surprise that it took a while. But as always, some necessary compromises led to some headaches.</p>&#13;
&#13;
<p>To accomplish this feat, <a data-primary="compiler" data-secondary="and generics" data-secondary-sortas="generics" data-type="indexterm" id="ix_compile_gen"/>Java employs a technique called <em>erasure</em>. Erasure relates to the idea that since most everything we do with generics applies statically at compile time, generic information does not need to be carried over into the compiled classes. The generic nature of the classes, enforced by the compiler, can be “erased” in the binary classes, maintaining compatibility with nongeneric code.</p>&#13;
&#13;
<p>While Java does retain information about the generic features of classes in the compiled form, this information is used mainly by the compiler. The Java runtime does not know anything about generics at all (and does not waste any resources on them).</p>&#13;
&#13;
<p>We can use <em>jshell</em> to <a data-primary="List interface" data-secondary="erasure" data-type="indexterm" id="ix_list_inter_erase"/>confirm the runtime notion of a parameterized <code>List&lt;E&gt;</code> still being a <code>List</code>:</p>&#13;
&#13;
<pre class="jshell" data-type="programlisting">jshell&gt; import java.util.*;&#13;
&#13;
jshell&gt; List&lt;Date&gt; dateList = new ArrayList&lt;Date&gt;();&#13;
dateList ==&gt; []&#13;
&#13;
jshell&gt; dateList instanceof List&#13;
$3 ==&gt; true</pre>&#13;
&#13;
<p>But our generic <code>dateList</code> clearly does not implement the <code>List</code> methods just <span class="keep-together">discussed:</span></p>&#13;
&#13;
<pre class="jshell" data-type="programlisting">jshell&gt; dateList.add(new Object())&#13;
|  Error:&#13;
|  incompatible types: java.lang.Object cannot be converted to java.util.Date&#13;
|  dateList.add(new Object())&#13;
|               ^----------^</pre>&#13;
&#13;
<p>This illustrates the somewhat eclectic nature of Java generics. The compiler believes in them, but the runtime says they are an illusion. What if we try something a little simpler and check that our <code>dateList</code> is a <code>List&lt;Date&gt;</code>:</p>&#13;
&#13;
<pre class="jshell" data-type="programlisting">jshell&gt; dateList instanceof List&lt;Date&gt;;&#13;
|  Error:&#13;
|  illegal generic type for instanceof&#13;
|  dateList instanceof List&lt;Date&gt;;&#13;
|                      ^--------^</pre>&#13;
&#13;
<p>This time the compiler simply puts its foot down and says, “No.” You can’t test for a generic type in an <code>instanceof</code> operation. Since there are no discernible classes for different parameterizations of <code>List</code> at runtime (every <code>List</code> is still a <code>List</code>), there is no way for the <code>instanceof</code> operator to tell the difference between one incarnation of <code>List</code> and another. All of the generic safety checking was done at compile time, so at runtime we’re just dealing with a single actual <code>List</code> type.</p>&#13;
&#13;
<p>Here’s what really happened: the compiler erased all of the angle bracket syntax and replaced the type parameters in our <code>List</code> class with a type that can work at runtime with any allowed type: in this case, <code>Object</code>. We would seem to be back where we started, except that the compiler still has the knowledge to enforce our usage of the generics in the code at compile time and can, therefore, handle the cast for us. If you <a data-primary="javap command" data-type="indexterm" id="id1482"/>decompile a class using a <code>List&lt;Date&gt;</code> (the <em>javap</em> command with the <em>-c</em> option shows you the bytecode, if you dare), you will see that the compiled code actually contains the cast to <code>Date</code>, even though we didn’t write it ourselves.</p>&#13;
&#13;
<p>We can now answer one of the questions posed at the beginning of the section: “Why can’t I implement what appear to be two different generic interfaces in one class?” We can’t have a class that implements two different generic <code>List</code> instantiations because they are really the same type at runtime, and there is no way to tell them apart:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code><code class="w"> </code><code class="kd">abstract</code><code class="w"> </code><code class="kd">class</code> <code class="nc">DualList</code><code class="w"> </code><code class="kd">implements</code><code class="w"> </code><code class="n">List</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code><code class="p">,</code><code class="w"> </code><code class="n">List</code><code class="o">&lt;</code><code class="n">Date</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="p">}</code><code class="w"/>&#13;
<code class="c1">// Error: java.util.List cannot be inherited with different arguments:</code><code class="w"/>&#13;
<code class="c1">//    &lt;java.lang.String&gt; and &lt;java.util.Date&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>Fortunately, there are always workarounds. In this case, for example, you can use a common superclass or create multiple classes. The alternatives may not be as elegant, but you can almost always land on a clean answer—even if it is a little verbose.<a data-primary="" data-startref="ix_generic_erasure_ch7" data-type="indexterm" id="id1483"/><a data-primary="" data-startref="ix_list_inter_erase" data-type="indexterm" id="id1484"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Raw Types" data-type="sect2"><div class="sect2" id="learnjava6-CHP-7-SECT-4.2">&#13;
<h2>Raw Types</h2>&#13;
&#13;
<p>Although the <a data-primary="generics" data-secondary="raw types" data-type="indexterm" id="ix_generics_raw_type"/><a data-primary="raw types" data-type="indexterm" id="ix_raw_type"/><a data-primary="type system" data-secondary="raw types" data-type="indexterm" id="ix_type_raw_type"/>compiler treats different parameterizations of a generic type as different types (with different APIs) at compile time, we have seen that only one real type exists at runtime. For example, both <code>List&lt;Date&gt;</code> and <code>List&lt;String&gt;</code> share the plain old Java class <code>List</code>. <code>List</code> is called the <em>raw type</em> of the generic class. Every generic has a raw type. It is the base, “plain” Java form from which all of the generic type information has been removed and the type variables replaced by a general Java type like <code>Object</code>.</p>&#13;
&#13;
<p>It is possible to use raw types in Java. However, the Java compiler generates a warning wherever they are used in an “unsafe” way. Outside <em>jshell</em>, the compiler still notices these <span class="keep-together">problems:</span></p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="c1">// nongeneric Java code using the raw type</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">List</code><code class="w"> </code><code class="n">list</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">ArrayList</code><code class="p">();</code><code class="w"> </code><code class="c1">// assignment ok</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">list</code><code class="p">.</code><code class="na">add</code><code class="p">(</code><code class="s">"foo"</code><code class="p">);</code><code class="w"> </code><code class="c1">// Compiler warning on usage of raw type</code><code class="w"/></pre>&#13;
&#13;
<p>This <a data-primary="unchecked warning" data-type="indexterm" id="id1485"/>snippet uses the raw <code>List</code> type just as old-fashioned Java code prior to Java 5 would have. The difference is that now the Java compiler issues an <em>unchecked warning</em> about the code if we attempt to insert an object into the list:</p>&#13;
&#13;
<pre data-type="programlisting">% javac RawType.java&#13;
Note: RawType.java uses unchecked or unsafe operations.&#13;
Note: Recompile with -Xlint:unchecked for details.</pre>&#13;
&#13;
<p>The compiler <a data-primary="-Xlint:unchecked" data-primary-sortas="Xlint:unchecked" data-type="indexterm" id="id1486"/>instructs us to use the <code>-Xlint:unchecked</code> option to get more specific information about the locations of unsafe operations:</p>&#13;
&#13;
<pre data-type="programlisting">% javac -Xlint:unchecked MyClass.java&#13;
RawType.java:6: warning: [unchecked] unchecked call to add(E)&#13;
as a member of the raw type List&#13;
    list.add("foo");&#13;
            ^&#13;
  where E is a type-variable:&#13;
    E extends Object declared in interface List</pre>&#13;
&#13;
<p>Note that <a data-primary="ArrayList" data-type="indexterm" id="ix_array_list"/><a data-primary="collections framework" data-secondary="ArrayList" data-type="indexterm" id="ix_collect_array_list"/>creating and assigning the raw <code>ArrayList</code> does not generate a warning. It is only when we try to use an “unsafe” method (one that refers to a type variable) that we get the warning. This means that it’s still OK to use older-style, nongeneric Java APIs that work with raw types. We get warnings only when we do something unsafe in our own code.</p>&#13;
&#13;
<p>One more <a data-primary="bounds" data-type="indexterm" id="id1487"/>thing about erasure before we move on. In the previous examples, the type variables were replaced by the <code>Object</code> type, which could represent any type applicable to the type variable <code>E</code>. Later, we’ll see that this is not always the case. We can place limitations or <em>bounds</em> on the parameter types, and, when we do, the compiler can be more restrictive about the erasure of the type, for example:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">class</code> <code class="nc">Bounded</code><code class="o">&lt;</code><code class="w"> </code><code class="n">E</code><code class="w"> </code><code class="kd">extends</code><code class="w"> </code><code class="n">Date</code><code class="w"> </code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">public</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">addElement</code><code class="p">(</code><code class="n">E</code><code class="w"> </code><code class="n">element</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="p">...</code><code class="w"> </code><code class="p">}</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>This parameter type declaration says that the element type <code>E</code> must be a subtype of the <code>Date</code> type. In this case, the erasure of the <code>addElement()</code> method is therefore more restrictive than <code>Object</code>, and the compiler uses <code>Date</code>:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">  </code><code class="kd">public</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">addElement</code><code class="p">(</code><code class="n">Date</code><code class="w"> </code><code class="n">element</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="p">...</code><code class="w"> </code><code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p><code>Date</code> is <a data-primary="upper bound of type" data-type="indexterm" id="id1488"/>called the <em>upper bound</em> of this type, meaning that it is the top of the object hierarchy here. You can only instantiate the parameterized type on a <code>Date</code> or on a “lower” (more derived, or subclassed) type.</p>&#13;
&#13;
<p>Now that we have a handle on what generic types really are, we can go into a little more detail about how they behave.<a data-primary="" data-startref="ix_generics_raw_type" data-type="indexterm" id="id1489"/><a data-primary="" data-startref="ix_raw_type" data-type="indexterm" id="id1490"/><a data-primary="" data-startref="ix_type_raw_type" data-type="indexterm" id="id1491"/><a data-primary="" data-startref="ix_compile_gen" data-type="indexterm" id="id1492"/><a data-primary="" data-startref="ix_erasure_ch7" data-type="indexterm" id="id1493"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Parameterized Type Relationships" data-type="sect1"><div class="sect1" id="learnjava6-CHP-7-SECT-5">&#13;
<h1>Parameterized Type Relationships</h1>&#13;
&#13;
<p>We know now that <a data-primary="type system" data-secondary="parameterized types" data-type="indexterm" id="ix_type_param_ch7"/><a data-primary="parameterized types" data-type="indexterm" id="ix_param_type_ch7"/><a data-primary="List interface" data-secondary="and generics" data-secondary-sortas="generics" data-type="indexterm" id="ix_list_generic2"/><a data-primary="generics" data-secondary="parameterized types" data-type="indexterm" id="ix_generic_param"/>parameterized types share a common, raw type. This is why our parameterized <code>List&lt;Date&gt;</code> is just a <code>List</code> at runtime. In fact, we can assign any instantiation of <code>List</code> to the raw type if we want:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="n">List</code><code class="w"> </code><code class="n">list</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">ArrayList</code><code class="o">&lt;</code><code class="n">Date</code><code class="o">&gt;</code><code class="p">();</code><code class="w"/></pre>&#13;
&#13;
<p>We can even go the other way and assign a raw type to a specific instantiation of the generic type:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="n">List</code><code class="o">&lt;</code><code class="n">Date</code><code class="o">&gt;</code><code class="w"> </code><code class="n">dates</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">ArrayList</code><code class="p">();</code><code class="w"> </code><code class="c1">// unchecked warning</code><code class="w"/></pre>&#13;
&#13;
<p>This statement generates an unchecked warning on the assignment, but after that, the compiler trusts that the list contained only <code>Date</code>s prior to the assignment. You can try casting <code>new ArrayList()</code> to <code>List&lt;Date&gt;</code>, but that won’t address the warning. We’ll talk about casting to generic types in <a data-type="xref" href="#learnjava6-CHP-7-SECT-6">“Casts”</a>.</p>&#13;
&#13;
<p>Whatever the runtime types, the compiler is running the show. It does not let us assign things that are clearly incompatible:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="n">List</code><code class="o">&lt;</code><code class="n">Date</code><code class="o">&gt;</code><code class="w"> </code><code class="n">dates</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">ArrayList</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code><code class="p">();</code><code class="w"> </code><code class="c1">// Compile-time Error!</code><code class="w"/></pre>&#13;
&#13;
<p>Of course, the <code>ArrayList&lt;String&gt;</code> does not implement the methods of <code>List&lt;Date&gt;</code> required by the compiler, so these types are incompatible.</p>&#13;
&#13;
<p>But what about more interesting type relationships? The <code>List</code> interface, for example, is a subtype of the more general <code>Collection</code> interface. Can you take a particular instantiation of the generic <code>List</code> and assign it to some instantiation of the generic &#13;
<span class="keep-together"><code>Collection</code></span>? Does it depend on the type parameters and their relationships? Clearly, a <code>List&lt;Date&gt;</code> is not a <code>Collection&lt;String&gt;</code>. But is a <code>List&lt;Date&gt;</code> a &#13;
<span class="keep-together"><code>Collection&lt;Date&gt;</code></span>? Can a <code>List&lt;Date&gt;</code> be a <code>Collection&lt;Object&gt;</code>?</p>&#13;
&#13;
<p>We’ll just blurt out the answer here first, then walk through it and explain. The rule for the <a data-primary="classes" data-secondary="inheritance" data-type="indexterm" id="id1494"/><a data-primary="inheritance" data-type="indexterm" id="id1495"/>simple types of generic instantiations we’ve discussed so far is that <em>inheritance applies only to the “base” generic type and not to the parameter types</em>. Furthermore, assignability applies only when the two generic types are instantiated on <em>exactly the same parameter type</em>. In other words, there is still one-dimensional inheritance, following the base generic class type, but with the additional restriction that the parameter types must be identical.</p>&#13;
&#13;
<p>For example, since a <code>List</code> is a type of <code>Collection</code>, we can assign instantiations of <code>List</code> to instantiations of <code>Collection</code> when the type parameter is exactly the same:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="n">Collection</code><code class="o">&lt;</code><code class="n">Date</code><code class="o">&gt;</code><code class="w"> </code><code class="n">cd</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">List</code><code class="o">&lt;</code><code class="n">Date</code><code class="o">&gt;</code><code class="w"> </code><code class="n">ld</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">ArrayList</code><code class="o">&lt;</code><code class="n">Date</code><code class="o">&gt;</code><code class="p">();</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">cd</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">ld</code><code class="p">;</code><code class="w"> </code><code class="c1">// Ok!</code><code class="w"/></pre>&#13;
&#13;
<p>This code snippet says that a <code>List&lt;Date&gt;</code> is a <code>Collection&lt;Date&gt;</code>—pretty intuitive. But trying the same logic on a variation in the parameter types fails:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="n">List</code><code class="o">&lt;</code><code class="n">Object</code><code class="o">&gt;</code><code class="w"> </code><code class="n">lo</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">List</code><code class="o">&lt;</code><code class="n">Date</code><code class="o">&gt;</code><code class="w"> </code><code class="n">ld</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">ArrayList</code><code class="o">&lt;</code><code class="n">Date</code><code class="o">&gt;</code><code class="p">();</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">lo</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">ld</code><code class="p">;</code><code class="w"> </code><code class="c1">// Compile-time Error!  Incompatible types.</code><code class="w"/></pre>&#13;
&#13;
<p>Although our intuition tells us that the <code>Date</code>s in that <code>List</code> could all live happily as <code>Object</code>s in a <code>List</code>, the assignment is an error. We’ll explain precisely why in the next section, but for now just note that the type parameters are not exactly the same and that there is no inheritance relationship among parameter types in generics.</p>&#13;
&#13;
<p>This is a case where it helps to think of the instantiation in terms of types and not in terms of what the instantiated objects do. These are not really a “list of dates” and a “list of objects”—more like a <code>DateList</code> and an <code>ObjectList</code>, the relationship of which is not immediately obvious.</p>&#13;
&#13;
<p>Try to pick out what’s OK and what’s not OK in the following example:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="n">Collection</code><code class="o">&lt;</code><code class="n">Number</code><code class="o">&gt;</code><code class="w"> </code><code class="n">cn</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">List</code><code class="o">&lt;</code><code class="n">Integer</code><code class="o">&gt;</code><code class="w"> </code><code class="n">li</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">ArrayList</code><code class="o">&lt;</code><code class="n">Integer</code><code class="o">&gt;</code><code class="p">();</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">cn</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">li</code><code class="p">;</code><code class="w"/></pre>&#13;
&#13;
<p>It is possible for an instantiation of <code>List</code> to be an instantiation of <code>Collection</code>, but only if the parameter types are exactly the same. Inheritance doesn’t follow the parameter types, so the final assignment in this example fails.</p>&#13;
&#13;
<p>Earlier we <a data-primary="concrete type instantiations" data-type="indexterm" id="id1496"/><a data-primary="wildcard instantiations" data-type="indexterm" id="id1497"/>mentioned that this rule applies to the simple types of instantiations we’ve discussed so far in this chapter. What other types are there? Well, the kinds of instantiations we’ve seen so far where we plug in an actual Java type as a parameter are called <em>concrete type instantiations</em>. Later, we’ll talk about <em>wildcard instantiations</em>, which are like mathematical set operations on types (think unions and intersections). It’s possible to make more exotic instantiations of generics where the type relationships are actually two-dimensional, depending both on the base type and the parameterization. But don’t worry: this doesn’t come up very often and is not as scary as it sounds.<a data-primary="" data-startref="ix_array_list" data-type="indexterm" id="id1498"/><a data-primary="" data-startref="ix_collect_array_list" data-type="indexterm" id="id1499"/></p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Why Isn’t a List&lt;Date&gt; a List&lt;Object&gt;?" data-type="sect2"><div class="sect2" id="learnjava6-CHP-7-SECT-5.1">&#13;
<h2>Why Isn’t a List&lt;Date&gt; a List&lt;Object&gt;?</h2>&#13;
&#13;
<p>It’s a reasonable question. Why shouldn’t we be able to assign our <code>List&lt;Date&gt;</code> to a <code>List&lt;Object&gt;</code> and work with the <code>Date</code> elements as <code>Object</code> types?</p>&#13;
&#13;
<p>The reason gets back to the heart of the rationale for generics: changing programming contracts. In the simplest case, supposing a <code>DateList</code> type extends an <code>ObjectList</code> type, the <code>DateList</code> would have all of the methods of <code>ObjectList</code> and we could insert <code>Object</code>s into it. Now, you might object that generics let us change the method signatures, so that doesn’t apply anymore. That’s true, but there is a bigger problem. If we could assign our <code>DateList</code> to an <code>ObjectList</code> variable, we could use <code>Object</code> methods to insert elements of types other than <code>Date</code> into it.</p>&#13;
&#13;
<p>We could <em>alias</em> (provide an alternate, broader type) the <code>DateList</code> as an <code>ObjectList</code>. Using the aliased object, we could try to trick it into accepting some other type:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="n">DateList</code><code class="w"> </code><code class="n">dateList</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">DateList</code><code class="p">();</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">ObjectList</code><code class="w"> </code><code class="n">objectList</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">dateList</code><code class="p">;</code><code class="w"> </code><code class="c1">// Can't really do this</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">objectList</code><code class="p">.</code><code class="na">add</code><code class="p">(</code><code class="k">new</code><code class="w"> </code><code class="n">Foo</code><code class="p">());</code><code class="w"> </code><code class="c1">// should be runtime error!</code><code class="w"/></pre>&#13;
&#13;
<p>We’d expect to get a runtime error when the actual <code>DateList</code> implementation was presented with the wrong type of object.</p>&#13;
&#13;
<p>And therein lies the problem. Java generics have no runtime representation. Even if this functionality were useful, there is no way for Java to know what to do at runtime. This feature is simply dangerous—it allows for an error at runtime that can’t be caught at compile time. In general, we’d like to catch type errors at compile time.</p>&#13;
&#13;
<p>You might think <a data-primary="safety" data-secondary="type" data-type="indexterm" id="id1500"/><a data-primary="type system" data-secondary="safety of" data-type="indexterm" id="id1501"/><a data-primary="arrays" data-secondary="and collections" data-secondary-sortas="collections" data-type="indexterm" id="id1502"/><a data-primary="collections framework" data-secondary="and arrays" data-secondary-sortas="arrays" data-type="indexterm" id="id1503"/>Java could guarantee the type safety of your code if it compiles with no unchecked warnings by disallowing these assignments. Unfortunately it can’t, but that limitation has nothing to do with generics; it has to do with arrays. (If this all sounds familiar to you, it’s because we mentioned this issue in <a data-type="xref" href="ch04.html#learnjava6-CHP-4">Chapter 4</a> in relation to Java arrays.) Array types have an inheritance relationship that allows this kind of aliasing to occur:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="n">Date</code><code class="w"> </code><code class="o">[]</code><code class="w"> </code><code class="n">dates</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">Date</code><code class="o">[</code><code class="mi">10</code><code class="o">]</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">Object</code><code class="w"> </code><code class="o">[]</code><code class="w"> </code><code class="n">objects</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">dates</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">objects</code><code class="o">[</code><code class="mi">0</code><code class="o">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">"not a date"</code><code class="p">;</code><code class="w"> </code><code class="c1">// Runtime ArrayStoreException!</code><code class="w"/></pre>&#13;
&#13;
<p>Arrays have runtime representations as different classes. They check themselves at runtime, throwing an <code>ArrayStoreException</code> in situations like this. The Java compiler cannot guarantee the type safety of your code if you use arrays in this way.<a data-primary="" data-startref="ix_generic_param" data-type="indexterm" id="id1504"/><a data-primary="" data-startref="ix_list_generic2" data-type="indexterm" id="id1505"/><a data-primary="" data-startref="ix_param_type_ch7" data-type="indexterm" id="id1506"/><a data-primary="" data-startref="ix_type_param_ch7" data-type="indexterm" id="id1507"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Casts" data-type="sect1"><div class="sect1" id="learnjava6-CHP-7-SECT-6">&#13;
<h1>Casts</h1>&#13;
&#13;
<p>We’ve now talked about <a data-primary="generics" data-secondary="casts" data-type="indexterm" id="ix_generic_cast_ch7"/><a data-primary="casting" data-type="indexterm" id="ix_cast_ch7"/>relationships between generic types and even between generic types and raw types. But we haven’t really explored the concept of casts in the world of generics.</p>&#13;
&#13;
<p>No cast was necessary when we interchanged generics with their raw types. But we triggered unchecked warnings from the compiler:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="n">List</code><code class="w"> </code><code class="n">list</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">ArrayList</code><code class="o">&lt;</code><code class="n">Date</code><code class="o">&gt;</code><code class="p">();</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">List</code><code class="o">&lt;</code><code class="n">Date</code><code class="o">&gt;</code><code class="w"> </code><code class="n">dl</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">list</code><code class="p">;</code><code class="w">  </code><code class="c1">// unchecked warning</code><code class="w"/></pre>&#13;
&#13;
<p>Normally, we use a cast in Java to work with two types that could be assignable. For example, we could attempt to cast an <code>Object</code> to a <code>Date</code> because it is plausible that the <code>Object</code> could be a <code>Date</code> value. The cast then performs the check at runtime to see if we are correct.</p>&#13;
&#13;
<p>Casting between unrelated types is a <a data-primary="compiler" data-secondary="and casts" data-secondary-sortas="casts" data-type="indexterm" id="id1508"/>compile-time error. For example, we can’t even try to cast an <code>Integer</code> to a <code>String</code>. Those types have no inheritance relationship. What about casts between compatible generic types?</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="n">Collection</code><code class="o">&lt;</code><code class="n">Date</code><code class="o">&gt;</code><code class="w"> </code><code class="n">cd</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">ArrayList</code><code class="o">&lt;</code><code class="n">Date</code><code class="o">&gt;</code><code class="p">();</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">List</code><code class="o">&lt;</code><code class="n">Date</code><code class="o">&gt;</code><code class="w"> </code><code class="n">ld</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">(</code><code class="n">List</code><code class="o">&lt;</code><code class="n">Date</code><code class="o">&gt;</code><code class="p">)</code><code class="n">cd</code><code class="p">;</code><code class="w"> </code><code class="c1">// Ok!</code><code class="w"/></pre>&#13;
&#13;
<p>This code snippet shows a valid cast from a more general <code>Collection&lt;Date&gt;</code> to a <code>List&lt;Date&gt;</code>. The cast is plausible here because a <code>Collection&lt;Date&gt;</code> is assignable from and could actually be a <code>List&lt;Date&gt;</code>.</p>&#13;
&#13;
<p>Similarly, the following cast catches our mistake: we have aliased a <code>TreeSet&lt;Date&gt;</code> as a <code>Collection&lt;Date&gt;</code> and tried to cast it to a <code>List&lt;Date&gt;</code>:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="n">Collection</code><code class="o">&lt;</code><code class="n">Date</code><code class="o">&gt;</code><code class="w"> </code><code class="n">cd</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">TreeSet</code><code class="o">&lt;</code><code class="n">Date</code><code class="o">&gt;</code><code class="p">();</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">List</code><code class="o">&lt;</code><code class="n">Date</code><code class="o">&gt;</code><code class="w"> </code><code class="n">ld</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">(</code><code class="n">List</code><code class="o">&lt;</code><code class="n">Date</code><code class="o">&gt;</code><code class="p">)</code><code class="n">cd</code><code class="p">;</code><code class="w"> </code><code class="c1">// Runtime ClassCastException!</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">ld</code><code class="p">.</code><code class="na">add</code><code class="p">(</code><code class="k">new</code><code class="w"> </code><code class="n">Date</code><code class="p">());</code><code class="w"/></pre>&#13;
&#13;
<p>There is one case where casts are not effective with generics, however, and that is when trying to differentiate the types based on their parameter types:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="n">Object</code><code class="w"> </code><code class="n">o</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">ArrayList</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code><code class="p">();</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">List</code><code class="o">&lt;</code><code class="n">Date</code><code class="o">&gt;</code><code class="w"> </code><code class="n">ld</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">(</code><code class="n">List</code><code class="o">&lt;</code><code class="n">Date</code><code class="o">&gt;</code><code class="p">)</code><code class="n">o</code><code class="p">;</code><code class="w"> </code><code class="c1">// unchecked warning, ineffective</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">Date</code><code class="w"> </code><code class="n">d</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">ld</code><code class="p">.</code><code class="na">get</code><code class="p">(</code><code class="mi">0</code><code class="p">);</code><code class="w"> </code><code class="c1">// unsafe at runtime, implicit cast may fail</code><code class="w"/></pre>&#13;
&#13;
<p>Here, we aliased an <code>ArrayList&lt;String&gt;</code> as a plain <code>Object</code>. Next, we cast <code>o</code> to a <code>List&lt;Date&gt;</code>. Unfortunately, Java does not know the difference between a <code>List&lt;String&gt;</code> and a <code>List&lt;Date&gt;</code> at runtime, so the cast is fruitless. The compiler warns us by generating an unchecked warning at the location of the cast. When we try to use the cast object, <code>ld</code>, we might find out that it is incorrect. Casts on generic types are ineffective at runtime because of erasure and the lack of type information.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Converting Between Collections and Arrays" data-type="sect2"><div class="sect2" id="learnjava6-CHP-7-SECT-6.1">&#13;
<h2>Converting Between Collections and Arrays</h2>&#13;
&#13;
<p>While not related by direct <a data-primary="arrays" data-secondary="and collections" data-secondary-sortas="collections" data-type="indexterm" id="id1509"/><a data-primary="collections framework" data-secondary="and arrays" data-secondary-sortas="arrays" data-type="indexterm" id="id1510"/>inheritance or shared interfaces, converting between collections and arrays is still straightforward. For convenience, you can retrieve the elements of a collection as an array using the following methods:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="kd">public</code><code class="w"> </code><code class="n">Object</code><code class="o">[]</code><code class="w"> </code><code class="nf">toArray</code><code class="p">()</code><code class="w"/>&#13;
<code class="w">    </code><code class="kd">public</code><code class="w"> </code><code class="o">&lt;</code><code class="n">E</code><code class="o">&gt;</code><code class="w"> </code><code class="n">E</code><code class="o">[]</code><code class="w"> </code><code class="nf">toArray</code><code class="p">(</code><code class="n">E</code><code class="o">[]</code><code class="w"> </code><code class="n">a</code><code class="p">)</code><code class="w"/></pre>&#13;
&#13;
<p>The first method returns a plain <code>Object</code> array. With the second form, we can be more specific and get back an array of the correct element type. If we supply an array of sufficient size, it will be filled in with the values. But if the array is too short (for instance, zero length), Java will create a new array of the <em>same type but the required length</em> and return it instead. So you can just pass in an empty array of the correct type like this:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="n">Collection</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code><code class="w"> </code><code class="n">myCollection</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">...;</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">String</code><code class="w"> </code><code class="o">[]</code><code class="w"> </code><code class="n">myStrings</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">myCollection</code><code class="p">.</code><code class="na">toArray</code><code class="p">(</code><code class="k">new</code><code class="w"> </code><code class="n">String</code><code class="o">[</code><code class="mi">0</code><code class="o">]</code><code class="p">);</code><code class="w"/></pre>&#13;
&#13;
<p>This trick is a little awkward. It would be nice if Java let us specify the type explicitly using a <code>Class</code> reference, but for some reason, it doesn’t.</p>&#13;
&#13;
<p>Going the <a data-primary="Arrays helper class" data-type="indexterm" id="id1511"/><a data-primary="asList() method" data-type="indexterm" id="id1512"/>other way, you can convert an array of objects to a <code>List</code> collection with the static <code>asList()</code> method of the <code>java.util.Arrays</code> helper class:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="n">String</code><code class="w"> </code><code class="o">[]</code><code class="w"> </code><code class="n">myStrings</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="s">"a"</code><code class="p">,</code><code class="w"> </code><code class="s">"b"</code><code class="p">,</code><code class="w"> </code><code class="s">"c"</code><code class="w"> </code><code class="p">};</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">List</code><code class="w"> </code><code class="n">list</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Arrays</code><code class="p">.</code><code class="na">asList</code><code class="p">(</code><code class="n">myStrings</code><code class="p">);</code><code class="w"/></pre>&#13;
&#13;
<p>The compiler is also smart enough to recognize a valid assignment to a <code>List&lt;String&gt;</code> variable.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Iterator" data-type="sect2"><div class="sect2" id="learnjava6-CHP-7-SECT-6.2">&#13;
<h2>Iterator</h2>&#13;
&#13;
<p>An <em>iterator</em> is an <a data-primary="iterators, collections" data-type="indexterm" id="ix_iter_collect"/><a data-primary="java.util package" data-secondary="Iterator interface" data-type="indexterm" id="ix_java_util_iter"/><a data-primary="collections framework" data-secondary="iterator" data-type="indexterm" id="ix_collect_iter"/>object that lets you step through a sequence of values. This kind of operation comes up so often that it has a standard interface: <code>java.util.Iterator</code>. The <code>Iterator</code> interface has three interesting methods:</p>&#13;
<dl>&#13;
<dt><code>public E next()</code></dt>&#13;
<dd>&#13;
<p>This <a data-primary="next() method, Iterator" data-type="indexterm" id="id1513"/>method returns the next element (an element of generic type E) of the associated collection.</p>&#13;
</dd>&#13;
<dt><code>public boolean hasNext()</code></dt>&#13;
<dd>&#13;
<p>This <a data-primary="hasNext() method, Iterator" data-type="indexterm" id="id1514"/>method returns <code>true</code> if you have not yet stepped through all the &#13;
<span class="keep-together"><code>Collection</code>’s</span> elements. In other words, it returns <code>true</code> if you can call <code>next()</code> to get the next element.</p>&#13;
</dd>&#13;
<dt><code>public void remove()</code></dt>&#13;
<dd>&#13;
<p>This method <a data-primary="remove() method" data-secondary="Iterator" data-type="indexterm" id="id1515"/>removes the most recent object returned from <code>next()</code> from the associated <code>Collection</code>.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>The following example shows how to use an <code>Iterator</code> to print out every element of a collection:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">  </code><code class="kd">public</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">printElements</code><code class="p">(</code><code class="n">Collection</code><code class="w"> </code><code class="n">c</code><code class="p">,</code><code class="w"> </code><code class="n">PrintStream</code><code class="w"> </code><code class="n">out</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">Iterator</code><code class="w"> </code><code class="n">iterator</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">c</code><code class="p">.</code><code class="na">iterator</code><code class="p">();</code><code class="w"/>&#13;
<code class="w">    </code><code class="k">while</code><code class="w"> </code><code class="p">(</code><code class="n">iterator</code><code class="p">.</code><code class="na">hasNext</code><code class="p">())</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="n">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="n">iterator</code><code class="p">.</code><code class="na">next</code><code class="p">());</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">}</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>After using <code>next()</code> to get the next element, you can sometimes <code>remove()</code> it. Working your way through a to-do list, for example, might follow a pattern: “get an item, process the item, remove the item.” But the removal feature of iterators is not always appropriate and not all iterators implement <code>remove()</code>. It doesn’t make sense to be able to remove an element from a read-only collection, for example.</p>&#13;
&#13;
<p>If element removal is not allowed, an <code>UnsupportedOperationException</code> is thrown from this method. If you call <code>remove()</code> before first calling <code>next()</code>, or if you call <code>remove()</code> twice in a row, you’ll get an <code>IllegalStateException</code>.<a data-primary="" data-startref="ix_collect_iter" data-type="indexterm" id="id1516"/><a data-primary="" data-startref="ix_iter_collect" data-type="indexterm" id="id1517"/><a data-primary="" data-startref="ix_java_util_iter" data-type="indexterm" id="id1518"/></p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Looping over collections" data-type="sect3"><div class="sect3" id="learnjava6-CHP-7-SECT-6.2.1">&#13;
<h3>Looping over collections</h3>&#13;
&#13;
<p>A <a data-primary="enhanced for loop" data-type="indexterm" id="id1519"/><a data-primary="for loops" data-type="indexterm" id="id1520"/><a data-primary="Iterable types, for loop" data-type="indexterm" id="id1521"/>form of the <code>for</code> loop, described in <a data-type="xref" href="ch04.html#learnjava6-CHP-4-SECT-5.1.4">“The for loop”</a>, can operate over all <code>Iterable</code> types, which means it can iterate over all types of <code>Collection</code> objects as that interface extends <code>Iterable</code>. For example, it can now step over all of the elements of a typed collection of <code>Date</code> objects, like so:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="n">Collection</code><code class="o">&lt;</code><code class="n">Date</code><code class="o">&gt;</code><code class="w"> </code><code class="n">col</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">...</code><code class="w"/>&#13;
<code class="w">    </code><code class="k">for</code><code class="w"> </code><code class="p">(</code><code class="n">Date</code><code class="w"> </code><code class="n">date</code><code class="w"> </code><code class="p">:</code><code class="w"> </code><code class="n">col</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="n">date</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>This <a data-primary="entrySet() method" data-secondary="Collection" data-type="indexterm" id="id1522"/><a data-primary="key-value pairs, Map" data-type="indexterm" id="id1523"/><a data-primary="keySet() method, Map" data-type="indexterm" id="id1524"/><a data-primary="values() method, Map" data-type="indexterm" id="id1525"/>feature of the Java built-in <code>for</code> loop is called the “enhanced” <code>for</code> loop (as opposed to the pregenerics, numeric-only <code>for</code> loop). The enhanced <code>for</code> loop applies only to <code>Collection</code> type collections, not <code>Map</code>s. But looping over a map can be useful in some situations. You can use the <code>Map</code> methods <code>keySet()</code> or <code>values()</code> (or even <code>entrySet()</code> if you want each key/value pair as a single entity) to get a collection from your map that <em>does</em> work with this enhanced <code>for</code> loop:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="n">Map</code><code class="o">&lt;</code><code class="n">Integer</code><code class="p">,</code><code class="w"> </code><code class="n">Employee</code><code class="o">&gt;</code><code class="w"> </code><code class="n">employees</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">HashMap</code><code class="o">&lt;&gt;</code><code class="p">();</code><code class="w"/>&#13;
<code class="w">    </code><code class="c1">// ...</code><code class="w"/>&#13;
<code class="w">    </code><code class="k">for</code><code class="w"> </code><code class="p">(</code><code class="n">Integer</code><code class="w"> </code><code class="n">id</code><code class="w"> </code><code class="p">:</code><code class="w"> </code><code class="n">employees</code><code class="p">.</code><code class="na">keySet</code><code class="p">())</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">print</code><code class="p">(</code><code class="s">"Employee "</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">id</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">      </code><code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="s">" =&gt; "</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">employees</code><code class="p">.</code><code class="na">get</code><code class="p">(</code><code class="n">id</code><code class="p">));</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>The collection of keys is a simple, unordered set. The enhanced <code>for</code> loop above will show all of your employees, but their printed order might appear somewhat random. If you wanted them listed in order of their IDs or perhaps their names, you would need to sort the keys or values first. Fortunately, sorting is a very common task—and the collections framework can help.<a data-primary="" data-startref="ix_generics_ch7" data-type="indexterm" id="id1526"/><a data-primary="" data-startref="ix_cast_ch7" data-type="indexterm" id="id1527"/><a data-primary="" data-startref="ix_generic_cast_ch7" data-type="indexterm" id="id1528"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="A Closer Look: The sort() Method" data-type="sect1"><div class="sect1" id="learnjava6-CHP-7-SECT-7">&#13;
<h1>A Closer Look: The sort() Method</h1>&#13;
&#13;
<p>Poking <a data-primary="collections framework" data-secondary="sort() method" data-type="indexterm" id="id1529"/><a data-primary="java.util package" data-secondary="Collections class" data-type="indexterm" id="id1530"/><a data-primary="sort() method, Collections" data-type="indexterm" id="id1531"/>around in the <code>java.util.Collections</code> class, we find all kinds of static utility methods for working with collections. Among them is this goody—the static generic method <code>sort()</code>:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="o">&lt;</code><code class="n">T</code><code class="w"> </code><code class="kd">extends</code><code class="w"> </code><code class="n">Comparable</code><code class="o">&lt;?</code><code class="w"> </code><code class="kd">super</code><code class="w"> </code><code class="n">T</code><code class="o">&gt;&gt;</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">sort</code><code class="p">(</code><code class="n">List</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="w"> </code><code class="n">list</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="p">...</code><code class="w"> </code><code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>Another nut for us to crack. Let’s focus on the last part of the bound:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="n">Comparable</code><code class="o">&lt;?</code><code class="w"> </code><code class="kd">super</code><code class="w"> </code><code class="n">T</code><code class="o">&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>This is a <a data-primary="wildcard instantiations" data-type="indexterm" id="id1532"/>wildcard instantiation that we mentioned in <a data-type="xref" href="#learnjava6-CHP-7-SECT-5">“Parameterized Type Relationships”</a>. In this case, it is an interface, so we can read the <code>extends</code> in the <code>sort()</code> return type as <code>implements</code> if it helps.</p>&#13;
&#13;
<p><code>Comparable</code> holds a <code>compareTo()</code> method for some <a data-primary="java.util package" data-secondary="Comparable interface" data-type="indexterm" id="id1533"/><a data-primary="Comparable interface" data-type="indexterm" id="id1534"/><a data-primary="compareTo() method" data-secondary="Comparable" data-type="indexterm" id="id1535"/>parameter type. A &#13;
<span class="keep-together"><code>Comparable&lt;String&gt;</code></span> means that the <code>compareTo()</code> method takes type <code>String</code>. Therefore, <code>Comparable&lt;? super T&gt;</code> is the set of instantiations of <code>Comparable</code> on <code>T</code> and all of its superclasses. A <code>Comparable&lt;T&gt;</code> suffices and, at the other end, so does a &#13;
<span class="keep-together"><code>Comparable&lt;Object&gt;</code></span>.</p>&#13;
&#13;
<p>What this means in English is that the elements must be comparable to their own type, or some supertype of their own type for the <code>sort()</code> method to use them. This ensures that the elements can all be compared to one another, but it’s not as restrictive as saying that they must all implement the <code>compareTo()</code> method themselves. Some of the elements may inherit the <code>Comparable</code> interface from a parent class that knows how to compare only to a supertype of <code>T</code>, and that is exactly what is allowed.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Application: Trees on the Field" data-type="sect1"><div class="sect1" id="learnjava6-CHP-7-SECT-8">&#13;
<h1>Application: Trees on the Field</h1>&#13;
&#13;
<p>There is a lot of <a data-primary="collections framework" data-secondary="application practice" data-type="indexterm" id="ix_collect_app"/><a data-primary="applications" data-secondary="collections" data-type="indexterm" id="ix_app_collect"/>theory in this chapter. Don’t be afraid of theory—it can help you predict behavior in novel scenarios and inspire solutions to new problems. But practice is just as important, so let’s revisit the game that we started in <a data-type="xref" href="ch05.html#learnjava6-CHP-5-SECT-1">“Classes”</a>. In particular, it’s time to store more than one object of each type.</p>&#13;
&#13;
<p>In <a data-type="xref" href="ch13.html#learnjava6-CHP-13">Chapter 13</a> we’ll cover networking and look at creating a two-player setup that would require storing multiple physicists. For now, we still have one physicist who can throw one apple at a time. But we can populate our field with several trees for target practice.</p>&#13;
&#13;
<p>Let’s add six trees. We’ll use a pair of loops so you can easily increase the tree count if you wish. Our <code>Field</code> currently stores a lone tree instance. We can upgrade that storage to a typed list (we’ll call it <code>trees</code>). From there we can approach adding and removing trees in a number of ways:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>We could create some methods for <code>Field</code> that work with the list and maybe enforce some other game rules (like managing a maximum number of trees).</p>&#13;
</li>&#13;
<li>&#13;
<p>We could just use the list directly since the <code>List</code> class already has nice methods for most of the things we want to do.</p>&#13;
</li>&#13;
<li>&#13;
<p>We could use some combination of those approaches: special methods where it makes sense for our game, and direct manipulation everywhere else.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Since we do have some game rules that are peculiar to our <code>Field</code>, we’ll take the first approach here. (But look at the examples and think about how you might alter them to use the list of trees directly.) We’ll start with an <code>addTree()</code> method. One benefit of this approach is that we can also relocate the creation of the tree instance to our method rather than creating and manipulating the tree separately. Here’s one way to add a tree at a desired point on the field:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">  </code><code class="n">List</code><code class="o">&lt;</code><code class="n">Tree</code><code class="o">&gt;</code><code class="w"> </code><code class="n">trees</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">ArrayList</code><code class="o">&lt;&gt;</code><code class="p">();</code><code class="w"/>&#13;
<code class="w">  </code><code class="c1">// other field state</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="kd">public</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">addTree</code><code class="p">(</code><code class="kt">int</code><code class="w"> </code><code class="n">x</code><code class="p">,</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="n">y</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">Tree</code><code class="w"> </code><code class="n">tree</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">Tree</code><code class="p">();</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">tree</code><code class="p">.</code><code class="na">setPosition</code><code class="p">(</code><code class="n">x</code><code class="p">,</code><code class="n">y</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">trees</code><code class="p">.</code><code class="na">add</code><code class="p">(</code><code class="n">tree</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>With that method in place, we could add a couple of trees quite quickly:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="n">Field</code><code class="w"> </code><code class="n">field</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">Field</code><code class="p">();</code><code class="w"/>&#13;
<code class="w">    </code><code class="c1">// other setup code</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">field</code><code class="p">.</code><code class="na">addTree</code><code class="p">(</code><code class="mi">100</code><code class="p">,</code><code class="mi">100</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">field</code><code class="p">.</code><code class="na">addTree</code><code class="p">(</code><code class="mi">200</code><code class="p">,</code><code class="mi">100</code><code class="p">);</code><code class="w"/></pre>&#13;
&#13;
<p>Those two lines add a pair of trees side by side. Let’s go ahead and write the loops we need to create our six trees:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="n">Field</code><code class="w"> </code><code class="n">field</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">Field</code><code class="p">();</code><code class="w"/>&#13;
<code class="w">    </code><code class="c1">// other setup code</code><code class="w"/>&#13;
<code class="w">    </code><code class="k">for</code><code class="w"> </code><code class="p">(</code><code class="kt">int</code><code class="w"> </code><code class="n">row</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">1</code><code class="p">;</code><code class="w"> </code><code class="n">row</code><code class="w"> </code><code class="o">&lt;=</code><code class="w"> </code><code class="mi">2</code><code class="p">;</code><code class="w"> </code><code class="n">row</code><code class="o">++</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="k">for</code><code class="w"> </code><code class="p">(</code><code class="kt">int</code><code class="w"> </code><code class="n">col</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">1</code><code class="p">;</code><code class="w"> </code><code class="n">col</code><code class="w"> </code><code class="o">&lt;=</code><code class="mi">3</code><code class="p">;</code><code class="w"> </code><code class="n">col</code><code class="o">++</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">        </code><code class="n">field</code><code class="p">.</code><code class="na">addTree</code><code class="p">(</code><code class="n">col</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="mi">100</code><code class="p">,</code><code class="w"> </code><code class="n">row</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="mi">100</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">}</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>Can you see now how easy it would be to add eight or nine or a hundred trees? Computers are really good at repetition.</p>&#13;
&#13;
<p>Hooray for creating our forest of apple targets! We left off a few critical details, though. Most importantly, we need to show our new forest on the screen. We also need to update our drawing method for the <code>Field</code> class so that it understands and uses our list of trees correctly. Eventually we’ll do the same for our physicists and apples as we add more functionality to our game. We’ll also need a way to remove elements that are no longer active. But first, let’s see our forest!</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="c1">// File: Field.java</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">protected</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">paintComponent</code><code class="p">(</code><code class="n">Graphics</code><code class="w"> </code><code class="n">g</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">g</code><code class="p">.</code><code class="na">setColor</code><code class="p">(</code><code class="n">fieldColor</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">g</code><code class="p">.</code><code class="na">fillRect</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="n">getWidth</code><code class="p">(),</code><code class="w"> </code><code class="n">getHeight</code><code class="p">());</code><code class="w"/>&#13;
<code class="w">    </code><code class="k">for</code><code class="w"> </code><code class="p">(</code><code class="n">Tree</code><code class="w"> </code><code class="n">t</code><code class="w"> </code><code class="p">:</code><code class="w"> </code><code class="n">trees</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="n">t</code><code class="p">.</code><code class="na">draw</code><code class="p">(</code><code class="n">g</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">}</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">physicist</code><code class="p">.</code><code class="na">draw</code><code class="p">(</code><code class="n">g</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">apple</code><code class="p">.</code><code class="na">draw</code><code class="p">(</code><code class="n">g</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>Since we are already in the <code>Field</code> class where our <code>trees</code> are stored, there is no need to write a separate function to pull out an individual tree and paint it.<a data-primary="" data-startref="ix_app_collect" data-type="indexterm" id="id1536"/><a data-primary="" data-startref="ix_collect_app" data-type="indexterm" id="id1537"/> We can use the nifty enhanced <code>for</code> loop structure and quickly get all of our trees on the field, as shown in <a data-type="xref" href="#learnjava6-CHP-7-FIG-1">Figure 7-1</a>.</p>&#13;
&#13;
<figure class="width-75"><div class="figure" id="learnjava6-CHP-7-FIG-1">&#13;
<img alt="ljv6 0701" src="assets/ljv6_0701.png"/>&#13;
<h6><span class="label">Figure 7-1. </span>Rendering all the trees in our <code>List</code></h6>&#13;
</div></figure>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Useful Features" data-type="sect1"><div class="sect1" id="learnjava6-CHP-7-SECT-9">&#13;
<h1>Useful Features</h1>&#13;
&#13;
<p>Java collections and generics are very powerful and useful additions to the language. Although some of the details we delved into in the latter half of this chapter may seem daunting, the common usage is very simple and compelling: generics make collections better. As you begin to use generics more, you will find that your code becomes more readable and more maintainable. Collections allow for elegant, efficient storage. Generics make explicit what you previously had to infer from usage.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Review Questions" data-type="sect2"><div class="sect2" id="learnjava6-CHP-7-SECT-9.1">&#13;
<h2>Review Questions</h2>&#13;
<ol>&#13;
<li>&#13;
<p>If you want to store a contact list with names and phone numbers, which kind of collection would work best?</p>&#13;
</li>&#13;
<li>&#13;
<p>What method do you use to get an iterator for the items in a <code>Set</code>?</p>&#13;
</li>&#13;
<li>&#13;
<p>How can you turn a <code>List</code> into an array?</p>&#13;
</li>&#13;
<li>&#13;
<p>How can you turn an array into a <code>List</code>?</p>&#13;
</li>&#13;
<li>&#13;
<p>What interface should you implement to sort a list using the &#13;
<span class="keep-together"><code>Collections.sort()</code></span> method?</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Code Exercises" data-type="sect2"><div class="sect2" id="learnjava6-CHP-7-SECT-9.2">&#13;
<h2>Code Exercises</h2>&#13;
<ol>&#13;
<li>&#13;
<p>The class <code>EmployeeList</code> in the <em>ch07exercises</em> folder contains a few employees loaded into a map of employee IDs and <code>Employee</code> objects, similar to the one used in several examples above. We mentioned printing these employees in a sorted fashion, but didn’t show any code. Try to sort the employees by their ID numbers. You’ll likely need to use the <code>keySet()</code> method and then create a temporary—but sortable—list from that set.</p>&#13;
</li>&#13;
<li>&#13;
<p>In <a href="ch05.html#learnjava6-CHP-5-SECT-7.3">Advanced Exercise 5.1</a>, you created a new obstacle class, <code>Hedge</code>. Update the game so that you can have multiple hedges similar to the multiple trees. Make sure all of your trees and hedges paint correctly when you run the program.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Advanced Exercises" data-type="sect2"><div class="sect2" id="learnjava6-CHP-7-SECT-9.3">&#13;
<h2>Advanced Exercises</h2>&#13;
<ol>&#13;
<li>&#13;
<p>In Code Exercise 1 above, you probably sorted the keys of the map and then used the correctly sorted keys to get the corresponding employee. For a bit more of a challenge, implement the <code>Comparable</code> interface in your <code>Employee</code> class. You can decide how you want to organize the employees: by ID, by last name, by full name, or maybe some combination of those attributes. Rather than sorting the <code>keySet()</code> collection, try sorting your newly comparable employees directly by building a temporary list from the <code>values()</code> of your map.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
</div></section>&#13;
</div></section>&#13;
<div data-type="footnotes"><p data-type="footnote" id="id1465"><sup><a href="ch07.html#id1465-marker">1</a></sup> You may also see the term <em>type variable</em> used. The Java Language Specification mostly uses <em>parameter</em> so that’s what we try to stick with, but you may see both names used in the wild.</p><p data-type="footnote" id="id1468"><sup><a href="ch07.html#id1468-marker">2</a></sup> That is, unless you want to use a generic type in a nongeneric way. We’ll talk about “raw” types later in this chapter.</p><p data-type="footnote" id="id1481"><sup><a href="ch07.html#id1481-marker">3</a></sup> For those of you who might like some context for the title of this section, here is where it comes from. Our hero, Neo, is learning about his powers. <br/> Boy: Do not try and bend the spoon. That’s impossible. Instead, only try to realize the truth. <br/> Neo: What truth? <br/> Boy: There is no spoon. <br/> Neo: There is no spoon? <br/> Boy: Then you’ll see that it is not the spoon that bends, it is only yourself. <br/> —The Wachowskis. <em>The Matrix</em>. 136 minutes. Warner Brothers, 1999.</p></div></div></section></body></html>