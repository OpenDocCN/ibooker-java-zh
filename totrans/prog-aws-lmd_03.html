<html><head></head><body><section data-pdf-bookmark="Chapter 3. Programming AWS Lambda Functions" data-type="chapter" epub:type="chapter"><div class="chapter" id="ch03">&#13;
<h1><span class="label">Chapter 3. </span>Programming AWS Lambda Functions</h1>&#13;
&#13;
&#13;
<p>This chapter is about digging into what it means to build Lambda functions—what do they look like,&#13;
how do you configure how they run, and how do you specify your own environmental configuration.&#13;
You’ll learn about these topics by examining core concepts for Lambda execution environments, input&#13;
and output, timeout, memory and CPU, and finally, how Lambda uses environment variables for&#13;
application <span class="keep-together">configuration</span>.</p>&#13;
&#13;
<p>To start, let’s take a look at how Lambda functions are executed. Grab your hiking boots—it’s time&#13;
to explore.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Core Concepts: Runtime Model, Invocation" data-type="sect1"><div class="sect1" id="idm46222430323032">&#13;
<h1>Core Concepts: Runtime Model, Invocation</h1>&#13;
&#13;
<p>In <a data-type="xref" href="ch02.html#ch02">Chapter 2</a>, you<a data-primary="Lambda functions" data-secondary="core concepts for execution environments" data-type="indexterm" id="LFcore03"/> created a Java class, uploaded it to the Lambda service somewhere in the&#13;
nebulous “cloud,” and magically were able to execute that code.&#13;
You didn’t have to consider operating systems, containers, startup scripts, deployment of the code to an actual host, or JVM settings.&#13;
Nor did you think about any of those pesky “servers.” So how did your code execute?</p>&#13;
&#13;
<p>To understand this, you need to first understand the basics of the Lambda execution environment, as&#13;
shown in <a data-type="xref" href="#lambda-execution-environment">Figure 3-1</a>.</p>&#13;
&#13;
<figure><div class="figure" id="lambda-execution-environment">&#13;
<img alt="images/ch03_image01.png" src="assets/awsl_0301.png"/>&#13;
<h6><span class="label">Figure 3-1. </span>The Lambda execution environment</h6>&#13;
</div></figure>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The Lambda Execution Environment" data-type="sect2"><div class="sect2" id="idm46222429459768">&#13;
<h2>The Lambda Execution Environment</h2>&#13;
&#13;
<p>As<a data-primary="execution environment" data-secondary="overview of" data-type="indexterm" id="idm46222429238344"/><a data-primary="control plane" data-type="indexterm" id="idm46222423752088"/><a data-primary="data plane" data-type="indexterm" id="idm46222423562056"/> we mentioned in <a data-type="xref" href="ch02.html#ch02">Chapter 2</a> (see <a data-type="xref" href="ch02.html#installing_the_aws_cli">“Installing the AWS CLI”</a>), both AWS management and function&#13;
operations (often referred to as the <em>control plane</em> and <em>data plane</em>, respectively) make extensive&#13;
use of APIs. Lambda is no different and offers an API both for management of functions and for&#13;
execution of functions.</p>&#13;
&#13;
<p>A<a data-primary="invocation models" data-type="indexterm" id="idm46222423786712"/> function is executed, or <em>invoked</em>, whenever the <code>invoke</code> command of the AWS Lambda API is called.&#13;
This happens at the following times:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>When a function is triggered by an event source</p>&#13;
</li>&#13;
<li>&#13;
<p>When you use the test harness in the web console</p>&#13;
</li>&#13;
<li>&#13;
<p>When you call the Lambda API <code>invoke</code> command yourself, typically via the CLI or SDK, from your own code or scripts</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Invoking a function for the first time will start the following chain of activity that will end in&#13;
your code being executed.</p>&#13;
&#13;
<p>First, the Lambda service will create a host Linux environment—a lightweight micro-virtual&#13;
machine. You typically won’t need to worry about the precise nature of what type of environment it&#13;
is (which kernel, what distribution, etc.), but if you do care, Amazon makes that information&#13;
public. But don’t rely on it staying constant—Amazon can and does make frequent changes to the OS&#13;
of Lambda functions, often for your own benefit, including automatic security patches.</p>&#13;
&#13;
<p>Once the host environment has been created, then Lambda will start a language runtime within it—in&#13;
our case a Java virtual machine. At the time of this writing, the JVM version will always be Java 8 or Java 11.&#13;
You must supply Lambda with code compatible with the version of Java that you choose.&#13;
The JVM is started with a set of environment flags that we can’t change.</p>&#13;
&#13;
<p>You<a data-primary="Lambda Java Runtime" data-type="indexterm" id="idm46222431054168"/> may have noticed when we wrote our code that there was no “main” method—the top-level Java&#13;
application is Amazon’s own Java application server, which we’ll refer to as the <em>Lambda Java&#13;
Runtime</em>; that’s the next component to be started. The runtime is responsible for&#13;
top-level error handling, logging, and more.</p>&#13;
&#13;
<p>Of course, the Lambda Java Runtime’s primary concern is executing our code. The final steps of the&#13;
invocation chain are (a) to load our Java classes and (b) to call the handler method that we&#13;
specified during deployment.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Invocation Types" data-type="sect2"><div class="sect2" id="invocation_types_explanation">&#13;
<h2>Invocation Types</h2>&#13;
&#13;
<p>Great—our<a data-primary="execution environment" data-secondary="invocation types" data-type="indexterm" id="EEinvo03"/> code is alive! What happens next?</p>&#13;
&#13;
<p>To<a data-primary="AWS CLI" data-secondary="aws lambda invoke command" data-type="indexterm" id="idm46222430557160"/> explore this, let’s start using the AWS CLI. In <a data-type="xref" href="ch02.html#ch02">Chapter 2</a> we used the higher-level SAM CLI tool—the AWS CLI is a little closer to the guts of the AWS machine. Specifically, we’re going to use a command in the AWS CLI for calling Lambda functions: <code>aws lambda invoke</code>.</p>&#13;
&#13;
<p>Assuming you ran the examples in <a data-type="xref" href="ch02.html#ch02">Chapter 2</a>, let’s start with a small update. Open the&#13;
<em>template.yaml</em> file (which we’ll refer to as the <em>SAM template</em> occasionally from now on), and&#13;
within the properties section, add a new property named <code>FunctionName</code> with the value&#13;
<code>HelloWorldJava</code> so that the resource section looks as follows:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">HelloWorldLambda</code><code class="p">:</code>&#13;
  <code class="nt">Type</code><code class="p">:</code> <code class="l-Scalar-Plain">AWS::Serverless::Function</code>&#13;
  <code class="nt">Properties</code><code class="p">:</code>&#13;
    <code class="nt">FunctionName</code><code class="p">:</code> <code class="l-Scalar-Plain">HelloWorldJava</code>&#13;
    <code class="nt">Runtime</code><code class="p">:</code> <code class="l-Scalar-Plain">java8</code>&#13;
    <code class="nt">MemorySize</code><code class="p">:</code> <code class="l-Scalar-Plain">512</code>&#13;
    <code class="nt">Handler</code><code class="p">:</code> <code class="l-Scalar-Plain">book.HelloWorld::handler</code>&#13;
    <code class="nt">CodeUri</code><code class="p">:</code> <code class="l-Scalar-Plain">target/lambda.jar</code></pre>&#13;
&#13;
<p>Run<a data-primary="sam deploy command" data-type="indexterm" id="idm46222423485720"/> the <strong><code>sam deploy</code></strong> command from <a data-type="xref" href="ch02.html#ch02">Chapter 2</a> again. This should complete after a couple of minutes. If you go back to the Lambda console, you’ll see your strangely named Java&#13;
function has now been renamed to <code>HelloWorldJava</code>. In most real-use cases, we like using the&#13;
generated names that AWS provides, but when we’re learning about Lambda, it’s nice to be able to&#13;
refer to functions with more succinct names.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>To use the Java 11 runtime instead of Java 8, simply change the <code>Runtime:</code> property in your SAM template from <code>java8</code> to <code>java11</code>.</p>&#13;
</div>&#13;
&#13;
<p class="pagebreak-before">Let’s get back to invocation. From the terminal, run the following command:</p>&#13;
&#13;
<pre data-type="programlisting">$ aws lambda invoke \&#13;
  --invocation-type RequestResponse \&#13;
  --function-name HelloWorldJava \&#13;
  --payload \"world\" outputfile.txt</pre>&#13;
&#13;
<p>This should return the following:</p>&#13;
&#13;
<pre data-type="programlisting">{&#13;
  "StatusCode": 200,&#13;
  "ExecutedVersion": "$LATEST"&#13;
}</pre>&#13;
&#13;
<p>You can tell that everything was OK because <code>StatusCode</code> was <code>200</code>.</p>&#13;
&#13;
<p>You can also see what the Lambda function returned by executing the following:</p>&#13;
&#13;
<pre data-type="programlisting">$ cat outputfile.txt &amp;&amp; echo&#13;
"Hello, world"</pre>&#13;
&#13;
<p>When we executed the <code>invoke</code> command, the Lambda function was first instantiated, as we described in&#13;
the previous section. With instantiation complete, the Lambda Java Runtime, itself within the JVM, then called our Lambda&#13;
function with the data that we passed in the <code>payload</code> parameter—in this case the string <code>"world"</code>.</p>&#13;
&#13;
<p>Our code then ran. As a reminder, here it is:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="n">String</code> <code class="nf">handler</code><code class="o">(</code><code class="n">String</code> <code class="n">s</code><code class="o">)</code> <code class="o">{</code>&#13;
  <code class="k">return</code> <code class="s">"Hello, "</code> <code class="o">+</code> <code class="n">s</code><code class="o">;</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p>It takes our input (<code>"world"</code>), and returns <code>"Hello, world"</code>.</p>&#13;
&#13;
<p>There’s an important but subtle point here. When we called <code>invoke</code>, we specified <span class="keep-together"><code>--invocation-type&#13;
RequestResponse</code></span>—this means that we are calling the function <em>synchronously</em> (i.e., the Lambda&#13;
runtime calls our code and waits for the result). We explained this in&#13;
<a data-type="xref" href="ch01.html#what_does_a_lambda_application_look_like">“What Does a Lambda Application Look Like?”</a>. <em>Synchronous behavior</em> is useful for&#13;
scenarios like web APIs.</p>&#13;
&#13;
<p>Because we called the function synchronously, the Lambda runtime was able to return the response to&#13;
our terminal, and this is what was saved to <em>outputfile.txt</em>.</p>&#13;
&#13;
<p>Now let’s invoke the function slightly differently:</p>&#13;
&#13;
<pre data-type="programlisting">$ aws lambda invoke \&#13;
  --invocation-type Event \&#13;
  --function-name HelloWorldJava \&#13;
  --payload \"world\" outputfile.txt</pre>&#13;
&#13;
<p class="pagebreak-before">Notice that we’ve changed the <code>--invocation-type</code> flag to <code>Event</code>. The result is now as follows:</p>&#13;
&#13;
<pre data-type="programlisting">{&#13;
  "StatusCode": 202&#13;
}</pre>&#13;
&#13;
<p><code>StatusCode</code> is <code>202</code>, not <code>200</code>. <code>202</code> means <em>Accepted</em> in HTTP terms. If you take a look at&#13;
<em>outputfile.txt</em>, you’ll see that it’s empty.</p>&#13;
&#13;
<p>This time we have called the function <em>asynchronously</em>. The Lambda runtime calls our code precisely&#13;
as before, but it does not wait for, or use, the value returned by our code—that value returned by&#13;
our code is discarded. The point of using asynchronous execution is that we can perform a “side&#13;
effect” on some other function or service. In the asynchronous example in <a data-type="xref" href="ch01.html#what_does_a_lambda_application_look_like">“What Does a Lambda Application Look Like?”</a>, the side effect was to upload a file to Amazon’s S3&#13;
service—a new, resized, version of a photo.</p>&#13;
&#13;
<p>As you start using Lambda, you’ll discover that most classes of Lambda function use asynchronous&#13;
invocation, embracing the idea that Lambda is an <em>event-driven platform</em>. We’ll explore this further&#13;
later in the book when we start examining <a data-type="xref" href="ch05.html#event-sources">“Lambda Event Sources”</a>.</p>&#13;
&#13;
<p>We used the same code in the previous two examples; however, if you know that your Lambda function will never be used synchronously, you don’t need to return a value—the method can have a <code>void</code> return&#13;
type. Let’s see an example of that.</p>&#13;
&#13;
<p>First, change your function’s method to the following:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kt">void</code> <code class="nf">handler</code><code class="o">(</code><code class="n">String</code> <code class="n">s</code><code class="o">)</code> <code class="o">{</code>&#13;
  <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="s">"Hello, "</code> <code class="o">+</code> <code class="n">s</code><code class="o">);</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p>Notice that we’ve changed the return type to <code>void</code> and are now writing a message to <code>System.out</code>.</p>&#13;
&#13;
<p>Now<a data-primary="mvn package command" data-type="indexterm" id="idm46222423378936"/><a data-primary="sam deploy command" data-type="indexterm" id="idm46222423378232"/> we need to rebuild and redeploy our code. To do this, run the same two commands you did in <a data-type="xref" href="ch02.html#ch02">Chapter 2</a>:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><strong><code>mvn package</code></strong></p>&#13;
</li>&#13;
<li>&#13;
<p><strong><code>sam deploy…</code></strong></p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>where <code><strong>…</strong></code> refers to the same arguments you used before. You’re going to be running these&#13;
commands often enough that you’ll probably want to put them in a script.</p>&#13;
&#13;
<p>Now invoke the code again with the <code>Event</code> invocation type, and you should receive another&#13;
<code>"StatusCode": 202</code> response. But where does that message to <code>System.out</code> go? To understand that,&#13;
we’ll take a quick look at logging.<a data-primary="" data-startref="EEinvo03" data-type="indexterm" id="idm46222423370808"/></p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>You now know enough about the <code>mvn</code>, <code>sam</code>, and <code>aws</code> commands to run the&#13;
remaining examples in this chapter. If you get into a weird state, go to <em>CloudFormation</em> in the AWS&#13;
Web Console, delete the <code><span class="keep-together">HelloWorldLambdaJava</span></code> stack, and deploy again.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Introduction to Logging" data-type="sect2"><div class="sect2" id="idm46222430559928">&#13;
<h2>Introduction to Logging</h2>&#13;
&#13;
<p>The<a data-primary="execution environment" data-secondary="logging" data-type="indexterm" id="idm46222423364584"/><a data-primary="logging" data-secondary="CloudWatch Logs" data-type="indexterm" id="idm46222423363576"/><a data-primary="CloudWatch Logs" data-secondary="overview of" data-type="indexterm" id="idm46222423362632"/> Lambda runtime captures anything written by our function to either the standard output or&#13;
standard error process streams. In Java terms, these correspond to <code>System.out</code> and <code>System.err</code>.&#13;
Once the Lambda runtime has caught this data, it sends it to CloudWatch Logs. If you’re new to AWS,&#13;
this will need a little more explanation!</p>&#13;
&#13;
<p>CloudWatch Logs consists of a few components. The principal one is a log capturing service. It’s cheap,&#13;
dependable, easy to use and handles all the scale you can throw at it.</p>&#13;
&#13;
<p>Once CloudWatch Logs has captured log messages, there are a few ways that you can view or process them.&#13;
The simplest way is to use the CloudWatch Logs log viewer in the AWS Web Console.</p>&#13;
&#13;
<p>There are various ways to get to this, but for now open up your Lambda function’s page in the AWS Web Console (as we showed&#13;
in <a data-type="xref" href="ch02.html#running_the_lambda_function">“Running the Lambda function”</a>). If you click the Monitoring tab of that page,&#13;
you should be able to see a <em>View logs in CloudWatch</em> button—click that, as shown in <a data-type="xref" href="#accessing-lambda-logs">Figure 3-2</a>.</p>&#13;
&#13;
<figure><div class="figure" id="accessing-lambda-logs">&#13;
<img alt="images/ch03_image02.png" src="assets/awsl_0302.png"/>&#13;
<h6><span class="label">Figure 3-2. </span>Access Lambda logs</h6>&#13;
</div></figure>&#13;
&#13;
<p>What you’ll see next will depend a little on how the CloudWatch console is working, but if you’re&#13;
not already seeing log output, then click the blue <em>Search Log Group</em> button and scroll down to&#13;
the most recent log lines. You should then be able to see something like in <a data-type="xref" href="#viewing-lambda-logs">Figure 3-3</a>.</p>&#13;
&#13;
<figure><div class="figure" id="viewing-lambda-logs">&#13;
<img alt="images/ch03_image03.png" src="assets/awsl_0303.png"/>&#13;
<h6><span class="label">Figure 3-3. </span>Lambda logs</h6>&#13;
</div></figure>&#13;
&#13;
<p>Notice there on the second line is the output we wrote from our Lambda function.</p>&#13;
&#13;
<p>No good, self-respecting Java programmer does real production logging using <code><span class="keep-together">System.out.println</span></code>,&#13;
though—logging frameworks give far more flexibility and <span class="keep-together">control</span> over logging behavior.&#13;
We dig into logging practices in detail in <a data-type="xref" href="ch07.html#logging">“Logging”</a>.<a data-primary="" data-startref="LFcore03" data-type="indexterm" id="idm46222423324664"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Input, Output" data-type="sect1"><div class="sect1" id="input-output">&#13;
<h1>Input, Output</h1>&#13;
&#13;
<p>When<a data-primary="input/output" data-secondary="JSON deserialization and serialization" data-type="indexterm" id="idm46222423321848"/><a data-primary="Lambda functions" data-secondary="input and output" data-type="indexterm" id="LFinout03"/> a Lambda function is executed, it is always passed an input argument, typically referred to as&#13;
an <em>event</em>. Within the Lambda execution environment, this event is specifically always a JSON value,&#13;
and in our examples so far we’ve been handcrafting a string—by itself valid JSON.</p>&#13;
&#13;
<p>In real use cases, the input to the Lambda function will be a JSON object that represents an event&#13;
from some other component or system. For example, it may be a representation of the details of an&#13;
HTTP request, or some metadata of an image uploaded to the S3 storage service. Again, we look in&#13;
detail at tying event sources to Lambda functions later in the book—see <a data-type="xref" href="ch05.html#event-sources">“Lambda Event Sources”</a>.</p>&#13;
&#13;
<p>The JSON that we create in our test events, or that comes from event sources, is passed to the&#13;
Lambda Java Runtime. In most use cases, the Lambda Java Runtime will automatically <em>deserialize</em> this&#13;
JSON payload for us, and we have several options of how to guide this.</p>&#13;
&#13;
<p>As you saw in the previous section, when we invoke a function synchronously, we can return a useful&#13;
value to the environment. The Lambda Java Runtime will automatically <em>serialize</em> this return value&#13;
to JSON for us.</p>&#13;
&#13;
<p>How the Java Runtime performs this serialization and deserialization depends on types we specify&#13;
within the function signature, so it’s time we took a deeper look at what makes a Lambda function&#13;
statically valid.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="pagebreak-before less_space" data-pdf-bookmark="Lambda Function Method Signatures" data-type="sect2"><div class="sect2" id="idm46222423314392">&#13;
<h2>Lambda Function Method Signatures</h2>&#13;
&#13;
<p>Valid<a data-primary="input/output" data-secondary="Lambda function method signatures" data-type="indexterm" id="idm46222423312360"/><a data-primary="Java" data-secondary="Lambda function method signatures" data-type="indexterm" id="idm46222423311288"/> Java Lambda methods must fit one of the following four signatures:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><em><code>output-type handler-name</code></em><code>(</code><em><code>input-type</code></em><code> <code>input</code>)</code></p>&#13;
</li>&#13;
<li>&#13;
<p><em><code>output-type handler-name</code></em><code>(</code><em><code>input-type</code></em><code> <code>input</code>, Context context)</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>void</code> <em><code>handler-name</code></em><code>(InputStream is, OutputStream os)</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>void</code> <em><code>handler-name</code></em><code>(InputStream is, OutputStream os, Context context)</code></p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>where:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><em><code>output-type</code></em> can be <code>void</code>, a Java primitive, or a JSON-serializable type.</p>&#13;
</li>&#13;
<li>&#13;
<p><em><code>input-type</code></em> is a Java primitive, or a JSON-serializable type.</p>&#13;
</li>&#13;
<li>&#13;
<p><code>Context</code> refers to <code>com.amazonaws.services.lambda.runtime.Context</code> (we describe this more later in the chapter).</p>&#13;
</li>&#13;
<li>&#13;
<p><code>InputStream</code> and <code>OutputStream</code> refer to the types with those names in the <code>java.io</code> package.</p>&#13;
</li>&#13;
<li>&#13;
<p><em><code>handler-name</code></em> can be any valid Java method name, and we refer to it in our application’s configuration.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Java Lambda methods can be either instance methods or static methods, but must be public.</p>&#13;
&#13;
<p>A class containing a Lambda function cannot be abstract and must have a no-argument constructor—either the default constructor (i.e., no constructor specified) or an explicit no-argument&#13;
constructor. The main reason to consider using a constructor at all is for caching data between&#13;
Lambda calls, which is an advanced topic that we’ll get to later in the book—see <a data-type="xref" href="ch08.html#caching">“Caching”</a>.</p>&#13;
&#13;
<p>Beyond those limitations, there are no static typing requirements of a Java Lambda function. You are not required to&#13;
implement any interfaces or base classes, although you may do so if you desire. AWS provides a&#13;
<code>RequestHandler</code> interface if you want to be very explicit about the type of your Lambda classes,&#13;
but we have never found a need to make use of this. Also, you can if you like extend your own&#13;
classes, subject to the constructor rules, but again we find this is rarely a useful ability.</p>&#13;
&#13;
<p>You may have multiple Lambda functions defined in one class with different names, but we don’t&#13;
usually recommend this style. Since two different Lambda functions never run in the same execution&#13;
environment, we find it makes it clearer for subsequent engineers when we cleanly separate the code&#13;
for each function.</p>&#13;
&#13;
<p>Lambda functions, statically, are simple in comparison with some other application frameworks.&#13;
The first two signatures listed earlier are the most common for Java Lambdas, and we’ll look at those next.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Configuring the Handler Function in the SAM Template" data-type="sect2"><div class="sect2" id="idm46222423313768">&#13;
<h2>Configuring the Handler Function in the SAM Template</h2>&#13;
&#13;
<p>So<a data-primary="input/output" data-secondary="configuring Handler function in SAM templates" data-type="indexterm" id="idm46222423284936"/><a data-primary="Handler function" data-type="indexterm" id="handler03"/><a data-primary="AWS SAM" data-secondary="configuring Handler function in SAM templates" data-type="indexterm" id="idm46222423282888"/> far we’ve made only one change to the SAM template file—<em>template.yaml</em>—to change the&#13;
function’s name. Before we go too much further, we need to look at another property in that file:&#13;
<code>Handler</code>.</p>&#13;
&#13;
<p>Open the <em>template.yaml</em> file, and you’ll see that <code>Handler</code> is currently set to&#13;
<code>book.HelloWorld::handler</code>. What this means is that for this Lambda function, the Lambda platform&#13;
will attempt to find a method named <code>handler</code> in a class named <code>HelloWorld</code> in the package named&#13;
<code>book</code>.</p>&#13;
&#13;
<p>If you create a new class named <code>Cow</code> in a package named <code>old.macdonald.farm</code>, and you have a method&#13;
named <code>moomoo</code> that is your Lambda function, then you would set <code>Handler</code> instead to&#13;
<code>old.macdonald.farm.Cow::moomoo</code>.</p>&#13;
&#13;
<p>With this information, you’re all set to create some new Lambda handlers!</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Basic Types" data-type="sect2"><div class="sect2" id="idm46222423274744">&#13;
<h2>Basic Types</h2>&#13;
&#13;
<p><a data-type="xref" href="#EX3-1">Example 3-1</a> shows<a data-primary="input/output" data-secondary="types of handler functions" data-type="indexterm" id="idm46222423272280"/> a class with three different Lambda handler functions (yes, we just said a moment ago that we&#13;
don’t tend to use multiple Lambda functions per class in real use—we’re doing so here for&#13;
brevity!)</p>&#13;
<div data-type="example" id="EX3-1">&#13;
<h5><span class="label">Example 3-1. </span>Basic type serialization and deserialization</h5>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kn">package</code> <code class="n">book</code><code class="o">;</code>&#13;
&#13;
<code class="kd">public</code> <code class="kd">class</code> <code class="nc">StringIntegerBooleanLambda</code> <code class="o">{</code>&#13;
  <code class="kd">public</code> <code class="kt">void</code> <code class="nf">handlerString</code><code class="o">(</code><code class="n">String</code> <code class="n">s</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="s">"Hello, "</code> <code class="o">+</code> <code class="n">s</code><code class="o">);</code>&#13;
  <code class="o">}</code>&#13;
&#13;
  <code class="kd">public</code> <code class="kt">boolean</code> <code class="nf">handlerBoolean</code><code class="o">(</code><code class="kt">boolean</code> <code class="n">input</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="k">return</code> <code class="o">!</code><code class="n">input</code><code class="o">;</code>&#13;
  <code class="o">}</code>&#13;
&#13;
  <code class="kd">public</code> <code class="kt">boolean</code> <code class="nf">handlerInt</code><code class="o">(</code><code class="kt">int</code> <code class="n">input</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="k">return</code> <code class="n">input</code> <code class="o">&gt;</code> <code class="mi">100</code><code class="o">;</code>&#13;
  <code class="o">}</code>&#13;
<code class="o">}</code></pre></div>&#13;
&#13;
<p>To try this code, add the new class <code>StringIntegerBooleanLambda</code> to your source tree, change the&#13;
<code>Handler</code> in the <em>template.yaml</em> file (e.g., to <code>book.StringIntegerBooleanLambda::handlerString</code>), and&#13;
then run your package and deploy commands.</p>&#13;
&#13;
<p>The first of these functions is the same as we described in the previous section. We can test this&#13;
method by invoking it with the JSON object <code>"world"</code>, and since it had a <code>void</code> return type, it is&#13;
meant for asynchronous usage.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>From here on in you should assume that when we say to invoke&#13;
a function in an example, we mean you should invoke it <em>synchronously</em> unless we specify otherwise. You can do this either&#13;
using the <code>--invocation-type RequestResponse</code> flag when invoking from a terminal or using the <em>Test</em> functionality in the AWS Web Console.</p>&#13;
</div>&#13;
&#13;
<p>The second function can be invoked with a Boolean—any of the JSON values <code>true</code>, <code>false</code>,&#13;
<code>"true"</code>, or <code>"false"</code>—and it will also return a Boolean, the inverse of the input in this case.</p>&#13;
&#13;
<p>The final function takes an integer (either a JSON integer or a number in a JSON string, e.g., <code>5</code>&#13;
or <code>"5"</code>) and returns a Boolean.</p>&#13;
&#13;
<p>In the second and third examples we’re using a primitive type, but you may use boxed types if you&#13;
prefer. For example, you are free to use <code>java.lang.Integer</code> instead of plain <code>int</code> if you like.</p>&#13;
&#13;
<p>What’s happening in all of these cases is that the Lambda Java Runtime is deserializing the JSON&#13;
input to a simple type on our behalf. If the event that is passed can’t be deserialized to the&#13;
specified parameter type, you’ll get a failure, with a message that starts as follows:</p>&#13;
&#13;
<pre data-type="programlisting">An error occurred during JSON parsing: java.lang.RuntimeException</pre>&#13;
&#13;
<p>Strings, integers, and Booleans are the only basic types that are explicitly documented as being&#13;
supported, but with some experimentation we see other basic types, such as doubles and floats, are&#13;
also included.<a data-primary="" data-startref="handler03" data-type="indexterm" id="idm46222423200056"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Lists and Maps" data-type="sect2"><div class="sect2" id="idm46222423274120">&#13;
<h2>Lists and Maps</h2>&#13;
&#13;
<p>JSON<a data-primary="input/output" data-secondary="Lists and Maps" data-type="indexterm" id="idm46222423197320"/><a data-primary="Lists and Maps" data-type="indexterm" id="idm46222423196312"/><a data-primary="Maps and Lists" data-type="indexterm" id="idm46222423195640"/><a data-primary="input/output" data-secondary="JSON deserialization and serialization" data-type="indexterm" id="idm46222423194968"/> also includes arrays and objects/properties (see <a data-type="xref" href="#EX3-2">Example 3-2</a>). The Lambda Java Runtime will automatically&#13;
deserialize those to Java <code>List</code>s and <code>Map</code>s, respectively, and will also serialize output <code>List</code>s and&#13;
<code>Map</code>s to JSON arrays and objects.</p>&#13;
<div class="pagebreak-before" data-type="example" id="EX3-2">&#13;
<h5><span class="label">Example 3-2. </span>List and Map serialization and deserialization</h5>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kn">package</code> <code class="n">book</code><code class="o">;</code>&#13;
&#13;
<code class="kn">import</code> <code class="nn">java.util.ArrayList</code><code class="o">;</code>&#13;
<code class="kn">import</code> <code class="nn">java.util.HashMap</code><code class="o">;</code>&#13;
<code class="kn">import</code> <code class="nn">java.util.List</code><code class="o">;</code>&#13;
<code class="kn">import</code> <code class="nn">java.util.Map</code><code class="o">;</code>&#13;
<code class="kn">import</code> <code class="nn">java.util.stream.IntStream</code><code class="o">;</code>&#13;
&#13;
<code class="kd">public</code> <code class="kd">class</code> <code class="nc">ListMapLambda</code> <code class="o">{</code>&#13;
  <code class="kd">public</code> <code class="n">List</code><code class="o">&lt;</code><code class="n">Integer</code><code class="o">&gt;</code> <code class="nf">handlerList</code><code class="o">(</code><code class="n">List</code><code class="o">&lt;</code><code class="n">Integer</code><code class="o">&gt;</code> <code class="n">input</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="n">List</code><code class="o">&lt;</code><code class="n">Integer</code><code class="o">&gt;</code> <code class="n">newList</code> <code class="o">=</code> <code class="k">new</code> <code class="n">ArrayList</code><code class="o">&lt;&gt;();</code>&#13;
    <code class="n">input</code><code class="o">.</code><code class="na">forEach</code><code class="o">(</code><code class="n">x</code> <code class="o">-&gt;</code> <code class="n">newList</code><code class="o">.</code><code class="na">add</code><code class="o">(</code><code class="mi">100</code> <code class="o">+</code> <code class="n">x</code><code class="o">));</code>&#13;
    <code class="k">return</code> <code class="n">newList</code><code class="o">;</code>&#13;
  <code class="o">}</code>&#13;
&#13;
  <code class="kd">public</code> <code class="n">Map</code><code class="o">&lt;</code><code class="n">String</code><code class="o">,</code><code class="n">String</code><code class="o">&gt;</code> <code class="n">handlerMap</code><code class="o">(</code><code class="n">Map</code><code class="o">&lt;</code><code class="n">String</code><code class="o">,</code><code class="n">String</code><code class="o">&gt;</code> <code class="n">input</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="n">Map</code><code class="o">&lt;</code><code class="n">String</code><code class="o">,</code> <code class="n">String</code><code class="o">&gt;</code> <code class="n">newMap</code> <code class="o">=</code> <code class="k">new</code> <code class="n">HashMap</code><code class="o">&lt;&gt;();</code>&#13;
    <code class="n">input</code><code class="o">.</code><code class="na">forEach</code><code class="o">((</code><code class="n">k</code><code class="o">,</code> <code class="n">v</code><code class="o">)</code> <code class="o">-&gt;</code> <code class="n">newMap</code><code class="o">.</code><code class="na">put</code><code class="o">(</code><code class="s">"New Map -&gt; "</code> <code class="o">+</code> <code class="n">k</code><code class="o">,</code> <code class="n">v</code><code class="o">));</code>&#13;
    <code class="k">return</code> <code class="n">newMap</code><code class="o">;</code>&#13;
  <code class="o">}</code>&#13;
&#13;
  <code class="kd">public</code> <code class="n">Map</code><code class="o">&lt;</code><code class="n">String</code><code class="o">,</code><code class="n">Map</code><code class="o">&lt;</code><code class="n">String</code><code class="o">,</code> <code class="n">Integer</code><code class="o">&gt;&gt;</code>&#13;
    <code class="n">handlerNestedCollection</code><code class="o">(</code><code class="n">List</code><code class="o">&lt;</code><code class="n">Map</code><code class="o">&lt;</code><code class="n">String</code><code class="o">,</code> <code class="n">Integer</code><code class="o">&gt;&gt;</code> <code class="n">input</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="n">Map</code><code class="o">&lt;</code><code class="n">String</code><code class="o">,</code> <code class="n">Map</code><code class="o">&lt;</code><code class="n">String</code><code class="o">,</code> <code class="n">Integer</code><code class="o">&gt;&gt;</code> <code class="n">newMap</code> <code class="o">=</code> <code class="k">new</code> <code class="n">HashMap</code><code class="o">&lt;&gt;();</code>&#13;
    <code class="n">IntStream</code><code class="o">.</code><code class="na">range</code><code class="o">(</code><code class="mi">0</code><code class="o">,</code> <code class="n">input</code><code class="o">.</code><code class="na">size</code><code class="o">())</code>&#13;
          <code class="o">.</code><code class="na">forEach</code><code class="o">(</code><code class="n">i</code> <code class="o">-&gt;</code> <code class="n">newMap</code><code class="o">.</code><code class="na">put</code><code class="o">(</code><code class="s">"Nested at position "</code> <code class="o">+</code> <code class="n">i</code><code class="o">,</code> <code class="n">input</code><code class="o">.</code><code class="na">get</code><code class="o">(</code><code class="n">i</code><code class="o">)));</code>&#13;
    <code class="k">return</code> <code class="n">newMap</code><code class="o">;</code>&#13;
  <code class="o">}</code>&#13;
<code class="o">}</code></pre></div>&#13;
&#13;
<p>Invoking the function <code>handlerList()</code> with the JSON array <code>[ 1, 2, 3 ]</code> returns <code>[ 101, 102, 103 ]</code>. Invoking the function <code>handlerMap()</code> with the JSON object <code>{ "a" : "x", "b" : "y"}</code> returns <code>{&#13;
"New Map → a" : "x", "New Map → b" : "y" }</code>.</p>&#13;
&#13;
<p>Furthermore, you can use nested collections as you would expect; for example, invoking&#13;
<code>handlerNestedCollection()</code> with</p>&#13;
&#13;
<pre data-type="programlisting">[&#13;
  { "m" : 1, "n" : 2 },&#13;
  { "x" : 8, "y" : 9 }&#13;
]</pre>&#13;
&#13;
<p>returns</p>&#13;
&#13;
<pre class="pagebreak-before" data-type="programlisting">{&#13;
  "Nested at position 0": { "m" : 1, "n" : 2},&#13;
  "Nested at position 1": { "x": 8, "y" : 9}&#13;
}</pre>&#13;
&#13;
<p>Finally, you can also just use <code>java.lang.Object</code> as the type of the input parameter. While not&#13;
often useful in production (unless you don’t care about the input argument’s value, which is&#13;
sometimes a valid use), this can be handy at development time if you don’t know the precise format of&#13;
an event. For example, you can use <code>.getClass()</code> on the argument to find out what type it really is,&#13;
print out the <code>.toString()</code> value, etc. We’ll show you a better way of getting the JSON structure of&#13;
an event a little later in this chapter.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="POJOs and Ecosystem Types" data-type="sect2"><div class="sect2" id="pojos_and_ecosystem_types">&#13;
<h2>POJOs and Ecosystem Types</h2>&#13;
&#13;
<p>The<a data-primary="input/output" data-secondary="POJOs and ecosystem types" data-type="indexterm" id="IOpojos03"/><a data-primary="POJO (Plain Old Java Object) serialization" data-type="indexterm" id="pojo03"/> previous input types work well for very fairly simple inputs. An alternative for more complex&#13;
types is to use the Lambda Java Runtime’s automatic POJO (Plain Old Java Object) serialization.&#13;
<a data-type="xref" href="#EX3-3">Example 3-3</a> shows an example where we use this for both input and output.</p>&#13;
<div data-type="example" id="EX3-3">&#13;
<h5><span class="label">Example 3-3. </span>POJO serialization and deserialization</h5>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kn">package</code> <code class="n">book</code><code class="o">;</code>&#13;
&#13;
<code class="kd">public</code> <code class="kd">class</code> <code class="nc">PojoLambda</code> <code class="o">{</code>&#13;
  <code class="kd">public</code> <code class="n">PojoResponse</code> <code class="nf">handlerPojo</code><code class="o">(</code><code class="n">PojoInput</code> <code class="n">input</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="k">return</code> <code class="k">new</code> <code class="nf">PojoResponse</code><code class="o">(</code><code class="s">"Input was "</code> <code class="o">+</code> <code class="n">input</code><code class="o">.</code><code class="na">getA</code><code class="o">());</code>&#13;
  <code class="o">}</code>&#13;
&#13;
  <code class="kd">public</code> <code class="kd">static</code> <code class="kd">class</code> <code class="nc">PojoInput</code> <code class="o">{</code>&#13;
    <code class="kd">private</code> <code class="n">String</code> <code class="n">a</code><code class="o">;</code>&#13;
&#13;
    <code class="kd">public</code> <code class="n">String</code> <code class="nf">getA</code><code class="o">()</code> <code class="o">{</code>&#13;
      <code class="k">return</code> <code class="n">a</code><code class="o">;</code>&#13;
    <code class="o">}</code>&#13;
&#13;
    <code class="kd">public</code> <code class="kt">void</code> <code class="nf">setA</code><code class="o">(</code><code class="n">String</code> <code class="n">a</code><code class="o">)</code> <code class="o">{</code>&#13;
      <code class="k">this</code><code class="o">.</code><code class="na">a</code> <code class="o">=</code> <code class="n">a</code><code class="o">;</code>&#13;
    <code class="o">}</code>&#13;
  <code class="o">}</code>&#13;
&#13;
  <code class="kd">public</code> <code class="kd">static</code> <code class="kd">class</code> <code class="nc">PojoResponse</code> <code class="o">{</code>&#13;
    <code class="kd">private</code> <code class="kd">final</code> <code class="n">String</code> <code class="n">b</code><code class="o">;</code>&#13;
&#13;
    <code class="n">PojoResponse</code><code class="o">(</code><code class="n">String</code> <code class="n">b</code><code class="o">)</code> <code class="o">{</code>&#13;
      <code class="k">this</code><code class="o">.</code><code class="na">b</code> <code class="o">=</code> <code class="n">b</code><code class="o">;</code>&#13;
    <code class="o">}</code>&#13;
&#13;
    <code class="kd">public</code> <code class="n">String</code> <code class="nf">getB</code><code class="o">()</code> <code class="o">{</code>&#13;
      <code class="k">return</code> <code class="n">b</code><code class="o">;</code>&#13;
    <code class="o">}</code>&#13;
  <code class="o">}</code>&#13;
<code class="o">}</code></pre></div>&#13;
&#13;
<p>Obviously this is a very simple case, but it shows POJO serialization in action. We can execute this&#13;
Lambda with the input <code>{ "a" : "Hello Lambda" }</code>, and it returns <code>{ "b" : "Input was Hello Lambda"&#13;
}</code>. Let’s look a little more closely at the code.</p>&#13;
&#13;
<p>First of all, we have our handler function, <code>handlerPojo()</code>. This takes as input the type&#13;
<code>PojoInput</code>, which is a POJO class we’ve defined. POJO input classes can be static nested classes,&#13;
as we’ve written here, or regular (outer) classes. The important thing is that they need to have an&#13;
empty constructor and have field setters that follow the naming of the expected fields to be&#13;
deserialized from the input JSON. If no JSON field is found with the same name as a setter, then the POJO field will be left null. Input POJO objects need to be mutable since&#13;
the runtime will modify them after they’ve been instantiated.</p>&#13;
&#13;
<p>Our handler function interrogates the POJO object and creates a new instance of the <code>PojoResponse</code>&#13;
class, which we pass back to the Lambda runtime. The Lambda <span class="keep-together">runtime</span> serializes it to JSON by&#13;
reflecting over all the <code>get…</code> methods. There are fewer limitations on POJO output classes—since&#13;
they are not created or mutated by the Lambda runtime, you are free to construct them as you please&#13;
and free to make them immutable. And like input classes, POJO output classes can be static nested&#13;
classes or regular (outer) classes.</p>&#13;
&#13;
<p>For both POJO input and output classes, you can nest further POJO classes, using the same rules, to&#13;
serialize/deserialize nested JSON objects. Further, you can mix up POJOs and the collection types&#13;
we discussed (<code>List</code>s and <code>Map</code>s) in your input and <span class="keep-together">output</span>.</p>&#13;
&#13;
<p>The example we gave previously follows most of the documentation you’ll see online: using a <em>JavaBean</em> convention for fields. However, if you don’t want to use setters in your input class or&#13;
getters in your output class, you’re free to also use public fields. For instance, <a data-type="xref" href="#EX3-4">Example 3-4</a> shows another&#13;
example.</p>&#13;
<div data-type="example" id="EX3-4">&#13;
<h5><span class="label">Example 3-4. </span>POJO serialization and deserialization alternative definition</h5>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kn">package</code> <code class="n">book</code><code class="o">;</code>&#13;
&#13;
<code class="kd">public</code> <code class="kd">class</code> <code class="nc">PojoLambda</code> <code class="o">{</code>&#13;
  <code class="kd">public</code> <code class="n">PojoResponse</code> <code class="nf">handlerPojo</code><code class="o">(</code><code class="n">PojoInput</code> <code class="n">input</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="k">return</code> <code class="k">new</code> <code class="nf">PojoResponse</code><code class="o">(</code><code class="s">"Input was "</code> <code class="o">+</code> <code class="n">input</code><code class="o">.</code><code class="na">c</code><code class="o">);</code>&#13;
  <code class="o">}</code>&#13;
&#13;
  <code class="kd">public</code> <code class="kd">static</code> <code class="kd">class</code> <code class="nc">PojoInput</code> <code class="o">{</code>&#13;
    <code class="kd">public</code> <code class="n">String</code> <code class="n">c</code><code class="o">;</code>&#13;
  <code class="o">}</code>&#13;
&#13;
  <code class="kd">public</code> <code class="kd">static</code> <code class="kd">class</code> <code class="nc">PojoResponse</code> <code class="o">{</code>&#13;
    <code class="kd">public</code> <code class="kd">final</code> <code class="n">String</code> <code class="n">d</code><code class="o">;</code>&#13;
&#13;
    <code class="n">PojoResponse</code><code class="o">(</code><code class="n">String</code> <code class="n">d</code><code class="o">)</code> <code class="o">{</code>&#13;
      <code class="k">this</code><code class="o">.</code><code class="na">d</code> <code class="o">=</code> <code class="n">d</code><code class="o">;</code>&#13;
    <code class="o">}</code>&#13;
  <code class="o">}</code>&#13;
<code class="o">}</code></pre></div>&#13;
&#13;
<p>We can execute this Lambda with the input <code>{ "c" : "Hello Lambda" }</code>, and it returns <code>{ "d" :&#13;
"Input was Hello Lambda" }</code>.</p>&#13;
&#13;
<p>One of the main uses for POJO input deserialization is when you tie your Lambda function to one of&#13;
the AWS ecosystem Lambda event sources. Here’s an example of a handler function that would process&#13;
the event of an object being uploaded to the S3 storage service:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kt">void</code> <code class="nf">handler</code><code class="o">(</code><code class="n">S3Event</code> <code class="n">input</code><code class="o">)</code> <code class="o">{</code>&#13;
  <code class="c1">// …</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p><code>S3Event</code> is a type that you can access from an AWS library dependency—we discuss this more in&#13;
<a data-type="xref" href="ch05.html#serverless-data-pipeline-example">“Example: Building a Serverless Data Pipeline”</a>. You’re also free to build your own POJO classes to handle AWS events.<a data-primary="" data-startref="IOpojos03" data-type="indexterm" id="idm46222422606008"/><a data-primary="" data-startref="pojo03" data-type="indexterm" id="idm46222422605128"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Streams" data-type="sect2"><div class="sect2" id="idm46222422950568">&#13;
<h2>Streams</h2>&#13;
&#13;
<p>The<a data-primary="input/output" data-secondary="streams" data-type="indexterm" id="idm46222422602488"/><a data-primary="streams" data-type="indexterm" id="idm46222422643064"/> input/output types we’ve covered so far will be useful for you in many, and possibly all, of&#13;
your use of Lambda in the real world. But what if you have a fairly dynamic and/or complicated&#13;
structure that you can’t, or don’t want to, use any of the previous deserialization methods for?</p>&#13;
&#13;
<p>The answer is to use option 3 or 4 of the valid signature list, making use of <code>java.io.InputStream</code>&#13;
for the event parameter. This gives you access to the raw bytes passed to your Lambda function.</p>&#13;
&#13;
<p>The signature for a Lambda using an <code>InputStream</code> is a little different in that it always has a <code>void</code>&#13;
return type. If you&#13;
take an <code>InputStream</code> as a parameter, you must also take a <code>java.io.OutputStream</code> as the second&#13;
parameter. To return a result from such a handler function, you need to write to the <code>OutputStream</code>.</p>&#13;
&#13;
<p><a data-type="xref" href="#EX3-5">Example 3-5</a> shows a handler that can process streams.</p>&#13;
<div data-type="example" id="EX3-5">&#13;
<h5><span class="label">Example 3-5. </span>Using streams as handler parameters</h5>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kn">package</code> <code class="n">book</code><code class="o">;</code>&#13;
&#13;
<code class="kn">import</code> <code class="nn">java.io.IOException</code><code class="o">;</code>&#13;
<code class="kn">import</code> <code class="nn">java.io.InputStream</code><code class="o">;</code>&#13;
<code class="kn">import</code> <code class="nn">java.io.OutputStream</code><code class="o">;</code>&#13;
&#13;
<code class="kd">public</code> <code class="kd">class</code> <code class="nc">StreamLambda</code> <code class="o">{</code>&#13;
  <code class="kd">public</code> <code class="kt">void</code> <code class="nf">handlerStream</code><code class="o">(</code><code class="n">InputStream</code> <code class="n">inputStream</code><code class="o">,</code> <code class="n">OutputStream</code> <code class="n">outputStream</code><code class="o">)</code>&#13;
    <code class="kd">throws</code> <code class="n">IOException</code> <code class="o">{</code>&#13;
    <code class="kt">int</code> <code class="n">letter</code><code class="o">;</code>&#13;
    <code class="k">while</code><code class="o">((</code><code class="n">letter</code> <code class="o">=</code> <code class="n">inputStream</code><code class="o">.</code><code class="na">read</code><code class="o">())</code> <code class="o">!=</code> <code class="o">-</code><code class="mi">1</code><code class="o">)</code>&#13;
    <code class="o">{</code>&#13;
      <code class="n">outputStream</code><code class="o">.</code><code class="na">write</code><code class="o">(</code><code class="n">Character</code><code class="o">.</code><code class="na">toUpperCase</code><code class="o">(</code><code class="n">letter</code><code class="o">));</code>&#13;
    <code class="o">}</code>&#13;
  <code class="o">}</code>&#13;
<code class="o">}</code></pre></div>&#13;
&#13;
<p>If we execute this handler with the input <code>"Hello World"</code>, it will write <code>"HELLO WORLD"</code> to the&#13;
output stream, which becomes the function’s result.</p>&#13;
&#13;
<p>You may well want to use your own JSON manipulation code if you’re using an <code>InputStream</code>, but we’ll&#13;
leave that as an exercise to the reader. You should also practice good stream hygiene—error&#13;
checking, closing, etc.</p>&#13;
&#13;
<p>For more on this subject, see the official documentation on <a href="https://oreil.ly/oXm39">using streams in handler functions</a>.</p>&#13;
&#13;
<p>One particularly handy use of this type of Lambda function is at development time when you don’t&#13;
know the structure of the event you are coding for. <a data-type="xref" href="#EX3-6">Example 3-6</a> will log the received&#13;
event to CloudWatch Logs so you can see what it is.</p>&#13;
<div data-type="example" id="EX3-6">&#13;
<h5><span class="label">Example 3-6. </span>Log received event to CloudWatch Logs</h5>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kn">package</code> <code class="n">book</code><code class="o">;</code>&#13;
&#13;
<code class="kn">import</code> <code class="nn">java.io.InputStream</code><code class="o">;</code>&#13;
<code class="kn">import</code> <code class="nn">java.io.OutputStream</code><code class="o">;</code>&#13;
&#13;
<code class="kd">public</code> <code class="kd">class</code> <code class="nc">WhatIsMyLambdaEvent</code> <code class="o">{</code>&#13;
  <code class="kd">public</code> <code class="kt">void</code> <code class="nf">handler</code><code class="o">(</code><code class="n">InputStream</code> <code class="n">is</code><code class="o">,</code> <code class="n">OutputStream</code> <code class="n">os</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="n">java</code><code class="o">.</code><code class="na">util</code><code class="o">.</code><code class="na">Scanner</code> <code class="n">s</code> <code class="o">=</code> <code class="k">new</code> <code class="n">java</code><code class="o">.</code><code class="na">util</code><code class="o">.</code><code class="na">Scanner</code><code class="o">(</code><code class="n">is</code><code class="o">).</code><code class="na">useDelimiter</code><code class="o">(</code><code class="s">"\\A"</code><code class="o">);</code>&#13;
    <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="n">s</code><code class="o">.</code><code class="na">hasNext</code><code class="o">()</code> <code class="o">?</code> <code class="n">s</code><code class="o">.</code><code class="na">next</code><code class="o">()</code> <code class="o">:</code> <code class="s">"No input detected"</code><code class="o">);</code>&#13;
  <code class="o">}</code>&#13;
<code class="o">}</code></pre></div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Context" data-type="sect2"><div class="sect2" id="idm46222422603592">&#13;
<h2>Context</h2>&#13;
&#13;
<p>So<a data-primary="input/output" data-secondary="Context object" data-type="indexterm" id="IOcontext03"/> far we’ve covered signature formats 1 and 3 of our earlier list, but what of 2 and 4? What’s that&#13;
<code>Context</code> object about?</p>&#13;
&#13;
<p>In all of our examples so far, the only input we’ve taken for a Lambda handler function is that of&#13;
the event that occurred. But that’s not the only information the handler can receive when it wants&#13;
to do some processing. Additionally, you can add a <code>com.amazonaws.services.lambda.runtime.Context</code>&#13;
parameter to the end of any handler parameter list, and the runtime will pass in an interesting&#13;
object that you can use. Let’s look at an example (<a data-type="xref" href="#EX3-7">Example 3-7</a>).</p>&#13;
<div data-type="example" id="EX3-7">&#13;
<h5><span class="label">Example 3-7. </span>Examining the Context object</h5>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kn">package</code> <code class="n">book</code><code class="o">;</code>&#13;
&#13;
<code class="kn">import</code> <code class="nn">com.amazonaws.services.lambda.runtime.Context</code><code class="o">;</code>&#13;
&#13;
<code class="kn">import</code> <code class="nn">java.util.HashMap</code><code class="o">;</code>&#13;
<code class="kn">import</code> <code class="nn">java.util.Map</code><code class="o">;</code>&#13;
&#13;
<code class="kd">public</code> <code class="kd">class</code> <code class="nc">ContextLambda</code> <code class="o">{</code>&#13;
  <code class="kd">public</code> <code class="n">Map</code><code class="o">&lt;</code><code class="n">String</code><code class="o">,</code><code class="n">Object</code><code class="o">&gt;</code> <code class="n">handler</code> <code class="o">(</code><code class="n">Object</code> <code class="n">input</code><code class="o">,</code> <code class="n">Context</code> <code class="n">context</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="n">Map</code><code class="o">&lt;</code><code class="n">String</code><code class="o">,</code> <code class="n">Object</code><code class="o">&gt;</code> <code class="n">toReturn</code> <code class="o">=</code> <code class="k">new</code> <code class="n">HashMap</code><code class="o">&lt;&gt;();</code>&#13;
    <code class="n">toReturn</code><code class="o">.</code><code class="na">put</code><code class="o">(</code><code class="s">"getMemoryLimitInMB"</code><code class="o">,</code> <code class="n">context</code><code class="o">.</code><code class="na">getMemoryLimitInMB</code><code class="o">()</code> <code class="o">+</code> <code class="s">""</code><code class="o">);</code>&#13;
    <code class="n">toReturn</code><code class="o">.</code><code class="na">put</code><code class="o">(</code><code class="s">"getFunctionName"</code><code class="o">,</code><code class="n">context</code><code class="o">.</code><code class="na">getFunctionName</code><code class="o">());</code>&#13;
    <code class="n">toReturn</code><code class="o">.</code><code class="na">put</code><code class="o">(</code><code class="s">"getFunctionVersion"</code><code class="o">,</code><code class="n">context</code><code class="o">.</code><code class="na">getFunctionVersion</code><code class="o">());</code>&#13;
    <code class="n">toReturn</code><code class="o">.</code><code class="na">put</code><code class="o">(</code><code class="s">"getInvokedFunctionArn"</code><code class="o">,</code><code class="n">context</code><code class="o">.</code><code class="na">getInvokedFunctionArn</code><code class="o">());</code>&#13;
    <code class="n">toReturn</code><code class="o">.</code><code class="na">put</code><code class="o">(</code><code class="s">"getAwsRequestId"</code><code class="o">,</code><code class="n">context</code><code class="o">.</code><code class="na">getAwsRequestId</code><code class="o">());</code>&#13;
    <code class="n">toReturn</code><code class="o">.</code><code class="na">put</code><code class="o">(</code><code class="s">"getLogStreamName"</code><code class="o">,</code><code class="n">context</code><code class="o">.</code><code class="na">getLogStreamName</code><code class="o">());</code>&#13;
    <code class="n">toReturn</code><code class="o">.</code><code class="na">put</code><code class="o">(</code><code class="s">"getLogGroupName"</code><code class="o">,</code><code class="n">context</code><code class="o">.</code><code class="na">getLogGroupName</code><code class="o">());</code>&#13;
    <code class="n">toReturn</code><code class="o">.</code><code class="na">put</code><code class="o">(</code><code class="s">"getClientContext"</code><code class="o">,</code><code class="n">context</code><code class="o">.</code><code class="na">getClientContext</code><code class="o">());</code>&#13;
    <code class="n">toReturn</code><code class="o">.</code><code class="na">put</code><code class="o">(</code><code class="s">"getIdentity"</code><code class="o">,</code><code class="n">context</code><code class="o">.</code><code class="na">getIdentity</code><code class="o">());</code>&#13;
    <code class="n">toReturn</code><code class="o">.</code><code class="na">put</code><code class="o">(</code><code class="s">"getRemainingTimeInMillis"</code><code class="o">,</code>&#13;
                   <code class="n">context</code><code class="o">.</code><code class="na">getRemainingTimeInMillis</code><code class="o">()</code> <code class="o">+</code> <code class="s">""</code><code class="o">);</code>&#13;
    <code class="k">return</code> <code class="n">toReturn</code><code class="o">;</code>&#13;
  <code class="o">}</code>&#13;
<code class="o">}</code></pre></div>&#13;
&#13;
<p>This is the first full example where we need to use a type outside of the Java standard library.&#13;
We’ll look in more detail at dependencies and packaging in the next chapter, but for now add the&#13;
following section anywhere under the root element of your <em>pom.xml</em> file:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;dependencies&gt;</code>&#13;
  <code class="nt">&lt;dependency&gt;</code>&#13;
    <code class="nt">&lt;groupId&gt;</code>com.amazonaws<code class="nt">&lt;/groupId&gt;</code>&#13;
    <code class="nt">&lt;artifactId&gt;</code>aws-lambda-java-core<code class="nt">&lt;/artifactId&gt;</code>&#13;
    <code class="nt">&lt;version&gt;</code>1.2.0<code class="nt">&lt;/version&gt;</code>&#13;
    <code class="nt">&lt;scope&gt;</code>provided<code class="nt">&lt;/scope&gt;</code>&#13;
  <code class="nt">&lt;/dependency&gt;</code>&#13;
<code class="nt">&lt;/dependencies&gt;</code></pre>&#13;
&#13;
<p>When<a data-primary="mvn package command" data-type="indexterm" id="idm46222422198808"/> you run <code>mvn package</code> now, it will compile your code using the core Lambda library provided by&#13;
AWS, enabling you to use the <code>Context</code> interface.</p>&#13;
&#13;
<p>The <code>Context</code> object gives us information about the current Lambda invocation. We can use this&#13;
information during the processing of a Lambda event. When we invoke the example (passing anything as&#13;
an input event—it won’t be used), we’ll get something like the following as a result:</p>&#13;
&#13;
<pre data-type="programlisting">{&#13;
  "getFunctionName": "ContextLambda",&#13;
  "getLogStreamName": "2019/07/24/[$LATEST]0f1b1111111111111111111111111111",&#13;
  "getInvokedFunctionArn":&#13;
    "arn:aws:lambda:us-west-2:181111111111:function:ContextLambda",&#13;
  "getIdentity": {&#13;
    "identityId": "",&#13;
    "identityPoolId": ""&#13;
  },&#13;
  "getRemainingTimeInMillis": "2967",&#13;
  "getLogGroupName": "/aws/lambda/ContextLambda",&#13;
  "getLogger": {},&#13;
  "getFunctionVersion": "$LATEST",&#13;
  "getMemoryLimitInMB": "512",&#13;
  "getClientContext": null,&#13;
  "getAwsRequestId": "2108d0a2-a271-11e8-8e33-cdbf63de49d2"&#13;
}</pre>&#13;
&#13;
<p>All the different <code>Context</code> fields are described in the <a href="https://oreil.ly/oE2hP">AWS documentation</a>.</p>&#13;
&#13;
<p>Most of these fields will stay the same whenever you call them during the processing of a particular&#13;
event, but <code>getRemainingTimeInMillis()</code> is a notable exception. It’s related to <em>timeout</em>, which is&#13;
what we look at next.<a data-primary="" data-startref="LFinout03" data-type="indexterm" id="idm46222422186952"/><a data-primary="" data-startref="IOcontext03" data-type="indexterm" id="idm46222422185976"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Timeout" data-type="sect1"><div class="sect1" id="lambda-timeout">&#13;
<h1>Timeout</h1>&#13;
&#13;
<p>Lambda functions<a data-primary="Lambda functions" data-secondary="timeouts" data-type="indexterm" id="idm46222422183176"/><a data-primary="timeouts" data-type="indexterm" id="idm46222422182168"/> are subject to a configurable timeout. You are able to specify this timeout when&#13;
you create the function, or you can update it later in the function’s <span class="keep-together">configuration</span>.</p>&#13;
&#13;
<p>At the time of this writing, the <em>maximum</em> timeout is 15 minutes. That means the longest a single invocation&#13;
of a Lambda function can run is 15 minutes. This restriction is one that AWS may increase in the&#13;
future, and they’ve done so before—for a long time the maximum timeout was 5 minutes.</p>&#13;
&#13;
<p>In our examples so far we haven’t specified a timeout setting, so it defaults to 3 seconds. That&#13;
means if our function doesn’t finish executing within 3 seconds, then the Lambda Java Runtime will&#13;
abort it. You’ll see an example of this in a moment.</p>&#13;
&#13;
<p>In the previous section, we looked at the <code>Context</code> object. Calling&#13;
<code>context.getRemainingTimeInMillis()</code> will tell you how much time to run you have left at any given&#13;
point during execution before the function is aborted by the runtime. Subsequent calls will give an&#13;
updated duration. This is useful if you are writing a fairly long-lived Lambda and want to save any&#13;
state before the timeout occurs.</p>&#13;
&#13;
<p>One question you may be asking yourself—why not always configure the timeout to the maximum of 900&#13;
seconds? As we’ll explore further in the next section, Lambda costs are based significantly on how&#13;
long functions run—if your function should only ever run for at most 10 seconds, then you don’t&#13;
want a billion invocations taking 90 times that long, since you’ll be charged 90 times as much as&#13;
you want to be.</p>&#13;
&#13;
<p>The timeout does <em>not</em> include the time our function is being instantiated—in other words, the timeout period is not started during the <em>cold start</em> of a function.&#13;
Or, to be even more precise, the timeout applies only to the time from when Lambda calls our <code>handler</code> method.&#13;
We discuss cold starts further in <a data-type="xref" href="ch08.html#cold-starts">“Cold Starts”</a>.</p>&#13;
&#13;
<p>The timeout maximum of 15 minutes is a significant constraint for Lambda functions—if you are&#13;
writing functionality that needs more than 15 minutes, you’ll need to either break it up into&#13;
multiple, orchestrated, Lambda functions, or not use Lambda at all.</p>&#13;
&#13;
<p>Enough theory, let’s look at timeouts in action.</p>&#13;
&#13;
<p><a data-type="xref" href="#EX3-8">Example 3-8</a> shows a Lambda function that will query the remaining time and then eventually fail due to&#13;
timeout.</p>&#13;
<div data-type="example" id="EX3-8">&#13;
<h5><span class="label">Example 3-8. </span>Looking at timeout with Context.getRemainingTimeInMillis()</h5>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kn">package</code> <code class="n">book</code><code class="o">;</code>&#13;
&#13;
<code class="kn">import</code> <code class="nn">com.amazonaws.services.lambda.runtime.Context</code><code class="o">;</code>&#13;
&#13;
<code class="kd">public</code> <code class="kd">class</code> <code class="nc">TimeoutLambda</code> <code class="o">{</code>&#13;
  <code class="kd">public</code> <code class="kt">void</code> <code class="nf">handler</code> <code class="o">(</code><code class="n">Object</code> <code class="n">input</code><code class="o">,</code> <code class="n">Context</code> <code class="n">context</code><code class="o">)</code> <code class="kd">throws</code> <code class="n">InterruptedException</code> <code class="o">{</code>&#13;
    <code class="k">while</code><code class="o">(</code><code class="kc">true</code><code class="o">)</code> <code class="o">{</code>&#13;
      <code class="n">Thread</code><code class="o">.</code><code class="na">sleep</code><code class="o">(</code><code class="mi">100</code><code class="o">);</code>&#13;
      <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="s">"Context.getRemainingTimeInMillis() : "</code> <code class="o">+</code>&#13;
        <code class="n">context</code><code class="o">.</code><code class="na">getRemainingTimeInMillis</code><code class="o">());</code>&#13;
    <code class="o">}</code>&#13;
  <code class="o">}</code>&#13;
<code class="o">}</code></pre></div>&#13;
&#13;
<p>Update your <em>template.yaml</em> file, adding a new property named <code>Timeout</code> to the <code>Properties</code> section&#13;
of your function. Set the value to be <code>2</code>—this says that the function’s timeout is now two seconds.&#13;
Also, remember to update your <code>Handler</code> property.</p>&#13;
&#13;
<p>Then run your package and deploy steps as usual.</p>&#13;
&#13;
<p>If we execute this using the test functionality in the web console, it will fail with the message&#13;
“Task timed out after 2.00 seconds.” The log output will be as follows:</p>&#13;
&#13;
<pre data-type="programlisting">START RequestId: 6127fe67-a406-11e8-9030-69649c02a345 Version: $LATEST&#13;
Context.getRemainingTimeInMillis() : 1857&#13;
Context.getRemainingTimeInMillis() : 1756&#13;
... Cut for brevity ...&#13;
Context.getRemainingTimeInMillis() : 252&#13;
Context.getRemainingTimeInMillis() : 152&#13;
Context.getRemainingTimeInMillis() : 51&#13;
END RequestId: 6127fe67-a406-11e8-9030-69649c02a345&#13;
REPORT RequestId: 6127fe67-a406-11e8-9030-69649c02a345	Duration: 2001.52 ms&#13;
  Billed Duration: 2000 ms 	Memory Size: 512 MB	Max Memory Used: 51 MB&#13;
2019-07-24T21:22:30.076Z 444e6ae0-9217-4cd2-8568-7585ca3fafee&#13;
  Task timed out after 2.00 seconds</pre>&#13;
&#13;
<p>Here we can see the <code>getRemainingTimeInMillis()</code> method being queried as we’d expect and then the&#13;
function finally failing as Lambda’s timeout occurs.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Memory and CPU" data-type="sect1"><div class="sect1" id="memory-and-cpu">&#13;
<h1>Memory and CPU</h1>&#13;
&#13;
<p>Lambda functions<a data-primary="memory-size setting" data-type="indexterm" id="idm46222422114648"/><a data-primary="Lambda functions" data-secondary="memory and CPU" data-type="indexterm" id="idm46222422113912"/> do not have infinite amounts of RAM, and in fact every function is configured with&#13;
a <code>memory-size</code> setting. The setting defaults to 128MB, but this is rarely enough for a production&#13;
Java Lambda function, so you should treat <code>memory-size</code> as something you actively think about&#13;
for every function.</p>&#13;
&#13;
<p><code>memory-size</code> can be as small as 64MB, although for Java Lambda functions you should probably use at&#13;
least 256MB. <code>memory-size</code> must be a multiple of 64MB.</p>&#13;
&#13;
<p>A very important thing to know is that the <code>memory-size</code> setting is not just for how much RAM your&#13;
function can use—<em>it also specifies how much CPU power you get</em>. In fact, a Lambda function’s CPU&#13;
power scales linearly from 64MB up to 1792MB. Therefore a Lambda function configured with 1024MB of&#13;
RAM has twice the CPU power of one with 512MB of RAM.</p>&#13;
&#13;
<p>A Lambda function with 1792MB RAM gets a full virtual CPU core—larger RAM settings than that&#13;
enable fractions of a second virtual core. This is worth knowing if your code is not multithreaded at&#13;
all—you may not see a CPU improvement for memory settings higher than 1792MB in such a case.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>We discuss how the Lambda execution environment interacts with multiple threads in <a data-type="xref" href="ch08.html#lambda-and-threading">“Lambda and Threading”</a>.</p>&#13;
</div>&#13;
&#13;
<p>But why should you care about this—why not always just set <code>memory-size</code> to its maximum of&#13;
3008MB? The reason is cost. AWS charges for Lambda functions by two primary factors:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>How long a function runs, rounded up to the nearest 100 ms</p>&#13;
</li>&#13;
<li>&#13;
<p>How much memory a function is specified to use</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>In other words, given the same execution duration, a Lambda function that has 2GB of RAM costs twice&#13;
as much to execute as one with 1GB of RAM. Or, one with 512MB of RAM costs 17% of one with 3008MB.&#13;
This, at scale, could be a big <span class="keep-together">difference</span>.</p>&#13;
&#13;
<p>Surely that means you should always use the smallest amount of memory possible then? No, that’s not&#13;
always the best choice. Since a function with twice as much memory of a smaller function also has&#13;
twice the CPU power, it might take half the time to execute, meaning the cost is the same, and it&#13;
gets its work done more quickly.</p>&#13;
&#13;
<p>Right-sizing Lambda functions is something of an art. We recommend you stick with somewhere between&#13;
512MB and 1GB to start with and then start tuning as your functions get bigger or as you need to&#13;
scale them.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="how-expensive-is-lambda">&#13;
<h5>How Expensive Is Lambda?</h5>&#13;
<p>Some<a data-primary="costs" data-secondary="request versus duration pricing" data-type="indexterm" id="idm46222422098424"/><a data-primary="request pricing" data-type="indexterm" id="idm46222422097400"/><a data-primary="duration pricing" data-type="indexterm" id="idm46222422096728"/><a data-primary="AWS Lambda" data-secondary="as cost-efficient choice" data-type="indexterm" id="idm46222422096056"/> people, when they first hear about Lambda, assume that it’s great for small tasks—things that don’t run very frequently—but is too expensive for “grown up” applications that service real-time multiuser applications.&#13;
How much truth is there to this?&#13;
Let’s take a look at a couple of examples.</p>&#13;
&#13;
<p>First, let’s think back to the<a data-primary="photo resizer" data-type="indexterm" id="idm46222422094264"/> photo resizer (see <a data-type="xref" href="ch01.html#file-processing-example">“File processing”</a>).&#13;
Let’s say that we set that function to use 1.5GB RAM, it takes on average 10 seconds to run, and it processes 10,000 photos per day.&#13;
Lambda pricing consists of two parts—<em>request</em> pricing, which is $0.20 per million requests, and <em>duration</em> pricing, which is $0.0000166667 per gigabyte-second. Therefore we need to calculate both parts to estimate cost for our photo resizer:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>The request cost is $0.20 × .01 = $0.002/day, or $0.06/month.</p>&#13;
</li>&#13;
<li>&#13;
<p>The duration cost is 10 (seconds/invocation) × 10,000 (invocations) × 1.5 (GB) × $0.0000166667 = $2.50/day, or $75/month.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Obviously the duration cost is the vast majority here.</p>&#13;
&#13;
<p>$75/month<a data-primary="costs" data-secondary="Lambda versus EC2" data-type="indexterm" id="idm46222422088184"/> is about the same cost as a “m5.large” EC2 instance—which is $70/month.&#13;
An m5.large EC2 instance is the smallest size VM in the m5 “general purpose” family; it has 8GB RAM and two CPUs, so it would likely be about right as an alternative to host our photo resizer.&#13;
However, Lambda<a data-primary="costs" data-secondary="benefits of Lambda" data-type="indexterm" id="idm46222422086744"/><a data-primary="AWS Lambda" data-secondary="benefits of" data-type="indexterm" id="idm46222422085800"/> has significant benefits as a solution, even though the costs appear at first glance about the same:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Lambda doesn’t require the operations cost of managing an EC2 instance—there’s no need to think about operating system patches, user management, etc. Therefore our total cost of ownership (TCO) is lower for Lambda.</p>&#13;
</li>&#13;
<li>&#13;
<p>Lambda already manages the “event driven” nature of the application, so we don’t need to build that into the version we would run on a regular server.</p>&#13;
</li>&#13;
<li>&#13;
<p>Lambda will auto-scale without effort and so will handle, without concern, any spikes in traffic. A server-based solution may become overloaded or need to be built to include buffering. In fact, the more “spikey” your application’s load, the more cost effective Lambda is as a solution.</p>&#13;
</li>&#13;
<li>&#13;
<p>Lambda is already highly available across AZs—to guarantee that availability with a server-based solution, we would need to <em>double or triple our costs</em> for two or three zones of availability.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Now<a data-primary="web API" data-type="indexterm" id="idm46222422079016"/> let’s look back to our web API (see <a data-type="xref" href="ch01.html#web-api">Figure 1-5</a>).&#13;
Let’s say we set the web API Lambda functions to use 512MB RAM and each invocation takes no more than 100 ms to run. Let’s say the API processes on average 10 requests per second (864,000 requests/day) but can peak up to 100 requests per second.</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>The request cost is $0.20 × 0.864 = $0.17/day, or $5.18/month.</p>&#13;
</li>&#13;
<li>&#13;
<p>The duration cost is 0.1 × 864,000 × 0.5 × $0.0000166667 = $0.72/day, or $21.60/month.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>In other words, we need to spend $27/month to handle 10 requests/second average, and this system could happily could peak to 10x that rate, without breaking a sweat (or increasing the costs).</p>&#13;
&#13;
<p>Now neither of these components by themselves is gargantuan in size, but they aren’t trivial either.&#13;
For many applications, these are not unrealistic performance needs and so we can see that Lambda is often going to be a cost-efficient choice of platform.</p>&#13;
&#13;
<p>The pricing example here assumes using Lambda in its regular, “on-demand” mode. Lambda has alternative pricing when using Provisioned Concurrency, which we describe in <a data-type="xref" href="ch08.html#provisioned-concurrency">“Provisioned Concurrency”</a>.</p>&#13;
</div></aside>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Environment Variables" data-type="sect1"><div class="sect1" id="environment-variables">&#13;
<h1>Environment Variables</h1>&#13;
&#13;
<p>The<a data-primary="Lambda functions" data-secondary="specifying environment variables" data-type="indexterm" id="idm46222421948296"/><a data-primary="environment variables" data-type="indexterm" id="idm46222421947304"/> previous two sections were all about Lambda’s own system configuration—what if you want to use&#13;
configuration for your own application?</p>&#13;
&#13;
<p>We can specify <em>environment variables</em> for our Lambda functions. This allows us to alter how our&#13;
function runs in different contexts for the same code. It’s very typical, for example, to specify&#13;
connection settings for external processes, or secure configuration, through environment variables.</p>&#13;
&#13;
<p>Let’s try this. <a data-type="xref" href="#EX3-9">Example 3-9</a> shows a function that reads from the environment using Java’s standard method&#13;
for doing so.</p>&#13;
<div data-type="example" id="EX3-9">&#13;
<h5><span class="label">Example 3-9. </span>Using an environment variable</h5>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kn">package</code> <code class="n">book</code><code class="o">;</code>&#13;
&#13;
<code class="kd">public</code> <code class="kd">class</code> <code class="nc">EnvVarLambda</code> <code class="o">{</code>&#13;
  <code class="kd">public</code> <code class="kt">void</code> <code class="nf">handler</code><code class="o">(</code><code class="n">Object</code> <code class="n">event</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="n">String</code> <code class="n">databaseUrl</code> <code class="o">=</code> <code class="n">System</code><code class="o">.</code><code class="na">getenv</code><code class="o">(</code><code class="s">"DATABASE_URL"</code><code class="o">);</code>&#13;
    <code class="k">if</code> <code class="o">(</code><code class="n">databaseUrl</code> <code class="o">==</code> <code class="kc">null</code> <code class="o">||</code> <code class="n">databaseUrl</code><code class="o">.</code><code class="na">isEmpty</code><code class="o">())</code>&#13;
      <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="s">"DATABASE_URL is not set"</code><code class="o">);</code>&#13;
    <code class="k">else</code>&#13;
      <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="s">"DATABASE_URL is set to: "</code> <code class="o">+</code> <code class="n">databaseUrl</code><code class="o">);</code>&#13;
  <code class="o">}</code>&#13;
<code class="o">}</code></pre></div>&#13;
&#13;
<p>Update the <em>template.yaml</em> file to point to this new class and perform the package and deploy&#13;
process.</p>&#13;
&#13;
<p>If we run this function (using any test input we like), the log output will include the following:</p>&#13;
&#13;
<pre data-type="programlisting">DATABASE_URL is not set</pre>&#13;
&#13;
<p>Now update the <em>template.yaml</em> file again so that the <code>HelloWorldLambda</code> section looks as follows&#13;
(careful with your YAML tabbing!):</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">HelloWorldLambda</code><code class="p">:</code>&#13;
  <code class="nt">Type</code><code class="p">:</code> <code class="l-Scalar-Plain">AWS::Serverless::Function</code>&#13;
  <code class="nt">Properties</code><code class="p">:</code>&#13;
    <code class="nt">FunctionName</code><code class="p">:</code> <code class="l-Scalar-Plain">HelloWorldJava</code>&#13;
    <code class="nt">Runtime</code><code class="p">:</code> <code class="l-Scalar-Plain">java8</code>&#13;
    <code class="nt">MemorySize</code><code class="p">:</code> <code class="l-Scalar-Plain">512</code>&#13;
    <code class="nt">Handler</code><code class="p">:</code> <code class="l-Scalar-Plain">book.EnvVarLambda::handler</code>&#13;
    <code class="nt">CodeUri</code><code class="p">:</code> <code class="l-Scalar-Plain">target/lambda.jar</code>&#13;
    <code class="nt">Environment</code><code class="p">:</code>&#13;
      <code class="nt">Variables</code><code class="p">:</code>&#13;
        <code class="nt">DATABASE_URL</code><code class="p">:</code> <code class="l-Scalar-Plain">my-database-url</code></pre>&#13;
&#13;
<p>After packaging and deploying, if we test the function now, the log output includes this instead:</p>&#13;
&#13;
<pre data-type="programlisting">DATABASE_URL is set to: my-database-url</pre>&#13;
&#13;
<p>We are free to update the environment configuration as much as we would like.</p>&#13;
&#13;
<p>When<a data-primary="security" data-secondary="storing sensitive data" data-type="indexterm" id="idm46222421863336"/> using environment variables, you often want to store sensitive data, for example access keys to&#13;
remote services. There are a number of ways of doing this in a secure way with Lambda, and they are&#13;
explained in Amazon’s documentation.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="pagebreak-before less_space" data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="idm46222421949400">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>The programming model for AWS Lambda is significantly different from other models that you may be used to.</p>&#13;
&#13;
<p>In this chapter, you explored what it means to program Lambda functions—what the runtime environment&#13;
is, how functions are invoked, and the different ways you can get data in and out of functions.</p>&#13;
&#13;
<p>Then you learned some aspects of configuration for Lambda functions—timeout and memory—and what those&#13;
settings mean. Finally, you saw how you can apply your own application configuration through&#13;
environment variables.</p>&#13;
&#13;
<p>Now that you know how to program Lambda functions, in the next chapter we will examine Lambda&#13;
operations—packaging, deployment, security, monitoring, and more.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Exercises" data-type="sect1"><div class="sect1" id="idm46222421858056">&#13;
<h1>Exercises</h1>&#13;
<ol>&#13;
<li>&#13;
<p>Take<a data-primary="exercises" data-secondary="programming AWS Lambda functions" data-type="indexterm" id="idm46222421799752"/> some time to work through the step-by-step descriptions in this chapter—Lambda is very&#13;
different than how you may have built and run Java applications in the past.</p>&#13;
</li>&#13;
<li>&#13;
<p>Try logging something using <code>System.err</code>—the standard error stream—instead of <code>System.out</code>.&#13;
Does the log output appear any differently to <code>System.out</code>? Does it change the result of calling the&#13;
function, either asynchronously or synchronously?</p>&#13;
</li>&#13;
<li>&#13;
<p>Deliberately call a function with invalid input to see the parsing exception described earlier:&#13;
<code>An error occurred during JSON parsing</code>. Where do you see this error? How does it impact the result&#13;
of calling the function, either asynchronously or <span class="keep-together">synchronously</span>?</p>&#13;
</li>&#13;
<li>&#13;
<p>Try building your own POJO types and calling Lambda with JSON versions of them. Do you prefer the&#13;
<em>JavaBean</em> style, or public fields?</p>&#13;
</li>&#13;
<li>&#13;
<p>Try using the <code>StreamLambda</code> described earlier that outputs the entire input event with one of the&#13;
provided test event template objects in the Lambda web console.</p>&#13;
</li>&#13;
<li>&#13;
<p>Try converting one of your classes to use a static handler method, rather than an instance method,&#13;
to confirm that it works just as well.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section></body></html>