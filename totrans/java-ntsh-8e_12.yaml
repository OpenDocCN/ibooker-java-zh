- en: Chapter 10\. File Handling and I/O
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java has had input/output (I/O) support since the very first version. However,
    due to Java’s strong desire for platform independence, the earlier versions of
    I/O functionality emphasized portability over functionality. As a result, they
    were not always easy to work with.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll see later in the chapter how the original APIs have been supplemented—they
    are now rich, fully featured, and very easy to develop with. Let’s kick off the
    chapter by looking at the original, “classic” approach to Java I/O, which the
    more modern approaches layer on top of.
  prefs: []
  type: TYPE_NORMAL
- en: Classic Java I/O
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `File` class is the cornerstone of Java’s original way to do file I/O.
    This abstraction can represent both files and directories but in doing so is sometimes
    a bit cumbersome to deal with, leading to code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This shows some of the flexibility possible with the `File` class, but it also
    demonstrates some of the problems with the abstraction. It is very general and
    thus requires a lot of methods to interrogate a `File` object in order to determine
    what it actually represents and its capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `File` class has a very large number of methods on it, but some basic functionality
    (notably a way to read the actual contents of a file) is not, and never has been,
    provided directly. The following is a quick summary of `File` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `File` class also has a few methods on it that aren’t a perfect fit for
    the abstraction. They largely involve interrogating the filesystem (e.g., inquiring
    about available free space) that the file resides on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: I/O Streams
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The I/O stream abstraction (not to be confused with the streams that are used
    when dealing with the Java 8 Collection APIs) was present in Java 1.0, as a way
    of dealing with sequential streams of bytes from disks or other sources.
  prefs: []
  type: TYPE_NORMAL
- en: 'The core of this API is a pair of abstract classes, `InputStream` and `OutputStream`.
    These are very widely used, and in fact the “standard” input and output streams,
    which are called `System.in` and `System.out`, are streams of this type. They
    are public, static fields of the `System` class, and they are often used in even
    the simplest programs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Specific subclasses of streams, including `FileInputStream` and `FileOutputStream`,
    can be used to operate on individual bytes in a file—for example, by counting
    all the times ASCII 97 (small letter *a*) occurs in a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This approach to dealing with on-disk data can lack some flexibility—most developers
    think in terms of characters, not bytes. To allow for this, the streams are usually
    combined with the higher-level `Reader` and `Writer` classes, which provide a
    character-stream level of interaction, rather than the low-level bytestream provided
    by `InputStream` and `OutputStream` and their subclasses.
  prefs: []
  type: TYPE_NORMAL
- en: Readers and Writers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By moving to an abstraction that deals in characters, rather than bytes, developers
    are presented with an API that is much more familiar and that hides many of the
    issues with character encoding, Unicode, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Reader` and `Writer` classes are intended to overlay the bytestream classes
    and to remove the need for low-level handling of I/O streams. They have several
    subclasses that are often used to layer on top of each other, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FileReader`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BufferedReader`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`StringReader`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`InputStreamReader`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FileWriter`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PrintWriter`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BufferedWriter`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To read all lines in from a file and print them out, we use a `BufferedReader`
    layered on top of a `FileReader`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If we need to read in lines from the console, rather than a file, we will usually
    use an `InputStreamReader` applied to `System.in`. Let’s look at an example where
    we want to read in lines of input from the console but treat input lines that
    start with a special character as special—commands (“metas”) to be processed,
    rather than regular text. This is a common feature of many chat programs, including
    IRC. We’ll use regular expressions from [Chapter 9](ch09.xhtml#javanut8-CHP-9)
    to help us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'To output text to a file, we can use code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This older style of Java I/O has a lot of other occasionally useful functionality.
    For example, to deal with text files, the `FilterInputStream` class is quite often
    useful. Or for threads that want to communicate in a way similar to the classic
    “piped” I/O approach, `PipedInputStream`, `PipedReader`, and their write counterparts
    are provided.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this chapter so far, we have used the language feature known as “try-with-resources”
    (TWR). This syntax was briefly introduced in [“The try-with-resources Statement”](ch02.xhtml#javanut8-CHP-2-SECT-5.18),
    but it is in conjunction with operations like I/O that it comes into its fullest
    potential, and it has granted a new lease on life to the older I/O style.
  prefs: []
  type: TYPE_NORMAL
- en: try-with-resources Revisited
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To make the most of Java’s I/O capabilities, it is important to understand how
    and when to use TWR. It is very easy to understand when code should use TWR—whenever
    it is possible to do so.
  prefs: []
  type: TYPE_NORMAL
- en: Before TWR, resources had to be closed manually; complex interactions between
    resources that failed to close led to buggy code that leaked resources.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, Oracle’s engineers estimate that 60% of the resource handling code
    in the initial JDK 6 release was incorrect. So, if even the platform authors can’t
    reliably get manual resource handling right, then all new code should definitely
    be using TWR.
  prefs: []
  type: TYPE_NORMAL
- en: The key to TWR is a new interface—`AutoCloseable`. This interface is a direct
    superinterface of `Closeable`. It marks a resource that must be automatically
    closed, and for which the compiler will insert special exception-handling code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside a TWR resource clause, only declarations of objects that implement `AutoCloseable`
    objects may appear—but the developer may declare as many as required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The consequences of this are that resources are automatically scoped to the
    `try` block. The resources (whether readable or writable) are automatically closed
    in the correct order (the reverse order to the way they were opened), and the
    compiler inserts exception handling that takes dependencies between resources
    into account.
  prefs: []
  type: TYPE_NORMAL
- en: TWR is related to similar concepts in other languages and environments, for
    example, RAII (Resource Acquisition Is Initialization) in C++. However, as discussed
    in the finalization section, TWR is limited to block scope. This minor limitation
    is because the feature is implemented by the Java source code compiler—it automatically
    inserts bytecode that calls the resource’s `close()` method when the scope is
    exited (by whatever means).
  prefs: []
  type: TYPE_NORMAL
- en: As a result, the overall effect of TWR is more similar to C#’s `using` keyword,
    rather than the C++ version of RAII. For Java developers, the best way to regard
    TWR is as “finalization done right.” As noted in [“Finalization”](ch06.xhtml#javanut8-CHP-6-SECT-4),
    new code should never directly use the finalization mechanism and should always
    use TWR instead. Older code should be refactored to use TWR as soon as is practicable,
    as it provides real tangible benefits to resource handling code.
  prefs: []
  type: TYPE_NORMAL
- en: Problems with Classic I/O
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Even with the welcome addition of `try`-with-resources, the `File` class and
    friends have a number of problems that make them less than ideal for extensive
    use when performing even standard I/O operations. For instance:'
  prefs: []
  type: TYPE_NORMAL
- en: “Missing methods” for common operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does not deal with filenames consistently across platforms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fails to have a unified model for file attributes (e.g., modeling read/write
    access)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Difficult to traverse unknown directory structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No platform- or OS-specific features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nonblocking operations for filesystems not supported
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To deal with these shortcomings, Java’s I/O has evolved over several major releases.
    With the release of Java 7, this support became truly easy and effective to use.
  prefs: []
  type: TYPE_NORMAL
- en: Modern Java I/O
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java 7 brought in a brand new I/O API—usually called NIO.2—and it should be
    considered almost a complete replacement for the original `File` approach to I/O.
  prefs: []
  type: TYPE_NORMAL
- en: The new classes are contained in the `java.nio.file` package and are considerably
    easier for many use cases. The API has two major parts. The first is a new abstraction
    called `Path` (which can be thought of as representing a file location, which
    may or may not actually exist). The second piece is lots of new convenience and
    utility methods to deal with files and filesystems. These are contained as static
    methods in the `Files` class.
  prefs: []
  type: TYPE_NORMAL
- en: Files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For example, when you are using the new `Files` functionality, a basic copy
    operation is now as simple as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s quickly survey some of the major methods in `Files`—the operation of
    most of them is pretty self-explanatory. In many cases, the methods have return
    types. We have omitted handling these, as they are rarely useful except for contrived
    examples and for duplicating the behavior of the equivalent C code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Some of the methods on `Files` provide the opportunity to pass optional arguments,
    to provide additional (possibly implementation-specific) behavior for the operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the API choices here produce occasionally annoying behavior. For example,
    by default, a copy operation will not overwrite an existing file, so we need to
    specify this behavior as a copy option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '`StandardCopyOption` is an enum that implements an interface called `CopyOption`.
    This is also implemented by `LinkOption`. So `Files.copy()` can take any number
    of either `LinkOption` or `StandardCopyOption` arguments. `LinkOption` is used
    to specify how symbolic links should be handled (provided the underlying OS supports
    symlinks, of course).'
  prefs: []
  type: TYPE_NORMAL
- en: Path
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Path` is a type that may be used to locate a file in a filesystem. It represents
    a path that is:'
  prefs: []
  type: TYPE_NORMAL
- en: System dependent
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hierarchical
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Composed of a sequence of path elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hypothetical (may not exist yet, or may have been deleted)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is therefore fundamentally different from a `File`. In particular, the system
    dependency is manifested by `Path` being an interface, not a class, which enables
    different filesystem providers to each implement the `Path` interface and provide
    for system-specific features while retaining the overall abstraction.
  prefs: []
  type: TYPE_NORMAL
- en: The elements of a `Path` consist of an optional root component, which identifies
    the filesystem hierarchy that this instance belongs to. Note that, for example,
    relative `Path` instances may not have a root component. In addition to the root,
    all `Path` instances have zero or more directory names and a name element.
  prefs: []
  type: TYPE_NORMAL
- en: The name element is the element farthest from the root of the directory hierarchy
    and represents the name of the file or directory. The `Path` can be thought of
    as consisting of the path elements joined by a special separator or delimiter.
  prefs: []
  type: TYPE_NORMAL
- en: '`Path` is an abstract concept; it isn’t necessarily bound to any physical file
    path. This allows us to talk easily about the locations of files that don’t exist
    yet. The `Path` interface provides static factory methods for creating `Path`
    instances.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: When NIO.2 was introduced in Java 7, static methods were not supported on interfaces,
    so a `Paths` class was introduced to hold the factory methods. With Java 17 the
    `Path` interface methods are recommended instead, and the `Paths` class may in
    the future be deprecated.
  prefs: []
  type: TYPE_NORMAL
- en: '`Path` provides two `of()` methods for creating `Path` objects. The usual version
    takes one or more `String` instances and uses the default filesystem provider.
    The `URI` version takes advantage of the ability of NIO.2 to plug in additional
    providers of bespoke filesystems. This is an advanced usage, and interested developers
    should consult the primary documentation. Let’s look at some simple examples of
    how to use `Path`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This example also shows the easy interoperation between `Path` and `File` objects.
    The addition of a `toFile()` method to `Path` and a `toPath()` method to `File`
    allows the developer to move effortlessly between the two APIs and allows for
    a straightforward approach to refactoring the internals of code based on `File`
    to use `Path` instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use some helpful “bridge” methods that the `Files` class also provides.
    These provide convenient access to the older I/O APIs—for example, by providing
    convenient methods to open `Writer` objects to specified `Path` locations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We’re using the `StandardOpenOption` enum, which provides similar capabilities
    to the copy options but for the case of opening a new file instead. We provide
    both `WRITE` and `CREATE`, so if the file doesn’t exist it will be created; otherwise,
    we’ll simply open it for additional writing.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example use case, we have used the `Path` API to:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `Path` corresponding to a new file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the `Files` class to create that new file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open a `Writer` to that file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write to that file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatically close it when done
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In our next example, we’ll build on this to manipulate a JAR file as a `FileSystem`
    in its own right, modifying it to add a file directly into the JAR. Recall that
    JAR files are actually just ZIP files, so this technique will also work for *.zip*
    archives:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This shows how we create a `FileSystem` object in order to create the `Path`
    objects that refer to files inside the jar, via the `getPath()` method. This enables
    the developer to essentially treat `FileSystem` objects as black boxes: they are
    automatically created via a service provider interface (SPI) mechanism.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To see which file systems are available on your machine, you can run some code
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Files` class also provides methods for handling temporary files and directories,
    which is a surprisingly common use case (and can be a source of security bugs).
    For example, let’s see how to load a resources file from within the classpath,
    copy it to a newly created temporary directory, and then safely clean up the temporary
    files (using a `Reaper` class available in the book resources online):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: One of the criticisms of Java’s original I/O APIs was the lack of support for
    native and high-performance I/O. A solution was initially added in Java 1.4, the
    Java New I/O (NIO) API, and it has been refined in later Java versions.
  prefs: []
  type: TYPE_NORMAL
- en: NIO Channels and Buffers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: NIO buffers are a low-level abstraction for high-performance I/O. They provide
    a container for a linear sequence of elements of a specific primitive type. We’ll
    work with the `ByteBuffer` (the most common case) in our examples.
  prefs: []
  type: TYPE_NORMAL
- en: ByteBuffer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is a sequence of bytes and can conceptually be thought of as a performance-critical
    alternative to working with a `byte[]`. To get the best possible performance,
    `ByteBuffer` provides support for dealing directly with the native capabilities
    of the platform the JVM is running on.
  prefs: []
  type: TYPE_NORMAL
- en: This approach is called the *direct buffers* case, and it bypasses the Java
    heap wherever possible. Direct buffers are allocated in native memory, not on
    the standard Java heap, and they are not subject to garbage collection in the
    same way as regular on-heap Java objects.
  prefs: []
  type: TYPE_NORMAL
- en: To obtain a direct `ByteBuffer`, call the `allocateDirect()` factory method.
    An on-heap version, `allocate()`, is also provided, but in practice this is not
    often used.
  prefs: []
  type: TYPE_NORMAL
- en: 'A third way to obtain a byte buffer is to `wrap()` an existing `byte[]`—this
    will give an on-heap buffer that serves to provide a more object-oriented view
    of the underlying bytes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Byte buffers are all about low-level access to the bytes. This means that developers
    have to deal with the details manually—including the need to handle the endianness
    of the bytes and the signed nature of Java’s integral primitives:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'To get data into or out of a buffer, we have two types of operation—single
    value, which reads or writes a single value, and bulk, which takes a `byte[]`
    or `ByteBuffer` and operates on a (potentially large) number of values as a single
    operation. It is from the bulk operations that we’d expect to realize performance
    gains:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The single value form also supports a form used for absolute positioning within
    the buffer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Buffers are an in-memory abstraction. To affect the outside world (e.g., the
    file or network), we need to use a `Channel`, from the package `java.nio.channels`.
    Channels represent connections to entities that can support read or write operations.
    Files and sockets are the usual examples of channels, but we could consider custom
    implementations used for low-latency data processing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Channels are open when they’re created and can subsequently be closed. Once
    closed, they cannot be reopened. Channels are usually either readable or writable,
    but not both. The key to understanding channels is that:'
  prefs: []
  type: TYPE_NORMAL
- en: Reading from a channel puts bytes into a buffer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing to a channel takes bytes from a buffer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, suppose we have a large file that we want to checksum in 16M chunks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This will use native I/O as far as possible and will avoid a lot of copying
    of bytes on and off the Java heap. If the `computeChecksum()` method has been
    well implemented, then this could be a very performant implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Mapped Byte Buffers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'These are a type of direct byte buffer that contains a memory-mapped file (or
    a region of one). They are created from a `FileChannel` object, but note that
    the `File` object corresponding to the `MappedByteBuffer` must not be used after
    the memory-mapped operations or an exception will be thrown. To mitigate this,
    we again use `try`-with-resources, to scope the objects tightly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Even with buffers, there are limitations of what can be done in Java for large
    I/O operations (e.g., transferring 10G between filesystems) that perform synchronously
    on a single thread. Before Java 7, these types of operations would typically be
    done by writing custom multithreaded code and managing a separate thread for performing
    a background copy. Let’s move on to look at the new asynchronous I/O features
    that were added with JDK 7.
  prefs: []
  type: TYPE_NORMAL
- en: Async I/O
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The key to the asynchronous functionality is new subclasses of `Channel` that
    can deal with I/O operations that need to be handed off to a background thread.
    The same functionality can be applied to large, long-running operations and to
    several other use cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we’ll deal exclusively with `AsynchronousFileChannel` for
    file I/O, but there are a couple of other asynchronous channels to be aware of.
    We’ll peek at asynchronous sockets at the end of the chapter. We’ll look at:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AsynchronousFileChannel` for file I/O'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AsynchronousSocketChannel` for client socket I/O'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AsynchronousServerSocketChannel` for asynchronous sockets that accept incoming
    connections'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are two different ways to interact with an asynchronous channel—`Future`
    style and callback style.
  prefs: []
  type: TYPE_NORMAL
- en: Future-Based Style
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A full discussion of the `Future` interface would take us too far into the
    details of Java concurrency. However, for the purpose of this chapter, it can
    be thought of as an ongoing task that may or may not have completed yet. It has
    two key methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`isDone()`'
  prefs: []
  type: TYPE_NORMAL
- en: Returns a Boolean indicating whether the task has finished.
  prefs: []
  type: TYPE_NORMAL
- en: '`get()`'
  prefs: []
  type: TYPE_NORMAL
- en: Returns the result. If finished, returns immediately. If not finished, blocks
    until done.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example of a program that reads a large file (possibly as
    large as 100 Mb) asynchronously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Callback-Based Style
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The callback style for asynchronous I/O is based on a `CompletionHandler`, which
    defines two methods, `completed()` and `failed()`, that will be called back when
    the operation either succeeds or fails.
  prefs: []
  type: TYPE_NORMAL
- en: 'This style is useful if you want immediate notification of events in asynchronous
    I/O—for example, if there are a large number of I/O operations in flight, but
    failure of any single operation is not necessarily fatal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `AsynchronousFileChannel` object is associated with a background thread
    pool, so that the I/O operation proceeds, while the original thread can get on
    with other tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `CompletionHandler` interface has two abstract methods, not one, so it cannot
    be the target type for a lambda expression, unfortunately.
  prefs: []
  type: TYPE_NORMAL
- en: By default, this uses a managed thread pool that is provided by the runtime.
    If required, it can be created to use a thread pool that is managed by the application
    (via an overloaded form of `AsynchronousFileChannel.open()`), but this is seldom
    necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, for completeness, let’s touch upon NIO’s support for multiplexed I/O.
    This enables a single thread to manage multiple channels and to examine those
    channels to see which are ready for reading or writing. The classes to support
    this are in the `java.nio.channels` package and include `SelectableChannel` and
    `Selector`.
  prefs: []
  type: TYPE_NORMAL
- en: These nonblocking multiplexed techniques can be extremely useful when you’re
    writing advanced applications that require high scalability, but a full discussion
    is outside the scope of this book. In general, the nonblocking API should only
    be used for advanced use cases when high performance or other nonfunctional requirements
    demand it.
  prefs: []
  type: TYPE_NORMAL
- en: Watch Services and Directory Searching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The last class of asynchronous services we will consider are those that watch
    a directory or visit a directory (or a tree). The watch services operate by observing
    everything that happens within a directory—for example, the creation or modification
    of files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'By contrast, the directory streams provide a view into all files currently
    in a single directory. For example, to list all the Java source files and their
    size in bytes, we can use code like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'One drawback of this API is that it will return only elements that match according
    to glob syntax, which is sometimes insufficiently flexible. We can go further
    by using the `Files.find()` and `Files.walk()` methods to address each element
    obtained by a recursive walk through the directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: It is possible to go even farther and construct advanced solutions based on
    the `FileVisitor` interface in `java.nio.file`, but that requires the developer
    to implement all four methods on the interface, rather than just using a single
    lambda expression as done here.
  prefs: []
  type: TYPE_NORMAL
- en: In the last section of this chapter, we will discuss Java’s networking support
    and the core JDK classes that enable it.
  prefs: []
  type: TYPE_NORMAL
- en: Networking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Java platform provides access to a large number of standard networking protocols,
    and these make writing simple networked applications quite easy. The core of Java’s
    network support lives in the package `java.net`, with additional extensibility
    provided by `javax.net` (and in particular, `javax.net.ssl`), all of which is
    in the module `java.base`.
  prefs: []
  type: TYPE_NORMAL
- en: One of the easiest protocols to use for building applications is HyperText Transmission
    Protocol (HTTP), the protocol used as the basic communication protocol of the
    Web.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: HTTP is the most common and popular high-level network protocol that Java supports
    out of the box. It is a very simple protocol, implemented on top of the standard
    TCP/IP stack. It can run on any network port but is usually found on port 443
    when encrypted with TLS (known as HTTPS) or port 80 when running unencrypted.
    These days, HTTPS should be the default wherever possible.
  prefs: []
  type: TYPE_NORMAL
- en: Java has two separate APIs for handling HTTP—one of which dates back to the
    earliest days of the platform, and a more modern API that arrived fully in Java
    11.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a quick look at the older API, for the sake of completeness. In
    this API, `URL` is the key class—it supports URLs of the form `http://`, `ftp://`,
    `file://`, and `https://` out of the box. It is very easy to use, and the simplest
    example of Java HTTP support is to download a particular URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'For more low-level control, including metadata about the request and response,
    we can use `URLConnection` and achieve something like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: HTTP defines “request methods,” which are the operations that a client can make
    on a remote resource. These methods are called GET, POST, HEAD, PUT, DELETE, OPTIONS,
    and TRACE.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each has slightly different usages, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: GET should only be used to retrieve a document and *never* should perform any
    side effects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HEAD is equivalent to GET except the body is not returned—useful if a program
    wants to quickly check via headers whether a URL has changed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: POST is used when we want to send data to a server for processing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By default, Java uses GET, but it does provide a way to use other methods for
    building more complex applications; however, doing so is a bit involved. In this
    next example, we’re using the echo function provided by Postman to return a view
    of the data we posted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we needed to send our query parameters in the body of a request
    and to encode them before sending. We also had to disable following of HTTP redirects
    and to treat any redirection from the server manually. This is due to a limitation
    of the `HttpURLConnection` class, which does not deal well with redirection of
    POST requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'The older API definitely shows its age, and in fact implements only version
    1.0 of the HTTP standard, which is very inefficient and considered archaic. As
    an alternative, modern Java programs can use the new API, which was added as a
    result of Java needing to support the new HTTP/2 protocol. It has been available
    in a fully supported module, `java.net.http`, since Java 11\. Let’s see a simple
    example of using the new API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Note that this API is designed to be extensible, with interfaces such as `HttpResponse.BodySubscriber`
    available for implementing custom handling. The interface also seamlessly hides
    the differences between HTTP/2 and the older HTTP/1.1 protocol, meaning that Java
    applications will be able to migrate gracefully as web servers adopt the new version.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s move on to look at the next layer down the networking stack, the Transmission
    Control Protocol (TCP).
  prefs: []
  type: TYPE_NORMAL
- en: TCP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'TCP is the basis of reliable network transport over the internet. It ensures
    that web pages and other internet traffic are delivered in a complete and comprehensible
    state. From a networking theory standpoint, the protocol properties that allow
    TCP to function as this “reliability layer” for internet traffic are:'
  prefs: []
  type: TYPE_NORMAL
- en: Connection based
  prefs: []
  type: TYPE_NORMAL
- en: Data belongs to a single logical stream (a connection).
  prefs: []
  type: TYPE_NORMAL
- en: Guaranteed in-order delivery
  prefs: []
  type: TYPE_NORMAL
- en: Data packets will be resent until they arrive.
  prefs: []
  type: TYPE_NORMAL
- en: Error checked
  prefs: []
  type: TYPE_NORMAL
- en: Damage caused by network transit will be detected and fixed automatically.
  prefs: []
  type: TYPE_NORMAL
- en: TCP is a two-way (or bidirectional) communication channel and uses a special
    numbering scheme (TCP sequence numbers) for data chunks to ensure that both sides
    of a communication stream stay in sync. To support many different services on
    the same network host, TCP uses port numbers to identify services and ensures
    that traffic intended for one port does not go to a different one.
  prefs: []
  type: TYPE_NORMAL
- en: In Java, TCP is represented by the classes `Socket` and `ServerSocket`. They
    are used to provide the capability to be the client side and server side of the
    connection, respectively—meaning that Java can be used both to connect to network
    services and as a language for implementing new services.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Java’s original socket support was reimplemented, without API changes, in Java
    13\. The classic socket APIs now share code with the more modern NIO infrastructure
    and will continue working well into the future as a result.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, let’s consider reimplementing HTTP 1.1\. This is a relatively
    simple, text-based protocol. We’ll need to implement both sides of the connection,
    so let’s start with an HTTP client on top of a TCP socket. To accomplish this,
    we will actually need to implement the details of the HTTP protocol, but we do
    have the advantage that we have complete control over the TCP socket.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will need to both read and write from the client socket, and we’ll construct
    the actual request line in accordance with the HTTP standard (which is known as
    RFC 2616, and uses explicit line-ending syntax). The resulting client code will
    look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'On the server side, we’ll need to receive possibly multiple incoming connections.
    To handle this, we’ll kick off a main server loop, then use `accept()` to take
    a new connection from the operating system. The new connection is then quickly
    passed to a separate handler class so that the main server loop can get back to
    listening for new connections. The code for this is a bit more involved than the
    client case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'When designing a protocol for applications to communicate over TCP, there’s
    a simple and profound network architecture principle, known as Postel’s Law (after
    Jon Postel, one of the fathers of the internet) that you should always keep in
    mind. It is sometimes stated as: “Be strict about what you send, and liberal about
    what you will accept.” This simple principle means that communication can remain
    broadly possible in a network system, even in the event of quite imperfect implementations.'
  prefs: []
  type: TYPE_NORMAL
- en: Postel’s Law, when combined with the general principle that the protocol should
    be as simple as possible (sometimes called the KISS principle), will make the
    developer’s job of implementing TCP-based communication much easier than it otherwise
    would be.
  prefs: []
  type: TYPE_NORMAL
- en: Below TCP is the internet’s general-purpose haulage protocol—the Internet Protocol
    (IP) itself.
  prefs: []
  type: TYPE_NORMAL
- en: IP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: IP, the “lowest common denominator” transport, provides a useful abstraction
    over the physical network technologies that are used to actually move bytes from
    A to B.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike TCP, delivery of an IP packet is not guaranteed, and a packet can be
    dropped by any overloaded system along the path. IP packets do have a destination
    but usually no routing data—it’s the responsibility of the (possibly many different)
    physical transports along the route to actually deliver the data.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to create “datagram” services in Java that are based around single
    IP packets (or those with a UDP header, instead of TCP), but this is not often
    required except for extremely low-latency applications. Java uses the class `DatagramSocket`
    to implement this functionality, although few developers should ever need to venture
    this far down the network stack.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, it’s worth noting some changes currently in-flight in the addressing
    schemes that are used across the internet. The current dominant version of IP
    in use is IPv4, which has a 32-bit space of possible network addresses. This space
    is now very badly squeezed and various mitigation techniques have been deployed
    to handle the depletion.
  prefs: []
  type: TYPE_NORMAL
- en: The next version of IP (IPv6) is being rolled out, but it is not fully accepted
    and has yet to displace IPv4, although steady progress toward it becoming the
    standard continues. As of this writing, IPv6 traffic is at about 35% of internet
    traffic and steadily rising. In the next 10 years, IPv6 is likely to overtake
    IPv4 in terms of traffic volume, and low-level networking will need to adapt to
    this radically new version.
  prefs: []
  type: TYPE_NORMAL
- en: However, for Java programmers, the good news is that the language and platform
    have been working for many years on good support for IPv6 and the changes that
    it introduces. The transition between IPv4 and IPv6 is likely to be much smoother
    and less problematic for Java applications than for many other languages.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we’ve met the file handling, I/O, and networking capabilities
    provided in Java’s SDK. However, these capabilities are not used equally often.
    The core file handling classes (especially `Path` and the rest of NIO.2) are used
    very often by Java developers, with the more advanced capabilities being less
    frequently encountered.
  prefs: []
  type: TYPE_NORMAL
- en: 'The story is different for the networking libraries. It’s good to be aware
    of these capabilities, but they are fairly basic. In practice, higher-level libraries
    provided by third parties are often used instead (e.g., Netty). The one exception:
    the one low-level JDK networking library that Java developers can expect to encounter
    relatively often is the new HTTP library in `java.net.http`.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s move on to meet some of Java’s key dynamic features—classloading and reflection—powerful
    techniques that allow code to be discovered, loaded, and executed at runtime in
    ways that were unknown at compile time.
  prefs: []
  type: TYPE_NORMAL
