- en: Chapter 10\. File Handling and I/O
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章。文件处理和I/O
- en: Java has had input/output (I/O) support since the very first version. However,
    due to Java’s strong desire for platform independence, the earlier versions of
    I/O functionality emphasized portability over functionality. As a result, they
    were not always easy to work with.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Java自第一个版本以来就支持输入/输出（I/O）功能。然而，由于Java强烈追求平台独立性，早期版本的I/O功能强调可移植性而不是功能性。因此，它们并不总是易于使用。
- en: We’ll see later in the chapter how the original APIs have been supplemented—they
    are now rich, fully featured, and very easy to develop with. Let’s kick off the
    chapter by looking at the original, “classic” approach to Java I/O, which the
    more modern approaches layer on top of.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面看到原始API是如何被补充的——它们现在非常丰富，功能完备，并且非常易于开发。让我们从查看Java I/O的原始“经典”方法开始，而更现代的方法则在其之上增加了层次。
- en: Classic Java I/O
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 经典的Java I/O
- en: 'The `File` class is the cornerstone of Java’s original way to do file I/O.
    This abstraction can represent both files and directories but in doing so is sometimes
    a bit cumbersome to deal with, leading to code like this:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '`File`类是Java原始文件I/O方式的基石。这种抽象化可以同时表示文件和目录，但在处理过程中有时会显得有些累赘，导致这样的代码：'
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This shows some of the flexibility possible with the `File` class, but it also
    demonstrates some of the problems with the abstraction. It is very general and
    thus requires a lot of methods to interrogate a `File` object in order to determine
    what it actually represents and its capabilities.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这展示了`File`类可能具有的一些灵活性，但也展示了抽象化带来的一些问题。它非常通用，因此需要大量的方法来查询`File`对象，以确定它实际代表什么以及其功能。
- en: Files
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件
- en: 'The `File` class has a very large number of methods on it, but some basic functionality
    (notably a way to read the actual contents of a file) is not, and never has been,
    provided directly. The following is a quick summary of `File` methods:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '`File`类上有大量的方法，但某些基本功能（特别是直接提供读取文件实际内容的方式）则没有，并且从未直接提供过。以下是`File`方法的快速总结：'
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `File` class also has a few methods on it that aren’t a perfect fit for
    the abstraction. They largely involve interrogating the filesystem (e.g., inquiring
    about available free space) that the file resides on:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`File`类还有一些方法并不完全适合于该抽象化。它们主要涉及对文件所在的文件系统进行询问（例如，询问可用的空闲空间）：'
- en: '[PRE2]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: I/O Streams
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: I/O流
- en: The I/O stream abstraction (not to be confused with the streams that are used
    when dealing with the Java 8 Collection APIs) was present in Java 1.0, as a way
    of dealing with sequential streams of bytes from disks or other sources.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: I/O流抽象化（不要与处理Java 8集合API时使用的流混淆）已存在于Java 1.0中，作为处理来自磁盘或其他源的顺序字节流的一种方式。
- en: 'The core of this API is a pair of abstract classes, `InputStream` and `OutputStream`.
    These are very widely used, and in fact the “standard” input and output streams,
    which are called `System.in` and `System.out`, are streams of this type. They
    are public, static fields of the `System` class, and they are often used in even
    the simplest programs:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这个API的核心是一对抽象类，`InputStream`和`OutputStream`。它们被广泛使用，事实上，“标准”输入和输出流，即称为`System.in`和`System.out`的流，属于这种类型。它们是`System`类的公共静态字段，甚至在最简单的程序中经常被使用：
- en: '[PRE3]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Specific subclasses of streams, including `FileInputStream` and `FileOutputStream`,
    can be used to operate on individual bytes in a file—for example, by counting
    all the times ASCII 97 (small letter *a*) occurs in a file:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 流的特定子类，包括`FileInputStream`和`FileOutputStream`，可以用于操作文件中的单个字节，例如，通过计算ASCII 97（小写字母*a*）在文件中出现的次数：
- en: '[PRE4]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This approach to dealing with on-disk data can lack some flexibility—most developers
    think in terms of characters, not bytes. To allow for this, the streams are usually
    combined with the higher-level `Reader` and `Writer` classes, which provide a
    character-stream level of interaction, rather than the low-level bytestream provided
    by `InputStream` and `OutputStream` and their subclasses.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 处理磁盘数据的这种方法可能缺乏一些灵活性——大多数开发人员都是以字符为单位思考，而不是以字节为单位。为了解决这个问题，这些流通常与更高级别的`Reader`和`Writer`类结合使用，提供字符流级别的交互，而不是由`InputStream`和`OutputStream`及其子类提供的低级字节流。
- en: Readers and Writers
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读者和写作者
- en: By moving to an abstraction that deals in characters, rather than bytes, developers
    are presented with an API that is much more familiar and that hides many of the
    issues with character encoding, Unicode, and so on.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 通过转向以字符为基础的抽象层，而不是字节，开发人员面对的是一个更加熟悉的API，它隐藏了许多字符编码、Unicode等问题。
- en: 'The `Reader` and `Writer` classes are intended to overlay the bytestream classes
    and to remove the need for low-level handling of I/O streams. They have several
    subclasses that are often used to layer on top of each other, such as:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`Reader`和`Writer`类旨在覆盖字节流类，并消除对I/O流的低级处理的需要。它们有几个子类经常用于彼此叠加，例如：'
- en: '`FileReader`'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FileReader`'
- en: '`BufferedReader`'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BufferedReader`'
- en: '`StringReader`'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StringReader`'
- en: '`InputStreamReader`'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InputStreamReader`'
- en: '`FileWriter`'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FileWriter`'
- en: '`PrintWriter`'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PrintWriter`'
- en: '`BufferedWriter`'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BufferedWriter`'
- en: 'To read all lines in from a file and print them out, we use a `BufferedReader`
    layered on top of a `FileReader`, like this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要从文件中读取所有行并将它们打印出来，我们使用一个在`FileReader`之上叠加的`BufferedReader`，如下所示：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If we need to read in lines from the console, rather than a file, we will usually
    use an `InputStreamReader` applied to `System.in`. Let’s look at an example where
    we want to read in lines of input from the console but treat input lines that
    start with a special character as special—commands (“metas”) to be processed,
    rather than regular text. This is a common feature of many chat programs, including
    IRC. We’ll use regular expressions from [Chapter 9](ch09.xhtml#javanut8-CHP-9)
    to help us:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要从控制台而不是文件中读取行，则通常会使用`InputStreamReader`应用于`System.in`。让我们看一个例子，我们想从控制台读取输入行，但要将以特殊字符开头的输入行视为特殊命令（“元命令”），而不是普通文本。这是许多聊天程序（包括IRC）的常见特性。我们将使用来自[第9章](ch09.xhtml#javanut8-CHP-9)的正则表达式来帮助我们：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To output text to a file, we can use code like this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要将文本输出到文件，我们可以使用以下代码：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This older style of Java I/O has a lot of other occasionally useful functionality.
    For example, to deal with text files, the `FilterInputStream` class is quite often
    useful. Or for threads that want to communicate in a way similar to the classic
    “piped” I/O approach, `PipedInputStream`, `PipedReader`, and their write counterparts
    are provided.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这种较旧的Java I/O风格还有许多其他偶尔有用的功能。例如，要处理文本文件，`FilterInputStream`类经常很有用。或者对于希望以类似于经典“管道”I/O方法进行通信的线程，提供了`PipedInputStream`，`PipedReader`及其写入对应物。
- en: Throughout this chapter so far, we have used the language feature known as “try-with-resources”
    (TWR). This syntax was briefly introduced in [“The try-with-resources Statement”](ch02.xhtml#javanut8-CHP-2-SECT-5.18),
    but it is in conjunction with operations like I/O that it comes into its fullest
    potential, and it has granted a new lease on life to the older I/O style.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在本章中一直在使用“try-with-resources”（TWR）这种语言特性。这种语法在[“try-with-resources语句”](ch02.xhtml#javanut8-CHP-2-SECT-5.18)中简要介绍过，但是结合像I/O这样的操作时，它才发挥出最大的潜力，并且它给旧的I/O风格带来了新生。
- en: try-with-resources Revisited
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 再探讨try-with-resources
- en: To make the most of Java’s I/O capabilities, it is important to understand how
    and when to use TWR. It is very easy to understand when code should use TWR—whenever
    it is possible to do so.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 要充分利用Java的I/O功能，理解何时以及如何使用TWR至关重要。只要可能，代码就应该使用TWR，这一点非常容易理解。
- en: Before TWR, resources had to be closed manually; complex interactions between
    resources that failed to close led to buggy code that leaked resources.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在TWR之前，资源必须手动关闭；资源之间复杂的交互导致有漏洞的泄漏资源的错误代码。
- en: In fact, Oracle’s engineers estimate that 60% of the resource handling code
    in the initial JDK 6 release was incorrect. So, if even the platform authors can’t
    reliably get manual resource handling right, then all new code should definitely
    be using TWR.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，Oracle的工程师们估计，初始JDK 6版本中60%的资源处理代码是错误的。因此，即使是平台的作者也无法可靠地处理手动资源处理，那么所有新代码肯定都应该使用TWR。
- en: The key to TWR is a new interface—`AutoCloseable`. This interface is a direct
    superinterface of `Closeable`. It marks a resource that must be automatically
    closed, and for which the compiler will insert special exception-handling code.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: TWR的关键在于一个新接口—`AutoCloseable`。这个接口是`Closeable`的直接超接口。它标志着一个必须自动关闭的资源，并且编译器将插入特殊的异常处理代码。
- en: 'Inside a TWR resource clause, only declarations of objects that implement `AutoCloseable`
    objects may appear—but the developer may declare as many as required:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在TWR资源子句中，只能声明实现了`AutoCloseable`接口的对象，但开发人员可以声明所需数量的对象：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The consequences of this are that resources are automatically scoped to the
    `try` block. The resources (whether readable or writable) are automatically closed
    in the correct order (the reverse order to the way they were opened), and the
    compiler inserts exception handling that takes dependencies between resources
    into account.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着资源自动限定于`try`块。这些资源（无论是可读还是可写的）会按照打开的相反顺序自动关闭，并且编译器会插入异常处理以考虑资源之间的依赖关系。
- en: TWR is related to similar concepts in other languages and environments, for
    example, RAII (Resource Acquisition Is Initialization) in C++. However, as discussed
    in the finalization section, TWR is limited to block scope. This minor limitation
    is because the feature is implemented by the Java source code compiler—it automatically
    inserts bytecode that calls the resource’s `close()` method when the scope is
    exited (by whatever means).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: TWR与其他语言和环境中的类似概念相关，例如C++中的RAII（资源获取即初始化）。然而，如终结部分所讨论的，TWR仅限于块范围。这种轻微的限制是因为该功能由Java源代码编译器实现
    —— 它在退出作用域时自动插入调用资源的`close()`方法的字节码（无论通过何种方式退出）。
- en: As a result, the overall effect of TWR is more similar to C#’s `using` keyword,
    rather than the C++ version of RAII. For Java developers, the best way to regard
    TWR is as “finalization done right.” As noted in [“Finalization”](ch06.xhtml#javanut8-CHP-6-SECT-4),
    new code should never directly use the finalization mechanism and should always
    use TWR instead. Older code should be refactored to use TWR as soon as is practicable,
    as it provides real tangible benefits to resource handling code.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，TWR的整体效果更类似于C#的`using`关键字，而不是C++版本的RAII。对于Java开发人员，理解TWR的最佳方式是“正确执行的终结”。正如在[“Finalization”](ch06.xhtml#javanut8-CHP-6-SECT-4)中所述，新代码不应直接使用终结机制，而应始终使用TWR。较旧的代码应尽快重构为使用TWR，因为它为资源处理代码提供了真正的实际好处。
- en: Problems with Classic I/O
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 经典I/O存在问题
- en: 'Even with the welcome addition of `try`-with-resources, the `File` class and
    friends have a number of problems that make them less than ideal for extensive
    use when performing even standard I/O operations. For instance:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 即使引入了`try`-with-resources，`File`类及其相关类在执行标准I/O操作时仍存在一些问题。例如：
- en: “Missing methods” for common operations
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺少常见操作的方法。
- en: Does not deal with filenames consistently across platforms
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平台之间并不一致地处理文件名。
- en: Fails to have a unified model for file attributes (e.g., modeling read/write
    access)
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有统一的文件属性模型（例如，建模读写访问）。
- en: Difficult to traverse unknown directory structures
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 难以遍历未知的目录结构
- en: No platform- or OS-specific features
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有平台或操作系统特定的功能。
- en: Nonblocking operations for filesystems not supported
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不支持文件系统的非阻塞操作。
- en: To deal with these shortcomings, Java’s I/O has evolved over several major releases.
    With the release of Java 7, this support became truly easy and effective to use.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决这些缺点，Java的I/O在几个重要版本中逐步演变。随着Java 7的发布，这种支持变得真正简单和高效。
- en: Modern Java I/O
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现代Java I/O
- en: Java 7 brought in a brand new I/O API—usually called NIO.2—and it should be
    considered almost a complete replacement for the original `File` approach to I/O.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Java 7 引入了全新的I/O API —— 通常称为NIO.2 —— 几乎完全取代了原始的`File`方法进行I/O操作。
- en: The new classes are contained in the `java.nio.file` package and are considerably
    easier for many use cases. The API has two major parts. The first is a new abstraction
    called `Path` (which can be thought of as representing a file location, which
    may or may not actually exist). The second piece is lots of new convenience and
    utility methods to deal with files and filesystems. These are contained as static
    methods in the `Files` class.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 新的类位于`java.nio.file`包中，对于许多用例来说更加简单。API由两个主要部分组成。第一个是称为`Path`的新抽象（可以视为表示文件位置，实际上可能存在也可能不存在）。第二部分是许多处理文件和文件系统的新便利和实用方法。这些方法作为`Files`类的静态方法提供。
- en: Files
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件
- en: 'For example, when you are using the new `Files` functionality, a basic copy
    operation is now as simple as:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当您使用新的`Files`功能时，基本的复制操作现在就像这样简单：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let’s quickly survey some of the major methods in `Files`—the operation of
    most of them is pretty self-explanatory. In many cases, the methods have return
    types. We have omitted handling these, as they are rarely useful except for contrived
    examples and for duplicating the behavior of the equivalent C code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速浏览一些`Files`中的主要方法——它们的大多数操作都是很明显的。在许多情况下，这些方法有返回类型。我们已经省略了处理这些内容，因为它们除了人为示例和复制等效的C代码行为外，很少有用：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Some of the methods on `Files` provide the opportunity to pass optional arguments,
    to provide additional (possibly implementation-specific) behavior for the operation.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`Files`上的一些方法提供了传递可选参数的机会，以提供额外的（可能是实现特定的）操作行为。'
- en: 'Some of the API choices here produce occasionally annoying behavior. For example,
    by default, a copy operation will not overwrite an existing file, so we need to
    specify this behavior as a copy option:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的一些API选择会产生偶尔令人讨厌的行为。例如，默认情况下，复制操作不会覆盖现有文件，因此我们需要指定此行为作为复制选项：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`StandardCopyOption` is an enum that implements an interface called `CopyOption`.
    This is also implemented by `LinkOption`. So `Files.copy()` can take any number
    of either `LinkOption` or `StandardCopyOption` arguments. `LinkOption` is used
    to specify how symbolic links should be handled (provided the underlying OS supports
    symlinks, of course).'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`StandardCopyOption`是一个实现`CopyOption`接口的枚举。这也被`LinkOption`实现。因此，`Files.copy()`可以接受任意数量的`LinkOption`或`StandardCopyOption`参数。`LinkOption`用于指定如何处理符号链接（当然，前提是底层操作系统支持符号链接）。'
- en: Path
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Path
- en: '`Path` is a type that may be used to locate a file in a filesystem. It represents
    a path that is:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`Path`是用于在文件系统中定位文件的类型。它表示一个路径，其特点是：'
- en: System dependent
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统相关
- en: Hierarchical
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分层的
- en: Composed of a sequence of path elements
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由一系列路径元素组成
- en: Hypothetical (may not exist yet, or may have been deleted)
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设性的（可能尚不存在，或已被删除）
- en: It is therefore fundamentally different from a `File`. In particular, the system
    dependency is manifested by `Path` being an interface, not a class, which enables
    different filesystem providers to each implement the `Path` interface and provide
    for system-specific features while retaining the overall abstraction.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，它与`File`基本不同。特别是，系统依赖通过`Path`作为接口而不是类来体现，这使得不同的文件系统提供者可以各自实现`Path`接口，并提供系统特定的功能，同时保留总体抽象。
- en: The elements of a `Path` consist of an optional root component, which identifies
    the filesystem hierarchy that this instance belongs to. Note that, for example,
    relative `Path` instances may not have a root component. In addition to the root,
    all `Path` instances have zero or more directory names and a name element.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`Path`的元素包括可选的根组件，它标识了此实例所属的文件系统层次结构。请注意，例如，相对`Path`实例可能没有根组件。除了根之外，所有的`Path`实例都有零个或多个目录名称和一个名称元素。'
- en: The name element is the element farthest from the root of the directory hierarchy
    and represents the name of the file or directory. The `Path` can be thought of
    as consisting of the path elements joined by a special separator or delimiter.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 名称元素是距离目录层次结构根部最远的元素，并表示文件或目录的名称。`Path`可以被认为是由特殊分隔符或分隔符连接的路径元素组成。
- en: '`Path` is an abstract concept; it isn’t necessarily bound to any physical file
    path. This allows us to talk easily about the locations of files that don’t exist
    yet. The `Path` interface provides static factory methods for creating `Path`
    instances.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`Path`是一个抽象概念；它不一定与任何物理文件路径绑定。这使得我们可以轻松地讨论尚不存在的文件的位置。`Path`接口提供了用于创建`Path`实例的静态工厂方法。'
- en: Note
  id: totrans-78
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: When NIO.2 was introduced in Java 7, static methods were not supported on interfaces,
    so a `Paths` class was introduced to hold the factory methods. With Java 17 the
    `Path` interface methods are recommended instead, and the `Paths` class may in
    the future be deprecated.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当NIO.2在Java 7中引入时，接口上不支持静态方法，因此引入了`Paths`类来保存工厂方法。到了Java 17，推荐使用`Path`接口的方法，而`Paths`类可能会在未来被弃用。
- en: '`Path` provides two `of()` methods for creating `Path` objects. The usual version
    takes one or more `String` instances and uses the default filesystem provider.
    The `URI` version takes advantage of the ability of NIO.2 to plug in additional
    providers of bespoke filesystems. This is an advanced usage, and interested developers
    should consult the primary documentation. Let’s look at some simple examples of
    how to use `Path`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`Path` 提供了两个 `of()` 方法用于创建 `Path` 对象。通常版本使用一个或多个 `String` 实例，并使用默认的文件系统提供者。`URI`
    版本利用了 NIO.2 的能力，可以插入额外提供定制文件系统的提供者。这是一个高级用法，有兴趣的开发人员应该查阅主要文档。让我们看一些如何使用 `Path`
    的简单示例：'
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This example also shows the easy interoperation between `Path` and `File` objects.
    The addition of a `toFile()` method to `Path` and a `toPath()` method to `File`
    allows the developer to move effortlessly between the two APIs and allows for
    a straightforward approach to refactoring the internals of code based on `File`
    to use `Path` instead.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 该示例还展示了 `Path` 和 `File` 对象之间的简单互操作性。`Path` 增加了 `toFile()` 方法，而 `File` 增加了 `toPath()`
    方法，允许开发人员在两个 API 之间轻松切换，并允许通过简单的方法重构基于 `File` 的代码内部，改为使用 `Path`。
- en: 'We can also use some helpful “bridge” methods that the `Files` class also provides.
    These provide convenient access to the older I/O APIs—for example, by providing
    convenient methods to open `Writer` objects to specified `Path` locations:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 `Files` 类提供的一些有用的“桥接”方法。例如，通过提供方便的方法来打开 `Writer` 对象到指定的 `Path` 位置：
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We’re using the `StandardOpenOption` enum, which provides similar capabilities
    to the copy options but for the case of opening a new file instead. We provide
    both `WRITE` and `CREATE`, so if the file doesn’t exist it will be created; otherwise,
    we’ll simply open it for additional writing.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了 `StandardOpenOption` 枚举，它提供了类似于复制选项的能力，但用于打开新文件的情况。我们同时提供了 `WRITE` 和 `CREATE`，所以如果文件不存在，它将被创建；否则，我们只是打开它以进行额外的写入操作。
- en: 'In this example use case, we have used the `Path` API to:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例用例中，我们已经使用了 `Path` API 来：
- en: Create a `Path` corresponding to a new file
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建对应于新文件的 `Path`
- en: Use the `Files` class to create that new file
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Files` 类来创建这个新文件
- en: Open a `Writer` to that file
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开一个 `Writer` 到该文件
- en: Write to that file
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向该文件写入
- en: Automatically close it when done
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在完成时自动关闭它
- en: 'In our next example, we’ll build on this to manipulate a JAR file as a `FileSystem`
    in its own right, modifying it to add a file directly into the JAR. Recall that
    JAR files are actually just ZIP files, so this technique will also work for *.zip*
    archives:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的下一个示例中，我们将在此基础上操作 JAR 文件，将其作为一个独立的 `FileSystem` 来修改，直接向 JAR 中添加文件。请记住，JAR
    文件实际上只是 ZIP 文件，因此这种技术也适用于 *.zip* 归档文件：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This shows how we create a `FileSystem` object in order to create the `Path`
    objects that refer to files inside the jar, via the `getPath()` method. This enables
    the developer to essentially treat `FileSystem` objects as black boxes: they are
    automatically created via a service provider interface (SPI) mechanism.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了我们如何创建一个 `FileSystem` 对象，以便创建引用 jar 内文件的 `Path` 对象，通过 `getPath()` 方法。这使得开发人员基本上可以将
    `FileSystem` 对象视为黑匣子：它们通过服务提供者接口（SPI）机制自动创建。
- en: 'To see which file systems are available on your machine, you can run some code
    like this:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看您的计算机上可用的文件系统，您可以运行类似于以下的代码：
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `Files` class also provides methods for handling temporary files and directories,
    which is a surprisingly common use case (and can be a source of security bugs).
    For example, let’s see how to load a resources file from within the classpath,
    copy it to a newly created temporary directory, and then safely clean up the temporary
    files (using a `Reaper` class available in the book resources online):'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`Files` 类还提供了处理临时文件和目录的方法，这是一个令人惊讶地常见的用例（也可能是安全漏洞的源头）。例如，让我们看看如何从类路径中加载资源文件，将其复制到新创建的临时目录，然后安全地清理临时文件（使用在线书籍资源中提供的
    `Reaper` 类）：'
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: One of the criticisms of Java’s original I/O APIs was the lack of support for
    native and high-performance I/O. A solution was initially added in Java 1.4, the
    Java New I/O (NIO) API, and it has been refined in later Java versions.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Java 原始 I/O API 的一个批评是缺乏对本地和高性能 I/O 的支持。在 Java 1.4 中首次添加了解决方案，即 Java 新 I/O (NIO)
    API，并在后续 Java 版本中进行了改进。
- en: NIO Channels and Buffers
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NIO 通道和缓冲区
- en: NIO buffers are a low-level abstraction for high-performance I/O. They provide
    a container for a linear sequence of elements of a specific primitive type. We’ll
    work with the `ByteBuffer` (the most common case) in our examples.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: NIO缓冲区是高性能I/O的低级抽象。它们提供了一个特定原始类型的线性序列元素的容器。我们将在示例中使用`ByteBuffer`（最常见的情况）。
- en: ByteBuffer
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ByteBuffer
- en: This is a sequence of bytes and can conceptually be thought of as a performance-critical
    alternative to working with a `byte[]`. To get the best possible performance,
    `ByteBuffer` provides support for dealing directly with the native capabilities
    of the platform the JVM is running on.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一系列字节，可以概念上看作是与`byte[]`工作的性能关键替代品。为了获得最佳性能，`ByteBuffer`提供了支持直接处理JVM运行平台的本地能力。
- en: This approach is called the *direct buffers* case, and it bypasses the Java
    heap wherever possible. Direct buffers are allocated in native memory, not on
    the standard Java heap, and they are not subject to garbage collection in the
    same way as regular on-heap Java objects.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法称为*直接缓冲区*情况，尽可能绕过Java堆。直接缓冲区在本机内存中分配，而不是在标准的Java堆上，并且不会像常规的在堆Java对象那样受垃圾收集的影响。
- en: To obtain a direct `ByteBuffer`, call the `allocateDirect()` factory method.
    An on-heap version, `allocate()`, is also provided, but in practice this is not
    often used.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取直接的`ByteBuffer`，调用`allocateDirect()`工厂方法。也提供了一个在堆上的版本`allocate()`，但在实践中这不常用。
- en: 'A third way to obtain a byte buffer is to `wrap()` an existing `byte[]`—this
    will give an on-heap buffer that serves to provide a more object-oriented view
    of the underlying bytes:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 获取字节缓冲区的第三种方法是使用`wrap()`一个现有的`byte[]` —— 这将提供一个在堆上的缓冲区，用于提供对底层字节的更面向对象的视图：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Byte buffers are all about low-level access to the bytes. This means that developers
    have to deal with the details manually—including the need to handle the endianness
    of the bytes and the signed nature of Java’s integral primitives:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 字节缓冲区都是关于对字节的低级访问。这意味着开发人员必须手动处理细节 —— 包括处理字节的字节顺序和Java整数原始类型的有符号性：
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To get data into or out of a buffer, we have two types of operation—single
    value, which reads or writes a single value, and bulk, which takes a `byte[]`
    or `ByteBuffer` and operates on a (potentially large) number of values as a single
    operation. It is from the bulk operations that we’d expect to realize performance
    gains:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要将数据输入或输出到缓冲区，我们有两种操作类型 —— 单值类型，读取或写入单个值，以及批量操作，接受一个`byte[]`或`ByteBuffer`并作为单个操作操作（可能大量的）值。我们期望从批量操作中获得性能提升：
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The single value form also supports a form used for absolute positioning within
    the buffer:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 单值形式也支持用于在缓冲区内进行绝对定位的形式：
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Buffers are an in-memory abstraction. To affect the outside world (e.g., the
    file or network), we need to use a `Channel`, from the package `java.nio.channels`.
    Channels represent connections to entities that can support read or write operations.
    Files and sockets are the usual examples of channels, but we could consider custom
    implementations used for low-latency data processing.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 缓冲区是内存中的抽象。要影响外部世界（例如文件或网络），我们需要使用`java.nio.channels`包中的`Channel`。通道代表可以支持读取或写入操作的实体连接。文件和套接字是通道的常见示例，但我们可以考虑用于低延迟数据处理的自定义实现。
- en: 'Channels are open when they’re created and can subsequently be closed. Once
    closed, they cannot be reopened. Channels are usually either readable or writable,
    but not both. The key to understanding channels is that:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 通道在创建时处于打开状态，可以随后关闭。一旦关闭，就不能重新打开。通常通道要么可读要么可写，但不能同时。理解通道的关键在于：
- en: Reading from a channel puts bytes into a buffer
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从通道读取将字节放入缓冲区
- en: Writing to a channel takes bytes from a buffer
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向通道写入从缓冲区中获取的字节
- en: 'For example, suppose we have a large file that we want to checksum in 16M chunks:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有一个大文件，想要以16M块进行校验和计算：
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This will use native I/O as far as possible and will avoid a lot of copying
    of bytes on and off the Java heap. If the `computeChecksum()` method has been
    well implemented, then this could be a very performant implementation.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这将尽可能使用本机I/O，并避免在Java堆上复制大量字节。如果`computeChecksum()`方法已经实现良好，那么这可能是一个非常高效的实现。
- en: Mapped Byte Buffers
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 映射的字节缓冲区
- en: 'These are a type of direct byte buffer that contains a memory-mapped file (or
    a region of one). They are created from a `FileChannel` object, but note that
    the `File` object corresponding to the `MappedByteBuffer` must not be used after
    the memory-mapped operations or an exception will be thrown. To mitigate this,
    we again use `try`-with-resources, to scope the objects tightly:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是一种直接字节缓冲区，包含一个内存映射文件（或其一部分）。它们是从 `FileChannel` 对象创建的，但请注意，与 `MappedByteBuffer`
    对应的 `File` 对象在内存映射操作后不能再使用，否则会抛出异常。为了减少这种情况，我们再次使用 `try`-with-resources，以紧密地限定对象的作用域：
- en: '[PRE22]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Even with buffers, there are limitations of what can be done in Java for large
    I/O operations (e.g., transferring 10G between filesystems) that perform synchronously
    on a single thread. Before Java 7, these types of operations would typically be
    done by writing custom multithreaded code and managing a separate thread for performing
    a background copy. Let’s move on to look at the new asynchronous I/O features
    that were added with JDK 7.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 即使使用缓冲区，Java 对于大型 I/O 操作（例如在文件系统之间传输 10G）也存在一些限制，这些操作在单个线程上同步执行。在 Java 7 之前，这类操作通常通过编写自定义的多线程代码来完成，并管理单独的线程执行后台复制。让我们继续看看
    JDK 7 中新增的异步 I/O 特性。
- en: Async I/O
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步 I/O
- en: The key to the asynchronous functionality is new subclasses of `Channel` that
    can deal with I/O operations that need to be handed off to a background thread.
    The same functionality can be applied to large, long-running operations and to
    several other use cases.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 异步功能的关键在于 `Channel` 的新子类，它们可以处理需要交给后台线程的 I/O 操作。相同的功能可以应用于大型、长时间运行的操作以及其他几种用例。
- en: 'In this section, we’ll deal exclusively with `AsynchronousFileChannel` for
    file I/O, but there are a couple of other asynchronous channels to be aware of.
    We’ll peek at asynchronous sockets at the end of the chapter. We’ll look at:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将专注于文件 I/O 的 `AsynchronousFileChannel`，但还有几个其他异步通道需要了解。我们将在本章末尾查看异步套接字。我们将看到：
- en: '`AsynchronousFileChannel` for file I/O'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于文件 I/O 的 `AsynchronousFileChannel`
- en: '`AsynchronousSocketChannel` for client socket I/O'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于客户端套接字 I/O 的 `AsynchronousSocketChannel`
- en: '`AsynchronousServerSocketChannel` for asynchronous sockets that accept incoming
    connections'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于异步套接字接受传入连接的 `AsynchronousServerSocketChannel`
- en: There are two different ways to interact with an asynchronous channel—`Future`
    style and callback style.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 与异步通道交互的有两种不同的方式 — `Future` 风格和回调风格。
- en: Future-Based Style
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于 Future 的风格
- en: 'A full discussion of the `Future` interface would take us too far into the
    details of Java concurrency. However, for the purpose of this chapter, it can
    be thought of as an ongoing task that may or may not have completed yet. It has
    two key methods:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 对 `Future` 接口的全面讨论将使我们深入了解 Java 并发的细节。然而，对于本章的目的，它可以被视为一个可能已经完成或尚未完成的任务。它有两个关键方法：
- en: '`isDone()`'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`isDone()`'
- en: Returns a Boolean indicating whether the task has finished.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个布尔值，指示任务是否已完成。
- en: '`get()`'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`get()`'
- en: Returns the result. If finished, returns immediately. If not finished, blocks
    until done.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 返回结果。如果完成，则立即返回。如果未完成，则阻塞直到完成。
- en: 'Let’s look at an example of a program that reads a large file (possibly as
    large as 100 Mb) asynchronously:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个示例程序，异步读取一个大文件（可能达到 100 Mb）：
- en: '[PRE23]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Callback-Based Style
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于回调的风格
- en: The callback style for asynchronous I/O is based on a `CompletionHandler`, which
    defines two methods, `completed()` and `failed()`, that will be called back when
    the operation either succeeds or fails.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 异步 I/O 的回调风格基于 `CompletionHandler`，它定义了两个方法 `completed()` 和 `failed()`，在操作成功或失败时将回调调用。
- en: 'This style is useful if you want immediate notification of events in asynchronous
    I/O—for example, if there are a large number of I/O operations in flight, but
    failure of any single operation is not necessarily fatal:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望在异步 I/O 中立即收到事件通知，则此风格非常有用 — 例如，如果有大量的 I/O 操作正在进行中，但任何单个操作的失败并不一定是致命的：
- en: '[PRE24]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `AsynchronousFileChannel` object is associated with a background thread
    pool, so that the I/O operation proceeds, while the original thread can get on
    with other tasks.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`AsynchronousFileChannel` 对象与后台线程池相关联，因此 I/O 操作可以继续进行，而原始线程可以继续进行其他任务。'
- en: Note
  id: totrans-145
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The `CompletionHandler` interface has two abstract methods, not one, so it cannot
    be the target type for a lambda expression, unfortunately.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`CompletionHandler` 接口有两个抽象方法，而不是一个，所以它不可以是 lambda 表达式的目标类型，遗憾地。'
- en: By default, this uses a managed thread pool that is provided by the runtime.
    If required, it can be created to use a thread pool that is managed by the application
    (via an overloaded form of `AsynchronousFileChannel.open()`), but this is seldom
    necessary.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，这使用由运行时提供的托管线程池。如果需要，可以创建一个由应用程序管理的线程池（通过`AsynchronousFileChannel.open()`的重载形式），但这很少是必要的。
- en: Finally, for completeness, let’s touch upon NIO’s support for multiplexed I/O.
    This enables a single thread to manage multiple channels and to examine those
    channels to see which are ready for reading or writing. The classes to support
    this are in the `java.nio.channels` package and include `SelectableChannel` and
    `Selector`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了完整起见，让我们简要介绍一下 NIO 对多路复用 I/O 的支持。这使得单个线程能够管理多个通道，并检查这些通道以查看哪些已准备好进行读取或写入。支持这些功能的类位于`java.nio.channels`包中，包括`SelectableChannel`和`Selector`。
- en: These nonblocking multiplexed techniques can be extremely useful when you’re
    writing advanced applications that require high scalability, but a full discussion
    is outside the scope of this book. In general, the nonblocking API should only
    be used for advanced use cases when high performance or other nonfunctional requirements
    demand it.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写需要高可伸缩性的高级应用程序时，这些非阻塞的多路复用技术可以非常有用，但是在本书的讨论范围之外。通常情况下，非阻塞 API 应仅用于高级用例，当高性能或其他非功能性要求要求时。
- en: Watch Services and Directory Searching
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 监控服务和目录搜索
- en: 'The last class of asynchronous services we will consider are those that watch
    a directory or visit a directory (or a tree). The watch services operate by observing
    everything that happens within a directory—for example, the creation or modification
    of files:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将考虑的最后一类异步服务是监视目录或访问目录（或树）。观察服务通过观察目录中发生的一切来操作，例如文件的创建或修改：
- en: '[PRE25]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'By contrast, the directory streams provide a view into all files currently
    in a single directory. For example, to list all the Java source files and their
    size in bytes, we can use code like:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，目录流提供了对单个目录中当前所有文件的视图。例如，要列出所有 Java 源文件及其大小（以字节为单位），我们可以使用如下代码：
- en: '[PRE26]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'One drawback of this API is that it will return only elements that match according
    to glob syntax, which is sometimes insufficiently flexible. We can go further
    by using the `Files.find()` and `Files.walk()` methods to address each element
    obtained by a recursive walk through the directory:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 此 API 的一个缺点是，它仅根据通配符语法返回匹配的元素，有时不够灵活。我们可以通过使用`Files.find()`和`Files.walk()`方法进一步处理通过目录的递归遍历获取的每个元素：
- en: '[PRE27]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: It is possible to go even farther and construct advanced solutions based on
    the `FileVisitor` interface in `java.nio.file`, but that requires the developer
    to implement all four methods on the interface, rather than just using a single
    lambda expression as done here.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以进一步构建基于`java.nio.file`中的`FileVisitor`接口的高级解决方案，但这要求开发人员实现接口的所有四个方法，而不仅仅是像这里所做的单个
    lambda 表达式。
- en: In the last section of this chapter, we will discuss Java’s networking support
    and the core JDK classes that enable it.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后一部分，我们将讨论 Java 的网络支持和使其成为可能的核心 JDK 类。
- en: Networking
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络
- en: The Java platform provides access to a large number of standard networking protocols,
    and these make writing simple networked applications quite easy. The core of Java’s
    network support lives in the package `java.net`, with additional extensibility
    provided by `javax.net` (and in particular, `javax.net.ssl`), all of which is
    in the module `java.base`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Java 平台提供了对大量标准网络协议的访问，这使得编写简单的网络应用程序非常容易。Java 网络支持的核心位于`java.net`包中，通过`javax.net`（特别是`javax.net.ssl`）提供了额外的可扩展性，所有这些都在模块`java.base`中。
- en: One of the easiest protocols to use for building applications is HyperText Transmission
    Protocol (HTTP), the protocol used as the basic communication protocol of the
    Web.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 构建应用程序最简单的协议之一是超文本传输协议（[HTTP](https://zh.wikipedia.org/wiki/超文本传输协议)），这是 Web
    的基本通信协议。
- en: HTTP
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP
- en: HTTP is the most common and popular high-level network protocol that Java supports
    out of the box. It is a very simple protocol, implemented on top of the standard
    TCP/IP stack. It can run on any network port but is usually found on port 443
    when encrypted with TLS (known as HTTPS) or port 80 when running unencrypted.
    These days, HTTPS should be the default wherever possible.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 是 Java 支持的最常见和流行的高级网络协议。它是一个非常简单的协议，在标准 TCP/IP 协议栈的基础上实现。它可以运行在任何网络端口上，但通常在加密的
    TLS（称为 HTTPS）上使用端口 443 或者在未加密时使用端口 80。如今，应尽可能在所有地方默认使用 HTTPS。
- en: Java has two separate APIs for handling HTTP—one of which dates back to the
    earliest days of the platform, and a more modern API that arrived fully in Java
    11.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Java 有两个单独的处理 HTTP 的 API —— 其中一个可以追溯到平台早期的日子，另一个是全面支持的 Java 11 新 API。
- en: 'Let’s take a quick look at the older API, for the sake of completeness. In
    this API, `URL` is the key class—it supports URLs of the form `http://`, `ftp://`,
    `file://`, and `https://` out of the box. It is very easy to use, and the simplest
    example of Java HTTP support is to download a particular URL:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整起见，让我们快速看一下旧 API。在这个 API 中，`URL` 是关键类 —— 它支持 `http://`、`ftp://`、`file://`
    和 `https://` 形式的 URL。它非常易于使用，Java HTTP 支持的最简单示例是下载特定 URL：
- en: '[PRE28]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'For more low-level control, including metadata about the request and response,
    we can use `URLConnection` and achieve something like:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更低级别的控制，包括请求和响应的元数据，我们可以使用 `URLConnection` 来实现类似以下的操作：
- en: '[PRE29]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: HTTP defines “request methods,” which are the operations that a client can make
    on a remote resource. These methods are called GET, POST, HEAD, PUT, DELETE, OPTIONS,
    and TRACE.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 定义了“请求方法”，即客户端可以在远程资源上执行的操作。这些方法包括 GET、POST、HEAD、PUT、DELETE、OPTIONS 和 TRACE。
- en: 'Each has slightly different usages, for example:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 每个方法有稍微不同的用法，例如：
- en: GET should only be used to retrieve a document and *never* should perform any
    side effects.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GET 应仅用于检索文档，并且*永远*不应执行任何副作用。
- en: HEAD is equivalent to GET except the body is not returned—useful if a program
    wants to quickly check via headers whether a URL has changed.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HEAD 与 GET 类似，但不返回主体 —— 如果程序想通过标头快速检查 URL 是否已更改，则此方法很有用。
- en: POST is used when we want to send data to a server for processing.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们需要将数据发送到服务器进行处理时使用 POST。
- en: 'By default, Java uses GET, but it does provide a way to use other methods for
    building more complex applications; however, doing so is a bit involved. In this
    next example, we’re using the echo function provided by Postman to return a view
    of the data we posted:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Java 使用 GET 方法，但它提供了一种使用其他方法构建更复杂应用程序的方式；然而，这样做比较复杂。在下一个示例中，我们使用 Postman
    提供的 echo 函数来返回我们发布的数据的视图：
- en: '[PRE30]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Notice that we needed to send our query parameters in the body of a request
    and to encode them before sending. We also had to disable following of HTTP redirects
    and to treat any redirection from the server manually. This is due to a limitation
    of the `HttpURLConnection` class, which does not deal well with redirection of
    POST requests.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们需要将查询参数发送到请求体中并在发送前进行编码。我们还需要禁用 HTTP 重定向的跟随，并手动处理来自服务器的任何重定向。这是由于 `HttpURLConnection`
    类在处理 POST 请求的重定向时存在限制。
- en: 'The older API definitely shows its age, and in fact implements only version
    1.0 of the HTTP standard, which is very inefficient and considered archaic. As
    an alternative, modern Java programs can use the new API, which was added as a
    result of Java needing to support the new HTTP/2 protocol. It has been available
    in a fully supported module, `java.net.http`, since Java 11\. Let’s see a simple
    example of using the new API:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 旧 API 明显显露其年龄，事实上仅实现了 HTTP 标准的 1.0 版本，非常低效且被认为是过时的。作为替代，现代 Java 程序可以使用新 API，这是为了支持新的
    HTTP/2 协议而添加的结果。自 Java 11 开始，它已经作为 `java.net.http` 模块的完全支持部分提供。让我们看一个使用新 API 的简单示例：
- en: '[PRE31]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Note that this API is designed to be extensible, with interfaces such as `HttpResponse.BodySubscriber`
    available for implementing custom handling. The interface also seamlessly hides
    the differences between HTTP/2 and the older HTTP/1.1 protocol, meaning that Java
    applications will be able to migrate gracefully as web servers adopt the new version.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，该 API 设计为可扩展，例如通过 `HttpResponse.BodySubscriber` 接口来实现自定义处理。该接口还可以无缝隐藏 HTTP/2
    和旧版 HTTP/1.1 协议之间的差异，这意味着 Java 应用程序能够在 Web 服务器采用新版本时进行优雅的迁移。
- en: Let’s move on to look at the next layer down the networking stack, the Transmission
    Control Protocol (TCP).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续看网络堆栈中更底层的下一层，传输控制协议（TCP）。
- en: TCP
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TCP
- en: 'TCP is the basis of reliable network transport over the internet. It ensures
    that web pages and other internet traffic are delivered in a complete and comprehensible
    state. From a networking theory standpoint, the protocol properties that allow
    TCP to function as this “reliability layer” for internet traffic are:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: TCP是互联网上可靠网络传输的基础。它确保网页和其他互联网流量以完整和可理解的状态传输。从网络理论的角度来看，使TCP能够作为互联网流量的“可靠性层”的协议特性包括：
- en: Connection based
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 基于连接
- en: Data belongs to a single logical stream (a connection).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 数据属于单个逻辑流（即连接）。
- en: Guaranteed in-order delivery
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 保证有序交付
- en: Data packets will be resent until they arrive.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 直到数据包到达为止，数据包将被重新发送。
- en: Error checked
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 经过错误检查
- en: Damage caused by network transit will be detected and fixed automatically.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 网络传输引起的损坏将被自动检测和修复。
- en: TCP is a two-way (or bidirectional) communication channel and uses a special
    numbering scheme (TCP sequence numbers) for data chunks to ensure that both sides
    of a communication stream stay in sync. To support many different services on
    the same network host, TCP uses port numbers to identify services and ensures
    that traffic intended for one port does not go to a different one.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: TCP是双向（或双向）通信通道，并使用特殊的编号方案（TCP序列号）来确保通信流的两侧保持同步。为了支持同一网络主机上的多个不同服务，TCP使用端口号来标识服务，并确保发送到一个端口的流量不会进入另一个端口。
- en: In Java, TCP is represented by the classes `Socket` and `ServerSocket`. They
    are used to provide the capability to be the client side and server side of the
    connection, respectively—meaning that Java can be used both to connect to network
    services and as a language for implementing new services.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，TCP由`Socket`和`ServerSocket`类表示。它们用于提供能力，分别作为连接的客户端和服务器端—这意味着Java既可用于连接到网络服务，也可作为实现新服务的语言。
- en: Note
  id: totrans-191
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Java’s original socket support was reimplemented, without API changes, in Java
    13\. The classic socket APIs now share code with the more modern NIO infrastructure
    and will continue working well into the future as a result.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Java的原始套接字支持在Java 13中重新实现，没有API更改。经典套接字API现在与更现代的NIO基础结构共享代码，并且将继续有效地运行到未来。
- en: As an example, let’s consider reimplementing HTTP 1.1\. This is a relatively
    simple, text-based protocol. We’ll need to implement both sides of the connection,
    so let’s start with an HTTP client on top of a TCP socket. To accomplish this,
    we will actually need to implement the details of the HTTP protocol, but we do
    have the advantage that we have complete control over the TCP socket.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 举例来说，让我们考虑重新实现HTTP 1.1。这是一个相对简单的基于文本的协议。我们需要实现连接的双方，所以让我们从基于TCP套接字的HTTP客户端开始。为了完成这个任务，我们实际上需要实现HTTP协议的细节，但我们有一个优势，那就是我们可以完全控制TCP套接字。
- en: 'We will need to both read and write from the client socket, and we’ll construct
    the actual request line in accordance with the HTTP standard (which is known as
    RFC 2616, and uses explicit line-ending syntax). The resulting client code will
    look something like this:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要从客户端套接字读取和写入，并且我们将按照HTTP标准（称为RFC 2616，并使用显式的行结束语法）构造实际的请求行。生成的客户端代码将类似于以下内容：
- en: '[PRE32]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'On the server side, we’ll need to receive possibly multiple incoming connections.
    To handle this, we’ll kick off a main server loop, then use `accept()` to take
    a new connection from the operating system. The new connection is then quickly
    passed to a separate handler class so that the main server loop can get back to
    listening for new connections. The code for this is a bit more involved than the
    client case:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器端，我们需要接收可能的多个传入连接。为了处理这一点，我们将启动一个主服务器循环，然后使用`accept()`从操作系统获取新连接。然后快速将新连接传递给一个单独的处理程序类，以便主服务器循环可以继续监听新连接。这段代码比客户端情况复杂一些：
- en: '[PRE33]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'When designing a protocol for applications to communicate over TCP, there’s
    a simple and profound network architecture principle, known as Postel’s Law (after
    Jon Postel, one of the fathers of the internet) that you should always keep in
    mind. It is sometimes stated as: “Be strict about what you send, and liberal about
    what you will accept.” This simple principle means that communication can remain
    broadly possible in a network system, even in the event of quite imperfect implementations.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当设计一个应用程序通过TCP进行通信的协议时，有一个简单而深刻的网络架构原则，即著名的波斯特尔定律（以互联网之父之一乔恩·波斯特尔命名），你应该始终牢记。它有时被表述为：“在发送时要严格，接收时要宽松。”这个简单的原则意味着即使在网络系统中存在相当不完美的实现，通信仍然可以广泛可能。
- en: Postel’s Law, when combined with the general principle that the protocol should
    be as simple as possible (sometimes called the KISS principle), will make the
    developer’s job of implementing TCP-based communication much easier than it otherwise
    would be.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 波斯特尔定律与协议应尽可能简单的一般原则结合起来（有时被称为KISS原则），将使得开发者实现基于TCP的通信任务比起其他方式要容易得多。
- en: Below TCP is the internet’s general-purpose haulage protocol—the Internet Protocol
    (IP) itself.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: TCP下面是互联网的通用运输协议——互联网协议（IP）本身。
- en: IP
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IP
- en: IP, the “lowest common denominator” transport, provides a useful abstraction
    over the physical network technologies that are used to actually move bytes from
    A to B.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: IP，作为“最低公共分母”传输，为实际从点A到点B传输字节的物理网络技术提供了一个有用的抽象。
- en: Unlike TCP, delivery of an IP packet is not guaranteed, and a packet can be
    dropped by any overloaded system along the path. IP packets do have a destination
    but usually no routing data—it’s the responsibility of the (possibly many different)
    physical transports along the route to actually deliver the data.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 不同于TCP，IP数据包的传递并不保证，可能会被沿途任何过载系统丢弃。IP数据包确实有一个目的地，但通常没有路由数据——这是沿途（可能是多个不同的）物理传输的责任来实际交付数据。
- en: It is possible to create “datagram” services in Java that are based around single
    IP packets (or those with a UDP header, instead of TCP), but this is not often
    required except for extremely low-latency applications. Java uses the class `DatagramSocket`
    to implement this functionality, although few developers should ever need to venture
    this far down the network stack.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中可以创建基于单个IP数据包（或带有UDP头部而不是TCP的数据包）的“数据报”服务，但这通常只有在需要极低延迟的应用程序时才需要。Java使用类`DatagramSocket`来实现此功能，尽管少数开发人员可能永远不需要深入到这个网络栈的层次。
- en: Finally, it’s worth noting some changes currently in-flight in the addressing
    schemes that are used across the internet. The current dominant version of IP
    in use is IPv4, which has a 32-bit space of possible network addresses. This space
    is now very badly squeezed and various mitigation techniques have been deployed
    to handle the depletion.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，值得注意的是，当前在互联网上使用的寻址方案正在飞行中发生一些变化。目前主导的IP版本是IPv4，其拥有32位的可能网络地址空间。现在这个空间已经非常紧张，已经部署了各种缓解技术来处理这种枯竭。
- en: The next version of IP (IPv6) is being rolled out, but it is not fully accepted
    and has yet to displace IPv4, although steady progress toward it becoming the
    standard continues. As of this writing, IPv6 traffic is at about 35% of internet
    traffic and steadily rising. In the next 10 years, IPv6 is likely to overtake
    IPv4 in terms of traffic volume, and low-level networking will need to adapt to
    this radically new version.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个IP版本（IPv6）正在逐步推出，但尚未完全被接受，也尚未取代IPv4，尽管向它成为标准的稳步进展正在持续。截至目前，IPv6流量约占互联网流量的35%，并且稳步增长。在未来的10年内，IPv6有可能在流量量上超过IPv4，并且低级网络将需要适应这个根本性的新版本。
- en: However, for Java programmers, the good news is that the language and platform
    have been working for many years on good support for IPv6 and the changes that
    it introduces. The transition between IPv4 and IPv6 is likely to be much smoother
    and less problematic for Java applications than for many other languages.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于Java程序员来说，好消息是该语言和平台多年来一直在为IPv6和其引入的变化提供良好支持。与其他许多语言相比，IPv4到IPv6的过渡可能对Java应用程序来说会更加平稳和少问题。
- en: Summary
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter we’ve met the file handling, I/O, and networking capabilities
    provided in Java’s SDK. However, these capabilities are not used equally often.
    The core file handling classes (especially `Path` and the rest of NIO.2) are used
    very often by Java developers, with the more advanced capabilities being less
    frequently encountered.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们介绍了Java SDK提供的文件处理、I/O和网络功能。然而，并不是所有这些功能都被同等频繁地使用。核心的文件处理类（特别是`Path`和NIO.2的其他部分）被Java开发者经常使用，而更高级的功能则较少遇到。
- en: 'The story is different for the networking libraries. It’s good to be aware
    of these capabilities, but they are fairly basic. In practice, higher-level libraries
    provided by third parties are often used instead (e.g., Netty). The one exception:
    the one low-level JDK networking library that Java developers can expect to encounter
    relatively often is the new HTTP library in `java.net.http`.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 网络库的情况有所不同。了解这些功能很好，但它们相当基础。在实践中，通常会使用第三方提供的更高级别的库（例如Netty）。唯一的例外是，Java开发者可以相对经常遇到的低级别JDK网络库是`java.net.http`中的新HTTP库。
- en: Let’s move on to meet some of Java’s key dynamic features—classloading and reflection—powerful
    techniques that allow code to be discovered, loaded, and executed at runtime in
    ways that were unknown at compile time.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来了解一些Java的关键动态特性——类加载和反射——这些强大的技术允许代码在运行时以编译时未知的方式被发现、加载和执行。
