- en: Chapter 13\. Platform Tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter discusses the tools that ship with the OpenJDK version of the Java
    platform. The tools covered are all command-line tools. If you are using a different
    version of Java, you may find different tools as part of your distribution but
    with similar function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Later in the chapter, we devote dedicated sections to two tools: `jshell`,
    which introduced interactive development to the Java platform, and Java Flight
    Recorder (JFR) tooling for deep profiling of Java applications.'
  prefs: []
  type: TYPE_NORMAL
- en: Command-Line Tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The command-line tools we cover are the most commonly used tools and those of
    greatest utility—they are not a complete description of every available tool.
    In particular, tools concerned with CORBA and the server portion of RMI are not
    covered, as these modules were removed from the platform with the release of Java
    11.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In some cases, we need to discuss switches that take filesystem paths. As elsewhere
    in the book, we use Unix conventions for such cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Below we’ll discuss the following tools, including their basic usage, description,
    and common switches:'
  prefs: []
  type: TYPE_NORMAL
- en: '`javac`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`javadoc`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jdeps`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jps`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jstat`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jstatd`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jinfo`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jstack`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jmap`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`javap`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jlink`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jmod`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jcmd`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Options described throughout are targeted at Java 17 and may vary in older Java
    versions. For example, `--class-path` was introduced when `--module-path` became
    an option but won’t work on Java 8 and earlier (which require `-cp` or `--classpath`).
  prefs: []
  type: TYPE_NORMAL
- en: javac
  prefs: []
  type: TYPE_NORMAL
- en: Basic usage
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`bjavac *some*/*package*/MyClass.java`'
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`javac` is the Java source code  compiler—it produces bytecode (in the form
    of *.class* files) from *.java* source files.'
  prefs: []
  type: TYPE_NORMAL
- en: For modern Java projects, `javac` is not often used directly, as it is rather
    low-level and unwieldy, especially for larger codebases. Instead, modern integrated
    development environments (IDEs) either drive `javac` automatically for the developer
    or have built-in compilers for use while code is being written. For deployment,
    most projects will use a separate build tool, most commonly Maven or Gradle. Discussion
    of these tools is outside the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Nevertheless, it is useful for developers to understand how to use `javac`,
    as there are cases when compiling small codebases by hand is preferable to having
    to install and manage a production-grade build tool such as Maven.
  prefs: []
  type: TYPE_NORMAL
- en: Common switches
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`-cp`, `--class-path *<path>*`'
  prefs: []
  type: TYPE_NORMAL
- en: Supply classes we need for compilation.
  prefs: []
  type: TYPE_NORMAL
- en: '`-p`, `--module-path *<path>*`'
  prefs: []
  type: TYPE_NORMAL
- en: Supply application modules for compilation. See [Chapter 12](ch12.xhtml#javanut8-CHP-12)
    for a full discussion of Java modules.
  prefs: []
  type: TYPE_NORMAL
- en: '`-d *some*/*dir*`'
  prefs: []
  type: TYPE_NORMAL
- en: Tell `javac` where to output class files.
  prefs: []
  type: TYPE_NORMAL
- en: '`@project.list`'
  prefs: []
  type: TYPE_NORMAL
- en: Load options and source files from the file *project.list*.
  prefs: []
  type: TYPE_NORMAL
- en: '`-help`'
  prefs: []
  type: TYPE_NORMAL
- en: Help on options.
  prefs: []
  type: TYPE_NORMAL
- en: '`-X`'
  prefs: []
  type: TYPE_NORMAL
- en: Help on nonstandard options.
  prefs: []
  type: TYPE_NORMAL
- en: '`-source *<version>*`'
  prefs: []
  type: TYPE_NORMAL
- en: Control the Java version that `javac` will accept.
  prefs: []
  type: TYPE_NORMAL
- en: '`-target *<version>*`'
  prefs: []
  type: TYPE_NORMAL
- en: Control the version of class files that `javac` will output.
  prefs: []
  type: TYPE_NORMAL
- en: '`-profile *<profile>*`'
  prefs: []
  type: TYPE_NORMAL
- en: Control the profile that `javac` will use when compiling the application.
  prefs: []
  type: TYPE_NORMAL
- en: '`-Xlint`'
  prefs: []
  type: TYPE_NORMAL
- en: Enable detail about warnings.
  prefs: []
  type: TYPE_NORMAL
- en: '`-Xstdout *<path>*`'
  prefs: []
  type: TYPE_NORMAL
- en: Redirect output of compilation run to a file.
  prefs: []
  type: TYPE_NORMAL
- en: '`-g`'
  prefs: []
  type: TYPE_NORMAL
- en: Add debug information to class files.
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`javac` has traditionally accepted switches (`-source` and `-target`) that
    control the version of the source language that the compiler accepts and the version
    of the class file format used for the outputted class files.'
  prefs: []
  type: TYPE_NORMAL
- en: This facility introduces additional compiler complexity (as multiple language
    syntaxes must be supported internally) for some small developer benefit. In Java
    8, this capability was slightly tidied up and placed on a more formal basis.
  prefs: []
  type: TYPE_NORMAL
- en: From JDK 8 onward, `javac` will only accept source and target options from three
    versions back. That is, only the formats from JDK 5, 6, 7, and 8 will be accepted
    by `javac` version 8\. This does not affect the `java` interpreter—any class file
    from any Java version will still work on the JVM shipped with Java 8.
  prefs: []
  type: TYPE_NORMAL
- en: C and C++ developers may find that the `-g` switch is less helpful to them than
    it is in those other languages. This is largely due to the widespread use of IDEs
    in the Java ecosystem—integrated debugging is simply a lot more useful, and easier
    to use, than additional debug symbols in class files.
  prefs: []
  type: TYPE_NORMAL
- en: The use of the lint capability remains somewhat controversial among developers.
    Many Java developers produce code that triggers a large number of compilation
    warnings, which they then simply ignore. However, experience on larger codebases
    (especially on the JDK codebase itself) suggests that in a substantial percentage
    of cases, code that triggers warnings is code in which subtle bugs may lurk. Use
    of the lint feature, or static analysis tools (such as SpotBugs), is strongly
    recommended.
  prefs: []
  type: TYPE_NORMAL
- en: java
  prefs: []
  type: TYPE_NORMAL
- en: Basic usage
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: b`java some.package.MyClass`
  prefs: []
  type: TYPE_NORMAL
- en: '`java -jar my-packaged.jar`'
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`java` is the executable that starts up a Java Virtual Machine. The initial
    entry point into the program is the `main()` method that exists on the named class
    and that has the signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This method is run on the single application thread created by the JVM startup.
    The JVM process will exit once this method returns (and any additional nondaemon
    application threads that were started have terminated).
  prefs: []
  type: TYPE_NORMAL
- en: If the form takes a JAR file rather than a class (the executable JAR form),
    the JAR file must contain a piece of metadata that tells the JVM which class to
    start from.
  prefs: []
  type: TYPE_NORMAL
- en: 'This bit of metadata is the `Main-Class`: attribute, and it is contained in
    the *MANIFEST.MF* file in the *META-INF/* directory. See the description of the
    `jar` tool for more details.'
  prefs: []
  type: TYPE_NORMAL
- en: Common switches
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`-cp`, `--class-path *<path>*`'
  prefs: []
  type: TYPE_NORMAL
- en: Define the classpath to read from.
  prefs: []
  type: TYPE_NORMAL
- en: '`-p`, `--module-path *<path>*`'
  prefs: []
  type: TYPE_NORMAL
- en: Define the path to find modules.
  prefs: []
  type: TYPE_NORMAL
- en: '`--list-modules`'
  prefs: []
  type: TYPE_NORMAL
- en: List modules found with current settings and exits.
  prefs: []
  type: TYPE_NORMAL
- en: '`-X`, `-?`, `-help`'
  prefs: []
  type: TYPE_NORMAL
- en: Provide help about the `java` executable and its switches.
  prefs: []
  type: TYPE_NORMAL
- en: '`-D*<property=value>*`'
  prefs: []
  type: TYPE_NORMAL
- en: Set a Java system property that can be retrieved by the Java program. Any number
    of such properties can be specified this way.
  prefs: []
  type: TYPE_NORMAL
- en: '`-jar`'
  prefs: []
  type: TYPE_NORMAL
- en: Run an executable JAR (see [the entry for `jar`](#refname_jar)).
  prefs: []
  type: TYPE_NORMAL
- en: '`-Xbootclasspath(/a or /p)`'
  prefs: []
  type: TYPE_NORMAL
- en: Run with an alternative system classpath (very rarely used).
  prefs: []
  type: TYPE_NORMAL
- en: '`-client`, `-server`'
  prefs: []
  type: TYPE_NORMAL
- en: Select a HotSpot JIT compiler (see [“Notes” for this entry](#_notes_2)).
  prefs: []
  type: TYPE_NORMAL
- en: '`-Xint`, `-Xcomp`, `-Xmixed`'
  prefs: []
  type: TYPE_NORMAL
- en: Control JIT compilation (very rarely used).
  prefs: []
  type: TYPE_NORMAL
- en: '`-Xms*<size>*`'
  prefs: []
  type: TYPE_NORMAL
- en: Set the minimum committed heap size for the JVM.
  prefs: []
  type: TYPE_NORMAL
- en: '`-Xmx*<size>*`'
  prefs: []
  type: TYPE_NORMAL
- en: Set the maximum committed heap size for the JVM.
  prefs: []
  type: TYPE_NORMAL
- en: '`-agentlib:*<agent>*`, `-agentpath:*<path to agent>*`'
  prefs: []
  type: TYPE_NORMAL
- en: Specify a JVM Tooling Interface (JVMTI) agent to attach to the process being
    started. Agents are typically used for instrumentation or monitoring.
  prefs: []
  type: TYPE_NORMAL
- en: '`-verbose`'
  prefs: []
  type: TYPE_NORMAL
- en: Generate additional output, sometimes useful for debugging.
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The HotSpot VM contains two separate JIT compilers—known as the client (or C1)
    compiler and the server (or C2) compiler. These were designed for different purposes, with
    the client compiler offering more predictable performance and quicker startup,
    at the expense of not performing aggressive code optimization.
  prefs: []
  type: TYPE_NORMAL
- en: Traditionally, the JIT compiler that a Java process used was chosen at process
    startup via the `-client` or `-server` switch. However, as hardware advances have
    made compilation ever cheaper, a new possibility has become available—to use the
    client compiler early on, while the Java process is warming up, and then to switch
    to the high-performance optimizations available in the server compiler when they
    are available. This scheme is called Tiered Compilation, and it is the default
    in Java 8\. Most processes will no longer need explicit `-client` or `-server`
    switches.
  prefs: []
  type: TYPE_NORMAL
- en: On the Windows platform, a slightly different version of the `java` executable
    is often used—`javaw`. This version starts up a Java Virtual Machine, without
    forcing a Windows console window to appear.
  prefs: []
  type: TYPE_NORMAL
- en: In older Java versions, a number of different legacy interpreters and virtual
    machine modes were supported. These have now mostly been removed and any remaining
    should be regarded as vestigial.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switches that start with `-X` were intended to be nonstandard switches. However,
    the trend has been to standardize a number of these switches (particularly `-Xms`
    and `-Xmx`). In parallel, Java versions have introduced an increasing number of
    `-XX`: switches. These were intended to be experimental and not for production
    use. However, as the implementations have stabilized, some of these switches are
    now suitable for some advanced users (even in production deployments).'
  prefs: []
  type: TYPE_NORMAL
- en: In general, a full discussion of switches is outside the scope of this book.
    Configuration of the JVM for production use is a specialist subject, and developers
    are urged to take care, especially when modifying any switches related to the
    garbage collection subsystem.
  prefs: []
  type: TYPE_NORMAL
- en: jar
  prefs: []
  type: TYPE_NORMAL
- en: Basic usage
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`jar cvf my.jar *someDir/*`'
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `jar` utility is used to create and manipulate Java Archive (*.jar*) files.
    These are ZIP format files that contain Java classes, additional resources, and
    (usually) metadata. The tool has five major modes of operation—Create, Update,
    Index, List, and Extract—on a JAR file.
  prefs: []
  type: TYPE_NORMAL
- en: These are controlled by passing a command option character (not a switch) to
    `jar`. Only one command character can be specified, but optional modifier characters
    can also be used.
  prefs: []
  type: TYPE_NORMAL
- en: Command options
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`c`: Create a new archive'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`u`: Update archive'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`i`: Index an archive'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`t`: List an archive'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x`: Extract an archive'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modifiers
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`v`: Verbose mode'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`f`: Operate on a named file, rather than standard input'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0`: Store, but do not compress, files added to the archive'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`m`: Add the contents of the specified file to the `jar` metadata manifest'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`e`: Make this `jar` executable, with the specified class as the entry point'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notes
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The syntax of the `jar` command is intentionally very similar to that of the
    Unix `tar` command. This similarity is the reason `jar` uses command options,
    rather than switches (as the other Java platform commands do). More typical explicit
    switches (e.g. `--create`) are also available and documentation for them can be
    found via `jar --help`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you create a JAR file, the `jar` tool will automatically add a directory
    called *META-INF* that contains a file called *MANIFEST.MF*—this is metadata in
    the form of headers paired with values. By default, *MANIFEST.MF* contains just
    two headers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Using the `m` option allows additional metadata to be added into *MANIFEST.MF*
    at JAR creation time. One frequently added piece is the `Main-Class:` attribute,
    which indicates the entry point into the application contained in the JAR. A JAR
    with a specified `Main-Class:` can be directly executed by the JVM, via `java
    -jar`, or double-clicking the JAR in a graphical file browser.
  prefs: []
  type: TYPE_NORMAL
- en: The addition of the `Main-Class:` attribute is so common that `jar` has the
    `e` option to create it directly in *MANIFEST.MF*, rather than having to create
    a separate text file for this purpose. Contents of a jar, including the manifest,
    may be inspected easily using the `--extract` option.
  prefs: []
  type: TYPE_NORMAL
- en: javadoc
  prefs: []
  type: TYPE_NORMAL
- en: Basic usage
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`javadoc *some.package*`'
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`javadoc` produces documentation from Java source files. It does so by reading
    a special comment format (known as Javadoc comments) and parsing it into a standard
    documentation format, which can then be output into a variety of document formats
    (although HTML is by far the most common).'
  prefs: []
  type: TYPE_NORMAL
- en: For a full description of Javadoc syntax, refer to [Chapter 7](ch07.xhtml#javanut8-CHP-7).
  prefs: []
  type: TYPE_NORMAL
- en: Common switches
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`-cp`, `--class-path *<path>*`'
  prefs: []
  type: TYPE_NORMAL
- en: Define the classpath to use.
  prefs: []
  type: TYPE_NORMAL
- en: '`-p`, `--module-path *<path>*`'
  prefs: []
  type: TYPE_NORMAL
- en: Define the path to find modules.
  prefs: []
  type: TYPE_NORMAL
- en: '`-D *<directory>*`'
  prefs: []
  type: TYPE_NORMAL
- en: Tell `javadoc` where to output the generated docs.
  prefs: []
  type: TYPE_NORMAL
- en: '`-quiet`'
  prefs: []
  type: TYPE_NORMAL
- en: Suppress output except for errors and warnings.
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The platform API docs are all written in Javadoc.
  prefs: []
  type: TYPE_NORMAL
- en: '`javadoc` is built on top of the same classes as `javac` and uses some of the
    source compiler infrastructure to implement Javadoc features.'
  prefs: []
  type: TYPE_NORMAL
- en: The typical way to use `javadoc` is to run it against a whole package, rather
    than just a class.
  prefs: []
  type: TYPE_NORMAL
- en: '`javadoc` has a very large number of switches and options that can control
    many aspects of its behavior. Detailed discussion of all the options is outside
    the scope of this book.'
  prefs: []
  type: TYPE_NORMAL
- en: jdeps
  prefs: []
  type: TYPE_NORMAL
- en: bThe `jdeps` tool is a static analysis tool for analyzing the dependencies of
    packages or classes. The tool has a number of usages, from identifying developer
    code that makes calls into the internal, undocumented JDK APIs (such as the `sun.misc`
    classes) to helping trace transitive dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: '`jdeps` can also be used to confirm whether a JAR file can run under a Compact
    Profile (see later in the chapter for more details on Compact Profiles).'
  prefs: []
  type: TYPE_NORMAL
- en: Basic usage
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`jdeps com.me.MyClass`'
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`jdeps` reports dependency information for the classes it is asked to analyze.
    The classes can be specified as any class on the classpath, a file path, a directory,
    or a JAR file.'
  prefs: []
  type: TYPE_NORMAL
- en: Common switches
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`-cp`, `--class-path *<path>*`'
  prefs: []
  type: TYPE_NORMAL
- en: Define the classpath to use.
  prefs: []
  type: TYPE_NORMAL
- en: '`-p`, `--module-path *<path>*`'
  prefs: []
  type: TYPE_NORMAL
- en: Define the path to find modules.
  prefs: []
  type: TYPE_NORMAL
- en: '`-s`, `-summary`'
  prefs: []
  type: TYPE_NORMAL
- en: Print dependency summary only.
  prefs: []
  type: TYPE_NORMAL
- en: '`-m *<module-name>*`'
  prefs: []
  type: TYPE_NORMAL
- en: Target a module for analysis
  prefs: []
  type: TYPE_NORMAL
- en: '`-v`, `-verbose`'
  prefs: []
  type: TYPE_NORMAL
- en: Print all class-level dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: '`-verbose:package`'
  prefs: []
  type: TYPE_NORMAL
- en: Print package-level dependencies, excluding dependencies within the same archive.
  prefs: []
  type: TYPE_NORMAL
- en: '`-verbose:class`'
  prefs: []
  type: TYPE_NORMAL
- en: Print class-level dependencies, excluding dependencies within the same archive.
  prefs: []
  type: TYPE_NORMAL
- en: '`-p *<pkg name>*, -package *<pkg name>*`'
  prefs: []
  type: TYPE_NORMAL
- en: Find dependencies in the specified package. You can specify this option multiple
    times for different packages. The `-p` and `-e` options are mutually exclusive.
  prefs: []
  type: TYPE_NORMAL
- en: '`-e *<regex>*, -regex *<regex>*`'
  prefs: []
  type: TYPE_NORMAL
- en: Find dependencies in packages matching the specified regular expression pattern.
    The `-p` and `-e` options are mutually exclusive.
  prefs: []
  type: TYPE_NORMAL
- en: '`-include *<regex>*`'
  prefs: []
  type: TYPE_NORMAL
- en: Restrict analysis to classes matching pattern. This option filters the list
    of classes to be analyzed. It can be used together with `-p` and `-e`.
  prefs: []
  type: TYPE_NORMAL
- en: '`-jdkinternals`'
  prefs: []
  type: TYPE_NORMAL
- en: Find class-level dependencies in JDK internal APIs (which may change or disappear
    in even minor platform releases).
  prefs: []
  type: TYPE_NORMAL
- en: '`-apionly`'
  prefs: []
  type: TYPE_NORMAL
- en: Restrict analysis to APIs—for example, dependencies from the signature of public
    and protected members of public classes including field type, method parameter
    types, returned type, and checked exception types.
  prefs: []
  type: TYPE_NORMAL
- en: '`-R`, `-recursive`'
  prefs: []
  type: TYPE_NORMAL
- en: Recursively traverse all dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: '`-h`, `-?`, `--help`'
  prefs: []
  type: TYPE_NORMAL
- en: Print help message for `jdeps`.
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`jdeps` is a useful tool for making developers aware of their dependencies
    on the JRE not as a monolithic environment but as something more modular.'
  prefs: []
  type: TYPE_NORMAL
- en: jps
  prefs: []
  type: TYPE_NORMAL
- en: Basic usage
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`jps`'
  prefs: []
  type: TYPE_NORMAL
- en: '`jps *<remote URL>*`'
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`jps` provides a list of all active JVM processes on the local machine (or
    a remote machine, if a suitable instance of `jstatd` is running on the remote
    side). Remote URL support requires RMI; this configuration is explained in more
    detail in the `jstatd` section.'
  prefs: []
  type: TYPE_NORMAL
- en: Common switches
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`-m`'
  prefs: []
  type: TYPE_NORMAL
- en: Output the arguments passed to the main method.
  prefs: []
  type: TYPE_NORMAL
- en: '`-l`'
  prefs: []
  type: TYPE_NORMAL
- en: Output the full package name for the application’s main class (or the full path
    name to the application’s JAR file).
  prefs: []
  type: TYPE_NORMAL
- en: '`-v`'
  prefs: []
  type: TYPE_NORMAL
- en: Output the arguments passed to the JVM.
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This command is not strictly necessary, as the standard Unix `ps` command could
    suffice. However, it does not use the standard Unix mechanism for interrogating
    the process, so there are circumstances in which a Java process stops responding
    (and looks dead to `jps`) but is still listed as alive by the operating system.
  prefs: []
  type: TYPE_NORMAL
- en: jstat
  prefs: []
  type: TYPE_NORMAL
- en: Basic usage
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`jstat -options`'
  prefs: []
  type: TYPE_NORMAL
- en: '`jstat *<report type such as -class>* *<PID>*`'
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This command displays some basic statistics about a given Java process. This
    is usually a local process but can be located on a remote machine, provided the
    remote side is running a suitable `jstatd` process.
  prefs: []
  type: TYPE_NORMAL
- en: Common switches
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`-options`'
  prefs: []
  type: TYPE_NORMAL
- en: 'List report types that `jstat` can produce. Most common options are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-class`'
  prefs: []
  type: TYPE_NORMAL
- en: Report on classloading activity to date.
  prefs: []
  type: TYPE_NORMAL
- en: '`-compiler`'
  prefs: []
  type: TYPE_NORMAL
- en: JIT compilation of the process so far.
  prefs: []
  type: TYPE_NORMAL
- en: '`-gcutil`'
  prefs: []
  type: TYPE_NORMAL
- en: Detailed garbage collection report.
  prefs: []
  type: TYPE_NORMAL
- en: '`-printcompilation`'
  prefs: []
  type: TYPE_NORMAL
- en: More detail on compilation.
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The general syntax `jstat` uses to identify a process (which may be remote)
    is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This syntax is used to specify a remote process (which is usually connected
    to via JMX over RMI), but in practice, the more common local syntax simply uses
    the VM ID, which is the operating system process ID (PID) on mainstream platforms
    (Linux, Windows, Unix, macOS, etc.).
  prefs: []
  type: TYPE_NORMAL
- en: jstatd
  prefs: []
  type: TYPE_NORMAL
- en: Basic usage
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`jstatd *<options>*`'
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`jstatd` makes information about local JVMs available over the network. It
    achieves this using RMI and can make these otherwise-local capabilities accessible
    to JMX clients. This requires special security settings, which differ from the
    JVM defaults. To start `jstatd`, first we need to create the following file and
    name it *jstatd.policy*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This policy file grants all security permissions to any class loaded from the
    JDK modules that implement `jstatd`. The precise policy requirements changed with
    the introduction of modules in JDK 9 and may vary in future JDK versions.
  prefs: []
  type: TYPE_NORMAL
- en: 'To launch `jstatd` with this policy, use this command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Common switches
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`-p *<port>*`'
  prefs: []
  type: TYPE_NORMAL
- en: Look for an existing RMI registry on that port and create one if not found.
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: It is recommended that `jstatd` is always switched on in production environments
    but not over the public internet. For most corporate and enterprise environments,
    this is nontrivial to achieve and will require the cooperation of Operations and
    Network Engineering staff. However, the benefits of having telemetry data from
    production JVMs, especially during outages, are difficult to overstate.
  prefs: []
  type: TYPE_NORMAL
- en: A full discussion of JMX and monitoring techniques is outside the scope of this
    book.
  prefs: []
  type: TYPE_NORMAL
- en: jinfo
  prefs: []
  type: TYPE_NORMAL
- en: Basic usage
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`jinfo *<PID>*`'
  prefs: []
  type: TYPE_NORMAL
- en: '`jinfo *<core file>*`'
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This tool displays the system properties and JVM options for a running Java
    process (or a core file).
  prefs: []
  type: TYPE_NORMAL
- en: Common switches
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`-flags`'
  prefs: []
  type: TYPE_NORMAL
- en: Display JVM flags only.
  prefs: []
  type: TYPE_NORMAL
- en: '`-sysprops`'
  prefs: []
  type: TYPE_NORMAL
- en: Display system properties only.
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In practice, this is very rarely used—although it can occasionally be helpful
    as a sanity check that the expected program is actually the one that is executing.
  prefs: []
  type: TYPE_NORMAL
- en: jstack
  prefs: []
  type: TYPE_NORMAL
- en: Basic usage
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`jstack *<PID>*`'
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `jstack` utility produces a stack trace for each Java thread in the process.
  prefs: []
  type: TYPE_NORMAL
- en: Common switches
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`-e`'
  prefs: []
  type: TYPE_NORMAL
- en: Extended mode (contains additional information about threads).
  prefs: []
  type: TYPE_NORMAL
- en: '`-l`'
  prefs: []
  type: TYPE_NORMAL
- en: Long mode (contains additional information about locks).
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Producing the stack trace does not stop or terminate the Java process. The files
    that `jstack` produces can be very large, and some postprocessing of the file
    is usually necessary.
  prefs: []
  type: TYPE_NORMAL
- en: jmap
  prefs: []
  type: TYPE_NORMAL
- en: Basic usage
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`jmap *<output option>* *<process>*`'
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`jmap` provides a view of memory allocation for a running Java process.'
  prefs: []
  type: TYPE_NORMAL
- en: Common switches
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '*-dump:<option>,file=<location;>*'
  prefs: []
  type: TYPE_NORMAL
- en: Produce a heap dump from the running process.
  prefs: []
  type: TYPE_NORMAL
- en: '*-histo*'
  prefs: []
  type: TYPE_NORMAL
- en: Produce a histogram of the current state of allocated memory.
  prefs: []
  type: TYPE_NORMAL
- en: '*-histo:live*'
  prefs: []
  type: TYPE_NORMAL
- en: This version of the histogram displays information only for live objects.
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The histogram forms walk the JVMs allocation list. This includes both live and
    dead (but not yet collected) objects. The histogram is organized by the type of
    objects using memory and is ordered from greatest to least number of bytes used
    by a particular type. The standard form does not pause the JVM.
  prefs: []
  type: TYPE_NORMAL
- en: The live form ensures that it is accurate by performing a full, stop-the-world
    (STW) garbage collection before executing. As a result, it should not be used
    on a production system at a time when a full GC would appreciably impact users.
  prefs: []
  type: TYPE_NORMAL
- en: For the `-dump` form, note that the production of a heap dump can be a time-consuming
    process and is STW. The size of the resulting file is proportional to the currently
    allocated heap and hence may be extremely large for some processes.
  prefs: []
  type: TYPE_NORMAL
- en: javap
  prefs: []
  type: TYPE_NORMAL
- en: Basic usage
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`javap *<classname>*`'
  prefs: []
  type: TYPE_NORMAL
- en: '`javap *<path/to/ClassFile.class>*`'
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`javap` is the Java class disassembler—effectively a tool for peeking inside
    class files. It can show the bytecode that Java methods have been compiled into,
    as well as the constant pool information (which contains information similar to
    that of the symbol table of Unix processes).'
  prefs: []
  type: TYPE_NORMAL
- en: By default, `javap` shows signatures of `public`, `protected`, and default methods.
    The `-p` switch will also show `private` methods.
  prefs: []
  type: TYPE_NORMAL
- en: Common switches
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`-c`'
  prefs: []
  type: TYPE_NORMAL
- en: Decompile bytecode
  prefs: []
  type: TYPE_NORMAL
- en: '`-v`'
  prefs: []
  type: TYPE_NORMAL
- en: Verbose mode (include constant pool information)
  prefs: []
  type: TYPE_NORMAL
- en: '`-p`'
  prefs: []
  type: TYPE_NORMAL
- en: Include `private` methods
  prefs: []
  type: TYPE_NORMAL
- en: '`-cp`, `--class-path`'
  prefs: []
  type: TYPE_NORMAL
- en: Location of classes if loading by class name
  prefs: []
  type: TYPE_NORMAL
- en: '`-p`, `--module-path`'
  prefs: []
  type: TYPE_NORMAL
- en: Location of modules if loading by class name
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `javap` tool will work with any class file, provided `javap` is from a JDK
    version the same as (or later than) the one that produced the file.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Some Java language features may have surprising implementations in bytecode.
    For example, as we saw in [Chapter 9](ch09.xhtml#javanut8-CHP-9), Java’s `String`
    class has effectively immutable instances, and the JVM implements the string concatenation
    operator `+` in a different way in Java versions after 8\. This difference is
    clearly visible in the disassembled bytecode shown by `javap`.
  prefs: []
  type: TYPE_NORMAL
- en: jlink
  prefs: []
  type: TYPE_NORMAL
- en: Basic usage
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`jlink *[options]* --module-path modulepath --add-modules module`'
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`jlink` is the custom runtime image linker for the Java platform—a tool for
    linking and packaging Java classes, modules, and their dependencies into a custom
    runtime image. The image created by the `jlink` tool will comprise a linked set
    of modules, along with their transitive dependences.'
  prefs: []
  type: TYPE_NORMAL
- en: Common switches
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`--add-modules *<module>* [, *module1*]`'
  prefs: []
  type: TYPE_NORMAL
- en: Add modules to the root set of modules to be linked
  prefs: []
  type: TYPE_NORMAL
- en: '`--endian {little|big}`'
  prefs: []
  type: TYPE_NORMAL
- en: Specify the endianness of the target architecture
  prefs: []
  type: TYPE_NORMAL
- en: '`--module-path *<path>*`'
  prefs: []
  type: TYPE_NORMAL
- en: Specify the path where the modules for linking can be found
  prefs: []
  type: TYPE_NORMAL
- en: '`--save-opts *<file>*`'
  prefs: []
  type: TYPE_NORMAL
- en: Save the options to the linker in the specified file
  prefs: []
  type: TYPE_NORMAL
- en: '`--help`'
  prefs: []
  type: TYPE_NORMAL
- en: Print help information
  prefs: []
  type: TYPE_NORMAL
- en: '`@filename`'
  prefs: []
  type: TYPE_NORMAL
- en: Read options from filename instead of the command line
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `jlink` tool will work with any class file or module and linking will require
    the transitive dependencies of the code to be linked.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Custom runtime images don’t have any support for automatic updates by default.
    This means developers are responsible for rebuilding and updating their own applications
    in the field when necessary. Some Java language features may have restrictions,
    as the runtime image may not include the full JDK; therefore, reflection and other
    dynamic techniques may not be fully supported.
  prefs: []
  type: TYPE_NORMAL
- en: jmod
  prefs: []
  type: TYPE_NORMAL
- en: Basic usage
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`jmod create *[options]* my-new.jmod`'
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`jmod` prepares Java software components for use by the custom linker (`jlink`).
    The result is a *.jmod* file. This should be considered an intermediate file,
    not a primary artifact for distribution.'
  prefs: []
  type: TYPE_NORMAL
- en: Basic modes
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`create`'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new JMOD file
  prefs: []
  type: TYPE_NORMAL
- en: '`extract`'
  prefs: []
  type: TYPE_NORMAL
- en: Extract all files from a JMOD file (explode it)
  prefs: []
  type: TYPE_NORMAL
- en: '`list`'
  prefs: []
  type: TYPE_NORMAL
- en: List all files from a JMOD file
  prefs: []
  type: TYPE_NORMAL
- en: '`describe`'
  prefs: []
  type: TYPE_NORMAL
- en: Print details about a JMOD file
  prefs: []
  type: TYPE_NORMAL
- en: Common switches
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`--module-path path`'
  prefs: []
  type: TYPE_NORMAL
- en: Specify the module path where the core contents of the module can be found.
  prefs: []
  type: TYPE_NORMAL
- en: '`--libs path`'
  prefs: []
  type: TYPE_NORMAL
- en: Specify the path where native libraries for inclusion can be found.
  prefs: []
  type: TYPE_NORMAL
- en: '`--help`'
  prefs: []
  type: TYPE_NORMAL
- en: Print help information.
  prefs: []
  type: TYPE_NORMAL
- en: '`@filename`'
  prefs: []
  type: TYPE_NORMAL
- en: Read options from filename instead of the command line.
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`jmod` reads and writes the JMOD format, but please note that this is different
    from the modular JAR format and is not intended as an immediate replacement for
    it.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `jmod` tool is only currently intended for modules that are to be linked
    into a runtime image (using the `jlink` tool). One other possible use case is
    for packaging modules that have native libraries or other configuration files
    that must be distributed along with the module.
  prefs: []
  type: TYPE_NORMAL
- en: jcmd
  prefs: []
  type: TYPE_NORMAL
- en: Basic usage
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`jcmd *<PID>*`'
  prefs: []
  type: TYPE_NORMAL
- en: '`jcmd *<PID>* *<command>*`'
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`jcmd` issues commands to a running Java process. The precise commands may
    vary between Java versions and may be listed by running `jcmd` with the process
    ID and no command.'
  prefs: []
  type: TYPE_NORMAL
- en: Common switches
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`-f *<path>*`'
  prefs: []
  type: TYPE_NORMAL
- en: Read from commands from a file rather than command-line arguments
  prefs: []
  type: TYPE_NORMAL
- en: '`-l`'
  prefs: []
  type: TYPE_NORMAL
- en: List Java processes (similar to `jps`)
  prefs: []
  type: TYPE_NORMAL
- en: '`--help`'
  prefs: []
  type: TYPE_NORMAL
- en: Print help information
  prefs: []
  type: TYPE_NORMAL
- en: Common commands
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`GC.heap_dump *<path>*`'
  prefs: []
  type: TYPE_NORMAL
- en: Generate a heap dump like `jmap`. Note the path is relative to the Java process,
    *not* where `jcmd` is run!
  prefs: []
  type: TYPE_NORMAL
- en: '`GC.heap_info`'
  prefs: []
  type: TYPE_NORMAL
- en: Display statistics and sizing information about the Java process heap.
  prefs: []
  type: TYPE_NORMAL
- en: '`JFR.start`'
  prefs: []
  type: TYPE_NORMAL
- en: Begin a Java Flight Recorder (JFR) session. JFR is the JVM’s built-in performance
    monitoring and profiling tool.
  prefs: []
  type: TYPE_NORMAL
- en: '`JFR.stop name=*<name from start>* filename=*<path>*`'
  prefs: []
  type: TYPE_NORMAL
- en: Stop named JFR session and record to a file.
  prefs: []
  type: TYPE_NORMAL
- en: '`VM.system_properties`'
  prefs: []
  type: TYPE_NORMAL
- en: Output Java process system properties.
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Commands to `jcmd` are grouped by the subsystem they interact with, for instance
    `GC` or `JFR`. There are many more commands than the examples we’ve given here.
    It’s worth exploring what’s available on your Java installation for help in operating
    the JVM in production.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to JShell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java is traditionally understood as a language that is class-oriented and has
    a distinct compile-interpret-evaluate execution model. However, in this section,
    we will discuss a new technology that extends this programming paradigm by providing
    a form of interactive/scripting capability.
  prefs: []
  type: TYPE_NORMAL
- en: With the advent of Java 9, the Java runtime and JDK bundles a new tool, JShell.
    This is an interactive shell for Java, similar to the REPL seen in languages like
    Python, Scala, or Lisp. The shell is intended for teaching and exploratory use
    and, due to the nature of the Java language, is not expected to be as much use
    to the working programmer as similar shells in other languages.
  prefs: []
  type: TYPE_NORMAL
- en: In particular, it is not expected that Java will become an REPL-driven language.
    Instead, this opens up an opportunity to use JShell for a different style of programming,
    one that complements the traditional use case but also provides new perspectives,
    especially for working with a new API.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is very easy to use JShell to explore simple language features, for instance:'
  prefs: []
  type: TYPE_NORMAL
- en: Primitive data types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simple numeric operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: String manipulation basics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining new classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating new objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To start up JShell, we just invoke it from the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'From here, we can enter small pieces of Java code, which are known as *snippets*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The shell is designed to be a simple working environment, and so it relaxes
    some of the rules that working Java programmers may expect. Some of the differences
    between JShell snippets and regular Java include:'
  prefs: []
  type: TYPE_NORMAL
- en: Semicolons are optional in JShell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JShell supports a verbose mode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JShell has a wider set of default imports than a regular Java program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Methods can be declared at top level (outside of a class)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Methods can be redefined within snippets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A snippet may not declare a package or a module—everything is placed in an unnamed
    package controlled by the shell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only public classes may be accessed from JShell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Due to package restrictions, it’s advisable to ignore access control when defining
    classes and working within JShell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It’s simple to create simple class hierarchies (e.g., for exploring Java’s
    inheritance and generics):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Tab completion within the shell is also possible, such as for autocompletion
    of possible methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Pressing the tab key twice with certain input will display documentation for
    a method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also create top-level methods, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Simple exception backtraces are also supported:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We can access classes from the JDK:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Or explicitly import classes if necessary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The environment also allows JShell commands, which start with a `/`. It is
    useful to be aware of some of the most common basic commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/help intro` is the introductory help text'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/help` is a more comprehensive entry point into the help system'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/vars` shows which variables are in scope'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/list` shows the shell history'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/save` outputs accepted snippet source to a file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/open` reads a saved file and brings it into the environment'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/exit` exits the jshell interface'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, the imports available within JShell include a lot more than just
    `java.lang`. The whole list is loaded by JShell during startup and can be seen
    as the *special imports* visible through the `/list -all` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The JShell environment is tab-completed, which greatly adds to the tool’s usability.
    The verbose mode is particularly useful when you are getting to know JShell—it
    can be activated by passing the `-v` switch at startup as well as via a shell
    command.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Java Flight Recorder (JFR)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java Flight Record (JFR) is a powerful, low-latency profiling system built directly
    into the JVM. It has existed for years but was available only with a commercial
    license prior to Java 11\. Now this rich source of information is available with
    OpenJDK and worth exploring.
  prefs: []
  type: TYPE_NORMAL
- en: The typical JFR workflow involves starting a profile against a running JVM,
    downloading the results as a file, and then inspecting that file offline with
    the JDK Mission Control (JMC) GUI application. While JFR is embedded directly
    within OpenJDK, JMC isn’t distributed with the JDK but can be downloaded from
    [*https://oreil.ly/eq4cg*](https://oreil.ly/eq4cg).
  prefs: []
  type: TYPE_NORMAL
- en: 'JFR recording can be started either via options at JVM startup or interactively
    with the `jcmd` tool shown earlier in this chapter. The following `java` invocation
    starts with JFR recording for two minutes, writing the results to a file when
    finished:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Options allow for tight control over the volume of data JFR will hold in memory,
    either by specifying how long a recording to generate or by the size of the file
    that will be generated. When combined with its low overhead, it is plausible to
    run JFR persistently in production so data is always ready should you wish to
    capture it (sometimes referred to as “ring buffer” mode). This opens up a world
    of possibilities for debugging in amazing detail with the JFR profiles, even minutes
    to hours after a problem has occurred.
  prefs: []
  type: TYPE_NORMAL
- en: 'Along with sizing limits, JFR recording can also be configured to gather only
    specific information of interest. Typical areas (but only a few of the things
    JFR measures) include:'
  prefs: []
  type: TYPE_NORMAL
- en: Object allocation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Garbage collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Threads and locks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Method profiling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With Java 17, APIs are available in-process to consume JFR events in a streaming
    fashion, evolving away from the file-based profiling approaches. This opens the
    door for monitoring tooling to tap into this rich source of data, without the
    hassle of logging onto servers to ask for a profile to be dumped.
  prefs: []
  type: TYPE_NORMAL
- en: In the future, we may expect JFR to act as a data source for the new generation
    of Observability tools that are being adopted by the Java ecosystem, such as OpenTelemetry.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java has changed a huge amount over the last 15+ years, and yet the platform
    and community remain vibrant. To have achieved this, while retaining a recognizable
    language and platform, is no small accomplishment.
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, Java’s continued existence and viability depend upon the individual
    developer. On that basis, the future looks bright, and we look forward to the
    next wave and beyond.
  prefs: []
  type: TYPE_NORMAL
