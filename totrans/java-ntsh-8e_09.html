<html><head></head><body>
<div id="sbo-rt-content"><section data-nutshell-tab="Conventions" data-pdf-bookmark="Chapter 7. Programming and Documentation Conventions" data-type="chapter" epub:type="chapter"><div class="chapter" id="javanut8-CHP-7">
<h1><span class="label">Chapter 7. </span>Programming and Documentation Conventions</h1>
<p><a data-primary="conventions, programming/documentation" data-type="indexterm" id="ix_ch07-asciidoc0"/>This chapter explains a number of important and useful Java programming
and documentation conventions. It covers:</p>
<ul>
<li>
<p>General naming and capitalization conventions</p>
</li>
<li>
<p>Portability tips and conventions</p>
</li>
<li>
<p><code>javadoc</code> documentation comment syntax and conventions</p>
</li>
</ul>
<section data-pdf-bookmark="Naming and Capitalization Conventions" data-type="sect1"><div class="sect1" id="idm45927729400432">
<h1>Naming and Capitalization Conventions</h1>
<p><a data-primary="capitalization conventions" data-type="indexterm" id="ix_ch07-asciidoc2"/><a data-primary="conventions, programming/documentation" data-secondary="naming and capitalization conventions" data-type="indexterm" id="ix_ch07-asciidoc3"/>The following widely adopted naming conventions apply to modules, packages,
reference types, methods, fields, and constants in Java. Because these
conventions are almost universally followed and because they affect the
public API of the classes you define, you should adopt them as well:</p>
<dl>
<dt>Modules</dt>
<dd>
<p><a data-primary="conventions, programming/documentation" data-secondary="modules" data-type="indexterm" id="idm45927729395008"/><a data-primary="modules" data-secondary="naming conventions" data-type="indexterm" id="idm45927729394064"/>As modules are the preferred unit of distribution for Java applications from Java 9 onward, you should take special care when naming them.</p>
<p>Module names must be globally unique—the modules system is essentially predicated on this assumption.
As modules are effectively super packages (or aggregates of packages), the module name should be closely related to the package names grouped into the module.
One recommended way to do this is to group the packages within a module and use the <em>root name</em> of the packages as the module name.
For example, if an application’s packages all live under <code>com.mycompany.*</code>, then <code>com.mycompany</code> is a good name for your module.</p>
</dd>
<dt>Packages</dt>
<dd>
<p><a data-primary="conventions, programming/documentation" data-secondary="packages" data-type="indexterm" id="idm45927729389872"/><a data-primary="packages" data-secondary="naming conventions" data-type="indexterm" id="idm45927729388928"/>It is customary to ensure that your publicly visible package names are unique.
One common way of doing this is by prefixing them with the inverted name of an internet domain that you own (e.g., <code>com.oreilly.javanutshell</code>).</p>
<p>This convention is now followed less strictly than it used to be, with some projects merely adopting a simple, recognizable, and unique prefix instead.
All package names should be lowercase.</p>
</dd>
<dt>Classes</dt>
<dd>
<p><a data-primary="class(es)" data-secondary="naming conventions" data-type="indexterm" id="idm45927729385872"/><a data-primary="conventions, programming/documentation" data-secondary="classes" data-type="indexterm" id="idm45927729384672"/><a data-primary="conventions, programming/documentation" data-secondary="types" data-type="indexterm" id="idm45927729383712"/><a data-primary="types" data-secondary="naming conventions" data-type="indexterm" id="idm45927729382752"/><a data-primary="Pascal case" data-type="indexterm" id="idm45927729381808"/>A type name should begin with a capital letter and be written in
mixed case (e.g., <code>String</code>).
This is usually referred to as <em>Pascal case</em>.
If a class name consists of more than one word, each word should begin with a capital letter (e.g., <code>StringBuffer</code>).
If a type name, or one of the words of a type name, is an acronym, the acronym can be written in all capital letters (e.g., <code>URL</code>, <code>HTMLParser</code>).</p>
<p>Because classes and enumerated types are designed to represent
objects, you should choose class names that are nouns (e.g., <code>Thread</code>,
<code>Teapot</code>, <code>FormatConverter</code>).</p>
<p><a data-primary="conventions, programming/documentation" data-secondary="enums" data-type="indexterm" id="idm45927729376864"/><a data-primary="enums (enumerated types)" data-type="indexterm" id="idm45927729375872"/>Enum types are a special case of a class with a finite number of instances.
They should be named as nouns in all but highly exceptional circumstances.
The constants defined by <code>enum</code> types are also typically written in all capital letters, as per the rules for constants below.</p>
</dd>
<dt>Interfaces</dt>
<dd>
<p><a data-primary="conventions, programming/documentation" data-secondary="interfaces" data-type="indexterm" id="idm45927729373376"/><a data-primary="interfaces" data-secondary="naming conventions" data-type="indexterm" id="idm45927729372384"/>Java programmers typically use interfaces in one of two ways: either to convey that a class has additional, supplementary aspects or behaviors; or to indicate that the class is one possible implementation of an interface for which there are multiple valid implementation choices.</p>
<p>When an interface is used to provide additional information about the classes that implement it, it is common to choose an interface name that is an adjective (i.e., <code>Runnable</code>, <code>Cloneable</code>, <code>Serializable</code>).</p>
<p>When an interface is intended to work more like an abstract superclass, use a
name that is a noun (e.g., <code>Document</code>, <code>FileNameMap</code>, <code>Collection</code>). It is
conventional to not indicate via the name that it is an interface (i.e.,
don’t use <code>IDocument</code> or <code>DocumentInterface</code>).</p>
</dd>
<dt>Methods</dt>
<dd>
<p><a data-primary="conventions, programming/documentation" data-secondary="methods" data-type="indexterm" id="idm45927729365312"/><a data-primary="methods" data-secondary="naming conventions" data-type="indexterm" id="idm45927729364144"/>A method name always begins with a lowercase letter. <a data-primary="camel case" data-type="indexterm" id="idm45927729363008"/>If the name
contains more than one word, every word after the first begins with a
capital letter (e.g., <code>insert()</code>, <code>insertObject()</code>,
<code>insertObjectAt()</code>). This is usually referred to as <em>camel case</em>.</p>
<p>Method names are typically chosen so that the first word is a verb.
Method names can be as long as is necessary to make their purpose
clear, but choose succinct names where possible. Avoid overly general
method names, such as <code>performAction()</code>, <code>go()</code>, or the dreadful
<code>doIt()</code>.</p>
</dd>
<dt>Fields and constants</dt>
<dd>
<p><a data-primary="constants" data-secondary="naming conventions" data-type="indexterm" id="idm45927729357536"/><a data-primary="conventions, programming/documentation" data-secondary="constants" data-type="indexterm" id="idm45927729356560"/><a data-primary="conventions, programming/documentation" data-secondary="fields" data-type="indexterm" id="idm45927729355648"/><a data-primary="fields" data-secondary="naming conventions" data-type="indexterm" id="idm45927729354688"/>Nonconstant field names follow the same capitalization
conventions as method names. A field name should be chosen to best describe the
purpose of the field or the value it holds. Prefixes to indicate types or
visibility of fields are discouraged.</p>
<p><a data-primary="conventions, programming/documentation" data-secondary="static final constant" data-type="indexterm" id="idm45927729353360"/><a data-primary="static final constant, naming conventions for" data-type="indexterm" id="idm45927729352368"/>If a field is a <code>static final</code> constant, it should be written in all uppercase.
If the name of a constant includes more than one word, the words should be separated with underscores (e.g., <code>MAX_VALUE</code>).</p>
</dd>
<dt>Parameters</dt>
<dd>
<p><a data-primary="conventions, programming/documentation" data-secondary="parameters" data-type="indexterm" id="idm45927729349424"/><a data-primary="parameters, naming conventions for" data-type="indexterm" id="idm45927729348432"/>Method parameters follow the same capitalization conventions as
nonconstant fields. The names of method parameters appear in the
documentation for a method, so you should choose names that make the
purpose of the parameters as clear as possible. Try to keep parameter
names to a single word and use them consistently. For example, if a
<code>WidgetProcessor</code> class defines many methods that accept a <code>Widget</code>
object as the first parameter, name this parameter <code>widget</code>.</p>
</dd>
<dt>Local variables</dt>
<dd>
<p><a data-primary="conventions, programming/documentation" data-secondary="local variables" data-type="indexterm" id="idm45927729345120"/><a data-primary="conventions, programming/documentation" data-secondary="variables" data-type="indexterm" id="idm45927729344128"/><a data-primary="local variables" data-secondary="naming conventions" data-type="indexterm" id="idm45927729343168"/><a data-primary="variables" data-secondary="naming conventions" data-type="indexterm" id="idm45927729342224"/>Local variable names are an implementation detail and never visible
outside your class. Nevertheless, choosing good names makes your code
easier to read, understand, and maintain. Variables are typically
named following the same conventions as methods and fields.</p>
<p>In addition to the conventions for specific types of names, there are
conventions regarding the characters you should use in your names.
<a data-primary="$ character" data-type="indexterm" id="idm45927729340608"/>Java allows the <code>$</code> character in any identifier, but, by convention,
its use is reserved for synthetic names generated by source-code
processors. For example, it is used by the Java compiler to make inner
classes work. You should not use the <code>$</code> character in any name that
you create.</p>
<p>Java allows names to use any alphanumeric characters from the entire
Unicode character set. While this can be convenient for
non-English-speaking programmers, Unicode use has never really taken off, and
this usage is extremely rare.<a data-startref="ix_ch07-asciidoc3" data-type="indexterm" id="idm45927729338528"/><a data-startref="ix_ch07-asciidoc2" data-type="indexterm" id="idm45927729337824"/></p>
</dd>
</dl>
</div></section>
<section data-pdf-bookmark="Practical Naming" data-type="sect1"><div class="sect1" id="idm45927729336896">
<h1>Practical Naming</h1>
<p><a data-primary="conventions, programming/documentation" data-secondary="practical naming" data-type="indexterm" id="ix_ch07-asciidoc4"/>The names we give to our constructs matter—a lot. Naming is a key part
of the process that conveys our abstract designs to our peers. The
process of transferring a software design from one human mind to another
is hard—harder, in many cases, than the process of transferring our
design from our mind to the machines that will execute it.</p>
<p>We must, therefore, do everything we can to ensure that this process is
eased. Names are a keystone of this. When reviewing code (and all code
should be reviewed), pay particular attention to the
names that have been chosen:</p>
<ul class="pagebreak-before">
<li>
<p>Do the names of the types reflect the purpose of those types?</p>
</li>
<li>
<p>Does each method do exactly what its name suggests? Ideally, no more
and no less?</p>
</li>
<li>
<p>Are the names descriptive enough? Could a more specific name be used
instead?</p>
</li>
<li>
<p>Are the names well suited for the domain they describe?</p>
</li>
<li>
<p>Are the names consistent across the domain?</p>
</li>
<li>
<p>Do the names mix metaphors?</p>
</li>
<li>
<p>Does the name reuse a common term of software engineering?</p>
</li>
<li>
<p>Do the names of boolean-returning methods include negation? These often
need more attention to understand when reading (e.g., <code>notEnabled()</code> vs.
<code>enabled()</code>)</p>
</li>
</ul>
<p>Mixed metaphors are common in software, especially after several
releases of an application. A system that starts off perfectly
reasonably with components called <code>Receptionist</code> (for handling incoming
connections), <code>Scribe</code> (for persisting orders), and <code>Auditor</code> (for
checking and reconciling orders) can quite easily end up in a later
release with a class called <code>Watchdog</code> for restarting processes. This
isn’t terrible, but it breaks the established pattern of people’s job
titles that previously existed.</p>
<p>It is also incredibly important to realize that software changes a lot
over time. A perfectly apposite name on release 1 can become highly
misleading by release 4. Care should be taken that as the system focus
and intent shift, the names are refactored along with the code. Modern
IDEs have no problem with global search and replace of symbols, so there
is no need to cling to outdated metaphors once they are no longer
useful.</p>
<p>One final note of caution: an overly strict interpretation of these
guidelines can lead the developer to some very odd naming constructs.
There are a number of excellent descriptions of some of the absurdities
that can result by taking these conventions to their extremes.</p>
<p>In other words, none of the conventions described here is mandatory.
Following them will, in the vast majority of cases, make your code
easier to read and maintain.
However, you should not be afraid to deviate from these guidelines
if it makes your code easier to read and understand.</p>
<blockquote>
<p>Break any of these rules rather than say anything outright barbarous.</p>
<p data-type="attribution">George Orwell</p>
</blockquote>
<p>Above all, you should have a sense of the expected lifetime of the code
you are writing. A risk calculation system in a bank may have a lifetime
of a decade or more, whereas a prototype for a startup may be
relevant for only a few weeks. Document accordingly—the longer the code is
likely to be live, the better its documentation and naming need to be.<a data-startref="ix_ch07-asciidoc4" data-type="indexterm" id="idm45927729318768"/></p>
</div></section>
<section data-pdf-bookmark="Java Documentation Comments" data-type="sect1"><div class="sect1" id="idm45927729336304">
<h1>Java Documentation Comments</h1>
<p><a data-primary="conventions, programming/documentation" data-secondary="Java documentation comments" data-seealso="doc comments" data-type="indexterm" id="ix_ch07-asciidoc5"/><a data-primary="doc comments" data-type="indexterm" id="ix_ch07-asciidoc6"/><a data-primary="Java (generally)" data-secondary="documentation comments" data-seealso="doc comments" data-type="indexterm" id="ix_ch07-asciidoc7"/>Most ordinary comments within Java code explain the implementation
details of that code. By contrast, the Java language specification
defines a special type of comment known as a <em>doc comment</em> that serves
to document the API of your code.</p>
<p><a data-primary="/ (slash)" data-secondary="/** */ in doc comments" data-type="indexterm" id="idm45927729311584"/>A doc comment is an ordinary multiline comment that begins with <code>/**</code>
(instead of the usual <code>/*</code>) and ends with <code>*/</code>. A doc comment appears
immediately before a type or member definition and contains
documentation for that type or member. The documentation can include
simple HTML formatting tags and other special keywords that provide
additional information.</p>
<p><a data-primary="javadoc" data-secondary="doc comments" data-type="indexterm" id="idm45927729308912"/>Doc comments are ignored by the compiler, but
they can be extracted and automatically turned into online HTML
documentation by the <code>javadoc</code> program. (See
<a data-type="xref" href="ch13.xhtml#javanut8-CHP-13">Chapter 13</a> for more information about <code>javadoc</code>.)</p>
<p>Here is an example class that contains appropriate doc comments:</p>
<pre data-code-language="java" data-type="programlisting"><code class="cm">/**</code>
<code class="cm"> * This immutable class represents &lt;i&gt;complex numbers&lt;/i&gt;.</code>
<code class="cm"> *</code>
<code class="cm"> * @author David Flanagan</code>
<code class="cm"> * @version 1.0</code>
<code class="cm"> */</code><code class="w"/>
<code class="kd">public</code><code class="w"> </code><code class="kd">class</code> <code class="nc">Complex</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="cm">/**</code>
<code class="cm">     * Holds the real part of this complex number.</code>
<code class="cm">     * @see #y</code>
<code class="cm">     */</code><code class="w"/>
<code class="w">    </code><code class="kd">protected</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="n">x</code><code class="p">;</code><code class="w"/>

<code class="w">    </code><code class="cm">/**</code>
<code class="cm">     * Holds the imaginary part of this complex number.</code>
<code class="cm">     * @see #x</code>
<code class="cm">     */</code><code class="w"/>
<code class="w">    </code><code class="kd">protected</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="n">y</code><code class="p">;</code><code class="w"/>

<code class="w">    </code><code class="cm">/**</code>
<code class="cm">     * Creates a new Complex object that represents the complex number</code>
<code class="cm">     * x+yi.</code>
<code class="cm">     * @param x The real part of the complex number.</code>
<code class="cm">     * @param y The imaginary part of the complex number.</code>
<code class="cm">     */</code><code class="w"/>
<code class="w">    </code><code class="kd">public</code><code class="w"> </code><code class="nf">Complex</code><code class="p">(</code><code class="kt">double</code><code class="w"> </code><code class="n">x</code><code class="p">,</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="n">y</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">this</code><code class="p">.</code><code class="na">x</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">x</code><code class="p">;</code><code class="w"/>
<code class="w">        </code><code class="k">this</code><code class="p">.</code><code class="na">y</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">y</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>

<code class="w">    </code><code class="cm">/**</code>
<code class="cm">     * Adds two Complex objects and produces a third object that</code>
<code class="cm">     * represents their sum.</code>
<code class="cm">     * @param c1 A Complex object</code>
<code class="cm">     * @param c2 Another Complex object</code>
<code class="cm">     * @return  A new Complex object that represents the sum of</code>
<code class="cm">     *          &lt;code&gt;c1&lt;/code&gt; and &lt;code&gt;c2&lt;/code&gt;.</code>
<code class="cm">     * @exception java.lang.NullPointerException</code>
<code class="cm">     *            If either argument is &lt;code&gt;null&lt;/code&gt;.</code>
<code class="cm">     */</code><code class="w"/>
<code class="w">    </code><code class="kd">public</code><code class="w"> </code><code class="kd">static</code><code class="w"> </code><code class="n">Complex</code><code class="w"> </code><code class="nf">add</code><code class="p">(</code><code class="n">Complex</code><code class="w"> </code><code class="n">c1</code><code class="p">,</code><code class="w"> </code><code class="n">Complex</code><code class="w"> </code><code class="n">c2</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">Complex</code><code class="p">(</code><code class="n">c1</code><code class="p">.</code><code class="na">x</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">c2</code><code class="p">.</code><code class="na">x</code><code class="p">,</code><code class="w"> </code><code class="n">c1</code><code class="p">.</code><code class="na">y</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">c2</code><code class="p">.</code><code class="na">y</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<section data-pdf-bookmark="Structure of a Doc Comment" data-type="sect2"><div class="sect2" id="idm45927729277616">
<h2>Structure of a Doc Comment</h2>
<p><a data-primary="doc comments" data-secondary="structure of" data-type="indexterm" id="idm45927729276368"/>The body of a doc comment should begin with a one-sentence summary of
the type or member being documented. This sentence may be displayed by
itself as summary documentation, so it should be written to stand on its
own. The initial sentence may be followed by any number of other
sentences and paragraphs that describe the class, interface, method, or
field in full detail.</p>
<p>After the descriptive paragraphs, a doc comment can contain any number
of other paragraphs, each of which begins with a special doc-comment
tag, such as <code>@author</code>, <code>@param</code>, or <code>@returns</code>. These tagged paragraphs
provide specific information about the class, interface, method, or
field that the <code>javadoc</code> program displays in a standard way. The full
set of doc-comment tags is listed in the next section.</p>
<p>The descriptive material in a doc comment can contain simple HTML markup
tags, such as <code>&lt;i&gt;</code> for emphasis; <code>&lt;code&gt;</code> for class, method, and field
names; and <code>&lt;pre&gt;</code> for multiline code examples. It can also contain
<code>&lt;p&gt;</code> tags to break the description into separate paragraphs and <code>&lt;ul&gt;</code>,
<code>&lt;li&gt;</code>, and related tags to display bulleted lists and similar
structures. Remember, however, that the material you write is embedded
within a larger, more complex HTML document. For this reason, doc
comments should not contain major structural HTML tags, such as <code>&lt;h2&gt;</code>
or <code>&lt;hr&gt;</code>, that might interfere with the structure of the larger
document.</p>
<p><a data-primary="@link doc-comment tag" data-primary-sortas="link doc-comment tag" data-type="indexterm" id="idm45927729215632"/>Avoid the use of the <code>&lt;a&gt;</code> tag to include hyperlinks or cross-references
in your doc comments. Instead, use the special <code>{@link}</code> doc-comment
tag, which, unlike the other doc-comment tags, can appear anywhere
within a doc comment. As described in the next section, the <code>{@link}</code>
tag allows you to specify hyperlinks to other classes, interfaces,
methods, and fields without knowing the HTML-structuring conventions and
filenames used by <code>javadoc</code>.</p>
<p>If you want to include an image in a doc comment, place the image file
in a <em>doc-files</em> subdirectory of the source code directory. Give the
image the same name as the class, with an integer suffix. For example,
the second image that appears in the doc comment for a class named
<code>Circle</code> can be included with this HTML tag:</p>
<pre data-code-language="java" data-type="programlisting"><code class="o">&lt;</code><code class="n">img</code><code class="w"> </code><code class="n">src</code><code class="o">=</code><code class="s">"doc-files/Circle-2.gif"</code><code class="o">&gt;</code><code class="w"/></pre>
<p><a data-primary="* (asterisk)" data-secondary="in doc comments" data-secondary-sortas="doc comments" data-type="indexterm" id="idm45927729038080"/>Because the lines of a doc comment are embedded within a Java comment,
any leading spaces and asterisks (<code>*</code>) are stripped from each line of
the comment before processing. Thus, you don’t need to worry about the
asterisks appearing in the generated documentation or about the
indentation of the comment affecting the indentation of code examples
included within the comment with a <code>&lt;pre&gt;</code> tag.</p>
</div></section>
<section data-pdf-bookmark="Doc-Comment Tags" data-type="sect2"><div class="sect2" id="idm45927729207552">
<h2>Doc-Comment Tags</h2>
<p><a data-primary="doc comments" data-secondary="tags" data-type="indexterm" id="ix_ch07-asciidoc8"/><a data-primary="doc-comment tags" data-type="indexterm" id="ix_ch07-asciidoc9"/><a data-primary="tags" data-secondary="doc-comment" data-type="indexterm" id="ix_ch07-asciidoc10"/>The <a data-primary="@ (at sign)" data-secondary="in doc-comment tags" data-secondary-sortas="doc-comment tags" data-type="indexterm" id="idm45927729063888"/><code>javadoc</code> program recognizes a number of special tags, each of
which begins with an <code>@</code> character. These doc-comment tags allow you to
encode specific information into your comments in a standardized way,
and they allow <code>javadoc</code> to choose the appropriate output format for
that information. For example, the <code>@param</code> tag lets you specify the
name and meaning of a single parameter for a method. <code>javadoc</code> can
extract this information and display it using an HTML <code>&lt;dl&gt;</code> list, an
HTML <code>&lt;table&gt;</code>, or whatever it sees fit.</p>
<p>The following doc-comment tags are recognized by <code>javadoc</code>; a doc
comment should typically use these tags in the order listed here:</p>
<dl>
<dt><code>@author</code> <em><code>name</code></em></dt>
<dd>
<p><a data-primary="@author doc-comment tag" data-type="indexterm" id="idm45927727718016"/>Adds an “Author:” entry that contains the specified name. This tag
should be used for every class or interface definition but must not be
used for individual methods and fields. If a class has multiple
authors, use multiple <code>@author</code> tags on adjacent lines. For example:</p>
<pre data-code-language="java" data-type="programlisting"><code class="nd">@author</code><code class="w"> </code><code class="n">David</code><code class="w"> </code><code class="n">Flanagan</code><code class="w"/>
<code class="nd">@author</code><code class="w"> </code><code class="n">Ben</code><code class="w"> </code><code class="n">Evans</code><code class="w"/>
<code class="nd">@author</code><code class="w"> </code><code class="n">Jason</code><code class="w"> </code><code class="n">Clark</code><code class="w"/></pre>
<p>List the authors in chronological order, with the original author
first. If the author is unknown, you can use “unascribed.” <code>javadoc</code>
does not output authorship information unless the <code>-author</code>
command-line argument is specified.</p>
</dd>
<dt><code>@version</code> <em><code>text</code></em></dt>
<dd>
<p><a data-primary="@version doc-comment tag" data-primary-sortas="version doc-comment tag" data-type="indexterm" id="idm45927727694848"/>Inserts a “Version:” entry that contains the specified text. For
example:</p>
<pre data-code-language="java" data-type="programlisting"><code class="nd">@version</code><code class="w"> </code><code class="mf">1.32</code><code class="p">,</code><code class="w"> </code><code class="mi">08</code><code class="o">/</code><code class="mi">26</code><code class="o">/</code><code class="mo">04</code><code class="w"/></pre>
<p>This tag should be included in every class and interface doc comment
but cannot be used for individual methods and fields. This tag is
often used in conjunction with the automated version-numbering
capabilities of a version control system, such as git, Perforce, or
SVN. <code>javadoc</code> does not output version information in its generated
documentation unless the <code>-version</code> command-line argument is
specified.</p>
</dd>
<dt><code>@param</code> <em><code>parameter-name</code></em> <em><code>description</code></em></dt>
<dd>
<p><a data-primary="@param doc-comment tag" data-primary-sortas="param doc-comment tag" data-type="indexterm" id="idm45927727653216"/>Adds the specified parameter and its description to the “Parameters:”
section of the current method. The doc comment for a method or
constructor must contain one <code>@param</code> tag for each parameter the
method expects. These tags should appear in the same order as the
parameters specified by the method. The tag can be used only in doc
comments for methods and constructors.</p>
<p>You are encouraged to use phrases and sentence fragments where
possible to keep the descriptions brief. However, if a parameter
requires detailed <span class="keep-together">documentation</span>, the description can wrap onto
multiple lines and include as much text as necessary. For readability
in source-code form, consider using spaces to align the descriptions
with each other. For example:</p>
<pre data-code-language="java" data-type="programlisting"><code class="nd">@param</code><code class="w"> </code><code class="n">o</code><code class="w">      </code><code class="n">the</code><code class="w"> </code><code class="n">object</code><code class="w"> </code><code class="n">to</code><code class="w"> </code><code class="n">insert</code><code class="w"/>
<code class="nd">@param</code><code class="w"> </code><code class="n">index</code><code class="w">  </code><code class="n">the</code><code class="w"> </code><code class="n">position</code><code class="w"> </code><code class="n">to</code><code class="w"> </code><code class="n">insert</code><code class="w"> </code><code class="n">it</code><code class="w"> </code><code class="n">at</code><code class="w"/></pre>
</dd>
<dt><code>@return</code> <em><code>description</code></em></dt>
<dd>
<p><a data-primary="@return doc-comment tag" data-primary-sortas="return doc-comment tag" data-type="indexterm" id="idm45927727601056"/>Inserts a “Returns:” section that contains the specified description.
This tag should appear in every doc comment for a method, unless the
method returns <code>void</code> or is a constructor. The description can be as
long as necessary, but consider using a sentence fragment to keep it
short. For example:</p>
<pre data-code-language="java" data-type="programlisting"><code class="nd">@return</code><code class="w"> </code><code class="o">&lt;</code><code class="n">code</code><code class="o">&gt;</code><code class="kc">true</code><code class="o">&lt;/</code><code class="n">code</code><code class="o">&gt;</code><code class="w"> </code><code class="k">if</code><code class="w"> </code><code class="n">the</code><code class="w"> </code><code class="n">insertion</code><code class="w"> </code><code class="n">is</code><code class="w"> </code><code class="n">successful</code><code class="p">,</code><code class="w"> </code><code class="n">or</code><code class="w"/>
<code class="w">        </code><code class="o">&lt;</code><code class="n">code</code><code class="o">&gt;</code><code class="kc">false</code><code class="o">&lt;/</code><code class="n">code</code><code class="o">&gt;</code><code class="w"> </code><code class="k">if</code><code class="w"> </code><code class="n">the</code><code class="w"> </code><code class="n">list</code><code class="w"> </code><code class="n">already</code><code class="w"> </code><code class="n">contains</code><code class="w"> </code><code class="n">the</code><code class="w"> </code><code class="n">object</code><code class="p">.</code><code class="w"/></pre>
</dd>
<dt><code>@exception</code> <em><code>full-classname description</code></em></dt>
<dd>
<p><a data-primary="@exception doc-comment tag" data-primary-sortas="exception doc-comment tag" data-type="indexterm" id="idm45927727503440"/>Adds a “Throws:” entry that contains the specified exception name and
description. A doc comment for a method or constructor should contain
an <code>@exception</code> tag for every checked exception that appears in its
<code>throws</code> clause. For example:</p>
<pre data-code-language="java" data-type="programlisting"><code class="nd">@exception</code><code class="w"> </code><code class="n">java</code><code class="p">.</code><code class="na">io</code><code class="p">.</code><code class="na">FileNotFoundException</code><code class="w"/>
<code class="w">           </code><code class="n">If</code><code class="w"> </code><code class="n">the</code><code class="w"> </code><code class="n">specified</code><code class="w"> </code><code class="n">file</code><code class="w"> </code><code class="n">could</code><code class="w"> </code><code class="n">not</code><code class="w"> </code><code class="n">be</code><code class="w"> </code><code class="n">found</code><code class="w"/></pre>
<p>The <code>@exception</code> tag can optionally be used to document unchecked
exceptions (i.e., subclasses of <code>RuntimeException</code>) the method may
throw, when these are exceptions that a user of the method may
reasonably want to catch. If a method can throw more than one
exception, use multiple <code>@exception</code> tags on adjacent lines and list
the exceptions in alphabetical order. The description can be as short
or as long as necessary to describe the significance of the exception.
This tag can be used only for method and constructor comments. The
<code>@throws</code> tag is a synonym for <code>@exception</code>.</p>
</dd>
<dt><code>@throws</code> <em><code>full-classname description</code></em></dt>
<dd>
<p><a data-primary="@throws doc-comment tag" data-primary-sortas="throws doc-comment tag" data-type="indexterm" id="idm45927727449360"/>This tag is a synonym for <code>@exception</code>.</p>
</dd>
<dt><code>@see</code> <em><code>reference</code></em></dt>
<dd>
<p><a data-primary="@see reference tag" data-primary-sortas="see reference tag" data-type="indexterm" id="idm45927727445936"/>Adds a “See Also:” entry that contains the specified reference. This
tag can appear in any kind of doc comment. The syntax for the
<em><code>reference</code></em> is explained in
<a data-type="xref" href="#javanut8-CHP-7-SECT-3.4">“Cross-References in Doc Comments”</a>.</p>
</dd>
<dt><code>@deprecated</code> <em><code>explanation</code></em></dt>
<dd>
<p><a data-primary="@deprecated doc-comment tag" data-primary-sortas="deprecated doc-comment tag" data-type="indexterm" id="idm45927727441856"/>This tag specifies that the following type or member has been
deprecated and that its use should be avoided. <code>javadoc</code> adds a
prominent “Deprecated” entry to the documentation and includes the
specified <em><code>explanation</code></em> text. This text should specify when the
class or member was deprecated and, if possible, suggest a replacement
class or member and include a link to it. For example:</p>
<pre data-code-language="java" data-type="programlisting"><code class="nd">@deprecated</code><code class="w"> </code><code class="n">As</code><code class="w"> </code><code class="n">of</code><code class="w"> </code><code class="n">Version</code><code class="w"> </code><code class="mf">3.0</code><code class="p">,</code><code class="w"> </code><code class="k">this</code><code class="w"> </code><code class="n">method</code><code class="w"> </code><code class="n">is</code><code class="w"> </code><code class="n">replaced</code><code class="w"/>
<code class="w">            </code><code class="n">by</code><code class="w"> </code><code class="p">{</code><code class="nd">@link</code><code class="w"> </code><code class="err">#</code><code class="n">setColor</code><code class="p">}.</code><code class="w"/></pre>
<p>The <code>@deprecated</code> tag is an exception to the general rule that <code>javac</code>
ignores all comments. When this tag appears, the compiler notes the
deprecation in the class file it produces. This allows it to issue
warnings for other classes that rely on the deprecated feature.</p>
</dd>
<dt><code>@since</code> <em><code>version</code></em></dt>
<dd>
<p><a data-primary="@since doc-comment tag" data-primary-sortas="since doc-comment tag" data-type="indexterm" id="idm45927727388928"/>Specifies when the type or member was added to the API. This tag
should be followed by a version number or other version specification.
For example:</p>
<pre data-code-language="java" data-type="programlisting"><code class="nd">@since</code><code class="w"> </code><code class="n">JNUT</code><code class="w"> </code><code class="mf">3.0</code><code class="w"/></pre>
<p>Every doc comment for a type should include an <code>@since</code> tag, and any
members added after the initial release of the type should have
<code>@since</code> tags in their doc comments.</p>
</dd>
<dt><code>@serial</code> <em><code>description</code></em></dt>
<dd>
<p><a data-primary="@serial doc-comment tag" data-primary-sortas="serial doc-comment tag" data-type="indexterm" id="idm45927727376976"/>Technically, the way a class is serialized is part of its public
API. If you write a class that you expect to be serialized, you should
document its serialization format using <code>@serial</code> and the related tags
listed next. <code>@serial</code> should appear in the doc comment for any field
that is part of the serialized state of a <code>Serializable</code> class.</p>
<p>For classes that use the default serialization mechanism, this means
all fields that are not declared <code>transient</code>, including fields
declared <code>private</code>. The <em><code>description</code></em> should be a brief description
of the field and of its purpose within a serialized object.</p>
<p>You can also use the <code>@serial</code> tag at the class and package level to
specify whether a “serialized form page” should be generated for the
class or package. The syntax is:</p>
<pre data-code-language="java" data-type="programlisting"><code class="nd">@serial</code><code class="w"> </code><code class="n">include</code><code class="w"/>
<code class="nd">@serial</code><code class="w"> </code><code class="n">exclude</code><code class="w"/></pre>
</dd>
<dt><code>@serialField</code> <em><code>name type description</code></em></dt>
<dd>
<p><a data-primary="@serialField doc-comment tag" data-primary-sortas="serialField doc-comment tag" data-type="indexterm" id="idm45927727340912"/>A <code>Serializable</code> class can define its serialized format by declaring
an array of <code>ObjectStreamField</code> objects in a field named
<code>serialPersistentFields</code>. For such a class, the doc comment for
<code>serialPersistentFields</code> should include an <code>@serialField</code> tag for each
element of the array. Each tag specifies the name, type, and
description for a particular field in the serialized state of the
class.</p>
</dd>
<dt><code>@serialData</code> <em><code>description</code></em></dt>
<dd>
<p><a data-primary="@serialData doc-comment tag" data-primary-sortas="serialData doc-comment tag" data-type="indexterm" id="idm45927727333808"/>A <code>Serializable</code> class can define a <code>writeObject()</code> method to write
data other than that written by the default serialization mechanism.
An <code>Externalizable</code> class defines a <code>writeExternal()</code> method
responsible for writing the complete state of an object to the
serialization stream. The <code>@serialData</code> tag should be used in the doc
comments for these <code>writeObject()</code> and <code>writeExternal()</code> methods, and
the <em><code>description</code></em> should document the serialization format used by
the method.</p>
</dd>
</dl>
</div></section>
<section data-pdf-bookmark="Inline Doc-Comment Tags" data-type="sect2"><div class="sect2" id="idm45927727719184">
<h2>Inline Doc-Comment Tags</h2>
<p><a data-primary="doc comments" data-secondary="inline tags" data-type="indexterm" id="ix_ch07-asciidoc11"/><a data-primary="inline doc-comment tags" data-type="indexterm" id="ix_ch07-asciidoc12"/><a data-primary="tags" data-secondary="inline doc-comment" data-type="indexterm" id="ix_ch07-asciidoc13"/>In addition to the preceding tags, <code>javadoc</code> also supports several
<em>inline tags</em> that may appear anywhere that HTML text appears in a doc
comment. Because these tags appear directly within the flow of HTML
text, they require the use of curly braces as delimiters to separate the
tagged text from the HTML text. Supported inline tags include the
following:</p>
<dl>
<dt><code>{@link</code> <em><code>reference</code></em> <code>}</code></dt>
<dd>
<p><a data-primary="@link doc-comment tag" data-primary-sortas="link doc-comment tag" data-type="indexterm" id="idm45927727300160"/>The <code>{@link}</code> tag is like the <code>@see</code> tag except that instead of
placing a link to the specified <em><code>reference</code></em> in a special “See Also:”
section, it inserts the link inline. An <code>{@link}</code> tag can appear
anywhere that HTML text appears in a doc comment. In other words, it
can appear in the initial description of the class, interface, method,
or field and in the descriptions associated with the <code>@param</code>,
<code>@returns</code>, <code>@exception</code>, and <code>@deprecated</code> tags. The <em><code>reference</code></em>
for the <code>{@link}</code> tag uses the syntax described next in
<a data-type="xref" href="#javanut8-CHP-7-SECT-3.4">“Cross-References in Doc Comments”</a>. For example:</p>
<pre data-code-language="java" data-type="programlisting"><code class="nd">@param</code><code class="w"> </code><code class="n">regexp</code><code class="w"> </code><code class="n">The</code><code class="w"> </code><code class="n">regular</code><code class="w"> </code><code class="n">expression</code><code class="w"> </code><code class="n">to</code><code class="w"> </code><code class="n">search</code><code class="w"> </code><code class="k">for</code><code class="p">.</code><code class="w"> </code><code class="n">This</code><code class="w"> </code><code class="n">string</code><code class="w"/>
<code class="w">              </code><code class="n">argument</code><code class="w"> </code><code class="n">must</code><code class="w"> </code><code class="n">follow</code><code class="w"> </code><code class="n">the</code><code class="w"> </code><code class="n">syntax</code><code class="w"> </code><code class="n">rules</code><code class="w"> </code><code class="n">described</code><code class="w"> </code><code class="k">for</code><code class="w"/>
<code class="w">              </code><code class="p">{</code><code class="nd">@link</code><code class="w"> </code><code class="n">java</code><code class="p">.</code><code class="na">util</code><code class="p">.</code><code class="na">regex</code><code class="p">.</code><code class="na">Pattern</code><code class="p">}.</code><code class="w"/></pre>
</dd>
<dt><code>{@linkplain</code> <em><code>reference</code></em> <code>}</code></dt>
<dd>
<p><a data-primary="@linkplain doc-comment tag" data-primary-sortas="linkplain doc-comment tag" data-type="indexterm" id="idm45927727252656"/>The <code>{@linkplain}</code> tag is just like the <code>{@link}</code> tag, except that
the text of the link is formatted using the normal font rather than
the code font used by the <code>{@link}</code> tag. This is most useful when
<em><code>reference</code></em> contains both a <em><code>feature</code></em> to link to and a <em><code>label</code></em>
that specifies alternate text to be displayed in the link. See
<a data-type="xref" href="#javanut8-CHP-7-SECT-3.4">“Cross-References in Doc Comments”</a> for more on the
<span class="keep-together"><em><code>feature</code></em></span> and <em><code>label</code></em> portions of the <em><code>reference</code></em> argument.</p>
</dd>
<dt><code>{@inheritDoc}</code></dt>
<dd>
<p><a data-primary="@inheritDoc doc-comment tag" data-primary-sortas="inheritDoc doc-comment tag" data-type="indexterm" id="idm45927727203648"/>When a method overrides a method in a superclass or implements a
method in an interface, you can omit a doc comment, and <code>javadoc</code>
automatically inherits the documentation from the overridden or
implemented method. You can use the <code>{@inheritDoc}</code> tag to inherit the
text of individual tags. This tag also allows you to inherit and
augment the descriptive text of the comment. To inherit individual
tags, use it like this:</p>
<pre data-code-language="java" data-type="programlisting"><code class="nd">@param</code><code class="w"> </code><code class="n">index</code><code class="w"> </code><code class="p">{</code><code class="nd">@inheritDoc</code><code class="p">}</code><code class="w"/>
<code class="nd">@return</code><code class="w"> </code><code class="p">{</code><code class="nd">@inheritDoc</code><code class="p">}</code><code class="w"/></pre>
</dd>
<dt><code>{@docRoot}</code></dt>
<dd>
<p><a data-primary="@docRoot doc-comment tag" data-primary-sortas="docRoot doc-comment tag" data-type="indexterm" id="idm45927727191600"/>This inline tag takes no parameters and is replaced with a reference
to the root directory of the generated documentation. It is useful in
hyperlinks that refer to an external file, such as an image or a
copyright statement:</p>
<pre data-code-language="java" data-type="programlisting"><code class="o">&lt;</code><code class="n">img</code><code class="w"> </code><code class="n">src</code><code class="o">=</code><code class="s">"{@docroot}/images/logo.gif"</code><code class="o">&gt;</code><code class="w"/>
<code class="n">This</code><code class="w"> </code><code class="n">is</code><code class="w"> </code><code class="o">&lt;</code><code class="n">a</code><code class="w"> </code><code class="n">href</code><code class="o">=</code><code class="s">"{@docRoot}/legal.xhtml"</code><code class="o">&gt;</code><code class="n">Copyrighted</code><code class="o">&lt;/</code><code class="n">a</code><code class="o">&gt;</code><code class="w"> </code><code class="n">material</code><code class="p">.</code><code class="w"/></pre>
</dd>
<dt><code>{@literal</code> <em><code>text</code></em> <code>}</code></dt>
<dd>
<p><a data-primary="@literal doc-comment tag" data-primary-sortas="literal doc-comment tag" data-type="indexterm" id="idm45927727110720"/>This inline tag displays <em><code>text</code></em> literally, escaping any HTML in it
and ignoring any <code>javadoc</code> tags it may contain. It does not retain
whitespace formatting but is useful when used within a <code>&lt;pre&gt;</code> tag.</p>
</dd>
<dt><code>{@code</code> <em><code>text</code></em> <code>}</code></dt>
<dd>
<p><a data-primary="@code doc-comment tag" data-primary-sortas="code doc-comment tag" data-type="indexterm" id="idm45927727130400"/>This tag is like the <code>{@literal}</code> tag but displays the literal
<em><code>text</code></em> in code font. Equivalent to:</p>
<pre data-code-language="java" data-type="programlisting"><code class="o">&amp;</code><code class="n">lt</code><code class="p">;</code><code class="n">code</code><code class="o">&amp;</code><code class="n">gt</code><code class="p">;{</code><code class="nd">@literal</code><code class="w"> </code><code class="o">&lt;</code><code class="n">replaceable</code><code class="o">&gt;</code><code class="n">text</code><code class="o">&lt;/</code><code class="n">replaceable</code><code class="o">&gt;</code><code class="p">}</code><code class="o">&amp;</code><code class="n">lt</code><code class="p">;</code><code class="o">/</code><code class="n">code</code><code class="o">&amp;</code><code class="n">gt</code><code class="p">;</code><code class="w"/></pre>
</dd>
<dt><code>{@value}</code></dt>
<dd>
<p><a data-primary="@value doc-comment tag" data-primary-sortas="value doc-comment tag" data-type="indexterm" id="idm45927727070704"/>The <code>{@value}</code> tag, with no arguments, is used inline in doc comments
for <code>static final</code> fields and is replaced with the constant value of
that field.</p>
</dd>
<dt><code>{@value</code> <em><code>reference</code></em> <code>}</code></dt>
<dd>
<p>This variant of the <code>{@value}</code> tag includes a <em><code>reference</code></em> to a
<code>static final</code> field and is replaced with the constant value of that
field<a data-startref="ix_ch07-asciidoc13" data-type="indexterm" id="idm45927727064400"/><a data-startref="ix_ch07-asciidoc12" data-type="indexterm" id="idm45927727063696"/><a data-startref="ix_ch07-asciidoc11" data-type="indexterm" id="idm45927727063024"/>.<a data-startref="ix_ch07-asciidoc10" data-type="indexterm" id="idm45927727062224"/><a data-startref="ix_ch07-asciidoc9" data-type="indexterm" id="idm45927727061520"/><a data-startref="ix_ch07-asciidoc8" data-type="indexterm" id="idm45927727060848"/></p>
</dd>
</dl>
</div></section>
<section data-pdf-bookmark="Cross-References in Doc Comments" data-type="sect2"><div class="sect2" id="javanut8-CHP-7-SECT-3.4">
<h2>Cross-References in Doc Comments</h2>
<p><a data-primary="cross-references, in doc comments" data-type="indexterm" id="ix_ch07-asciidoc14"/><a data-primary="doc comments" data-secondary="cross-references in" data-type="indexterm" id="ix_ch07-asciidoc15"/>The <a data-primary="@link doc-comment tag" data-primary-sortas="link doc-comment tag" data-type="indexterm" id="idm45927727040400"/><a data-primary="@linkplain doc-comment tag" data-primary-sortas="linkplain doc-comment tag" data-type="indexterm" id="idm45927727039552"/><a data-primary="@see reference tag" data-primary-sortas="see reference tag" data-type="indexterm" id="idm45927727038704"/><code>@see</code> tag and the inline tags <code>{@link}</code>, <code>{@linkplain}</code>, and
<code>{@value}</code> all encode a cross-reference to some other source of
documentation, typically to the documentation comment for some other
type or member.</p>
<p><em><code>reference</code></em> can take three different forms. If it begins with a quote
character, it is taken to be the name of a book or some other printed
resource and is displayed as is. If <em><code>reference</code></em> begins with a &lt;
character, it is taken to be an arbitrary HTML hyperlink that uses the
<code>&lt;a&gt;</code> tag, and the hyperlink is inserted into the output documentation
as is. This form of the <code>@see</code> tag can insert links to other online
documents, such as a programmer’s guide or user’s manual.</p>
<p>If <em><code>reference</code></em> is not a quoted string or a hyperlink, it is expected
to have the following form:</p>
<pre data-code-language="java" data-type="programlisting">
<em><code class="n">feature</code></em><code class="w"> </code><code class="o">[</code><em><code class="n">label</code></em><code class="o">]</code><code class="w">
</code></pre>
<p>In this case, <code>javadoc</code> outputs the text specified by <em><code>label</code></em> and
encodes it as a hyperlink to the specified <em><code>feature</code></em>. If <em><code>label</code></em> is
omitted (as it usually is), <code>javadoc</code> uses the name of the specified
<em><code>feature</code></em> instead.</p>
<p><em><code>feature</code></em> can refer to a package, type, or type member, using one of
the following forms:</p>
<dl>
<dt><em><code>pkgname</code></em></dt>
<dd>
<p>A reference to the named package. For example:</p>
<pre data-code-language="java" data-type="programlisting"><code class="nd">@see</code><code class="w"> </code><code class="n">java</code><code class="p">.</code><code class="na">lang</code><code class="p">.</code><code class="na">reflect</code><code class="w"/></pre>
</dd>
<dt><em><code>pkgname</code></em>.<em><code>typename</code></em></dt>
<dd>
<p>A reference to a class, interface, enumerated type, or annotation type
specified with its full package name. For example:</p>
<pre data-code-language="java" data-type="programlisting"><code class="nd">@see</code><code class="w"> </code><code class="n">java</code><code class="p">.</code><code class="na">util</code><code class="p">.</code><code class="na">List</code><code class="w"/></pre>
</dd>
<dt><em><code>typename</code></em></dt>
<dd>
<p>A reference to a type specified without its package name. For example:</p>
<pre data-code-language="java" data-type="programlisting"><code class="nd">@see</code><code class="w"> </code><code class="n">List</code><code class="w"/></pre>
<p><code>javadoc</code> resolves this reference by searching the current package and
the list of imported classes for a class with this name.</p>
</dd>
<dt><em><code>typename</code></em> <code>#</code> <em><code>methodname</code></em></dt>
<dd>
<p>A reference to a named method or constructor within the specified
type. For example:</p>
<pre data-code-language="java" data-type="programlisting"><code class="nd">@see</code><code class="w"> </code><code class="n">java</code><code class="p">.</code><code class="na">io</code><code class="p">.</code><code class="na">InputStream</code><code class="err">#</code><code class="n">reset</code><code class="w"/>
<code class="nd">@see</code><code class="w"> </code><code class="n">InputStream</code><code class="err">#</code><code class="n">close</code><code class="w"/></pre>
<p>If the type is specified without its package name, it is resolved as
described for <em><code>typename</code></em>. This syntax is ambiguous if the method is
overloaded or the class defines a field by the same name.</p>
</dd>
<dt><em><code>typename</code></em> <code>#</code> <em><code>methodname</code></em> <code>(</code> <em><code>paramtypes</code></em> <code>)</code></dt>
<dd>
<p>A reference to a method or constructor with the type of its parameters
explicitly specified. This is useful when cross-referencing an
overloaded method. For example:</p>
<pre data-code-language="java" data-type="programlisting"><code class="nd">@see</code><code class="w"> </code><code class="n">InputStream</code><code class="err">#</code><code class="n">read</code><code class="p">(</code><code class="kt">byte</code><code class="o">[]</code><code class="p">,</code><code class="w"> </code><code class="kt">int</code><code class="p">,</code><code class="w"> </code><code class="kt">int</code><code class="p">)</code><code class="w"/></pre>
</dd>
<dt><code>#</code> <em><code>methodname</code></em></dt>
<dd>
<p>A reference to a nonoverloaded method or constructor in the current
class or interface or one of the containing classes, superclasses, or
superinterfaces of the current class or interface. Use this concise
form to refer to other methods in the same class. For example:</p>
<pre data-code-language="java" data-type="programlisting"><code class="nd">@see</code><code class="w"> </code><code class="err">#</code><code class="n">setBackgroundColor</code><code class="w"/></pre>
</dd>
<dt><code>#</code> <em><code>methodname</code></em> <code>(</code> <em><code>paramtypes</code></em> <code>)</code></dt>
<dd>
<p>A reference to a method or constructor in the current class or
interface or one of its superclasses or containing classes. This form
works with overloaded methods because it lists the types of the method
parameters explicitly. For example:</p>
<pre data-code-language="java" data-type="programlisting"><code class="nd">@see</code><code class="w"> </code><code class="err">#</code><code class="n">setPosition</code><code class="p">(</code><code class="kt">int</code><code class="p">,</code><code class="w"> </code><code class="kt">int</code><code class="p">)</code><code class="w"/></pre>
</dd>
<dt><em><code>typename</code></em> <code>#</code> <em><code>fieldname</code></em></dt>
<dd>
<p>A reference to a named field within the specified class. For example:</p>
<pre data-code-language="java" data-type="programlisting"><code class="nd">@see</code><code class="w"> </code><code class="n">java</code><code class="p">.</code><code class="na">io</code><code class="p">.</code><code class="na">BufferedInputStream</code><code class="err">#</code><code class="n">buf</code><code class="w"/></pre>
<p>If the type is specified without its package name, it is resolved as
described for <em><code>typename</code></em>.</p>
</dd>
<dt><code>#</code> <em><code>fieldname</code></em></dt>
<dd>
<p>A reference to a field in the current type or one of the containing
classes, superclasses, or superinterfaces of the current type. For
example:<a data-startref="ix_ch07-asciidoc15" data-type="indexterm" id="idm45927726754672"/><a data-startref="ix_ch07-asciidoc14" data-type="indexterm" id="idm45927726753968"/></p>
<pre data-code-language="java" data-type="programlisting"><code class="nd">@see</code><code class="w"> </code><code class="err">#</code><code class="n">x</code><code class="w"/></pre>
</dd>
</dl>
</div></section>
<section data-pdf-bookmark="Doc Comments for Packages" data-type="sect2"><div class="sect2" id="idm45927727020192">
<h2>Doc Comments for Packages</h2>
<p>Documentation comments for classes, interfaces, methods, constructors,
and fields appear in Java source code immediately before the definitions
of the features they document. <code>javadoc</code> can also read and display
summary documentation for packages. Because a package is defined in a
directory, not in a single file of source code, <code>javadoc</code> looks for the
package documentation in a file named <em>package.xhtml</em> in the directory
that contains the source code for the classes of the package.</p>
<p><a data-primary="doc comments" data-secondary="for packages" data-secondary-sortas="packages" data-type="indexterm" id="idm45927726744640"/><a data-primary="javadoc" data-secondary="package documentation" data-type="indexterm" id="idm45927726742992"/><a data-primary="packages" data-secondary="doc comments for" data-type="indexterm" id="idm45927726719184"/>The <em>package.xhtml</em> file should contain simple HTML documentation for the
package. It can also contain <code>@see</code>, <code>@link</code>, <code>@deprecated</code>, and
<code>@since</code> tags. Because 
<span class="keep-together"><em>package.xhtml</em></span> is not a file of Java source code,
the documentation it contains should be HTML and should <em>not</em> be a Java
comment (i.e., it should not be enclosed within <code>/**</code> and <code>*/</code>
characters). Finally, any <code>@see</code> and <code>@link</code> tags that appear in
<em>package.xhtml</em> must use fully qualified class names.</p>
<p>In addition to defining a <em>package.xhtml</em> file for each package, you can
also provide high-level documentation for a group of packages by
defining an <em>overview.xhtml</em> file in the source tree for those packages.
When <code>javadoc</code> is run over that source tree, it uses <em>overview.xhtml</em> as
the highest-level overview it displays.<a data-startref="ix_ch07-asciidoc7" data-type="indexterm" id="idm45927726697952"/><a data-startref="ix_ch07-asciidoc6" data-type="indexterm" id="idm45927726697456"/><a data-startref="ix_ch07-asciidoc5" data-type="indexterm" id="idm45927726696848"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Doclets" data-type="sect1"><div class="sect1" id="idm45927729317472">
<h1>Doclets</h1>
<p><a data-primary="conventions, programming/documentation" data-secondary="doclets" data-type="indexterm" id="idm45927726694992"/><a data-primary="doclets" data-type="indexterm" id="idm45927726693888"/><a data-primary="javadoc" data-secondary="doclets" data-type="indexterm" id="idm45927726693216"/>The <code>javadoc</code> tool that is used to generate HTML documentation is based upon a standard API.
Since Java 9, this standard interface has been delivered in the module <code>jdk.javadoc</code> and tools leveraging this API are typically called <em>doclets</em> (with <code>javadoc</code> being referred to as the standard doclet).</p>
<p><a data-primary="Java 9" data-primary-sortas="Java 09" data-secondary="doclet upgrade" data-type="indexterm" id="idm45927726690160"/>The Java 9 release also included a major upgrade of the standard doclet.
In particular, it now (as of Java 10) generates modern HTML5 by default.
This allows for other improvements—such as implementing the <a href="https://oreil.ly/4Slwr">WAI-ARIA standard</a> for accessibility.
This standard makes it easier for people with visual or other impairments to access <code>javadoc</code> output using tools such as screen readers.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><code>javadoc</code> has also been enhanced to understand the new platform modules, and so the semantic meaning of what constitutes an API (and so what should be documented) is now aligned with the modular Java definition.</p>
</div>
<p>The standard doclet now also automatically indexes the code as documentation is generated and creates a client-side index in JavaScript.
The resulting web pages have a search capability to allow developers to easily find some common program components, such as the names of:</p>
<ul>
<li>
<p>Modules</p>
</li>
<li>
<p>Packages</p>
</li>
<li>
<p>Types and members</p>
</li>
<li>
<p>Method parameter types</p>
</li>
</ul>
<p>The developer can also add search terms or phrases using an <code>@index</code> inline <code>javadoc</code> tag.</p>
</div></section>
<section data-pdf-bookmark="Conventions for Portable Programs" data-type="sect1"><div class="sect1" id="idm45927726680272">
<h1>Conventions for Portable Programs</h1>
<p><a data-primary="conventions, programming/documentation" data-secondary="portable code conventions" data-type="indexterm" id="ix_ch07-asciidoc16"/><a data-primary="portable code, conventions for" data-type="indexterm" id="ix_ch07-asciidoc17"/>One of the earliest slogans for Java was “write once, run anywhere.”
This emphasizes that Java makes it easy to write portable programs, but
it is still possible to write Java programs that do not automatically
run successfully on any Java platform. The following tips help to avoid
portability problems:</p>
<dl>
<dt>Native methods</dt>
<dd>
<p><a data-primary="methods" data-secondary="native" data-type="indexterm" id="idm45927726674832"/><a data-primary="native methods" data-secondary="portable programs and" data-type="indexterm" id="idm45927726673856"/>Portable Java code can use any methods in the core Java APIs,
including methods implemented as <code>native</code> methods. However, portable
code must not define its own native methods. By their very nature,
native methods must be ported to each new platform, so they directly
subvert the “write once, run anywhere” promise of Java.</p>
</dd>
<dt>The <code>Runtime.exec()</code> method</dt>
<dd>
<p><a data-primary="Runtime.exec()" data-type="indexterm" id="idm45927726670656"/>Calling the <code>Runtime.exec()</code> method to spawn a process and execute an
external command on the native system is rarely allowed in portable
code. This is because the native OS command to be executed is never
guaranteed to exist or behave the same way on all platforms.</p>
<p>The only time it is legal to use <code>Runtime.exec()</code> in portable code is when the user is allowed to specify the command to run, either by typing the command at runtime or by specifying the command in a configuration file or preferences dialog box.</p>
<p>If the programmer wishes to control external processes, then this should be done through the enhanced <code>ProcessHandle</code> capability introduced in Java 9, rather than by using <code>Runtime.exec()</code> and parsing the output.
This is not fully portable, but it at least reduces the amount of platform-specific logic necessary to control external processes.</p>
</dd>
<dt>The <code>System.getenv()</code> method</dt>
<dd>
<p><a data-primary="System.getenv()" data-type="indexterm" id="idm45927726665584"/>Using <code>System.getenv()</code> is inherently nonportable.
Different operating systems have differing casing conventions (e.g., Windows is
case-insensitive, where Unix systems are not). Also, typical values found in an
environment vary greatly between operating systems and organizations. Use of
<code>System.getenv()</code> to parameterize specific values your application expects can be
acceptable if well documented; this is frequently done with containerized
applications. But reaching out to the broader environment can yield incompatible
behavior.</p>
</dd>
<dt>Undocumented classes</dt>
<dd>
<p>Portable Java code must use only classes and interfaces that are a
documented part of the Java platform. Most Java implementations ship
with additional undocumented public classes that are part of the
implementation but not part of the Java platform specification.</p>
<p>The modules system prevents a program from using and relying on these
implementation classes, but even with the increased restrictions in Java 17 it
is still possible to circumvent this protection by using reflection (although
the exact runtime switches permitting reflection have changed in recent
versions; see <a data-type="xref" href="ch12.xhtml#javanut8-CHP-12">Chapter 12</a> for more details).</p>
<p>However, doing so is not portable because the implementation classes are not
guaranteed to exist in all Java implementations or on all platforms, and they
may change or disappear in future versions. Even if you don’t care much about
portability, use of undocumented classes can greatly complicate future JDK
version upgrades.</p>
<p>Of particular note is the <code>sun.misc.Unsafe</code> class, which provides
access to a number of “unsafe” methods, which can allow developers to
circumvent key restrictions of the Java platform.
Developers should not directly use the <code>Unsafe</code> class under any
circumstances.</p>
</dd>
<dt>Implementation-specific features</dt>
<dd>
<p><a data-primary="implementation-specific code" data-type="indexterm" id="idm45927726658544"/>Portable code must not rely on features specific to a single
implementation.
For example, in the early years of Java, Microsoft distributed a version of the Java runtime system that included a number of additional methods that were not part of the Java platform as defined by the specifications.
Any program that depends on such extensions is obviously not portable to other platforms.</p>
</dd>
<dt>Implementation-specific bugs</dt>
<dd>
<p>Just as portable code must not depend on implementation-specific features, it must not depend on implementation-specific bugs.
If a class or method behaves differently than the specification says it should,
a portable program cannot rely on this behavior, which may be different on
different platforms, and a future version may ultimately fix the bug, hindering
JDK upgrades.</p>
</dd>
<dt>Implementation-specific behavior</dt>
<dd>
<p>Sometimes different platforms and different implementations present different behaviors, all of which are legal according to the Java specification.
Portable code must not depend on any one specific behavior.
For example, the Java specification does not indicate whether threads of equal priority share the CPU or if one long-running thread can starve another thread at the same priority.
If an application assumes one behavior or the other, it may not run properly on all platforms.</p>
</dd>
<dt>Defining system classes</dt>
<dd>
<p><a data-primary="system classes" data-type="indexterm" id="idm45927726654032"/>Portable Java code never attempts to define classes in any of the system or standard extension packages. Doing so violates the protection boundaries of those packages and exposes package-visible implementation details, even in those cases where it is not forbidden by the modules system.</p>
</dd>
<dt>Hardcoded filenames</dt>
<dd>
<p><a data-primary="filenames, hardcoded" data-type="indexterm" id="idm45927726652048"/>A portable program contains no hardcoded file or directory names.
This is because different platforms have significantly different
filesystem organizations and use different directory separator
characters. If you need to work with a file or directory, have the
user specify the filename, or at least the base directory beneath
which the file can be found. This specification can be done at
runtime, in a configuration file, or as a command-line argument to the
program. When concatenating a file or directory name to a directory
name, use the <code>File()</code> constructor, the <code>File.separator</code> constant, or the
<code>Path.of()</code> method.</p>
</dd>
<dt>Line separators</dt>
<dd>
<p><a data-primary="format()" data-secondary="line separators" data-type="indexterm" id="idm45927726648048"/><a data-primary="line separators" data-type="indexterm" id="idm45927726647072"/><a data-primary="println()" data-secondary="line separators and" data-type="indexterm" id="idm45927726646400"/>Different systems use different characters or sequences of characters
as line separators. Do not hardcode <code>\n</code>, <code>\r</code>, or <code>\r\n</code> as the line
separator in your program. Instead, use the <code>println()</code> method of
<code>PrintStream</code> or <code>PrintWriter</code>, which automatically terminates a line
with the line separator appropriate for the platform, or use the value
of the <code>line.separator</code> system property. <a data-primary="Formatter class" data-type="indexterm" id="idm45927726642064"/><a data-primary="java.util.Formatter" data-type="indexterm" id="idm45927726641328"/><a data-primary="printf()" data-type="indexterm" id="idm45927726640656"/>You can also use the “%n”
format string to <code>printf()</code> and <code>format()</code> methods of
<code>java.util.Formatter</code> and related classes.<a data-startref="ix_ch07-asciidoc17" data-type="indexterm" id="idm45927726638512"/><a data-startref="ix_ch07-asciidoc16" data-type="indexterm" id="idm45927726637776"/></p>
</dd>
</dl>
</div></section>
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="idm45927726675712">
<h1>Summary</h1>
<p>In this chapter, we’ve seen the standard conventions around naming parts of our
Java code. While the language allows many things beyond these conventions, your
code will be easier for others to read and understand the more these are
followed.</p>
<p>Good documentation is at the heart of creating maintainable systems. The
<code>javadoc</code> tool allows us to write much of our documentation within our code,
keeping it in context when things change. A variety of document tags allow for
generating clear and consistent documentation.</p>
<p>Part of the appeal of the JVM is its broad install base across many operating
systems and types of hardware. However, you can compromise the portability of
your application if you’re not careful in a few areas, so this chapter reviewed guidelines
around the most typical of those stumbling blocks to avoid.</p>
<p>Next up, we’ll take a look at one of the most commonly used parts of Java’s
standard libraries: collections.<a data-startref="ix_ch07-asciidoc0" data-type="indexterm" id="idm45927726633776"/></p>
</div></section>
</div></section></div></body></html>