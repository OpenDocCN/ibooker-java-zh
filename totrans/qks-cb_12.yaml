- en: Chapter 12\. Application Secrets Management
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 12 章 应用程序秘密管理
- en: Every application has information that needs to be kept confidential. This information
    could include database credentials, external service authentication, or even the
    location of certain resources. All of these are collectively called *secrets*.
    Your application needs a secure place to store these secrets both during application
    startup and at rest. In this chapter, we will discuss secret management using
    Kubernetes and Vault.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 每个应用程序都有需要保密的信息。这些信息可能包括数据库凭据、外部服务身份验证或某些资源的位置。所有这些信息统称为*秘密*。您的应用程序需要一个安全的地方来存储这些秘密，在应用程序启动期间和静态时都是如此。在本章中，我们将讨论使用
    Kubernetes 和 Vault 进行秘密管理。
- en: 12.1 Storing Data Using Kubernetes Secrets
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12.1 使用 Kubernetes 秘密存储数据
- en: Problem
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to store secrets in Kubernetes in a safer way than directly on the
    Pod or container.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望以比直接在 Pod 或容器上更安全的方式在 Kubernetes 中存储秘密。
- en: Solution
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use Kubernetes secrets to store and retrieve sensitive data such as passwords,
    tokens, or SSH keys in plain text on a container. Kubernetes has the concept of
    `secret` objects that can be used to store sensitive data.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Kubernetes 秘密对象以明文形式存储和检索敏感数据，例如密码、令牌或 SSH 密钥。Kubernetes 提供了可以用来存储敏感数据的 `secret`
    对象的概念。
- en: 'It is important to know that storing sensitive data in a secret object does
    not automatically make it secure because Kubernetes does not encrypt data but
    instead encodes it in Base64 by default. Using secrets gives you some features
    that are not provided by the standard configuration process:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 将敏感数据存储在秘密对象中并不自动使其安全，因为 Kubernetes 不加密数据，而是默认使用 Base64 编码。使用秘密对象可以获得一些标准配置流程不提供的功能：
- en: You can define the authorization policies to access the secret.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以定义授权策略以访问秘密。
- en: You can configure Kubernetes to encrypt sensitive data (this is known as *encryption
    at rest*).
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以配置 Kubernetes 以加密敏感数据（称为*静态加密*）。
- en: You can grant access to a specific container instance using lists.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用列表为特定容器实例授予权限。
- en: Important
  id: totrans-11
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 重要
- en: None of these features are enabled by default, and they require some knowledge
    about Kubernetes. In the book, we explain only how Quarkus integrates with other
    tools like Kubernetes; we do not explain the operational side of the tool.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这些功能都不会默认启用，它们需要一些关于 Kubernetes 的知识。在本书中，我们仅解释了 Quarkus 如何与 Kubernetes 等其他工具集成；我们不解释工具的操作方面。
- en: The secrets can be injected into the container as an environment variable or
    as a volume. The environment variable approach is less secure because anyone with
    access to the container instance could dump the content easily. The volume approach,
    on the other hand, easily becomes complex when there are a large number of keys
    because Kubernetes creates one file per key to store inside the value.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 秘密可以作为环境变量或卷注入到容器中。环境变量方法较不安全，因为任何能够访问容器实例的人都可以轻松地转储内容。另一方面，当存在大量密钥时，卷方法会变得复杂，因为
    Kubernetes 会为存储值内的每个密钥创建一个文件。
- en: Both approaches are shown, so you can choose the one that works better for your
    use case.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 两种方法都显示了，因此您可以选择适合您用例的方法。
- en: The example covers the use case in which an API token (e.g., GitHub Personal
    Access Token) needs to be set as secret in the application.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例涵盖了需要将 API 令牌（例如 GitHub 个人访问令牌）设置为应用程序中的秘密的用例。
- en: 'To enable the generation of Kubernetes resources with the `secrets` injection
    in the `Pod`, you need to register the `quarkus-kubernetes` extension:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 `Pod` 中启用 `secrets` 注入的 Kubernetes 资源生成，需要注册 `quarkus-kubernetes` 扩展：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create a secret by creating a Kubernetes resource of the kind `Secret` or by
    using the `kubectl` CLI tool. Open a new terminal and run the following command
    to register a new secret with `greeting-security` ID and a key `github.api.key.token`
    with a token (this token is invalid and is used only for example purposes):'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建 `Secret` 类型的 Kubernetes 资源或使用 `kubectl` CLI 工具来创建秘密。打开新终端并运行以下命令，以注册具有
    `greeting-security` ID 和键 `github.api.key.token` 的新秘密（此令牌无效，仅用于示例目的）：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now that the secret is created, let’s see how to set it as an environment variable.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在秘密已创建，让我们看看如何将其设置为环境变量。
- en: 'A configuration property is required to get the property from the environment
    variable. In this case, the property is called `github.api.key.token`, but of
    course you could also access it directly by using `System.getenv()`. The former
    approach is better because it relies on the MicroProfile Config spec to read the
    configuration properties and not some custom solution:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 需要从环境变量获取属性的配置属性。在本例中，属性称为`github.api.key.token`，但当然你也可以直接使用`System.getenv()`来访问它。前一种方法更好，因为它依赖于
    MicroProfile Config 规范来读取配置属性，而不是一些自定义解决方案：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Set extra properties for the Kubernetes extension in the *application.properties*
    so that the generated Kubernetes deployment file contains the segments needed
    to inject the secret as an environment variable:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在*application.properties*中为 Kubernetes 扩展设置额外属性，以便生成的 Kubernetes 部署文件包含注入秘密作为环境变量所需的部分：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[![1](Images/1.png)](#co_application_secrets_management_CO1-1)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_application_secrets_management_CO1-1)'
- en: Configures Docker image
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 配置 Docker 镜像
- en: '[![2](Images/2.png)](#co_application_secrets_management_CO1-2)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_application_secrets_management_CO1-2)'
- en: Sets the environment variable to override the `github.api.key.token` property
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 设置环境变量以覆盖`github.api.key.token`属性
- en: '[![3](Images/3.png)](#co_application_secrets_management_CO1-3)'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_application_secrets_management_CO1-3)'
- en: Sets the secret name to load
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 设置要加载的秘密名称
- en: The generation of the Kubernetes file will contain a new entry in the container
    definition called `secretKeyRef` that defines all the key/value pairs.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 文件的生成将在容器定义中包含一个名为`secretKeyRef`的新条目，该条目定义了所有的键/值对。
- en: The MicroProfile Config spec permits the override of any configuration property
    using the equivalent environment variable (in uppercase and changing dots [`.`]
    to underscores [`_`]). The `Secrets` contains the configuration properties as
    secrets. In *application.properties*, the Kubernetes extension is configured to
    generate a deployment descriptor that sets these secrets as environment variables
    so that when the container is started inside the Kubernetes cluster, the secrets
    are injected into the container as environment variables and are read by MicroProfile
    Config as configuration properties.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: MicroProfile 配置规范允许使用等效的环境变量（大写并更改点[`.`]为下划线[`_`]）覆盖任何配置属性。`Secrets`包含配置属性作为秘密。在*application.properties*中，Kubernetes
    扩展被配置为生成一个设置这些秘密作为环境变量的部署描述符，这样当容器在 Kubernetes 集群内启动时，秘密会作为环境变量注入到容器中，并被 MicroProfile
    Config 读取为配置属性。
- en: 'To deploy the application, open a new terminal window, package the application,
    create the Docker container, and apply the generated Kubernetes resources:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要部署该应用程序，请打开一个新的终端窗口，打包该应用程序，创建 Docker 容器，并应用生成的 Kubernetes 资源：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'But secrets can also be mounted as volumes instead of being set as environment
    variables. Set the Kubernetes extension properties in the *application.properties*
    so that the generated Kubernetes deployment file contains the segments to mount
    the secret file as a volume:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 但是秘密也可以挂载为卷，而不是设置为环境变量。在*application.properties*中设置 Kubernetes 扩展属性，使生成的 Kubernetes
    部署文件包含挂载秘密文件作为卷所需的部分：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[![1](Images/1.png)](#co_application_secrets_management_CO2-1)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_application_secrets_management_CO2-1)'
- en: Mounts the volume with `github-token` name
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`github-token`名称挂载卷
- en: '[![2](Images/2.png)](#co_application_secrets_management_CO2-2)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_application_secrets_management_CO2-2)'
- en: Sets the path where the volume is mounted inside the container
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 设置卷在容器内挂载的路径
- en: '[![3](Images/3.png)](#co_application_secrets_management_CO2-3)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_application_secrets_management_CO2-3)'
- en: Sets the volume as read-only
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 将卷设置为只读
- en: '[![4](Images/4.png)](#co_application_secrets_management_CO2-4)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](Images/4.png)](#co_application_secrets_management_CO2-4)'
- en: Sets the secret name to load
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 设置要加载的秘密名称
- en: '[![5](Images/5.png)](#co_application_secrets_management_CO2-5)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](Images/5.png)](#co_application_secrets_management_CO2-5)'
- en: Sets the mode to be readable from the process
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 设置模式为从进程可读取
- en: 'The last step is to read the secret from the code. Since the secret is mounted
    in the file system, it needs to be read as any other file:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是从代码中读取秘密。由于秘密被挂载在文件系统中，因此需要像读取任何其他文件一样读取它：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[![1](Images/1.png)](#co_application_secrets_management_CO3-1)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_application_secrets_management_CO3-1)'
- en: The location of the secret is the mount path plus the secret key
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 秘密的位置是挂载路径加上秘密密钥
- en: 'To deploy the application, package it, create the Docker container, and apply
    the generated Kubernetes resources:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要部署该应用程序，打包它，创建 Docker 容器，并应用生成的 Kubernetes 资源：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Discussion
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'Kubernetes secrets have some problems that need to be addressed externally.
    The following are some of these problems:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes secrets 存在一些需要通过外部方式解决的问题。以下是其中一些问题：
- en: Secrets are not encrypted but just encoded in Base64 by default.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机密默认情况下不是加密的，而只是以 Base64 编码。
- en: You need to use SSL to communicate with `etcd`. This is the place where the
    secrets are stored.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您需要使用 SSL 与 `etcd` 进行通信。这是存储机密的地方。
- en: The disk needs to be encrypted because `etcd` might store the data on the disk.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要加密磁盘，因为 `etcd` 可能会将数据存储在磁盘上。
- en: You need to correctly define the RBAC to prevent anyone from accessing a secret.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您需要正确定义 RBAC 以防止任何人访问机密。
- en: See Also
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'To learn more about Kubernetes Secrets, visit the following pages on the Kubernetes
    website:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解有关 Kubernetes Secrets 的更多信息，请访问 Kubernetes 网站上的以下页面：
- en: '[Secrets](https://oreil.ly/dFTgh)'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[秘密](https://oreil.ly/dFTgh)'
- en: '[Encrypting Secret Data at Rest](https://oreil.ly/_auK1)'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[加密休息时的秘密数据](https://oreil.ly/_auK1)'
- en: '[Authorization Overview](https://oreil.ly/ctlyn)'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[授权概述](https://oreil.ly/ctlyn)'
- en: '[Using RBAC Authorization](https://oreil.ly/WrcaP)'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用 RBAC 授权](https://oreil.ly/WrcaP)'
- en: 12.2 Store Configuration Secrets Securely with Vault
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12.2 使用 Vault 安全地存储配置机密
- en: Problem
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to store configuration secrets securely.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望安全地存储配置机密。
- en: Solution
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the Quarkus [Vault](https://oreil.ly/UMKuH) extension to retrieve secrets.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Quarkus [Vault](https://oreil.ly/UMKuH) 扩展检索机密。
- en: The key aspects when dealing with secrets are storing them so they cannot be
    read by forbidden users and protecting access to them so only the services that
    require the secrets can access them.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 处理机密时的关键方面是存储方式，使其无法被禁止用户读取，并保护对其的访问，以便只有需要访问机密的服务可以访问它们。
- en: Vault is a tool that simplifies these use cases by providing a unified interface
    for storing and consuming secrets.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Vault 是一个工具，通过提供统一接口来简化这些用例，用于存储和使用机密。
- en: 'Vault supports multiple authentication methods to authenticate against the
    Vault service and start consuming the secrets. At the time of writing, the following
    authentication methods are supported by the Quarkus Vault extension:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Vault 支持多种认证方法，用于对 Vault 服务进行认证并开始使用这些机密。在撰写本文时，Quarkus Vault 扩展支持以下认证方法：
- en: '`token`'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`token`'
- en: Directly pass the user token to bypass the authentication process.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 直接传递用户令牌以绕过认证过程。
- en: '`user`/`password`'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`user`/`password`'
- en: Authenticate with Vault using a username and password credentials.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 使用用户名和密码凭据认证 Vault。
- en: '`approle`'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`approle`'
- en: Authenticate using a `role_id` and a `secret_id`. This method is oriented to
    automated workflows (machines and services). `role_id` is usually embedded into
    a Docker container, and `secret_id` is obtained by a Kubernetes cluster as a cubbyhole
    response, wrapping it (single use) and delivering it to the target service.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `role_id` 和 `secret_id` 进行认证。此方法适用于自动化工作流程（机器和服务）。`role_id` 通常嵌入到 Docker
    容器中，`secret_id` 由 Kubernetes 集群作为 cubbyhole 响应获取，包装（单次使用）并传递给目标服务。
- en: '`kubernetes`'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubernetes`'
- en: Authenticate with Vault using the Kubernetes Service Account Token.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Kubernetes 服务账户令牌认证 Vault。
- en: 'To get started, register the `quarkus-vault` extension to use Vault:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用 Vault，请注册 `quarkus-vault` 扩展。
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The Quarkus Vault extension integrates with the MicroProfile Configuration
    spec so that a secret can be injected using the `@ConfigProperty` annotation.
    Configure the application to use username and password as the authentication method
    for Vault, and set the base path where secrets are stored:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Quarkus Vault 扩展与 MicroProfile 配置规范集成，可以使用 `@ConfigProperty` 注解注入秘密。配置应用程序以使用用户名和密码作为
    Vault 的认证方法，并设置存储机密的基本路径：
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[![1](Images/1.png)](#co_application_secrets_management_CO7-1)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_application_secrets_management_CO7-1)'
- en: The base URL of the Vault server
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Vault 服务器的基本 URL
- en: '[![2](Images/2.png)](#co_application_secrets_management_CO7-2)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_application_secrets_management_CO7-2)'
- en: The credentials to authenticate
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 用于认证的凭据
- en: '[![3](Images/3.png)](#co_application_secrets_management_CO7-3)'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_application_secrets_management_CO7-3)'
- en: The path where the secrets are stored
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 存储机密的路径
- en: 'Access the secret value of the `foo` key by using the `@org.eclipse.microprofile.config.inject.ConfigProperty`
    annotation:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `@org.eclipse.microprofile.config.inject.ConfigProperty` 注解访问 `foo` 键的秘密值：
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[![1](Images/1.png)](#co_application_secrets_management_CO8-1)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_application_secrets_management_CO8-1)'
- en: Secret value for the `foo` key is injected
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为 `foo` 键的秘密值注入
- en: 'Start the application and send a request to the endpoint:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 启动应用程序并向端点发送请求：
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Discussion
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'If the path is known only at runtime, secrets can also be retrieved programmatically
    by injecting the `io.quarkus.vault.VaultKVSecretEngine` interface:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果路径只在运行时已知，则还可以通过注入 `io.quarkus.vault.VaultKVSecretEngine` 接口来以编程方式检索秘密：
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[![1](Images/1.png)](#co_application_secrets_management_CO9-1)'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_application_secrets_management_CO9-1)'
- en: Provides the values stored in the Vault key/value secret engine
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 提供存储在 Vault 键/值秘密引擎中的值
- en: See Also
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'To learn more about Vault, visit the following website:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解有关 Vault 的更多信息，请访问以下网站：
- en: '[Vault: Documentation](https://oreil.ly/ke_Q5)'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Vault：文档](https://oreil.ly/ke_Q5)'
- en: 12.3 Cryptography as a Service
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12.3 加密即服务
- en: Problem
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to avoid spreading all cryptographic operations across all the services.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望避免在所有服务中分散所有密码操作。
- en: Solution
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the *transit* engine of Vault to have all cryptographic operations executed
    in the same place.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Vault 的 *transit* 引擎，将所有密码操作集中在同一位置执行。
- en: 'Open a shell inside the Vault container created in the previous recipe to configure
    Vault and add keys to encrypt and sign messages:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一篇章节创建的 Vault 容器内打开一个 shell，以配置 Vault 并添加用于加密和签署消息的密钥：
- en: '[PRE13]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[![1](Images/1.png)](#co_application_secrets_management_CO10-1)'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_application_secrets_management_CO10-1)'
- en: Sets the token to access
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 设置访问令牌
- en: '[![2](Images/2.png)](#co_application_secrets_management_CO10-2)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_application_secrets_management_CO10-2)'
- en: Enables `transit` engine
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 启用 `transit` 引擎
- en: '[![3](Images/3.png)](#co_application_secrets_management_CO10-3)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_application_secrets_management_CO10-3)'
- en: Creates an encryption key of type `AES-256-GCM96`
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 创建类型为 `AES-256-GCM96` 的加密密钥
- en: '[![4](Images/4.png)](#co_application_secrets_management_CO10-4)'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](Images/4.png)](#co_application_secrets_management_CO10-4)'
- en: Creates a signing key of type `ECDSA-P256`
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 创建类型为 `ECDSA-P256` 的签名密钥
- en: 'Create a policy that gives access to transit operations:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 创建授予过境操作权限的策略：
- en: '[PRE14]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The last step is to enable credentials (`userpass` engine) for accessing secrets
    from the service:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是启用凭证（`userpass` 引擎），以便从服务中访问秘密：
- en: '[PRE15]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[![1](Images/1.png)](#co_application_secrets_management_CO11-1)'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_application_secrets_management_CO11-1)'
- en: Creates a user with ID `alex` and password `alex`
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 ID 为 `alex`、密码为 `alex` 的用户
- en: 'Register `quarkus-vault` extension to use Vault:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 注册 `quarkus-vault` 扩展以使用 Vault：
- en: '[PRE16]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Configure the application to use username and password as the authentication
    method for Vault:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 配置应用程序以将用户名和密码作为 Vault 的身份验证方法：
- en: '[PRE17]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[![1](Images/1.png)](#co_application_secrets_management_CO12-1)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_application_secrets_management_CO12-1)'
- en: The base URL of the Vault server
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Vault 服务器的基本 URL
- en: '[![2](Images/2.png)](#co_application_secrets_management_CO12-2)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_application_secrets_management_CO12-2)'
- en: The credentials to authenticate
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 用于身份验证的凭证
- en: 'Inject the `io.quarkus.vault.VaultTransitSecretEngine` instance to use transit
    operations:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 注入 `io.quarkus.vault.VaultTransitSecretEngine` 实例以使用过境操作：
- en: '[PRE18]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[![1](Images/1.png)](#co_application_secrets_management_CO13-1)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_application_secrets_management_CO13-1)'
- en: Transit operations interface
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 过境操作接口
- en: '[![2](Images/2.png)](#co_application_secrets_management_CO13-2)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_application_secrets_management_CO13-2)'
- en: Encrypts using the encryption key
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 使用加密密钥加密
- en: '[![3](Images/3.png)](#co_application_secrets_management_CO13-3)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_application_secrets_management_CO13-3)'
- en: Decrypts using the encryption key
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 使用加密密钥解密
- en: '[![4](Images/4.png)](#co_application_secrets_management_CO13-4)'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](Images/4.png)](#co_application_secrets_management_CO13-4)'
- en: Signs the text with the given signature
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 用给定签名对文本进行签名
- en: 'Start the application and send a request to the endpoint:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '启动应用程序并发送请求到端点：  '
- en: '[PRE19]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Discussion
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Cryptography operations such as encrypt, decrypt, sign, or hash-based message
    authentication codes (HMACs) of data are commonly required in services. These
    operations are usually implemented in each of the services, which means that you
    are duplicating this sensitive logic as well as the management of the keys in
    each of the services.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务中通常需要执行加密、解密、签名或基于哈希的消息认证码（HMAC）等密码操作。这些操作通常在每个服务中实现，这意味着您也在每个服务中重复执行这些敏感逻辑以及密钥管理。
- en: The Vault Transit engine handles all cryptographic functions for you without
    storing the resulted data. You can think of Vault as a *cryptographic-as-a-service*
    model in which data is sent, manipulated, and returned back without being stored
    internally.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Vault Transit 引擎为您处理所有加密功能，而不存储结果数据。您可以将 Vault 视为 *加密即服务* 模型，在该模型中，数据被发送、操作并返回，而不存储在内部。
- en: Everything is managed internally by Vault, freeing developers to focus on implementing
    the important business logic.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都由 Vault 在内部管理，使开发人员能够专注于实现重要的业务逻辑。
- en: 'The following operations are supported by the Vault extension:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Vault 扩展支持以下操作：
- en: '`encrypt`'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`encrypt`'
- en: Encrypts a regular string with a Vault key configured in the transit secret
    engine.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 使用配置在传输秘密引擎中的 Vault 密钥对常规字符串进行加密。
- en: '`decrypt`'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`decrypt`'
- en: Decrypts the encrypted data with the specified key and returns unencrypted data.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 解密指定键的加密数据并返回未加密数据。
- en: '`rewrap`'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`rewrap`'
- en: Reencrypts into a new cipher text a cipher text that was obtained from encryption
    using an old key version with the last key version.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 使用最新的密钥版本对使用旧密钥版本加密获取的密文重新加密成新的密文。
- en: '`sign`'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`sign`'
- en: Signs an input string with the specified key.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 使用指定键对输入字符串进行签名。
- en: '`verifySignature`'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`verifySignature`'
- en: Checks that the signature was obtained from signing the input with the specified
    key.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 检查签名是否来自使用指定键对输入进行签名的操作。
- en: See Also
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'For more information, visit the following website:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 欲知更多信息，请访问以下网站：
- en: '[Vault: Transit Secrets Engine](https://oreil.ly/rloOa)'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Vault：传输秘密引擎](https://oreil.ly/rloOa)'
- en: 12.4 Generate Database Password as Secret
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12.4 生成数据库密码作为秘密
- en: Problem
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to store the database password securely.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望安全地存储数据库密码。
- en: Solution
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Read the database password as a secret.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 作为秘密读取数据库密码。
- en: The database password is something that needs to be protected and should not
    be set directly to the configuration file. The Quarkus Vault extension integrates
    with persistence configuration to read the database password as a secret from
    Vault.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库密码是需要保护的内容，不应直接设置到配置文件中。Quarkus Vault 扩展集成了持久化配置，从 Vault 中读取数据库密码作为秘密。
- en: 'Open a shell inside the Vault container created in the previous recipe to configure
    Vault and add the database password as a secret:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个配方中创建的 Vault 容器内部打开一个 shell，以配置 Vault 并将数据库密码添加为秘密：
- en: '[PRE20]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[![1](Images/1.png)](#co_application_secrets_management_CO14-1)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_application_secrets_management_CO14-1)'
- en: Sets the token to access
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 设置用于访问的令牌
- en: '[![2](Images/2.png)](#co_application_secrets_management_CO14-2)'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_application_secrets_management_CO14-2)'
- en: Creates a new secret with a key `password` and the value `alex`
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 使用键 `password` 和值 `alex` 创建一个新的秘密
- en: 'Create a policy that gives read access to the secret:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个授予对秘密读取权限的策略：
- en: '[PRE21]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The last step is to enable credentials (`userpass` engine) for accessing secrets
    from the service:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是启用凭据（`userpass` 引擎）以从服务中访问秘密：
- en: '[PRE22]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[![1](Images/1.png)](#co_application_secrets_management_CO15-1)'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_application_secrets_management_CO15-1)'
- en: Creates a user with ID `alex` and password `alex`
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个 ID 为 `alex` 并且密码为 `alex` 的用户
- en: 'For this example, the PostgreSQL server is used as database. Start a new Docker
    instance in a new terminal by running the following command:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，使用 PostgreSQL 服务器作为数据库。通过运行以下命令在新终端中启动一个新的 Docker 实例：
- en: '[PRE23]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Notice that the password is the same as the one set in the *secret/myapps/vault-service/db*
    path.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，密码与 *secret/myapps/vault-service/db* 路径中设置的密码相同。
- en: 'Register the `quarkus-vault` and persistence extensions:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 注册 `quarkus-vault` 和持久化扩展：
- en: '[PRE24]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The datasource configuration is slightly different than the one shown in [Chapter 7](ch07.xhtml#persistence_chapter).
    Instead of having the password hardcoded in the configuration file, the password
    is retrieved from Vault as a secret and is used to make the connection.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 数据源配置与 [第7章](ch07.xhtml#persistence_chapter) 中显示的配置略有不同。不是将密码硬编码到配置文件中，而是作为秘密从
    Vault 中检索并用于建立连接。
- en: Apart from Vault configuration parameters such as the URL and the authenticated
    method (i.e., user/password), you need to define the key/value path inside Vault,
    where the database configuration is stored. More specifically, it is the path
    where the key named `password` is stored with the database password. In the following
    example, to set this information into Vault, you run the command `vault kv put
    secret/myapps/vault-service/db password=alex`, but if you have followed this section,
    you’ve already done this when configuring Vault.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 Vault 配置参数（如 URL 和认证方法（即用户/密码））外，您还需要定义 Vault 内部的键/值路径，其中存储了数据库配置。更具体地说，它是存储带有数据库密码的名为
    `password` 的键的路径。在以下示例中，要将此信息设置到 Vault 中，您可以运行命令 `vault kv put secret/myapps/vault-service/db
    password=alex`，但如果您已经在配置 Vault 时完成了此操作。
- en: Also, overriding the credentials provider used when establishing the connection
    to the database is required to indicate that the password comes from Vault and
    not as a configuration property. This is done by using the `q⁠u⁠a⁠r⁠k⁠u⁠s⁠.⁠d⁠a⁠t⁠a​s⁠o⁠u⁠r⁠c⁠e⁠.⁠c⁠r⁠e⁠d⁠e⁠n⁠t⁠i⁠a⁠l⁠s⁠-⁠p⁠r⁠o⁠v⁠i⁠d⁠e⁠r`
    property.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要覆盖用于建立与数据库连接时使用的凭据提供程序，以指示密码来自 Vault 而不是作为配置属性。这通过使用 `q⁠u⁠a⁠r⁠k⁠u⁠s⁠.⁠d⁠a⁠t⁠a⁠s⁠o⁠u⁠r⁠c⁠e⁠.⁠c⁠r⁠e⁠d⁠e⁠n⁠t⁠i⁠a⁠l⁠s⁠-⁠p⁠r⁠o⁠v⁠i⁠d⁠e⁠r`
    属性完成。
- en: 'Configure the application with the datasource and Vault parameters and override
    the credentials provider:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 配置应用程序的数据源和 Vault 参数，并覆盖凭据提供程序：
- en: '[PRE25]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[![1](Images/1.png)](#co_application_secrets_management_CO16-1)'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_application_secrets_management_CO16-1)'
- en: Sets the credentials provider to a custom name (`mydatabase`)
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 将凭据提供程序设置为自定义名称（`mydatabase`）
- en: '[![2](Images/2.png)](#co_application_secrets_management_CO16-2)'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_application_secrets_management_CO16-2)'
- en: Sets the key/value path where the password is stored for the `mydatabase` provider
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 设置保存 `mydatabase` 提供程序密码的键/值路径
- en: '[![3](Images/3.png)](#co_application_secrets_management_CO16-3)'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_application_secrets_management_CO16-3)'
- en: Configures Vault parameters
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 配置 Vault 参数
- en: It is important to note that there is no `quarkus.datasource.password` property
    because the password is retrieved from Vault.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，没有 `quarkus.datasource.password` 属性，因为密码从 Vault 获取。
- en: 'At this time, when the Quarkus application is started, the following steps
    are executed:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 当启动 Quarkus 应用程序时，执行以下步骤：
- en: Service authenticates to the Vault service.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务对接 Vault 服务进行认证。
- en: Key/Value is retrieved from `secret/myapps/vault-service/db` path.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `secret/myapps/vault-service/db` 路径检索键/值。
- en: The value of the key `password` is used as password credentials for the database.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 键 `password` 的值被用作数据库凭据的密码。
- en: Tip
  id: totrans-203
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: 'The key name can be changed from `password` to any other key name by using
    the `kv-key` property: `quarkus.vault.credentials-provider.mydatabase.kv-key=pass`.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 可通过 `kv-key` 属性将密钥名称从 `password` 更改为任何其他密钥名称：`quarkus.vault.credentials-provider.mydatabase.kv-key=pass`。
- en: Discussion
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Vault can generate database credentials dynamically and configure the database
    instances to use them as credentials instead of having to manually configure the
    credentials and set them in Vault and/or in the service that requires access to
    the database. This implies that no credentials are hardcoded in any place, as
    they are requested from Vault. The generated pair of username and password are
    subject to Vault’s leasing mechanism, which makes the credentials invalid after
    a reasonable time.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Vault 可以动态生成数据库凭据，并配置数据库实例使用它们作为凭据，而不是手动配置凭据并将其设置在 Vault 和/或需要访问数据库的服务中。这意味着在任何地方都不会硬编码凭据，因为它们是从
    Vault 请求的。生成的用户名和密码遵循 Vault 的租赁机制，使得凭据在合理时间后失效。
- en: 'Take the following steps to configure Vault to generate database credentials
    dynamically:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 配置 Vault 以动态生成数据库凭据，请按以下步骤操作：
- en: Enable the database secret engine.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用数据库机密引擎。
- en: Set connection parameters to the database, and set the vendor database (at this
    time most of SQL and NoSQL databases are supported).
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置连接参数到数据库，并设置供应商数据库（此时大多数 SQL 和 NoSQL 数据库都受支持）。
- en: 'Configure a role that maps a name in Vault to an SQL statement to create the
    database credential:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置将名字在 Vault 中映射到 SQL 语句以创建数据库凭证的角色：
- en: '[PRE26]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The Vault extension also supports using dynamic database credentials through
    the `database-credentials-role` property on the `credentials-provider`:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: Vault 扩展还支持通过 `credentials-provider` 上的 `database-credentials-role` 属性使用动态数据库凭据：
- en: '[PRE27]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[![1](Images/1.png)](#co_application_secrets_management_CO17-1)'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_application_secrets_management_CO17-1)'
- en: No password set
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 未设置密码
- en: '[![2](Images/2.png)](#co_application_secrets_management_CO17-2)'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_application_secrets_management_CO17-2)'
- en: Configures dynamic credentials
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 配置动态凭据
- en: See Also
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'To learn more about dynamic database credentials with Vault, visit the following
    website:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解有关使用 Vault 的动态数据库凭据的更多信息，请访问以下网站：
- en: '[Vault: Databases](https://oreil.ly/RDaes)'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Vault：数据库](https://oreil.ly/RDaes)'
- en: 12.5 Authenticating Services Using Vault Kubernetes Auth
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12.5 使用 Vault Kubernetes Auth 验证服务
- en: Problem
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to authenticate services against Vault without using a username/password.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望在不使用用户名/密码的情况下对接 Vault 认证服务。
- en: Solution
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the Vault Kubernetes Auth method.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Vault Kubernetes Auth 方法。
- en: So far, you’ve used credentials with the username/password approach to authenticating
    the Quarkus service against the Vault service. This method might be good in some
    circumstances (testing purposes, internal applications, etc.), but notice that
    you are introducing a new secret (the password) to get more secrets. One way to
    fix this problem is by using Kubernetes Secrets to set the Vault password using,
    for example, the `approle` authentication method. Another way is to use the Vault
    Kubernetes Auth, which makes it a perfect fit for authenticating services deployed
    in a Kubernetes cluster.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经使用了用户名/密码方法来对接 Quarkus 服务与 Vault 服务进行认证。在某些情况下（例如测试目的、内部应用程序等），这种方法可能很好，但请注意，您正在引入一个新的秘密（密码）以获取更多秘密。解决此问题的一种方法是使用
    Kubernetes Secrets 设置 Vault 密码，例如使用 `approle` 认证方法。另一种方法是使用 Vault Kubernetes Auth，这使其非常适合用于认证部署在
    Kubernetes 集群中的服务。
- en: The Vault Kubernetes `auth` method uses the Kubernetes service account token
    and a defined role to authenticate against a Vault service. With this method,
    Vault does not store the credentials; it uses a trusted third party (the Kubernetes
    cluster) to validate them. When the Pod with the service is instantiated, the
    service account token is mounted inside the container, so it is accessible by
    the application. The default mounting point of the secret token is */var/run/secrets/kubernetes.io/serviceaccount/token*.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: Vault Kubernetes `auth` 方法使用 Kubernetes 服务账户令牌和定义的角色来对接 Vault 服务进行认证。使用这种方法，Vault
    不会存储凭据；它使用一个受信任的第三方（Kubernetes 集群）来验证它们。当包含服务的 Pod 实例化时，服务账户令牌会挂载在容器内，因此应用程序可以访问它。秘密令牌的默认挂载点是
    */var/run/secrets/kubernetes.io/serviceaccount/token*。
- en: The application then attempts to authenticate using this token by sending it
    to the Vault server. After that, Vault makes a call to Kubernetes API to ensure
    the validity of the token. If the token is valid, then an internal Vault token
    is returned to be used in future requests to get secrets. The process is summarized
    in [Figure 12-1](#vaultk8sauth).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 然后应用程序尝试使用此令牌进行身份验证，将其发送到 Vault 服务器。然后，Vault 调用 Kubernetes API 来验证令牌的有效性。如果令牌有效，则返回内部
    Vault 令牌，以便将来用于获取秘密的请求。该过程在 [图 12-1](#vaultk8sauth) 中进行了总结。
- en: '![qucb 1201](Images/qucb_1201.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![qucb 1201](Images/qucb_1201.png)'
- en: Figure 12-1\. Kubernetes authentication method
  id: totrans-230
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-1\. Kubernetes 认证方法
- en: To configure the Kubernetes auth mode, you need to set two parameters to Vault
    to connect to Kubernetes API. The first one is the token to access, and the second
    one is the certificate authority to validate the communication between Vault and
    the Kubernetes API. These values are retrieved from the secret that starts with
    `vault-token`. When Vault was first set up for this example, the value was `vault-token-mm5qx`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置 Kubernetes 认证模式，您需要向 Vault 设置两个参数以连接到 Kubernetes API。第一个是访问令牌，第二个是用于验证 Vault
    与 Kubernetes API 之间通信的证书颁发机构。这些值来自以 `vault-token` 开头的秘密。当为本示例首次设置 Vault 时，该值为
    `vault-token-mm5qx`。
- en: 'To get the token and store it in a file, open a terminal window and run the
    following command:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取令牌并将其存储在文件中，请打开终端窗口并运行以下命令：
- en: '[PRE28]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[![1](Images/1.png)](#co_application_secrets_management_CO18-1)'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_application_secrets_management_CO18-1)'
- en: Substitute the secret name to your secret name starting with `vault-token`
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 将秘密名称替换为以 `vault-token` 开头的您的秘密名称
- en: '[![2](Images/2.png)](#co_application_secrets_management_CO18-2)'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_application_secrets_management_CO18-2)'
- en: Secrets are stored in Base64, so they need to be decoded
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 秘密存储在 Base64 中，因此需要解码
- en: 'To get the certificate authority and store it in a file, run the following
    in the terminal:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取证书颁发机构并将其存储在文件中，请在终端中运行以下命令：
- en: '[PRE29]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[![1](Images/1.png)](#co_application_secrets_management_CO19-1)'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_application_secrets_management_CO19-1)'
- en: Pod is named `vault-0`
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: Pod 的名称为 `vault-0`
- en: '[![2](Images/2.png)](#co_application_secrets_management_CO19-2)'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_application_secrets_management_CO19-2)'
- en: A `vault-token` is set as a secret
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `vault-token` 设置为一个秘密
- en: Before deploying the application, you need to enable Kubernetes `auth` method,
    configure it, and insert some secrets to test it.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在部署应用程序之前，您需要启用 Kubernetes `auth` 方法，进行配置，并插入一些秘密来进行测试。
- en: 'Expose the Vault service out of the Kubernetes cluster so that it can be configured
    from your local machine. Open a new terminal window and run the command to forward
    the traffic from `localhost:8200` into the Vault instance running inside the Kubernetes
    cluster:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Vault 服务暴露在 Kubernetes 集群外，以便可以从本地机器进行配置。打开一个新的终端窗口，并运行以下命令以将流量从 `localhost:8200`
    转发到运行在 Kubernetes 集群内的 Vault 实例：
- en: '[PRE30]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Get back to the terminal window where you run the commands to get the token
    and the certificate authority, and run the following commands to insert a secret:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到运行命令获取令牌和 CA 的终端窗口，并运行以下命令插入一个秘密：
- en: '[PRE31]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[![1](Images/1.png)](#co_application_secrets_management_CO20-1)'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_application_secrets_management_CO20-1)'
- en: Configure Vault connection parameters
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 配置 Vault 连接参数
- en: '[![2](Images/2.png)](#co_application_secrets_management_CO20-2)'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_application_secrets_management_CO20-2)'
- en: Creates a policy called `vault-service-policy` to `myapps/vault-service/*` secrets
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 创建名为 `vault-service-policy` 的策略来管理 `myapps/vault-service/*` 的秘密
- en: '[![3](Images/3.png)](#co_application_secrets_management_CO20-3)'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_application_secrets_management_CO20-3)'
- en: Sets a new secret
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 设置一个新的秘密
- en: The last step is enabling the Kubernetes `auth` method and configuring it to
    validate the token using the Kubernetes API.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是启用 Kubernetes `auth` 方法，并配置它使用 Kubernetes API 验证令牌。
- en: 'Execute the following commands:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下命令：
- en: '[PRE32]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[![1](Images/1.png)](#co_application_secrets_management_CO21-1)'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_application_secrets_management_CO21-1)'
- en: Enables Kubernetes `auth` method
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 启用 Kubernetes `auth` 方法
- en: '[![2](Images/2.png)](#co_application_secrets_management_CO21-2)'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_application_secrets_management_CO21-2)'
- en: Configures the `auth` method
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 配置 `auth` 方法
- en: '[![3](Images/3.png)](#co_application_secrets_management_CO21-3)'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_application_secrets_management_CO21-3)'
- en: Sets the token file retrieved in the previous step
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 设置在前面的步骤中检索到的令牌文件
- en: '[![4](Images/4.png)](#co_application_secrets_management_CO21-4)'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](Images/4.png)](#co_application_secrets_management_CO21-4)'
- en: Sets the Kubernetes API host
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 Kubernetes API 主机
- en: '[![5](Images/5.png)](#co_application_secrets_management_CO21-5)'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](Images/5.png)](#co_application_secrets_management_CO21-5)'
- en: Sets the CA file retrieved in the previous step
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 设置在前面的步骤中检索到的 CA 文件
- en: '[![6](Images/6.png)](#co_application_secrets_management_CO21-6)'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](Images/6.png)](#co_application_secrets_management_CO21-6)'
- en: Creates a new role (`example`) to authenticate from the application
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新角色 (`example`) 以从应用程序进行身份验证
- en: '[![7](Images/7.png)](#co_application_secrets_management_CO21-7)'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](Images/7.png)](#co_application_secrets_management_CO21-7)'
- en: Sets the service account name that in our deployment is `vault`
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 设置在我们的部署中使用的服务账号名称为 `vault`
- en: '[![8](Images/8.png)](#co_application_secrets_management_CO21-8)'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '[![8](Images/8.png)](#co_application_secrets_management_CO21-8)'
- en: Sets the namespace where services are running
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 设置服务运行的命名空间
- en: '[![9](Images/9.png)](#co_application_secrets_management_CO21-9)'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '[![9](Images/9.png)](#co_application_secrets_management_CO21-9)'
- en: Binds the user authenticating with this method to the created policy
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 将使用此方法进行身份验证的用户绑定到创建的策略
- en: Let’s develop a Quarkus service that authenticates using the Vault Kubernetes
    `auth` method and get the secret named `foo`.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 开发一个使用 Vault Kubernetes `auth` 方法进行认证并获取名为 `foo` 的秘密的 Quarkus 服务。
- en: 'Add the Vault and Kubernetes extensions:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 添加 Vault 和 Kubernetes 扩展：
- en: '[PRE33]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Configure the application to use the Kubernetes Vault `auth` method and the
    Kubernetes extension to generate the correct deployment file:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 配置应用程序以使用 Kubernetes Vault `auth` 方法和 Kubernetes 扩展来生成正确的部署文件：
- en: '[PRE35]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[![1](Images/1.png)](#co_application_secrets_management_CO22-1)'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_application_secrets_management_CO22-1)'
- en: Configures Vault location and secrets
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 配置 Vault 的位置和秘密
- en: '[![2](Images/2.png)](#co_application_secrets_management_CO22-2)'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_application_secrets_management_CO22-2)'
- en: Sets the `example` role to be used by the user (created in the previous step)
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 `example` 角色供用户使用（在上一步中创建）
- en: '[![3](Images/3.png)](#co_application_secrets_management_CO22-3)'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_application_secrets_management_CO22-3)'
- en: Sets the `serviceaccount` name to set in the generated deployment file
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 设置要在生成的部署文件中设置的 `serviceaccount` 名称
- en: '[![4](Images/4.png)](#co_application_secrets_management_CO22-4)'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](Images/4.png)](#co_application_secrets_management_CO22-4)'
- en: Sets the group name of Docker image
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 Docker 镜像的组名
- en: Notice that the `quarkus.vault.authentication.kubernetes.jwt-token-path` property
    is not set. The reason is that the default value (`/var/run/secrets/kubernetes.io/serviceaccount/token`)
    works perfectly with the defaults. If the secret was mounted on a different path,
    then this property should be set to the new location.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`quarkus.vault.authentication.kubernetes.jwt-token-path` 属性未设置。原因是默认值 (`/var/run/secrets/kubernetes.io/serviceaccount/token`)
    与默认值完美配合。如果秘密挂载在不同的路径上，则应将此属性设置为新位置。
- en: 'To deploy the application, open a new terminal window, package the application,
    create the Docker container, and apply the generated Kubernetes resources:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 要部署应用程序，请打开一个新的终端窗口，打包应用程序，创建 Docker 容器，并应用生成的 Kubernetes 资源：
- en: '[PRE36]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: When the Pod is deployed, the application is authenticated with Vault, and Vault
    validates that the token is valid using the Kubernetes API. The application is
    then authenticated and can get the secrets from the configured path.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 当Pod部署后，应用程序通过Vault进行身份验证，并且Vault使用Kubernetes API验证令牌是否有效。然后应用程序被验证，并可以从配置的路径获取秘密。
- en: The big difference between this example and the previous ones is that in this
    case no secret like the Vault password is set, meaning that the secrets can be
    accessed securely but without having to add any new secret.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例与之前的示例之间的主要区别在于，在这种情况下没有像Vault密码这样的秘密设置，这意味着可以安全地访问秘密，但无需添加任何新秘密。
- en: Discussion
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Our intention isn’t to show how to deploy Vault in Kubernetes for production
    purposes. For this reason, a deployment file is provided to deploy a Vault service
    with the minimal requirements to run this example.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目的不是展示如何在生产环境中部署Kubernetes中的Vault。因此，提供了一个部署文件，用于部署一个仅满足此示例运行所需的最小要求的Vault服务。
- en: 'This deployment file is located at *src/main/kubernetes/vault-dev-deployment.yaml*
    and provides the following elements:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 此部署文件位于*src/main/kubernetes/vault-dev-deployment.yaml*，提供以下元素：
- en: Vault with `dev` mode and root token set to `root`.
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`dev`模式和根令牌设置为`root`的Vault。
- en: Exposes Vault at port 8200.
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在端口8200上公开Vault。
- en: '`ServiceAccount` with the name set to `vault`.'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ServiceAccount`的名称设置为`vault`。'
- en: '`ClusterRoleBinding` and `ClusterRole` bound to `vault`.'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ClusterRoleBinding`和`ClusterRole`绑定到`vault`。'
- en: All resources applied to the `default` namespace.
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有应用于`default`命名空间的资源。
- en: 'Deploy the Vault service by running the following command:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行以下命令部署Vault服务：
- en: '[PRE37]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[![1](Images/1.png)](#co_application_secrets_management_CO23-1)'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_application_secrets_management_CO23-1)'
- en: Pod is named `vault-0`
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: Pod命名为`vault-0`
- en: '[![2](Images/2.png)](#co_application_secrets_management_CO23-2)'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_application_secrets_management_CO23-2)'
- en: A `vault-token` is set as a secret
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '`vault-token`设置为一个秘密'
- en: To configure Vault, you need to install the Vault CLI locally on your computer.
    The Vault CLI is a single file that can be downloaded from [Vault](https://oreil.ly/fTB0x)
    and set in your `PATH` variable.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置Vault，您需要在计算机上本地安装Vault CLI。Vault CLI是一个单文件，可以从[Vault](https://oreil.ly/fTB0x)下载，并设置在您的`PATH`变量中。
- en: Assuming you’ve got the Vault client installed locally and available in your
    PATH variable, you can configure Vault.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您已在本地安装并将Vault客户端添加到您的PATH变量中，您可以配置Vault。
- en: See Also
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'To learn more about Vault Kubernetes `auth` method, visit the following websites:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解有关Vault Kubernetes `auth`方法的更多信息，请访问以下网站：
- en: '[Vault: Kubernetes Auth Method](https://oreil.ly/AV3D_)'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Vault：Kubernetes认证方法](https://oreil.ly/AV3D_)'
- en: '[Vault Agent with Kubernetes](https://oreil.ly/WGbUx)'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用Kubernetes的Vault代理](https://oreil.ly/WGbUx)'
