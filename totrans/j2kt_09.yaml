- en: Chapter 9\. Multi- to Single-Expression Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nat and Duncan both love Kotlin’s single-expression function definitions. When
    should we use this form, why might we prefer it, and what Kotlin features can
    we use to make more functions single expressions?
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'As with Java, the code in a Kotlin function is usually { defined inside braces
    } and uses `return` to define the result of the function (unless it is `Unit`,
    Kotlin’s alias for `void`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If the top level of the code is a single expression though, we can optionally
    drop the result type, and define the code with an expression after an equals sign:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We can read this as: the result of function `add` equals `a + b`. Which makes
    sense for a single expression, and can also read nicely when that expression is
    itself composed of subexpressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This interpretation makes less sense for functions that have side effects,
    especially those that perform I/O or write to mutable state. For instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We can’t read this as the result of `printTwice` equals `println(..)`, because
    `println` doesn’t have a result, or at least it doesn’t return one. Its function
    is entirely side effects, as we explored in [Chapter 7](ch07.html#actions-to-calculations).
  prefs: []
  type: TYPE_NORMAL
- en: Reserve Single-Expression Functions for Calculations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we adopt a convention of reserving single-expression functions for calculations
    ([“Calculations”](ch07.html#calculations)), then we have a way of communicating
    our intent when we use them. When we see a single-expression function, we will
    know that it isn’t an action ([“Actions”](ch07.html#actions)), and so is much
    safer to refactor.
  prefs: []
  type: TYPE_NORMAL
- en: In practice this means that single-expression functions shouldn’t return `Unit`,
    or read or write from mutable state, including performing I/O.
  prefs: []
  type: TYPE_NORMAL
- en: Your authors have found that attempting to make as many functions as possible
    into single expressions improves our software. For one thing, if we reserve the
    single-expression form for calculations, then this will decrease the proportion
    of our code that is [actions](ch07.html#actions), making it easier to understand
    and modify. Single expressions will also tend to be shorter than the alternative,
    limiting the complexity of each function. When a function does get too large to
    be easily understood, single-expression style lets us more easily refactor for
    clarity, because there is less risk of breaking logic that depends on side effects
    and the order in which actions are performed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also prefer expressions as opposed to statements. Expressions are *declarative*:
    we declare *what* we want the function to calculate and let the Kotlin compiler
    and runtime decide *how* to compute that calculation. We don’t have to run the
    code in a simulated computer in our heads to figure out what the function does.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, at the end of [Chapter 3](ch03.html#java-to-kotlin-classes) we
    were left with this code for `EmailAddress`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 9.1 [single-expressions.0:src/main/java/travelator/EmailAddress.kt]](https://java-to-kotlin.dev/code.html?ref=9.1&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=9.1&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: The `toString` method is already a nice simple single expression. As we said
    at the time though, the amount of code required in the `parse` method adds insult
    to the injury of having to declare static methods in a companion object. Maybe
    focusing on making the function into a simple single expression would help?
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we go on, we should say that lots of the refactoring sequences presented
    in this book are of the form “Here’s one I prepared earlier.” We show you the
    successful take. Real-life refactorings, like writing code from scratch, aren’t
    like that. We try things that don’t work at all, or we take a much more circuitous
    route than we show in the final edit. Because this is an otherwise small example,
    we’ve taken this opportunity to show what actually happened when we tried to convert
    `parse` to a single expression. We think that there are valuable lessons in the
    journey, but if you just want the destination, you should skip ahead to [“Take
    4: Stepping Back”](#take-4).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Take 1: Inlining'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s analyze the code and see what is preventing this function from being
    a nice single expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 9.2 [single-expressions.1:src/main/java/travelator/EmailAddress.kt]](https://java-to-kotlin.dev/code.html?ref=9.2&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=9.2&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: '[![1](assets/1.png)](#co_introduction_CO16-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Assigning to `atIndex` is a statement.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_introduction_CO16-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The call to `require` is a statement.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_introduction_CO16-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the `EmailAddress` is a single expression, depending on `value` and
    `atIndex`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first statement is the assignment to `atIndex`. In Kotlin, assignment is
    a statement, not an expression (unlike Java, where we can chain assignments).
    Its position in the code also matters—it has to happen here in the code for the
    value of `atIndex` to be available to compile the rest of the function. The expression
    bound to the variable, `value.lastIndexOf(Char)`, is a calculation though, meaning
    that it will always return the same result for the same arguments (`this` is considered
    an argument when we call methods). As a result, we can inline the variable `atIndex`
    without changing the result of the function, giving:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 9.3 [single-expressions.2:src/main/java/travelator/EmailAddress.kt]](https://java-to-kotlin.dev/code.html?ref=9.3&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=9.3&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: This version won’t produce the same bytecode, nor run as fast (probably, it’s
    notoriously difficult to second-guess HotSpot), but it will return the same result.
    We still have that `require` call to deal with, though, and we seem to have made
    everything a bit less understandable already, so let’s revert the change and try
    another tack.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take 2: Introduce a Function'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another way to remove the assignment statement is to have a scope where `atIndex`
    is always defined. We could use a function as such a scope, because a function
    binds a single evaluation of its arguments to its parameters. We can see this
    by selecting all but the code before the assignment and extracting a function
    `emailAddress`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 9.4 [single-expressions.3:src/main/java/travelator/EmailAddress.kt]](https://java-to-kotlin.dev/code.html?ref=9.4&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=9.4&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can inline the `atIndex` variable in `parse`, because the `atIndex`
    parameter has captured its value for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 9.5 [single-expressions.4:src/main/java/travelator/EmailAddress.kt]](https://java-to-kotlin.dev/code.html?ref=9.5&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=9.5&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: Now `parse` is a single expression, but `emailAddress(...)` isn’t, so we can’t
    declare victory just yet. That `require` is always going to cause us some problems,
    because its job is to prevent evaluation from proceeding. This is the opposite
    of an expression, which needs to evaluate to a value.
  prefs: []
  type: TYPE_NORMAL
- en: Often when we reach this sort of impasse when refactoring, inlining the cause
    of the problem will let us see the way ahead. So let’s inline `require`. (Suspend
    disbelief for now; things are going to get worse before they get better.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 9.6 [single-expressions.5:src/main/java/travelator/EmailAddress.kt]](https://java-to-kotlin.dev/code.html?ref=9.6&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=9.6&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s an awful lot of redundancy that we can remove here. Alt-Enter on the
    `if` condition will remove the double-negation `!!`, and then Alt-Enter on the
    redundant `toString` will remove it. This allows us to inline `message`, yielding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 9.7 [single-expressions.6:src/main/java/travelator/EmailAddress.kt]](https://java-to-kotlin.dev/code.html?ref=9.7&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=9.7&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can introduce an `else` to see the structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 9.8 [single-expressions.7:src/main/java/travelator/EmailAddress.kt]](https://java-to-kotlin.dev/code.html?ref=9.8&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=9.8&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point we have a function with two statements chosen by an `if`. This
    is so tantalizingly close to a single expression that even the IDE can feel it:
    Alt-Enter on the `if`, and IntelliJ offers to “Lift return out of ‘if’”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 9.9 [single-expressions.8:src/main/java/travelator/EmailAddress.kt]](https://java-to-kotlin.dev/code.html?ref=9.9&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=9.9&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'There it is—our single expression. Alt-Enter on the `return` offers “Convert
    to expression body”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 9.10 [single-expressions.9:src/main/java/travelator/EmailAddress.kt]](https://java-to-kotlin.dev/code.html?ref=9.10&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=9.10&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'When we’re defining a function as a single expression, `when` is often clearer
    than `if`. IntelliJ will do this for us if we Alt-Enter on the `if`. Here we’ve
    also removed unnecessary braces, inlined `message`, and finally converted `parse`
    to a single expression too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 9.11 [single-expressions.10:src/main/java/travelator/EmailAddress.kt]](https://java-to-kotlin.dev/code.html?ref=9.11&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=9.11&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'For comparison, here is the original:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 9.12 [single-expressions.11:src/main/java/travelator/EmailAddress.kt]](https://java-to-kotlin.dev/code.html?ref=9.12&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=9.12&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: Are we happy with the result?
  prefs: []
  type: TYPE_NORMAL
- en: Not really. We now have *more* code, and that `emailAddress` function doesn’t
    feel like it’s adding any value except for capturing `atIndex`.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring is often a process of exploration. We have a goal in mind, but don’t
    always know how it will turn out. It’s our (your authors’) experience that trying
    to find a single-expression form of a function often improves our code, but we
    can’t look you in the eye and say that has happened here.
  prefs: []
  type: TYPE_NORMAL
- en: We could give up on the idea, or we could push on and try to get there from
    here. Instead though, let’s revert and try a third approach, informed by the experience
    we’ve just gained.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take 3: Let'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The reason we extracted the `emailAddress` function was to give us a scope
    where the `atIndex` value is defined throughout the block; rather than having
    to be assigned to a local variable. Where we only have one variable we need to
    replace, a `let` block gives us this facility without having to define a function.
    We can get there in baby steps by first surrounding the code after the assignment
    with a `let`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 9.13 [single-expressions.12:src/main/java/travelator/EmailAddress.kt]](https://java-to-kotlin.dev/code.html?ref=9.13&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=9.13&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can lift the return out of the `let`; unfortunately IntelliJ doesn’t
    offer to help us this time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 9.14 [single-expressions.13:src/main/java/travelator/EmailAddress.kt]](https://java-to-kotlin.dev/code.html?ref=9.14&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=9.14&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Currently, `atIndex` in the `let` block refers to the local that we are trying
    to remove. If we add a lambda parameter with the same name, it will bind to that
    instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 9.15 [single-expressions.14:src/main/java/travelator/EmailAddress.kt]](https://java-to-kotlin.dev/code.html?ref=9.15&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=9.15&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: '[![1](assets/1.png)](#co_introduction_CO17-1)'
  prefs: []
  type: TYPE_NORMAL
- en: '`Warning Name shadowed: atIndex`, which is the point'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inline the `atIndex` variable and we have our single expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 9.16 [single-expressions.15:src/main/java/travelator/EmailAddress.kt]](https://java-to-kotlin.dev/code.html?ref=9.16&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=9.16&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now Alt-Enter on the return lets us “Convert to expression body”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 9.17 [single-expressions.16:src/main/java/travelator/EmailAddress.kt]](https://java-to-kotlin.dev/code.html?ref=9.17&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=9.17&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: We’ve reached the point of no return! Are we happy with the result?
  prefs: []
  type: TYPE_NORMAL
- en: Duncan is writing this, and he *is* pretty relieved to have made it here after
    15 refactoring steps. The example has certainly served its purpose of showing
    some tricks to allow us to get to single-expression functions. Nevertheless, he
    isn’t convinced that it has demonstrated that seeking single expressions has a
    significant payoff. This still seems to be a lot of code, and none of it feels
    like it is earning its keep.
  prefs: []
  type: TYPE_NORMAL
- en: Can we make this better by raising the level of abstraction? Let’s try a fourth
    tack.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take 4: Stepping Back'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we step out from the mechanical refactorings, we can see that what we are
    doing is creating an `EmailAddress` from two nonempty strings separated by a particular
    character, `@` in this case. Finding two nonempty strings separated by a character
    sounds like a higher-level concept that we could refactor toward.
  prefs: []
  type: TYPE_NORMAL
- en: 'One last revert, then, back to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 9.18 [single-expressions.17:src/main/java/travelator/EmailAddress.kt]](https://java-to-kotlin.dev/code.html?ref=9.18&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=9.18&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'This time we’ll concentrate not on `atIndex`, but on those `substring` calls.
    We’ll pull them out into variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 9.19 [single-expressions.18:src/main/java/travelator/EmailAddress.kt]](https://java-to-kotlin.dev/code.html?ref=9.19&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=9.19&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, one more time with feeling. We can extract a function of all but the return
    statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 9.20 [single-expressions.19:src/main/java/travelator/EmailAddress.kt]](https://java-to-kotlin.dev/code.html?ref=9.20&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=9.20&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: IntelliJ turns out to be really quite clever here, making the result a `Pair`
    because it has two values to return.
  prefs: []
  type: TYPE_NORMAL
- en: 'This `split` would be a nice generic function that we might use in other places
    if it was parameterized with the character. “Introduce Parameter” on the `''@''`
    makes that so. We “Convert parameter to receiver” on `value` while we’re there
    to get a little local extension function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 9.21 [single-expressions.20:src/main/java/travelator/EmailAddress.kt]](https://java-to-kotlin.dev/code.html?ref=9.21&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=9.21&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can introduce a `let`, as we did previously, to get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 9.22 [single-expressions.21:src/main/java/travelator/EmailAddress.kt]](https://java-to-kotlin.dev/code.html?ref=9.22&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=9.22&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: This, finally, is a single-expression function that feels worth the effort!
  prefs: []
  type: TYPE_NORMAL
- en: 'To finish, we can apply the techniques from this chapter to `split` to make
    it a single expression, too. Here then is the final `EmailAddress.kt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 9.23 [single-expressions.22:src/main/java/travelator/EmailAddress.kt]](https://java-to-kotlin.dev/code.html?ref=9.23&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=9.23&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: '`splitAroundLast` felt like a better name that doesn’t clash with the standard
    `String.split`, and hints that both sides of the split must be nonempty. Words
    like *around*, which are unusual in identifiers, should prompt readers of the
    code to suspend their assumptions about what a function does and actually look
    it up.'
  prefs: []
  type: TYPE_NORMAL
- en: Although `splitAroundLast` does feel like a generally applicable utility function,
    if we want to promote it to be public, we should probably write some unit tests
    for it. We’ve spent enough time for today though, so we’ll make a mental note
    that we have a `String.splitAroundLast` lying around if we ever need one, and
    finally commit the change.
  prefs: []
  type: TYPE_NORMAL
- en: Moving On
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Defining our calculations as single-expression functions lets us communicate
    that they are different from side-effecting actions. Trying to express functions
    as a simple single expression is a useful discipline that can lead to well-factored,
    clean code. To achieve single-expression form, we usually have to factor out subexpressions
    into their own functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Single-expression form is declarative: the expression describes the function’s
    result in terms of its parameters rather than the actions that the computer must
    perform to compute the result. Factoring subexpressions into their own functions
    prompts us to think about what those subexpressions should be denoting, and so
    guides us to write clearer code. For example, `String.splitAroundLast(''@'')`
    better described what we wanted to calculate than `emailAddress(value: String,
    atIndex: Int)`.'
  prefs: []
  type: TYPE_NORMAL
- en: At a deeper level, this chapter is about more than single expressions; it’s
    about how we can rearrange our code without changing its behavior. Many different
    arrangements of statements and expressions will have the same behavior; refactoring
    is the art of finding a better one, and getting there safely. The more arrangements
    we can visualize, and the more safe routes we can plan, the more options we have
    to make our code better.
  prefs: []
  type: TYPE_NORMAL
- en: Refactorings don’t always succeed the first, second, or even third time we try
    them. As developers, we don’t always have the luxury of repeated attempts, but
    the more we practice improving our communication in code, the more often we’ll
    get there before we have to give up and move on.
  prefs: []
  type: TYPE_NORMAL
