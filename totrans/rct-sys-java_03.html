<html><head></head><body><section data-pdf-bookmark="Chapter 2. Introduction to Quarkus" data-type="chapter" epub:type="chapter"><div class="chapter" id="quarkus">&#13;
<h1><span class="label">Chapter 2. </span>Introduction to Quarkus</h1>&#13;
&#13;
&#13;
<p><a data-primary="Quarkus" data-secondary="basics" data-type="indexterm" id="ix_quarkus-adoc0"/>Before continuing with understanding Reactive,&#13;
let’s take a few moments to learn more about Quarkus.&#13;
So what is Quarkus?</p>&#13;
&#13;
<p><em>Quarkus</em> is a Kubernetes-native Java stack.&#13;
It has been tailored for Kubernetes, containers, and the cloud, but works perfectly well on bare metal and virtual machines.<sup><a data-type="noteref" href="ch02.html#idm45358839670352" id="idm45358839670352-marker">1</a></sup>&#13;
Quarkus applications require less memory and start faster than applications using traditional frameworks.&#13;
They also have the capability to be compiled into native executables, which make them consume even less memory and start instantly.</p>&#13;
&#13;
<p><a data-primary="reactive engine" data-type="indexterm" id="idm45358839668608"/>One exciting, and central, aspect of Quarkus is the reactive engine.&#13;
When running in containers or virtualized environments, a reactive engine is essential to reducing memory and CPU consumption.&#13;
The engine makes any Quarkus application efficient while also enabling the creation of reactive applications and systems.</p>&#13;
&#13;
<p>In this chapter, you will see the main characteristics of Quarkus and learn to create an application,&#13;
deploy it to Kubernetes, and create native builds.&#13;
In <a data-type="xref" href="ch06.html#quarkus-reactive">Chapter 6</a>, we cover the reactive engine in detail and show how to develop on Quarkus with a unified reactive and imperative programming model.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Java on the Cloud" data-type="sect1"><div class="sect1" id="quarkus::java-cloud">&#13;
<h1>Java on the Cloud</h1>&#13;
&#13;
<p><a data-primary="Quarkus" data-secondary="Java on the cloud and" data-type="indexterm" id="ix_quarkus-adoc1"/>Java is now 25 years old!&#13;
That’s hard to imagine sometimes.&#13;
From the era of three-tier and client/server architecture,&#13;
Java has evolved with many changes in architecture over the years.&#13;
However, when a language is 25 years old,&#13;
there will be pieces lingering that may not be suited to modern development.</p>&#13;
&#13;
<p>What do we mean by that? When the initial versions of Java came out,&#13;
<em>clouds</em>, <em>containers</em>, <em>microservices</em>, <em>serverless</em>,&#13;
and any other term associated with computing today had not been imagined yet.&#13;
There is no way we can expect the Java language created in the era of three-tier and client/server architecture to perform as we need in containers today.</p>&#13;
&#13;
<p>Yes, many advancements have occurred over the years in Java,&#13;
especially over the last couple of years with a new and faster release cadence.&#13;
At the same time,&#13;
Java prides itself on not breaking backward compatibility for developers and users.&#13;
A large cost of that approach is that Java still retains pieces that were conceived without the&#13;
benefits and knowledge of containers and what they provide.</p>&#13;
&#13;
<p>For many applications, Java will continue to work fine, and as is, for many more years to come. However, over the last few years, with the explosion of microservices, and most recently the evolution to serverless, Java does not fit these deployment models naturally.</p>&#13;
&#13;
<p><a data-primary="cgroups (control groups)" data-type="indexterm" id="idm45358839657760"/>Only a few years ago, Java’s lack of suitability in containers became apparent for all as we found out <a href="https://oreil.ly/Mbux3">Java ignored cgroups</a>.&#13;
For containers, this created a huge problem. Java, unable to see the amount of memory allocated to a container, could only see the memory of the entire physical machine.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45358839655760">&#13;
<h5>What Are cgroups?</h5>&#13;
<p>The term <em>cgroups</em> is shorthand for <em>control groups</em>, a kernel feature allowing the allocation of specific amounts of resources, such as CPU time, memory, and bandwidth, to processes. In our situation, cgroups are used to limit the amount of resources a container can use from the entire system.</p>&#13;
</div></aside>&#13;
&#13;
<p>In an environment where each container needs to work within a constrained amount of memory,&#13;
Java didn’t <em>play nice</em>.&#13;
Java was greedy.&#13;
In addition, Java would create application threads based on the number of CPU cores. This caused many more threads to be allocated in a memory- and CPU-constrained container.</p>&#13;
&#13;
<p>Is it a big deal? You might get lucky with your Java applications deployed in containers, if deploying to a Kubernetes node with other containers staying well within their memory limits. Then one day there’s a load spike, along with a spike in the memory consumed by the Java Virtual Machine (JVM), and then <em>boom</em>! Kubernetes kills the container for using too much memory.</p>&#13;
&#13;
<p>This specific problem with Java and cgroups has been fixed since Java 10,&#13;
and since Java Development Kit (JDK) 8u131 options are available for enabling the same behavior.&#13;
Check out the <a href="https://oreil.ly/L5Yh7">“Java Inside Docker” article</a> on the Red Hat Developer’s site&#13;
by Rafael Benevides with all the details.</p>&#13;
&#13;
<p>You might be thinking that Java should now be <em>good</em> in containers or in the cloud, right? Though this fix is available with an appropriate JDK version, many enterprises are using JDK 8 or older, and quite possibly not using a JDK 8 with the flags available. And Java’s issue in the cloud is more than cgroups alone.</p>&#13;
&#13;
<p>Containers not being killed for grabbing more memory than the container expected is great.&#13;
However, Java in containers raises concerns about the speed with which applications start receiving requests&#13;
and the amount of memory they consume while running.&#13;
Neither of these are great for Java applications, compared with other languages running in containers.&#13;
Maybe startup speed isn’t a concern for many applications running today,&#13;
but it can impact microservices needing to scale quickly for large traffic spikes,&#13;
or the cold start time for serverless applications.</p>&#13;
&#13;
<p>What do we mean by <em>start receiving requests</em>?&#13;
<a data-primary="frameworks" data-secondary="time to first request" data-type="indexterm" id="idm45358839646432"/>While it’s common for frameworks used in building applications to log their startup time,&#13;
it refers to the amount of time taken for a <em>framework</em> to start. The time does not represent the time taken by an <em>application</em> before being able to start receiving requests.&#13;
This time is a critical indicator with containers and the cloud!</p>&#13;
&#13;
<p><a data-primary="time to first request" data-type="indexterm" id="idm45358839643872"/>The time to start receiving requests can also be called <em>time to first request</em>. Whether a framework can start in half a second doesn’t mean much,&#13;
if another 2–3 seconds passes before any traffic can be received and processed by the application.&#13;
In such an example,&#13;
it could be anywhere from 2.5 to 3.5 seconds before a new application instance can begin receiving user requests.</p>&#13;
&#13;
<p>Granted, time to start receiving requests and memory consumption may not be a concern for a monolithic application&#13;
with a few hundred, or even thousand, internal users.&#13;
Monolithic applications can be developed with Quarkus,&#13;
though the benefits we talk of for Quarkus will not be as prominent when developing monoliths.&#13;
However, for microservices,&#13;
and especially serverless,&#13;
both these factors impact the costs of running a service&#13;
and the availability to users.</p>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>Frameworks can often have low startup times by delaying work until&#13;
receiving the first request.&#13;
The remainder of any startup tasks are performed before processing the first request.&#13;
<a data-primary="lazy initialization" data-type="indexterm" id="idm45358839640160"/><em>Lazy initialization</em> is another name for this behavior,&#13;
offering a false indication on when an application is really ready.&#13;
The time to <em>start receiving requests</em> is the best measure of application startup time.&#13;
Having a low <em>time to first request</em> is essential in serverless workloads, as well as any kind of mechanism using a <em>scale-to-zero</em> approach, where the services are started only when needed.&#13;
In more common architectures, such fast startup time reduces the recovery time after a crash.</p>&#13;
</div>&#13;
&#13;
<p>How can we measure startup time? Many approaches are possible,&#13;
including modification of endpoints to output a timestamp when they’re accessed.&#13;
To make our lives a bit simpler,&#13;
we’re going to use a Node.js script developed by John O’Hara from Red Hat.<sup><a data-type="noteref" href="ch02.html#idm45358839636416" id="idm45358839636416-marker">2</a></sup>&#13;
The script uses the application start command, and the URL to access it,&#13;
to start the application in another process.&#13;
The script waits for the URL to return <code>200</code>,&#13;
meaning success,&#13;
before computing the time to first request.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>For ease of use, we included <a href="https://github.com/cescoffier/reactive-systems-in-java">the contents of the GitHub repository</a> along with the code in the <em>chapter-2/startup-measurement</em> directory.&#13;
Ensure that you have Node.js installed,&#13;
and run <code>npm install request</code> to install the script dependencies.</p>&#13;
</div>&#13;
&#13;
<p>Right now you might be thinking that this discussion about startup speed and memory consumption&#13;
is a very <em>hand wavy</em> topic that’s too subjective.&#13;
We totally agree,&#13;
which is why we’re now going to use a traditional Java EE stack, in this case <a href="https://thorntail.io">Thorntail</a>,&#13;
to illustrate these concepts in practice.&#13;
We chose Thorntail for the comparison as the first microservice framework from Red Hat,&#13;
while Quarkus is the latest. Though the Thorntail project is no longer maintained, sadly, the good news is Quarkus incorporates lots of ideas from Thorntail.</p>&#13;
&#13;
<p>One last thing before we get coding and running applications. <em>Memory</em> can be a somewhat vague term, as there are many types of memory. <a data-primary="resident set size (RSS)" data-type="indexterm" id="idm45358839628256"/><a data-primary="RSS (resident set size)" data-type="indexterm" id="idm45358839627472"/>When we’re talking about memory, we’re referring to <a href="https://oreil.ly/o4TzC"><em>resident set size</em> (RSS)</a>,&#13;
and not the JVM heap size, as heap is only part of the total memory that a Java application consumes.&#13;
When running an application on the JVM,&#13;
the total allocated memory can include the following:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Heap space</p>&#13;
</li>&#13;
<li>&#13;
<p>Class metadata</p>&#13;
</li>&#13;
<li>&#13;
<p>Thread stacks</p>&#13;
</li>&#13;
<li>&#13;
<p>Compiled code</p>&#13;
</li>&#13;
<li>&#13;
<p>Garbage collection</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>RSS represents the amount of memory that a process is occupying from main memory (RAM).&#13;
RSS includes all the memory that the JVM requires to run an application,&#13;
providing a more accurate value for the amount of memory actually occupied.&#13;
As we’re running a single application in a single JVM process,&#13;
we can easily ensure that we’re not measuring memory consumption of nonapplication processes.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>All performance numbers are from our MacBook computer.&#13;
As such, the results you see in this chapter may differ slightly, depending on your particular hardware configuration.&#13;
If you happen to have an Apple M1, you could see even better results!</p>&#13;
</div>&#13;
&#13;
<p>Okay, time to run some code and see what we’re talking about with startup speed and memory consumption.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Thorntail Example" data-type="sect2"><div class="sect2" id="idm45358839617520">&#13;
<h2>Thorntail Example</h2>&#13;
&#13;
<p><a data-primary="Thorntail" data-type="indexterm" id="ix_quarkus-adoc2"/>We start by creating a <em>traditional</em> application with Thorntail to provide a comparison of the memory,&#13;
or RSS, and time-to-first-request metrics.&#13;
For anyone not familiar with Thorntail,&#13;
the project focused on the idea of a customizable <a href="https://wildfly.org">WildFly server</a>. Thorntail takes only the bits you need for a specific application, removing everything else.</p>&#13;
&#13;
<p>The Thorntail application requires a <a href="https://oreil.ly/eYjXF">Java API for RESTful Web Services</a> (JAX-RS) application,&#13;
and a simple resource endpoint for us to make requests against.&#13;
The Thorntail example needs a JAX-RS application,&#13;
and a JAX-RS resource with a single method returning a greeting for an HTTP GET request.&#13;
All the source code for the Thorntail example can be found in the &#13;
<span class="keep-together"><em>/chapter-2/thorntail-hello</em></span> directory.</p>&#13;
&#13;
<p>There’s nothing special about the classes. They’re the bare minimum required to provide an HTTP endpoint with JAX-RS to make requests against. Let’s build the Thorntail application and then start it, as shown in <a data-type="xref" href="#thorntail-2-1">Example 2-1</a>.</p>&#13;
<div data-type="example" id="thorntail-2-1">&#13;
<h5><span class="label">Example 2-1. </span>Build and run the Thorntail Hello World application</h5>&#13;
&#13;
<pre data-code-language="shell" data-type="programlisting">&gt; mvn verify&#13;
&gt; java -jar target/thorntail-hello-world-thorntail.jar</pre></div>&#13;
&#13;
<p>Once the application has started,&#13;
hit the <em><a href="http://localhost:8080/hello"><em class="hyperlink">http://localhost:8080/hello</em></a></em> endpoint with <code>curl</code> or a browser.&#13;
After you’ve made a few requests, or more if you prefer, it’s time to take a look at the RSS memory used by the process. Accessing the endpoint before measuring RSS is important because&#13;
an application may not have loaded all classes during startup,&#13;
meaning we could see a misleading figure.</p>&#13;
&#13;
<p>To be able to find out the memory used, we need the ID of the process the Thorntail application is running in.&#13;
On Linux-based systems, including Mac,&#13;
we can use <code>ps -e | grep thorntail</code>, which lists all the active processes and restricts the results&#13;
to those containing <code>thorntail</code> in the name.&#13;
With the process ID in hand,&#13;
we can now find out how much RSS the process is using (as seen in <a data-type="xref" href="#measure-2-2">Example 2-2</a>).</p>&#13;
<div data-type="example" id="measure-2-2">&#13;
<h5><span class="label">Example 2-2. </span>Measure the RSS usage of the Thorntail application</h5>&#13;
&#13;
<pre data-code-language="shell" data-type="programlisting"><code>&gt;</code><code> </code><code>ps</code><code> </code><code>-o</code><code> </code><code>pid,rss,command</code><code> </code><code>-p</code><code> </code><code class="m">4529</code><code> </code><code class="p">|</code><code> </code><code>awk</code><code> </code><code class="s1">'{$2=int($2/1024)"M";}{ print;}'</code><code>     </code><a class="co" href="#callout_introduction_to_quarkus_CO1-1" id="co_introduction_to_quarkus_CO1-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
&#13;
</code><code>PID</code><code>   </code><code>RSS</code><code> </code><code>COMMAND</code><code>&#13;
</code><code class="m">4529</code><code> </code><code>441M</code><code> </code><code>java</code><code> </code><code>-jar</code><code> </code><code>target/thorntail-hello-world-thorntail.jar</code></pre></div>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_introduction_to_quarkus_CO1-1" id="callout_introduction_to_quarkus_CO1-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p><code>ps</code> retrieves the RSS and command,&#13;
and <code>awk</code> converts the RSS value to megabytes.</p></dd>&#13;
</dl>&#13;
&#13;
<p>You will see something like the preceding terminal output,&#13;
showing the process ID, RSS converted to megabytes (<code>M</code>), and the command.&#13;
Full details on how to find RSS for a process can be found on&#13;
the Quarkus website.<sup><a data-type="noteref" href="ch02.html#idm45358841838240" id="idm45358841838240-marker">3</a></sup></p>&#13;
&#13;
<p>We can see that a “Hello World” style application with a single endpoint returning a string uses 441 megabytes (MB).&#13;
Whoa!&#13;
That’s a lot of memory for a single JAX-RS endpoint returning a fixed string!</p>&#13;
&#13;
<p>We should caution we’re running these tests on OpenJDK 11 without any customization&#13;
for limiting the amount of memory the JVM captures,&#13;
or any other tuning available to the JVM.&#13;
<a data-primary="heap size" data-secondary="Thorntail" data-type="indexterm" id="idm45358842298864"/>We can limit what the JVM is able to grab and see how that affects the overall RSS (<a data-type="xref" href="#start-thorntail-2-3">Example 2-3</a>).</p>&#13;
<div data-type="example" id="start-thorntail-2-3">&#13;
<h5><span class="label">Example 2-3. </span>Start the Thorntail application to configure the heap size</h5>&#13;
&#13;
<pre data-code-language="shell" data-type="programlisting">&gt; java -Xmx48m -XX:MinHeapFreeRatio<code class="o">=</code><code class="m">10</code> -XX:MaxHeapFreeRatio<code class="o">=</code><code class="m">20</code> <code class="se">\</code>&#13;
    -jar target/thorntail-hello-world-thorntail.jar</pre></div>&#13;
&#13;
<p>Now we get the output in <a data-type="xref" href="#measure-rss-2-4">Example 2-4</a>.</p>&#13;
<div data-type="example" id="measure-rss-2-4">&#13;
<h5><span class="label">Example 2-4. </span>Measure the RSS usage</h5>&#13;
&#13;
<pre data-code-language="shell" data-type="programlisting">&gt; ps -o pid,rss,command -p <code class="m">5433</code> <code class="p">|</code> awk <code class="s1">'{$2=int($2/1024)"M";}{ print;}'</code>&#13;
PID   RSS COMMAND&#13;
<code class="m">5433</code> 265M java -Xmx48m -XX:MinHeapFreeRatio<code class="o">=</code><code class="m">10</code> -XX:MaxHeapFreeRatio<code class="o">=</code><code class="m">20</code> <code class="se">\</code>&#13;
    -jar target/thorntail-hello-world-thorntail.jar</pre></div>&#13;
&#13;
<p>That dropped the memory usage down to 265 MB!&#13;
We saved nearly 200 MB of RSS by limiting the amount of heap the JVM grabbed to 48 MB.&#13;
Maybe 48 MB isn’t quite the sweet spot in terms of throughput,&#13;
but that’s something to verify with your own applications, to find the balance between reduced memory consumption and increased throughput.</p>&#13;
&#13;
<p>We’ve shown the RSS usage, and now we need to calculate the time to first request.&#13;
Ensure that all previous instances of the Thorntail application are stopped before continuing.&#13;
Let’s check out time to first request, as shown in <a data-type="xref" href="#measure-time-2-5">Example 2-5</a>.</p>&#13;
<div data-type="example" id="measure-time-2-5">&#13;
<h5><span class="label">Example 2-5. </span>Measure the time to first request of the Thorntail application</h5>&#13;
&#13;
<pre data-code-language="shell" data-type="programlisting">&gt; node time.js <code class="s2">"java \</code>&#13;
<code class="s2">    -jar [fullPathToDir]/thorntail-hello/target/</code>&#13;
<code class="s2">      thorntail-hello-world-thorntail.jar"</code> <code class="se">\</code>&#13;
    <code class="s2">"http://localhost:8080/hello"</code></pre></div>&#13;
&#13;
<p>We see a bunch of <code>404</code> messages fly past in the console until the application returns a <code>200</code> response,&#13;
and then we see the time taken.&#13;
In our case, it was 6,810 milliseconds (ms)!&#13;
That’s not exactly fast in the world of microservices and functions.&#13;
You can run it a few times to see whether the time varies much&#13;
or not really at all.&#13;
With a 7-second startup time,&#13;
scaling microservices can’t meet traffic spikes quick enough, causing user delays and possibly errors.&#13;
From a serverless perspective,&#13;
we’re even worse off as we’d expect a serverless function to be started, run, and stopped well before 7 seconds elapsed.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>The time to first request captured with <em>time.js</em> may be fractionally longer than it actually is,&#13;
as a very small amount of time will be included as the child process spawns but before the JVM starts.&#13;
We’re not too worried about such a small amount,&#13;
as the impact applies to each runtime we test in the same manner.</p>&#13;
</div>&#13;
&#13;
<p>So, we’ve seen what a traditional application consumes for RSS,&#13;
and how long it can take to reach time to first request.&#13;
Now it’s time to see how Quarkus compares.<a data-startref="ix_quarkus-adoc2" data-type="indexterm" id="idm45358833906176"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Quarkus Example" data-type="sect2"><div class="sect2" id="idm45358833958656">&#13;
<h2>Quarkus Example</h2>&#13;
&#13;
<p><a data-primary="Quarkus" data-secondary="sample application" data-type="indexterm" id="ix_quarkus-adoc3"/>We’re going to create an identical Hello World endpoint,&#13;
though it doesn’t say “Hello from Thorntail!”&#13;
With Quarkus, we don’t need the JAX-RS application class;&#13;
we need only the JAX-RS resource that has the same content as the Thorntail version,&#13;
except for the message.<sup><a data-type="noteref" href="ch02.html#idm45358833902576" id="idm45358833902576-marker">4</a></sup>&#13;
The source code for the Quarkus example can be found in the <em>/chapter-2/quarkus-hello</em> directory.</p>&#13;
&#13;
<p>In <a data-type="xref" href="#quarkus::create-first-application">“Create Your First Quarkus Application”</a>, we cover how to create a Quarkus application. Now build and run the Quarkus Hello World application, as shown in <a data-type="xref" href="#build-start-quarkus-2-6">Example 2-6</a>.</p>&#13;
<div data-type="example" id="build-start-quarkus-2-6">&#13;
<h5><span class="label">Example 2-6. </span>Build and start the Quarkus Hello World application</h5>&#13;
&#13;
<pre data-code-language="shell" data-type="programlisting">&gt; mvn verify&#13;
&gt; java -jar target/quarkus-hello-world-1.0-SNAPSHOT-runner.jar</pre></div>&#13;
&#13;
<p>As with Thorntail,&#13;
we’re not optimizing the JVM to see what raw RSS usage we see.&#13;
Hit <em><a href="http://localhost:8080/hello"><em class="hyperlink">http://localhost:8080/hello</em></a></em> a few times as we did with Thorntail.&#13;
Hopefully, you’re seeing the message “Hello from Quarkus!”&#13;
Otherwise, you’re still running the Thorntail application.</p>&#13;
&#13;
<p>Go find the process ID for the Quarkus application and check out the RSS (<a data-type="xref" href="#measure-rss-2-7">Example 2-7</a>).</p>&#13;
<div data-type="example" id="measure-rss-2-7">&#13;
<h5><span class="label">Example 2-7. </span>Measure the RSS usage of the Quarkus Hello World application</h5>&#13;
&#13;
<pre data-code-language="shell" data-type="programlisting">&gt; ps -o pid,rss,command -p <code class="m">6439</code> <code class="p">|</code> awk <code class="s1">'{$2=int($2/1024)"M";}{ print;}'</code>&#13;
PID    0M COMMAND&#13;
<code class="m">6439</code> 133M java -jar target/quarkus-hello-world-1.0-SNAPSHOT-runner.jar</pre></div>&#13;
&#13;
<p>Here we see Quarkus using 133 MB of RSS,&#13;
over 300 MB less than the 441 MB with Thorntail!&#13;
That’s an astonishing improvement for what is essentially the same &#13;
<span class="keep-together">application</span>.</p>&#13;
&#13;
<p><a data-primary="heap size" data-secondary="Quarkus" data-type="indexterm" id="idm45358833822656"/>If we limit the maximum heap size to 48 MB,&#13;
as we did for Thorntail,&#13;
how much of an improvement do we get? Review <a data-type="xref" href="#constrain-2-8">Example 2-8</a>.&#13;
Don’t forget to use the endpoint once the application is started.</p>&#13;
<div data-type="example" id="constrain-2-8">&#13;
<h5><span class="label">Example 2-8. </span>Constrain the heap usage and measure the RSS usage</h5>&#13;
&#13;
<pre data-code-language="shell" data-type="programlisting">&gt; java -Xmx48m -XX:MinHeapFreeRatio<code class="o">=</code><code class="m">10</code> -XX:MaxHeapFreeRatio<code class="o">=</code><code class="m">20</code> <code class="se">\</code>&#13;
    -jar target/quarkus-hello-world-1.0-SNAPSHOT-runner.jar&#13;
&gt; ps -o pid,rss,command -p <code class="m">7194</code> <code class="p">|</code> awk <code class="s1">'{$2=int($2/1024)"M";}{ print;}'</code>&#13;
PID    0M COMMAND&#13;
<code class="m">7194</code> 114M java -Xmx48m -XX:MinHeapFreeRatio<code class="o">=</code><code class="m">10</code> -XX:MaxHeapFreeRatio<code class="o">=</code><code class="m">20</code> <code class="se">\</code>&#13;
    -jar target/quarkus-hello-world-1.0-SNAPSHOT-runner.jar</pre></div>&#13;
&#13;
<p>That got it down to 114 MB, but let’s see how far we can push Quarkus into smaller heap sizes! Refer to <a data-type="xref" href="#constrain-2-9">Example 2-9</a>.&#13;
Once again, don’t forget to use the endpoint once started.</p>&#13;
<div data-type="example" id="constrain-2-9">&#13;
<h5><span class="label">Example 2-9. </span>Constrain the heap usage of the Quarkus application even more and measure the RSS usage</h5>&#13;
&#13;
<pre data-code-language="shell" data-type="programlisting">&gt; java -Xmx24m -XX:MinHeapFreeRatio<code class="o">=</code><code class="m">10</code> -XX:MaxHeapFreeRatio<code class="o">=</code><code class="m">20</code> <code class="se">\</code>&#13;
    -jar target/quarkus-hello-world-1.0-SNAPSHOT-runner.jar&#13;
&gt; ps -o pid,rss,command -p <code class="m">19981</code> <code class="p">|</code> awk <code class="s1">'{$2=int($2/1024)"M";}{ print;}'</code>&#13;
PID    0M COMMAND&#13;
<code class="m">19981</code> 98M java -Xmx24m -XX:MinHeapFreeRatio<code class="o">=</code><code class="m">10</code> -XX:MaxHeapFreeRatio<code class="o">=</code><code class="m">20</code> <code class="se">\</code>&#13;
    -jar target/quarkus-hello-world-1.0-SNAPSHOT-runner.jar</pre></div>&#13;
&#13;
<p>With a max heap of 24 MB,&#13;
we’re down to 98 MB of RSS!&#13;
More importantly, the application still works!&#13;
See how low you can reduce the maximum heap before Quarkus is unable to start.&#13;
Although for regular applications, and even microservices,&#13;
you wouldn’t be setting the maximum heap so low,&#13;
being able to set it this low is critical for serverless environments.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>Setting the heap size to a very low value may penalize the performance of the application, especially if the application does a lot of allocations.&#13;
Don’t aim for the smallest value as possible, but verify the value according to your expected performance and deployment density gain.&#13;
Note that the Quarkus architecture tries to avoid having such a penalty. However, we highly recommend you check with your application.</p>&#13;
</div>&#13;
&#13;
<p>Time for startup speed (see <a data-type="xref" href="#measure-time-2-10">Example 2-10</a>).</p>&#13;
<div data-type="example" id="measure-time-2-10">&#13;
<h5><span class="label">Example 2-10. </span>Measure the time to first request for the Quarkus application</h5>&#13;
&#13;
<pre data-code-language="shell" data-type="programlisting">&gt; node time.js <code class="s2">"java \</code>&#13;
<code class="s2">    -jar [fullPathToDir]/quarkus-hello/target/</code>&#13;
<code class="s2">      quarkus-hello-world-1.0-SNAPSHOT-runner.jar"</code> <code class="se">\</code>&#13;
    <code class="s2">"http://localhost:8080/hello"</code></pre></div>&#13;
&#13;
<p>If your hardware is similar to ours,&#13;
you should see a time to first request of around 1,001 ms!&#13;
That’s nearly seven times faster than the traditional application!</p>&#13;
&#13;
<p>All this is really great, but what’s the point?&#13;
Recalling our earlier discussion about Java in containers,&#13;
let’s see the impact when running in containers.&#13;
Assuming we have a node with 2 GB of RAM available,&#13;
how many containers of each application can fit? Take a look at <a data-type="xref" href="#image:java-memory-containers">Figure 2-1</a>.</p>&#13;
&#13;
<figure><div class="figure" id="image:java-memory-containers">&#13;
<img alt="Java memory in containers" src="assets/rsij_0201.png"/>&#13;
<h6><span class="label">Figure 2-1. </span>Java memory in containers: Quarkus allows increasing the deployment &#13;
<span class="keep-together">density</span></h6>&#13;
</div></figure>&#13;
&#13;
<p><a data-primary="container density" data-type="indexterm" id="idm45358833721312"/><em>Container density</em> is a key characteristic of cloud deployments with Kubernetes.&#13;
Given a specific node size,&#13;
such as 2 GB of RAM,&#13;
the more containers that can run in that single node,&#13;
the greater container density we can provide.&#13;
Improving container density enables better utilization of the resources available.&#13;
From the example in <a data-type="xref" href="#image:java-memory-containers">Figure 2-1</a>,&#13;
will more throughput be achieved with 4 instances or 14?&#13;
If each of the 14 containers supports less throughput,&#13;
or requests per second,&#13;
compared with one of the traditional containers,&#13;
it doesn’t matter.&#13;
A minor reduction in throughput in a container is more than offset by supporting 14 containers instead of 4.</p>&#13;
&#13;
<p>Container density is an important metric in determining the number of instances that are required.&#13;
What a developer needs to determine is their expected, or desired, throughput to be supported. Maybe fewer containers with larger memory requirements are fine for today’s needs, but keep in mind that things change, and you could easily need more than four to support your users!</p>&#13;
&#13;
<p>You’ve now seen the amount of RSS memory and time to first request with traditional applications on the JVM,&#13;
and how Quarkus can significantly reduce these aspects for an application. Quarkus wants to tackle the challenge of improving Java in containers with a new approach.&#13;
This approach improves the startup speed and the memory consumption of Java in a container.</p>&#13;
&#13;
<p>The next section explains the details of how Quarkus makes this possible,&#13;
and more importantly,&#13;
how it differs from a traditional framework approach<a data-startref="ix_quarkus-adoc3" data-type="indexterm" id="idm45358833716544"/>.<a data-startref="ix_quarkus-adoc1" data-type="indexterm" id="idm45358833715712"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The Quarkus Way" data-type="sect1"><div class="sect1" id="quarkus::quarkus-way">&#13;
<h1>The Quarkus Way</h1>&#13;
&#13;
<p><a data-primary="frameworks" data-secondary="Quarkus versus traditional" data-type="indexterm" id="ix_quarkus-adoc4"/><a data-primary="Quarkus" data-secondary="traditional frameworks versus" data-type="indexterm" id="ix_quarkus-adoc5"/>We’re sure you want to know all the intricate details of how Quarkus starts faster and consumes less memory than a traditional framework, right? We need to slow down a bit first,&#13;
by explaining how traditional frameworks work, so you can understand what changes with Quarkus.</p>&#13;
&#13;
<p>Some well-known features of traditional frameworks are depicted in <a data-type="xref" href="#image:quarkus-build">Figure 2-2</a>:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Annotations within code defining expected behavior,&#13;
with many examples of this we’ve all used over the years.&#13;
Typical ones include <code>@Entity</code>, <code>@Autowired</code>, <code>@Inject</code>, and many, many more.</p>&#13;
</li>&#13;
<li>&#13;
<p>Configuration files of various kinds.&#13;
These files do everything from defining how classes should be wired together to configuring persistent data sources,&#13;
and everything in between.</p>&#13;
</li>&#13;
<li>&#13;
<p>Classes used only during startup for creating runtime metadata and classes for the application to function.</p>&#13;
</li>&#13;
<li>&#13;
<p>Utilizing reflection in determining methods to invoke,&#13;
setting values into objects, and dynamically loading classes by name only.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<figure><div class="figure" id="image:quarkus-build">&#13;
<img alt="Quarkus build time approach" src="assets/rsij_0202.png"/>&#13;
<h6><span class="label">Figure 2-2. </span>The Quarkus way</h6>&#13;
</div></figure>&#13;
&#13;
<p>We’re certainly not saying that Quarkus doesn’t have annotations, configuration files,&#13;
or any other features of traditional frameworks.&#13;
We <em>are</em> saying Quarkus handles them in a very different manner.</p>&#13;
&#13;
<p>Why would these features of traditional frameworks be considered “bad”?&#13;
That’s a good question,&#13;
and the answer requires some understanding of how these frameworks handle the preceding features. When there’s any type of configuration to be parsed or annotations to be discovered,&#13;
framework classes are required to perform this work.&#13;
Depending on how complex the process might be,&#13;
anywhere from dozens to hundreds of classes could be needed to perform the task.&#13;
In addition, each class would typically be holding state within itself&#13;
representing intermediate states as startup occurs,&#13;
or a final desired state after everything is processed.</p>&#13;
&#13;
<p>There’s nothing particularly special about this;&#13;
frameworks have worked this way for years, decades even.&#13;
What you may not realize, though, is that any classes used to perform these startup tasks are still present,&#13;
even if the JVM process has been running for six months without a restart!&#13;
While any memory those classes grabbed should be eventually garbage collected,&#13;
provided the classes properly released their hold on the memory when work was complete,&#13;
the class metadata for them is still present in the JVM, even on the latest Java versions.&#13;
It may not seem like much,&#13;
but a couple of hundred classes that are no longer needed can impact the amount of memory required by the JVM.</p>&#13;
&#13;
<p>This problem impacts all JVMs today, without special handling by a framework.&#13;
All the classes used during startup, and never again,&#13;
can be garbage collected by the JVM only if all objects of the class can be garbage collected,&#13;
all references to the class are removed, and most importantly,&#13;
all other classes in the same classloader are also no longer referenced.&#13;
To facilitate the garbage collection of startup classes,&#13;
a framework would need to utilize a classloader for startup classes and another classloader for runtime classes.&#13;
It can be difficult to enable garbage collection for startup classes when thread pools are used,&#13;
especially <code>ForkJoinPool</code>, and when thread-local variables are set during startup.</p>&#13;
&#13;
<p>Why should we retain classes in JVM memory if they will never be used again? Ideally, we shouldn’t, as it’s wasteful. This is where Quarkus shines. Quarkus extensions are designed and built to separate&#13;
the various pieces of the traditional framework startup processing into smaller chunks of work.&#13;
Doing this enables the build process, with Maven or Gradle,&#13;
to take advantage of those smaller chunks and execute them during the build, instead of waiting until the runtime start.&#13;
Utilizing startup classes <em>during build time</em> means those classes don’t need to be included in the JVM at runtime! This saves us memory and startup time.</p>&#13;
&#13;
<p>How does it help to do this at build time, and where does the output go that’s needed during runtime? Extensions use bytecode recorders to do everything from setting static values on classes for runtime,&#13;
to creating new classes to hold metadata that’s needed for runtime.&#13;
What do we mean by that?&#13;
Earlier we talked about frameworks doing a lot of work during startup, and&#13;
Quarkus is able to create the output of that work during build time and write bytecode equating to the same&#13;
result as with traditional frameworks at startup.&#13;
At runtime, instead of performing the startup work,&#13;
the JVM loads the class written by a Quarkus extension into memory as if all that startup work just happened without the cost of the memory and classes to do the work.</p>&#13;
&#13;
<p>Looking at some steps a traditional framework performs at startup,&#13;
we can see in <a data-type="xref" href="#image:quarkus-framework-phases">Figure 2-3</a> how Quarkus handles them differently.</p>&#13;
&#13;
<figure><div class="figure" id="image:quarkus-framework-phases">&#13;
<img alt="Framework startup phases in Traditional Frameworks vs Quarkus" src="assets/rsij_0203.png"/>&#13;
<h6><span class="label">Figure 2-3. </span>Framework startup phases in traditional frameworks versus Quarkus</h6>&#13;
</div></figure>&#13;
&#13;
<p class="pagebreak-before less_space">While Quarkus reads the configuration at build time, some properties, such as locations and credentials, are still configured and read at runtime.&#13;
However, everything application-centric that can be decided at build time is handled during the build process. So far, we’ve been using build time to describe when Quarkus completes these typically startup-related tasks,&#13;
<a data-primary="ahead of time (AOT) compilation" data-type="indexterm" id="idm45358833673424"/><a data-primary="AOT (ahead of time) compilation" data-type="indexterm" id="idm45358833672816"/>but there is another term: <em>ahead-of-time</em> (AOT) compilation. You’ve seen that Quarkus differs from traditional frameworks in the way&#13;
it approaches optimizing your application code and dependencies.&#13;
Yes, this approach reduces the variability that is generally handled at runtime.</p>&#13;
&#13;
<p>However, modern workloads deployed in the cloud or in containers do not need such variability, as almost everything is known at build time. We hope you now have a clearer understanding of what Quarkus offers with this innovative approach,&#13;
and why it is bringing excitement to Java development in the cloud again.<a data-startref="ix_quarkus-adoc5" data-type="indexterm" id="idm45358833670720"/><a data-startref="ix_quarkus-adoc4" data-type="indexterm" id="idm45358833670112"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Create Your First Quarkus Application" data-type="sect1"><div class="sect1" id="quarkus::create-first-application">&#13;
<h1>Create Your First Quarkus Application</h1>&#13;
&#13;
<p><a data-primary="Quarkus" data-secondary="creating your first application in" data-type="indexterm" id="ix_quarkus-adoc6"/>There are quite a few ways to create a Quarkus application for the first time:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Manually creating the project <em>pom.xml</em> or <em>build.gradle</em> file, adding Quarkus&#13;
dependencies, setting up and configuring the plug-ins, and defining the source folders.&#13;
Pretty messy and tedious, in our view!</p>&#13;
</li>&#13;
<li>&#13;
<p>Using Maven and the Quarkus plug-in to construct the project &#13;
<span class="keep-together">skeleton</span>.</p>&#13;
</li>&#13;
<li>&#13;
<p>Browsing to <a href="https://code.quarkus.io"><em class="hyperlink">https://code.quarkus.io</em></a> and selecting the dependencies that are needed. This is the simplest, quickest way to get started, and the method we’ll use.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>It’s time to dive into creating a project!&#13;
Head over to <a href="https://code.quarkus.io"><em class="hyperlink">https://code.quarkus.io</em></a>, and you will be presented with the page in <a data-type="xref" href="#image:quarkus-code-start">Figure 2-4</a>. We’ve circled some key parts to explain them in detail.</p>&#13;
&#13;
<p>At the very top of the page is the Quarkus version of the generated project.&#13;
Just below it to the left, you can customize the group and artifact names that will be set for the project.&#13;
These can be changed later if desired as well;&#13;
you’re not stuck with <em>org.acme</em> if you forget to customize it.</p>&#13;
&#13;
<p>To the right, users can decide whether they want starter code added to the project.&#13;
The default is yes, so if you select any extensions with the <em>CODE</em> marker,&#13;
such as <em>RESTEasy JAX-RS</em>,&#13;
starter code for that extension will be generated for the project.&#13;
Below the top part of the page is the list of all available Quarkus extensions.&#13;
A lot of extensions are available;&#13;
the screenshot shows only the ones that would fit on a single page.&#13;
Use each checkbox to select specific extensions to include in your project.</p>&#13;
&#13;
<figure><div class="figure" id="image:quarkus-code-start">&#13;
<img alt="Quarkus project selection" src="assets/rsij_0204.png"/>&#13;
<h6><span class="label">Figure 2-4. </span>Quarkus project selection</h6>&#13;
</div></figure>&#13;
&#13;
<p>Lastly, if you don’t want to scroll through all the extensions,&#13;
start typing terms into the search box above all the extensions.&#13;
As you type, the list of extensions below it will filter, showing only the extensions matching your search criteria.&#13;
As extensions are selected,&#13;
they appear under the Selected Extensions area next to “Generate your application.”</p>&#13;
&#13;
<p><a data-type="xref" href="#image:quarkus-code-start-generate">Figure 2-5</a> shows how the screen looks when we’re about to generate the application.</p>&#13;
&#13;
<figure><div class="figure" id="image:quarkus-code-start-generate">&#13;
<img alt="Quarkus project generation" src="assets/rsij_0205.png"/>&#13;
<h6><span class="label">Figure 2-5. </span>Quarkus project generation</h6>&#13;
</div></figure>&#13;
&#13;
<p>You can see we’ve chosen not to generate any starter code,&#13;
and the RESTEasy JAX-RS extension is selected.&#13;
We’re sticking with plain JAX-RS for now.&#13;
We will explore a more reactive JAX-RS in <a data-type="xref" href="ch08.html#http">Chapter 8</a>.</p>&#13;
&#13;
<p>As we hover over “Generate your application,”&#13;
we can decide to download the project as a ZIP file or publish it to a GitHub repository.&#13;
Right now, we will download as a ZIP file.&#13;
The file will be automatically downloaded,&#13;
with a name matching the artifact name.&#13;
Once the download is finished,&#13;
extract the ZIP file to a directory.</p>&#13;
&#13;
<p>With that done,&#13;
we open a terminal window and change to the directory where the generated project was extracted.&#13;
Let’s dive into using live reload (<a data-type="xref" href="#run-app-dev-mode">Example 2-11</a>) and experience real Developer Joy!</p>&#13;
<div data-type="example" id="run-app-dev-mode">&#13;
<h5><span class="label">Example 2-11. </span>Run the application in dev mode</h5>&#13;
&#13;
<pre data-code-language="shell" data-type="programlisting">&gt; mvn quarkus:dev</pre></div>&#13;
&#13;
<p>The preceding command starts Quarkus in live reload,&#13;
enabling us to quickly iterate with code and instantly see the impact.&#13;
A successful start will have the terminal output, shown in <a data-type="xref" href="#output-quarkus-app">Example 2-12</a>.</p>&#13;
<div data-type="example" id="output-quarkus-app">&#13;
<h5><span class="label">Example 2-12. </span>Output the Quarkus application</h5>&#13;
&#13;
<pre data-code-language="text" data-type="programlisting">__  ____  __  _____   ___  __ ____  ______&#13;
 --/ __ \/ / / / _ | / _ \/ //_/ / / / __/&#13;
 -/ /_/ / /_/ / __ |/ , _/ ,&lt; / /_/ /\ \&#13;
--\___\_\____/_/ |_/_/|_/_/|_|\____/___/&#13;
INFO  [io.quarkus] (Quarkus Main Thread) code-with-quarkus 1.0.0-SNAPSHOT on JVM \&#13;
    (powered by Quarkus 2.2.0.Final) started in 0.937s. \&#13;
    Listening on: http://localhost:8080&#13;
INFO  [io.quarkus] (Quarkus Main Thread) Profile dev activated.&#13;
  Live Coding activated.&#13;
INFO  [io.quarkus] (Quarkus Main Thread) Installed features: [cdi]</pre></div>&#13;
&#13;
<p>We’re off and running.&#13;
Open <em><a href="http://localhost:8080"><em class="hyperlink">http://localhost:8080</em></a></em> in a browser, and you will see <code>Resource not found</code>.&#13;
Oh, no!&#13;
What went wrong?</p>&#13;
&#13;
<p>Actually, nothing went wrong.&#13;
Eagle-eyed readers might have noticed the startup log listed only <code>cdi</code> as an installed feature.&#13;
What about RESTEasy? We selected the extension for it when creating the project.&#13;
Have a look inside <em>pom.xml</em>, and you will see the dependencies (<a data-type="xref" href="#quarkus-ext-dep-gen-proj">Example 2-13</a>).</p>&#13;
<div data-type="example" id="quarkus-ext-dep-gen-proj">&#13;
<h5><span class="label">Example 2-13. </span>Quarkus extension dependencies of generated project (<em>chapter-2/code-with-quarkus/pom.xml</em>)</h5>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;dependency&gt;</code>&#13;
  <code class="nt">&lt;groupId&gt;</code>io.quarkus<code class="nt">&lt;/groupId&gt;</code>&#13;
  <code class="nt">&lt;artifactId&gt;</code>quarkus-resteasy<code class="nt">&lt;/artifactId&gt;</code>&#13;
<code class="nt">&lt;/dependency&gt;</code>&#13;
<code class="nt">&lt;dependency&gt;</code>&#13;
  <code class="nt">&lt;groupId&gt;</code>io.quarkus<code class="nt">&lt;/groupId&gt;</code>&#13;
  <code class="nt">&lt;artifactId&gt;</code>quarkus-arc<code class="nt">&lt;/artifactId&gt;</code>&#13;
<code class="nt">&lt;/dependency&gt;</code>&#13;
<code class="nt">&lt;dependency&gt;</code>&#13;
  <code class="nt">&lt;groupId&gt;</code>io.quarkus<code class="nt">&lt;/groupId&gt;</code>&#13;
  <code class="nt">&lt;artifactId&gt;</code>quarkus-junit5<code class="nt">&lt;/artifactId&gt;</code>&#13;
  <code class="nt">&lt;scope&gt;</code>test<code class="nt">&lt;/scope&gt;</code>&#13;
<code class="nt">&lt;/dependency&gt;</code></pre></div>&#13;
&#13;
<p>RESTEasy is definitely there as a dependency,&#13;
so what’s going on?&#13;
During the build process, Quarkus recognized there wasn’t actually any code present utilizing RESTEasy,&#13;
making the feature uninstalled and available for removal to save memory.&#13;
Let’s fix that now.</p>&#13;
&#13;
<p>With Quarkus still running,&#13;
create the <em>org.acme</em> package within <em>/src/main/java</em>.&#13;
Now create a class named <code>MyResource</code> within the package and the content in <a data-type="xref" href="#jaxrs-myresource">Example 2-14</a>.</p>&#13;
<div data-type="example" id="jaxrs-myresource">&#13;
<h5><span class="label">Example 2-14. </span>JAX-RS <code>MyResource</code> (<em>chapter-2/code-with-quarkus/src/main/java/org/acme/MyResource.java</em>)</h5>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kn">import</code> <code class="nn">javax.ws.rs.GET</code><code class="o">;</code>&#13;
<code class="kn">import</code> <code class="nn">javax.ws.rs.Path</code><code class="o">;</code>&#13;
<code class="kn">import</code> <code class="nn">javax.ws.rs.Produces</code><code class="o">;</code>&#13;
<code class="kn">import</code> <code class="nn">javax.ws.rs.core.MediaType</code><code class="o">;</code>&#13;
&#13;
<code class="nd">@Path</code><code class="o">(</code><code class="s">"/"</code><code class="o">)</code>&#13;
<code class="nd">@Produces</code><code class="o">({</code><code class="n">MediaType</code><code class="o">.</code><code class="na">TEXT_PLAIN</code><code class="o">})</code>&#13;
<code class="kd">public</code> <code class="kd">class</code> <code class="nc">MyResource</code> <code class="o">{</code>&#13;
  <code class="nd">@GET</code>&#13;
  <code class="kd">public</code> <code class="n">String</code> <code class="nf">message</code><code class="o">()</code> <code class="o">{</code>&#13;
    <code class="k">return</code> <code class="s">"Hi"</code><code class="o">;</code>&#13;
  <code class="o">}</code>&#13;
<code class="o">}</code></pre></div>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>You may wonder why in the preceding snippet none of the <code>import</code> lines are Quarkus specific. Quarkus provides a cohesive full-stack framework by leveraging a growing list of over 50 best-of-breed libraries. In the preceding example, we use JAX-RS, a simple but efficient and flexible approach to building HTTP and REST APIs.</p>&#13;
</div>&#13;
&#13;
<p>Refresh <em><a href="http://localhost:8080"><em class="hyperlink">http://localhost:8080</em></a></em>.&#13;
Wow, we now see <code>Hi</code> in the browser; what happened?&#13;
Take a look in the terminal window (<a data-type="xref" href="#automatic-restart-of-app">Example 2-15</a>).</p>&#13;
<div data-type="example" id="automatic-restart-of-app">&#13;
<h5><span class="label">Example 2-15. </span>Automatic restart of the application after a code change</h5>&#13;
&#13;
<pre data-code-language="text" data-type="programlisting">INFO  [io.qua.dep.dev.RuntimeUpdatesProcessor] (vert.x-worker-thread-7) \&#13;
    Changed source files detected, recompiling \&#13;
    [{pathToProject}/code-with-quarkus/src/main/java/org/acme/MyResource.java]&#13;
INFO  [io.quarkus] (Quarkus Main Thread) code-with-quarkus stopped in 0.037s&#13;
__  ____  __  _____   ___  __ ____  ______&#13;
 --/ __ \/ / / / _ | / _ \/ //_/ / / / __/&#13;
 -/ /_/ / /_/ / __ |/ , _/ ,&lt; / /_/ /\ \&#13;
--\___\_\____/_/ |_/_/|_/_/|_|\____/___/&#13;
INFO  [io.quarkus] (Quarkus Main Thread) code-with-quarkus 1.0.0-SNAPSHOT on JVM \&#13;
    (powered by Quarkus 1.11.1.Final) started in 0.195s. \&#13;
    Listening on: http://localhost:8080&#13;
INFO  [io.quarkus] (Quarkus Main Thread) Profile dev activated. Live Coding activated&#13;
INFO  [io.quarkus] (Quarkus Main Thread) Installed features: [cdi, resteasy]&#13;
INFO  [io.qua.dep.dev.RuntimeUpdatesProcessor] (vert.x-worker-thread-7) \&#13;
    Hot replace total time: 0.291s</pre></div>&#13;
&#13;
<p>We can see Quarkus noticed modifications to <em>MyResource.java</em>, stopped, and then restarted itself.&#13;
Looking at the installed features,&#13;
we see it now includes <code>resteasy</code>.&#13;
How cool is that?&#13;
Even better, the server stopped and restarted in just over 300 ms.</p>&#13;
&#13;
<p>Why don’t we explore live reload some more to have a better feel of the real Developer Joy!&#13;
With <code>mvn quarkus:dev</code> still running,&#13;
open <em><a href="http://localhost:8080/welcome"><em class="hyperlink">http://localhost:8080/welcome</em></a></em> in a browser (<a data-type="xref" href="#image:quarkus-resource-not-found">Figure 2-6</a>).</p>&#13;
&#13;
<figure><div class="figure" id="image:quarkus-resource-not-found">&#13;
<img alt="Resource not found" src="assets/rsij_0206.png"/>&#13;
<h6><span class="label">Figure 2-6. </span>Resource not found</h6>&#13;
</div></figure>&#13;
&#13;
<p>We got an error. Oh no!</p>&#13;
&#13;
<p>Don’t fear too much;&#13;
we did expect it because we don’t have anything to respond to the <em>/welcome</em> endpoint yet.&#13;
However,&#13;
Quarkus offers us some links to help diagnose the problem based on what it knows about the application.&#13;
We are shown the list of valid endpoints—in this case, there is only an HTTP GET on <em>/</em>.</p>&#13;
&#13;
<p>Under “Additional endpoints,”&#13;
there are endpoints to assist while developing applications.&#13;
In this example, we have endpoints related to <em>ArC</em>,&#13;
which is the bean container based on Contexts and Dependency Injection (CDI) for Quarkus,&#13;
as well as a link to the developer console.&#13;
Clicking the developer console link will bring you to its main page (<a data-type="xref" href="#image:quarkus-dev-console">Figure 2-7</a>).</p>&#13;
&#13;
<figure><div class="figure" id="image:quarkus-dev-console">&#13;
<img alt="Quarkus Dev console" src="assets/rsij_0207.png"/>&#13;
<h6><span class="label">Figure 2-7. </span>Quarkus Dev console</h6>&#13;
</div></figure>&#13;
&#13;
<p>There isn’t a lot there now,&#13;
but we need to remember that the only extension we’ve added is RESTEasy.&#13;
As we enhance an application with more extensions,&#13;
more options and abilities will be available from the developer console. We went down a side track there, so&#13;
let’s get back to resolving our failed page load!&#13;
With the <em>/welcome</em> page open to the failure in the browser,&#13;
go back to the source and create a new class called <code>WelcomeResource</code> (<a data-type="xref" href="#jaxrs-welcome-resource">Example 2-16</a>).</p>&#13;
<div data-type="example" id="jaxrs-welcome-resource">&#13;
<h5><span class="label">Example 2-16. </span>JAX-RS <code>WelcomeResource</code> (<em>chapter-2/code-with-quarkus/src/main/java/org/acme/WelcomeResource.java</em>)</h5>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="nd">@Path</code><code class="o">(</code><code class="s">"/welcome"</code><code class="o">)</code>&#13;
<code class="kd">public</code> <code class="kd">class</code> <code class="nc">WelcomeResource</code> <code class="o">{</code>&#13;
  <code class="nd">@GET</code>&#13;
  <code class="kd">public</code> <code class="n">String</code> <code class="nf">welcomeMessage</code><code class="o">()</code> <code class="o">{</code>&#13;
    <code class="k">return</code> <code class="s">"Welcome to Quarkus!"</code><code class="o">;</code>&#13;
  <code class="o">}</code>&#13;
<code class="o">}</code></pre></div>&#13;
&#13;
<p>With the class written, head back to the browser and click Refresh.</p>&#13;
&#13;
<p>Triggering an HTTP request causes Quarkus to check whether any files were modified since the last request,&#13;
as we’re running with live reload.&#13;
Quarkus notices the presence of <code>WelcomeResource</code>,&#13;
compiles it, and then restarts the server.&#13;
If you’re like us, you may not have realized everything happening behind the scenes because the browser&#13;
gave the expected response without much delay.</p>&#13;
&#13;
<p>Are you exhausted yet? We are.</p>&#13;
&#13;
<p>That was a lot of information on creating a Quarkus project for the first time with <a href="https://code.quarkus.io"><em class="hyperlink">https://code.quarkus.io</em></a>,&#13;
and experiencing the ease of development that live reload with Quarkus brings.&#13;
It does have drawbacks, including less chance to get a coffee during a compile and restart. We will continue to explore everything that live reload can do as we work through the chapters, but take it for a spin yourself, adding new extensions and seeing what can be done without stopping it!<a data-startref="ix_quarkus-adoc6" data-type="indexterm" id="idm45358833395952"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Kubernetes with Quarkus in 10 Minutes" data-type="sect1"><div class="sect1" id="quarkus::kube-ten">&#13;
<h1>Kubernetes with Quarkus in 10 Minutes</h1>&#13;
&#13;
<p><a data-primary="Kubernetes" data-secondary="deploying a Quarkus application in" data-type="indexterm" id="ix_quarkus-adoc7"/><a data-primary="Quarkus" data-secondary="deploying an application in Kubernetes" data-type="indexterm" id="ix_quarkus-adoc8"/>In the previous section, we had lots of fun changing code and seeing the application&#13;
update on the fly.&#13;
We hope you had fun; we know we did!</p>&#13;
&#13;
<p>While that’s great for developing the code,&#13;
can we use live coding in production?&#13;
Well, maybe you could, but we really don’t think you want to do that!</p>&#13;
&#13;
<p>For deploying to production, we want to use immutable containers,&#13;
which requires container orchestration, which for most means Kubernetes.&#13;
<a data-type="xref" href="ch03.html#distributed-system::cloud-native-kube">“The New Kids on the Block: Cloud Native and Kubernetes Native Applications”</a> covers cloud native and Kubernetes applications in further detail.</p>&#13;
&#13;
<p>Why is Quarkus great for the cloud and, in particular, Kubernetes? Quarkus applications are designed to run efficiently in containers and have built-in health checks and monitoring capabilities.&#13;
Quarkus also provides a great user experience, including the ability to deploy in a Kubernetes cluster in a single command, without having to write Kubernetes resource descriptors.</p>&#13;
&#13;
<p>Kubernetes introduces its own specific jargon, which may be confusing.&#13;
This section introduces its main concepts.</p>&#13;
&#13;
<p>What are the steps to take our Quarkus application from the previous&#13;
section and deploy it to Kubernetes?&#13;
Let’s extend the application we generated in the previous section. The first thing we do is add the extension for Kubernetes to our application, as shown in <a data-type="xref" href="#kubernetes-ext-dep">Example 2-17</a>.</p>&#13;
<div data-type="example" id="kubernetes-ext-dep">&#13;
<h5><span class="label">Example 2-17. </span>Kubernetes extension dependency (<em>chapter-2/code-with-quarkus/pom.xml</em>)</h5>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;dependency&gt;</code>&#13;
  <code class="nt">&lt;groupId&gt;</code>io.quarkus<code class="nt">&lt;/groupId&gt;</code>&#13;
  <code class="nt">&lt;artifactId&gt;</code>quarkus-kubernetes<code class="nt">&lt;/artifactId&gt;</code>&#13;
<code class="nt">&lt;/dependency&gt;</code></pre></div>&#13;
&#13;
<p>With this new dependency,&#13;
the build can generate the necessary resource files for deploying the application to Kubernetes,&#13;
as well as enable us to deploy the application.&#13;
What a time-saver! Let’s see how it works!</p>&#13;
&#13;
<p>Before we can see how it works, we need to choose the preferred containerization mechanism.&#13;
With Quarkus, we can choose between Docker, <a href="https://oreil.ly/Ybxcs">Jib</a>, and Source-to-Image (S2I).&#13;
<a data-primary="Jib" data-type="indexterm" id="idm45358833350832"/>We will choose Jib, as all dependencies are cached in a layer separate from the application,&#13;
making subsequent container builds much faster.&#13;
Let’s add the Jib container dependency, as shown in <a data-type="xref" href="#jib-container-ext-dep">Example 2-18</a>.</p>&#13;
<div data-type="example" id="jib-container-ext-dep">&#13;
<h5><span class="label">Example 2-18. </span>Jib container extension dependency (<em>chapter-2/code-with-quarkus/pom.xml</em>)</h5>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;dependency&gt;</code>&#13;
  <code class="nt">&lt;groupId&gt;</code>io.quarkus<code class="nt">&lt;/groupId&gt;</code>&#13;
  <code class="nt">&lt;artifactId&gt;</code>quarkus-container-image-jib<code class="nt">&lt;/artifactId&gt;</code>&#13;
<code class="nt">&lt;/dependency&gt;</code></pre></div>&#13;
&#13;
<p>We’re nearly there!&#13;
But first, we need a Kubernetes cluster!&#13;
<a data-primary="minikube" data-type="indexterm" id="ix_quarkus-adoc9"/>The easiest is to use minikube,&#13;
but you can also use Docker Desktop,&#13;
or <a href="https://microk8s.io/">MicroK8s</a>.&#13;
In this book, we will use minikube, as it’s one of the most straightforward solutions.&#13;
Minikube is not a complete Kubernetes cluster but provides enough features for us.</p>&#13;
&#13;
<p>Follow the instructions from <a href="https://oreil.ly/Vn7Jf">the minikube documentation</a> to download and install minikube.&#13;
With minikube installed, start it (<a data-type="xref" href="#start-minikube">Example 2-19</a>).</p>&#13;
<div data-type="example" id="start-minikube">&#13;
<h5><span class="label">Example 2-19. </span>Start minikube</h5>&#13;
&#13;
<pre data-code-language="shell" data-type="programlisting">&gt; minikube start</pre></div>&#13;
&#13;
<p>The default configuration of minikube will be used unless we have specific configuration options set.&#13;
Right now, the default is fine,&#13;
which is two CPUs and 4 GB RAM for a virtual machine.&#13;
If this is the first time minikube is being run, there will be a short delay while minikube downloads the necessary images.</p>&#13;
&#13;
<p>Quarkus provides an additional extension for use with minikube, to tailor the Kubernetes resources&#13;
specifically for minikube.&#13;
A big advantage to this approach is not requiring a Kubernetes <code>Ingress</code> to access services inside Kubernetes;&#13;
instead, we can access them through a <code>NodePort</code> service.&#13;
This allows us to see localhost-accessible URLs for our services when running <code>minikube services list</code>.&#13;
To activate localhost-accessible URLs, we need another dependency (<a data-type="xref" href="#minikube-ext-dep">Example 2-20</a>).</p>&#13;
<div data-type="example" id="minikube-ext-dep">&#13;
<h5><span class="label">Example 2-20. </span>Minikube extension dependency (<em>chapter-2/code-with-quarkus/pom.xml</em>)</h5>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;dependency&gt;</code>&#13;
  <code class="nt">&lt;groupId&gt;</code>io.quarkus<code class="nt">&lt;/groupId&gt;</code>&#13;
  <code class="nt">&lt;artifactId&gt;</code>quarkus-minikube<code class="nt">&lt;/artifactId&gt;</code>&#13;
<code class="nt">&lt;/dependency&gt;</code></pre></div>&#13;
&#13;
<p>Before deploying our application, let’s play a bit with Kubernetes to understand some concepts.&#13;
You can interact with Kubernetes clusters by using the <code>kubectl</code> command; see <a data-type="xref" href="#retrieving-the-nodes">Example 2-21</a>.</p>&#13;
<div data-type="example" id="retrieving-the-nodes">&#13;
<h5><span class="label">Example 2-21. </span>Retrieve the nodes</h5>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting">&gt; kubectl get nodes&#13;
NAME       STATUS   ROLES    AGE     VERSION&#13;
minikube   Ready    master   2m45s   v1.18.3</pre></div>&#13;
&#13;
<p>This command prints the <em>nodes</em> managed by Kubernetes.&#13;
You should not be surprised to see that we have a single node here, named <code>master</code>.&#13;
That’s your machine, or virtual machine, depending on your operating system.</p>&#13;
&#13;
<p>Unlike other systems such as Docker, Kubernetes doesn’t run containers directly.&#13;
<a data-primary="pods" data-type="indexterm" id="idm45358833242176"/>Instead, it wraps one or more containers into a higher-level structure called a <em>pod</em>.&#13;
Pods are used as the unit of replication.&#13;
If your application is getting too many requests, and a single pod instance can’t carry the load, you can ask Kubernetes to instantiate new replicas.&#13;
Even when not under heavy load, it is a good idea to have multiple replicas of a pod, to allow load balancing and fault-tolerance.&#13;
You can get the list of pods by using <code>kubectl get pods</code> (<a data-type="xref" href="#get-kubectl-pods-2-22">Example 2-22</a>).</p>&#13;
<div data-type="example" id="get-kubectl-pods-2-22">&#13;
<h5><span class="label">Example 2-22. </span>Use the <code>kubectl</code> command to list the running pods</h5>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting">&gt; kubectl get pods&#13;
No resources found in default namespace.</pre></div>&#13;
&#13;
<p>Not a big surprise, our cluster is empty.</p>&#13;
&#13;
<p>In <a data-type="xref" href="#quarkus::java-cloud">“Java on the Cloud”</a>, we talked a lot about wanting to reduce the amount of memory for&#13;
services written in Java within a container.&#13;
To be able to determine that in minikube,&#13;
we need to install an add-on before deploying our service (<a data-type="xref" href="#add-metric-server-to-minikube">Example 2-23</a>).</p>&#13;
<div data-type="example" id="add-metric-server-to-minikube">&#13;
<h5><span class="label">Example 2-23. </span>Add the metric server to the minikube cluster</h5>&#13;
&#13;
<pre data-code-language="shell" data-type="programlisting">&gt; minikube addons <code class="nb">enable </code>metrics-server</pre></div>&#13;
&#13;
<p><a data-primary="deployment (Quarkus)" data-type="indexterm" id="idm45358833187744"/>To create pods, we need a <em>deployment</em>.&#13;
Deployments have two primary purposes:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Indicate which containers need to run in the pod</p>&#13;
</li>&#13;
<li>&#13;
<p>Indicate the number of instances of the pod that should be running at a time</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Generally, to create a deployment, you need the following:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>A container image accessible to your Kubernetes cluster</p>&#13;
</li>&#13;
<li>&#13;
<p>A YAML document describing your deployment<sup><a data-type="noteref" href="ch02.html#idm45358833162544" id="idm45358833162544-marker">5</a></sup></p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Quarkus provides facilities to avoid having to create the image and write the deployment manually,&#13;
such as the Kubernetes, minikube, and Jib container extensions we mentioned earlier.</p>&#13;
&#13;
<p>With all the pieces in place, it’s time for us to build and deploy the application to Kubernetes in minikube! Open a terminal window and change to the directory of the project. Because we don’t want to run our own Docker daemon for building the containers, we can run <code>eval $(minikube -p minikube docker-env)</code> to expose the Docker daemon from minikube to the local terminal environment.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p><code>eval $(minikube -p minikube docker-env)</code> must be run in every terminal window we use to access minikube.&#13;
Without, it any Docker commands we execute will use the local Docker daemon,&#13;
which we don’t want.</p>&#13;
</div>&#13;
&#13;
<p>Next we build and deploy the container (as shown in <a data-type="xref" href="#deploy-quarkus-app-to-kub">Example 2-24</a>).</p>&#13;
<div data-type="example" id="deploy-quarkus-app-to-kub">&#13;
<h5><span class="label">Example 2-24. </span>Deploy a Quarkus application to Kubernetes</h5>&#13;
&#13;
<pre data-code-language="shell" data-type="programlisting"><code>&gt;</code><code> </code><code>mvn</code><code> </code><code>verify</code><code> </code><code>-Dquarkus.kubernetes.deploy</code><code class="o">=</code><code class="nb">true</code><code> </code><a class="co" href="#callout_introduction_to_quarkus_CO2-1" id="co_introduction_to_quarkus_CO2-1"><img alt="1" src="assets/1.png"/></a></pre></div>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_introduction_to_quarkus_CO2-1" id="callout_introduction_to_quarkus_CO2-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Package the application, create the container image, create the deployment descriptor, and deploy it to our cluster.</p></dd>&#13;
</dl>&#13;
&#13;
<p>Execute the <code>kubeclt get pods</code> command to verify (<a data-type="xref" href="#list-running-pods-with-kubectl">Example 2-25</a>).</p>&#13;
<div data-type="example" id="list-running-pods-with-kubectl">&#13;
<h5><span class="label">Example 2-25. </span>List running pods with <code>kubectl</code></h5>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting">&gt; kubectl get pods&#13;
code-with-quarkus-66769bd48f-l65ff   1/1     Running   <code class="m">0</code>          88s</pre></div>&#13;
&#13;
<p>Yeah! Our application is running!</p>&#13;
&#13;
<p>Quarkus creates a deployment for us, as shown in <a data-type="xref" href="#list-installed-deployments">Example 2-26</a>.</p>&#13;
<div data-type="example" id="list-installed-deployments">&#13;
<h5><span class="label">Example 2-26. </span>List the installed deployments</h5>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting">&gt; kubectl get deployments&#13;
NAME               READY   UP-TO-DATE   AVAILABLE   AGE&#13;
code-with-quarkus  1/1     <code class="m">1</code>            <code class="m">1</code>           6m23s</pre></div>&#13;
&#13;
<p>You can check the created deployment in <em>target/kubernetes/minikube.yml</em>, or review <a data-type="xref" href="#generated-deployment">Example 2-27</a>.</p>&#13;
<div data-type="example" id="generated-deployment">&#13;
<h5><span class="label">Example 2-27. </span>The generated deployment</h5>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">apps/v1</code><code>&#13;
</code><code class="nt">kind</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">Deployment</code><code>&#13;
</code><code class="nt">metadata</code><code class="p">:</code><code>&#13;
</code><code>  </code><code class="c1"># ...</code><code>&#13;
</code><code>  </code><code class="nt">name</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">code-with-quarkus</code><code>&#13;
</code><code class="nt">spec</code><code class="p">:</code><code>&#13;
</code><code>  </code><code class="nt">replicas</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">1</code><code> </code><a class="co" href="#callout_introduction_to_quarkus_CO3-1" id="co_introduction_to_quarkus_CO3-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
</code><code>  </code><code class="c1">#...</code><code>&#13;
</code><code>  </code><code class="nt">template</code><code class="p">:</code><code>&#13;
</code><code>    </code><code class="nt">metadata</code><code class="p">:</code><code>&#13;
</code><code>      </code><code class="c1"># ...</code><code>&#13;
</code><code>    </code><code class="nt">spec</code><code class="p">:</code><code>&#13;
</code><code>      </code><code class="nt">containers</code><code class="p">:</code><code>&#13;
</code><code>        </code><code class="nt">image</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">your_name/code-with-quarkus:1.0.0-SNAPSHOT</code><code> </code><a class="co" href="#callout_introduction_to_quarkus_CO3-2" id="co_introduction_to_quarkus_CO3-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
</code><code>        </code><code class="nt">imagePullPolicy</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">IfNotPresent</code><code>&#13;
</code><code>        </code><code class="nt">name</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">code-with-quarkus</code><code>&#13;
</code><code>        </code><code class="nt">ports</code><code class="p">:</code><code>&#13;
</code><code>        </code><code class="p-Indicator">-</code><code> </code><code class="nt">containerPort</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">8080</code><code>&#13;
</code><code>          </code><code class="nt">name</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">http</code><code>&#13;
</code><code>          </code><code class="nt">protocol</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">TCP</code><code>&#13;
</code><code>        </code><code class="c1"># ...</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_introduction_to_quarkus_CO3-1" id="callout_introduction_to_quarkus_CO3-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>The number of replicas</p></dd>&#13;
<dt><a class="co" href="#co_introduction_to_quarkus_CO3-2" id="callout_introduction_to_quarkus_CO3-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>The container image name</p></dd>&#13;
</dl></div>&#13;
&#13;
<p>As you can see, the deployment YAML indicates the number of replicas and the set of containers running in the pod (here, a single one).</p>&#13;
&#13;
<p>If you look carefully at the generated descriptor, you will see <code>service</code>:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">v1</code><code>&#13;
</code><code class="nt">kind</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">Service</code><code>&#13;
</code><code class="nt">metadata</code><code class="p">:</code><code>&#13;
</code><code>  </code><code class="c1"># ...</code><code>&#13;
</code><code>  </code><code class="nt">name</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">code-with-quarkus</code><code>&#13;
</code><code class="nt">spec</code><code class="p">:</code><code>&#13;
</code><code>  </code><code class="nt">ports</code><code class="p">:</code><code>&#13;
</code><code>  </code><code class="p-Indicator">-</code><code> </code><code class="nt">name</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">http</code><code>&#13;
</code><code>    </code><code class="nt">nodePort</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">31995</code><code>       </code><a class="co" href="#callout_introduction_to_quarkus_CO4-1" id="co_introduction_to_quarkus_CO4-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
</code><code>    </code><code class="nt">port</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">8080</code><code>&#13;
</code><code>    </code><code class="nt">targetPort</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">8080</code><code>&#13;
</code><code>  </code><code class="nt">selector</code><code class="p">:</code><code>&#13;
</code><code>    </code><code class="nt">app.kubernetes.io/name</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">code-with-quarkus</code><code>&#13;
</code><code>    </code><code class="nt">app.kubernetes.io/version</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">1.0.0-SNAPSHOT</code><code>&#13;
</code><code>  </code><code class="nt">type</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">NodePort</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_introduction_to_quarkus_CO4-1" id="callout_introduction_to_quarkus_CO4-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Random local port number we can access the service on</p></dd>&#13;
</dl>&#13;
&#13;
<p><a data-primary="service, defined" data-type="indexterm" id="idm45358832887696"/>A <em>service</em> is a channel of communication delegating to a set of pods (selected using labels).&#13;
In our example, the service is named <code>code-with-quarkus</code>.&#13;
This name can be used by other applications to discover the functionality we expose.&#13;
This service delegates the port 8080 on pods with matching labels (<em>app.kubernetes.io/name</em> and <em>app.kubernetes.io/version</em>).&#13;
The good news is that our pod is configured with these labels.&#13;
As a result, calling this <code>code-with-quarkus</code> on port 8080 delegates to port 8080 of our container.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Quarkus generates multiple descriptors.&#13;
The <em>minikube.yml</em> descriptor is tailored for minikube.&#13;
The <em>kubernetes.yml</em> descriptor is more generic.&#13;
The main difference is the type of service that gets created.</p>&#13;
</div>&#13;
&#13;
<p>So, let’s invoke our service!&#13;
We need to ask minikube to give us the service URL, as shown in <a data-type="xref" href="#retrieve-the-service-url">Example 2-28</a>.</p>&#13;
<div data-type="example" id="retrieve-the-service-url">&#13;
<h5><span class="label">Example 2-28. </span>Retrieve the service URL</h5>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting">&gt; minikube service code-with-quarkus --url&#13;
&#13;
🏃  Starting tunnel <code class="k">for</code> service code-with-quarkus.&#13;
<code class="p">|</code>-----------<code class="p">|</code>-------------------<code class="p">|</code>-------------<code class="p">|</code>------------------------<code class="p">|</code>&#13;
<code class="p">|</code> NAMESPACE <code class="p">|</code>      NAME         <code class="p">|</code> TARGET PORT <code class="p">|</code>          URL           <code class="p">|</code>&#13;
<code class="p">|</code>-----------<code class="p">|</code>-------------------<code class="p">|</code>-------------<code class="p">|</code>------------------------<code class="p">|</code>&#13;
<code class="p">|</code> default   <code class="p">|</code> code-with-quarkus <code class="p">|</code>             <code class="p">|</code> http://127.0.0.1:31995 <code class="p">|</code>&#13;
<code class="p">|</code>-----------<code class="p">|</code>-------------------<code class="p">|</code>-------------<code class="p">|</code>------------------------<code class="p">|</code>&#13;
http://127.0.0.1:31995&#13;
❗  Because you are using a Docker driver on darwin, the terminal needs&#13;
  to be open to run it.</pre></div>&#13;
&#13;
<p>Open a browser and use the URL of the service to access it, or <code>curl</code> if you prefer.&#13;
If deployment worked, we see <code>Hi</code> as a response on the root path.&#13;
Add <code>/welcome</code> to see <code>Welcome to Quarkus!</code> We deployed a Quarkus service to Kubernetes!</p>&#13;
&#13;
<p>We’ve verified that our Quarkus service deployed and works as expected,&#13;
but what about the memory situation? Let’s check it out in <a data-type="xref" href="#measure-resource-usage-kubectl">Example 2-29</a>.</p>&#13;
<div data-type="example" id="measure-resource-usage-kubectl">&#13;
<h5><span class="label">Example 2-29. </span>Measure resource usage using <code>kubectl top</code></h5>&#13;
&#13;
<pre data-code-language="shell" data-type="programlisting">&gt; kubectl top pods&#13;
NAME                                 CPU<code class="o">(</code>cores<code class="o">)</code>   MEMORY<code class="o">(</code>bytes<code class="o">)</code>&#13;
code-with-quarkus-66769bd48f-l65ff   1m           80Mi</pre></div>&#13;
&#13;
<p>Wow, only 80 MB is really nice and compact!&#13;
That’s a large improvement over traditional frameworks in containers.</p>&#13;
&#13;
<p>You’ve just seen how to take a Quarkus application and add the ability&#13;
to deploy it to Kubernetes&#13;
or, in this case, to minikube.<a data-startref="ix_quarkus-adoc9" data-type="indexterm" id="idm45358832809328"/>&#13;
There are certainly potential gotchas in defining the Kubernetes resources&#13;
we need for deployment,&#13;
but that’s why we use the Kubernetes extension with Quarkus to handle all that for us.&#13;
We prefer not to handcode YAML or JSON, inadvertently making an error with indentation, and then watching deployment fail!<a data-startref="ix_quarkus-adoc8" data-type="indexterm" id="idm45358832808592"/><a data-startref="ix_quarkus-adoc7" data-type="indexterm" id="idm45358832806432"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Going Native" data-type="sect1"><div class="sect1" id="idm45358833393728">&#13;
<h1>Going Native</h1>&#13;
&#13;
<p><a data-primary="native executables" data-type="indexterm" id="ix_quarkus-adoc10"/><a data-primary="Quarkus" data-secondary="going native" data-type="indexterm" id="ix_quarkus-adoc11"/>What does <em>going native</em> mean? We’re referring to the ability to build native executables for an environment.&#13;
Many applications we use every day on our machines are <em>native executables</em>,&#13;
meaning the code of the application was compiled down to low-level instructions for a specific operating system,&#13;
in our case macOS.</p>&#13;
&#13;
<p>Developing Java applications has always required the presence of a JVM for execution.&#13;
<a data-primary="GraalVM" data-type="indexterm" id="ix_quarkus-adoc12"/>However, the ability to build a native executable from Java code has recently been made possible&#13;
with releases from the <a href="https://www.graalvm.org">GraalVM</a> project.&#13;
In this section, we explain how to utilize the GraalVM project with Quarkus to generate a native executable for your Java code!</p>&#13;
&#13;
<p><a data-primary="ahead of time (AOT) compilation" data-type="indexterm" id="idm45358832798752"/><a data-primary="AOT (ahead of time) compilation" data-type="indexterm" id="idm45358832798080"/>In <a data-type="xref" href="#quarkus::quarkus-way">“The Quarkus Way”</a>, we discussed how Quarkus utilizes AOT compilation to perform actions&#13;
during build time instead of on application start.</p>&#13;
&#13;
<p class="pagebreak-before less_space">Quarkus extensions achieve this by breaking all the work into three separate phases:</p>&#13;
<dl>&#13;
<dt>Augmentation</dt>&#13;
<dd>&#13;
<p>Build steps process descriptors and annotations, and augment the application classes by generating bytecode containing any required metadata. This phase is always executed within the build process on a JVM.</p>&#13;
</dd>&#13;
<dt>Static initialization</dt>&#13;
<dd>&#13;
<p>Runs any steps intended to have their resulting output captured in bytecode. There are restrictions on what these steps can do, as they should not open ports for listening or start threads.</p>&#13;
</dd>&#13;
<dt>Runtime initialization</dt>&#13;
<dd>&#13;
<p>These steps are run as part of the application’s main method during startup. Tasks should be kept to a minimum to take the most advantage of AOT.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>Static and runtime initialization both occur at startup when executing on a JVM.&#13;
However, with native executables we have an extra benefit.&#13;
With initialization separated into two phases,&#13;
we’re able to perform static initialization during the native executable build process.&#13;
This allows the output from the static initialization phase to be serialized directly into the native executable,&#13;
allowing any classes used in this phase to be dropped from the native executable as they’re no longer needed.&#13;
This provides benefits in native executable startup time and reduction in memory requirements.</p>&#13;
&#13;
<p>As part of the native executable build process with GraalVM, all execution paths are evaluated.&#13;
Any classes, methods, or fields deemed to not be on the execution path are removed from the resulting native executable.&#13;
This is why reflection, dynamic class loading, and other features of JVM usage are disallowed without&#13;
special flags, because the goal is to <em>not</em> retain every piece of code within a native executable.&#13;
If we were to attempt to build a native executable for the earlier Thorntail example,&#13;
it would require flags to be set to allow reflection, dynamic class loading, and possibly others.&#13;
The design of Thorntail is not suitable for a native executable build,&#13;
whereas Quarkus has the goal of code reduction in mind from the beginning.</p>&#13;
&#13;
<p>Let’s see what’s needed to actually build a native executable.<sup><a data-type="noteref" href="ch02.html#idm45358832739008" id="idm45358832739008-marker">6</a></sup> Creating the project with <a href="https://code.quarkus.io"><em class="hyperlink">https://code.quarkus.io</em></a> means a Maven profile was already added to the project for us.&#13;
<a data-type="xref" href="#native-image-gen-maven-profile">Example 2-30</a> shows what that looks like.</p>&#13;
<div data-type="example" id="native-image-gen-maven-profile">&#13;
<h5><span class="label">Example 2-30. </span>Native image generation Maven profile (<em>chapter-2/code-with-quarkus/pom.xml</em>)</h5>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;profile&gt;</code>&#13;
  <code class="nt">&lt;id&gt;</code>native<code class="nt">&lt;/id&gt;</code>&#13;
  <code class="nt">&lt;activation&gt;</code>&#13;
    <code class="nt">&lt;property&gt;</code>&#13;
      <code class="nt">&lt;name&gt;</code>native<code class="nt">&lt;/name&gt;</code>&#13;
    <code class="nt">&lt;/property&gt;</code>&#13;
  <code class="nt">&lt;/activation&gt;</code>&#13;
  <code class="nt">&lt;properties&gt;</code>&#13;
    <code class="nt">&lt;quarkus.package.type&gt;</code>native<code class="nt">&lt;/quarkus.package.type&gt;</code>&#13;
  <code class="nt">&lt;/properties&gt;</code>&#13;
<code class="nt">&lt;/profile&gt;</code></pre></div>&#13;
&#13;
<p>We now have the ability to build a native executable for Quarkus,&#13;
but without GraalVM installed we won’t get very far!&#13;
Check <a href="https://oreil.ly/HFtW1">the “Building a Native Executable” guide</a> for all the details on installing GraalVM for&#13;
building native executables.<a data-startref="ix_quarkus-adoc12" data-type="indexterm" id="idm45358832720752"/></p>&#13;
&#13;
<p>Once GraalVM is installed,&#13;
let’s build a native executable; see <a data-type="xref" href="#compile-quarkus-app-into-native">Example 2-31</a>.</p>&#13;
<div data-type="example" id="compile-quarkus-app-into-native">&#13;
<h5><span class="label">Example 2-31. </span>Compile a Quarkus application into a native executable</h5>&#13;
&#13;
<pre data-code-language="shell" data-type="programlisting">&gt; mvn verify -Pnative</pre></div>&#13;
&#13;
<p>Unfortunately, building a native executable does take longer than usual JVM builds.&#13;
For this reason, we suggest not building a native executable regularly,&#13;
and recommend doing these builds as part of a CI pipeline.</p>&#13;
&#13;
<p>Running these builds is our new opportunity for coffee breaks!</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>As the number of classes grows in an application,&#13;
a native executable build takes longer to complete.&#13;
This longer time is caused by the larger number of execution paths requiring evaluation.</p>&#13;
</div>&#13;
&#13;
<p>With the native executable built,&#13;
we can run it with <code>./target/code-with-quarkus-1.0.0-SNAPSHOT-runner</code>.&#13;
Relish in the speed with which it starts,&#13;
and be sure to verify that the two endpoints we created still work.</p>&#13;
&#13;
<p>We’ve now built a native executable for our local environment,&#13;
but unless we’re using a Linux operating system,&#13;
our native executable won’t work inside a container!&#13;
As native executables are specific to an operating system,&#13;
we need to specially build one for use in a Linux container.</p>&#13;
&#13;
<p><a data-primary="Docker" data-type="indexterm" id="idm45358832712176"/>To build a native executable for containers,&#13;
we need to utilize <a href="https://docker.com">Docker</a>.&#13;
Once Docker is installed, ensure that it’s started.&#13;
As the current terminal has been switched to use the Docker daemon inside minikube,&#13;
we need to open a new terminal so we can use local Docker for a build.&#13;
Navigate to the project directory and run <a data-type="xref" href="#compile-quarkus-app-linux-64">Example 2-32</a>.</p>&#13;
<div data-type="example" id="compile-quarkus-app-linux-64">&#13;
<h5><span class="label">Example 2-32. </span>Compile a Quarkus application into a Linux 64-bit native executable</h5>&#13;
&#13;
<pre data-code-language="shell" data-type="programlisting">&gt; mvn verify -Pnative -Dquarkus.native.container-build<code class="o">=</code><code class="nb">true</code></pre></div>&#13;
&#13;
<p>What we’ve done is utilized our local Docker environment to build a native executable for a Linux operating system.&#13;
If we tried to run the native executable,&#13;
and our local operating system is not Linux,&#13;
we see an error (<a data-type="xref" href="#format-error-start-application">Example 2-33</a>).</p>&#13;
<div data-type="example" id="format-error-start-application">&#13;
<h5><span class="label">Example 2-33. </span>Format error when we start an application not compiled for the host operating system</h5>&#13;
&#13;
<pre data-code-language="shell" data-type="programlisting">zsh: <code class="nb">exec </code>format error: ./target/code-with-quarkus-1.0.0-SNAPSHOT-runner</pre></div>&#13;
&#13;
<p>We need to go back to the previous terminal now,&#13;
as we want to interact with the Docker daemon in minikube.&#13;
Let’s run a Docker build inside minikube, as shown in <a data-type="xref" href="#build-container-running-quarkus-app">Example 2-34</a>.</p>&#13;
<div data-type="example" id="build-container-running-quarkus-app">&#13;
<h5><span class="label">Example 2-34. </span>Build a container running a Quarkus application compiled into a native executable</h5>&#13;
&#13;
<pre data-code-language="shell" data-type="programlisting">&gt; docker build -f src/main/docker/Dockerfile.native <code class="se">\</code>&#13;
    -t &lt;_your_docker_username_&gt;/code-with-quarkus:1.0.0-SNAPSHOT .</pre></div>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>Don’t forget to replace <code><em>&lt;your_docker_username&gt;</em></code> with your local Docker username.</p>&#13;
</div>&#13;
&#13;
<p>We now have a container available inside minikube,&#13;
so let’s create the application deployment; see <a data-type="xref" href="#deploy-quarkus-application-into-minikube">Example 2-35</a>.</p>&#13;
<div data-type="example" id="deploy-quarkus-application-into-minikube">&#13;
<h5><span class="label">Example 2-35. </span>Deploy the Quarkus application into minikube</h5>&#13;
&#13;
<pre data-code-language="shell" data-type="programlisting">&gt; kubectl apply -f target/kubernetes/minikube.yml</pre></div>&#13;
&#13;
<p>We used the minikube-specific Kubernetes YAML from an earlier build to create the deployment.&#13;
This version creates the <em>NodePort</em> service we need to access a service from our local environment,&#13;
but also modifies the <code>imagePullPolicy</code> of the container to <code>IfNotPresent</code> instead of <code>Always</code>.&#13;
This last change prevents minikube from trying to check for a newer container image from Docker Hub,&#13;
which is good because it wouldn’t find one there!</p>&#13;
&#13;
<p>With the deployment done,&#13;
grab the URL from <code>minikube service list</code> and test out the endpoints again.&#13;
Everything should be good, and we get the same messages as before.</p>&#13;
&#13;
<p>Now for the interesting part! Earlier we installed the metrics server into minikube to track memory utilization,&#13;
and now it’s time to see what our native executable looks like.&#13;
Though we’ve made requests and the deployment is present,&#13;
it can be a few minutes before the metrics are available.&#13;
Keep trying until they appear.&#13;
You should see something similar to <a data-type="xref" href="#measure-resource-usages-kubernetes">Example 2-36</a>.</p>&#13;
<div data-type="example" id="measure-resource-usages-kubernetes">&#13;
<h5><span class="label">Example 2-36. </span>Measure resource usage in Kubernetes</h5>&#13;
&#13;
<pre data-code-language="shell" data-type="programlisting">&gt; kubectl top pods&#13;
NAME                                CPU<code class="o">(</code>cores<code class="o">)</code>   MEMORY<code class="o">(</code>bytes<code class="o">)</code>&#13;
code-with-quarkus-fd76c594b-48b98   0m           7Mi</pre></div>&#13;
&#13;
<p>That’s fantastic! Only 7 MB of RAM used!</p>&#13;
&#13;
<p>This is where the combination of Quarkus and native executables really shines.&#13;
We can also check the logs of the pod to see how quickly the container started;&#13;
we would expect it to be around 10–20 ms.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>We attempted to build a native image for Thorntail to provide a comparison. However, we experienced issues building a usable native image and were stopped by an <a href="https://oreil.ly/hxcqo"><code>UnsatisfiedLinkError</code></a>.<a data-startref="ix_quarkus-adoc11" data-type="indexterm" id="idm45358832647200"/><a data-startref="ix_quarkus-adoc10" data-type="indexterm" id="idm45358832555280"/></p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="idm45358832805504">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>We’ve covered a great deal about Quarkus in a short amount of time,&#13;
and there’s still plenty more to go through in the remainder of the book.&#13;
Quarkus is a Kubernetes-native Java stack,&#13;
focused on minimizing memory requirements with AOT, and&#13;
amping up the memory reduction even further when we want a native executable.&#13;
With the Kubernetes and container extensions,&#13;
Quarkus takes the hassle out of handwriting YAML deployment files,&#13;
doing it all for us!</p>&#13;
&#13;
<p>In this chapter, you learned about the following:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Understanding the problems with Java in containers</p>&#13;
</li>&#13;
<li>&#13;
<p>Understanding how Quarkus differs from traditional frameworks in moving runtime startup tasks to buildtime with AOT</p>&#13;
</li>&#13;
<li>&#13;
<p>Creating a Quarkus project with <a href="https://code.quarkus.io"><em class="hyperlink">https://code.quarkus.io</em></a></p>&#13;
</li>&#13;
<li>&#13;
<p>Using Kubernetes and minikube extensions to generate the required deployment configuration</p>&#13;
</li>&#13;
<li>&#13;
<p>Building a native executable for Quarkus with GraalVM</p>&#13;
</li>&#13;
<li>&#13;
<p>Using the Kubernetes extension to deploy Quarkus applications to a container environment<a data-startref="ix_quarkus-adoc0" data-type="indexterm" id="idm45358832545360"/></p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>In the next chapters, we will briefly take a step back to detail distributed systems,&#13;
reactive systems, reactive programming, and how they relate to each other.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<div data-type="footnotes"><p data-type="footnote" id="idm45358839670352"><sup><a href="ch02.html#idm45358839670352-marker">1</a></sup> In this book, <em>container</em> refers to a form of operating system virtualization, not to Java EE containers.</p><p data-type="footnote" id="idm45358839636416"><sup><a href="ch02.html#idm45358839636416-marker">2</a></sup> You can find the <a href="https://github.com/cescoffier/reactive-systems-in-java">script to measure startup time on GitHub</a>.</p><p data-type="footnote" id="idm45358841838240"><sup><a href="ch02.html#idm45358841838240-marker">3</a></sup> <a href="https://oreil.ly/eYjXF">See Platform Specific Memory Reporting on the Quarkus website</a>.</p><p data-type="footnote" id="idm45358833902576"><sup><a href="ch02.html#idm45358833902576-marker">4</a></sup> Quarkus offers multiple ways to implement HTTP endpoints. JAX-RS is one of them. You can also use controller classes with Spring MVC annotation or reactive routes if you prefer more programmatic approaches.</p><p data-type="footnote" id="idm45358833162544"><sup><a href="ch02.html#idm45358833162544-marker">5</a></sup> YAML (Yet Another Markup Language) is the most used format to describe Kubernetes resources. <a href="https://oreil.ly/mZOTT">Wikipedia provides a gentle introduction</a>.</p><p data-type="footnote" id="idm45358832739008"><sup><a href="ch02.html#idm45358832739008-marker">6</a></sup> GraalVM is not the first tool to build native executables from Java code. Dalvik, Avian, GNU Compiler for Java (GCJ,) and Excelsior JET predate GraalVM.</p></div></div></section></body></html>