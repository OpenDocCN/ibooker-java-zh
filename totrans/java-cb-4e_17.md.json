["```java\njava -verbose HelloJava | more\n```", "```java\n        System.out.println(\"Trying the ClassName.class keyword:\");\n        System.out.println(\"Object class: \" + Object.class);\n        System.out.println(\"String class: \" + String.class);\n        System.out.println(\"String[] class: \" + String[].class);\n        System.out.println(\"Calendar class: \" + Calendar.class);\n        System.out.println(\"Current class: \" + ClassKeyword.class);\n        System.out.println(\"Class for int: \" + int.class);\n        System.out.println();\n\n        System.out.println(\"Trying the instance.getClass() method:\");\n        System.out.println(\"Sir Robin the Brave\".getClass());\n        System.out.println(Calendar.getInstance().getClass());\n```", "```java\nC:\\javasrc\\reflect>java  ClassKeyword \nTrying the ClassName.class keyword:\nObject class: class java.lang.Object\nString class: class java.lang.String\nString[] class: class [Ljava.lang.String;\nCalendar class: class java.util.Calendar\nCurrent class: class ClassKeyword\nClass for int: int\n\nTrying the instance.getClass( ) method:\nclass java.lang.String\nclass java.util.GregorianCalendar\n\nC:\\javasrc\\reflect>\n```", "```java\npublic class ListMethods {\n    public static void main(String[] argv) throws ClassNotFoundException {\n        if (argv.length == 0) {\n            System.err.println(\"Usage: ListMethods className\");\n            return;\n        }\n        Class<?> c = Class.forName(argv[0]);\n        Constructor<?>[] cons = c.getConstructors();\n        printList(\"Constructors\", cons);\n        Method[] meths = c.getMethods();\n        printList(\"Methods\", meths);\n    }\n    static void printList(String s, Object[] o) {\n        System.out.println(\"*** \" + s + \" ***\");\n        for (int i=0; i<o.length; i++)\n            System.out.println(o[i].toString());\n    }\n}\n```", "```java\n> java reflection.ListMethods java.lang.String\n*** Constructors ***\npublic java.lang.String( )\npublic java.lang.String(java.lang.String)\npublic java.lang.String(java.lang.StringBuffer)\npublic java.lang.String(byte[])\n// and many more...\n*** Methods ***\npublic static java.lang.String java.lang.String.copyValueOf(char[])\npublic static java.lang.String java.lang.String.copyValueOf(char[],int,int)\npublic static java.lang.String java.lang.String.valueOf(char)\n// and more valueOf( ) forms...\npublic boolean java.lang.String.equals(java.lang.Object)\npublic final native java.lang.Class java.lang.Object.getClass( )\n// and more java.lang.Object methods...\npublic char java.lang.String.charAt(int)\npublic int java.lang.String.compareTo(java.lang.Object)\npublic int java.lang.String.compareTo(java.lang.String)\n```", "```java\npublic class FindField {\n\n    public static void main(String[] unused)\n    throws NoSuchFieldException, IllegalAccessException {\n\n        // Create instance of FindField\n        FindField gf = new FindField();\n\n        // Create instance of target class (YearHolder defined below).\n        Object o = new YearHolder();\n\n        // Use gf to extract a field from o.\n        System.out.println(\"The value of 'currentYear' is: \" +\n            gf.intFieldValue(o, \"currentYear\"));\n    }\n\n    int intFieldValue(Object o, String name)\n    throws NoSuchFieldException, IllegalAccessException {\n        Class<?> c = o.getClass();\n        Field fld = c.getField(name);\n        int value = fld.getInt(o);\n        return value;\n    }\n}\n\n/** This is just a class that we want to get a field from */\nclass YearHolder {\n    /** Just a field that is used to show getting a field's value. */\n    public int currentYear = Calendar.getInstance().get(Calendar.YEAR);\n}\n```", "```java\npublic void work(String s) { }\n```", "```java\n/**\n * Get a given method, and invoke it.\n * @author Ian F. Darwin, http://www.darwinsys.com/\n */\npublic class GetAndInvokeMethod {\n\n    /** This class is just here to give us something to work on,\n * with a println() call that will prove we got into it.\n */\n    static class X {\n        public void work(int i, String s) {\n            System.out.printf(\"Called: i=%d, s=%s%n\", i, s);\n        }\n        // The main code does not use this overload.\n        public void work(int i) {\n            System.out.println(\"Unexpected call!\");\n        }\n    }\n    public static void main(String[] argv) {\n        try {\n            Class<?> clX = X.class; // or Class.forName(\"X\");\n\n            // To find a method we need the array of matching Class types.\n            Class<?>[] argTypes = {\n                int.class,\n                String.class\n            };\n\n            // Now find a Method object for the given method.\n            Method worker = clX.getMethod(\"work\", argTypes);\n\n            // To INVOKE the method, we need the invocation\n            // arguments, as an Object array.\n            Object[] theData = {\n                42,\n                \"Chocolate Chips\"\n            };\n\n            // The obvious last step: invoke the method.\n            // First arg is an instance, null if static method\n            worker.invoke(new X(), theData);\n\n        } catch (Exception e) {\n            System.err.println(\"Invoke() failed: \" + e);\n        }\n    }\n}\n```", "```java\nclass X {\n    @SuppressWarnings(\"unused\") // Used surreptitiously below.\n    private int p = 42;\n    int q = 3;\n}\n\n/**\n * Demonstrate that it is, in fact, all too easy to access private members\n * of an object using Reflection, using the default SecurityManager\n */\npublic class DefeatPrivacy {\n\n    public static void main(String[] args) throws Exception {\n        new DefeatPrivacy().process();\n    }\n\n    private void process() throws Exception {\n        X x = new X();\n        System.out.println(x);\n        // System.out.println(x.p); // Won't compile\n        System.out.println(x.q);\n        Class<? extends X> class1 = x.getClass();\n        Field[] flds = class1.getDeclaredFields();\n        for (Field f : flds) {\n            f.setAccessible(true);    // bye-bye \"private\"\n            System.out.println(f + \"==\" + f.get(x));\n            f.setAccessible(false);    // reset to \"correct\" state\n        }\n    }\n}\n```", "```java\n/** A simple class, just to provide the list of methods that\n * users need to provide to be usable in our application.\n * Note that the class is abstract so you must subclass it,\n * but the methods are non-abstract so you don't have to provide\n * dummy versions if you don't need a particular functionality.\n */\npublic abstract class Cooklet {\n\n    /** The initialization method. The Cookie application will\n * call you here (AFTER calling your no-argument constructor)\n * to allow you to initialize your code\n */\n    public void initialize( ) {\n    }\n\n    /** The work method. The cookie application will call you\n * here when it is time for you to start cooking.\n */\n    public void work( ) {\n    }\n\n    /** The termination method. The cookie application will call you\n * here when it is time for you to stop cooking and shut down\n * in an orderly fashion.\n */\n    public void terminate( ) {\n    }\n}\n```", "```java\npublic class DemoCooklet extends Cooklet {\n    public void work() {\n        System.out.println(\"I am busy baking cookies.\");\n    }\n    public void terminate() {\n        System.out.println(\"I am shutting down my ovens now.\");\n    }\n}\n```", "```java\npublic class Cookies {\n    public static void main(String[] argv) {\n        System.out.println(\"Cookies Application Version 0.0\");\n        Cooklet cooklet = null;\n        String cookletClassName = argv[0];\n        try {\n            Class<Cooklet> cookletClass =\n                (Class<Cooklet>) Class.forName(cookletClassName);\n            cooklet = cookletClass.newInstance();\n        } catch (Exception e) {\n            System.err.println(\"Error \" + cookletClassName + e);\n        }\n        cooklet.initialize();\n        cooklet.work();\n        cooklet.terminate();\n    }\n}\n```", "```java\n$ java Cookies DemoCooklet\nCookies Application Version 0.0\nI am busy baking cookies.\nI am shutting down my ovens now.\n$\n```", "```java\npackage reflection;\n\nimport java.lang.reflect.Method;\nimport java.net.URI;\nimport java.util.List;\nimport java.util.concurrent.Callable;\n\n// tag::main[] import javax.tools.JavaCompiler;\nimport javax.tools.SimpleJavaFileObject;\nimport javax.tools.ToolProvider;\n\n/** Demo the Java Compiler API: Create a class, compile, load, and run it.\n * N.B. Will not run under Eclipse due to classpath settings;\n * best run it standalone using \"java JavaCompiler.java\"\n * @author Ian Darwin\n */\npublic class JavaCompilerDemo {\n    private final static String PACKAGE = \"reflection\";\n    private final static String CLASS = \"AnotherDemo\";\n    private static boolean verbose;\n    public static void main(String[] args) throws Exception {\n        String source = \"package \" + PACKAGE + \";\\n\" +                  ![1](assets/1.png)\n            \"public class \" + CLASS + \" {\\n\" +\n            \"\\tpublic static void main(String[] args) {\\n\" +\n            \"\\t\\tString message = (args.length > 0 ? args[0] : \\\"Hi\\\")\" + \";\\n\" +\n            \"\\t\\tSystem.out.println(message + \\\" from AnotherDemo\\\");\\n\" +\n            \"\\t}\\n}\\n\";\n        if (verbose)\n            System.out.print(\"Source to be compiled:\\n\" + source);\n\n        JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();   ![2](assets/2.png)\n        if (compiler == null) {\n            throw new IllegalStateException(\"No default compiler, giving up.\");\n        }\n        Callable<Boolean> compilation =\n            compiler.getTask(null, null, null, List.of(\"-d\",\".\"), null, ![3](assets/3.png)\n            List.of(new MySource(CLASS, source)));\n        boolean result = compilation.call();                            ![4](assets/4.png)\n        if (result) {\n            System.out.println(\"Compiled OK\");\n            Class<?> c = Class.forName(PACKAGE + \".\" + CLASS);          ![5](assets/5.png)\n            System.out.println(\"Class = \" + c);\n            Method m = c.getMethod(\"main\", args.getClass());            ![6](assets/6.png)\n            System.out.println(\"Method descriptor = \" + m);\n            Object[] passedArgs = { args };\n            m.invoke(null, passedArgs);                                 ![7](assets/7.png)\n        } else {\n            System.out.println(\"Compilation failed\");\n        }\n    }\n}\n// end::main[] \nclass MySource extends SimpleJavaFileObject {\n    final String source;\n    MySource(String fileName, String source) {\n        super(URI.create(\"string:///\" + fileName.replace('.', '/') +\n                Kind.SOURCE.extension), Kind.SOURCE);\n        this.source = source;\n    }\n    @Override\n    public CharSequence getCharContent(boolean ignoreEncodingErrors) {\n        return source;\n    }\n}\n```", "```java\n$ java src/main/java/reflection/JavaCompilerDemo.java\nCompiled OK\nClass = class reflection.AnotherDemo\nMethod descriptor = public static void\n  reflection.AnotherDemo.main(java.lang.String[])\nHi from AnotherDemo\n$ java src/main/java/reflection/JavaCompilerDemo.java Welcome\nCompiled OK\nClass = class reflection.AnotherDemo\nMethod descriptor = public static void\n  reflection.AnotherDemo.main(java.lang.String[])\nWelcome from AnotherDemo\n$\n```", "```java\nprintln(\"Time is \" + n.toString( ) + \" seconds\");\n```", "```java\npublic class StringPrintA {\n    public static void main(String[] argv) {\n        Object o = \"Hello World\";\n        for (int i=0; i<100000; i++) {\n            System.out.println(\"<p><b>\" + o.toString() + \"</b></p>\");\n        }\n    }\n}\n```", "```java\npublic class StringPrintB {\n    public static void main(String[] argv) {\n        Object o = \"Hello World\";\n        for (int i=0; i<100000; i++) {\n            System.out.print(\"<p><b>\");\n            System.out.print(o.toString());\n            System.out.print(\"</b></p>\");\n            System.out.println();\n        }\n    }\n}\n```", "```java\npublic class Time {\n    public static void main(String[] argv) throws Exception {\n        // Instantiate target class, from argv[0]\n        Class<?> c = Class.forName(argv[0]);\n\n        // Find its static main method (use our own argv as the signature).\n        Class<?>[] classes = { argv.getClass() };\n        Method main = c.getMethod(\"main\", classes);\n\n        // Make new argv array, dropping class name from front.\n        // Normally Java doesn't get the class name, but in\n        // this case the user puts the name of the class to time\n        // as well as all its arguments...\n        String nargv[] = new String[argv.length - 1];\n        System.arraycopy(argv, 1, nargv, 0, nargv.length);\n\n        Object[] nargs = { nargv };\n\n        System.err.println(\"Starting class \" + c);\n\n        // About to start timing run. Important to not do anything\n        // (even a println) that would be attributed to the program\n        // being timed, from here until we've gotten ending time.\n\n        // Get current (i.e., starting) time\n        long t0 = System.currentTimeMillis();\n\n        // Run the main program\n        main.invoke(null, nargs);\n\n        // Get ending time, and compute usage\n        long t1 = System.currentTimeMillis();\n\n        long runTime = t1 - t0;\n\n        System.err.println(\n             \"runTime=\"  + Double.toString(runTime/1000D));\n    }\n}\n```", "```java\npublic class MyJavaP {\n\n    /** Simple main program, construct self, process each class name\n * found in argv.\n */\n    public static void main(String[] argv) {\n        MyJavaP pp = new MyJavaP();\n\n        if (argv.length == 0) {\n            System.err.println(\"Usage: MyJavaP className [...]\");\n            System.exit(1);\n        } else for (int i=0; i<argv.length; i++)\n            pp.doClass(argv[i]);\n    }\n\n    /** Format the fields and methods of one class, given its name.\n */\n    protected void doClass(String className) {\n        try {\n            Class<? extends Object> c = Class.forName(className);\n\n            final Annotation[] annotations = c.getAnnotations();\n            for (Annotation a : annotations) {\n                System.out.println(a);\n            }\n\n            System.out.println(c + \" {\");\n\n            Field fields[] = c.getDeclaredFields();\n            for (Field f : fields) {\n                final Annotation[] fldAnnotations = f.getAnnotations();\n                for (Annotation a : fldAnnotations) {\n                    System.out.println(a);\n                }\n                if (!Modifier.isPrivate(f.getModifiers()))\n                    System.out.println(\"\\t\" + f + \";\");\n            }\n\n            Constructor<? extends Object>[] constructors = c.getConstructors();\n            for (Constructor<? extends Object> con : constructors) {\n                System.out.println(\"\\t\" + con + \";\");\n            }\n\n            Method methods[] = c.getDeclaredMethods();\n            for (Method m : methods) {\n                final Annotation[] methodAnnotations = m.getAnnotations();\n                for (Annotation a : methodAnnotations) {\n                    System.out.println(a);\n                }\n                if (!Modifier.isPrivate(m.getModifiers())) {\n                    System.out.println(\"\\t\" + m + \";\");\n                }\n            }\n            System.out.println(\"}\");\n        } catch (ClassNotFoundException e) {\n            System.err.println(\"Error: Class \" +\n                className + \" not found!\");\n        } catch (Exception e) {\n            System.err.println(\"JavaP Error: \" + e);\n        }\n    }\n}\n```", "```java\npublic class ClassesInPackage {\n\n    /** This approach began as a contribution by Paul Kuit at\n * http://stackoverflow.com/questions/1456930/, but his only\n * handled single files in a directory in classpath, not in Jar files.\n * N.B. Does NOT handle system classes!\n * @param packageName\n * @return\n * @throws IOException\n */\n    public static String[] getPackageContent(String packageName)\n        throws IOException {\n\n        final String packageAsDirName = packageName.replace(\".\", \"/\");\n        final List<String> list = new ArrayList<>();\n        final Enumeration<URL> urls =\n                Thread.currentThread().\n                getContextClassLoader().\n                getResources(packageAsDirName);\n        while (urls.hasMoreElements()) {\n            URL url = urls.nextElement();\n            // System.out.println(\"URL = \" + url);\n            String file = url.getFile();\n            switch (url.getProtocol()) {\n            case \"file\":\n                // This is the easy case: \"file\" is\n                // the full path to the classpath directory\n                File dir = new File(file);\n                for (File f : dir.listFiles()) {\n                    list.add(packageAsDirName + \"/\" + f.getName());\n                }\n                break;\n            case \"jar\":\n                // This is the harder case; \"file\" is of the form\n                // \"jar:/home/ian/bleah/darwinsys.jar!com/darwinsys/io\"\n                // for some jar file that contains at least one class from\n                // the given package.\n                int colon = file.indexOf(':');\n                int bang = file.indexOf('!');\n                String jarFileName = file.substring(colon + 1, bang);\n                JarFile jarFile = new JarFile(jarFileName);\n                Enumeration<JarEntry> entries = jarFile.entries();\n                while (entries.hasMoreElements()) {\n                    JarEntry e = entries.nextElement();\n                    String jarEntryName = e.getName();\n                    if (!jarEntryName.endsWith(\"/\") &&\n                        jarEntryName.startsWith(packageAsDirName)) {\n                        list.add(jarEntryName);\n                    }\n                }\n                break;\n            default:\n                throw new IllegalStateException(\n                \"Dunno what to do with URL \" + url);\n            }\n        }\n        return list.toArray(new String[] {});\n    }\n\n    public static void main(String[] args) throws IOException {\n        String[] names = getPackageContent(\"com.darwinsys.io\");\n        for (String name : names) {\n            System.out.println(name);\n        }\n        System.out.println(\"Done\");\n    }\n}\n```", "```java\npublic class MyClass {\n\n    public boolean equals(MyClass object2) {\n        // compare, return boolean\n    }\n}\n```", "```java\npublic class MyClass {\n\n    @Override\n    public boolean equals(MyClass object2) {\n        // compare, return boolean\n    }\n}\n```", "```java\n@Entity\npublic class Person {\n\n    int id;\n    protected String firstName;\n    protected String lastName;\n\n    public Person() {\n        // required by JPA; must code it since we need 2-arg form.\n    }\n\n    public Person(String firstName, String lastName) {\n        this.firstName = firstName;\n        this.lastName = lastName;\n    }\n\n    @Id @GeneratedValue(strategy=GenerationType.AUTO, generator=\"my_poid_gen\")\n    public int getId() {\n        return id;\n    }\n\n    public void setId(int id) {\n        this.id = id;\n    }\n\n    public String getFirstName() {\n        return firstName;\n    }\n\n    public void setFirstName(String firstName) {\n        this.firstName = firstName;\n    }\n\n    @Column(name=\"surname\")\n    public String getLastName() {\n        return lastName;\n    }\n\n    public void setLastName(String lastName) {\n        this.lastName = lastName;\n    }\n\n    @Override\n    public String toString() {\n        return getFullName();\n    }\n\n    @Transient /* synthetic: cannot be used in JPA queries. */\n    public String getFullName() {\n        StringBuilder sb = new StringBuilder();\n        if (firstName != null)\n            sb.append(firstName).append(' ');\n        if (lastName != null)\n            sb.append(lastName);\n        if (sb.length() == 0)\n            sb.append(\"NO NAME\");\n        return sb.toString();\n    }\n}\n```", "```java\npackage lang;\n\npublic @interface MyToyAnnotation {\n}\n```", "```java\n$ javap lang.MyToyAnnotation\nCompiled from \"MyToyAnnotation.java\"\npublic interface lang.MyToyAnnotation extends java.lang.annotation.Annotation {\n}\n$\n```", "```java\n$ javap java.lang.annotation.Annotation\nCompiled from \"Annotation.java\"\npublic interface java.lang.annotation.Annotation {\n  public abstract boolean equals(java.lang.Object);\n  public abstract int hashCode();\n  public abstract java.lang.String toString();\n  public abstract java.lang.Class<? extends java.lang.annotation.Annotation>\n    annotationType();\n}\n$\n```", "```java\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface MyAnnotation {\n}\n```", "```java\n/**\n * A sample annotation for types (classes, interfaces);\n * it will be available at run time.\n */\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface AnnotationDemo {\n    public boolean fancy() default false;\n    public int order() default 42;\n}\n\n/** A simple example of using the annotation */\n@AnnotationDemo(fancy=true)\n@Resource(name=\"Dumbledore\")\nclass FancyClassJustToShowAnnotation {\n\n    /** Print out the annotations attached to this class */\n    public static void main(String[] args) {\n        Class<?> c = FancyClassJustToShowAnnotation.class;\n        System.out.println(\"Class \" + c.getName() + \" has these annotations:\");\n        for (Annotation a : c.getAnnotations()) {\n            if (a instanceof AnnotationDemo) {\n                AnnotationDemo ad = (AnnotationDemo)a;\n                System.out.println(\"\\t\" +a +\n                    \" with fancy=\" + ad.fancy() +\n                    \" and order \" + ad.order());\n            } else {\n                System.out.println(\"\\tSomebody else's annotation: \" + a);\n            }\n        }\n    }\n}\n```", "```java\n/** Discover \"plugins\" or other add-in classes via Reflection using Annotations */\npublic class PluginsViaAnnotations {\n\n    /**\n * Find all classes in the given package which have the given\n * class-level annotation class.\n */\n    public static List<Class<?>> findAnnotatedClasses(String packageName,\n        Class<? extends Annotation> annotationClass) throws Exception {\n\n        List<Class<?>> ret = new ArrayList<>();\n        String[] clazzNames = ClassesInPackage.getPackageContent(packageName);\n        for (String clazzName : clazzNames) {\n            if (!clazzName.endsWith(\".class\")) {\n                continue;\n            }\n            clazzName = clazzName.replace('/', '.').replace(\".class\", \"\");\n            Class<?> c = null;\n            try {\n                c = Class.forName(clazzName);\n            } catch (ClassNotFoundException ex) {\n                System.err.println(\"Weird: class \" + clazzName +\n                    \" reported in package but gave CNFE: \" + ex);\n                continue;\n            }\n            if (c.isAnnotationPresent(annotationClass) &&\n                    !ret.contains(c))\n                    ret.add(c);\n\n        }\n        return ret;\n    }\n```", "```java\n    /**\n * Find all classes in the given package which have the given\n * method-level annotation class on at least one method.\n */\n    public static List<Class<?>> findClassesWithAnnotatedMethods(String packageName,\n            Class<? extends Annotation> methodAnnotationClass) throws Exception {\n        List<Class<?>> ret = new ArrayList<>();\n        String[] clazzNames = ClassesInPackage.getPackageContent(packageName);\n        for (String clazzName : clazzNames) {\n            if (!clazzName.endsWith(\".class\")) {\n                continue;\n            }\n            clazzName = clazzName.replace('/', '.').replace(\".class\", \"\");\n            Class<?> c = null;\n            try {\n                c = Class.forName(clazzName);\n                // System.out.println(\"Loaded \" + c);\n            } catch (ClassNotFoundException ex) {\n                System.err.println(\"Weird: class \" + clazzName +\n                    \" reported in package but gave CNFE: \" + ex);\n                continue;\n            }\n            for (Method m : c.getDeclaredMethods()) {\n                // System.out.printf(\"Class %s Method: %s\\n\",\n                //     c.getSimpleName(), m.getName());\n                if (m.isAnnotationPresent(methodAnnotationClass) &&\n                        !ret.contains(c)) {\n                    ret.add(c);\n                }\n            }\n        }\n        return ret;\n    }\n```", "```java\npublic class CrossRef extends APIFormatter {\n\n    /** Simple main program, construct self, process each .ZIP file\n * found in CLASSPATH or in argv.\n */\n    public static void main(String[] argv) throws IOException {\n        CrossRef xref = new CrossRef();\n        xref.doArgs(argv);\n    }\n\n    /**\n * Print the fields and methods of one class.\n */\n    protected void doClass(Class<?> c) {\n        startClass(c);\n        try {\n            Field[] fields = c.getDeclaredFields();\n            Arrays.sort(fields, new Comparator<Field>() {\n                public int compare(Field o1, Field o2) {\n                    return o1.getName().compareTo(o2.getName());\n                }\n            });\n            for (int i = 0; i < fields.length; i++) {\n                Field field = (Field)fields[i];\n                if (!Modifier.isPrivate(field.getModifiers()))\n                    putField(field, c);\n                // else System.err.println(\"private field ignored: \" + field);\n            }\n\n            Method methods[] = c.getDeclaredMethods();\n            Arrays.sort(methods, new Comparator<Method>() {\n                public int compare(Method o1, Method o2) {\n                    return o1.getName().compareTo(o2.getName());\n                }\n            });\n            for (int i = 0; i < methods.length; i++) {\n                if (!Modifier.isPrivate(methods[i].getModifiers()))\n                    putMethod(methods[i], c);\n                // else System.err.println(\"pvt: \" + methods[i]);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        endClass();\n    }\n\n    /** put a Field's information to the standard output.  */\n    protected void putField(Field fld, Class<?> c) {\n        println(fld.getName() + \" field \" + c.getName() + \" \");\n    }\n\n    /** put a Method's information to the standard output.  */\n    protected void putMethod(Method method, Class<?> c) {\n        String methName = method.getName();\n        println(methName + \" method \" + c.getName() + \" \");\n    }\n\n    /** Print the start of a class. Unused in this version,\n * designed to be overridden */\n    protected void startClass(Class<?> c) {\n    }\n\n    /** Print the end of a class. Unused in this version,\n * designed to be overridden */\n    protected void endClass() {\n    }\n\n    /** Convenience routine, short for System.out.println */\n    protected final void println(String s) {\n        System.out.println(s);\n    }\n}\n```", "```java\npublic class CrossRefXML extends CrossRef {\n\n    public static void main(String[] argv) throws IOException {\n        CrossRef xref = new CrossRefXML();\n        xref.doArgs(argv);\n    }\n\n    /** Print the start of a class.\n */\n    protected void startClass(Class<?> c) {\n        println(\"<class><classname>\" + c.getName() + \"</classname>\");\n    }\n\n    protected void putField(Field fld, Class<?> c) {\n        println(\"<field>\" + fld + \"</field>\");\n    }\n\n    /** put a Method's information to the standard output.\n * Marked protected so you can override it (hint, hint).\n */\n    protected void putMethod(Method method, Class<?> c) {\n        println(\"<method>\" + method + \"</method>\");\n    }\n\n    /** Print the end of a class.\n */\n    protected void endClass() {\n        println(\"</class>\");\n    }\n}\n```"]