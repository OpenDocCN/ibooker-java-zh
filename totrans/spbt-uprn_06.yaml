- en: Chapter 6\. Really Digging into Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Data can be a complex topic, with so much to consider: its structure and relationships
    with other data; handling, storage, and retrieval options; various applicable
    standards; database providers and mechanisms; and more. Data may be the most complex
    aspect of development to which devs are exposed so early in their careers and
    when learning a new toolchain.'
  prefs: []
  type: TYPE_NORMAL
- en: The reason this is often the case is that without data in some form, nearly
    all applications are meaningless. Very few apps provide any value at all without
    storing, retrieving, or correlating data.
  prefs: []
  type: TYPE_NORMAL
- en: 'As something that forms the underpinning for nearly all application value,
    *data* has attracted a great deal of innovation from database providers and platform
    vendors. But in many cases, complexity remains: it is a topic with great depth
    and breadth, after all.'
  prefs: []
  type: TYPE_NORMAL
- en: Enter Spring Data. Spring Data’s stated [mission](https://spring.io/projects/spring-data)
    is “to provide a familiar and consistent, Spring-based programming model for data
    access while still retaining the special traits of the underlying data store.”
    Regardless of database engine or platform, Spring Data’s goal is to make the developer’s
    access to data as simple and as powerful as humanly possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter demonstrates how to define data storage and retrieval using various
    industry standards and leading database engines and the Spring Data projects and
    facilities that enable their use in the most streamlined and powerful ways possible:
    via Spring Boot.'
  prefs: []
  type: TYPE_NORMAL
- en: Defining Entities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In nearly every case when dealing with data, some form of domain entity is involved.
    Whether it’s an invoice, an automobile, or something else entirely, data is rarely
    dealt with as a collection of unrelated properties. Inevitably, what we consider
    useful data are cohesive pools of elements that together constitute a meaningful
    whole. An automobile—in data or in real life—is really only a useful concept if
    it’s a unique, fully attributed thing.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Data provides several different mechanisms and data access options for
    Spring Boot applications to use, at a variety of abstraction levels. Regardless
    of which level of abstraction a developer settles on for any given use case, the
    first step is defining any domain classes that will be used to handle applicable
    data.
  prefs: []
  type: TYPE_NORMAL
- en: 'While a full exploration of Domain-Driven Design (DDD) is beyond the scope
    of this book, I’ll use the concepts as a foundation for defining applicable domain
    classes for the example applications built in this and subsequent chapters. For
    a full exploration of DDD I would refer the reader to Eric Evans’s seminal work
    on the topic, [*Domain-Driven Design: Tackling Complexity in the Heart of Software*](https://oreil.ly/DomainDrivDes).'
  prefs: []
  type: TYPE_NORMAL
- en: By way of a cursory explanation, a *domain class* encapsulates a primary domain
    entity that has relevance and significance independently of other data. This doesn’t
    mean it doesn’t relate to other domain entities, only that it can stand alone
    and make sense as a unit, even when unassociated with other entities.
  prefs: []
  type: TYPE_NORMAL
- en: To create a domain class in Spring using Java, you can create a class with member
    variables, applicable constructors, accessors/mutators, and `equals()`/`hashCode()`
    /`toString()` methods (and more). You can also employ Lombok with Java or data
    classes in Kotlin to create domain classes for data representation, storage, and
    retrieval. I do all of these things in this chapter to demonstrate just how easy
    it is to work with domains using Spring Boot and Spring Data. It’s great to have
    options.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the examples in this chapter, once I’ve defined a domain class, I’ll decide
    on a database and level of abstraction based on goals for data usage and exposed
    APIs for or by the database provider. Within the Spring ecosystem, this typically
    boils down to one of two options, with minor variations: templates or repositories.'
  prefs: []
  type: TYPE_NORMAL
- en: Template Support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to provide a set of “just high enough” coherent abstractions, Spring
    Data defines an interface of type `Operations` for most of its various data sources.
    This `Operations` interface—examples include `MongoOperations`, `RedisOperations`,
    and `CassandraOperations`—specifies a foundational set of operations that can
    be used directly for greatest flexibility or upon which higher-level abstractions
    can be constructed. `Template` classes provide direct implementations of `Operations`
    interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Templates can be thought of as a Service Provider Interface (SPI) of sorts—directly
    usable and extremely capable but with many repetitive steps required each time
    they’re used to accomplish the more common use cases developers face. For those
    scenarios in which data access follows common patterns, repositories may be a
    better choice. And the best part is that repositories build upon templates, so
    you lose nothing by stepping up to the higher abstraction.
  prefs: []
  type: TYPE_NORMAL
- en: Repository Support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Data defines the `Repository` interface from which all other types of
    Spring Data repository interfaces derive. Examples include `JPARepository` and
    `MongoRepository` (providing JPA-specific and Mongo-specific capabilities, respectively)
    and more versatile interfaces like `CrudRepository`, `ReactiveCrudRepository`,
    and `PagingAndSortingRepository`. These various repository interfaces specify
    useful higher-level operations like `findAll()`, `findById()`, `count()`, `delete()`,
    `deleteAll()`, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Repositories are defined for both blocking and nonblocking interactions. Additionally,
    creating queries using convention over configuration, and even literal query statements,
    is supported by Spring Data’s repositories. Using Spring Data’s repositories with
    Spring Boot makes building complex database interactions an almost trivial exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'I demonstrate all of these capabilities at some point in this book. In this
    chapter, I plan to cover the key elements across a number of database options
    by incorporating various implementation details: Lombok, Kotlin, and more. In
    that way, I provide a broad and stable base upon which to build in subsequent
    chapters.'
  prefs: []
  type: TYPE_NORMAL
- en: '@Before'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As much as I love coffee and rely on it to drive my application development,
    in order to better explore the concepts covered throughout the rest of this book,
    I felt a more versatile domain was in order. As both a software developer and
    pilot, I see the increasingly complex and data-driven world of aviation as offering
    no shortage of interesting scenarios (and fascinating data) to explore as we delve
    deeper into Spring Boot’s facility in numerous use cases.
  prefs: []
  type: TYPE_NORMAL
- en: To deal with data, we must *have* data. I’ve developed a small Spring Boot RESTful
    web service called `PlaneFinder` (available within this book’s code repositories)
    to serve as an API gateway that I can poll for current aircraft and positions
    within range of a small device on my desk. This device receives Automatic Dependent
    Surveillance—Broadcast (ADS-B) data from airplanes within a certain distance and
    shares them with a service online, [PlaneFinder.net](https://planefinder.net).
    It also exposes an HTTP API that my gateway service consumes, simplifies, and
    exposes to other downstream services like the ones in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: More details throughout, but for now, let’s create some database-connected services.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Template-Based Service Using Redis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Redis is a database that is typically used as an in-memory datastore for sharing
    state among instances of a service, caching, and brokering messages between services.
    Like all major databases, Redis does more, but the focus for this chapter is simply
    using Redis to store and retrieve from memory aircraft information our service
    obtains from the `PlaneFinder` service referred to previously.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing the Project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To begin, we return to the Spring Initializr. From there, I choose the following
    options:'
  prefs: []
  type: TYPE_NORMAL
- en: Maven project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Current production version of Spring Boot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Packaging: Jar'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Java: 11'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And for dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: Spring Reactive Web (`spring-boot-starter-webflux`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Data Redis (Access+Driver) (`spring-boot-starter-data-redis`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lombok (`lombok`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, I generate the project and save it locally, unzip it, and open it in the
    IDE.
  prefs: []
  type: TYPE_NORMAL
- en: Developing the Redis Service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s begin with the domain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Currently, the `PlaneFinder` API gateway exposes a single REST endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Any (local) service can query this endpoint and receive a JSON response of
    all aircraft within range of the receiver in the following format (with representative
    data):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Defining the domain class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to ingest and manipulate these aircraft reports, I create an `Aircraft`
    class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This domain class includes a few helpful annotations that streamline the necessary
    code and/or increase its flexibility. Class-level annotations include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@Data`:: Instructs Lombok to create getter, setter, `equals()`, `hashCode()`,
    and `toString()` methods, creating a so-called data class `@NoArgsConstructor`::
    Instructs Lombok to create a zero-parameter constructor, thus requiring no arguments
    `@AllArgsConstructor`:: Instructs Lombok to create a constructor with a parameter
    for each member variable, requiring an argument be provided for all `@JsonIgnoreProperties(ignoreUnknown
    = true)`:: Informs Jackson deserialization mechanisms to ignore fields within
    JSON responses for which there is no corresponding member variable'
  prefs: []
  type: TYPE_NORMAL
- en: 'Field-level annotations provide more specific guidance where appropriate. Examples
    of field-level annotations include the two used for this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@Id`:: Designates the annotated member variable as holding the unique identifier
    for a database entry/record `@JsonProperty("vert_rate")`:: Connects a member variable
    with its differently named JSON field'
  prefs: []
  type: TYPE_NORMAL
- en: 'You may be wondering why I created explicit accesssors and mutators for the
    three member variables of type `Instant` if the `@Data` annotation results in
    the creation of getter and setter methods for all member variables. In the case
    of these three, the JSON value must be parsed and transformed from a `String`
    to a complex data type by calling a method: `Instant::parse`. If that value is
    entirely absent (null), different logic must be performed to avoid passing a null
    to `parse()` and to assign some meaningful substitute value to the corresponding
    member variable via setter. Additionally, serialization of `Instant` values is
    best done by conversion to a `String`—thus the explicit getter methods.'
  prefs: []
  type: TYPE_NORMAL
- en: With a domain class defined, it’s time to create and configure the mechanism
    for accessing a Redis database.
  prefs: []
  type: TYPE_NORMAL
- en: Adding template support
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Spring Boot provides basic `RedisTemplate` capabilities via autoconfiguration,
    and if you only need to manipulate `String` values using Redis, very little work
    (or code) is required from you. Dealing with complex domain objects necessitates
    a bit more configuration but not too much.
  prefs: []
  type: TYPE_NORMAL
- en: The `RedisTemplate` class extends the `RedisAccessor` class and implements the
    `RedisOperations` interface. Of particular interest for this application is `RedisOperations`,
    as it specifies the functionality needed to interact with Redis.
  prefs: []
  type: TYPE_NORMAL
- en: As developers, we should prefer to write code against interfaces, not implementations.
    Doing so allows one to provide the most appropriate concrete implementation for
    the task at hand without code/API changes or excessive and unnecessary violations
    of the DRY (Don’t Repeat Yourself) principle; as long as the interface is fully
    implemented, any concrete implementation will function just as well as any other.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code listing, I create a bean of type `RedisOperations`, returning
    a `RedisTemplate` as the bean’s concrete implementation. I perform the following
    steps in order to configure it properly to accommodate inbound `Aircraft`:'
  prefs: []
  type: TYPE_NORMAL
- en: I create a `Serializer` to be used when converting between objects and JSON
    records. Since Jackson is used for marshalling/unmarshalling (serialization/deserialization)
    of JSON values and is already present in Spring Boot web applications, I create
    a `Jackson2JsonRedisSerializer` for objects of type `Aircraft`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: I create a `RedisTemplate` that accepts keys of type `String` and values of
    type `Aircraft` to accommodate the inbound `Aircraft` with `String` IDs. . I plug
    the `RedisConnectionFactory` bean that was helpfully and automatically autowired
    into this bean-creation method’s sole parameter—`RedisConnectionFactory factory`—into
    the `template` object so it can create and retrieve a connection to the Redis
    database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: I supply the `Jackson2JsonRedisSerializer<Aircraft>` serializer to the `template`
    object in order to be used as the default serializer. `RedisTemplate` has a number
    of serializers that are assigned the default serializer in the absence of specific
    assignment, a useful touch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: I create and specify a different serializer to be used for keys so that the
    template doesn’t attempt to use the default serializer—which expects objects of
    type `Aircraft`—to convert to/from key values of type `String`. A `StringRedisSerializer`
    does the trick nicely.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, I return the created and configured `RedisTemplate` as the bean to
    use when some implementation of a `RedisOperations` bean is requested within the
    application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Bringing it all together
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that the underlying wiring is in place for accessing the Redis database
    using a template, it’s time for the payoff. As shown in the code listing that
    follows, I create a Spring Boot `@Component` class to poll the `PlaneFinder` endpoint
    and handle the resultant `Aircraft` records it receives using Redis template support.
  prefs: []
  type: TYPE_NORMAL
- en: To initialize the `PlaneFinderPoller` bean and prepare it for action, I create
    a `WebClient` object and assign it to a member variable, pointing it to the destination
    endpoint exposed by the external `PlaneFinder` service. `PlaneFinder` currently
    runs on my local machine and listens on port 7634.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `PlaneFinderPoller` bean requires access to two other beans to perform
    its duties: a `RedisConnectionFactory` (supplied by Boot’s autoconfiguration due
    to Redis being an app dependency) and an implementation of `RedisOperations`,
    the `RedisTemplate` created earlier. Both are assigned to properly defined member
    variables via constructor injection (autowired):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, I create the method that does the heavy lifting. In order to have it
    poll on a fixed schedule, I leverage the `@EnableScheduling` annotation I previously
    placed at the class level and annotate the `pollPlanes()` method I create with
    `@Scheduled`, supplying a parameter of `fixedDelay=1000` to specify a polling
    frequency of once per 1,000 ms—once per second. The rest of the method consists
    of only three declarative statements: one to clear any previously saved `Aircraft`,
    one to retrieve and save current positions, and one to report the results of the
    latest capture.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the first task I use the autowired `ConnectionFactory` to obtain a connection
    to the database, and via that connection, I execute the server command to clear
    all keys present: `flushDb()`.'
  prefs: []
  type: TYPE_NORMAL
- en: The second statement uses the `WebClient` to call the `PlaneFinder` service
    and retrieve a collection of aircraft within range, along with their current position
    information. The response body is converted to a `Flux` of `Aircraft` objects,
    filtered to remove any `Aircraft` that don’t include registration numbers, converted
    to a `Stream` of `Aircraft`, and saved to the Redis database. The save is performed
    on each valid `Aircraft` by setting a key/value pair to the `Aircraft` registration
    number and the `Aircraft` object itself, respectively, using Redis’s operations
    tailored to manipulating data values.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: A `Flux` is a reactive type covered in upcoming chapters, but for now, simply
    think of it as a collection of objects delivered without blocking.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final statement in `pollPlanes()` again leverages a couple of Redis’s defined
    value operations to retrieve all keys (via the wildcard parameter *) and, using
    each key, to retrieve each corresponding `Aircraft` value, which is then printed.
    Here is the `pollPlanes()` method in finished form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The final version (for now) of the `PlaneFinderPoller` class is shown in the
    following listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: With polling mechanisms fully fleshed out, let’s run the application and see
    the results.
  prefs: []
  type: TYPE_NORMAL
- en: The results
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With the `PlaneFinder` service already running on my machine, I start the *sbur-redis*
    application to obtain, store and retrieve in Redis, and display the results of
    each poll of `PlaneFinder`. What follows is an example of the results, edited
    for brevity and formatted a bit for readability:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Working with databases via Spring Data’s template support provides a lower-level
    API with excellent flexibility. If you’re looking for minimum friction and maximum
    productivity and repeatability, however, repository support is the better choice.
    Next, I show how to convert from using templates to interact with Redis to using
    a Spring Data repository. It’s great to have options.
  prefs: []
  type: TYPE_NORMAL
- en: Converting from Template to Repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we can use a repository, it’s necessary to define one, and Spring Boot’s
    autoconfiguration helps considerably with this. I create a repository interface
    as follows, extending Spring Data’s `CrudRepository` and providing the type of
    object to store along with its key: `Aircraft` and `Long`, in this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As explained in [Chapter 4](ch04.xhtml#sbur-04), Spring Boot detects the Redis
    database driver on the application classpath and notes that we’re extending a
    Spring Data repository interface, then creates a database proxy automatically
    with no additional code required to instantiate it. Just like that, the application
    has access to an `AircraftRepository` bean. Let’s plug it in and put it to use.
  prefs: []
  type: TYPE_NORMAL
- en: Revisiting the `PlaneFinderPoller` class, I can now replace the lower-level
    references to and operations using `RedisOperations` and replace them with `AircraftRepository`.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, I remove the `RedisOperations` member variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Then replace it with one for the `AircraftRepository` to autowire:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, I replace the `RedisOperations` bean autowired via constructor injection
    with the `AircraftRepository` and the assignment within the constructor to the
    applicable member variable so that the constructor ends up like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The next step is to refactor the `pollPlanes()` method to replace template-based
    operations with repository-based ops.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changing the last line of the first statement is a simple matter. Using a method
    reference further simplifies the lambda:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'And the second one reduces even more, again including use of a method reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The newly repository-enabled `PlaneFinderPoller` now consists of the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'With no further need of a bean implementing the `RedisOperations` interface,
    I can now delete its `@Bean` definition from the main application class, leaving
    `SburRedisApplication`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Only one small task and a very nice code reduction remain to fully enable Redis
    repository support in our application. I add the `@RedisHash` annotation to the
    `Aircraft` entity to indicate that `Aircraft` is an aggregate root to be stored
    in a Redis hash, performing a function similar to what `@Entity` annotation does
    for JPA objects. I then remove the explicit accessors and mutators previously
    required for the `Instant`-typed member variables, as the converters in Spring
    Data’s repository support handle complex type conversions with ease. The newly
    streamlined `Aircraft` class now looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'With the latest changes in place, restarting the service results in output
    indistinguishable from the template-based approach but with much less code and
    inherent ceremony required. An example of results follows, again edited for brevity
    and formatted for readability:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: If you need direct access to the lower-level capabilities exposed by Spring
    Data templates, template-based database support is indispensable. But for nearly
    all common use cases, when Spring Data offers repository-based access for a target
    database, it’s best to begin—and in all likelihood remain—there.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Repository-Based Service Using the Java Persistence API (JPA)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the Spring ecosystem’s strengths is consistency: once you learn how
    to accomplish something, the same approach can be applied to drive successful
    outcomes with different components. Database access is a case in point.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring Boot and Spring Data provide repository support for a number of different
    databases: JPA-compliant databases, numerous NoSQL datastores of varying types,
    and in-memory and/or persistent stores. Spring smooths the bumps a developer runs
    into when transitioning between databases, whether for a single application or
    throughout a vast system of them.'
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate some of the flexible options at your disposal when creating data-aware
    Spring Boot applications, I highlight a few different approaches supported by
    Spring Boot in each of the following sections, while relying on Boot (and Spring
    Data) to streamline the database portion of the different, but similar, services.
    First up is JPA, and for this example I use Lombok throughout to reduce code and
    increase readability.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing the Project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once again we return to the Spring Initializr. This time, I choose the following
    options:'
  prefs: []
  type: TYPE_NORMAL
- en: Maven project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Current production version of Spring Boot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Packaging: Jar'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Java: 11'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And for dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: Spring Reactive Web (`spring-boot-starter-webflux`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Data JPA (`spring-boot-starter-data-jpa`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MySQL Driver (`mysql-connector-java`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lombok (`lombok`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, I generate the project and save it locally, unzip it, and open it in the
    IDE.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As with the earlier Redis project and most other examples in this chapter, each
    data-aware service must be able to access a running database. Please refer to
    this book’s associated code repositories for Docker scripts to create and run
    suitable containerized database engines.
  prefs: []
  type: TYPE_NORMAL
- en: Developing the JPA (MySQL) Service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Considering both [Chapter 4](ch04.xhtml#sbur-04)’s example built using JPA and
    the H2 database and the previous Redis repository-based example, the JPA-based
    service using MariaDB/MySQL clearly demonstrates the way in which Spring’s consistency
    amplifies developer productivity.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the domain class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As with all of this chapter’s projects, I create an `Aircraft` domain class
    to serve as the primary (data) focus. Each different project will have slight
    variations around a common theme pointed out along the way. Here is the JPA-centric
    `Aircraft` domain class structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: There are a few particulars of note with regard to this version of `Aircraft`
    versus prior versions and those to come.
  prefs: []
  type: TYPE_NORMAL
- en: First, the `@Entity`, `@Id`, and `@GeneratedValue` annotations are all imported
    from the `javax.persistence` package. You may remember that in the Redis version
    (and some others), `@Id` comes from `org.springframework.data.annotation`.
  prefs: []
  type: TYPE_NORMAL
- en: Class-level annotations closely parallel those used in the example using Redis
    repository support, with the replacement of `@RedisHash` with a JPA `@Entity`
    annotation. To revisit the other (unchanged) annotations shown, please refer to
    the aforementioned earlier section.
  prefs: []
  type: TYPE_NORMAL
- en: Field-level annotations are also similar, with the addition of `@GeneratedValue`.
    As its name implies, `@GeneratedValue` indicates that the identifier will be generated
    by the underlying database engine. The developer can—if desired or necessary—provide
    additional guidance for key generation, but for our purposes, the annotation itself
    is sufficient.
  prefs: []
  type: TYPE_NORMAL
- en: As with Spring Data’s repository support for Redis, there is no need for explicit
    accessors/mutators for the member variables of type `Instant`, leaving (once again)
    a very svelte `Aircraft` domain class.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the repository interface
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, I define the required repository interface, extending Spring Data’s `CrudRepository`
    and providing the type of object to store and its key: `Aircraft` and `Long`,
    in this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Both Redis and JPA databases function well with unique key values/identifiers
    of type `Long`, so this is identical to the one defined in the earlier Redis example.
  prefs: []
  type: TYPE_NORMAL
- en: Bringing it all together
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now to create the `PlaneFinder` polling component and configure it for database
    access.
  prefs: []
  type: TYPE_NORMAL
- en: Polling PlaneFinder
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Once again I create a Spring Boot `@Component` class to poll for current position
    data and handle the resultant `Aircraft` records it receives.
  prefs: []
  type: TYPE_NORMAL
- en: Like the earlier example, I create a `WebClient` object and assign it to a member
    variable, pointing it to the destination endpoint exposed by the `PlaneFinder`
    service on port 7634.
  prefs: []
  type: TYPE_NORMAL
- en: As you should expect from a sibling repository implementation, the code is quite
    similar to the Redis repository endstate. I demonstrate a couple of differences
    in approach for this example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rather than manually creating a constructor via which to receive the autowired
    `AircraftRepository` bean, I instruct Lombok—via its compile-time code generator—to
    provide a constructor with any required member variables. Lombok determines which
    arguments are required via two annotations: `@RequiredArgsConstructor` on the
    class and `@NonNull` on the member variable(s) designated as requiring initialization.
    By annotating the `AircraftRepository` member variable as an `@NonNull` property,
    Lombok creates a constructor with an `AircraftRepository` as a parameter; Spring
    Boot then dutifully autowires the existing repository bean for use within the
    `PlaneFinderPoller` bean.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The wisdom of deleting all stored entries in a database each time a poll is
    conducted depends heavily on requirements, polling frequency, and storage mechanism
    involved. For example, the costs involved in clearing an in-memory database before
    each poll is quite different from deleting all records in a cloud-hosted database’s
    table. Frequent polling also increases associated costs. Alternatives exist; please
    choose wisely.
  prefs: []
  type: TYPE_NORMAL
- en: 'To revisit the details of the remaining code in `PlaneFinderPoller`, please
    review the corresponding section under Redis repository support. Refactored to
    take full advantage of Spring Data JPA support, the complete code for `PlaneFinderPoller`
    is shown in the following listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Connecting to MariaDB/MySQL
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Spring Boot autoconfigures the application’s environment using all information
    available at runtime; that’s one of the key enablers of its unrivaled flexibility.
    Since there are many JPA-compliant databases supported by Spring Boot and Spring
    Data, we need to provide a few key bits of information for Boot to use to seamlessly
    connect to the database of our choosing for this particular application. For this
    service running in my environment, these properties include:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Both the database name and the database username are “mark” in the example above.
    Replace datasource, username, and password values with those specific to your
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: The results
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With the `PlaneFinder` service still running on my machine, I start the *sbur-jpa*
    service to obtain, store and retrieve (in MariaDB), and display the results of
    each polling of `PlaneFinder`. An example of the results follows, edited for brevity
    and formatted for readability:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The service works as expected to poll, capture, and display aircraft positions.
  prefs: []
  type: TYPE_NORMAL
- en: Loading Data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter’s focus thus far has been how to interact with a database when
    data flows into the application. What happens if data exists—sample, test, or
    actual seed data—that must be persisted?
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring Boot has a few different mechanisms to initialize and populate a database.
    I cover what I consider to be the two most useful approaches here:'
  prefs: []
  type: TYPE_NORMAL
- en: Using Data Definition Language (DDL) and Data Manipulation Language (DML) scripts
    to initialize and populate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allowing Boot (via Hibernate) to automatically create the table structure from
    defined `@Entity` class(es) and populating via a repository bean
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each approach to data definition and population has its pros and cons.
  prefs: []
  type: TYPE_NORMAL
- en: API- or database-specific scripts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Spring Boot checks the usual root classpath locations for files that fit the
    following naming format:'
  prefs: []
  type: TYPE_NORMAL
- en: '*schema.sql*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*data.sql*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*schema-${platform}.sql*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*data-${platform}.sql*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last two filenames are matched to the developer-assigned application property
    `spring.datasource.platform`. Valid values include `h2`, `mysql`, `postgresql`,
    and other Spring Data JPA databases, and using a combination of the `spring.datasource.platform`
    property and related `.sql` files enables a developer to fully leverage syntax
    specific to that particular database.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and populating with scripts
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To leverage scripts to create and populate a MariaDB/MySQL database in the
    most straightforward way, I create two files under the `resources` directory of
    the *sbur-jpa* project: *schema-mysql.sql* and *data-mysql.sql*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the `aircraft` table schema, I add the following DDL to *schema-mysql.sql*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'To populate the `aircraft` table with a single sample row, I add the following
    DML to *data-mysql.sql*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, Boot automatically creates table structures from any classes annotated
    with `@Entity`. It’s simple to override this behavior with the following property
    settings, shown here from the app’s *application.properties* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Setting `spring.datasource.initialization-mode` to “always” indicates that the
    app is expecting to use an external (nonembedded) database and should initialize
    it each time the application executes. Setting `spring.jpa.hibernate.ddl-auto`
    to “none” disables Spring Boot’s automatic table creation from `@Entity` classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'To verify that the preceding scripts are being used to create and populate
    the `aircraft` table, I visit the `PlaneFinderPoller` class and do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Comment out the `repository.deleteAll();` statement in `pollPlanes()`. This
    is necessary to avoid deleting the record added via *data-mysql.sql*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comment out the `client.get()...` statement, also in `pollPlanes()`. This results
    in no additional records being retrieved and created from polling the external
    `PlaneFinder` service for easier verification.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Restarting the *sbur-jpa* service now results in the following output (`id`
    fields may differ), edited for brevity and formatted for clarity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The only record saved is the one specified in *data-mysql.sql*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like all approaches to anything, there are pros and cons to this method of
    table creation and population. Upsides include:'
  prefs: []
  type: TYPE_NORMAL
- en: The ability to directly use SQL scripts, both DDL and DML, leveraging existing
    scripts and/or SQL expertise
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access to SQL syntax specific to the chosen database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Downsides aren’t particularly serious but should be recognized:'
  prefs: []
  type: TYPE_NORMAL
- en: Using SQL files is obviously specific to SQL-supporting relational databases.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scripts can rely on SQL syntax for a particular database, which can require
    editing if the choice of underlying database changes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some (two) application properties must be set to override default Boot behavior.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Populating the database using the application’s repository
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There is another way, one that I find particularly powerful and more flexible:
    using Boot’s default behavior to create the table structures (if they don’t already
    exist) and the application’s repository support to populate sample data.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To restore Spring Boot’s default behavior of creating the `aircraft` table
    from the `Aircraft` JPA `@Entity` class, I comment out the two properties just
    added to *application.properties*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: With these properties no longer being defined, Spring Boot will not search for
    and execute *data-mysql.sql* or other data initialization scripts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, I create a class with a purpose-descriptive name like `DataLoader`. I
    add class-level annotations of `@Component` (so Spring creates a `DataLoader`
    bean) and `@AllArgsConstructor` (so Lombok creates a constructor with a parameter
    for each member variable). I then add a single member variable to hold the `AircraftRepository`
    bean Spring Boot will autowire for me via constructor injection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'And a method called `loadData()` to both clear and populate the `aircraft`
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'And that’s it. Really. Restarting the the *sbur-jpa* service now results in
    the output that follows (`id` fields may differ), edited for brevity and formatted
    for clarity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The only record saved is the one defined in the previous `DataLoader` class,
    with one small difference: since the `id` field is generated by the database (as
    specified in the `Aircraft` domain class specification), the provided `id` value
    is replaced by the database engine when the record is saved.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Advantages of this approach are significant:'
  prefs: []
  type: TYPE_NORMAL
- en: Fully database independent.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any code/annotations specific to a particular database are already within the
    app simply to support db access.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easy to disable by simply commenting out the `@Component` annotation on the
    `DataLoader` class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other mechanisms
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These are two powerful and widely used options for database initialization and
    population, but there are other options, including using Hibernate support for
    an *import.sql* file (similar to the JPA approach introduced earlier), using external
    imports, and using FlywayDB, among others. Exploring the numerous other options
    is out of scope for this book and is left as an optional exercise for the reader.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Repository-Based Service Using a NoSQL Document Database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned earlier, there are several ways to further enhance developer productivity
    when creating applications using Spring Boot. One of these is to increase code
    conciseness by using Kotlin as the foundational app language.
  prefs: []
  type: TYPE_NORMAL
- en: An exhaustive exploration of the Kotlin language is well beyond the scope of
    this book, and there are other books that fulfill that role. Fortunately, though,
    while Kotlin definitely differs from Java in numerous meaningful ways, it is similar
    enough to pose no great hardship in adapting to its idioms with a few well-placed
    explanations when things diverge from the “Java way.” I’ll endeavor to provide
    those explanations as I proceed; for background or additional information, please
    refer to Kotlin-specific tomes.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this example, I use MongoDB. Perhaps the best-known document datastore,
    MongoDB is widely used and wildly popular for good reason: it works well and generally
    makes life easier for developers to store, manipulate, and retrieve data in all
    of its varied (and sometimes messy) forms. The team at MongoDB also constantly
    strives to improve their feature set, security, and APIs: MongoDB was one of the
    first databases to offer reactive database drivers, leading the industry in taking
    nonblocking access all the way down to the database level.'
  prefs: []
  type: TYPE_NORMAL
- en: Initializing the Project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you might expect, we return to the Spring Initializr to get started. For
    this project, I choose the following options (also shown in [Figure 6-1](#using_the_spring_boot_initialzr_to_create_a_kotlin_application))—somewhat
    of a departure from prior visits:'
  prefs: []
  type: TYPE_NORMAL
- en: Gradle project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kotlin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Current production version of Spring Boot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Packaging: Jar'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Java: 11'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And for dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: Spring Reactive Web (`spring-boot-starter-webflux`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Data MongoDB (`spring-boot-starter-data-mongodb`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Embedded MongoDB Database (`de.flapdoodle.embed.mongo`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, I generate the project and save it locally, unzip it, and open it in the
    IDE.
  prefs: []
  type: TYPE_NORMAL
- en: '![sbur 0601](Images/sbur_0601.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-1\. Using the Spring Boot Initializr to create a Kotlin application
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'A couple of things of particular note about the options selected: First, I
    chose Gradle for this project’s build system for good reason—simply choosing to
    use Gradle with Kotlin in a Spring Boot project results in the Gradle build file
    using the Kotlin DSL, which is supported by the Gradle team on equal footing with
    the Groovy DSL. Note that the resultant build file is *build.gradle.kts*—the .kts
    extension indicates it is a Kotlin script—rather than the Groovy-based *build.gradle*
    file you may be accustomed to seeing. Maven works perfectly well as a build system
    for Spring Boot + Kotlin applications too, but being an XML-based declarative
    build system, it doesn’t directly use Kotlin or any other language.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Second, I took advantage of the presence of a Spring Boot Starter for an embedded
    MongoDB database for this application. Because an embedded MongoDB instance is
    meant solely for testing, I advise against using it in a production setting; that
    said, it’s a wonderful option for demonstrating how Spring Boot and Spring Data
    work with MongoDB, and from the developer’s perspective, it matches locally deployed
    database capabilities without the additional steps of installing and/or running
    a containerized instance of MongoDB. The only adjustment necessary to use the
    embedded database from (nontest) code is to change a single line in *build.gradle.kts*
    from this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: And with that, we’re ready to create our service.
  prefs: []
  type: TYPE_NORMAL
- en: Developing the MongoDB Service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As with previous examples, the MongoDB-based service offers a very consistent
    approach and experience, even when using Kotlin instead of Java as the language
    foundation.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the domain class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For this project I create a Kotlin `Aircraft` domain class to serve as the
    primary (data) focus. Here is the new `Aircraft` domain class structure with a
    few observations following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The first thing to note is that there are no curly braces to be seen; put succinctly,
    this class has no body. If you’re new to Kotlin, this may seem a bit unusual,
    but in cases where there is nothing to place in a class (or interface) body, curly
    braces add no value. As such, Kotlin doesn’t require them.
  prefs: []
  type: TYPE_NORMAL
- en: The second interesting thing is the many assignments shown between parentheses
    immediately after the classname. What purpose do these serve?
  prefs: []
  type: TYPE_NORMAL
- en: 'A Kotlin class’s primary constructor is often shown this way: in the class
    header, immediately following the classname. Here is an example of the full, formal
    format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: As is often the case in Kotlin, if a pattern is clearly identifiable and repeats
    consistently, it can be condensed. Removing the `constructor` keyword before the
    parameter list leads to no confusion with any other language construct, so it
    is optional.
  prefs: []
  type: TYPE_NORMAL
- en: Within the constructor are parameters. By placing a `var` (for repeatedly assignable
    mutable variables) or `val` (for single-assignment values equivalent to Java’s
    `final` variables) before each parameter, it also becomes a property. A Kotlin
    property is roughly equivalent in function to a Java member variable, its accessor,
    and (if declared with `var`) its mutator combined.
  prefs: []
  type: TYPE_NORMAL
- en: The values with types containing a question mark (?), e.g., `Double?`, indicate
    that the constructor parameter may be omitted. If so, that parameter is assigned
    the default value shown after the equals sign (=).
  prefs: []
  type: TYPE_NORMAL
- en: Kotlin method (including constructor) parameters and properties can also include
    annotations, just like their Java counterparts. `@Id` and `@JsonProperty` perform
    the same functions that they did in earlier Java examples.
  prefs: []
  type: TYPE_NORMAL
- en: Regarding class-level annotations, `@Document` indicates to MongoDB that each
    object of type `Aircraft` will be stored as a document within the database. As
    before, `@JsonIgnoreProperties(ignoreUnknown = true)` simply builds a bit of flexibility
    into the *sbur-mongo* service; if at some point additional fields are added to
    the data feed produced by the upstream `PlaneFinder` service, they will simply
    be ignored and *sbur_mongo* will continue to run without issue.
  prefs: []
  type: TYPE_NORMAL
- en: The final point of note is the word `data` that precedes the class definition.
    It’s a frequent pattern to create domain classes that serve primarily as data
    buckets to be manipulated and/or passed between processes. It’s such a common
    pattern in fact that the capability to create so-called data classes manifests
    itself in several ways; as one example, `@Data` has been a feature of Lombok for
    years.
  prefs: []
  type: TYPE_NORMAL
- en: 'Kotlin rolled this capability into the language itself and added the `data`
    keyword to signal that a data class automatically derives the following from all
    properties declared in the class’s primary constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '`equals()` and `hashCode()` functions (Java has methods; Kotlin has functions)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`toString()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`componentN()` functions, one for each property in the order in which they
    were declared'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`copy()` function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kotlin data classes have certain requirements and limitations, but they are
    reasonable and minimal. For details, please refer to the Kotlin documentation
    for [data classes](https://kotlinlang.org/docs/reference/data-classes.html#data-classes).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: One other change of interest is the type of each aircraft position’s `id` field/property.
    In Redis and JPA, it was a `Long`; but MongoDB uses a `String` for its unique
    document identifier. This is of no real consequence, only something to be aware
    of.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the repository interface
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, I define the required repository interface, extending Spring Data’s `CrudRepository`
    and providing the type of object to store and its unique identifier: `Aircraft`
    and `String`, as mentioned earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two things of interest in this concise interface definition:'
  prefs: []
  type: TYPE_NORMAL
- en: With no actual interface body, no curly braces are required in Kotlin. If your
    IDE added them when you created this interface, you can safely remove them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Kotlin uses the colon (:) contextually to indicate a `val` or `var` type, or
    in this case, to indicate that a class or interface extends or implements another.
    In this particular instance, I define an interface `AircraftRepository`, and it
    extends the `CrudRepository` interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: There is a `MongoRepository` interface that extends both `PagingAndSortingRepository`
    (which extends `CrudRepository`) and `QueryByExampleExecutor` that can be used
    instead of `CrudRepository`, as I do here. But unless the additional capabilities
    are required, it is a good practice and habit to write to the highest-level interface
    that satisfies all requirements. In this case, `CrudRepository` is sufficient
    for current needs.
  prefs: []
  type: TYPE_NORMAL
- en: Bringing it all together
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next step is to create the component that periodically polls the `PlaneFinder`
    service.
  prefs: []
  type: TYPE_NORMAL
- en: Polling PlaneFinder
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Similar to earlier examples, I create a Spring Boot component class `PlaneFinderPoller`
    to poll for current position data and handle any `Aircraft` records received,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'I create the primary constructor in the header with an `AircraftRepository`
    parameter. Spring Boot automatically autowires the existing `AircraftRepository`
    bean into the `PlaneFinderPoller` component for use, and I mark it as a `private
    val` to ensure the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It isn’t assignable later.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It isn’t exposed externally as a property from the `PlaneFinderPoller` bean,
    as the repository is already accessible throughout the application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, I create a `WebClient` object and assign it to a property, pointing it
    to the destination endpoint exposed by the `PlaneFinder` service on port 7634.
  prefs: []
  type: TYPE_NORMAL
- en: I annotate the class with `@Component` to have Spring Boot create a component
    (bean) upon application startup and `@EnableScheduling` to enable periodic polling
    via an annotated function to follow.
  prefs: []
  type: TYPE_NORMAL
- en: And finally, I create a function to delete all existing `Aircraft` data, poll
    the `PlaneFinder` endpoint via the `WebClient` client property, convert and store
    the retrieved aircraft positions in MongoDB, and display them. The `@Scheduled(fixedRate
    = 1000)` results in the polling function being executed once every 1,000 ms (once
    per second).
  prefs: []
  type: TYPE_NORMAL
- en: There are three more interesting things to note in the `pollPlanes()` function,
    and both regard Kotlin’s lambdas.
  prefs: []
  type: TYPE_NORMAL
- en: First is that if a lambda is the final parameter of a function, parentheses
    can be omitted, as they add nothing to clarity or meaning. If a function has only
    a single parameter of a lambda, this fits the criteria as well, of course. This
    results in fewer symbols to sift through in sometimes busy lines of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Second is that if a lambda itself has a single parameter, a developer can still
    explicitly specify it but isn’t required to do so. Kotlin implicitly recognizes
    and refers to a sole lambda parameter as `it`, which further streamlines lambdas,
    as demonstrated by this lambda parameter to `forEach()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Finally, the function `isNullOrEmpty()` that operates on a `CharSequence` provides
    a very nice all-in-one capability for String evaluation. This function performs
    both a null check (first), then if the value is determined to be non-null, it
    checks to see if it has zero length, i.e., is empty. There are many times that
    a developer can process properties only if they contain actual values, and this
    single function performs both validations in one step. If a value exists in the
    `Aircraft`’s registration property `reg`, that incoming aircraft position report
    is passed along; aircraft position reports with missing registration values are
    filtered out.
  prefs: []
  type: TYPE_NORMAL
- en: All remaining position reports are streamed to the repository to be saved, then
    we query the repository for all persisted documents and display the results.
  prefs: []
  type: TYPE_NORMAL
- en: The results
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With the `PlaneFinder` service running on my machine, I start the *sbur-mongo*
    service to obtain, store and retrieve (in an embedded MongoDB instance), and display
    the results of each polling of `PlaneFinder`. An example of the results follows,
    edited for brevity and formatted for readability:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: As expected, the service polls, captures, and displays aircraft positions without
    issue using Spring Boot, Kotlin, and MongoDB to make it nearly effortless.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Repository-Based Service Using a NoSQL Graph Database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Graph databases bring a different approach to data, in particular how it’s interrelated.
    There are a few graph databases on the market, but for all intents and purposes,
    the segment leader is Neo4j.
  prefs: []
  type: TYPE_NORMAL
- en: While graph theory and graph database design is far afield of the scope of this
    book, demonstrating how best to work with a graph database using Spring Boot and
    Spring Data falls squarely within its purview. This section shows you how to easily
    connect to and work with data using Spring Data Neo4j in your Spring Boot application.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing the Project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once more we return to the Spring Initializr. This time, I choose the following
    options:'
  prefs: []
  type: TYPE_NORMAL
- en: Gradle project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Current production version of Spring Boot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Packaging: Jar'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Java: 11'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And for dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: Spring Reactive Web (`spring-boot-starter-webflux`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Data Neo4j (`spring-boot-starter-data-neo4j`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, I generate the project and save it locally, unzip it, and open it in the
    IDE.
  prefs: []
  type: TYPE_NORMAL
- en: I chose Gradle for this project’s build system solely to demonstrate that when
    creating a Spring Boot Java application using Gradle, the generated *build.gradle*
    file uses the Groovy DSL, but Maven is a valid option as well.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As with most other examples in this chapter, I have a Neo4j database instance
    running in a locally hosted container, ready to respond to this application.
  prefs: []
  type: TYPE_NORMAL
- en: And with that, we’re ready to create our service.
  prefs: []
  type: TYPE_NORMAL
- en: Developing the Neo4j Service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As with previous examples, Spring Boot and Spring Data make the experience of
    working with Neo4j databases highly consistent with using other types of underlying
    datastores. The full power of a graph datastore is available and easily accessible
    from Spring Boot applications, but ramp-up is drastically reduced.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the domain class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once more I begin by defining the `Aircraft` domain. Without Lombok as a dependency,
    I create it with the usual extensive list of constructors, accessors, mutators,
    and supporting methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Java code can indeed be verbose. To be fair this isn’t a huge problem in cases
    like domain classes, because while accessors and mutators take up a significant
    amount of space, they can be generated by IDEs and typically don’t involve much
    maintenance due to their long-term stability. That said, it *is* a lot of boilerplate
    code, which is why many developers use solutions like Lombok or Kotlin—even if
    only creating domain classes in Kotlin for Java applications.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Neo requires a database-generated unique identifier, even if entities being
    persisted contain a unique identifier already. To satisfy this requirement, I
    add a `neoId` parameter/member variable and annotate it with `@Id` and `GeneratedValue`
    so Neo4j correctly associates this member variable with the value it generates
    internally.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, I add two class-level annotations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@Node`:: To designate each instance of this `record` as an instance of the
    Neo4j node `Aircraft` `@JsonIgnoreProperties(ignoreUnknown = true)`:: To ignore
    new fields that might be added to feed from the `PlaneFinder` service endpoint'
  prefs: []
  type: TYPE_NORMAL
- en: Note that like `@Id` and `@GeneratedValue`, the `@Node` annotation is from the
    `org.springframework.data.neo4j.core.schema` package for Spring Data Neo4j-based
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: With that, the domain for our service is defined.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the repository interface
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For this application I again define the required repository interface, extending
    Spring Data’s `CrudRepository` and providing the type of object to store and its
    key: `Aircraft` and `Long`, in this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Similar to the earlier MongoDB-based project, there is a `Neo4jRepository` interface
    that extends `PagingAndSortingRepository` (which extends `CrudRepository`) that
    can used instead of `CrudRepository`; however, since `CrudRepository` is the highest-level
    interface that satisfies all requirements, I use it as the basis for `AircraftRepository`.
  prefs: []
  type: TYPE_NORMAL
- en: Bringing it all together
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now to create the component to poll `PlaneFinder` and configure it to access
    the Neo4j database.
  prefs: []
  type: TYPE_NORMAL
- en: Polling PlaneFinder
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Once more I create a Spring Boot `@Component` class to poll for current aircraft
    positions and handle `Aircraft` records received.
  prefs: []
  type: TYPE_NORMAL
- en: Like other Java-based projects in this chapter, I create a `WebClient` object
    and assign it to a member variable, pointing it to the destination endpoint exposed
    by the `PlaneFinder` service on port 7634.
  prefs: []
  type: TYPE_NORMAL
- en: Without Lombok as a dependency, I create a constructor via which to receive
    the autowired `AircraftRepository` bean.
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in the following full listing of the `PlaneFinderPoller` class, the
    `pollPlanes()` method looks nearly identical to other examples, owing to the abstractions
    brought to bear by repository support. To revisit any other details of the remaining
    code in `PlaneFinderPoller`, please review the corresponding section under earlier
    sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Connecting to Neo4j
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As with the earlier MariaDB/MySQL example, we need to provide a few key bits
    of information for Boot to use to seamlessly connect to a Neo4j database. For
    this service running in my environment, these properties include:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Replace username and password values shown with those specific to your environment.
  prefs: []
  type: TYPE_NORMAL
- en: The results
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With the `PlaneFinder` service running on my machine, I start the *sbur-neo*
    service to obtain, store and retrieve, and display the results of each polling
    of `PlaneFinder` using Neo4j as the datastore of choice. An example of the results
    follows, edited for brevity and formatted for readability:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The service is fast and efficient, using Spring Boot and Neo4j to retrieve,
    capture, and display aircraft positions as they’re reported.
  prefs: []
  type: TYPE_NORMAL
- en: Code Checkout Checkup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For complete chapter code, please check out branch *chapter6end* from the code
    repository.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data can be a complex topic with innumerable variables and constraints, including
    data structures, relationships, applicable standards, providers and mechanisms,
    and more. Yet without data in some form, most applications provide little or no
    value.
  prefs: []
  type: TYPE_NORMAL
- en: As something that forms the foundation of nearly all application value, “data”
    has attracted a great deal of innovation from database providers and platform
    vendors. In many cases, though, complexity remains, and developers have to tame
    that complexity to unlock the value.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Data’s stated mission is “to provide a familiar and consistent, Spring-based
    programming model for data access while still retaining the special traits of
    the underlying data store.” Regardless of database engine or platform, Spring
    Data’s goal is to make the developer’s use of data as simple and as powerful as
    humanly possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter demonstrated how to streamline data storage and retrieval using
    various database options and the Spring Data projects and facilities that enable
    their use in the most powerful ways possible: via Spring Boot.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, I’ll show how to create imperative applications using Spring
    MVC’s REST interactions, messaging platforms, and other communications mechanisms,
    as well as provide an introduction to templating language support. While this
    chapter’s focus was from the application downward, [Chapter 7](ch07.xhtml#sbur-07)
    focuses on the application outward.
  prefs: []
  type: TYPE_NORMAL
