- en: Chapter 6\. Really Digging into Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。深入数据
- en: 'Data can be a complex topic, with so much to consider: its structure and relationships
    with other data; handling, storage, and retrieval options; various applicable
    standards; database providers and mechanisms; and more. Data may be the most complex
    aspect of development to which devs are exposed so early in their careers and
    when learning a new toolchain.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 数据可能是一个复杂的话题，有很多要考虑的地方：它的结构和与其他数据的关系；处理、存储和检索选项；各种适用的标准；数据库提供者和机制；等等。数据可能是开发者在职业早期接触到的最复杂的开发方面，也是学习新工具链时的一部分。
- en: The reason this is often the case is that without data in some form, nearly
    all applications are meaningless. Very few apps provide any value at all without
    storing, retrieving, or correlating data.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常是这样的原因，因为几乎所有应用程序没有某种形式的数据，几乎都是毫无意义的。几乎没有应用程序能够在不存储、检索或关联数据的情况下提供任何价值。
- en: 'As something that forms the underpinning for nearly all application value,
    *data* has attracted a great deal of innovation from database providers and platform
    vendors. But in many cases, complexity remains: it is a topic with great depth
    and breadth, after all.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 作为几乎所有应用程序价值基础的一部分，*数据*已经引起了数据库提供商和平台供应商的大量创新。但在许多情况下，复杂性仍然存在：毕竟，这是一个有深度和广度的话题。
- en: Enter Spring Data. Spring Data’s stated [mission](https://spring.io/projects/spring-data)
    is “to provide a familiar and consistent, Spring-based programming model for data
    access while still retaining the special traits of the underlying data store.”
    Regardless of database engine or platform, Spring Data’s goal is to make the developer’s
    access to data as simple and as powerful as humanly possible.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 进入Spring Data。Spring Data的宣言 [使命](https://spring.io/projects/spring-data) 是“为数据访问提供一个熟悉和一致的基于Spring的编程模型，同时保留底层数据存储的特殊特性。”
    不论数据库引擎或平台如何，Spring Data的目标是尽可能简化开发者对数据的访问，使其既简单又强大。
- en: 'This chapter demonstrates how to define data storage and retrieval using various
    industry standards and leading database engines and the Spring Data projects and
    facilities that enable their use in the most streamlined and powerful ways possible:
    via Spring Boot.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章演示了如何使用各种行业标准和领先的数据库引擎定义数据存储和检索，以及Spring Data项目和工具如何通过Spring Boot以最简化和强大的方式支持它们的使用。
- en: Defining Entities
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义实体
- en: In nearly every case when dealing with data, some form of domain entity is involved.
    Whether it’s an invoice, an automobile, or something else entirely, data is rarely
    dealt with as a collection of unrelated properties. Inevitably, what we consider
    useful data are cohesive pools of elements that together constitute a meaningful
    whole. An automobile—in data or in real life—is really only a useful concept if
    it’s a unique, fully attributed thing.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎在处理数据的每个案例中，都涉及某种形式的领域实体。无论是发票、汽车还是其他任何东西，数据很少被视为一组不相关的属性。不可避免地，我们认为有用的数据是构成有意义整体的一致性元素池。汽车——无论是在数据中还是在现实生活中——只有在作为一个独特的、充分属性的事物时才是一个真正有用的概念。
- en: Spring Data provides several different mechanisms and data access options for
    Spring Boot applications to use, at a variety of abstraction levels. Regardless
    of which level of abstraction a developer settles on for any given use case, the
    first step is defining any domain classes that will be used to handle applicable
    data.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data为Spring Boot应用程序提供了多种不同的机制和数据访问选项，涵盖各种抽象级别。无论开发者为任何给定的用例选择了哪个抽象级别，第一步都是定义用于处理适用数据的任何领域类。
- en: 'While a full exploration of Domain-Driven Design (DDD) is beyond the scope
    of this book, I’ll use the concepts as a foundation for defining applicable domain
    classes for the example applications built in this and subsequent chapters. For
    a full exploration of DDD I would refer the reader to Eric Evans’s seminal work
    on the topic, [*Domain-Driven Design: Tackling Complexity in the Heart of Software*](https://oreil.ly/DomainDrivDes).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然本书范围不包括完全探讨领域驱动设计（DDD），我将使用这些概念作为在本书和后续章节中构建的示例应用程序中定义适用领域类的基础。关于DDD的全面探讨，我建议读者参考埃里克·埃文斯关于这一主题的开创性工作，《*领域驱动设计：软件核心复杂性应对之道*》(https://oreil.ly/DomainDrivDes)。
- en: By way of a cursory explanation, a *domain class* encapsulates a primary domain
    entity that has relevance and significance independently of other data. This doesn’t
    mean it doesn’t relate to other domain entities, only that it can stand alone
    and make sense as a unit, even when unassociated with other entities.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，*领域类*封装了一个具有独立于其他数据的相关性和重要性的主要领域实体。这并不意味着它与其他领域实体无关，只是即使与其他实体无关，它也可以作为一个单元站立并有意义。
- en: To create a domain class in Spring using Java, you can create a class with member
    variables, applicable constructors, accessors/mutators, and `equals()`/`hashCode()`
    /`toString()` methods (and more). You can also employ Lombok with Java or data
    classes in Kotlin to create domain classes for data representation, storage, and
    retrieval. I do all of these things in this chapter to demonstrate just how easy
    it is to work with domains using Spring Boot and Spring Data. It’s great to have
    options.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Java在Spring中创建一个领域类，您可以创建一个具有成员变量、适用的构造函数、访问器/修改器以及`equals()`/`hashCode()`/`toString()`方法（以及更多内容）的类。您还可以使用Java中的Lombok或Kotlin中的数据类来创建用于数据表示、存储和检索的领域类。在本章中，我展示了所有这些操作，以演示使用Spring
    Boot和Spring Data处理领域时有多么容易。拥有多种选择真是太好了。
- en: 'For the examples in this chapter, once I’ve defined a domain class, I’ll decide
    on a database and level of abstraction based on goals for data usage and exposed
    APIs for or by the database provider. Within the Spring ecosystem, this typically
    boils down to one of two options, with minor variations: templates or repositories.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的示例中，一旦我定义了一个领域类，我将根据数据使用目标和数据库提供程序的API来决定数据库和抽象级别。在Spring生态系统中，这通常归结为两种选项之一，具有轻微差异：模板或仓库。
- en: Template Support
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板支持
- en: In order to provide a set of “just high enough” coherent abstractions, Spring
    Data defines an interface of type `Operations` for most of its various data sources.
    This `Operations` interface—examples include `MongoOperations`, `RedisOperations`,
    and `CassandraOperations`—specifies a foundational set of operations that can
    be used directly for greatest flexibility or upon which higher-level abstractions
    can be constructed. `Template` classes provide direct implementations of `Operations`
    interfaces.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供一组“刚刚好”的连贯抽象，Spring Data为其各种数据源定义了一个名为`Operations`的接口。这个`Operations`接口——例如`MongoOperations`、`RedisOperations`和`CassandraOperations`——定义了一组基础操作，可以直接使用以获得最大的灵活性，或者可以构建更高级别的抽象。`Template`类提供了`Operations`接口的直接实现。
- en: Templates can be thought of as a Service Provider Interface (SPI) of sorts—directly
    usable and extremely capable but with many repetitive steps required each time
    they’re used to accomplish the more common use cases developers face. For those
    scenarios in which data access follows common patterns, repositories may be a
    better choice. And the best part is that repositories build upon templates, so
    you lose nothing by stepping up to the higher abstraction.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将模板视为一种服务提供者接口（SPI）——直接可用且功能强大，但每次使用它们完成更常见的开发人员面临的用例时都需要许多重复的步骤。对于那些数据访问遵循常见模式的场景，仓库可能是一个更好的选择。而最好的部分是仓库建立在模板之上，因此通过提升到更高的抽象层次，您不会失去任何东西。
- en: Repository Support
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 仓库支持
- en: Spring Data defines the `Repository` interface from which all other types of
    Spring Data repository interfaces derive. Examples include `JPARepository` and
    `MongoRepository` (providing JPA-specific and Mongo-specific capabilities, respectively)
    and more versatile interfaces like `CrudRepository`, `ReactiveCrudRepository`,
    and `PagingAndSortingRepository`. These various repository interfaces specify
    useful higher-level operations like `findAll()`, `findById()`, `count()`, `delete()`,
    `deleteAll()`, and more.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data从`Repository`接口定义了所有其他类型的Spring Data仓库接口派生出来。例如`JPARepository`和`MongoRepository`（分别提供JPA特定和Mongo特定的功能），以及更通用的接口如`CrudRepository`、`ReactiveCrudRepository`和`PagingAndSortingRepository`。这些不同的仓库接口指定了有用的高级操作，如`findAll()`、`findById()`、`count()`、`delete()`、`deleteAll()`等。
- en: Repositories are defined for both blocking and nonblocking interactions. Additionally,
    creating queries using convention over configuration, and even literal query statements,
    is supported by Spring Data’s repositories. Using Spring Data’s repositories with
    Spring Boot makes building complex database interactions an almost trivial exercise.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库被定义为阻塞和非阻塞交互。此外，Spring Data的仓库支持使用约定优于配置创建查询，甚至支持直接的查询语句。使用Spring Boot与Spring
    Data的仓库使得构建复杂的数据库交互几乎成为一种简单的练习。
- en: 'I demonstrate all of these capabilities at some point in this book. In this
    chapter, I plan to cover the key elements across a number of database options
    by incorporating various implementation details: Lombok, Kotlin, and more. In
    that way, I provide a broad and stable base upon which to build in subsequent
    chapters.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '@Before'
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As much as I love coffee and rely on it to drive my application development,
    in order to better explore the concepts covered throughout the rest of this book,
    I felt a more versatile domain was in order. As both a software developer and
    pilot, I see the increasingly complex and data-driven world of aviation as offering
    no shortage of interesting scenarios (and fascinating data) to explore as we delve
    deeper into Spring Boot’s facility in numerous use cases.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: To deal with data, we must *have* data. I’ve developed a small Spring Boot RESTful
    web service called `PlaneFinder` (available within this book’s code repositories)
    to serve as an API gateway that I can poll for current aircraft and positions
    within range of a small device on my desk. This device receives Automatic Dependent
    Surveillance—Broadcast (ADS-B) data from airplanes within a certain distance and
    shares them with a service online, [PlaneFinder.net](https://planefinder.net).
    It also exposes an HTTP API that my gateway service consumes, simplifies, and
    exposes to other downstream services like the ones in this chapter.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: More details throughout, but for now, let’s create some database-connected services.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Template-Based Service Using Redis
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Redis is a database that is typically used as an in-memory datastore for sharing
    state among instances of a service, caching, and brokering messages between services.
    Like all major databases, Redis does more, but the focus for this chapter is simply
    using Redis to store and retrieve from memory aircraft information our service
    obtains from the `PlaneFinder` service referred to previously.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Initializing the Project
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To begin, we return to the Spring Initializr. From there, I choose the following
    options:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Maven project
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Current production version of Spring Boot
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Packaging: Jar'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Java: 11'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And for dependencies:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Spring Reactive Web (`spring-boot-starter-webflux`)
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Data Redis (Access+Driver) (`spring-boot-starter-data-redis`)
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lombok (`lombok`)
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, I generate the project and save it locally, unzip it, and open it in the
    IDE.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Developing the Redis Service
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s begin with the domain.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'Currently, the `PlaneFinder` API gateway exposes a single REST endpoint:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Any (local) service can query this endpoint and receive a JSON response of
    all aircraft within range of the receiver in the following format (with representative
    data):'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Defining the domain class
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to ingest and manipulate these aircraft reports, I create an `Aircraft`
    class as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This domain class includes a few helpful annotations that streamline the necessary
    code and/or increase its flexibility. Class-level annotations include the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '`@Data`:: Instructs Lombok to create getter, setter, `equals()`, `hashCode()`,
    and `toString()` methods, creating a so-called data class `@NoArgsConstructor`::
    Instructs Lombok to create a zero-parameter constructor, thus requiring no arguments
    `@AllArgsConstructor`:: Instructs Lombok to create a constructor with a parameter
    for each member variable, requiring an argument be provided for all `@JsonIgnoreProperties(ignoreUnknown
    = true)`:: Informs Jackson deserialization mechanisms to ignore fields within
    JSON responses for which there is no corresponding member variable'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Data`：指示Lombok创建getter、setter、`equals()`、`hashCode()`和`toString()`方法，从而创建所谓的数据类。`@NoArgsConstructor`：指示Lombok创建一个零参数构造函数，因此不需要参数。`@AllArgsConstructor`：指示Lombok为每个成员变量创建一个带参数的构造函数，因此需要提供所有参数。`@JsonIgnoreProperties(ignoreUnknown
    = true)`：通知Jackson反序列化机制忽略JSON响应中没有对应成员变量的字段。'
- en: 'Field-level annotations provide more specific guidance where appropriate. Examples
    of field-level annotations include the two used for this class:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 字段级注释在适当的情况下提供了更具体的指导。此类使用的字段级注释示例包括两个：
- en: '`@Id`:: Designates the annotated member variable as holding the unique identifier
    for a database entry/record `@JsonProperty("vert_rate")`:: Connects a member variable
    with its differently named JSON field'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Id`：指定带注释的成员变量作为数据库条目/记录的唯一标识符 `@JsonProperty("vert_rate")`：将成员变量与其不同命名的JSON字段连接起来。'
- en: 'You may be wondering why I created explicit accesssors and mutators for the
    three member variables of type `Instant` if the `@Data` annotation results in
    the creation of getter and setter methods for all member variables. In the case
    of these three, the JSON value must be parsed and transformed from a `String`
    to a complex data type by calling a method: `Instant::parse`. If that value is
    entirely absent (null), different logic must be performed to avoid passing a null
    to `parse()` and to assign some meaningful substitute value to the corresponding
    member variable via setter. Additionally, serialization of `Instant` values is
    best done by conversion to a `String`—thus the explicit getter methods.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`@Data`注解会为所有成员变量创建getter和setter方法，你可能会想为什么我为`Instant`类型的三个成员变量创建了显式的访问器和变更器。对于这三个成员变量，JSON值必须通过调用`Instant::parse`方法从`String`解析和转换为复杂数据类型。如果该值完全不存在（null），则必须执行不同的逻辑以避免向`parse()`传递null，并通过setter为相应的成员变量分配一些有意义的替代值。此外，最好通过转换为`String`来序列化`Instant`值，因此需要显式的getter方法。
- en: With a domain class defined, it’s time to create and configure the mechanism
    for accessing a Redis database.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了一个域类后，现在是创建和配置访问Redis数据库的机制的时候了。
- en: Adding template support
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加模板支持
- en: Spring Boot provides basic `RedisTemplate` capabilities via autoconfiguration,
    and if you only need to manipulate `String` values using Redis, very little work
    (or code) is required from you. Dealing with complex domain objects necessitates
    a bit more configuration but not too much.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot通过自动配置提供了基本的`RedisTemplate`功能，如果只需要使用Redis操作`String`值，则您几乎不需要做任何工作（或编写任何代码）。处理复杂的领域对象需要更多的配置，但也不是太多。
- en: The `RedisTemplate` class extends the `RedisAccessor` class and implements the
    `RedisOperations` interface. Of particular interest for this application is `RedisOperations`,
    as it specifies the functionality needed to interact with Redis.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`RedisTemplate`类扩展了`RedisAccessor`类，并实现了`RedisOperations`接口。对于本应用程序特别感兴趣的是`RedisOperations`，因为它指定了与Redis交互所需的功能。'
- en: As developers, we should prefer to write code against interfaces, not implementations.
    Doing so allows one to provide the most appropriate concrete implementation for
    the task at hand without code/API changes or excessive and unnecessary violations
    of the DRY (Don’t Repeat Yourself) principle; as long as the interface is fully
    implemented, any concrete implementation will function just as well as any other.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发者，我们应该优先编写针对接口而不是实现的代码。这样做可以在不改变代码/API或过度违反DRY（不要重复自己）原则的情况下，为手头任务提供最合适的具体实现；只要接口被完全实现，任何具体实现都将像任何其他一样正常工作。
- en: 'In the following code listing, I create a bean of type `RedisOperations`, returning
    a `RedisTemplate` as the bean’s concrete implementation. I perform the following
    steps in order to configure it properly to accommodate inbound `Aircraft`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码清单中，我创建了一个`RedisOperations`类型的bean，返回一个`RedisTemplate`作为bean的具体实现。为了正确配置它以适应传入的`Aircraft`，我执行以下步骤：
- en: I create a `Serializer` to be used when converting between objects and JSON
    records. Since Jackson is used for marshalling/unmarshalling (serialization/deserialization)
    of JSON values and is already present in Spring Boot web applications, I create
    a `Jackson2JsonRedisSerializer` for objects of type `Aircraft`.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我创建了一个`Serializer`，用于在对象和JSON记录之间进行转换。由于Jackson用于JSON值的编组/解组（序列化/反序列化）并且已经存在于Spring
    Boot Web应用程序中，我为`Aircraft`类型的对象创建了一个`Jackson2JsonRedisSerializer`。
- en: I create a `RedisTemplate` that accepts keys of type `String` and values of
    type `Aircraft` to accommodate the inbound `Aircraft` with `String` IDs. . I plug
    the `RedisConnectionFactory` bean that was helpfully and automatically autowired
    into this bean-creation method’s sole parameter—`RedisConnectionFactory factory`—into
    the `template` object so it can create and retrieve a connection to the Redis
    database.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我创建了一个`RedisTemplate`，接受`String`类型的键和`Aircraft`类型的值，以适应具有`String` ID的入站`Aircraft`。我将被自动自动装配的`RedisConnectionFactory`
    bean插入到此bean创建方法的唯一参数——`RedisConnectionFactory factory`——中，以便`template`对象可以创建和检索到Redis数据库的连接。
- en: I supply the `Jackson2JsonRedisSerializer<Aircraft>` serializer to the `template`
    object in order to be used as the default serializer. `RedisTemplate` has a number
    of serializers that are assigned the default serializer in the absence of specific
    assignment, a useful touch.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我向`template`对象提供`Jackson2JsonRedisSerializer<Aircraft>`序列化器，以便用作默认序列化器。在没有特定分配的情况下，`RedisTemplate`有许多序列化器被分配为默认序列化器，这是一个有用的功能。
- en: I create and specify a different serializer to be used for keys so that the
    template doesn’t attempt to use the default serializer—which expects objects of
    type `Aircraft`—to convert to/from key values of type `String`. A `StringRedisSerializer`
    does the trick nicely.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我创建并指定了一个不同的序列化器用于键，以便模板不会尝试使用默认序列化器——它期望`Aircraft`类型的对象——将键值转换为`String`类型。`StringRedisSerializer`非常好地完成了这项任务。
- en: 'Finally, I return the created and configured `RedisTemplate` as the bean to
    use when some implementation of a `RedisOperations` bean is requested within the
    application:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我将创建和配置的`RedisTemplate`作为在应用程序中请求`RedisOperations` bean的某个实现时要使用的bean返回：
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Bringing it all together
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Bringing it all together
- en: Now that the underlying wiring is in place for accessing the Redis database
    using a template, it’s time for the payoff. As shown in the code listing that
    follows, I create a Spring Boot `@Component` class to poll the `PlaneFinder` endpoint
    and handle the resultant `Aircraft` records it receives using Redis template support.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，已经为使用模板访问Redis数据库进行了底层连接，该时候该有回报了。如下面的代码清单所示，我创建了一个Spring Boot `@Component`类来轮询`PlaneFinder`端点，并使用Redis模板支持处理接收到的`Aircraft`记录。
- en: To initialize the `PlaneFinderPoller` bean and prepare it for action, I create
    a `WebClient` object and assign it to a member variable, pointing it to the destination
    endpoint exposed by the external `PlaneFinder` service. `PlaneFinder` currently
    runs on my local machine and listens on port 7634.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为了初始化`PlaneFinderPoller` bean并准备好进行操作，我创建了一个`WebClient`对象并将其分配给一个成员变量，指向外部`PlaneFinder`服务暴露的目标端点。`PlaneFinder`目前在我的本地机器上运行，并监听端口7634。
- en: 'The `PlaneFinderPoller` bean requires access to two other beans to perform
    its duties: a `RedisConnectionFactory` (supplied by Boot’s autoconfiguration due
    to Redis being an app dependency) and an implementation of `RedisOperations`,
    the `RedisTemplate` created earlier. Both are assigned to properly defined member
    variables via constructor injection (autowired):'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`PlaneFinderPoller` bean需要访问其他两个bean来执行其任务：`RedisConnectionFactory`（由于Redis是应用程序依赖项，由Boot的自动配置提供）和`RedisOperations`的实现，即之前创建的`RedisTemplate`。这两个bean都通过构造函数注入（自动装配）分配到了正确定义的成员变量中：'
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, I create the method that does the heavy lifting. In order to have it
    poll on a fixed schedule, I leverage the `@EnableScheduling` annotation I previously
    placed at the class level and annotate the `pollPlanes()` method I create with
    `@Scheduled`, supplying a parameter of `fixedDelay=1000` to specify a polling
    frequency of once per 1,000 ms—once per second. The rest of the method consists
    of only three declarative statements: one to clear any previously saved `Aircraft`,
    one to retrieve and save current positions, and one to report the results of the
    latest capture.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我创建了处理重要任务的方法。为了使其定期轮询，我利用了之前放置在类级别的`@EnableScheduling`注解，并为我创建的`pollPlanes()`方法加上了`@Scheduled`注解，提供了参数`fixedDelay=1000`来指定每1,000毫秒一次的轮询频率——即每秒一次。方法的其余部分仅包含三个声明性语句：一个用于清除任何先前保存的`Aircraft`，一个用于检索和保存当前位置，一个用于报告最新捕获结果。
- en: 'For the first task I use the autowired `ConnectionFactory` to obtain a connection
    to the database, and via that connection, I execute the server command to clear
    all keys present: `flushDb()`.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一个任务，我使用自动装配的`ConnectionFactory`获取与数据库的连接，并通过该连接执行服务器命令来清除所有当前存在的键：`flushDb()`。
- en: The second statement uses the `WebClient` to call the `PlaneFinder` service
    and retrieve a collection of aircraft within range, along with their current position
    information. The response body is converted to a `Flux` of `Aircraft` objects,
    filtered to remove any `Aircraft` that don’t include registration numbers, converted
    to a `Stream` of `Aircraft`, and saved to the Redis database. The save is performed
    on each valid `Aircraft` by setting a key/value pair to the `Aircraft` registration
    number and the `Aircraft` object itself, respectively, using Redis’s operations
    tailored to manipulating data values.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个语句使用`WebClient`调用`PlaneFinder`服务，并检索范围内的飞行器集合及其当前位置信息。响应体被转换为包含注册号的`Aircraft`对象的`Flux`，过滤掉不包含注册号的任何`Aircraft`，转换为`Aircraft`的`Stream`，并保存到Redis数据库中。对每个有效的`Aircraft`执行保存操作，通过设置`Aircraft`注册号和`Aircraft`对象本身的键值对，使用Redis的操作来操作数据值。
- en: Note
  id: totrans-72
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: A `Flux` is a reactive type covered in upcoming chapters, but for now, simply
    think of it as a collection of objects delivered without blocking.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`Flux`是一种在后续章节中介绍的响应式类型，但现在，简单地将其视为无阻塞传递对象的集合即可。'
- en: 'The final statement in `pollPlanes()` again leverages a couple of Redis’s defined
    value operations to retrieve all keys (via the wildcard parameter *) and, using
    each key, to retrieve each corresponding `Aircraft` value, which is then printed.
    Here is the `pollPlanes()` method in finished form:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`pollPlanes()`方法中的最后一个语句再次利用了Redis定义的值操作，以检索所有键（通过通配符参数*）并使用每个键检索每个相应的`Aircraft`值，然后将其打印出来。以下是完成形式的`pollPlanes()`方法：'
- en: '[PRE5]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The final version (for now) of the `PlaneFinderPoller` class is shown in the
    following listing:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在（目前为止）`PlaneFinderPoller`类的最终版本如下所示：
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: With polling mechanisms fully fleshed out, let’s run the application and see
    the results.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 轮询机制已完全完善，让我们运行应用程序并查看结果。
- en: The results
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结果
- en: 'With the `PlaneFinder` service already running on my machine, I start the *sbur-redis*
    application to obtain, store and retrieve in Redis, and display the results of
    each poll of `PlaneFinder`. What follows is an example of the results, edited
    for brevity and formatted a bit for readability:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我的机器上已经运行了`PlaneFinder`服务，我启动了*sbur-redis*应用程序来获取、存储和检索Redis中的结果，并显示每次`PlaneFinder`轮询的结果。以下是一个编辑过的、为了简洁而格式化的结果示例：
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Working with databases via Spring Data’s template support provides a lower-level
    API with excellent flexibility. If you’re looking for minimum friction and maximum
    productivity and repeatability, however, repository support is the better choice.
    Next, I show how to convert from using templates to interact with Redis to using
    a Spring Data repository. It’s great to have options.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 通过Spring Data模板支持的数据库操作提供了一个具有极大灵活性的低级API。然而，如果你寻求最小的摩擦和最大的生产力与重复性，那么仓库支持则是更好的选择。接下来，我将展示如何从使用模板与Redis交互转换为使用Spring
    Data仓库。拥有多种选择是件好事。
- en: Converting from Template to Repository
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换从模板到仓库
- en: 'Before we can use a repository, it’s necessary to define one, and Spring Boot’s
    autoconfiguration helps considerably with this. I create a repository interface
    as follows, extending Spring Data’s `CrudRepository` and providing the type of
    object to store along with its key: `Aircraft` and `Long`, in this case:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以使用存储库之前，需要定义一个存储库，Spring Boot的自动配置在这方面帮助很大。我创建了一个存储库接口如下，扩展了Spring Data的`CrudRepository`并提供要存储的对象类型以及其键：在本例中是`Aircraft`和`Long`：
- en: '[PRE8]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As explained in [Chapter 4](ch04.xhtml#sbur-04), Spring Boot detects the Redis
    database driver on the application classpath and notes that we’re extending a
    Spring Data repository interface, then creates a database proxy automatically
    with no additional code required to instantiate it. Just like that, the application
    has access to an `AircraftRepository` bean. Let’s plug it in and put it to use.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第4章](ch04.xhtml#sbur-04)中解释的那样，Spring Boot检测到应用程序类路径上的Redis数据库驱动程序，并注意到我们正在扩展Spring
    Data存储库接口，然后自动创建数据库代理，无需额外的代码来实例化它。就这样，应用程序可以访问一个`AircraftRepository` bean。让我们将其插入并投入使用。
- en: Revisiting the `PlaneFinderPoller` class, I can now replace the lower-level
    references to and operations using `RedisOperations` and replace them with `AircraftRepository`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾`PlaneFinderPoller`类，我现在可以替换对`RedisOperations`的低级引用和操作，并用`AircraftRepository`替换它们。
- en: 'First, I remove the `RedisOperations` member variable:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我删除了`RedisOperations`成员变量：
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then replace it with one for the `AircraftRepository` to autowire:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然后用`AircraftRepository`替换它以自动装配：
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, I replace the `RedisOperations` bean autowired via constructor injection
    with the `AircraftRepository` and the assignment within the constructor to the
    applicable member variable so that the constructor ends up like so:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我用构造函数注入替换了通过构造函数注入的`RedisOperations` bean，并且分配给适用的成员变量，使得构造函数最终如下：
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The next step is to refactor the `pollPlanes()` method to replace template-based
    operations with repository-based ops.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是重构`pollPlanes()`方法，以替换基于模板的操作为基于存储库的操作。
- en: 'Changing the last line of the first statement is a simple matter. Using a method
    reference further simplifies the lambda:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 更改第一条语句的最后一行很简单。使用方法引用进一步简化了lambda表达式：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'And the second one reduces even more, again including use of a method reference:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个进一步减少，再次包括使用方法引用：
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The newly repository-enabled `PlaneFinderPoller` now consists of the following
    code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 新启用存储库的`PlaneFinderPoller`现在包含以下代码：
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'With no further need of a bean implementing the `RedisOperations` interface,
    I can now delete its `@Bean` definition from the main application class, leaving
    `SburRedisApplication`, as shown in the following code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在不再需要实现`RedisOperations`接口的bean，我现在可以从主应用程序类中删除其`@Bean`定义，留下如下所示的`SburRedisApplication`：
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Only one small task and a very nice code reduction remain to fully enable Redis
    repository support in our application. I add the `@RedisHash` annotation to the
    `Aircraft` entity to indicate that `Aircraft` is an aggregate root to be stored
    in a Redis hash, performing a function similar to what `@Entity` annotation does
    for JPA objects. I then remove the explicit accessors and mutators previously
    required for the `Instant`-typed member variables, as the converters in Spring
    Data’s repository support handle complex type conversions with ease. The newly
    streamlined `Aircraft` class now looks like this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 只剩下一个小任务和一个非常好的代码减少，以完全启用我们应用中的Redis存储库支持。我为`Aircraft`实体添加了`@RedisHash`注解，表示`Aircraft`是要存储在Redis哈希中的聚合根，类似于`@Entity`注解用于JPA对象的功能。然后，我删除了之前为`Instant`类型成员变量所需的显式访问器和修改器，因为Spring
    Data的存储库支持中的转换器轻松处理复杂类型转换。新简化的`Aircraft`类现在如下所示：
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'With the latest changes in place, restarting the service results in output
    indistinguishable from the template-based approach but with much less code and
    inherent ceremony required. An example of results follows, again edited for brevity
    and formatted for readability:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在最新的更改完成后，重新启动服务会产生与基于模板方法的输出无法区分的结果，但所需的代码和典礼性明显减少。以下是结果示例，再次经过编辑以缩短并格式化以提高可读性：
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If you need direct access to the lower-level capabilities exposed by Spring
    Data templates, template-based database support is indispensable. But for nearly
    all common use cases, when Spring Data offers repository-based access for a target
    database, it’s best to begin—and in all likelihood remain—there.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要直接访问Spring Data模板提供的底层功能，则基于模板的数据库支持是必不可少的。但对于几乎所有常见用例而言，当Spring Data为目标数据库提供基于仓库的访问时，最好从那里开始，并且很可能保持在那里。
- en: Creating a Repository-Based Service Using the Java Persistence API (JPA)
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Java持久化API（JPA）创建基于仓库的服务
- en: 'One of the Spring ecosystem’s strengths is consistency: once you learn how
    to accomplish something, the same approach can be applied to drive successful
    outcomes with different components. Database access is a case in point.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Spring生态系统的一个优点是一致性：一旦您学会了如何完成某件事，同样的方法可以用于推动不同组件的成功结果。数据库访问就是一个例子。
- en: 'Spring Boot and Spring Data provide repository support for a number of different
    databases: JPA-compliant databases, numerous NoSQL datastores of varying types,
    and in-memory and/or persistent stores. Spring smooths the bumps a developer runs
    into when transitioning between databases, whether for a single application or
    throughout a vast system of them.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot和Spring Data为多种不同的数据库提供了仓库支持：符合JPA标准的数据库、多种类型的NoSQL数据存储以及内存中和/或持久存储。Spring能够消除开发人员在不同数据库之间切换时遇到的障碍。
- en: To demonstrate some of the flexible options at your disposal when creating data-aware
    Spring Boot applications, I highlight a few different approaches supported by
    Spring Boot in each of the following sections, while relying on Boot (and Spring
    Data) to streamline the database portion of the different, but similar, services.
    First up is JPA, and for this example I use Lombok throughout to reduce code and
    increase readability.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示在创建数据感知的Spring Boot应用时可以使用的一些灵活选项，我在以下各节中重点介绍了几种不同的方法，同时依赖于Boot（和Spring
    Data）来简化不同但相似服务的数据库部分。首先是JPA，在这个示例中，我始终使用Lombok来减少代码并增加可读性。
- en: Initializing the Project
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化项目
- en: 'Once again we return to the Spring Initializr. This time, I choose the following
    options:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 再次回到Spring Initializr。这一次，我选择以下选项：
- en: Maven project
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Maven项目
- en: Java
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java
- en: Current production version of Spring Boot
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前生产版本的Spring Boot
- en: 'Packaging: Jar'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打包：Jar
- en: 'Java: 11'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java：11
- en: 'And for dependencies:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 并且对于依赖项：
- en: Spring Reactive Web (`spring-boot-starter-webflux`)
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring响应式Web (`spring-boot-starter-webflux`)
- en: Spring Data JPA (`spring-boot-starter-data-jpa`)
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Data JPA (`spring-boot-starter-data-jpa`)
- en: MySQL Driver (`mysql-connector-java`)
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MySQL驱动程序 (`mysql-connector-java`)
- en: Lombok (`lombok`)
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lombok (`lombok`)
- en: Next, I generate the project and save it locally, unzip it, and open it in the
    IDE.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我生成项目并将其保存在本地，解压并在IDE中打开。
- en: Note
  id: totrans-125
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: As with the earlier Redis project and most other examples in this chapter, each
    data-aware service must be able to access a running database. Please refer to
    this book’s associated code repositories for Docker scripts to create and run
    suitable containerized database engines.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前Redis项目和本章中大多数其他示例一样，每个数据感知服务必须能够访问正在运行的数据库。请参考本书的相关代码库以获取创建和运行适合的容器化数据库引擎的Docker脚本。
- en: Developing the JPA (MySQL) Service
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发JPA（MySQL）服务
- en: Considering both [Chapter 4](ch04.xhtml#sbur-04)’s example built using JPA and
    the H2 database and the previous Redis repository-based example, the JPA-based
    service using MariaDB/MySQL clearly demonstrates the way in which Spring’s consistency
    amplifies developer productivity.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到[第4章](ch04.xhtml#sbur-04)使用JPA和H2数据库构建的示例以及之前的Redis基于仓库的示例，明显可以看出使用MariaDB/MySQL的基于JPA的服务展示了Spring一贯的一致性如何增强开发者的生产力。
- en: Defining the domain class
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义领域类
- en: 'As with all of this chapter’s projects, I create an `Aircraft` domain class
    to serve as the primary (data) focus. Each different project will have slight
    variations around a common theme pointed out along the way. Here is the JPA-centric
    `Aircraft` domain class structure:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 与本章所有项目一样，我创建一个`Aircraft`领域类作为主要（数据）关注点。每个不同的项目将围绕一个共同主题进行轻微变化，并在路上指出。这里是以JPA为中心的`Aircraft`领域类结构：
- en: '[PRE18]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: There are a few particulars of note with regard to this version of `Aircraft`
    versus prior versions and those to come.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个版本的`Aircraft`与先前版本及未来版本的一些特殊之处值得注意。
- en: First, the `@Entity`, `@Id`, and `@GeneratedValue` annotations are all imported
    from the `javax.persistence` package. You may remember that in the Redis version
    (and some others), `@Id` comes from `org.springframework.data.annotation`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`@Entity`、`@Id` 和 `@GeneratedValue` 注解都从 `javax.persistence` 包导入。您可能还记得在
    Redis 版本（以及其他一些版本）中，`@Id` 来自于 `org.springframework.data.annotation`。
- en: Class-level annotations closely parallel those used in the example using Redis
    repository support, with the replacement of `@RedisHash` with a JPA `@Entity`
    annotation. To revisit the other (unchanged) annotations shown, please refer to
    the aforementioned earlier section.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 类级别的注解与使用 Redis 仓库支持的示例中使用的注解密切相关，只是将`@RedisHash`替换为 JPA 的`@Entity`注解。要重新访问其他（未更改）所示的注解，请参阅前面提到的较早部分。
- en: Field-level annotations are also similar, with the addition of `@GeneratedValue`.
    As its name implies, `@GeneratedValue` indicates that the identifier will be generated
    by the underlying database engine. The developer can—if desired or necessary—provide
    additional guidance for key generation, but for our purposes, the annotation itself
    is sufficient.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 字段级别的注解也类似，增加了 `@GeneratedValue`。顾名思义，`@GeneratedValue` 表示标识符将由底层数据库引擎生成。开发人员可以—如果需要或必要的话—为键生成提供额外的指导，但对于我们的目的来说，注解本身就足够了。
- en: As with Spring Data’s repository support for Redis, there is no need for explicit
    accessors/mutators for the member variables of type `Instant`, leaving (once again)
    a very svelte `Aircraft` domain class.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Spring Data 对 Redis 的仓库支持一样，对于类型为`Instant`的成员变量，不需要显式访问器/修改器，因此（再次）留下了一个非常苗条的`Aircraft`域类。
- en: Creating the repository interface
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建仓库接口
- en: 'Next, I define the required repository interface, extending Spring Data’s `CrudRepository`
    and providing the type of object to store and its key: `Aircraft` and `Long`,
    in this case:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我定义了所需的仓库接口，扩展了 Spring Data 的`CrudRepository`并提供要存储的对象类型及其键：在本例中是`Aircraft`和`Long`：
- en: '[PRE19]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note
  id: totrans-140
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Both Redis and JPA databases function well with unique key values/identifiers
    of type `Long`, so this is identical to the one defined in the earlier Redis example.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Redis 和 JPA 数据库都可以很好地使用类型为`Long`的唯一键值/标识符，因此这与之前 Redis 示例中定义的相同。
- en: Bringing it all together
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将一切都整合在一起
- en: Now to create the `PlaneFinder` polling component and configure it for database
    access.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在来创建`PlaneFinder`轮询组件并配置它以进行数据库访问。
- en: Polling PlaneFinder
  id: totrans-144
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 轮询 PlaneFinder
- en: Once again I create a Spring Boot `@Component` class to poll for current position
    data and handle the resultant `Aircraft` records it receives.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我再次创建一个 Spring Boot `@Component` 类来轮询当前位置数据，并处理它接收到的`Aircraft`记录。
- en: Like the earlier example, I create a `WebClient` object and assign it to a member
    variable, pointing it to the destination endpoint exposed by the `PlaneFinder`
    service on port 7634.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的示例类似，我创建一个`WebClient`对象，并将其分配给一个成员变量，将其指向端口`7634`上由`PlaneFinder`服务公开的目标端点。
- en: As you should expect from a sibling repository implementation, the code is quite
    similar to the Redis repository endstate. I demonstrate a couple of differences
    in approach for this example.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你从兄弟仓库实现中所期望的那样，代码与 Redis 仓库的最终状态非常相似。我在这个示例中展示了几种不同的方法。
- en: 'Rather than manually creating a constructor via which to receive the autowired
    `AircraftRepository` bean, I instruct Lombok—via its compile-time code generator—to
    provide a constructor with any required member variables. Lombok determines which
    arguments are required via two annotations: `@RequiredArgsConstructor` on the
    class and `@NonNull` on the member variable(s) designated as requiring initialization.
    By annotating the `AircraftRepository` member variable as an `@NonNull` property,
    Lombok creates a constructor with an `AircraftRepository` as a parameter; Spring
    Boot then dutifully autowires the existing repository bean for use within the
    `PlaneFinderPoller` bean.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我指示 Lombok—通过其编译时代码生成器—提供一个构造函数，以接收自动连接的`AircraftRepository` bean，而不是手动创建一个构造函数。Lombok通过两个注解确定哪些参数是必需的：类上的`@RequiredArgsConstructor`和成员变量上的`@NonNull`，指定需要初始化的成员变量。通过将`AircraftRepository`成员变量注释为一个`@NonNull`属性，Lombok创建一个带有`AircraftRepository`作为参数的构造函数；然后
    Spring Boot 忠实地自动连接现有的仓库 bean，以在`PlaneFinderPoller` bean 中使用。
- en: Note
  id: totrans-149
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The wisdom of deleting all stored entries in a database each time a poll is
    conducted depends heavily on requirements, polling frequency, and storage mechanism
    involved. For example, the costs involved in clearing an in-memory database before
    each poll is quite different from deleting all records in a cloud-hosted database’s
    table. Frequent polling also increases associated costs. Alternatives exist; please
    choose wisely.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'To revisit the details of the remaining code in `PlaneFinderPoller`, please
    review the corresponding section under Redis repository support. Refactored to
    take full advantage of Spring Data JPA support, the complete code for `PlaneFinderPoller`
    is shown in the following listing:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Connecting to MariaDB/MySQL
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Spring Boot autoconfigures the application’s environment using all information
    available at runtime; that’s one of the key enablers of its unrivaled flexibility.
    Since there are many JPA-compliant databases supported by Spring Boot and Spring
    Data, we need to provide a few key bits of information for Boot to use to seamlessly
    connect to the database of our choosing for this particular application. For this
    service running in my environment, these properties include:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note
  id: totrans-156
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Both the database name and the database username are “mark” in the example above.
    Replace datasource, username, and password values with those specific to your
    environment.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: The results
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With the `PlaneFinder` service still running on my machine, I start the *sbur-jpa*
    service to obtain, store and retrieve (in MariaDB), and display the results of
    each polling of `PlaneFinder`. An example of the results follows, edited for brevity
    and formatted for readability:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The service works as expected to poll, capture, and display aircraft positions.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Loading Data
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter’s focus thus far has been how to interact with a database when
    data flows into the application. What happens if data exists—sample, test, or
    actual seed data—that must be persisted?
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring Boot has a few different mechanisms to initialize and populate a database.
    I cover what I consider to be the two most useful approaches here:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Using Data Definition Language (DDL) and Data Manipulation Language (DML) scripts
    to initialize and populate
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allowing Boot (via Hibernate) to automatically create the table structure from
    defined `@Entity` class(es) and populating via a repository bean
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each approach to data definition and population has its pros and cons.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: API- or database-specific scripts
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Spring Boot checks the usual root classpath locations for files that fit the
    following naming format:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '*schema.sql*'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*data.sql*'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*schema-${platform}.sql*'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*data-${platform}.sql*'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last two filenames are matched to the developer-assigned application property
    `spring.datasource.platform`. Valid values include `h2`, `mysql`, `postgresql`,
    and other Spring Data JPA databases, and using a combination of the `spring.datasource.platform`
    property and related `.sql` files enables a developer to fully leverage syntax
    specific to that particular database.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Creating and populating with scripts
  id: totrans-175
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To leverage scripts to create and populate a MariaDB/MySQL database in the
    most straightforward way, I create two files under the `resources` directory of
    the *sbur-jpa* project: *schema-mysql.sql* and *data-mysql.sql*.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the `aircraft` table schema, I add the following DDL to *schema-mysql.sql*:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To populate the `aircraft` table with a single sample row, I add the following
    DML to *data-mysql.sql*:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'By default, Boot automatically creates table structures from any classes annotated
    with `@Entity`. It’s simple to override this behavior with the following property
    settings, shown here from the app’s *application.properties* file:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Setting `spring.datasource.initialization-mode` to “always” indicates that the
    app is expecting to use an external (nonembedded) database and should initialize
    it each time the application executes. Setting `spring.jpa.hibernate.ddl-auto`
    to “none” disables Spring Boot’s automatic table creation from `@Entity` classes.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'To verify that the preceding scripts are being used to create and populate
    the `aircraft` table, I visit the `PlaneFinderPoller` class and do the following:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Comment out the `repository.deleteAll();` statement in `pollPlanes()`. This
    is necessary to avoid deleting the record added via *data-mysql.sql*.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comment out the `client.get()...` statement, also in `pollPlanes()`. This results
    in no additional records being retrieved and created from polling the external
    `PlaneFinder` service for easier verification.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Restarting the *sbur-jpa* service now results in the following output (`id`
    fields may differ), edited for brevity and formatted for clarity:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note
  id: totrans-189
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The only record saved is the one specified in *data-mysql.sql*.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 'Like all approaches to anything, there are pros and cons to this method of
    table creation and population. Upsides include:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: The ability to directly use SQL scripts, both DDL and DML, leveraging existing
    scripts and/or SQL expertise
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access to SQL syntax specific to the chosen database
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Downsides aren’t particularly serious but should be recognized:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Using SQL files is obviously specific to SQL-supporting relational databases.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scripts can rely on SQL syntax for a particular database, which can require
    editing if the choice of underlying database changes.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some (two) application properties must be set to override default Boot behavior.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Populating the database using the application’s repository
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There is another way, one that I find particularly powerful and more flexible:
    using Boot’s default behavior to create the table structures (if they don’t already
    exist) and the application’s repository support to populate sample data.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'To restore Spring Boot’s default behavior of creating the `aircraft` table
    from the `Aircraft` JPA `@Entity` class, I comment out the two properties just
    added to *application.properties*:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: With these properties no longer being defined, Spring Boot will not search for
    and execute *data-mysql.sql* or other data initialization scripts.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, I create a class with a purpose-descriptive name like `DataLoader`. I
    add class-level annotations of `@Component` (so Spring creates a `DataLoader`
    bean) and `@AllArgsConstructor` (so Lombok creates a constructor with a parameter
    for each member variable). I then add a single member variable to hold the `AircraftRepository`
    bean Spring Boot will autowire for me via constructor injection:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'And a method called `loadData()` to both clear and populate the `aircraft`
    table:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'And that’s it. Really. Restarting the the *sbur-jpa* service now results in
    the output that follows (`id` fields may differ), edited for brevity and formatted
    for clarity:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note
  id: totrans-209
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The only record saved is the one defined in the previous `DataLoader` class,
    with one small difference: since the `id` field is generated by the database (as
    specified in the `Aircraft` domain class specification), the provided `id` value
    is replaced by the database engine when the record is saved.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'Advantages of this approach are significant:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Fully database independent.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any code/annotations specific to a particular database are already within the
    app simply to support db access.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easy to disable by simply commenting out the `@Component` annotation on the
    `DataLoader` class.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other mechanisms
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These are two powerful and widely used options for database initialization and
    population, but there are other options, including using Hibernate support for
    an *import.sql* file (similar to the JPA approach introduced earlier), using external
    imports, and using FlywayDB, among others. Exploring the numerous other options
    is out of scope for this book and is left as an optional exercise for the reader.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Repository-Based Service Using a NoSQL Document Database
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned earlier, there are several ways to further enhance developer productivity
    when creating applications using Spring Boot. One of these is to increase code
    conciseness by using Kotlin as the foundational app language.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: An exhaustive exploration of the Kotlin language is well beyond the scope of
    this book, and there are other books that fulfill that role. Fortunately, though,
    while Kotlin definitely differs from Java in numerous meaningful ways, it is similar
    enough to pose no great hardship in adapting to its idioms with a few well-placed
    explanations when things diverge from the “Java way.” I’ll endeavor to provide
    those explanations as I proceed; for background or additional information, please
    refer to Kotlin-specific tomes.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Kotlin 语言的详尽探索远超出本书的范围，也有其他的书籍来满足这一角色。不过幸运的是，尽管 Kotlin 在许多有意义的方面与 Java 有所不同，但它与
    Java 相似到足以在事物背离“Java 方式”时通过几处恰当的解释来适应其习惯。我将在继续进行时努力提供这些解释；有关背景或额外信息，请参考专门的 Kotlin
    书籍。
- en: 'For this example, I use MongoDB. Perhaps the best-known document datastore,
    MongoDB is widely used and wildly popular for good reason: it works well and generally
    makes life easier for developers to store, manipulate, and retrieve data in all
    of its varied (and sometimes messy) forms. The team at MongoDB also constantly
    strives to improve their feature set, security, and APIs: MongoDB was one of the
    first databases to offer reactive database drivers, leading the industry in taking
    nonblocking access all the way down to the database level.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 作为例子，我使用 MongoDB。作为可能最知名的文档数据库，MongoDB 因其良好的工作方式和广泛的使用而广受欢迎，这对开发人员来说通常更容易存储、操作和检索各种数据（有时是混乱的形式）。MongoDB
    团队还不断努力改进其功能集、安全性和 API：MongoDB 是第一批提供反应式数据库驱动程序的数据库之一，引领行业将非阻塞访问扩展到数据库级别。
- en: Initializing the Project
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化项目
- en: 'As you might expect, we return to the Spring Initializr to get started. For
    this project, I choose the following options (also shown in [Figure 6-1](#using_the_spring_boot_initialzr_to_create_a_kotlin_application))—somewhat
    of a departure from prior visits:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所预期的，我们回到 Spring Initializr 开始工作。对于这个项目，我选择了以下选项（也显示在 [图 6-1](#using_the_spring_boot_initialzr_to_create_a_kotlin_application)）——与以前的访问有所不同：
- en: Gradle project
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gradle 项目
- en: Kotlin
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kotlin
- en: Current production version of Spring Boot
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前生产版本的 Spring Boot
- en: 'Packaging: Jar'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打包：Jar
- en: 'Java: 11'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java：11
- en: 'And for dependencies:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 并且对于依赖项：
- en: Spring Reactive Web (`spring-boot-starter-webflux`)
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring 响应式 Web (`spring-boot-starter-webflux`)
- en: Spring Data MongoDB (`spring-boot-starter-data-mongodb`)
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring 数据 MongoDB (`spring-boot-starter-data-mongodb`)
- en: Embedded MongoDB Database (`de.flapdoodle.embed.mongo`)
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嵌入式 MongoDB 数据库 (`de.flapdoodle.embed.mongo`)
- en: Next, I generate the project and save it locally, unzip it, and open it in the
    IDE.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我生成项目并将其保存在本地，解压并在 IDE 中打开。
- en: '![sbur 0601](Images/sbur_0601.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![sbur 0601](Images/sbur_0601.png)'
- en: Figure 6-1\. Using the Spring Boot Initializr to create a Kotlin application
  id: totrans-234
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-1\. 使用 Spring Boot Initializr 创建 Kotlin 应用程序
- en: 'A couple of things of particular note about the options selected: First, I
    chose Gradle for this project’s build system for good reason—simply choosing to
    use Gradle with Kotlin in a Spring Boot project results in the Gradle build file
    using the Kotlin DSL, which is supported by the Gradle team on equal footing with
    the Groovy DSL. Note that the resultant build file is *build.gradle.kts*—the .kts
    extension indicates it is a Kotlin script—rather than the Groovy-based *build.gradle*
    file you may be accustomed to seeing. Maven works perfectly well as a build system
    for Spring Boot + Kotlin applications too, but being an XML-based declarative
    build system, it doesn’t directly use Kotlin or any other language.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 关于所选选项的几个特别注意事项：首先，我选择了 Gradle 作为这个项目的构建系统，这是有充分理由的——在 Spring Boot 项目中选择使用 Gradle
    仅仅会导致 Gradle 构建文件使用 Kotlin DSL，这与 Groovy DSL 在 Gradle 团队中的支持地位不相上下。请注意，生成的构建文件是
    *build.gradle.kts* —— .kts 扩展名表明它是一个 Kotlin 脚本 —— 而不是您习惯看到的基于 Groovy 的 *build.gradle*
    文件。对于 Spring Boot + Kotlin 应用程序，Maven 也完全可以作为一个很好的构建系统，但作为基于 XML 的声明式构建系统，它不直接使用
    Kotlin 或任何其他语言。
- en: 'Second, I took advantage of the presence of a Spring Boot Starter for an embedded
    MongoDB database for this application. Because an embedded MongoDB instance is
    meant solely for testing, I advise against using it in a production setting; that
    said, it’s a wonderful option for demonstrating how Spring Boot and Spring Data
    work with MongoDB, and from the developer’s perspective, it matches locally deployed
    database capabilities without the additional steps of installing and/or running
    a containerized instance of MongoDB. The only adjustment necessary to use the
    embedded database from (nontest) code is to change a single line in *build.gradle.kts*
    from this:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我利用了此应用程序的嵌入式 MongoDB 数据库的 Spring Boot Starter 的存在。因为嵌入式 MongoDB 实例仅用于测试，我建议不要在生产环境中使用它；话虽如此，它是一个很好的选择，可以演示
    Spring Boot 和 Spring Data 如何与 MongoDB 协作，并且从开发者的角度来看，它与本地部署的数据库功能匹配，而无需安装和/或运行一个容器化的
    MongoDB 实例的额外步骤。从（非测试）代码中使用嵌入式数据库所需的唯一调整是在 *build.gradle.kts* 中更改一行，从这样：
- en: '[PRE31]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'to this:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 到这个：
- en: '[PRE32]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: And with that, we’re ready to create our service.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们准备好创建我们的服务了。
- en: Developing the MongoDB Service
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发 MongoDB 服务
- en: As with previous examples, the MongoDB-based service offers a very consistent
    approach and experience, even when using Kotlin instead of Java as the language
    foundation.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的示例一样，基于 MongoDB 的服务在使用 Kotlin 而不是 Java 作为语言基础时，提供了非常一致的方法和体验。
- en: Defining the domain class
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义域类
- en: 'For this project I create a Kotlin `Aircraft` domain class to serve as the
    primary (data) focus. Here is the new `Aircraft` domain class structure with a
    few observations following:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，我创建了一个 Kotlin `Aircraft` 域类来作为主要（数据）关注点。以下是带有一些观察的新`Aircraft`域类结构：
- en: '[PRE33]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The first thing to note is that there are no curly braces to be seen; put succinctly,
    this class has no body. If you’re new to Kotlin, this may seem a bit unusual,
    but in cases where there is nothing to place in a class (or interface) body, curly
    braces add no value. As such, Kotlin doesn’t require them.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的第一件事是没有看到花括号；简单地说，这个类没有主体。如果你是 Kotlin 的新手，这可能看起来有点不寻常，但是在没有东西放在类（或接口）主体中的情况下，花括号没有添加任何值。因此，Kotlin
    不需要它们。
- en: The second interesting thing is the many assignments shown between parentheses
    immediately after the classname. What purpose do these serve?
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 第二件有趣的事情是类名后面紧跟的括号中显示的许多赋值。这些的用途是什么？
- en: 'A Kotlin class’s primary constructor is often shown this way: in the class
    header, immediately following the classname. Here is an example of the full, formal
    format:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 类的主构造函数通常是这样显示的：在类头中，紧跟在类名之后。以下是完整的、正式格式的示例：
- en: '[PRE34]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As is often the case in Kotlin, if a pattern is clearly identifiable and repeats
    consistently, it can be condensed. Removing the `constructor` keyword before the
    parameter list leads to no confusion with any other language construct, so it
    is optional.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 像 Kotlin 中经常发生的那样，如果一个模式很清晰可辨并且重复一致，它可以被压缩。在参数列表之前删除`constructor`关键字不会与任何其他语言构造混淆，因此是可选的。
- en: Within the constructor are parameters. By placing a `var` (for repeatedly assignable
    mutable variables) or `val` (for single-assignment values equivalent to Java’s
    `final` variables) before each parameter, it also becomes a property. A Kotlin
    property is roughly equivalent in function to a Java member variable, its accessor,
    and (if declared with `var`) its mutator combined.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数中包含参数。通过在每个参数前放置`var`（用于可重复赋值的可变变量）或`val`（用于单次赋值的值，相当于Java的`final`变量），它也变成了一个属性。
    Kotlin 属性在功能上大致相当于 Java 成员变量、其访问器和（如果用`var`声明）其变化器的组合。
- en: The values with types containing a question mark (?), e.g., `Double?`, indicate
    that the constructor parameter may be omitted. If so, that parameter is assigned
    the default value shown after the equals sign (=).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 具有包含问号（？）的类型的值，例如，`Double?`，表示构造函数参数可能被省略。如果是这样，该参数被分配在等号（=）后显示的默认值。
- en: Kotlin method (including constructor) parameters and properties can also include
    annotations, just like their Java counterparts. `@Id` and `@JsonProperty` perform
    the same functions that they did in earlier Java examples.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 方法（包括构造函数）参数和属性也可以包括注释，就像它们的 Java 对应项一样。`@Id`和`@JsonProperty`执行与先前 Java
    示例中相同的功能。
- en: Regarding class-level annotations, `@Document` indicates to MongoDB that each
    object of type `Aircraft` will be stored as a document within the database. As
    before, `@JsonIgnoreProperties(ignoreUnknown = true)` simply builds a bit of flexibility
    into the *sbur-mongo* service; if at some point additional fields are added to
    the data feed produced by the upstream `PlaneFinder` service, they will simply
    be ignored and *sbur_mongo* will continue to run without issue.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: The final point of note is the word `data` that precedes the class definition.
    It’s a frequent pattern to create domain classes that serve primarily as data
    buckets to be manipulated and/or passed between processes. It’s such a common
    pattern in fact that the capability to create so-called data classes manifests
    itself in several ways; as one example, `@Data` has been a feature of Lombok for
    years.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: 'Kotlin rolled this capability into the language itself and added the `data`
    keyword to signal that a data class automatically derives the following from all
    properties declared in the class’s primary constructor:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '`equals()` and `hashCode()` functions (Java has methods; Kotlin has functions)'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`toString()`'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`componentN()` functions, one for each property in the order in which they
    were declared'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`copy()` function'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kotlin data classes have certain requirements and limitations, but they are
    reasonable and minimal. For details, please refer to the Kotlin documentation
    for [data classes](https://kotlinlang.org/docs/reference/data-classes.html#data-classes).
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-262
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: One other change of interest is the type of each aircraft position’s `id` field/property.
    In Redis and JPA, it was a `Long`; but MongoDB uses a `String` for its unique
    document identifier. This is of no real consequence, only something to be aware
    of.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: Creating the repository interface
  id: totrans-264
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, I define the required repository interface, extending Spring Data’s `CrudRepository`
    and providing the type of object to store and its unique identifier: `Aircraft`
    and `String`, as mentioned earlier:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'There are two things of interest in this concise interface definition:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: With no actual interface body, no curly braces are required in Kotlin. If your
    IDE added them when you created this interface, you can safely remove them.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Kotlin uses the colon (:) contextually to indicate a `val` or `var` type, or
    in this case, to indicate that a class or interface extends or implements another.
    In this particular instance, I define an interface `AircraftRepository`, and it
    extends the `CrudRepository` interface.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  id: totrans-270
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: There is a `MongoRepository` interface that extends both `PagingAndSortingRepository`
    (which extends `CrudRepository`) and `QueryByExampleExecutor` that can be used
    instead of `CrudRepository`, as I do here. But unless the additional capabilities
    are required, it is a good practice and habit to write to the highest-level interface
    that satisfies all requirements. In this case, `CrudRepository` is sufficient
    for current needs.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Bringing it all together
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next step is to create the component that periodically polls the `PlaneFinder`
    service.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建定期轮询`PlaneFinder`服务的组件。
- en: Polling PlaneFinder
  id: totrans-274
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 轮询 PlaneFinder
- en: 'Similar to earlier examples, I create a Spring Boot component class `PlaneFinderPoller`
    to poll for current position data and handle any `Aircraft` records received,
    as shown here:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 与早期示例类似，我创建了一个Spring Boot组件类`PlaneFinderPoller`来轮询当前位置数据并处理接收到的任何`Aircraft`记录，如下所示：
- en: '[PRE36]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'I create the primary constructor in the header with an `AircraftRepository`
    parameter. Spring Boot automatically autowires the existing `AircraftRepository`
    bean into the `PlaneFinderPoller` component for use, and I mark it as a `private
    val` to ensure the following:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我在头部创建了主构造函数，并带有一个`AircraftRepository`参数。Spring Boot自动将现有的`AircraftRepository`
    bean自动装配到`PlaneFinderPoller`组件中供使用，并将其标记为`private val`以确保以下内容：
- en: It isn’t assignable later.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以后不可重新分配。
- en: It isn’t exposed externally as a property from the `PlaneFinderPoller` bean,
    as the repository is already accessible throughout the application.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不作为`PlaneFinderPoller` bean的属性对外暴露，因为存储库已经可以在整个应用程序中访问。
- en: Next, I create a `WebClient` object and assign it to a property, pointing it
    to the destination endpoint exposed by the `PlaneFinder` service on port 7634.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我创建一个`WebClient`对象并将其分配给一个属性，指向由`PlaneFinder`服务在7634端口上暴露的目标端点。
- en: I annotate the class with `@Component` to have Spring Boot create a component
    (bean) upon application startup and `@EnableScheduling` to enable periodic polling
    via an annotated function to follow.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用`@Component`对类进行注释，以便Spring Boot在应用程序启动时创建一个组件（bean），并使用`@EnableScheduling`来启用通过注解的函数进行定期轮询。
- en: And finally, I create a function to delete all existing `Aircraft` data, poll
    the `PlaneFinder` endpoint via the `WebClient` client property, convert and store
    the retrieved aircraft positions in MongoDB, and display them. The `@Scheduled(fixedRate
    = 1000)` results in the polling function being executed once every 1,000 ms (once
    per second).
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我创建一个函数来删除所有现有的`Aircraft`数据，通过`WebClient`客户端属性轮询`PlaneFinder`端点，将检索到的飞机位置转换并存储在MongoDB中，并显示它们。`@Scheduled(fixedRate
    = 1000)`导致轮询函数每1000毫秒执行一次（每秒一次）。
- en: There are three more interesting things to note in the `pollPlanes()` function,
    and both regard Kotlin’s lambdas.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在`pollPlanes()`函数中还有三个更有趣的事情需要注意，这些都涉及Kotlin的 lambda。
- en: First is that if a lambda is the final parameter of a function, parentheses
    can be omitted, as they add nothing to clarity or meaning. If a function has only
    a single parameter of a lambda, this fits the criteria as well, of course. This
    results in fewer symbols to sift through in sometimes busy lines of code.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 首先是，如果 lambda 是函数的最后一个参数，则可以省略括号，因为它们对于清晰度或含义没有任何增加。如果函数只有一个 lambda 参数，这也符合条件。这样做可以减少在有时繁忙的代码行中需要查找的符号数量。
- en: 'Second is that if a lambda itself has a single parameter, a developer can still
    explicitly specify it but isn’t required to do so. Kotlin implicitly recognizes
    and refers to a sole lambda parameter as `it`, which further streamlines lambdas,
    as demonstrated by this lambda parameter to `forEach()`:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个是，如果 lambda 本身具有单个参数，开发人员仍然可以显式指定它，但不是必需的。Kotlin隐式识别并引用唯一的 lambda 参数作为`it`，进一步简化
    lambda，正如此 lambda 参数传递给`forEach()`所示：
- en: '[PRE37]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Finally, the function `isNullOrEmpty()` that operates on a `CharSequence` provides
    a very nice all-in-one capability for String evaluation. This function performs
    both a null check (first), then if the value is determined to be non-null, it
    checks to see if it has zero length, i.e., is empty. There are many times that
    a developer can process properties only if they contain actual values, and this
    single function performs both validations in one step. If a value exists in the
    `Aircraft`’s registration property `reg`, that incoming aircraft position report
    is passed along; aircraft position reports with missing registration values are
    filtered out.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，函数`isNullOrEmpty()`操作`CharSequence`提供了一个非常好的全能功能进行字符串评估。此函数首先执行空值检查，然后如果确定值为非空，则检查其长度是否为零，即为空。开发人员经常只有在属性包含实际值时才能处理它们，而此单一函数一次性执行两个验证步骤。如果在`Aircraft`的注册属性`reg`中存在值，则将传递该传入的飞机位置报告；缺少注册值的飞机位置报告将被过滤掉。
- en: All remaining position reports are streamed to the repository to be saved, then
    we query the repository for all persisted documents and display the results.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 所有剩余的位置报告都会被流向存储库进行保存，然后我们查询存储库中的所有持久化文档并显示结果。
- en: The results
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结果
- en: 'With the `PlaneFinder` service running on my machine, I start the *sbur-mongo*
    service to obtain, store and retrieve (in an embedded MongoDB instance), and display
    the results of each polling of `PlaneFinder`. An example of the results follows,
    edited for brevity and formatted for readability:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: As expected, the service polls, captures, and displays aircraft positions without
    issue using Spring Boot, Kotlin, and MongoDB to make it nearly effortless.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Repository-Based Service Using a NoSQL Graph Database
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Graph databases bring a different approach to data, in particular how it’s interrelated.
    There are a few graph databases on the market, but for all intents and purposes,
    the segment leader is Neo4j.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: While graph theory and graph database design is far afield of the scope of this
    book, demonstrating how best to work with a graph database using Spring Boot and
    Spring Data falls squarely within its purview. This section shows you how to easily
    connect to and work with data using Spring Data Neo4j in your Spring Boot application.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: Initializing the Project
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once more we return to the Spring Initializr. This time, I choose the following
    options:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: Gradle project
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Current production version of Spring Boot
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Packaging: Jar'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Java: 11'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And for dependencies:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: Spring Reactive Web (`spring-boot-starter-webflux`)
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Data Neo4j (`spring-boot-starter-data-neo4j`)
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, I generate the project and save it locally, unzip it, and open it in the
    IDE.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: I chose Gradle for this project’s build system solely to demonstrate that when
    creating a Spring Boot Java application using Gradle, the generated *build.gradle*
    file uses the Groovy DSL, but Maven is a valid option as well.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-308
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As with most other examples in this chapter, I have a Neo4j database instance
    running in a locally hosted container, ready to respond to this application.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: And with that, we’re ready to create our service.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: Developing the Neo4j Service
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As with previous examples, Spring Boot and Spring Data make the experience of
    working with Neo4j databases highly consistent with using other types of underlying
    datastores. The full power of a graph datastore is available and easily accessible
    from Spring Boot applications, but ramp-up is drastically reduced.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: Defining the domain class
  id: totrans-313
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once more I begin by defining the `Aircraft` domain. Without Lombok as a dependency,
    I create it with the usual extensive list of constructors, accessors, mutators,
    and supporting methods:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Java code can indeed be verbose. To be fair this isn’t a huge problem in cases
    like domain classes, because while accessors and mutators take up a significant
    amount of space, they can be generated by IDEs and typically don’t involve much
    maintenance due to their long-term stability. That said, it *is* a lot of boilerplate
    code, which is why many developers use solutions like Lombok or Kotlin—even if
    only creating domain classes in Kotlin for Java applications.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-317
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Neo requires a database-generated unique identifier, even if entities being
    persisted contain a unique identifier already. To satisfy this requirement, I
    add a `neoId` parameter/member variable and annotate it with `@Id` and `GeneratedValue`
    so Neo4j correctly associates this member variable with the value it generates
    internally.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: Neo要求具有数据库生成的唯一标识符，即使被持久化的实体已包含唯一标识符。为满足此要求，我添加了一个`neoId`参数/成员变量，并用`@Id`和`GeneratedValue`对其进行了注释，以便Neo4j正确地将此成员变量与其内部生成的值关联起来。
- en: 'Next, I add two class-level annotations:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我添加了两个类级别的注解：
- en: '`@Node`:: To designate each instance of this `record` as an instance of the
    Neo4j node `Aircraft` `@JsonIgnoreProperties(ignoreUnknown = true)`:: To ignore
    new fields that might be added to feed from the `PlaneFinder` service endpoint'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Node`：将每个此`record`实例指定为Neo4j节点`Aircraft`的一个实例`@JsonIgnoreProperties(ignoreUnknown
    = true)`：忽略可能添加到`PlaneFinder`服务端点的新字段'
- en: Note that like `@Id` and `@GeneratedValue`, the `@Node` annotation is from the
    `org.springframework.data.neo4j.core.schema` package for Spring Data Neo4j-based
    applications.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，像`@Id`和`@GeneratedValue`一样，`@Node`注解来自于Spring Data Neo4j的`org.springframework.data.neo4j.core.schema`包，用于基于Spring
    Data Neo4j的应用程序。
- en: With that, the domain for our service is defined.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们定义了服务的领域。
- en: Creating the repository interface
  id: totrans-323
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建仓库接口
- en: 'For this application I again define the required repository interface, extending
    Spring Data’s `CrudRepository` and providing the type of object to store and its
    key: `Aircraft` and `Long`, in this case:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此应用程序，我再次定义了所需的仓库接口，扩展了Spring Data的`CrudRepository`并提供了要存储的对象类型及其键：在这种情况下是`Aircraft`和`Long`。
- en: '[PRE40]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Note
  id: totrans-326
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Similar to the earlier MongoDB-based project, there is a `Neo4jRepository` interface
    that extends `PagingAndSortingRepository` (which extends `CrudRepository`) that
    can used instead of `CrudRepository`; however, since `CrudRepository` is the highest-level
    interface that satisfies all requirements, I use it as the basis for `AircraftRepository`.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于早期基于MongoDB的项目，这里有一个`Neo4jRepository`接口，它扩展了`PagingAndSortingRepository`（它又扩展了`CrudRepository`），可以用来替代`CrudRepository`；然而，由于`CrudRepository`是满足所有要求的最高级别接口，我将其用作`AircraftRepository`的基础。
- en: Bringing it all together
  id: totrans-328
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将所有内容汇总
- en: Now to create the component to poll `PlaneFinder` and configure it to access
    the Neo4j database.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 现在创建组件以轮询`PlaneFinder`并配置它以访问Neo4j数据库。
- en: Polling PlaneFinder
  id: totrans-330
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 轮询PlaneFinder
- en: Once more I create a Spring Boot `@Component` class to poll for current aircraft
    positions and handle `Aircraft` records received.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 再次创建一个Spring Boot `@Component`类来轮询当前飞机位置并处理接收到的`Aircraft`记录。
- en: Like other Java-based projects in this chapter, I create a `WebClient` object
    and assign it to a member variable, pointing it to the destination endpoint exposed
    by the `PlaneFinder` service on port 7634.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于本章其他基于Java的项目，我创建了一个`WebClient`对象，并将其分配给成员变量，指向由`PlaneFinder`服务在7634端口上公开的目标端点。
- en: Without Lombok as a dependency, I create a constructor via which to receive
    the autowired `AircraftRepository` bean.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有Lombok作为依赖项的情况下，我通过构造函数创建了一个接收@Autowired的`AircraftRepository` bean。
- en: 'As shown in the following full listing of the `PlaneFinderPoller` class, the
    `pollPlanes()` method looks nearly identical to other examples, owing to the abstractions
    brought to bear by repository support. To revisit any other details of the remaining
    code in `PlaneFinderPoller`, please review the corresponding section under earlier
    sections:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示的完整列出了`PlaneFinderPoller`类，`pollPlanes()`方法与其他示例几乎相同，这要归功于仓库支持带来的抽象。如果需要重新查看`PlaneFinderPoller`中其余代码的任何细节，请查阅前面章节中的相应部分：
- en: '[PRE41]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Connecting to Neo4j
  id: totrans-336
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 连接到Neo4j
- en: 'As with the earlier MariaDB/MySQL example, we need to provide a few key bits
    of information for Boot to use to seamlessly connect to a Neo4j database. For
    this service running in my environment, these properties include:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 与早期的MariaDB/MySQL示例类似，我们需要提供一些关键信息，以便Boot能够无缝连接到Neo4j数据库。对于我环境中运行的此服务，这些属性包括：
- en: '[PRE42]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Note
  id: totrans-339
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Replace username and password values shown with those specific to your environment.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 将显示的用户名和密码值替换为与您的环境特定的值。
- en: The results
  id: totrans-341
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结果
- en: 'With the `PlaneFinder` service running on my machine, I start the *sbur-neo*
    service to obtain, store and retrieve, and display the results of each polling
    of `PlaneFinder` using Neo4j as the datastore of choice. An example of the results
    follows, edited for brevity and formatted for readability:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The service is fast and efficient, using Spring Boot and Neo4j to retrieve,
    capture, and display aircraft positions as they’re reported.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: Code Checkout Checkup
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For complete chapter code, please check out branch *chapter6end* from the code
    repository.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data can be a complex topic with innumerable variables and constraints, including
    data structures, relationships, applicable standards, providers and mechanisms,
    and more. Yet without data in some form, most applications provide little or no
    value.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: As something that forms the foundation of nearly all application value, “data”
    has attracted a great deal of innovation from database providers and platform
    vendors. In many cases, though, complexity remains, and developers have to tame
    that complexity to unlock the value.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: Spring Data’s stated mission is “to provide a familiar and consistent, Spring-based
    programming model for data access while still retaining the special traits of
    the underlying data store.” Regardless of database engine or platform, Spring
    Data’s goal is to make the developer’s use of data as simple and as powerful as
    humanly possible.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter demonstrated how to streamline data storage and retrieval using
    various database options and the Spring Data projects and facilities that enable
    their use in the most powerful ways possible: via Spring Boot.'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, I’ll show how to create imperative applications using Spring
    MVC’s REST interactions, messaging platforms, and other communications mechanisms,
    as well as provide an introduction to templating language support. While this
    chapter’s focus was from the application downward, [Chapter 7](ch07.xhtml#sbur-07)
    focuses on the application outward.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
