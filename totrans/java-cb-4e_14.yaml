- en: Chapter 14\. Processing JSON Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 14.0 Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JSON, or JavaScript Object Notation, is all of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A simple, lightweight data interchange format.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A simpler, lighter alternative to XML.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easy to generate with `println()` or with one of several APIs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recognized directly by the JavaScript parser in all web browsers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supported with add-on frameworks for all common languages (Java, C/C++, Perl,
    Ruby, Python, Lua, Erlang, Haskell, to name a few); a ridiculously long list of
    supported languages (including two dozen parsers for Java alone) is right on the
    [home page](http://json.org).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A simple JSON message might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*json/src/main/resources/json/softwareinfo.json/*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the syntax is simple, nestable, and amenable to human inspection.
  prefs: []
  type: TYPE_NORMAL
- en: '[The JSON home page](http://json.org) provides a concise summary of JSON syntax.
    There are two kinds of structure: JSON objects (maps) and JSON arrays (lists).
    JSON objects are sets of name and value pairs, which can be represented either
    as a `java.util.Map` *or* as the properties of a Java object. For example, the
    fields of a `LocalDate` (see [Recipe 6.1](ch06.html#javacook-dates-SECT-1)) object
    for April 1, 2019, might be represented like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'JSON arrays are ordered lists, represented in Java either as arrays or as `java.util.List`s.
    A list of two dates might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'JSON is free-format, so the preceding could also be written, with some loss
    of human readability but no loss of information or functionality, as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Hundreds of parsers have, I’m sure, been written for JSON. A few that come
    to mind in the Java world include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`stringtree.org`'
  prefs: []
  type: TYPE_NORMAL
- en: Very small and lightweight
  prefs: []
  type: TYPE_NORMAL
- en: '`json.org parser`'
  prefs: []
  type: TYPE_NORMAL
- en: Widely used because it’s free and has a good domain name
  prefs: []
  type: TYPE_NORMAL
- en: '`jackson.org parser`'
  prefs: []
  type: TYPE_NORMAL
- en: Widely used because it’s very powerful and used with Spring Framework and with
    JBoss RESTEasy and Wildfly
  prefs: []
  type: TYPE_NORMAL
- en: '`javax.json`'
  prefs: []
  type: TYPE_NORMAL
- en: Oracle’s official but currently EE-only standard
  prefs: []
  type: TYPE_NORMAL
- en: This chapter shows several ways of processing JSON data using some of the various
    APIs just listed. The official `javax.json` API is only included in the Java EE,
    not the Java SE, so it is unlikely to see very much use on the client side. This
    API uses some names in common with the `org.json` API, but not enough to be considered
    compatible.
  prefs: []
  type: TYPE_NORMAL
- en: Because this is a book for client-side Java developers, nothing will be made
    of the ability to process JSON directly in server-generated, browser-based JavaScript,
    though this can be very useful in building enterprise applications.
  prefs: []
  type: TYPE_NORMAL
- en: 14.1 Generating JSON Directly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to generate JSON without bothering to use an API.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Get the data you want, and use `println()` or `String.format()` as appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you are careful, you can generate JSON data yourself. For the utterly trivial
    cases, you can just use `PrintWriter.println()` or `String.format()`. For significant
    volumes, however, it’s usually better to use one of the APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'This code prints the year, month, and date from a `LocalTime` object (see [Recipe
    6.1](ch06.html#javacook-dates-SECT-1)). Some of the JSON formatting is delegated
    to the `toJson()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Of course, this is an extremely trivial example. For anything more involved,
    or for the common case of having to parse JSON objects, using one of the frameworks
    will be easier on your nerves.
  prefs: []
  type: TYPE_NORMAL
- en: 14.2 Parsing and Writing JSON with Jackson
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to read and/or write JSON using a full-function JSON API.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use Jackson, the full-blown JSON API.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Jackson provides many ways of working. For simple cases, you can have POJO (Plain
    Old Java Objects) converted to/from JSON more or less automatically, as is illustrated
    in [Example 14-1](#javacook-json-jackson-readwrite).
  prefs: []
  type: TYPE_NORMAL
- en: Example 14-1\. json/src/main/java/json/ReadWriteJackson.java (reading and writing
    POJOs with Jackson)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_processing_json_data_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Create a Jackson `ObjectMapper` that can map POJOs to/from JSON.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_processing_json_data_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Map the string `jsonInput` into a `Person` object with one call to `readValue()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_processing_json_data_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Convert the `Person` object `p` into JSON with one call to `writeValue()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running this example produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As another example, this code reads the example file that opened this chapter
    (which happens to have been a description of a JSON parser). Notice the declaration
    `List<String>` for the array of contributors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_processing_json_data_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The `ObjectMapper` does the actual parsing of the JSON input.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running this example produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Of course there are cases where the mapping gets more involved; for this purpose,
    Jackson provides a set of annotations to control the mapping. But the default
    mapping is pretty good!
  prefs: []
  type: TYPE_NORMAL
- en: There is also a streaming API for Jackson; refer to the website for details.
  prefs: []
  type: TYPE_NORMAL
- en: 14.3 Parsing and Writing JSON with org.json
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to read/write JSON using a midsized, widely used JSON API.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Consider using the org.json API , also known as JSON-Java; it’s widely used
    and is also used in Android.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The *org.json* package is not as advanced as Jackson, nor as high level; it
    makes you think and work in terms of the underlying JSON abstractions instead
    of at the Java code level. For example, here is the *org.json* version of reading
    the software description from the opening of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_processing_json_data_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Create the `JSONObject` from the input.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_processing_json_data_CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Retrieve individual `String` fields.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_processing_json_data_CO3-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Retrieve the `JSONArray` of contributor names.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_processing_json_data_CO3-4)'
  prefs: []
  type: TYPE_NORMAL
- en: '`org.json.JSONArray` doesn’t implement `Iterable`, so you can’t use a `forEach`
    loop.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Running it produces the expected output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`JSONObject` and `JSONArray` use their `toString()` method to produce (correctly
    formatted) JSON strings, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_processing_json_data_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Nice that it offers a fluent API to allow chaining of method calls.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_processing_json_data_CO4-2)'
  prefs: []
  type: TYPE_NORMAL
- en: '`toString()` converts to textual JSON representation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Running this produces the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The org.json library code including its javadoc documentation is online at [*https://github.com/stleary/JSON-java*](https://github.com/stleary/JSON-java).
    (under the name JSON-java to differentiate it from the other packages).
  prefs: []
  type: TYPE_NORMAL
- en: 14.4 Parsing and Writing JSON with JSON-B
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to read/write JSON using a midsized, standards-conforming JSON API.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Consider using JSON-B, the new Java standard (JSR-367).
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The JSON-B (JSON Binding) API is designed to make it simple to read/write Java
    POJOs. This is neatly illustrated by the code in [Example 14-2](#javacook-json-jsonb-code1).
  prefs: []
  type: TYPE_NORMAL
- en: Example 14-2\. json/src/main/java/json/ReadWriteJsonB.java (reading/writing
    JSON with JSON-B)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_processing_json_data_CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `Jsonb` object, your gateway to JSON-B services.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_processing_json_data_CO5-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Obtain a JSON string, and convert it to a Java object using `jsonb.fromJson()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_processing_json_data_CO5-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Convert a `Person` object back to a JSON string using the inverse `jsonb.toJson()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the methods are sensibly named and that no annotations are needed
    on the Java entity class to make this work. However, there is an API that allows
    us to customize it. For example, the `fullName` property is really just a convenience
    for concatenating the first name and last name with a space between. As such,
    it’s completely redundant and does not need to be transmitted over a JSON network
    stream. However, running the program produces this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We need only add the `@JsonbTransient` annotation to the `getFullName()` accessor
    in the `Person` class to eliminate the redundancy; running the program now produces
    this smaller output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As with most other JSON APIs, there is full support for customization, ranging
    from the simple annotation shown here up to writing complete custom serializer/deserializer
    helpers. See [the JSON-B spec page](https://javaee.github.io/jsonb-spec), the
    [JSON-B home page](http://json-b.net), and [this longer tutorial online](https://www.baeldung.com/java-json-binding-api).
  prefs: []
  type: TYPE_NORMAL
- en: 14.5 Finding JSON Elements with JSON Pointer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have a JSON document and want to extract only selected values from it.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use `javax.json`’s implementation of *JSON Pointer*, the standard API for extracting
    selected elements from JSON.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[The Internet Standard RFC 6901](https://tools.ietf.org/html/rfc6901) spells
    out in detail the syntax for JSON Pointer, a language-independent syntax for matching
    elements in JSON documents. Obviously inspired by the XML syntax XPath, JSON Pointer
    is a bit simpler than XPath because of JSON’s inherent simpllicity. Basically
    a JSON Pointer is a string that identifies an element (either simple or array)
    within a JSON document. The `javax.json` package provides an object model API
    somewhat similar to the XML DOM API for Java, letting you create immutable objects
    to represent objects (via `JsonObjectBuilder` and `JsonArrayBuilder`) or to read
    them from JSON string format via a `Reader` or `InputStream`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'JSON Pointers begin with a “/” (inherited from XPath), followed by the name
    of the element or subelement we want to look for. Suppose we extend our `Person`
    example from [Example 14-2](#javacook-json-jsonb-code1) to add an array of roles
    the comedian played, looking like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Then the following JSON Pointers should generate the given matches:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The program in [Example 14-3](#javacook-json-jsonpointer-1) demonstrates this.
  prefs: []
  type: TYPE_NORMAL
- en: Example 14-3\. json/src/main/java/json/JsonPointerDemo.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_processing_json_data_CO6-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Create the `JsonStructure`, the gateway into this API, from a `JsonReader`,
    using a `StringReader`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_processing_json_data_CO6-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Create a JSON Pointer for the `firstName` element, and get the `JsonString`
    from the element’s value. Since `getValue()` will throw an exception if the element
    is not found, use `jsonPointer.containsValue(jsonStr)` to check first, if not
    sure if the element will be found.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_processing_json_data_CO6-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Same for `age`, but using more fluent syntax. If you print the class name for
    the match in `/age`, it will report an implementation-specific implementation
    class, such as `org.glassfish.json.JsonNumberImpl$JsonIntNumber`. Change the age
    in the XML from 63 to 63.5 and it will print a class with `BigDecimal` in its
    name. Either way, `toString()` on this object will return just the numeric value.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_processing_json_data_CO6-4)'
  prefs: []
  type: TYPE_NORMAL
- en: In the JSON file, `roles` is an array. Thus, getting it using a JSON Pointer
    should return a `JsonArray` object, so we cast it to a reference of that type.
    This behaves somewhat like an immutable `List` implementation, so we call `get()`.
    JSON array indices start at zero, as in Java.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_processing_json_data_CO6-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Retrieve the same array element directly, using a pattern with “/1” to mean
    the numbered element in the array.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible (but fortunately not common) for a JSON element name to contain
    special characters such as a slash. Most characters are not special to JSON Pointer,
    but to match a name containing a slash (*/*), the slash must be entered as *~1*,
    and since that makes the tilde (*~*) special, tilde characters must be entered
    as *~0*. Thus if the Person JSON file had an element like `"ft/pt/~"`, you would
    look for it with `Json.createPointer("/ft~1pt~1~0");`.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The JSON Pointer API has additional methods that let you modify values and add/remove
    elements. The offical home page for `javax.json`, which includes JSON Pointer,
    is at [*jakarta.ee*](https://jakarta.ee/specifications/jsonp/1.1). The javadoc
    for `javax.json` is linked to from that page.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many APIs exist for Java. Jackson is the biggest and most powerful; org.json,
    javax.json, and JSON-B are in the middle and StringTree (which I didn’t give an
    example of because it doesn’t have a Maven Artifact available) is the smallest.
    For a list of these and other JSON APIs, consult [*https://www.json.org/json-en.html*](https://www.json.org/json-en.html)
    and scroll past the syntax summary.
  prefs: []
  type: TYPE_NORMAL
