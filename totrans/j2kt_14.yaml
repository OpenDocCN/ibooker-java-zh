- en: Chapter 14\. Accumulating Objects to Transformations
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第14章. 累积对象到转换
- en: Java programs usually rely heavily on mutable state because it is so arduous
    in Java to define value types and transform values, even with the Streams API.
    What is the best way to translate Java code that relies upon mutable objects and
    side effects to Kotlin code that transforms immutable values?
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Java 程序通常依赖于可变状态，因为即使使用 Streams API，在 Java 中定义值类型和转换值仍然非常困难。如何将依赖于可变对象和副作用的
    Java 代码最佳地转换为 Kotlin 代码，以转换不可变值？
- en: Calculating with Accumulator Parameters
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用累加器参数进行计算
- en: One of the most important things our travelers want to know is how much their
    adventures will cost. International travel makes this rather complicated. A trip
    will incur costs in multiple currencies as it wends its way across borders, but
    the traveler wants to be able to compare overall costs to make decisions about
    routes and where to stay. So Travelator summarizes costs by local currency *and*
    the traveler’s preferred currency, and then shows the overall total in the preferred
    currency. It does this using the `CostSummary` and `CostSummaryCalculator` classes.
    Let’s take a look at how they are used, and then we’ll look at their implementation.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的旅行者最关心的事情之一是他们的冒险将花费多少。国际旅行使这变得相当复杂。旅行会在多个货币中产生成本，因为它穿越边界，但旅行者希望能够比较总体成本，以便做出关于路线和住宿地点的决定。因此，Travelator通过本地货币和旅行者首选货币汇总成本，然后显示首选货币的总体总额。它使用了
    `CostSummary` 和 `CostSummaryCalculator` 类。让我们看一下它们的使用方法，然后再看看它们的实现。
- en: 'The `Itinerary` class has an operation for summarizing its costs with a `CostSummary​Cal⁠culator`.
    It is used like this:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '`Itinerary` 类有一个用于汇总其成本的操作，使用 `CostSummaryCalculator`。它的使用方式如下：'
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[Example 14.1 [accumulator.0:src/test/java/travelator/itinerary/Itinerary_CostTest.kt]](https://java-to-kotlin.dev/code.html?ref=14.1&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=14.1&show=diff)'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 14.1 [accumulator.0:src/test/java/travelator/itinerary/Itinerary_CostTest.kt]](https://java-to-kotlin.dev/code.html?ref=14.1&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=14.1&show=diff)'
- en: '[![1](assets/1.png)](#co_introduction_CO22-1)'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_introduction_CO22-1)'
- en: Here the code creates a `CostSummaryCalculator` with the traveler’s preferred
    currency and a source of currency exchange rates.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在此，代码使用旅行者首选的货币和货币汇率来源创建了 `CostSummaryCalculator`。
- en: '[![2](assets/2.png)](#co_introduction_CO22-2)'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_introduction_CO22-2)'
- en: 'This tells the `Itinerary` to add its costs to the calculator. In response,
    the `Itinerary` adds the cost of its elements: the journeys along the route, accommodation,
    and other chargeable services.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉 `Itinerary` 将其成本添加到计算器中。作为响应，`Itinerary` 添加其元素的成本：沿途旅程、住宿和其他收费服务的成本。
- en: '[![3](assets/3.png)](#co_introduction_CO22-3)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_introduction_CO22-3)'
- en: This calls the calculator’s `summarise` method to obtain the `CostSummary` after
    all the costs have been collected.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这调用计算器的 `summarise` 方法，在收集所有成本后获取 `CostSummary`。
- en: 'Someone has already converted the `Itinerary` class to Kotlin, but the implementations
    of `addCostsTo` still have a Java flavor:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`Itinerary` 类已被转换为 Kotlin，但 `addCostsTo` 的实现仍带有 Java 的风格：'
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[Example 14.2 [accumulator.0:src/main/java/travelator/itinerary/Itinerary.kt]](https://java-to-kotlin.dev/code.html?ref=14.2&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=14.2&show=diff)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 14.2 [accumulator.0:src/main/java/travelator/itinerary/Itinerary.kt]](https://java-to-kotlin.dev/code.html?ref=14.2&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=14.2&show=diff)'
- en: The logic relies upon side effects to accumulate costs in the mutable state
    of the `CostSummaryCalculator`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 此逻辑依赖于副作用，在 `CostSummaryCalculator` 的可变状态中累积成本。
- en: The benefit of this design is that we can use the calculator to summarize the
    costs of any object in our domain model, without knowing the structure of that
    object. The object is responsible for adding its costs to the calculator and passing
    the calculator to its children so that they can add *their* costs. This decouples
    the code that needs the costs from the code that provides the costs, allowing
    us to evolve them independently.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计的好处在于，我们可以使用计算器总结域模型中任何对象的成本，而无需了解该对象的结构。对象负责将其成本添加到计算器中，并将计算器传递给其子对象，以便它们可以添加
    *它们* 的成本。这样一来，需要成本的代码与提供成本的代码解耦，使我们能够独立地演化它们。
- en: For example, a `Route` contains a list of `Journey`, each of which has a cost,
    and `Accommodation` has a room rate, a number of nights, and additional costs
    such as meals and hotel services. The `Itinerary` doesn’t have to know or care
    how these objects are structured, or how to collect their respective costs. That
    knowledge is encapsulated in the `Route` and `Accommodation` classes.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: However, our use of mutable state has two significant disadvantages.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: First, it introduces the possibility of [aliasing errors](https://oreil.ly/PeqKs).
    Aliasing errors create “spooky action at a distance” (as Einstein famously described
    quantum entanglement) that is not immediately obvious from the source code. We
    saw an example in [Chapter 6](ch06.html#java-to-kotlin-collections), when a function
    sorted a mutable list parameter and broke its caller.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: In the case of the `CostSummaryCalculator`, if we reuse a calculator to summarize
    the costs of multiple entities, we have to reset its state between each calculation.
    If we do not reset the calculator state, costs collected during one calculation
    will be included in the next. The type system cannot help us avoid this mistake.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: The example at the start of this chapter *may* make this error. The calculator
    is not local to the `costSummary` method, and `costSummary` does not reset the
    calculator before each calculation. We can’t tell whether this is a problem merely
    by looking at the `costSummary` method. We have to understand how that method
    is used in its wider context, and as we make changes in that context, we have
    to make sure those changes do not break our assumptions about how the `costSummary`
    method is used.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: The second problem with mutable state is that it scatters the implementation
    of our algorithms across the code. We’ll return to this later in this chapter.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we look at `CostSummaryCalculator`, let’s have a look at the `CostSummary`
    that it computes. It uses `CurrencyConversion` (thankfully already Kotlin):'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[Example 14.3 [accumulator.0:src/main/java/travelator/money/CurrencyConversion.kt]](https://java-to-kotlin.dev/code.html?ref=14.3&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=14.3&show=diff)'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'A `CostSummary` is a mutable POJO (as described in [Chapter 5](ch05.html#beans-to-values))
    that holds a list of `CurrencyConversion`, from local currencies to the traveler’s
    preferred currency:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[Example 14.4 [accumulator.0:src/main/java/travelator/itinerary/CostSummary.java]](https://java-to-kotlin.dev/code.html?ref=14.4&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=14.4&show=diff)'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '`CostSummary` also reports the total cost in the preferred currency. It stores
    the total cost in a field rather than calculating it in `getTotal` because the
    application often sorts items by their `CostSummary.total`, and recalculating
    every time we make a comparison turned out to be a bottleneck. This means that
    a `CostSummary` has to update `total` whenever a `CurrencyConversion` is added.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '`CostSummary` is also effectively a shared mutable collection. Because this
    breaks our rule of thumb in [“Don’t Mutate Shared Collections”](ch06.html#dont-mutate-shared-collections),
    it performs a copy in `getLines` to limit the damage.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: 'Now to `CostSummaryCalculator`. It keeps a running total for each `Currency`
    in a `currencyTotals` field when `addCost` is called. The `summarise` method constructs
    a `CostSummary` using a source of exchange rates to convert local costs to the
    traveler’s preferred currency:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[Example 14.5 [accumulator.0:src/main/java/travelator/itinerary/CostSummaryCalculator.java]](https://java-to-kotlin.dev/code.html?ref=14.5&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=14.5&show=diff)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, the calculation of a `CostSummary` is spread between two classes that
    intertwine the following responsibilities:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Hold information from the context of the calculation that is needed to compute
    the summary.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculate per-currency totals, so the calculation doesn’t accumulate rounding
    errors.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Convert costs to the traveler’s preferred currency.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculate the grand total in the traveler’s preferred currency.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sort the currency conversions in alphabetical order of the original currency
    code.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Store the currency conversions and grand total so they can be displayed to the
    traveler.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Such smearing of responsibilities across classes is common when we compute by
    mutating shared state. We’d like to disentangle the responsibilities and simplify
    the implementation. What final structure we should we aim for?
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'One clue is in the name of the `CostCurrencyCalculator` class. In linguistic
    jargon, the `CostCurrencyCalculator` is an *agent noun*: a noun derived from a
    verb that means no more than a thing that performs the action identified by the
    verb, like *driver* or *baker* or *calculator*. `CostCurrencyCalculator` is a
    so-called “doer class.”'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Another clue is in the data that the class holds. The traveler’s preferred currency
    and source of exchange rates are the context for the calculation. They are managed
    elsewhere in the application and held by `CostCurrencyCalculator` so that they
    are close at hand for its calculations. The map of totals by currency (`currencyTotals`)
    contains transient, intermediate results of the calculation that are irrelevant
    after the calculation is complete and, in fact, should be discarded to avoid aliasing
    errors. The class doesn’t *own* any data, only holds it temporarily for operational
    reasons.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: The `CostCurrencyCalculator` class doesn’t represent a *concept* in our application
    domain model, but a *function* that we perform upon elements of that domain model.
    In Kotlin, we usually implement functions not with objects but with, well, functions.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Let’s refactor the calculation from mutable classes to functions that work with
    immutable data.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring to Functions over Immutable Data
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Converting the two classes to Kotlin leaves us with Java in Kotlin syntax.
    Here is `CostSummary` after a little tidying and rearranging:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[Example 14.6 [accumulator.1:src/main/java/travelator/itinerary/CostSummary.kt]](https://java-to-kotlin.dev/code.html?ref=14.6&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=14.6&show=diff)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 14.6 [accumulator.1:src/main/java/travelator/itinerary/CostSummary.kt]](https://java-to-kotlin.dev/code.html?ref=14.6&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=14.6&show=diff)'
- en: 'The automatic conversion of `CostSummaryCalculator` needs less tidying:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`CostSummaryCalculator` 的自动转换需要整理工作更少：'
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[Example 14.7 [accumulator.1:src/main/java/travelator/itinerary/CostSummaryCalculator.kt]](https://java-to-kotlin.dev/code.html?ref=14.7&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=14.7&show=diff)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 14.7 [accumulator.1:src/main/java/travelator/itinerary/CostSummaryCalculator.kt]](https://java-to-kotlin.dev/code.html?ref=14.7&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=14.7&show=diff)'
- en: 'We can start from here and refactor away the mutability. We’ll work from the
    inside, making `CostSummary` an immutable value type, and gradually push immutability
    outward through the `CostSummaryCalculator`. Before we do though, we’ve been stung
    by Java’s obsession with sorting collections in place before now, so we fix that
    first:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从这里开始，重构掉可变性。我们将从内部开始，使 `CostSummary` 成为一个不可变的值类型，并逐渐将不可变性向外推进到 `CostSummaryCalculator`。不过，在我们开始之前，我们一直被
    Java 对于在原地排序集合的痴迷所困扰，所以我们先解决这个问题：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[Example 14.8 [accumulator.2:src/main/java/travelator/itinerary/CostSummaryCalculator.kt]](https://java-to-kotlin.dev/code.html?ref=14.8&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=14.8&show=diff)'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 14.8 [accumulator.2:src/main/java/travelator/itinerary/CostSummaryCalculator.kt]](https://java-to-kotlin.dev/code.html?ref=14.8&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=14.8&show=diff)'
- en: 'Now we see a pattern that is common in mutating code: create an object (`CostSummary`
    in this case), call some initialization steps, and then return it. Whenever we
    see initialization steps like this, we should reach for `apply`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们看到一个在突变代码中常见的模式：创建一个对象（在这种情况下是 `CostSummary`），调用一些初始化步骤，然后返回它。每当我们看到像这样的初始化步骤时，我们应该使用
    `apply`：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[Example 14.9 [accumulator.3:src/main/java/travelator/itinerary/CostSummaryCalculator.kt]](https://java-to-kotlin.dev/code.html?ref=14.9&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=14.9&show=diff)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 14.9 [accumulator.3:src/main/java/travelator/itinerary/CostSummaryCalculator.kt]](https://java-to-kotlin.dev/code.html?ref=14.9&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=14.9&show=diff)'
- en: 'Using `apply` allows us to group the initialization steps into a block to better
    express our intent. It’s like a mini builder: the `summarise` function never sees
    a reference to a partially initialized `CostSummary`, only the completed object.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `apply` 允许我们将初始化步骤分组到一个块中，以更好地表达我们的意图。这就像一个迷你构建器：`summarise` 函数从未看到过部分初始化的
    `CostSummary` 的引用，只看到完成的对象。
- en: 'This is small-scale functional thinking—trying to limit the scope of mutation
    even within a function. Functional thinking also helps us see that looping over
    `totals`, creating a `CurrencyConversion` for each, and calling `addLine` with
    it, is the same as creating a `conversions` list and looping over that:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这是小规模的功能性思维——试图在函数内部限制突变的范围。功能性思维还帮助我们看到，循环遍历 `totals`，为每个创建一个 `CurrencyConversion`，然后调用
    `addLine`，与创建一个 `conversions` 列表并遍历它是一样的：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[Example 14.10 [accumulator.4:src/main/java/travelator/itinerary/CostSummaryCalculator.kt]](https://java-to-kotlin.dev/code.html?ref=14.10&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=14.10&show=diff)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 14.10 [accumulator.4:src/main/java/travelator/itinerary/CostSummaryCalculator.kt]](https://java-to-kotlin.dev/code.html?ref=14.10&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=14.10&show=diff)'
- en: 'Why make this change? Well, we want to strip a `CostSummary` down to its immutable
    essence. If `CostSummary` was immutable, client code would have to pass the list
    of lines to its constructor instead of calling its `addLine` method. `CostSummary`
    shouldn’t be responsible for currency conversion, so we’re making the `apply`
    block look like we want its constructor to look. From here we add a secondary
    constructor that duplicates this initialization logic:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么要做这个改变？嗯，我们想将 `CostSummary` 剥离到其不可变的本质。如果 `CostSummary` 是不可变的，客户端代码将不得不将行列表传递给其构造函数，而不是调用其
    `addLine` 方法。`CostSummary` 不应负责货币转换，所以我们让 `apply` 块看起来像我们希望其构造函数看起来的样子。从这里开始，我们添加一个次要构造函数，复制这个初始化逻辑：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[Example 14.11 [accumulator.5:src/main/java/travelator/itinerary/CostSummary.kt]](https://java-to-kotlin.dev/code.html?ref=14.11&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=14.11&show=diff)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 14.11 [accumulator.5:src/main/java/travelator/itinerary/CostSummary.kt]](https://java-to-kotlin.dev/code.html?ref=14.11&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=14.11&show=diff)'
- en: 'Now we can change the `CostSummaryCalculator.summarise` method to call the
    new constructor, treating the `CostSummary` class as if it was an immutable value
    type:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以修改`CostSummaryCalculator.summarise`方法，调用新的构造函数，将`CostSummary`类视为不可变值类型：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[Example 14.12 [accumulator.5:src/main/java/travelator/itinerary/CostSummaryCalculator.kt]](https://java-to-kotlin.dev/code.html?ref=14.12&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=14.12&show=diff)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 14.12 [accumulator.5:src/main/java/travelator/itinerary/CostSummaryCalculator.kt]](https://java-to-kotlin.dev/code.html?ref=14.12&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=14.12&show=diff)'
- en: 'This in turn allows us to make the `CostSummary` class actually immutable,
    at least from outside:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这样一来，我们可以确保`CostSummary`类从外部实际上是不可变的：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[Example 14.13 [accumulator.6:src/main/java/travelator/itinerary/CostSummary.kt]](https://java-to-kotlin.dev/code.html?ref=14.13&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=14.13&show=diff)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 14.13 [accumulator.6:src/main/java/travelator/itinerary/CostSummary.kt]](https://java-to-kotlin.dev/code.html?ref=14.13&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=14.13&show=diff)'
- en: 'As we can see from that nasty `var` and `init`, it’s sometimes hard to get
    away from mutation once it has set in, especially for accumulators like this;
    `fold` is our friend here. We had a series of actions ([“Actions”](ch07.html#actions))
    acting on the mutable variable `total`, and `fold` converts the actions to a single
    calculation ([“Calculations”](ch07.html#calculations)) that we can use to initialize
    an immutable variable:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们从那个恶心的`var`和`init`中看到的，一旦变异发生，有时很难摆脱它，特别是对于像这样的累加器；`fold`在这里是我们的朋友。我们有一系列操作（[“操作”](ch07.html#actions)）作用于可变变量`total`，而`fold`将这些操作转换为单个计算（[“计算”](ch07.html#calculations)），我们可以用来初始化不可变变量：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[Example 14.14 [accumulator.7:src/main/java/travelator/itinerary/CostSummary.kt]](https://java-to-kotlin.dev/code.html?ref=14.14&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=14.14&show=diff)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 14.14 [accumulator.7:src/main/java/travelator/itinerary/CostSummary.kt]](https://java-to-kotlin.dev/code.html?ref=14.14&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=14.14&show=diff)'
- en: Now that it is fully immutable, we can make `CostSummary` a data class if we
    can make `total` a primary constructor parameter. We could do this by converting
    the current constructor to a secondary constructor, but instead we are going to
    move all the calculation into the `CostSummaryCalculator`, leaving the `CostSummary`
    merely to hold the results of that calculation.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 既然它完全是不可变的，我们可以将`CostSummary`改为数据类，只要我们可以将`total`作为主构造函数参数。我们可以通过将当前构造函数转换为次构造函数来实现这一点，但我们将所有计算移动到`CostSummaryCalculator`中，仅保留`CostSummary`来保存计算结果。
- en: 'To do this, we first select the expression to the right of the equals sign
    in the definition of the `total` property and use the IDE’s “Introduce Parameter”
    refactoring to push the expression out as a constructor parameter:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们首先选择`total`属性定义中等号右侧的表达式，并使用IDE的“引入参数”重构将表达式作为构造函数参数推出：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[Example 14.15 [accumulator.8:src/main/java/travelator/itinerary/CostSummary.kt]](https://java-to-kotlin.dev/code.html?ref=14.15&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=14.15&show=diff)'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 14.15 [accumulator.8:src/main/java/travelator/itinerary/CostSummary.kt]](https://java-to-kotlin.dev/code.html?ref=14.15&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=14.15&show=diff)'
- en: 'The `total` property is now highlighted as a style warning: the IDE detected
    that the property can be declared in the constructor parameter. A quick Alt-Enter
    on the warning leaves the class declaration as:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`total`属性被标记为样式警告：IDE检测到该属性可以在构造函数参数中声明。通过快捷键Alt-Enter可以将类声明为：
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[Example 14.16 [accumulator.9:src/main/java/travelator/itinerary/CostSummary.kt]](https://java-to-kotlin.dev/code.html?ref=14.16&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=14.16&show=diff)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 14.16 [accumulator.9:src/main/java/travelator/itinerary/CostSummary.kt]](https://java-to-kotlin.dev/code.html?ref=14.16&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=14.16&show=diff)'
- en: 'Meanwhile, back at the `CostSummaryCalculator`, IntelliJ has pulled the calculation
    into `summarise`, leaving it looking like this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，在`CostSummaryCalculator`中，IntelliJ已经将计算合并到`summarise`方法中，代码看起来像这样：
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[Example 14.17 [accumulator.9:src/main/java/travelator/itinerary/CostSummaryCalculator.kt]](https://java-to-kotlin.dev/code.html?ref=14.17&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=14.17&show=diff)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 14.17 [accumulator.9:src/main/java/travelator/itinerary/CostSummaryCalculator.kt]](https://java-to-kotlin.dev/code.html?ref=14.17&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=14.17&show=diff)'
- en: '*Now* we can make `CostSummary` a data class. Its sole responsibility is to
    hold the results of the calculation for filtering, sorting, and display:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*现在*我们可以将`CostSummary`定义为一个数据类。它的唯一责任是保存过滤、排序和显示计算结果的数据：'
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[Example 14.18 [accumulator.10:src/main/java/travelator/itinerary/CostSummary.kt]](https://java-to-kotlin.dev/code.html?ref=14.18&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=14.18&show=diff)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 14.18 [accumulator.10:src/main/java/travelator/itinerary/CostSummary.kt]](https://java-to-kotlin.dev/code.html?ref=14.18&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=14.18&show=diff)'
- en: 'We said previously that mutable state can obscure algorithms by smearing them
    through the code. We can now look back and see that was the case with `CostSummary`.
    When we arrived, calculating the total was split into initializing a mutable `total`
    property and updating it in the `addLine` method:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前说过，可变状态会将算法模糊化，并将其在代码中传播。现在我们可以回顾一下，看看`CostSummary`确实如此。当我们到达时，计算总和被分割成了初始化一个可变的`total`属性并在`addLine`方法中更新它：
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[Example 14.19 [accumulator.1:src/main/java/travelator/itinerary/CostSummary.kt]](https://java-to-kotlin.dev/code.html?ref=14.19&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=14.19&show=diff)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 14.19 [accumulator.1:src/main/java/travelator/itinerary/CostSummary.kt]](https://java-to-kotlin.dev/code.html?ref=14.19&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=14.19&show=diff)'
- en: 'Now the calculation is a single expression in `summarise`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在计算是在`summarise`中的一个单一表达式：
- en: '[PRE19]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[Example 14.20 [accumulator.9:src/main/java/travelator/itinerary/CostSummaryCalculator.kt]](https://java-to-kotlin.dev/code.html?ref=14.20&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=14.20&show=diff)'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 14.20 [accumulator.9:src/main/java/travelator/itinerary/CostSummaryCalculator.kt]](https://java-to-kotlin.dev/code.html?ref=14.20&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=14.20&show=diff)'
- en: Let’s Do That Again
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们再次做这件事
- en: 'Similarly, whatever is happening with currencies is still hidden in the remaining
    mutations in `CostSummaryCalculator`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，货币相关的情况仍然隐藏在`CostSummaryCalculator`中的剩余突变中：
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[Example 14.21 [accumulator.9:src/main/java/travelator/itinerary/CostSummaryCalculator.kt]](https://java-to-kotlin.dev/code.html?ref=14.21&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=14.21&show=diff)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 14.21 [accumulator.9:src/main/java/travelator/itinerary/CostSummaryCalculator.kt]](https://java-to-kotlin.dev/code.html?ref=14.21&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=14.21&show=diff)'
- en: 'We can apply a similar process to eliminate these, but this time we won’t add
    a secondary constructor. Instead, we will apply [“Expand-and-Contract Refactoring”](ch04.html#expand-contract)
    by adding an overload of the `summarise` method that takes the costs:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以应用类似的过程来消除这些，但这次我们不会添加第二个构造函数。相反，我们将通过添加一个接受成本的`summarise`方法的重载来应用[“扩展和收缩重构”](ch04.html#expand-contract)：
- en: '[PRE21]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[Example 14.22 [accumulator.11:src/main/java/travelator/itinerary/CostSummaryCalculator.kt]](https://java-to-kotlin.dev/code.html?ref=14.22&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=14.22&show=diff)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 14.22 [accumulator.11:src/main/java/travelator/itinerary/CostSummaryCalculator.kt]](https://java-to-kotlin.dev/code.html?ref=14.22&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=14.22&show=diff)'
- en: 'This is quite sneaky. The old `summarise` method is an action: its result depends
    on the past history of calling `addCost` and `reset`. This new `summarise` is
    a calculation: its result depends only on the values of its inputs (the `costs`
    parameter plus the `userCurrency` and `exchangeRates` properties it accesses).
    And yet the new `summarise` uses the old one; it just limits the scope of mutation
    to a local variable, converting it to a calculation.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这很狡猾。旧的`summarise`方法是一个动作：它的结果取决于调用`addCost`和`reset`的过去历史。这个新的`summarise`是一个计算：它的结果只取决于它的输入值（`costs`参数加上它访问的`userCurrency`和`exchangeRates`属性的值）。然而新的`summarise`使用了旧的方法；它只是将突变范围限制在一个局部变量中，将其转换为一个计算。
- en: When we use this version of `summarise`, we have drawn a distinction between
    the *context* of cost-summary calculations, which we pass to the constructor as
    `userCurrency` and `exchangeRates`, and the parameters of a *specific* calculation
    (the `costs` that we pass to the `summarise` method). This will be significant
    later ([“Enriching the Abstraction We Discovered”](#pricing-context)).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用这个版本的`summarise`时，我们对费用总结计算的*上下文*进行了区分，我们将其作为`userCurrency`和`exchangeRates`传递给构造函数，以及*特定*计算的参数（我们传递给`summarise`方法的`costs`）。这在后面会变得重要（[“丰富我们发现的抽象”](#pricing-context)）。
- en: Now that we have two `summarise` methods, we can move our callers to the new
    one. To switch over to using the new `summarise`, we’ll have to extract the costs
    from the entities we want to summarize, rather than telling them to add their
    costs to a mutable calculator that we pass in. Instead of asking children to add
    their costs to the `CostSummaryCalculator`, parents will ask their children for
    their costs and combine them.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll end up using the calculator like this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[Example 14.23 [accumulator.12:src/test/java/travelator/itinerary/Itinerary_CostTest.kt]](https://java-to-kotlin.dev/code.html?ref=14.23&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=14.23&show=diff)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: 'And we’ll report the costs from our domain models like this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[Example 14.24 [accumulator.12:src/main/java/travelator/itinerary/Itinerary.kt]](https://java-to-kotlin.dev/code.html?ref=14.24&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=14.24&show=diff)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'When all uses of `CostSummaryCalculator` in the application are using our new
    `summarise` method, we can flatten the calculation of the `currencyTotals` and
    `CostSummary` into that method, the one that currently uses a local to do the
    job:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[Example 14.25 [accumulator.11:src/main/java/travelator/itinerary/CostSummaryCalculator.kt]](https://java-to-kotlin.dev/code.html?ref=14.25&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=14.25&show=diff)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'We can effectively inline the entire class into this method using local variables
    instead:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[Example 14.26 [accumulator.13:src/main/java/travelator/itinerary/CostSummaryCalculator.kt]](https://java-to-kotlin.dev/code.html?ref=14.26&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=14.26&show=diff)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Our tests still pass, and IntelliJ tells us that all the other methods of `CostSummary​Cal⁠cu⁠lator`
    are now unused, as is the `currencyTotals` field, so by deleting them all we have
    finally succeeded in removing all the mutable state from the class. Not from that
    method though—we still have a mutable map! This is the last remnant of the smearing
    out of the algorithm that we mentioned earlier. We have finally brought all the
    logic into this one method, and because all our logic is in one place, we know
    that it happens at one time and is safe to refactor to any equivalent form.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 'What is that form? We have to think about that, but come to the conclusion
    that the `MutableMap.merge` is accumulating a total per currency. When we have
    all the data at once, as we do now, we can perform the same calculation by grouping
    by currency and summing the lists:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[Example 14.27 [accumulator.14:src/main/java/travelator/itinerary/CostSummaryCalculator.kt]](https://java-to-kotlin.dev/code.html?ref=14.27&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=14.27&show=diff)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: It is a bit irritating that we have to use `reduce` to sum monies instead of
    having a nice `Iterable<Money>.sum()` extension function. We should probably fix
    that. And now that the calculation is all in one place, we might ponder whether
    there is meaning in the fact that we use `reduce` in one expression and `fold`
    in another (hint, there is), but these are thoughts that we can have only because
    the code is now set out in one place.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 稍显恼人的是，我们必须使用`reduce`来求和金额，而不是拥有一个漂亮的`Iterable<Money>.sum()`扩展函数。我们应该修复这个问题。现在计算都在一个地方了，我们可以思考一下为什么在一个表达式中使用了`reduce`，而在另一个表达式中使用了`fold`（提示，这是有意义的），但这些都是因为现在代码都集中在一处而能够有的想法。
- en: The key thing is that we can see the shape of the `summarise` calculation more
    clearly now. It is a pure function that is applied to a collection of costs and
    is evaluated in the context of some exchange rates and the traveler’s preferred
    currency. The function transforms the nested entities of our domain model into
    a flat collection of costs and then transforms the costs into a map of the total
    for each currency, transforms the totals for each `Currency` into a list of `CurrencyConversion`,
    and finally transforms the list of currency conversions into a `CostSummary`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 关键是我们现在可以更清楚地看到`summarise`计算的形状了。它是一个纯函数，应用于成本集合，并在一些汇率和旅行者首选货币的背景下进行评估。该函数将我们领域模型的嵌套实体转换为成本的平面集合，然后将成本转换为每种货币的总数的映射，再将每种`Currency`的总数转换为`CurrencyConversion`列表，最后将货币转换列表转换为`CostSummary`。
- en: Tip
  id: totrans-123
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: A functional program transforms its inputs into outputs.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式程序将其输入转换为输出。
- en: If you can’t write that easily in one step, transform the inputs into an intermediate
    representation that is easy to transform into the outputs.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不能轻松地一步写成，将输入转换为易于转换为输出的中间表示。
- en: Introduce intermediate forms and transformations until you have a pipeline of
    simple transformations between intermediate forms that compose to transform the
    inputs that you *have* to the outputs that you *want*.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 引入中间形式和转换，直到你有一个简单转换的管道，将中间形式之间的输入转换为你*想要*的输出。
- en: We will look more at pure functions evaluated in context in [Chapter 16](ch16.html#interfaces-to-functions).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第16章](ch16.html#interfaces-to-functions)更详细地讨论在上下文中评估的纯函数。
- en: Enriching the Abstraction We Discovered
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 丰富我们发现的抽象
- en: Travelator does more with exchange rates and the traveler’s preferred currency
    than summarize costs. For example, while the user is browsing hotel rooms, it
    shows the cost of each room in both local and preferred currencies. That is, the
    hotel room browser performs a currency conversion on an individual cost. The `CostSummary​Cal⁠cu⁠lator`
    also has to perform currency conversions on individual costs to calculate a summary.
    If we extract that functionality as a public method, which we can call `toUserCurrency`,
    we can initialize the hotel room browser with a `CostSummary​Cal⁠cul⁠ator` instead
    of passing it both the exchange rates and preferred currency. We can also remove
    the currency conversion calculation—that we now see is duplicated code—from the
    hotel room browser.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Travelator在汇率和旅行者首选货币方面比简单成本汇总做得更多。例如，当用户浏览酒店房间时，它显示每个房间在本地货币和首选货币中的费用。也就是说，酒店房间浏览器对单个成本执行货币转换。`CostSummary​Cal⁠cu⁠lator`还必须对单个成本执行货币转换以计算汇总。如果我们将该功能提取为一个公共方法，我们可以称之为`toUserCurrency`，我们可以用`CostSummary​Cal⁠cul⁠ator`初始化酒店房间浏览器，而不是传递汇率和首选货币。我们还可以从酒店房间浏览器中删除重复的货币转换计算代码。
- en: 'At that point, the class is no longer a calculator of cost summaries. It holds
    the context for any pricing we do for an individual traveler. So let’s rename
    it to reflect its newfound responsibility. At the moment, we can’t think of a
    better name than `PricingContext`, which leaves our class looking like this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在那一点上，该类不再是成本汇总的计算器。它为任何单个旅行者的定价提供上下文。因此，让我们重新命名它以反映它的新职责。目前我们想不出比`PricingContext`更好的名称了，这使得我们的类看起来像这样：
- en: '[PRE27]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[Example 14.28 [accumulator.16:src/main/java/travelator/itinerary/PricingContext.kt]](https://java-to-kotlin.dev/code.html?ref=14.28&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=14.28&show=diff)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 14.28 [accumulator.16:src/main/java/travelator/itinerary/PricingContext.kt]](https://java-to-kotlin.dev/code.html?ref=14.28&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=14.28&show=diff)'
- en: 'This leaves the code that used to use the `CostSummaryCalculator` looking like
    this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这样一来，之前使用`CostSummaryCalculator`的代码看起来像这样：
- en: '[PRE28]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[Example 14.29 [accumulator.16:src/test/java/travelator/itinerary/Itinerary_CostTest.kt]](https://java-to-kotlin.dev/code.html?ref=14.29&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=14.29&show=diff)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 14.29 [accumulator.16:src/test/java/travelator/itinerary/Itinerary_CostTest.kt]](https://java-to-kotlin.dev/code.html?ref=14.29&show=file)
    [(变更)](https://java-to-kotlin.dev/code.html?ref=14.29&show=diff)'
- en: Now that we have this concept in our codebase, we can identify other parts of
    our application that can use it. We can move logic from those parts onto the `Pricing​Con⁠text`,
    making it a one-stop shop for operations that need to convert monetary amounts
    into the traveler’s preferred currency. And should it end up full of disparate
    methods for different use cases, then we can move the operations from methods
    to extension functions to keep them closer to where they are needed (see [Chapter 10](ch10.html#functions-to-extension-functions)).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在代码库中有了这个概念，我们可以识别出其他可以使用它的应用程序部分。我们可以将逻辑从这些部分移动到`Pricing​Con⁠text`上，使其成为将货币金额转换为旅行者首选货币的操作的一站式店。如果最终充满了不同用例的不同方法，那么我们可以将操作从方法移动到扩展函数中，以使它们更接近需要它们的地方（参见[第10章](ch10.html#functions-to-extension-functions)）。
- en: Moving On
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继续前进
- en: We started this chapter with a calculation that relied on shared, mutable state.
    It duplicated logic from the standard library and introduced the risk of aliasing
    errors. By the end of the chapter, we had refactored the same calculation to a
    transformation of immutable data.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章开始时使用了依赖共享的可变状态进行计算。这种做法复制了标准库中的逻辑，并引入了别名错误的风险。到了本章结束时，我们已经将同样的计算重构为对不可变数据的转换。
- en: 'To do so, we moved mutation out of our code in two directions, outward and
    inward. Outward was obvious: we made the `CostSummaryCalculator` treat the `CostSummary`
    class as an immutable value type and then made `CostSummary` immutable. Then we
    made users of `CostSummaryCalculator` treat it as an immutable context to a calculation
    and then made `CostSummaryCalculator` immutable. But inward? We replaced the imperative
    code that mutated collections and fields with calls to standard higher-order functions,
    like `groupingBy`, `fold`, and `reduce`. Under the hood, those functions may mutate
    state, but they hide that mutation from their callers. From outside, the functions
    are calculations.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们将变异从代码中移出，向两个方向进行：向外和向内。向外是显而易见的：我们让`CostSummaryCalculator`将`CostSummary`类视为不可变值类型，然后使`CostSummary`不可变。然后我们让`CostSummaryCalculator`的使用者将其视为计算的不可变上下文，然后使`CostSummaryCalculator`不可变。但是向内呢？我们用标准的高阶函数调用（如`groupingBy`、`fold`和`reduce`）替换了那些变异集合和字段的命令式代码。在幕后，这些函数可能会改变状态，但它们将这种变异隐藏在其调用者之外。从外部来看，这些函数就是计算。
- en: We can use the same approach in our own code when we need to. Sometimes mutating
    a collection is the easiest thing to do. The standard library does not always
    have a higher-order function that transforms data the way we want. If we do need
    a mutable collection, we can hide that mutation inside a calculation to limit
    the blast radius of any potential aliasing errors. However, every release adds
    more functions to the standard library, so the need diminishes over time.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要时，我们可以在我们自己的代码中采用相同的方法。有时候变异集合是最简单的事情。标准库并不总是具有按照我们希望的方式转换数据的高阶函数。如果我们确实需要可变集合，我们可以将该变异隐藏在计算中，以限制任何潜在别名错误的影响范围。然而，每个发布版本都会向标准库添加更多的函数，因此随着时间的推移，这种需求会减少。
- en: Functional programming does not eliminate mutable state but instead *makes it
    the responsibility of the runtime*. A functional program declares what the runtime
    should calculate and lets the runtime be responsible for computing that calculation.
    Kotlin is not a pure functional language, but we benefit by following that principle
    where we can.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程并不消除可变状态，而是*将其责任委托给运行时*。函数式程序声明了运行时应该计算的内容，并让运行时负责执行该计算。Kotlin并不是纯函数式语言，但我们可以通过遵循这一原则来获益。
