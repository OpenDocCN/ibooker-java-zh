- en: Chapter 11\. Lazy Evaluation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although *laziness* is often seen as a character flaw in people, it can be considered
    a favorable feature in some programming languages. In computer science terms,
    *laziness* is the antagonist to *strictness* —  or *eagerness* — of code evaluation.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will show you how being lazy can improve performance. You will
    learn about the difference between strict and lazy evaluation and its impact on
    your code’s design.
  prefs: []
  type: TYPE_NORMAL
- en: Laziness Versus Strictness
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The strictness of a language describes the semantics of how your code is evaluated.
  prefs: []
  type: TYPE_NORMAL
- en: '*Strict* evaluation happens as soon as possible, such as declaring or setting
    a variable or passing an expression as an argument. *Non-strict* evaluation, however,
    happens when the result of an expression is actually needed. This way, expressions
    can have a value even if one or more subexpressions fail to evaluate.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, *Haskell* is a functional programming language with *non-strict*
    semantics by default, evaluating expressions from the outermost to the inner ones.
    This allows you to create control structures or infinite data sequences due to
    the separation of the *creation* and *consumption* of expressions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at the following *strict* Java code of a simple method accepting
    two arguments but using only one for its logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The *non-strict* Haskell-equivalent function declaration looks more like a
    variable assignment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This function also uses only its first argument and doesn’t evaluate the second
    argument, `y`, at all. That’s why the following Haskell code still yields a result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If you call the Java equivalent of this function with the same arguments, the
    value `1` and the expression `(1/0)`, it will throw an exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Even though the second parameter of the `add` call isn’t used in any capacity,
    Java, as a *strict* language, evaluates the expression immediately. Method arguments
    are *passed-by-value*, which means they’re evaluated before being passed to the
    method, which in this case throws an `ArithmeticException`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Java’s method arguments are always pass-by-value. In the case of non-primitive
    types, arguments are passed as *object-handles* by the JVM with a special type
    called `references`. These are technically still passed-by-value, making the general
    terminology and semantics quite confusing.
  prefs: []
  type: TYPE_NORMAL
- en: Conversely, lazy evaluation is defined as evaluating expressions only when their
    result is needed. That means the declaration of an expression doesn’t trigger
    its immediate evaluation, which makes Java lambda expressions the perfect match
    for lazy evaluation, as seen in [Example 11-1](#_02-lazy-evaluation_lazy).
  prefs: []
  type: TYPE_NORMAL
- en: Example 11-1\. Lazy Evaluation with Java and Suppliers
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The declaration of the `IntSupplier` instances, or their inline equivalents,
    is a strict statement and is evaluated immediately. The actual lambda body, however,
    doesn’t evaluate until it’s explicitly called with `getAsInt`, preventing the
    `ArithmeticException` in this case.
  prefs: []
  type: TYPE_NORMAL
- en: In essence, *strictness* is about “doing things,” but *laziness* is about “considering
    things to do.”
  prefs: []
  type: TYPE_NORMAL
- en: How Strict Is Java?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most programming languages are neither fully lazy nor strict. Java is considered
    a strict language, but with some noteworthy lazy exceptions on a language level
    and in the available types of the JDK.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go through them.
  prefs: []
  type: TYPE_NORMAL
- en: Short-Circuit Evaluation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Language-integrated laziness is available in Java in the form of the logical
    *short-circuit evaluation* with the logical operators `&&` (double ampersand)
    and `||` (double pipe) for `AND` and `OR`. These operators evaluate their operands
    left to right and only as required. If the logical expression is satisfied by
    the expression left of the operator, the right operand isn’t evaluated at all,
    as seen in [Table 11-1](#_02-lazy-evaluation_logical-operators_table).
  prefs: []
  type: TYPE_NORMAL
- en: Table 11-1\. Evaluation of logical short-circuit operators
  prefs: []
  type: TYPE_NORMAL
- en: '| Operations | Value of `leftExpr` | Is `rightExpr` evaluated? |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `leftExpr && rightExpr` | `true` | yes |'
  prefs: []
  type: TYPE_TB
- en: '| `false` | no |'
  prefs: []
  type: TYPE_TB
- en: '| `leftExpr &#124;&#124; rightExpr` | `true` | no |'
  prefs: []
  type: TYPE_TB
- en: '| `false` | yes |'
  prefs: []
  type: TYPE_TB
- en: Bitwise Logical Operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The similar bitwise operators `&` (single ampersand) and `|` (single pipe) evaluate
    *eagerly* and serve a different purpose than their logical brethren. Bitwise operators
    compare individual bits of integer types, resulting in an integer result.
  prefs: []
  type: TYPE_NORMAL
- en: Despite functioning similarly to a control structure, these logical operands
    can’t exist in a vacuum. They must always be part of another statement, like a
    condition for an `if`-block or a variable assignment, as seen in [Example 11-2](#_02-lazy-evaluation_logical-operators_existence).
    Another advantage of short-circuit evaluation for assignments is that they create
    (effectively) `final`⁠^([1](ch11.xhtml#idm45115222435312)) references, making
    them a perfect fit to use with Java’s functional approach.
  prefs: []
  type: TYPE_NORMAL
- en: Example 11-2\. Usage of logical short-circuit operators
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Omitting the evaluation of right-side operand evaluation is extremely helpful
    if the expression is costly or has any side effects, or doesn’t need to be evaluated
    if the left-side was. However, it also might be the source of not evaluating a
    required expression if the statement is short-circuited and the expression necessary
    is on the right side. If you make them a part of decision-making, make sure to
    design them carefully.
  prefs: []
  type: TYPE_NORMAL
- en: Any decision-making code benefits immensely from pure functions. The intended
    behavior is straightforward and easily understandable, without any lurking side
    effects that might get unnoticed during redesigning or refactoring your code,
    introducing subtle bugs that are often hard to pin down. You should make sure
    that there are either no side effects at all, which in my opinion, is too absolute
    and generally an unrealistic goal, or name your methods to reflect their repercussions.
  prefs: []
  type: TYPE_NORMAL
- en: Control Structures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Control structures are responsible for changing the path taken through the instructions
    of your code. An `if`-`else` construct, for example, is a conditional branch with
    one (`if`-only) or more (`if`-`else`) blocks of code. These blocks are only evaluated
    depending on their corresponding condition, which is a lazy trait. Strictly evaluating
    any part of an `if`-`else` construct on declaration would defeat its purpose of
    using it as a conditional branch. This “lazy exception to the eager rules” applies
    to all branching and loop structures, as listed in [Table 11-2](#_02-lazy-evaluation_control-structures-table).
  prefs: []
  type: TYPE_NORMAL
- en: Table 11-2\. Lazy structures in Java
  prefs: []
  type: TYPE_NORMAL
- en: '| Branching control structures | Looping structures |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `if`-`else` `? :` (ternary operator)'
  prefs: []
  type: TYPE_NORMAL
- en: '`switch`'
  prefs: []
  type: TYPE_NORMAL
- en: '`catch` | `for` `while`'
  prefs: []
  type: TYPE_NORMAL
- en: '`do-while` |'
  prefs: []
  type: TYPE_NORMAL
- en: An absolutely strict language with non-lazy control structures is hard to imagine,
    if not impossible.
  prefs: []
  type: TYPE_NORMAL
- en: Lazy Types in the JDK
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, I’ve talked about how Java’s laziness was built directly into the language
    in the form of operators and control structures. The JDK, however, also provides
    multiple built-in types and data structures with a certain degree of laziness
    at runtime as well.
  prefs: []
  type: TYPE_NORMAL
- en: Lazy Maps
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A common task for Maps is checking if a key already has a mapped value, and
    providing one if it’s missing. The related code requires multiple checks and non
    (effectively) `final` variables, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The code might vary depending on the actual `Map` implementation, but the gist
    should be clear.
  prefs: []
  type: TYPE_NORMAL
- en: In general, this is already a lazy approach, delaying loading a user until necessary.
    In the course of retrofitting functional additions to many types in JDK 8, the
    `Map` type received a more concise and functional alternative with its `computeIf…​`
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two methods available based on the existence of a mapped value for
    a key:'
  prefs: []
  type: TYPE_NORMAL
- en: '`V computeIfAbsent(K key, Function<? super K, ? extends V> mappingFunction)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`V computeIfPresent(K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first one is an ideal replacement for the code of the previous example,
    as such:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: It requires the desired key as its first argument and a mapper `Function<K,
    V>` as its second argument that provides the new mapped value for the key if absent.
    The `computeIfPresent` is the antagonist for remapping values only if one’s present.
  prefs: []
  type: TYPE_NORMAL
- en: A combination of both methods is also available in the form of the `V compute(K
    key, BiFunction<? super K, ? super V, ? extends V> remappingFunction)` method.
    It’s able to update and even delete mapped values depending on the result of the
    `remapping` function, as illustrated in [Figure 11-1](#_02-lazy-evaluation_map-compute).
  prefs: []
  type: TYPE_NORMAL
- en: '![Lazy remapping with Map#compute](assets/afaj_1101.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-1\. Lazy remapping with Map#compute
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The general theme of a functional approach is clearly visible in Maps’ lazy
    additions. Instead of requiring you to write the verbose and repetitive code of
    *how* to work with the Map and its mapped values, now you can concentrate on *what*
    is happening and how to deal with keys and values.
  prefs: []
  type: TYPE_NORMAL
- en: Streams
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Java Streams are the perfect example of lazy functional pipelines. You can define
    an intricate Stream scaffold filled with expensive functional operations that
    will only start evaluation after calling a terminal operation. The number of processed
    elements solely depends on the design of the pipeline, allowing you to minimize
    the required work as much as possible by separating the definition of an expression
    and its actual evaluation in a data processing pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 6](ch06.xhtml#_02-data-processing) explains Streams and their lazy
    approach to data processing in detail.'
  prefs: []
  type: TYPE_NORMAL
- en: Optionals
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Optionals are a non-lazy way of handling `null` values. Their general approach
    is similar to Streams, but they evaluate strictly compared to Streams. There are
    lazy operations available, for example, the `T orElseGet(Supplier<? extends T>
    supplier)` method that utilizes a `Supplier` to delay the execution to when it’s
    absolutely necessary.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 9](ch09.xhtml#_02-optionals) gives a detailed introduction to Optionals
    and more information on how to use them.'
  prefs: []
  type: TYPE_NORMAL
- en: Lambdas and Higher-Order Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lambdas are a great way to introduce laziness on a code level. Their declaration
    is a statement and, therefore, strictly evaluated. Their body — the *single abstract
    method* --⁠, however, encapsulates the actual logic and evaluates at your discretion.
    That makes them a simple way to store and transfer expressions for later evaluation.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at some eager code for providing an argument to a method and how
    it can be made lazy with the help of lambdas.
  prefs: []
  type: TYPE_NORMAL
- en: An Eager Approach
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [Example 11-3](#_01-laziness_eager), a hypothetical `User` is updated with
    a list of roles. The update isn’t always done and depends on the inner logic of
    the `update` method. The arguments are provided *eagerly*, requiring a pretty
    expensive lookup call through the *DAO*⁠^([2](ch11.xhtml#idm45115222180992)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 11-3\. Updating a `User` with eager method arguments
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_lazy_evaluation_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The `updateUser` method requires the `user` and a list of all available roles.
    The update itself depends on the inner logic and might not need the roles after
    all.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_lazy_evaluation_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The `loadAllAvailableRoles(user)` is called regardless of the `updateUser` method
    requiring the roles. This results in a costly trip to the database that might
    be unnecessary.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_lazy_evaluation_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: All arguments are already evaluated at the time of the method call.
  prefs: []
  type: TYPE_NORMAL
- en: Providing `updateUser` with the roles, even if they aren’t necessary for every
    use-case, creates unnecessary database calls and wastes performance.
  prefs: []
  type: TYPE_NORMAL
- en: So how can you make the call non-mandatory if it’s not always required? By introducing
    laziness.
  prefs: []
  type: TYPE_NORMAL
- en: A Lazier Approach
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a strict language like Java, all method arguments are provided upfront and
    as-is. The method has no choice but to accept them, even if an argument isn’t
    actually needed. This is especially a problem when it comes to executing expensive
    operations to create such arguments beforehand, such as database calls, which
    can be a drain on your available resources and performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The naïve approach to remedy unnecessary database calls is to change `updateUser`
    to accept the DAO directly, so it can only use it if necessary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `updateUser` method now has all the tools necessary to load the available
    roles by itself. On a superficial level, the initial problem of non-lazy data
    access is solved, but this “solution” creates a new problem: cohesion.'
  prefs: []
  type: TYPE_NORMAL
- en: The `updateUser` method now uses the DAO directly and is no longer isolated
    from *how* the roles are acquired. This approach will make the method *impure*,
    as accessing the database is considered a side-effect and makes it harder to verify
    and test. Thanks to possible API boundaries, it gets even more complicated if
    the `updateUser` method doesn’t know the DAO type at all. So you need to create
    another abstraction to retrieve the roles. Instead of creating an additional abstract
    layer to bridge the gap between the DAO and the `updateUser` method, you can make
    `updateUser` a higher-order function and accept a lambda expression.
  prefs: []
  type: TYPE_NORMAL
- en: A Functional Approach
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To create a functional abstraction for the retrieving of the required user roles
    in [Example 11-3](#_01-laziness_eager), you must first dissect the problem into
    a more abstract representation, finding out *what* is actually needed as an argument
    and not *how* the argument’s value came to be.
  prefs: []
  type: TYPE_NORMAL
- en: The `updateUser` method needs access to the available roles, as it is reflected
    in the original method signature. And that’s exactly the point in your code where
    introducing laziness will give you the most flexible solution.
  prefs: []
  type: TYPE_NORMAL
- en: The `Supplier<T>` type is the most low-level possibility to encapsulate certain
    logic to retrieve a value at your discretion. Instead of providing `updateUser`
    directly with the DAO, a lambda expression is the lazy intermediate construct
    for loading the roles, as seen in [Example 11-4](#_01-laziness_lazy).
  prefs: []
  type: TYPE_NORMAL
- en: Example 11-4\. Updating a `User` with a lambda
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_lazy_evaluation_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The `updateUser` method signature has to be changed to accept a `Supplier<List<Role>>`
    instead of the already loaded `List<Role>` or the DAO itself.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_lazy_evaluation_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The logic of how to acquire the roles is now encapsulated in a method reference.
  prefs: []
  type: TYPE_NORMAL
- en: Making `updateUser` a higher-order function by accepting a `Supplier` creates
    a superficial new layer without requiring an additional custom type wrapping the
    role-loading process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `DAO` directly as an argument eliminates the downsides:'
  prefs: []
  type: TYPE_NORMAL
- en: There’s no longer a connection between the `DAO` and the `updateUser` method,
    creating the possibility of a pure, side-effect-free method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You don’t need an additional type to represent the abstraction. The already
    available `Supplier<T>` functional interface is the simplest and most compatible
    form of abstraction possible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testability is restored without requiring the possibly complicated mocking of
    a DAO.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Costly operations, like database queries, can benefit immensely from a lazy
    approach if the call is avoidable. That doesn’t mean, though, that making all
    method arguments lazy without a real need is the right approach, either. There
    are other solutions, too, like caching the result of costly calls, that might
    be simpler to use than designing your method calls to accept lazy arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Delayed Executions with Thunks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Lambda expressions are a simple and low-level way to encapsulate an expression
    for later evaluation. One missing thing, though, is storing the result after evaluation — *memoization* — so
    you don’t re-evaluate an expression if called twice. There’s an easy way to remedy
    this omission: *Thunks*.'
  prefs: []
  type: TYPE_NORMAL
- en: A Thunk is a wrapper around a computation that is delayed until the result is
    needed. Unlike a `Supplier<T>`, which also delays a computation, a Thunk only
    evaluates once and directly returns the result on subsequent calls.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thunks fall into the general category of *lazy loading/initialization*, a design
    pattern often found in object-oriented code. Both techniques — lazy loading and
    lazy initialization — are similar mechanisms for achieving the same goal: non-strict
    evaluation and caching the result. Where a `Supplier<T>` just defers the evaluation,
    a Thunk also caches its result.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create a simple Thunk that follows the *virtual proxy* design-pattern^([3](ch11.xhtml#idm45115221832208))
    to be a drop-in replacement for `Supplier<T>`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Simple Thunk
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most straightforward approach is wrapping a `Supplier<T>` instance and storing
    its result after its first evaluation. By also implementing the `Supplier<T>`
    interface, the Thunk becomes a drop-in replacement, as shown in [Example 11-5](#_01-lazy_thunk_01).
  prefs: []
  type: TYPE_NORMAL
- en: Example 11-5\. A simple `Thunk<T>`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_lazy_evaluation_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: '`Thunk<T>` implements `Supplier<T>` to serve as a drop-in replacement.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_lazy_evaluation_CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The actual `Supplier<T>` needs to be stored to delay evaluation.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_lazy_evaluation_CO3-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The result must be stored after evaluation.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_lazy_evaluation_CO3-4)'
  prefs: []
  type: TYPE_NORMAL
- en: If not evaluated yet, the expression gets resolved, and its result is stored.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_lazy_evaluation_CO3-5)'
  prefs: []
  type: TYPE_NORMAL
- en: A convenience factory method to create a `Thunk` without needing `new` or generic
    type information, so the only constructor can be `private`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_lazy_evaluation_CO3-6)'
  prefs: []
  type: TYPE_NORMAL
- en: No need to create a `Thunk<T>` for a `Thunk<T>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This Thunk implementation is simple yet powerful. It adds memoization by calling
    a factory method with any `Supplier<T>` to create a drop-in replacement. Updating
    a `User`, like in the previous section, requires wrapping the method reference
    in the `Thunk.of` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The functional additions to `Thunk<T>` don’t have to stop here. You can easily
    add “glue methods,” as I discussed in [Chapter 2](ch02.xhtml#_01-functional-java),
    to support functional composition, as shown in [Example 11-6](#_01-lazy_thunk_02)
  prefs: []
  type: TYPE_NORMAL
- en: Example 11-6\. Functional additions to `Thunk<T>`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_lazy_evaluation_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Factory method for creating a `Thunk<T>` of a single value instead of an `Supplier<T>`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_lazy_evaluation_CO4-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Creates a new `Thunk<R>` including the `mapper` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_lazy_evaluation_CO4-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Creates a new `Thunk<R>` from a function that returns a+Thunk<T>+ without needlessly
    wrapping it in another `Thunk`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_lazy_evaluation_CO4-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Consumes a Thunks’ result.
  prefs: []
  type: TYPE_NORMAL
- en: With the addition of “glue” methods, the `Thunk<T>` type becomes a more versatile
    utility type for creating lazy pipelines for single expressions.
  prefs: []
  type: TYPE_NORMAL
- en: 'One general problem remains, though: *thread-safety*.'
  prefs: []
  type: TYPE_NORMAL
- en: A Thread-Safe Thunk
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For single-threaded environments, the `Thunk<T>` implementation I discussed
    in the previous section works as intended. However, if it’s accessed from another
    thread while the expression evaluates, a race condition might lead to re-evaluation.
    The only way to prevent this is to synchronize it across all accessing threads.
  prefs: []
  type: TYPE_NORMAL
- en: The most straightforward approach would be to add the keyword `synchronized`
    to its `get` method. However, it has the obvious downside of *always* requiring
    `synchronized` access and the associated overhead, even if the evaluation is already
    finished. Synchronization might not be as slow as it used to be, but it’s still
    an overhead for *every* call to the `get` method and definitely will slow down
    your code unnecessarily.
  prefs: []
  type: TYPE_NORMAL
- en: So how do you change the implementation to eliminate the race condition without
    affecting the overall performance more than necessary? You do a risk analysis
    of *where* and *when* a race condition can occur.
  prefs: []
  type: TYPE_NORMAL
- en: The risk of the evaluation-related race condition exists only until the expression
    is evaluated. After that, no double evaluation can happen, as the result is returned
    instead. That allows you to only synchronize the evaluation itself, not each call
    to the `get` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 11-7](#_01-lazy_think-cas-01) shows the introduction of a dedicated
    and `synchronized` `evaluate` method. The actual implementation of it, and how
    to access its result will be explained shortly.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 11-7\. `Thunk<T>` with synchronized evaluation
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous version of the `Thunk` used an additional field, `value`, to determine
    if the `expression` was already evaluated. The new, thread-safe variant, however,
    replaces the stored `value` and its checks with a dedicated abstraction that holds
    the value, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Holder<T>` does two things:'
  prefs: []
  type: TYPE_NORMAL
- en: Hold the evaluated value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement `Supplier<T>`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thanks to being a drop-in replacement for the field `expression`, a technique
    known as *compare & swap* (CAS). It’s used for designing concurrent algorithms,
    by comparing the value of a variable with an expected value, and if they are equal,
    swapping out the value for the new value. The operation has to be *atomic*, meaning
    it’s all-or-nothing for accessing the underlying data. That’s why the `evaluate`
    method has to be `synchronized`. Any thread can either see the data before or
    after, but never in-between evaluation and, therefore, eliminating the race condition.
  prefs: []
  type: TYPE_NORMAL
- en: In [Example 11-8](#_01-lazy_think-cas-02), you see a CAS implementation of `evaluate`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, the `private` field +expression can be replaced by the new type, as shown
    in [Example 11-7](#_01-lazy_think-cas-01).
  prefs: []
  type: TYPE_NORMAL
- en: Example 11-8\. Using `Holder<T>` instead of `Supplier<T>`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_lazy_evaluation_CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The field gets renamed to better reflect its usage, and also made non-`final`,
    as it has swapped out after the expression is evaluated.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_lazy_evaluation_CO5-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The expression only gets evaluated if the `holder` field currently isn’t a `Holder`
    instance, but the expression created in the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_lazy_evaluation_CO5-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The `holder` field, at this point holding the original lambda to evaluate the
    initial expression, gets swapped out for a `Holder` instance with the evaluated
    result.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_lazy_evaluation_CO5-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The un-`synchronized` `get` method uses the `holder` field directly to access
    the value, as it always references a `Supplier`.
  prefs: []
  type: TYPE_NORMAL
- en: The improved `Thunk<T>` implementation isn’t as simple as before, but it eliminates
    the race condition by decoupling the evaluation of the expression from accessing
    it.
  prefs: []
  type: TYPE_NORMAL
- en: On first access, the `holder` field will call `evaluate`, which is `synchronized`,
    and therefore thread-safe. Any additional calls while the expression is evaluated
    will call to `evaluate`, too. Instead of a re-evaluation, the type-check of the
    `holder` field skips directly to returning the result of `this.holder.get()`.
    Any access after the `holder` is re-assigned will skip any `synchronized` entirely.
  prefs: []
  type: TYPE_NORMAL
- en: That’s it, you now have a thread-safe, lazily evaluated `Supplier<T>` drop-in
    that only evaluates once.
  prefs: []
  type: TYPE_NORMAL
- en: Our `Thunk` implementation uses `synchronized`, but there are multiple approaches
    to implementing a *compare & swap* algorithm. The same general behavior can be
    accomplished using one of the `java.util.concurrent.atomic.Atomic…​` types in
    the JDK, or even use a `ConcurrentHashMap#computeIfAbsent` to prevent the race
    condition. The book “Java Concurrency” by Brian Goetz^([4](ch11.xhtml#idm45115220668960))
    provides a good starting point for better understanding atomic variables, non-blocking
    synchronization, and Java’s concurrency model in general.
  prefs: []
  type: TYPE_NORMAL
- en: Final Thoughts on Laziness
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At its core, the idea of laziness boils down to deferring required work until
    a point in time when it’s indispensable. The separation of *creating* and *consuming*
    expressions gives you a new axis of modularity in your code. This approach can
    improve performance immensely if an operation is optional and not required for
    each use case. Lazy evaluation also means, though, that you have to give up a
    certain degree of control over the exact time of evaluation.
  prefs: []
  type: TYPE_NORMAL
- en: The perceived and actual *loss of control* makes it much harder to reason about
    the required performance and memory characteristics of your code. The total performance
    requirement is the sum of all evaluated parts. Eager evaluation allows for quite
    linear and compositional performance assessment. Laziness shifts the actual computational
    cost from where expressions are defined to when they are used, with the possibility
    of code not being run at all. That’s why idiomatic lazy performance is harder
    to assess because the perceived performance would most likely improve immediately
    compared to eager evaluation, especially if your code has many costly but maybe
    optional code paths. The total performance requirements may vary on the general
    context and what code is actually evaluated. You’d have to analyze your lazy code’s
    “average” usage patterns and estimate the performance characteristics required
    under different scenarios, making straightforward benchmarking quite hard.
  prefs: []
  type: TYPE_NORMAL
- en: Software development is a constant battle of *effectively utilizing scarce resources*
    to reach the desired, or required, performance. Lazy techniques, like delayed
    evaluation, or Streams for data processing, are low-hanging fruits^([5](ch11.xhtml#idm45115220665120))
    to improve your code’s performance that is easy to integrate into an existing
    codebase. It definitely will reduce the required work to a minimum, maybe even
    zero, freeing up precious performance for other tasks. If some expression or costly
    computation can be avoided, making it lazy will most definitely be a worthwhile
    endeavor in the long run.
  prefs: []
  type: TYPE_NORMAL
- en: Takeaways
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Strict evaluation means expressions and method arguments evaluate immediately
    on declaration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lazy evaluation separates *creating* and *consuming* expressions by deferring
    their evaluation until their result is necessary, maybe even not evaluating them
    at all.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Strictness* is about “doing things”; *laziness* is about “considering things
    to do.”'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java is a “strict” language regarding expressions and method arguments, although
    certain *lazy* operators and control structures exist.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lambas encapsulate expressions, making them lazy wrappers to be evaluated at
    your discretion.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The JDK has several lazy runtime constructs and helper methods. For example,
    Streams are lazy functional pipelines, `Optional` and `Map` provide *lazy* additions
    to their general interfaces.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Supplier<T>` interface is the simplest way to create a lazy calculation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memoization, in the form of a `Thunk`, helps to avoid re-evaluation and can
    be used as a drop-in replacement for `Supplier<T>`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Laziness is a performance optimization powerhouse. The best code is the one
    that’s not run at all. The next best alternative is to run it only lazily “on-demand.”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The assessment of performance requirements for lazy code is difficult and might
    conceal performance problems if tested in environments not matching a “real-world”
    use case.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ^([1](ch11.xhtml#idm45115222435312-marker)) See [“Effectively final”](ch02.xhtml#_01-functions_lambdas_effectively-final)
    for the definition and requirements of *effectively* `final` variables.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch11.xhtml#idm45115222180992-marker)) A *DAO* (data access object) is
    a pattern to provide an abstract interface to a persistence layer like a database.
    It translates application calls to specific operations on the underlying persistence
    layer without exposing details of it.
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch11.xhtml#idm45115221832208-marker)) Wikipedia entry on [proxies](https://en.wikipedia.org/wiki/Proxy_pattern)
    provides an overview of the different kinds of proxies and their usage.
  prefs: []
  type: TYPE_NORMAL
- en: ^([4](ch11.xhtml#idm45115220668960-marker)) Goetz, Brian. 2006\. “Java Concurrency
    in Practice.” Addison-Wesley. ISBN 978-0321349606.
  prefs: []
  type: TYPE_NORMAL
- en: ^([5](ch11.xhtml#idm45115220665120-marker)) The concept of a *low-hanging fruit*
    describes a goal that is easy to achieve or taken advantage of, compared to the
    alternatives, like re-designing or refactoring your whole codebase.
  prefs: []
  type: TYPE_NORMAL
