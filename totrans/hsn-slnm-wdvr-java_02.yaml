- en: Chapter 1\. A Primer on Selenium
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 1 章. Selenium 入门
- en: '[*Selenium*](https://www.selenium.dev) is an open source suite composed of
    a set of libraries and tools that enable the automation of web browsers. We can
    see Selenium as an umbrella project with three core components: WebDriver, Grid,
    and IDE (Integrated Development Environment). Selenium WebDriver is a library
    that allows the driving of browsers programmatically. Thus, we can use Selenium
    WebDriver to navigate websites and interact with web pages (e.g., clicking on
    links, filling in forms, etc.) as a real user would do, in an automated fashion.
    The primary use of Selenium WebDriver is the automated testing of web applications.
    Other Selenium uses include the automation of web-based administration tasks or
    web scraping (automated web data extraction).'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '[*Selenium*](https://www.selenium.dev) 是一个由一组库和工具组成的开源套件，允许自动化 web 浏览器。我们可以将
    Selenium 视为一个以三个核心组件为中心的项目：WebDriver、Grid 和 IDE（集成开发环境）。Selenium WebDriver 是一个允许以编程方式驱动浏览器的库。因此，我们可以使用
    Selenium WebDriver 自动化地浏览网站并与网页交互（例如点击链接、填写表单等），就像真实用户一样。 Selenium WebDriver 的主要用途是自动化测试
    web 应用程序。 Selenium 的其他用途包括自动化基于 web 的管理任务或网络抓取（自动化的 web 数据提取）。'
- en: 'This chapter provides a comprehensive overview of the Selenium core components:
    WebDriver, Grid, and IDE. Then, it reviews the Selenium ecosystem, i.e., other
    tools and technologies around it. Finally, it analyzes the foundations of software
    testing related to Selenium.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章全面介绍了 Selenium 的核心组件：WebDriver、Grid 和 IDE。然后，它回顾了 Selenium 生态系统，即其周围的其他工具和技术。最后，它分析了与
    Selenium 相关的软件测试基础。
- en: Selenium Core Components
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Selenium 核心组件
- en: Jason Huggins and Paul Hammant created Selenium in 2004 while working in Thoughtworks.
    They chose the name “Selenium” as a counterpart to Mercury, an existing testing
    framework developed by Hewlett-Packard. The name is significant because the chemical
    selenium is known for reducing the toxicity of mercury.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Jason Huggins 和 Paul Hammant 在 Thoughtworks 工作期间于 2004 年创建了 Selenium。他们选择了“Selenium”这个名字作为
    Hewlett-Packard 开发的现有测试框架“Mercury”的对应物。这个名称很重要，因为化学元素硒以减少汞的毒性而闻名。
- en: 'That initial version of Selenium (known today as *Selenium Core*) is a JavaScript
    library that impersonates user actions in web applications. Selenium Core interprets
    the so-called *Selenese* commands to achieve this task. These commands are encoded
    as an HTML table composed of three parts: *command* (action executed in a web
    browser, such as opening a URL or clicking a link), *target* (locator that identifies
    a web element, such as the attribute of a given component), and *value* (optional
    data, such as the text typed into a web-form field).'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Selenium 的最初版本（今天称为 *Selenium Core*）是一个 JavaScript 库，模拟用户在 web 应用程序中的操作。 Selenium
    Core 解释所谓的 *Selenese* 命令来执行这些任务。这些命令被编码为由三部分组成的 HTML 表：*command*（在 web 浏览器中执行的操作，如打开
    URL 或点击链接）、*target*（标识 web 元素的定位器，如给定组件的属性）和 *value*（可选数据，如输入到 web 表单字段的文本）。
- en: Huggins and Hammant added a scripting layer to Selenium Core in a new project
    called *Selenium Remote Control* (RC). Selenium RC follows a client-server architecture.
    Clients use a binding language (such as Java or JavaScript) to send Selenese commands
    over HTTP to an intermediate proxy called the *Selenium RC Server*. This server
    launches web browsers on demand, injecting the Selenium Core library into a website
    and proxying requests from clients to Selenium Core. In addition, the Selenium
    RC Server masks the target website to the same local URL of the injected Selenium
    Core library to avoid same-origin policy concerns. This approach was a game-changer
    for browser automation at that time, but it had significant limitations. First,
    because JavaScript is the underlying technology to support automation, some actions
    are not permitted since JavaScript does not allow them—for instance, uploading
    and downloading files or handling pop-ups and dialogs, to name a few. Besides,
    Selenium RC introduces a relevant overhead that impacts its performance.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Huggins 和 Hammant 在 Selenium Core 中增加了一个脚本层，创建了一个名为 *Selenium Remote Control*（RC）的新项目。Selenium
    RC 遵循客户端-服务器架构。客户端使用绑定语言（如 Java 或 JavaScript）通过 HTTP 发送 Selenese 命令到一个名为 *Selenium
    RC Server* 的中间代理。这个服务器根据需求启动 Web 浏览器，在网站中注入 Selenium Core 库，并将来自客户端的请求代理到 Selenium
    Core。此外，Selenium RC Server 将目标网站伪装成注入的 Selenium Core 库的相同本地 URL，以避免同源策略的问题。这种方法在当时是浏览器自动化的一个变革，但它有显著的限制。首先，由于
    JavaScript 是支持自动化的基础技术，一些动作是不允许的，因为 JavaScript 不允许它们 - 例如，上传和下载文件或处理弹出窗口和对话框等。此外，Selenium
    RC 引入了相当大的开销，影响了其性能。
- en: In parallel, Simon Stewart created the project *WebDriver* in 2007\. WebDriver
    and Selenium RC were equivalent from a functional perspective, i.e., both projects
    allow programmers to impersonate web users using a programming language. Nevertheless,
    WebDriver uses the native support of each browser to carry out the automation,
    and therefore, its capabilities and performance are far superior to RC. In 2009,
    after a meeting between Jason Huggins and Simon Stewart at the Google Test Automation
    Conference, they decided to merge Selenium and WebDriver in a single project.
    The new project was called *Selenium WebDriver* or Selenium 2\. This new project
    uses a communication protocol based on HTTP combined with the native automation
    support on the browser. That approach is still the basis of Selenium 3 (released
    in 2016) and Selenium 4 (released in 2021). Now we refer to Selenium RC and Core
    as “Selenium 1,” and its use is discouraged in favor of Selenium WebDriver. This
    book focuses on the latest version of Selenium WebDriver to date, i.e., version
    4.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，Simon Stewart 在 2007 年创建了项目 *WebDriver*。从功能角度来看，WebDriver 和 Selenium RC
    是等效的，即两个项目都允许程序员使用编程语言模拟 Web 用户。然而，WebDriver 使用每个浏览器的原生支持来执行自动化，因此，其功能和性能远远优于
    RC。2009 年，在 Jason Huggins 和 Simon Stewart 在 Google 测试自动化大会上的会议之后，他们决定将 Selenium
    和 WebDriver 合并成一个单一项目。这个新项目被称为 *Selenium WebDriver* 或 Selenium 2。这个新项目使用了基于 HTTP
    的通信协议，结合了浏览器上的原生自动化支持。这种方法仍然是 Selenium 3（2016 年发布）和 Selenium 4（2021 年发布）的基础。现在我们将
    Selenium RC 和 Core 称为“Selenium 1”，并且鼓励使用 Selenium WebDriver。本书重点介绍迄今为止最新版本的 Selenium
    WebDriver，即版本 4。
- en: Tip
  id: totrans-8
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: '[Appendix A](app01.html#appendix01) summarizes the novelties shipped with Selenium
    4\. This appendix also contains a migration guide for bumping from Selenium 3
    to 4.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '[附录 A](app01.html#appendix01) 总结了随 Selenium 4 发布的新特性。本附录还包含了从 Selenium 3 升级到
    4 的迁移指南。'
- en: 'Today, Selenium is a well-known automation suite composed of three subprojects:
    WebDriver, Grid, and IDE. The following subsections present the main characteristics
    of each one.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，Selenium 是一个知名的自动化套件，由三个子项目组成：WebDriver、Grid 和 IDE。以下小节介绍了每个子项目的主要特点。
- en: Selenium WebDriver
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Selenium WebDriver
- en: Selenium WebDriver is a library that allows the controlling of web browsers
    automatically. To that aim, it provides a cross-platform API in different language
    bindings. The official programming languages supported by Selenium WebDriver are
    Java, JavaScript, Python, Ruby, and C#. Internally, Selenium WebDriver uses the
    native support implemented by each browser to carry out the automation process.
    For this reason, we need to place a component called *driver* between the script
    using the Selenium WebDriver API and the browser. [Table 1-1](#browsers-drivers)
    summarizes the browsers and drivers officially supported by Selenium WebDriver.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-13
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The name *Selenium* is widely used to refer to the library for browser automation.
    Since this term is also the name of the umbrella project, I use *Selenium* in
    this book to identify the browser automation suite, which is composed of three
    components: Selenium WebDriver (library), Selenium Grid (infrastructure), and
    Selenium IDE (tool).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Table 1-1\. Browsers and drivers supported by Selenium WebDriver
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '| Browser | Driver | Operating system | Maintainer | Download |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
- en: '| Chrome/Chromium | chromedriver | Windows/macOS/Linux | Google | [*https://chromedriver.chromium.org*](https://chromedriver.chromium.org)
    |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
- en: '| Edge | msedgedriver | Windows/macOS/Linux | Microsoft | [*https://developer.microsoft.com/en-us/microsoft-edge/tools/webdriver*](https://developer.microsoft.com/en-us/microsoft-edge/tools/webdriver)
    |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
- en: '| Firefox | geckodriver | Windows/macOS/Linux | Mozilla | [*https://github.com/mozilla/geckodriver*](https://github.com/mozilla/geckodriver)
    |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
- en: '| Opera | operadriver | Windows/macOS/Linux | Opera Software AS | [*https://github.com/operasoftware/operachromiumdriver*](https://github.com/operasoftware/operachromiumdriver)
    |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
- en: '| Internet Explorer | IEDriverServer | Windows | Selenium project | [*https://www.selenium.dev/downloads*](https://www.selenium.dev/downloads)
    |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
- en: '| Safari | safaridriver | macOS | Apple | Built-in |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
- en: Drivers (e.g., chromedriver, geckodriver, etc.) are platform-dependent binary
    files that receive commands from a WebDriver script and translate them into some
    browser-specific language. In the first releases of Selenium WebDriver (i.e.,
    in Selenium 2), these commands (also known as the *Selenium protocol*) were JSON
    messages over HTTP (the so-called *JSON Wire Protocol*). Nowadays, this communication
    (still JSON over HTTP) follows a standard specification named [*W3C WebDriver*](https://www.w3.org/TR/webdriver).
    This specification is the preferred Selenium protocol as of Selenium 4.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 1-1](#selenium-webdriver-arch) summarizes the basic architecture of
    Selenium WebDriver we have seen so far. As you can see, this architecture has
    three tiers. First, we find a script using the Selenium WebDriver API (Java, JavaScript,
    Python, Ruby, or C#). This script sends W3C WebDriver commands to the second layer,
    in which we find the drivers. This figure shows the specific case of using chromedriver
    (to control Chrome) and geckodriver (to control Firefox). Finally, the third layer
    contains the web browsers. In the case of Chrome, the native browser follows the
    [*DevTools Protocol*](https://chromedevtools.github.io/devtools-protocol). DevTools
    is a set of developer tools for browsers based on the Blink rendering engine,
    such as Chrome, Chromium, Edge, or Opera. The DevTools Protocol is based on JSON-RPC
    messages and allows inspecting, debugging, and profiling these browsers. In Firefox,
    the native automation support uses the [*Marionette*](https://firefox-source-docs.mozilla.org/testing/marionette)
    protocol. Marionette is a remote protocol based on JSON, allowing instrumenting
    and controlling web browsers based on the Gecko engine (such as Firefox).'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 1-1](#selenium-webdriver-arch) 总结了我们迄今所见的 Selenium WebDriver 的基本架构。可以看到，这个架构有三层。首先，我们有一个使用
    Selenium WebDriver API 的脚本（Java、JavaScript、Python、Ruby 或 C#）。这个脚本将 W3C WebDriver
    命令发送到第二层，其中包含驱动程序。本图展示了使用 chromedriver（控制 Chrome）和 geckodriver（控制 Firefox）的具体情况。最后，第三层包含了
    Web 浏览器。在 Chrome 的情况下，本机浏览器遵循 [*DevTools Protocol*](https://chromedevtools.github.io/devtools-protocol)。DevTools
    是针对基于 Blink 渲染引擎的浏览器（如 Chrome、Chromium、Edge 或 Opera）的一组开发者工具。DevTools Protocol
    基于 JSON-RPC 消息，并允许检查、调试和分析这些浏览器。在 Firefox 中，本机自动化支持使用 [*Marionette*](https://firefox-source-docs.mozilla.org/testing/marionette)
    协议。Marionette 是一个基于 JSON 的远程协议，允许对基于 Gecko 引擎的 Web 浏览器（如 Firefox）进行仪器化和控制。'
- en: '![hosw 0101](assets/hosw_0101.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![hosw 0101](assets/hosw_0101.png)'
- en: Figure 1-1\. Selenium WebDriver architecture
  id: totrans-27
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1-1\. Selenium WebDriver 架构
- en: Overall, Selenium WebDriver allows controlling web browsers as a user would,
    but programmatically. To that aim, the Selenium WebDriver API provides a wide
    variety of features to navigate web pages, interact with web elements, or impersonate
    user actions, among many other capabilities. The target application is web-based,
    such as static websites, dynamic web applications, Single Page Applications (SPA),
    complex enterprise systems with a web interface, etc.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 总体来说，Selenium WebDriver 允许以编程方式控制网页浏览器，如同用户一样操作。为此，Selenium WebDriver API 提供了广泛的功能，用于浏览网页、与网页元素交互或模拟用户操作等。目标应用程序是基于
    web 的，如静态网站、动态 Web 应用程序、单页面应用程序（SPA）、具有 Web 界面的复杂企业系统等。
- en: Selenium Grid
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Selenium Grid
- en: The second project of the Selenium family is *Selenium Grid*. Philippe Hanrigou
    started the development of this project in 2008\. Selenium Grid is a group of
    networked hosts that provides browser infrastructure for Selenium WebDriver. This
    infrastructure enables the (parallel) execution of Selenium WebDriver scripts
    with remote browsers of a different nature (types and versions) in multiple operating
    systems.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Selenium 家族的第二个项目是 *Selenium Grid*。Philippe Hanrigou 在 2008 年开始开发该项目。Selenium
    Grid 是一组网络主机，为 Selenium WebDriver 提供浏览器基础设施。这种基础设施使得可以在多个操作系统上（并行）执行 Selenium
    WebDriver 脚本，使用不同类型和版本的远程浏览器。
- en: '[Figure 1-2](#selenium-grid-hub-node-arch) shows the basic architecture of
    Selenium Grid. As you can see, a group of nodes provides browsers used by Selenium
    scripts. These nodes can use different operating systems (as we saw in [Table 1-1](#browsers-drivers))
    with various installed browsers. The central entry point to this Grid is the *Hub*
    (also known as *Selenium Server*). This server-side component keeps track of the
    nodes and proxies requests from the Selenium scripts. Like in Selenium WebDriver,
    the W3C WebDriver specification is the standard protocol for the communication
    between these scripts and the Hub.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 1-2](#selenium-grid-hub-node-arch) 展示了 Selenium Grid 的基本架构。可以看到，一组节点提供了
    Selenium 脚本使用的浏览器。这些节点可以使用不同的操作系统（如我们在 [表 1-1](#browsers-drivers) 中看到的）以及安装了各种浏览器。这个
    Grid 的中心入口点是 *Hub*（也称为 *Selenium 服务器*）。这个服务器端组件负责跟踪节点并代理 Selenium 脚本的请求。与 Selenium
    WebDriver 类似，W3C WebDriver 规范是这些脚本与 Hub 之间通信的标准协议。'
- en: '![hosw 0102](assets/hosw_0102.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![hosw 0102](assets/hosw_0102.png)'
- en: Figure 1-2\. Selenium Grid hub-nodes architecture
  id: totrans-33
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1-2\. Selenium Grid 汇集节点架构
- en: The hub-nodes architecture in Grid has been available since Selenium 2\. This
    architecture is also present in Selenium 3 and 4\. Nevertheless, this centralized
    architecture can lead to performance bottlenecks if the number of requests to
    the Hub is high. Selenium 4 provides a fully distributed flavor of Selenium Grid
    to avoid this problem. This architecture implements advanced load balancing mechanisms
    to avoid overloading any component.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Grid 中的中心-节点架构自 Selenium 2 版本以来就已经可用。这种架构在 Selenium 3 和 4 中也存在。然而，如果向中心发送的请求数量很大，这种集中式架构可能会导致性能瓶颈。Selenium
    4 提供了完全分布式的 Selenium Grid 变体，以避免这个问题。此架构实现了先进的负载均衡机制，以避免任何组件的过载。
- en: Tip
  id: totrans-35
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: Tip
- en: '[Chapter 6](ch06.html#ch06) describes how to set up Selenium Grid following
    the classical approach (based on a hub and set of nodes). This chapter also covers
    the *standalone* mode (i.e., hub and node(s) hosted in the same machine) and the
    fully distributed architecture.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 6 章](ch06.html#ch06)描述了如何按照经典方法设置 Selenium Grid（基于中心和一组节点）。本章还涵盖了*独立*模式（即在同一台机器上托管中心和节点）以及完全分布式架构。'
- en: Selenium IDE
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Selenium IDE
- en: '[Selenium IDE](https://www.selenium.dev/selenium-ide) is the last core component
    of the Selenium suite. Shinya Kasatani created this project in 2006\. Selenium
    IDE is a tool that implements the so-called *Record and Playback* (R&P) automation
    technique. As the name suggests, this technique has two steps. First, in Selenium
    IDE, the *record* part captures user interactions with a browser, encoding these
    actions as Selenium commands. Second, we use the generated Selenium script to
    execute a browser session automatically (*playback*).'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '[Selenium IDE](https://www.selenium.dev/selenium-ide) 是 Selenium 套件的最后一个核心组件。Shinya
    Kasatani 在 2006 年创建了这个项目。Selenium IDE 是一个实现所谓的*记录和回放*（R&P）自动化技术的工具。顾名思义，这项技术分为两步。首先，在
    Selenium IDE 中，*记录*部分捕捉用户与浏览器的交互，将这些动作编码为 Selenium 命令。其次，使用生成的 Selenium 脚本自动执行浏览器会话（*回放*）。'
- en: This early version of Selenium IDE was a Firefox plug-in that embedded Selenium
    Core to record, edit, and play back Selenium scripts. These early versions were
    XPI modules (i.e., a technology used to create Mozilla extensions). As of version
    55 (released in 2017), Firefox migrated support for add-ons to the [W3C Browser
    Extension specification](https://browserext.github.io/browserext). As a result,
    Selenium IDE was discontinued, and for some time, it has not been possible to
    use it. The Selenium team rewrote Selenium IDE following the Browser Extensions
    recommendation to solve this problem. Thanks to this, we can now use Selenium
    IDE in multiple browsers, such as Chrome, Edge, and Firefox.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Selenium IDE 的早期版本是一个嵌入 Selenium Core 来录制、编辑和回放 Selenium 脚本的 Firefox 插件。这些早期版本是
    XPI 模块（即用于创建 Mozilla 扩展的技术）。从 2017 年发布的版本 55 开始，Firefox 将对插件的支持迁移到[W3C 浏览器扩展规范](https://browserext.github.io/browserext)。因此，Selenium
    IDE 被停用，并且一段时间内无法使用。Selenium 团队根据浏览器扩展建议重新编写了 Selenium IDE，以解决这个问题。由此，我们现在可以在
    Chrome、Edge 和 Firefox 等多个浏览器中使用 Selenium IDE。
- en: '[Figure 1-3](#selenium-ide) shows the new Selenium IDE GUI (Graphical User
    Interface).'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 1-3](#selenium-ide)展示了新版 Selenium IDE GUI（图形用户界面）。'
- en: 'Using this GUI, users can record interactions with a browser and edit and execute
    the generated script. Selenium IDE encodes each interaction in different parts:
    a command (i.e., the action executed in the browser), a target (i.e., the locator
    of the web element), and a value (i.e., the data handled). Optionally, we can
    include a description of the command. [Figure 1-3](#selenium-ide) shows a recorded
    example of these steps:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此 GUI，用户可以记录与浏览器的交互并编辑和执行生成的脚本。Selenium IDE 将每个交互编码为不同部分：命令（即在浏览器中执行的动作）、目标（即
    Web 元素的定位器）和值（即处理的数据）。我们还可以选择包括命令的描述。[图 1-3](#selenium-ide)展示了这些步骤的一个记录示例：
- en: Open website ([*https://bonigarcia.dev/selenium-webdriver-java*](https://bonigarcia.dev/selenium-webdriver-java)).
    We will use this website as the practice site in the rest of the book.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开网站（[*https://bonigarcia.dev/selenium-webdriver-java*](https://bonigarcia.dev/selenium-webdriver-java)）。在本书的其余部分中，我们将使用此网站作为实践站点。
- en: Click on the link with the text “GitHub.” As a result, the navigation moves
    to the examples repository source code.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击带有“GitHub”文本的链接。结果，导航移动到示例存储库源代码。
- en: Assert that the book title (*Hands-On Selenium WebDriver with Java*) is present
    on the web page.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 断言网页上存在书名（*Hands-On Selenium WebDriver with Java*）。
- en: Close the browser.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭浏览器。
- en: '![hosw 0103](assets/hosw_0103.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![hosw 0103](assets/hosw_0103.png)'
- en: Figure 1-3\. Selenium IDE showing an example of a recorded script
  id: totrans-47
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1-3\. Selenium IDE 显示了录制脚本的示例
- en: Once we have created a script in Selenium IDE, we can export this script as
    a Selenium WebDriver test. For instance, [Figure 1-4](#selenium-ide-export-junit)
    shows how to convert the presented example as a JUnit test case. Finally, we can
    save the project on our local machine. The resulting project for this sample is
    available in the [examples GitHub repository](https://github.com/bonigarcia/selenium-webdriver-java/tree/master/selenium-ide).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们在 Selenium IDE 中创建了脚本，我们就可以将此脚本导出为 Selenium WebDriver 测试。例如，[图 1-4](#selenium-ide-export-junit)
    展示了如何将所示示例转换为 JUnit 测试用例。最后，我们可以将项目保存在本地计算机上。此示例的结果项目可在 [示例 GitHub 存储库](https://github.com/bonigarcia/selenium-webdriver-java/tree/master/selenium-ide)
    中找到。
- en: Note
  id: totrans-49
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注
- en: The Selenium project is porting Selenium IDE to [Electron](https://www.electronjs.org)
    at the time of this writing. Electron is an open source framework based on Chromium
    and Node.js that allows desktop application development.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Selenium 项目正在将 Selenium IDE 移植到 [Electron](https://www.electronjs.org)。Electron
    是一个基于 Chromium 和 Node.js 的开源框架，允许进行桌面应用程序开发。
- en: '![hosw 0104](assets/hosw_0104.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![hosw 0104](assets/hosw_0104.png)'
- en: Figure 1-4\. Exporting a Selenium IDE script to a JUnit test case
  id: totrans-52
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1-4\. 将 Selenium IDE 脚本导出为 JUnit 测试用例
- en: Selenium Ecosystem
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Selenium 生态系统
- en: 'Software ecosystems are collections of elements interacting with a shared market
    underpinned by a common technological background. In the case of Selenium, its
    ecosystem involves the official core projects and other related projects, libraries,
    and actors. This section reviews the Selenium ecosystem, divided into the following
    categories: language bindings, driver managers, frameworks, browser infrastructure,
    and community.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 软件生态系统是与共同技术背景支持下的共享市场进行交互的元素的集合。在 Selenium 的情况下，其生态系统涉及官方核心项目和其他相关项目、库和参与者。本节将审查
    Selenium 生态系统，分为以下几类：语言绑定、驱动程序管理器、框架、浏览器基础设施和社区。
- en: Language Bindings
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语言绑定
- en: 'As we already know, the Selenium project maintains various language bindings
    for Selenium WebDriver: Java, JavaScript, Python, Ruby, and C#. Nevertheless,
    other languages are also available. [Table 1-2](#language-bindings) summarizes
    these language bindings for Selenium WebDriver maintained by the community.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所知，Selenium 项目为 Selenium WebDriver 维护了各种语言绑定：Java、JavaScript、Python、Ruby
    和 C#。然而，也有其他语言可用。[表 1-2](#language-bindings) 总结了社区维护的 Selenium WebDriver 的这些语言绑定。
- en: Table 1-2\. Unofficial language bindings for Selenium WebDriver
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 表 1-2\. Selenium WebDriver 的非官方语言绑定
- en: '| Name | Language | License | Maintainer | Website |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 语言 | 许可证 | 维护者 | 网站 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| hs-webdriver | Haskell | BSD-3-Clause | Adam Curtis | [*https://github.com/kallisti-dev/hs-webdriver*](https://github.com/kallisti-dev/hs-webdriver)
    |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| hs-webdriver | Haskell | BSD-3-Clause | Adam Curtis | [*https://github.com/kallisti-dev/hs-webdriver*](https://github.com/kallisti-dev/hs-webdriver)
    |'
- en: '| php-webdriver | PHP | MIT | Facebook, community | [*https://github.com/php-webdriver/php-webdriver*](https://github.com/php-webdriver/php-webdriver)
    |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| php-webdriver | PHP | MIT | Facebook、社区 | [*https://github.com/php-webdriver/php-webdriver*](https://github.com/php-webdriver/php-webdriver)
    |'
- en: '| RSelenium | R | AGPLv3 | rOpenSci | [*https://github.com/ropensci/RSelenium*](https://github.com/ropensci/RSelenium)
    |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| RSelenium | R | AGPLv3 | rOpenSci | [*https://github.com/ropensci/RSelenium*](https://github.com/ropensci/RSelenium)
    |'
- en: '| Selenium | Go | MIT | Miki Tebeka | [*https://github.com/tebeka/selenium*](https://github.com/tebeka/selenium)
    |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| Selenium | Go | MIT | Miki Tebeka | [*https://github.com/tebeka/selenium*](https://github.com/tebeka/selenium)
    |'
- en: '| Selenium-Remote-Driver | Perl | Apache 2.0 | George S. Baugh | [*https://github.com/teodesian/Selenium-Remote-Driver*](https://github.com/teodesian/Selenium-Remote-Driver)
    |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| Selenium-Remote-Driver | Perl | Apache 2.0 | George S. Baugh | [*https://github.com/teodesian/Selenium-Remote-Driver*](https://github.com/teodesian/Selenium-Remote-Driver)
    |'
- en: '| webdriver.dart | Dart | Apache 2.0 | Google | [*https://github.com/google/webdriver.dart*](https://github.com/google/webdriver.dart)
    |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| webdriver.dart | Dart | Apache 2.0 | Google | [*https://github.com/google/webdriver.dart*](https://github.com/google/webdriver.dart)
    |'
- en: '| wd | JavaScript | Apache 2.0 | Adam Christian | [*https://github.com/admc/wd*](https://github.com/admc/wd)
    |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| wd | JavaScript | Apache 2.0 | Adam Christian | [*https://github.com/admc/wd*](https://github.com/admc/wd)
    |'
- en: Driver Managers
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 驱动程序管理器
- en: 'Drivers are mandatory components to control web browsers natively with Selenium
    WebDriver (see [Figure 1-1](#selenium-webdriver-arch)). For this reason, before
    using the Selenium WebDriver API, we need to manage these drivers. *Driver management*
    is the process of downloading, setting up, and maintaining the proper driver for
    a given browser. The usual steps in the driver management procedure are:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动程序是使用Selenium WebDriver原生控制网络浏览器所必需的组件（参见[Figure 1-1](#selenium-webdriver-arch)）。因此，在使用Selenium
    WebDriver API之前，我们需要管理这些驱动程序。*驱动程序管理*是指下载、设置和维护适合特定浏览器的正确驱动程序的过程。驱动程序管理过程中的常见步骤包括：
- en: 1\. Download
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 下载
- en: Each browser has its own driver. For example, we use chromedriver for controlling
    Chrome or geckodriver for Firefox (see [Table 1-1](#browsers-drivers)). The driver
    is a platform-specific binary file. Therefore, we need to download the proper
    driver for a given operating system (typically, Windows, macOS, or Linux). In
    addition, we need to consider the driver version since a driver release is compatible
    with a given browser version (or range). For example, to use Chrome 91.x, we need
    to download chromedriver 91.0.4472.19\. We usually find the browser-driver compliance
    in the driver documentation or release notes.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 每个浏览器都有自己的驱动程序。例如，我们使用chromedriver来控制Chrome或geckodriver来控制Firefox（参见[Table 1-1](#browsers-drivers)）。驱动程序是特定于平台的二进制文件。因此，我们需要为特定操作系统（通常是Windows、macOS或Linux）下载适当的驱动程序。此外，我们需要考虑驱动程序的版本，因为驱动程序发布与特定浏览器版本（或范围）兼容。例如，要使用Chrome
    91.x，我们需要下载chromedriver 91.0.4472.19\. 我们通常可以在驱动程序文档或发布说明中找到浏览器驱动程序的兼容性信息。
- en: 2\. Setup
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 设置
- en: Once we have the proper driver, we need to make it available in our Selenium
    WebDriver script.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了合适的驱动程序，我们需要在我们的Selenium WebDriver脚本中使其可用。
- en: 3\. Maintenance
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. 维护
- en: Modern web browsers (e.g., Chrome, Firefox, or Edge) upgrade themselves automatically
    and silently, without prompting the user. For this reason, and concerning Selenium
    WebDriver, we need to maintain the browser-driver version compatibility in time
    for these so-called *evergreen* browsers.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现代网络浏览器（例如Chrome，Firefox或Edge）会自动静默升级，无需提示用户。因此，关于Selenium WebDriver，我们需要及时维护浏览器驱动程序版本的兼容性，以适应这些所谓的*evergreen*浏览器。
- en: As you can see, the driver maintenance process can be time-consuming. Furthermore,
    it can cause problems for Selenium WebDriver users (e.g., failed tests due to
    browser-driver incompatibility after an automatic browser upgrade). For this reason,
    the so-called *driver managers* aim to carry out the driver management process
    in an automated fashion to some extent. [Table 1-3](#managers) summarizes the
    available driver managers for different language bindings.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，驱动程序的维护过程可能耗时。此外，它可能会给Selenium WebDriver用户带来问题（例如，由于自动浏览器升级后的浏览器驱动程序不兼容而导致的测试失败）。因此，所谓的*驱动程序管理器*旨在在一定程度上自动化驱动程序管理过程。[Table 1-3](#managers)总结了不同语言绑定的可用驱动程序管理器。
- en: Table 1-3\. Driver managers for Selenium WebDriver
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Table 1-3\. Selenium WebDriver的驱动程序管理器
- en: '| Name | Language | License | Maintainer | Website |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| Name | Language | License | Maintainer | Website |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| WebDriverManager | Java | Apache 2.0 | Boni García | [*https://github.com/bonigarcia/webdrivermanager*](https://github.com/bonigarcia/webdrivermanager)
    |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| WebDriverManager | Java | Apache 2.0 | Boni García | [*https://github.com/bonigarcia/webdrivermanager*](https://github.com/bonigarcia/webdrivermanager)
    |'
- en: '| webdriver-manager | JavaScript | MIT | Google | [*https://www.npmjs.com/package/webdriver-manager*](https://www.npmjs.com/package/webdriver-manager)
    |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| webdriver-manager | JavaScript | MIT | Google | [*https://www.npmjs.com/package/webdriver-manager*](https://www.npmjs.com/package/webdriver-manager)
    |'
- en: '| webdriver-manager | Python | Apache 2.0 | Serhii Pirohov | [*https://pypi.org/project/webdriver-manager*](https://pypi.org/project/webdriver-manager)
    |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| webdriver-manager | Python | Apache 2.0 | Serhii Pirohov | [*https://pypi.org/project/webdriver-manager*](https://pypi.org/project/webdriver-manager)
    |'
- en: '| WebDriverManager.Net | C# | MIT | Aliaksandr Rasolka | [*https://github.com/rosolko/WebDriverManager.Net*](https://github.com/rosolko/WebDriverManager.Net)
    |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| WebDriverManager.Net | C# | MIT | Aliaksandr Rasolka | [*https://github.com/rosolko/WebDriverManager.Net*](https://github.com/rosolko/WebDriverManager.Net)
    |'
- en: '| webdrivers | Ruby | MIT | Titus Fortner | [*https://github.com/titusfortner/webdrivers*](https://github.com/titusfortner/webdrivers)
    |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| webdrivers | Ruby | MIT | Titus Fortner | [*https://github.com/titusfortner/webdrivers*](https://github.com/titusfortner/webdrivers)
    |'
- en: Tip
  id: totrans-84
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: In this book, I recommend using WebDriverManager because it automates the entire
    driver maintenance process (i.e., download, setup, and maintenance). See [Appendix B](app02.html#appendix02)
    for further information about automated and manual driver management.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我推荐使用 WebDriverManager，因为它自动化了整个驱动程序维护过程（即下载、设置和维护）。有关自动化和手动驱动程序管理的更多信息，请参见
    [附录 B](app02.html#appendix02)。
- en: Locator Tools
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定位器工具
- en: 'The Selenium WebDriver API provides different ways to locate web elements (see
    [Chapter 3](ch03.html#ch03)): by attribute (id, name, or class), by link text
    (complete or partial), by tag name, by CSS (Cascading Style Sheets) selector,
    or by XML Path Language (XPath). Specific tools can help to identify and generate
    these locators. [Table 1-4](#locators) shows some of these tools.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Selenium WebDriver API 提供了不同的定位 Web 元素的方法（参见 [第 3 章](ch03.html#ch03)）：通过属性（id、name
    或 class）、通过链接文本（完整或部分）、通过标签名、通过 CSS（层叠样式表）选择器或通过 XML Path Language（XPath）。具体的工具可以帮助识别和生成这些定位器。[表格
    1-4](#locators) 展示了其中一些工具。
- en: Table 1-4\. Locators tools summary
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 表格 1-4\. 定位器工具概述
- en: '| Name | Type | License | Maintainer | Website |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 类型 | 许可证 | 维护者 | 网站 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| Chrome DevTools | Built-in browser tool | Proprietary freeware, based on
    open source | Google | [*https://developer.chrome.com/docs/devtools*](https://developer.chrome.com/docs/devtools)
    |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| Chrome DevTools | 内置浏览器工具 | 专有免费软件，基于开源 | Google | [*https://developer.chrome.com/docs/devtools*](https://developer.chrome.com/docs/devtools)
    |'
- en: '| Firefox Developer Tools | Built-in browser tool | MPL 2.0 | Mozilla | [*https://developer.mozilla.org/en-US/docs/Tools*](https://developer.mozilla.org/en-US/docs/Tools)
    |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| Firefox Developer Tools | 内置浏览器工具 | MPL 2.0 | Mozilla | [*https://developer.mozilla.org/en-US/docs/Tools*](https://developer.mozilla.org/en-US/docs/Tools)
    |'
- en: '| Cropath | Browser extension | Freeware | AutonomIQ | [*https://autonomiq.io/deviq-chropath.html*](https://autonomiq.io/deviq-chropath.html)
    |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| Cropath | 浏览器扩展 | 免费软件 | AutonomIQ | [*https://autonomiq.io/deviq-chropath.html*](https://autonomiq.io/deviq-chropath.html)
    |'
- en: '| SelectorsHub | Browser extension | Freeware | Sanjay Kumar | [*https://selectorshub.com*](https://selectorshub.com)
    |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| SelectorsHub | 浏览器扩展 | 免费软件 | Sanjay Kumar | [*https://selectorshub.com*](https://selectorshub.com)
    |'
- en: '| POM Builder | Browser extension | Freeware | LogiGear Corporation | [*https://pombuilder.com*](https://pombuilder.com)
    |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| POM Builder | 浏览器扩展 | 免费软件 | LogiGear Corporation | [*https://pombuilder.com*](https://pombuilder.com)
    |'
- en: Frameworks
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 框架
- en: In software engineering, a *framework* is a set of libraries and tools used
    as a conceptual and technological base and support for software development. Selenium
    is the foundation for frameworks that wrap, enhance, or complement its default
    features. [Table 1-5](#frameworks) contains some of these frameworks and libraries
    based on Selenium.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件工程中，*框架*是一组用作软件开发的概念和技术基础和支持的库和工具。Selenium 是包装、增强或补充其默认功能的框架的基础。[表格 1-5](#frameworks)
    包含了基于 Selenium 的这些框架和库。
- en: Table 1-5\. Testing frameworks and libraries based on Selenium
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 表格 1-5\. 基于 Selenium 的测试框架和库
- en: '| Name | Language | Description | License | Maintainer | Website |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 语言 | 描述 | 许可证 | 维护者 | 网站 |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| CodeceptJS | JavaScript | Multi-backend testing framework that models browser
    interactions as simple steps from a user perspective | MIT | Michael Bodnarchuk
    | [*https://codecept.io*](https://codecept.io) |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| CodeceptJS | JavaScript | 将浏览器交互建模为用户视角的简单步骤的多后端测试框架 | MIT | Michael Bodnarchuk
    | [*https://codecept.io*](https://codecept.io) |'
- en: '| FluentSelenium | Java | Fluent API for Selenium WebDriver | Apache 2.0 |
    Paul Hammant | [*https://github.com/SeleniumHQ/fluent-selenium*](https://github.com/SeleniumHQ/fluent-selenium)
    |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| FluentSelenium | Java | Selenium WebDriver 的流畅 API | Apache 2.0 | Paul Hammant
    | [*https://github.com/SeleniumHQ/fluent-selenium*](https://github.com/SeleniumHQ/fluent-selenium)
    |'
- en: '| FluentLenium | Java | Website and mobile automation framework to create readable
    and reusable WebDriver tests | Apache 2.0 | FluentLenium team | [*https://fluentlenium.com*](https://fluentlenium.com)
    |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| FluentLenium | Java | 网站和移动自动化框架，用于创建可读性强、可重用的 WebDriver 测试 | Apache 2.0
    | FluentLenium 团队 | [*https://fluentlenium.com*](https://fluentlenium.com) |'
- en: '| Healenium | Java | Library for improving the stability of Selenium tests
    by using machine learning algorithms to analyze web and mobile web elements |
    Apache 2.0 | Anna Chernyshova and Dmitriy Gumeniuk | [*https://healenium.io*](https://healenium.io)
    |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| Healenium | Java | 使用机器学习算法分析 Web 和移动 Web 元素，改善 Selenium 测试稳定性的库 | Apache
    2.0 | Anna Chernyshova 和 Dmitriy Gumeniuk | [*https://healenium.io*](https://healenium.io)
    |'
- en: '| Helium | Python | High-level API based on Selenium WebDriver | MIT | Michael
    Herrmann | [*https://github.com/mherrmann/selenium-python-helium*](https://github.com/mherrmann/selenium-python-helium)
    |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| Helium | Python | 基于Selenium WebDriver的高级API | MIT | Michael Herrmann | [*https://github.com/mherrmann/selenium-python-helium*](https://github.com/mherrmann/selenium-python-helium)
    |'
- en: '| QAF (QMetry Automation Framework) | Java | Test automation platform for web
    and mobile applications | MIT | Chirag Jayswal | [*https://qmetry.github.io/qaf*](https://qmetry.github.io/qaf)
    |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| QAF (QMetry Automation Framework) | Java | 用于Web和移动应用程序的测试自动化平台 | MIT | Chirag
    Jayswal | [*https://qmetry.github.io/qaf*](https://qmetry.github.io/qaf) |'
- en: '| Lightning | Java | Lightweight Selenium WebDriver client for Java | Apache
    2.0 | FluentLenium | [*https://github.com/aerokube/lightning-java*](https://github.com/aerokube/lightning-java)
    |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| Lightning | Java | 轻量级的Selenium WebDriver Java客户端 | Apache 2.0 | FluentLenium
    | [*https://github.com/aerokube/lightning-java*](https://github.com/aerokube/lightning-java)
    |'
- en: '| Nerodia | Python | Python port of the Watir Ruby gem | MIT | Lucas Tierney
    | [*https://nerodia.readthedocs.io*](https://nerodia.readthedocs.io) |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| Nerodia | Python | Watir Ruby gem的Python移植版 | MIT | Lucas Tierney | [*https://nerodia.readthedocs.io*](https://nerodia.readthedocs.io)
    |'
- en: '| Robot Framework | Python, Java, .NET, and others | Generic automation framework
    based on human-readable test cases | Apache 2.0 | Robot Framework Foundation |
    [*https://robotframework.org*](https://robotframework.org) |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| Robot Framework | Python, Java, .NET等 | 基于可读测试用例的通用自动化框架 | Apache 2.0 | Robot
    Framework Foundation | [*https://robotframework.org*](https://robotframework.org)
    |'
- en: '| Selenide team | Java | Fluent, concise API for Selenium WebDriver | MIT |
    Selenide team | [*https://selenide.org*](https://selenide.org) |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| Selenide团队 | Java | Selenium WebDriver的流畅、简洁API | MIT | Selenide团队 | [*https://selenide.org*](https://selenide.org)
    |'
- en: '| SeleniumBase | Python | Browser automation framework based on WebDriver and
    pytest | MIT | Michael Mintz | [*https://seleniumbase.io*](https://seleniumbase.io)
    |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| SeleniumBase | Python | 基于WebDriver和pytest的浏览器自动化框架 | MIT | Michael Mintz
    | [*https://seleniumbase.io*](https://seleniumbase.io) |'
- en: '| Watir (Web Application Testing in Ruby) | Ruby | Gem library based on WebDriver
    for automating web browsers | MIT | Titus Fortner | [*http://watir.com*](http://watir.com)
    |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| Watir (Web Application Testing in Ruby) | Ruby | 基于WebDriver的Ruby gem库，用于自动化Web浏览器
    | MIT | Titus Fortner | [*http://watir.com*](http://watir.com) |'
- en: '| WebDriverIO | JavaScript | Test automation framework based WebDriver and
    Appium | MIT | Christian Bromann | [*https://webdriver.io*](https://webdriver.io)
    |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| WebDriverIO | JavaScript | 基于WebDriver和Appium的测试自动化框架 | MIT | Christian Bromann
    | [*https://webdriver.io*](https://webdriver.io) |'
- en: '| Nightwatch.js | JavaScript | Integrated end-to-end testing framework based
    on the W3C WebDriver | MIT | Andrei Rusu | [*https://nightwatchjs.org*](https://nightwatchjs.org)
    |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| Nightwatch.js | JavaScript | 基于W3C WebDriver的集成端到端测试框架 | MIT | Andrei Rusu
    | [*https://nightwatchjs.org*](https://nightwatchjs.org) |'
- en: '| Applitools | Java, JavaScript, C#, Ruby, PHP, Python | Test automation framework
    for visual user interface regression and A/B testing. It provides SDKs for Selenium,
    Appium, and others | Commercial | Applitools team | [*https://applitools.com*](https://applitools.com)
    |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| Applitools | Java, JavaScript, C#, Ruby, PHP, Python | 用于视觉用户界面回归和A/B测试的测试自动化框架。它为Selenium、Appium等提供SDK
    | 商业 | Applitools团队 | [*https://applitools.com*](https://applitools.com) |'
- en: '| Katalon Studio | Java, Groovy | Test automation platform leveraging Selenium
    WebDriver, Appium, and cloud providers | Commercial | Katalon team | [*https://www.katalon.com*](https://www.katalon.com)
    |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| Katalon Studio | Java, Groovy | 利用Selenium WebDriver、Appium和云提供商的测试自动化平台
    | 商业 | Katalon团队 | [*https://www.katalon.com*](https://www.katalon.com) |'
- en: '| TestProject | Java, C#, Python | Test automation platform for web and mobile
    apps built on top of Selenium and Appium | Commercial | TestProject team | [*https://testproject.io*](https://testproject.io)
    |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| TestProject | Java, C#, Python | 构建在Selenium和Appium之上的Web和移动应用测试自动化平台 | 商业
    | TestProject团队 | [*https://testproject.io*](https://testproject.io) |'
- en: Browser Infrastructure
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 浏览器基础设施
- en: We can use Selenium WebDriver to control local browsers installed in the machine
    running the WebDriver script. Also, Selenium WebDriver can drive remote web browsers
    (i.e., those executed in other hosts). In this case, we can use Selenium Grid
    to support the remote browser infrastructure. Nevertheless, this infrastructure
    can be challenging to create and maintain.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Selenium WebDriver来控制安装在运行WebDriver脚本的机器上的本地浏览器。此外，Selenium WebDriver还可以驱动远程Web浏览器（即在其他主机上执行的浏览器）。在这种情况下，我们可以使用Selenium
    Grid来支持远程浏览器基础设施。然而，这种基础设施的创建和维护可能具有挑战性。
- en: Alternatively, we can use a *cloud provider* to outsource the responsibility
    for supporting the browser infrastructure. In the Selenium ecosystem, a cloud
    provider is a company or product that supplies managed services for automated
    testing. These companies typically offer commercial solutions for web and mobile
    testing. The users of a cloud provider request on-demand browsers of different
    types, versions, and operating systems. Also, these providers typically offer
    additional services for easing the testing and monitoring activities, such as
    access to session recordings or analysis capabilities, to name a few. Some of
    the most relevant cloud providers for Selenium nowadays are [Sauce Labs](https://saucelabs.com),
    [BrowserStack](https://www.browserstack.com), [LambdaTest](https://www.lambdatest.com),
    [CrossBrowserTesting](https://crossbrowsertesting.com), [Moon Cloud](https://aerokube.com/moon-cloud),
    [TestingBot](https://testingbot.com), [Perfecto](https://www.perfecto.io), or
    [Testinium](https://testinium.com).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用 *云服务提供商* 来外包支持浏览器基础设施的责任。在 Selenium 生态系统中，云服务提供商是为自动化测试提供托管服务的公司或产品。这些公司通常为
    Web 和移动测试提供商业解决方案。云服务提供商的用户可以请求各种类型、版本和操作系统的按需浏览器。此外，这些提供商通常还提供其他服务，以简化测试和监控活动，例如访问会话录像或分析能力等。目前
    Selenium 最相关的云服务提供商包括 [Sauce Labs](https://saucelabs.com)、[BrowserStack](https://www.browserstack.com)、[LambdaTest](https://www.lambdatest.com)、[CrossBrowserTesting](https://crossbrowsertesting.com)、[Moon
    Cloud](https://aerokube.com/moon-cloud)、[TestingBot](https://testingbot.com)、[Perfecto](https://www.perfecto.io)
    和 [Testinium](https://testinium.com)。
- en: 'Another solution we can use to support the browser infrastructure for Selenium
    is [*Docker*](https://www.docker.com). Docker is an open source software technology
    that allows users to pack and run applications as lightweight, portable containers.
    The Docker platform has two main components: the *Docker Engine*, a tool for creating
    and running containers, and the [*Docker Hub*](https://hub.docker.com), a cloud
    service for distributing Docker images. In the Selenium domain, we can use Docker
    to pack and execute containerized browsers. [Table 1-6](#docker) presents a summary
    of relevant projects using Docker in the Selenium ecosystem.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个我们可以使用来支持 Selenium 浏览器基础设施的解决方案是 [*Docker*](https://www.docker.com)。Docker
    是一种开源软件技术，允许用户将应用程序打包和运行为轻量级、可移植的容器。Docker 平台有两个主要组件：*Docker 引擎*，用于创建和运行容器，以及
    [*Docker Hub*](https://hub.docker.com)，用于分发 Docker 镜像的云服务。在 Selenium 领域，我们可以使用
    Docker 来打包和执行容器化的浏览器。[表 1-6](#docker) 总结了在 Selenium 生态系统中使用 Docker 的相关项目。
- en: Table 1-6\. Docker resources for Selenium
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 表 1-6\. Selenium 的 Docker 资源
- en: '| Name | Description | License | Maintainer | Website |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 | 许可证 | 维护者 | 网站 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| docker-selenium | Official Docker images for Selenium Grid | Apache 2.0 |
    Selenium project | [*https://github.com/seleniumhq/docker-selenium*](https://github.com/seleniumhq/docker-selenium)
    |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| docker-selenium | Selenium Grid 的官方 Docker 镜像 | Apache 2.0 | Selenium 项目
    | [*https://github.com/seleniumhq/docker-selenium*](https://github.com/seleniumhq/docker-selenium)
    |'
- en: '| Selenoid | Lightweight Golang implementation of Selenium Hub running browsers
    in Docker (images available on Docker Hub) | Apache 2.0 | Aerokube | [*https://aerokube.com/selenoid*](https://aerokube.com/selenoid)
    |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| Selenoid | 用 Go 语言轻量级实现的 Selenium Hub，在 Docker 中运行浏览器（镜像可在 Docker Hub 上找到）
    | Apache 2.0 | Aerokube | [*https://aerokube.com/selenoid*](https://aerokube.com/selenoid)
    |'
- en: '| Moon | Enterprise Selenium cluster that use Docker and Kubernetes | Commercial
    | Aerokube | [*https://aerokube.com/moon*](https://aerokube.com/moon) |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| Moon | 使用 Docker 和 Kubernetes 的企业级 Selenium 集群 | 商业 | Aerokube | [*https://aerokube.com/moon*](https://aerokube.com/moon)
    |'
- en: '| Callisto | Open source Kubernetes-native implementation of Selenium Grid
    | MIT | Aerokube | [*https://github.com/wrike/callisto*](https://github.com/wrike/callisto)
    |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| Callisto | 开源的 Kubernetes 本地实现的 Selenium Grid | MIT | Aerokube | [*https://github.com/wrike/callisto*](https://github.com/wrike/callisto)
    |'
- en: Community
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 社区
- en: 'Due to its collaborative nature, software development needs the organization
    and interaction of many participants. In the open source domain, we can measure
    the success of a project by the relevance of its community. Selenium is supported
    by a large community of many different participants worldwide. [Table 1-7](#community)
    presents a summary of several Selenium resources grouped into the following categories:
    official documentation, development, support, and events.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 由于软件开发的协作性质，需要许多参与者的组织和互动。在开源领域，我们可以通过社区的相关性来衡量项目的成功。Selenium得到了全球许多不同参与者的大力支持。[表1-7](#community)
    总结了几个分组资源，包括官方文档、开发、支持和活动。
- en: Table 1-7\. Selenium community resources
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 表1-7\. Selenium 社区资源
- en: '| Category | Description | Website |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| 类别 | 描述 | 网站 |'
- en: '| --- | --- | --- |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Official documentation | User guide | [*https://www.selenium.dev/documentation*](https://www.selenium.dev/documentation)
    |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| 官方文档 | 用户指南 | [*https://www.selenium.dev/documentation*](https://www.selenium.dev/documentation)
    |'
- en: '| Blog | [*https://www.selenium.dev/blog*](https://www.selenium.dev/blog) |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| 博客 | [*https://www.selenium.dev/blog*](https://www.selenium.dev/blog) |'
- en: '| Wiki | [*https://github.com/seleniumhq/selenium/wiki*](https://github.com/seleniumhq/selenium/wiki)
    |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| Wiki | [*https://github.com/seleniumhq/selenium/wiki*](https://github.com/seleniumhq/selenium/wiki)
    |'
- en: '| Ecosystem | [*https://www.selenium.dev/ecosystem*](https://www.selenium.dev/ecosystem)
    |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| 生态系统 | [*https://www.selenium.dev/ecosystem*](https://www.selenium.dev/ecosystem)
    |'
- en: '| Development | Source code | [*https://github.com/seleniumhq/selenium*](https://github.com/seleniumhq/selenium)
    |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| 开发 | 源代码 | [*https://github.com/seleniumhq/selenium*](https://github.com/seleniumhq/selenium)
    |'
- en: '| Issues | [*https://github.com/seleniumhq/selenium/issues*](https://github.com/seleniumhq/selenium/issues)
    |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| 问题 | [*https://github.com/seleniumhq/selenium/issues*](https://github.com/seleniumhq/selenium/issues)
    |'
- en: '| Governance | [*https://www.selenium.dev/project*](https://www.selenium.dev/project)
    |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| 治理 | [*https://www.selenium.dev/project*](https://www.selenium.dev/project)
    |'
- en: '| Support | User group | [*https://groups.google.com/group/selenium-users*](https://groups.google.com/group/selenium-users)
    |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| 支持 | 用户组 | [*https://groups.google.com/group/selenium-users*](https://groups.google.com/group/selenium-users)
    |'
- en: '| Slack | [*https://seleniumhq.slack.com*](https://seleniumhq.slack.com) |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| Slack | [*https://seleniumhq.slack.com*](https://seleniumhq.slack.com) |'
- en: '| IRC | [*https://webchat.freenode.net/#selenium*](https://webchat.freenode.net/#selenium)
    |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| IRC | [*https://webchat.freenode.net/#selenium*](https://webchat.freenode.net/#selenium)
    |'
- en: '| StackOverflow | [*https://stackoverflow.com/questions/tagged/selenium*](https://stackoverflow.com/questions/tagged/selenium)
    |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| StackOverflow | [*https://stackoverflow.com/questions/tagged/selenium*](https://stackoverflow.com/questions/tagged/selenium)
    |'
- en: '| Reddit | [*https://www.reddit.com/r/selenium*](https://www.reddit.com/r/selenium)
    |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| Reddit | [*https://www.reddit.com/r/selenium*](https://www.reddit.com/r/selenium)
    |'
- en: '| Events | Conference | [*https://www.selenium.dev/categories/conference*](https://www.selenium.dev/categories/conference)
    |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| 活动 | 会议 | [*https://www.selenium.dev/categories/conference*](https://www.selenium.dev/categories/conference)
    |'
- en: '| Meetups | [*https://www.meetup.com/topics/selenium*](https://www.meetup.com/topics/selenium)
    |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| Meetups | [*https://www.meetup.com/topics/selenium*](https://www.meetup.com/topics/selenium)
    |'
- en: Software Testing Fundamentals
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件测试基础
- en: Software testing (or simply *testing*) consists of the dynamic evaluation of
    a piece of software, called *System Under Test* (SUT), through a finite set of
    test cases (or simply *tests*), giving a verdict about it. Testing implies the
    execution of SUT using specific input values to assess the outcome or expected
    behavior.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 软件测试（或简称*测试*）包括对称为*被测系统*（SUT）的软件的动态评估，通过一组有限的测试用例（或简称*测试*）对其进行评估，并对其做出裁决。测试意味着使用特定的输入值执行
    SUT，以评估结果或期望行为。
- en: 'At first glance, we distinguish two separate categories of software testing:
    manual and automated. On the one hand, in *manual testing*, a person (typically
    a software engineer or the final user) evaluates the SUT. On the other hand, in
    *automated testing*, we use specific software tools to develop tests and control
    their execution against the SUT. Automated tests allow the early detection of
    defects (usually called *bugs*) in the SUT while providing a large number of additional
    benefits (e.g., cost savings, fast feedback, test coverage, or reusability, to
    name a few). Manual testing can also be a valuable approach in some cases, for
    example, in *exploratory testing* (i.e., human testers freely investigate and
    evaluate the SUT).'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，我们可以区分软件测试的两个单独类别：手动和自动化。一方面，在*手动测试*中，一个人（通常是软件工程师或最终用户）评估 SUT。另一方面，在*自动化测试*中，我们使用特定的软件工具开发测试并控制它们对
    SUT 的执行。自动化测试允许在 SUT 中早期检测缺陷（通常称为*错误*），同时提供大量额外的好处（例如成本节省、快速反馈、测试覆盖率或可重复使用性等）。在某些情况下，手动测试也可以是一种有价值的方法，例如*探索性测试*（即人工测试人员自由地调查和评估
    SUT）。
- en: Note
  id: totrans-151
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: There is no universal classification for the numerous forms of testing presented
    in this section. These concepts are subject to continuous evolution and debate,
    just like software engineering. Consider it a proposal that can fit into a large
    number of projects.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 此部分提供的众多测试形式没有统一的分类标准。这些概念正如软件工程一样，处于持续演变和辩论之中。可以将其视为适用于大量项目的提议。
- en: Levels of Testing
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试级别
- en: Depending on the size of the SUT, we can define different *levels of testing*.
    These levels define several categories in which software teams divide their testing
    efforts. In this book, I propose a stacked layout to represent the different levels
    (see [Figure 1-5](#testing-levels-stack)). The lower levels of this structure
    represent the tests aimed at verifying small pieces of software (called *units*).
    As we ascend in the stack, we find other tiers (e.g., *integration*, *system*,
    etc.) in which the SUT integrates more and more components.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 SUT 的规模不同，我们可以定义不同的*测试级别*。这些级别确定了软件团队在测试工作中划分的几个类别。在本书中，我提出使用堆叠布局来表示不同的级别（见[图 1-5](#testing-levels-stack)）。这个结构的较低级别代表了用于验证软件小片段（称为*单元*）的测试。随着堆栈的上升，我们在其中找到其他层级（例如*集成*、*系统*等），其中
    SUT 集成了越来越多的组件。
- en: '![hosw 0105](assets/hosw_0105.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![hosw 0105](assets/hosw_0105.png)'
- en: Figure 1-5\. Stack representation of the different levels of testing
  id: totrans-156
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1-5\. 不同测试级别的堆栈表示
- en: The lowest level of this stack is *unit testing*. At this level, we assess individual
    units of software. A unit is a particular observable element of behavior. For
    instance, units are typically methods or classes in object-oriented programming
    and functions in functional programming. Unit testing aims to verify that each
    unit behaves as expected. Automated unit tests usually run very fast since each
    test executes a small amount of code in isolation. To achieve this isolation,
    we can use *test doubles*, pieces of software that replace the dependent components
    of a given unit. For example, a popular type of test double in object-oriented
    programming is the *mock object*. A mock object mimics an actual object using
    some programmed behavior.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 此堆栈的最低级别是*单元测试*。在这个级别，我们评估软件的各个单元。一个单元是特定的可观察行为元素。例如，单元通常是面向对象编程中的方法或类，以及函数式编程中的函数。单元测试旨在验证每个单元的预期行为。由于每个测试在隔离环境中执行少量代码，自动化单元测试通常运行非常快速。为了实现这种隔离，我们可以使用*测试替身*，即替换给定单元的依赖组件的软件片段。例如，在面向对象编程中，一种流行的测试替身类型是*模拟对象*。模拟对象使用一些程序化的行为来模仿实际对象。
- en: The next level in [Figure 1-5](#testing-levels-stack) is *integration testing*.
    At this level, different units are composed to create composite components. Integration
    testing aims to assess the interaction between the involved units and expose defects
    in their interfaces.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 1-5](#testing-levels-stack)中的下一个级别是*集成测试*。在这个级别，不同的单元组合在一起以创建复合组件。集成测试旨在评估涉及单元之间的交互并暴露其接口中的缺陷。'
- en: Then, at the *system testing* and *end-to-end* (E2E) levels, we test the software
    system as a whole. We need to deploy the SUT and verify its high-level features
    to carry out these levels. The difference between system/end-to-end and integration
    testing is that the former involves all the system components and the final user
    (typically impersonated). In other words, system and end-to-end testing assess
    the SUT through the User Interface (UI). This UI can be graphical (GUI) or nongraphical
    (e.g., text-based or other types).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在*系统测试*和*端到端*（E2E）级别，我们测试整个软件系统。我们需要部署系统测试对象（SUT）并验证其高级功能来执行这些级别的测试。系统/端到端测试与集成测试的区别在于前者涉及所有系统组件和最终用户（通常是模拟的）。换句话说，系统和端到端测试通过用户界面（UI）评估SUT。该UI可以是图形化的（GUI）或非图形化的（例如基于文本或其他类型）。
- en: '[Figure 1-6](#testing-levels-components) illustrates the difference between
    system and end-to-end testing. As you can see, on the one hand, end-to-end testing
    involves the software system and its dependent subsystems (e.g., database or external
    services). On the other hand, system testing comprises only the software system,
    and these external dependencies are typically mocked.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 1-6](#testing-levels-components)展示了系统测试与端到端测试之间的区别。如您所见，端到端测试涉及软件系统及其依赖子系统（例如数据库或外部服务）。而系统测试仅包括软件系统，这些外部依赖通常是模拟的。'
- en: '![hosw 0106](assets/hosw_0106.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![hosw 0106](assets/hosw_0106.png)'
- en: Figure 1-6\. Component-based representation of the different levels of testing
  id: totrans-162
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1-6\. 测试不同级别的基于组件的表示
- en: '*Acceptance testing* is the top tier of the presented stack. At this level,
    the final user participates in the testing process. The objective of acceptance
    testing is to decide whether the software system meets end-user expectations.
    As you can see in [Figure 1-6](#testing-levels-components), like end-to-end testing,
    acceptance testing validates the whole system and its dependencies. Therefore,
    acceptance tests also use the UI to carry out the SUT validation.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '*验收测试*是所呈现堆栈的顶层。在这个级别，最终用户参与测试过程。验收测试的目标是决定软件系统是否符合最终用户的期望。如图 1-6所示，与端到端测试类似，验收测试验证整个系统及其依赖项。因此，验收测试也使用UI来执行SUT验证。'
- en: Tip
  id: totrans-164
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: The primary purpose of Selenium WebDriver is to implement end-to-end tests.
    Nevertheless, we can use WebDriver to carry out system testing when mocking the
    backend calls made by the website under test. Moreover, we can use Selenium WebDriver
    in conjunction with a Behavior-Driven Development (BDD) tool to implement acceptance
    tests (see [Chapter 9](ch09.html#ch09)).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Selenium WebDriver的主要目的是实施端到端测试。尽管如此，我们可以使用WebDriver来进行系统测试，当模拟网站调用的后端时。此外，我们可以将Selenium
    WebDriver与行为驱动开发（BDD）工具结合使用，以实施验收测试（请参阅[第9章](ch09.html#ch09)）。
- en: Types of Testing
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试类型
- en: 'Depending on the strategy for designing test cases, we can implement different
    types of tests. The two principal types of testing are:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 根据设计测试用例的策略，我们可以实施不同类型的测试。两种主要的测试类型是：
- en: '*Functional testing* (also known as behavioral or *closed-box testing*)'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '*功能测试*（也称为行为或*闭箱测试*）'
- en: Evaluates the compliance of a piece of software with the expected behavior (i.e.,
    its functional requirements).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 评估软件片段是否符合预期行为（即其功能需求）。
- en: '*Structural testing* (also known as *clear-box testing*)'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '*结构测试*（也称为*透明箱测试*）'
- en: Determines if the program-code structure is faulty. To that aim, testers should
    know the internal logic of a piece of software.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 确定程序代码结构是否存在错误。为此，测试人员应了解软件片段的内部逻辑。
- en: The difference between these testing types is that functional tests are responsibility-based,
    while structural tests are implementation-based. Both types can be performed at
    any test level (unit, integration, system, end-to-end, or acceptance). Nevertheless,
    structural tests are commonly done at the unit or integration level since these
    levels enable more direct control of the code execution flow.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试类型的区别在于，功能测试是基于责任的，而结构测试是基于实现的。这两种类型可以在任何测试级别（单元、集成、系统、端到端或验收）进行。然而，结构测试通常在单元或集成级别进行，因为这些级别能够更直接地控制代码执行流程。
- en: Warning
  id: totrans-173
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: '*Black-box* and *white-box* testing are other names for functional and structural
    testing, respectively. Nevertheless, these designations are not recommended since
    the tech industry is trying to adopt more inclusive terms and use neutral terminology
    instead of potentially harmful language.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '*黑盒测试*和*白盒测试*分别是功能测试和结构测试的另外两个名称。然而，由于科技行业正努力采用更具包容性的术语，而非潜在有害的语言，因此不推荐使用这些称号。'
- en: 'There are different flavors of functional testing. For example:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 功能测试有不同的类型。例如：
- en: '*UI testing* (known as *GUI testing* when the UI is graphical)'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '*UI测试*（当UI是图形界面时称为*GUI测试*）'
- en: Evaluates if the visual elements of an application meet the expected functionality.
    Note that UI testing is different from the system and end-to-end testing levels
    since the former tests the interface itself, and the latter evaluates the whole
    system through the UI.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 评估应用的视觉元素是否符合预期功能。请注意，UI测试与系统和端到端测试级别不同，因为前者测试界面本身，而后者通过UI评估整个系统。
- en: '*Negative testing*'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '*负面测试*'
- en: Evaluates the SUT under unexpected conditions (e.g., expected exceptions). This
    term is the counterpart of the regular functional testing (sometimes called *positive
    testing*), in which we assess if the SUT behaves as expected (i.e., its *happy
    path*).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在意外条件下评估SUT（例如预期异常）。此术语是常规功能测试（有时称为*正面测试*）的对应项，其中我们评估SUT是否按预期行为（即其*快乐路径*）。
- en: '*Cross-browser testing*'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '*跨浏览器测试*'
- en: This is specific for web applications. It aims to verify the compatibility of
    websites and applications in different web browsers (types, versions, or operating
    systems).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这是针对Web应用的。它旨在验证不同Web浏览器（类型、版本或操作系统）中的网站和应用的兼容性。
- en: 'A third miscellaneous testing type, *nonfunctional testing*, includes testing
    strategies that assess the quality attributes of a software system (i.e., its
    nonfunctional requirements). Common methods of nonfunctional testing include,
    but are not limited to:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种杂项测试类型，*非功能测试*，包括评估软件系统的质量属性（即其非功能需求）的测试策略。非功能测试的常见方法包括但不限于：
- en: '*Performance testing*'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '*性能测试*'
- en: 'Assesses different metrics of software systems, such as response time, stability,
    reliability, or scalability. The objective of performance testing is not finding
    bugs but finding system bottlenecks. There are two common subtypes of performance
    testing:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 评估软件系统的不同指标，例如响应时间、稳定性、可靠性或可扩展性。性能测试的目标不是查找错误，而是查找系统瓶颈。性能测试有两种常见的子类型：
- en: '*Load testing*'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '*负载测试*'
- en: Increases the usage on the system by simulating multiple concurrent users to
    verify if it can operate in the defined boundaries.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 通过模拟多个并发用户增加系统的使用量，以验证其是否可以在定义的边界内运行。
- en: '*Stress testing*'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '*压力测试*'
- en: Exercises a system beyond its operational capacity to identify the actual limits
    at which the system breaks.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 超越系统的操作能力来进行系统练习，以确定系统崩溃的实际极限。
- en: '*Security testing*'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '*安全测试*'
- en: Tries to evaluate security concerns, such as confidentiality (disclosure of
    information protection), authentication (ensuring the user identity), or authorization
    (determining user rights and privileges), among others.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 试图评估安全性关注点，例如机密性（信息保护披露）、认证（确保用户身份）或授权（确定用户权利和特权）等。
- en: '*Usability testing*'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '*可用性测试*'
- en: 'Evaluates how user-friendly a software application is. This assessment is also
    called User eXperience (UX) testing. A subtype of usability testing is:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 评估软件应用的用户友好程度。这种评估也称为用户体验（UX）测试。可用性测试的一个子类型是：
- en: '*A/B testing*'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '*A/B测试*'
- en: Compares different variations of the same application to determine which one
    is more effective for its end users.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 比较同一应用的不同变体，以确定哪一个对其最终用户更有效。
- en: '*Accessibility testing*'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '*可访问性测试*'
- en: Evaluates if a system is usable by people with disabilities.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 评估系统是否可供残障人士使用。
- en: Tip
  id: totrans-197
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: We use Selenium WebDriver primarily to implement functional tests (i.e., interacting
    with a web application UI to assess the application behavior). It is unlikely
    to use WebDriver to implement structural tests. In addition, although it is not
    its principal usage, we can use WebDriver to implement nonfunctional tests, e.g.,
    for load, security, accessibility, or localization (assessment of specific locale
    settings) testing (see [Chapter 9](ch09.html#ch09)).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Testing Methodologies
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The *software development lifecycle* is the set of activities, actions, and
    tasks required to create software systems in software engineering. The moment
    at which software engineers design and implement test cases in the overall development
    lifecycle depends on the specific development process (such as iterative, waterfall,
    or agile, to name a few). Two of the most relevant testing methodologies are:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Test Driven Development (TDD)
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: TDD is a methodology in which we design and implement tests before the actual
    software design and implementation. At the beginning of the 21st century, TDD
    became popular with the rise of *agile* software development methodologies, such
    as Extreme Programming (XP). In TDD, a developer first writes an (initially failing)
    automated test for a given feature. Then, the developer creates a piece of code
    to pass that test. Finally, the developer refactors the code to achieve or improve
    readability and maintainability.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Test Last Development (TLD)
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: TLD is a methodology in which we design and implement tests after implementing
    the SUT. This practice is typical in traditional software development processes,
    such as waterfall (sequential), incremental (multi-waterfall), spiral (risk-oriented
    multi-waterfall), or Rational Unified Process (RUP).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'Another relevant testing methodology is *Behavior-Driven Development* (BDD).
    BDD is a testing practice derived from TDD, and consequently, we design tests
    at the early stages of the software development lifecycle in BDD. To that aim,
    conversations occur between the final user and the development team (typically
    with the project leader, manager, or analysts). These conversations formalize
    a common understanding of the desired behavior and the software system. As a result,
    we create acceptance tests in terms of one or more *scenarios* following a *Given-When-Then*
    structure:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Given
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Initial context at the beginning of the scenario
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: When
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Event that triggers the scenario
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Then
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Expected outcome
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-212
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: TLD is a common practice used to implement Selenium WebDriver. In other words,
    developers/testers do not implement a WebDriver test until the SUT is available.
    Nevertheless, different methodologies are also possible. For instance, BDD is
    a common approach when using WebDriver with Cucumber (see [Chapter 9](ch09.html#ch09)).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Closely related to the domain of testing methodologies, we find the concept
    of *Continuous Integration* (CI). CI is a software development practice where
    members of a software project build, test, and integrate their work continuously.
    Grady Booch first coined the term CI in 1991\. Now it is a popular strategy to
    create software.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: As [Figure 1-7](#ci-process) shows, CI has three separate stages. First, we
    use a *source code repository*, a hosting facility to store and share the source
    code of a software project. We typically use a *version control system* (VCS)
    to manage this repository. A VCS is a tool that keeps track of the source code,
    who made each change, and when (sometimes called *patch*).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '![hosw 0107](assets/hosw_0107.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
- en: Figure 1-7\. CI generic process
  id: totrans-217
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '*Git*, initially developed by Linus Torvalds, is the preferred VCS today. Other
    alternatives are a *concurrent versions system* (CVS) or Subversion (SVN). On
    top of Git, several *code hosting platforms* (such as GitHub, GitLab, or Bitbucket)
    provide collaborative cloud repository hosting services for developing, sharing,
    and maintaining software.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Developers synchronize a local repository (or simply, *repo*) copy in their
    local environments. Then, they do the coding work using that local copy, committing
    new changes to the remote repository (typically daily). The basic idea of CI is
    that every commit triggers the build and test of the software with the new changes.
    The test suite executed to assess that a patch does not break the build is called
    a *regression test*. A regression suite can contain tests of different types,
    including unit, integration, end-to-end, etc.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: When the number of tests is too large for regression testing, we typically choose
    only a part of the relevant tests from the whole suite. There are different strategies
    to select these tests, for instance, *smoke testing* (i.e., tests that ensure
    the critical functionality) or *sanity testing* (i.e., tests that evaluate the
    basic functionality). Lastly, we can execute the complete suite as a scheduled
    task (typically nightly).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: We need to use a server-side infrastructure called a *build server* to implement
    a CI pipeline. The build server usually reports a problem to the original developer
    when the regression tests fail. [Table 1-8](#build_servers) provides a summary
    of several build servers.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Table 1-8\. Build servers
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description | License | Maintainer | Website |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
- en: '| Bamboo | Easy use with Jira (issue tracker) and Bitbucket | Commercial |
    Atlassian | [*https://www.atlassian.com/software/bamboo*](https://www.atlassian.com/software/bamboo)
    |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
- en: '| GitHub Actions | Integrated build server in GitHub | Free for public repositories
    | Microsoft | [*https://github.com/features/actions*](https://github.com/features/actions)
    |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
- en: '| GitLab CI/CD | Integrated build server in GitLab | Free for public repositories
    | GitLab | [*https://docs.gitlab.com/ee/ci*](https://docs.gitlab.com/ee/ci) |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
- en: '| Jenkins | Open source automation server | MIT | Jenkins team | [*https://www.jenkins.io*](https://www.jenkins.io)
    |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| Jenkins | 开源自动化服务器 | MIT | Jenkins团队 | [*https://www.jenkins.io*](https://www.jenkins.io)
    |'
- en: Tip
  id: totrans-229
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: I use a GitHub repository ([*https://github.com/bonigarcia/selenium-webdriver-java*](https://github.com/bonigarcia/selenium-webdriver-java))
    to publish and maintain the test examples presented in this book. GitHub Actions
    is the build server for this repo (see [Chapter 2](ch02.html#ch02)).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用一个GitHub存储库（[*https://github.com/bonigarcia/selenium-webdriver-java*](https://github.com/bonigarcia/selenium-webdriver-java)）来发布和维护本书中提供的测试示例。GitHub
    Actions是此存储库的构建服务器（见[第2章](ch02.html#ch02)）。
- en: 'We can extend a typical CI pipeline in two ways (see [Figure 1-8](#ci-cds)):'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过两种方式扩展典型的CI流水线（见[图 1-8](#ci-cds)）：
- en: Continuous Delivery (CD)
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 持续交付（CD）
- en: After CI, the build server deploys the release to a staging environment (i.e.,
    a replica of a production environment for testing purposes) and executes the automated
    acceptance tests (if any).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在CI之后，构建服务器将发布版本部署到一个暂存环境（即用于测试目的的生产环境副本），并执行自动化验收测试（如果有）。
- en: Continuous Deployment
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 持续部署
- en: The build server deploys the software release to the production environment
    as the final step.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 构建服务器将软件发布到生产环境作为最后一步。
- en: '![hosw 0108](assets/hosw_0108.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![hosw 0108](assets/hosw_0108.png)'
- en: Figure 1-8\. Continuous Integration, Delivery, and Deployment pipeline
  id: totrans-237
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1-8\. 持续集成、交付和部署流水线
- en: Close to CI, the term DevOps (development and operations) has gained momentum.
    DevOps is a software methodology that promotes communication and collaboration
    between different teams in a software project to develop and deliver software
    efficiently. These teams include developers, testers, QA (quality assurance),
    operations (infrastructure), etc.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 靠近CI，术语DevOps（开发与运维）已经获得了推广。DevOps是一种软件方法论，促进了软件项目中不同团队（包括开发者、测试人员、质量保证、运维等）之间的沟通和协作，以高效开发和交付软件。
- en: Test Automation Tools
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试自动化工具
- en: We need to use some tooling to implement, execute, and control automated tests
    effectively. One of the most relevant categories for testing tools is the *unit
    testing framework*. The original framework in the unit testing family (also known
    as *xUnit*) is SmalltalkUnit (or SUnit). SUnit is a unit test framework for the
    Smalltalk language created by Kent Beck in 1999\. Erich Gamma ported SUnit to
    Java, creating JUnit. Since then, JUnit has been very popular, inspiring other
    unit testing frameworks. [Table 1-9](#xunit) summarizes the most relevant unit
    testing frameworks in different languages.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要使用一些工具来有效地实施、执行和控制自动化测试。其中最相关的测试工具类别之一是*单元测试框架*。单元测试家族的原始框架（也称为*xUnit*）是SmalltalkUnit（或SUnit）。SUnit是由Kent
    Beck于1999年为Smalltalk语言创建的单元测试框架。Erich Gamma将SUnit移植到Java，创建了JUnit。从那时起，JUnit变得非常流行，激发了其他单元测试框架的开发。[表 1-9](#xunit)总结了不同语言中最相关的单元测试框架。
- en: Table 1-9\. Unit testing frameworks
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 表 1-9\. 单元测试框架
- en: '| Name | Language | Description | License | Maintainer | Website |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 语言 | 描述 | 许可证 | 维护者 | 网站 |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| JUnit | Java | Reference implementation of xUnit family | EPL | JUnit team
    | [*https://junit.org*](https://junit.org) |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| JUnit | Java | xUnit家族的参考实现 | EPL | JUnit团队 | [*https://junit.org*](https://junit.org)
    |'
- en: '| TestNG | Java | Inspired by JUnit and NUnit, including extra features | Apache
    2.0 | Cedric Beust | [*https://testng.org*](https://testng.org) |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| TestNG | Java | 受JUnit和NUnit启发，包括额外功能 | Apache 2.0 | Cedric Beust | [*https://testng.org*](https://testng.org)
    |'
- en: '| Mocha | JavaScript | Test framework for Node.js and the browser | MIT | OpenJS
    Foundation | [*https://mochajs.org*](https://mochajs.org) |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| Mocha | JavaScript | 用于Node.js和浏览器的测试框架 | MIT | OpenJS Foundation | [*https://mochajs.org*](https://mochajs.org)
    |'
- en: '| Jest | JavaScript | Focused on simplicity with a focus on web applications
    | MIT | Facebiij | [*https://jestjs.io*](https://jestjs.io) |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| Jest | JavaScript | 着重于Web应用程序的简易性 | MIT | Facebiij | [*https://jestjs.io*](https://jestjs.io)
    |'
- en: '| Karma | JavaScript | Allows you to execute JavaScript tests in web browsers
    | MIT | Karma team | [*https://karma-runner.github.io*](https://karma-runner.github.io)
    |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| Karma | JavaScript | 允许在Web浏览器中执行JavaScript测试 | MIT | Karma团队 | [*https://karma-runner.github.io*](https://karma-runner.github.io)
    |'
- en: '| NUnit | .Net | Unit testing framework for all .Net languages (C#, Visual
    Basic, and F#) | MIT | .NET Foundation | [*https://nunit.org*](https://nunit.org)
    |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| NUnit | .Net | 适用于所有.Net语言（C#、Visual Basic和F#）的单元测试框架 | MIT | .NET Foundation
    | [*https://nunit.org*](https://nunit.org) |'
- en: '| unittest | Python | Unit testing framework included as a standard library
    as of Python 2.1 | PSF License | Python Software Foundation | [*https://docs.python.org/library/unittest.html*](https://docs.python.org/library/unittest.html)
    |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| unittest | Python | Python 2.1 起作为标准库包含的单元测试框架 | PSF 许可证 | Python 软件基金会 |
    [*https://docs.python.org/library/unittest.html*](https://docs.python.org/library/unittest.html)
    |'
- en: '| minitest | Ruby | Complete suite of testing utilities for Ruby | MIT | Seattle
    Ruby Brigade | [*https://github.com/settlers/minitest*](https://github.com/settlers/minitest)
    |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| minitest | Ruby | Ruby 的完整测试工具套件 | MIT | Seattle Ruby Brigade | [*https://github.com/settlers/minitest*](https://github.com/settlers/minitest)
    |'
- en: 'An important common characteristic of the xUnit family is the test structure,
    composed of four phases (see [Figure 1-9](#unit-test-structure)):'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: xUnit 家族的一个重要共同特征是测试结构，由四个阶段组成（见 [图 1-9](#unit-test-structure)）：
- en: Setup
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 设置
- en: The test case initializes the SUT to exhibit the expected behavior.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 测试用例初始化 SUT 以展示预期行为。
- en: Exercise
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 练习
- en: The test case interacts with the SUT. As a result, the test gets an outcome
    from the SUT.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 测试用例与 SUT 交互。因此，测试从 SUT 获取结果。
- en: Verify
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 验证
- en: The test case decides if the obtained outcome from the SUT is as expected. To
    that aim, the test contains one or more assertions. An *assertion* (or predicate)
    is a boolean-value function that checks if an expected condition is true. The
    execution of the assertions generates a test verdict (typically, pass or fail).
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 测试用例决定从 SUT 获取的结果是否符合预期。为此，测试包含一个或多个断言。*断言*（或谓词）是检查预期条件是否为真的布尔值函数。执行断言生成测试结论（通常是通过或失败）。
- en: Teardown
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 拆卸
- en: The test case puts the SUT back into the initial state.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 测试用例将 SUT 恢复到初始状态。
- en: '![hosw 0109](assets/hosw_0109.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![hosw 0109](assets/hosw_0109.png)'
- en: Figure 1-9\. Unit test generic structure
  id: totrans-262
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1-9\. 单元测试通用结构
- en: Tip
  id: totrans-263
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: We can use unit testing frameworks in conjunction with other libraries or utilities
    to implement any test type. For example, as explained in [Chapter 2](ch02.html#ch02),
    we use JUnit and TestNG to embed the call to the Selenium WebDriver API, implementing
    end-to-end tests for web applications.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以与其他库或实用工具结合使用单元测试框架来实现任何测试类型。例如，如 [第 2 章](ch02.html#ch02) 所述，我们使用 JUnit
    和 TestNG 嵌入调用 Selenium WebDriver API，为 Web 应用实现端到端测试。
- en: The stages of setup and teardown are optional in a unit test case. Although
    it is not strictly mandatory, verifying is highly recommended. Even if unit testing
    frameworks include capabilities to implement assertions, it is common to incorporate
    third-party *assertions libraries*. These libraries aim to improve the test code’s
    readability by providing a rich set of fluent assertions. In addition, these libraries
    offer enhanced error messages to help testers understand the cause of a failure.
    [Table 1-10](#assertions) contains a summary of some of the most relevant assertion
    libraries for Java.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 设置和拆卸阶段在单元测试用例中是可选的。虽然它不是严格强制的，但强烈建议进行验证。即使单元测试框架包括实现断言的能力，通常也会集成第三方 *断言库*。这些库旨在通过提供丰富的流畅断言集来改善测试代码的可读性。此外，这些库还提供增强的错误消息，帮助测试人员理解失败的原因。Java
    的一些最相关的断言库总结在 [表 1-10](#assertions) 中。
- en: Table 1-10\. Assertion libraries for Java
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 表 1-10\. Java 的断言库
- en: '| Name | Description | License | Maintainer | Website |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 | 许可证 | 维护者 | 网站 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| AssertJ | Fluent assertions Java library | Apache 2.0 | AssertJ team | [*https://assertj.github.io/doc*](https://assertj.github.io/doc)
    |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| AssertJ | Java 的流畅断言库 | Apache 2.0 | AssertJ 团队 | [*https://assertj.github.io/doc*](https://assertj.github.io/doc)
    |'
- en: '| Hamcrest | Java library of matchers aimed to create flexible assertions |
    BSD | Hamcrest team | [*http://hamcrest.org*](http://hamcrest.org) |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| Hamcrest | 创建灵活断言的 Java 匹配器库 | BSD | Hamcrest 团队 | [*http://hamcrest.org*](http://hamcrest.org)
    |'
- en: '| Truth | Fluent assertions for Java and Android | Apache 2.0 | Google | [*https://truth.dev*](https://truth.dev)
    |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| Truth | 用于 Java 和 Android 的流畅断言 | Apache 2.0 | Google | [*https://truth.dev*](https://truth.dev)
    |'
- en: As you can see in [Figure 1-9](#unit-test-structure), the SUT usually can query
    another component, named the *Depended-On Component* (DOC). In some cases (e.g.,
    at the unit or system testing level), we might want to isolate the SUT from the
    DOC(s). We can find a wide variety of mock libraries to achieve this isolation.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如图 1-9 所示（见 [图 1-9](#unit-test-structure)），SUT 通常可以查询另一个组件，称为 *依赖组件*（DOC）。在某些情况下（例如单元或系统测试级别），我们可能希望将
    SUT 与 DOC（们）隔离开来。我们可以找到各种模拟库来实现这种隔离。
- en: '[Table 1-11](#mocks) shows a comprehensive summary of some of these mock libraries
    for Java.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 1-11](#mocks) 显示了 Java 的一些模拟库的综合摘要。'
- en: Table 1-11\. Mock libraries for Java
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 表 1-11\. Java 的模拟库
- en: '| Name | Level | Description | License | Maintainer | Website |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 级别 | 描述 | 许可证 | 维护人员 | 网站 |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| EasyMock | Unit | It allows mocking objects for unit testing using Java annotations
    | Apache | EasyMock team | [*https://easymock.org*](https://easymock.org) |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| EasyMock | 单元 | 允许使用 Java 注释对对象进行单元测试的模拟对象 | Apache | EasyMock 团队 | [*https://easymock.org*](https://easymock.org)
    |'
- en: '| Mockito | Unit | Mocking Java library for mock creation and verification
    | MIT | Mockito team | [*https://site.mockito.org*](https://site.mockito.org)
    |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| Mockito | 单元 | 用于模拟创建和验证的 Java 模拟库 | MIT | Mockito 团队 | [*https://site.mockito.org*](https://site.mockito.org)
    |'
- en: '| JMockit | Integration | It allows out-of-container integration testing for
    Java EE and Spring-based apps | Open | JMockit team | [*https://jmockit.github.io*](https://jmockit.github.io)
    |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| JMockit | 集成 | 允许 Java EE 和基于 Spring 的应用进行容器外集成测试 | 开源 | JMockit 团队 | [*https://jmockit.github.io*](https://jmockit.github.io)
    |'
- en: '| MockServer | System | Mocking library for any system integrated via HTTP
    or HTTPS with Java clients | Apache 2.0 | James Bloom | [*https://www.mock-server.com*](https://www.mock-server.com)
    |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| MockServer | 系统 | 用于通过 HTTP 或 HTTPS 与 Java 客户端集成的任何系统的模拟库 | Apache 2.0 |
    James Bloom | [*https://www.mock-server.com*](https://www.mock-server.com) |'
- en: '| WireMock | System | Tool for simulating HTTP-based services | Apache 2.0
    | Tom Akehurst | [*https://wiremock.org*](https://wiremock.org) |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| WireMock | 系统 | 用于模拟基于 HTTP 的服务的工具 | Apache 2.0 | Tom Akehurst | [*https://wiremock.org*](https://wiremock.org)
    |'
- en: The last category of testing tools we analyze in this section is BDD, a development
    process that creates acceptance tests. There are plenty of alternatives to implement
    this approach. For instance, [Table 1-12](#bdd) shows a condensed summary of relevant
    BDD frameworks.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本节分析的最后一类测试工具是 BDD，这是一种创建验收测试的开发过程。实现这种方法有很多替代方案。例如，[表 1-12](#bdd) 显示了相关
    BDD 框架的简要摘要。
- en: Table 1-12\. BDD frameworks
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 表 1-12\. BDD 框架
- en: '| Name | Language | Description | License | Maintainer | Website |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 语言 | 描述 | 许可证 | 维护人员 | 网站 |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| Cucumber | Ruby, Java, JavaScript, Python | Testing framework to created
    automated acceptance tests following a BDD approach | MIT | SmartBear Software
    | [*https://cucumber.io*](https://cucumber.io) |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| Cucumber | Ruby, Java, JavaScript, Python | 用于创建遵循 BDD 方法的自动验收测试的测试框架 | MIT
    | SmartBear Software | [*https://cucumber.io*](https://cucumber.io) |'
- en: '| FitNesse | Java | Standalone collaborative wiki and acceptance testing framework
    | CPL | FitNesse team | [*http://fitnesse.org*](http://fitnesse.org) |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| FitNesse | Java | 独立的协作 wiki 和验收测试框架 | CPL | FitNesse 团队 | [*http://fitnesse.org*](http://fitnesse.org)
    |'
- en: '| JBehave | Java, Groovy, Kotlin, Ruby, Scala | BDD framework for all JVM languages
    | BSD-3-Clause | JBehave team | [*https://jbehave.org*](https://jbehave.org) |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| JBehave | Java, Groovy, Kotlin, Ruby, Scala | 适用于所有 JVM 语言的 BDD 框架 | BSD-3-Clause
    | JBehave 团队 | [*https://jbehave.org*](https://jbehave.org) |'
- en: '| Jasmine | JavaScript | BDD framework for JavaScript | MIT | Jasmine team
    | [*https://jasmine.github.io*](https://jasmine.github.io) |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| Jasmine | JavaScript | 用于 JavaScript 的 BDD 框架 | MIT | Jasmine 团队 | [*https://jasmine.github.io*](https://jasmine.github.io)
    |'
- en: '| Capybara | Ruby | Web-based acceptance test framework that simulates scenarios
    for user stories | MIT | Thomas Walpole | [*https://teamcapybara.github.io/capybara*](https://teamcapybara.github.io/capybara)
    |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| Capybara | Ruby | 模拟用户故事场景的基于 Web 的验收测试框架 | MIT | Thomas Walpole | [*https://teamcapybara.github.io/capybara*](https://teamcapybara.github.io/capybara)
    |'
- en: '| Serenity BDD | Java, Javascript | Automated acceptance testing library |
    Apache 2.0 | Serenity BDD team | [*https://serenity-bdd.info*](https://serenity-bdd.info)
    |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| Serenity BDD | Java, Javascript | 自动验收测试库 | Apache 2.0 | Serenity BDD 团队
    | [*https://serenity-bdd.info*](https://serenity-bdd.info) |'
- en: Summary and Outlook
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结与展望
- en: Selenium has come a long way since its inception in 2004\. Many practitioners
    consider it the de facto standard solution to develop end-to-end tests for web
    applications, and it is used by thousands of projects worldwide. In this chapter,
    you have seen the foundations of the Selenium project (made up of WebDriver, Grid,
    and IDE). In addition, Selenium has a rich ecosystem and active community. WebDriver
    is the heart of the Selenium project, and it is a library that provides an API
    to control different web browsers (e.g., Chrome, Firefox, Edge, etc.) programmatically.
    [Table 1-13](#summary) contains a comprehensive overview of the primary and secondary
    uses of Selenium WebDriver.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 自2004年起，Selenium已经发展了很长一段路程。许多从业者认为它是开发Web应用端到端测试的事实标准解决方案，并被全球数千个项目使用。在本章中，您已经看到了Selenium项目的基础（由WebDriver、Grid和IDE组成）。此外，Selenium拥有一个丰富的生态系统和活跃的社区。WebDriver是Selenium项目的核心，它是一个提供API以编程方式控制不同Web浏览器（例如Chrome、Firefox、Edge等）的库。[Table 1-13](#summary)
    包含了Selenium WebDriver的主要和次要用途的全面概述。
- en: Table 1-13\. Selenium WebDriver primary and secondary usages
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 表 1-13\. Selenium WebDriver 的主要和次要用途
- en: '|  | Primary | Secondary (other usages) |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
  zh: '|  | 主要 | 次要（其他用途） |'
- en: '| --- | --- | --- |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Purpose | Automated testing | Web scraping, web-based administration tasks
    |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
  zh: '| 目的 | 自动化测试 | Web页面抓取、基于Web的管理任务 |'
- en: '| Test level | End-to-end testing | System testing (mocking backend calls)
    Acceptance testing (e.g., using with Cucumber) |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
  zh: '| 测试级别 | 端到端测试 | 系统测试（模拟后端调用）验收测试（例如与Cucumber一起使用） |'
- en: '| Test type | Functional testing (ensuring expected behavior) Cross-browser
    testing (compatibility in different web browsers)'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '| 测试类型 | 功能测试（确保预期行为）跨浏览器测试（不同Web浏览器的兼容性） |'
- en: Regression testing (ensuring build after each commit in CI) | Nonfunctional
    testing (e.g., load, security, accessibility, or localization) |
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 回归测试（确保每次提交后的构建在CI中） | 非功能性测试（例如负载、安全性、可访问性或本地化） |
- en: '| Test methodology | TLD (implementing tests when SUT is available) | BDD (defining
    user scenarios at early development stages) |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '| 测试方法论 | TLD（在系统可用时实施测试） | BDD（在早期开发阶段定义用户场景） |'
- en: In the next chapter, you discover how to set up a Java project using Maven or
    Gradle as build tools. This project will contain end-to-end tests for web applications
    using JUnit and TestNG as the unit testing frameworks and calls to the Selenium
    WebDriver API. In addition, you will learn how to control different web browsers
    (e.g., Chrome, Firefox, or Edge) with a basic test case (the Selenium WebDriver’s
    version of the classic *hello world*).
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，您将了解如何使用Maven或Gradle作为构建工具设置Java项目。该项目将包含用于Web应用的端到端测试，使用JUnit和TestNG作为单元测试框架，并调用Selenium
    WebDriver API。此外，您将学习如何使用基本测试案例（Selenium WebDriver版本的经典*hello world*）来控制不同的Web浏览器（例如Chrome、Firefox或Edge）。
