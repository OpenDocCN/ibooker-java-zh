- en: Chapter 3\. Creating Your First Spring Boot REST API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, I explain and demonstrate how to develop a basic working application
    using Spring Boot. Since most applications involve exposing backend cloud resources
    to users, usually via a frontend UI, an Application Programming Interface (API)
    is an excellent starting point for both understanding and practicality. Let’s
    get started.
  prefs: []
  type: TYPE_NORMAL
- en: The Hows and Whys of APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The age of the monolithic application that does everything is over.
  prefs: []
  type: TYPE_NORMAL
- en: 'This isn’t to say that monoliths no longer exist or that they won’t still be
    created for ages to come. Under various circumstances, a monolithic application
    that provides numerous capabilities in one package still makes sense, especially
    in the following settings:'
  prefs: []
  type: TYPE_NORMAL
- en: The domain and thus domain boundaries are largely unknown.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provided capabilities are tightly coupled, and absolute performance of module
    interactions takes precedence over flexibility.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scaling requirements for all related capabilities are known and consistent.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functionality isn’t volatile; change is slow, limited in scope, or both.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For everything else, there are microservices.
  prefs: []
  type: TYPE_NORMAL
- en: This is a gross oversimplification, of course, but I believe it to be a useful
    summary. By splitting capabilities into smaller, cohesive “chunks,” we can decouple
    them, resulting in the potential for more flexible and robust systems that can
    be more rapidly deployed and more easily maintained.
  prefs: []
  type: TYPE_NORMAL
- en: 'In any distributed system—and make no mistake, a system comprising microservices
    is exactly that—communication is key. No service is an island. And while there
    are numerous mechanisms for connecting applications/microservices, we often begin
    our journey by emulating the very fabric of our daily lives: the internet.'
  prefs: []
  type: TYPE_NORMAL
- en: The internet was built for communication. In fact, the designers of its precursor,
    the Advanced Research Projects Agency Network (ARPANET), anticipated a need to
    maintain intersystem communication even in the event of “significant interruption.”
    It is reasonable to conclude that an HTTP-based approach similar to the one we
    use to conduct a great deal of our daily lives could also ably allow us to create,
    retrieve, update, and delete various resources “over the wire.”
  prefs: []
  type: TYPE_NORMAL
- en: As much as I love history, I won’t dive deeper into the history of REST APIs
    other than to say that Roy Fielding laid out their principles in his 2000 PhD
    dissertation, which built upon the *HTTP object model* from 1994.
  prefs: []
  type: TYPE_NORMAL
- en: What Is REST, and Why Does It Matter?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned earlier, an API is the specification/interface that we developers
    *write to* so our code can use other code: libraries, other applications, or services.
    But what does the *REST* in *REST API* represent?'
  prefs: []
  type: TYPE_NORMAL
- en: REST is an acronym for *representational state transfer*, which is a somewhat
    cryptic way of saying that when one application communicates with another, Application
    A brings its current state with it; it doesn’t expect Application B to maintain
    state— current and cumulative, process-based information—between communication
    calls. Application A supplies a representation of its relevant state with each
    request to Application B. You can easily see why this increases survivability
    and resilience, because if there is a communication issue or Application B crashes
    and is restarted, it doesn’t lose the current state of its interactions with Application
    A; Application A can simply reissue the request and pick up where the two applications
    left off.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This general concept is often referred to as *stateless* applications/services,
    because each service maintains its own current state, even within a sequence of
    interactions, and doesn’t expect others to do so on its behalf.
  prefs: []
  type: TYPE_NORMAL
- en: Your API, HTTP Verb Style
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, about that REST API—sometimes called a RESTful API, which is a nice, relaxing
    take on things, isn’t it?
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a number of standardized HTTP verbs defined within a handful of Internet
    Engineering Task Force (IETF) requests for comments (RFCs). Of these, a small
    number are typically used consistently for building APIs, with a couple more that
    find occasional use. REST APIs are primarily built upon the following HTTP verbs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`POST`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GET`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUT`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PATCH`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These verbs correspond with typical operations we perform on resources: create
    (`POST`), read (`GET`), update (`PUT` and `PATCH`), and delete (`DELETE`).'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: I’m admittedly blurring the lines somewhat by loosely equating `PUT` with updating
    a resource, and a bit less so by equating `POST` with creating a resource. I would
    ask the reader to bear with me as I step through the implementation and provide
    clarifications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Occasionally, the following two verbs are employed:'
  prefs: []
  type: TYPE_NORMAL
- en: '`OPTIONS`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HEAD`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These can be used to retrieve the communication options available for request/response
    pairs (`OPTIONS`) and retrieve a response header minus its body (`HEAD`).
  prefs: []
  type: TYPE_NORMAL
- en: For this book, and indeed for most production use, I will focus on the first,
    heavily utilized group. To get (no pun intended) started, let’s create a simple
    microservice that implements a very basic REST API.
  prefs: []
  type: TYPE_NORMAL
- en: Back to the Initializr
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We begin as usual with the Spring Initializr, as shown in [Figure 3-1](#creating_a_spring_boot_project_to_build_a_rest_api).
    I’ve changed the Group and Artifact fields to reflect the details I use (please
    feel free to use your preferred nomenclature), selected Java 11 under Options
    (optional, any listed version will do nicely), and selected only the Spring Web
    dependency. As it indicates in the displayed description, this dependency brings
    with it several capabilities, including that of “[building] web, *including RESTful*,
    applications using Spring MVC” (emphasis added). This is exactly what we require
    for the task at hand.
  prefs: []
  type: TYPE_NORMAL
- en: '![sbur 0301](Images/sbur_0301.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-1\. Creating a Spring Boot project to build a REST API
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Once we’ve generated the project in the Initializr and saved the resultant *.zip*
    file locally, we’ll extract the compressed project files—typically by double-clicking
    the *sbur-rest-demo.zip* file that was downloaded in your file browser or by using
    *unzip* from a shell/terminal window—and then open the now-extracted project in
    your chosen IDE or text editor for a view similar to [Figure 3-2](#our_new_spring_boot_project_just_waiting_for_us_to_begin).
  prefs: []
  type: TYPE_NORMAL
- en: '![sbur 0302](Images/sbur_0302.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-2\. Our new Spring Boot project, just waiting for us to begin
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Creating a Simple Domain
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to *work with* resources, we’ll need to write some code to *accommodate
    some* resources. Let’s start by creating a very simple domain class that represents
    a resource we want to manage.
  prefs: []
  type: TYPE_NORMAL
- en: I’m somewhat of a coffee aficionado, as my good friends—this now includes you—know.
    With that in mind, I’ll be using a coffee domain, with a class representing a
    particular type of coffee, as the domain for this example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s begin by creating the `Coffee` class. This is essential to the example,
    as we need a resource of some kind to demonstrate how to manage resources via
    a REST API. But the domain simplicity or complexity is incidental to the example,
    so I’ll keep it simple to focus on the objective: the resultant REST API.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in [Figure 3-3](#the_coffee_class_our_domain_class), the `Coffee`
    class has two member variables:'
  prefs: []
  type: TYPE_NORMAL
- en: An `id` field used to uniquely identify a particular kind of coffee
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `name` field that describes the coffee by name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![sbur 0303](Images/sbur_0303.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-3\. The Coffee class: our domain class'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: I declare the `id` field as `final` so that it can be assigned only once and
    never modified; as such, this also requires that it is assigned when creating
    an instance of class `Coffee` and implies that it has no mutator method.
  prefs: []
  type: TYPE_NORMAL
- en: 'I create two constructors: one that takes both parameters and another that
    provides a unique identifier if none is provided upon creation of a `Coffee`.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, I create accessor and mutator methods—or getter and setter methods, if
    you prefer to call them that—for the `name` field, which is not declared `final`
    and is thus mutable. This is a debatable design decision, but it serves our upcoming
    needs for this example well.
  prefs: []
  type: TYPE_NORMAL
- en: With that, we now have a basic domain in place. Next it’s time for a REST.
  prefs: []
  type: TYPE_NORMAL
- en: GET-ting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Perhaps the most-used of the most-used verbs is `GET`. So let’s *get* (pun intended)
    started.
  prefs: []
  type: TYPE_NORMAL
- en: '@RestController in a Nutshell'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Without going too deep down the rabbit hole, Spring MVC (Model-View-Controller)
    was created to separate concerns between data, its delivery, and its presentation,
    assuming the views would be provided as a server-rendered web page. The `@Controller`
    annotation helps tie the various pieces together.
  prefs: []
  type: TYPE_NORMAL
- en: '`@Controller` is a stereotype/alias for the `@Component` annotation, meaning
    that upon application startup, a Spring Bean—an object created and managed by
    the Spring inversion of control (IoC) container within the app—is created from
    that class. `@Controller`-annotated classes accommodate a `Model` object to provide
    model-based data to the presentation layer and work with a `ViewResolver` to direct
    the application to display a particular view, as rendered by a view technology.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Spring supports several view technologies and templating engines, covered in
    a later chapter.
  prefs: []
  type: TYPE_NORMAL
- en: It’s also possible to instruct a `Controller` class to return a formatted response
    as JavaScript Object Notation (JSON) or as another data-oriented format such as
    XML simply by adding an `@ResponseBody` annotation to the class or method (JSON
    by default). This results in the Object/Iterable return value of a method being
    the *entire body* of the response to a web request, instead of being returned
    as a part of the `Model`.
  prefs: []
  type: TYPE_NORMAL
- en: The `@RestController` annotation is a convenience notation that combines `@Controller`
    with `@ResponseBody` into a single descriptive annotation, simplifying your code
    and making intent more obvious. Once we’ve annotated a class as an `@RestController`,
    we can begin creating our REST API.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s `GET` Busy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: REST APIs deal with objects, and objects can come alone or as a group of related
    objects. To leverage our coffee scenario, you may want to retrieve a particular
    coffee; you may instead wish to retrieve all coffees, or all that are considered
    dark roast, fall within a range of identifiers, or include “Colombian” in the
    description, for example. To accommodate the need to retrieve one instance or
    more than one instance of an object, it is a good practice to create multiple
    methods in our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ll begin by creating a list of `Coffee` objects to support the method returning
    multiple `Coffee` objects, as shown in the rudimentary class definition that follows.
    I define the variable holding this group of coffees as a `List` of `Coffee` objects.
    I choose `List` as the higher-level interface for my member variable type, but
    I’ll actually assign an empty `ArrayList` for use within the `RestApiDemoController`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: It’s a recommended practice to adopt the highest level of type (class, interface)
    that can cleanly satisfy internal and external APIs. These may not match in all
    cases, as they don’t here. Internally, `List` provides the level of API that enables
    me to create the cleanest implementation based on my criteria; externally, we
    can define an even higher-level abstraction, as I’ll demonstrate shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s always a good idea to have some data to retrieve in order to confirm that
    everything is working as expected. In the following code, I create a constructor
    for the `RestApiDemoController` class, adding code to populate the list of coffees
    upon object creation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the following code, I create a method in the `RestApiDemoController`
    class that returns an iterable group of coffees represented by our member variable
    `coffees`. I choose to use an `Iterable<Coffee>` because any iterable type will
    satisfactorily provide this API’s desired functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: .Using `@RequestMapping` to `GET` the list of coffees
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: To the `@RequestMapping` annotation, I add a path specification of `/coffees`
    and a method type of `RequestMethod.GET`, indicating that the method will respond
    to requests with the path of `/coffees` and restrict requests to only `HTTP GET`
    requests. Retrieval of data is handled by this method, but updates of any kind
    are not. Spring Boot, via the Jackson dependencies included in Spring Web, performs
    the marshalling and unmarshalling of objects to JSON or other formats automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can streamline this even further using another convenience annotation. Using
    `@GetMapping` incorporates the direction to allow only `GET` requests, reducing
    boilerplate and requiring only the path to be specified, even omitting the `path
    =` since no parameter deconfliction is required. The following code clearly demonstrates
    the readability benefits of this annotation swap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: POST-ing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To create resources, an `HTTP POST` method is the preferred option.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: A `POST` supplies details of a resource, typically in JSON format, and requests
    that the destination service creates that resource *under* the specified URI.
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in the next code fragment, a `POST` is a relatively simple affair:
    our service receives the specified coffee details as a `Coffee` object—thanks
    to Spring Boot’s automatic marshalling—and adds it to our list of coffees. It
    then returns the `Coffee` object—automatically unmarshalled by Spring Boot to
    JSON by default—to the requesting application or service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: PUT-ting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Generally speaking, `PUT` requests are used to update existing resources with
    known URIs.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Per the IETF’s document titled [Hypertext Transfer Protocol (HTTP/1.1): Semantics
    and Content](https://tools.ietf.org/html/rfc7231), `PUT` requests should update
    the specified resource if present; if the resource doesn’t already exist, it should
    be created.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code operates in accordance with the specification: search for
    the coffee with the specified identifier, and if found, update it. If no such
    coffee is contained within the list, create it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: DELETE-ing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To delete a resource, we use an `HTTP DELETE` request. As shown in the next
    code fragment, we create a method that accepts a coffee’s identifier as an `@PathVariable`
    and removes the applicable coffee from our list using the `removeIf` `Collection`
    method. `removeIf` accepts a `Predicate`, meaning we can provide a lambda to evaluate
    that will return a boolean value of `true` for the desired coffee to remove. Nice
    and tidy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: And More
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While there are many more things that could be done to improve this scenario,
    I’m going to focus on two in particular: reducing repetition and returning HTTP
    status codes where required by the specification.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To reduce repetition in the code, I’ll elevate the portion of the URI mapping
    that is common to all methods within the `RestApiDemoController` class to the
    class-level `@RequestMapping` annotation, `"/coffees".` We can then remove that
    same portion of the URI from each method’s mapping URI specification, reducing
    the textual noise level a bit, as the following code shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, I consult the IETF document referenced earlier and note that while HTTP
    status codes are not specified for `GET` and suggested for `POST` and `DELETE`
    methods, they are required for `PUT` method responses. To accomplish this, I modify
    the `putCoffee` method as shown in the following code segment. Instead of returning
    only the updated or created `Coffee` object, the `putCoffee` method will now return
    a `ResponseEntity` containing said `Coffee` and the appropriate HTTP status code:
    201 (Created) if the `PUT` coffee didn’t already exist, and 200 (OK) if it existed
    and was updated. We could do more, of course, but the current application code
    fulfills requirements and represents straightforward and clean internal and external
    APIs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Trust, but Verify
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With all of the code in place, let’s put this API through its paces.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: I use the [HTTPie](https://httpie.org) command line HTTP client for nearly all
    of my HTTP-based chores. Occasionally I will also use [curl](https://curl.haxx.se)
    or [Postman](https://www.postman.com), but I find HTTPie to be a versatile client
    with a streamlined command-line interface and superb utility.
  prefs: []
  type: TYPE_NORMAL
- en: As shown in [Figure 3-4](#get_all_the_coffees), I query the *coffees* endpoint
    for all coffees currently in our list. HTTPie defaults to a `GET` request and
    assumes *localhost* if no hostname is provided, reducing unnecessary typing. As
    expected, we see all four coffees with which we prepopulated our list.
  prefs: []
  type: TYPE_NORMAL
- en: '![sbur 0304](Images/sbur_0304.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-4\. `GET`-ting all coffees
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Next, I copy the `id` field for one of the coffees just listed and paste it
    into another `GET` request. [Figure 3-5](#get_a_coffee) displays the correct response.
  prefs: []
  type: TYPE_NORMAL
- en: '![sbur 0305](Images/sbur_0305.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-5\. `GET`-ting a coffee
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'To execute a `POST` request with HTTPie is simple: just pipe a plaintext file
    containing a JSON representation of a `Coffee` object with `id` and `name` fields,
    and HTTPie assumes that a `POST` operation is in order. [Figure 3-6](#post_a_new_coffee_to_the_list)
    shows the command and its successful outcome.'
  prefs: []
  type: TYPE_NORMAL
- en: '![sbur 0306](Images/sbur_0306.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-6\. `POST`-ing a new coffee to the list
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As mentioned earlier, a `PUT` command should allow for updating an existing
    resource or adding a new one if the requested resource doesn’t already exist.
    In [Figure 3-7](#put_an_updated_to_an_existing_coffee), I specify the `id` of
    the coffee I just added and pass another JSON object with a different name to
    the command. The result is that the coffee with `id` of “99999” now has a `name`
    of “Caribou Coffee” instead of “Kaldi’s Coffee” as before. The return code is
    200 (OK), as expected as well.
  prefs: []
  type: TYPE_NORMAL
- en: '![sbur 0307](Images/sbur_0307.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-7\. `PUT`-ting an update to an existing coffee
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In [Figure 3-8](#put_a_new_coffee) I initiate a `PUT` request in the same manner
    but reference an `id` in the URI that doesn’t exist. The application dutifully
    adds it in compliance with IETF-specified behavior and correctly returns an HTTP
    status of 201 (Created).
  prefs: []
  type: TYPE_NORMAL
- en: '![sbur 0308](Images/sbur_0308.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-8\. `PUT`-ting a new coffee
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Creating a `DELETE` request with HTTPie is very similar to creating a `PUT`
    request: the HTTP verb must be specified, and the resource’s URI must be complete.
    [Figure 3-9](#delete_a_coffee) shows the result: an HTTP status code of 200 (OK),
    indicating the resource was successfully deleted and with no shown value, since
    the resource no longer exists.'
  prefs: []
  type: TYPE_NORMAL
- en: '![sbur 0309](Images/sbur_0309.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-9\. `DELETE`-ing a coffee
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Finally, we re-query our full list of coffees to confirm the expected final
    state. As [Figure 3-10](#get_all_coffees_now_in_the_list) demonstrates, we now
    have one additional coffee that wasn’t in our list before, as expected: Mötor
    Oil Coffee. API validation is a success.'
  prefs: []
  type: TYPE_NORMAL
- en: '![sbur 0310](Images/sbur_0310.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-10\. `GET`-ting all coffees now in the list
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter demonstrated how to develop a basic working application using Spring
    Boot. Since most applications involve exposing backend cloud resources to users,
    usually via a frontend user interface, I showed how to create and evolve a useful
    REST API that can be consumed in numerous, consistent ways to provide needed functionality
    for creating, reading, updating, and deleting resources central to nearly every
    critical system.
  prefs: []
  type: TYPE_NORMAL
- en: 'I examined and explained the `@RequestMapping` annotation and its various convenience
    annotation specializations that align with defined HTTP verbs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@GetMapping`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@PostMapping`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@PutMapping`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@PatchMapping`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@DeleteMapping`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After creating methods that addressed many of these annotations and their associated
    actions, I then refactored the code a bit to streamline it and provide HTTP response
    codes where required. Validating the API confirmed its correct operation.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, I discuss and demonstrate how to add database access to
    our Spring Boot application to make it increasingly useful and ready for production.
  prefs: []
  type: TYPE_NORMAL
