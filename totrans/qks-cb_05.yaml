- en: Chapter 5\. Programming Model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you’ll learn about topics related to the programming model
    of Quarkus. Quarkus is unique in the programming model it follows. Unlike some
    other frameworks, Quarkus allows you to mix and match both an imperative model,
    using CDI, and a reactive model, using SmallRye Mutiny. [Chapter 15](ch15.xhtml#working_with_a_reactive_programming_model_chapter)
    is dedicated to using the reactive approach. At times, you may find yourself needing
    both approaches, so it is good to know how to utilize each.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re focusing on the imperative model, so you’ll learn the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: How to marshal/unmarshal JSON and XML documents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to validate request parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use the CDI spec as a context and dependency injection solution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to write tests for a Quarkus service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5.1 Marshalling/Unmarshalling JSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to marshall/unmarshall JSON documents to/from Java objects.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the `JSON-B` specification or Jackson project to marshall and unmarshall
    JSON documents from/to Java objects.
  prefs: []
  type: TYPE_NORMAL
- en: When you are creating a REST API, you *usually* use JSON as a data format to
    exchange information. So far, you’ve seen examples of returning only simple plain-text
    responses; but in this recipe, you’ll learn how to start using JSON as the data
    format for the body of the request and as a response.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing you need to do is register the *JSON-B* extension in the *pom.xml*.
    Open a terminal window, and from the root directory of the project run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This effectively adds `io.quarkus:quarkus-resteasy-jsonb` into the build tool.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In Gradle, you can use `./gradlew addExtension` `--extensions="quarkus-resteasy-jsonb"`
    to add the extension.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to create a `developer` class that will be marshalled and
    unmarshalled in the endpoint. Create a new class named `org.acme.quickstart.Developer.java`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you can create a Rest API endpoint for implementing `developer` operations.
    Create a new class named `org.acme.quickstart.DeveloperResource.java`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Try it by opening a new terminal window, starting the Quarkus application,
    and sending requests for `POST` and `GET` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that each Java field is mapped directly to a JSON field. If you want
    to change that, you can use the `javax.json.bind.annotation.JsonbProperty` annotation
    to set a different mapping name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can use the Jackson project to marshall/unmarshall JSON documents to/from
    Java objects instead of JSON-B as well. You need to register the `Jackson-Extension`
    to use it as a JSON solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, a `com.fasterxml.jackson.databind.ObjectMapper` is provided, but
    you can provide a custom `ObjectMapper` using CDI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can learn more about JSON-B and Jackson at the following web pages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Jakarta JSON Binding (JSON-B)](http://json-b.net)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Jackson Project Home @GitHub](https://oreil.ly/U3hwH)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5.2 Marshalling/Unmarshalling XML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to marshall/unmarshall XML documents to/from Java objects.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the JAX-B specification to marshall and unmarshall XML documents from/to
    Java objects.
  prefs: []
  type: TYPE_NORMAL
- en: When you are creating a REST API, you might want to use XML as a data format
    to exchange information. So far, you’ve seen how to do it in JSON format, but
    in this section, you’ll learn how to start using XML as the data format for the
    body of the request and as a response.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing you need to do is register the JAX-B extension in the *pom.xml*.
    Open a terminal window, and from the root directory of the project run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This effectively adds `io.quarkus:quarkus-resteasy-jaxb` into the build tool.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In Gradle, you can use `./gradlew addExtension` `--extensions="quarkus-resteasy-jaxb"`
    to add the extension.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to create a `computer` class that will be marshalled and unmarshalled
    in the endpoint. Create a new class named `org.acme.quickstart.Computer.java`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_programming_model_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: '`XmlRootElement` sets this as XML document'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you can create a REST API endpoint for implementing `computer` operations.
    Create a new class named `org.acme.quickstart.ComputerResource.java`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Try it by opening a new terminal window, starting the Quarkus application,
    and sending requests for `POST` and `GET` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Apart from `@XmlRootElement`, there are other important annotations in the
    JAX-B spec:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@XmlRootElement`'
  prefs: []
  type: TYPE_NORMAL
- en: Sets the root XML document. You can also use it to set the name of the element
    or the namespace.
  prefs: []
  type: TYPE_NORMAL
- en: '`@XmlType`'
  prefs: []
  type: TYPE_NORMAL
- en: Defines the order in which the fields are written.
  prefs: []
  type: TYPE_NORMAL
- en: '`@XmlElement`'
  prefs: []
  type: TYPE_NORMAL
- en: Defines the actual XML element name among other attributes like `namespace`,
    `nillable`, or `required`.
  prefs: []
  type: TYPE_NORMAL
- en: '`@XmlAttribute`'
  prefs: []
  type: TYPE_NORMAL
- en: Defines the field to be mapped as an attribute instead of as an element.
  prefs: []
  type: TYPE_NORMAL
- en: '`@XmlTransient`'
  prefs: []
  type: TYPE_NORMAL
- en: Indicates fields not to be included in XML.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can learn more about JAX-B at the following web page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Oracle: Lesson: Introduction to JAXB (The Java Tutorials)](https://oreil.ly/r9FKb)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5.3 Validating Input and Output Values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to validate the input and output values of your REST and business services.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the Bean Validation specification to add validations to your model.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, your model might contain some constraints, whether or not the model
    is semantically valid—for example, that a `name` is not null, or an `email` is
    a valid email. Quarkus integrates with Bean Validation to express constraints
    on object models via annotations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing you need to do is register the Bean Validation extension in
    the *pom.xml*. Open a terminal window, and from the root directory of the project
    run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This effectively adds `io.quarkus:quarkus-hibernate-validator` into the build
    tool.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In Gradle, you can use `./gradlew addExtension` `--extensions="quarkus-hibernate-validator"`
    to add the extension.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to update the `developer` class and annotate it with some
    constraints. Open the `org.acme.quickstart.Developer.java` class and annotate
    some of the fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_programming_model_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The minimum size of the string is 4
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_programming_model_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The field is mandatory
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Either of the available packages is sufficient, but if you want to use only
    the spec APIs, use the `javax` packages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you need to annotate with `javax.validation.Valid` that a parameter
    must be verified. Open the `org.acme.quickstart.DeveloperResource.java` class
    and annotate the `developer` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_programming_model_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: '`@Valid` is mandatory to validate the object'
  prefs: []
  type: TYPE_NORMAL
- en: 'Try it by opening a new terminal window, starting the Quarkus application,
    and executing requests for the POST method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: It is important to note that in the first request, the name has an incorrect
    size, hence a 400 Bad Request HTTP code is returned. In the second request, because
    the request body is correct, the method works as expected.
  prefs: []
  type: TYPE_NORMAL
- en: But notice that if there is an error, the response does not contain any information
    about what has failed. That’s fine because it is important to show the internals
    not directly, but in a controlled way.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you want to provide a better response message, you can provide an implementation
    of `ExceptionMapper`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new class named `org.acme.quickstart.BeanValidationExceptionMapper.java`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_programming_model_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: '`@Provider` set an implementation of an extension interface discoverable by
    the JAX-RS runtime'
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_programming_model_CO4-2)'
  prefs: []
  type: TYPE_NORMAL
- en: '`javax.ws.rs.ext.ExceptionMapper` is used to transform an exception into a
    `javax.ws.rs.core.Response`'
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_programming_model_CO4-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Creates an array of constraint violations
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_programming_model_CO4-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Iterates over each of the constraint violations
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](Images/5.png)](#co_programming_model_CO4-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Creates a JSON object
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you can send a request for the POST method again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The output is now slightly different. The error code is still the same, a 400
    Bad Request, but now the body content of the response contains the JSON document
    that we created in the exception mapper.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also validate the output parameters (the parameters you send back to
    the caller) by adding `@Valid` annotation in the return type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Moreover, sometimes you don’t want to add validation rules at the endpoint
    but at the business service layer. Bean Validation can be used in your business
    service if you’re using CDI. See the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you want to learn more about Bean Validations and what constraints are implemented
    by default (i.e., `@Min`, `@Max`, `@AssertTrue`, `@Email`, and so on), you can
    find the information at the following website:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Jakarta Bean Validation](https://oreil.ly/YHR_X)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5.4 Creating Custom Validations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to create custom validations.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the Bean Validation extension model by implementing the `javax.validation.ConstraintValidator`
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes the default constraints provided by the Bean Validation specification
    are not enough, and you will want to implement constraints that more closely align
    with your business model. Bean Validation allows you to do that by creating a
    class that implements the `javax.validation.ConstraintValidator` interface and
    the annotation for annotating the field to be validated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s validate that your favorite language can only be a JVM-based language.
    First of all, you need to create the annotation. Create a new class named `org.acme.quickstart.JvmLanguage.java`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_programming_model_CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Raises the constraint as a normal compilation error
  prefs: []
  type: TYPE_NORMAL
- en: Then you need to create the logic to detect any constraint violation. This new
    class must implement the `javax.validation.ConstraintValidator` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create a class named `org.acme.quickstart.JvmLanguageValidator.java`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_programming_model_CO6-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The annotation defined in previous step
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_programming_model_CO6-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The type of object that the validation applies
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_programming_model_CO6-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Checks if the provided favorite language (`value`) is a JVM-based language
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you need to annotate the `favoriteLanguage` field from `org.acme.quickstart.Developer`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Try it by opening a new terminal window, starting the Quarkus application,
    and sending some requests to the POST method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Any validations following the Bean Validation specification on your REST endpoints,
    services methods, and ultimately any CDI-scoped object will be automatically executed
    during the run of your application. If you need something with more control, see
    the next recipe, [Recipe 5.5](#validate-objects-programmatically), for additional
    means of validating objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also good to know that, by default, constraint violation messages will
    be returned using the system locale. If you would like to change this, you can
    do so in the *application.properties* file by setting the `quarkus.default-locale`
    setting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'For REST endpoints, the locale will be based on the `Accept-Language` HTTP
    header. You can specify a list of supported locales in the *application.properties*
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For more information, visit the following websites:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Jakarta Bean Validation](https://oreil.ly/R6L4d)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Hibernate Validator](https://oreil.ly/O7BNR)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5.5 Validating Objects Programmatically
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to validate objects programmatically.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the Bean Validation `javax.validation.Validator` class.
  prefs: []
  type: TYPE_NORMAL
- en: In some circumstances (for example, in non-CDI beans) you want to control when
    the validation process is executed. For this reason, `javax.validation.Validator`
    class is provided.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create an endpoint that validates the input using `javax.validation.Validator`
    instead of using a declarative way with `@Valid` annotations. Open the `org.acme.quickstart.DeveloperResource.java`
    class and inject `Validator` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_programming_model_CO7-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Inject `Validator` class from Bean Validation spec
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_programming_model_CO7-2)'
  prefs: []
  type: TYPE_NORMAL
- en: '`@Valid` is not required'
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_programming_model_CO7-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Validate the object programmatically
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_programming_model_CO7-4)'
  prefs: []
  type: TYPE_NORMAL
- en: If there are no errors, proceed
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](Images/5.png)](#co_programming_model_CO7-5)'
  prefs: []
  type: TYPE_NORMAL
- en: If there are errors, then build the output
  prefs: []
  type: TYPE_NORMAL
- en: 'Try it by opening a new terminal window, starting the Quarkus application,
    and sending a request for the new POST method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Quarkus will automatically create an instance of the `javax.validation.ValidatorFactory`.
    You can tweak this a little by creating your own replacement beans. An instance
    of the following types in your application will automatically be injected into
    the `ValidatorFactory`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`javax.validation.ClockProvider`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`javax.validation.ConstraintValidator`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`javax.validation.ConstraintValidatorFactory`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`javax.validation.MessageInterpolator`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`javax.validation.ParameterNameProvider`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`javax.validation.TraversableResolver`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`org.hibernate.validator.spi.properties.GetterPropertySelectionStrategy`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`org.hibernate.validator.spi.scripting.ScriptEvaluatorFactory`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You may have only one instance of a particular type in the preceding list, and
    classes should be declared as `@ApplicationScoped`.
  prefs: []
  type: TYPE_NORMAL
- en: 5.6 Injecting Dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to inject dependencies into your classes.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use Contexts and Dependency Injection (CDI).
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Dependency injection (DI) in Quarkus, which is based on the [Contexts and Dependency
    Injection 2.0 specification](https://oreil.ly/VcDnN), is pretty standard, with
    only a few modifications needed for the basic use case.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Quarkus implements most of the specification, except for some corner cases that
    should not affect your code. The Quarkus website maintains a list of supported
    features and limitations, including more advanced features that are not covered
    here in the book. You can find those lists in the [Quarkus CDI Reference Guide](https://oreil.ly/-LPAd).
  prefs: []
  type: TYPE_NORMAL
- en: 'Injection happens just as you would expect in any other application using CDI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_programming_model_CO8-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Use of the `@Inject` annotation is required
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_programming_model_CO8-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Due to restrictions on reflection, package-private injection fields are preferred
  prefs: []
  type: TYPE_NORMAL
- en: 'The injected service is pretty standard and without any surprises:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_programming_model_CO9-1)'
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned in the following, you should include a bean-defining annotation
    that allows classes to be found
  prefs: []
  type: TYPE_NORMAL
- en: Bean discovery in Quarkus follows a simplified process from standard CDI. In
    short, if your application classes do not have a [bean-defining annotation](https://oreil.ly/jm4QF),
    they will not be picked up by Quarkus.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To learn more, see the following web pages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[JBoss: JSR 365: Contexts and Dependency Injection for Java 2.0](https://oreil.ly/clOD4)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[GitHub: GraalVM Native Image Compatibility and Optimization Guide](https://oreil.ly/7sgPm)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5.7 Creating Factories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to create a factory for an object.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the `javax.enterise.inject.Produces` concept from CDI.
  prefs: []
  type: TYPE_NORMAL
- en: 'CDI has a concept called *producers* that allows you to do any sort of object
    creation necessary to add a new bean or class to the list of resolvable instances,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Quarkus takes the producers concept a little further. Quarkus does so by adding
    the `@io.quarkus.arc.DefaultBean` annotation. In terms of CDI, this is like an
    enabled default alternative. Because Quarkus does not allow for alternatives,
    a class annotated with `DefaultBean` gives you a way to create a default instance
    of a bean. The following code is an example pulled from the Quarkus website:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The following excerpt allows your application or library to inject a tracer
    wherever necessary. It also allows for customization by creating a new producer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: With this code in your application, the `Reporter` created from the `CustomTracerConfiguration`
    class will be used instead of the default.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To learn more, visit the following web page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[JBoss: JSR 365: Contexts and Dependency Injection for Java 2.0](https://oreil.ly/4-OrV)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5.8 Executing Object Life Cycle Events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to execute logic before and/or after objection creation/destruction.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'CDI makes use of the `@javax.annotation.PostConstruct` and `@javax.annotation.PreDestroy`
    annotations for life cycle management. The methods annotated with those annotations
    will be called after object creation for `PostConstruct` and before the object
    is destroyed for `PreDestroy`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If there is logic that needs to happen after the constructor is called and after
    all the injections happen, it should go into a method annotated with the `@PostConstruct`
    annotation. This is guaranteed to be called only once in the lifetime of an object
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, if logic needs to be executed before the object is destroyed, place
    it in a method annotated with the `@PreDestroy` annotation. Ideas for this would
    include closing connections, cleaning up resources, and finalizing logging.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To learn more, see the following pages on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Common Annotations API: PostConstruct.java](https://oreil.ly/UxdG2)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Common Annotations API: PreDestroy.java](https://oreil.ly/qsZUC)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5.9 Executing Application Life Cycle Events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to execute logic at application startup and/or after application shutdown.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Observe the `io.quarkus.runtime.StartupEvent` and the `io.quarkus.runtime.ShutdownEvent`.
    During application startup, Quarkus will fire the `StartupEvent`; and during shutdown,
    the `ShutdownEvent`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_programming_model_CO10-1)'
  prefs: []
  type: TYPE_NORMAL
- en: You must add a bean-defining annotation
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_programming_model_CO10-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The startup event that is fired
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_programming_model_CO10-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The shutdown event that Quarkus fires
  prefs: []
  type: TYPE_NORMAL
- en: Neither of these event objects carry any additional information, so there is
    not anything else to cover.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Event observation is a very powerful way in Quarkus (and in other CDI frameworks)
    to decouple concerns with minimal overhead.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For more, see [Recipe 5.8](#executing-obj-lifecycle-events).
  prefs: []
  type: TYPE_NORMAL
- en: 5.10 Using a Named Qualifier
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to qualify an injection with a name.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the `@javax.inject.Named` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: In CDI, a *qualifier* is any annotation defined as `@Retention(RUNTIME)` and
    annotated with `@javax.inject.Qualifier`. Qualifiers are typically defined so
    that they can be used everywhere you need them as `@Target({METHOD, FIELD, PARAMETER,
    TYPE})`.
  prefs: []
  type: TYPE_NORMAL
- en: 'CDI comes with a useful qualifier: `@javax.inject.Named`. The value isn’t required,
    but it doesn’t make sense to use `@Named` without an actual name. When resolving
    an injection point, CDI will look for any beans of the correct type that also
    contain the same qualifier. In the case of `@Named`, the value part of the annotation
    must match as well.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is very useful if you have multiple instances of a type, but they are
    not the same object. CDI doesn’t take into consideration the actual instance of
    the object because that isn’t known until it is created and will be different
    each time anyway. To get around this problem, CDI uses qualifiers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For completeness, this is a way to produce named beans:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '`@Named` qualification, though weak—which is one of the things CDI tries to
    avoid—can be a useful trick during integrations. We recommend using strongly typed
    annotations where possible.'
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For more information, visit the following web page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[JBoss: qualifier @Named at injection points](https://oreil.ly/5NydQ)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5.11 Using Custom Qualifiers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to qualify an injection with some other qualifier annotation.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Develop and use qualifier annotations.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Recipe 5.10](#named_qualifier), you were introduced to the idea of a qualifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Producing the bean is exactly as you would expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, of course, injecting the newly qualified instance is just as easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using qualifier annotations is the preferred way to use qualified CDI injections
    both in a normal CDI application and in Quarkus.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For more information, visit the following web page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[JBoss: Qualifiers](https://oreil.ly/MOfwa)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5.12 Qualifying and Configuring Annotations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to qualify and configure a dependency using annotations.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using a combination of `InjectionPoint` in a producer and nonbinding attributes
    on the qualifier annotation, it is possible to both qualify and configure a bean.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is an interesting, albeit atypical, use case for qualifiers and producers.
    Take a look at the following code to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_programming_model_CO11-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The attributes are listed as nonbinding, so injections actually work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Normally, the attributes of a qualifier are considered for injections, so if
    the attributes don’t match, the qualified object will not be injected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_programming_model_CO12-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Only the default attributes on the producer
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_programming_model_CO12-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Get the instance of the qualifier to pull configuration from the attributes
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_programming_model_CO12-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Return the newly configured object
  prefs: []
  type: TYPE_NORMAL
- en: 'Usage is exactly the same as any other qualifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For more information, visit the following web page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[JBoss: Injection point metadata](https://oreil.ly/BVmV2)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5.13 Creating Interceptors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to implement cross-cutting concerns.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *cross-cutting concern* is an aspect that affects other concerns of a program.
    The textbook example of this is *transaction control*. It is an action that affects
    the use of data in your program and must always be addressed, often in the same
    or similar manner.
  prefs: []
  type: TYPE_NORMAL
- en: Create `@javax.inject.AroundInvoke` and `@javax.inject.AroundConstruct` interceptors
    with the corresponding interceptor bindings. You are also able to create CDI stereotypes
    to better compose concerns into a single annotation.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, create an annotation with the `@javax.interceptor.InterceptorBinding`
    annotation. This will be used to link up the actual interceptor code and to annotate
    any of the methods or classes you wish to be intercepted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Nothing special going on there. Next, you need to create the interceptor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a pretty contrived example, but it is easy to understand what is happening.
    Lastly, you simply need to annotate a method or class with the binding annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Every time the `executeOrder` method is called, the method in the interceptor
    that is annotated with `@javax.interceptor.AroundInvoke`, `logEvent` in this case,
    will be called before the actual `executeOrder` method is called.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Interceptors are very easy to implement in Quarkus using the standard CDI mechanism.
    This provides a simple way to define and utilize cross-cutting actions in your
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Aspect-oriented programming (AOP) has been around for quite some time, since
    1997 to be exact. A team at Xerox PARC lead by Gregor Kiczales created and termed
    cross-cutting and aspect-oriented programming. Some claim the Microsoft Transaction
    Server was the first widely adopted instance of AOP. Eventually, Enterprise JavaBeans
    developed AOP aspects. There’s also Spring and AspectJ in the Java ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: However, we are talking about CDI and Quarkus. Quarkus ArC (the dependency injection
    flavor in Quarkus), the name of which is a play on arc welding, makes use of the
    same concepts.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For more information, check out the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Essential.NET, Volume 1: The Common Language Runtime* by Don Box and Chris
    Sells (Addison-Wesley Professional)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[JBoss: Interceptor bindings](https://oreil.ly/QlAGP)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Stack Overflow: What does ArC mean?](https://oreil.ly/0BpNz)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5.14 Writing Behavioral Tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to write behavioral tests to verify the correctness of service without
    verifying its internals.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Quarkus’s testing solution is based on [JUnit 5](https://oreil.ly/bh494), the
    de facto testing tool in the Java ecosystem, and provides tight integration with
    [REST-Assured](http://rest-assured.io) testing framework for validating RESTful
    Web APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Important
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Using REST-Assured is not mandatory; it is just a recommendation or best practice,
    so you can use any other framework that you prefer for testing endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most important part of the Quarkus testing framework is an annotation called
    `QuarkusTest`. When you annotate a test class with this annotation, you are effectively
    marking that test to be executed within the Quarkus test framework, which instructs
    the test to follow the following life cycle:'
  prefs: []
  type: TYPE_NORMAL
- en: The Quarkus application is automatically started once. When the application
    has been booted up and is ready to start serving requests, the test execution
    is started.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Each test is executed against this running instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Quarkus application is stopped.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: To minimize the impact of running tests in terms of performance, the Quarkus
    application is started only once, and then all test classes defined in the testing
    plan are executed against this running instance, so the application is not restarted
    for each test class execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `org.acme.quickstart.GreetingResourceTest.java` class located at *src/test/java*
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_programming_model_CO13-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets this test as a Quarkus test
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_programming_model_CO13-2)'
  prefs: []
  type: TYPE_NORMAL
- en: REST-Assured static method to start the validation
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_programming_model_CO13-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Sends a request using GET HTTP method to `/hello` path
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_programming_model_CO13-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Starts the assertion section
  prefs: []
  type: TYPE_NORMAL
- en: You can run the test from your IDE as well, as shown in [Figure 5-1](#testvscode).
  prefs: []
  type: TYPE_NORMAL
- en: '![qucb 0501](Images/qucb_0501.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-1\. Visual Studio Code with Java integration
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Or if you want to run the test in a terminal window, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_programming_model_CO14-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Quarkus listens on port 8081 when running tests
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_programming_model_CO14-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The `test` profile is activated
  prefs: []
  type: TYPE_NORMAL
- en: As you’ve seen in the previous example, port 8081 is the default port used when
    tests are executed.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can change the port used by tests by setting the `quarkus.http.test-port`
    property to a different value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Because Quarkus offers nice integration with REST-Assured, it automatically
    updates the port used, so no additional configuration is required in that part.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In some scenarios, you might want to run tests in a random port instead of
    a specific one. This is also supported by Quarkus; the only thing you need to
    set is the `quarkus.http.test-port` property to zero (`0`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Quarkus supports writing behavioral tests, which are tests that validate the
    functionality of a service without knowing or verifying the internals of the service.
    [Figure 5-2](#behavioral-testing-fig) shows the nature of behavioral testing.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of REST APIs and microservices in general, you can understand a
    behavioral test as a form of test that follows the schema of sending a request
    to a running instance of the service and validating that the response is the expected
    one.
  prefs: []
  type: TYPE_NORMAL
- en: '![qucb 0502](Images/qucb_0502.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-2\. Behavioral testing
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you have scaffolded the project using any of the methods explained in [Chapter 1](ch01.xhtml#quarkus_overview_chapter),
    you should already have a completed behavioral test, including the required dependencies
    registered at your build tool script.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you want to learn more about the underlying technologies used by the Quarkus
    testing framework, you can visit the following websites:'
  prefs: []
  type: TYPE_NORMAL
- en: '[JBoss: JUnit 5 User Guide](https://oreil.ly/oahZK)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[REST-Assured](http://rest-assured.io)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5.15 Writing Unit Tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to write unit tests to verify the correctness of the internals of the
    service.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the Quarkus testing solution based on [JUnit 5](https://oreil.ly/oahZK)
    and its integration with CDI.
  prefs: []
  type: TYPE_NORMAL
- en: Quarkus allows you to inject CDI beans into your tests via the `@Inject` annotation.
    In fact, under the covers, a test in Quarkus is just a CDI bean, so everything
    that it is valid in a bean is also valid in a test.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a Greeting Service bean that uses Bean Validation to verify its
    input parameters. Remember to add the `quarkus-hibernate-validator` extension.
    Create a new class `org.acme.quickstart.GreetingService.java`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_programming_model_CO15-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets service as CDI bean
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_programming_model_CO15-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Adds validation in the method
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you want to test that Greeting Service works as expected in the next three
    cases:'
  prefs: []
  type: TYPE_NORMAL
- en: When the user age is less than 16, an exception is thrown.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the user age is between 16 and 18, the teenager’s message is returned.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the user age is greater than 18, return the message for adults.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We recommend that you use the [AssertJ](https://oreil.ly/d5tI2) project to
    write readable assertions. To use it, you need to register the AssertJ dependency
    in the build script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new class `org.acme.quickstart.GreetingService.java` at *src/test/java*
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_programming_model_CO16-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets this test as a Quarkus test
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_programming_model_CO16-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Injects `GreetingService` instance
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_programming_model_CO16-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Executes tests using the Greeting Service instance created by CDI container
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_programming_model_CO16-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Uses AssertJ assertions
  prefs: []
  type: TYPE_NORMAL
- en: 'Try it by opening a new terminal window and running tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the Quarkus application is started once but both test classes are
    executed.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the [Recipe 5.14](#behavioral_tests) recipe, you learned how to write tests
    using a behavioral approach in which you care only about requests and responses
    of the service. However, more often than not, you want to validate what’s happening
    inside the service, or you want to validate how some pieces are behaving inside
    a running instance without having to mock the environment. This is typically required
    when you want to validate that a business object works as expected, which includes
    its integration with the features provided by Quarkus (Bean Validation, CDI, etc.).
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To learn more about AssertJ, visit the following web page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[AssertJ: fluent assertions java library](https://oreil.ly/d5tI2)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5.16 Creating Mock Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to test classes that require extra processing time or need to communicate
    with external systems.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use mock support in Quarkus to provide CDI objects that mimic the behavior of
    real objects by replacing the default ones.
  prefs: []
  type: TYPE_NORMAL
- en: '*Mock objects* are simulated objects that simulate the behavior of real objects
    by providing some canned answer to a method call.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s mock the Greeting Service that was created in the [Recipe 5.15](#writing_unit_tests)
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new class `org.acme.quickstart.MockedGreetingService.java` at *src/test/java*
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_programming_model_CO17-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Mark POJO as a mocked class (alternative class) in CDI
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_programming_model_CO17-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The class must extend or implement the base service
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_programming_model_CO17-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Canned answer
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Creating mocks is not only a great way to bypass external services and longer
    running processes, but also a simple way of testing particular scenarios. In the
    previous solution, there could be two tests: one using the mock and the other
    using the actual object. One would demonstrate the expected behavior by the service,
    and the other could demonstrate an expected failure. This technique is especially
    useful for testing external service failures.'
  prefs: []
  type: TYPE_NORMAL
- en: 5.17 Creating Mock Objects with Mockito
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using Mockito, you want to test classes that require extra processing time or
    need to communicate with external systems.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the Mockito library to provide CDI objects that mimic the behavior of real
    objects by replacing the default ones.
  prefs: []
  type: TYPE_NORMAL
- en: Using Mockito, let’s mock the Greeting Service that was created in the [Recipe
    5.15](#writing_unit_tests) recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing to do is add the Quarkus Mockito extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new class `org.acme.quickstart.GreetingResourceTest.java` at *src/main/java*
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_programming_model_CO18-1)'
  prefs: []
  type: TYPE_NORMAL
- en: '`InjectMock` makes this field a Mockito mock'
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_programming_model_CO18-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Before each test execution, the mock expectations are recorded
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_programming_model_CO18-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The message that is returned is the mocked one
  prefs: []
  type: TYPE_NORMAL
- en: 5.18 Grouping Several Annotations into One
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: with a Meta-Annotation
  prefs: []
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to avoid the population of annotations in your application.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use meta-annotations to group several annotations into one.
  prefs: []
  type: TYPE_NORMAL
- en: You can develop a meta-annotation that contains all the annotations required
    by the tests or other portions of your application. For example, you could create
    a `TransactionalQuarkusTest` annotation that contains both `@QuarkusTest` and
    `@Transactional` annotations, making a Quarkus test transactional by default if
    this newly created annotation is used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new class called `org.acme.quickstart.TransactionalQuarkusTest.java`
    in the *src/test/java* directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_programming_model_CO19-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Adds the annotations that this meta-annotation might “inherit”
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_programming_model_CO19-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets the annotation as a stereotype (meta-annotation)
  prefs: []
  type: TYPE_NORMAL
- en: 'If you then apply this annotation to a class, it will be like you had applied
    both the `@QuarkusTest` and the `@Transactional` annotations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Notice that now the test is more readable and the annotations are reusable.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Quarkus tests are CDI beans, and for this reason, you can apply CDI interceptors.
    For example, you could make your test become transactional by using the transactional
    interceptor. This interceptor is enabled by annotating the test class with `@javax.transaction.Transactional`.
    So, a transactional test might look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, this is perfectly valid, but there are two scenarios in which multiple
    annotations on the class might impact the readability of your test:'
  prefs: []
  type: TYPE_NORMAL
- en: Your test requires more annotations—for example, JUnit 5 annotations like `@TestMethodOrder`
    to define the order execution of tests, or you need to enable other interceptors
    for the test. In these cases, you can end up setting more annotations than code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You have a lot of tests that require the same annotations, so you continuously
    annotate, in most of the cases, all tests with the same annotations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 5.19 Executing Code Before or After a Test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to execute some logic before/after the test suite to start/stop/configure
    a resource for the test.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the *Quarkus Test Resource* extension mechanism to define the required resources
    to execute the tests.
  prefs: []
  type: TYPE_NORMAL
- en: Quarkus provides an extension mechanism that allows you to execute Java code
    before the test suite is started and after the test suite has finished. Furthermore,
    it allows you to create/override configuration properties programmatically so
    that any parameter required by the resource can be set in the test resource class
    instead of having to modify the *application.properties* file.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s write a simple Quarkus Test Resource that just prints some messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new class named `org.acme.quickstart.HelloWorldQuarkusTestResourceLifecycleManager`
    implementing `io.quarkus.test.common.QuarkusTestResourceLifecycleManager` interface
    at *src/test/java* directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_programming_model_CO20-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Must implement `QuarkusTestResourceLifecycleManager`
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_programming_model_CO20-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The method that is executed before the test suite
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_programming_model_CO20-3)'
  prefs: []
  type: TYPE_NORMAL
- en: '`Map` object with system properties to be used'
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_programming_model_CO20-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The method that is executed after the test suite
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](Images/5.png)](#co_programming_model_CO20-5)'
  prefs: []
  type: TYPE_NORMAL
- en: For each test class execution, this method is invoked, passing the test instance
    so that you can inject specific fields
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](Images/6.png)](#co_programming_model_CO20-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets the order of execution in case multiple resources are defined
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you need to register this extension to be executed during the test
    suite execution. To do that, you need to use the `QuarkusTestResource` annotation
    in any class placed within the *src/test/java* directory and set the test resource
    to be started. Although it could be any test class responsible for registering
    the resource, we recommend you create a specific empty class that registers the
    test resource.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new class `org.acme.quickstart.HelloWorldTestResource` in *src/test/java*
    with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_programming_model_CO21-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Registers the test resource
  prefs: []
  type: TYPE_NORMAL
- en: 'Then run the tests in a terminal, and you’ll see something similar as terminal
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_programming_model_CO22-1)'
  prefs: []
  type: TYPE_NORMAL
- en: '`start` method is invoked before Quarkus is started'
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_programming_model_CO22-2)'
  prefs: []
  type: TYPE_NORMAL
- en: '`inject` method is invoked before `GreetingResourceTest` is run'
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_programming_model_CO22-3)'
  prefs: []
  type: TYPE_NORMAL
- en: '`stop` method is invoked after all tests have been executed'
  prefs: []
  type: TYPE_NORMAL
- en: This example is not very usable; however, it is simple to understand the test
    life cycle, but nothing more.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you move forward, the complexity of your tests (integration tests, end-to-end
    tests, etc.) and the required dependencies to run them increases. For example,
    the tests might require a database instance, a Kafka broker, a JMS queue, or an
    identity provider like Keycloak.
  prefs: []
  type: TYPE_NORMAL
- en: With this background, let’s write a more interesting test resource that uses
    Docker to boot up a MariaDB Docker container.
  prefs: []
  type: TYPE_NORMAL
- en: For this example, you are going to use the [Testcontainers](https://oreil.ly/aEeAV)
    test framework; at the time of writing, the latest version is 1.14.3.
  prefs: []
  type: TYPE_NORMAL
- en: Before running tests, you need to have Docker installed in your machine so Testcontainers
    can boot up the MariaDB container locally.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step in developing the Testcontainers Quarkus Test Resource is registering
    the Testcontainers dependency in your build tool for using the MariaDB Docker
    container in your test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation of `QuarkusTestResourceLifecycleManager` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_programming_model_CO23-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Registers the test resource
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_programming_model_CO23-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Defines the test resource interface
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_programming_model_CO23-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets MariaDB container object
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_programming_model_CO23-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Instantiate MariaDB container with required Docker image
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](Images/5.png)](#co_programming_model_CO23-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Starts the container and waits until the container is accepting connections
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](Images/6.png)](#co_programming_model_CO23-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Overrides Quarkus’s configuration to point database connection to the container
    one
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](Images/7.png)](#co_programming_model_CO23-7)'
  prefs: []
  type: TYPE_NORMAL
- en: Stops the container
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, run the tests in a terminal. You’ll see something like this in the
    terminal output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_programming_model_CO24-1)'
  prefs: []
  type: TYPE_NORMAL
- en: MariaDB Docker container is created
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_programming_model_CO24-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Container is up and running and ready to receive incoming requests
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can develop Quarkus Test Resources in a separate project and package them
    as an external JAR library. You can then reuse them in as many projects as required.
  prefs: []
  type: TYPE_NORMAL
- en: 'Quarkus provides the following default Quarkus Test Resource implementations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`H2DatabaseTestResource`'
  prefs: []
  type: TYPE_NORMAL
- en: For starting/stopping H2 database in server mode
  prefs: []
  type: TYPE_NORMAL
- en: '`DerbyDatabaseTestResource`'
  prefs: []
  type: TYPE_NORMAL
- en: For starting/stopping Derby database in server mode
  prefs: []
  type: TYPE_NORMAL
- en: '`InfinispanEmbeddedTestResource`'
  prefs: []
  type: TYPE_NORMAL
- en: For starting/stopping Infinispan in embedded mode
  prefs: []
  type: TYPE_NORMAL
- en: '`InfinispanServerTestResource`'
  prefs: []
  type: TYPE_NORMAL
- en: For starting/stopping Infinispan in server mode
  prefs: []
  type: TYPE_NORMAL
- en: '`KeycloakTestResource`'
  prefs: []
  type: TYPE_NORMAL
- en: For starting/stopping Keycloak identity provider
  prefs: []
  type: TYPE_NORMAL
- en: '`ArtemisTestResource`'
  prefs: []
  type: TYPE_NORMAL
- en: For starting/stopping Embedded ActiveMQ
  prefs: []
  type: TYPE_NORMAL
- en: '`KafkaTestResource`'
  prefs: []
  type: TYPE_NORMAL
- en: For starting/stopping a Kafka cluster using Debezium classes
  prefs: []
  type: TYPE_NORMAL
- en: '`KubernetesMockServerTestResource`'
  prefs: []
  type: TYPE_NORMAL
- en: For starting/stopping Kubernetes Mock server
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can learn more about how to install Docker in your local machine and find
    more examples about Testcontainers test framework at the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Docker: Get Docker](https://oreil.ly/WrfY8)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Testcontainers](https://oreil.ly/aEeAV)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5.20 Testing the Native Executable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to test that the native executable is correct.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use `NativeImageTest` annotation to start the application from the native file
    instead of using the JVM.
  prefs: []
  type: TYPE_NORMAL
- en: If you plan to produce a native executable of your application, it is always
    a good idea to write some behavioral tests against the application running in
    the native executable.
  prefs: []
  type: TYPE_NORMAL
- en: Quarkus provides the `NativeImageTest` annotation to start the application from
    the native file instead of using the JVM. It is important to note that you must
    generate the native executable before running the tests or using the `quarkus.package.type`
    system property to generate the native executable before running the tests. You
    can learn more about how to generate a native executable in the [Recipe 6.4](ch06.xhtml#native_executable)
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: If the project is scaffolded using any of the methods explained before, a native
    executable test is already provided.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: It is not possible to mix JVM and native image tests in the same test suite.
    The JVM tests must be run in a different cycle than the native tests (e.g., in
    Maven, this would be `surefire` for JVM tests and `failsafe` for native tests).
  prefs: []
  type: TYPE_NORMAL
- en: 'This configuration is provided by default when a project is scaffolded by any
    of the methods explained earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_programming_model_CO25-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Native tests are run in `verify` goal (`./mvnw verify`)
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_programming_model_CO25-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The location of the produced native executable (the line should not be split
    in the pom)
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_programming_model_CO25-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Produces a native executable before running tests
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `org.acme.quickstart.NativeGreetingResourceIT.java` class located
    at *src/test/java* directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_programming_model_CO26-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Starts the native executable located at `native.image.path`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_programming_model_CO26-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Extends JVM tests to make them run against native executable. This is not mandatory;
    you can write your tests, but remember to annotate them with `@QuarkusTest`. This
    will run the same test but against the native executable.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: All testing features showed in this section are valid except injecting into
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are some things that you need to take into consideration when writing
    native tests:'
  prefs: []
  type: TYPE_NORMAL
- en: Quarkus waits for 60 seconds for the native image to start before automatically
    failing the native tests. This duration can be changed using the `quarkus.test.native-image-wait-time`
    property (i.e., `./mvnw verify` `-Pnative -Dquarkus.test.native-image-wait-time=200`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Native tests run on `prod` profile; if you want to change that, you can use
    the `quarkus.test.native-image-profile` property to set an alternative profile.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can disable certain test methods (or classes) to be able to run them in
    native tests by annotating them with the `io.quarkus.test.junit.DisabledOnNativeImage`
    annotation (i.e., `@DisabledOnNativeImage @Test public void` `n⁠o⁠n⁠N⁠a⁠t⁠i⁠v⁠e⁠T⁠e⁠s⁠t⁠(⁠)⁠{⁠}`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
