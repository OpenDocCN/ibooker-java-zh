- en: Chapter 5\. Programming Model
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you’ll learn about topics related to the programming model
    of Quarkus. Quarkus is unique in the programming model it follows. Unlike some
    other frameworks, Quarkus allows you to mix and match both an imperative model,
    using CDI, and a reactive model, using SmallRye Mutiny. [Chapter 15](ch15.xhtml#working_with_a_reactive_programming_model_chapter)
    is dedicated to using the reactive approach. At times, you may find yourself needing
    both approaches, so it is good to know how to utilize each.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re focusing on the imperative model, so you’ll learn the
    following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: How to marshal/unmarshal JSON and XML documents
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to validate request parameters
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use the CDI spec as a context and dependency injection solution
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to write tests for a Quarkus service
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5.1 Marshalling/Unmarshalling JSON
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to marshall/unmarshall JSON documents to/from Java objects.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the `JSON-B` specification or Jackson project to marshall and unmarshall
    JSON documents from/to Java objects.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: When you are creating a REST API, you *usually* use JSON as a data format to
    exchange information. So far, you’ve seen examples of returning only simple plain-text
    responses; but in this recipe, you’ll learn how to start using JSON as the data
    format for the body of the request and as a response.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing you need to do is register the *JSON-B* extension in the *pom.xml*.
    Open a terminal window, and from the root directory of the project run the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This effectively adds `io.quarkus:quarkus-resteasy-jsonb` into the build tool.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-16
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In Gradle, you can use `./gradlew addExtension` `--extensions="quarkus-resteasy-jsonb"`
    to add the extension.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to create a `developer` class that will be marshalled and
    unmarshalled in the endpoint. Create a new class named `org.acme.quickstart.Developer.java`:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Finally, you can create a Rest API endpoint for implementing `developer` operations.
    Create a new class named `org.acme.quickstart.DeveloperResource.java`:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Try it by opening a new terminal window, starting the Quarkus application,
    and sending requests for `POST` and `GET` methods:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Notice that each Java field is mapped directly to a JSON field. If you want
    to change that, you can use the `javax.json.bind.annotation.JsonbProperty` annotation
    to set a different mapping name:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Discussion
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can use the Jackson project to marshall/unmarshall JSON documents to/from
    Java objects instead of JSON-B as well. You need to register the `Jackson-Extension`
    to use it as a JSON solution:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'By default, a `com.fasterxml.jackson.databind.ObjectMapper` is provided, but
    you can provide a custom `ObjectMapper` using CDI:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: See Also
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can learn more about JSON-B and Jackson at the following web pages:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[Jakarta JSON Binding (JSON-B)](http://json-b.net)'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Jackson Project Home @GitHub](https://oreil.ly/U3hwH)'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5.2 Marshalling/Unmarshalling XML
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to marshall/unmarshall XML documents to/from Java objects.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the JAX-B specification to marshall and unmarshall XML documents from/to
    Java objects.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 JAX-B 规范将 XML 文档从/到 Java 对象编组和解组。
- en: When you are creating a REST API, you might want to use XML as a data format
    to exchange information. So far, you’ve seen how to do it in JSON format, but
    in this section, you’ll learn how to start using XML as the data format for the
    body of the request and as a response.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当您创建 REST API 时，可能希望使用 XML 作为请求体和响应的数据格式。到目前为止，您已经了解了如何在 JSON 格式中实现它，但在本节中，您将学习如何开始使用
    XML 作为请求体和响应的数据格式。
- en: 'The first thing you need to do is register the JAX-B extension in the *pom.xml*.
    Open a terminal window, and from the root directory of the project run the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要在 *pom.xml* 中注册 JAX-B 扩展。打开一个终端窗口，并从项目的根目录运行以下命令：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This effectively adds `io.quarkus:quarkus-resteasy-jaxb` into the build tool.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上将 `io.quarkus:quarkus-resteasy-jaxb` 添加到构建工具中。
- en: Note
  id: totrans-44
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: In Gradle, you can use `./gradlew addExtension` `--extensions="quarkus-resteasy-jaxb"`
    to add the extension.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Gradle 中，您可以使用 `./gradlew addExtension` `--extensions="quarkus-resteasy-jaxb"`
    来添加扩展。
- en: 'The next step is to create a `computer` class that will be marshalled and unmarshalled
    in the endpoint. Create a new class named `org.acme.quickstart.Computer.java`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建一个 `computer` 类，在端点中将其编组和解组。创建一个名为 `org.acme.quickstart.Computer.java`
    的新类：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[![1](Images/1.png)](#co_programming_model_CO1-1)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_programming_model_CO1-1)'
- en: '`XmlRootElement` sets this as XML document'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`XmlRootElement` 将其设置为 XML 文档'
- en: 'Finally, you can create a REST API endpoint for implementing `computer` operations.
    Create a new class named `org.acme.quickstart.ComputerResource.java`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以创建一个 REST API 端点以实现 `computer` 操作。创建一个名为 `org.acme.quickstart.ComputerResource.java`
    的新类：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Try it by opening a new terminal window, starting the Quarkus application,
    and sending requests for `POST` and `GET` methods:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 通过打开新的终端窗口，启动 Quarkus 应用程序，并发送 `POST` 和 `GET` 方法的请求进行测试：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Discussion
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'Apart from `@XmlRootElement`, there are other important annotations in the
    JAX-B spec:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `@XmlRootElement`，JAX-B 规范中还有其他重要的注解：
- en: '`@XmlRootElement`'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`@XmlRootElement`'
- en: Sets the root XML document. You can also use it to set the name of the element
    or the namespace.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 设置根 XML 文档。您还可以用它来设置元素的名称或命名空间。
- en: '`@XmlType`'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`@XmlType`'
- en: Defines the order in which the fields are written.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 定义字段写入的顺序。
- en: '`@XmlElement`'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`@XmlElement`'
- en: Defines the actual XML element name among other attributes like `namespace`,
    `nillable`, or `required`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 定义实际的 XML 元素名称，以及 `namespace`、`nillable` 或 `required` 等其他属性。
- en: '`@XmlAttribute`'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`@XmlAttribute`'
- en: Defines the field to be mapped as an attribute instead of as an element.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 定义将字段映射为属性而不是元素。
- en: '`@XmlTransient`'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`@XmlTransient`'
- en: Indicates fields not to be included in XML.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 表示不包括在 XML 中的字段。
- en: See Also
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'You can learn more about JAX-B at the following web page:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下网页了解更多关于 JAX-B 的信息：
- en: '[Oracle: Lesson: Introduction to JAXB (The Java Tutorials)](https://oreil.ly/r9FKb)'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Oracle: Lesson: Introduction to JAXB (The Java Tutorials)](https://oreil.ly/r9FKb)'
- en: 5.3 Validating Input and Output Values
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.3 验证输入和输出值
- en: Problem
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to validate the input and output values of your REST and business services.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望验证 REST 和业务服务的输入和输出值。
- en: Solution
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the Bean Validation specification to add validations to your model.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Bean Validation 规范向模型添加验证。
- en: Usually, your model might contain some constraints, whether or not the model
    is semantically valid—for example, that a `name` is not null, or an `email` is
    a valid email. Quarkus integrates with Bean Validation to express constraints
    on object models via annotations.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您的模型可能包含一些约束条件，无论模型是否语义上有效——例如，`name` 不为空，或者 `email` 是有效的电子邮件。Quarkus 通过注解集成
    Bean Validation 来表达对对象模型的约束。
- en: 'The first thing you need to do is register the Bean Validation extension in
    the *pom.xml*. Open a terminal window, and from the root directory of the project
    run the following:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要在 *pom.xml* 中注册 Bean Validation 扩展。打开一个终端窗口，并从项目的根目录运行以下命令：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This effectively adds `io.quarkus:quarkus-hibernate-validator` into the build
    tool.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上将 `io.quarkus:quarkus-hibernate-validator` 添加到构建工具中。
- en: Note
  id: totrans-78
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: In Gradle, you can use `./gradlew addExtension` `--extensions="quarkus-hibernate-validator"`
    to add the extension.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Gradle 中，您可以使用 `./gradlew addExtension` `--extensions="quarkus-hibernate-validator"`
    来添加扩展。
- en: 'The next step is to update the `developer` class and annotate it with some
    constraints. Open the `org.acme.quickstart.Developer.java` class and annotate
    some of the fields:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是更新 `developer` 类，并对其进行一些字段注解。打开 `org.acme.quickstart.Developer.java` 类并对一些字段进行注解：
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[![1](Images/1.png)](#co_programming_model_CO2-1)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_programming_model_CO2-1)'
- en: The minimum size of the string is 4
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串的最小长度为 4
- en: '[![2](Images/2.png)](#co_programming_model_CO2-2)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_programming_model_CO2-2)'
- en: The field is mandatory
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 此字段是必填的
- en: Note
  id: totrans-86
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Either of the available packages is sufficient, but if you want to use only
    the spec APIs, use the `javax` packages.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的包之一就足够了，但是如果您只想使用规范 API，请使用 `javax` 包。
- en: 'Finally, you need to annotate with `javax.validation.Valid` that a parameter
    must be verified. Open the `org.acme.quickstart.DeveloperResource.java` class
    and annotate the `developer` parameter:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您需要使用 `javax.validation.Valid` 注释来验证必须验证的参数。打开 `org.acme.quickstart.DeveloperResource.java`
    类并对 `developer` 参数进行注释：
- en: '[PRE13]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[![1](Images/1.png)](#co_programming_model_CO3-1)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_programming_model_CO3-1)'
- en: '`@Valid` is mandatory to validate the object'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Valid` 是验证对象的必需注解'
- en: 'Try it by opening a new terminal window, starting the Quarkus application,
    and executing requests for the POST method:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试通过打开新的终端窗口，启动 Quarkus 应用程序，并执行 POST 方法的请求来测试它：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: It is important to note that in the first request, the name has an incorrect
    size, hence a 400 Bad Request HTTP code is returned. In the second request, because
    the request body is correct, the method works as expected.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，在第一次请求中，名称的大小不正确，因此返回了 400 Bad Request HTTP 状态码。在第二次请求中，因为请求体是正确的，方法按预期工作。
- en: But notice that if there is an error, the response does not contain any information
    about what has failed. That’s fine because it is important to show the internals
    not directly, but in a controlled way.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 但请注意，如果出现错误，则响应不包含有关失败内容的任何信息。这没关系，因为重要的是以受控的方式显示内部而不是直接显示。
- en: Discussion
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: If you want to provide a better response message, you can provide an implementation
    of `ExceptionMapper`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要提供更好的响应消息，可以提供 `ExceptionMapper` 的实现。
- en: 'Create a new class named `org.acme.quickstart.BeanValidationExceptionMapper.java`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `org.acme.quickstart.BeanValidationExceptionMapper.java` 的新类：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[![1](Images/1.png)](#co_programming_model_CO4-1)'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_programming_model_CO4-1)'
- en: '`@Provider` set an implementation of an extension interface discoverable by
    the JAX-RS runtime'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Provider` 设置一个扩展接口的实现，由 JAX-RS 运行时发现'
- en: '[![2](Images/2.png)](#co_programming_model_CO4-2)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_programming_model_CO4-2)'
- en: '`javax.ws.rs.ext.ExceptionMapper` is used to transform an exception into a
    `javax.ws.rs.core.Response`'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`javax.ws.rs.ext.ExceptionMapper` 用于将异常转换为 `javax.ws.rs.core.Response`'
- en: '[![3](Images/3.png)](#co_programming_model_CO4-3)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_programming_model_CO4-3)'
- en: Creates an array of constraint violations
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个约束违规的数组
- en: '[![4](Images/4.png)](#co_programming_model_CO4-4)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](Images/4.png)](#co_programming_model_CO4-4)'
- en: Iterates over each of the constraint violations
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历每个约束违规
- en: '[![5](Images/5.png)](#co_programming_model_CO4-5)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](Images/5.png)](#co_programming_model_CO4-5)'
- en: Creates a JSON object
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个 JSON 对象
- en: 'Now you can send a request for the POST method again:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以再次发送 POST 方法的请求：
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The output is now slightly different. The error code is still the same, a 400
    Bad Request, but now the body content of the response contains the JSON document
    that we created in the exception mapper.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在输出略有不同。错误代码仍然是相同的，400 Bad Request，但是现在响应体的内容包含了我们在异常映射器中创建的 JSON 文档。
- en: 'You can also validate the output parameters (the parameters you send back to
    the caller) by adding `@Valid` annotation in the return type:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过在返回类型中添加 `@Valid` 注解来验证输出参数（发送回调用者的参数）：
- en: '[PRE17]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Moreover, sometimes you don’t want to add validation rules at the endpoint
    but at the business service layer. Bean Validation can be used in your business
    service if you’re using CDI. See the following example:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，有时您不希望在端点上添加验证规则，而是希望在业务服务层上添加。如果您使用 CDI，可以在业务服务中使用 Bean Validation。参见以下示例：
- en: '[PRE18]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: See Also
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'If you want to learn more about Bean Validations and what constraints are implemented
    by default (i.e., `@Min`, `@Max`, `@AssertTrue`, `@Email`, and so on), you can
    find the information at the following website:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想进一步了解 Bean Validation 和默认实施的约束（如 `@Min`、`@Max`、`@AssertTrue`、`@Email` 等），可以在以下网站找到信息：
- en: '[Jakarta Bean Validation](https://oreil.ly/YHR_X)'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Jakarta Bean Validation](https://oreil.ly/YHR_X)'
- en: 5.4 Creating Custom Validations
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.4 创建自定义验证
- en: Problem
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to create custom validations.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 您想要创建自定义验证。
- en: Solution
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the Bean Validation extension model by implementing the `javax.validation.ConstraintValidator`
    interface.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实现 `javax.validation.ConstraintValidator` 接口使用 Bean Validation 扩展模型。
- en: Sometimes the default constraints provided by the Bean Validation specification
    are not enough, and you will want to implement constraints that more closely align
    with your business model. Bean Validation allows you to do that by creating a
    class that implements the `javax.validation.ConstraintValidator` interface and
    the annotation for annotating the field to be validated.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，Bean验证规范提供的默认约束不足以满足您的需求，您需要实现更符合业务模型的约束。Bean验证允许您通过创建一个实现 `javax.validation.ConstraintValidator`
    接口和用于注释要验证的字段的注释来实现这一点。
- en: 'Let’s validate that your favorite language can only be a JVM-based language.
    First of all, you need to create the annotation. Create a new class named `org.acme.quickstart.JvmLanguage.java`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们验证您最喜欢的语言只能是基于JVM的语言。首先，您需要创建注释。创建一个名为 `org.acme.quickstart.JvmLanguage.java`
    的新类：
- en: '[PRE19]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[![1](Images/1.png)](#co_programming_model_CO5-1)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_programming_model_CO5-1)'
- en: Raises the constraint as a normal compilation error
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 将约束错误作为普通编译错误引发
- en: Then you need to create the logic to detect any constraint violation. This new
    class must implement the `javax.validation.ConstraintValidator` interface.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您需要创建检测任何约束违规的逻辑。这个新类必须实现 `javax.validation.ConstraintValidator` 接口。
- en: 'Next, create a class named `org.acme.quickstart.JvmLanguageValidator.java`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个名为 `org.acme.quickstart.JvmLanguageValidator.java` 的类：
- en: '[PRE20]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[![1](Images/1.png)](#co_programming_model_CO6-1)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_programming_model_CO6-1)'
- en: The annotation defined in previous step
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面步骤中定义的注释
- en: '[![2](Images/2.png)](#co_programming_model_CO6-2)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_programming_model_CO6-2)'
- en: The type of object that the validation applies
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 验证应用的对象类型
- en: '[![3](Images/3.png)](#co_programming_model_CO6-3)'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_programming_model_CO6-3)'
- en: Checks if the provided favorite language (`value`) is a JVM-based language
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 检查提供的喜爱语言（`value`）是否是基于JVM的语言
- en: 'Finally, you need to annotate the `favoriteLanguage` field from `org.acme.quickstart.Developer`
    class:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您需要注释 `org.acme.quickstart.Developer` 类中的 `favoriteLanguage` 字段：
- en: '[PRE21]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Try it by opening a new terminal window, starting the Quarkus application,
    and sending some requests to the POST method:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 通过打开一个新的终端窗口，启动Quarkus应用程序，并向POST方法发送一些请求来尝试它：
- en: '[PRE22]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Discussion
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Any validations following the Bean Validation specification on your REST endpoints,
    services methods, and ultimately any CDI-scoped object will be automatically executed
    during the run of your application. If you need something with more control, see
    the next recipe, [Recipe 5.5](#validate-objects-programmatically), for additional
    means of validating objects.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的REST端点、服务方法以及最终任何CDI作用域对象上遵循Bean验证规范的任何验证将在应用运行期间自动执行。如果您需要更多控制，请参阅下一个配方，[配方
    5.5](#validate-objects-programmatically)，以获取验证对象的额外方法。
- en: 'It is also good to know that, by default, constraint violation messages will
    be returned using the system locale. If you would like to change this, you can
    do so in the *application.properties* file by setting the `quarkus.default-locale`
    setting:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 还值得注意的是，默认情况下，约束违规消息将使用系统语言环境返回。如果您想要更改此设置，可以在 *application.properties* 文件中设置
    `quarkus.default-locale` 设置：
- en: '[PRE23]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'For REST endpoints, the locale will be based on the `Accept-Language` HTTP
    header. You can specify a list of supported locales in the *application.properties*
    file:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 对于REST端点，语言环境将基于 `Accept-Language` HTTP 头。您可以在 *application.properties* 文件中指定支持的语言环境列表：
- en: '[PRE24]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: See Also
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'For more information, visit the following websites:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多信息，请访问以下网站：
- en: '[Jakarta Bean Validation](https://oreil.ly/R6L4d)'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[雅加达Bean验证](https://oreil.ly/R6L4d)'
- en: '[Hibernate Validator](https://oreil.ly/O7BNR)'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Hibernate验证器](https://oreil.ly/O7BNR)'
- en: 5.5 Validating Objects Programmatically
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.5 验证对象的编程方式
- en: Problem
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to validate objects programmatically.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望以编程方式验证对象。
- en: Solution
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the Bean Validation `javax.validation.Validator` class.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Bean验证 `javax.validation.Validator` 类。
- en: In some circumstances (for example, in non-CDI beans) you want to control when
    the validation process is executed. For this reason, `javax.validation.Validator`
    class is provided.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下（例如非CDI bean中），您希望控制何时执行验证过程。因此，提供了 `javax.validation.Validator` 类。
- en: 'Let’s create an endpoint that validates the input using `javax.validation.Validator`
    instead of using a declarative way with `@Valid` annotations. Open the `org.acme.quickstart.DeveloperResource.java`
    class and inject `Validator` instance:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个端点，使用 `javax.validation.Validator` 验证输入，而不是使用 `@Valid` 注解的声明方式。打开 `org.acme.quickstart.DeveloperResource.java`
    类并注入 `Validator` 实例：
- en: '[PRE25]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[![1](Images/1.png)](#co_programming_model_CO7-1)'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_programming_model_CO7-1)'
- en: Inject `Validator` class from Bean Validation spec
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 从Bean验证规范中注入`Validator`类
- en: '[![2](Images/2.png)](#co_programming_model_CO7-2)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_programming_model_CO7-2)'
- en: '`@Valid` is not required'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要`@Valid`
- en: '[![3](Images/3.png)](#co_programming_model_CO7-3)'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_programming_model_CO7-3)'
- en: Validate the object programmatically
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 以编程方式验证对象
- en: '[![4](Images/4.png)](#co_programming_model_CO7-4)'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](Images/4.png)](#co_programming_model_CO7-4)'
- en: If there are no errors, proceed
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有错误，请继续
- en: '[![5](Images/5.png)](#co_programming_model_CO7-5)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](Images/5.png)](#co_programming_model_CO7-5)'
- en: If there are errors, then build the output
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有错误，则构建输出
- en: 'Try it by opening a new terminal window, starting the Quarkus application,
    and sending a request for the new POST method:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 通过打开新的终端窗口，启动Quarkus应用程序，并发送新的POST方法请求来尝试它：
- en: '[PRE26]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Discussion
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'Quarkus will automatically create an instance of the `javax.validation.ValidatorFactory`.
    You can tweak this a little by creating your own replacement beans. An instance
    of the following types in your application will automatically be injected into
    the `ValidatorFactory`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Quarkus将自动创建`javax.validation.ValidatorFactory`的实例。 您可以通过创建自己的替代bean稍微调整这一点。
    您的应用程序中以下类型的实例将自动注入到`ValidatorFactory`中：
- en: '`javax.validation.ClockProvider`'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javax.validation.ClockProvider`'
- en: '`javax.validation.ConstraintValidator`'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javax.validation.ConstraintValidator`'
- en: '`javax.validation.ConstraintValidatorFactory`'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javax.validation.ConstraintValidatorFactory`'
- en: '`javax.validation.MessageInterpolator`'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javax.validation.MessageInterpolator`'
- en: '`javax.validation.ParameterNameProvider`'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javax.validation.ParameterNameProvider`'
- en: '`javax.validation.TraversableResolver`'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javax.validation.TraversableResolver`'
- en: '`org.hibernate.validator.spi.properties.GetterPropertySelectionStrategy`'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.hibernate.validator.spi.properties.GetterPropertySelectionStrategy`'
- en: '`org.hibernate.validator.spi.scripting.ScriptEvaluatorFactory`'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.hibernate.validator.spi.scripting.ScriptEvaluatorFactory`'
- en: Note
  id: totrans-183
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You may have only one instance of a particular type in the preceding list, and
    classes should be declared as `@ApplicationScoped`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述列表中，您可能只有一个特定类型的实例，并且类应声明为`@ApplicationScoped`。
- en: 5.6 Injecting Dependencies
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.6 注入依赖项
- en: Problem
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to inject dependencies into your classes.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 您想将依赖项注入到您的类中。
- en: Solution
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use Contexts and Dependency Injection (CDI).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上下文和依赖注入（CDI）。
- en: Discussion
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Dependency injection (DI) in Quarkus, which is based on the [Contexts and Dependency
    Injection 2.0 specification](https://oreil.ly/VcDnN), is pretty standard, with
    only a few modifications needed for the basic use case.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Quarkus中的依赖注入（DI）基于[上下文和依赖注入2.0规范](https://oreil.ly/VcDnN)，非常标准，仅需对基本用例进行少量修改。
- en: Note
  id: totrans-192
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Quarkus implements most of the specification, except for some corner cases that
    should not affect your code. The Quarkus website maintains a list of supported
    features and limitations, including more advanced features that are not covered
    here in the book. You can find those lists in the [Quarkus CDI Reference Guide](https://oreil.ly/-LPAd).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Quarkus实现了大部分规范，除了一些不会影响您的代码的边缘情况。 Quarkus网站维护了一个支持的特性和限制列表，包括这本书中未涵盖的更高级特性。
    您可以在[Quarkus CDI参考指南](https://oreil.ly/-LPAd)中找到这些列表。
- en: 'Injection happens just as you would expect in any other application using CDI:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 注入的方式与使用CDI的任何其他应用程序一样符合预期：
- en: '[PRE27]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[![1](Images/1.png)](#co_programming_model_CO8-1)'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_programming_model_CO8-1)'
- en: Use of the `@Inject` annotation is required
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 需要使用`@Inject`注解
- en: '[![2](Images/2.png)](#co_programming_model_CO8-2)'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_programming_model_CO8-2)'
- en: Due to restrictions on reflection, package-private injection fields are preferred
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 由于反射的限制，优选包私有注入字段
- en: 'The injected service is pretty standard and without any surprises:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 注入的服务非常标准，没有任何意外：
- en: '[PRE28]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[![1](Images/1.png)](#co_programming_model_CO9-1)'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_programming_model_CO9-1)'
- en: As mentioned in the following, you should include a bean-defining annotation
    that allows classes to be found
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所述，您应包括一个定义bean的注解，允许找到类
- en: Bean discovery in Quarkus follows a simplified process from standard CDI. In
    short, if your application classes do not have a [bean-defining annotation](https://oreil.ly/jm4QF),
    they will not be picked up by Quarkus.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: Quarkus中的Bean发现遵循从标准CDI简化的过程。 简而言之，如果您的应用程序类没有[定义bean的注解](https://oreil.ly/jm4QF)，它们将不会被Quarkus选择。
- en: See Also
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'To learn more, see the following web pages:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多，请参阅以下网页：
- en: '[JBoss: JSR 365: Contexts and Dependency Injection for Java 2.0](https://oreil.ly/clOD4)'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[JBoss: JSR 365: Java上下文和依赖注入2.0](https://oreil.ly/clOD4)'
- en: '[GitHub: GraalVM Native Image Compatibility and Optimization Guide](https://oreil.ly/7sgPm)'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5.7 Creating Factories
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to create a factory for an object.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the `javax.enterise.inject.Produces` concept from CDI.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: 'CDI has a concept called *producers* that allows you to do any sort of object
    creation necessary to add a new bean or class to the list of resolvable instances,
    like this:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Discussion
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Quarkus takes the producers concept a little further. Quarkus does so by adding
    the `@io.quarkus.arc.DefaultBean` annotation. In terms of CDI, this is like an
    enabled default alternative. Because Quarkus does not allow for alternatives,
    a class annotated with `DefaultBean` gives you a way to create a default instance
    of a bean. The following code is an example pulled from the Quarkus website:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The following excerpt allows your application or library to inject a tracer
    wherever necessary. It also allows for customization by creating a new producer:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: With this code in your application, the `Reporter` created from the `CustomTracerConfiguration`
    class will be used instead of the default.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To learn more, visit the following web page:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[JBoss: JSR 365: Contexts and Dependency Injection for Java 2.0](https://oreil.ly/4-OrV)'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5.8 Executing Object Life Cycle Events
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to execute logic before and/or after objection creation/destruction.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'CDI makes use of the `@javax.annotation.PostConstruct` and `@javax.annotation.PreDestroy`
    annotations for life cycle management. The methods annotated with those annotations
    will be called after object creation for `PostConstruct` and before the object
    is destroyed for `PreDestroy`:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Discussion
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If there is logic that needs to happen after the constructor is called and after
    all the injections happen, it should go into a method annotated with the `@PostConstruct`
    annotation. This is guaranteed to be called only once in the lifetime of an object
    instance.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, if logic needs to be executed before the object is destroyed, place
    it in a method annotated with the `@PreDestroy` annotation. Ideas for this would
    include closing connections, cleaning up resources, and finalizing logging.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To learn more, see the following pages on GitHub:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[Common Annotations API: PostConstruct.java](https://oreil.ly/UxdG2)'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Common Annotations API: PreDestroy.java](https://oreil.ly/qsZUC)'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5.9 Executing Application Life Cycle Events
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to execute logic at application startup and/or after application shutdown.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Observe the `io.quarkus.runtime.StartupEvent` and the `io.quarkus.runtime.ShutdownEvent`.
    During application startup, Quarkus will fire the `StartupEvent`; and during shutdown,
    the `ShutdownEvent`, like this:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[![1](Images/1.png)](#co_programming_model_CO10-1)'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: You must add a bean-defining annotation
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_programming_model_CO10-2)'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: The startup event that is fired
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_programming_model_CO10-3)'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: The shutdown event that Quarkus fires
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Neither of these event objects carry any additional information, so there is
    not anything else to cover.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Event observation is a very powerful way in Quarkus (and in other CDI frameworks)
    to decouple concerns with minimal overhead.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For more, see [Recipe 5.8](#executing-obj-lifecycle-events).
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: 5.10 Using a Named Qualifier
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to qualify an injection with a name.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the `@javax.inject.Named` annotation.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: In CDI, a *qualifier* is any annotation defined as `@Retention(RUNTIME)` and
    annotated with `@javax.inject.Qualifier`. Qualifiers are typically defined so
    that they can be used everywhere you need them as `@Target({METHOD, FIELD, PARAMETER,
    TYPE})`.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: 'CDI comes with a useful qualifier: `@javax.inject.Named`. The value isn’t required,
    but it doesn’t make sense to use `@Named` without an actual name. When resolving
    an injection point, CDI will look for any beans of the correct type that also
    contain the same qualifier. In the case of `@Named`, the value part of the annotation
    must match as well.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: 'This is very useful if you have multiple instances of a type, but they are
    not the same object. CDI doesn’t take into consideration the actual instance of
    the object because that isn’t known until it is created and will be different
    each time anyway. To get around this problem, CDI uses qualifiers:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Discussion
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For completeness, this is a way to produce named beans:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '`@Named` qualification, though weak—which is one of the things CDI tries to
    avoid—can be a useful trick during integrations. We recommend using strongly typed
    annotations where possible.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For more information, visit the following web page:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[JBoss: qualifier @Named at injection points](https://oreil.ly/5NydQ)'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5.11 Using Custom Qualifiers
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to qualify an injection with some other qualifier annotation.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Develop and use qualifier annotations.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Recipe 5.10](#named_qualifier), you were introduced to the idea of a qualifier:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Producing the bean is exactly as you would expect:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Then, of course, injecting the newly qualified instance is just as easy:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Discussion
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using qualifier annotations is the preferred way to use qualified CDI injections
    both in a normal CDI application and in Quarkus.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For more information, visit the following web page:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '[JBoss: Qualifiers](https://oreil.ly/MOfwa)'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5.12 Qualifying and Configuring Annotations
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to qualify and configure a dependency using annotations.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using a combination of `InjectionPoint` in a producer and nonbinding attributes
    on the qualifier annotation, it is possible to both qualify and configure a bean.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: 'This is an interesting, albeit atypical, use case for qualifiers and producers.
    Take a look at the following code to see it in action:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[![1](Images/1.png)](#co_programming_model_CO11-1)'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: The attributes are listed as nonbinding, so injections actually work.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: 'Normally, the attributes of a qualifier are considered for injections, so if
    the attributes don’t match, the qualified object will not be injected:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，限定符的属性被认为是注入的依据，因此如果属性不匹配，将不会注入限定对象：
- en: '[PRE40]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[![1](Images/1.png)](#co_programming_model_CO12-1)'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_programming_model_CO12-1)'
- en: Only the default attributes on the producer
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 只有生产者上的默认属性
- en: '[![2](Images/2.png)](#co_programming_model_CO12-2)'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_programming_model_CO12-2)'
- en: Get the instance of the qualifier to pull configuration from the attributes
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 获取限定符的实例以从属性中提取配置
- en: '[![3](Images/3.png)](#co_programming_model_CO12-3)'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_programming_model_CO12-3)'
- en: Return the newly configured object
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 返回新配置的对象
- en: 'Usage is exactly the same as any other qualifier:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方式与任何其他限定符完全相同：
- en: '[PRE41]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: See Also
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'For more information, visit the following web page:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解更多信息，请访问以下网页：
- en: '[JBoss: Injection point metadata](https://oreil.ly/BVmV2)'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[JBoss：注入点元数据](https://oreil.ly/BVmV2)'
- en: 5.13 Creating Interceptors
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.13 创建拦截器
- en: Problem
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to implement cross-cutting concerns.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望实现横切关注点。
- en: Solution
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: A *cross-cutting concern* is an aspect that affects other concerns of a program.
    The textbook example of this is *transaction control*. It is an action that affects
    the use of data in your program and must always be addressed, often in the same
    or similar manner.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '*横切关注点* 是影响程序其他关注点的一个方面。其典型示例是 *事务控制*。它是一种影响程序中数据使用的行为，通常必须以相同或类似的方式处理。'
- en: Create `@javax.inject.AroundInvoke` and `@javax.inject.AroundConstruct` interceptors
    with the corresponding interceptor bindings. You are also able to create CDI stereotypes
    to better compose concerns into a single annotation.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 创建带有相应拦截器绑定的 `@javax.inject.AroundInvoke` 和 `@javax.inject.AroundConstruct`
    拦截器。您还可以创建 CDI 类型化注解，以更好地组合关注点到单个注解中。
- en: 'To start, create an annotation with the `@javax.interceptor.InterceptorBinding`
    annotation. This will be used to link up the actual interceptor code and to annotate
    any of the methods or classes you wish to be intercepted:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个带有 `@javax.interceptor.InterceptorBinding` 注解的注释。这将用于将实际的拦截器代码与要拦截的任何方法或类进行关联注释：
- en: '[PRE42]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Nothing special going on there. Next, you need to create the interceptor:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 那里没有什么特别的。接下来，您需要创建拦截器：
- en: '[PRE43]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This is a pretty contrived example, but it is easy to understand what is happening.
    Lastly, you simply need to annotate a method or class with the binding annotation:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当牵强的例子，但很容易理解正在发生的事情。最后，您只需使用绑定注解对方法或类进行注释：
- en: '[PRE44]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Every time the `executeOrder` method is called, the method in the interceptor
    that is annotated with `@javax.interceptor.AroundInvoke`, `logEvent` in this case,
    will be called before the actual `executeOrder` method is called.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用 `executeOrder` 方法时，都会在实际调用 `executeOrder` 方法之前调用带有 `@javax.interceptor.AroundInvoke`
    注解的拦截器方法，本例中为 `logEvent`。
- en: Discussion
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Interceptors are very easy to implement in Quarkus using the standard CDI mechanism.
    This provides a simple way to define and utilize cross-cutting actions in your
    application.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Quarkus 中使用标准的 CDI 机制非常容易实现拦截器。这提供了在应用程序中定义和利用横切动作的简单方式。
- en: Aspect-oriented programming (AOP) has been around for quite some time, since
    1997 to be exact. A team at Xerox PARC lead by Gregor Kiczales created and termed
    cross-cutting and aspect-oriented programming. Some claim the Microsoft Transaction
    Server was the first widely adopted instance of AOP. Eventually, Enterprise JavaBeans
    developed AOP aspects. There’s also Spring and AspectJ in the Java ecosystem.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 面向切面编程（AOP）已经存在很长时间了，确切地说是自 1997 年以来。由 Gregor Kiczales 领导的 Xerox PARC 团队创造并称为横切和面向切面编程。有人声称
    Microsoft Transaction Server 是第一个被广泛采纳的 AOP 实例。最终，企业 JavaBeans 开发了 AOP 方面。Java
    生态系统中还有 Spring 和 AspectJ。
- en: However, we are talking about CDI and Quarkus. Quarkus ArC (the dependency injection
    flavor in Quarkus), the name of which is a play on arc welding, makes use of the
    same concepts.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，我们在谈论 CDI 和 Quarkus。Quarkus ArC（Quarkus 中的依赖注入风格）的名字是对电弧焊接的一种戏仿，使用了相同的概念。
- en: See Also
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'For more information, check out the following:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解更多信息，请查看以下内容：
- en: '*Essential.NET, Volume 1: The Common Language Runtime* by Don Box and Chris
    Sells (Addison-Wesley Professional)'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Essential.NET, Volume 1: The Common Language Runtime*，作者 Don Box 和 Chris Sells（Addison-Wesley
    Professional）'
- en: '[JBoss: Interceptor bindings](https://oreil.ly/QlAGP)'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[JBoss：拦截器绑定](https://oreil.ly/QlAGP)'
- en: '[Stack Overflow: What does ArC mean?](https://oreil.ly/0BpNz)'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Stack Overflow：ArC 是什么意思？](https://oreil.ly/0BpNz)'
- en: 5.14 Writing Behavioral Tests
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.14 编写行为测试
- en: Problem
  id: totrans-332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to write behavioral tests to verify the correctness of service without
    verifying its internals.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望编写行为测试以验证服务的正确性，而不验证其内部。
- en: Solution
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Quarkus’s testing solution is based on [JUnit 5](https://oreil.ly/bh494), the
    de facto testing tool in the Java ecosystem, and provides tight integration with
    [REST-Assured](http://rest-assured.io) testing framework for validating RESTful
    Web APIs.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: Quarkus的测试解决方案基于[JUnit 5](https://oreil.ly/bh494)，这是Java生态系统中的事实上的测试工具，并与[REST-Assured](http://rest-assured.io)测试框架紧密集成，用于验证RESTful
    Web API。
- en: Important
  id: totrans-336
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 重要提示
- en: Using REST-Assured is not mandatory; it is just a recommendation or best practice,
    so you can use any other framework that you prefer for testing endpoints.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 使用REST-Assured并非强制要求；这只是一个建议或最佳实践，因此您可以选择任何其他您喜欢的框架来测试端点。
- en: 'The most important part of the Quarkus testing framework is an annotation called
    `QuarkusTest`. When you annotate a test class with this annotation, you are effectively
    marking that test to be executed within the Quarkus test framework, which instructs
    the test to follow the following life cycle:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: Quarkus测试框架的最重要部分是一个叫做`QuarkusTest`的注解。当您用这个注解标记一个测试类时，您实际上是在Quarkus测试框架内执行该测试，这指示测试要遵循以下生命周期：
- en: The Quarkus application is automatically started once. When the application
    has been booted up and is ready to start serving requests, the test execution
    is started.
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Quarkus应用程序会自动启动一次。当应用程序启动并准备好开始处理请求时，测试执行就会开始。
- en: Each test is executed against this running instance.
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个测试都针对此运行实例执行。
- en: The Quarkus application is stopped.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Quarkus应用程序已停止。
- en: Warning
  id: totrans-342
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: To minimize the impact of running tests in terms of performance, the Quarkus
    application is started only once, and then all test classes defined in the testing
    plan are executed against this running instance, so the application is not restarted
    for each test class execution.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 为了尽量减少性能方面运行测试的影响，Quarkus应用程序仅启动一次，然后执行测试计划中定义的所有测试类针对此运行实例执行，因此不会为每个测试类的执行重新启动应用程序。
- en: 'Open the `org.acme.quickstart.GreetingResourceTest.java` class located at *src/test/java*
    directory:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 打开位于*src/test/java*目录下的`org.acme.quickstart.GreetingResourceTest.java`类：
- en: '[PRE45]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[![1](Images/1.png)](#co_programming_model_CO13-1)'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_programming_model_CO13-1)'
- en: Sets this test as a Quarkus test
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 将此测试标记为Quarkus测试
- en: '[![2](Images/2.png)](#co_programming_model_CO13-2)'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_programming_model_CO13-2)'
- en: REST-Assured static method to start the validation
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: REST-Assured的静态方法开始验证
- en: '[![3](Images/3.png)](#co_programming_model_CO13-3)'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_programming_model_CO13-3)'
- en: Sends a request using GET HTTP method to `/hello` path
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 使用GET HTTP方法发送请求到`/hello`路径
- en: '[![4](Images/4.png)](#co_programming_model_CO13-4)'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](Images/4.png)](#co_programming_model_CO13-4)'
- en: Starts the assertion section
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 开始断言部分
- en: You can run the test from your IDE as well, as shown in [Figure 5-1](#testvscode).
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以从您的IDE中运行测试，就像在[图 5-1](#testvscode)中展示的那样。
- en: '![qucb 0501](Images/qucb_0501.png)'
  id: totrans-355
  prefs: []
  type: TYPE_IMG
  zh: '![qucb 0501](Images/qucb_0501.png)'
- en: Figure 5-1\. Visual Studio Code with Java integration
  id: totrans-356
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-1\. 具有Java集成的Visual Studio Code
- en: 'Or if you want to run the test in a terminal window, run the following:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 或者如果您想在终端窗口中运行测试，请运行以下命令：
- en: '[PRE46]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[![1](Images/1.png)](#co_programming_model_CO14-1)'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_programming_model_CO14-1)'
- en: Quarkus listens on port 8081 when running tests
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行测试时，Quarkus监听8081端口
- en: '[![2](Images/2.png)](#co_programming_model_CO14-2)'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_programming_model_CO14-2)'
- en: The `test` profile is activated
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '`test`配置文件已激活'
- en: As you’ve seen in the previous example, port 8081 is the default port used when
    tests are executed.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的例子所示，测试执行时使用的默认端口是8081。
- en: Discussion
  id: totrans-364
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'You can change the port used by tests by setting the `quarkus.http.test-port`
    property to a different value:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过将`quarkus.http.test-port`属性设置为不同的值来更改测试使用的端口：
- en: '[PRE47]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Because Quarkus offers nice integration with REST-Assured, it automatically
    updates the port used, so no additional configuration is required in that part.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 因为Quarkus与REST-Assured有良好的集成，它会自动更新所使用的端口，因此在那部分不需要额外的配置。
- en: Tip
  id: totrans-368
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: 'In some scenarios, you might want to run tests in a random port instead of
    a specific one. This is also supported by Quarkus; the only thing you need to
    set is the `quarkus.http.test-port` property to zero (`0`):'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些场景下，您可能希望在随机端口而不是特定端口上运行测试。Quarkus也支持这一点；您唯一需要做的是将`quarkus.http.test-port`属性设置为零（`0`）：
- en: '[PRE48]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Quarkus supports writing behavioral tests, which are tests that validate the
    functionality of a service without knowing or verifying the internals of the service.
    [Figure 5-2](#behavioral-testing-fig) shows the nature of behavioral testing.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: In the case of REST APIs and microservices in general, you can understand a
    behavioral test as a form of test that follows the schema of sending a request
    to a running instance of the service and validating that the response is the expected
    one.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: '![qucb 0502](Images/qucb_0502.png)'
  id: totrans-374
  prefs: []
  type: TYPE_IMG
- en: Figure 5-2\. Behavioral testing
  id: totrans-375
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you have scaffolded the project using any of the methods explained in [Chapter 1](ch01.xhtml#quarkus_overview_chapter),
    you should already have a completed behavioral test, including the required dependencies
    registered at your build tool script.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  id: totrans-377
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you want to learn more about the underlying technologies used by the Quarkus
    testing framework, you can visit the following websites:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: '[JBoss: JUnit 5 User Guide](https://oreil.ly/oahZK)'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[REST-Assured](http://rest-assured.io)'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5.15 Writing Unit Tests
  id: totrans-381
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  id: totrans-382
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to write unit tests to verify the correctness of the internals of the
    service.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-384
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the Quarkus testing solution based on [JUnit 5](https://oreil.ly/oahZK)
    and its integration with CDI.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: Quarkus allows you to inject CDI beans into your tests via the `@Inject` annotation.
    In fact, under the covers, a test in Quarkus is just a CDI bean, so everything
    that it is valid in a bean is also valid in a test.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a Greeting Service bean that uses Bean Validation to verify its
    input parameters. Remember to add the `quarkus-hibernate-validator` extension.
    Create a new class `org.acme.quickstart.GreetingService.java`:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[![1](Images/1.png)](#co_programming_model_CO15-1)'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: Sets service as CDI bean
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_programming_model_CO15-2)'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: Adds validation in the method
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you want to test that Greeting Service works as expected in the next three
    cases:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: When the user age is less than 16, an exception is thrown.
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the user age is between 16 and 18, the teenager’s message is returned.
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the user age is greater than 18, return the message for adults.
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We recommend that you use the [AssertJ](https://oreil.ly/d5tI2) project to
    write readable assertions. To use it, you need to register the AssertJ dependency
    in the build script:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Create a new class `org.acme.quickstart.GreetingService.java` at *src/test/java*
    directory:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[![1](Images/1.png)](#co_programming_model_CO16-1)'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: Sets this test as a Quarkus test
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_programming_model_CO16-2)'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: Injects `GreetingService` instance
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_programming_model_CO16-3)'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: Executes tests using the Greeting Service instance created by CDI container
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_programming_model_CO16-4)'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: Uses AssertJ assertions
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: 'Try it by opening a new terminal window and running tests:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Notice that the Quarkus application is started once but both test classes are
    executed.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  id: totrans-412
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the [Recipe 5.14](#behavioral_tests) recipe, you learned how to write tests
    using a behavioral approach in which you care only about requests and responses
    of the service. However, more often than not, you want to validate what’s happening
    inside the service, or you want to validate how some pieces are behaving inside
    a running instance without having to mock the environment. This is typically required
    when you want to validate that a business object works as expected, which includes
    its integration with the features provided by Quarkus (Bean Validation, CDI, etc.).
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  id: totrans-414
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To learn more about AssertJ, visit the following web page:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: '[AssertJ: fluent assertions java library](https://oreil.ly/d5tI2)'
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5.16 Creating Mock Objects
  id: totrans-417
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  id: totrans-418
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to test classes that require extra processing time or need to communicate
    with external systems.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-420
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use mock support in Quarkus to provide CDI objects that mimic the behavior of
    real objects by replacing the default ones.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: '*Mock objects* are simulated objects that simulate the behavior of real objects
    by providing some canned answer to a method call.'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: Let’s mock the Greeting Service that was created in the [Recipe 5.15](#writing_unit_tests)
    recipe.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new class `org.acme.quickstart.MockedGreetingService.java` at *src/test/java*
    directory:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[![1](Images/1.png)](#co_programming_model_CO17-1)'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: Mark POJO as a mocked class (alternative class) in CDI
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_programming_model_CO17-2)'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: The class must extend or implement the base service
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_programming_model_CO17-3)'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: Canned answer
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  id: totrans-432
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Creating mocks is not only a great way to bypass external services and longer
    running processes, but also a simple way of testing particular scenarios. In the
    previous solution, there could be two tests: one using the mock and the other
    using the actual object. One would demonstrate the expected behavior by the service,
    and the other could demonstrate an expected failure. This technique is especially
    useful for testing external service failures.'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: 5.17 Creating Mock Objects with Mockito
  id: totrans-434
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  id: totrans-435
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using Mockito, you want to test classes that require extra processing time or
    need to communicate with external systems.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-437
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the Mockito library to provide CDI objects that mimic the behavior of real
    objects by replacing the default ones.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: Using Mockito, let’s mock the Greeting Service that was created in the [Recipe
    5.15](#writing_unit_tests) recipe.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing to do is add the Quarkus Mockito extension:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Create a new class `org.acme.quickstart.GreetingResourceTest.java` at *src/main/java*
    directory:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[![1](Images/1.png)](#co_programming_model_CO18-1)'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: '`InjectMock` makes this field a Mockito mock'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_programming_model_CO18-2)'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: Before each test execution, the mock expectations are recorded
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_programming_model_CO18-3)'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: The message that is returned is the mocked one
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: 5.18 Grouping Several Annotations into One
  id: totrans-450
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: with a Meta-Annotation
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: Problem
  id: totrans-452
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to avoid the population of annotations in your application.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望避免在应用程序中进行注解的填充。
- en: Solution
  id: totrans-454
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use meta-annotations to group several annotations into one.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 使用元注解将多个注解分组成一个。
- en: You can develop a meta-annotation that contains all the annotations required
    by the tests or other portions of your application. For example, you could create
    a `TransactionalQuarkusTest` annotation that contains both `@QuarkusTest` and
    `@Transactional` annotations, making a Quarkus test transactional by default if
    this newly created annotation is used.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以开发一个包含测试或应用程序其他部分所需的所有注解的元注解。例如，您可以创建一个`TransactionalQuarkusTest`注解，其中包含`@QuarkusTest`和`@Transactional`注解，如果使用此新创建的注解，则默认情况下使Quarkus测试具有事务性。
- en: 'Create a new class called `org.acme.quickstart.TransactionalQuarkusTest.java`
    in the *src/test/java* directory:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 在*src/test/java*目录下创建一个名为`org.acme.quickstart.TransactionalQuarkusTest.java`的新类：
- en: '[PRE57]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[![1](Images/1.png)](#co_programming_model_CO19-1)'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_programming_model_CO19-1)'
- en: Adds the annotations that this meta-annotation might “inherit”
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 添加此元注解可能“继承”的注解
- en: '[![2](Images/2.png)](#co_programming_model_CO19-2)'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_programming_model_CO19-2)'
- en: Sets the annotation as a stereotype (meta-annotation)
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 将注解设置为元注解（元注解）
- en: 'If you then apply this annotation to a class, it will be like you had applied
    both the `@QuarkusTest` and the `@Transactional` annotations:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 如果然后将此注解应用于类，则会像应用了`@QuarkusTest`和`@Transactional`注解一样：
- en: '[PRE58]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Notice that now the test is more readable and the annotations are reusable.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 注意现在测试更易读且注解可重复使用。
- en: Discussion
  id: totrans-466
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'Quarkus tests are CDI beans, and for this reason, you can apply CDI interceptors.
    For example, you could make your test become transactional by using the transactional
    interceptor. This interceptor is enabled by annotating the test class with `@javax.transaction.Transactional`.
    So, a transactional test might look like the following:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: Quarkus测试是CDI bean，因此您可以应用CDI拦截器。例如，您可以使用事务拦截器使测试变得具有事务性。通过使用事务注释测试类，可以启用此拦截器`@javax.transaction.Transactional`。因此，事务性测试可能如下所示：
- en: '[PRE59]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Of course, this is perfectly valid, but there are two scenarios in which multiple
    annotations on the class might impact the readability of your test:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这是完全有效的，但有两种情况下，类上的多个注解可能会影响您的测试的可读性：
- en: Your test requires more annotations—for example, JUnit 5 annotations like `@TestMethodOrder`
    to define the order execution of tests, or you need to enable other interceptors
    for the test. In these cases, you can end up setting more annotations than code.
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您的测试需要更多注解，例如，JUnit 5注解（如`@TestMethodOrder`）用于定义测试的执行顺序，或者您需要为测试启用其他拦截器。在这些情况下，您可能会设置比代码更多的注解。
- en: You have a lot of tests that require the same annotations, so you continuously
    annotate, in most of the cases, all tests with the same annotations.
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您有很多测试需要相同的注解，因此在大多数情况下，您会连续注释所有测试具有相同的注解。
- en: 5.19 Executing Code Before or After a Test
  id: totrans-472
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.19 在测试前或后执行代码
- en: Problem
  id: totrans-473
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to execute some logic before/after the test suite to start/stop/configure
    a resource for the test.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试套件开始/结束前/后执行一些逻辑，以启动/停止/配置测试所需的资源。
- en: Solution
  id: totrans-475
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the *Quarkus Test Resource* extension mechanism to define the required resources
    to execute the tests.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*Quarkus Test Resource*扩展机制来定义执行测试所需的资源。
- en: Quarkus provides an extension mechanism that allows you to execute Java code
    before the test suite is started and after the test suite has finished. Furthermore,
    it allows you to create/override configuration properties programmatically so
    that any parameter required by the resource can be set in the test resource class
    instead of having to modify the *application.properties* file.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: Quarkus提供了一种扩展机制，允许您在测试套件启动之前和测试套件完成之后执行Java代码。此外，它允许您以编程方式创建/覆盖配置属性，以便可以在测试资源类中设置测试资源所需的任何参数，而无需修改*application.properties*文件。
- en: Let’s write a simple Quarkus Test Resource that just prints some messages.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个简单的Quarkus测试资源，只需打印一些消息。
- en: 'Create a new class named `org.acme.quickstart.HelloWorldQuarkusTestResourceLifecycleManager`
    implementing `io.quarkus.test.common.QuarkusTestResourceLifecycleManager` interface
    at *src/test/java* directory:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 在*src/test/java*目录下创建一个实现`io.quarkus.test.common.QuarkusTestResourceLifecycleManager`接口的名为`org.acme.quickstart.HelloWorldQuarkusTestResourceLifecycleManager`的新类：
- en: '[PRE60]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[![1](Images/1.png)](#co_programming_model_CO20-1)'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_programming_model_CO20-1)'
- en: Must implement `QuarkusTestResourceLifecycleManager`
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 必须实现`QuarkusTestResourceLifecycleManager`
- en: '[![2](Images/2.png)](#co_programming_model_CO20-2)'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: The method that is executed before the test suite
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_programming_model_CO20-3)'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: '`Map` object with system properties to be used'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_programming_model_CO20-4)'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: The method that is executed after the test suite
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](Images/5.png)](#co_programming_model_CO20-5)'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: For each test class execution, this method is invoked, passing the test instance
    so that you can inject specific fields
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](Images/6.png)](#co_programming_model_CO20-6)'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: Sets the order of execution in case multiple resources are defined
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you need to register this extension to be executed during the test
    suite execution. To do that, you need to use the `QuarkusTestResource` annotation
    in any class placed within the *src/test/java* directory and set the test resource
    to be started. Although it could be any test class responsible for registering
    the resource, we recommend you create a specific empty class that registers the
    test resource.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new class `org.acme.quickstart.HelloWorldTestResource` in *src/test/java*
    with the following content:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[![1](Images/1.png)](#co_programming_model_CO21-1)'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: Registers the test resource
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: 'Then run the tests in a terminal, and you’ll see something similar as terminal
    output:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[![1](Images/1.png)](#co_programming_model_CO22-1)'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: '`start` method is invoked before Quarkus is started'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_programming_model_CO22-2)'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: '`inject` method is invoked before `GreetingResourceTest` is run'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_programming_model_CO22-3)'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: '`stop` method is invoked after all tests have been executed'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: This example is not very usable; however, it is simple to understand the test
    life cycle, but nothing more.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  id: totrans-507
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you move forward, the complexity of your tests (integration tests, end-to-end
    tests, etc.) and the required dependencies to run them increases. For example,
    the tests might require a database instance, a Kafka broker, a JMS queue, or an
    identity provider like Keycloak.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: With this background, let’s write a more interesting test resource that uses
    Docker to boot up a MariaDB Docker container.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: For this example, you are going to use the [Testcontainers](https://oreil.ly/aEeAV)
    test framework; at the time of writing, the latest version is 1.14.3.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: Before running tests, you need to have Docker installed in your machine so Testcontainers
    can boot up the MariaDB container locally.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step in developing the Testcontainers Quarkus Test Resource is registering
    the Testcontainers dependency in your build tool for using the MariaDB Docker
    container in your test:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The implementation of `QuarkusTestResourceLifecycleManager` is as follows:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[![1](Images/1.png)](#co_programming_model_CO23-1)'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: Registers the test resource
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_programming_model_CO23-2)'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: Defines the test resource interface
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_programming_model_CO23-3)'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: Sets MariaDB container object
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_programming_model_CO23-4)'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: Instantiate MariaDB container with required Docker image
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 使用所需的Docker镜像实例化MariaDB容器
- en: '[![5](Images/5.png)](#co_programming_model_CO23-5)'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](Images/5.png)](#co_programming_model_CO23-5)'
- en: Starts the container and waits until the container is accepting connections
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 启动容器并等待容器接受连接
- en: '[![6](Images/6.png)](#co_programming_model_CO23-6)'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](Images/6.png)](#co_programming_model_CO23-6)'
- en: Overrides Quarkus’s configuration to point database connection to the container
    one
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖Quarkus的配置，将数据库连接指向容器中的连接
- en: '[![7](Images/7.png)](#co_programming_model_CO23-7)'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](Images/7.png)](#co_programming_model_CO23-7)'
- en: Stops the container
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 停止容器
- en: 'Finally, run the tests in a terminal. You’ll see something like this in the
    terminal output:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在终端中运行测试。您将在终端输出中看到类似以下内容：
- en: '[PRE65]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[![1](Images/1.png)](#co_programming_model_CO24-1)'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_programming_model_CO24-1)'
- en: MariaDB Docker container is created
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 创建MariaDB Docker容器
- en: '[![2](Images/2.png)](#co_programming_model_CO24-2)'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_programming_model_CO24-2)'
- en: Container is up and running and ready to receive incoming requests
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 容器已启动并准备好接收传入请求
- en: Tip
  id: totrans-536
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: You can develop Quarkus Test Resources in a separate project and package them
    as an external JAR library. You can then reuse them in as many projects as required.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在单独的项目中开发Quarkus测试资源，并将它们打包为外部JAR库。然后可以在任意数量的项目中重用它们。
- en: 'Quarkus provides the following default Quarkus Test Resource implementations:'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: Quarkus提供以下默认的Quarkus测试资源实现：
- en: '`H2DatabaseTestResource`'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: '`H2DatabaseTestResource`'
- en: For starting/stopping H2 database in server mode
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 用于启动/停止服务器模式下的H2数据库
- en: '`DerbyDatabaseTestResource`'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: '`DerbyDatabaseTestResource`'
- en: For starting/stopping Derby database in server mode
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 用于启动/停止服务器模式下的Derby数据库
- en: '`InfinispanEmbeddedTestResource`'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: '`InfinispanEmbeddedTestResource`'
- en: For starting/stopping Infinispan in embedded mode
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 用于启动/停止嵌入式模式下的Infinispan
- en: '`InfinispanServerTestResource`'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: '`InfinispanServerTestResource`'
- en: For starting/stopping Infinispan in server mode
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 用于启动/停止服务器模式下的Infinispan
- en: '`KeycloakTestResource`'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: '`KeycloakTestResource`'
- en: For starting/stopping Keycloak identity provider
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 用于启动/停止Keycloak身份提供者
- en: '`ArtemisTestResource`'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: '`ArtemisTestResource`'
- en: For starting/stopping Embedded ActiveMQ
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 用于启动/停止嵌入式ActiveMQ
- en: '`KafkaTestResource`'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: '`KafkaTestResource`'
- en: For starting/stopping a Kafka cluster using Debezium classes
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 用于使用Debezium类启动/停止Kafka集群
- en: '`KubernetesMockServerTestResource`'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: '`KubernetesMockServerTestResource`'
- en: For starting/stopping Kubernetes Mock server
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 用于启动/停止Kubernetes Mock服务器
- en: See Also
  id: totrans-555
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'You can learn more about how to install Docker in your local machine and find
    more examples about Testcontainers test framework at the following:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下位置了解如何在本地机器上安装Docker，并找到有关Testcontainers测试框架的更多示例：
- en: '[Docker: Get Docker](https://oreil.ly/WrfY8)'
  id: totrans-557
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Docker：获取Docker](https://oreil.ly/WrfY8)'
- en: '[Testcontainers](https://oreil.ly/aEeAV)'
  id: totrans-558
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Testcontainers](https://oreil.ly/aEeAV)'
- en: 5.20 Testing the Native Executable
  id: totrans-559
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.20 测试本地可执行文件
- en: Problem
  id: totrans-560
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to test that the native executable is correct.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望测试本地可执行文件是否正确。
- en: Solution
  id: totrans-562
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use `NativeImageTest` annotation to start the application from the native file
    instead of using the JVM.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`NativeImageTest`注解从本地文件而非JVM启动应用程序。
- en: If you plan to produce a native executable of your application, it is always
    a good idea to write some behavioral tests against the application running in
    the native executable.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 如果计划生成应用程序的本地可执行文件，则编写一些针对在本地可执行文件中运行的应用程序的行为测试始终是一个好主意。
- en: Quarkus provides the `NativeImageTest` annotation to start the application from
    the native file instead of using the JVM. It is important to note that you must
    generate the native executable before running the tests or using the `quarkus.package.type`
    system property to generate the native executable before running the tests. You
    can learn more about how to generate a native executable in the [Recipe 6.4](ch06.xhtml#native_executable)
    recipe.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: Quarkus提供`NativeImageTest`注解，从本地文件而非JVM启动应用程序。需要注意，在运行测试或使用`quarkus.package.type`系统属性生成本地可执行文件之前，必须先生成本地可执行文件。可以在[Recipe
    6.4](ch06.xhtml#native_executable)中了解如何生成本地可执行文件。
- en: If the project is scaffolded using any of the methods explained before, a native
    executable test is already provided.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 如果项目是使用前述任何方法脚手架生成的，则已提供本地可执行文件测试。
- en: Warning
  id: totrans-567
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: It is not possible to mix JVM and native image tests in the same test suite.
    The JVM tests must be run in a different cycle than the native tests (e.g., in
    Maven, this would be `surefire` for JVM tests and `failsafe` for native tests).
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 不可能在同一测试套件中混合JVM和本地镜像测试。JVM测试必须在与本地测试不同的周期中运行（例如，在Maven中，这将是`surefire`用于JVM测试和`failsafe`用于本地测试）。
- en: 'This configuration is provided by default when a project is scaffolded by any
    of the methods explained earlier:'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 当项目通过前述任何方法搭建时，默认提供此配置：
- en: '[PRE66]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[![1](Images/1.png)](#co_programming_model_CO25-1)'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_programming_model_CO25-1)'
- en: Native tests are run in `verify` goal (`./mvnw verify`)
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 本地测试在`verify`目标（`./mvnw verify`）中运行
- en: '[![2](Images/2.png)](#co_programming_model_CO25-2)'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_programming_model_CO25-2)'
- en: The location of the produced native executable (the line should not be split
    in the pom)
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的本地可执行文件的位置（该行不应在 pom 文件中拆分）
- en: '[![3](Images/3.png)](#co_programming_model_CO25-3)'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_programming_model_CO25-3)'
- en: Produces a native executable before running tests
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行测试之前生成一个本地可执行文件
- en: 'Open the `org.acme.quickstart.NativeGreetingResourceIT.java` class located
    at *src/test/java* directory:'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 打开位于*src/test/java*目录下的`org.acme.quickstart.NativeGreetingResourceIT.java`类：
- en: '[PRE67]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[![1](Images/1.png)](#co_programming_model_CO26-1)'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_programming_model_CO26-1)'
- en: Starts the native executable located at `native.image.path`.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 启动位于`native.image.path`的本地可执行文件。
- en: '[![2](Images/2.png)](#co_programming_model_CO26-2)'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_programming_model_CO26-2)'
- en: Extends JVM tests to make them run against native executable. This is not mandatory;
    you can write your tests, but remember to annotate them with `@QuarkusTest`. This
    will run the same test but against the native executable.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展 JVM 测试以使其针对本地可执行文件运行。这不是强制性的；您可以编写您的测试，但请记得用`@QuarkusTest`进行注解。这将在本地可执行文件上运行相同的测试。
- en: Warning
  id: totrans-583
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: All testing features showed in this section are valid except injecting into
    tests.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中展示的所有测试功能都是有效的，除了在测试中进行注入。
- en: Discussion
  id: totrans-585
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'There are some things that you need to take into consideration when writing
    native tests:'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写本地测试时需要考虑一些事项：
- en: Quarkus waits for 60 seconds for the native image to start before automatically
    failing the native tests. This duration can be changed using the `quarkus.test.native-image-wait-time`
    property (i.e., `./mvnw verify` `-Pnative -Dquarkus.test.native-image-wait-time=200`).
  id: totrans-587
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Quarkus 等待本地镜像启动的时间为 60 秒，然后自动失败本地测试。可以使用`quarkus.test.native-image-wait-time`属性进行更改（例如，`./mvnw
    verify -Pnative -Dquarkus.test.native-image-wait-time=200`）。
- en: Native tests run on `prod` profile; if you want to change that, you can use
    the `quarkus.test.native-image-profile` property to set an alternative profile.
  id: totrans-588
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本地测试在`prod`配置文件中运行；如果要更改，可以使用`quarkus.test.native-image-profile`属性来设置替代配置文件。
- en: You can disable certain test methods (or classes) to be able to run them in
    native tests by annotating them with the `io.quarkus.test.junit.DisabledOnNativeImage`
    annotation (i.e., `@DisabledOnNativeImage @Test public void` `n⁠o⁠n⁠N⁠a⁠t⁠i⁠v⁠e⁠T⁠e⁠s⁠t⁠(⁠)⁠{⁠}`).
  id: totrans-589
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以通过使用`io.quarkus.test.junit.DisabledOnNativeImage`注解来禁用某些测试方法（或类），以便在本地测试中运行它们（例如，`@DisabledOnNativeImage
    @Test public void` `n⁠o⁠n⁠N⁠a⁠t⁠i⁠v⁠e⁠T⁠e⁠s⁠t⁠(⁠)⁠{⁠}`）。
