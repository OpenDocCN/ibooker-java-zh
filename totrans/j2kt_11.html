<html><head></head><body><section data-pdf-bookmark="Chapter 11. Methods to Properties" data-type="chapter" epub:type="chapter"><div class="chapter" id="methods-to-properties">&#13;
<h1><span class="label">Chapter 11. </span>Methods to Properties</h1>&#13;
&#13;
<blockquote data-type="epigraph" epub:type="epigraph">&#13;
<p>Java does not distinguish between property access methods and other types.&#13;
Kotlin, on the other hand, treats properties differently than member functions.&#13;
When should we prefer a computed property to a function returning a result?</p>&#13;
</blockquote>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Fields, Accessors, and Properties" data-type="sect1"><div class="sect1" id="idm46393388798664">&#13;
<h1>Fields, Accessors, and Properties</h1>&#13;
&#13;
<p>Most programming languages<a data-primary="methods to properties" data-secondary="fields, accessors, and properties" data-type="indexterm" id="MPfields11"/> allow us to group data together in some way, giving names (and often types) to the properties of a composite.</p>&#13;
&#13;
<p>Here, for<a data-primary="records" data-type="indexterm" id="idm46393388795000"/><a data-primary="fields" data-type="indexterm" id="idm46393388794264"/> example, is a <em>record</em>, composed of three <em>fields</em>, in ALGOL W, one of the first general-purpose languages to support record types. (ALGOL W was also the language in which Tony Hoare introduced null references.)</p>&#13;
&#13;
<pre data-type="programlisting">RECORD PERSON (&#13;
    STRING(20) NAME;&#13;
    INTEGER AGE;&#13;
    LOGICAL MALE;&#13;
);</pre>&#13;
&#13;
<p>Things were different then: real programmers only had CAPITAL LETTERS, and gender was a Boolean.</p>&#13;
&#13;
<p>In ALGOL W, we can (well OK, could) update the age held in a <code>PERSON</code> record:</p>&#13;
&#13;
<pre data-type="programlisting">AGE(WILMA) := AGE(WILMA) + 1;</pre>&#13;
&#13;
<p>In this case the compiler will emit the instructions to reach into the memory of the record, find the bytes representing Wilma’s age, and increment it.&#13;
Records, also known as<a data-primary="structs" data-type="indexterm" id="idm46393388789048"/> <em>structs</em> (for structure) in other languages, are a convenience for grouping related data.&#13;
There is no information hiding here, just composition.</p>&#13;
&#13;
<p class="pagebreak-before">Most early object-oriented systems (C++ in particular) were based on this record mechanism.&#13;
Instance variables were simply record fields, and methods (aka member functions) were fields holding pointers to functions.&#13;
Smalltalk was different.&#13;
Smalltalk objects can have instance variables, but access to this state is by sending a message to the object asking for the value.&#13;
Messages, not fields, is the fundamental abstraction.</p>&#13;
&#13;
<p>The<a data-primary="Java" data-secondary="fields, accessors, and properties" data-type="indexterm" id="JPSfield11"/> Java implementers took a little of each approach.&#13;
Objects can have public fields, but clients can’t just reach into their memory to retrieve them; they have to call bytecode instructions to access their values.&#13;
This allows us to treat classes as records while allowing the runtime to enforce private field access.</p>&#13;
&#13;
<p>Although direct access to fields was <em>permitted</em>, from the outset it was discouraged.&#13;
We can’t change the internal representation of data if clients access fields directly, at least not without changing those clients too.&#13;
We also cannot maintain any invariant relationships between fields if clients can mutate them directly, and as we’ve seen in <a data-type="xref" href="ch05.html#beans-to-values">Chapter 5</a>, in those days objects were all about mutation.&#13;
Fields access is also not polymorphic, so subclasses cannot change their implementation.&#13;
In those days, objects were all about the subclassing too.</p>&#13;
&#13;
<p>So<a data-primary="accessor methods" data-type="indexterm" id="idm46393388781736"/> instead of direct field access in Java, we usually write <em>accessor</em> methods: getters and (if need be) setters.&#13;
Getters usually do nothing except return the value of a field, but they may instead compute a value from other fields.&#13;
Setters may maintain invariants or fire events as well as update a field or, perhaps, more than one field.</p>&#13;
&#13;
<p>Sometimes, though, data is just data.&#13;
When it is, then direct access to public fields may be fine, especially when we have immutable values (which is to say, final fields of immutable types).&#13;
For more complicated models, polymorphic behavior and/or a uniform way of accessing values from either a field or a calculation become useful, and accessor methods come into their own.</p>&#13;
&#13;
<p>The Kotlin designers choose to take the decision away from us and only support accessor methods.&#13;
The language doesn’t support giving direct access to fields.&#13;
Kotlin will generate code to access public fields of Java classes but does not define public fields itself. (A special annotation, <code>@JvmField</code>, provides a back door if you really need it.)&#13;
They did this to encourage us to use accessors so that we can change representations without affecting clients.</p>&#13;
&#13;
<p>To<a data-primary="properties" data-seealso="methods to properties" data-type="indexterm" id="idm46393388777576"/> encourage accessors further, Kotlin allows us to generate both a private member-variable and an accessor in a single <em>property</em> declaration.</p>&#13;
&#13;
<p>So in Java we can give access to a field directly:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">class</code> <code class="nc">PersonWithPublicFields</code> <code class="o">{</code>&#13;
    <code class="kd">public</code> <code class="kd">final</code> <code class="n">String</code> <code class="n">givenName</code><code class="o">;</code>&#13;
    <code class="kd">public</code> <code class="kd">final</code> <code class="n">String</code> <code class="n">familyName</code><code class="o">;</code>&#13;
    <code class="kd">public</code> <code class="kd">final</code> <code class="n">LocalDate</code> <code class="n">dateOfBirth</code><code class="o">;</code>&#13;
&#13;
    <code class="kd">public</code> <code class="nf">PersonWithPublicFields</code><code class="o">(</code>&#13;
        <code class="n">String</code> <code class="n">givenName</code><code class="o">,</code>&#13;
        <code class="n">String</code> <code class="n">familyName</code><code class="o">,</code>&#13;
        <code class="n">LocalDate</code> <code class="n">dateOfBirth</code>&#13;
    <code class="o">)</code> <code class="o">{</code>&#13;
        <code class="k">this</code><code class="o">.</code><code class="na">givenName</code> <code class="o">=</code> <code class="n">givenName</code><code class="o">;</code>&#13;
        <code class="k">this</code><code class="o">.</code><code class="na">familyName</code> <code class="o">=</code> <code class="n">familyName</code><code class="o">;</code>&#13;
        <code class="k">this</code><code class="o">.</code><code class="na">dateOfBirth</code> <code class="o">=</code> <code class="n">dateOfBirth</code><code class="o">;</code>&#13;
    <code class="o">}</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p>Or, we can write our own accessor:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">class</code> <code class="nc">PersonWithAccessors</code> <code class="o">{</code>&#13;
    <code class="kd">private</code> <code class="kd">final</code> <code class="n">String</code> <code class="n">givenName</code><code class="o">;</code>&#13;
    <code class="kd">private</code> <code class="kd">final</code> <code class="n">String</code> <code class="n">familyName</code><code class="o">;</code>&#13;
    <code class="kd">private</code> <code class="kd">final</code> <code class="n">LocalDate</code> <code class="n">dateOfBirth</code><code class="o">;</code>&#13;
&#13;
&#13;
    <code class="kd">public</code> <code class="nf">PersonWithAccessors</code><code class="o">(</code>&#13;
        <code class="o">...</code>&#13;
    <code class="o">}</code>&#13;
&#13;
    <code class="kd">public</code> <code class="n">String</code> <code class="nf">getGivenName</code><code class="o">()</code> <code class="o">{</code>&#13;
        <code class="k">return</code> <code class="n">givenName</code><code class="o">;</code>&#13;
    <code class="o">}</code>&#13;
&#13;
    <code class="kd">public</code> <code class="n">String</code> <code class="nf">getFamilyName</code><code class="o">()</code> <code class="o">{</code>&#13;
        <code class="k">return</code> <code class="n">familyName</code><code class="o">;</code>&#13;
    <code class="o">}</code>&#13;
&#13;
    <code class="o">...</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p>In Kotlin, we only have properties:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="n">data</code> <code class="k">class</code> <code class="nc">PersonWithProperties</code><code class="p">(</code>&#13;
    <code class="k">val</code> <code class="py">givenName</code><code class="p">:</code> <code class="n">String</code><code class="p">,</code>&#13;
    <code class="k">val</code> <code class="py">familyName</code><code class="p">:</code> <code class="n">String</code><code class="p">,</code>&#13;
    <code class="k">val</code> <code class="py">dateOfBirth</code><code class="p">:</code> <code class="n">LocalDate</code>&#13;
<code class="p">)</code> <code class="p">{</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This declaration will generate private fields: <code>givenName</code>, <code>familyName</code>, and <code>dateOfBirth</code>, accessor methods <code>getGivenName()</code> and so on, and a constructor to initialize all the fields.</p>&#13;
&#13;
<p>In Java, we can access (visible) fields directly or call accessors:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">static</code> <code class="n">String</code> <code class="nf">accessField</code><code class="o">(</code><code class="n">PersonWithPublicFields</code> <code class="n">person</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="k">return</code> <code class="n">person</code><code class="o">.</code><code class="na">givenName</code><code class="o">;</code>&#13;
<code class="o">}</code>&#13;
&#13;
<code class="kd">public</code> <code class="kd">static</code> <code class="n">String</code> <code class="nf">callAccessor</code><code class="o">(</code><code class="n">PersonWithAccessors</code> <code class="n">person</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="k">return</code> <code class="n">person</code><code class="o">.</code><code class="na">getGivenName</code><code class="o">();</code>&#13;
<code class="o">}</code>&#13;
&#13;
<code class="kd">public</code> <code class="kd">static</code> <code class="n">String</code> <code class="nf">callKotlinAccessor</code><code class="o">(</code><code class="n">PersonWithProperties</code> <code class="n">person</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="k">return</code> <code class="n">person</code><code class="o">.</code><code class="na">getGivenName</code><code class="o">();</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p>In Kotlin, we can access visible fields (from Java classes) directly or call accessors as if they were fields:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">accessField</code><code class="p">(</code><code class="n">person</code><code class="p">:</code> <code class="n">PersonWithPublicFields</code><code class="p">):</code> <code class="n">String</code> <code class="p">=</code>&#13;
    <code class="n">person</code><code class="p">.</code><code class="n">givenName</code>&#13;
&#13;
<code class="k">fun</code> <code class="nf">callAccessor</code><code class="p">(</code><code class="n">person</code><code class="p">:</code> <code class="n">PersonWithAccessors</code><code class="p">):</code> <code class="n">String</code> <code class="p">=</code>&#13;
    <code class="n">person</code><code class="p">.</code><code class="n">givenName</code>&#13;
&#13;
<code class="k">fun</code> <code class="nf">callKotlinAccessor</code><code class="p">(</code><code class="n">person</code><code class="p">:</code> <code class="n">PersonWithProperties</code><code class="p">):</code> <code class="n">String</code> <code class="p">=</code>&#13;
    <code class="n">person</code><code class="p">.</code><code class="n">givenName</code></pre>&#13;
&#13;
<p>Properties are a convenience backed by some compiler magic.&#13;
They make it as simple to use fields and accessors in Kotlin as plain old fields in Java, so we will naturally write code that can take advantage of encapsulation.&#13;
For example, we might find that we want to define a property in an interface or compute a property that we previously stored.</p>&#13;
&#13;
<p><em>Computed</em> properties<a data-primary="computed properties" data-type="indexterm" id="idm46393388259112"/> are those not backed by a field.&#13;
If we have <code>givenName</code> and <code>familyName</code> backed by fields, there is no need to store <code>fullName</code>; we can compute it when we need it:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">class</code> <code class="nc">PersonWithPublicFields</code> <code class="o">{</code>&#13;
    <code class="kd">public</code> <code class="kd">final</code> <code class="n">String</code> <code class="n">givenName</code><code class="o">;</code>&#13;
    <code class="kd">public</code> <code class="kd">final</code> <code class="n">String</code> <code class="n">familyName</code><code class="o">;</code>&#13;
    <code class="kd">public</code> <code class="kd">final</code> <code class="n">LocalDate</code> <code class="n">dateOfBirth</code><code class="o">;</code>&#13;
&#13;
    <code class="kd">public</code> <code class="nf">PersonWithPublicFields</code><code class="o">(</code>&#13;
        <code class="o">...</code>&#13;
    <code class="o">}</code>&#13;
&#13;
    <code class="kd">public</code> <code class="n">String</code> <code class="nf">getFullName</code><code class="o">()</code> <code class="o">{</code>&#13;
        <code class="k">return</code> <code class="n">givenName</code> <code class="o">+</code> <code class="s">" "</code> <code class="o">+</code> <code class="n">familyName</code><code class="o">;</code>&#13;
    <code class="o">}</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p>If we use direct-field access in Java, there is now a difference between the way we access the stored and computed properties:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">static</code> <code class="n">String</code> <code class="nf">fieldAndAccessor</code><code class="o">(</code><code class="n">PersonWithPublicFields</code> <code class="n">person</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="k">return</code>&#13;
        <code class="n">person</code><code class="o">.</code><code class="na">givenName</code> <code class="o">+</code> <code class="s">" "</code> <code class="o">+</code>&#13;
        <code class="n">person</code><code class="o">.</code><code class="na">getFullName</code><code class="o">();</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p>This isn’t the case in Kotlin, even when accessing the Java fields and methods, which is nice:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">fieldAndAccessor</code><code class="p">(</code><code class="n">person</code><code class="p">:</code> <code class="n">PersonWithPublicFields</code><code class="p">)</code> <code class="p">=</code>&#13;
    <code class="n">person</code><code class="p">.</code><code class="n">givenName</code> <code class="p">+</code> <code class="s">" "</code> <code class="p">+</code>&#13;
    <code class="n">person</code><code class="p">.</code><code class="n">fullName</code></pre>&#13;
&#13;
<p>In Kotlin, we define computed properties outside the constructor:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="n">data</code> <code class="k">class</code> <code class="nc">PersonWithProperties</code><code class="p">(</code>&#13;
    <code class="k">val</code> <code class="py">givenName</code><code class="p">:</code> <code class="n">String</code><code class="p">,</code>&#13;
    <code class="k">val</code> <code class="py">familyName</code><code class="p">:</code> <code class="n">String</code><code class="p">,</code>&#13;
    <code class="k">val</code> <code class="py">dateOfBirth</code><code class="p">:</code> <code class="n">LocalDate</code>&#13;
<code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">val</code> <code class="py">fullName</code> <code class="k">get</code><code class="p">()</code> <code class="p">=</code> <code class="s">"$givenName $familyName"</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>So, in Java, we <em>can</em> define classes that give direct access to fields, but <em>should</em> generally use accessors, which are just methods named (by convention but not always) with a <code>get</code> or <code>set</code> prefix.&#13;
In Kotlin, we cannot define fields and accessors separately.&#13;
When we define a property in Kotlin, the compiler generates a field and accessors that follow the Java naming convention.&#13;
When we refer to a property in Kotlin, the syntax is the same as Java’s syntax for field access, but the compiler generates a call to the accessor.&#13;
This even applies across the interop boundary: when we refer to properties of Java objects, the compiler will generate a call to the accessor if one exists and follows the Java naming convention.<a data-primary="" data-startref="MPfields11" data-type="indexterm" id="idm46393388051864"/><a data-primary="" data-startref="JPSfield11" data-type="indexterm" id="idm46393388050888"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="How to Choose" data-type="sect1"><div class="sect1" id="idm46393388797720">&#13;
<h1>How to Choose</h1>&#13;
&#13;
<p>Returning<a data-primary="methods to properties" data-secondary="choosing computed properties versus methods" data-type="indexterm" id="MPchoos11"/> to the question at the beginning of the chapter: given that computed properties are just methods with sugar on top, when should we choose a computed property, and when should we choose a method?</p>&#13;
&#13;
<p>A good rule of thumb is to use a property when it depends only on other properties on the type and is cheap to compute.&#13;
This applies to <code>fullName</code>, so that is a good computed property.&#13;
What about a person’s age?</p>&#13;
&#13;
<p>We can compute age easily (ignoring time zones) from the <code>dateOfBirth</code> property, so we might be tempted in Java to write <code>fred.getAge()</code>.&#13;
But this doesn’t depend only on other properties, it also depends on when we call it.&#13;
Unlikely though it is, <code>fred.age == fred.age</code> can return <code>false</code>.</p>&#13;
&#13;
<p>Age<a data-primary="actions" data-secondary="functions versus properties" data-type="indexterm" id="idm46393388043256"/> is an action (<a data-type="xref" href="ch07.html#actions">“Actions”</a>); its result depends on when it is called.&#13;
Properties<a data-primary="calculations" data-secondary="properties as" data-type="indexterm" id="idm46393388041320"/> should be calculations (<a data-type="xref" href="ch07.html#calculations">“Calculations”</a>), timeless and dependent only on their inputs, in this case the <code>dateOfBirth</code> property.&#13;
Hence <code>age()</code> should be a function, not a property:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="n">data</code> <code class="k">class</code> <code class="nc">PersonWithProperties</code><code class="p">(</code>&#13;
    <code class="k">val</code> <code class="py">givenName</code><code class="p">:</code> <code class="n">String</code><code class="p">,</code>&#13;
    <code class="k">val</code> <code class="py">familyName</code><code class="p">:</code> <code class="n">String</code><code class="p">,</code>&#13;
    <code class="k">val</code> <code class="py">dateOfBirth</code><code class="p">:</code> <code class="n">LocalDate</code>&#13;
<code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">fun</code> <code class="nf">age</code><code class="p">()</code> <code class="p">=</code> <code class="n">Period</code><code class="p">.</code><code class="n">between</code><code class="p">(</code><code class="n">dateOfBirth</code><code class="p">,</code> <code class="n">LocalDate</code><code class="p">.</code><code class="n">now</code><code class="p">()).</code><code class="n">years</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>What about a cryptographic hash of all the other properties of the object?&#13;
This is a calculation (for immutable objects), but if it is expensive to compute, it should be a method <code>hash()</code> not a property <code>hash</code>.&#13;
We might even want to hint at the cost of the method in its name:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="n">data</code> <code class="k">class</code> <code class="nc">PersonWithProperties</code><code class="p">(</code>&#13;
    <code class="k">val</code> <code class="py">givenName</code><code class="p">:</code> <code class="n">String</code><code class="p">,</code>&#13;
    <code class="k">val</code> <code class="py">familyName</code><code class="p">:</code> <code class="n">String</code><code class="p">,</code>&#13;
    <code class="k">val</code> <code class="py">dateOfBirth</code><code class="p">:</code> <code class="n">LocalDate</code>&#13;
<code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">fun</code> <code class="nf">computeHash</code><code class="p">():</code> <code class="n">ByteArray</code> <code class="p">=</code>&#13;
        <code class="n">someSlowHashOf</code><code class="p">(</code><code class="n">givenName</code><code class="p">,</code> <code class="n">familyName</code><code class="p">,</code> <code class="n">dateOfBirth</code><code class="p">.</code><code class="n">toString</code><code class="p">())</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>We could make a property by calculating it up front and storing it in a field:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="n">data</code> <code class="k">class</code> <code class="nc">PersonWithProperties</code><code class="p">(</code>&#13;
    <code class="k">val</code> <code class="py">givenName</code><code class="p">:</code> <code class="n">String</code><code class="p">,</code>&#13;
    <code class="k">val</code> <code class="py">familyName</code><code class="p">:</code> <code class="n">String</code><code class="p">,</code>&#13;
    <code class="k">val</code> <code class="py">dateOfBirth</code><code class="p">:</code> <code class="n">LocalDate</code>&#13;
<code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">val</code> <code class="py">hash</code><code class="p">:</code> <code class="n">ByteArray</code> <code class="p">=</code>&#13;
        <code class="n">someSlowHashOf</code><code class="p">(</code><code class="n">givenName</code><code class="p">,</code> <code class="n">familyName</code><code class="p">,</code> <code class="n">dateOfBirth</code><code class="p">.</code><code class="n">toString</code><code class="p">())</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This has the disadvantage of making every instance slow to create, whether or not its <code>hash</code> is ever accessed.&#13;
We might split the difference with a lazy property:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="n">data</code> <code class="k">class</code> <code class="nc">PersonWithProperties</code><code class="p">(</code>&#13;
    <code class="k">val</code> <code class="py">givenName</code><code class="p">:</code> <code class="n">String</code><code class="p">,</code>&#13;
    <code class="k">val</code> <code class="py">familyName</code><code class="p">:</code> <code class="n">String</code><code class="p">,</code>&#13;
    <code class="k">val</code> <code class="py">dateOfBirth</code><code class="p">:</code> <code class="n">LocalDate</code>&#13;
<code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">val</code> <code class="py">hash</code><code class="p">:</code> <code class="n">ByteArray</code> <code class="k">by</code> <code class="n">lazy</code> <code class="p">{</code>&#13;
        <code class="n">someSlowHashOf</code><code class="p">(</code><code class="n">givenName</code><code class="p">,</code> <code class="n">familyName</code><code class="p">,</code> <code class="n">dateOfBirth</code><code class="p">.</code><code class="n">toString</code><code class="p">())</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>In a limited scope this would be fine, but if the class was more widely used, we should at least hint at the potential first-invocation performance issue by hiding the computed property behind a function:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="n">data</code> <code class="k">class</code> <code class="nc">PersonWithProperties</code><code class="p">(</code>&#13;
    <code class="k">val</code> <code class="py">givenName</code><code class="p">:</code> <code class="n">String</code><code class="p">,</code>&#13;
    <code class="k">val</code> <code class="py">familyName</code><code class="p">:</code> <code class="n">String</code><code class="p">,</code>&#13;
    <code class="k">val</code> <code class="py">dateOfBirth</code><code class="p">:</code> <code class="n">LocalDate</code>&#13;
<code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">private</code> <code class="k">val</code> <code class="py">hash</code><code class="p">:</code> <code class="n">ByteArray</code> <code class="k">by</code> <code class="n">lazy</code> <code class="p">{</code>&#13;
        <code class="n">someSlowHashOf</code><code class="p">(</code><code class="n">givenName</code><code class="p">,</code> <code class="n">familyName</code><code class="p">,</code> <code class="n">dateOfBirth</code><code class="p">.</code><code class="n">toString</code><code class="p">())</code>&#13;
    <code class="p">}</code>&#13;
    <code class="k">fun</code> <code class="nf">hash</code><code class="p">()</code> <code class="p">=</code> <code class="n">hash</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>In this case, we might consider an extension property.&#13;
As we saw in <a data-type="xref" href="ch10.html#functions-to-extension-functions">Chapter 10</a>, though, extension properties can only be computed rather than backed by a field and so cannot be lazy.&#13;
Apart from that, most of the discussion here also applies to extension functions versus extension properties.<a data-primary="" data-startref="MPchoos11" data-type="indexterm" id="idm46393387684632"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Mutable Properties" data-type="sect1"><div class="sect1" id="idm46393388049816">&#13;
<h1>Mutable Properties</h1>&#13;
&#13;
<p>So<a data-primary="methods to properties" data-secondary="mutable properties" data-type="indexterm" id="idm46393387682520"/><a data-primary="mutability" data-secondary="mutable properties" data-type="indexterm" id="idm46393387681512"/> what of mutable properties?&#13;
Kotlin allows us to define properties as <code>var</code>, for &#13;
<span class="keep-together">variable</span>.</p>&#13;
&#13;
<p>If you’ve read this far, you’ll know that your authors like to keep their data (<a data-type="xref" href="ch05.html#beans-to-values">Chapter 5</a>) and collections (<a data-type="xref" href="ch06.html#java-to-kotlin-collections">Chapter 6</a>) immutable.&#13;
We can <em>imagine</em> using Kotlin to define a mutable property to integrate with some Java code that required it, but very, very rarely use mutable public properties in practice.&#13;
We might occasionally define a property that will change over time (to give access to a count, for example), but almost never one that clients can set.&#13;
In practice, we find that data classes with copy methods work better in almost all situations that might have called for a setter; in fact, we would go as far as to say that allowing <code>var</code> properties in data classes was a language design mistake.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Refactoring to Properties" data-type="sect1"><div class="sect1" id="idm46393387675656">&#13;
<h1>Refactoring to Properties</h1>&#13;
&#13;
<p>IntelliJ<a data-primary="methods to properties" data-secondary="refactoring to properties" data-type="indexterm" id="MPreftop11"/><a data-primary="IntelliJ IDE" data-secondary="converting between Kotlin methods and properties" data-type="indexterm" id="IJconvert11"/><a data-primary="refactoring" data-secondary="methods to properties" data-type="indexterm" id="Rmethods11"/> provides excellent refactoring support for converting between Kotlin methods and properties.&#13;
This is on the one hand simple, because both are simply method calls, and on the other complicated, because Java interop relies on naming conventions to identify accessors.&#13;
Let’s look at an example from Travelator.</p>&#13;
&#13;
<p>Some of our hardier clients like to camp, so we list campsites in the application:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">class</code> <code class="nc">CampSite</code> <code class="o">{</code>&#13;
    <code class="kd">private</code> <code class="kd">final</code> <code class="n">String</code> <code class="n">id</code><code class="o">;</code>&#13;
    <code class="kd">private</code> <code class="kd">final</code> <code class="n">String</code> <code class="n">name</code><code class="o">;</code>&#13;
    <code class="kd">private</code> <code class="kd">final</code> <code class="n">Address</code> <code class="n">address</code><code class="o">;</code>&#13;
    <code class="o">...</code>&#13;
&#13;
    <code class="kd">public</code> <code class="nf">CampSite</code><code class="o">(</code>&#13;
        <code class="n">String</code> <code class="n">id</code><code class="o">,</code>&#13;
        <code class="n">String</code> <code class="n">name</code><code class="o">,</code>&#13;
        <code class="n">Address</code> <code class="n">address</code>&#13;
        <code class="o">...</code>&#13;
    <code class="o">)</code> <code class="o">{</code>&#13;
        <code class="k">this</code><code class="o">.</code><code class="na">id</code> <code class="o">=</code> <code class="n">id</code><code class="o">;</code>&#13;
        <code class="k">this</code><code class="o">.</code><code class="na">name</code> <code class="o">=</code> <code class="n">name</code><code class="o">;</code>&#13;
        <code class="k">this</code><code class="o">.</code><code class="na">address</code> <code class="o">=</code> <code class="n">address</code><code class="o">;</code>&#13;
        <code class="o">...</code>&#13;
    <code class="o">}</code>&#13;
&#13;
    <code class="kd">public</code> <code class="n">String</code> <code class="nf">getId</code><code class="o">()</code> <code class="o">{</code>&#13;
        <code class="k">return</code> <code class="n">id</code><code class="o">;</code>&#13;
    <code class="o">}</code>&#13;
&#13;
    <code class="kd">public</code> <code class="n">String</code> <code class="nf">getName</code><code class="o">()</code> <code class="o">{</code>&#13;
        <code class="k">return</code> <code class="n">name</code><code class="o">;</code>&#13;
    <code class="o">}</code>&#13;
&#13;
    <code class="kd">public</code> <code class="n">String</code> <code class="nf">getCountryCode</code><code class="o">()</code> <code class="o">{</code>&#13;
        <code class="k">return</code> <code class="n">address</code><code class="o">.</code><code class="na">getCountryCode</code><code class="o">();</code>&#13;
    <code class="o">}</code>&#13;
&#13;
    <code class="kd">public</code> <code class="n">String</code> <code class="nf">region</code><code class="o">()</code> <code class="o">{</code>&#13;
        <code class="k">return</code> <code class="n">address</code><code class="o">.</code><code class="na">getRegion</code><code class="o">();</code>&#13;
    <code class="o">}</code>&#13;
&#13;
    <code class="o">...</code>&#13;
<code class="o">}</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=11.1&amp;show=file">Example 11.1 [methods-to-properties.0:src/main/java/travelator/CampSite.java]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=11.1&amp;show=diff">(diff)</a>&#13;
</div>&#13;
&#13;
<p>This is typical of a domain class that has grown over the years.&#13;
It has lots of properties, some backed by fields like <code>id</code> and <code>name</code>, and some computed (for low values of compute) like <code>countryCode</code> and <code>region</code>.&#13;
Someone ignored bean conventions by naming an accessor <code>region</code> rather than <code>getRegion</code>, but it is clear to us what they meant.</p>&#13;
&#13;
<p>Here’s some code that uses the accessors:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">class</code> <code class="nc">CampSites</code> <code class="o">{</code>&#13;
&#13;
    <code class="kd">public</code> <code class="kd">static</code> <code class="n">Set</code><code class="o">&lt;</code><code class="n">CampSite</code><code class="o">&gt;</code> <code class="nf">sitesInRegion</code><code class="o">(</code>&#13;
        <code class="n">Set</code><code class="o">&lt;</code><code class="n">CampSite</code><code class="o">&gt;</code> <code class="n">sites</code><code class="o">,</code>&#13;
        <code class="n">String</code> <code class="n">countryISO</code><code class="o">,</code>&#13;
        <code class="n">String</code> <code class="n">region</code>&#13;
    <code class="o">)</code> <code class="o">{</code>&#13;
        <code class="k">return</code> <code class="n">sites</code><code class="o">.</code><code class="na">stream</code><code class="o">()</code>&#13;
            <code class="o">.</code><code class="na">filter</code><code class="o">(</code> <code class="n">campSite</code> <code class="o">-&gt;</code>&#13;
                <code class="n">campSite</code><code class="o">.</code><code class="na">getCountryCode</code><code class="o">().</code><code class="na">equals</code><code class="o">(</code><code class="n">countryISO</code><code class="o">)</code> <code class="o">&amp;&amp;</code>&#13;
                    <code class="n">campSite</code><code class="o">.</code><code class="na">region</code><code class="o">().</code><code class="na">equalsIgnoreCase</code><code class="o">(</code><code class="n">region</code><code class="o">)</code>&#13;
            <code class="o">)</code>&#13;
            <code class="o">.</code><code class="na">collect</code><code class="o">(</code><code class="n">toUnmodifiableSet</code><code class="o">());</code>&#13;
    <code class="o">}</code>&#13;
<code class="o">}</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=11.2&amp;show=file">Example 11.2 [methods-to-properties.0:src/main/java/travelator/CampSites.java]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=11.2&amp;show=diff">(diff)</a>&#13;
</div>&#13;
&#13;
<p>Let’s convert <code>Campsite</code> to Kotlin with IntelliJ (and then make it a data class):</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="n">data</code> <code class="k">class</code> <code class="nc">CampSite</code><code class="p">(</code>&#13;
    <code class="k">val</code> <code class="py">id</code><code class="p">:</code> <code class="n">String</code><code class="p">,</code>&#13;
    <code class="k">val</code> <code class="py">name</code><code class="p">:</code> <code class="n">String</code><code class="p">,</code>&#13;
    <code class="k">val</code> <code class="py">address</code><code class="p">:</code> <code class="n">Address</code><code class="p">,</code>&#13;
    <code class="p">...</code>&#13;
<code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">val</code> <code class="py">countryCode</code><code class="p">:</code> <code class="n">String</code>&#13;
        <code class="k">get</code><code class="p">()</code> <code class="p">=</code> <code class="n">address</code><code class="p">.</code><code class="n">countryCode</code>&#13;
&#13;
    <code class="k">fun</code> <code class="nf">region</code><code class="p">():</code> <code class="n">String</code> <code class="p">{</code>&#13;
        <code class="k">return</code> <code class="n">address</code><code class="p">.</code><code class="n">region</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="p">...</code>&#13;
<code class="p">}</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=11.3&amp;show=file">Example 11.3 [methods-to-properties.1:src/main/java/travelator/CampSite.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=11.3&amp;show=diff">(diff)</a>&#13;
</div>&#13;
&#13;
<p>Our field-backed properties have become constructor properties, and the computed <code>countryCode</code> a computed property.&#13;
However, IntelliJ has not realized that <code>region</code> is a property, because it didn’t obey getter naming conventions and has simply converted the method.&#13;
The net result is that client code doesn’t need to change.&#13;
If we want to correct the oversight, we can Alt-Enter on <code>region</code> and “Convert function to property”, yielding:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">val</code> <code class="py">region</code><code class="p">:</code> <code class="n">String</code>&#13;
    <code class="k">get</code><code class="p">()</code> <code class="p">{</code>&#13;
        <code class="k">return</code> <code class="n">address</code><code class="p">.</code><code class="n">region</code>&#13;
    <code class="p">}</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=11.4&amp;show=file">Example 11.4 [methods-to-properties.2:src/main/java/travelator/CampSite.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=11.4&amp;show=diff">(diff)</a>&#13;
</div>&#13;
&#13;
<p>As with most computed properties, this is better as a single expression (see &#13;
<span class="keep-together"><a data-type="xref" href="ch09.html#multi-to-single-expression-functions">Chapter 9</a></span>):</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">val</code> <code class="py">region</code><code class="p">:</code> <code class="n">String</code> <code class="k">get</code><code class="p">()</code> <code class="p">=</code> <code class="n">address</code><code class="p">.</code><code class="n">region</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=11.5&amp;show=file">Example 11.5 [methods-to-properties.3:src/main/java/travelator/CampSite.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=11.5&amp;show=diff">(diff)</a>&#13;
</div>&#13;
&#13;
<p>Changing the Kotlin <code>region</code> method to a property means that the accessor method will now be named <code>getRegion</code>; thankfully, IntelliJ is smart enough to fix up our clients for us:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code><code> </code><code class="kd">static</code><code> </code><code class="n">Set</code><code class="o">&lt;</code><code class="n">CampSite</code><code class="o">&gt;</code><code> </code><code class="nf">sitesInRegion</code><code class="o">(</code><code>&#13;
</code><code>    </code><code class="n">Set</code><code class="o">&lt;</code><code class="n">CampSite</code><code class="o">&gt;</code><code> </code><code class="n">sites</code><code class="o">,</code><code>&#13;
</code><code>    </code><code class="n">String</code><code> </code><code class="n">countryISO</code><code class="o">,</code><code>&#13;
</code><code>    </code><code class="n">String</code><code> </code><code class="n">region</code><code>&#13;
</code><code class="o">)</code><code> </code><code class="o">{</code><code>&#13;
</code><code>    </code><code class="k">return</code><code> </code><code class="n">sites</code><code class="o">.</code><code class="na">stream</code><code class="o">(</code><code class="o">)</code><code>&#13;
</code><code>        </code><code class="o">.</code><code class="na">filter</code><code class="o">(</code><code> </code><code class="n">campSite</code><code> </code><code class="o">-</code><code class="o">&gt;</code><code>&#13;
</code><code>            </code><code class="n">campSite</code><code class="o">.</code><code class="na">getCountryCode</code><code class="o">(</code><code class="o">)</code><code class="o">.</code><code class="na">equals</code><code class="o">(</code><code class="n">countryISO</code><code class="o">)</code><code> </code><code class="o">&amp;</code><code class="o">&amp;</code><code>&#13;
</code><code>                </code><code class="n">campSite</code><code class="o">.</code><code class="na">getRegion</code><code class="o">(</code><code class="o">)</code><code class="o">.</code><code class="na">equalsIgnoreCase</code><code class="o">(</code><code class="n">region</code><code class="o">)</code><code> </code><a class="co" href="#callout_introduction_CO19-1" id="co_introduction_CO19-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
</code><code>        </code><code class="o">)</code><code>&#13;
</code><code>        </code><code class="o">.</code><code class="na">collect</code><code class="o">(</code><code class="n">toUnmodifiableSet</code><code class="o">(</code><code class="o">)</code><code class="o">)</code><code class="o">;</code><code>&#13;
</code><code class="o">}</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=11.6&amp;show=file">Example 11.6 [methods-to-properties.3:src/main/java/travelator/CampSites.java]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=11.6&amp;show=diff">(diff)</a>&#13;
</div>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_introduction_CO19-1" id="callout_introduction_CO19-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p><code>campsite.region()</code> has been replaced by <code>campsite.getRegion()</code>.</p></dd>&#13;
</dl>&#13;
&#13;
<p>If we now convert <code>sitesInRegion</code> to Kotlin, we get the following:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">object</code><code> </code><code class="nc">CampSites</code><code> </code><code class="p">{</code><code>&#13;
</code><code>    </code><code class="k">fun</code><code> </code><code class="nf">sitesInRegion</code><code class="p">(</code><code>&#13;
</code><code>        </code><code class="n">sites</code><code class="p">:</code><code> </code><code class="n">Set</code><code class="p">&lt;</code><code class="n">CampSite</code><code class="p">&gt;</code><code class="p">,</code><code>&#13;
</code><code>        </code><code class="n">countryISO</code><code class="p">:</code><code> </code><code class="n">String</code><code class="p">,</code><code>&#13;
</code><code>        </code><code class="n">region</code><code class="p">:</code><code> </code><code class="n">String</code><code class="p">?</code><code>&#13;
</code><code>    </code><code class="p">)</code><code class="p">:</code><code> </code><code class="n">Set</code><code class="p">&lt;</code><code class="n">CampSite</code><code class="p">&gt;</code><code> </code><code class="p">{</code><code>&#13;
</code><code>        </code><code class="k">return</code><code> </code><code class="n">sites</code><code class="p">.</code><code class="n">stream</code><code class="p">(</code><code class="p">)</code><code>&#13;
</code><code>            </code><code class="p">.</code><code class="n">filter</code><code> </code><code class="p">{</code><code> </code><code class="n">campSite</code><code class="p">:</code><code> </code><code class="n">CampSite</code><code> </code><code class="p">-</code><code class="p">&gt;</code><code>&#13;
</code><code>                </code><code class="n">campSite</code><code class="p">.</code><code class="n">countryCode</code><code> </code><code class="p">=</code><code class="p">=</code><code> </code><code class="n">countryISO</code><code> </code><code class="p">&amp;</code><code class="p">&amp;</code><code>&#13;
</code><code>                    </code><code class="n">campSite</code><code class="p">.</code><code class="n">region</code><code class="p">.</code><code class="n">equals</code><code class="p">(</code><code class="n">region</code><code class="p">,</code><code> </code><code class="n">ignoreCase</code><code> </code><code class="p">=</code><code> </code><code class="k">true</code><code class="p">)</code><code> </code><a class="co" href="#callout_introduction_CO20-1" id="co_introduction_CO20-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
</code><code>            </code><code class="p">}</code><code>&#13;
</code><code>            </code><code class="p">.</code><code class="n">collect</code><code class="p">(</code><code class="n">Collectors</code><code class="p">.</code><code class="n">toUnmodifiableSet</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code>&#13;
</code><code>    </code><code class="p">}</code><code>&#13;
</code><code class="p">}</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=11.7&amp;show=file">Example 11.7 [methods-to-properties.4:src/main/java/travelator/CampSites.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=11.7&amp;show=diff">(diff)</a>&#13;
</div>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_introduction_CO20-1" id="callout_introduction_CO20-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p><code>campsite.getRegion()</code> is now invoked by <code>campsite.region</code>.</p></dd>&#13;
</dl>&#13;
&#13;
<p>We saw how to move <code>sitesInRegion</code> to the top level in <a data-type="xref" href="ch08.html#static-methods-to-top-level-functions">Chapter 8</a>, and to an extension function in <a data-type="xref" href="ch10.html#functions-to-extension-functions">Chapter 10</a>:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">Set</code><code class="p">&lt;</code><code class="n">CampSite</code><code class="p">&gt;.</code><code class="n">sitesInRegion</code><code class="p">(</code>&#13;
    <code class="n">countryISO</code><code class="p">:</code> <code class="n">String</code><code class="p">,</code>&#13;
    <code class="n">region</code><code class="p">:</code> <code class="n">String</code>&#13;
<code class="p">):</code> <code class="n">Set</code><code class="p">&lt;</code><code class="n">CampSite</code><code class="p">&gt;</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="n">stream</code><code class="p">()</code>&#13;
        <code class="p">.</code><code class="n">filter</code> <code class="p">{</code> <code class="n">campSite</code><code class="p">:</code> <code class="n">CampSite</code> <code class="p">-&gt;</code>&#13;
            <code class="n">campSite</code><code class="p">.</code><code class="n">countryCode</code> <code class="p">==</code> <code class="n">countryISO</code> <code class="p">&amp;&amp;</code>&#13;
                <code class="n">campSite</code><code class="p">.</code><code class="n">region</code><code class="p">.</code><code class="n">equals</code><code class="p">(</code><code class="n">region</code><code class="p">,</code> <code class="n">ignoreCase</code> <code class="p">=</code> <code class="k">true</code><code class="p">)</code>&#13;
        <code class="p">}</code>&#13;
        <code class="p">.</code><code class="n">collect</code><code class="p">(</code><code class="n">Collectors</code><code class="p">.</code><code class="n">toUnmodifiableSet</code><code class="p">())</code>&#13;
<code class="p">}</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=11.8&amp;show=file">Example 11.8 [methods-to-properties.5:src/main/java/travelator/CampSites.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=11.8&amp;show=diff">(diff)</a>&#13;
</div>&#13;
&#13;
<p><em>Streams to Iterables to Sequences</em> (<a data-type="xref" href="ch13.html#streams-to-sequences">Chapter 13</a>) and <em>Multi- to Single-Expression Functions</em> (<a data-type="xref" href="ch09.html#multi-to-single-expression-functions">Chapter 9</a>) show how to finish the job to:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">Iterable</code><code class="p">&lt;</code><code class="n">CampSite</code><code class="p">&gt;.</code><code class="n">sitesInRegion</code><code class="p">(</code>&#13;
    <code class="n">countryISO</code><code class="p">:</code> <code class="n">String</code><code class="p">,</code>&#13;
    <code class="n">region</code><code class="p">:</code> <code class="n">String</code>&#13;
<code class="p">):</code> <code class="n">Set</code><code class="p">&lt;</code><code class="n">CampSite</code><code class="p">&gt;</code> <code class="p">=</code>&#13;
    <code class="n">filter</code> <code class="p">{</code> <code class="n">site</code> <code class="p">-&gt;</code>&#13;
        <code class="n">site</code><code class="p">.</code><code class="n">countryCode</code> <code class="p">==</code> <code class="n">countryISO</code> <code class="p">&amp;&amp;</code>&#13;
            <code class="n">site</code><code class="p">.</code><code class="n">region</code><code class="p">.</code><code class="n">equals</code><code class="p">(</code><code class="n">region</code><code class="p">,</code> <code class="n">ignoreCase</code> <code class="p">=</code> <code class="k">true</code><code class="p">)</code>&#13;
    <code class="p">}.</code><code class="n">toSet</code><code class="p">()</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=11.9&amp;show=file">Example 11.9 [methods-to-properties.6:src/main/java/travelator/CampSites.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=11.9&amp;show=diff">(diff)</a>&#13;
</div>&#13;
&#13;
<p>Due to the excellent tooling and interop around methods, accessors, and properties, this has been a mercifully short refactor. So we crave your indulgence while we add just one more tweak.</p>&#13;
&#13;
<p><code>sitesInRegion</code> is a bit of an odd method.&#13;
It is making up for a deficiency in our modeling, which is that regions are just strings not entities.&#13;
Without the country code, if we filter just on region name “Hampshire,” we risk returning a set of sites, most of which are in an English county, but where one (Moonlight Camping—it sounds lovely) is on a Canadian island.&#13;
Until we can fix that, what if we pull the filter predicate out into its own method?</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">Iterable</code><code class="p">&lt;</code><code class="n">CampSite</code><code class="p">&gt;.</code><code class="n">sitesInRegion</code><code class="p">(</code>&#13;
    <code class="n">countryISO</code><code class="p">:</code> <code class="n">String</code><code class="p">,</code>&#13;
    <code class="n">region</code><code class="p">:</code> <code class="n">String</code>&#13;
<code class="p">):</code> <code class="n">Set</code><code class="p">&lt;</code><code class="n">CampSite</code><code class="p">&gt;</code> <code class="p">=</code>&#13;
    <code class="n">filter</code> <code class="p">{</code> <code class="n">site</code> <code class="p">-&gt;</code>&#13;
        <code class="n">site</code><code class="p">.</code><code class="n">isIn</code><code class="p">(</code><code class="n">countryISO</code><code class="p">,</code> <code class="n">region</code><code class="p">)</code>&#13;
    <code class="p">}.</code><code class="n">toSet</code><code class="p">()</code>&#13;
&#13;
<code class="k">fun</code> <code class="nf">CampSite</code><code class="p">.</code><code class="n">isIn</code><code class="p">(</code><code class="n">countryISO</code><code class="p">:</code> <code class="n">String</code><code class="p">,</code> <code class="n">region</code><code class="p">:</code> <code class="n">String</code><code class="p">)</code> <code class="p">=</code>&#13;
    <code class="n">countryCode</code> <code class="p">==</code> <code class="n">countryISO</code> <code class="p">&amp;&amp;</code>&#13;
        <code class="k">this</code><code class="p">.</code><code class="n">region</code><code class="p">.</code><code class="n">equals</code><code class="p">(</code><code class="n">region</code><code class="p">,</code> <code class="n">ignoreCase</code> <code class="p">=</code> <code class="k">true</code><code class="p">)</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=11.10&amp;show=file">Example 11.10 [methods-to-properties.7:src/main/java/travelator/CampSites.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=11.10&amp;show=diff">(diff)</a>&#13;
</div>&#13;
&#13;
<p>Now that we have <code>Campsite.isIn(...)</code>, maybe <code>sitesInRegion</code> could be inlined into the places that call it, because the code is now really quite self-explanatory.&#13;
We prefer to find and publish the fundamental operations that clients can build on, rather than hiding them inside functions.&#13;
Pulling on this thread, we might expand the functionality of <code>isIn</code> by making <code>region</code> optional:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">CampSite</code><code class="p">.</code><code class="n">isIn</code><code class="p">(</code><code class="n">countryISO</code><code class="p">:</code> <code class="n">String</code><code class="p">,</code> <code class="n">region</code><code class="p">:</code> <code class="n">String</code><code class="p">?</code> <code class="p">=</code> <code class="k">null</code><code class="p">)</code> <code class="p">=</code>&#13;
    <code class="k">when</code> <code class="p">(</code><code class="n">region</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="k">null</code> <code class="p">-&gt;</code> <code class="n">countryCode</code> <code class="p">==</code> <code class="n">countryISO</code>&#13;
        <code class="k">else</code> <code class="p">-&gt;</code> <code class="n">countryCode</code> <code class="p">==</code> <code class="n">countryISO</code> <code class="p">&amp;&amp;</code>&#13;
            <code class="n">region</code><code class="p">.</code><code class="n">equals</code><code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="n">region</code><code class="p">,</code> <code class="n">ignoreCase</code> <code class="p">=</code> <code class="k">true</code><code class="p">)</code>&#13;
    <code class="p">}</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=11.11&amp;show=file">Example 11.11 [methods-to-properties.8:src/main/java/travelator/CampSites.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=11.11&amp;show=diff">(diff)</a>&#13;
</div>&#13;
&#13;
<p>Nat prefers the same, but with an Elvis operator:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">CampSite</code><code class="p">.</code><code class="n">isIn</code><code class="p">(</code><code class="n">countryISO</code><code class="p">:</code> <code class="n">String</code><code class="p">,</code> <code class="n">region</code><code class="p">:</code> <code class="n">String</code><code class="p">?</code> <code class="p">=</code> <code class="k">null</code><code class="p">)</code> <code class="p">=</code>&#13;
    <code class="n">countryCode</code> <code class="p">==</code> <code class="n">countryISO</code> <code class="p">&amp;&amp;</code>&#13;
        <code class="n">region</code><code class="o">?.</code><code class="n">equals</code><code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="n">region</code><code class="p">,</code> <code class="n">ignoreCase</code> <code class="p">=</code> <code class="k">true</code><code class="p">)</code> <code class="o">?:</code> <code class="k">true</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=11.12&amp;show=file">Example 11.12 [methods-to-properties.9:src/main/java/travelator/CampSites.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=11.12&amp;show=diff">(diff)</a>&#13;
</div>&#13;
&#13;
<p>Duncan likes a good Elvis but thinks the code is clearer his way.&#13;
Your team will probably have these little battles (choose Duncan’s way).</p>&#13;
&#13;
<p>A fundamental operation like <code>isIn</code> might now be promoted to a method (as opposed to an extension function) on <code>Campsite</code> or, even better, <code>Address</code>.&#13;
This way, the problem of regions not being entities is confined to the type closest to the problem, and fixing it there will have the least effect on the rest of the codebase.<a data-primary="" data-startref="MPreftop11" data-type="indexterm" id="idm46393386554872"/><a data-primary="" data-startref="IJconvert11" data-type="indexterm" id="idm46393386553896"/><a data-primary="" data-startref="Rmethods11" data-type="indexterm" id="idm46393386552952"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Moving On" data-type="sect1"><div class="sect1" id="idm46393387674072">&#13;
<h1>Moving On</h1>&#13;
&#13;
<p>Kotlin provides a convenient syntax for both field-backed and computed properties that allows us to express the difference between accessing a property and calling a function, even if they are the same message-passing mechanism under the hood.</p>&#13;
&#13;
<p>We should prefer a property to a method when it applies to a value type, depends only on the value, and is not expensive to compute.&#13;
In these cases, refactoring from a method to a property is simple and makes our code easier to understand.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section></body></html>