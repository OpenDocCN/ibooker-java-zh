<html><head></head><body>
<div id="sbo-rt-content"><section data-pdf-bookmark="Chapter 3. Functional Interfaces of the JDK" data-type="chapter" epub:type="chapter"><div class="chapter" id="_01-functional-jdk">
<h1><span class="label">Chapter 3. </span>Functional Interfaces of the JDK</h1>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45115250319728">
<h1>A Note for Early Release Readers</h1>
<p>With Early Release ebooks, you get books in their earliest form—the author’s raw and unedited content as they write—so you can take advantage of these technologies long before the official release of these titles.</p>
<p>This will be the 3rd chapter of the final book. Please note that the GitHub repo will be made active later on.</p>
<p>If you have comments about how we might improve the content and/or examples in this book, or if you notice missing material within this chapter, please reach out to the editor at <em>rfernando@oreilly.com</em>.</p>
</div></aside>
<p>Many functional programming languages only use a singular and dynamic concept of “functions” to describe their lambdas, regardless of their arguments, return type, or actual use case.
Java, on the other hand, is a strictly typed language requiring tangible types for everything, including lambdas.
That’s why the JDK provides you with over 40 readily available functional interfaces in its <code>java.util.functional</code> package to kickstart your functional toolset.</p>
<p>This chapter will show you the most important functional interfaces, explain why there are so many variations, and show how you can extend your own code to be more functional.</p>
<section data-pdf-bookmark="The Big Four Functional Interface Categories" data-type="sect1"><div class="sect1" id="_01-functions_the-big-four">
<h1>The Big Four Functional Interface Categories</h1>
<p>The 40+ functional interfaces in <code>java.util.functional</code> fall into four main categories with each category representing an essential functional use case:</p>
<ul>
<li>
<p><em>Functions</em> accept arguments and return a result.</p>
</li>
<li>
<p><em>Consumers</em> only accept arguments but do not return a result.</p>
</li>
<li>
<p><em>Suppliers</em> do not accept arguments and only return a result.</p>
</li>
<li>
<p><em>Predicates</em> accept arguments to test against an expression and return a <code>boolean</code> primitive as their result.</p>
</li>
</ul>
<p>These four categories cover many use cases and their names relate to functional interface types and their variants.</p>
<p>Let’s take a look at the four main categories of functional interfaces.</p>
<section data-pdf-bookmark="Functions" data-type="sect2"><div class="sect2" id="idm45115250286912">
<h2>Functions</h2>
<p>Functions with their corresponding <code>java.util.functional.Function&lt;T, R&gt;</code> interface, are one of the most central functional interfaces.
They represent a “classical” function with a single input and output, as seen in <a data-type="xref" href="#_01-functions_big-four_function">Figure 3-1</a>:</p>
<figure><div class="figure" id="_01-functions_big-four_function">
<img alt="Function&lt;T, R&gt;" height="66" src="assets/afaj_0301.png" width="268"/>
<h6><span class="label">Figure 3-1. </span><code>Function&lt;T, R&gt;</code></h6>
</div></figure>
<p>The single abstract method of <code>Function&lt;T, R&gt;</code> is called <code>apply</code> and accepts an argument of a type <code>T</code> and produces a result of type <code>R</code>:</p>
<pre data-code-language="java" data-type="programlisting"><code class="nd">@FunctionalInterface</code>
<code class="kd">public</code> <code class="kd">interface</code> <code class="nc">Function</code><code class="o">&lt;</code><code class="n">T</code><code class="p">,</code> <code class="n">R</code><code class="o">&gt;</code> <code class="p">{</code>

  <code class="n">R</code> <code class="nf">apply</code><code class="p">(</code><code class="n">T</code> <code class="n">t</code><code class="p">);</code>
<code class="p">}</code></pre>
<p>The following code shows how to <code>null</code>-check and convert a <code>String</code> to its length as an <code>Integer</code>:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">Function</code><code class="o">&lt;</code><code class="n">String</code><code class="p">,</code> <code class="n">Integer</code><code class="o">&gt;</code> <code class="n">stringLength</code> <code class="o">=</code> <code class="n">str</code> <code class="o">-&gt;</code> <code class="n">str</code> <code class="o">!=</code> <code class="kc">null</code> <code class="o">?</code> <code class="n">str</code><code class="p">.</code><code class="na">length</code><code class="p">()</code> <code class="p">:</code> <code class="mi">0</code><code class="p">;</code>

<code class="n">Integer</code> <code class="n">result</code> <code class="o">=</code> <code class="n">stringLength</code><code class="p">.</code><code class="na">apply</code><code class="p">(</code><code class="s">"Hello, Function!"</code><code class="p">);</code></pre>
<p>The input type <code>T</code> and output type <code>R</code> can be identical.
However, in <a data-type="xref" href="#_01-functions_function-arity">“Function Arity”</a> I discuss specialized functional interface variants with identical types.</p>
</div></section>
<section data-pdf-bookmark="Consumers" data-type="sect2"><div class="sect2" id="idm45115250178560">
<h2>Consumers</h2>
<p>As the name suggests, a Consumer only <em>consumes</em> an input parameter but doesn’t return anything, as shown in <a data-type="xref" href="#_01-functions_big-four_consumer">Figure 3-2</a>.
The central Consumer functional interface is <code>java.util.functional.Consumer&lt;T&gt;</code>.</p>
<figure><div class="figure" id="_01-functions_big-four_consumer">
<img alt="Consumer&lt;T&gt;" height="66" src="assets/afaj_0302.png" width="193"/>
<h6><span class="label">Figure 3-2. </span><code>Consumer&lt;T&gt;</code></h6>
</div></figure>
<p>The single abstract method of <code>Consumer&lt;T&gt;</code> is called <code>accept</code> and requires an argument of a type <code>T</code>:</p>
<pre data-code-language="java" data-type="programlisting"><code class="nd">@FunctionalInterface</code>
<code class="kd">public</code> <code class="kd">interface</code> <code class="nc">Consumer</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code> <code class="p">{</code>

  <code class="kt">void</code> <code class="nf">accept</code><code class="p">(</code><code class="n">T</code> <code class="n">t</code><code class="p">);</code>
<code class="p">}</code></pre>
<p>The following code consumes a <code>String</code> to print it:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">Consumer</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code> <code class="n">println</code> <code class="o">=</code> <code class="n">str</code> <code class="o">-&gt;</code> <code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="n">str</code><code class="p">);</code>

<code class="n">println</code><code class="p">.</code><code class="na">accept</code><code class="p">(</code><code class="s">"Hello, Consumer!"</code><code class="p">);</code></pre>
<p>Even though the sole consumption of a value in an expression might not fit into “pure” functional concepts, it’s an essential component for employing a more functional coding style in Java, bridging many gaps between non-functional code and higher-order functions.</p>
<p>The <code>Consumer&lt;T&gt;</code> interface is similar to the Java 5+ <code>Callable&lt;V&gt;</code> found in the <code>java.util.concurrent</code> package, except the latter, throws a checked exception.
The concept of checked and unchecked exceptions and their implications for functional code in Java will be explored in detail in <a data-type="xref" href="ch10.xhtml#_02-exception-handling">Chapter 10</a>.</p>
</div></section>
<section data-pdf-bookmark="Suppliers" data-type="sect2"><div class="sect2" id="idm45115250029136">
<h2>Suppliers</h2>
<p>Suppliers are the antithesis of Consumers.
Based around the central functional interface <code>java.util.functional.Supplier&lt;T&gt;</code>, the different Supplier variants don’t accept any input parameters but return a single value of type <code>T</code>, as shown in <a data-type="xref" href="#_01-functions_big-four_supplier">Figure 3-3</a>.</p>
<figure><div class="figure" id="_01-functions_big-four_supplier">
<img alt="Supplier&lt;T&gt;" height="66" src="assets/afaj_0303.png" width="193"/>
<h6><span class="label">Figure 3-3. </span><code>Supplier&lt;T&gt;</code></h6>
</div></figure>
<p>The single abstract method of <code>Supplier&lt;T&gt;</code> is called <code>get</code>:</p>
<pre data-code-language="java" data-type="programlisting"><code class="nd">@FunctionalInterface</code>
<code class="kd">public</code> <code class="kd">interface</code> <code class="nc">Supplier</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code> <code class="p">{</code>

  <code class="n">T</code> <code class="nf">get</code><code class="p">();</code>
<code class="p">}</code></pre>
<p>The following supplier provides a new random value on calling <code>get()</code>:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">Supplier</code><code class="o">&lt;</code><code class="n">Double</code><code class="o">&gt;</code> <code class="n">random</code> <code class="o">=</code> <code class="p">()</code> <code class="o">-&gt;</code> <code class="n">Math</code><code class="p">.</code><code class="na">random</code><code class="p">();</code>

<code class="n">Double</code> <code class="n">result</code> <code class="o">=</code> <code class="n">random</code><code class="p">.</code><code class="na">get</code><code class="p">();</code></pre>
<p>Suppliers are often used for deferred execution, like wrapping an expensive task into them and only calling <code>get</code> when needed, as I will discuss in <a data-type="xref" href="ch11.xhtml#_02-lazy-evaluation">Chapter 11</a>.</p>
</div></section>
<section data-pdf-bookmark="Predicates" data-type="sect2"><div class="sect2" id="idm45115249948208">
<h2>Predicates</h2>
<p>Predicates are functions that accept a single argument to be tested against its logic and return either <code>true</code> or <code>false</code>.
The syntax for the main functional interface <code>java.util.functional.Predicate&lt;T&gt;</code> is illustrated in <a data-type="xref" href="#_01-functions_big-four_predicate">Figure 3-4</a>.</p>
<figure><div class="figure" id="_01-functions_big-four_predicate">
<img alt="Predicate&lt;T&gt;" height="66" src="assets/afaj_0304.png" width="300"/>
<h6><span class="label">Figure 3-4. </span><code>Predicate&lt;T&gt;</code></h6>
</div></figure>
<p>The single abstract method is called <code>test</code> and accepts an argument of a type <code>T</code> and returns a <code>boolean</code> primitive:</p>
<pre data-code-language="java" data-type="programlisting"><code class="nd">@FunctionalInterface</code>
<code class="kd">public</code> <code class="kd">interface</code> <code class="nc">Predicate</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code> <code class="p">{</code>

  <code class="kt">boolean</code> <code class="nf">test</code><code class="p">(</code><code class="n">T</code> <code class="n">t</code><code class="p">);</code>
<code class="p">}</code></pre>
<p>It’s the go-to functional interface for decision-making, like <code>filter</code> methods of the functional pattern <em>map/filter/reduce</em> you will learn more about later on in <a data-type="xref" href="ch06.xhtml#_02-data-processing">Chapter 6</a>.</p>
<p>The following code tests an <code>Integer</code> to be over 9000:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">Predciate</code><code class="o">&lt;</code><code class="n">Integer</code><code class="o">&gt;</code> <code class="n">over9000</code> <code class="o">=</code> <code class="n">i</code> <code class="o">-&gt;</code> <code class="n">i</code> <code class="o">&gt;</code> <code class="mi">9_000</code><code class="p">;</code>

<code class="n">Integer</code> <code class="n">result</code> <code class="o">=</code> <code class="n">over9000</code><code class="p">.</code><code class="na">test</code><code class="p">(</code><code class="mi">1_234</code><code class="p">);</code></pre>
</div></section>
</div></section>
<section data-pdf-bookmark="Why So Many Functional Interface Variants?" data-type="sect1"><div class="sect1" id="_01-functions_specialized-functional-intefaces">
<h1>Why So Many Functional Interface Variants?</h1>
<p>Although the big four categories and their main functional interface representations already cover many use cases, there are also variations and more specialized variants you can use.
All these different types are necessary to fit lambdas into Java without a trade-off in backward compatibility.
Due to this, though, using lambdas in Java is a little bit more complicated than in other languages.
Still, integrating such a feature without breaking the vast ecosystem is worth it in my opinion.</p>
<p>There are ways to bridge between different functional interfaces, and each variant has its own optimal problem context to be used in.
Handling so many different types might seem intimidating at first, but it will become almost second nature to know which type to use for what scenario after using a more functional approach for a while.</p>
<section data-pdf-bookmark="Function Arity" data-type="sect2"><div class="sect2" id="_01-functions_function-arity">
<h2>Function Arity</h2>
<p>The concept of <em>arity</em> describes the number of operands that a function accepts.
For example, an arity of one means that a lambda accepts a single argument, as follows:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">Function</code><code class="o">&lt;</code><code class="n">String</code><code class="p">,</code> <code class="n">String</code><code class="o">&gt;</code> <code class="n">greeterFn</code> <code class="o">=</code> <code class="n">name</code> <code class="o">-&gt;</code> <code class="s">"Hello "</code> <code class="o">+</code> <code class="n">name</code><code class="p">;</code></pre>
<p>As the number of arguments in Java methods, like a SAM, is fixed<sup><a data-type="noteref" href="ch03.xhtml#idm45115249764864" id="idm45115249764864-marker">1</a></sup>, there must be an explicit functional interface representing every required arity.
To support arities higher than one, the JDK includes specialized variants of the main functional interface categories that accept arguments, as listed in <a data-type="xref" href="#_01-functions_arity_types">Table 3-1</a>.</p>
<table id="_01-functions_arity_types">
<caption><span class="label">Table 3-1. </span>Arity-based Functional Interfaces</caption>
<thead>
<tr>
<th>Arity of one</th>
<th>Arity of two</th>
</tr>
</thead>
<tbody>
<tr>
<td><p><code>Function&lt;T, R&gt;</code></p></td>
<td><p><code>BiFunction&lt;T, U, R&gt;</code></p></td>
</tr>
<tr>
<td><p><code>Consumer&lt;T&gt;</code></p></td>
<td><p><code>BiConsumer&lt;T, U&gt;</code></p></td>
</tr>
<tr>
<td><p><code>Predicate&lt;T&gt;</code></p></td>
<td><p><code>BiPredicate&lt;T, U&gt;</code></p></td>
</tr>
</tbody>
</table>
<p>Only functions interfaces with an arity of up to two are supported out-of-the-box.
Looking at the functional APIs and use cases in Java, arities of one or two cover the most common tasks.
That’s most likely why the Java language designers decided to stop there and didn’t add any higher arities out-of-the-box.</p>
<p>Adding higher arities is simple though, like in the following code:</p>
<pre data-code-language="java" data-type="programlisting"><code class="nd">@FunctionalInterface</code>
<code class="kd">public</code> <code class="kd">interface</code> <code class="nc">TriFunction</code><code class="o">&lt;</code><code class="n">T</code><code class="p">,</code> <code class="n">U</code><code class="p">,</code> <code class="n">V</code><code class="p">,</code> <code class="n">R</code><code class="o">&gt;</code> <code class="p">{</code>

  <code class="n">R</code> <code class="nf">accept</code><code class="p">(</code><code class="n">T</code> <code class="n">t</code><code class="p">,</code> <code class="n">U</code> <code class="n">u</code><code class="p">,</code> <code class="n">V</code><code class="p">,</code> <code class="n">v</code><code class="p">);</code>
<code class="p">}</code></pre>
<p>However, I wouldn’t recommend it unless it’s an absolute necessity.
As you will see throughout this chapter and the book, the included functional interface give you a lot of additional functionality through <code>static</code> and <code>default</code> methods.
That’s why relying on them ensures the best compatibility and well-understood usage patterns.</p>
<section data-pdf-bookmark="Functional Operators" data-type="sect3"><div class="sect3" id="idm45115249677472">
<h3>Functional Operators</h3>
<p>The concept of operators simplifies the two most commonly used arities by giving you functional interfaces with identical generic types.
For example, if you require a function to accept two <code>String</code> arguments to create another <code>String</code> value, the type definition of <code>BiFunctuon&lt;String, String, String&gt;</code> would be quite repetitive.
Instead, you can use a <code>BinaryOperator&lt;String&gt;</code> which is defined as follows:</p>
<pre data-code-language="java" data-type="programlisting"><code class="nd">@FunctionalInteface</code>
<code class="kd">interface</code> <code class="nc">BinaryOperator</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code> <code class="kd">extends</code> <code class="n">BiFunction</code><code class="o">&lt;</code><code class="n">T</code><code class="p">,</code> <code class="n">T</code><code class="p">,</code> <code class="n">T</code><code class="o">&gt;</code> <code class="p">{</code>
  <code class="c1">// ...</code>
<code class="p">}</code></pre>
<p>Implementing a comment super interface allows you to write more concise code with more meaningful types.</p>
<p>The available operator functional interfaces are listed in <a data-type="xref" href="#_01-functions_operator_types">Table 3-2</a>.</p>
<table id="_01-functions_operator_types">
<caption><span class="label">Table 3-2. </span>Operator Functional Interfaces</caption>
<thead>
<tr>
<th>Arity</th>
<th>Operator</th>
<th>Super Interface</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>1</p></td>
<td><p><code>UnaryOperator&lt;T&gt;</code></p></td>
<td><p><code>Function&lt;T, T&gt;</code></p></td>
</tr>
<tr>
<td><p>2</p></td>
<td><p><code>BinaryOperator&lt;T&gt;</code></p></td>
<td><p><code>BiFunction&lt;T, T, T&gt;</code></p></td>
</tr>
</tbody>
</table>
<p>Be aware that operator types and their <code>super</code> interface aren’t interchangeable, though.
That’s especially important when designing APIs.</p>
<p>Imagine a method signature requires a <code>UnaryOperator&lt;String&gt;</code> as an argument, it won’t be compatible with <code>Function&lt;String, String&gt;</code>.
However, the other way around works, as shown in <a data-type="xref" href="#_01-functions_arity_compatibility">Example 3-1</a>.</p>
<div data-type="example" id="_01-functions_arity_compatibility">
<h5><span class="label">Example 3-1. </span>Java arity compatibility</h5>
<pre data-code-language="java" data-type="programlisting"><code class="n">UnaryOperator</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code> <code class="n">unaryOp</code> <code class="o">=</code> <code class="n">String</code><code class="p">::</code><code class="n">toUpperCase</code><code class="p">;</code>

<code class="n">Function</code><code class="o">&lt;</code><code class="n">String</code><code class="p">,</code> <code class="n">String</code><code class="o">&gt;</code> <code class="n">func</code> <code class="o">=</code> <code class="n">String</code><code class="p">::</code><code class="n">toUpperCase</code><code class="p">;</code>


<code class="kt">void</code> <code class="nf">acceptsUnary</code><code class="p">(</code><code class="n">UnaryOperator</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code> <code class="n">unaryOp</code><code class="p">)</code> <code class="p">{</code> <code class="p">...</code> <code class="p">};</code>

<code class="kt">void</code> <code class="nf">acceptsFunction</code><code class="p">(</code><code class="n">Function</code><code class="o">&lt;</code><code class="n">String</code><code class="p">,</code> <code class="n">String</code><code class="o">&gt;</code> <code class="n">func</code><code class="p">)</code> <code class="p">{</code> <code class="p">...</code> <code class="p">};</code>

<code class="n">acceptsUnary</code><code class="p">(</code><code class="n">unaryOp</code><code class="p">);</code> <code class="c1">// OK</code>
<code class="n">acceptsUnary</code><code class="p">(</code><code class="n">func</code><code class="p">);</code> <code class="c1">// COMPILE-ERROR</code>

<code class="n">acceptsFunction</code><code class="p">(</code><code class="n">func</code><code class="p">);</code> <code class="c1">// OK</code>
<code class="n">acceptsFunction</code><code class="p">(</code><code class="n">unaryOp</code><code class="p">);</code> <code class="c1">// OK</code></pre></div>
<p>That example highlights that you should choose the most common denominator for method arguments, in this case, <code>Function&lt;String, String&gt;</code>, as they give you the most compatibility.
Even though it increases the verbosity of your method signatures, it’s an acceptable trade-off, in my opinion, because it maximizes usability and doesn’t restrict an argument to a specialized functional interface.
When creating a lambda, on the other hand, the specialized type allows for more concise code without losing any expressiveness in your code.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="Primitive Types" data-type="sect2"><div class="sect2" id="_01-functional_primitives">
<h2>Primitive Types</h2>
<p>Most of the functional interfaces you’ve encountered so far had a generic type definition, but that’s not always the case.
Primitive types can’t be used as generic types (yet).
That’s why there are specialized functional interfaces for primitives.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="_01-functions_project-valhalla">
<h1>Project Valhalla and Specialized Generics</h1>
<p>The OpenJDK <a href="https://openjdk.java.net/projects/valhalla/">Project Valhalla</a> is an experimental JDK project to develop multiple changes to the Java language itself.
One change they’re working on that is quite relevant to simplify lambdas is “specialized generics.”</p>
<p>As it stands, generic type arguments are constrained to types that extend <code>java.lang.Object</code>, meaning that they are not compatible with primitives.
Your only option is to use auto-boxed types like <code>java.lang.Integer</code>, etc., which has performance implications and other pitfalls compared to using primitives directly.</p>
<p>It started in 2014, and in March 2020, the team behind it previewed five distinct prototypes to tackle the associated aspects of the problems.
At the time of writing, there isn’t an official release date yet.</p>
</div></aside>
<p>You <em>could</em> use any generic functional interface for the object wrapper type and let autoboxing take care of the rest.
However, auto-boxing isn’t <em>free</em>, so it can have a performance impact.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Autoboxing and unboxing is the automatic conversion between primitive value types and their object-based counterparts so they can be used indiscriminately.
For example, autoboxing an <code>int</code> to an <code>Integer</code>.
The other way around is called unboxing.</p>
</div>
<p>That’s why many of the functional interfaces provided by the JDK deal with primitive types to avoid autoboxing.
Such primitive functional interfaces, like the arity specializations, aren’t available for all primitives, though.
They are mostly concentrated around the numeric primitives <code>int</code>, <code>long</code>, and <code>double</code>.</p>
<p><a data-type="xref" href="#_01-functions_primitive-functional-interfaces">Table 3-3</a> lists the available functional interfaces for <code>int</code>, but there are equivalent interfaces for <code>long</code> and <code>double</code> as well.</p>
<table id="_01-functions_primitive-functional-interfaces">
<caption><span class="label">Table 3-3. </span>Functional Interfaces for the integer primitive</caption>
<thead>
<tr>
<th>Category</th>
<th>Functional Interface</th>
<th>Boxed Alternative</th>
</tr>
</thead>
<tbody>
<tr>
<td rowspan="7"><p>Functions</p></td>
<td><p><code>IntFunction&lt;R&gt;</code></p></td>
<td><p><code>Function&lt;Integer, R&gt;</code></p></td>
</tr>
<tr>
<td><p><code>IntUnaryOperator</code></p></td>
<td><p><code>UnaryOperator&lt;Integer&gt;</code></p></td>
</tr>
<tr>
<td><p><code>IntBinaryOperator</code></p></td>
<td><p><code>BinaryOperator&lt;Integer&gt;</code></p></td>
</tr>
<tr>
<td><p><code>ToIntFunction&lt;T&gt;</code></p></td>
<td><p><code>Function&lt;T, Integer&gt;</code></p></td>
</tr>
<tr>
<td><p><code>ToIntBiFunction&lt;T, U&gt;</code></p></td>
<td><p><code>BiFunction&lt;T, U, Integer&gt;</code></p></td>
</tr>
<tr>
<td><p><code>IntToDoubleFunction</code></p></td>
<td><p><code>Function&lt;Integer, Double&gt;</code></p></td>
</tr>
<tr>
<td><p><code>IntToLongFunction</code></p></td>
<td><p><code>Function&lt;Integer, Long&gt;</code></p></td>
</tr>
<tr>
<td rowspan="2"><p>Consumers</p></td>
<td><p><code>IntConsumer</code></p></td>
<td><p><code>Consumer&lt;Integer&gt;</code></p></td>
</tr>
<tr>
<td><p><code>ObjIntConsumer&lt;T&gt;</code></p></td>
<td><p><code>BiConsumer&lt;T, Integer&gt;</code></p></td>
</tr>
<tr>
<td><p>Suppliers</p></td>
<td><p><code>IntSupplier</code></p></td>
<td><p><code>Supplier&lt;Integer&gt;</code></p></td>
</tr>
<tr>
<td><p>Predicates</p></td>
<td><p><code>IntPredicate</code></p></td>
<td><p><code>Predicate&lt;Integer&gt;</code></p></td>
</tr>
</tbody>
</table>
<p>The <code>boolean</code> primitive has only a single specialized variant available: <code>BooleanSupplier</code>.</p>
<p>Functional interfaces for primitives aren’t the only special consideration in the new functional parts of Java to accommodate primitives.
As you will learn later in this book, Streams and Optionals provide specialized types, too, to reduce the unnecessary overhead incurred by autoboxing.</p>
</div></section>
<section data-pdf-bookmark="Bridging Functional Interfaces" data-type="sect2"><div class="sect2" id="_01-functional-jdk_bridging-functional-interfaces">
<h2>Bridging Functional Interfaces</h2>
<p>Functional interfaces are, well, interfaces, and lambda expressions are concrete implementations of these interfaces.
Type inference makes it easy to forget that you can’t use them interchangeably or simply cast between unrelated interfaces.
Even if their method signatures are identical, an exception is thrown, as seen previously in <a data-type="xref" href="ch02.xhtml#_01-functional-java_lambdas-in-action-creating">“Creating Lambdas”</a>:</p>
<pre data-code-language="java" data-type="programlisting" id="_01-functions_casting"><code class="kd">interface</code> <code class="nc">LikePredicate</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code> <code class="p">{</code>
  <code class="kt">boolean</code> <code class="nf">test</code><code class="p">(</code><code class="n">T</code> <code class="n">value</code><code class="p">)</code><code class="p">;</code> <a class="co" href="#callout_functional_interfaces_of_the_jdk_CO1-1" id="co_functional_interfaces_of_the_jdk_CO1-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a>
<code class="p">}</code>

<code class="n">LikePredicate</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code> <code class="n">isNull</code> <code class="o">=</code> <code class="n">str</code> <code class="o">-</code><code class="o">&gt;</code> <code class="n">str</code> <code class="o">=</code><code class="o">=</code> <code class="kc">null</code><code class="p">;</code>

<code class="n">Predicate</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code> <code class="n">wontCompile</code> <code class="o">=</code> <code class="n">isNull</code><code class="p">;</code>
<code class="c1">// Error:</code>
<code class="c1">// incompatible types: LikePredicate&lt;java.lang.String&gt; cannot be</code>
<code class="c1">// converted to java.util.function.Predicate&lt;java.lang.String&gt;</code>

<code class="n">Predicate</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code> <code class="n">wontCompileEither</code> <code class="o">=</code> <code class="p">(</code><code class="n">Predicate</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code><code class="p">)</code> <code class="n">isNull</code><code class="p">;</code>
<code class="c1">// Exception java.lang.ClassCastException: class LikePredicate</code>
<code class="c1">// cannot be cast to class java.util.function.Predicate</code></pre>
<p>From a lambda-based point of view, both SAMs are identical.
They both accept a <code>String</code> argument and return an <code>boolean</code> result.
For Java’s type-system, though, they have no connection whatsoever, making a cast between them impossible.
Still, the gap between “lambda-compatible but type-incompatible” functional interfaces can be bridged by a feature I discussed in the previous chapter: <em>method references</em>.</p>
<p>By using a method reference instead of trying to cast between the “identical but incompatible” functional interfaces, you can refer to the SAM instead to make your code compile:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">Predicate</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code> <code class="n">thisIsFine</code> <code class="o">=</code> <code class="n">isNull</code><code class="p">::</code><code class="n">test</code><code class="p">;</code></pre>
<p>Using a method reference creates a new dynamic call site to be invoked by the bytecode opcode <code>invokedynamic</code> instead of trying to implicitly or explicitly cast the functional interface itself.</p>
<p>Like re-finalizing variables that you’ve learned about in <a data-type="xref" href="ch02.xhtml#_01-functions-refinalize">“Re-finalizing a Reference”</a>, bridging functional interfaces with method references is another “band-aid” to deal with code that can’t be refactored or redesigned another way.
Still, it’s an easy-to-use and sometimes necessary tool to have in your functional kit, especially if you’re transitioning from a legacy code base to a more functional approach, or work with third-party code that provides its own functional interfaces.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="Functional Composition" data-type="sect1"><div class="sect1" id="_01-functional-jdk_functional-composition">
<h1>Functional Composition</h1>
<p>Functional composition is an essential part of the functional approach to combine small functional units into a bigger, more complex task, and Java got you covered.
However, it’s done in a typical Java fashion to ensure backward compatibility.
Instead of introducing a new keyword, or changing any language semantics, Java uses “glue” methods that are directly implemented on the functional interfaces themselves as <code>default</code> methods.
With their help, you can compose the big four categories of functional interfaces easily.
Such glue methods build the bridge between two functional interfaces by returning a new one with the combined functionality.</p>
<p>In the case of <code>Function&lt;T, R&gt;</code>, two <code>default</code> methods are available:</p>
<ul>
<li>
<p><code>&lt;V&gt; Function&lt;V, R&gt; compose(Function&lt;? super V, ? extends T&gt; before)</code></p>
</li>
<li>
<p><code>&lt;V&gt; Function&lt;T, V&gt; andThen(Function&lt;? super R, ? extends V&gt; after)</code></p>
</li>
</ul>
<p>The difference between these two methods is the direction of the composition, as indicated by the argument names and the returned <code>Function</code> and its generic types.
The first one, <code>compose</code>, creates a composed function that applies the <code>before</code> argument to its input and the result to <code>this</code>.
The second one, <code>andThen</code>, is the antagonist to <code>compose</code>, as it evaluates <code>this</code> and then applies <code>after</code> to the previous result.</p>
<p>Which direction of functional composition to choose, <code>compose</code> or <code>andThen</code>, depends on the context and personal preference.
The call <code>fn1.compose(fn2)</code> leads to an equivalent call like <code>fn1(fn2(input))</code>.
To achieve the same flow with the <code>andThen</code> method, the compositional order must be reversed to a <code>fn2.andThen(fn1(input))</code> call, as illustrated in <a data-type="xref" href="#_01-functions_functional-composition_direction-figure">Figure 3-5</a>.</p>
<figure><div class="figure" id="_01-functions_functional-composition_direction-figure">
<img alt="Function&lt;T, R&gt; composition order" height="177" src="assets/afaj_0305.png" width="409"/>
<h6><span class="label">Figure 3-5. </span>Function&lt;T, R&gt; composition order</h6>
</div></figure>
<p>Personally, I prefer <code>andThen(…​)</code> because the resulting prose-like fluent method call-chain mirrors the logical flow of functions that’s easier to grasp for other readers that aren’t versed with functional programming naming conventions.</p>
<p>Think of manipulating a <code>String</code> by removing occurrences of any lowercase “a” and uppercasing the result.
The overall tasks consist of two <code>Function&lt;String, String&gt;</code> doing a singular thing.
Composing them can be done either way without a difference in the final result, if you use the appropriate glue method, as seen in <a data-type="xref" href="#_01-functions_functional-composition_direction">Example 3-2</a>.</p>
<div data-type="example" id="_01-functions_functional-composition_direction">
<h5><span class="label">Example 3-2. </span>Functional composition direction</h5>
<pre data-code-language="java" data-type="programlisting"><code class="n">Function</code><code class="o">&lt;</code><code class="n">String</code><code class="p">,</code> <code class="n">String</code><code class="o">&gt;</code> <code class="n">removeLowerCaseA</code> <code class="o">=</code> <code class="n">str</code> <code class="o">-&gt;</code> <code class="n">str</code><code class="p">.</code><code class="na">replace</code><code class="p">(</code><code class="s">"a"</code><code class="p">,</code> <code class="s">""</code><code class="p">);</code>
<code class="n">Function</code><code class="o">&lt;</code><code class="n">String</code><code class="p">,</code> <code class="n">String</code><code class="o">&gt;</code> <code class="n">upperCase</code> <code class="o">=</code> <code class="n">String</code><code class="p">::</code><code class="n">toUpperCase</code><code class="p">;</code>


<code class="kd">var</code> <code class="n">input</code> <code class="o">=</code> <code class="s">"abcd"</code><code class="p">;</code>

<code class="n">removeLowerCaseA</code><code class="p">.</code><code class="na">andThen</code><code class="p">(</code><code class="n">upperCase</code><code class="p">)</code>
                <code class="p">.</code><code class="na">apply</code><code class="p">(</code><code class="n">input</code><code class="p">);</code>
<code class="c1">// =&gt; "BCD"</code>

<code class="n">upperCase</code><code class="p">.</code><code class="na">compose</code><code class="p">(</code><code class="n">removeLowerCaseA</code><code class="p">)</code>
         <code class="p">.</code><code class="na">apply</code><code class="p">(</code><code class="n">input</code><code class="p">);</code>
<code class="c1">// =&gt; "BCD"</code></pre></div>
<p>Be aware that not every functional interface provides such “glue methods” to easily support composition, even if it would be sensible to do so.
The following list gives you a summary of how the different main interfaces of the big four categories support composition out of the box:</p>
<dl>
<dt><code>Function&lt;T, R&gt;</code></dt>
<dd>
<p><code>Function&lt;T, R&gt;</code>, and its specialized arities, like <code>UnaryOperator&lt;T&gt;</code>, support composition in both directions.
The <code>Bi…​</code> variants only support <code>andThen</code>.</p>
</dd>
<dt><code>Predicate&lt;T&gt;</code></dt>
<dd>
<p>Predicates support various methods to compose a new Predicate with common operations associated with them: <code>and</code>, <code>or</code>, <code>negate</code>.</p>
</dd>
<dt><code>Consumer&lt;T&gt;</code></dt>
<dd>
<p>Only <code>andThen</code> is supported, which will compose two Consumers to accept a value in sequence.</p>
</dd>
<dt>Specialized primitive functional interfaces</dt>
<dd>
<p>The support for functional composition among the specialized functional interfaces for primitives is not on par with their generic brethren.
Even among themselves, the support differs between the primitive types.</p>
</dd>
</dl>
<p>But don’t fret!
Writing your own functional compositional helper is easy, as I will discuss in the next section.</p>
</div></section>
<section data-pdf-bookmark="Extending Functional Support" data-type="sect1"><div class="sect1" id="idm45115249294672">
<h1>Extending Functional Support</h1>
<p>Most functional interfaces usually give you more than just their single abstract method defining the lambda signature.
Usually, they provide additional <code>default</code> methods to support concepts like functional composition, or <code>static</code> helpers to simplify common use cases of that type.</p>
<p>As you can’t change the types of the JDK yourself, you can still make your own types more functional instead.
There are three approaches you can choose that are also used by the JDK itself:</p>
<ul>
<li>
<p>Add <code>default</code> methods to an interface to make existing types more functional.</p>
</li>
<li>
<p>Implement a functional interface explicitly.</p>
</li>
<li>
<p>Create <code>static</code> helpers to provide common functional operations.</p>
</li>
</ul>
<section data-pdf-bookmark="Adding Default Methods" data-type="sect2"><div class="sect2" id="idm45115249110688">
<h2>Adding Default Methods</h2>
<p>Adding new functionality to an interface always requires you to implement new methods on all implementations.
When dealing with a small project, it might be fine to just update any implementation, but in bigger and shared projects it’s often not as easy.
In library code it’s even worse, you might break the code of anyone using your library.
That’s where <code>default</code> methods come in to save the day.</p>
<p>Instead of solely changing the contract of a type’s interface and letting anyone implementing it deal with the fallout — adding the new method on any type that implements the interface --⁠, you can use <code>default</code> methods to supply a “common-sense” implementation.
Such an implementation provides a general variant of the intended logic to all other types down the line, so you don’t have to throw an <code>UnsupportedOperationException</code>.
This way, your code is backward-compatible because only the interface itself has changed, but any type that implements the interface has still a chance to create its own, more fitting implementation if necessary.
That’s exactly how the JDK added Stream-support to any type implementing the interface <code>java.util.Collection&lt;E&gt;</code>.</p>
<p>The following code shows the actual <code>default</code> methods that give any <code>Collection</code>-based type Stream capabilities out of the box at no additional (implementation) cost:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">interface</code> <code class="nc">Collection</code><code class="o">&lt;</code><code class="n">E</code><code class="o">&gt;</code> <code class="kd">extends</code> <code class="n">Iterable</code><code class="o">&lt;</code><code class="n">E</code><code class="o">&gt;</code> <code class="p">{</code>

  <code class="k">default</code> <code class="n">Stream</code><code class="o">&lt;</code><code class="n">E</code><code class="o">&gt;</code> <code class="nf">stream</code><code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="n">StreamSupport</code><code class="p">.</code><code class="na">stream</code><code class="p">(</code><code class="n">spliterator</code><code class="p">(),</code> <code class="kc">false</code><code class="p">);</code>
  <code class="p">}</code>

  <code class="k">default</code> <code class="n">Stream</code><code class="o">&lt;</code><code class="n">E</code><code class="o">&gt;</code> <code class="nf">parallelStream</code><code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="n">StreamSupport</code><code class="p">.</code><code class="na">stream</code><code class="p">(</code><code class="n">spliterator</code><code class="p">(),</code> <code class="kc">true</code><code class="p">);</code>
  <code class="p">}</code>

  <code class="c1">// ...</code>
<code class="p">}</code></pre>
<p>The two <code>default</code> methods create new <code>Stream&lt;E&gt;</code> instances by calling the <code>static</code> helper <code>StreamSupport.stream(…​)</code> and the <code>default</code> method <code>spliterator()</code>.
The <code>spliterator()</code> is initially defined in <code>java.util.Iterable&lt;E&gt;</code> but is overridden as necessary, as shown in <a data-type="xref" href="#_01-functional-jdk_default-method-hierarchy">Example 3-3</a>.</p>
<div data-type="example" id="_01-functional-jdk_default-method-hierarchy">
<h5><span class="label">Example 3-3. </span>Default Method Hierarchy</h5>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">interface</code> <code class="nc">Iterable</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code> <code class="p">{</code> <a class="co" href="#callout_functional_interfaces_of_the_jdk_CO1-1" id="co_functional_interfaces_of_the_jdk_CO1-2"><img alt="1" height="12" src="assets/1.png" width="12"/></a>

  <code class="k">default</code> <code class="n">Spliterator</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code> <code class="nf">spliterator</code><code class="p">(</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="n">Spliterators</code><code class="p">.</code><code class="na">spliteratorUnknownSize</code><code class="p">(</code><code class="n">iterator</code><code class="p">(</code><code class="p">)</code><code class="p">,</code> <code class="mi">0</code><code class="p">)</code><code class="p">;</code> <a class="co" href="#callout_functional_interfaces_of_the_jdk_CO1-1" id="co_functional_interfaces_of_the_jdk_CO1-3"><img alt="1" height="12" src="assets/1.png" width="12"/></a>
  <code class="p">}</code>

  <code class="c1">// ...</code>
<code class="p">}</code>

<code class="kd">public</code> <code class="kd">interface</code> <code class="nc">Collection</code><code class="o">&lt;</code><code class="n">E</code><code class="o">&gt;</code> <code class="kd">extends</code> <code class="n">Iterable</code><code class="o">&lt;</code><code class="n">E</code><code class="o">&gt;</code> <code class="p">{</code>

  <code class="nd">@Override</code>
  <code class="k">default</code> <code class="n">Spliterator</code><code class="o">&lt;</code><code class="n">E</code><code class="o">&gt;</code> <code class="nf">spliterator</code><code class="p">(</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="n">Spliterators</code><code class="p">.</code><code class="na">spliterator</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="mi">0</code><code class="p">)</code><code class="p">;</code> <a class="co" href="#callout_functional_interfaces_of_the_jdk_CO1-2" id="co_functional_interfaces_of_the_jdk_CO1-4"><img alt="2" height="12" src="assets/2.png" width="12"/></a>
  <code class="p">}</code>

  <code class="c1">// ...</code>
<code class="p">}</code>

<code class="kd">public</code> <code class="kd">class</code> <code class="nc">ArrayList</code><code class="o">&lt;</code><code class="n">E</code><code class="o">&gt;</code> <code class="kd">extends</code> <code class="n">AbstractList</code><code class="o">&lt;</code><code class="n">E</code><code class="o">&gt;</code>
  <code class="kd">implements</code> <code class="n">List</code><code class="o">&lt;</code><code class="n">E</code><code class="o">&gt;</code><code class="p">,</code> <code class="p">.</code><code class="p">.</code><code class="p">.</code> <code class="p">{</code>

  <code class="nd">@Override</code>
  <code class="kd">public</code> <code class="n">Spliterator</code><code class="o">&lt;</code><code class="n">E</code><code class="o">&gt;</code> <code class="nf">spliterator</code><code class="p">(</code><code class="p">)</code> <code class="p">{</code>
      <code class="k">return</code> <code class="k">new</code> <code class="n">ArrayListSpliterator</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code> <code class="o">-</code><code class="mi">1</code><code class="p">,</code> <code class="mi">0</code><code class="p">)</code><code class="p">;</code> <a class="co" href="#callout_functional_interfaces_of_the_jdk_CO1-3" id="co_functional_interfaces_of_the_jdk_CO1-5"><img alt="3" height="12" src="assets/3.png" width="12"/></a>
  <code class="p">}</code>

  <code class="c1">// ...</code>
<code class="p">}</code></pre></div>
<dl class="calloutlist">
<dt><a class="co" href="#co_functional_interfaces_of_the_jdk_CO1-1" id="callout_functional_interfaces_of_the_jdk_CO1-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p>The original definition of <code>spliterator()</code> with a common-sense implementation based on all the available information for the type.</p></dd>
<dt><a class="co" href="#co_functional_interfaces_of_the_jdk_CO1-4" id="callout_functional_interfaces_of_the_jdk_CO1-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a></dt>
<dd><p>The <code>Collection</code> interface can use more information to create a more specific <code>Spliterator&lt;E&gt;</code> that is available to all of its implementations.</p></dd>
<dt><a class="co" href="#co_functional_interfaces_of_the_jdk_CO1-5" id="callout_functional_interfaces_of_the_jdk_CO1-3"><img alt="3" height="12" src="assets/3.png" width="12"/></a></dt>
<dd><p>The concrete implementation <code>ArrayList&lt;E&gt;</code>, which implements <code>Collection&lt;E&gt;</code> via <code>List&lt;E&gt;</code>, provides an even further specialized <code>Spliterator&lt;E&gt;</code>.</p></dd>
</dl>
<p>A hierarchy of <code>default</code> methods gives you the power to add new functionality to an interface without breaking any implementations and still providing a common-sense variant of the new method.
Even if a type never implements a more specific variant for itself, it can fall back to the logic provided by the <code>default</code> method.</p>
</div></section>
<section data-pdf-bookmark="Implementing Functional Interfaces Explicitly" data-type="sect2"><div class="sect2" id="idm45115248812336">
<h2>Implementing Functional Interfaces Explicitly</h2>
<p>Functional interfaces can be implemented implicitly via lambda or method references, but they are also useful when implemented explicitly by one of your types so they are usable in higher-order functions.
Some of your types might already implement one of the retroactively functional interfaces like <code>java.util.Comparator&lt;T&gt;</code> or <code>java.lang.Runnable</code>.</p>
<p>Implementing a functional interface directly creates a bridge between previously “non-functional” types and their easy usage in functional code.
A good example is the object-oriented <em>command design pattern</em>⁠<sup><a data-type="noteref" href="ch03.xhtml#idm45115248733296" id="idm45115248733296-marker">2</a></sup>.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The command pattern encapsulates an action, or “command”, and all data required to execute it in an object.
This approach decouples the creation of commands from consuming them.</p>
</div>
<p>Usually, a command already has a dedicated interface.
Imagine a text editor with its common commands like opening a file or saving it.
A shared command interface between these commands could be as simple as follows:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">interface</code> <code class="nc">TextEditorCommand</code> <code class="p">{</code>

  <code class="n">String</code> <code class="nf">execute</code><code class="p">();</code>
<code class="p">}</code></pre>
<p>The concrete command classes would accept the required arguments, but the executed command would simply return the updated editor content.
If you look closely, you see that the interface matches a <code>Supplier&lt;String&gt;</code>.</p>
<p>As I discussed in <a data-type="xref" href="#_01-functional-jdk_bridging-functional-interfaces">“Bridging Functional Interfaces”</a>, the mere logical equivalency between functional interfaces isn’t enough to create compatibility.
However, by extending <code>TextEditorCommand</code> with <code>Supplier&lt;String&gt;</code>, you bridge the gap with a <code>default</code> method, as follows:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">interface</code> <code class="nc">TextEditorCommand</code>
  <code class="kd">extends</code> <code class="n">Supplier</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code> <code class="p">{</code>

  <code class="n">String</code> <code class="nf">execute</code><code class="p">();</code>

  <code class="k">default</code> <code class="n">String</code> <code class="nf">get</code><code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="n">execute</code><code class="p">();</code>
  <code class="p">}</code>
<code class="p">}</code></pre>
<p>Interfaces allow multiple inheritance, so adding a functional interface shouldn’t be an issue.
The functional interface’s SAM is a simple <code>default</code> method calling the actual method doing the work.
This way, not a single command needs to be changed but all of them gain compatibility with any higher-order function accepting a <code>Supplier&lt;String&gt;</code> without requiring a method reference as a bridge.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>Look out for method signature collisions if existing interfaces implement a functional interface, so you don’t accidentally override an existing one.</p>
</div>
<p>Implementing one or more functional interfaces is a great way to give your types a functional starting point, including all the additional <code>default</code> methods available on the functional interfaces.</p>
</div></section>
<section data-pdf-bookmark="Creating Static Helpers" data-type="sect2"><div class="sect2" id="_01-functional-jdk_static-helpers">
<h2>Creating Static Helpers</h2>
<p>Functional interfaces usually extend their versatility by having <code>default</code> methods and <code>static</code> helpers for common tasks.
If you don’t have control over the type, though, like a functional interface provided by the JDK itself, you can create a helper type accumulating <code>static</code> methods.</p>
<p>In <a data-type="xref" href="#_01-functional-jdk_functional-composition">“Functional Composition”</a>, I discussed functional composition with the help of the available <code>default</code> methods on the big four interfaces.
Even though the most common use cases are covered, certain different functional interfaces aren’t covered.
You can create them yourself, however.</p>
<p>Let’s take a look at how <code>Function&lt;T, R&gt;</code> implements<sup><a data-type="noteref" href="ch03.xhtml#idm45115248649152" id="idm45115248649152-marker">3</a></sup> its <code>compose</code> method in <a data-type="xref" href="#_01-functional-java_func-compoisition_simplified-function-interface">Example 3-4</a>, so we can develop a compositor helper type to accept other types, too.</p>
<div data-type="example" id="_01-functional-java_func-compoisition_simplified-function-interface">
<h5><span class="label">Example 3-4. </span>Simplified <code>Function&lt;T, R&gt;</code> interface</h5>
<pre data-code-language="java" data-type="programlisting"><code class="nd">@FunctionalInterface</code>
<code class="kd">public</code> <code class="kd">interface</code> <code class="nc">Function</code><code class="o">&lt;</code><code class="n">T</code><code class="p">,</code> <code class="n">R</code><code class="o">&gt;</code> <code class="p">{</code>

    <code class="k">default</code> <code class="o">&lt;</code><code class="n">V</code><code class="o">&gt;</code> <code class="n">Function</code><code class="o">&lt;</code><code class="n">V</code><code class="p">,</code> <code class="n">R</code><code class="o">&gt;</code> <code class="nf">compose</code><code class="p">(</code><code class="n">Function</code><code class="o">&lt;</code><code class="n">V</code><code class="p">,</code> <code class="n">T</code><code class="o">&gt;</code> <code class="n">before</code><code class="p">)</code> <code class="p">{</code> <a class="co" href="#callout_functional_interfaces_of_the_jdk_CO2-1" id="co_functional_interfaces_of_the_jdk_CO2-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a>
        <code class="n">Objects</code><code class="p">.</code><code class="na">requireNonNull</code><code class="p">(</code><code class="n">before</code><code class="p">)</code><code class="p">;</code> <a class="co" href="#callout_functional_interfaces_of_the_jdk_CO2-2" id="co_functional_interfaces_of_the_jdk_CO2-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a>

        <code class="k">return</code> <code class="p">(</code><code class="n">V</code> <code class="n">v</code><code class="p">)</code> <code class="o">-</code><code class="o">&gt;</code> <code class="p">{</code> <a class="co" href="#callout_functional_interfaces_of_the_jdk_CO2-3" id="co_functional_interfaces_of_the_jdk_CO2-3"><img alt="3" height="12" src="assets/3.png" width="12"/></a>
          <code class="n">T</code> <code class="n">result</code> <code class="o">=</code> <code class="n">before</code><code class="p">.</code><code class="na">apply</code><code class="p">(</code><code class="n">v</code><code class="p">)</code><code class="p">;</code> <a class="co" href="#callout_functional_interfaces_of_the_jdk_CO2-4" id="co_functional_interfaces_of_the_jdk_CO2-4"><img alt="4" height="12" src="assets/4.png" width="12"/></a>
          <code class="k">return</code> <code class="n">apply</code><code class="p">(</code><code class="n">result</code><code class="p">)</code><code class="p">;</code> <a class="co" href="#callout_functional_interfaces_of_the_jdk_CO2-5" id="co_functional_interfaces_of_the_jdk_CO2-5"><img alt="5" height="12" src="assets/5.png" width="12"/></a>
        <code class="p">}</code><code class="p">;</code>
    <code class="p">}</code>

    <code class="c1">// ...</code>
<code class="p">}</code></pre></div>
<dl class="calloutlist">
<dt><a class="co" href="#co_functional_interfaces_of_the_jdk_CO2-1" id="callout_functional_interfaces_of_the_jdk_CO2-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p>The composed function isn’t bound to the original type <code>T</code> and introduces <code>V</code> in its method signature.</p></dd>
<dt><a class="co" href="#co_functional_interfaces_of_the_jdk_CO2-2" id="callout_functional_interfaces_of_the_jdk_CO2-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a></dt>
<dd><p>A <code>null</code>-check helper to throw a <code>NullPointerException</code> on composition and not only on the first use of the returned lambda.</p></dd>
<dt><a class="co" href="#co_functional_interfaces_of_the_jdk_CO2-3" id="callout_functional_interfaces_of_the_jdk_CO2-3"><img alt="3" height="12" src="assets/3.png" width="12"/></a></dt>
<dd><p>The returned lambda accepts a value of the newly introduced type <code>V</code>.</p></dd>
<dt><a class="co" href="#co_functional_interfaces_of_the_jdk_CO2-4" id="callout_functional_interfaces_of_the_jdk_CO2-4"><img alt="4" height="12" src="assets/4.png" width="12"/></a></dt>
<dd><p>The <code>before</code> function is evaluated first.</p></dd>
<dt><a class="co" href="#co_functional_interfaces_of_the_jdk_CO2-5" id="callout_functional_interfaces_of_the_jdk_CO2-5"><img alt="5" height="12" src="assets/5.png" width="12"/></a></dt>
<dd><p>The <code>result</code> is then applied to the original <code>Function&lt;T, R&gt;</code>.</p></dd>
</dl>
<p>To create your own compositional methods, you have to first think about what exactly you want to achieve.
The involved functional interfaces and their compositional order dictate the overall type chain that the method signature has to reflect:</p>
<dl>
<dt><code>Function&lt;T, R&gt;#compose(Function&lt;V, T&gt;)</code></dt>
<dd>
<p><code>V</code> → <code>T</code> → <code>R</code></p>
</dd>
<dt><code>Function&lt;T, R&gt;#andThen(Function&lt;R, V)</code></dt>
<dd>
<p><code>T</code> → <code>R</code> → <code>V</code>.</p>
</dd>
</dl>
<p>Let’s develop a compositor for <code>Function&lt;T, R&gt;</code> and <code>Supplier</code>/<code>Consumer</code>.</p>
<p>Only two combinations are possible because <code>Supplier</code> won’t accept arguments, so it can’t evaluate the result of the <code>Function&lt;T, R&gt;</code>.
The opposite reason is true for <code>Supplier</code>.
Because we can’t extend the <code>Function&lt;T, R&gt;</code> interface directly, an indirect compositor in form of a <code>static</code> helper is needed.
That leads to the following method signatures in which the compositional order is reflected by the argument order:</p>
<ul>
<li>
<p><code>Supplier&lt;R&gt; compose(Supplier&lt;T&gt; before, Function&lt;T, R&gt; fn)</code></p>
</li>
<li>
<p><code>Consumer&lt;T&gt; compose(Function&lt;T, R&gt; fn, Consumer&lt;R&gt; after)</code></p>
</li>
</ul>
<p><a data-type="xref" href="#_01-functional-java_func-compositor">Example 3-5</a> shows a simple compositor implementation that won’t differ much from the JDK’s implementation of equivalent methods.</p>
<div data-type="example" id="_01-functional-java_func-compositor">
<h5><span class="label">Example 3-5. </span>Functional Compositor</h5>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">final</code> <code class="kd">class</code> <code class="nc">Compositor</code> <code class="p">{</code>

  <code class="kd">public</code> <code class="kd">static</code> <code class="o">&lt;</code><code class="n">T</code><code class="p">,</code> <code class="n">R</code><code class="o">&gt;</code> <code class="n">Supplier</code><code class="o">&lt;</code><code class="n">R</code><code class="o">&gt;</code> <code class="nf">compose</code><code class="p">(</code><code class="n">Supplier</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code> <code class="n">before</code><code class="p">,</code>
                                           <code class="n">Function</code><code class="o">&lt;</code><code class="n">T</code><code class="p">,</code> <code class="n">R</code><code class="o">&gt;</code> <code class="n">fn</code><code class="p">)</code> <code class="p">{</code>
    <code class="n">Objects</code><code class="p">.</code><code class="na">requireNonNull</code><code class="p">(</code><code class="n">before</code><code class="p">);</code>
    <code class="n">Objects</code><code class="p">.</code><code class="na">requireNonNull</code><code class="p">(</code><code class="n">fn</code><code class="p">);</code>

    <code class="k">return</code> <code class="p">()</code> <code class="o">-&gt;</code> <code class="p">{</code>
      <code class="n">T</code> <code class="n">result</code> <code class="o">=</code> <code class="n">before</code><code class="p">.</code><code class="na">get</code><code class="p">();</code>
      <code class="k">return</code> <code class="n">fn</code><code class="p">.</code><code class="na">apply</code><code class="p">(</code><code class="n">result</code><code class="p">);</code>
    <code class="p">};</code>
  <code class="p">}</code>

  <code class="kd">public</code> <code class="kd">static</code> <code class="o">&lt;</code><code class="n">T</code><code class="p">,</code> <code class="n">R</code><code class="o">&gt;</code> <code class="n">Consumer</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code> <code class="nf">compose</code><code class="p">(</code><code class="n">Function</code><code class="o">&lt;</code><code class="n">T</code><code class="p">,</code> <code class="n">R</code><code class="o">&gt;</code> <code class="n">fn</code><code class="p">,</code>
                                           <code class="n">Consumer</code><code class="o">&lt;</code><code class="n">R</code><code class="o">&gt;</code> <code class="n">after</code><code class="p">)</code> <code class="p">{</code>
    <code class="n">Objects</code><code class="p">.</code><code class="na">requireNonNull</code><code class="p">(</code><code class="n">fn</code><code class="p">);</code>
    <code class="n">Objects</code><code class="p">.</code><code class="na">requireNonNull</code><code class="p">(</code><code class="n">after</code><code class="p">);</code>

    <code class="k">return</code> <code class="p">(</code><code class="n">T</code> <code class="n">t</code><code class="p">)</code> <code class="o">-&gt;</code> <code class="p">{</code>
      <code class="n">R</code> <code class="n">result</code> <code class="o">=</code> <code class="n">fn</code><code class="p">.</code><code class="na">apply</code><code class="p">(</code><code class="n">t</code><code class="p">);</code>
      <code class="n">after</code><code class="p">.</code><code class="na">accept</code><code class="p">(</code><code class="n">result</code><code class="p">);</code>
    <code class="p">};</code>
  <code class="p">}</code>

  <code class="kd">private</code> <code class="nf">Compositor</code><code class="p">()</code> <code class="p">{</code>
    <code class="c1">// disallows direct instantiation</code>
  <code class="p">}</code>
<code class="p">}</code></pre></div>
<p>Composing the previous <code>String</code> operation from <a data-type="xref" href="#_01-functions_functional-composition_direction">Example 3-2</a> with an additional <code>Consumer&lt;String&gt;</code> for printing the result is now easy, as shown in <a data-type="xref" href="#_01-functional-java_func-compositor-usage">Example 3-6</a>:</p>
<div data-type="example" id="_01-functional-java_func-compositor-usage">
<h5><span class="label">Example 3-6. </span>Using the Functional Compositor</h5>
<pre data-code-language="java" data-type="programlisting"><code class="c1">// SINGULAR STRING FUNCTIONS</code>

<code class="n">Function</code><code class="o">&lt;</code><code class="n">String</code><code class="p">,</code> <code class="n">String</code><code class="o">&gt;</code> <code class="n">removeLowerCaseA</code> <code class="o">=</code> <code class="n">str</code> <code class="o">-&gt;</code> <code class="n">str</code><code class="p">.</code><code class="na">replace</code><code class="p">(</code><code class="s">"a"</code><code class="p">,</code> <code class="s">""</code><code class="p">);</code>
<code class="n">Function</code><code class="o">&lt;</code><code class="n">String</code><code class="p">,</code> <code class="n">String</code><code class="o">&gt;</code> <code class="n">upperCase</code> <code class="o">=</code> <code class="n">String</code><code class="p">::</code><code class="n">toUpperCase</code><code class="p">;</code>


<code class="c1">// COMPOSED STRING FUNCTIONS</code>

<code class="n">Function</code><code class="o">&lt;</code><code class="n">String</code><code class="p">,</code> <code class="n">String</code><code class="o">&gt;</code> <code class="n">stringOperations</code> <code class="o">=</code>
  <code class="n">removeLowerCaseA</code><code class="p">.</code><code class="na">andThen</code><code class="p">(</code><code class="n">upperCase</code><code class="p">);</code>


<code class="c1">// COMPOSED STRING FUNCTIONS AND CONSUMER</code>

<code class="n">Consumer</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code> <code class="n">task</code> <code class="o">=</code> <code class="n">Compositor</code><code class="p">.</code><code class="na">compose</code><code class="p">(</code><code class="n">stringOperations</code><code class="p">,</code>
                                           <code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">::</code><code class="n">println</code><code class="p">);</code>


<code class="c1">// RUNNING TASK</code>

<code class="n">task</code><code class="p">.</code><code class="na">accept</code><code class="p">(</code><code class="s">"abcd"</code><code class="p">);</code>
<code class="c1">// =&gt; BCD</code></pre></div>
<p>A simple compositor passing values between functional interfaces is an obvious use case for functional composition.
Still, it’s useful for other use cases, too, like introducing a certain degree of logic and decision-making.
For example, you could safeguard a <code>Consumer</code> with a <code>Predicate</code> as shown in <a data-type="xref" href="#_01-functional-java_func-compositor-improved">Example 3-7</a></p>
<div data-type="example" id="_01-functional-java_func-compositor-improved">
<h5><span class="label">Example 3-7. </span>Improved Functional Compositor</h5>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">final</code> <code class="kd">class</code> <code class="nc">Compositor</code> <code class="p">{</code>

  <code class="kd">public</code> <code class="kd">static</code> <code class="n">Consumer</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code> <code class="nf">acceptIf</code><code class="p">(</code><code class="n">Predicate</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code> <code class="n">predicate</code><code class="p">,</code>
                                     <code class="n">Consumer</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code> <code class="n">consumer</code><code class="p">)</code> <code class="p">{</code>
    <code class="n">Objects</code><code class="p">.</code><code class="na">requireNonNull</code><code class="p">(</code><code class="n">predicate</code><code class="p">);</code>
    <code class="n">Objects</code><code class="p">.</code><code class="na">requireNonNull</code><code class="p">(</code><code class="n">consumer</code><code class="p">);</code>

    <code class="k">return</code> <code class="p">(</code><code class="n">T</code> <code class="n">t</code><code class="p">)</code> <code class="o">-&gt;</code> <code class="p">{</code>
      <code class="k">if</code> <code class="p">(</code><code class="o">!</code><code class="n">predicate</code><code class="p">.</code><code class="na">test</code><code class="p">(</code><code class="n">t</code><code class="p">))</code> <code class="p">{</code>
        <code class="k">return</code><code class="p">;</code>
      <code class="p">}</code>
      <code class="n">consumer</code><code class="p">.</code><code class="na">accept</code><code class="p">(</code><code class="n">t</code><code class="p">);</code>
    <code class="p">}</code>
  <code class="p">}</code>

  <code class="c1">// ...</code>
<code class="p">}</code></pre></div>
<p>You can fill the gaps left by the JDK by adding new <code>static</code> helpers to your types as needed.
From personal experience, I would suggest only adding helpers as required instead of trying to fill the gaps proactively.
Only implement what you currently need because it can be quite hard to foresee what you need in the future.
Any additional line of code that’s not used right now will need maintenance over time and might need changes or refactoring anyway if you want to use it and the actual requirements become clear.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="Takeaways" data-type="sect1"><div class="sect1" id="idm45115248654272">
<h1>Takeaways</h1>
<ul>
<li>
<p>The JDK provides 40+ functional interfaces because Java’s type system requires tangible interfaces for different use cases.
The available functional interfaces fall into four categories: Functions, Consumers, Suppliers, and Predicates.</p>
</li>
<li>
<p>More specialized functional interface variants exist for arities up to two.
Method signatures, however, should use their equivalent <code>super</code> interface instead to maximize compatibility.</p>
</li>
<li>
<p>Primitives are supported by either using <em>autoboxing</em>, or a respective functional interface variant for <code>int</code>, <code>long</code>, <code>double</code>, and <code>boolean</code>.</p>
</li>
<li>
<p>Functional interfaces behave like any other interface and require a common ancestor to be used interchangeably.
However, bridging the gap between “identical but incompatible” functional interfaces is possible by using a method reference of a SAM.</p>
</li>
<li>
<p>Adding functional support to your own types is easy.
Use <code>default</code> methods on your interfaces to cover functional use cases without requiring you to change any implementations.</p>
</li>
<li>
<p>Common or missing functional tasks can be accumulated in a helper type with <code>static</code> methods.</p>
</li>
</ul>
</div></section>
<div data-type="footnotes"><p data-type="footnote" id="idm45115249764864"><sup><a href="ch03.xhtml#idm45115249764864-marker">1</a></sup> Varargs method arguments, like <code>String…​</code>, appear to have a dynamic arity, as the method accepts a non-fixed amount of arguments. However, behind the scenes, the arguments are converted to an array, making the actual arity one.</p><p data-type="footnote" id="idm45115248733296"><sup><a href="ch03.xhtml#idm45115248733296-marker">2</a></sup> The command pattern is one of many object-oriented design patterns described by the <em>gang of four</em>. Gamma, E., Helm, R., Johnson, R., &amp; Vlissides, J. (1994). Design patterns: Elements of reusable object-oriented software. Boston, MA: Addison Wesley.</p><p data-type="footnote" id="idm45115248649152"><sup><a href="ch03.xhtml#idm45115248649152-marker">3</a></sup> The shown <code>Function&lt;T, R&gt;</code> interface is a simplified variant of the <a href="https://github.com/openjdk/jdk/blob/jdk-17+35/src/java.base/share/classes/java/util/function/Function.java">source code</a> present in the JDK to increase readability.</p></div></div></section></div></body></html>