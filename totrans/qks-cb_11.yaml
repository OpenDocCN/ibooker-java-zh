- en: Chapter 11\. Authentication and Authorization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about how authorization and authentication,
    the backbone of application security, work within a Quarkus application. We’ll
    discuss the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: File-backed authentication and authorization schemes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Databased-backed authentication and authorization schemes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: External-service-backed authentication and authorization schemes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quarkus Security Basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we get to our first recipe, this section will show you the basics of
    Quarkus and security, the security extensions you will use to load authentication
    sources, and how to protect resources using a *role-based access control* (RBAC)
    approach.
  prefs: []
  type: TYPE_NORMAL
- en: The examples shown in this section are not meant to be runnable, but they will
    be the basis for the upcoming recipes in which we are going to see the security
    extensions in action.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the two main concepts regarding security:'
  prefs: []
  type: TYPE_NORMAL
- en: Authentication
  prefs: []
  type: TYPE_NORMAL
- en: Validate your credentials (i.e., username/password) to verify your identity
    so that the system knows who you are.
  prefs: []
  type: TYPE_NORMAL
- en: Authorization
  prefs: []
  type: TYPE_NORMAL
- en: Verify your rights to be granted access to a protected resource. This happens
    after the authentication process.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Quarkus provides two authenticating mechanisms for HTTP, the well-known `BASIC`
    and `FORM` methods. These mechanisms can be extended by any Quarkus extension
    to provide a custom authentication method. An example of these mechanisms is found
    in the form of the Quarkus extension to authenticate against an OpenID Connect
    server such as Keycloak. We are going to explore how to do this in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use authentication, an identity provider is required to validate the credentials
    (i.e., username/password) provided by the user. Quarkus provides the following
    identity providers out of the box, but you can implement your own, too:'
  prefs: []
  type: TYPE_NORMAL
- en: Elytron properties file
  prefs: []
  type: TYPE_NORMAL
- en: Provides a mapping between user/password/role in the form of the properties
    file. The information can be embedded either in *application.properties* file
    or in a specific file for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Elytron JDBC
  prefs: []
  type: TYPE_NORMAL
- en: Provides a mapping between user/password/role based on JDBC queries.
  prefs: []
  type: TYPE_NORMAL
- en: JPA
  prefs: []
  type: TYPE_NORMAL
- en: Provides support for authenticating via JPA.
  prefs: []
  type: TYPE_NORMAL
- en: SmallRye JWT
  prefs: []
  type: TYPE_NORMAL
- en: Provides authentication using JSON Web Tokens (JWT) spec.
  prefs: []
  type: TYPE_NORMAL
- en: OIDC
  prefs: []
  type: TYPE_NORMAL
- en: Provides authentication using an OpenID Connect (OIDC) provider like Keycloak.
  prefs: []
  type: TYPE_NORMAL
- en: Keycloak authorization
  prefs: []
  type: TYPE_NORMAL
- en: Provides support for a policy enforcer using Keycloak Authorization Services.
  prefs: []
  type: TYPE_NORMAL
- en: Basic authentication
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To authenticate using *basic* access authentication, the `quarkus.http.auth.basic`
    configuration property must be set to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: Form-based authentication
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `quarkus.http.auth.form.enabled` configuration property must be set to `true`
    in order to authenticate using *form* access authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Important
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Quarkus does not store the authenticated user in an HTTP session because there
    is no clustered HTTP session support. Instead, the authentication information
    is stored in an encrypted cookie.
  prefs: []
  type: TYPE_NORMAL
- en: The encryption key can be set using the `quarkus.http.auth.session.encryption-key`
    property, and it must be at least 16 characters long. The key is hashed using
    SHA-256, and the result is used as a key for AES-256 encryption of the cookie
    value. This cookie contains an expiry time as part of the encrypted value, generating
    a new cookie in one-minute intervals with an updated expiry time if the session
    is in use.
  prefs: []
  type: TYPE_NORMAL
- en: Authorization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Quarkus integrates with [Java EE Security annotations](https://oreil.ly/ATPpq)
    to define RBAC on RESTful web endpoints and CDI beans.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, you can define the authorization of RESTful Web Endpoints using a
    configuration file (*application.properties*) instead of annotations.
  prefs: []
  type: TYPE_NORMAL
- en: Both approaches can coexist in the same application, but configuration file
    checks are executed before any annotation check and are not mutually exclusive,
    which means that in case of overlap, both checks must pass.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following snippet shows how to secure a JAX-RS endpoint using the Java
    EE Security annotations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_authentication_and_authorization_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Requires an authenticated user with role `Tester`
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_authentication_and_authorization_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Unauthenticated users have access to the method
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_authentication_and_authorization_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: No user can access whether authenticated or not
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_authentication_and_authorization_CO1-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Permit any authenticated user to access; it is an alias of `@RolesAllowed("*")`
    and is provided by Quarkus, not the spec
  prefs: []
  type: TYPE_NORMAL
- en: 'The `javax.ws.rs.core.Context` annotation can be used to inject the `javax.ws.rs.core.SecurityContext`
    instance to get information about the user that was authenticated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_authentication_and_authorization_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Injects `SecurityContext` for current request
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_authentication_and_authorization_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Gets the current logged user
  prefs: []
  type: TYPE_NORMAL
- en: Important
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Security annotations are not restricted only to JAX-RS resources. They can be
    used in CDI beans to protect method calls, too.
  prefs: []
  type: TYPE_NORMAL
- en: 'Quarkus supports configuring RESTful web endpoints using the configuration
    file instead of annotations. The equivalent security annotation example can be
    expressed using the configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_authentication_and_authorization_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Defines the roles of the application; `role-policy1` is used as reference value
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_authentication_and_authorization_CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets the permission to the resource; `roles1` is an arbitrary name to avoid
    repeating keys
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_authentication_and_authorization_CO3-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets the role policy
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_authentication_and_authorization_CO3-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Restricts permission to the `GET` method
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](Images/5.png)](#co_authentication_and_authorization_CO3-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Denies access
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](Images/6.png)](#co_authentication_and_authorization_CO3-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Permits access
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that the `paths` attribute supports multiple values
    separated by a comma, and also the `*` wildcard to match any subpath. For example,
    `quarkus.http.auth.permission.permit1.paths=/public/_,/robots.txt` sets permission
    for any resource placed at */public* and any of its subpaths and the file */robots.txt*.
  prefs: []
  type: TYPE_NORMAL
- en: In the same way, the `methods` attribute allows multiple values separated by
    a comma.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two configuration properties that affect the RBAC behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '`quarkus.security.jaxrs.deny-unannotated-endpoints`'
  prefs: []
  type: TYPE_NORMAL
- en: If it is set to `true`, then all JAX-RS endpoints not annotated with security
    annotations are denied by default. This property is `false` by default.
  prefs: []
  type: TYPE_NORMAL
- en: '`quarkus.security.deny-unannotated-members`'
  prefs: []
  type: TYPE_NORMAL
- en: If it is set to `true`, then all JAX-RS endpoints and CDI methods not annotated
    with security annotations are denied by default. This property is `false` by default.
  prefs: []
  type: TYPE_NORMAL
- en: So far, you’ve seen that in Quarkus you can set authorization procedure (basic,
    form, or other provided by extension) and define the authentication roles using
    security annotations or specifying them in the configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: The recipes in this chapter will explore the different Quarkus extensions to
    provide authentication and authorization identity providers.
  prefs: []
  type: TYPE_NORMAL
- en: 11.1 Authentication and Authorization with Elytron Properties File Config
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to secure the application by storing identities in files.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Quarkus security provides support to store identities in files using the Elytron
    properties file config as an identity provider.
  prefs: []
  type: TYPE_NORMAL
- en: You’ve seen how to define the authentication mechanism and how to protect the
    resources with RBAC, either with security annotations or in *application.properties*,
    but you’ve not seen how to register an identity provider and how to store the
    user information like username, password, or roles where it belongs.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see how to define identity information using the Elytron properties file
    config extension. This extension is based on the properties file to define all
    identity information, and its main purpose is for development and testing. It
    is not recommended that this be used in production because passwords can be expressed
    only in plain text or in MD5 hashed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable the Elytron properties file config, you need to register the `quarkus-elytron-security-properties-file`
    extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This extension supports the mapping of users to passwords and users to roles
    with a combination of properties files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Protect the endpoint with allowing only the `Tester` role to access the resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: To register identities, two properties files are required, one for mapping user
    and password, and another one for mapping the user and the list of roles they
    belong in.
  prefs: []
  type: TYPE_NORMAL
- en: 'The user configuration properties file defines for each line the pair of user
    and password that are registered in the system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the users’ properties file, the key part is the username, and the value part
    is the password.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Notice that the password is in plain text. You can hash the password with MD5
    following this pattern: `HEX(MD5(username:realm:password)`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The roles configuration file defines for each line the pair of username and
    the roles (separated by commas) that the user belongs in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the roles properties file, the key part is the username, and the value is
    the roles assigned to the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the Elytron Security properties file extension needs to be configured
    with the classpath locations of the users and roles properties files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_authentication_and_authorization_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Enables basic authentication method
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_authentication_and_authorization_CO4-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Enables security with the properties file extension
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_authentication_and_authorization_CO4-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets the password that is not hashed with MD5
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_authentication_and_authorization_CO4-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets the classpath location of the users and roles properties files
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the generated test to validate the protection of the endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The test is failing with an HTTP 401 Unauthorized error because the test is
    not providing any identity using the Basic authentication method. Modify the test
    to authenticate with a configured username and password:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_authentication_and_authorization_CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets authentication part
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_authentication_and_authorization_CO5-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Basic authentication with a given username and password
  prefs: []
  type: TYPE_NORMAL
- en: Now, with valid authenticating parameters, the test passes.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Elytron properties file config extension also supports embedding the mapping
    between user/password/roles in the Quarkus configuration file (*application.properties*)
    instead of using different files.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Passwords stored in a file can be hashed using the formula `HEX(MD5(username
    ":" realm ":" password))`.
  prefs: []
  type: TYPE_NORMAL
- en: An embedded Elytron properties file config can be configured by using the properties
    listed in [Table 11-1](#embeded-elytron-properties-config-table).
  prefs: []
  type: TYPE_NORMAL
- en: Table 11-1\. Embeded Elytron properties
  prefs: []
  type: TYPE_NORMAL
- en: '| Property | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '`quarkus.security.users.embedded.realm-name`'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: The realm name used when generating a hashed password (defaults to `Quarkus`).
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '`quarkus.security.users.embedded.enabled`'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Enables security with the properties file extension (defaults to `false`).
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '`quarkus.security.users.embedded.plain-text`'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Sets if the password is hashed or not. If `true`, the hashed password must be
    in the form of `HEX(MD5(username:realm:password)` (defaults to `false`).
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '`quarkus.security.users.embedded.users.<user>`'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: The user information. The key part is the username, and the value part is the
    password.
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '`quarkus.security.users.embedded.roles.<user>`'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: The role information. The key part is the username, and the value part is the
    password.
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 11.2 Authentication and Authorization with Elytron Security JDBC Config
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to secure the application and store user identities in a database.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Quarkus security provides support to store user identities in a data source
    using Elytron Security JDBC config as an identity provider.
  prefs: []
  type: TYPE_NORMAL
- en: You’ve seen how to define identities in properties files using the Elytron properties
    file config extension in [Recipe 11.1](#authentication-and-authorization-with-elytron-properties-file-config).
    However, as noted there, this method is more for testing/dev purposes and should
    not be used in production environments.
  prefs: []
  type: TYPE_NORMAL
- en: The Elytron Security JDBC extension can be used to store the user identities
    in a database, supporting password encryption using bcrypt password mapper, and
    being versatile enough to not lock you into any predefined database schema.
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable the Elytron Security JDBC extension, you need to register the `quarkus-elytron-security-jdbc`
    extension, the JDBC driver used to connect to the database, and optionally Flyway
    to populate schema and some default users:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Protect the endpoint with allowing only the `Tester` role to access the resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to define the database schema to store all RBAC information.
    For the sake of simplicity, a simple table with user, password, and role is used
    in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the extension must be configured to specify which query to execute
    to validate the user and retrieve the roles they belong in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_authentication_and_authorization_CO6-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Enables Elytron Security JDBC
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_authentication_and_authorization_CO6-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Defines the query to validate the user and get the roles; the query must contain
    exactly one parameter (the username) and return at least the password, and the
    value should be on the same line as the key
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_authentication_and_authorization_CO6-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The password is stored in cleartext
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_authentication_and_authorization_CO6-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets the index of the password; this should all be on the same line
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](Images/5.png)](#co_authentication_and_authorization_CO6-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets the index of the role and specifies the field as role
  prefs: []
  type: TYPE_NORMAL
- en: Important
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Index is 1-based.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The query to retrieve the password (and optionally the roles) can be as complex
    as required by your model (i.e., SQL joins).
  prefs: []
  type: TYPE_NORMAL
- en: Now, the authentication and authorization data are retrieved from the database
    instead of a file. When the username and password are provided (e.g., using the
    basic `auth` method), the query is executed to retrieve all required information
    for the authentication process (matching provided password against the retrieved
    password from the database) and to get roles for the authorization process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember to update the test (if not done before) to make it pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, you’ve used a cleartext password, which obviously should not
    be used in a production environment. The extension provides an integration to
    the `bcrypt` password mapper, so the authentication process also works for hashing
    passwords.
  prefs: []
  type: TYPE_NORMAL
- en: You need to extend the configuration file with some extra parameters to indicate
    to Elytron Security JDBC that the password is using `bcrypt` and should not be
    compared as cleartext.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of configuring `clear-password-mapper`, the `bcrypt-password-mapper`
    is used. The following is an example of a configuration file using `bcrypt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_authentication_and_authorization_CO7-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Enables bcrypt
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_authentication_and_authorization_CO7-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets password index; this should be on the same line
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_authentication_and_authorization_CO7-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets password hash encoding; this should be on the same line
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_authentication_and_authorization_CO7-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets salt index; this should be on the same line
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](Images/5.png)](#co_authentication_and_authorization_CO7-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets salt encoding; this should be on the same line
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](Images/6.png)](#co_authentication_and_authorization_CO7-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets iteration count index; this should be on the same line
  prefs: []
  type: TYPE_NORMAL
- en: 'After this change, the password matching between the provided password and
    the password retrieved by query does not happen in cleartext. Rather, the provided
    password is hashed using bcrypt and then compared with the stored password:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_authentication_and_authorization_CO8-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Default data source is used to retrieve the password
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_authentication_and_authorization_CO8-2)'
  prefs: []
  type: TYPE_NORMAL
- en: '`roles` is used as a name to identify the second query; the query should all
    be on the same line'
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_authentication_and_authorization_CO8-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Gets the role from another query
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_authentication_and_authorization_CO8-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Role query is executed against a data source named `permissions`
  prefs: []
  type: TYPE_NORMAL
- en: 11.3 Authorization with MicroProfile JWT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to save security context in RESTful web services and stateless services
    in general.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use JSON Web Tokens.
  prefs: []
  type: TYPE_NORMAL
- en: JWT (JSON Web Token) is a standard specified under RFC-7519 that is used for
    exchanging information between services. The particularity of JWT is that the
    token content is formatted in JSON instead of in plain text or any other binary
    format.
  prefs: []
  type: TYPE_NORMAL
- en: Quarkus integrates with the [MicroProfile JWT specification](https://oreil.ly/IU0-d)
    to consume and validate JWT tokens and retrieve the claims.
  prefs: []
  type: TYPE_NORMAL
- en: A JWT token is formed by *claims*, which are the information to transmit—for
    example, the username, the expiration of the token, or the roles of the user.
    The token is digitally signed so the information contained in the token can be
    trusted and verified.
  prefs: []
  type: TYPE_NORMAL
- en: 'A JWT token is composed of three sections. All of them are encoded in the Base64
    format:'
  prefs: []
  type: TYPE_NORMAL
- en: Header
  prefs: []
  type: TYPE_NORMAL
- en: It contains some metadata, like the algorithm used to sign the token; custom
    information of the token, like the type of token; or unencrypted claims if using
    JSON Web Encryption (JWE).
  prefs: []
  type: TYPE_NORMAL
- en: Claims
  prefs: []
  type: TYPE_NORMAL
- en: Information to store inside the token. Some claims are mandatory, others are
    options, and some are custom to our application.
  prefs: []
  type: TYPE_NORMAL
- en: Signature
  prefs: []
  type: TYPE_NORMAL
- en: The signature of the token.
  prefs: []
  type: TYPE_NORMAL
- en: Then the three sections are encoded to Base64 and concatenated with a period
    sign (`.`), so the final token looks like `base64(Header).base64(Claims).base64(Signature)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this example, the following JWT token is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_authentication_and_authorization_CO9-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Header part
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_authentication_and_authorization_CO9-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Claims part
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_authentication_and_authorization_CO9-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The issuer of the token
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_authentication_and_authorization_CO9-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Groups (or roles) that the owner of the token belongs in
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the serialized version of the same token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the sections are divided by periods.
  prefs: []
  type: TYPE_NORMAL
- en: 'MicroProfile JWT spec performs the following operations when a request is received:'
  prefs: []
  type: TYPE_NORMAL
- en: Extract security token from the request, usually from the `Authorization` header.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Validate the token to make sure that the token is valid. These checks might
    involve things like verifying the signature to trust on the token or verifying
    that the token has not expired.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extract token information.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a security context with identity information so it can be used in case
    of authorization (RBAC).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Moreover, the MicroProfile JWT spec sets a list of mandatory claims that every
    token must provide:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Claim | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '`typ`'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: The token format. It must be `JWT`.
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '`alg`'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Identifies the cryptographic algorithm to secure the token. It must be `RS256`.
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '`kid`'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Indicates which key was used to secure the token.
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '`iss`'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: The token issuer.
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '`sub`'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Identifies the principal subjected to the token.
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '`aud`'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Identifies the recipients that the token is intended for.
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '`exp`'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Sets the expiration time.
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '`iat`'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Provides the time at which the token was issued.
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '`jti`'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Unique identifier of the token.
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '`upn`'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: The user-principal name used in the `java.security.Principal` interface.
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '`groups`'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: The list of group names that have been assigned to the principal of the token.
    They are the roles in which the user belongs.
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: These are the minimal claims that are required by the MicroProfile JWT specification,
    but additional claims can be added, such as `preferred_username` or any other
    information that your application might need to transmit between services.
  prefs: []
  type: TYPE_NORMAL
- en: 'Register the `quarkus-smallrye-jwt` extension to start using the MicroProfile
    JWT specification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Configure the extension to set the public key used to verify that the token
    has not been modified and that the issuer (`iss`) claim of the token the server
    accepts is valid.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are public key formats supported by the specification:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Public Key Cryptography Standards #8 (PKCS#8) Privacy-Enhanced Mail (PEM)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSON Web Key (JWK)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSON Web Key Set (JWKS)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSON Web Key (JWK) Base64 URL encoded
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSON Web Key Set (JWKS) Base64 URL encoded
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For this example, we choose the JSON Web Key Set (JWKS) format to specify the
    public key used to validate the token.
  prefs: []
  type: TYPE_NORMAL
- en: 'The JWKS file containing the public key is placed inside the project directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The configuration file pointing to this data is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_authentication_and_authorization_CO10-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Location of the public key
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_authentication_and_authorization_CO10-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The issuer accepted by the service
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from handling the verification process of the token, the MicroProfile
    JWT integrates with existing Java EE security APIs providing the data from the
    token. The integration happens in the following annotations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Furthermore, the MicroProfile JWT spec provides two classes to accommodate
    JWT data inside CDI or JAX-RS classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`org.eclipse.microprofile.jwt.JsonWebToken`'
  prefs: []
  type: TYPE_NORMAL
- en: Interface that exposes the raw token and offers methods to get the claims
  prefs: []
  type: TYPE_NORMAL
- en: '`@org.eclipse.microprofile.jwt.Claim`'
  prefs: []
  type: TYPE_NORMAL
- en: Annotation to provide injection of claims into classes
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_authentication_and_authorization_CO11-1)'
  prefs: []
  type: TYPE_NORMAL
- en: A JWT token is, by nature, request-scoped; if you expect to use the token, the
    class must be `RequestScoped` to avoid mixing tokens in classes
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_authentication_and_authorization_CO11-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Injects `JsonWebToken` interface that represents the full JWT token
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_authentication_and_authorization_CO11-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Injects the `preferred_username` claim
  prefs: []
  type: TYPE_NORMAL
- en: 'Claim annotation also supports the injection of private claim names. These
    claims are not official claim names provided by the RFC but claims that are specific
    to the service (custom claims). To inject a private claim, use the annotation
    value as the name of the claim: `@Claim("*my_claim*")`. Moreover, in case of nonmandatory
    claims, the `java.util.Optional` class can be used to indicate that the claim
    is nullable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the test to send a bearer JWT token to the defined endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_authentication_and_authorization_CO13-1)'
  prefs: []
  type: TYPE_NORMAL
- en: JWT token is sent as bearer token in `Authorization` header
  prefs: []
  type: TYPE_NORMAL
- en: 'With the current solution, these assumptions are true:'
  prefs: []
  type: TYPE_NORMAL
- en: If a valid token is provided, the `preferred_username` is extracted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If an invalid token is provided (expired, signature not valid, modified by third
    party, etc.), then a 401 Unauthorized Error error code is sent back to the caller.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If no token is provided, then the request is processed but the `preferred_username`
    field is null.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The MicroProfile JWT spec also provides support for the authorization process
    by integrating with the `@RolesAllowed` annotation. The `groups` claim value is
    used any time the `isCallerInRole()` method is called, which effectively means
    that any value in `groups` can be used as a role in the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `groups` claim in the JWT token used in this example contains the following
    values: `"groups": ["Echoer", "Tester", "Subscriber", "group2"]`. Protect the
    call to `/hello` by using `@RolesAllowed` with one of the group values present
    in the token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can assume the following:'
  prefs: []
  type: TYPE_NORMAL
- en: If a valid token is provided and the `groups` claim contains the `Tester` group,
    then the `preferred_username` is extracted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a valid token is provided and the `groups` claim does not contain the `Tester`
    group, then a 403 Forbidden error code is sent back to the caller.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If an invalid token is provided (expired, signature not valid, modified by third
    party, etc.), then a 401 Unauthorized Error error code is sent back to the caller.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If no token is provided, then a 401 Unauthorized Error error code is sent back
    to the caller.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the past, the security context was saved in the HTTP session, which works
    well until you start scaling up the services and things start to become more and
    more complicated. To avoid this problem, one of the possible solutions is to pass
    this information in all calls using a token, especially a JSON token.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that the token is signed and not encrypted, which means
    that the information can be seen by anyone but not modified. An encryption layer
    can be added using JSON Web Encryption so that the claims are not in cleartext
    but instead are encrypted.
  prefs: []
  type: TYPE_NORMAL
- en: The intent of this section is not for you to master JWT but for you learn how
    to use it in Quarkus, so we are assuming that you already have some knowledge
    about JWT. We are also providing some links in the following “See Also” to help
    you become more familiar with JWT.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To learn about JWT, visit the following web pages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[JSON Web Tokens](https://jwt.io)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[GitHub: JWT RBAC for MicroProfile](https://oreil.ly/tXP9d)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[IETF: JSON Web Token](https://oreil.ly/p9jUC)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 11.4 Authorization and Authentication with OpenId Connect
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to protect your RESTful Web API with OpenId Connect.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use bearing token authorization where the token is issued by OpenId Connect.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous section, you learned how to use the JWT token for protecting
    resources, but the generation of the token was not covered because the token was
    generated up front and provided in a text file.
  prefs: []
  type: TYPE_NORMAL
- en: In real-world applications, you need an identity provider that issues the token.
    The de facto protocol for distributed services is OpenId Connect and OAuth 2.0
    and an authorization-compliant server with the protocol, such as [Keycloak](https://www.keycloak.org).
  prefs: []
  type: TYPE_NORMAL
- en: 'Register the `quarkus-oidc` extension to protect resources with OpenId Connect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Configure the location of the OpenId Connect server to validate the token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_authentication_and_authorization_CO14-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The base URL of the OpenID Connect server
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_authentication_and_authorization_CO14-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Each application has a client ID used to identify the application
  prefs: []
  type: TYPE_NORMAL
- en: 'Protect the endpoint using the `@RolesAllowed` annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_authentication_and_authorization_CO15-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Quarkus interface that represents the currently logged in user
  prefs: []
  type: TYPE_NORMAL
- en: 'The test must be updated to get the access token from OpenId Connect and provide
    it as the bearer token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The access token is generated in the OpenId Connect server. To generate it,
    some parameters must be provided, such as the username and password, to access
    the server and to generate a token representing the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The code is essentially an implementation of the next `curl` command but using
    REST-Assured:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Now, when running the test, something completely different is shown than in
    [Recipe 11.3](#authorization-with-microprofile-jwt).
  prefs: []
  type: TYPE_NORMAL
- en: First of all, the token (JWT token) is not static; it is issued by OpenID Connect
    (Keycloak) for the `alice` username.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is example of an issued token for `alice`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Second, the OpenID Connect is responsible for providing everything to validate
    the token; the public key is not configured manually.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following validations are performed by Keycloak when the token is provided:'
  prefs: []
  type: TYPE_NORMAL
- en: If a valid token is provided and the `roles` claim contains the `user` group,
    then the `preferred_username` is extracted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a valid token is provided and the `roles` claim does not contain the `user`
    group, then a 403 Forbidden error code is sent back to the caller.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If an invalid token is provided (expired, signature not valid, modified by third
    party, etc.), then a 403 Forbidden error code is sent back to the caller.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If no token is provided, then a 401 Unauthorized Error error code is sent back
    to the caller.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To learn more about OpenId Connect protocol, see the following websites:'
  prefs: []
  type: TYPE_NORMAL
- en: '[OpenID Connect](https://openid.net/connect)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Keycloak](https://www.keycloak.org)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 11.5 Protecting Web Resources with OpenId Connect
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to protect your web resources.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use OpenId Connect and file-based role definitions to protect web resources.
  prefs: []
  type: TYPE_NORMAL
- en: Web resources can be protected using OpenId Connect protocol and Quarkus. The
    OpenId Connect extension enables authentication to web resources by implementing
    the well-known authorization code flow, where any unauthenticated user that is
    trying to access a protected resource is redirected to the OpenId Connect Provider
    website to authenticate. After the authentication process is completed, the user
    is sent back to the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Register the `quarkus-oidc` extension to protect resources with OpenId Connect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Configure the location of the OpenId Connect server to validate the token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_authentication_and_authorization_CO16-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The base URL of the OpenID Connect server
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_authentication_and_authorization_CO16-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Each application has a client ID used to identify the application
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_authentication_and_authorization_CO16-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Enables OpenID Connect Authorization Code Flow
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_authentication_and_authorization_CO16-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets permission to web resources
  prefs: []
  type: TYPE_NORMAL
- en: 'Start the application, open a browser, and enter the following URL: [*http://localhost:8080*](http://localhost:8080):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The default *index.html* page is not shown, but you are redirected to the authentication
    page of Keycloak. Enter the following valid credentials (login: **`alice`**, password:
    **`alice`**) to gain access to the web resource. After pushing the Login button,
    the page is redirected back to the login page.'
  prefs: []
  type: TYPE_NORMAL
