- en: Chapter 3\. Java to Kotlin Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The class is the basic unit of code organization in Java. How do we convert
    our Java classes to Kotlin, and what differences will we see when we have?
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In this book, we’ll work together on the code in Travelator, our fictional trip-planning
    web app. Imagine that we have a feature to implement, but we want to take the
    opportunity to make our code a little better before we do. You’re pairing with
    one of Nat or Duncan (choose your favorite, just don’t let Nat know). The pair
    is the *we* in our refactoring discussions; not just your author, but also you
    as part of the team working on Travelator. Welcome aboard!
  prefs: []
  type: TYPE_NORMAL
- en: A Simple Value Type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s jump into the deep end of the codebase and convert some of our existing
    Java to Kotlin, starting with `EmailAddress`. This is a value type that holds
    the two parts of, you guessed it, an email address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 3.1 [classes.0:src/main/java/travelator/EmailAddress.java]](https://java-to-kotlin.dev/code.html?ref=3.1&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=3.1&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'This class is very simple; it does nothing more than wrap two strings and provides
    no operations of its own. Even so, it has a lot of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[![1](assets/1.png)](#co_introduction_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Values are immutable, so the class declares its fields as final.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_introduction_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: There is a static factory method to `parse` an `EmailAddress` from a string;
    this calls the primary constructor.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_introduction_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The fields are initialized in a constructor.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_introduction_CO1-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The accessor methods of its properties follow the JavaBean naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_introduction_CO1-6)'
  prefs: []
  type: TYPE_NORMAL
- en: The class implements the `equals` and `hashCode` methods to ensure that two
    `EmailAddress` values with equal fields compare as equal.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_introduction_CO1-8)'
  prefs: []
  type: TYPE_NORMAL
- en: '`toString` returns the canonical form.'
  prefs: []
  type: TYPE_NORMAL
- en: Your authors come from the school of Java that assumes that everything we pass,
    store, or return is not null unless explicitly indicated otherwise. You can’t
    see that convention, because it results in an absence of `@Nullable` annotations
    or null checks of parameters ([Chapter 4](ch04.html#optional-to-nullable) discusses
    nullability). What you *can* see is the amount of boilerplate code required to
    express a value composed of two other values. Happily, our IDE generated the `equals`
    and `hashCode` methods for us, but we have to remember to delete and regenerate
    those methods if we change the fields of the class to avoid confusing bugs.
  prefs: []
  type: TYPE_NORMAL
- en: So much for the Java; we’re here for the Kotlin. How do we convert? Helpfully,
    IntelliJ has an action called “Convert Java File to Kotlin File”. When we invoke
    it, IntelliJ offers to change other files if necessary to keep things consistent.
    Because the conversion can potentially modify files throughout the project, it’s
    best to say yes.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Make sure you have no uncommitted changes before converting Java source to Kotlin
    so that you can easily see the impact of the conversion on the rest of your codebase
    and revert the conversion if it does something you didn’t expect.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, IntelliJ doesn’t have to change any other files. It has replaced
    our *EmailAddress.java* file with *EmailAddress.kt* in the same directory, though:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 3.2 [classes.2:src/main/java/travelator/EmailAddress.kt]](https://java-to-kotlin.dev/code.html?ref=3.2&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=3.2&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Kotlin class is noticeably more succinct because it declares its properties
    in the primary constructor: the parameters after the class name. Parameters marked
    `val` are considered properties and so stand in for all this Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 3.3 [classes.1:src/main/java/travelator/EmailAddress.java]](https://java-to-kotlin.dev/code.html?ref=3.3&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=3.3&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The primary constructor syntax is convenient, but it does interfere with the
    scanability of the class. Java classes that follow the standard coding conventions
    always define their elements in the same order: class name, superclass, interfaces,
    and then, within the class body, fields, constructors, and methods. This makes
    it easy to skim-read the class and quickly locate the features you’re interested
    in.'
  prefs: []
  type: TYPE_NORMAL
- en: It’s not quite so easy to find the parts of a Kotlin class. A Kotlin class definition
    has a header part with the class name, primary constructor (which can contain
    parameters and/or property definitions), superclass (which may also be the call
    to the superclass’s constructor), and interfaces. Then, within the class body,
    there are more properties and more constructors, methods, and companion objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Coming from Java, Nat and Duncan definitely found it harder to read classes
    at first, and although we got used to it eventually, we still find it hard at
    times to format classes for maximum readability, especially if there is a lot
    going on in the header part. One easy fix is to lay out the constructor parameter
    list line by line. With the cursor inside the parameter list, we can do that with
    Alt-Enter and “Put parameters on separate lines”. Sometimes a blank line after
    the header part helps, too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 3.4 [classes.3:src/main/java/travelator/EmailAddress.kt]](https://java-to-kotlin.dev/code.html?ref=3.4&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=3.4&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: One place where Kotlin is noticeably less succinct than Java is where it uses
    companion objects to host static state and methods, in this case `parse()`. In
    Kotlin, we often prefer top-level state and functions to these class-scoped members.
    [Chapter 8](ch08.html#static-methods-to-top-level-functions) discusses the pros
    and cons.
  prefs: []
  type: TYPE_NORMAL
- en: 'We currently have Java code that uses the static method, for example, the tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 3.5 [classes.0:src/test/java/travelator/EmailAddressTests.java]](https://java-to-kotlin.dev/code.html?ref=3.5&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=3.5&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: The companion object, combined with the `@JVMStatic` annotation, means this
    didn’t have to change when we converted the class to Kotlin, so we’ll leave `parse`
    as it is for now. We’ll discuss how to refactor to top-level functions in [Chapter 8](ch08.html#static-methods-to-top-level-functions).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re new to Kotlin, you may wonder what happened to the `getLocalPart()`
    and `getDomain()` accessor methods. Declaring the `domain` property causes the
    compiler to generate a private `domain` field and a `getDomain()` method so that
    Java code can still call it. Here is a little throwaway code to support a marketing
    plan:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 3.6 [classes.3:src/main/java/travelator/Marketing.java]](https://java-to-kotlin.dev/code.html?ref=3.6&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=3.6&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that Java is accessing the domain property through the `getDomain()`
    method. Conversely, when the class was Java and had an explicit `getDomain()`
    method, Kotlin code could have called it as `address.domain`. We’ll discuss properties
    in more detail in [Chapter 11](ch11.html#methods-to-properties).
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, converting our class to Kotlin has saved us 14 lines of code, but we
    aren’t done yet. Value types like this are so useful, but so tedious to get right
    and keep right, that Kotlin supports them at a language level. If we mark the
    class with the `data` modifier, the compiler generates any undefined `equals`,
    `hashCode`, and `toString` methods for us. That reduces the `EmailAddress` class
    to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 3.7 [classes.4:src/main/java/travelator/EmailAddress.kt]](https://java-to-kotlin.dev/code.html?ref=3.7&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=3.7&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: '[![1](assets/1.png)](#co_introduction_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We don’t want the generated `toString()` method, so we define the one we do
    want.
  prefs: []
  type: TYPE_NORMAL
- en: Frankly, that `parse` method still rankles; it’s taking up a disproportionate
    amount of space for the work it is doing. We’ll finally relieve this tension in
    [Chapter 9](ch09.html#multi-to-single-expression-functions). For now, though,
    we’re done with converting our `EmailAddress` Java class to Kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: The Limitations of Data Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A drawback of data classes is that they offer no encapsulation. We saw how the
    compiler generates `equals`, `hashCode`, and `toString` methods for data classes
    but didn’t mention that it also generates a `copy` method that creates a new copy
    of the value with different values for one or more of its properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following code creates a copy of an `EmailAddress` with a
    `localPart` of “postmaster” and the same domain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: For many types, this is very convenient. However, when a class abstracts its
    internal representation or maintains invariants between its properties, that `copy`
    method allows client code direct access to the internal state of a value, which
    can break its invariants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an abstract data type in the Travelator application, the `Money`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 3.8 [values.4:src/main/java/travelator/money/Money.java]](https://java-to-kotlin.dev/code.html?ref=3.8&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=3.8&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: '[![1](assets/1.png)](#co_introduction_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The constructor is private. Other classes obtain `Money` values by calling the
    static `Money.of` method, which guarantees that the scale of the amount is consistent
    with the number of minor units of the currency. Most currencies have one hundred
    minor units (two digits), but some have fewer and some more. For example, the
    Japanese yen has no minor units, and the Jordanian dinar is made up of one thousand
    fils.
  prefs: []
  type: TYPE_NORMAL
- en: The `of` method follows a coding convention of [Modern Java](ch01.html#modern-java-style)
    that draws a distinction in the source between objects with identity, which are
    constructed by the new operator, and values, which are obtained from static methods.
    This convention is followed by the Java time API (for example, `LocalDate.of(2020,8,17)`)
    and recent additions to the collections API (for example, `List.of(1,2,3)` creates
    an immutable list).
  prefs: []
  type: TYPE_NORMAL
- en: The class provides some convenient overloads of the `of` method for String or
    int amounts.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_introduction_CO3-3)'
  prefs: []
  type: TYPE_NORMAL
- en: A `Money` value exposes its amount and currency properties using JavaBean conventions,
    even though it is not actually a JavaBean.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_introduction_CO3-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The `equals` and `hashCode` methods implement value semantics.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_introduction_CO3-7)'
  prefs: []
  type: TYPE_NORMAL
- en: The `toString` method returns a representation of its properties that can be
    shown to the user, not just for debugging.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_introduction_CO3-8)'
  prefs: []
  type: TYPE_NORMAL
- en: '`Money` provides operations for calculating with money values. For example,
    you can add monetary values together. The `add` method constructs new `Money`
    values by calling the constructor directly (rather than using `Money.of`), because
    the result of `BigDecimal.add` already has the correct scale, so we can avoid
    the overhead of setting the scale in `Money.of`.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The method `BigDecimal.setScale` is confusing. Although named like a JavaBean
    setter, it does not actually mutate the BigDecimal object. Like our `EmailAddress`
    and `Money` classes, `BigDecimal` is an immutable value type, so `setScale` returns
    a new `BigDecimal` value with the specified scale.
  prefs: []
  type: TYPE_NORMAL
- en: Sun added the `BigDecimal` class to the standard library in Java 1.1\. This
    release also included the first version of the JavaBeans API. The hype around
    the Beans API popularized the JavaBeans coding conventions, and they were widely
    adopted, even for classes that, like `BigDecimal`, were not JavaBeans (see [“Bean
    Style”](ch01.html#bean-java-style)). There were no Java conventions for value
    types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Today, we avoid the “set” prefix for methods that do not mutate their receiver
    and instead use names that emphasize when the method returns a transformation
    of the receiver. A common convention is to use the prefix “with” for transformations
    that affect a single property, which would make the code in our `Money` class
    read as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In Kotlin we can write extension functions to fix such historical accidents.
    If we were writing a lot of code that calculated with `BigDecimal`s, it might
    be worth doing so to improve the clarity of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Converting `Money` to Kotlin produces the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 3.9 [values.5:src/main/java/travelator/money/Money.kt]](https://java-to-kotlin.dev/code.html?ref=3.9&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=3.9&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Kotlin class still has a primary constructor, but that constructor is now
    marked private. The syntax for this is a little clumsy: we’ve reformatted the
    code that the translator produced in an attempt to make it easier to scan. Like
    `EmailAddress.parse`, the static `of` factory functions are now methods on a companion
    object annotated as `@JvmStatic`. Overall, the code is not much more concise than
    the original Java.'
  prefs: []
  type: TYPE_NORMAL
- en: Can we shrink it even further by making it a data class?
  prefs: []
  type: TYPE_NORMAL
- en: 'When we change `class` to `data class`, IntelliJ highlights the `private` keyword
    of the primary constructor with a warning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: What’s that all about?
  prefs: []
  type: TYPE_NORMAL
- en: There is a detail hiding in the implementation of `Money`. The class maintains
    an invariant between its properties, guaranteeing that the scale of the amount
    field is equal to the default number of minor currency digits of the currency
    field. The private constructor prevents code outside the `Money` class from creating
    values that violate the invariant. The `Money.of(BigDecimal,Currency)` method
    ensures the invariant is true for new `Money` values. The `add` method maintains
    the invariant because adding two `BigDecimal` values with the same scale produces
    a `BigDecimal` that also has the same scale, and it can therefore call the constructor
    directly. The constructor, therefore, need only assign fields, safe in the knowledge
    that it is never called with parameters that violate the class invariant.
  prefs: []
  type: TYPE_NORMAL
- en: However, the `copy` method of a data class is always public and so *would* allow
    client code to create `Money` values that violate the invariant. Unlike `EmailAddress`,
    an abstract data type like the `Money` class cannot be implemented by a Kotlin
    data class.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Don’t define a value type as a data class if it must maintain invariants between
    its properties.
  prefs: []
  type: TYPE_NORMAL
- en: We can still make the class more concise and convenient with Kotlin features
    that we will encounter in later chapters. So we’ll leave the `Money` class for
    now and come back to it in [Chapter 12](ch12.html#functions-to-operators) to give
    it a thorough makeover.
  prefs: []
  type: TYPE_NORMAL
- en: Moving On
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For most classes, it is quick and easy to convert Java to Kotlin. The result
    is completely compatible with existing Java code.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want value semantics, `data` classes allow us to remove even more boilerplate
    for simple classes like `EmailAddress`. Because data classes are so quick and
    easy to create, and require no maintenance, we use them to define new value types
    far more frequently in Kotlin than in Java: to declare application-specific “micro-types”
    that wrap primitive values, to hold intermediate results of a calculation pipeline,
    or to pivot data into temporary structures that make it easier to write application
    logic.'
  prefs: []
  type: TYPE_NORMAL
- en: If our value types must maintain invariants or encapsulate their representation,
    data classes are not suitable. In that case we have to implement value semantics
    ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: We left both `EmailAddress` and `Money` still looking rather Java-y…Java-ish?…Java-esque?…whatever.
    In the following chapters, we will explore how to apply Kotlin idioms to make
    code more concise, more type safe, and easier to build code upon. [Chapter 9,
    *Multi- to Single-Expression Functions*](ch09.html#multi-to-single-expression-functions),
    looks at how we can make calculation functions and methods, such as the `toString`
    method of both classes, or `equals` and `hashCode` of `Money`, more concise by
    refactoring them to single expression form. In [Chapter 12, *Functions to Operators*](ch12.html#functions-to-operators),
    we make the `Money` type more convenient to use in Kotlin by defining operators
    instead of methods.
  prefs: []
  type: TYPE_NORMAL
- en: Not all our Java classes are value types. The prevalent Java coding style favors
    mutable objects. In [Chapter 5, *Beans to Values*](ch05.html#beans-to-values),
    we look at the advantages of using value types where Java would use mutable objects,
    and show how to refactor code from mutating objects to transforming values.
  prefs: []
  type: TYPE_NORMAL
- en: Many classes in Java code exist to hold static utility methods. In Kotlin, functions
    and data are first class features. They do not need to be declared as members
    of classes. [Chapter 8, *Static Methods to Top-Level Functions*](ch08.html#static-methods-to-top-level-functions),
    explores how to convert Java classes of utility methods into top-level declarations.
  prefs: []
  type: TYPE_NORMAL
