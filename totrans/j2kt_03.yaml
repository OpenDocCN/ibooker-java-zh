- en: Chapter 3\. Java to Kotlin Classes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The class is the basic unit of code organization in Java. How do we convert
    our Java classes to Kotlin, and what differences will we see when we have?
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In this book, we’ll work together on the code in Travelator, our fictional trip-planning
    web app. Imagine that we have a feature to implement, but we want to take the
    opportunity to make our code a little better before we do. You’re pairing with
    one of Nat or Duncan (choose your favorite, just don’t let Nat know). The pair
    is the *we* in our refactoring discussions; not just your author, but also you
    as part of the team working on Travelator. Welcome aboard!
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: A Simple Value Type
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s jump into the deep end of the codebase and convert some of our existing
    Java to Kotlin, starting with `EmailAddress`. This is a value type that holds
    the two parts of, you guessed it, an email address:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[Example 3.1 [classes.0:src/main/java/travelator/EmailAddress.java]](https://java-to-kotlin.dev/code.html?ref=3.1&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=3.1&show=diff)'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: 'This class is very simple; it does nothing more than wrap two strings and provides
    no operations of its own. Even so, it has a lot of code:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: '[![1](assets/1.png)](#co_introduction_CO1-1)'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Values are immutable, so the class declares its fields as final.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_introduction_CO1-2)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: There is a static factory method to `parse` an `EmailAddress` from a string;
    this calls the primary constructor.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_introduction_CO1-3)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: The fields are initialized in a constructor.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_introduction_CO1-4)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: The accessor methods of its properties follow the JavaBean naming conventions.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_introduction_CO1-6)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: The class implements the `equals` and `hashCode` methods to ensure that two
    `EmailAddress` values with equal fields compare as equal.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_introduction_CO1-8)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '`toString` returns the canonical form.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Your authors come from the school of Java that assumes that everything we pass,
    store, or return is not null unless explicitly indicated otherwise. You can’t
    see that convention, because it results in an absence of `@Nullable` annotations
    or null checks of parameters ([Chapter 4](ch04.html#optional-to-nullable) discusses
    nullability). What you *can* see is the amount of boilerplate code required to
    express a value composed of two other values. Happily, our IDE generated the `equals`
    and `hashCode` methods for us, but we have to remember to delete and regenerate
    those methods if we change the fields of the class to avoid confusing bugs.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: So much for the Java; we’re here for the Kotlin. How do we convert? Helpfully,
    IntelliJ has an action called “Convert Java File to Kotlin File”. When we invoke
    it, IntelliJ offers to change other files if necessary to keep things consistent.
    Because the conversion can potentially modify files throughout the project, it’s
    best to say yes.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-22
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Make sure you have no uncommitted changes before converting Java source to Kotlin
    so that you can easily see the impact of the conversion on the rest of your codebase
    and revert the conversion if it does something you didn’t expect.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, IntelliJ doesn’t have to change any other files. It has replaced
    our *EmailAddress.java* file with *EmailAddress.kt* in the same directory, though:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[Example 3.2 [classes.2:src/main/java/travelator/EmailAddress.kt]](https://java-to-kotlin.dev/code.html?ref=3.2&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=3.2&show=diff)'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'The Kotlin class is noticeably more succinct because it declares its properties
    in the primary constructor: the parameters after the class name. Parameters marked
    `val` are considered properties and so stand in for all this Java:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[Example 3.3 [classes.1:src/main/java/travelator/EmailAddress.java]](https://java-to-kotlin.dev/code.html?ref=3.3&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=3.3&show=diff)'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'The primary constructor syntax is convenient, but it does interfere with the
    scanability of the class. Java classes that follow the standard coding conventions
    always define their elements in the same order: class name, superclass, interfaces,
    and then, within the class body, fields, constructors, and methods. This makes
    it easy to skim-read the class and quickly locate the features you’re interested
    in.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: It’s not quite so easy to find the parts of a Kotlin class. A Kotlin class definition
    has a header part with the class name, primary constructor (which can contain
    parameters and/or property definitions), superclass (which may also be the call
    to the superclass’s constructor), and interfaces. Then, within the class body,
    there are more properties and more constructors, methods, and companion objects.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: 'Coming from Java, Nat and Duncan definitely found it harder to read classes
    at first, and although we got used to it eventually, we still find it hard at
    times to format classes for maximum readability, especially if there is a lot
    going on in the header part. One easy fix is to lay out the constructor parameter
    list line by line. With the cursor inside the parameter list, we can do that with
    Alt-Enter and “Put parameters on separate lines”. Sometimes a blank line after
    the header part helps, too:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[Example 3.4 [classes.3:src/main/java/travelator/EmailAddress.kt]](https://java-to-kotlin.dev/code.html?ref=3.4&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=3.4&show=diff)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: One place where Kotlin is noticeably less succinct than Java is where it uses
    companion objects to host static state and methods, in this case `parse()`. In
    Kotlin, we often prefer top-level state and functions to these class-scoped members.
    [Chapter 8](ch08.html#static-methods-to-top-level-functions) discusses the pros
    and cons.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 'We currently have Java code that uses the static method, for example, the tests:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[Example 3.5 [classes.0:src/test/java/travelator/EmailAddressTests.java]](https://java-to-kotlin.dev/code.html?ref=3.5&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=3.5&show=diff)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: The companion object, combined with the `@JVMStatic` annotation, means this
    didn’t have to change when we converted the class to Kotlin, so we’ll leave `parse`
    as it is for now. We’ll discuss how to refactor to top-level functions in [Chapter 8](ch08.html#static-methods-to-top-level-functions).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re new to Kotlin, you may wonder what happened to the `getLocalPart()`
    and `getDomain()` accessor methods. Declaring the `domain` property causes the
    compiler to generate a private `domain` field and a `getDomain()` method so that
    Java code can still call it. Here is a little throwaway code to support a marketing
    plan:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[Example 3.6 [classes.3:src/main/java/travelator/Marketing.java]](https://java-to-kotlin.dev/code.html?ref=3.6&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=3.6&show=diff)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: You can see that Java is accessing the domain property through the `getDomain()`
    method. Conversely, when the class was Java and had an explicit `getDomain()`
    method, Kotlin code could have called it as `address.domain`. We’ll discuss properties
    in more detail in [Chapter 11](ch11.html#methods-to-properties).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, converting our class to Kotlin has saved us 14 lines of code, but we
    aren’t done yet. Value types like this are so useful, but so tedious to get right
    and keep right, that Kotlin supports them at a language level. If we mark the
    class with the `data` modifier, the compiler generates any undefined `equals`,
    `hashCode`, and `toString` methods for us. That reduces the `EmailAddress` class
    to:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[Example 3.7 [classes.4:src/main/java/travelator/EmailAddress.kt]](https://java-to-kotlin.dev/code.html?ref=3.7&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=3.7&show=diff)'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[![1](assets/1.png)](#co_introduction_CO2-1)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: We don’t want the generated `toString()` method, so we define the one we do
    want.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Frankly, that `parse` method still rankles; it’s taking up a disproportionate
    amount of space for the work it is doing. We’ll finally relieve this tension in
    [Chapter 9](ch09.html#multi-to-single-expression-functions). For now, though,
    we’re done with converting our `EmailAddress` Java class to Kotlin.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: The Limitations of Data Classes
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A drawback of data classes is that they offer no encapsulation. We saw how the
    compiler generates `equals`, `hashCode`, and `toString` methods for data classes
    but didn’t mention that it also generates a `copy` method that creates a new copy
    of the value with different values for one or more of its properties.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following code creates a copy of an `EmailAddress` with a
    `localPart` of “postmaster” and the same domain:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: For many types, this is very convenient. However, when a class abstracts its
    internal representation or maintains invariants between its properties, that `copy`
    method allows client code direct access to the internal state of a value, which
    can break its invariants.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多类型，这非常方便。然而，当一个类抽象其内部表示或在其属性之间维持不变性时，那个`copy`方法允许客户端代码直接访问值的内部状态，这可能会破坏其不变性。
- en: 'Let’s look at an abstract data type in the Travelator application, the `Money`
    class:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看Travelator应用中的一个抽象数据类型，`Money`类：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[Example 3.8 [values.4:src/main/java/travelator/money/Money.java]](https://java-to-kotlin.dev/code.html?ref=3.8&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=3.8&show=diff)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例3.8 [values.4:src/main/java/travelator/money/Money.java]](https://java-to-kotlin.dev/code.html?ref=3.8&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=3.8&show=diff)'
- en: '[![1](assets/1.png)](#co_introduction_CO3-1)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_introduction_CO3-1)'
- en: The constructor is private. Other classes obtain `Money` values by calling the
    static `Money.of` method, which guarantees that the scale of the amount is consistent
    with the number of minor units of the currency. Most currencies have one hundred
    minor units (two digits), but some have fewer and some more. For example, the
    Japanese yen has no minor units, and the Jordanian dinar is made up of one thousand
    fils.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数是私有的。其他类通过调用静态的`Money.of`方法来获取`Money`值，这保证了金额的刻度与货币的最小单位数量一致。大多数货币有一百个最小单位（两位数），但有些货币少一些，有些多一些。例如，日本日元没有最小单位，约旦第纳尔由一千菲尔组成。
- en: The `of` method follows a coding convention of [Modern Java](ch01.html#modern-java-style)
    that draws a distinction in the source between objects with identity, which are
    constructed by the new operator, and values, which are obtained from static methods.
    This convention is followed by the Java time API (for example, `LocalDate.of(2020,8,17)`)
    and recent additions to the collections API (for example, `List.of(1,2,3)` creates
    an immutable list).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`of`方法遵循了[现代Java](ch01.html#modern-java-style)的编码规范，在源代码中区分具有身份的对象（由new操作符构造）和从静态方法获取的值。这个规范由Java时间API（例如，`LocalDate.of(2020,8,17)`）和集合API的最新添加（例如，`List.of(1,2,3)`创建一个不可变列表）所遵循。'
- en: The class provides some convenient overloads of the `of` method for String or
    int amounts.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 该类提供了一些方便的`of`方法重载，用于字符串或整数金额。
- en: '[![2](assets/2.png)](#co_introduction_CO3-3)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_introduction_CO3-3)'
- en: A `Money` value exposes its amount and currency properties using JavaBean conventions,
    even though it is not actually a JavaBean.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`Money`值使用JavaBean约定公开其金额和货币属性，即使它实际上不是JavaBean。
- en: '[![3](assets/3.png)](#co_introduction_CO3-4)'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_introduction_CO3-4)'
- en: The `equals` and `hashCode` methods implement value semantics.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`equals`和`hashCode`方法实现了值语义。'
- en: '[![4](assets/4.png)](#co_introduction_CO3-7)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_introduction_CO3-7)'
- en: The `toString` method returns a representation of its properties that can be
    shown to the user, not just for debugging.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`toString`方法返回一个属性的表示形式，可以展示给用户，而不仅仅是用于调试。'
- en: '[![5](assets/5.png)](#co_introduction_CO3-8)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_introduction_CO3-8)'
- en: '`Money` provides operations for calculating with money values. For example,
    you can add monetary values together. The `add` method constructs new `Money`
    values by calling the constructor directly (rather than using `Money.of`), because
    the result of `BigDecimal.add` already has the correct scale, so we can avoid
    the overhead of setting the scale in `Money.of`.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`Money`提供了用于计算货币值的操作。例如，你可以将货币值相加。`add`方法通过直接调用构造函数（而不是使用`Money.of`）来构造新的`Money`值，因为`BigDecimal.add`的结果已经具有正确的刻度，因此我们可以避免在`Money.of`中设置刻度的开销。'
- en: Note
  id: totrans-70
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The method `BigDecimal.setScale` is confusing. Although named like a JavaBean
    setter, it does not actually mutate the BigDecimal object. Like our `EmailAddress`
    and `Money` classes, `BigDecimal` is an immutable value type, so `setScale` returns
    a new `BigDecimal` value with the specified scale.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`BigDecimal.setScale`方法令人困惑。虽然其名称类似于JavaBean的setter方法，但它实际上并不会改变BigDecimal对象。像我们的`EmailAddress`和`Money`类一样，`BigDecimal`是一个不可变的值类型，因此`setScale`返回一个具有指定刻度的新`BigDecimal`值。'
- en: Sun added the `BigDecimal` class to the standard library in Java 1.1\. This
    release also included the first version of the JavaBeans API. The hype around
    the Beans API popularized the JavaBeans coding conventions, and they were widely
    adopted, even for classes that, like `BigDecimal`, were not JavaBeans (see [“Bean
    Style”](ch01.html#bean-java-style)). There were no Java conventions for value
    types.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'Today, we avoid the “set” prefix for methods that do not mutate their receiver
    and instead use names that emphasize when the method returns a transformation
    of the receiver. A common convention is to use the prefix “with” for transformations
    that affect a single property, which would make the code in our `Money` class
    read as:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In Kotlin we can write extension functions to fix such historical accidents.
    If we were writing a lot of code that calculated with `BigDecimal`s, it might
    be worth doing so to improve the clarity of the code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Converting `Money` to Kotlin produces the following code:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[Example 3.9 [values.5:src/main/java/travelator/money/Money.kt]](https://java-to-kotlin.dev/code.html?ref=3.9&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=3.9&show=diff)'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: 'The Kotlin class still has a primary constructor, but that constructor is now
    marked private. The syntax for this is a little clumsy: we’ve reformatted the
    code that the translator produced in an attempt to make it easier to scan. Like
    `EmailAddress.parse`, the static `of` factory functions are now methods on a companion
    object annotated as `@JvmStatic`. Overall, the code is not much more concise than
    the original Java.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Can we shrink it even further by making it a data class?
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: 'When we change `class` to `data class`, IntelliJ highlights the `private` keyword
    of the primary constructor with a warning:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: What’s that all about?
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: There is a detail hiding in the implementation of `Money`. The class maintains
    an invariant between its properties, guaranteeing that the scale of the amount
    field is equal to the default number of minor currency digits of the currency
    field. The private constructor prevents code outside the `Money` class from creating
    values that violate the invariant. The `Money.of(BigDecimal,Currency)` method
    ensures the invariant is true for new `Money` values. The `add` method maintains
    the invariant because adding two `BigDecimal` values with the same scale produces
    a `BigDecimal` that also has the same scale, and it can therefore call the constructor
    directly. The constructor, therefore, need only assign fields, safe in the knowledge
    that it is never called with parameters that violate the class invariant.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: However, the `copy` method of a data class is always public and so *would* allow
    client code to create `Money` values that violate the invariant. Unlike `EmailAddress`,
    an abstract data type like the `Money` class cannot be implemented by a Kotlin
    data class.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  id: totrans-87
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Don’t define a value type as a data class if it must maintain invariants between
    its properties.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: We can still make the class more concise and convenient with Kotlin features
    that we will encounter in later chapters. So we’ll leave the `Money` class for
    now and come back to it in [Chapter 12](ch12.html#functions-to-operators) to give
    it a thorough makeover.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Moving On
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For most classes, it is quick and easy to convert Java to Kotlin. The result
    is completely compatible with existing Java code.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want value semantics, `data` classes allow us to remove even more boilerplate
    for simple classes like `EmailAddress`. Because data classes are so quick and
    easy to create, and require no maintenance, we use them to define new value types
    far more frequently in Kotlin than in Java: to declare application-specific “micro-types”
    that wrap primitive values, to hold intermediate results of a calculation pipeline,
    or to pivot data into temporary structures that make it easier to write application
    logic.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: If our value types must maintain invariants or encapsulate their representation,
    data classes are not suitable. In that case we have to implement value semantics
    ourselves.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: We left both `EmailAddress` and `Money` still looking rather Java-y…Java-ish?…Java-esque?…whatever.
    In the following chapters, we will explore how to apply Kotlin idioms to make
    code more concise, more type safe, and easier to build code upon. [Chapter 9,
    *Multi- to Single-Expression Functions*](ch09.html#multi-to-single-expression-functions),
    looks at how we can make calculation functions and methods, such as the `toString`
    method of both classes, or `equals` and `hashCode` of `Money`, more concise by
    refactoring them to single expression form. In [Chapter 12, *Functions to Operators*](ch12.html#functions-to-operators),
    we make the `Money` type more convenient to use in Kotlin by defining operators
    instead of methods.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: Not all our Java classes are value types. The prevalent Java coding style favors
    mutable objects. In [Chapter 5, *Beans to Values*](ch05.html#beans-to-values),
    we look at the advantages of using value types where Java would use mutable objects,
    and show how to refactor code from mutating objects to transforming values.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Many classes in Java code exist to hold static utility methods. In Kotlin, functions
    and data are first class features. They do not need to be declared as members
    of classes. [Chapter 8, *Static Methods to Top-Level Functions*](ch08.html#static-methods-to-top-level-functions),
    explores how to convert Java classes of utility methods into top-level declarations.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
