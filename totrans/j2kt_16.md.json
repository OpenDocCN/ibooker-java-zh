["```java\ndata class Email(\n    val to: EmailAddress,\n    val from: EmailAddress,\n    val subject: String,\n    val body: String\n)\n```", "```java\nfun send(email: Email) {\n    ...\n}\n```", "```java\nfun sendEmail(\n    email: Email,\n    serverAddress: InetAddress,\n    username: String,\n    password: String\n) {\n    ...\n}\n```", "```java\nclass EmailSender(\n    private val serverAddress: InetAddress,\n    private val username: String,\n    private val password: String\n) {\n    fun send(email: Email) {\n        sendEmail(\n            email,\n            serverAddress,\n            username,\n            password\n        )\n    }\n}\n```", "```java\n// Where we know the configuration\nval sender: EmailSender = EmailSender(\n    inetAddress(\"smtp.travelator.com\"),\n    \"username\",\n    \"password\"\n)\n\n// Where we send the message\nfun sendThanks() {\n    sender.send(\n        Email(\n            to = parse(\"support@internationalrescue.org\"),\n            from = parse(\"support@travelator.com\"),\n            subject = \"Thanks for your help\",\n            body = \"...\"\n        )\n    )\n}\n```", "```java\n// Where we know the configuration\nval subsystem = Rescuing(\n    EmailSender(\n        inetAddress(\"smtp.travelator.com\"),\n        \"username\",\n        \"password\"\n    )\n)\n\n// Where we send the message\nclass Rescuing(\n    private val emailSender: EmailSender\n) {\n    fun sendThanks() {\n        emailSender.send(\n            Email(\n                to = parse(\"support@internationalrescue.org\"),\n                from = parse(\"support@travelator.com\"),\n                subject = \"Thanks for your help\",\n                body = \"...\"\n            )\n        )\n    }\n}\n```", "```java\ninterface ISendEmail {\n    fun send(email: Email)\n}\n```", "```java\nclass EmailSender(\n        ...\n) : ISendEmail {\n    override fun send(email: Email) {\n        sendEmail(\n            email,\n            serverAddress,\n            username,\n            password\n        )\n    }\n}\n```", "```java\nfun createEmailSender(\n    serverAddress: InetAddress,\n    username: String,\n    password: String\n): ISendEmail =\n    object : ISendEmail {\n        override fun send(email: Email) =\n            sendEmail(\n                email,\n                serverAddress,\n                username,\n                password\n            )\n    }\n```", "```java\nfun interface ISendEmail {\n    fun send(email: Email)\n}\n\nfun createEmailSender(\n    serverAddress: InetAddress,\n    username: String,\n    password: String\n) = ISendEmail { email ->\n    sendEmail(\n        email,\n        serverAddress,\n        username,\n        password\n    )\n}\n```", "```java\nfun send(email: Email) {\n    ...\n}\n```", "```java\nfun sendEmail(\n    email: Email,\n    serverAddress: InetAddress,\n    username: String,\n    password: String\n) {\n    ...\n}\n```", "```java\nfun createEmailSender(\n    serverAddress: InetAddress,\n    username: String,\n    password: String\n): (Email) -> Unit { ![1](assets/1.png)\n    ...\n}\n```", "```java\nfun createEmailSender(\n    serverAddress: InetAddress,\n    username: String,\n    password: String\n): (Email) -> Unit {\n\n    fun result(email: Email) {\n        sendEmail(\n            email,\n            serverAddress,\n            username,\n            password\n        )\n    }\n    return ::result\n}\n```", "```java\nfun createEmailSender(\n    serverAddress: InetAddress,\n    username: String,\n    password: String\n): (Email) -> Unit {\n\n    val result: (Email) -> Unit =\n        { email ->\n            sendEmail(\n                email,\n                serverAddress,\n                username,\n                password\n            )\n        }\n    return result\n}\n```", "```java\nfun createEmailSender(\n    serverAddress: InetAddress,\n    username: String,\n    password: String\n): (Email) -> Unit =\n    { email ->\n        sendEmail(\n            email,\n            serverAddress,\n            username,\n            password\n        )\n    }\n```", "```java\n// Where we know the configuration val sender: (Email) -> Unit = createEmailSender(\n    inetAddress(\"smtp.travelator.com\"),\n    \"username\",\n    \"password\"\n)\n\n// Where we send the message fun sendThanks() {\n    sender( ![1](assets/1.png)\n        Email(\n            to = parse(\"support@internationalrescue.org\"),\n            from = parse(\"support@travelator.com\"),\n            subject = \"Thanks for your help\",\n            body = \"...\"\n        )\n    )\n}\n```", "```java\nfun sendThanks() {\n    sender.send(\n        Email(\n            to = parse(\"support@internationalrescue.org\"),\n            from = parse(\"support@travelator.com\"),\n            subject = \"Thanks for your help\",\n            body = \"...\"\n        )\n    )\n}\n```", "```java\n// Where we know the configuration Consumer<Email> sender = createEmailSender(\n    inetAddress(\"example.com\"),\n    \"username\",\n    \"password\"\n);\n\n// Where we send the message public void sendThanks() {\n    sender.accept( ![1](assets/1.png)\n        new Email(\n            parse(\"support@internationalrescue.org\"),\n            parse(\"support@travelator.com\"),\n            \"Thanks for your help\",\n            \"...\"\n        )\n    );\n}\n```", "```java\nstatic Consumer<Email> createEmailSender(\n    InetAddress serverAddress,\n    String username,\n    String password\n) {\n    return email -> sendEmail(\n        email,\n        serverAddress,\n        username,\n        password\n    );\n}\n```", "```java\nstatic Consumer<Email> createEmailSender(\n    InetAddress serverAddress,\n    String username,\n    String password\n) {\n    return new Consumer<Email>() {\n        @Override\n        public void accept(Email email) {\n            sendEmail(\n                email,\n                serverAddress,\n                username,\n                password\n            );\n        }\n    };\n}\n```", "```java\n// Kotlin function type\nval sender: (Email) -> Unit = createEmailSender(\n    inetAddress(\"smtp.travelator.com\"),\n    \"username\",\n    \"password\"\n)\n```", "```java\nval consumer: Consumer<Email> = sender // Doesn't compile ![1](assets/1.png)\n```", "```java\nval consumer: Consumer<Email> = Consumer<Email> { email ->\n    sender(email)\n}\n```", "```java\nclass Rescuing {\n    private final Consumer<Email> emailSender;\n\n    Rescuing(Consumer<Email> emailSender) {\n        this.emailSender = emailSender;\n    }\n    ...\n}\n```", "```java\nRescuing(sender)\n```", "```java\npublic class EmailSender\n    implements ISendEmail,\n        Consumer<Email> ![1](assets/1.png)\n{\n        ...\n    @Override\n    public void accept(Email email) { ![2](assets/2.png)\n        send(email);\n    }\n\n    @Override\n    public void send(Email email) {\n        sendEmail(email, serverAddress, username, password);\n    }\n}\n```", "```java\nclass EmailSender(\n        ...\n) : ISendEmail,\n    (Email) -> Unit ![1](assets/1.png)\n{\n    override operator fun invoke(email: Email) =\n        send(email) ![2](assets/2.png)\n\n    override fun send(email: Email) {\n        sendEmail(\n            email,\n            serverAddress,\n            username,\n            password\n        )\n    }\n}\n```", "```java\n// Where we know the configuration val sender: (Email) -> Unit = EmailSender(\n    inetAddress(\"smtp.travelator.com\"),\n    \"username\",\n    \"password\"\n)\n\n// Where we send the message fun sendThanks() {\n    sender( ![1](assets/1.png)\n        Email(\n            to = parse(\"support@internationalrescue.org\"),\n            from = parse(\"support@travelator.com\"),\n            subject = \"Thanks for your help\",\n            body = \"...\"\n        )\n    )\n}\n```", "```java\ntypealias EmailSenderFunction = (Email) -> Unit\n\nclass EmailSender(\n    ...\n) : EmailSenderFunction {\n    override fun invoke(email: Email) {\n        sendEmail(\n            email,\n            serverAddress,\n            username,\n            password\n        )\n    }\n}\n```", "```java\nclass EmailSender(\n    private val serverAddress: InetAddress,\n    private val username: String,\n    private val password: String\n) {\n    fun send(email: Email) {\n        sendEmail(\n            email,\n            serverAddress,\n            username,\n            password\n        )\n    }\n}\n```", "```java\nval instance = EmailSender(\n    inetAddress(\"smtp.travelator.com\"),\n    \"username\",\n    \"password\"\n)\nval sender: (Email) -> Unit = { instance.send(it) }\n```", "```java\nval sender: (Email) -> Unit = instance::send\n```", "```java\nval function: (Email) -> Unit = createEmailSender(\n    inetAddress(\"smtp.travelator.com\"),\n    \"username\",\n    \"password\"\n)\n\nval sender: ISendEmail = object : ISendEmail {\n    override fun send(email: Email) {\n        function(email)\n    }\n}\n```", "```java\nfun interface ISendEmail {\n    fun send(email: Email)\n}\n\nval sender = ISendEmail { function(it) }\n```", "```java\nclass EmailSender(\n    private val serverAddress: InetAddress,\n    private val username: String,\n    private val password: String\n) {\n    fun send(email: Email) {\n        sendEmail(\n            email,\n            serverAddress,\n            username,\n            password\n        )\n    }\n}\n```", "```java\n// Where we know the configuration\nval sender: EmailSender = EmailSender(\n    inetAddress(\"smtp.travelator.com\"),\n    \"username\",\n    \"password\"\n)\n\n// Where we send the message\nfun sendThanks() {\n    sender.send(\n        Email(\n            to = parse(\"support@internationalrescue.org\"),\n            from = parse(\"support@travelator.com\"),\n            subject = \"Thanks for your help\",\n            body = \"...\"\n        )\n    )\n}\n```", "```java\n// Where we know the configuration val sender: (Email) -> Unit = createEmailSender(\n    inetAddress(\"smtp.travelator.com\"),\n    \"username\",\n    \"password\"\n)\n\n// Where we send the message fun sendThanks() {\n    sender( ![1](assets/1.png)\n        Email(\n            to = parse(\"support@internationalrescue.org\"),\n            from = parse(\"support@travelator.com\"),\n            subject = \"Thanks for your help\",\n            body = \"...\"\n        )\n    )\n}\n```", "```java\ninterface EmailSystem {\n    fun send(email: Email)\n    fun delete(email: Email)\n    fun list(folder: Folder): List<Email>\n    fun move(email: Email, to: Folder)\n}\n```", "```java\nclass EmailSystem(\n    val send: (Email) -> Unit,\n    val delete: (Email) -> Unit,\n    val list: (folder: Folder) -> List<Email>,\n    val move: (email: Email, to: Folder) ->  Unit\n)\n```", "```java\nfun sendThanks(sender: EmailSystem) {\n    sender.send(\n        Email(\n            to = parse(\"support@internationalrescue.org\"),\n            from = parse(\"support@travelator.com\"),\n            subject = \"Thanks for your help\",\n            body = \"...\"\n        )\n    )\n}\n```", "```java\nfun sendThanks(sender: EmailSystem) {\n    sender.send.invoke(\n        Email(\n            to = parse(\"support@internationalrescue.org\"),\n            from = parse(\"support@travelator.com\"),\n            subject = \"Thanks for your help\",\n            body = \"...\"\n        )\n    )\n}\n```", "```java\ninterface EmailSystem {\n    fun send(email: Email)\n    fun delete(email: Email)\n    fun list(folder: Folder): List<Email>\n    fun move(email: Email, to: Folder)\n}\n```", "```java\nclass Organiser(\n    private val listing: (Folder) -> List<Email>\n) {\n    fun subjectsIn(folder: Folder): List<String> {\n        return listing(folder).map { it.subject }\n    }\n}\n\nval emailSystem: EmailSystem = ...\nval organiser = Organiser(emailSystem::list)\n```", "```java\nclass Organiser(\n    private val listing: (Folder) -> List<Email>,\n    private val deleting: (Email) -> Unit\n) {\n    fun deleteInternal(folder: Folder) {\n        listing(rootFolder).forEach {\n            if (it.to.isInternal()) {\n                deleting.invoke(it)\n            }\n        }\n    }\n}\n\nval organiser = Organiser(\n    emailSystem::list,\n    emailSystem::delete\n)\n```", "```java\nclass Organiser(\n    private val emails: EmailSystem\n) {\n    fun organise() {\n        emails.list(rootFolder).forEach {\n            if (it.to.isInternal()) {\n                emails.delete(it)\n            } else {\n                emails.move(it, archiveFolder)\n            }\n        }\n    }\n}\n\nval organiser = Organiser(emailSystem)\n```", "```java\nclass Organiser(\n    private val emails: Dependencies\n) {\n    interface Dependencies {\n        fun delete(email: Email)\n        fun list(folder: Folder): List<Email>\n        fun move(email: Email, to: Folder)\n    }\n\n    fun organise() {\n        emails.list(rootFolder).forEach {\n            if (it.to.isInternal()) {\n                emails.delete(it)\n            } else {\n                emails.move(it, archiveFolder)\n            }\n        }\n    }\n}\n\nval organiser = Organiser(object : Organiser.Dependencies {\n    override fun delete(email: Email) {\n        emailSystem.delete(email)\n    }\n\n    override fun list(folder: Folder): List<Email> {\n        return emailSystem.list(folder)\n    }\n\n    override fun move(email: Email, to: Folder) {\n        emailSystem.move(email, to)\n    }\n})\n```", "```java\nclass Organiser(\n    private val emails: Dependencies\n) {\n    class Dependencies(\n        val delete: (Email) -> Unit,\n        val list: (folder: Folder) -> List<Email>,\n        val move: (email: Email, to: Folder) -> Unit\n    )\n\n    fun organise() {\n        emails.list(rootFolder).forEach {\n            if (it.to.isInternal()) {\n                emails.delete(it)\n            } else {\n                emails.move(it, archiveFolder)\n            }\n        }\n    }\n}\n\nval organiser = Organiser(\n    Organiser.Dependencies(\n        delete = emailSystem::delete,\n        list = emailSystem::list,\n        move = emailSystem::move\n    )\n)\n```", "```java\npublic class Recommendations {\n    private final FeaturedDestinations featuredDestinations;\n    private final DistanceCalculator distanceCalculator;\n\n    public Recommendations(\n        FeaturedDestinations featuredDestinations,\n        DistanceCalculator distanceCalculator\n    ) {\n        this.featuredDestinations = featuredDestinations;\n        this.distanceCalculator = distanceCalculator;\n    }\n    ...\n}\n```", "```java\npublic interface FeaturedDestinations {\n    List<FeaturedDestination> findCloseTo(Location location);\n    FeaturedDestination findClosest(Location location);\n\n    FeaturedDestination add(FeaturedDestinationData destination);\n    void remove(FeaturedDestination destination);\n    void update(FeaturedDestination destination);\n}\n```", "```java\ninterface DistanceCalculator {\n    fun distanceInMetersBetween(\n        start: Location,\n        end: Location\n    ): Int\n\n    fun travelTimeInSecondsBetween(\n        start: Location,\n        end: Location\n    ): Int\n}\n```", "```java\npublic List<FeaturedDestinationSuggestion> recommendationsFor(\n    Set<Location> journey\n) {\n    var results = removeDuplicates(\n        journey.stream()\n            .flatMap(location ->\n                recommendationsFor(location).stream()\n            )\n    );\n    results.sort(distanceComparator);\n    return results;\n}\n\npublic List<FeaturedDestinationSuggestion> recommendationsFor(\n    Location location\n) {\n    return featuredDestinations\n        .findCloseTo(location) ![1](assets/1.png)\n        .stream()\n        .map(featuredDestination ->\n            new FeaturedDestinationSuggestion(\n                location,\n                featuredDestination,\n                distanceCalculator.distanceInMetersBetween( ![2](assets/2.png)\n                    location,\n                    featuredDestination.getLocation()\n                )\n            )\n        ).collect(toList());\n}\n```", "```java\npublic class RecommendationsTests {\n\n    private final DistanceCalculator distanceCalculator =\n        mock(DistanceCalculator.class);\n    private final FeaturedDestinations featuredDestinations =\n        mock(FeaturedDestinations.class);\n    private final Recommendations recommendations = new Recommendations(\n        featuredDestinations,\n        distanceCalculator\n    );\n    ...\n}\n```", "```java\n@Test\npublic void returns_recommendations_for_multi_location() {\n    givenFeaturedDestinationsFor(paris,\n        List.of(\n            eiffelTower,\n            louvre\n        ));\n    givenADistanceBetween(paris, eiffelTower, 5000);\n    givenADistanceBetween(paris, louvre, 1000);\n\n    givenFeaturedDestinationsFor(alton,\n        List.of(\n            flowerFarm,\n            watercressLine\n        ));\n    givenADistanceBetween(alton, flowerFarm, 5300);\n    givenADistanceBetween(alton, watercressLine, 320);\n\n    assertEquals(\n        List.of(\n            new FeaturedDestinationSuggestion(alton, watercressLine, 320),\n            new FeaturedDestinationSuggestion(paris, louvre, 1000),\n            new FeaturedDestinationSuggestion(paris, eiffelTower, 5000),\n            new FeaturedDestinationSuggestion(alton, flowerFarm, 5300)\n        ),\n        recommendations.recommendationsFor(Set.of(paris, alton))\n    );\n}\n```", "```java\nclass Recommendations(\n    private val featuredDestinations: FeaturedDestinations,\n    private val distanceCalculator: DistanceCalculator\n) {\n    fun recommendationsFor(\n        journey: Set<Location>\n    ): List<FeaturedDestinationSuggestion> =\n        journey\n            .flatMap { location -> recommendationsFor(location) }\n            .deduplicated()\n            .sortedBy { it.distanceMeters }\n\n    fun recommendationsFor(\n        location: Location\n    ): List<FeaturedDestinationSuggestion> =\n        featuredDestinations.findCloseTo(location)\n            .map { featuredDestination ->\n                FeaturedDestinationSuggestion(\n                    location,\n                    featuredDestination,\n                    distanceCalculator.distanceInMetersBetween(\n                        location,\n                        featuredDestination.location\n                    )\n                )\n            }\n}\n\nprivate fun List<FeaturedDestinationSuggestion>.deduplicated() =\n    groupBy { it.suggestion }\n        .values\n        .map { suggestionsWithSameDestination ->\n            suggestionsWithSameDestination.closestToJourneyLocation()\n        }\n\nprivate fun List<FeaturedDestinationSuggestion>.closestToJourneyLocation() =\n    minByOrNull { it.distanceMeters } ?: error(\"Unexpected empty group\")\n```", "```java\nclass Recommendations(\n    private val featuredDestinations: FeaturedDestinations,\n    private val distanceCalculator: DistanceCalculator\n) {\n    private val destinationFinder: ![1](assets/1.png)\n        (Location) -> List<FeaturedDestination> =\n        featuredDestinations::findCloseTo\n\n    ...\n\n    fun recommendationsFor(\n        location: Location\n    ): List<FeaturedDestinationSuggestion> =\n        destinationFinder(location) ![2](assets/2.png)\n            .map { featuredDestination ->\n                FeaturedDestinationSuggestion(\n                    location,\n                    featuredDestination,\n                    distanceCalculator.distanceInMetersBetween(\n                        location,\n                        featuredDestination.location\n                    )\n                )\n            }\n}\n```", "```java\nclass Recommendations(\n    private val featuredDestinations: FeaturedDestinations,\n    private val distanceCalculator: DistanceCalculator,\n    private val destinationFinder:\n        (Location) -> List<FeaturedDestination> =\n        featuredDestinations::findCloseTo\n) {\n```", "```java\nprivate final Recommendations recommendations = new Recommendations(\n    featuredDestinations,\n    distanceCalculator,\n    featuredDestinations::findCloseTo\n);\n```", "```java\nclass Recommendations(\n    private val distanceCalculator: DistanceCalculator,\n    private val destinationFinder: (Location) -> List<FeaturedDestination>\n) {\n```", "```java\nprivate final Recommendations recommendations = new Recommendations(\n    distanceCalculator,\n    featuredDestinations::findCloseTo\n);\n```", "```java\nclass Recommendations(\n    private val destinationFinder: (Location) -> List<FeaturedDestination>,\n    private val distanceInMetersBetween: (Location, Location) -> Int\n) {\n    ...\n    fun recommendationsFor(\n        location: Location\n    ): List<FeaturedDestinationSuggestion> =\n        destinationFinder(location)\n            .map { featuredDestination ->\n                FeaturedDestinationSuggestion(\n                    location,\n                    featuredDestination,\n                    distanceInMetersBetween( ![1](assets/1.png)\n                        location,\n                        featuredDestination.location\n                    )\n                )\n            }\n}\n```", "```java\nprivate final Recommendations recommendations = new Recommendations(\n    featuredDestinations::findCloseTo,\n    distanceCalculator::distanceInMetersBetween\n);\n```"]