<html><head></head><body><section data-pdf-bookmark="Chapter 11. Functional Approaches in Java" data-type="chapter" epub:type="chapter"><div class="chapter" id="learnjava6-CHP-11">&#13;
<h1><span class="label">Chapter 11. </span>Functional Approaches in Java</h1>&#13;
&#13;
&#13;
<p>Java is—and remains—an object-oriented language. All of the design patterns and class types we saw in <a data-type="xref" href="ch05.html#learnjava6-CHP-5">Chapter 5</a> are still core to how most developers write Java code. Java is also flexible, with individual and corporate contributors proposing and making improvements. <a data-primary="java.util.function package" data-type="indexterm" id="ix_java_util_func"/><a data-primary="functional programming (FP) with Java" data-type="indexterm" id="ix_func_prog_ch11"/>As <em>functional programming</em> (FP) moves back into the limelight, Java is keeping up. FP represents an alternate way to approach programming: functions, rather than objects, are the focus.</p>&#13;
&#13;
<p>Starting as far back as Java 8, Java has supported a reasonable set of functional features with the <code>java.util.function</code> package. This package includes several classes and interfaces that allow developers to use popular functional approaches to problem-solving. We’ll explore some of these approaches in this chapter, but we want to emphasize that verb, <em>allow</em>. If you don’t enjoy functional programming, you can safely ignore this chapter. We hope you’ll try some of the examples, though. There are some nice features that can make your code more compact while retaining its readability.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Functions 101" data-type="sect1"><div class="sect1" id="learnjava6-CHP-11-SECT-1">&#13;
<h1>Functions 101</h1>&#13;
&#13;
<p>The roots of <a data-primary="Church, Alonzo" data-type="indexterm" id="id2198"/>functional programming extend all the way back to the 1930s, with American mathematician Alonzo Church and his lambda calculus. Church wasn’t running his calculus on any hardware, but lambda calculus formalized a way of problem-solving that would lead to early programming languages written for real, operating machines.<sup><a data-type="noteref" href="ch11.html#id2199" id="id2199-marker">1</a></sup> <a data-primary="Lisp" data-type="indexterm" id="id2200"/>The Lisp language was developed in the 1950s at MIT and ran on early iterations of modern computers like the IBM 700 series. If you can picture an old black-and-white photo with bookshelf-sized walls of blinking lights, you’ve got the right idea for how far back FP ideas and patterns go in the history of computing.</p>&#13;
&#13;
<p>But <a data-primary="OOP (object-oriented programming)" data-type="indexterm" id="id2201"/>FP is not the only way to program a computer. Other paradigms, such as procedural programming and object-oriented programming (OOP), regularly vie for popularity. Happily, you can accomplish the same goals in any of those paradigms. The paradigm you choose usually comes down to the problem domain and more than a bit of personal preference.</p>&#13;
&#13;
<p>Consider the simple tasks of adding two numbers and assigning that result to a variable. We can do this in object-oriented languages like Java, in functional languages like Clojure,<sup><a data-type="noteref" href="ch11.html#id2202" id="id2202-marker">2</a></sup> or procedural languages like C:</p>&#13;
&#13;
<pre data-type="programlisting">// Java objects&#13;
BigInteger five = new BigInteger(5);&#13;
BigInteger twelve = new BigInteger(12);&#13;
BigInteger sum = five.add(twelve);&#13;
&#13;
// Clojure&#13;
(def five 5)&#13;
(def twelve 12)&#13;
(def sum (+ five twelve))&#13;
&#13;
// C&#13;
int five = 5;&#13;
int twelve = 12;&#13;
int sum = five + twelve;</pre>&#13;
&#13;
<p>Java hit the digital scene as OOP was (again) on the rise, and it reflects those roots. Still, FP has always had its evangelists. Java 8 offered some substantial additions to the language and opened the door for fans of functional programming to work with Java. Let’s take a look at some of those additions and see how they integrate with the larger world of Java.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Lambdas" data-type="sect1"><div class="sect1" id="learnjava6-CHP-11-SECT-2">&#13;
<h1>Lambdas</h1>&#13;
&#13;
<p>Inspired by the <a data-primary="lambda expressions (lambdas)" data-type="indexterm" id="ix_lambda_exp"/><a data-primary="functional programming (FP) with Java" data-secondary="lambda expressions" data-type="indexterm" id="ix_func_prog_lambda"/>lambda calculus, <em>lambda expressions</em> (or more simply, lambdas) form the core unit of functional programming in Java. Lambdas are a means of encapsulating a bit of logic. In a functional language, functions are “first-class citizens” and can be created, stored, referenced, used, and passed around just like objects in Java. To mimic that, uh, functionality, Java 8 introduced some new syntax alongside several special interfaces. These additions allow you to quickly define a function that can replace an entire inner class. The result of that definition is still an object under the hood, of course, but one whose “objectness” is mostly hidden.</p>&#13;
&#13;
<p>We’ll cover lambda expressions and those special interfaces in more detail throughout the rest of this section. Then we’ll look at a popular, concrete example of using these expressions to do real work.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Lambda Expressions" data-type="sect2"><div class="sect2" id="learnjava6-CHP-11-SECT-2.1">&#13;
<h2>Lambda Expressions</h2>&#13;
&#13;
<p>Lambda <a data-primary="expressions" data-secondary="lambda" data-type="indexterm" id="ix_exp_lambda"/>expressions are small bits of code that can accept parameters and return values, just like methods. <a data-primary="methods" data-secondary="and lambdas" data-secondary-sortas="lambdas" data-type="indexterm" id="id2203"/>Unlike methods, though, you can easily pass a lambda as an argument to some other method or store it in a variable like you might with an object reference. FP proponents prize this ability to move code around like data. It allows you to write interesting and dynamic code without the clutter of creating inner or anonymous inner classes.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Lambdas are not meant to provide a <a data-primary="performance" data-secondary="lambdas" data-type="indexterm" id="id2204"/>performance boost. Although judicious use of lambdas often makes for more compact, more concise source code, that compression does not remove any complexity. Lambdas may require less typing, but they don’t do less work.</p>&#13;
</div>&#13;
&#13;
<p>Recall the <code>run()</code> method used by threads, which we saw so often in <a data-type="xref" href="ch09.html#learnjava6-CHP-9">Chapter 9</a>. We created more than a few small classes that implemented the <code>Runnable</code> interface to supply a “body” to our threads. Small classes that do not include any state as instance variables are prime candidates for using lambdas: you have a well-defined task that you use in a well-defined situation.</p>&#13;
&#13;
<p>Let’s revisit one of our <a data-primary="threads" data-secondary="lambdas with" data-type="indexterm" id="ix_thread_lambda"/>thread demonstrations and then take a peek at how we could use a lambda expression as an alternative to the explicit use of <code>Runnable</code>. We’ll simplify the <code>VirtualDemo</code> class from <a data-type="xref" href="ch09.html#learnjava6-CHP-9-SECT-2">“Death of a Thread”</a> and concentrate on the anonymous inner class:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code><code class="w"> </code><code class="kd">class</code> <code class="nc">VirtualDemo2</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">public</code><code class="w"> </code><code class="kd">static</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">main</code><code class="p">(</code><code class="n">String</code><code class="w"> </code><code class="n">args</code><code class="o">[]</code><code class="p">)</code><code class="w"> </code><code class="kd">throws</code><code class="w"> </code><code class="n">Exception</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">Runnable</code><code class="w"> </code><code class="n">runnable</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">Runnable</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="kd">public</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">run</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">        </code><code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="s">"Hello thread! ID: "</code><code class="w"> </code><code class="o">+</code><code class="w"/>&#13;
<code class="w">            </code><code class="n">Thread</code><code class="p">.</code><code class="na">currentThread</code><code class="p">().</code><code class="na">threadId</code><code class="p">());</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">}</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">};</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">Thread</code><code class="w"> </code><code class="n">t</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Thread</code><code class="p">.</code><code class="na">startVirtualThread</code><code class="p">(</code><code class="n">runnable</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">t</code><code class="p">.</code><code class="na">join</code><code class="p">();</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">}</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>We create a new instance of <code>Runnable</code> with a simple <code>run()</code> method that prints a greeting and the thread’s ID number:</p>&#13;
&#13;
<pre data-type="programlisting">% java --enable-preview VirtualDemo2&#13;
Hello thread! ID: 20</pre>&#13;
&#13;
<p>Great. Everything works as expected. Now let’s replace that <code>runnable</code> variable with a lambda expression:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code><code class="w"> </code><code class="kd">class</code> <code class="nc">VirtualDemo3</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">public</code><code class="w"> </code><code class="kd">static</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">main</code><code class="p">(</code><code class="n">String</code><code class="w"> </code><code class="n">args</code><code class="o">[]</code><code class="p">)</code><code class="w"> </code><code class="kd">throws</code><code class="w"> </code><code class="n">Exception</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">Thread</code><code class="w"> </code><code class="n">t</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Thread</code><code class="p">.</code><code class="na">startVirtualThread</code><code class="p">(()</code><code class="w"> </code><code class="o">-&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="s">"Hello thread! ID: "</code><code class="w"> </code><code class="o">+</code><code class="w"/>&#13;
<code class="w">          </code><code class="n">Thread</code><code class="p">.</code><code class="na">currentThread</code><code class="p">().</code><code class="na">threadId</code><code class="p">())</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">t</code><code class="p">.</code><code class="na">join</code><code class="p">();</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">}</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>We still start a <a data-primary="startVirtualThread() method" data-type="indexterm" id="id2205"/>new virtual thread, and we still store that thread in a variable (<code>t</code>, in both examples), but there is no evidence of the <code>Runnable</code> interface. We passed a somewhat strange argument to the <code>startVirtualThread()</code> method instead of a reference to some object. That “strange argument” is our lambda expression, annotated in <a data-type="xref" href="#learnjava6-CHP-11-FIG-lambda-1">Figure 11-1</a>.</p>&#13;
&#13;
<figure><div class="figure" id="learnjava6-CHP-11-FIG-lambda-1">&#13;
<img alt="ljv6 1101" src="assets/ljv6_1101.png"/>&#13;
<h6><span class="label">Figure 11-1. </span>Basic structure of a lambda expression</h6>&#13;
</div></figure>&#13;
&#13;
<p>This particular <a data-primary="-&gt; (arrow operator)" data-secondary="lambda expressions" data-type="indexterm" id="id2206"/>lambda is very simple. We don’t pass it any arguments, and it does not return a value. Often that’s all you need. But lambdas are capable of much more. Lambda expressions also support arguments, can return values, and can have more interesting bodies.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Passing arguments" data-type="sect3"><div class="sect3" id="learnjava6-CHP-11-SECT-2.1.1">&#13;
<h3>Passing arguments</h3>&#13;
&#13;
<p>If we <a data-primary="lambda expressions (lambdas)" data-secondary="passing arguments" data-type="indexterm" id="id2207"/><a data-primary="passing arguments" data-type="indexterm" id="id2208"/><a data-primary="arguments" data-secondary="in lambda expressions" data-secondary-sortas="lambda expressions" data-type="indexterm" id="id2209"/>think about lambdas as bits of code, it’s reasonable to compare them to regular methods. Regular methods do encapsulate logic, just like lambdas. But many of the methods we’ve seen in previous chapters also accept arguments. Can we supply arguments to a lambda?</p>&#13;
&#13;
<p>Consider an iterator that walks through the elements of a Java collection. We saw several examples in <a data-type="xref" href="ch07.html#learnjava6-CHP-7">Chapter 7</a>. In those examples, we used an iterator inside a loop, with the body of the loop doing something with the given element of the collection on each pass. Recall our tree-painting loop from <a data-type="xref" href="ch07.html#learnjava6-CHP-7-SECT-8">“Application: Trees on the Field”</a>:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="c1">// File: Field.java</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">protected</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">paintComponent</code><code class="p">(</code><code class="n">Graphics</code><code class="w"> </code><code class="n">g</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">g</code><code class="p">.</code><code class="na">setColor</code><code class="p">(</code><code class="n">fieldColor</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">g</code><code class="p">.</code><code class="na">fillRect</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="n">getWidth</code><code class="p">(),</code><code class="w"> </code><code class="n">getHeight</code><code class="p">());</code><code class="w"/>&#13;
<code class="w">    </code><code class="k">for</code><code class="w"> </code><code class="p">(</code><code class="n">Tree</code><code class="w"> </code><code class="n">t</code><code class="w"> </code><code class="p">:</code><code class="w"> </code><code class="n">trees</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="n">t</code><code class="p">.</code><code class="na">draw</code><code class="p">(</code><code class="n">g</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">}</code><code class="w"/>&#13;
<code class="w">    </code><code class="c1">// ...</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>The alternate <code>for</code> loop <a data-primary="forEach() method" data-secondary="Iterable" data-type="indexterm" id="id2210"/><a data-primary="Iterable interface" data-type="indexterm" id="id2211"/>uses the iterator from <code>trees</code> to get every individual tree, and then tells that tree to draw itself on our field. We could replace that loop with a lambda and the <code>forEach()</code> method of the <code>Iterable</code> interface:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="c1">// File: Field.java</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">protected</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">paintComponent</code><code class="p">(</code><code class="n">Graphics</code><code class="w"> </code><code class="n">g</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">g</code><code class="p">.</code><code class="na">setColor</code><code class="p">(</code><code class="n">fieldColor</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">g</code><code class="p">.</code><code class="na">fillRect</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="n">getWidth</code><code class="p">(),</code><code class="w"> </code><code class="n">getHeight</code><code class="p">());</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">trees</code><code class="p">.</code><code class="na">forEach</code><code class="p">(</code><code class="n">t</code><code class="w"> </code><code class="o">-&gt;</code><code class="w"> </code><code class="n">t</code><code class="p">.</code><code class="na">draw</code><code class="p">(</code><code class="n">g</code><code class="p">));</code><code class="w"/>&#13;
<code class="w">    </code><code class="c1">// ...</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>You can see the same arrow operator, but instead of an empty pair of parentheses, we have a variable, <code>t</code> on the lefthand side. That variable receives one tree at a time from the <code>trees</code> collection, just like the alternate <code>for</code> loop from the first snippet. And just like the body of that <code>for</code> loop, you can use the current tree on the righthand side of the expression. With this arrangement, we get a slightly more concise version of our loop, but it retains its readability. You can use this handy trick with any collection that implements the <code>Iterable</code> interface.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Terms like <em>concise</em> and <em>readable</em> are subjective judgments. Proponents of FP definitely find the more compact syntax of lambdas easier to read, but those folks are already comfortable with the notation. We hope you’ll try the examples and exercises in this chapter to gain a little of that familiarity. We do like lambdas and use them in a number of situations, but they are never required. If you don’t find lambdas useful or readable after trying them out, you don’t need to use them in your own code.</p>&#13;
</div>&#13;
&#13;
<p>You may have noticed that our first lambda expression for a simple thread body took no arguments, so we used an empty set of parentheses on the lefthand side. But in this most recent example, we had one argument and no parentheses. The single argument form is so common that the compiler allows this shorthand with no parentheses. If you have no arguments, or more than one argument, the parentheses are required.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Expression bodies" data-type="sect3"><div class="sect3" id="learnjava6-CHP-11-SECT-2.1.2">&#13;
<h3>Expression bodies</h3>&#13;
&#13;
<p>Lambda <a data-primary="lambda expressions (lambdas)" data-secondary="expression bodies" data-type="indexterm" id="id2212"/><a data-primary="inner classes" data-type="indexterm" id="id2213"/><a data-primary="lambda expressions (lambdas)" data-secondary="and inner classes" data-secondary-sortas="inner classes" data-type="indexterm" id="id2214"/>expressions shine in situations where you would otherwise use an anonymous inner class. You can’t substitute lambdas for all situations that call for anonymous inner classes, but there are a surprising number of spots throughout Java that do work with lambdas. With this variety of applications comes the need for more complex computing beyond print statements. If you need to perform a few statements or work with a temporary variable, for example, you can enclose the body of the expression in curly braces, just like a method.</p>&#13;
&#13;
<p>Imagine the trees in our game are seasonal. You could specify the color of their leaves before drawing them. You can still use a lambda:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="n">trees</code><code class="p">.</code><code class="na">forEach</code><code class="p">(</code><code class="n">t</code><code class="w"> </code><code class="o">-&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="n">t</code><code class="p">.</code><code class="na">setLeafColor</code><code class="p">(</code><code class="n">getSeasonalColor</code><code class="p">());</code><code class="w"/>&#13;
<code class="w">      </code><code class="n">t</code><code class="p">.</code><code class="na">draw</code><code class="p">(</code><code class="n">g</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">});</code><code class="w"/></pre>&#13;
&#13;
<p>Presumably our fictitious <code>getSeasonalColor()</code> method does some nice date-based calculating and returns an appropriate color. Notice that you can use methods (and most variables) from the rest of the class inside our lambda expression. Lambdas are quite powerful. But part of their power comes from judicious use—a 20-line expression body would probably hurt the readability of your code. But if you have a few lambdas with a few lines, you’re in good shape.</p>&#13;
&#13;
<p>Beyond <a data-primary="variables" data-secondary="final variables in lambdas" data-type="indexterm" id="id2215"/><a data-primary="final variables, lambdas" data-type="indexterm" id="id2216"/>keeping your lambdas readable, we want to point out a few quirks that might crop up for you. If you do want to use a local variable from the enclosing scope, it must be “effectively final” per the documentation. Recall that <code>final</code> variables can’t be modified. <em>Effectively final</em> variables are ones that <em>are not</em> modified even though they might not have the official <code>final</code> keyword in their declaration. If you try to use a nonfinal, local variable, the compiler will complain. Happily, this restriction only applies to local variables. You are free to use (and even modify) variables declared as members of the enclosing class.</p>&#13;
&#13;
<p>The other <a data-primary="this reference" data-type="indexterm" id="id2217"/>quirk revolves around the keyword <code>this</code>. If you recall from <a data-type="xref" href="ch05.html#learnjava6-CHP-5-SECT-2.2.1">“The “this” reference”</a>, <code>this</code> gives you a reference to the current object. It’s handy when methods or constructors have argument names that overlap with member variables:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code><code class="w"> </code><code class="kd">class</code> <code class="nc">Position</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="kt">int</code><code class="w"> </code><code class="n">x</code><code class="p">,</code><code class="w"> </code><code class="n">y</code><code class="p">;</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="kd">public</code><code class="w"> </code><code class="nf">Position</code><code class="p">(</code><code class="kt">int</code><code class="w"> </code><code class="n">x</code><code class="p">,</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="n">y</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="k">this</code><code class="p">.</code><code class="na">x</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">x</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">    </code><code class="k">this</code><code class="p">.</code><code class="na">y</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">y</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">}</code><code class="w"/>&#13;
<code class="w">  </code><code class="c1">// ...</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>While you might reasonably think that <code>this</code> inside a lambda body would refer to the lambda itself, it actually still refers to the enclosing class. This quirk means you can use <code>this</code> inside a lambda just as you would with the constructor in the previous example. It makes sure your lambdas have access to the stuff in your class, even if a local variable would otherwise shadow something.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Returning values" data-type="sect3"><div class="sect3" id="learnjava6-CHP-11-SECT-2.1.3">&#13;
<h3>Returning values</h3>&#13;
&#13;
<p>Whether your <a data-primary="returning values, lambda expressions" data-type="indexterm" id="id2218"/><a data-primary="lambda expressions (lambdas)" data-secondary="returning values" data-type="indexterm" id="id2219"/>lambda is a pithy one-liner or includes a readability-busting dozen lines, you can also return a value. A (deceptively) simple example is an incrementing function that takes an integer argument and returns an integer that is one more than the input. The expression itself would look something like this:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="n">x</code><code class="w"> </code><code class="o">-&gt;</code><code class="w"> </code><code class="n">x</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="mi">1</code><code class="w"/></pre>&#13;
&#13;
<p>In this form, Java will compute the answer to <code>x + 1</code> and return it. If we have a multiline body that should return a value, we can use the <code>return</code> keyword:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="n">x</code><code class="w"> </code><code class="o">-&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="s">"Input: "</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">x</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="n">x</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="mi">1</code><code class="p">;</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>Explicit returns can be handy when you have <code>if</code> statements in the body. But the simpler form is preferable if your expression fits.<a data-primary="" data-startref="ix_thread_lambda" data-type="indexterm" id="id2220"/><a data-primary="" data-startref="ix_exp_lambda" data-type="indexterm" id="id2221"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Functional Interfaces" data-type="sect2"><div class="sect2" id="learnjava6-CHP-11-SECT-2.2">&#13;
<h2>Functional Interfaces</h2>&#13;
&#13;
<p>You may be <a data-primary="functional programming (FP) with Java" data-secondary="functional interfaces" data-type="indexterm" id="id2222"/><a data-primary="lambda expressions (lambdas)" data-secondary="functional interfaces" data-type="indexterm" id="id2223"/>wondering how Java categorizes our simple lambda expression. Is it an <code>int</code> like the input, or the result? Is it an object like so much of Java? Is it something we haven’t seen yet? Let’s see if <em>jshell</em> can shed any light:</p>&#13;
&#13;
<pre class="jshell" data-type="programlisting">jshell&gt; x -&gt; x + 1&#13;
|  Error:&#13;
|  incompatible types: java.lang.Object is not a functional interface&#13;
|  x -&gt; x + 1&#13;
|  ^--------^</pre>&#13;
&#13;
<p>Hmm, not <a data-primary="reference (class) types" data-secondary="inferring" data-type="indexterm" id="id2224"/><a data-primary="inferring reference type" data-type="indexterm" id="id2225"/>really what we were hoping for, but that phrase <em>functional interface</em> is a clue. Let’s try that <code>var</code> keyword we saw in <a data-type="xref" href="ch04.html#learnjava6-CHP-4-SECT-4.2.1">“Inferring types”</a> and see if our lambda expression can be inferred:</p>&#13;
&#13;
<pre class="jshell" data-type="programlisting">jshell&gt; var inc = x -&gt; x + 1&#13;
|  Error:&#13;
|  cannot infer type for local variable inc&#13;
|    (lambda expression needs an explicit target-type)&#13;
|  var inc = x -&gt; x + 1;&#13;
|  ^-------------------^</pre>&#13;
&#13;
<p>Shoot. <em>jshell</em> did recognize our lambda expression, but that recognition isn’t enough to establish a type.</p>&#13;
&#13;
<p>So what is a <a data-primary="IntFunction interface" data-type="indexterm" id="id2226"/><a data-primary="java.util.function package" data-secondary="IntFunction interface" data-type="indexterm" id="id2227"/>lambda expression’s type? In the case of our simple incrementing lambda, it turns out to be an <code>IntFunction</code>, a function that accepts one <code>int</code> as an argument and returns an <code>int</code>. The <code>IntFunction</code> interface lives in the <code>java.util.function</code> package alongside several other functional interfaces. Each interface in this package represents a different “shape” that a lambda expression can take. Let’s try it:</p>&#13;
&#13;
<pre class="jshell" data-type="programlisting">jshell&gt; import java.util.function.*&#13;
&#13;
jshell&gt; IntFunction inc = x -&gt; x + 1&#13;
inc ==&gt; $Lambda$24/0x0000000840087840@23ab930d</pre>&#13;
&#13;
<p>Hooray! We didn’t get an error! (Although that resulting value looks rather daunting.) Happily, we don’t need to worry about the internal details of our lambda, as long as we can apply it to some data. But just how would we apply it?</p>&#13;
&#13;
<p>Take a look at the <a href="https://oreil.ly/pgX7J">online documentation</a> for the interface and you’ll <a data-primary="apply() method, IntFunction" data-type="indexterm" id="id2228"/>see it has one method, <code>apply()</code>, appropriately enough:</p>&#13;
&#13;
<pre class="jshell" data-type="programlisting">jshell&gt; inc.apply(7)&#13;
$16 ==&gt; 8</pre>&#13;
&#13;
<p>Another hooray! Our incrementor increments! The other interfaces have a similar method defined.</p>&#13;
&#13;
<p>The shapes that we mentioned cover the different arrangements of the arguments and results of lambda expressions. If we wanted to work with <code>double</code> values instead of <code>int</code>s, for example, we could use the <code>DoubleFunction</code> interface. If we want to supply an object as an argument but don’t need to return a value, we could use the <code>Consumer&lt;T&gt;</code> interface. (Since <code>Consumer</code> works on reference types, it is parameterized. If we really did want to store a lambda that accepted a string, we would use the type <code>Consumer&lt;String&gt;</code>.) Or maybe we have a lambda that takes no arguments but generates a <code>long</code> value: the <code>LongSupplier</code> interface will do the trick. We won’t reproduce the full list of functional interfaces here, but it’s worth looking at the <a href="https://oreil.ly/ksK1Z">package summary</a> online.</p>&#13;
&#13;
<p>As you <a data-primary="abstract methods" data-type="indexterm" id="id2229"/><a data-primary="ActionListener interface" data-type="indexterm" id="id2230"/><a data-primary="actionPerformed() method, ActionListener" data-type="indexterm" id="id2231"/><a data-primary="SAM (single abstract method)" data-type="indexterm" id="id2232"/><a data-primary="single abstract method (SAM)" data-type="indexterm" id="id2233"/>find more situations where you can use lambdas, you’ll see how all these different shapes get used. But it’s important to point out that the term <em>functional interface</em> can apply to any interface that has a single abstract method (often abbreviated as SAM in the documentation). In <a data-type="xref" href="ch12.html#learnjava6-CHP-12">Chapter 12</a>, for example, we’ll use lambdas to handle user interface events like clicking a button. Button events are reported to &#13;
<span class="keep-together"><code>ActionListener</code>s</span>. The <code>ActionListener</code> interface has one abstract method, <code>actionPerformed()</code>, so it qualifies as a functional interface, even though it was part of Java long before these functional features were added.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Method References" data-type="sect2"><div class="sect2" id="learnjava6-CHP-11-SECT-2.3">&#13;
<h2>Method References</h2>&#13;
&#13;
<p>One other <a data-primary="functional programming (FP) with Java" data-secondary="method references" data-type="indexterm" id="id2234"/><a data-primary="lambda expressions (lambdas)" data-secondary="method references" data-type="indexterm" id="id2235"/><a data-primary="method reference, functional approach" data-type="indexterm" id="id2236"/><a data-primary="references" data-secondary="method" data-type="indexterm" id="id2237"/>feature is associated with Java’s functional approach: a <em>method reference</em>. Sometimes your lambda expressions are really just wrappers for other methods. Consider the very popular task of printing out the contents of a collection. We could use the <code>forEach()</code> method we just learned about and print the elements of a list using a lambda:</p>&#13;
&#13;
<pre class="jshell" data-type="programlisting">jshell&gt; List&lt;String&gt; names = new ArrayList&lt;&gt;()&#13;
names ==&gt; []&#13;
jshell&gt; names.add("Kermit");&#13;
$3 ==&gt; true&#13;
jshell&gt; names.add("Fozzie");&#13;
$4 ==&gt; true&#13;
jshell&gt; names.add("Gonzo");&#13;
$5 ==&gt; true&#13;
jshell&gt; names.add("Piggy");&#13;
$6 ==&gt; true&#13;
&#13;
jshell&gt; names.forEach(n -&gt; System.out.println(n))&#13;
Kermit&#13;
Fozzie&#13;
Gonzo&#13;
Piggy</pre>&#13;
&#13;
<p>You can see that our lambda expression simply shuttles each string to the &#13;
<span class="keep-together"><code>System.out.println()</code></span> method. This is just the right candidate for a method &#13;
<span class="keep-together">reference</span>.</p>&#13;
&#13;
<p>We specify such a reference with a double-colon operator separating the method from its object (or its class, in the case of a <code>static</code> method):</p>&#13;
&#13;
<pre class="jshell" data-type="programlisting">jshell&gt; names.forEach(System.out::println)&#13;
Kermit&#13;
Fozzie&#13;
Gonzo&#13;
Piggy</pre>&#13;
&#13;
<p>Very compact and still readable. Method references only work in a narrow set of circumstances, but they are popular options wherever they’re allowed. As with lambda expressions in general, there is no real performance benefit versus using a lambda. Indeed, the Java compiler creates a lambda expression out of our method reference behind the scenes:</p>&#13;
&#13;
<pre class="jshell" data-type="programlisting">jshell&gt; Consumer&lt;String&gt; printer = System.out::println&#13;
printer ==&gt; $Lambda$27/0x0000000840087440@63c12fb0</pre>&#13;
&#13;
<p>Feel free to use method references where they fit, but it’s also fine to stick with an explicit lambda expression if you find it easier to read.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Practical Lambdas: Sorting" data-type="sect2"><div class="sect2" id="learnjava6-CHP-11-SECT-2.4">&#13;
<h2>Practical Lambdas: Sorting</h2>&#13;
&#13;
<p>Gosh, that was a lot of <a data-primary="lambda expressions (lambdas)" data-secondary="sorting a list with" data-type="indexterm" id="id2238"/>theory! It’s time to put these lambda expressions to use in some code you often find in real applications: sorting data. Sorting is a common task; we talked about it in <a data-type="xref" href="ch07.html#learnjava6-CHP-7-SECT-7">“A Closer Look: The sort() Method”</a> while discussing collections. Where do lambdas fit in?</p>&#13;
&#13;
<p>To put any list in order, you <a data-primary="Comparable interface" data-type="indexterm" id="id2239"/>need a way of comparing two elements in the list so you know which one should come before the other. Some lists—say a list of employee salaries or a list of file and subfolder names in a given directory—have a fairly natural ordering that suffices in most cases. But sometimes you need a more complex ordering, like sorting the subfolders to the top before the files. You could implement the <code>Comparable</code> interface like you did before, or create a custom class that implements the closely related <code>Comparator</code> interface, but you could also supply a lambda.</p>&#13;
&#13;
<p>For a <a data-primary="Comparator class" data-type="indexterm" id="id2240"/><a data-primary="compare() method, Comparator" data-type="indexterm" id="id2241"/>lambda expression to help with sorting, it needs to behave like the <code>compare()</code> method of <code>Comparator</code>. We need an expression that takes two arguments, say <code>a</code> and <code>b</code>, and returns one of three <code>int</code> values:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Something less than zero if <code>a &lt; b</code></p>&#13;
</li>&#13;
<li>&#13;
<p>Something greater than zero if <code>a &gt; b</code></p>&#13;
</li>&#13;
<li>&#13;
<p>Zero if <code>a == b</code></p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>The magic of <a data-primary="java.util package" data-secondary="Collections class" data-type="indexterm" id="id2242"/><a data-primary="sort() method, Collections" data-type="indexterm" id="id2243"/>lambdas allows us to decide <em>how</em> we organize a list in a dynamic way. The <code>java.util.Collections</code> helper class contains a <code>sort()</code> method that accepts a collection to sort, along with a comparator to provide the ordering. We can use a lambda to do that comparing. For example, we could create a simple lambda to sort our <code>names</code> list in alphabetical order:</p>&#13;
&#13;
<pre class="jshell" data-type="programlisting">jshell&gt; Collections.sort(names, (a, b) -&gt; a.compareTo(b))&#13;
&#13;
jshell&gt; names&#13;
names ==&gt; [Fozzie, Gonzo, Kermit, Piggy]</pre>&#13;
&#13;
<p>Arranged as expected, although we could have used any of Java’s sorting tricks to get this default ordering. Let’s reverse the ordering:</p>&#13;
&#13;
<pre class="jshell" data-type="programlisting">jshell&gt; Collections.sort(names, (a, b) -&gt; b.compareTo(a))&#13;
&#13;
jshell&gt; names&#13;
names ==&gt; [Piggy, Kermit, Gonzo, Fozzie]</pre>&#13;
&#13;
<p>Neat! <a data-primary="compareTo() method" data-secondary="Collections" data-type="indexterm" id="id2244"/>All we had to do was swap the order of the arguments using the <code>compareTo()</code> method.</p>&#13;
&#13;
<p>Lambdas can do more, of course, especially when you need to order something a little more complex than a list of names. Imagine taking the trees in our apple tossing game and sorting them by their distance from the origin, <code>(0,0)</code>, using a slightly more interesting lambda:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="n">Collections</code><code class="p">.</code><code class="na">sort</code><code class="p">(</code><code class="n">trees</code><code class="p">,</code><code class="w"> </code><code class="p">(</code><code class="n">t1</code><code class="p">,</code><code class="w"> </code><code class="n">t2</code><code class="p">)</code><code class="w"> </code><code class="o">-&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">var</code><code class="w"> </code><code class="n">t1x</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">t1</code><code class="p">.</code><code class="na">getPositionX</code><code class="p">();</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">var</code><code class="w"> </code><code class="n">t1y</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">t1</code><code class="p">.</code><code class="na">getPositionY</code><code class="p">();</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">var</code><code class="w"> </code><code class="n">t2x</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">t2</code><code class="p">.</code><code class="na">getPositionX</code><code class="p">();</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">var</code><code class="w"> </code><code class="n">t2y</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">t2</code><code class="p">.</code><code class="na">getPositionY</code><code class="p">();</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">var</code><code class="w"> </code><code class="n">dist1</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Math</code><code class="p">.</code><code class="na">sqrt</code><code class="p">(</code><code class="n">t1x</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="n">t1x</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">t1y</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="n">t1Y</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">var</code><code class="w"> </code><code class="n">dist2</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Math</code><code class="p">.</code><code class="na">sqrt</code><code class="p">(</code><code class="n">t2x</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="n">t2x</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">t2y</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="n">t2y</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="n">dist1</code><code class="w"> </code><code class="o">-</code><code class="w"> </code><code class="n">dist2</code><code class="p">;</code><code class="w"/>&#13;
<code class="p">});</code><code class="w"/></pre>&#13;
&#13;
<p>We made this expression body more verbose than necessary to emphasize that lambdas can have many lines of code. This lambda probably strains readability, but it also highlights a handy side effect of such expressions: you get to see the code being used to sort right where the sorting is done. This self-documenting feature is another reason FP has so many proponents.<a data-primary="" data-startref="ix_func_prog_lambda" data-type="indexterm" id="id2245"/><a data-primary="" data-startref="ix_lambda_exp" data-type="indexterm" id="id2246"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Streams" data-type="sect1"><div class="sect1" id="learnjava6-CHP-11-SECT-3">&#13;
<h1>Streams</h1>&#13;
&#13;
<p>As we’ve noted before, <a data-primary="java.util.stream package" data-type="indexterm" id="ix_java_util_str_pkg"/><a data-primary="functional programming (FP) with Java" data-secondary="streams" data-type="indexterm" id="ix_func_prog_stream"/><a data-primary="lambda expressions (lambdas)" data-secondary="and streams" data-secondary-sortas="streams" data-type="indexterm" id="ix_lambda_stream"/>lambda expressions don’t do anything that you couldn’t accomplish using other features of Java, but they provide a different way to think about problems. In that same vein, the <a data-primary="Java Streams API" data-seealso="java.util.stream package" data-type="indexterm" id="id2247"/>Java Streams API (not to be confused with all of the various “Stream” classes, like <code>PrintStream</code> in the <code>java.io</code> package) provides a different way to think about data.</p>&#13;
&#13;
<p>You can get a <a data-primary="operations, stream" data-type="indexterm" id="id2248"/><a data-primary="stream() method, Collection" data-type="indexterm" id="id2249"/>stream from one of the classes in the <code>java.util.stream</code> package or by using the <code>stream()</code> method of a collection. A stream provides a steady flow of objects, and you perform <em>operations</em> on each object as you encounter it. Operations can filter out unwanted objects, count them, or even alter them before passing them along. In situations where you have very large amounts of data, streams offer a concise way to process all of that data. As a programmer, you can concentrate on how you handle a single object and let the stream do the work of getting those single objects ready for you.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Sources and Operations" data-type="sect2"><div class="sect2" id="learnjava6-CHP-11-SECT-3.1">&#13;
<h2>Sources and Operations</h2>&#13;
&#13;
<p>To try out <a data-primary="java.util.stream package" data-secondary="sources and operations" data-type="indexterm" id="ix_java_util_str"/><a data-primary="Stream.of() method" data-type="indexterm" id="id2250"/><a data-primary="Collection interface" data-type="indexterm" id="id2251"/>streams, we’ll need a source of data. An easy start is using the <code>stream()</code> method on any class implementing the <code>Collection</code> interface or one of its descendants. (Arrays don’t have a built-in stream option, but you can create one easily enough with the <code>Stream.of()</code> static method.)</p>&#13;
&#13;
<p>Once we have a <a data-primary="count() operation" data-type="indexterm" id="id2252"/>stream going, we can operate on it. We’ll look at many more operations next, but a popular and simple starting point is the <code>count()</code> operation. Not surprisingly, this operation counts each element of the stream as it goes by and produces a single result. For example, we can use our <code>names</code> list in <em>jshell</em> and find out how many friends are in our list:</p>&#13;
&#13;
<pre class="jshell" data-type="programlisting">jshell&gt; names&#13;
names ==&gt; [Fozzie, Gonzo, Kermit, Piggy]&#13;
&#13;
jshell&gt; names.stream().count()&#13;
$24 ==&gt; 4</pre>&#13;
&#13;
<p>Admittedly, this example doesn’t do anything amazing, but we’ll build up to more complex operations. The important thing to note is the way we attach an operation to our stream. The <code>stream()</code> returns a stream object, and we use the dot operator (<code>.</code>) immediately to get our count.</p>&#13;
&#13;
<p>We could use another operation to print out our names:</p>&#13;
&#13;
<pre class="jshell" data-type="programlisting">jshell&gt; names.stream().forEach(System.out::println)&#13;
Fozzie&#13;
Gonzo&#13;
Kermit&#13;
Piggy</pre>&#13;
&#13;
<p>We supplied a <a data-primary="forEach() method" data-secondary="Collection" data-type="indexterm" id="id2253"/>method reference to the <code>forEach()</code> operation, but you can also provide a lambda that takes one argument (the current name from the stream) and does not return a value.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Stream reuse" data-type="sect3"><div class="sect3" id="learnjava6-CHP-11-SECT-3.1.1">&#13;
<h3>Stream reuse</h3>&#13;
&#13;
<p>You may have <a data-primary="java.util.stream package" data-secondary="reusing" data-type="indexterm" id="id2254"/>noticed that we did not store our stream in a variable for reuse between our <code>count()</code> example and the similar <code>forEach()</code> example. Streams are one-way and single use. You can actually store a stream in a variable, but if you try to reuse the stream after you have processed it, you’ll get an error:</p>&#13;
&#13;
<pre class="jshell" data-type="programlisting">jshell&gt; Stream&lt;String&gt; nameStream = names.stream()&#13;
nameStream ==&gt; java.util.stream.ReferencePipeline$Head@621be5d1&#13;
&#13;
jshell&gt; nameStream.count()&#13;
$27 ==&gt; 4&#13;
&#13;
jshell&gt; nameStream.forEach(System.out::println)&#13;
|  Exception java.lang.IllegalStateException: stream has&#13;
|     already been operated upon or closed&#13;
|        at AbstractPipeline.sourceStageSpliterator&#13;
|           (AbstractPipeline.java:279)&#13;
|        at ReferencePipeline$Head.forEach&#13;
|           (ReferencePipeline.java:658)&#13;
|        at (#28:1)</pre>&#13;
&#13;
<p>We created a parameterized <code>Stream</code> object for our stream of <code>String</code> objects. We successfully started the stream and used the <code>count()</code> operation, but we failed to use that same stream for our <code>forEach()</code> operation. Processing a stream does not alter the original source, so you can safely start a new stream as often as needed. But once a stream has ended, it cannot be restarted.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Stream generators" data-type="sect3"><div class="sect3" id="learnjava6-CHP-11-SECT-3.1.2">&#13;
<h3>Stream generators</h3>&#13;
&#13;
<p>Another source of <a data-primary="java.util.stream package" data-secondary="generators" data-type="indexterm" id="id2255"/><a data-primary="generator, stream" data-type="indexterm" id="id2256"/>stream data is a <em>generator</em>. Generators create data according to some rule. Some generators produce a fixed value over and over, while others produce random content. You can generate simple things like numbers or complex things like objects. If getting real data is an expensive operation, you can use generators to more easily test your stream logic. Similarly, you can use a generator to create good (or quirky, or error-filled) data to test other parts of your application.</p>&#13;
&#13;
<p>The <code>Stream.generate()</code> method takes an <a data-primary="get() method" data-secondary="Stream" data-type="indexterm" id="id2257"/><a data-primary="generate() method, Stream" data-type="indexterm" id="id2258"/><a data-primary="Supplier interface" data-type="indexterm" id="id2259"/>instance of the <code>Supplier</code> interface. A supplier has one job: to supply an infinite stream of elements. It has one method: <code>get()</code>, which returns an element of the appropriate type. And the element’s type is really the only restriction that Java places on your generator. Let’s try generating something simple: a steady stream of the number 42:</p>&#13;
&#13;
<pre class="jshell" data-type="programlisting">jshell&gt; Stream.generate(() -&gt; 42).limit(3).forEach(System.out::println)&#13;
42&#13;
42&#13;
42</pre>&#13;
&#13;
<p>Our <code>Supplier</code> in this case is the very simple lambda, <code>() → 42</code>. There are no arguments, and every time the lambda expression is used or evaluated, the result is 42. <a data-primary="limit() method" data-secondary="Stream" data-type="indexterm" id="id2260"/>Notice that we follow our <code>generate()</code> method with a new method, <code>limit()</code>, that sits between the generator and our <code>println()</code> step. On their own, generators generate forever. We’ll discuss <code>limit()</code> and other related methods in the next section, but we need something in the short term to rein in our generators. If you don’t believe us, try removing that piece. Just be ready to hit Ctrl-C quickly (and repeatedly) to stop the onslaught of infinite 42s!</p>&#13;
&#13;
<p>We can <a data-primary="Random class" data-type="indexterm" id="id2261"/>implement the <code>Supplier</code> interface (or any of its base-type cousins such as <code>IntSupplier</code>) in a class when we need a more interesting set of generated data. Consider a stream of random day names. We need a random number generator and a list of valid days. Those requirements would probably make for a messy inline lambda, but they’re trivial in a small class:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kn">import</code><code class="w"> </code><code class="nn">java.util.Random</code><code class="p">;</code><code class="w"/>&#13;
<code class="kn">import</code><code class="w"> </code><code class="nn">java.util.stream.Stream</code><code class="p">;</code><code class="w"/>&#13;
<code class="kn">import</code><code class="w"> </code><code class="nn">java.util.function.Supplier</code><code class="p">;</code><code class="w"/>&#13;
&#13;
<code class="kd">public</code><code class="w"> </code><code class="kd">class</code> <code class="nc">WeekDayGenerator</code><code class="w"> </code><code class="kd">implements</code><code class="w"> </code><code class="n">Supplier</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">private</code><code class="w"> </code><code class="kd">static</code><code class="w"> </code><code class="n">String</code><code class="o">[]</code><code class="w"> </code><code class="n">days</code><code class="w"> </code><code class="o">=</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">{</code><code class="w"> </code><code class="s">"Sun"</code><code class="p">,</code><code class="w"> </code><code class="s">"Mon"</code><code class="p">,</code><code class="w"> </code><code class="s">"Tue"</code><code class="p">,</code><code class="w"> </code><code class="s">"Wed"</code><code class="p">,</code><code class="w"> </code><code class="s">"Thu"</code><code class="p">,</code><code class="w"> </code><code class="s">"Fri"</code><code class="p">,</code><code class="w"> </code><code class="s">"Sat"</code><code class="w"> </code><code class="p">};</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">private</code><code class="w"> </code><code class="n">Random</code><code class="w"> </code><code class="n">randSrc</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">Random</code><code class="p">();</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="kd">public</code><code class="w"> </code><code class="n">String</code><code class="w"> </code><code class="nf">get</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="n">days</code><code class="o">[</code><code class="n">randSrc</code><code class="p">.</code><code class="na">nextInt</code><code class="p">(</code><code class="n">days</code><code class="p">.</code><code class="na">length</code><code class="p">)</code><code class="o">]</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">}</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="kd">public</code><code class="w"> </code><code class="kd">static</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">main</code><code class="p">(</code><code class="n">String</code><code class="w"> </code><code class="n">args</code><code class="o">[]</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">Stream</code><code class="p">.</code><code class="na">generate</code><code class="p">(</code><code class="k">new</code><code class="w"> </code><code class="n">WeekDayGenerator</code><code class="p">())</code><code class="w"/>&#13;
<code class="w">          </code><code class="p">.</code><code class="na">limit</code><code class="p">(</code><code class="mi">5</code><code class="p">)</code><code class="w"/>&#13;
<code class="w">          </code><code class="p">.</code><code class="na">forEach</code><code class="p">(</code><code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">::</code><code class="n">println</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">}</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>The <code>main()</code> method here isn’t necessary, but it makes it easy to test. Just compile and run the class from the <em>ch11/examples</em> folder. You should see five random days of the week:</p>&#13;
&#13;
<pre data-type="programlisting">% cd ch11/examples&#13;
% javac WeekDayGenerator.java&#13;
% java WeekDayGenerator&#13;
Sun&#13;
Thu&#13;
Fri&#13;
Sun&#13;
Mon</pre>&#13;
&#13;
<p>Try running it a few times just to confirm that the random feature is working. Your generating class can be as rich as necessary. You just need to make sure <code>get()</code> returns an appropriate object or value: notice we implemented a parameterized version of our interface: <code>Suppler&lt;String&gt;</code>, and our <code>get()</code> method returns <code>String</code>. Now you’re good to go!</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Stream iterators" data-type="sect3"><div class="sect3" id="learnjava6-CHP-11-SECT-3.1.3">&#13;
<h3>Stream iterators</h3>&#13;
&#13;
<p>In addition to <a data-primary="java.util.stream package" data-secondary="iterators" data-type="indexterm" id="id2262"/>generators, streams can be built from iterators. These iterators aren’t quite the same as the iterators you use to walk through a collection, but the idea is similar. <em>Stream iterators</em> have the same notion of a “next” value as collection iterators, but for streams, that next value comes from performing a calculation on the previous value. If you need a range of sequential numbers, for example, an iterator is ideal:</p>&#13;
&#13;
<pre class="jshell" data-type="programlisting">jshell&gt; IntStream.iterate(1, i -&gt; i + 1).limit(5).forEach(System.out::println)&#13;
1&#13;
2&#13;
3&#13;
4&#13;
5</pre>&#13;
&#13;
<p>The <code>iterate()</code> source <a data-primary="iterate() source method" data-type="indexterm" id="id2263"/>method takes two arguments: a starting value and a lambda expression. The lambda takes one argument and uses it to create the next element. That second element will be put back through the same lambda expression to create the third, and so on. We certainly could have done that with a custom <code>Supplier</code>, but for many sequences, iterators offer a simpler entry point. And you aren’t restricted to iterating on numbers—you can iterate on any object type that suits your needs. As long as you have a way to calculate the next object for the stream, you can use an iterator as a source. Let’s try creating a sequence of <code>LocalDate</code> objects as an example:</p>&#13;
&#13;
<pre class="jshell" data-type="programlisting">jshell&gt; import java.time.LocalDate&#13;
&#13;
jshell&gt; import java.time.temporal.ChronoUnit&#13;
&#13;
jshell&gt; Stream.iterate(LocalDate.now(),&#13;
   ...&gt;   d -&gt; d.plus(1, ChronoUnit.DAYS)).limit(5).forEach(System.out::println)&#13;
2023-02-10&#13;
2023-02-11&#13;
2023-02-12&#13;
2023-02-13&#13;
2023-02-14</pre>&#13;
&#13;
<p>We use the <code>LocalDate.now()</code> static method to get the current date for our starting value. The iterating expression takes a <code>LocalDate</code> object as input, uses the <code>plus()</code> method to add one day, and returns the new <code>LocalDate</code>. (And we end on such a lovely date.)<a data-primary="" data-startref="ix_java_util_str" data-type="indexterm" id="id2264"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Filtering Streams" data-type="sect2"><div class="sect2" id="learnjava6-CHP-11-SECT-3.2">&#13;
<h2>Filtering Streams</h2>&#13;
&#13;
<p>Both the <code>count()</code> and the <code>forEach()</code> <a data-primary="filtering, streams" data-type="indexterm" id="id2265"/><a data-primary="limit() method" data-secondary="java.util.stream" data-type="indexterm" id="id2266"/><a data-primary="java.util.stream package" data-secondary="filtering" data-type="indexterm" id="id2267"/><a data-primary="terminal operations" data-type="indexterm" id="id2268"/><a data-primary="intermediate operations" data-type="indexterm" id="id2269"/>operations in the previous snippets are examples of <em>terminal</em> operations. Terminal operations “terminate” a stream. You can have only one, final terminating operation when processing a stream. The <code>limit()</code> operation, in contrast, is an example of an <em>intermediate</em> operation. An intermediate operation may alter or remove some of the data in the stream, but the stream continues. Filtering is a popular type of intermediate operation, and limiting the number of elements that continue on down the stream is a form of filtering. But you can filter for all kinds of reasons. You can filter to select desirable data or to toss out undesirable data. You can filter out duplicates. You can input a stream of objects to your filter and have it output an essentially new stream for use by the next operation.</p>&#13;
&#13;
<p>As luck would have it, <a data-primary="Predicate interface" data-type="indexterm" id="id2270"/><a data-primary="java.util.function package" data-secondary="Predicate interface" data-type="indexterm" id="id2271"/>generic filters are just lambdas that return <code>boolean</code> values. This is the <code>Predicate</code> shape from the big list of functional interfaces in the <code>java.util.function</code> package. You send one argument in, and either <code>true</code> or <code>false</code> comes out. For example, we could use a filter to count the names that contain the letter “o” like so:</p>&#13;
&#13;
<pre class="jshell" data-type="programlisting">jshell&gt; names.stream().filter(n -&gt; n.indexOf("o") &gt; -1).count()&#13;
$30 ==&gt; 2</pre>&#13;
&#13;
<p>Our <a data-primary="indexOf() method" data-secondary="Predicate" data-type="indexterm" id="id2272"/>filtering lambda takes one name and uses the <code>indexOf()</code> operation to see if the name contains an “o”. Since <code>indexOf()</code> returns an <code>int</code> value, we compare it to an impossible index, -1, to create the required <code>boolean</code> result. If the predicate returns <code>true</code>, that name will be passed along. If the predicate returns <code>false</code>, the name is simply dropped from the stream.</p>&#13;
&#13;
<p>The important detail again is the “in the middle” nature of a filter. We can keep doing things with our stream. It’s common to stack multiple filters, for example. Each filter selects different desired elements (or removes unwanted elements, depending on how you look at it). <a data-primary="distinct() method, Stream" data-type="indexterm" id="id2273"/>Another popular built-in filter is the <code>distinct()</code> operation that weeds out duplicates. Let’s add some repeated names to our list and try using two intermediate operations:</p>&#13;
&#13;
<pre class="jshell" data-type="programlisting">jshell&gt; names.add("Gonzo")&#13;
$32 ==&gt; true&#13;
&#13;
jshell&gt; names&#13;
names ==&gt; [Fozzie, Gonzo, Kermit, Piggy, Gonzo]&#13;
&#13;
jshell&gt; names.stream().&#13;
   ...&gt; filter(n -&gt; n.indexOf("o") &gt; -1).count()&#13;
$34 ==&gt; 3&#13;
&#13;
jshell&gt; names.stream().&#13;
   ...&gt; filter(n -&gt; n.indexOf("o") &gt; -1).&#13;
   ...&gt; distinct().count()&#13;
$35 ==&gt; 2</pre>&#13;
&#13;
<p>You can stack as many filters as you need, although it’s still important to keep your code readable. (If you have a gauntlet of 20 filters, you may want to reconsider how you process the source for the stream.) But you can do more than simply filter the elements in your stream: you can turn them into something else!</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Mapping Streams" data-type="sect2"><div class="sect2" id="learnjava6-CHP-11-SECT-3.3">&#13;
<h2>Mapping Streams</h2>&#13;
&#13;
<p>In <a data-primary="mapping streams" data-type="indexterm" id="ix_map_str"/><a data-primary="java.util.stream package" data-secondary="mapping streams" data-type="indexterm" id="ix_java_stream_map"/>streams, <em>mapping</em> is the process of altering an element in a stream before passing it along. Like filtering, you use a lambda expression to perform the alteration. You can map simple changes, like adding sales tax to a stream of prices, or you can create complex maps that convert one type of object into a wholly different type. Or you can do both! Mapping is also an intermediate operation, so you can stack map operations just as you did with filters. Indeed, you will see many examples online of programmers mixing maps and filters to achieve their final result.</p>&#13;
&#13;
<p>Let’s <a data-primary="map() method, Stream" data-type="indexterm" id="id2274"/>start by trying the task of adding sales tax. We’ll start with a short list of <code>double</code> values and a 5% tax. We can <code>map()</code> the tax onto the prices like so:</p>&#13;
&#13;
<pre class="jshell" data-type="programlisting">jshell&gt; double[] prices = { 5.99, 9.99, 20.0, 8.5};&#13;
prices ==&gt; double[4] { 5.99, 9.99, 20.0, 8.5 }&#13;
&#13;
jshell&gt; DoubleStream.of(prices).forEach(System.out::println)&#13;
5.99&#13;
9.99&#13;
20.0&#13;
8.5&#13;
&#13;
jshell&gt; DoubleStream.of(prices).map(p -&gt; p*1.05).&#13;
   ...&gt;   forEach(System.out::println)&#13;
6.2895&#13;
10.489500000000001&#13;
21.0&#13;
8.925</pre>&#13;
&#13;
<p>The formatting of our prices isn’t very polished, but the tax has been correctly applied. While we have them handy, we can try out another useful terminal operation, <code>sum()</code>, to add up all the prices:</p>&#13;
&#13;
<pre class="jshell" data-type="programlisting">jshell&gt; DoubleStream.of(prices).map(p -&gt; p*1.05).sum()&#13;
$7 ==&gt; 46.70400000000001</pre>&#13;
&#13;
<p>Again, the output isn’t nicely formatted, but we summed up an entire array of numbers in one line!</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Mapping object attributes" data-type="sect3"><div class="sect3" id="learnjava6-CHP-11-SECT-3.3.1">&#13;
<h3>Mapping object attributes</h3>&#13;
&#13;
<p>You can also use <a data-primary="attributes" data-secondary="mapping object" data-type="indexterm" id="id2275"/>maps to peer inside objects. Let’s create a simplified variation of our <code>Employee</code> class from <a data-type="xref" href="ch07.html#learnjava6-CHP-7">Chapter 7</a> with an additional <code>salary</code> attribute. We’ll call this version a <code>PaidEmployee</code>:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code><code class="w"> </code><code class="kd">class</code> <code class="nc">PaidEmployee</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">private</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="n">id</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">private</code><code class="w"> </code><code class="n">String</code><code class="w"> </code><code class="n">name</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">private</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="n">salary</code><code class="p">;</code><code class="w"> </code><code class="c1">// annual, in whole dollars</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="kd">public</code><code class="w"> </code><code class="nf">PaidEmployee</code><code class="p">(</code><code class="n">String</code><code class="w"> </code><code class="n">fullname</code><code class="p">,</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="n">id</code><code class="p">,</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="n">salary</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="k">this</code><code class="p">.</code><code class="na">name</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">fullname</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">    </code><code class="k">this</code><code class="p">.</code><code class="na">id</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">id</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">    </code><code class="k">this</code><code class="p">.</code><code class="na">salary</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">salary</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">}</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="kd">public</code><code class="w"> </code><code class="n">String</code><code class="w"> </code><code class="nf">getName</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="n">name</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">public</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="nf">getID</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="n">id</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">public</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="nf">getSalary</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="n">salary</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>In a stream of employees, we can now use <code>map()</code> to extract specific attributes, like their names. Let’s write a test class that creates a few example employee objects and then uses a stream to process the employees:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kn">import</code><code class="w"> </code><code class="nn">java.util.*</code><code class="p">;</code><code class="w"/>&#13;
&#13;
<code class="kd">public</code><code class="w"> </code><code class="kd">class</code> <code class="nc">Report</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="n">List</code><code class="o">&lt;</code><code class="n">PaidEmployee</code><code class="o">&gt;</code><code class="w"> </code><code class="n">employees</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">ArrayList</code><code class="o">&lt;&gt;</code><code class="p">();</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="kt">void</code><code class="w"> </code><code class="nf">buildEmployeeList</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">employees</code><code class="p">.</code><code class="na">add</code><code class="p">(</code><code class="k">new</code><code class="w"> </code><code class="n">PaidEmployee</code><code class="p">(</code><code class="s">"Fozzie"</code><code class="p">,</code><code class="w"> </code><code class="mi">4</code><code class="p">,</code><code class="w"> </code><code class="mi">30_000</code><code class="p">));</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">employees</code><code class="p">.</code><code class="na">add</code><code class="p">(</code><code class="k">new</code><code class="w"> </code><code class="n">PaidEmployee</code><code class="p">(</code><code class="s">"Gonzo"</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="mi">50_000</code><code class="p">));</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">employees</code><code class="p">.</code><code class="na">add</code><code class="p">(</code><code class="k">new</code><code class="w"> </code><code class="n">PaidEmployee</code><code class="p">(</code><code class="s">"Kermit"</code><code class="p">,</code><code class="w"> </code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">60_000</code><code class="p">));</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">employees</code><code class="p">.</code><code class="na">add</code><code class="p">(</code><code class="k">new</code><code class="w"> </code><code class="n">PaidEmployee</code><code class="p">(</code><code class="s">"Piggy"</code><code class="p">,</code><code class="w"> </code><code class="mi">3</code><code class="p">,</code><code class="w"> </code><code class="mi">80_000</code><code class="p">));</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">}</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="kd">public</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">publishNames</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">employees</code><code class="p">.</code><code class="na">stream</code><code class="p">().</code><code class="na">map</code><code class="p">(</code><code class="n">e</code><code class="w"> </code><code class="o">-&gt;</code><code class="w"> </code><code class="n">e</code><code class="p">.</code><code class="na">getName</code><code class="p">()).</code><code class="na">forEach</code><code class="p">(</code><code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">::</code><code class="n">println</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">}</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="kd">public</code><code class="w"> </code><code class="kd">static</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">main</code><code class="p">(</code><code class="n">String</code><code class="w"> </code><code class="n">args</code><code class="o">[]</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">Report</code><code class="w"> </code><code class="n">r</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">Report</code><code class="p">();</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">r</code><code class="p">.</code><code class="na">buildEmployeeList</code><code class="p">();</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">r</code><code class="p">.</code><code class="na">publishNames</code><code class="p">();</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">}</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>The <code>publishNames()</code> method <a data-primary="map() method, Stream" data-type="indexterm" id="id2276"/>uses <code>map()</code> to take our <code>PaidEmployee</code> object and grab the employee’s name. That name (a simple <code>String</code> object) continues on down the stream. With the names available, we could add filters, like our “names with an o” filter from earlier examples, or watch out for duplicate employee records. Any time you need to massage your data, <code>map()</code> is the method to use.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Mapping conversions" data-type="sect3"><div class="sect3" id="learnjava6-CHP-11-SECT-3.3.2">&#13;
<h3>Mapping conversions</h3>&#13;
&#13;
<p>In the <a data-primary="conversions, mapping type" data-type="indexterm" id="id2277"/><a data-primary="reference (class) types" data-secondary="moving to/from base types" data-type="indexterm" id="id2278"/>previous example, we quietly converted our stream from one with &#13;
<span class="keep-together"><code>PaidEmployee</code></span> objects to one with <code>String</code> objects. Because both types are reference types, we don’t really have to worry about the fact that we have different before and after types. If you need to move from a reference type to a base type—or vice versa—you have to be a little more explicit about the conversion. This is definitely a common task, so Java supplies some handy variations of <code>map()</code> for just this purpose. Let’s get a sum of all our employees’ annual salaries to know what our wage budget should be:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">  </code><code class="kd">public</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">publishBudget</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="kt">int</code><code class="w"> </code><code class="n">b</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">employees</code><code class="p">.</code><code class="na">stream</code><code class="p">().</code><code class="na">mapToInt</code><code class="p">(</code><code class="n">e</code><code class="w"> </code><code class="o">-&gt;</code><code class="w"> </code><code class="n">e</code><code class="p">.</code><code class="na">getSalary</code><code class="p">()).</code><code class="na">sum</code><code class="p">();</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="s">"Annual budget is "</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">b</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p><a data-type="xref" href="#learnjava6-CHP-11-FIG-obj-to-int">Figure 11-2</a> illustrates the data moving through this budget-calculating stream.</p>&#13;
&#13;
<figure><div class="figure" id="learnjava6-CHP-11-FIG-obj-to-int">&#13;
<img alt="ljv6 1102" src="assets/ljv6_1102.png"/>&#13;
<h6><span class="label">Figure 11-2. </span>Converting between objects and ints in a stream</h6>&#13;
</div></figure>&#13;
&#13;
<p>Similar classes exist for moving to two other base types: <code>mapToDouble()</code> and <code>mapToLong()</code>. If you already have a stream of numbers and want to move to an object, the base type streams, like <code>IntStream</code>, all include the <code>mapToObj()</code> operation.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Flatmaps" data-type="sect2"><div class="sect2" id="learnjava6-CHP-11-SECT-3.4">&#13;
<h2>Flatmaps</h2>&#13;
&#13;
<p>We want to <a data-primary="java.util.stream package" data-secondary="flatmaps" data-type="indexterm" id="id2279"/><a data-primary="flatMap() method" data-type="indexterm" id="ix_flat_map"/><a data-primary="arrays" data-secondary="multidimensional" data-type="indexterm" id="id2280"/>introduce one other type of mapping operation commonly used with streams: the <em>flatmap</em>. The flatmap operation takes lumpy inputs and smooths them into a single (you might even say flat!) stream of elements. What do we mean by lumpy input? It’s mostly a cute way of saying multidimensional data. Consider the array-of-arrays chessboard we discussed in <a data-type="xref" href="ch04.html#learnjava6-CHP-4-SECT-6.5">“Multidimensional Arrays”</a>. We can play with a similar setup in <em>jshell</em> using simple <code>int</code> values. The “board” is an array of rows, where each row is an array of numbers. What happens if we try to start a stream from our two-dimensional array? Let’s try it out with a reduced 4 × 4 matrix:</p>&#13;
&#13;
<pre class="jshell" data-type="programlisting">jshell&gt; int[][] board = {&#13;
   ...&gt;   { 2, 0, 4, 2 },&#13;
   ...&gt;   { 0, 3, 0, 1 },&#13;
   ...&gt;   { 5, 0, 1, 0 },&#13;
   ...&gt;   { 2, 3, 0, 2 } }&#13;
board ==&gt; int[4][] { int[4] ... , int[4] { 2, 3, 4, 2 } }&#13;
&#13;
jshell&gt; Arrays.stream(board).forEach(System.out::println)&#13;
[I@5a10411&#13;
[I@2ef1e4fa&#13;
[I@306a30c7&#13;
[I@b81eda8</pre>&#13;
&#13;
<p>Hmm, that appears to be a stream of <code>int[]</code> objects, not individual integers. (Those ugly blobs are Java’s default way of printing objects that don’t have a pretty <code>toString()</code> method. The format is “object type @ memory address”.) What if we try to start a stream from the first row?</p>&#13;
&#13;
<pre class="jshell" data-type="programlisting">jshell&gt; Arrays.stream(board[0]).forEach(System.out::println)&#13;
2&#13;
3&#13;
4&#13;
2</pre>&#13;
&#13;
<p>That output looks better—it’s a list of our made-up chess piece values, but it’s only one row. We could put the stream in the middle of a <code>for</code> loop and process a separate stream for every row, but that seems cumbersome and would make any kind of counting or summing step much more difficult.</p>&#13;
&#13;
<p>For a nice, stream-friendly way to get all of our chess pieces into one stream, we’ll use <code>flatMap()</code>, or in our case of going from an object (each row is an array object) to a base type (each chess piece is an <code>int</code>), we’ll use <code>flatMapToInt()</code>:</p>&#13;
&#13;
<pre class="jshell" data-type="programlisting">jshell&gt; Arrays.stream(board).&#13;
   ...&gt;   flatMapToInt(r -&gt; Arrays.stream(r)).&#13;
   ...&gt;   forEach(System.out::println)&#13;
2&#13;
3&#13;
4&#13;
2&#13;
0&#13;
0&#13;
0&#13;
0&#13;
0&#13;
0&#13;
0&#13;
0&#13;
2&#13;
3&#13;
4&#13;
2</pre>&#13;
&#13;
<p>Hooray, it worked! We started with a stream of dense objects and broke up those dense objects into a single stream of smaller parts. You can use <code>flatMap()</code> and its base-type cousins to toss any tabular, cubic, or generic multidimensional data into a pleasant stream of individual elements.</p>&#13;
&#13;
<p>Let’s look at another example that combines several of the stream topics we’ve covered so far. A common task for system and network administrators is parsing log files. Web servers, for example, log each visitor’s Internet Protocol (IP) address and the resource they requested. Here’s a small example, with the long lines truncated for readability:</p>&#13;
&#13;
<pre data-type="programlisting">54.152.182.118 - - [20/Sep/2020:08:28:46 -0400] "GET / ...&#13;
107.150.59.82 - - [20/Sep/2020:09:33:02 -0400] "GET / ...&#13;
66.249.65.234 - - [20/Sep/2020:09:33:54 -0400] "GET /robots.txt ...&#13;
66.249.65.243 - - [20/Sep/2020:09:33:54 -0400] "GET /robots.txt ...</pre>&#13;
&#13;
<p>Each line contains lots of information: that IP address, the date and time of the request, what was requested, how it was requested, and (if you peek at the real log file in the <em>ch11/examples</em> folder) information about what browser or user agent made the request. Real-world log files can be huge, and admins usually keep them compressed on disk.</p>&#13;
&#13;
<p>Let’s use all our stream skills. We’ll start with a GZIP file and load its contents with some I/O streams, then break up the uncompressed data into lines. We can use <code>flatMap()</code> to turn the functional stream of lines into a stream of space-separated tokens. With our tokens in hand, we can finally get to the information we really want: a count of unique visitor IP addresses:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kn">import</code><code class="w"> </code><code class="nn">java.util.regex.Pattern</code><code class="p">;</code><code class="w"/>&#13;
<code class="kn">import</code><code class="w"> </code><code class="nn">java.util.stream.Stream</code><code class="p">;</code><code class="w"/>&#13;
<code class="kn">import</code><code class="w"> </code><code class="nn">java.util.zip.GZIPInputStream</code><code class="p">;</code><code class="w"/>&#13;
<code class="kn">import</code><code class="w"> </code><code class="nn">java.io.*</code><code class="p">;</code><code class="w"/>&#13;
&#13;
<code class="kd">public</code><code class="w"> </code><code class="kd">class</code> <code class="nc">UniqueIPs</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">public</code><code class="w"> </code><code class="kd">static</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">main</code><code class="p">(</code><code class="n">String</code><code class="w"> </code><code class="n">args</code><code class="o">[]</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">Pattern</code><code class="w"> </code><code class="n">separator</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Pattern</code><code class="p">.</code><code class="na">compile</code><code class="p">(</code><code class="s">"\\s+"</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">Pattern</code><code class="w"> </code><code class="n">ipAddress</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Pattern</code><code class="p">.</code><code class="na">compile</code><code class="p">(</code><code class="s">"\\d+\\.\\d+\\.\\d+\\.\\d+"</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="k">try</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="c1">// Open the file...</code><code class="w"/>&#13;
<code class="w">      </code><code class="n">FileInputStream</code><code class="w"> </code><code class="n">fis</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">FileInputStream</code><code class="p">(</code><code class="s">"sample-access.log.gz"</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">      </code><code class="c1">// Then decompress the file with a wrapper...</code><code class="w"/>&#13;
<code class="w">      </code><code class="n">GZIPInputStream</code><code class="w"> </code><code class="n">gis</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">GZIPInputStream</code><code class="p">(</code><code class="n">fis</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">      </code><code class="c1">// Then wrap the decompressed input in a reader</code><code class="w"/>&#13;
<code class="w">      </code><code class="n">InputStreamReader</code><code class="w"> </code><code class="n">ir</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">InputStreamReader</code><code class="p">(</code><code class="n">gis</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">      </code><code class="c1">// Then layer on a buffered reader...</code><code class="w"/>&#13;
<code class="w">      </code><code class="n">BufferedReader</code><code class="w"> </code><code class="n">br</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">BufferedReader</code><code class="p">(</code><code class="n">ir</code><code class="p">);</code><code class="w"/>&#13;
&#13;
<code class="w">      </code><code class="c1">// That finally gives us our stream!</code><code class="w"/>&#13;
<code class="w">      </code><code class="c1">// Now let's process that stream to get some interesting information</code><code class="w"/>&#13;
<code class="w">      </code><code class="kt">long</code><code class="w"> </code><code class="n">result</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">br</code><code class="p">.</code><code class="na">lines</code><code class="p">()</code><code class="w"/>&#13;
<code class="w">          </code><code class="p">.</code><code class="na">flatMap</code><code class="p">(</code><code class="n">ls</code><code class="w"> </code><code class="o">-&gt;</code><code class="w"> </code><code class="n">separator</code><code class="p">.</code><code class="na">splitAsStream</code><code class="p">(</code><code class="n">ls</code><code class="p">))</code><code class="w"/>&#13;
<code class="w">          </code><code class="p">.</code><code class="na">filter</code><code class="p">(</code><code class="n">word</code><code class="w"> </code><code class="o">-&gt;</code><code class="w"> </code><code class="n">ipAddress</code><code class="p">.</code><code class="na">matcher</code><code class="p">(</code><code class="n">word</code><code class="p">).</code><code class="na">matches</code><code class="p">())</code><code class="w"/>&#13;
<code class="w">          </code><code class="p">.</code><code class="na">distinct</code><code class="p">()</code><code class="w"/>&#13;
<code class="w">          </code><code class="p">.</code><code class="na">count</code><code class="p">();</code><code class="w"/>&#13;
<code class="w">      </code><code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="s">"Found "</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">result</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="s">" unique IPs."</code><code class="p">);</code><code class="w"/>&#13;
&#13;
<code class="w">    </code><code class="p">}</code><code class="w"> </code><code class="k">catch</code><code class="w"> </code><code class="p">(</code><code class="n">IOException</code><code class="w"> </code><code class="n">ioe</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="n">System</code><code class="p">.</code><code class="na">err</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="s">"Oh no! Something went wrong: "</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">ioe</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">}</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">}</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>Very nice. Once we have the stream of lines from our decompressed file, we can get our count using the functional approach to processing data with a compact, efficient, and readable list of steps. Again, you do not <em>have</em> to use functional streams and lambdas, but more and more programmers are looking into this way of solving problems—even in erstwhile object-oriented languages like Java.<a data-primary="" data-startref="ix_java_stream_map" data-type="indexterm" id="id2281"/><a data-primary="" data-startref="ix_map_str" data-type="indexterm" id="id2282"/><a data-primary="" data-startref="ix_flat_map" data-type="indexterm" id="id2283"/><a data-primary="" data-startref="ix_java_str_flat_map" data-type="indexterm" id="id2284"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Reducing and Collecting" data-type="sect2"><div class="sect2" id="learnjava6-CHP-11-SECT-3.5">&#13;
<h2>Reducing and Collecting</h2>&#13;
&#13;
<p>We’ve <a data-primary="java.util.stream package" data-secondary="reducing and collecting" data-type="indexterm" id="ix_java_stream_red_coll"/>looked at several examples using streams in this chapter. Each example has ended the stream with one of three terminal operations: a <code>forEach()</code> that we typically use to print the elements, a <code>count()</code> to know how many elements there are, or with <code>sum()</code> as a way to add up all of the numerical elements. Counting and summing are examples of <em>reducing</em> a stream. You “reduce” all the elements in your stream to a single answer.</p>&#13;
&#13;
<p>Streams in Java have several built-in reducers, as shown in <a data-type="xref" href="#learnjava6-CHP-11-TABLE-1">Table 11-1</a>.</p>&#13;
<table id="learnjava6-CHP-11-TABLE-1">&#13;
<caption><span class="label">Table 11-1. </span>Terminal reduction operations</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Operation</th>&#13;
<th>Description</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p><code>count()</code></p></td>&#13;
<td><p>Returns the number of elements in the stream</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>findAny()</code></p></td>&#13;
<td><p>Returns an element (if any exist) from the stream</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>findFirst()</code></p></td>&#13;
<td><p>Returns the first element (if it exists) from the stream</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>matchAll()</code></p></td>&#13;
<td><p>Returns <code>true</code> if all elements of the stream match the given criteria</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>matchAny()</code></p></td>&#13;
<td><p>Returns <code>true</code> if at least one element in the stream matches the given criteria</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>max()</code></p></td>&#13;
<td><p>Using a provided comparator, returns the “largest” element (if any)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>min()</code></p></td>&#13;
<td><p>Using a provided comparator, returns the “smallest” element (if any)</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>You might wonder why the <code>sum()</code> operation we’ve used a few times isn’t listed. It is definitely a reducer, but the built-in version is available only on the base-type streams: <code>IntStream</code>, <code>LongStream</code>, and <code>DoubleStream</code>.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Optional values" data-type="sect3"><div class="sect3" id="learnjava6-CHP-11-SECT-3.5.1">&#13;
<h3>Optional values</h3>&#13;
&#13;
<p>Before <a data-primary="empty stream challenge" data-type="indexterm" id="id2285"/>looking deeper at reducers (including how to create a custom reducer), we need to be prepared for a potentially dire outcome: an empty stream.</p>&#13;
&#13;
<p>Any time you filter a stream, it’s possible you won’t have anything left on the other side of the filter. As a quick example, what if the filter in our <code>names</code> example earlier had been looking for the letter “a” instead of “o”? None of our names contain an “a,” so the filter would end up dropping every name from our list. <a data-primary="findFirst() method, Optional" data-type="indexterm" id="id2286"/>The <code>count()</code> operation can handle that situation fine: it simply returns an answer of zero. But what if we had used <code>min()</code> or <code>findFirst()</code>? Those reducers expect to give you a matching element from your stream. If there are no elements left, what should a reducer return? It might be acceptable in some scenarios to return a <code>null</code> value, but if your stream ends with base-type elements, like <code>int</code> values, you can’t use <code>null</code>.</p>&#13;
&#13;
<p>Rather than <a data-primary="java.util package" data-secondary="Optional class" data-type="indexterm" id="id2287"/>force you to construct some strange rule or throw an exception, Java streams support the notion of an <em>optional</em> answer. These answers are wrapped in a class,  appropriately called <code>Optional</code>, from the <code>java.util</code> package. An <code>Optional</code> object has two key methods that we’ll work with in this section: <code>isPresent()</code> tells us whether a value exists or not, and <code>get()</code> returns that value. (If you call <code>get()</code> when no value is present, you’ll “get” a <code> NoSuchElementException</code>.)</p>&#13;
&#13;
<p>We can test this optional idea by revisiting our name filtering example. Rather than counting the results, though, we’ll use <code>findFirst()</code> to return the first matching name. Since there might not be any matches at all, we’ll get the result wrapped in an <code>Optional</code>. Feel free to reuse the <code>names</code> collection if it’s still in your <em>jshell</em>, but here’s a quick recap:</p>&#13;
&#13;
<pre class="jshell" data-type="programlisting">jshell&gt; List&lt;String&gt; names = new ArrayList&lt;&gt;()&#13;
names ==&gt; []&#13;
&#13;
jshell&gt; names.add("Kermit")&#13;
jshell&gt; names.add("Fozzie")&#13;
jshell&gt; names.add("Gonzo")&#13;
jshell&gt; names.add("Piggy")&#13;
&#13;
jshell&gt; names&#13;
names ==&gt; [Kermit, Fozzie, Gonzo, Piggy]</pre>&#13;
&#13;
<p>Now let’s run those names through a filter and look for the first match. We’ll try our filter with an “o” (which should have an answer) and then with an “a” (which should not have an answer). Notice how we use the <code>Optional</code> result:</p>&#13;
&#13;
<pre class="jshell" data-type="programlisting">jshell&gt; Optional matched = names.stream().&#13;
   ...&gt;   filter(n -&gt; n.indexOf("o") &gt; -1).findFirst()&#13;
matched ==&gt; Optional[Fozzie]&#13;
&#13;
jshell&gt; System.out.println(matched.isPresent() ?&#13;
   ...&gt;   matched.get() : "N/A")&#13;
Fozzie&#13;
&#13;
jshell&gt; Optional matched = names.stream().&#13;
   ...&gt;   filter(n -&gt; n.indexOf("a") &gt; -1).findFirst()&#13;
matched ==&gt; Optional.empty&#13;
&#13;
jshell&gt; System.out.println(matched.isPresent() ?&#13;
   ...&gt;   matched.get() : "N/A")&#13;
N/A</pre>&#13;
&#13;
<p>While it makes your code a little more verbose to test if your value <code>isPresent()</code>, <code>Optional</code> provides a clear interface for handling both the good and the “bad” outcomes of your stream processing. And as with so many other classes and methods in this functional arena, you can use the <code>OptionalInt</code>, <code>OptionalLong</code>, and <code>Optional</code>&#13;
<span class="keep-together"><code>Double</code></span> classes to catch potentially missing base-type results.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Creating a custom reducer" data-type="sect3"><div class="sect3" id="learnjava6-CHP-11-SECT-3.5.2">&#13;
<h3>Creating a custom reducer</h3>&#13;
&#13;
<p>What if the <a data-primary="reduce() operation" data-type="indexterm" id="id2288"/><a data-primary="java.util.function package" data-secondary="BinaryOperator" data-type="indexterm" id="id2289"/>built-in reducers don’t cover your needs? You may not be surprised to learn that you can supply a lambda to create a custom reducer. The <code>Stream</code> class includes a <code>reduce()</code> operation that accepts a lambda with the <code>BinaryOperator</code> shape from the <code>java.util.function</code> package we discussed in <a data-type="xref" href="#learnjava6-CHP-11-SECT-2.2">“Functional Interfaces”</a>. <code>BinaryOperator</code> accepts two arguments of the same type and returns a value (also of the same type). Depending on your needs, you can either use <code>reduce()</code> with just the binary operator lambda, or you can use a second form that also takes an initial value of the same type used by the binary operator. Let’s try out this second form to create a custom factorial reducer.</p>&#13;
&#13;
<p><em>Factorials</em> are big <a data-primary="factorials" data-type="indexterm" id="ix_factorial_ch11"/>numbers—or they can be, anyway. If the term doesn’t sound familiar, it’s similar to a summing operation, but instead of adding each number in the sequence, you multiply. You typically use the exclamation mark to indicate this operation: <code>5!</code> (pronounced “five factorial”) will multiply 5 and 4 making 20, then &#13;
<span class="keep-together">20 × 3</span> makes 60, then 60 × 2 makes 120, and finally 120 × 1 leaves 120. It may look simple enough, but factorial numbers get very big, very quickly:</p>&#13;
&#13;
<pre class="jshell" data-type="programlisting">jshell&gt; 5 * 4 * 3 * 2 * 1&#13;
$17 ==&gt; 120&#13;
&#13;
// we already know what 5! is, so reuse that value&#13;
jshell&gt; 10 * 9 * 8 * 7 * 6 * 120&#13;
$18 ==&gt; 3628800&#13;
&#13;
jshell&gt; 12 * 11 * 3628800&#13;
$19 ==&gt; 479001600</pre>&#13;
&#13;
<p>If you look carefully at the result of <code>12!</code>, you’ll notice it is just under half a billion, so it still fits within the (positive) range of values for the <code>int</code> type. But <code>13!</code> would be roughly 6.5 billion, so we can’t store that answer with <code>int</code>s. We could calculate it with <code>long</code>s, but even that type can’t hold anything after <code>20!</code>. Fortunately, Java is ready with some fun classes from <code>java.math</code>: <code>BigInteger</code> and <code>BigDecimal</code>. These classes can house arbitrarily large values, perfect for removing the limits of base types in our factorial work.</p>&#13;
&#13;
<p>We can use a simple iterator as our source, since multiplication doesn’t require a particular order of operations. Our factorial reducer will always produce an answer similar to <code>count()</code> or <code>sum()</code>,<sup><a data-type="noteref" href="ch11.html#id2290" id="id2290-marker">3</a></sup> so we’ll use the second form with a starting value of 1.  We can try this out in <em>jshell</em>:</p>&#13;
&#13;
<pre class="jshell" data-type="programlisting">// First make a quick alias for our "1" value&#13;
jshell&gt; one = BigInteger.ONE&#13;
one ==&gt; 1&#13;
&#13;
// Test with 12!&#13;
jshell&gt; Stream.iterate(one, count -&gt; count.add(one)).&#13;
   ...&gt;   limit(12).reduce(one, (a, b) -&gt; a.multiply(b))&#13;
$32 ==&gt; 479001600&#13;
&#13;
// It matches. Yay! Can we get 13!?&#13;
jshell&gt; Stream.iterate(one, count -&gt; count.add(one)).&#13;
   ...&gt;   limit(13).reduce(one, (a, b) -&gt; a.multiply(b))&#13;
$33 ==&gt; 6227020800&#13;
&#13;
// Hooray. Big test next, can we get 21!?&#13;
jshell&gt; Stream.iterate(one, count -&gt; count.add(one)).&#13;
   ...&gt;   limit(21).reduce(one, (a, b) -&gt; a.multiply(b))&#13;
$36 ==&gt; 51090942171709440000&#13;
&#13;
// Sure did! Now, just to be silly, try 99!&#13;
jshell&gt; Stream.iterate(one, count -&gt; count.add(one)).&#13;
   ...&gt;   limit(99).reduce(one, (a, b) -&gt; a.multiply(b))&#13;
$37 ==&gt; 933262154439441526816992388562667004907159682643&#13;
        816214685929638952175999932299156089414639761565&#13;
        182862536979208272237582511852109168640000000000&#13;
        000000000000</pre>&#13;
&#13;
<p>The output of <code>99!</code> is so large we had to arbitrarily chop it up to make it fit the printed edition of this book.<sup><a data-type="noteref" href="ch11.html#id2291" id="id2291-marker">4</a></sup> But our custom reducer worked!<a data-primary="" data-startref="ix_factorial_ch11" data-type="indexterm" id="id2292"/></p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>You can implement the <code>BinaryOperator</code> interface in a class if your reducing logic is too complex for the simple, inline lambda. Then you can supply an instance of that class to <code>reduce()</code> instead of the lambdas we used in our examples.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Collectors" data-type="sect3"><div class="sect3" id="learnjava6-CHP-11-SECT-3.5.3">&#13;
<h3>Collectors</h3>&#13;
&#13;
<p>The answers that reducers produce are often very useful. How many lines did you process? How many times did you see a particular word? What’s the average of some column in tabular data? But what if you want more than a single answer? When filtering, for example, you might want to keep all of the items from the stream that match, rather than counting or summing them.</p>&#13;
&#13;
<p>What if you want a new list of just the names containing the letter “o”? We can use a collector.</p>&#13;
&#13;
<p>The <code>java.util.stream.Collector</code> interface <a data-primary="Collector interface" data-type="indexterm" id="id2293"/><a data-primary="java.util.stream package" data-secondary="Collector interface" data-type="indexterm" id="id2294"/>allows for some impressive flexibility in how you collect and organize the results of processing your stream. We won’t be tackling custom collectors in this book, but happily, the related <code>Collectors</code> class includes several common collectors as static methods. For example, we can use one of those static methods to get that list of o-having names we were curious about:</p>&#13;
&#13;
<pre class="jshell" data-type="programlisting">jshell&gt; List&lt;String&gt; onames = names.stream().&#13;
   ...&gt;   filter(n -&gt; n.indexOf("o") &gt; -1).&#13;
   ...&gt;   collect(Collectors.toList())&#13;
onames ==&gt; [Fozzie, Gonzo]</pre>&#13;
&#13;
<p>Excellent. Now <code>onames</code> is a regular <code>List&lt;String&gt;</code> object that we can use anywhere else we might need it. There are many, many other collecting methods that we encourage you to peek at in the <a href="https://oreil.ly/R3vmF">online documentation for <code>Collectors</code></a>. The code exercises at the end of this chapter give you the chance to try out another popular collector, <code>groupingBy()</code>, but we don’t have time to cover all of the other wonderful options available.<a data-primary="" data-startref="ix_func_prog_stream" data-type="indexterm" id="id2295"/><a data-primary="" data-startref="ix_java_util_str_pkg" data-type="indexterm" id="id2296"/><a data-primary="" data-startref="ix_lambda_stream" data-type="indexterm" id="id2297"/><a data-primary="" data-startref="ix_java_stream_red_coll" data-type="indexterm" id="id2298"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Using Lambdas Directly" data-type="sect1"><div class="sect1" id="learnjava6-CHP-11-SECT-4">&#13;
<h1>Using Lambdas Directly</h1>&#13;
&#13;
<p>We want to <a data-primary="lambda expressions (lambdas)" data-secondary="using directly in code" data-type="indexterm" id="ix_lambda_direct"/>highlight one other feature of lambdas in Java: you can use them in your own code. While you will probably start by using lambdas in a few tasks like sorting collections or filtering long streams of data, eventually you may want to write methods that accept a lambda as an argument to be used in the body of that method. Since lambda expressions are just instances of some functional interface, Java makes accepting lambdas fairly straightforward.</p>&#13;
&#13;
<p>Consider a digital sensor: perhaps some gadget attached to a USB port. Many of these sensors are stable and consistent, but they are consistently off by some factor. Maybe a thermometer thinks your home office is always three degrees warmer than it is, or maybe a light sensor underestimates ambient light by 10%. You could write separate adjustment methods that “add 3” to a reading or that “reduce by 10%” every value, but you can also use lambdas to create a generic adjustment method and let the caller supply the adjusting logic.</p>&#13;
&#13;
<p>Let’s see how you <a data-primary="java.util.function package" data-secondary="DoubleUnaryOperator" data-type="indexterm" id="id2299"/><a data-primary="DoubleUnaryOperator" data-type="indexterm" id="id2300"/><a data-primary="unary operator" data-type="indexterm" id="id2301"/>might write such a method. To make your method accept a lambda, you need to decide what shape it should have. You can always create your own shape, of course, but often you can simply use one of the interfaces from the <code>java.util.function</code> package. For our sensor-reading adjustments, we’ll use the <code>DoubleUnaryOperator</code> shape. (A <em>unary operator</em> operates on one value the same way a binary operator works on two.) We’ll accept one <code>double</code> argument and return an adjusted <code>double</code> as the result. We can put our amazingly flexible adjuster in a simple test harness to try out:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kn">import</code><code class="w"> </code><code class="nn">java.util.function.DoubleUnaryOperator</code><code class="p">;</code><code class="w"/>&#13;
&#13;
<code class="kd">public</code><code class="w"> </code><code class="kd">class</code> <code class="nc">Adjuster</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">public</code><code class="w"> </code><code class="kd">static</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="nf">adjust</code><code class="p">(</code><code class="kt">double</code><code class="w"> </code><code class="n">val</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">                              </code><code class="n">DoubleUnaryOperator</code><code class="w"> </code><code class="n">adjustment</code><code class="p">)</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="n">adjustment</code><code class="p">.</code><code class="na">applyAsDouble</code><code class="p">(</code><code class="n">val</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">}</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="kd">public</code><code class="w"> </code><code class="kd">static</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">main</code><code class="p">(</code><code class="n">String</code><code class="w"> </code><code class="n">args</code><code class="o">[]</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="kt">double</code><code class="w"> </code><code class="n">sample</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mf">70.2</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="s">"Initial reading: "</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">sample</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">print</code><code class="p">(</code><code class="s">"Adding 3: "</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="n">adjust</code><code class="p">(</code><code class="n">sample</code><code class="p">,</code><code class="w"> </code><code class="n">s</code><code class="w"> </code><code class="o">-&gt;</code><code class="w"> </code><code class="n">s</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="mi">3</code><code class="p">));</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">print</code><code class="p">(</code><code class="s">"Reducing by 10%: "</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="n">adjust</code><code class="p">(</code><code class="n">sample</code><code class="p">,</code><code class="w"> </code><code class="n">s</code><code class="w"> </code><code class="o">-&gt;</code><code class="w"> </code><code class="n">s</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="mf">0.9</code><code class="p">));</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">}</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>You can see that our <code>adjust()</code> method takes two arguments: the value we want to adjust, and the lambda that will do the adjusting. (And yes, you could implement the <code>DoubleUnaryOperator</code> in a class and supply an instance of that implementation as an alternative.) When we call <code>adjust()</code>, we get to use the same compact syntax that we’ve seen with other parts of the official JDK. It feels a bit like using forbidden magic, but it is entirely encouraged!</p>&#13;
&#13;
<p>If you compile and run this demo, you should see output similar to this:</p>&#13;
&#13;
<pre data-type="programlisting">$ java Adjuster&#13;
Initial reading: 70.2&#13;
Adding 3: 73.2&#13;
Reducing by 10%: 63.18000000000001</pre>&#13;
&#13;
<p>Exactly what we expected. And we could write other adjustments without having to rewrite our actual <code>adjust()</code> method. You probably  won’t need this type of dynamic logic for every problem you tackle in Java, but it’s worth putting this trick into your toolbox so you can pull it out when you do.<a data-primary="" data-startref="ix_lambda_direct" data-type="indexterm" id="id2302"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Next Steps" data-type="sect1"><div class="sect1" id="learnjava6-CHP-11-SECT-5">&#13;
<h1>Next Steps</h1>&#13;
&#13;
<p>As with so many features of Java, we could write an entire book just on lambda expressions or streams. <a href="https://oreil.ly/4Eb4c">Others have!</a> We hope this introduction whets your appetite for learning more about FP topics. If you want more interactive practice with these topics, we highly recommend the labs available through O’Reilly’s <a href="https://oreil.ly/gRFDW">online platform</a>. Our own Marc Loy has created two series, one on&#13;
<a href="https://oreil.ly/QNmjK">Java lambdas</a> and another on&#13;
<a href="https://oreil.ly/XquFS">Java streams</a>, both with practical examples of the topics we touched on in this chapter. These labs take advantage of O’Reilly’s Interactive Learning Environment, where you can edit, compile, and execute Java code right in your browser.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Review Questions" data-type="sect2"><div class="sect2" id="learnjava6-CHP-11-SECT-5.1">&#13;
<h2>Review Questions</h2>&#13;
<ol>&#13;
<li>&#13;
<p>Which package contains the majority of functional interfaces introduced in &#13;
<span class="keep-together">Java 8</span>?</p>&#13;
</li>&#13;
<li>&#13;
<p>Do you need to use any special flags when compiling or running Java applications that use functional features like lambdas?</p>&#13;
</li>&#13;
<li>&#13;
<p>How do you create lambda expressions with multiple statements in the body?</p>&#13;
</li>&#13;
<li>&#13;
<p>Can lambda expressions be void? Can they return values?</p>&#13;
</li>&#13;
<li>&#13;
<p>Can you reuse a stream after you have processed it?</p>&#13;
</li>&#13;
<li>&#13;
<p>How might you take a stream of objects and convert it to a stream of integers?</p>&#13;
</li>&#13;
<li>&#13;
<p>If you have a stream that filters out empty lines from a file, what operation might you use to tell you how many lines had some content?</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Code Exercises" data-type="sect2"><div class="sect2" id="learnjava6-CHP-11-SECT-5.2">&#13;
<h2>Code Exercises</h2>&#13;
<ol>&#13;
<li>&#13;
<p>Our <code>Adjuster</code> demonstration allows us to pass any lambda that accepts and returns a <code>double</code> value. We aren’t restricted to simple changes like adding a fixed amount. Add one more line of output that converts the number from a Fahrenheit reading to Celsius. (As a quick refresher, C = (F – 32) * 5 / 9. Our reading of 70.2 should come out around 21.2.)</p>&#13;
</li>&#13;
<li>&#13;
<p>Using the <code>PaidEmployee</code> and <code>Report</code> classes from <a data-type="xref" href="#learnjava6-CHP-11-SECT-3.3.1">“Mapping object attributes”</a>, add a simple report similar to <code>publishBudget()</code> that displays the average salary of all employees.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Advanced Exercises" data-type="sect2"><div class="sect2" id="learnjava6-CHP-11-SECT-5.3">&#13;
<h2>Advanced Exercises</h2>&#13;
<ol>&#13;
<li>&#13;
<p>Let’s explore more of the collectors we touched on at the end of the chapter. Add a “role” attribute (of type <code>String</code>) to the <code>PaidEmployee</code> class. Be sure to update the <code>buildEmployeeList()</code> method in the <code>Report</code> class to assign roles as well. Feel free to pick whatever roles you like but make sure at least two employees share the same role (for testing purposes).<a data-primary="" data-startref="ix_func_prog_ch11" data-type="indexterm" id="id2303"/><a data-primary="" data-startref="ix_java_util_func" data-type="indexterm" id="id2304"/></p>&#13;
&#13;
<p>Now look at the <a href="https://oreil.ly/miu1t">documentation for the <code>groupingBy()</code> collector</a>. It returns a map of the groups and their members. In our example, the keys of this map will be the roles you created. The associated values will be lists of all the employees who share that role. You can add one more “report” to the <code>Report</code> class that creates this map and then prints out the roles and their associated employees.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
</div></section>&#13;
</div></section>&#13;
<div data-type="footnotes"><p data-type="footnote" id="id2199"><sup><a href="ch11.html#id2199-marker">1</a></sup> Indeed, Church’s student and computing pioneer Alan Turing proved that the lambda calculus was equivalent to Turing’s own system (the foundational Turing machine) for performing computation.</p><p data-type="footnote" id="id2202"><sup><a href="ch11.html#id2202-marker">2</a></sup> We mention Clojure rather than the myriad other modern functional languages because it runs on the JVM and can integrate with Java classes and methods. Neat!</p><p data-type="footnote" id="id2290"><sup><a href="ch11.html#id2290-marker">3</a></sup> A quirk of the factorial process is that <code>0!</code> is defined as “the number of ways to arrange items in an empty set”—which is exactly one. Even if our stream has no elements, we can still correctly return the starting value.</p><p data-type="footnote" id="id2291"><sup><a href="ch11.html#id2291-marker">4</a></sup> That’s 9.3e+155 if scientific notation is easier for you to parse at that size. Popular estimates for the number of atoms in the known universe come in around 10e+82, in case you were wondering just how big <code>99!</code> really is.</p></div></div></section></body></html>