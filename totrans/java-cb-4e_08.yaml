- en: Chapter 8\. Object-Oriented Techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 8.0 Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java is an Object-Oriented (OO) language in the tradition of Simula-67, SmallTalk,
    and C++. It borrows syntax from C++ and ideas from SmallTalk. The Java API has
    been designed and built on the OO model. Design patterns (see the book of the
    same name), such as Factory and Delegate, are used throughout; an understanding
    of these patterns will help you better understand the use of the API and improve
    the design of your own classes.
  prefs: []
  type: TYPE_NORMAL
- en: Advice, or Mantras
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are any number of short bits of advice that I could give. A few recurring
    themes arise when learning the basics of Java, and I suggest reviewing them when
    learning more Java.
  prefs: []
  type: TYPE_NORMAL
- en: Use the API
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I can’t say this often enough. A lot of the things you need to do have already
    been done by the good folks who develop the standard Java library (and third-party
    libraries). And this grows with every release. Learning the API well is a good
    grounds for avoiding that deadly “reinventing the flat tire” syndrome—coming up
    with a second-rate equivalent of a first-rate product that was available to you
    the whole time. In fact, part of this book’s mission is to prevent you from reinventing
    what’s already there. One example of this is the Collections API in `java.util`,
    discussed in [Chapter 7](ch07.html#javacook-structure). The Collections API has
    a high degree of generality and regularity, so there is often no need to invent
    your own data structuring code.
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions to the rule
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There is one exception to the rule of using the API: the `clone()` method in
    `java.lang.Object` should generally *not* be used. If you need to copy an object,
    just write a copy method, or a *copy constructor*. Joshua Bloch’s arguments against
    the `clone()` method in the book *Effective Java* (Addison-Wesley) are persuasive
    and should be read by any dedicated Java programmer. While you’re at it, read
    that whole book.'
  prefs: []
  type: TYPE_NORMAL
- en: Another exception is the `finalize()` method in `java.lang.Object()`. Don’t
    use it. It has been deprecated since Java 9 because it isn’t guaranteed to be
    invoked; but because it might get invoked, it will cause your dead objects not
    to be garbage collected, resulting in a memory leak. If you need some kind of
    cleanup, you must take responsibility for defining a method and invoking it before
    you let any object of that class go out of reference. You might call such a method
    `cleanUp()`. For application-level cleanup, see [*https://darwinsys.com/java/shutdownhook.html*](https://darwinsys.com/java/shutdownhook.html).
  prefs: []
  type: TYPE_NORMAL
- en: Generalize
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is a trade-off between generality (and the resulting reusability), which
    is emphasized here, and the convenience of application specificity. If you’re
    writing one small part of a very large application designed according to OO design
    techniques, you’ll have in mind a specific set of use cases. On the other hand,
    if you’re writing toolkit-style code, you should write classes with few assumptions
    about how they’ll be used. Making code easy to use from a variety of programs
    is the route to writing reusable code.
  prefs: []
  type: TYPE_NORMAL
- en: Read and write javadoc
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You’ve no doubt looked at the Java online documentation in a browser, in part
    because I just told you to learn the API well. Do you think Sun/Oracle hired millions
    of tech writers to produce all that documentation? No. That documentation exists
    because the developers of the API took the time to write javadoc comments, those
    funny `/**` comments you’ve seen in code. So, one more bit of advice: use javadoc.
    The standard JDK provides a good, standard mechanism for API documentation. And
    use it as you write the code—don’t think you’ll come back and write it in later.
    That kind of tomorrow never comes.'
  prefs: []
  type: TYPE_NORMAL
- en: See [Recipe 15.2](ch15.html#javacook-packages-javadoc) for details on using
    javadoc.
  prefs: []
  type: TYPE_NORMAL
- en: Use subclassing and delegation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Use subclassing. But don’t overuse subclassing. It is one of the best ways not
    only for avoiding code duplication, but for developing software that works. See
    any number of good books on the topic of object-oriented design and programming
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: There are several alternatives. One alternative to subclassing is delegation.
    Think about “is a” versus “has a.” For example, instead of subclassing `NameAndAddress`
    to make `BusinessPartner` and `Customer`, make `BusinessPartner` and `Customer`
    have instances of `NameAndAddress`. That is a clearer structure; having `BusinessPartner`
    *be a* `NameAndAddress` just because the partner *has a* name and address would
    not make sense. And delegation also makes it easier for a `Customer` to have both
    a billing address and a shipping address. Another alternative is Aspect-Oriented
    Programming (AOP), which allows you to bolt on extra functionality from the outside
    of your classes. AOP is provided by the Java EE using EJB Interception and by
    the Spring Framework AOP mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: Use design patterns
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the [Preface](preface01.html#preface), I mentioned *Design Patterns* as one
    of the Very Important Books on object-oriented programming. Often called the “Gang
    of Four” (GoF) book for its four authors, it provides a powerful catalog of things
    that programmers often reinvent. Some people find the GoF book to be somewhat
    academic in tone; a less-formal presentation on patterns is *Head First Design
    Patterns* by Bert Bates et al. (O’Reilly); this covers the same two dozen patterns
    as the GoF book. A design pattern provides a statement of a problem and its solution(s),
    rather like the present book, but generally at a higher level of abstraction.
    It is as important for giving a standard vocabulary of design as it is for its
    clear explanations of how the basic patterns work and how they can be implemented.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 8-1](#javacook-oo-intro-table) shows some example uses of design patterns
    in the standard API.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 8-1\. Design patterns in the JavaSE API
  prefs: []
  type: TYPE_NORMAL
- en: '| Pattern name | Meaning | Examples in Java API |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Command | Encapsulate requests, allowing queues of requests, undoable operations,
    etc. | `javax.swing.Action; javax.swing.undo.UndoableEdit` |'
  prefs: []
  type: TYPE_TB
- en: '| Decorator | One class decorates another | Swing `Border`s |'
  prefs: []
  type: TYPE_TB
- en: '| Factory Method | One class makes up instances for you, controlled by subclasses
    | `getInstance` (in `Calendar`, `Format`, `Locale`…); `SocketFactory`; RMI `InitialContext`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Iterator | Loop over all elements in a collection, visiting each exactly
    once | `Iterator`; older `Enumeration`; `java.sql.ResultSet` |'
  prefs: []
  type: TYPE_TB
- en: '| Model-View-Controller | Model represents data; View is what the user sees;
    Controller responds to user requests | `ActionListener` and friends; `Observer/Observable`;
    used internally by all visible Swing components |'
  prefs: []
  type: TYPE_TB
- en: '| Proxy | One object stands in for another | RMI, AOP, Dynamic Proxy |'
  prefs: []
  type: TYPE_TB
- en: '| Singleton | Only one instance may exist | `java.lang.Runtime, java.awt.Toolkit`
    |'
  prefs: []
  type: TYPE_TB
- en: I have written articles on the [State](https://blogs.oracle.com/javamagazine/the-state-pattern),
    [Proxy](https://blogs.oracle.com/javamagazine/the-proxy-pattern), [Command](https://blogs.oracle.com/javamagazine/the-command-pattern-in-depth),
    [Decorator](https://blogs.oracle.com/javamagazine/the-decorator-pattern-in-depth),
    and [Visitor](https://blogs.oracle.com/javamagazine/the-visitor-design-pattern-in-depth)
    patterns for *Oracle Java Magazine*.
  prefs: []
  type: TYPE_NORMAL
- en: '8.1 Object Methods: Formatting Objects with toString(), Comparing with Equals'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want your objects to have a useful default format and to behave themselves
    when placed in `Collections` classes.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are four overridable methods inherited from `java.lang.Object`; of these,
    `toString()` provides default formatting, while `equals()` and `hashCode()` provide
    equality testing and efficient usage in `Map` implementations. The fourth, `clone()`,
    is not recommended for general use.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: toString()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Whenever you pass an object to `System.out.println()` or any equivalent method
    or involve it in string concatenation, Java automatically calls its `toString()`
    method. Java knows that every object has a `toString()` method because `java.lang.Object`
    has one and all classes are ultimately subclasses of `Object`. The default implementation,
    in `java.lang.Object`, is neither pretty nor interesting: it just prints the class
    name, an @ sign, and the object’s `hashCode()` value. For example, if you run
    the code'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'you might see this uninformative output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To make it print better, you should provide an implementation of `toString()`
    that prints the class name and some of the important states in all but the most
    trivial classes. This gives you formatting control in `println()`, in debuggers,
    and anywhere your objects get referred to in a `String` context. Here is the previous
    program rewritten with a `toString()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This version produces the more useful output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This example uses `String` concatenation, but you may also want to use `String.format()`
    or `StringBuilder`; see [Chapter 3](ch03.html#javacook-strings).
  prefs: []
  type: TYPE_NORMAL
- en: hashCode() and equals()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To ensure your classes work correctly when any client code calls `equals()`
    or when these objects are stored in `Map` or other `Collection` classes, outfit
    your class with `equals()` and `hashCode()` methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'How do you determine equality? For arithmetic or Boolean operands, the answer
    is simple: you test with the equals operator (`==`). For object references, though,
    Java provides both `==` and the `equals()` method inherited from `java.lang.Object`.
    The `equals` operator can be confusing because it simply compares two object references
    to see if they refer to the same object. This is not the same as comparing the
    values of the objects themselves.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The inherited `equals()` method is also not as useful as you might imagine.
    Some people seem to start their lives as Java developers thinking that the default
    `equals()` magically does some kind of detailed, field-by-field or even binary
    comparison of objects. But it does *not* compare fields! It just does the simplest
    possible thing: it returns the value of an `==` comparison on the two objects
    involved! So, for any *value classes* you write, you probably have to write an
    `equals` method.^([1](ch08.html#idm45290664734344)) Note that both the `equals`
    and `hashCode` methods are used by `Map`s or hashes (such as `HashMap`; see [Recipe
    7.9](ch07.html#javacook-structure-SECT-6)). So if you think somebody using your
    class might want to create instances and put them into a `Map`, or even compare
    your objects, you owe it to them (and to yourself!) to implement both `equals()`
    and `hashCode()` and to implement them properly.'
  prefs: []
  type: TYPE_NORMAL
- en: Most IDEs know how to generate correct `equals()` and `hashCode()` methods,
    but it’s worth your while to understand what these are doing, for the occasional
    case where you need to tweak the generated code. The Eclipse IDE (see [Recipe
    1.3](ch01.html#javacook-getstarted-SECT-3)), for example, offers a `Source` menu
    item `Generate hashCode() and equals()`; it will only do both at the same time,
    not let you generate `equals()` without `hashCode()` nor vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the rules for a correct `equals()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: It is reflexive
  prefs: []
  type: TYPE_NORMAL
- en: '`x.equals(x)` must be true.'
  prefs: []
  type: TYPE_NORMAL
- en: It is symmetrical
  prefs: []
  type: TYPE_NORMAL
- en: '`x.equals(y)` must be true if and only if `y.equals(x)` is also true.'
  prefs: []
  type: TYPE_NORMAL
- en: It is transitive
  prefs: []
  type: TYPE_NORMAL
- en: If `x.equals(y)` is true and `y.equals(z)` is true, then `x.equals(z)` must
    also be true.
  prefs: []
  type: TYPE_NORMAL
- en: It is idempotent (repeatable)
  prefs: []
  type: TYPE_NORMAL
- en: Multiple calls on `x.equals(y)` return the same value (unless state values used
    in the comparison are changed, as by calling a set method).
  prefs: []
  type: TYPE_NORMAL
- en: It is cautious
  prefs: []
  type: TYPE_NORMAL
- en: '`x.equals(null)` must return false rather than accidentally throwing a `NullPointerException`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, beware of one common mistake: the argument to `equals()` must
    be declared as `java.lang.Object`, not the class it is in; this is so that polymorphism
    will work correctly (some classes may not have an `equals()` method of their own).
    To prevent this mistake, the `@Override` annotation is usually added to the `equals()`
    override, as mentioned in [Recipe 15.3](ch15.html#javacook-packages-SECT-3).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a class that endeavors to implement these rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_object_oriented_techniques_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Optimization: if same object, true by definition.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_object_oriented_techniques_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: If other object null, false by definition.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_object_oriented_techniques_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Compare class descriptors using !=; see following paragraph.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_object_oriented_techniques_CO1-4)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Optimization: compare primitives first. May or may not be worthwhile; may be
    better to order by those most likely to differ—depends on the data and the usage.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another common mistake to avoid: note the use of class descriptor equality
    (i.e., `o.getClass() != EqualsDemo.class`) to ensure the correct class, rather
    than via `instanceof`, as is sometimes erroneously done. The reflexive requirement
    of the `equals()` method contract pretty much makes it impossible to compare a
    subclass with a superclass correctly, so we now use class equality (see [Chapter 17,
    *Reflection, or “A Class Named Class”*](ch17.html#javacook-reflection) for details
    on the class descriptor).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a basic JUnit test (see [Recipe 1.10](ch01.html#javacook-getstarted-junit))
    for the `EqualsDemo` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: With all that testing, what could go wrong? Well, some things still need care.
    What if the object is a *subclass* of `EqualsDemo`? We should test that it returns
    false in this case.
  prefs: []
  type: TYPE_NORMAL
- en: What else could go wrong? Well, what if either `obj1` or `other.obj1` is null?
    You might have just earned a nice shiny new `NullPointerException`. So you also
    need to test for any possible null values. Good constructors can avoid these `NullPointerException`s,
    as I’ve tried to do in `EqualsDemo`, or else test for them explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you should never override `equals()` without also overriding `hashCode()`,
    and the same fields must take part in both computations.
  prefs: []
  type: TYPE_NORMAL
- en: hashCode()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `hashCode()` method is supposed to return an `int` that should uniquely
    identify any set of values in objects of its class.
  prefs: []
  type: TYPE_NORMAL
- en: 'A properly written `hashCode()` method will follow these rules:'
  prefs: []
  type: TYPE_NORMAL
- en: It is repeatable
  prefs: []
  type: TYPE_NORMAL
- en: '`hashCode(x)` must return the same `int` when called repeatedly, unless set
    methods have been called.'
  prefs: []
  type: TYPE_NORMAL
- en: It is consistent with equality
  prefs: []
  type: TYPE_NORMAL
- en: If `x.equals(y)`, then `x.hashCode()` must == `y.hashCode()`.
  prefs: []
  type: TYPE_NORMAL
- en: Distinct objects should produce distinct hashCodes
  prefs: []
  type: TYPE_NORMAL
- en: If `!x.equals(y)`, it is not required that `x.hashCode()` != `y.hashCode()`,
    but doing so may improve performance of hash tables (i.e., hashes may call `hashCode()`
    before `equals()`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The default `hashCode()` on the standard JDK returns a machine address, which
    conforms to the first rule. Conformance to the second and third rules depends,
    in part, on your `equals()` method. Here is a program that prints the hashcodes
    of a small handful of objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: What does it print?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The hashcode value for the `Color` object is interesting. It is actually computed
    as something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this formula, `r`, `g`, and `b` are the red, green, and blue components,
    respectively, and `alpha` is the transparency. Each of these quantities is stored
    in 8 bits of a 32-bit integer. If the alpha value is greater than 128, the high
    bit in this word—having been set by shifting into the sign bit of the word—causes
    the integer value to appear negative when printed as a signed integer. Hashcode
    values are of type `int`, so they are allowed to be negative.
  prefs: []
  type: TYPE_NORMAL
- en: Difficulties and Alternatives to Clone
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `java.util.Observable` class (designed to implement the Model-View-Controller
    pattern with AWT or Swing applications) contains a private `Vector` but no clone
    method to deep-clone it. Thus, `Observable` objects cannot safely be cloned, ever!
  prefs: []
  type: TYPE_NORMAL
- en: 'This and several other issues around `clone()`—such as the uncertainty of whether
    a given `clone()` implementation is deep or shallow—suggest that `clone()` was
    not as well thought out as might be. An alternative is simply to provide a copy
    constructor or similar method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 8.2 Using Inner Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to write a private class, or a class to be used in one other class
    at most.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use a nonpublic class or an inner class.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A nonpublic class can be written as part of another class’s source file, but
    not inside that class. An inner class is Java terminology for a class defined
    inside another class. Inner classes were first popularized with early Java for
    use as event handlers for GUI applications, but they have a much wider application.
  prefs: []
  type: TYPE_NORMAL
- en: Inner classes can, in fact, be constructed in several contexts. An inner class
    defined as a member of a class can be instantiated anywhere in that class. An
    inner class defined inside a method can be referred to later only in the same
    method. Inner classes can also be named or anonymous. A named inner class has
    a full name that is compiler dependent; the standard JVM uses a name like `MainClass$InnerClass`
    for the resulting file. An anonymous inner class, similarly, has a compiler-dependent
    name; the JVM uses `MainClass$1`, `MainClass$2`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'These classes cannot be instantiated in any other context; any explicit attempt
    to refer to, say, `OtherMainClass$InnerClass`, is caught at compile time:'
  prefs: []
  type: TYPE_NORMAL
- en: '*main/src/main/java/oo/AllClasses.java*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_object_oriented_techniques_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: This is an inner class, which can be used anywhere in class `AllClasses`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_object_oriented_techniques_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: This shows the anonymous inner class syntax, which uses `new` with a type followed
    by `(){`, a class body, and `}`. The compiler will assign a name; the class will
    extend or implement the given type, as appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_object_oriented_techniques_CO2-3)'
  prefs: []
  type: TYPE_NORMAL
- en: This is a nonpublic class; it can be used in the main class and (with warning)
    in other classes.
  prefs: []
  type: TYPE_NORMAL
- en: One issue is that the inner class retains a reference to the outer class. If
    you want to avoid memory leaks if the inner class will be held for a longer time
    than the outer, you can make the inner class `static`.
  prefs: []
  type: TYPE_NORMAL
- en: Inner classes implementing a single-method interface can be written in a much
    more concise fashion as lambda expressions (see [Chapter 9](ch09.html#javacook-fp)).
  prefs: []
  type: TYPE_NORMAL
- en: 8.3 Providing Callbacks via Interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to provide callbacks—that is, have unrelated classes call back into
    your code.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One way is to use a Java interface.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An interface is a class-like entity that can contain only abstract methods
    and final fields. As we’ve seen, interfaces are used a lot in Java! In the standard
    API, the following are a few of the commonly used interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Runnable`, `Comparable`, and `Cloneable` (in `java.lang`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`List`, `Set`, `Map`, and `Enumeration/Iterator` (in the Collections API; as
    you’ll see in [Chapter 7](ch07.html#javacook-structure)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ActionListener`, `WindowListener`, and others in the GUI layer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Driver`, `Connection`, `Statement`, and `ResultSet` in JDBC; see [*https://darwinsys.com/javadatabase*](https://darwinsys.com/javadatabase).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *remote interface*—the contact between the client and the server—is specified
    as an `Interface` (in RMI, CORBA, and EJB).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Suppose we are generating a building management system. To be energy efficient,
    we want to be able to remotely turn off (at night and on weekends) such things
    as room lights and computer monitors, which use a lot of energy. Assume we have
    some kind of remote control technology. It could be a commercial version of BSR’s
    house-light control technology X10, it could be Bluetooth or 802.11—it doesn’t
    matter. What matters is that we have to be very careful what we turn off. It would
    cause great ire if we turned off computer processors automatically—people often
    leave things running overnight. It would be a matter of public safety if we ever
    turned off the building emergency lighting.^([2](ch08.html#idm45290663675912))
  prefs: []
  type: TYPE_NORMAL
- en: So we’ve come up with the design shown in [Figure 8-1](#javacook-oo-FIG-1).
  prefs: []
  type: TYPE_NORMAL
- en: '![jcb4 0801](assets/jcb4_0801.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-1\. Classes for a building management system
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The code for these data classes is not shown (it’s pretty trivial), but it’s
    in the *oo/interfaces* directory of the online source. The top-level classes (i.e.,
    `BuildingLight` and `Asset`) are abstract classes. You can’t instantiate them,
    because they don’t have any specific functionality. To ensure—both at compile
    time and at runtime—that we can never switch off the emergency lighting, we need
    only ensure that the class representing it, `EmergencyLight`, does not implement
    the `PowerSwitchable` interface.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we can’t very well use direct inheritance here. No common ancestor
    class includes both `ComputerMonitor` and `RoomLights` that doesn’t also include
    `ComputerCPU` and `EmergencyLight`. Use interfaces to define functionality in
    unrelated classes.
  prefs: []
  type: TYPE_NORMAL
- en: How we use these is demonstrated by the `BuildingManagement` class; this class
    is not part of the hierarchy shown in [Figure 8-1](#javacook-oo-FIG-1), but it
    *uses* a collection of `Asset` objects from that hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Items that can’t be switched must nonetheless be in the database, for various
    purposes (auditing, insurance, etc.). In the method that turns things off, the
    code is careful to check whether each object in the database is an instance of
    the `PowerSwitchable` interface. If so, the object is casted to `PowerSwitchable`
    so that its `powerDown()` method can be called. If not, the object is skipped,
    thus preventing any possibility of turning out the emergency lights or shutting
    off a machine that is busy running SETI@Home, downloading a big MP3 playlist,
    or performing system backups. The following code shows this set of classes in
    action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run this program, it shows all the items being added but only the
    `PowerSwitchable` ones being switched off:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 8.4 Polymorphism/Abstract Methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want each of a number of subclasses to provide its own version of one or
    more methods.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make the method abstract in the parent class; this makes the compiler ensure
    that each subclass implements it.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A hypothetical drawing program uses a `Shape` subclass for anything that is
    drawn. `Shape` has an abstract method called `computeArea()` that computes the
    exact area of the given shape:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'A `Rectangle` subclass, for example, has a `computeArea()` that multiplies
    width times height and returns the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'A `Circle` subclass returns π*r*²:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This system has a high degree of generality. In the main program, we can iterate
    over a collection of `Shape` objects and—here’s the real beauty—call `computeArea()`
    on any `Shape` subclass object without having to worry about what kind of shape
    it is. Java’s polymorphic methods automatically call the correct `computeArea()`
    method in the class of which the object was originally constructed:'
  prefs: []
  type: TYPE_NORMAL
- en: '*main/src/main/java/oo//shapes/ShapeDriver.java*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Polymorphism is a great boon for software maintenance: if a new subclass is
    added, the code in the main program does not change. Further, all the code that
    is specific to, say, polygon handling, is all in one place: in the source file
    for the `Polygon` class. This is a big improvement over older languages, where
    type fields in a structure were used with case or switch statements scattered
    all across the software. Java makes software more reliable and maintainable with
    the use of polymorphism.'
  prefs: []
  type: TYPE_NORMAL
- en: 8.5 Using Typesafe Enumerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to manage a small list of discrete values within a program.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the Java `enum` mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To enumerate means to list all the values. You often know that a small list
    of possible values is all that’s wanted in a variable, such as the months of the
    year, the suits or ranks in a deck of cards, or the primary and secondary colors.
    The C programming language provided an `enum` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Java was criticized in its early years for its lack of enumerations, which many
    developers have wished for. Many have had to develop custom classes to implement
    the *typesafe enumeration pattern*.
  prefs: []
  type: TYPE_NORMAL
- en: But C enumerations are not typesafe; they simply define constants that can be
    used in any integer context. For example, this code compiles without warning,
    even on *gcc* 3 with `-Wall` (all warnings), whereas a C++ compiler catches the
    error:^([3](ch08.html#idm45290663297016))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'To replicate this mistake in Java, one needs only to define a series of `final
    int` values; it will still not be typesafe. By typesafe I mean that you cannot
    accidentally use values other than those defined for the given enumeration. The
    definitive statement on the typesafe enumeration pattern is probably the version
    defined in item 21 of Joshua Bloch’s book *Effective Java* (Addison-Wesley). All
    modern Java versions include enumerations in the language; it is no longer necessary
    to use the code from Bloch’s book. Bloch was one of the authors of the Typesafe
    Enumeration specification (`enum` keyword), so you can be sure that Java now does
    a good job of implementing his pattern. These `enum`s are implemented as classes,
    subclassed (transparently, by the compiler) from the class `java.lang.Enum`. Unlike
    C, and unlike a series of `final int`s, Java typesafe enumerations have the following
    qualities:'
  prefs: []
  type: TYPE_NORMAL
- en: They are printable (they print as the name, not as an underlying `int` implementation).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are almost as fast as `int` constants, but the code is more readable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They can be easily iterated over.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They use a separate namespace for each `enum` type, which means you don’t have
    to prefix each with some sort of constant name, like `ACCOUNT_SAVINGS`, `ACCOUNT_CHECKING`,
    etc.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enum constants are not compiled into clients, giving you the freedom to reorder
    the constants within your `enum` without recompiling the client classes. That
    does not mean you should, however; think about the case where objects that use
    them have been persisted, and the person designing the database mapping used the
    numeric values of the enums. Bad idea to reorder then!
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, an `enum` type is a class, so it can, for example, implement arbitrary
    interfaces; and you can add constructors, fields, and methods to an `enum` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Compared to Bloch’s Typesafe Enum pattern in the book:'
  prefs: []
  type: TYPE_NORMAL
- en: Java `enums` are simpler to use and more readable (those in the book require
    a lot of methods, making them cumbersome to write).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enums can be used in switch statements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So there are many benefits and few pitfalls.
  prefs: []
  type: TYPE_NORMAL
- en: The `enum` keyword is at the same level as the keyword `class` in declarations.
    That is, an `enum` may be declared in its own file with public or default access.
    It may also be declared inside classes, much like nested or inner classes (see
    [Recipe 8.2](#javacook-oo-SECT-6)). *Media.java*, shown in [Example 8-1](#javacook-CHP-8-EX-7),
    is a code sample showing the definition of a typesafe `enum`.
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-1\. structure/Media.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that an `enum` class *is* a class; see what *javap* thinks of the `Media`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '*Product.java*, shown in [Example 8-2](#javacook-CHP-8-EX-8), is a code sample
    that uses the `Media` enum.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-2\. main/src/main/java/structure/Product.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In [Example 8-3](#javacook-CHP-8-EX-9), `MediaFancy` shows how operations (methods)
    can be added to enumerations; the `toString()` method is overridden for the `Book`
    value of this enum.
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-3\. main/src/main/java/structure/MediaFancy.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the `MediaFancy` program produces this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: That is, the `Book` values print in a user-friendly way compared to the default
    way the other values print. In real life you’d want to extend this to all the
    values in the `enum`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, `EnumList`, in [Example 8-4](#javacook-CHP-8-EX-10), shows how to list
    all the possible values that a given `enum` can take on; simply iterate over the
    array returned by the enumeration class’s inherited `values()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-4\. structure/EnumList.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the `EnumList` program is this, of course:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 8.6 Avoiding NPEs with Optional
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You worry about null references causing a `NullPointerException` (NPE) in your
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use `java.util.Optional`.
  prefs: []
  type: TYPE_NORMAL
- en: Discusssion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The developer who invented the notion of null pointers, and a key early contributor
    to our discipline, has described the null reference as [“my billion-dollar mistake”](https://en.wikipedia.org/wiki/Tony_Hoare).
    However, use of `null` is not going away anytime soon.
  prefs: []
  type: TYPE_NORMAL
- en: What we can do is make clear that we worry about null pointers in certain contexts.
    For this purpose, Java 8 introduced the class `java.util.Optional`. The `Optional`
    is an object wrapper around a possibly-null object reference. The `Optional` wrapper
    has a long history; a similar construct is found in LLVM’s ADT, where its `Optional`
    describes itself in turn as “in the spirit of OCaml’s *opt* variant.”
  prefs: []
  type: TYPE_NORMAL
- en: '`Optionals` can be created with one of the creational methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Optional.empty()`'
  prefs: []
  type: TYPE_NORMAL
- en: Returns an empty optional
  prefs: []
  type: TYPE_NORMAL
- en: '`Optional.of(T obj)`'
  prefs: []
  type: TYPE_NORMAL
- en: Returns a nonempty optional containing the given value
  prefs: []
  type: TYPE_NORMAL
- en: '`Optional.ofNullable(T obj)`'
  prefs: []
  type: TYPE_NORMAL
- en: Returns either an empty optional or one containing the given value
  prefs: []
  type: TYPE_NORMAL
- en: The basic operation of this class is to behave in one of two ways, depending
    on whether it is full or empty. Optional objects are immutable, so they cannot
    transition from one state to the other.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest use is to invoke `isEmpty()` or its opposite `isPresent()` and
    use program logic to behave differently. This is not much different from using
    an `if` statement to check for null, but it puts the choice in front of you, making
    it less likely that you’ll forget to check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'A better form would use the `orElse` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: A useful use case is that of passing values into methods. The object can be
    wrapped in an `Optional` either before it is passed to a method or after; the
    latter is useful when migrating from code that didn’t use `Optional` from the
    start. The `Item` demo in [Example 8-5](#javacook-oo-ex-optional-item) might represent
    part of a shipments tracking program, a lending library manager, or anything else
    that has time-related data which might be missing.
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-5\. main/src/main/java/oo/OptionalDemo.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: There are methods that throw exceptions, that return null, and so on. There
    are also methods for interacting with the Streams mechanism (see [Recipe 9.3](ch09.html#javacook-fp-streams1-1)).
    A full list of `Optional`’s methods is at the start of the [javadoc page](https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/util/Optional.html).
  prefs: []
  type: TYPE_NORMAL
- en: 8.7 Enforcing the Singleton Pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to be sure there is only one instance of your class in a given Java
    Virtual Machine, or at least within your application.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are several methods of making your class enforce the Singleton pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: Enum implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Having only a private constructor (or multiple) and a `getInstance()` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a framework such as Spring or CDI ([Recipe 8.9](#javacook-oo-SECT-di)) configured
    to give Singleton-style instantiation of plain classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is often useful to ensure that only one instance of a class gets created,
    usually to funnel all requests for some resource through a single point. An example
    of a Singleton from the standard API is `java.lang.Runtime`: you cannot create
    instances of `Runtime`; you simply ask for a reference by calling the static method
    `Runtime.getRuntime()`. Singleton is also an example of a design pattern that
    can be easily implemented. In all forms, the point of the Singleton implementation
    is to provide an instance in which certain methods can run, typically to control
    access to some resource.'
  prefs: []
  type: TYPE_NORMAL
- en: The easiest implementation uses a Java `enum` to provide Singleton-ness. The
    `enum` mechanism already guarantees that only one instance of each enum constant
    will exist in a given JVM context, so this technique piggy-backs on that, as shown
    in [Example 8-6](#javacook-oo-singleton-1).
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-6\. main/src/main/java/oo/EnumSingleton.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Using it is simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The next easiest implementation consists of a private constructor and a field
    to hold its result, as well as a static accessor method with a name like `getInstance()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The private field can be assigned from within a static initializer block or,
    more simply, by using an initializer. The `getInstance()` method (which must be
    public) then simply returns this instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Note that the method of using *lazy evaluation* in the `getInstance()` method
    (as in *Design Patterns*) is not necessary in Java because Java already uses *lazy
    loading*. Your `Singleton` class will probably not get loaded until its `getInstance()`
    is called, so there is no point in trying to defer the `Singleton` construction
    until it’s needed by having `getInstance()` test the `singleton` variable for
    null and creating the singleton there.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this class is equally simple: simply get the instance reference, and
    invoke methods on it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Some commentators believe that a code-based Singleton should also provide a
    `public final clone()` method that just throws an exception, in order to avoid
    subclasses that cheat and `clone()` the Singleton. However, it is clear that a
    class with only a private constructor cannot be subclassed, so this paranoia does
    not appear to be necessary.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Collections` class in `java.util` has methods `singletonList()`, `singletonMap()`,
    and `singletonSet()`, which give out an immutable `List`, `Map`, or `Set`, respectively,
    containing only the one object that is passed to the method. This does not, of
    course, convert the object into a Singleton in the sense of preventing that object
    from being cloned or other instances from being constructed.
  prefs: []
  type: TYPE_NORMAL
- en: See page 127 of the original *Design Patterns* book.
  prefs: []
  type: TYPE_NORMAL
- en: 8.8 Roll Your Own Exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You’d like to use an application-specific exception class or two.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Go ahead and subclass `Exception` or `RuntimeException`.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In theory, you could subclass `Throwable` directly, but that’s considered rude.
    You normally subclass `Exception` (if you want a checked exception) or `RuntimeException`
    (if you want an unchecked exception). Checked exceptions are those that an application
    developer is required to catch or throw upward by listing them in the `throws`
    clause of the invoking method.
  prefs: []
  type: TYPE_NORMAL
- en: 'When subclassing either of these, it is customary to provide at least these
    constructors:'
  prefs: []
  type: TYPE_NORMAL
- en: A no-argument constructor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A one-string argument constructor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A two-argument constructor—a string message and a `Throwable` cause
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The cause will appear if the code receiving the exception performs a stack trace
    operation on it, with the prefix “Root Cause is” or similar. [Example 8-7](#chessmoveexception)
    shows these three constructors for an application-defined exception, `ChessMoveException`.
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-7\. main/src/main/java/oo/ChessMoveException.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The javadoc documentation for `Exception` lists a large number of subclasses;
    you might look there first to see if there is one you can use.
  prefs: []
  type: TYPE_NORMAL
- en: 8.9 Using Dependency Injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to avoid excessive coupling between classes, and you want to avoid
    excessive code dedicated to object creation/lookup.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use a dependency injection framework.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A dependency injection framework allows you to have objects passed in to your
    code instead of making you either create them explicitly (which ties your code
    to the implementing class name, since you’re calling the constructor) or looking
    for them (which requires use of a possibly cumbersome lookup API, such as JNDI,
    the Java Naming and Directory Interface).
  prefs: []
  type: TYPE_NORMAL
- en: Three of the best-known dependency injection frameworks are the [Spring Framework](http://springframework.org),
    the [Java Enterprise Edition’s Context and Dependency Injection (CDI)](http://docs.oracle.com/javaee/6/tutorial/doc/giwhl.html),
    and [Google Guice](http://code.google.com/p/google-guice). Suppose we have three
    classes, a `Model`, a `View`, and a `Controller`, implementing the traditional
    MVC pattern. Given that we may want to have different versions of some of these,
    especially the `View`, we’ll define Java interfaces for simple versions of the
    Model (in [Example 8-8](#MVC_Model_interface)) and View (in [Example 8-9](#MVC_View_interface)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-8\. MVC Model interface
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Example 8-9\. main/src/main/java/di/View.java (MVC View interface)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementations of these are not shown, because they’re so trivial, but
    they are online. The Controller in this example is a main program, no interface
    needed. First, let’s see a version of the main program *not* using dependency
    injection. Obviously the View requires the Model, to get the data to display:'
  prefs: []
  type: TYPE_NORMAL
- en: '*main/src/main/java/di/ControllerTightlyCoupled.java*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we have four tasks to undertake:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the Model.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the View.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tie the Model into the View.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ask the View to display some data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now a version using dependency injection:'
  prefs: []
  type: TYPE_NORMAL
- en: '*main/src/main/java/di/spring/MainAndController.java - Spring Controller*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'In this version, we have only three tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Set up the Spring context, which provides the dependency injection framework.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get the View from the context; it already has the Model set into it!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ask the View to display some data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Furthermore, we don’t depend on particular implementations of the interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'How does Spring know to inject, or provide, a Model to the View? And how does
    it know what code to use for the View? There might be multiple implementations
    of the View interface. Of course we have to tell it these things, which we’ll
    do here with annotations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: While Spring has provided its own annotations, it will also accept the Java
    standard `@javax.annotation.Resource` annotation for injection and `@java.inject.Named`
    to specify the injectee.
  prefs: []
  type: TYPE_NORMAL
- en: Due to the persistence of information on the web, if you do a web search for
    Spring Injection, you will probably find zillions of articles that refer to the
    older Spring 2.x way of doing things, which is to use an XML configuration file.
    You can still use this, but modern Spring practice is generally to use Java annotations
    to configure the dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Annotations are also used in the Java Enterprise Edition Contexts and Dependency
    Injection (CDI). Although this is most widely used in web applications, we’ll
    reuse the same example, using the open source Weld implementation of CDI. CDI
    is quite a bit more powerful than Spring’s DI; because in CDI we don’t even need
    to know the class from which a resource is being injected, we don’t even need
    the interfaces from the Spring example! First, the Controller, or main program,
    which requires a Weld-specific import or two because CDI was originally designed
    for use in enterprise applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The `View` interface is shared between both implementations. The `ConsoleViewer`
    implementation is similar too, except it isn’t coupled to the Model; it just asks
    to have a `String` injected. In this simple example there is only one `String`
    in the application; in a larger app you would need one additional annotation to
    specify which string to inject. Here is the CDI `ConsoleViewer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Where does the injected `String` come from? From the Model, as before:'
  prefs: []
  type: TYPE_NORMAL
- en: '*main/src/main/java/di/cdi/ModelImpl.java*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Spring DI, Java EE CDI, and Guice all provide powerful *dependency injection*.
    Spring’s is more widely used; Java EE’s has the same power and is built into every
    EE container. All three can be used standalone or in a web application, with minor
    variations. In the EE, Spring provides special support for web apps, and in EE
    containers, CDI is already set up so that the first statement in the `CDIMain`
    example is not needed in an EE app. There are many books on Spring. One book specifically
    treats Weld: *[JBoss Weld CDI for Java Platform](http://shop.oreilly.com/product/9781782160182.do)*
    by Ken Finnegan (O’Reilly).'
  prefs: []
  type: TYPE_NORMAL
- en: '8.10 Program: Plotter'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Not because it is very sophisticated, but because it is simple, this program
    serves as an example of some of the things we’ve covered in this chapter, and
    also, in its subclasses, provides a springboard for other discussions. This class
    describes a series of old-fashioned (i.e., common in the 1970s and 1980s) pen
    plotters. A pen plotter, in case you’ve never seen one, is a device that moves
    a pen around a piece of paper and draws things. It can lift the pen off the paper
    or lower it, and it can draw lines, letters, and so on. Before the rise of laser
    printers and ink-jet printers, pen plotters were the dominant means of preparing
    charts of all sorts, as well as presentation slides (this was, ah, well before
    the rise of programs like Harvard Presents and Microsoft PowerPoint). Today, few,
    if any, companies still manufacture pen plotters, but I use them here because
    they are simple enough to be well understood from this brief description. Today’s
    3D printers may be thought of as representing a resurgence of the pen plotter
    with just one additional axis of motion. And a fancier pen.
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ll present a high-level class that abstracts the key characteristics of a
    series of such plotters made by different vendors. It would be used, for example,
    in an analytical or data-exploration program to draw colorful charts showing the
    relationships found in data. But I don’t want my main program to worry about the
    gory details of any particular brand of plotter, so I’ll abstract into a `Plotter`
    class, whose source is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*main/src/main/java/plotter/Plotter.java*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Note the variety of abstract methods. Those related to motion, pen control,
    or drawing are left abstract, due to the number of different ways of implementing
    motion on radically different devices. However, the method for drawing a rectangle
    (`drawBox`) has a default implementation, which simply puts the currently selected
    pen onto the paper at the last-moved-to location, draws the four sides, and raises
    the pen. Subclasses for smarter plotters will likely override this method, but
    subclasses for less-evolved plotters will probably use the default version. This
    method also has two overloaded convenience methods for cases where the client
    has an AWT Dimension for the size or an AWT Rectangle for the location and size.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate one of the subclasses of this program, consider the following
    simple driver program. This is intended to simulate a larger graphics application
    such as gnuplot. The `Class.forName()` near the beginning of `main` is discussed
    in [Recipe 17.2](ch17.html#javacook-reflection-SECT-2); for now, you can take
    my word that it simply creates an instance of the given subclass, which we store
    in a `Plotter` reference named `r` and use to draw the plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '*main/src/main/java/plotter/PlotDriver.java*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: We don’t show any actual subclasses of this `Plotter` class in upcoming chapters,
    however there is a PlotterAWT proof-of-concept in the same source folder, and
    one could implement this for PostScript, PDF, or other output technologies.
  prefs: []
  type: TYPE_NORMAL
- en: '^([1](ch08.html#idm45290664734344-marker)) A value class is one used mainly
    to hold state, rather than logic: a `Person` is a value class, whereas `java.lang.Math`
    is not. Many classes are somewhere in between.'
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch08.html#idm45290663675912-marker)) Of course these lights wouldn’t have
    remote power-off. But the computers might, for maintenance purposes.
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch08.html#idm45290663297016-marker)) For Java folks not that familiar
    with C/C++, C is the older, non-OO language; C++ is an OO derivative of C; and
    Java is in part a portable, more strongly typesafe derivative of C++.
  prefs: []
  type: TYPE_NORMAL
