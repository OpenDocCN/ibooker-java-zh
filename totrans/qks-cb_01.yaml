- en: Chapter 1\. Quarkus Overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kubernetes is becoming the de facto platform to deploy our enterprise applications
    nowadays. The movement to containers and Kubernetes has led to changes in the
    way we code, deploy, and maintain our Java-based applications. You can easily
    get yourself in trouble if you containerize and run a Java application without
    taking proper measures. Containers in Pods (a Kubernetes term) are the basic units
    in Kubernetes, so it is very important to have a good understanding of how to
    containerize a Java-based application correctly to avoid pitfalls, wasted work,
    and extra hours of frustration.
  prefs: []
  type: TYPE_NORMAL
- en: Quarkus is a cloud-native framework with built-in Kubernetes integration. It
    is an open source stack, released under the Apache License 2.0, that helps you
    create Kubernetes-native applications tailored for GraalVM and OpenJDK HotSpot.
    It is built on top of popular libraries and technologies such as Hibernate, Eclipse
    MicroProfile, Kubernetes, Apache Camel, and Eclipse Vert.x.
  prefs: []
  type: TYPE_NORMAL
- en: The benefits of Quarkus include easy integration with Docker and Kubernetes,
    quick startup time, low resident set size (RSS) memory, and increased developer
    productivity. In this introductory chapter, we’ll take a quick look Quarkus—what
    it is, the problems it solves, how it integrates with Kubernetes, why developers
    enjoy working with it, and some of its most noteworthy features.
  prefs: []
  type: TYPE_NORMAL
- en: Developer-Friendly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Quarkus allows you, the Java developer, to be more productive, and it helps
    you stay relevant in the fast-paced area of microservices and cloud-based applications.
  prefs: []
  type: TYPE_NORMAL
- en: Quarkus will enable your applications to scale better, to more tightly fill
    up a Kubernetes cluster utilizing fewer resources overall, and to make use of
    decades of community work in open source Java.
  prefs: []
  type: TYPE_NORMAL
- en: To start developing with Quarkus, you won’t need to learn a new technology.
    If you’re already familiar with dependency injection, JAX-RS, Hibernate, and Eclipse
    MicroProfile concepts, there’s nothing new here. All the knowledge you have built
    up over the course of your career will map directly into Quarkus. Whereas it might
    take weeks to learn other frameworks, you can get started with Quarkus and be
    productive in a matter of days or even hours.
  prefs: []
  type: TYPE_NORMAL
- en: Quarkus is designed to be an optimized choice for the next generation of application
    development and deployment. It supports you through the entire application life
    cycle from application scaffolding and live reloading in dev mode (a save-and-refresh
    workflow), all the way through to deployment in a cloud-based Kubernetes cluster.
    As a developer, Quarkus will keep you productive and solving problems, instead
    of shaving yaks.
  prefs: []
  type: TYPE_NORMAL
- en: Integration with Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We said that Quarkus is meant to run within Kubernetes. That sounds great, but
    we know lots of things can run within Kubernetes. Throw your application in a
    Docker container, and it will run on Kubernetes. While this is true, there are
    a number of things that traditionally have to be done to properly tune, size,
    and configure your application to run efficiently within Kubernetes. You also
    have to pull out your text editor of choice and craft multiple YAML files—and
    let’s be honest, no one really enjoys doing all that.
  prefs: []
  type: TYPE_NORMAL
- en: Quarkus eliminates that work by having a number of enhancements for deploying
    to and using Kubernetes with your application. When you bootstrap a Quarkus application,
    it comes with some Dockerfile files used to generate the Docker containers for
    your application. That is a great first step. These files are optimized for running
    with the OpenJDK JVM or running as native executables with GraalVM. They contain
    what is necessary to run the application, thereby eliminating as much duplication
    and unnecessary bloat from the container image as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Next, when you use the Kubernetes extensions, Quarkus can generate the resources
    (YAML files) for a vanilla Kubernetes or OpenShift deployment! No more having
    to wade through YAML files and make sure you have the right indentation. After
    all, you’d prefer to be writing code than looking for that one line of YAML that
    isn’t formatted correctly. Quarkus can also push your image to a registry before
    deploying to the Kubernetes cluster. All of these application images can be further
    enhanced and customized via the Quarkus application configuration, which you’ll
    learn about in [Chapter 4](ch04.xhtml#configuration_chapter). For example, in
    Quarkus 1.4 and later, `ConfigMap` and `Secret`s can be read from the API server—you
    don’t need to mount any of the files in the Pod!
  prefs: []
  type: TYPE_NORMAL
- en: Memory and First Response Time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Quarkus is known as the “supersonic, subatomic” Java framework. That may set
    off marketing alarms with developers, but when you break it down and understand
    what Quarkus is doing, you’ll see that you really are getting a very small, quick,
    and productive execution. With Quarkus, you can deploy a native application optimized
    to be run on Kubernetes. For example, let’s say you want to deploy a native application,
    optimized to be run on Kubernetes, where the container image is around 200 MB
    or smaller. In Quarkus, this application will start up and be ready to accept
    requests within a fraction of a second, and it will use less than 50 MB of memory.
  prefs: []
  type: TYPE_NORMAL
- en: When deploying to a Kubernetes cluster, you want to pack in as many instances
    of your application as possible so you are able to scale to meet unexpected load
    yet still utilize as many of the resources as possible. When scaling up you want
    your new application instances up and running quickly—this is where a native executable
    shines. Quarkus does as much pre-boot of your application and the frameworks it
    uses as possible during the native executable build process. This helps your application
    start quickly and be ready to service requests without having to do additional
    class loading, runtime scanning, or other warm-up the the JVM typically does.
  prefs: []
  type: TYPE_NORMAL
- en: Naturally, available memory is a finite resource. Understanding exactly how
    much memory is being used by your application, and not starving the JVM while
    trying to keep that number low, is key to deployment density. Quarkus succeeds
    in helping you achieve that with the native executable, which is small and memory
    efficient.
  prefs: []
  type: TYPE_NORMAL
- en: A Basic Quarkus Workflow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While reading this book and going through the recipes, you’ll be introduced
    to the Quarkus ecosystem. You’ll learn about extensions, integrations, and design
    decisions. You will also see the basic workflow used throughout to help you be
    productive. In a nutshell, this workflow is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Scaffold
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Launch dev mode
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Code
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Package
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deploy
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Scaffolding your application, or adding an extension to an existing start,
    gives you a solid foundation to build upon. You’ll become familiar with this in
    [Chapter 2](ch02.xhtml#scaffolding_chapter). Following scaffolding, you will be
    asked to run your application in dev mode, which is also introduced in [Chapter 2](ch02.xhtml#scaffolding_chapter).
    You will then learn about typical tasks for an application: creating RESTful services,
    completing the basic programming model, and performing application configuration.
    Dev mode will give you near instant feedback without the bothersome dance of compile,
    package, and deploy that you’ve become familiar with. In [Chapter 5](ch05.xhtml#programming_model)
    you’ll see how to test a Quarkus application that targets both the JVM and native
    executable, giving you reassurance that your application runs correctly and meets
    your standards. Creating the final deliverable is covered in [Chapter 6](ch06.xhtml#packaging_quark_applications_chapter),
    as is learning how to package your application for your particular deployment
    strategy. The last piece of that workflow, deployment, is covered in [Chapter 10](ch10.xhtml#integrating_with_kubernetes_chapter).
    Exploring further, you’ll learn how to make your application more fault resistant,
    how to interact with various persistence engines, and how to communicate with
    external services. We will also explain additional integrations to aid you in
    leveraging existing knowledge from other libraries and programming paradigms.
    We’ll walk you through setting up the Kubernetes optimizations that are necessary
    for your application, building Kubernetes resources, and pushing it all live.'
  prefs: []
  type: TYPE_NORMAL
