<html><head></head><body><section data-pdf-bookmark="Chapter 5. Reactive Programming: &#10;Taming the Asynchronicity" data-type="chapter" epub:type="chapter"><div class="chapter" id="reactive-programming">&#13;
<h1><span class="label">Chapter 5. </span>Reactive Programming: &#13;
<span class="keep-together">Taming the Asynchronicity</span></h1>&#13;
&#13;
&#13;
<p><a data-primary="asynchronous code" data-type="indexterm" id="ix_reactive-programming-adoc0"/>In the previous chapter, we introduced reactive systems and how they elegantly handle the challenges of distributed systems.&#13;
Although never forget that nothing comes for free in the IT world.&#13;
One of the characteristics of reactive systems is the use of nonblocking I/O.&#13;
Nonblocking I/O improves the concurrency, responsiveness, and resource utilization of reactive applications.&#13;
To fully benefit from nonblocking I/O, you must design and develop the code in a nonblocking manner, and that is a not-so-easy challenge.</p>&#13;
&#13;
<p>This chapter explores approaches to writing nonblocking and asynchronous Java code such as callbacks and reactive programming.&#13;
We also cover flow control and Reactive Streams, which is an essential part of modern reactive applications.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Asynchronous Code and Patterns" data-type="sect1"><div class="sect1" id="reactive-programming:async-code-patterns">&#13;
<h1>Asynchronous Code and Patterns</h1>&#13;
&#13;
<p><a data-primary="asynchronous code" data-secondary="basics" data-type="indexterm" id="ix_reactive-programming-adoc1"/><a data-primary="nonblocking I/O" data-secondary="asynchronous code/patterns" data-type="indexterm" id="ix_reactive-programming-adoc2"/>How does nonblocking lead to asynchronous code?&#13;
Remember the design of nonblocking I/O from the preceding chapter.&#13;
It allows using a few threads to handle concurrent network interactions.&#13;
That particular architecture reduces memory consumption but also CPU usage.&#13;
<a data-primary="threads" data-secondary="asynchronous code and" data-type="indexterm" id="ix_reactive-programming-adoc3"/>As a consequence, the application code gets executed by one of these I/O threads, and there are scarce resources.&#13;
If your code unconsciously blocks one of these threads, it would reduce your application’s concurrency and increase the response time, as fewer threads are available to handle the requests.&#13;
In the worst-case scenario, all the I/O threads get blocked, and the application cannot handle requests anymore.&#13;
In other words, the benefits from nonblocking I/O would vanish.</p>&#13;
&#13;
<p>Let’s illustrate this with an example.&#13;
Imagine a <code>greeting</code> service, which takes a name as a parameter and produces a greeting message.&#13;
With a synchronous model, you would invoke that service as shown in <a data-type="xref" href="#reactive-programming::synchronous-code">Example 5-1</a>.</p>&#13;
<div data-type="example" id="reactive-programming::synchronous-code">&#13;
<h5><span class="label">Example 5-1. </span>Example of synchronous code</h5>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="n">String</code> <code class="n">greetings</code> <code class="o">=</code> <code class="n">service</code><code class="o">.</code><code class="na">greeting</code><code class="o">(</code><code class="s">"Luke"</code><code class="o">);</code>&#13;
<code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="n">greetings</code><code class="o">);</code></pre></div>&#13;
&#13;
<p>You call the service, synchronously get the result, and use it on the next line.</p>&#13;
&#13;
<p>Now, let’s imagine that the <code>greeting</code> service is a remote service.&#13;
You could still call it synchronously, but, in this case, you are going to block the thread until the response is received, as depicted in <a data-type="xref" href="#image:synchronous-sequence-diagram">Figure 5-1</a>.</p>&#13;
&#13;
<figure><div class="figure" id="image:synchronous-sequence-diagram">&#13;
<img alt="Synchronous invocation" src="assets/rsij_0501.png"/>&#13;
<h6><span class="label">Figure 5-1. </span>Synchronous invocation</h6>&#13;
</div></figure>&#13;
&#13;
<p>If your code runs on the I/O thread, you block that thread.&#13;
As a consequence, the service cannot handle any other requests while waiting for the response.&#13;
Blocking the I/O thread discards all the advantages of nonblocking I/O.</p>&#13;
&#13;
<p>What can we do?&#13;
That’s simple: we must not block the thread.&#13;
We call the method, and it returns immediately, not <em>waiting</em> for the response.&#13;
But, there is a small problem with this approach: how would you get this response?&#13;
You need to pass some continuation, invoked when the response is received, as shown in <a data-type="xref" href="#reactive-programming::asynchronous-code">Example 5-2</a>.</p>&#13;
<div data-type="example" id="reactive-programming::asynchronous-code">&#13;
<h5><span class="label">Example 5-2. </span>Example of asynchronous code</h5>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="n">service</code><code class="o">.</code><code class="na">greeting</code><code class="o">(</code><code class="s">"Luke"</code><code class="o">,</code> <code class="n">greeting</code> <code class="o">-&gt;</code> <code class="o">{</code>&#13;
    <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="n">greeting</code><code class="o">);</code>&#13;
<code class="o">});</code></pre></div>&#13;
&#13;
<p>In this code snippet, we pass a continuation implemented using a <em>callback</em>, a function invoked with the received result.&#13;
It embraces well the event-driven nature of this code: <code>on result, call that function</code>.&#13;
With this asynchronous model, we release the I/O thread.&#13;
When the response is received, it calls the function with that response and continues the execution.&#13;
During that time, this I/O thread can be used to handle more requests (<a data-type="xref" href="#image:asynchronous-sequence-diagram">Figure 5-2</a>).<a data-startref="ix_reactive-programming-adoc3" data-type="indexterm" id="idm45358830182560"/></p>&#13;
&#13;
<figure><div class="figure" id="image:asynchronous-sequence-diagram">&#13;
<img alt="Asynchronous invocation" src="assets/rsij_0502.png"/>&#13;
<h6><span class="label">Figure 5-2. </span>Asynchronous invocation</h6>&#13;
</div></figure>&#13;
&#13;
<p>Let’s have a deeper look at the preceding code snippet and add some traces by using the good old <code>System.out</code> statements (<a data-type="xref" href="#reactive-programming::asynchronous-code-trace">Example 5-3</a>).</p>&#13;
<div data-type="example" id="reactive-programming::asynchronous-code-trace">&#13;
<h5><span class="label">Example 5-3. </span>Asynchronous code and ordering</h5>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="s">"Before"</code><code class="o">);</code>&#13;
<code class="n">service</code><code class="o">.</code><code class="na">greeting</code><code class="o">(</code><code class="s">"Luke"</code><code class="o">,</code> <code class="n">greeting</code> <code class="o">-&gt;</code> <code class="o">{</code>&#13;
    <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="n">greeting</code><code class="o">);</code>&#13;
<code class="o">});</code>&#13;
<code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="s">"After"</code><code class="o">);</code></pre></div>&#13;
&#13;
<p>What would be the output of this program?&#13;
For sure, <code>Before</code> is printed first, but what about the greeting message and <code>After</code>?&#13;
Which one would be first?&#13;
There is a good chance that <code>After</code> is printed first because invoking the <code>greeting</code> service takes at least a few milliseconds (remember, it’s a remote service).&#13;
This means that with asynchronous code, the next line often is executed before the <em>continuation</em>.</p>&#13;
&#13;
<p>What does that mean in practice?&#13;
Let’s imagine you want to call the <code>greeting</code> service twice, once for Luke and once for Leia; see <a data-type="xref" href="#reactive-programming::asynchronous-code-calls">Example 5-4</a>.</p>&#13;
<div data-type="example" id="reactive-programming::asynchronous-code-calls">&#13;
<h5><span class="label">Example 5-4. </span>Calling asynchronous methods twice</h5>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="n">service</code><code class="o">.</code><code class="na">greeting</code><code class="o">(</code><code class="s">"Leia"</code><code class="o">,</code> <code class="n">greeting</code> <code class="o">-&gt;</code> <code class="o">{</code>&#13;
    <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="s">"Leia: "</code> <code class="o">+</code> <code class="n">greeting</code><code class="o">);</code>&#13;
<code class="o">});</code>&#13;
<code class="n">service</code><code class="o">.</code><code class="na">greeting</code><code class="o">(</code><code class="s">"Luke"</code><code class="o">,</code> <code class="n">greeting</code> <code class="o">-&gt;</code> <code class="o">{</code>&#13;
    <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="s">"Luke: "</code> <code class="o">+</code> <code class="n">greeting</code><code class="o">);</code>&#13;
<code class="o">});</code></pre></div>&#13;
&#13;
<p>In this code, we can’t anticipate which message is going to appear first.&#13;
It depends on many factors such as latency, speed, and number of instances of the <code>greeting</code> service.&#13;
However, both calls run concurrently, which is an attractive benefit.</p>&#13;
&#13;
<p>If you want or need a strict order (for example, to call the service for Leia first and then Luke), we need to compose the asynchronous calls (<a data-type="xref" href="#reactive-programming::sequential-composition">Example 5-5</a>).</p>&#13;
<div data-type="example" id="reactive-programming::sequential-composition">&#13;
<h5><span class="label">Example 5-5. </span>Sequential composition pattern</h5>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="n">service</code><code class="o">.</code><code class="na">greeting</code><code class="o">(</code><code class="s">"Leia"</code><code class="o">,</code> <code class="n">greeting1</code> <code class="o">-&gt;</code> <code class="o">{</code>&#13;
    <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="s">"Leia: "</code> <code class="o">+</code> <code class="n">greeting1</code><code class="o">);</code>&#13;
    <code class="n">service</code><code class="o">.</code><code class="na">greeting</code><code class="o">(</code><code class="s">"Luke"</code><code class="o">,</code> <code class="n">greeting2</code> <code class="o">-&gt;</code> <code class="o">{</code>&#13;
        <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="s">"Luke: "</code> <code class="o">+</code> <code class="n">greeting2</code><code class="o">);</code>&#13;
    <code class="o">});</code>&#13;
<code class="o">});</code></pre></div>&#13;
&#13;
<p><a data-primary="sequential composition" data-type="indexterm" id="idm45358830008640"/>With this code, we first call the service with <code>Leia</code>, and when we get the response, call it with <code>Luke</code>.&#13;
The calls don’t run concurrently anymore, but at least we know the order.&#13;
We call this pattern <em>sequential composition</em>.&#13;
It’s quite common, as you can &#13;
<span class="keep-together">imagine</span>.</p>&#13;
&#13;
<p><a data-primary="parallel composition" data-type="indexterm" id="idm45358829937104"/>Let’s continue our investigation with another type of useful composition: <em>parallel composition</em>.&#13;
We want to execute the calls concurrently this time, but we need to pass a continuation invoked when both calls are complete (<a data-type="xref" href="#reactive-programming::parallel-composition">Example 5-6</a>).</p>&#13;
<div data-type="example" id="reactive-programming::parallel-composition">&#13;
<h5><span class="label">Example 5-6. </span>Simplified parallel composition pattern</h5>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="n">String</code> <code class="n">resultForLeia</code> <code class="o">=</code> <code class="kc">null</code><code class="o">;</code>&#13;
<code class="n">String</code> <code class="n">resultForLuke</code> <code class="o">=</code> <code class="kc">null</code><code class="o">;</code>&#13;
<code class="n">BiConsumer</code><code class="o">&lt;</code><code class="n">String</code><code class="o">,</code> <code class="n">String</code><code class="o">&gt;</code> <code class="n">continuation</code> <code class="o">=</code> <code class="o">...;</code>&#13;
&#13;
<code class="n">service</code><code class="o">.</code><code class="na">greeting</code><code class="o">(</code><code class="s">"Leia"</code><code class="o">,</code> <code class="n">greeting</code> <code class="o">-&gt;</code> <code class="o">{</code>&#13;
    <code class="n">resultForLeia</code> <code class="o">=</code> <code class="n">greeting</code><code class="o">;</code>&#13;
    <code class="k">if</code> <code class="o">(</code><code class="n">resultForLuke</code> <code class="o">!=</code> <code class="kc">null</code><code class="o">)</code> <code class="o">{</code>&#13;
        <code class="n">continuation</code><code class="o">.</code><code class="na">accept</code><code class="o">(</code><code class="n">resultForLeia</code><code class="o">,</code> <code class="n">resultForLuke</code><code class="o">);</code>&#13;
    <code class="o">}</code>&#13;
<code class="o">});</code>&#13;
<code class="n">service</code><code class="o">.</code><code class="na">greeting</code><code class="o">(</code><code class="s">"Luke"</code><code class="o">,</code> <code class="n">greeting</code> <code class="o">-&gt;</code> <code class="o">{</code>&#13;
    <code class="n">resultForLuke</code> <code class="o">=</code> <code class="n">greeting</code><code class="o">;</code>&#13;
    <code class="k">if</code> <code class="o">(</code><code class="n">resultForLeia</code> <code class="o">!=</code> <code class="kc">null</code><code class="o">)</code> <code class="o">{</code>&#13;
        <code class="n">continuation</code><code class="o">.</code><code class="na">accept</code><code class="o">(</code><code class="n">resultForLeia</code><code class="o">,</code> <code class="n">resultForLuke</code><code class="o">);</code>&#13;
    <code class="o">}</code>&#13;
    <code class="o">});</code>&#13;
<code class="o">});</code></pre></div>&#13;
&#13;
<p>It starts to be a bit more convoluted, and this code is not totally correct, as you can have race conditions if both callbacks are invoked concurrently.&#13;
We need to store the results, check if they are non-null, and invoke the continuation function.</p>&#13;
&#13;
<p>We have slightly forgotten another aspect: failures.&#13;
It’s not because it’s an asynchronous API that failures don’t happen.&#13;
You cannot use <code>try/catch</code> blocks anymore, as the failure can also happen asynchronously; see <a data-type="xref" href="#reactive-programming::asynchronous-code-try-catch">Example 5-7</a>.</p>&#13;
<div data-type="example" id="reactive-programming::asynchronous-code-try-catch">&#13;
<h5><span class="label">Example 5-7. </span>Would this <code>try</code>/<code>catch</code> work as intended?</h5>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="k">try</code> <code class="o">{</code>&#13;
    <code class="n">service</code><code class="o">.</code><code class="na">greeting</code><code class="o">(</code><code class="s">"Luke"</code><code class="o">,</code> <code class="n">greeting</code> <code class="o">-&gt;</code> <code class="o">{</code>&#13;
        <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="n">greeting</code><code class="o">);</code>&#13;
    <code class="o">});</code>&#13;
<code class="o">}</code> <code class="k">catch</code> <code class="o">(</code><code class="n">Exception</code> <code class="n">e</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="c1">// does not handle the exception thrown by the remote service</code>&#13;
<code class="o">}</code></pre></div>&#13;
&#13;
<p>The <code>catch</code> block would catch only synchronous exceptions.&#13;
If the service produces a failure asynchronously, like the inability to produce the greeting message, this <code>try/catch</code> is useless.&#13;
To handle failures, we need to have a proper construct for it.&#13;
We can imagine two <em>simple</em> ways:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Use an asynchronous result construct encapsulating both the result and the failure.</p>&#13;
</li>&#13;
<li>&#13;
<p>Have a second callback for failures.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>With the first approach, you would need something like <a data-type="xref" href="#reactive-programming::asynchronous-result">Example 5-8</a>.</p>&#13;
<div data-type="example" id="reactive-programming::asynchronous-result">&#13;
<h5><span class="label">Example 5-8. </span>Use asynchronous result encapsulating both result and failure</h5>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="n">service</code><code class="o">.</code><code class="na">greeting</code><code class="o">(</code><code class="s">"Luke"</code><code class="o">,</code> <code class="n">greeting</code> <code class="o">-&gt;</code> <code class="o">{</code>&#13;
    <code class="k">if</code> <code class="o">(</code><code class="n">greeting</code><code class="o">.</code><code class="na">failed</code><code class="o">())</code> <code class="o">{</code>&#13;
        <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="s">"D'oh! "</code> <code class="o">+</code> <code class="n">greeting</code><code class="o">.</code><code class="na">failure</code><code class="o">().</code><code class="na">getMessage</code><code class="o">());</code>&#13;
    <code class="o">}</code> <code class="k">else</code> <code class="o">{</code>&#13;
        <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="n">greeting</code><code class="o">.</code><code class="na">result</code><code class="o">());</code>&#13;
    <code class="o">}</code>&#13;
<code class="o">});</code></pre></div>&#13;
&#13;
<p><code>greeting</code> is not a <code>String</code> anymore but a type encapsulating the operation’s outcome.<sup><a data-type="noteref" href="ch05.html#idm45358829664160" id="idm45358829664160-marker">1</a></sup>&#13;
You need to check whether the operation failed or succeeded and act accordingly.&#13;
You can quickly imagine how this would impact our previous composition examples.&#13;
At that level, it’s not challenging; it’s a nightmare!</p>&#13;
&#13;
<p>The second approach uses two callbacks: the first one when the operation succeeded, and the second one when it failed (<a data-type="xref" href="#reactive-programming::onSuccess_onError">Example 5-9</a>).</p>&#13;
<div data-type="example" id="reactive-programming::onSuccess_onError">&#13;
<h5><span class="label">Example 5-9. </span>Use different continuations for each outcome</h5>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="n">service</code><code class="o">.</code><code class="na">greeting</code><code class="o">(</code><code class="s">"Luke"</code><code class="o">,</code>&#13;
        <code class="n">greeting</code> <code class="o">-&gt;</code> <code class="o">{</code>&#13;
            <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="n">greeting</code><code class="o">);</code>&#13;
        <code class="o">},</code>&#13;
        <code class="n">failure</code> <code class="o">-&gt;</code> <code class="o">{</code>&#13;
            <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="s">"D'oh! "</code> <code class="o">+</code> <code class="n">failure</code><code class="o">.</code><code class="na">getMessage</code><code class="o">());</code>&#13;
        <code class="o">}</code>&#13;
<code class="o">);</code></pre></div>&#13;
&#13;
<p>This approach clearly distinguishes the two cases, but again, it makes composition harder (<a data-type="xref" href="#reactive-programming::onSuccess_onError_composition">Example 5-10</a>).</p>&#13;
<div data-type="example" id="reactive-programming::onSuccess_onError_composition">&#13;
<h5><span class="label">Example 5-10. </span>Use multiple continuations and compositing actions</h5>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="n">service</code><code class="o">.</code><code class="na">greeting</code><code class="o">(</code><code class="s">"Leia"</code><code class="o">,</code>&#13;
        <code class="n">greeting1</code> <code class="o">-&gt;</code> <code class="o">{</code>&#13;
            <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="n">greeting1</code><code class="o">);</code>&#13;
            <code class="n">service</code><code class="o">.</code><code class="na">greeting</code><code class="o">(</code><code class="s">"Luke"</code><code class="o">,</code>&#13;
                    <code class="n">greeting2</code> <code class="o">-&gt;</code> <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="n">greeting2</code><code class="o">),</code>&#13;
                    <code class="n">failure2</code> <code class="o">-&gt;</code> <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="s">"D'oh! "</code> <code class="o">+</code> <code class="n">failure2</code><code class="o">.</code><code class="na">getMessage</code><code class="o">())</code>&#13;
            <code class="o">);</code>&#13;
        <code class="o">},</code>&#13;
        <code class="n">failure1</code> <code class="o">-&gt;</code> <code class="o">{</code>&#13;
            <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="s">"D'oh! "</code> <code class="o">+</code> <code class="n">failure1</code><code class="o">.</code><code class="na">getMessage</code><code class="o">());</code>&#13;
        <code class="o">}</code>&#13;
<code class="o">);</code></pre></div>&#13;
&#13;
<p>It’s not simple, right?&#13;
However, this second approach has an advantage.&#13;
If we imagine having a <code>greeting</code> service accepting multiple names, it is well suited to handle sequential responses (<a data-type="xref" href="#reactive-programming::first_stream">Example 5-11</a>).</p>&#13;
<div data-type="example" id="reactive-programming::first_stream">&#13;
<h5><span class="label">Example 5-11. </span>Multiple results for a single operation</h5>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="n">service</code><code class="o">.</code><code class="na">greeting</code><code class="o">(</code><code class="n">Arrays</code><code class="o">.</code><code class="na">asList</code><code class="o">(</code><code class="s">"Leia"</code><code class="o">,</code> <code class="s">"Luke"</code><code class="o">),</code>&#13;
        <code class="n">greeting</code> <code class="o">-&gt;</code> <code class="o">{</code>    <code class="c1">// Called once for Leia, and once for Luke</code>&#13;
            <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="n">greeting</code><code class="o">);</code>&#13;
        <code class="o">},</code>&#13;
        <code class="n">failure</code> <code class="o">-&gt;</code> <code class="o">{</code>&#13;
            <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="s">"D'oh! "</code> <code class="o">+</code> <code class="n">failure</code><code class="o">.</code><code class="na">getMessage</code><code class="o">());</code>&#13;
        <code class="o">}</code>&#13;
<code class="o">);</code></pre></div>&#13;
&#13;
<p>This example starts exhibiting a new construct: streams of data.&#13;
You will see a lot more of these in this book.&#13;
These streams can be internal to the application or convey messages coming from a message broker.&#13;
In this chapter, we consider only streams internal to the reactive applications. We will cover how these streams can be connected to various message brokers in <a data-type="xref" href="ch11.html#event-bus">Chapter 11</a>.</p>&#13;
&#13;
<p>In Java, to express your continuation using callbacks, we often use Java 8 Lambdas.&#13;
They are well integrated in the language, but we have also seen the limit of that approach.&#13;
Callbacks do not compose well.&#13;
So we need a higher-level construct.&#13;
Any seasoned developers would say future!<a data-startref="ix_reactive-programming-adoc2" data-type="indexterm" id="idm45358829414080"/><a data-startref="ix_reactive-programming-adoc1" data-type="indexterm" id="idm45358829413392"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Using Futures" data-type="sect1"><div class="sect1" id="idm45358830256192">&#13;
<h1>Using Futures</h1>&#13;
&#13;
<p><a data-primary="asynchronous code" data-secondary="futures" data-type="indexterm" id="idm45358829412192"/><a data-primary="futures" data-type="indexterm" id="idm45358829411248"/>A <em>future</em> is a placeholder for a value resolved later.&#13;
By nature, it’s asynchronous; you don’t know when the future will get the value.&#13;
It’s just <em>later</em>.&#13;
When the value gets set, the future allows <em>reacting</em> on it—for example, transforming the value, implementing side effects, and so forth.</p>&#13;
&#13;
<p>How does it help our asynchronous code concern?&#13;
<a data-primary="CompletionStage" data-type="indexterm" id="idm45358829408240"/>In Java, <code>CompletableFuture</code>, or <code>CompletionStage</code>, the associated interface, can represent the result of an asynchronous action.&#13;
Your API returns a <code>CompletionStage</code> object, which gets the result when the operation completes.&#13;
The method returning the <code>CompletionStage</code> object returns immediately, and so does not block the caller thread, and the continuation can be attached to the returned <code>CompletionStage</code>; see <a data-type="xref" href="#reactive-programming::future">Example 5-12</a>.</p>&#13;
<div data-type="example" id="reactive-programming::future">&#13;
<h5><span class="label">Example 5-12. </span>Example of <code>CompletionStage</code> (<em>chapter-5/reactive-programming-examples/src/main/java/org/acme/future/Futures.java</em>)</h5>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="n">CompletionStage</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code> <code class="n">future</code> <code class="o">=</code> <code class="n">service</code><code class="o">.</code><code class="na">greeting</code><code class="o">(</code><code class="s">"Luke"</code><code class="o">);</code></pre></div>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>The full examples from this section are located in <em>chapter-5/reactive-programming-examples/src/main/java/org/acme/future/Futures.java</em>.</p>&#13;
</div>&#13;
&#13;
<p>The continuation can be divided into a set of <em>stages</em> to process, consume, and transform the results, as shown in <a data-type="xref" href="#reactive-programming::future-chain">Example 5-13</a>.</p>&#13;
<div data-type="example" id="reactive-programming::future-chain">&#13;
<h5><span class="label">Example 5-13. </span>Chaining operation with <code>CompletionStage</code> (<em>chapter-5/reactive-programming-examples/src/main/java/org/acme/future/Futures.java</em>)</h5>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="n">service</code><code class="o">.</code><code class="na">greeting</code><code class="o">(</code><code class="s">"Luke"</code><code class="o">)</code>&#13;
        <code class="o">.</code><code class="na">thenApply</code><code class="o">(</code><code class="n">response</code> <code class="o">-&gt;</code> <code class="n">response</code><code class="o">.</code><code class="na">toUpperCase</code><code class="o">())</code>&#13;
        <code class="o">.</code><code class="na">thenAccept</code><code class="o">(</code><code class="n">greeting</code> <code class="o">-&gt;</code> <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="n">greeting</code><code class="o">));</code></pre></div>&#13;
&#13;
<p>Futures also ease the implementation of sequential composition.&#13;
With the &#13;
<span class="keep-together"><code>CompletionStage</code></span> API, you can use <code>thenCompose</code> to invoke a second operation (as seen in <a data-type="xref" href="#reactive-programming::future-sequential-composition">Example 5-14</a>).</p>&#13;
<div data-type="example" id="reactive-programming::future-sequential-composition">&#13;
<h5><span class="label">Example 5-14. </span>Sequential composition with <code>CompletionStage</code> (<em>chapter-5/reactive-programming-examples/src/main/java/org/acme/future/Futures.java</em>)</h5>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="n">service</code><code class="o">.</code><code class="na">greeting</code><code class="o">(</code><code class="s">"Luke"</code><code class="o">)</code>&#13;
    <code class="o">.</code><code class="na">thenCompose</code><code class="o">(</code><code class="n">greetingForLuke</code> <code class="o">-&gt;</code> <code class="o">{</code>&#13;
        <code class="k">return</code> <code class="n">service</code><code class="o">.</code><code class="na">greeting</code><code class="o">(</code><code class="s">"Leia"</code><code class="o">)</code>&#13;
                <code class="o">.</code><code class="na">thenApply</code><code class="o">(</code><code class="n">greetingForLeia</code> <code class="o">-&gt;</code>&#13;
                        <code class="n">Tuple2</code><code class="o">.</code><code class="na">of</code><code class="o">(</code><code class="n">greetingForLuke</code><code class="o">,</code> <code class="n">greetingForLeia</code><code class="o">)</code>&#13;
                <code class="o">);</code>&#13;
    <code class="o">})</code>&#13;
    <code class="o">.</code><code class="na">thenAccept</code><code class="o">(</code><code class="n">tuple</code> <code class="o">-&gt;</code>&#13;
            <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="n">tuple</code><code class="o">.</code><code class="na">getItem1</code><code class="o">()</code> <code class="o">+</code> <code class="s">" "</code> <code class="o">+</code> <code class="n">tuple</code><code class="o">.</code><code class="na">getItem2</code><code class="o">())</code>&#13;
    <code class="o">);</code></pre></div>&#13;
&#13;
<p>The <code>allOf</code> method allows implementing parallel composition; see <a data-type="xref" href="#reactive-programming::future-parallel-composition">Example 5-15</a>.</p>&#13;
<div data-type="example" id="reactive-programming::future-parallel-composition">&#13;
<h5><span class="label">Example 5-15. </span>Parallel composition with <code>CompletableFuture</code> (<em>chapter-5/reactive-programming-examples/src/main/java/org/acme/future/Futures.java</em>)</h5>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="n">CompletableFuture</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code> <code class="n">luke</code> <code class="o">=</code> <code class="n">service</code><code class="o">.</code><code class="na">greeting</code><code class="o">(</code><code class="s">"Luke"</code><code class="o">).</code><code class="na">toCompletableFuture</code><code class="o">();</code>&#13;
<code class="n">CompletableFuture</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code> <code class="n">leia</code> <code class="o">=</code> <code class="n">service</code><code class="o">.</code><code class="na">greeting</code><code class="o">(</code><code class="s">"Leia"</code><code class="o">).</code><code class="na">toCompletableFuture</code><code class="o">();</code>&#13;
&#13;
<code class="n">CompletableFuture</code><code class="o">.</code><code class="na">allOf</code><code class="o">(</code><code class="n">luke</code><code class="o">,</code> <code class="n">leia</code><code class="o">)</code>&#13;
        <code class="o">.</code><code class="na">thenAccept</code><code class="o">(</code><code class="n">ignored</code> <code class="o">-&gt;</code> <code class="o">{</code>&#13;
            <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="n">luke</code><code class="o">.</code><code class="na">join</code><code class="o">()</code> <code class="o">+</code> <code class="s">" "</code> <code class="o">+</code> <code class="n">leia</code><code class="o">.</code><code class="na">join</code><code class="o">());</code>&#13;
        <code class="o">});</code></pre></div>&#13;
&#13;
<p>Futures make composing asynchronous actions much more straightforward than callbacks.&#13;
Besides, futures encapsulate both the result and failure.&#13;
In <code>CompletionStage</code>, specific methods handle failure and recover, as you can see in <a data-type="xref" href="#reactive-programming::future-failure-management">Example 5-16</a>.</p>&#13;
<div data-type="example" id="reactive-programming::future-failure-management">&#13;
<h5><span class="label">Example 5-16. </span>Recover from failure with the <code>CompletionStage</code> API (<em>chapter-5/reactive-programming-examples/src/main/java/org/acme/future/Futures.java</em>)</h5>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="n">service</code><code class="o">.</code><code class="na">greeting</code><code class="o">(</code><code class="s">"Leia"</code><code class="o">)</code>&#13;
        <code class="o">.</code><code class="na">exceptionally</code><code class="o">(</code><code class="n">exception</code> <code class="o">-&gt;</code> <code class="s">"Hello"</code><code class="o">);</code></pre></div>&#13;
&#13;
<p><a data-primary="pipelines" data-type="indexterm" id="idm45358829105616"/>When using <code>CompletionStage</code>, we start seeing the creation of <em>pipelines</em>: a sequence of operations handling events and asynchronous results.</p>&#13;
&#13;
<p>You may be wondering, what’s missing?&#13;
Futures seem to tick all the boxes.&#13;
But one tick is missing: streams.&#13;
Futures do not handle streams of data well.&#13;
They can be used for operations returning single values, but they won’t work for functions returning sequences as in <a data-type="xref" href="#reactive-programming::first_stream">Example 5-11</a>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Project Loom: Virtual Threads and Carrier Threads" data-type="sect1"><div class="sect1" id="idm45358830255600">&#13;
<h1>Project Loom: Virtual Threads and Carrier Threads</h1>&#13;
&#13;
<p><a data-primary="asynchronous code" data-secondary="Project Loom" data-type="indexterm" id="ix_reactive-programming-adoc4"/><a data-primary="carrier threads" data-type="indexterm" id="ix_reactive-programming-adoc5"/><a data-primary="Loom" data-type="indexterm" id="ix_reactive-programming-adoc6"/><a data-primary="Project Loom" data-type="indexterm" id="ix_reactive-programming-adoc7"/><a data-primary="threads" data-secondary="carrier" data-type="indexterm" id="ix_reactive-programming-adoc8"/><a data-primary="threads" data-secondary="virtual" data-type="indexterm" id="ix_reactive-programming-adoc9"/><a data-primary="virtual threads" data-type="indexterm" id="ix_reactive-programming-adoc10"/>If you follow the news around Java, you may have heard about <a href="https://oreil.ly/vuLzu">Project Loom</a>.&#13;
Loom adds the concept of <em>virtual threads</em> into Java.&#13;
Unlike regular threads, virtual threads are lightweight.&#13;
A single carrier thread, a regular OS thread, can execute many virtual threads, potentially millions.&#13;
Loom (the JVM) manages the scheduling of these virtual threads, while the operating system manages the carrier thread’s scheduling.</p>&#13;
&#13;
<p>One benefit is that you can execute blocking code in a virtual thread; it does not block the carrier thread.&#13;
When a virtual thread executes a blocking call, such as an I/O call, the Loom scheduler, managing the virtual threads, parks that virtual thread and runs another virtual thread.&#13;
So the carrier thread is not blocked and is used to execute this other virtual thread.&#13;
That does smell good, right?</p>&#13;
&#13;
<p>In other words, you can write blocking code using a synchronous syntax without having to take care of the continuation.&#13;
Loom handles that for you!&#13;
Even better: because virtual threads are lightweight, you don’t need thread pools anymore; you can create new ones on the fly.</p>&#13;
&#13;
<p>However, at the time of writing, the Loom project is still incubating.<sup><a data-type="noteref" href="ch05.html#idm45358829062432" id="idm45358829062432-marker">2</a></sup>&#13;
The following code snippets may slightly change as the API is still evolving.&#13;
Besides, some concurrency or blocking constructs are not yet supported, and you may unintentionally block the carrier threads, which, as you can imagine, can be catastrophic.</p>&#13;
&#13;
<p>But, to give some ideas, let’s see how we could use our <code>greeting</code> service in a Loom world.&#13;
First, the <code>greeting</code> service implementation can be blocking and use blocking I/O to interact with a remote service.&#13;
If the call is executed on a virtual thread, it does not block the carrier thread, which can execute another virtual thread.&#13;
Loom replaces the blocking I/O calls with a nonblocking I/O and parks the virtual thread until the response is received.&#13;
When the response is available, the parked virtual thread can continue its execution with the result.&#13;
From the developer point of view, it’s all synchronous, but under the hood it’s not; see <a data-type="xref" href="#reactive-programming::loom-simple">Example 5-17</a>.</p>&#13;
<div data-type="example" id="reactive-programming::loom-simple">&#13;
<h5><span class="label">Example 5-17. </span>Create a virtual thread</h5>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="n">Thread</code><code class="o">.</code><code class="na">startVirtualThread</code><code class="o">(()</code> <code class="o">-&gt;</code> <code class="o">{</code>&#13;
    <code class="c1">// We are running on a virtual thread.</code>&#13;
    <code class="c1">// The service may use blocking I/O, the virtual thread would be parked.</code>&#13;
    <code class="n">String</code> <code class="n">response</code> <code class="o">=</code> <code class="n">service</code><code class="o">.</code><code class="na">greeting</code><code class="o">(</code><code class="s">"Luke"</code><code class="o">);</code>&#13;
    <code class="c1">// Once the response is received, the virtual thread can continue its execution.</code>&#13;
    <code class="c1">// The carrier thread has not been blocked.</code>&#13;
    <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="n">response</code><code class="o">);</code>&#13;
<code class="o">});</code></pre></div>&#13;
&#13;
<p>As you can see, it’s pure synchronous code.&#13;
As a consequence, the sequential composition is remarkably simple (<a data-type="xref" href="#reactive-programming::loom-sequential-composition">Example 5-18</a>).</p>&#13;
<div data-type="example" id="reactive-programming::loom-sequential-composition">&#13;
<h5><span class="label">Example 5-18. </span>Sequential composition with Loom</h5>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="n">Thread</code><code class="o">.</code><code class="na">startVirtualThread</code><code class="o">(()</code> <code class="o">-&gt;</code> <code class="o">{</code>&#13;
    <code class="n">String</code> <code class="n">response1</code> <code class="o">=</code> <code class="n">service</code><code class="o">.</code><code class="na">greeting</code><code class="o">(</code><code class="s">"Luke"</code><code class="o">);</code>&#13;
    <code class="n">String</code> <code class="n">response2</code> <code class="o">=</code> <code class="n">service</code><code class="o">.</code><code class="na">greeting</code><code class="o">(</code><code class="s">"Leia"</code><code class="o">);</code>&#13;
    <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="s">"Luke: "</code> <code class="o">+</code> <code class="n">response1</code><code class="o">);</code>&#13;
    <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="s">"Leia: "</code> <code class="o">+</code> <code class="n">response2</code><code class="o">);</code>&#13;
<code class="o">});</code></pre></div>&#13;
&#13;
<p>It’s not different from what you would use in a traditional application.&#13;
Don’t forget that the virtual thread is suspended and resumes multiple times.&#13;
But, again, the carrier thread is not.</p>&#13;
&#13;
<p>Failure management can use <code>try/catch</code> as, again, you use synchronous code.&#13;
If the call to the service fails, the failure is thrown as a regular exception (<a data-type="xref" href="#reactive-programming::loom-failure">Example 5-19</a>).</p>&#13;
<div data-type="example" id="reactive-programming::loom-failure">&#13;
<h5><span class="label">Example 5-19. </span>Exception handling with Loom</h5>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="n">Thread</code><code class="o">.</code><code class="na">startVirtualThread</code><code class="o">(()</code> <code class="o">-&gt;</code> <code class="o">{</code>&#13;
    <code class="k">try</code> <code class="o">{</code>&#13;
        <code class="n">String</code> <code class="n">response</code> <code class="o">=</code> <code class="n">service</code><code class="o">.</code><code class="na">greeting</code><code class="o">(</code><code class="s">"Luke"</code><code class="o">);</code>&#13;
        <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="s">"Luke: "</code> <code class="o">+</code> <code class="n">response</code><code class="o">);</code>&#13;
    <code class="o">}</code> <code class="k">catch</code> <code class="o">(</code><code class="n">Exception</code> <code class="n">e</code><code class="o">)</code> <code class="o">{</code>&#13;
        <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="s">"Failed"</code><code class="o">);</code>&#13;
    <code class="o">}</code>&#13;
<code class="o">});</code></pre></div>&#13;
&#13;
<p>Unfortunately, Loom does not offer any specific construct for parallel composition.&#13;
You need to use the same approach as for <code>CompletableFuture</code>, as shown in <a data-type="xref" href="#reactive-programming::loom-parallel-composition">Example 5-20</a>.</p>&#13;
<div data-type="example" id="reactive-programming::loom-parallel-composition">&#13;
<h5><span class="label">Example 5-20. </span>Parallel composition with Loom</h5>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="n">ExecutorService</code> <code class="n">executor</code> <code class="o">=</code> <code class="n">Executors</code><code class="o">.</code><code class="na">newUnboundedVirtualThreadExecutor</code><code class="o">();</code>&#13;
<code class="n">CompletableFuture</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code> <code class="n">future1</code> <code class="o">=</code> <code class="n">executor</code><code class="o">.</code><code class="na">submitTask</code><code class="o">(()</code>&#13;
    <code class="o">-&gt;</code> <code class="n">service</code><code class="o">.</code><code class="na">greeting</code><code class="o">(</code><code class="s">"Luke"</code><code class="o">));</code>&#13;
<code class="n">CompletableFuture</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code> <code class="n">future2</code> <code class="o">=</code> <code class="n">executor</code><code class="o">.</code><code class="na">submitTask</code><code class="o">(()</code>&#13;
    <code class="o">-&gt;</code> <code class="n">service</code><code class="o">.</code><code class="na">greeting</code><code class="o">(</code><code class="s">"Leia"</code><code class="o">));</code>&#13;
&#13;
<code class="n">Thread</code><code class="o">.</code><code class="na">startVirtualThread</code><code class="o">(()</code> <code class="o">-&gt;</code> <code class="o">{</code>&#13;
    <code class="n">CompletableFuture</code><code class="o">.</code><code class="na">allOf</code><code class="o">(</code><code class="n">future1</code><code class="o">,</code> <code class="n">future2</code><code class="o">).</code><code class="na">thenAccept</code><code class="o">(</code><code class="n">v</code> <code class="o">-&gt;</code> <code class="o">{</code>&#13;
        <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="s">"Luke: "</code> <code class="o">+</code> <code class="n">future1</code><code class="o">.</code><code class="na">join</code><code class="o">());</code>&#13;
        <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="s">"Leia: "</code> <code class="o">+</code> <code class="n">future2</code><code class="o">.</code><code class="na">join</code><code class="o">());</code>&#13;
    <code class="o">});</code>&#13;
<code class="o">});</code></pre></div>&#13;
&#13;
<p>Sounds magic, right?&#13;
But, you see it coming; there is a catch…</p>&#13;
&#13;
<p>While you write synchronous code and do not block the carrier thread, I/Os are still happening on I/O threads.&#13;
The carrier threads are not I/O threads (<a data-type="xref" href="#image:loom-thread-switch">Figure 5-3</a>).&#13;
So, there are multiple thread switches that are not free, even if optimized.</p>&#13;
&#13;
<figure><div class="figure" id="image:loom-thread-switch">&#13;
<img alt="Thread switches hapenning under the hood" src="assets/rsij_0503.png"/>&#13;
<h6><span class="label">Figure 5-3. </span>Thread switches happening under the hood</h6>&#13;
</div></figure>&#13;
&#13;
<p>Also, the temptation to create a massive number of virtual threads can lead to complicated execution. Even if virtual threads are lightweight, storing their stacks in memory may lead to unexpected memory consumption.&#13;
It’s like any software using many threads; they can be hard to understand and tune. That’s being said, Loom is promising.&#13;
Does that make Reactive pointless?&#13;
It’s the opposite.&#13;
Loom addresses only the development model, not the architecture concepts behind reactive systems.&#13;
Also, a synchronous model looks attractive but does not accommodate every situation, especially when you need to group events or implement stream-based logic.&#13;
That’s what we cover in the next section: reactive programming.<a data-startref="ix_reactive-programming-adoc10" data-type="indexterm" id="idm45358828708048"/><a data-startref="ix_reactive-programming-adoc9" data-type="indexterm" id="idm45358828707328"/><a data-startref="ix_reactive-programming-adoc8" data-type="indexterm" id="idm45358828706640"/><a data-startref="ix_reactive-programming-adoc7" data-type="indexterm" id="idm45358828705952"/><a data-startref="ix_reactive-programming-adoc6" data-type="indexterm" id="idm45358828705264"/><a data-startref="ix_reactive-programming-adoc5" data-type="indexterm" id="idm45358828704576"/><a data-startref="ix_reactive-programming-adoc4" data-type="indexterm" id="idm45358828703888"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Reactive Programming" data-type="sect1"><div class="sect1" id="reactive-programming::reactive-programming">&#13;
<h1>Reactive Programming</h1>&#13;
&#13;
<p><a data-primary="asynchronous code" data-secondary="reactive programming and" data-type="indexterm" id="ix_reactive-programming-adoc11"/><a data-primary="reactive programming" data-type="indexterm" id="ix_reactive-programming-adoc12"/><a data-primary="reactive programming" data-secondary="basics" data-type="indexterm" id="ix_reactive-programming-adoc13"/>First, what is <em>reactive programming</em>?&#13;
<a data-primary="reactive programming" data-secondary="common definition" data-type="indexterm" id="idm45358828697376"/> A common definition is:</p>&#13;
<blockquote>&#13;
    <p>Reactive programming combines functional programming, the observer pattern, and the iterable pattern.</p>&#13;
    <p data-type="attribution">The <a href="http://reactivex.io">ReactiveX website</a></p>&#13;
</blockquote>&#13;
&#13;
<p>We never found that definition helpful—too many patterns, and it’s hard to clearly convey what reactive programming is about.&#13;
Let’s make another definition, much more straightforward: “Reactive programming is about programming with asynchronous streams.”</p>&#13;
&#13;
<p>That’s it.&#13;
Reactive programming is about streams and, especially, observing them.&#13;
It pushes that idea to its limit: everything is a stream.&#13;
These streams can be seen as a pipe in which <em>events</em> flow.&#13;
We observe the events flowing—such as items, failures, completion, cancellations—and implement side effects (see <a data-type="xref" href="#image:rp-stream">Figure 5-4</a>).</p>&#13;
&#13;
<figure><div class="figure" id="image:rp-stream">&#13;
<img alt="Reactive Programming is about observing streams" src="assets/rsij_0504.png"/>&#13;
<h6><span class="label">Figure 5-4. </span>Reactive programming is about observing streams</h6>&#13;
</div></figure>&#13;
&#13;
<p>Reactive programming is a specialization of the observer pattern in the sense that you observe an object (the stream) and react.&#13;
It’s asynchronous by nature, as you don’t know when the event is going to be seen.&#13;
Yet, reactive programming goes beyond this.&#13;
It provides a toolbox to compose streams and process events.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Streams" data-type="sect2"><div class="sect2" id="idm45358828688416">&#13;
<h2>Streams</h2>&#13;
&#13;
<p><a data-primary="reactive programming" data-secondary="streams and" data-type="indexterm" id="ix_reactive-programming-adoc14"/><a data-primary="streams" data-secondary="reactive programming and" data-type="indexterm" id="ix_reactive-programming-adoc15"/>When using reactive programming, everything—yes, <em>everything</em>—is a stream of items.&#13;
The stock market, user clicks, keystrokes, steps, ticks…&#13;
All these are streams, and it’s easy to see why: they are sequences of individual events.&#13;
So the stream carries every occurrence of this event, and the observer can react.</p>&#13;
&#13;
<p>But reactive programming also considers asynchronous actions, HTTP requests, RPC method invocations, and database insertions or queries as streams.&#13;
So, a stream does not need to carry multiple items; it can contain a single one or even none!&#13;
That is a bit harder to imagine, but it can be powerful.</p>&#13;
&#13;
<p><a data-primary="pipelines" data-type="indexterm" id="idm45358828682448"/>With reactive programming, you structure your code around streams and build chains of transformation, also called <em>pipelines</em>.&#13;
The events flow from the <em>upstream</em> source to the <em>downstream</em> subscriber, traversing each operator and getting &#13;
<span class="keep-together">transformed</span>, processed, filtered, and so on.&#13;
Each operator observes the upstream and produces a new stream.&#13;
But, there is an important point to not miss in this chain.&#13;
You need a final <em>subscriber</em> that subscribes to the last stream and triggers the whole &#13;
<span class="keep-together">computation</span>.&#13;
When this subscription happens, the direct upstream of the final observer subscribes to its own upstream, which subscribes to its upstream, until it reaches the root.</p>&#13;
&#13;
<p>Let’s go back to the idea of a stream.&#13;
As we’ve mentioned, we consider a stream as only internal to the reactive applications.&#13;
These streams are sequences of events ordered in time.&#13;
The order matters.&#13;
You observe them in the emission order.</p>&#13;
&#13;
<p><a data-primary="events" data-secondary="streams and" data-type="indexterm" id="idm45358828676944"/>A stream can emit three types of events&#13;
(<a data-type="xref" href="#image:rp-stream-failure-completion">Figure 5-5</a>):</p>&#13;
<dl>&#13;
<dt>Items</dt>&#13;
<dd>&#13;
<p>The type depends on the stream; it can be a step, a click, or a response from a remote service.</p>&#13;
</dd>&#13;
<dt>Failures</dt>&#13;
<dd>&#13;
<p>Indicate that something bad happened, and no more items will be emitted.</p>&#13;
</dd>&#13;
<dt>Completions</dt>&#13;
<dd>&#13;
<p>Indicate that there are no more items to emit.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<figure><div class="figure" id="image:rp-stream-failure-completion">&#13;
<img alt="Streams can emit three types of events: item, failure and completion" src="assets/rsij_0505.png"/>&#13;
<h6><span class="label">Figure 5-5. </span>Streams can emit three types of events: items, failures, and completions</h6>&#13;
</div></figure>&#13;
&#13;
<p><a data-primary="item (event)" data-type="indexterm" id="idm45358828668160"/>Item is the most frequent type of event.&#13;
As an observer, you get notified every time a new item is transiting in the stream.&#13;
You can react to it, transform it, implement side effects, and so on.</p>&#13;
&#13;
<p><a data-primary="failure (event)" data-type="indexterm" id="idm45358828666864"/>Failure is an error signal.&#13;
It indicates that something <em>terrible</em> happened, and the observed stream cannot recover from it.&#13;
If not handled properly, failures are a terminal event, and no more items will be emitted after a failure.&#13;
You may wonder, why do we need to handle failure?&#13;
Because streams are asynchronous, and if something breaks the source of items, you should be aware of it, and not wait for additional items, as they won’t come.&#13;
As for the other asynchronous development models, you cannot use a <code>try/catch</code> block, so you need to observe failures and react to them. For example, you can log an error or use a fallback item.</p>&#13;
&#13;
<p><a data-primary="completion event" data-type="indexterm" id="idm45358828664352"/>Finally, the completion event is emitted only when observing a bounded stream, as unbounded streams never terminate.&#13;
The event indicates the end of the stream; the source (upstream) is not going to send any more items.</p>&#13;
&#13;
<p>Every time one of these events transit in the observed stream, you, as the observer, get notified.&#13;
You attach functions handling each of them, as shown in <a data-type="xref" href="#reactive-programming::subscription">Example 5-21</a>.</p>&#13;
<div data-type="example" id="reactive-programming::subscription">&#13;
<h5><span class="label">Example 5-21. </span>Subscribe to a stream to receive the events (<em>chapter-5/reactive-programming-examples/src/main/java/org/acme/reactive/StreamsExample.java</em>)</h5>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="n">stream</code>&#13;
        <code class="o">.</code><code class="na">subscribe</code><code class="o">().</code><code class="na">with</code><code class="o">(</code>&#13;
            <code class="n">item</code> <code class="o">-&gt;</code> <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="s">"Received an item: "</code> <code class="o">+</code> <code class="n">item</code><code class="o">),</code>&#13;
            <code class="n">failure</code> <code class="o">-&gt;</code> <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="s">"Oh no! Received a failure: "</code> <code class="o">+</code> <code class="n">failure</code><code class="o">),</code>&#13;
            <code class="o">()</code> <code class="o">-&gt;</code> <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="s">"Received the completion signal"</code><code class="o">)</code>&#13;
<code class="o">);</code></pre></div>&#13;
&#13;
<p><a data-primary="subscription" data-type="indexterm" id="idm45358828654384"/>To observe a stream, you <em>subscribe</em> to it.&#13;
It’s a key concept in reactive programming, as streams are lazy by default.&#13;
Subscribing indicates your interest in the events.&#13;
Without a subscription:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>You won’t receive the items</p>&#13;
</li>&#13;
<li>&#13;
<p>You won’t tell the stream that it needs to operate</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>The second point is important.&#13;
It means that, in general, if no one subscribes to a stream, the stream won’t do anything.&#13;
That may look odd but allows you to save resources and to start the computation only when everything is ready and you actually need the events.<a data-startref="ix_reactive-programming-adoc15" data-type="indexterm" id="idm45358828577776"/><a data-startref="ix_reactive-programming-adoc14" data-type="indexterm" id="idm45358828577008"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Operators" data-type="sect2"><div class="sect2" id="idm45358828687792">&#13;
<h2>Operators</h2>&#13;
&#13;
<p><a data-primary="operators, reactive programming and" data-type="indexterm" id="ix_reactive-programming-adoc16"/><a data-primary="reactive programming" data-secondary="operators" data-type="indexterm" id="ix_reactive-programming-adoc17"/>Although reactive programming is about streams, it would be useless without a toolbox to manipulate these streams.&#13;
Reactive programming libraries offer countless operators that let you create, combine, filter, and transform the object emitted by streams.&#13;
As depicted in <a data-type="xref" href="#image:rp-stream-transform">Figure 5-6</a>, a stream can be used as input to another one.</p>&#13;
&#13;
<figure><div class="figure" id="image:rp-stream-transform">&#13;
<img alt="Example of transform operator" src="assets/rsij_0506.png"/>&#13;
<h6><span class="label">Figure 5-6. </span>Example of transform operator</h6>&#13;
</div></figure>&#13;
&#13;
<p>It’s important to understand that operators return new streams.&#13;
The operator observes the previous stream (named <code>upstream</code>) and creates a new stream by combining their logic and the received events.&#13;
For example, the <code>transform</code> operator from <a data-type="xref" href="#image:rp-stream-transform">Figure 5-6</a> applies a function for each received&#13;
item<sup><a data-type="noteref" href="ch05.html#idm45358828566736" id="idm45358828566736-marker">3</a></sup>&#13;
and emits the result to its <em>downstream</em> subscriber (<a data-type="xref" href="#reactive-programming::transform">Example 5-22</a>).</p>&#13;
<div data-type="example" id="reactive-programming::transform">&#13;
<h5><span class="label">Example 5-22. </span>Transform items (<em>chapter-5/reactive-programming-examples/src/main/java/org/acme/reactive/StreamsExample.java</em>)</h5>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="n">stream</code>&#13;
        <code class="o">.</code><code class="na">onItem</code><code class="o">().</code><code class="na">transform</code><code class="o">(</code><code class="n">circle</code> <code class="o">-&gt;</code> <code class="n">toSquare</code><code class="o">(</code><code class="n">circle</code><code class="o">))</code>&#13;
        <code class="o">.</code><code class="na">subscribe</code><code class="o">().</code><code class="na">with</code><code class="o">(</code>&#13;
            <code class="n">item</code> <code class="o">-&gt;</code> <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="s">"Received a square: "</code> <code class="o">+</code> <code class="n">item</code><code class="o">),</code>&#13;
            <code class="n">failure</code> <code class="o">-&gt;</code> <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="s">"Oh no! Received a failure: "</code> <code class="o">+</code> <code class="n">failure</code><code class="o">),</code>&#13;
            <code class="o">()</code> <code class="o">-&gt;</code> <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="s">"Received the completion signal"</code><code class="o">)</code>&#13;
<code class="o">);</code></pre></div>&#13;
&#13;
<p><a data-primary="failure handling" data-secondary="operators and" data-type="indexterm" id="idm45358828560816"/>As depicted in <a data-type="xref" href="#image-rp-stream-recover">Figure 5-7</a> and <a data-type="xref" href="#reactive-programming::recover">Example 5-23</a>, operators can also handle failures; for example, to recover or retry.</p>&#13;
&#13;
<figure><div class="figure" id="image-rp-stream-recover">&#13;
<img alt="Recovering from failures" src="assets/rsij_0507.png"/>&#13;
<h6><span class="label">Figure 5-7. </span>Recovering from failures</h6>&#13;
</div></figure>&#13;
<div data-type="example" id="reactive-programming::recover">&#13;
<h5><span class="label">Example 5-23. </span>Recover from failures (<em>chapter-5/reactive-programming-examples/src/main/java/org/acme/reactive/StreamsExample.java</em>)</h5>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="n">stream</code>&#13;
        <code class="o">.</code><code class="na">onFailure</code><code class="o">().</code><code class="na">recoverWithItem</code><code class="o">(</code><code class="n">failure</code> <code class="o">-&gt;</code> <code class="n">getFallbackForFailure</code><code class="o">(</code><code class="n">failure</code><code class="o">))</code>&#13;
        <code class="o">.</code><code class="na">subscribe</code><code class="o">().</code><code class="na">with</code><code class="o">(</code>&#13;
            <code class="n">item</code> <code class="o">-&gt;</code> <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="s">"Received a square: "</code> <code class="o">+</code> <code class="n">item</code><code class="o">),</code>&#13;
            <code class="n">failure</code> <code class="o">-&gt;</code> <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="s">"Oh no! Received a failure: "</code> <code class="o">+</code> <code class="n">failure</code><code class="o">),</code>&#13;
            <code class="o">()</code> <code class="o">-&gt;</code> <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="s">"Received the completion signal"</code><code class="o">)</code>&#13;
<code class="o">);</code></pre></div>&#13;
&#13;
<p>You may wonder why the <code>recover</code> operator emits a completion event after the recovery, as shown in <a data-type="xref" href="#image-rp-stream-recover">Figure 5-7</a>.&#13;
When the operator receives the failure event, it knows that the source is not going to emit any more items, as failures are terminal.&#13;
So,  after emitting the <em>fallback</em> item, the operator emits the completion event.&#13;
For the downstream subscriber, it’s like the failure did not happen and the stream completed successfully.</p>&#13;
&#13;
<p>Operators are not limited to synchronous or single-in, single-out types of transformations.&#13;
Operators can transform a single item into a stream, or on the flip side, discard items, as shown in <a data-type="xref" href="#image-rp-stream-operators">Figure 5-8</a>.</p>&#13;
&#13;
<figure><div class="figure" id="image-rp-stream-operators">&#13;
<img alt="Example of operators emitting multiple items or discarding some items" src="assets/rsij_0508.png"/>&#13;
<h6><span class="label">Figure 5-8. </span>Example of operators emitting multiple items or discarding some items</h6>&#13;
</div></figure>&#13;
&#13;
<p>Finally, operators can observe multiple upstreams, to merge them, for example, as shown in <a data-type="xref" href="#image-rp-stream-merge">Figure 5-9</a> and demonstrated in <a data-type="xref" href="#reactive-programming::merge">Example 5-24</a>.</p>&#13;
&#13;
<figure><div class="figure" id="image-rp-stream-merge">&#13;
<img alt="Merging multiple streams" src="assets/rsij_0509.png"/>&#13;
<h6><span class="label">Figure 5-9. </span>Merging multiple streams</h6>&#13;
</div></figure>&#13;
<div data-type="example" id="reactive-programming::merge">&#13;
<h5><span class="label">Example 5-24. </span>Merge multiple streams (<em>chapter-5/reactive-programming-examples/src/main/java/org/acme/reactive/StreamsExample.java</em>)</h5>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="n">Multi</code><code class="o">.</code><code class="na">createBy</code><code class="o">().</code><code class="na">merging</code><code class="o">().</code><code class="na">streams</code><code class="o">(</code><code class="n">circles</code><code class="o">,</code> <code class="n">squares</code><code class="o">)</code>&#13;
        <code class="o">.</code><code class="na">subscribe</code><code class="o">().</code><code class="na">with</code><code class="o">(</code>&#13;
        <code class="n">item</code> <code class="o">-&gt;</code> <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="s">"Received a square or circle: "</code> <code class="o">+</code> <code class="n">item</code><code class="o">),</code>&#13;
        <code class="n">failure</code> <code class="o">-&gt;</code> <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="s">"Oh no! Received a failure: "</code> <code class="o">+</code> <code class="n">failure</code><code class="o">),</code>&#13;
        <code class="o">()</code> <code class="o">-&gt;</code> <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="s">"Received the completion signal"</code><code class="o">)</code>&#13;
<code class="o">);</code></pre></div>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>In the preceding example, note when the observer received the completion event.&#13;
The merging operator waits for all the merged streams to complete before sending the completion event, as at that point, no more items&#13;
will be emitted.&#13;
That illustrates the coordination role of operators.<a data-startref="ix_reactive-programming-adoc17" data-type="indexterm" id="idm45358828288768"/><a data-startref="ix_reactive-programming-adoc16" data-type="indexterm" id="idm45358828288064"/></p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Reactive Programming Libraries" data-type="sect2"><div class="sect2" id="idm45358828575728">&#13;
<h2>Reactive Programming Libraries</h2>&#13;
&#13;
<p><a data-primary="reactive programming" data-secondary="libraries" data-type="indexterm" id="idm45358828286208"/>Java has many reactive programming libraries.&#13;
In this book, we are using SmallRye Mutiny, the reactive programming library integrated in Quarkus.&#13;
We will have a deeper look at Mutiny in <a data-type="xref" href="ch07.html#mutiny">Chapter 7</a>.&#13;
Project Reactor and RxJava, two popular alternatives, propose similar concepts.</p>&#13;
&#13;
<p>Reactive programming is not limited to Java.&#13;
<a data-primary="RX-JS" data-type="indexterm" id="idm45358828283424"/><a href="https://oreil.ly/pF21o">RX-JS</a> is a reactive programming library in JavaScript, often used in combination with Angular.&#13;
<a data-primary="RxPY" data-type="indexterm" id="idm45358828281952"/><a href="https://oreil.ly/tlGl1">RxPY</a> and <a href="https://oreil.ly/Mg4Rj">RxGo</a> offer the same type of constructs for Python and Go applications, respectively.<a data-startref="ix_reactive-programming-adoc13" data-type="indexterm" id="idm45358828279872"/><a data-startref="ix_reactive-programming-adoc12" data-type="indexterm" id="idm45358828279200"/><a data-startref="ix_reactive-programming-adoc11" data-type="indexterm" id="idm45358828278512"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Reactive Streams and the Need for Flow Control" data-type="sect1"><div class="sect1" id="idm45358828702608">&#13;
<h1>Reactive Streams and the Need for Flow Control</h1>&#13;
&#13;
<p>Using data streams as primary constructs does not come without issues.&#13;
One of the main problems is the need for flow control.&#13;
Let’s imagine a fast producer and a slow consumer.&#13;
The producer sends events too quickly for the consumer, which can’t keep up.&#13;
Imagine that this producer emits an item every 10 milliseconds, while a downstream consumer can consume only one per second.&#13;
Run the code in <a data-type="xref" href="#reactive-programming::streams-back-pressure-failure">Example 5-25</a>, and you’ll see how it ends: badly.<a data-primary="asynchronous code" data-secondary="Reactive Streams and need for flow control" data-type="indexterm" id="ix_reactive-programming-adoc18"/><a data-primary="flow control" data-secondary="Reactive Streams and" data-type="indexterm" id="ix_reactive-programming-adoc19"/><a data-primary="reactive programming" data-secondary="Reactive Streams and need for flow control" data-type="indexterm" id="ix_reactive-programming-adoc20"/><a data-primary="Reactive Streams" data-secondary="flow control and" data-type="indexterm" id="ix_reactive-programming-adoc21"/><a data-primary="streams" data-secondary="Reactive Streams and flow control" data-type="indexterm" id="ix_reactive-programming-adoc22"/></p>&#13;
<div data-type="example" id="reactive-programming::streams-back-pressure-failure">&#13;
<h5><span class="label">Example 5-25. </span>Example of backpressure failure (<em>chapter-5/reactive-programming-examples/src/main/java/org/acme/streams/BackPressureExample.java</em>)</h5>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="c1">// Ticks is a stream emitting an item periodically (every 10 ms)</code>&#13;
<code class="n">Multi</code><code class="o">&lt;</code><code class="n">Long</code><code class="o">&gt;</code> <code class="n">ticks</code> <code class="o">=</code> <code class="n">Multi</code><code class="o">.</code><code class="na">createFrom</code><code class="o">().</code><code class="na">ticks</code><code class="o">().</code><code class="na">every</code><code class="o">(</code><code class="n">Duration</code><code class="o">.</code><code class="na">ofMillis</code><code class="o">(</code><code class="mi">10</code><code class="o">))</code>&#13;
        <code class="o">.</code><code class="na">emitOn</code><code class="o">(</code><code class="n">Infrastructure</code><code class="o">.</code><code class="na">getDefaultExecutor</code><code class="o">());</code>&#13;
&#13;
<code class="n">ticks</code>&#13;
    <code class="o">.</code><code class="na">onItem</code><code class="o">().</code><code class="na">transform</code><code class="o">(</code><code class="nl">BackPressureExample:</code><code class="o">:</code><code class="n">canOnlyConsumeOneItemPerSecond</code><code class="o">)</code>&#13;
    <code class="o">.</code><code class="na">subscribe</code><code class="o">().</code><code class="na">with</code><code class="o">(</code>&#13;
        <code class="n">item</code> <code class="o">-&gt;</code> <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="s">"Got item: "</code> <code class="o">+</code> <code class="n">item</code><code class="o">),</code>&#13;
        <code class="n">failure</code> <code class="o">-&gt;</code> <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="s">"Got failure: "</code> <code class="o">+</code> <code class="n">failure</code><code class="o">)</code>&#13;
<code class="o">);</code></pre></div>&#13;
&#13;
<p>If you run that code, you will see that the subscriber gets <code>MissingBackPressureFailure</code>, indicating that the downstream could not keep up (<a data-type="xref" href="#reactive-programming::stream-back-pressure-failure-output">Example 5-26</a>).</p>&#13;
<div data-type="example" id="reactive-programming::stream-back-pressure-failure-output">&#13;
<h5><span class="label">Example 5-26. </span>Subscriber getting a <code>BackPressureFailure</code></h5>&#13;
&#13;
<pre data-code-language="text" data-type="programlisting">Got item: 0&#13;
Got failure: io.smallrye.mutiny.subscription.BackPressureFailure: Could not&#13;
emit tick 16 due to lack of requests</pre></div>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>In <a data-type="xref" href="#reactive-programming::streams-back-pressure-failure">Example 5-25</a>, you may wonder about <code>emitOn</code>.&#13;
This operator controls when a thread is used to emit the events.<sup><a data-type="noteref" href="ch05.html#idm45358828159456" id="idm45358828159456-marker">4</a></sup>&#13;
Backpressure is required when multiple threads are involved because in a single thread, blocking the thread would block the source.</p>&#13;
</div>&#13;
&#13;
<p>So, what can we do to handle this case?</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Buffering Items" data-type="sect2"><div class="sect2" id="idm45358828155440">&#13;
<h2>Buffering Items</h2>&#13;
&#13;
<p><a data-primary="buffers" data-type="indexterm" id="idm45358828154000"/><a data-primary="flow control" data-secondary="buffering" data-type="indexterm" id="idm45358828153296"/><a data-primary="streams" data-secondary="buffering" data-type="indexterm" id="idm45358828152352"/>The first natural solution uses buffers.&#13;
The consumer can buffer the events, so it does not fail (<a data-type="xref" href="#image:rp-buffer">Figure 5-10</a>).</p>&#13;
&#13;
<figure><div class="figure" id="image:rp-buffer">&#13;
<img alt="Buffering to avoid overwhelming downstream consumers" src="assets/rsij_0510.png"/>&#13;
<h6><span class="label">Figure 5-10. </span>Buffering to avoid overwhelming downstream consumers</h6>&#13;
</div></figure>&#13;
&#13;
<p>Buffers allow handling small bumps, but they’re not a long-term solution.&#13;
If you update your code to use a buffer, as in <a data-type="xref" href="#reactive-programming::streams-back-pressure-buffer">Example 5-27</a>, the consumer can handle more events but eventually fails.</p>&#13;
<div data-type="example" id="reactive-programming::streams-back-pressure-buffer">&#13;
<h5><span class="label">Example 5-27. </span>Handle overflow with buffers (<em>chapter-5/reactive-programming-examples/src/main/java/org/acme/streams/BufferingExample.java</em>)</h5>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="n">Multi</code><code class="o">&lt;</code><code class="n">Long</code><code class="o">&gt;</code> <code class="n">ticks</code> <code class="o">=</code> <code class="n">Multi</code><code class="o">.</code><code class="na">createFrom</code><code class="o">().</code><code class="na">ticks</code><code class="o">().</code><code class="na">every</code><code class="o">(</code><code class="n">Duration</code><code class="o">.</code><code class="na">ofMillis</code><code class="o">(</code><code class="mi">10</code><code class="o">))</code>&#13;
    <code class="o">.</code><code class="na">onOverflow</code><code class="o">().</code><code class="na">buffer</code><code class="o">(</code><code class="mi">250</code><code class="o">)</code>&#13;
    <code class="o">.</code><code class="na">emitOn</code><code class="o">(</code><code class="n">Infrastructure</code><code class="o">.</code><code class="na">getDefaultExecutor</code><code class="o">());</code>&#13;
&#13;
<code class="n">ticks</code>&#13;
    <code class="o">.</code><code class="na">onItem</code><code class="o">().</code><code class="na">transform</code><code class="o">(</code><code class="nl">BufferingExample:</code><code class="o">:</code><code class="n">canOnlyConsumeOneItemPerSecond</code><code class="o">)</code>&#13;
    <code class="o">.</code><code class="na">subscribe</code><code class="o">().</code><code class="na">with</code><code class="o">(</code>&#13;
        <code class="n">item</code> <code class="o">-&gt;</code> <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="s">"Got item: "</code> <code class="o">+</code> <code class="n">item</code><code class="o">),</code>&#13;
        <code class="n">failure</code> <code class="o">-&gt;</code> <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="s">"Got failure: "</code> <code class="o">+</code> <code class="n">failure</code><code class="o">)</code>&#13;
<code class="o">);</code></pre>&#13;
&#13;
<p>Here’s the output:</p>&#13;
&#13;
<pre data-code-language="text" data-type="programlisting">Got item: 0&#13;
Got item: 1&#13;
Got item: 2&#13;
Got failure: io.smallrye.mutiny.subscription.BackPressureFailure:&#13;
Buffer is full due to lack of downstream consumption</pre></div>&#13;
&#13;
<p>You can imagine increasing the buffer’s size, but it’s hard to anticipate the optimal value.&#13;
These buffers are local to the application, so, using large buffers also increases your memory consumption and reduces your resource utilization efficiency.&#13;
Not to mention that unbounded buffers are a terrible idea, as you may run out of memory.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Dropping Items" data-type="sect2"><div class="sect2" id="idm45358828155104">&#13;
<h2>Dropping Items</h2>&#13;
&#13;
<p><a data-primary="flow control" data-secondary="dropping items" data-type="indexterm" id="idm45358828009824"/><a data-primary="streams" data-secondary="dropping items" data-type="indexterm" id="idm45358828008880"/>Another solution consists of dropping items.&#13;
We can drop the newest received items or oldest ones; see&#13;
<a data-type="xref" href="#reactive-programming::streams-back-pressure-drop">Example 5-28</a>.</p>&#13;
<div data-type="example" id="reactive-programming::streams-back-pressure-drop">&#13;
<h5><span class="label">Example 5-28. </span>Handle overflow by dropping items (<em>chapter-5/reactive-programming-examples/src/main/java/org/acme/streams/DropExample.java</em>)</h5>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="n">Multi</code><code class="o">&lt;</code><code class="n">Long</code><code class="o">&gt;</code> <code class="n">ticks</code> <code class="o">=</code> <code class="n">Multi</code><code class="o">.</code><code class="na">createFrom</code><code class="o">().</code><code class="na">ticks</code><code class="o">().</code><code class="na">every</code><code class="o">(</code><code class="n">Duration</code><code class="o">.</code><code class="na">ofMillis</code><code class="o">(</code><code class="mi">10</code><code class="o">))</code>&#13;
        <code class="o">.</code><code class="na">onOverflow</code><code class="o">().</code><code class="na">drop</code><code class="o">(</code><code class="n">x</code> <code class="o">-&gt;</code> <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="s">"Dropping item "</code> <code class="o">+</code> <code class="n">x</code><code class="o">))</code>&#13;
        <code class="o">.</code><code class="na">emitOn</code><code class="o">(</code><code class="n">Infrastructure</code><code class="o">.</code><code class="na">getDefaultExecutor</code><code class="o">());</code>&#13;
&#13;
<code class="n">ticks</code>&#13;
        <code class="o">.</code><code class="na">onItem</code><code class="o">().</code><code class="na">transform</code><code class="o">(</code><code class="nl">DropExample:</code><code class="o">:</code><code class="n">canOnlyConsumeOneItemPerSecond</code><code class="o">)</code>&#13;
        <code class="o">.</code><code class="na">transform</code><code class="o">().</code><code class="na">byTakingFirstItems</code><code class="o">(</code><code class="mi">10</code><code class="o">)</code>&#13;
        <code class="o">.</code><code class="na">subscribe</code><code class="o">().</code><code class="na">with</code><code class="o">(</code>&#13;
            <code class="n">item</code> <code class="o">-&gt;</code> <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="s">"Got item: "</code> <code class="o">+</code> <code class="n">item</code><code class="o">),</code>&#13;
            <code class="n">failure</code> <code class="o">-&gt;</code> <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="s">"Got failure: "</code> <code class="o">+</code> <code class="n">failure</code><code class="o">)</code>&#13;
<code class="o">);</code></pre>&#13;
&#13;
<p>Here’s the output:</p>&#13;
&#13;
<pre data-code-language="text" data-type="programlisting">// ....&#13;
Dropping item 997&#13;
Dropping item 998&#13;
Dropping item 999&#13;
Dropping item 1000&#13;
Dropping item 1001&#13;
Dropping item 1002&#13;
Dropping item 1003&#13;
Got item: 9</pre></div>&#13;
&#13;
<p>Dropping items provides a sustainable solution to our problem, but we are losing items!&#13;
As we can see in the preceding output, we may drop the majority of items.&#13;
In many cases, this is not acceptable.</p>&#13;
&#13;
<p>We need another solution, one that adjusts the overall pace to satisfy the pipeline’s slowest element.&#13;
We need a backpressure protocol.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="What Is Backpressure?" data-type="sect2"><div class="sect2" id="idm45358827852752">&#13;
<h2>What Is Backpressure?</h2>&#13;
&#13;
<p><a data-primary="backpressure" data-type="indexterm" id="idm45358827851472"/><a data-primary="backpressure" data-secondary="defined" data-type="indexterm" id="idm45358827850768"/><a data-primary="flow control" data-secondary="backpressure" data-type="indexterm" id="idm45358827849824"/>In mechanics, backpressure is a way to control the flow of fluid through pipes, leading to a pressure drop.&#13;
That control can use reducers or bends.&#13;
While this is great if you are a plumber, it’s not clear how it can help us here.</p>&#13;
&#13;
<p>We can see our streams as a flow of fluid, and the set of stages (operator or subscriber) forms a pipe.&#13;
We want to make the fluid flow as frictionless as possible, without swirls and waves.</p>&#13;
&#13;
<p>An interesting characteristic of fluid mechanics is the way a downstream reduction of the throughput affects the upstream.&#13;
Essentially, that’s what we need: a way for the downstream operators and subscribers to reduce the throughput, not only locally but also upstream.</p>&#13;
&#13;
<p>Don’t be mistaken; backpressure is not something new in the IT world and is not limited to Reactive.&#13;
One of the most brilliant uses of backpressure is in TCP.<sup><a data-type="noteref" href="ch05.html#idm45358827846624" id="idm45358827846624-marker">5</a></sup>&#13;
A reader receiving data can block the writer on the other side of the wire if it does not read the sent data.&#13;
That way, the reader is never overwhelmed.&#13;
But the consequences need to be understood: blocking the writer may not be without side effects.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Introducing Reactive Streams" data-type="sect2"><div class="sect2" id="idm45358827844704">&#13;
<h2>Introducing Reactive Streams</h2>&#13;
&#13;
<p><a data-primary="backpressure" data-secondary="Reactive Streams" data-type="indexterm" id="ix_reactive-programming-adoc23"/><a data-primary="flow control" data-secondary="Reactive Streams" data-type="indexterm" id="ix_reactive-programming-adoc24"/><a data-primary="Reactive Streams" data-secondary="basics" data-type="indexterm" id="ix_reactive-programming-adoc25"/><a data-primary="streams" data-secondary="Reactive Streams" data-type="indexterm" id="ix_reactive-programming-adoc26"/>Let’s now focus on another backpressure protocol: Reactive Streams.&#13;
This asynchronous and backpressure protocol is suited to our fast producer/slow consumer problem.&#13;
With Reactive Streams, the consumer, named <code>Subscriber</code>, requests items from the producer, named <code>Publisher</code>.&#13;
As depicted in <a data-type="xref" href="#image:rp-control-flow">Figure 5-11</a>, <code>Publisher</code> cannot send more than the requested number of items.</p>&#13;
&#13;
<figure><div class="figure" id="image:rp-control-flow">&#13;
<img alt="Using flow control to avoid overwhelming consumers" src="assets/rsij_0511.png"/>&#13;
<h6><span class="label">Figure 5-11. </span>Using flow control to avoid overwhelming consumers</h6>&#13;
</div></figure>&#13;
&#13;
<p>When the items are received and processed, the consumer can request more items, and so on.&#13;
Thus, the consumer controls the flow.</p>&#13;
&#13;
<p>Note that Reactive Streams introduces a strong coupling between a consumer and a producer.&#13;
The producer must listen to the requests from the consumer.</p>&#13;
&#13;
<p>To implement that protocol, Reactive Streams defines a set of entities.&#13;
First, &#13;
<span class="keep-together"><code>Subscriber</code></span> is a consumer.&#13;
It subscribes to a stream, called <code>Publisher</code>, which produces items (<a data-type="xref" href="#image:rp-back-pressure-sequence">Figure 5-12</a>).&#13;
Then <code>Publisher</code> sends, asynchronously, a <code>Subscription</code> object to <code>Subscriber</code>.&#13;
This <code>Subscription</code> object is a contract.&#13;
With <code>Subscription</code>, &#13;
<span class="keep-together"><code>Subscriber</code></span> can request items and then cancel the subscription when it does not want any more items.&#13;
Each subscriber subscribing to a publisher gets a different &#13;
<span class="keep-together"><code>Subscription</code></span>, and so emits independent requests.&#13;
The publisher implementation is in charge of the orchestration of the various requests and the emission of the items to the multiple subscribers.</p>&#13;
&#13;
<figure><div class="figure" id="image:rp-back-pressure-sequence">&#13;
<img alt="Example of interactions between a `Subscriber` and a `Publisher`" src="assets/rsij_0512.png"/>&#13;
<h6><span class="label">Figure 5-12. </span>Example of interactions between <code>Subscriber</code> and <code>Publisher</code></h6>&#13;
</div></figure>&#13;
&#13;
<p><code>Publisher</code> cannot send more items than requested to <code>Subscriber</code>, and <code>Subscriber</code> can request more items at any time.</p>&#13;
&#13;
<p>It is essential to understand that the requests and emissions are not necessarily happening synchronously.&#13;
<code>Subscriber</code> can request three items, and <code>Publisher</code> will send them one by one when they are available.</p>&#13;
&#13;
<p>Reactive Streams introduces another entity named <code>Processor</code>.&#13;
<code>Processor</code> is a subscriber and a publisher simultaneously.&#13;
In other words, it’s a link in our pipeline, as shown in <a data-type="xref" href="#image:rp-back-processor">Figure 5-13</a>.</p>&#13;
&#13;
<figure><div class="figure" id="image:rp-back-processor">&#13;
<img alt="Example of interactions between a `Subscriber`, a `Processor` and a `Publisher`" src="assets/rsij_0513.png"/>&#13;
<h6><span class="label">Figure 5-13. </span>Example of interactions between <code>Subscriber</code>, <code>Processor</code>, and <code>Publisher</code></h6>&#13;
</div></figure>&#13;
&#13;
<p><code>Subscriber</code> calls <code>subscribe</code> on <code>Processor</code>.&#13;
Before receiving a <code>Subscription</code>, &#13;
<span class="keep-together"><code>Processor</code></span> subscribes to its own upstream source (<code>Publisher</code> in <a data-type="xref" href="#image:rp-back-processor">Figure 5-13</a>).&#13;
When that upstream provides <code>Subscription</code> to our <code>Processor</code>, it can give <code>Subscription</code> to &#13;
<span class="keep-together"><code>Subscriber</code></span>.&#13;
All these interactions are asynchronous.&#13;
When this handshake completes, <code>Subscriber</code> can start requesting items.&#13;
<code>Processor</code> is responsible for mediating the <code>Subscriber</code> requests with its upstream.&#13;
For example, as illustrated in <a data-type="xref" href="#image:rp-back-processor">Figure 5-13</a>, if  <code>Subscriber</code> requires two items,  <code>Processor</code> also requests two items to its own upstream.&#13;
Of course, depending on the <code>Processor</code> code, it may not be that simple.&#13;
What’s fundamental is that each <code>Publisher</code> and <code>Processor</code> enforces the flowing requests to never overload downstream subscribers.<a data-startref="ix_reactive-programming-adoc26" data-type="indexterm" id="idm45358827786512"/><a data-startref="ix_reactive-programming-adoc25" data-type="indexterm" id="idm45358827785792"/><a data-startref="ix_reactive-programming-adoc24" data-type="indexterm" id="idm45358827785104"/><a data-startref="ix_reactive-programming-adoc23" data-type="indexterm" id="idm45358827784464"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Be Warned: It’s a Trap!" data-type="sect2"><div class="sect2" id="idm45358827844112">&#13;
<h2>Be Warned: It’s a Trap!</h2>&#13;
&#13;
<p><a data-primary="Reactive Streams" data-secondary="protocol issues/solutions" data-type="indexterm" id="idm45358827783472"/>If you look at the Reactive Streams API,<sup><a data-type="noteref" href="ch05.html#idm45358827782352" id="idm45358827782352-marker">6</a></sup> you will find it <em>simple</em>: a few classes, a couple of methods.&#13;
It’s a trap!&#13;
Behind this apparent simplicity, implementing Reactive Streams entities yourself is a nightmare.&#13;
The problem is not the interfaces; it’s the protocol.&#13;
Reactive Streams comes with a broad set of rules, and a strict Technology Compatibility Kit (TCK) to verify that your implementation enforces the protocol.</p>&#13;
&#13;
<p>Fortunately, you don’t need to implement publishers, subscribers, or processors yourself.&#13;
Recent reactive programming libraries already implement the protocol for you.&#13;
Project Reactor, RxJava (versions 2 and 3), and Mutiny implement the specification.&#13;
For example, Mutiny’s <code>Multi</code> is a publisher following the Reactive Streams protocol.&#13;
All the subscription handshakes and request negotiations are done for you.</p>&#13;
&#13;
<p>Also, because all these libraries are using the same core concepts and API, it allows smooth integration: you can consume a Reactor <code>Flux</code> by using a Mutiny <code>Subscriber</code> and vice versa!&#13;
Reactive Streams is the integration layer between the various reactive programming libraries, in addition to being a backpressure protocol.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Backpressure in Distributed Systems" data-type="sect2"><div class="sect2" id="idm45358827776848">&#13;
<h2>Backpressure in Distributed Systems</h2>&#13;
&#13;
<p><a data-primary="backpressure" data-secondary="distributed systems and" data-type="indexterm" id="idm45358827775456"/><a data-primary="distributed systems" data-secondary="backpressure in" data-type="indexterm" id="idm45358827774480"/><a data-primary="Reactive Streams" data-secondary="distributed systems and" data-type="indexterm" id="idm45358827773536"/>Reactive Streams works perfectly within a local node, but what about distributed systems?&#13;
In such a system, it’s important that event producers do not overflow the consumers.&#13;
We need flow control.&#13;
Fortunately, we have many alternatives.</p>&#13;
&#13;
<p><a data-primary="RSocket" data-type="indexterm" id="idm45358827771952"/>First, RSocket is proposing a distributed variant of Reactive Streams.&#13;
However, because of distributed systems’ challenges and potential communication disruptions, the protocol requires a few adaptations.</p>&#13;
&#13;
<p><a data-primary="AMQP (Advanced Message Queuing Protocol)" data-secondary="AMQP 1.0" data-type="indexterm" id="idm45358827770640"/>AMQP 1.0 uses a <a href="https://oreil.ly/ZKURr">flow control protocol based on credit</a>.&#13;
As a producer, you get a certain amount of credit.&#13;
When you run out of credit, you can’t send messages anymore.&#13;
The broker refills your credit according to the consumer pace.</p>&#13;
&#13;
<p><a data-primary="Kafka" data-secondary="backpressure/performance considerations" data-type="indexterm" id="idm45358827768256"/>Apache Kafka consumers can also implement backpressure by using pause/resume cycles and explicit polling.&#13;
In this case, Kafka does not prevent the production of messages.&#13;
It stores the messages in the broker, and uses it as a large buffer.&#13;
The consumer polls the messages according to its capacity.</p>&#13;
&#13;
<p>The mechanism presented for AMQP 1.0 and Apache Kafka are not the same as Reactive Streams.&#13;
Frameworks, such as Quarkus, create bridges between these mechanisms with the Reactive Streams protocol.<a data-startref="ix_reactive-programming-adoc22" data-type="indexterm" id="idm45358827766176"/><a data-startref="ix_reactive-programming-adoc21" data-type="indexterm" id="idm45358827765456"/><a data-startref="ix_reactive-programming-adoc20" data-type="indexterm" id="idm45358827764768"/><a data-startref="ix_reactive-programming-adoc19" data-type="indexterm" id="idm45358827764080"/><a data-startref="ix_reactive-programming-adoc18" data-type="indexterm" id="idm45358827763392"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="idm45358828277232">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>In this chapter, you have learned the following:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Asynchronous code is hard but is required to avoid discarding the benefits of nonblocking I/O.</p>&#13;
</li>&#13;
<li>&#13;
<p>Reactive programming is one possibility for writing asynchronous code.</p>&#13;
</li>&#13;
<li>&#13;
<p>Reactive programming uses data streams as primary constructs. You write a processing pipeline reacting to events flowing from upstream.</p>&#13;
</li>&#13;
<li>&#13;
<p>Reactive Streams is an essential aspect of Reactive. It avoids overwhelming fragile parts of your system.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Small cracks that ripple in your system can lead to dreadful &#13;
<span class="keep-together">consequences</span>.</p>&#13;
&#13;
<p>Now, you have enough knowledge about Reactive to build your own reactive systems and appreciate the benefits.&#13;
Wait! You may need some more concrete details, no?&#13;
That’s what we are going to cover in <a data-type="xref" href="part03.html#quarkus-part">Part III</a>, where we explore how easy it is to build reactive systems with Quarkus.<a data-startref="ix_reactive-programming-adoc0" data-type="indexterm" id="idm45358827754240"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<div data-type="footnotes"><p data-type="footnote" id="idm45358829664160"><sup><a href="ch05.html#idm45358829664160-marker">1</a></sup> The Vert.x 3 main development model uses callbacks. Many operations pass a callback receiving <code>AsyncResult</code>. In Vert.x 4, an alternative model using futures has been introduced.</p><p data-type="footnote" id="idm45358829062432"><sup><a href="ch05.html#idm45358829062432-marker">2</a></sup> Check the <a href="https://oreil.ly/arP4E">Project Loom site</a> for updates on the general availability.</p><p data-type="footnote" id="idm45358828566736"><sup><a href="ch05.html#idm45358828566736-marker">3</a></sup> In functional programming, <code>transform</code> is often called <code>map</code>.</p><p data-type="footnote" id="idm45358828159456"><sup><a href="ch05.html#idm45358828159456-marker">4</a></sup> More details about <code>emitOn</code> can be found in the <a href="https://oreil.ly/qrVdD">Mutiny online guides</a>.</p><p data-type="footnote" id="idm45358827846624"><sup><a href="ch05.html#idm45358827846624-marker">5</a></sup> We recommend reading <a href="https://oreil.ly/JEbNh">“Using Backpressure to Improve TCP Performance with Many Flows”</a> by Carlos M. Pazos et al., which explains how TCP backpressure can be used to improve performance.</p><p data-type="footnote" id="idm45358827782352"><sup><a href="ch05.html#idm45358827782352-marker">6</a></sup> For more information, see the <a href="https://oreil.ly/mcYRu">Reactive Streams Javadoc</a>.</p></div></div></section></body></html>