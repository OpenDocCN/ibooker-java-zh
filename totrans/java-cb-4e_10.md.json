["```java\nFiles.lines(Path.of(\"myFile.txt\")).forEach(System.out::println);\n```", "```java\n        System.out.println(\"Using Path.lines()\");\n        Files.lines(Path.of(fileName)).forEach(System.out::println);\n\n        System.out.println(\"Using Path.readAllLines()\");\n        List<String> lines = Files.readAllLines(Path.of(fileName));\n        lines.forEach(System.out::println);\n\n        System.out.println(\"Using BufferedReader.lines().forEach()\");\n        new BufferedReader(new FileReader(fileName)).lines().forEach(s -> {\n            System.out.println(s);\n        });\n\n        System.out.println(\"The old-fashioned way\");\n        BufferedReader is = new BufferedReader(new FileReader(fileName));\n        String line;\n        while ((line = is.readLine()) != null) {\n            System.out.println(line);\n        }\n```", "```java\n    static void oldWayShorter() throws IOException {\n        try (BufferedReader is =\n            new BufferedReader(new FileReader(INPUT_FILE_NAME));\n            BufferedOutputStream bytesOut = new BufferedOutputStream(\n              new FileOutputStream(OUTPUT_FILE_NAME.replace(\"\\\\.\", \"-1.\")));) {\n\n            // Read from is, write to bytesOut\n            String line;\n            while ((line = is.readLine()) != null) {\n                line = doSomeProcessingOn(line);\n                bytesOut.write(line.getBytes(\"UTF-8\"));\n                bytesOut.write('\\n');\n            }\n\n        }\n    }\n```", "```java\nString input = Files.readString(Path.of(INPUT_FILE_NAME)));\n```", "```java\nint b = System.in.read( );\n```", "```java\npublic static void main(String args[]) throws IOException {\n...\n}\n```", "```java\n        int b = 0;\n        try {\n            b = System.in.read();\n            System.out.println(\"Read this data: \" + (char)b);\n        } catch (Exception e) {\n            System.out.println(\"Caught \" + e);\n        }\n```", "```java\nScanner sc = Scanner.create(System.in);\nint i = sc.nextInt();\n```", "```java\nBufferedReader is = new BufferedReader(new InputStreamReader(System.in));\n```", "```java\npublic class CatStdin {\n\n    public static void main(String[] av) {\n        try (BufferedReader is =\n                new BufferedReader(new InputStreamReader(System.in))) {\n            String inputLine;\n\n            while ((inputLine = is.readLine()) != null) {\n                System.out.println(inputLine);\n            }\n        } catch (IOException e) {\n            System.out.println(\"IOException: \" + e);\n        }\n    }\n}\n```", "```java\npublic class ReadStdinIntsFunctional {\n    private static Stream<Integer> parseIntSafe(String s) {\n        try {\n            return Stream.of(Integer.parseInt(s));\n        } catch (NumberFormatException e) {\n            return Stream.empty();\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        try (BufferedReader is =\n                new BufferedReader(new InputStreamReader(System.in));) {\n            is.lines()\n                .flatMap(ReadStdinIntsFunctional::parseIntSafe)\n                .forEach(System.out::println);\n        }\n    }\n}\n```", "```java\npublic class ConsoleRead {\n    public static void main(String[] args) {\n        String name = System.console().readLine(\"What is your name?\");\n        System.out.println(\"Hello, \" + name.toUpperCase());\n    }\n}\n```", "```java\nSystem.out.printf(\"%1$04d - the year of %2$f%n\", 1956, Math.PI);\nSystem.out.printf(\"%04d - the year of %f%n\", 1956, Math.PI);\n```", "```java\npublic class FormatterDemo {\n    public static void main(String[] args) {\n\n        // The arguments to all these format methods consist of\n        // a format code String and 1 or more arguments.\n        // Each format code consists of the following:\n        // % - code lead-in\n        // N$ - OPTIONAL parameter number (1-based) after the format code\n        // N - field width\n        // L - format letter (d: decimal(int); f: float; s: general; many more)\n        // For the full(!) story, see javadoc for java.util.Formatter.\n\n        // Most general (cumbersome) way of proceding.\n        Formatter fmtr = new Formatter();\n        Object result = fmtr.format(\"%1$04d - the year of %2$f\", 1956, Math.PI);\n        System.out.println(result);\n        fmtr.close();\n\n        // Shorter way using static String.format(), default parameter numbering.\n        Object stringResult = String.format(\"%04d - the year of %f\", 1956, Math.PI);\n        System.out.println(stringResult);\n\n        // A shorter way using PrintStream/PrintWriter.format, more in line with\n        // other languages. But this way you should provide the newline delimiter\n        // using %n (rather than \\n as that is platform-dependent!).\n        System.out.printf(\"%04d - the year of %f%n\", 1956, Math.PI);\n\n        // Format doubles with more control\n        System.out.printf(\"PI is approximately %4.2f%n\", Math.PI);\n    }\n}\n```", "```java\nC:> javac FormatterDates.java\nC:> java io.FormatterDates \n1956 - The year of 3.141593\n1956 - The year of 3.141593\n1956 - The year of 3.141593\nPI is about 3.14\n```", "```java\npublic class FormatterDates {\n    public static void main(String[] args) {\n\n        // Format number as dates e.g., 2020-06-28\n        System.out.printf(\"%4d-%02d-%2d%n\", 2020, 6, 28);\n\n        // Format fields directly from a Date object: multiple fields from \"1$\"\n        // (hard-coded formatting for Date not advisable; see I/O chapter)\n        LocalDate today = LocalDate.now();\n        // Print in a form like e.g., \"July 4, 2020\"\n        System.out.printf(\"Today is %1$tB %1$td, %1$tY%n\", today);\n    }\n}\n```", "```java\nC:> java io.FormatterDates\n2020-06-28\nToday is January 01, 2020\n```", "```java\npublic class ReadCharsOneAtATime {\n\n    void doFile(Reader is) throws IOException {\n        int c;\n        while ((c=is.read( )) != -1) {\n            System.out.print((char)c);\n        }\n    }\n}\n```", "```java\npublic class ScanStringTok {\n\n    public static void main(String[] av) throws IOException {\n        if (av.length == 0)\n            System.err.printf(\"Usage: %s filename [...]%n\",\n                ScanStringTok.class.getSimpleName());\n        else\n            for (int i=0; i<av.length; i++)\n                process(av[i]);\n    }\n\n    static void process(String fileName) {\n        String s = null;\n        try (BufferedReader is =\n                new BufferedReader(new FileReader(fileName));) {\n            while ((s = is.readLine()) != null) {\n                StringTokenizer st = new StringTokenizer(s, \"@\", true);\n                String user = (String)st.nextElement();\n                st.nextElement();\n                String host = (String)st.nextElement();\n                System.out.println(\"User name: \" + user +\n                    \"; host part: \" + host);\n\n                // Do something useful with the user and host parts...\n            }\n        } catch (NoSuchElementException ix) {\n            System.err.println(\"Malformed input \" + s);\n        } catch (IOException e) {\n            System.err.println(e);\n        }\n    }\n}\n```", "```java\n2 2 + =\n4\n22 7 / =\n3.141592857\n```", "```java\n4 5 * = 2 / =\n20.0\n10.0\n```", "```java\npublic class SimpleCalcStreamTok {\n    /** The StreamTokenizer input */\n    protected  StreamTokenizer tf;\n    /** The output file */\n    protected PrintWriter out = new PrintWriter(System.out, true);\n    /** The variable name (not used in this version) */\n    protected String variable;\n    /** The operand stack */\n    protected Stack<Double> s = new Stack<>();\n\n    /* Driver - main program */\n    public static void main(String[] av) throws IOException {\n        if (av.length == 0)\n            new SimpleCalcStreamTok(\n                new InputStreamReader(System.in)).doCalc();\n        else\n            for (int i=0; i<av.length; i++)\n                new SimpleCalcStreamTok(av[i]).doCalc();\n    }\n\n    /** Construct by filename */\n    public SimpleCalcStreamTok(String fileName) throws IOException {\n        this(new FileReader(fileName));\n    }\n\n    /** Construct from an existing Reader */\n    public SimpleCalcStreamTok(Reader rdr) throws IOException {\n        tf = new StreamTokenizer(rdr);\n        // Control the input character set:\n        tf.slashSlashComments(true);    // treat \"//\" as comments\n        tf.ordinaryChar('-');        // used for subtraction\n        tf.ordinaryChar('/');    // used for division\n    }\n\n    /** Construct from a Reader and a PrintWriter\n */\n    public SimpleCalcStreamTok(Reader in, PrintWriter out) throws IOException {\n        this(in);\n        setOutput(out);\n    }\n\n    /**\n * Change the output destination.\n */\n    public void setOutput(PrintWriter out) {\n        this.out = out;\n    }\n\n    protected void doCalc() throws IOException {\n        int iType;\n        double tmp;\n\n        while ((iType = tf.nextToken()) != StreamTokenizer.TT_EOF) {\n            switch(iType) {\n            case StreamTokenizer.TT_NUMBER: // Found a number, push value to stack\n                push(tf.nval);\n                break;\n            case StreamTokenizer.TT_WORD:\n                // Found a variable, save its name. Not used here.\n                variable = tf.sval;\n                break;\n            case '+':\n                // + operator is commutative.\n                push(pop() + pop());\n                break;\n            case '-':\n                // - operator: order matters.\n                tmp = pop();\n                push(pop() - tmp);\n                break;\n            case '*':\n                // Multiply is commutative.\n                push(pop() * pop());\n                break;\n            case '/':\n                // Handle division carefully: order matters!\n                tmp = pop();\n                push(pop() / tmp);\n                break;\n            case '=':\n                out.println(peek());\n                break;\n            default:\n                out.println(\"What's this? iType = \" + iType);\n            }\n        }\n    }\n    void push(double val) {\n        s.push(Double.valueOf(val));\n    }\n    double pop() {\n        return ((Double)s.pop()).doubleValue();\n    }\n    double peek() {\n        return ((Double)s.peek()).doubleValue();\n    }\n    void clearStack() {\n        s.removeAllElements();\n    }\n}\n```", "```java\n        String sampleDate = \"25 Dec 1988\";\n\n        try (Scanner sDate = new Scanner(sampleDate)) {\n            int dayOfMonth = sDate.nextInt();\n            String month = sDate.next();\n            int year = sDate.nextInt();\n            System.out.printf(\"%d-%s-%02d%n\", year, month, dayOfMonth);\n        }\n```", "```java\npublic class SimpleCalcScanner {\n    /** The Scanner */\n    protected Scanner scan;\n\n    /** The output */\n    protected PrintWriter out = new PrintWriter(System.out, true);\n\n    /** The variable name (not used in this version) */\n    protected String variable;\n\n    /** The operand stack; no operators are pushed,\n * so it can be a stack of Double\n */\n    protected Stack<Double> s = new Stack<>();\n\n    /* Driver - main program */\n    public static void main(String[] args) throws IOException {\n        if (args.length == 0)\n            new SimpleCalcScanner(\n                new InputStreamReader(System.in)).doCalc();\n        else\n            for (String arg : args) {\n                new SimpleCalcScanner(arg).doCalc();\n            }\n    }\n\n    /** Construct a SimpleCalcScanner by name */\n    public SimpleCalcScanner(String fileName) throws IOException {\n        this(new FileReader(fileName));\n    }\n\n    /** Construct a SimpleCalcScanner from an open Reader */\n    public SimpleCalcScanner(Reader rdr) throws IOException {\n        scan = new Scanner(rdr);\n    }\n\n    /** Construct a SimpleCalcScanner from a Reader and a PrintWriter */\n    public SimpleCalcScanner(Reader rdr, PrintWriter pw) throws IOException {\n        this(rdr);\n        setWriter(pw);\n    }\n\n    /** Change the output to go to a new PrintWriter */\n    public void setWriter(PrintWriter pw) {\n        out = pw;\n    }\n\n    protected void doCalc() throws IOException {\n        double tmp;\n\n        while (scan.hasNext()) {\n            if (scan.hasNextDouble()) {\n                push(scan.nextDouble());\n            } else {\n                String token;\n                switch(token = scan.next()) {\n                case \"+\":\n                    // Found + operator, perform it immediately.\n                    push(pop() + pop());\n                    break;\n                case \"-\":\n                    // Found - operator, perform it (order matters).\n                    tmp = pop();\n                    push(pop() - tmp);\n                    break;\n                case \"*\":\n                    // Multiply is commutative.\n                    push(pop() * pop());\n                    break;\n                case \"/\":\n                    // Handle division carefully: order matters!\n                    tmp = pop();\n                    push(pop() / tmp);\n                    break;\n                case \"=\":\n                    out.println(peek());\n                    break;\n                default:\n                    out.println(\"What's this? \" + token);\n                    break;\n                }\n            }\n        }\n    }\n\n    void push(double val) {\n        s.push(Double.valueOf(val));\n    }\n\n    double pop() {\n        return ((Double)s.pop()).doubleValue();\n    }\n\n    double peek() {\n        return ((Double)s.peek()).doubleValue();\n    }\n\n    void clearStack() {\n        s.removeAllElements();\n    }\n}\n```", "```java\nname:  [A-Za-z0-9]+@[A-Za-z0-0.]\nor\nname: \\w+#[\\w.]\n```", "```java\nPath copy(Path, Path, CopyOption...) throws java.io.IOException;\nlong copy(InputStream, Path, CopyOption...) throws IOException;\nlong copy(Path, OutputStream) throws IOException;\n```", "```java\nPath p = Paths.get(\"my_new_file\");\nInputStream is = // open some file for reading\nlong newFileSize = Files.copy(is, p);\n```", "```java\npackage com.darwinsys.io;\n\nimport java.io.IOException;\n\npublic class FileIoDemo {\n    public static void main(String[] av) {\n        try {\n            FileIO.copyFile(\"FileIO.java\", \"FileIO.bak\");\n            FileIO.copyFile(\"FileIO.class\", \"FileIO-class.bak\");\n        } catch (IOException e) {\n            System.err.println(e);\n        }\n    }\n}\n```", "```java\n        String LOGFILENAME = \"error.log\";\n        System.setErr(new PrintStream(new FileOutputStream(LOGFILENAME)));\n        System.out.println(\"Please look for errors in \" + LOGFILENAME);\n        // Now assume this is somebody else's code; you'll see it\n        //   writing to stderr...\n        int[] a = new int[5];\n        a[10] = 0;    // here comes an ArrayIndexOutOfBoundsException\n```", "```java\nSystem.setErr(System.out);    // merge stderr and stdout to same output file.\n```", "```java\nwho | wc -l\n```", "```java\nwho | tee wholist | wc -l\n```", "```java\nian      ttyC0    Mar 14 09:59\nben      ttyC3    Mar 14 10:23\nian      ttyp4    Mar 14 13:46  (laptop.darwinsys.com)\n```", "```java\nSystem.setErr(new TeePrintStream(System.err, \"err.log\"));\n// ...lots of code that occasionally writes to System.err... Or might.\n```", "```java\npublic class TeePrintStream extends PrintStream {\n    /** The original/direct print stream */\n    protected PrintStream parent;\n\n    /** The filename we are tee-ing too, if known;\n * intended for use in future error reporting.\n */\n    protected String fileName;\n\n    /** The name for when the input filename is not known */\n    private static final String UNKNOWN_NAME = \"(opened Stream)\";\n\n    /** Construct a TeePrintStream given an existing PrintStream,\n * an opened OutputStream, and a boolean to control auto-flush.\n * This is the main constructor, to which others delegate via \"this\".\n */\n    public TeePrintStream(PrintStream orig, OutputStream os, boolean flush)\n    throws IOException {\n        super(os, true);\n        fileName = UNKNOWN_NAME;\n        parent = orig;\n    }\n\n    /** Construct a TeePrintStream given an existing PrintStream and\n * an opened OutputStream.\n */\n    public TeePrintStream(PrintStream orig, OutputStream os)\n    throws IOException {\n        this(orig, os, true);\n    }\n\n    /* Construct a TeePrintStream given an existing Stream and a filename.\n */\n    public TeePrintStream(PrintStream os, String fn) throws IOException {\n        this(os, fn, true);\n    }\n\n    /* Construct a TeePrintStream given an existing Stream, a filename,\n * and a boolean to control the flush operation.\n */\n    public TeePrintStream(PrintStream orig, String fn, boolean flush)\n    throws IOException {\n        this(orig, new FileOutputStream(fn), flush);\n        fileName = fn;\n    }\n\n    /** Return true if either stream has an error. */\n    public boolean checkError() {\n        return parent.checkError() || super.checkError();\n    }\n\n    /** override write(). This is the actual \"tee\" operation. */\n    public void write(int x) {\n        parent.write(x);    // \"write once;\n        super.write(x);        // write somewhere else.\"\n    }\n\n    /** override write(). This is the actual \"tee\" operation. */\n    public void write(byte[] x, int o, int l) {\n        parent.write(x, o, l);    // \"write once;\n        super.write(x, o, l);    // write somewhere else.\"\n    }\n\n    /** Close both streams. */\n    public void close() {\n        parent.close();\n        super.close();\n    }\n\n    /** Flush both streams. */\n    public void flush() {\n        parent.flush();\n        super.flush();\n    }\n}\n```", "```java\n// io/UseConverters.java\nBufferedReader fromKanji = new BufferedReader(\n    new InputStreamReader(new FileInputStream(\"kanji.txt\"), \"EUC_JP\"));\nPrintWriter toSwedish = new PrinterWriter(\n    new OutputStreamWriter(new FileOutputStream(\"sverige.txt\"), \"Cp278\"));\n```", "```java\noutputSocket.print(\"HELO \" + myName + \"\\r\\n\");\nString response = inputSocket.readLine();\n```", "```java\n    String myName;\n    public static void main(String[] argv) {\n        BadNewline jack = new BadNewline(\"Jack Adolphus Schmidt, III\");\n        System.out.println(jack);\n    }\n    /**\n * DON'T DO THIS. THIS IS BAD CODE.\n */\n    public String toString() {\n        return \"BadNewlineDemo@\" + hashCode() + \"\\n\" + myName;\n    }\n\n    // The obvious Constructor is not shown for brevity; it's in the code\n```", "```java\n    String myName;\n    public static void main(String[] argv) {\n        GoodNewline jack = new GoodNewline(\"Jack Adolphus Schmidt, III\");\n        jack.print(System.out);\n    }\n\n    protected void print(PrintStream out) {\n        out.println(toString());    // classname and hashcode\n        out.println(myName);        // print name  on next line\n    }\n```", "```java\npublic class WriteBinary {\n    public static void main(String[] argv) throws IOException {\n        int i = 42;\n        double d = Math.PI;\n        String FILENAME = \"binary.dat\";\n        DataOutputStream os = new DataOutputStream(\n            new FileOutputStream(FILENAME));\n        os.writeInt(i);\n        os.writeDouble(d);\n        os.close();\n        System.out.println(\"Wrote \" + i + \", \" + d + \" to file \" + FILENAME);\n    }\n}\n```", "```java\nZipFile zippy = new ZipFile(fileName);\n```", "```java\nEnumeration all = zippy.entries( );\nwhile (all.hasMoreElements( )) {\n    ZipEntry entry = (ZipEntry)all.nextElement( );\n    ...\n}\n```", "```java\nif (entry.isDirectory( ))\n    println(\"Directory: \" + e.getName( ));\nelse\n    println(\"File: \" + e.getName( ));\n```", "```java\npublic class UnZip {\n    /** Constants for mode listing or mode extracting. */\n    public static enum Mode {\n        LIST,\n        EXTRACT;\n    }\n    /** Whether we are extracting or just printing TOC */\n    protected Mode mode = Mode.LIST;\n\n    /** The ZipFile that is used to read an archive */\n    protected ZipFile zippy;\n\n    /** The buffer for reading/writing the ZipFile data */\n    protected byte[] b = new byte[8092];\n\n    /** Simple main program, construct an UnZipper, process each\n * .ZIP file from argv[] through that object.\n */\n    public static void main(String[] argv) {\n        UnZip u = new UnZip();\n\n        for (int i=0; i<argv.length; i++) {\n            if (\"-x\".equals(argv[i])) {\n                u.setMode(Mode.EXTRACT);\n                continue;\n            }\n            String candidate = argv[i];\n            // System.err.println(\"Trying path \" + candidate);\n            if (candidate.endsWith(\".zip\") ||\n                candidate.endsWith(\".jar\"))\n                    u.unZip(candidate);\n            else System.err.println(\"Not a zip file? \" + candidate);\n        }\n        System.err.println(\"All done!\");\n    }\n\n    /** Set the Mode (list, extract). */\n    protected void setMode(Mode m) {\n        mode = m;\n    }\n\n    /** Cache of paths we've mkdir()ed. */\n    protected SortedSet<String> dirsMade;\n\n    /** For a given Zip file, process each entry. */\n    public void unZip(String fileName) {\n        dirsMade = new TreeSet<String>();\n        try {\n            zippy = new ZipFile(fileName);\n            @SuppressWarnings(\"unchecked\")\n            Enumeration<ZipEntry> all = (Enumeration<ZipEntry>) zippy.entries();\n            while (all.hasMoreElements()) {\n                getFile((ZipEntry)all.nextElement());\n            }\n        } catch (IOException err) {\n            System.err.println(\"IO Error: \" + err);\n            return;\n        }\n    }\n\n    protected boolean warnedMkDir = false;\n\n    /** Process one file from the zip, given its name.\n * Either print the name, or create the file on disk.\n */\n    protected void getFile(ZipEntry e) throws IOException {\n        String zipName = e.getName();\n        switch (mode) {\n        case EXTRACT:\n            if (zipName.startsWith(\"/\")) {\n                if (!warnedMkDir)\n                    System.out.println(\"Ignoring absolute paths\");\n                warnedMkDir = true;\n                zipName = zipName.substring(1);\n            }\n            // if a directory, just return. We mkdir for every file,\n            // since some widely used Zip creators don't put out\n            // any directory entries, or put them in the wrong place.\n            if (zipName.endsWith(\"/\")) {\n                return;\n            }\n            // Else must be a file; open the file for output\n            // Get the directory part.\n            int ix = zipName.lastIndexOf('/');\n            if (ix > 0) {\n                String dirName = zipName.substring(0, ix);\n                if (!dirsMade.contains(dirName)) {\n                    File d = new File(dirName);\n                    // If it already exists as a dir, don't do anything\n                    if (!(d.exists() && d.isDirectory())) {\n                        // Try to create the directory, warn if it fails\n                        System.out.println(\"Creating Directory: \" + dirName);\n                        if (!d.mkdirs()) {\n                            System.err.println(\n                            \"Warning: unable to mkdir \" + dirName);\n                        }\n                        dirsMade.add(dirName);\n                    }\n                }\n            }\n            System.err.println(\"Creating \" + zipName);\n            FileOutputStream os = new FileOutputStream(zipName);\n            InputStream  is = zippy.getInputStream(e);\n            int n = 0;\n            while ((n = is.read(b)) >0)\n                os.write(b, 0, n);\n            is.close();\n            os.close();\n            break;\n        case LIST:\n            // Not extracting, just list\n            if (e.isDirectory()) {\n                System.out.println(\"Directory \" + zipName);\n            } else {\n                System.out.println(\"File \" + zipName);\n            }\n            break;\n        default:\n            throw new IllegalStateException(\"mode value (\" + mode + \") bad\");\n        }\n    }\n}\n```", "```java\nInputStream is = getClass().getResourceAsStream(\"foo.properties\");\n// then do something with the InputStream...\n```", "```java\nClass<?> c = getClass();\nInputStream isOne = getResourceAsStream(\"/one.txt\");\t// note leading slash\nInputStream isTwo = getResourceAsStream(\"two.txt\");\t// without leading slash\n```", "```java\n        println(\"exists\", Files.exists(Path.of(\"/\")));\n        println(\"isDirectory\", Files.isDirectory(Path.of(\"/\")));\n        println(\"isExecutable\", Files.isExecutable(Path.of(\"/bin/cat\")));\n        println(\"isHidden\", Files.isHidden(Path.of(\"~/.profile\")));\n        println(\"isReadable\", Files.isReadable(Path.of(\"lines.txt\")));\n        println(\"isRegularFile\", Files.isRegularFile(Path.of(\"lines.txt\")));\n        println(\"isSameFile\", Files.isSameFile(Path.of(\"lines.txt\"),\n            Path.of(\"../main/lines.txt\")));\n        println(\"isSymbolicLink\", Files.isSymbolicLink(Path.of(\"/var\")));\n        println(\"isWritable\", Files.isWritable(Path.of(\"/tmp\")));\n        println(\"isDirectory\", Files.isDirectory(Path.of(\"/\")));\n        println(\"notexists\",\n            Files.notExists(Path.of(\"no_such_file_as_skjfsjljwerjwj\")));\n        println(\"probeContentType\", Files.probeContentType(Path.of(\"lines.txt\")));\n        println(\"readSymbolicLink\", Files.readSymbolicLink(Path.of(\"/var\")));\n        println(\"size\", Files.size(Path.of(\"lines.txt\")));\n```", "```java\nprobeContentType returned text/plain\nreadSymbolicLink returned private/var\nsize returned 78\n```", "```java\npublic class FileStatus {\n    public static void main(String[] argv) throws IOException {\n\n        // Ensure that a filename (or something) was given in argv[0]\n        if (argv.length == 0) {\n            System.err.println(\"Usage: FileStatus filename\");\n            System.exit(1);\n        }\n        for (String a : argv) {\n            status(a);\n        }\n    }\n\n    public static void status(String fileName) throws IOException {\n        System.out.println(\"---\" + fileName + \"---\");\n\n        // Construct a Path object for the given file.\n        Path p = Path.of(fileName);\n\n        // See if it actually exists\n        if (!Files.exists(p)) {\n            System.out.println(\"file not found\");\n            System.out.println();    // Blank line\n            return;\n        }\n        // Print full name\n        System.out.println(\"Canonical name \" + p.normalize());\n        // Print parent directory if possible\n        Path parent = p.getParent();\n        if (parent != null) {\n            System.out.println(\"Parent directory: \" + parent);\n        }\n        // Check if the file is readable\n        if (Files.isReadable(p)) {\n            System.out.println(fileName + \" is readable.\");\n        }\n        // Check if the file is writable\n        if (Files.isWritable(p)) {\n            System.out.println(fileName + \" is writable.\");\n        }\n\n        // See if file, directory, or other. If file, print size.\n        if (Files.isRegularFile(p)) {\n            // Report on the file's size and possibly its type\n            System.out.printf(\"File size is %d bytes, content type %s\\n\",\n                    Files.size(p),\n                    Files.probeContentType(p));\n        } else if (Files.isDirectory(p)) {\n            System.out.println(\"It's a directory\");\n        } else {\n            System.out.println(\"I dunno! Neither a file nor a directory!\");\n        }\n\n        // Report on the modification time.\n        final FileTime d = Files.getLastModifiedTime(p);\n        System.out.println(\"Last modified \" + d);\n\n        System.out.println();    // blank line between entries\n    }\n```", "```java\nC:\\javasrc\\dir_file>java dir_file.FileStatus   / /tmp/id /autoexec.bat\n---/---\nCanonical name C:\\\nFile is readable.\nFile is writable.\nLast modified 1970-01-01T00:00:00.00000Z\nIt's a directory\n\n---/tmp/id---\nfile not found\n\n---/autoexec.bat---\nCanonical name C:\\AUTOEXEC.BAT\nParent directory: \\\nFile is readable.\nFile is writable.\nLast modified 2019-10-13T12:43:05.123918Z\nFile size is 308 bytes.\n```", "```java\n$ java dir_file.FileStatus / /tmp/id /autoexec.bat\n---/---\nCanonical name /\nFile is readable.\nIt's a directory\nLast modified 2019-12-16T01:14:05.226108Z\n\n---/tmp/id---\nCanonical name /tmp/id\nParent directory: /tmp\nFile is readable.\nFile is writable.\nFile size is 36768 bytes, content type null\nLast modified 2019-12-21T18:46:27.402108Z\n\n---/autoexec.bat---\nfile not found\n\n$\n```", "```java\njshell> Path p = Path.of(\"/\");\np ==> /\n\njshell> File f = p.toFile();\nf ==> /\n```", "```java\njshell> File f = new File(\"/\");\nf ==> /\n\njshell> Path p = f.toPath();\np ==> /\n```", "```java\n/** Create file(s) by name. Final \"e\" omitted in homage to UNIX system call. */\npublic class Creat {\n    public static void main(String[] argv) throws IOException {\n\n        // Ensure that a filename (or something) was given in argv[0]\n        if (argv.length == 0) {\n            throw new IllegalArgumentException(\"Usage: Creat filename [...]\");\n        }\n\n        for (String arg : argv) {\n            // Constructing a Path object doesn't affect the disk, but\n            // the Files.createFile() method does.\n            final Path p = Path.of(arg);\n            final Path created = Files.createFile(p);\n            System.out.println(created);\n        }\n    }\n}\n```", "```java\nshell> Files.createDirectory(Path.of(\"/Users/ian/abc\"))\n$11 ==> /Users/ian/abc\n```", "```java\njshell> Files.createDirectory(Path.of(\"/Users/ian/once/twice/again\"))\n```", "```java\njshell> Files.createDirectories(Path.of(\"/Users/ian/once/twice/again\"))\n$14 ==> /Users/ian/once/twice/again\n```", "```java\npublic class Rename {\n    public static void main(String[] argv) throws IOException {\n\n        // Construct the Path object. Does NOT create a file on disk!\n        final Path p = Path.of(\"MyCoolDocument\"); // The file we will rename\n\n        // Setup for the demo: create a new \"old\" file\n        final Path oldName = Files.exists(p) ? p : Files.createFile(p);\n\n        // Rename the backup file to \"mydoc.bak\"\n        // Renaming requires a Path object for the target.\n        final Path newName = Path.of(\"mydoc.bak\");\n        Files.deleteIfExists(newName); // In case previous run left it there\n        Path p2 = Files.move(oldName, newName);\n        System.out.println(p + \" renamed to \" + p2);\n    }\n}\n```", "```java\njshell> var f = File.createTempFile(\"foo\", \"bar\");\nf ==> /tmp/foo9391300789087780984bar\n\njshell> f.createNewFile();\n$4 ==> false\n\njshell> f.setReadOnly();\n$5 ==> true\n\njshell> f.canRead();\n$6 ==> true\n\njshell> f.canWrite();\n$7 ==> false\n\njshell> f.setReadable(true);\n$8 ==> true\n\njshell> f.canWrite();\n$9 ==> false\n\njshell> f.setReadable(false, false);\n$10 ==> true\n\njshell> f.canWrite();\n$11 ==> false\n```", "```java\npublic class Delete {\n    public static void main(String[] argv) throws IOException {\n\n        // Construct a File object for the backup created by editing\n        // this source file. The file probably already exists.\n        // Some text editors create backups by putting ~ at end of filename.\n        File bkup = new File(\"Delete.java~\");\n        // Now, delete it:\n        bkup.delete();\n    }\n}\n```", "```java\npublic class Delete2 {\n\n    static boolean hard = false; // True for delete, false for deleteIfExists\n\n    public static void main(String[] argv) {\n        for (String arg : argv) {\n            if (\"-h\".equals(arg)) {\n                hard = true;\n                continue;\n            }\n            delete(arg);\n        }\n    }\n\n    public static void delete(String fileName) {\n        // Construct a File object for the file to be deleted.\n        final Path target = Path.of(fileName);\n\n        // Now, delete it:\n        if (hard) {\n            try {\n                System.out.print(\"Using Files.delete(): \");\n                Files.delete(target);\n                System.err.println(\"** Deleted \" + fileName + \" **\");\n            } catch (IOException e) {\n                System.out.println(\"Deleting \" + fileName + \" threw \" + e);\n            }\n        } else {\n            try {\n                System.out.print(\"Using deleteIfExists(): \");\n                if (Files.deleteIfExists(target)) {\n                    System.out.println(\"** Deleted \" + fileName + \" **\");\n                } else {\n                    System.out.println(\n                        \"Deleting \" + fileName + \" returned false.\");\n                }\n            } catch (IOException e) {\n                System.out.println(\"Deleting \" + fileName + \" threw \" + e);\n            }\n        }\n    }\n}\n```", "```java\n$ ls -ld ?\n-rw-r--r--  1 ian  512   0 Dec 21 16:35 a\ndrwxr-xr-x  2 ian  512  64 Dec 21 16:35 b\ndrwxr-xr-x  3 ian  512  96 Dec 21 16:22 c\n$ java -cp target/classes dir_file.Delete2 a b c d \nUsing deleteIfExists(): ** Deleted a **\nUsing deleteIfExists(): ** Deleted b **\nUsing deleteIfExists(): Deleting c threw\n  java.nio.file.DirectoryNotEmptyException: c\nUsing deleteIfExists(): Deleting d returned false.\n# Here I put the files back the way they were, then run again with -h\n$ java -cp target/classes dir_file.Delete2 -h a b c d\nUsing Files.delete(): ** Deleted a **\nUsing Files.delete(): ** Deleted b **\nUsing Files.delete(): Deleting c threw\n  java.nio.file.DirectoryNotEmptyException: c\nUsing Files.delete(): Deleting d threw java.nio.file.NoSuchFileException: d\n$ ls -l c\ntotal 2\ndrwxr-xr-x  2 ian  ian  512 Oct  8 16:50 d\n$ java dir_file.Delete2 c/d c\nUsing deleteIfExists(): ** Deleted c/d **\nUsing deleteIfExists(): ** Deleted c **\n$ \n```", "```java\npublic class TempFiles {\n    public static void main(String[] argv) throws IOException {\n\n        // 1\\. Making an existing file temporary\n        // Construct a File object for the backup created by editing\n        // this source file. The file probably already exists.\n        // My editor creates backups by putting ~ at the end of the name.\n        File bkup = new File(\"Rename.java~\");\n        // Arrange to have it deleted when the program ends.\n        bkup.deleteOnExit();\n\n        // 2\\. Create a new temporary file.\n\n        // Make a file object for foo.tmp, in the default temp directory\n        Path tmp = Files.createTempFile(\"foo\", \"tmp\");\n        // Report on the filename that it made up for us.\n        System.out.println(\"Your temp file is \" + tmp.normalize());\n        // Arrange for it to be deleted at exit.\n        tmp.toFile().deleteOnExit();\n        // Now do something with the temporary file, without having to\n        // worry about deleting it later.\n        writeDataInTemp(tmp);\n    }\n\n    public static void writeDataInTemp(Path tempFile) throws IOException {\n        // This version is dummy. Use your imagination.\n        Files.writeString(tempFile, \"This is a temp file\");\n    }\n}\n```", "```java\n$ java TempFiles.java\nYour temp file is /tmp/foo8423321910215054689tmp\n$ ls -l /tmp/foo8423321910215054689tmp\nls: /tmp/foo8423321910215054689tmp: No such file or directory\n$\n```", "```java\nFiles.list(Path.of(\".\")).forEach(System.out::println);\n```", "```java\npublic class Ls {\n    public static void main(String args[]) throws IOException {\n        Files.list(Path.of(\".\"))\n            .sorted()\n            .forEach(dir -> {\n                System.out.println(dir);\n            });\n    }\n}\n```", "```java\nFileSystems.getDefault().getRootDirectories().forEach(System.out::println);\n```", "```java\nC:> java dir_file.DirRoots\nA:\\\nC:\\\nD:\\\nC:>\n```", "```java\n$ java dir_file.DirRoots\n/\n$\n```", "```java\npublic class FileWatchServiceDemo {\n\n    final static String TEMP_DIR_PATH = \"/tmp\";\n    static final String FILE_SEMA_FOR = \"MyFileSema.for\";\n    final static Path SEMAPHORE_PATH = Path.of(TEMP_DIR_PATH ,FILE_SEMA_FOR);\n    static volatile boolean done = false;\n    final static ExecutorService threadPool = Executors.newSingleThreadExecutor();\n\n    public static void main(String[] args) throws Throwable {\n        String tempDirPath = \"/tmp\";\n        System.out.println(\"Starting watcher for \" + tempDirPath);\n        System.out.println(\"Semaphore file is \" + SEMAPHORE_PATH);\n        Path p = Paths.get(tempDirPath);\n        WatchService watcher =\n            FileSystems.getDefault().newWatchService();\n        Kind<?>[] watchKinds = { ENTRY_CREATE, ENTRY_MODIFY };\n        p.register(watcher, watchKinds);\n        threadPool.submit(new DemoService());\n        while (!done) {\n            WatchKey key = watcher.take();\n            for (WatchEvent<?> e : key.pollEvents()) {\n                System.out.println(\n                    \"Saw event \" + e.kind() + \" on \" +\n                    e.context());\n                if (e.context().toString().equals(FILE_SEMA_FOR)) {\n                    System.out.println(\"Semaphore found, shutting down watcher\");\n                    done = true;\n                }\n            }\n            if (!key.reset()) {\n                System.err.println(\"WatchKey failed to reset!\");\n            }\n        }\n    }\n\n    /**\n * Nested class whose only job is to wait a while, create a file in\n * the monitored directory, and then go away.\n */\n    private final static class DemoService implements Runnable {\n        public void run() {\n            try {\n                Thread.sleep(1000);\n                System.out.println(\"DemoService: Creating file\");\n                Files.deleteIfExists(SEMAPHORE_PATH); // clean up from previous run\n                Files.createFile(SEMAPHORE_PATH);\n                Thread.sleep(1000);\n                System.out.println(\"DemoService: Shutting down\");\n            } catch (Exception e) {\n                System.out.println(\"Caught UNEXPECTED \" + e);\n            }\n        }\n    }\n}\n```", "```java\n// package com.darwinsys.io;\npublic class FileSaver {\n\n    private enum State {\n        /** The state before and after use */\n        AVAILABLE,\n        /** The state while in use */\n        INUSE\n    }\n    private State state;\n    private final Path inputFile;\n    private final Path tmpFile;\n    private final Path backupFile;\n\n    private OutputStream mOutputStream;\n    private Writer mWriter;\n\n    public FileSaver(Path inputFile) throws IOException {\n\n        // Step 1: Create temp file in right place; must be on same disk\n        // as the original file, to avoid disk-full troubles later.\n        this.inputFile = inputFile;\n        tmpFile = Path.of(inputFile.normalize() + \".tmp\");\n        Files.createFile(tmpFile);\n        tmpFile.toFile().deleteOnExit();\n        backupFile = Path.of(inputFile.normalize() + \".bak\");\n        state = State.AVAILABLE;\n    }\n\n    /**\n * Return a reference to the contained File object, to\n * promote reuse (File objects are immutable so this\n * is at least moderately safe). Typical use would be:\n * <pre>\n * if (fileSaver == null ||\n *   !(fileSaver.getFile().equals(file))) {\n *        fileSaver = new FileSaver(file);\n * }\n * </pre>\n * @return the File object for the file to be saved\n */\n    public Path getFile() {\n        return inputFile;\n    }\n\n    /** Return an output file that the client should use to\n * write the client's data to.\n * @return An OutputStream, which should be wrapped in a\n *     buffered OutputStream to ensure reasonable performance.\n * @throws IOException if the temporary file cannot be written\n */\n    public OutputStream getOutputStream() throws IOException {\n\n        if (state != State.AVAILABLE) {\n            throw new IllegalStateException(\"FileSaver not opened\");\n        }\n        mOutputStream = Files.newOutputStream(tmpFile);\n        state = State.INUSE;\n        return mOutputStream;\n    }\n\n    /** Return an output file that the client should use to\n * write the client's data to.\n * @return A BufferedWriter to write on the new file.\n * @throws IOException if the temporary file cannot be written\n */\n    public Writer getWriter() throws IOException {\n\n        if (state != State.AVAILABLE) {\n            throw new IllegalStateException(\"FileSaver not opened\");\n        }\n        mWriter = Files.newBufferedWriter(tmpFile);\n        state = State.INUSE;\n        return mWriter;\n    }\n\n    /** Close the output file and rename the temp file to the original name.\n * @throws IOException If anything goes wrong\n */\n    public void finish() throws IOException {\n\n        if (state != State.INUSE) {\n            throw new IllegalStateException(\"FileSaver not in use\");\n        }\n\n        // Ensure both are closed before we try to rename.\n        if (mOutputStream != null) {\n            mOutputStream.close();\n        }\n        if (mWriter != null) {\n            mWriter.close();\n        }\n\n        // Delete the previous backup file if it exists.\n        Files.deleteIfExists(backupFile);\n\n        // Rename the user's previous file to itsName.bak,\n        // UNLESS this is a new file.\n        if (Files.exists(inputFile) &&\n            Files.move(inputFile, backupFile) == null) {\n            throw new IOException(\n                \"Could not rename file to backup file \" + backupFile);\n        }\n\n        // Rename the temporary file to the save file.\n        if (Files.move(tmpFile, inputFile) == null) {\n            throw new IOException(\"Could not rename temp file to save file\");\n        }\n        state = State.AVAILABLE;\n    }\n}\n```", "```java\nFiles.walk(startingPath).forEach(path -> {\n\t// Do something with Path path; might be file, directory or other...\n}\n```", "```java\n/**\n * Find - find files by name, size, or other criteria. Non-GUI version.\n */\npublic class Find {\n\n    public enum Conjunction { AND, OR };\n\n    private static Logger logger = Logger.getLogger(Find.class.getSimpleName());\n    static boolean started;\n\n    /** Main program\n * @throws IOException If the Files.walkTree does so\n */\n    public static void main(String[] args) throws IOException {\n        Find finder = new Find();\n\n        if (args.length == 0) {\n            finder.startWalkingAt(\".\");\n        } else {\n            for (int i = 0; i < args.length; i++) {\n                if (args[i].charAt(0) == '-') {\n                    switch(args[i].substring(1)) {\n                    case \"name\":\n                        finder.filter.setNameFilter(args[++i]);\n                        continue;\n                    case \"size\":\n                        finder.filter.setSizeFilter(args[++i]);\n                        continue;\n//                    Not implemented by back-end yet\n//                    case \"a\":\n//                        finder.filter.addConjunction(Conjunction.AND);\n//                        continue;\n//                    case \"o\":\n//                        finder.filter.addConjunction(Conjunction.OR);\n//                        continue;\n                    default: throw new IllegalArgumentException(\n                        \"Unknown argument \" + args[i]);\n                    }\n                }\n                finder.startWalkingAt(args[i]);\n            }\n            if (!started) {\n                finder.startWalkingAt(\".\");\n            }\n        }\n    }\n\n    protected FindFilter filter = new FindFilter();\n\n    public static void usage() {\n        System.err.println(\n            \"Usage: Find [-n namefilter][-s sizefilter][dir...]\");\n        System.exit(1);\n    }\n\n    /** doName - handle one filesystem object by name */\n    private void startWalkingAt(String s) throws IOException {\n        logger.info(\"doName(\" + s + \")\");\n        started = true;\n        Path f = Path.of(s);\n        if (!Files.exists(f)) {\n            System.out.println(s + \" does not exist\");\n            return;\n        }\n        Files.walk(f).forEach(fp -> {\n            try {\n                if (Files.isRegularFile(fp))\n                    doFile(fp);\n                else if (Files.isDirectory(fp)) {\n                    doDir(fp);\n                } else {\n                    System.err.println(\"Unknown type: \" + s);\n                }\n            } catch (IOException e) {\n                throw new RuntimeException(\"IO Exception: \" + e);\n            }\n        });\n    }\n\n    /** doFile - process one regular file.\n * @throws IOException */\n    private void doFile(Path f) throws IOException {\n        if (filter.accept(f)) {\n            System.out.println(\"f \" + f);\n        }\n    }\n\n    /** doDir - process a directory */\n    private void doDir(Path d) {\n        System.out.println(\"d \" + d.normalize());\n    }\n}\n```", "```java\n/** Class to encapsulate the filtration for Find.\n * For now just set*Filter() methods. Really needs to be a real\n * data structure (maybe LinkedList<FilterOp> or a Tree) for complex\n * requests like:\n *    -n \"*.html\" -a \\( -size < 0 -o mtime < 5 \\).\n */\npublic class FindFilter {\n    private enum SizeMode {GT, EQ, LT};\n    SizeMode sizeMode;\n    Find.Conjunction conj;\n    long size;\n    String name;\n    Pattern nameRE;\n    boolean debug = false;\n\n    void setSizeFilter(String sizeFilter) {\n        System.out.println(\"FindFilter.setSizeFilter()\");\n        sizeMode = SizeMode.EQ;\n        char c = sizeFilter.charAt(0);\n        if (c == '+') {\n            sizeMode = SizeMode.GT;\n            sizeFilter = sizeFilter.substring(1);\n        } else {\n            if (c == '-') {\n                sizeMode = SizeMode.LT;\n                sizeFilter = sizeFilter.substring(1);\n            }\n        }\n        size = Long.parseLong(sizeFilter);\n    }\n\n    /** Add a conjunction */\n    public void addConjunction(Find.Conjunction conj) {\n        System.out.println(\"FindFilter.addConjunction()\");\n        if (this.conj != null) {\n            throw new IllegalArgumentException(\n                \"Only one conjucntion allowed in this version\");\n        }\n        this.conj = conj;\n    }\n\n    /** Convert the given shell wildcard pattern into internal form (an RE) */\n    void setNameFilter(String nameToFilter) {\n        nameRE = makeNameFilter(nameToFilter);\n    }\n\n    Pattern makeNameFilter(String name) {\n        StringBuilder sb = new StringBuilder('^');\n        for (char c : name.toCharArray()) {\n            switch(c) {\n                case '.':    sb.append(\"\\\\.\"); break;\n                case '*':    sb.append(\".*\"); break;\n                case '?':    sb.append('.'); break;\n                // Some chars are special to RE and have to be escaped\n                case '[':    sb.append(\"\\\\[\"); break;\n                case ']':    sb.append(\"\\\\]\"); break;\n                case '(':    sb.append(\"\\\\(\"); break;\n                case ')':    sb.append(\"\\\\)\"); break;\n                default:    sb.append(c); break;\n            }\n        }\n        sb.append('$');\n        if (debug) {\n            System.out.println(\"RE=\\\"\" + sb + \"\\\".\");\n        }\n        // Should catch PatternException and rethrow for better diagnostics\n        return Pattern.compile(sb.toString());\n    }\n\n    /** Do the filtering. For now, only filter on name, size or name+size */\n    public boolean accept(Path p) throws IOException {\n        if (debug) {\n            System.out.println(\"FindFilter.accept(\" + p + \")\");\n        }\n\n        if (nameRE != null) {\n            return nameRE.matcher(p.getFileName().toString()).matches();\n        }\n\n        // size handling\n        if (sizeMode != null) {\n            long sz = Files.size(p);\n            switch (sizeMode) {\n            case EQ:\n                return (sz == size);\n            case GT:\n                return (sz > size);\n            case LT:\n                return (sz < size);\n            }\n        }\n\n        // Catchall\n        return false;\n    }\n\n    public String getName() {\n        return name;\n    }\n}\n```"]