- en: 'Chapter 10\. Input and Output: Reading, Writing, and Directory Tricks'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 10 章。输入和输出：读取、写入和目录技巧
- en: 10.0 Introduction
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10.0 介绍
- en: Most programs need to interact with the outside world, and one common way of
    doing so is by reading and writing files. Files are normally on some persistent
    medium such as a disk drive; and, for the most part, we shall happily ignore the
    differences between files on a hard disk (and all the operating system–dependent
    filesystem types), a USB drive or SD card, a DVD-ROM, and other memory devices.
    For now, they’re just files. And, like most other languages and OSes, Java extends
    the reading-and-writing model to network (socket) communications, which we’ll
    touch on in Chapters [12](ch12.html#javacook-netclient) and [13](ch13.html#javacook-netserver).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数程序都需要与外部世界进行交互，其中一种常见的方式是读取和写入文件。文件通常位于某种持久介质上，如磁盘驱动器；大部分时间，我们将忽略硬盘上文件（以及所有操作系统相关的文件系统类型）、USB
    驱动器或 SD 卡、DVD-ROM 和其他存储设备之间的差异。就目前而言，它们只是文件。而且，与大多数其他语言和操作系统一样，Java 将读取和写入模型扩展到网络（套接字）通信，我们将在第
    [12](ch12.html#javacook-netclient) 和 [13](ch13.html#javacook-netserver) 章中进行讨论。
- en: Java provides many classes for input and output; they are summarized in [Figure 10-1](#javacook-io-FIG-1).
    This chapter covers all the normal input/output operations such as opening/closing
    and reading/writing files. Files are assumed to reside on some kind of file store
    or permanent storage. Distributed filesystems such as Apache Hadoop HDFS, Sun’s
    Network File System (NFS, common on Unix and available for Windows), SMB (the
    Windows network filesystem, available for Unix via the open source Samba program),
    and FUSE (Filesystem in User SpacE, implementations for most Unix/Linux systems)
    are assumed to work just like disk filesystems, except where noted.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Java 提供了许多用于输入和输出的类；它们在[图 10-1](#javacook-io-FIG-1)中进行了总结。本章涵盖了所有常规的输入/输出操作，如打开/关闭和读取/写入文件。假设文件位于某种文件存储或永久存储中。假定分布式文件系统（如
    Apache Hadoop HDFS、Sun 的 Network File System（NFS，在 Unix 上很常见，并且可用于 Windows）、SMB（Windows
    网络文件系统，通过开源的 Samba 程序可用于 Unix）、以及 FUSE（Filesystem in User SpacE，在大多数 Unix/Linux
    系统上都有实现））与磁盘文件系统的工作方式相同，除非另有说明。
- en: 'The support for reading and writing is in two major parts:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 读取和写入的支持主要分为两个部分：
- en: The `InputStream`/`OutputStream`/`Reader`/`Writer` classes, which are the traditional
    ways of reading/writing files, have been largely unchanged since the days of Java
    1.0 and 1.1. In modern Java, a new class, `java.nio.file.Files`, is provided.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InputStream`/`OutputStream`/`Reader`/`Writer` 类，这些是传统的读取/写入文件的方式，自 Java 1.0
    和 1.1 以来基本未变。在现代 Java 中，提供了一个新类，`java.nio.file.Files`。'
- en: 'All modern operating systems provide the means to organize groups of files
    into directories, or folders. This chapter covers directories: how to create them,
    how to navigate them. `Files` provides most of the support for processing directories,
    but it also introduces a number of convenience routines for easily reading, writing,
    and copying files that are covered in this chapter. These are generally more convenient
    than using the traditional I/O classes. We cover both in this chapter.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有现代操作系统都提供了将文件组织成目录或文件夹的手段。本章涵盖了目录：如何创建它们，如何浏览它们。`Files`提供了大部分处理目录的支持，但它也引入了一些方便的例程，用于轻松读取、写入和复制文件，这些内容在本章中进行了讨论。这些通常比使用传统的
    I/O 类更方便。我们在本章中都进行了介绍。
- en: Warning
  id: totrans-7
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: There are two different uses of the term *stream*. The first is for a stream
    of bytes to be read or written, and is unrelated to the second use, which is used
    in modern Java to refer to a connection among cooperating methods. I’ll try to
    keep these meanings straight by only using `InputStream` and/or `OutputStream`
    for the former, and `Stream` for the latter.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 术语*流*有两种不同的用法。第一种是用于读取或写入的字节流，与第二种用法无关，后者用于现代 Java 中指的是协作方法之间的连接。我将尽量保持这些含义的准确性，只使用`InputStream`和/或`OutputStream`来表示前者，而使用`Stream`来表示后者。
- en: To give you control over the format of data that you read and write, the `Formatter`
    and `Scanner` classes provide formatting and scanning operations. `Formatter`
    allows many formatting tasks to be performed either into a `String` or to almost
    any output destination. `Scanner` parses many kinds of objects, again either from
    a `String` or from almost any input source. These are fairly powerful; each is
    given its own recipe in this chapter.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让你能够控制读取和写入数据的格式，`Formatter` 和 `Scanner` 类提供了格式化和扫描操作。`Formatter` 允许执行许多格式化任务，可以输出到
    `String` 或几乎任何输出目的地。`Scanner` 解析许多种类的对象，同样可以从 `String` 或几乎任何输入源获取。这些都非常强大；本章为每个类都提供了详细的说明。
- en: The second part of the chapter is largely devoted to the `Files` and `Path`
    classes in `java.nio.file`. These two classes provide the ability to list directories,
    obtain file status, rename and delete files on disk, create directories, and perform
    other filesystem operations. They also provide the ability to read a file line
    by line into a `Stream<String>`. These two classes together largely supplant the
    older `java.io.File` class. They were introduced in Java 7, so very little new
    code should be using the older `File` class.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的第二部分主要介绍了 `java.nio.file` 中的 `Files` 和 `Path` 类。这两个类提供了列出目录、获取文件状态、重命名和删除磁盘上的文件、创建目录以及执行其他文件系统操作的能力。它们还提供了逐行读取文件内容到
    `Stream<String>` 的能力。这两个类共同主要替代了较旧的 `java.io.File` 类。它们在 Java 7 中引入，因此很少有新代码应该使用旧的
    `File` 类。
- en: 'Note that many of the methods of this class attempt to modify the permanent
    file store, or disk filesystem, of the computer you run them on. Naturally, you
    might not have permission to change certain files in certain ways. This can be
    detected by the Java Virtual Machine’s `SecurityManager`, which will throw the
    unchecked exception `SecurityException` if you don’t have permission to do the
    attempted operation. But failure can also be detected by the underlying operating
    system: if the security manager approves it, but the user running your program
    lacks permissions on the directory, for example, you will either get back an indication
    (such as false) or an instance of the checked exception `IOException`. This must
    be caught (or declared in the `throws` clause) in any code that calls any method
    that tries to change the filesystem.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个类的许多方法试图修改计算机上的永久文件存储或磁盘文件系统。当然，你可能没有权限以某种方式更改某些文件。这可以被 Java 虚拟机的 `SecurityManager`
    检测到，如果你没有权限执行尝试的操作，它会抛出未检查的异常 `SecurityException`。但是如果安全管理器批准了操作，但运行程序的用户在目录上缺少权限，操作系统也可以检测到失败，例如返回一个指示（如
    `false`）或一个受检异常 `IOException` 的实例。必须在调用任何尝试更改文件系统的方法的任何代码中捕获（或在 `throws` 子句中声明）此异常。
- en: 10.1 About InputStreams/OutputStreams and Readers/Writers
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10.1 关于 InputStreams/OutputStreams 和 Readers/Writers
- en: Java provides two sets of classes for reading and writing. The `InputStream`/`OutputStream`
    section of package `java.io` (see [Figure 10-1](#javacook-io-FIG-1)) is for reading
    or writing bytes of data. Older languages tended to assume that a byte (which
    is a machine-specific collection of bits, usually eight bits on modern computers)
    is exactly the same thing as a character—a letter, digit, or other linguistic
    element. However, Java is designed to be used internationally, and eight bits
    is simply not enough to handle the many different character sets used around the
    world. Script-based languages, and pictographic languages like Chinese and Japanese,
    each have many more than 256 characters, the maximum that can be represented in
    an eight-bit byte. The unification of these many character code sets is called,
    not surprisingly, Unicode. Both Java and XML use Unicode as their character sets,
    allowing you to read and write text in any of these human languages. But you should
    use `Reader`s and `Writer`s, not `Stream`s, for textual data.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Java 提供了两组用于读取和写入的类。`java.io` 包中的 `InputStream`/`OutputStream` 部分（参见 [图 10-1](#javacook-io-FIG-1)）用于读取或写入数据字节。早期的语言倾向于假设字节（一种机器特定的位集合，在现代计算机上通常是八位）与字符——字母、数字或其他语言元素——完全相同。然而，Java
    设计用于国际化使用，八位并不足以处理世界各地使用的许多不同字符集。基于脚本的语言和象形文字语言如中文和日文，每种语言有超过 256 个字符，这是八位字节能表示的最大数量。这些多种字符编码集的统一称为
    Unicode，Java 和 XML 都使用 Unicode 作为其字符集，允许你读写任何这些人类语言的文本。但是对于文本数据应该使用 `Reader` 和
    `Writer`，而不是 `Stream`。
- en: Unicode itself doesn’t solve the entire problem. Many of these human languages
    were used on computers long before Unicode was invented, and they didn’t all pick
    the same representation as Unicode. And they all have zillions of files encoded
    in a particular representation that isn’t Unicode. So routines are needed when
    reading and writing to convert between Unicode `String` objects used inside the
    Java machine and the particular external representation in which a user’s files
    are written. These converters are packaged inside a powerful set of classes called
    `Reader`s and `Writer`s. `Reader`s and `Writer`s should always be used instead
    of `InputStream`s and `OutputStream`s when you want to deal with characters instead
    of bytes. We’ll see more on this conversion, and how to specify which conversion,
    a little later in this chapter.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Unicode 本身并不能解决所有问题。在 Unicode 发明之前，许多人类语言已经在计算机上使用，它们并不都选择了与 Unicode 相同的表示形式。它们都有大量以特定非
    Unicode 编码表示的文件。因此，在读写时需要一些例程来在 Java 虚拟机内部使用 Unicode `String` 对象和用户文件写入的特定外部表示之间进行转换。这些转换器被打包在一个强大的称为
    `Reader` 和 `Writer` 的类集合中。在处理字符而不是字节时，应始终使用 `Reader` 和 `Writer` 而不是 `InputStream`
    和 `OutputStream`。我们稍后在本章节将更详细地看到这种转换及如何指定转换。
- en: '![jcb4 1001](assets/jcb4_1001.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![jcb4 1001](assets/jcb4_1001.png)'
- en: Figure 10-1\. java.io classes
  id: totrans-16
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10-1\. java.io 类
- en: See Also
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: One topic *not* addressed in depth here is the reading/writing capabilities
    of `Channel`s classes in the Java “new I/O” package.^([1](ch10.html#idm45290657814168))
    This part of NIO is more complex to use than either `Files` or the input/output
    streams, and the benefits accrue primarily in large-scale server-side processing.
    [Recipe 4.5](ch04.html#javacook-regex-SECT-5) provides one example of using NIO.
    The NIO package is given full coverage in the book *[Java NIO](http://shop.oreilly.com/product/9780596002886.do)*
    by Ron Hitchens (O’Reilly).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有深入讨论 Java “新 I/O” 包中 `Channel` 类的读写能力。NIO 的这一部分比 `Files` 或输入/输出流更复杂，主要在大规模服务器端处理中获益。[Recipe
    4.5](ch04.html#javacook-regex-SECT-5) 提供了使用 NIO 的一个例子。Ron Hitchens 的书 *[Java NIO](http://shop.oreilly.com/product/9780596002886.do)*
    对 NIO 包进行了全面覆盖（O’Reilly）。
- en: 'Another topic not covered here is that of having the read or write occur concurrently
    with other program activity. This requires the use of threads, or multiple flows
    of control within a single program. Threaded I/O is a necessity in many programs:
    those reading from slow devices such as tape drives, those reading from or writing
    to network connections, and those with a GUI. For this reason, the topic is given
    considerable attention, in the context of multithreaded applications, in [Chapter 16](ch16.html#javacook-threads).'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个在此处未涵盖的主题是在读取或写入时与其他程序活动同时发生。这需要使用线程或单个程序内的多个控制流。多线程 I/O 在许多程序中是必需的：那些从缓慢设备（如磁带驱动器）读取的程序，那些从或向网络连接读取或写入的程序，以及那些具有
    GUI 的程序。因此，在多线程应用程序的上下文中，这一主题受到了相当的关注，详见[第 16 章](ch16.html#javacook-threads)。
- en: For traditional I/O topics, Elliotte Rusty Harold’s *[Java I/O](http://shop.oreilly.com/product/9780596527501.do)*,
    although somewhat dated, should be considered the antepenultimate documentation.
    The penultimate reference is the javadoc documentation, while the ultimate reference
    is, if you really need it, the source code for the Java API. Due in part to the
    quality of the javadoc documentation, I have not needed to refer to the source
    code in writing this chapter.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 对于传统 I/O 主题，虽然有些过时，Elliotte Rusty Harold 的书 *[Java I/O](http://shop.oreilly.com/product/9780596527501.do)*
    应被视为倒数第二的文档。倒数第一参考文献是 javadoc 文档，而最终的参考文献是，如果确实需要，Java API 的源代码。部分因为 javadoc 文档的质量，写作本章时我并未需要参考源代码。
- en: 10.2 Reading a Text File
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10.2 读取文本文件
- en: Problem
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: The Java documentation doesn’t have methods for opening files. How do I open
    and read a text file and then either process it a line at a time, or get a collection
    of all the lines?
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Java 文档没有打开文件的方法。如何打开并读取文本文件，然后逐行处理，或者获取所有行的集合？
- en: Solution
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the `Files::lines()` method, which returns a `Stream` of `String`s. Or,
    use `Files.newBufferedReader()`, `Files.newBufferedWriter()`, `Files.newInputStream()`,
    and `Files.newOutputStream()`. Or, construct a `FileReader` or a `FileInputStream`.
    Once you have that, construct a `BufferedReader`, and use the older `$$while ((line
    == readLine()) != null)$$` pattern.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Files::lines()` 方法，该方法返回一个 `Stream` 的 `String`。或者，使用 `Files.newBufferedReader()`、`Files.newBufferedWriter()`、`Files.newInputStream()`
    和 `Files.newOutputStream()`。或者构造一个 `FileReader` 或 `FileInputStream`。一旦您拥有这些，构造一个
    `BufferedReader`，并使用旧的 `$$while ((line == readLine()) != null)$$` 模式。
- en: Discussion
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: There is no explicit open operation,^([2](ch10.html#idm45290657786632)) perhaps
    as a kind of rhetorical flourish of the Java API’s object-oriented design.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 没有显式的打开操作，^([2](ch10.html#idm45290657786632)) 或许是 Java API 面向对象设计的一种修辞华丽。
- en: 'The quickest way to process a text file a line at a time is to use `Files.lines()`,
    which takes a `Path` argument and returns a functional `Stream<String>` into which
    it feeds the lines from the file:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 逐行处理文本文件的最快方法是使用 `Files.lines()`，该方法接受 `Path` 参数并返回一个功能性 `Stream<String>`，它将文件中的行输入其中：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `Files` class has several other static methods which open a file and read
    some or all of it:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`Files` 类还有几个静态方法，可以打开文件并读取部分或全部内容：'
- en: '`List<String> Files.readAllLines(Path)`'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`List<String> Files.readAllLines(Path)`'
- en: Reads the whole file into a `List<String>`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 将整个文件读入 `List<String>`。
- en: '`byte[] Files.readAllBytes`'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`byte[] Files.readAllBytes`'
- en: Reads the whole file into an array of bytes.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 将整个文件读入字节数组。
- en: There is a series of methods with names like `newReader()`, `newBufferedWriter()`,
    etc., each of which takes a `Path` argument and return the appropriate `Reader/Writer`
    or `InputStream/OutputStream`. A `Path` is a descriptor for an abstract path (filename)
    that may or may not exist. The explicit constructors for a `FileReader`, `FileWriter`,
    `FileInputStream`, or `FileOutputStream` take a filename or an instance of the
    older `File` class containing the path. These operations correspond to the “open”
    operation in most other languages’ I/O packages.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 存在一系列类似 `newReader()`、`newBufferedWriter()` 等方法，每个方法接受一个 `Path` 参数并返回相应的 `Reader/Writer`
    或 `InputStream/OutputStream`。`Path` 是一个描述可能存在或不存在的抽象路径（文件名）的描述符。`FileReader`、`FileWriter`、`FileInputStream`
    或 `FileOutputStream` 的显式构造函数接受文件名或包含路径的较旧 `File` 类的实例。这些操作对应于大多数其他语言 I/O 包中的“打开”操作。
- en: Historically, Java used to require use of the code pattern `while ((line ==
    readLine()) != null` to read lines from a `BufferedReader`. This still works,
    of course, and will continue to work until the last JavaBean sets in the west,
    in the far future.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在历史上，Java 曾要求使用代码模式 `while ((line == readLine()) != null` 从 `BufferedReader`
    中读取行。当然，这仍然有效，并将在 JavaBean 西部设置到位的遥远未来继续有效。
- en: '[Example 10-1](#javacook-CHAPTER-EX-readlines) shows the code for each of these
    ways of reading lines from a file.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 10-1](#javacook-CHAPTER-EX-readlines) 展示了从文件中读取行的每种方式的代码。'
- en: Example 10-1\. main/src/main/java/io/ReadLines.java (reading lines from a file)
  id: totrans-38
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-1\. main/src/main/java/io/ReadLines.java（从文件中读取行）
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Most of these methods can throw the checked exception `IOException`, so you
    must have a `throws` clause or a `try/catch` around these invocations.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数这些方法可以抛出检查异常 `IOException`，因此您必须在这些调用周围使用 `throws` 子句或 `try/catch`。
- en: 'If you create an `InputStream`, `OutputStream`, `Reader`, or `Writer`, you
    should close it when finished. This avoids memory leaks and, in the case of writing,
    ensures that all buffered data is actually written to disk. One way to ensure
    this is not forgotten is to use the try-with-resources syntax. This puts the declaration
    and definition of a `Closeable` resource into the `try` statement:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您创建了 `InputStream`、`OutputStream`、`Reader` 或 `Writer`，在完成后应该关闭它。这样可以避免内存泄漏，并且在写入的情况下确保所有缓冲数据实际写入磁盘。确保不会忘记这一点的一种方法是使用
    try-with-resources 语法。这将 `Closeable` 资源的声明和定义放入 `try` 语句中：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `lines()` and read-related methods in `Files` obviate the need for closing
    the resource, but not the need for handling `IOException`; the compiler or IDE
    will remind you if you forget those.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`Files` 中的 `lines()` 和读取相关方法消除了关闭资源的需要，但没有消除处理 `IOException` 的需要；如果忘记了这些，编译器或
    IDE 将提醒您。'
- en: 'There are options that can be passed to the `Files` methods that open a file;
    these are discussed in the sidebar [“Understanding I/O Options: StandardOpenOptions,
    FileAttribute, PosixFileAttribute, and More”](#javacook-ioOptions).'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给打开文件的 `Files` 方法的选项是可以选择的；这些选项在侧边栏 [“理解 I/O 选项：StandardOpenOptions、FileAttribute、PosixFileAttribute
    和更多”](#javacook-ioOptions) 中讨论过。
- en: 'To read the entire contents of a file into single string, in Java 8+, use `Files.readString()`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Java 8+中将文件的整个内容读取为单个字符串，请使用`Files.readString()`：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In older Java versions, use my `FileIO.readerToString()` method. This will read
    the entire named file into one long string, with embedded newline (*\n*) characters
    between each line. To read a binary file, use `Files.readAllBytes()` instead.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在旧版本的Java中，使用我的`FileIO.readerToString()`方法。这将把整个命名文件读取为一个长字符串，每行之间用嵌入的换行符（*\n*）分隔。要读取二进制文件，请改用`Files.readAllBytes()`。
- en: See Also
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: There is formal documentation online for [`File`s](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html)
    and [`Path`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Path.html).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 有关[`File`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html)和[`Path`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Path.html)的正式在线文档可供查阅。
- en: 10.3 Reading from the Standard Input or from the Console/Controlling Terminal
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10.3 从标准输入或控制台/控制终端读取
- en: Problem
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to read from the program’s standard input or directly from the program’s
    controlling terminal or console terminal.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望从程序的标准输入读取，或直接从程序的控制终端或控制台终端读取。
- en: Solution
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: For the standard input, read bytes by wrapping a `BufferedInputStream()` around
    `System.in`. For reading text, use an `InputStreamReader` and a `BufferedReader`.
    For the console or controlling terminal, use Java’s `System.console()` method
    to obtain a `Console` object, and use its methods.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 对于标准输入，通过在`System.in`周围包装`BufferedInputStream()`来读取字节。对于读取文本，使用`InputStreamReader`和`BufferedReader`。对于控制台或控制终端，请使用Java的`System.console()`方法获取`Console`对象，并使用其方法。
- en: Discussion
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Sometimes you really do need to read from the standard input, or console. One
    reason is that simple test programs are often console-driven. Another is that
    some programs naturally require a lot of interaction with the user and you want
    something faster than a GUI (consider an interactive mathematics or statistical
    exploration program). Yet another is piping the output of one program directly
    to the input of another, a very common operation among Unix users and quite valuable
    on other platforms, such as Windows, that support this operation.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 有时确实需要从标准输入或控制台读取。一个原因是简单的测试程序通常是控制台驱动的。另一个原因是某些程序自然需要与用户进行大量交互，并且您希望比GUI更快（考虑交互式数学或统计探索程序）。另一个原因是将一个程序的输出直接传递到另一个程序的输入，这在Unix用户中非常常见，也在其他支持此操作的平台（例如Windows）中非常有价值。
- en: Standard input
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标准输入
- en: Most desktop platforms support the notion of *standard input* (a keyboard, a
    file, or the output from another program) and *standard output* (a terminal window,
    a printer, a file on disk, or the input to yet another program). Most such systems
    also support a standard error output so that error messages can be seen by the
    user even if the standard output is being redirected. When programs on these platforms
    start up, the three streams are preassigned to particular platform-dependent handles,
    or *file descriptors*. The net result is that ordinary programs on these operating
    systems can read the standard input or write to the standard output or standard
    error stream without having to open any files or make any other special arrangements.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数桌面平台支持*标准输入*（键盘、文件或另一个程序的输出）和*标准输出*（终端窗口、打印机、磁盘上的文件或另一个程序的输入）。大多数这种系统还支持标准错误输出，以便用户即使重定向了标准输出，也能看到错误消息。当这些平台上的程序启动时，这三个流被预分配给特定的平台相关句柄或*文件描述符*。其最终结果是，这些操作系统上的普通程序可以在不需要打开任何文件或进行任何其他特殊安排的情况下读取标准输入或将数据写入标准输出或标准错误流。
- en: 'Java continues this tradition and enshrines it in the `System` class. The static
    variables `System.in`, `System.out`, and `System.err` are connected to the three
    operating system streams before your program begins execution (an application
    is free to reassign these; see [Recipe 10.10](#javacook-io-SECT-10)). So, to read
    the standard input, you need only refer to the variable `System.in` and call its
    methods. For example, to read one byte from the standard input, you call the read
    method of `System.in`, which returns the byte in an `int` variable:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Java延续了这一传统，并将其确立在`System`类中。静态变量`System.in`，`System.out`和`System.err`在程序执行之前与三个操作系统流相连接（应用程序可以重新分配这些；见[Recipe
    10.10](#javacook-io-SECT-10)）。因此，要读取标准输入，只需引用变量`System.in`并调用其方法。例如，要从标准输入读取一个字节，可以调用`System.in`的read方法，该方法将字节以`int`变量返回：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'But is that enough? No, because the `read()` method can throw an `IOException`.
    So you must either declare that your program throws an `IOException`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 但这足够吗？不，因为`read()`方法可能会抛出`IOException`。因此，您必须声明您的程序可能会抛出`IOException`：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Or you can put a `try`/`catch` block around the `read()` method:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 或者您可以在`read()`方法周围放置一个`try`/`catch`块：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this case, it makes sense to print the results inside the `try` block because
    there’s no point in trying to print the value you read, if the `read()` threw
    an `IOException`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，在`try`块内打印结果是有意义的，因为如果`read()`抛出`IOException`，则尝试打印读取的值是没有意义的。
- en: 'That code works and gives you the ability to read a byte at a time from the
    standard input. But most applications are designed in terms of larger units, such
    as integers, or a line of text. To read a value of a known type, such as `int`,
    from the standard input, you can use the `Scanner` class (covered in more detail
    in [Recipe 10.6](#javacook-io-SECT-5)):'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 那段代码可以让你从标准输入流中逐字节读取。但是大多数应用程序设计为处理更大的单元，如整数或文本行。要从标准输入中读取已知类型（如`int`）的值，可以使用`Scanner`类（详见[Recipe
    10.6](#javacook-io-SECT-5)）：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'For reading characters of text with an input character converter so that your
    program will work with multiple input encodings around the world, use a `Reader`
    class. The particular subclass that allows you to read lines of characters is
    a `BufferedReader`. But there’s a hitch. Remember I mentioned those two categories
    of input classes, `Stream`s and `Reader`s? But I also said that `System.in` is
    a `Stream`, and you want a `Reader`. How do you get from a `Stream` to a `Reader`?
    A crossover class called `InputStreamReader` is tailor-made for this purpose.
    Just pass your `Stream` (like `System.in`) to the `InputStreamReader` constructor
    and you get back a `Reader`, which you in turn pass to the `BufferedReader` constructor.
    The usual idiom for writing this in Java is to nest the constructor calls:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用输入字符转换器读取文本字符，以便程序能够处理全球多种输入编码，可以使用`Reader`类。特定的子类允许您读取字符行是`BufferedReader`。但是有一个问题。记得我提到过两种输入类别，`Stream`和`Reader`吗？但我也说过`System.in`是一个`Stream`，而你需要一个`Reader`。如何从`Stream`获得`Reader`？有一个专门用于此目的的交叉类叫做`InputStreamReader`。只需将您的`Stream`（如`System.in`）传递给`InputStreamReader`构造函数，您就会得到一个`Reader`，然后将其传递给`BufferedReader`构造函数。在Java中写这个通常的习惯用法是嵌套构造函数调用：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You can then read lines of text using the `readLine()` method. This method
    takes no argument and returns a `String` that is made up for you by `readLine()`
    containing the characters (converted to Unicode) from the next line of text in
    the file. When there are no more lines of text, the literal value `null` is returned:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以使用`readLine()`方法读取文本行。此方法不接受参数，并返回一个`String`，由`readLine()`为您准备，其中包含文件中下一行文本的字符（转换为Unicode）。当没有更多文本行时，返回字面值`null`：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To read a single `Integer` from the standard input, read a line and parse it
    using `Integer.parseInt()`. To read a series of integers, one per line, you could
    combine these with a functional style, since the `BufferedReader` has a `lines()`
    method that produces a `Stream<String>`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 要从标准输入读取单个`Integer`，请读取一行并使用`Integer.parseInt()`解析它。要逐行读取一系列整数，可以将这些与函数式风格结合起来，因为`BufferedReader`有一个生成`Stream<String>`的`lines()`方法：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The Console (Controlling Terminal)
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制台（控制终端）
- en: The `Console` class is intended for reading directly from a program’s controlling
    terminal. When you run an application from a *terminal window* or *command prompt
    window* on most systems, its console and its standard input are both connected
    to the terminal, by default. However, the standard input can be changed by piping
    or redirection on most OSes. If you really want to read from wherever the user
    is sitting, bypassing any indirections, then the `Console` class is usually your
    friend.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`Console`类用于直接从程序控制的终端读取。在大多数系统上，从*终端窗口*或*命令提示窗口*运行应用程序时，默认情况下，其控制台和标准输入都连接到终端。但是，标准输入可以通过大多数操作系统上的管道或重定向进行更改。如果您确实希望从用户所在位置读取，绕过任何间接操作，则`Console`类通常是您的好帮手。'
- en: You cannot instantiate `Console` yourself; you must get an instance from the
    `System` class’s `console()` method. You can then call methods such as `readLine()`,
    which behaves largely like the method of the same name in the `BufferedReader`
    class used in the previous recipe.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 您不能自己实例化`Console`；必须从`System`类的`console()`方法获取一个实例。然后，您可以调用诸如`readLine()`之类的方法，其行为基本与前面配方中使用的`BufferedReader`类中的同名方法相似。
- en: 'The following code shows an example of prompting for a name and reading it
    from the console:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了一个提示输入姓名并从控制台读取的示例：
- en: '*main/src/main/java/io/ConsoleRead.java*'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*main/src/main/java/io/ConsoleRead.java*'
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: One complication is that the `System.console()` method can return `null` if
    the console isn’t connected. Annoyingly, some IDEs, including Eclipse, don’t manage
    to set up a controlling terminal when you use the Run As→Java Application mechanism.
    So production-quality code should always check for `null` before trying to use
    the `Console`. If it fails, use a logger or just plain `System.out`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 一个复杂的情况是，如果控制台未连接，则 `System.console()` 方法可能返回 `null`。令人讨厌的是，一些 IDE，包括 Eclipse，在使用“Run
    As→Java Application”机制时无法设置控制终端。因此，生产质量的代码应始终在尝试使用控制台之前检查 `null`。如果失败了，请使用记录器或普通的
    `System.out`。
- en: 'One facility the `Console` class is quite useful for is reading a password
    without having it echo. This has been a standard facility of command-line applications
    for decades, as the most obvious way of preventing *shoulder surfing*—somebody
    looking over your shoulder to see your password. Nonecho password reading is now
    supported in Java: the `Console` class has a `readPassword()` method that takes
    a `prompt` argument, intended to be used like: `cons.readPassword("Password:")`.
    This method returns an array of bytes, which can be used directly in some encryption
    and security APIs, or can easily be converted into a `String`. It is generally
    advised to overwrite the byte array after use to prevent security leaks when other
    code can access the stack, although the benefits of this are probably reduced
    when you’ve constructed a `String`. There’s an example of this in the online code
    in *io/ReadPassword.java*.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`Console` 类非常有用的一个功能是在不回显密码的情况下读取密码。几十年来，这一直是命令行应用程序的标准功能，因为这是防止“窥视”的最明显方式——有人从你的肩膀上窥视你的密码。现在在
    Java 中支持不回显密码读取：`Console` 类有一个 `readPassword()` 方法，它接受一个 `prompt` 参数，应该像这样使用：`cons.readPassword("Password:")`。此方法返回一个字节数组，可以直接在某些加密和安全
    API 中使用，或者可以轻松地转换为 `String`。通常建议在使用后覆盖字节数组，以防止其他代码可以访问堆栈时发生安全泄漏，尽管当您构造了一个 `String`
    时，这种好处可能会减少。在线代码中有一个示例，在 *io/ReadPassword.java* 中。'
- en: 10.4 Printing with Formatter and printf
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10.4 使用 Formatter 和 printf 打印
- en: Problem
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want an easy way to use `java.util.Formatter` class’s capability for simple
    printing tasks.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要一种简单的方法来使用 `java.util.Formatter` 类的能力来进行简单的打印任务。
- en: Solution
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use `Formatter` for printing values with fine-grained control over the formatting.
    Use `String.format()` or `PrintWriter.printf()` / `PrintStream.printf()`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Formatter` 来以精细的控制方式打印值。使用 `String.format()` 或 `PrintWriter.printf()` /
    `PrintStream.printf()`。
- en: Discussion
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: The `Formatter` class is patterned after C’s `printf` routines. In fact, `PrintStream`
    and `PrintWriter` have convenience routines named `printf()` that simply delegate
    to the stream or writer’s `format()` method, which uses a default `Formatter`
    instance. Unlike in C, however, Java is a strongly typed language, so invalid
    arguments will throw an exception rather than generating gibberish. There are
    also convenience routines `static String.format()` and `printf()` in `PrintWRiter/PrintStream`
    for use when you want to format a `String` without the bother of creating the
    `Formatter` explicitly.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`Formatter` 类是模仿 C 语言的 `printf` 函数设计的。实际上，`PrintStream` 和 `PrintWriter` 都有名为
    `printf()` 的便利函数，它们简单地委托给流或写入器的 `format()` 方法，后者使用默认的 `Formatter` 实例。然而，与 C 不同，Java
    是一种强类型语言，因此无效的参数会抛出异常而不是生成无意义的结果。在 `PrintWriter/PrintStream` 中还有便利函数 `static String.format()`
    和 `printf()`，用于在不显式创建 `Formatter` 的情况下格式化 `String`。'
- en: 'The underlying `Formatter` class in `java.util` works on a `String` containing
    format codes. For each item that you want to format, you put a format code. The
    format code consists of a percent sign, optionally an argument number followed
    by a dollar sign, optionally a field width or precision, and a format type (e.g.,
    `d` for decimal integer, that is, an integer with no decimal point, and `f` for
    floating point). A simple use might look like the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util` 中的底层 `Formatter` 类可用于包含格式代码的 `String` 上。对于每个要格式化的项目，您都要放置一个格式代码。格式代码由一个百分号组成，可选地是一个参数编号后跟一个美元符号，可选地是一个字段宽度或精度，以及一个格式类型（例如，`d`
    表示十进制整数，即没有小数点的整数，`f` 表示浮点数）。简单的用法可能如下所示：'
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As shown in [Figure 10-2](#javacook-io-FIG-2), the “%1$04d” controls formatting
    of the year, and the “%2$f” controls formatting of the value of PI.^([3](ch10.html#idm45290656852712))
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 正如 [图 10-2](#javacook-io-FIG-2) 所示，“%1$04d” 控制年份的格式化，而“%2$f” 控制 PI 的值的格式化。^([3](ch10.html#idm45290656852712))
- en: '![jcb4 1002](assets/jcb4_1002.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![jcb4 1002](assets/jcb4_1002.png)'
- en: Figure 10-2\. Format codes examined
  id: totrans-93
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10-2\. 格式代码详解
- en: Many format codes are available; [Table 10-1](#javacook-io-TABLE-1) lists some
    of the more common ones. For a complete description, refer to the javadoc for
    `java.util.Formatter`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 许多格式代码可供选择；[表 10-1](#javacook-io-TABLE-1) 列出了一些较常见的代码。完整的描述请参考 `java.util.Formatter`
    的 javadoc。
- en: Table 10-1\. Formatter format codes
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 表 10-1\. 格式化器格式代码
- en: '| Code | Meaning |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| 代码 | 含义 |'
- en: '| --- | --- |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| c | Character (argument must be `char` or integral type containing valid
    character value). |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| c | 字符（参数必须是包含有效字符值的 `char` 或整型类型）。 |'
- en: '| d | “decimal int”—integer to be printed as a decimal (radix 10) with no decimal
    point (argument must be integral type). |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| d | “十进制整数”—以十进制（基数 10）打印的整数，没有小数点（参数必须是整型）。 |'
- en: '| f | Floating-point value with decimal fraction (must be numeric); field width
    may be followed by decimal point and fractional digit field width; e.g., 7.2f.
    |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| f | 带有小数部分的浮点值（必须是数字）；字段宽度后面可以跟小数点和小数位字段宽度；例如，7.2f。 |'
- en: '| e | Floating-point value in scientific notation. |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| e | 科学计数法表示的浮点数值。 |'
- en: '| g | Floating-point value, as per f or e, depending on magnitude. |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| g | 浮点值，根据大小选择 f 或 e。 |'
- en: '| s | Generic format; if value is null, prints “null”; else if arg implements
    `Formattable`, format as per `arg.formatTo()`; else format as per `arg.toString()`.
    |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| s | 通用格式；如果值为 null，则打印“null”；否则，如果 arg 实现了 `Formattable`，则按照 `arg.formatTo()`
    格式化；否则按照 `arg.toString()` 格式化。 |'
- en: '| t | Date codes; follow with secondary code. Common date codes are shown in
    [Table 10-2](#javacook-io-TABLE-2). Argument must be `long`, `Long`, `Calendar`,
    or `Date`. |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| t | 日期代码；后跟次要代码。常见的日期代码显示在 [表 10-2](#javacook-io-TABLE-2) 中。参数必须是 `long`、`Long`、`Calendar`
    或 `Date`。 |'
- en: '| n | Newline; insert the platform-dependent line ending character. |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| n | 换行；插入特定于平台的换行字符。 |'
- en: '| % | Insert a literal `%` character. |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| % | 插入字面上的 `%` 字符。 |'
- en: Note also that you may, but are not required to, put a *parameter order* number
    between the `%` and the format code. For example, in “%2$04d”, the “2$” means
    to format the *second* parameter, regardless of the order of the parameters. This
    is primarily useful with dates (see the following example, where you need to format
    several different portions of the same `Date` or `Calendar`, or any time you want
    to format the same object more than once) and in internationalization, where different
    languages may require words to be in a different order within a sentence.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，你可以但并非必须在 `%` 和格式代码之间放置一个*参数顺序*数字。例如，在“%2$04d”中，“2$”表示格式化*第二个*参数，而不管参数的顺序如何。这在日期（见下面的示例，在其中需要格式化相同的
    `Date` 或 `Calendar` 的几个不同部分）和国际化中特别有用，因为不同的语言可能要求句子中的单词以不同的顺序出现。
- en: Some examples of using a `Formatter` are shown in [Example 10-2](#javacook-io-EX-1).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一些使用 `Formatter` 的示例显示在 [示例 10-2](#javacook-io-EX-1) 中。
- en: Example 10-2\. main/src/main/java/io/FormatterDemo.java
  id: totrans-109
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-2\. main/src/main/java/io/FormatterDemo.java
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Running `FormatterDemo` produces this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `FormatterDemo` 会产生这样的结果：
- en: '[PRE14]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: For formatting date and time objects, a large variety of format codes are available—about
    40 in all. Date and time objects are discussed in [Chapter 6](ch06.html#javacook-dates).
    [Table 10-3](#javacook-io-TABLE-3) shows the more common date/time format codes.
    Each must be preceded by a `t`, so to format the first argument as a year, you
    would use `%1$tY`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 对于格式化日期和时间对象，可用的格式代码有很多——总共约有 40 个。日期和时间对象在 [第 6 章](ch06.html#javacook-dates)
    中讨论。[表 10-3](#javacook-io-TABLE-3) 显示了更常见的日期/时间格式代码。每个代码前必须带有一个 `t`，所以要将第一个参数格式化为年份，你会使用
    `%1$tY`。
- en: Table 10-2\. Formatting codes for dates and times
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 表 10-2\. 日期和时间的格式化代码
- en: '| Format code | Meaning |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| 格式代码 | 含义 |'
- en: '| --- | --- |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Y | Year (at least four digits) |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| Y | 年份（至少四位数字）。 |'
- en: '| m | Month as two-digit (leading zeros) number |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| m | 月份，两位数字（前导零）。 |'
- en: '| B | Locale-specific month name (b for abbreviated) |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| B | 本地化的月份名称（b 表示缩写）。 |'
- en: '| d | Day of month (two digits, leading zeros) |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| d | 日期的日（两位数字，前导零）。 |'
- en: '| e | Day of month (one or two digits) |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| e | 日期的日（一到两位数字）。 |'
- en: '| A | Locale-specific day of week (*a* for abbreviated) |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| A | 本地化的星期几（*a* 表示缩写）。 |'
- en: '| H or I | Hour in 24-hour (H) or 12-hour (I) format (two digits, leading zeros)
    |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| H 或 I | 24小时制（H）或12小时制（I）格式的小时（两位数，前导零） |'
- en: '| M | Minute (two digits) |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| M | 分钟（两位数） |'
- en: '| S | Second (two digits) |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| S | 秒（两位数） |'
- en: '| P/p | Locale-specific AM or PM in uppercase (if P) or lowercase (if p) |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| P/p | 区域设置特定的大写AM或PM（如果是P）或小写（如果是p） |'
- en: '| R or T | 24-hour time combination: %tH:%tM (if R) or %tH:%tM:%tS (if T) |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| R 或 T | 24小时制时间组合：%tH:%tM（如果是R）或%tH:%tM:%tS（如果是T） |'
- en: '| D | Date formatted as *`%tm/%td/%ty`* |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| D | 格式化为*`%tm/%td/%ty`*的日期 |'
- en: In my opinion, embedding these codes directly in applications that you distribute
    or make available as web applications is often a bad idea, because any direct
    use of them assumes that you know the correct order to print these fields in all
    locales around the world. Trust me, you don’t. Instead of these, I recommend the
    use of `DateTimeFormatter`, covered in [Recipe 6.2](ch06.html#javacook-dates-format),
    to control the order of arguments. However, for quick-and-dirty work, as well
    as for writing log or data files that must be in a given format because some other
    program reads them, these are OK.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的观点中，直接将这些代码嵌入到您分发或提供为Web应用程序的应用程序中通常是一个坏主意，因为对它们的任何直接使用都假定您知道如何正确地按照全球所有地区的顺序打印这些字段。相信我，你不知道。我建议使用`DateTimeFormatter`来控制参数的顺序，而不是这些代码，`DateTimeFormatter`在[配方 6.2](ch06.html#javacook-dates-format)中有介绍。然而，对于快速而粗糙的工作，以及写入必须以给定格式存在的日志或数据文件，这些代码是可以的。
- en: Some date examples are shown in [Example 10-3](#javacook-io-EX-2).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 一些日期示例显示在[示例 10-3](#javacook-io-EX-2)中。
- en: Example 10-3\. main/src/main/java/io/FormatterDates.java
  id: totrans-131
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-3\. main/src/main/java/io/FormatterDates.java
- en: '[PRE15]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Running this `FormatterDates` class produces the following output:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个`FormatterDates`类将产生以下输出：
- en: '[PRE16]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 10.5 Scanning Input with StreamTokenizer
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10.5 使用`StreamTokenizer`扫描输入
- en: Problem
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to scan a file with more fine-grained resolution than the `readLine()`
    method of the `BufferedReader` class and its subclasses.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要以比`BufferedReader`类及其子类的`readLine()`方法更细粒度的分辨率扫描文件。
- en: Solution
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use a `StreamTokenizer`, `readLine()` and a `StringTokenizer`, the `Scanner`
    class (see [Recipe 10.6](#javacook-io-SECT-5)), regular expressions ([Chapter 4](ch04.html#javacook-regex)),
    or one of several third-party parser generators.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`StreamTokenizer`、`readLine()`和`StringTokenizer`，`Scanner`类（见[配方 10.6](#javacook-io-SECT-5)），正则表达式（[第4章](ch04.html#javacook-regex)）或几种第三方解析器生成器之一。
- en: Discussion
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'Though you could, in theory, read a file one character at a time and analyze
    each character, that is a pretty low-level approach. The `read()` method in the
    `Reader` class is defined to return `int` so that it can use the time-honored
    value `-1` (defined as EOF in Unix *<stdio.h>* for years) to indicate that you
    have read to the end of the file:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然从理论上讲，您可以逐个字符读取文件并分析每个字符，但这是一个相当底层的方法。`Reader`类中的`read()`方法被定义为返回`int`，以便它可以使用古老的值`-1`（在Unix
    *<stdio.h>*中定义为EOF多年来）来指示您已经读取到文件的末尾：
- en: '*main/src/main/java/io/ReadCharsOneAtATime.java*'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*main/src/main/java/io/ReadCharsOneAtATime.java*'
- en: '[PRE17]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Notice the cast to `char`; the program compiles fine without it, but it does
    not print correctly because `c` is declared as `int`. Variable `c` must be declared
    `int` to be able to compare against the end-of-file value `-1`. For example, the
    integer value corresponding to capital A treated as an `int` prints as 65, whereas
    with `(char)` prints the character `A`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 注意将`c`转换为`char`；程序即使没有它也能编译通过，但由于`c`被声明为`int`，所以打印不正确。必须将变量`c`声明为`int`，以便能够将其与EOF值`-1`进行比较。例如，作为`int`处理的大写字母A对应的整数值为65，而使用`(char)`打印字符`A`。
- en: 'We discussed the `StringTokenizer` class extensively in [Recipe 3.1](ch03.html#javacook-strings-SECT-1).
    The combination of `readLine()` and `StringTokenizer` provides a simple means
    of scanning a file. Suppose you need to read a file in which each line consists
    of a name like *user@host.domain*, and you want to split the lines into users
    and host addresses. You could use this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[配方 3.1](ch03.html#javacook-strings-SECT-1)中广泛讨论了`StringTokenizer`类。`readLine()`和`StringTokenizer`的组合提供了一种简单的扫描文件的方法。假设您需要读取一个每行包含一个类似*user@host.domain*的名称的文件，并且您希望将行分成用户和主机地址。您可以使用这个：
- en: '[PRE18]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `StreamTokenizer` class in `java.util` provides slightly more capabilities
    for scanning a file. It reads characters and assembles them into words, or tokens.
    It returns these tokens to you along with a type code describing the kind of token
    it found. This type code is one of four predefined types (`StringTokenizer.TT_WORD`,
    `TT_NUMBER`, `TT_EOF`, or `TT_EOL` for the end-of-line) or the `char` value of
    an ordinary character (such as 32 for the space character). Methods such as `ordinaryCharacter()`
    allow you to specify how to categorize characters, while others such as `slashSlashComment()`
    allow you to enable or disable features.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 10-4](#javacook-io-EX-3) shows a `StreamTokenizer` used to implement
    a simple immediate-mode stack-based calculator:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'I read tokens as they arrive from the `StreamTokenizer`. Numbers are put on
    the stack. The four operators (`+`, `-`, `\*`, and `/`) are immediately performed
    on the two elements at the top of the stack, and the result is put back on the
    top of the stack. The `=` operator causes the top element to be printed, but is
    left on the stack so that you can say this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Example 10-4\. main/src/main/java/io/SimpleCalcStreamTok.java (simple calculator
    using StreamTokenizer)
  id: totrans-152
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 10.6 Scanning Input with the Scanner Class
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to scan a simple input file consisting of various numbers and strings
    in a known format.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Read with `Scanner`’s `next()` methods.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Scanner` class lets you read an input source by tokens, somewhat analogous
    to the `StreamTokenizer` described in [Recipe 10.5](#javacook-io-SECT-4). The
    `Scanner` is more flexible in some ways (it lets you break tokens based on spaces
    or regular expressions) but less in others (you need to know the kind of token
    you are reading). This class bears some resemblance to the C-language `scanf()`
    function, but in the `Scanner` you specify the input token types by calling methods
    like `nextInt()`, `nextDouble()`, and so on. Here is a simple example of scanning:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `Scanner` recognizes Java’s eight built-in types, in addition to `BigInteger`
    and `BigDecimal`. It can also return input tokens as `String`s or by matching
    regular expressions (see [Chapter 4](ch04.html#javacook-regex)). [Table 10-3](#javacook-io-TABLE-3)
    lists the “next” methods and corresponding “has” methods; the “has” method returns
    true if the corresponding “next” method would succeed. There is no `nextString()`
    method; just use `next()` to get the next token as a `String`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Table 10-3\. Scanner methods
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '| Returned type | “has” method | “next” method | Comment |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
- en: '| `String` | `hasNext()` | `next()` | The next complete token from this scanner
    |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
- en: '| `String` | `hasNext(Pattern)` | `next(Pattern)` | The next string that matches
    the given regular expression (regex) |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
- en: '| `String` | `hasNext(String)` | `next(String)` | The next token that matches
    the regex pattern constructed from the specified string |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
- en: '| `BigDecimal` | `hasNextBigDecimal()` | `nextBigDecimal()` | The next token
    of the input as a `BigDecimal` |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| `BigDecimal` | `hasNextBigDecimal()` | `nextBigDecimal()` | 输入中的下一个标记作为 `BigDecimal`
    类型 |'
- en: '| `BigInteger` | `hasNextBigInteger()` | `nextBigInteger()` | The next token
    of the input as a `BigInteger` |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| `BigInteger` | `hasNextBigInteger()` | `nextBigInteger()` | 输入中的下一个标记作为 `BigInteger`
    类型 |'
- en: '| `boolean` | `hasNextBoolean()` | `nextBoolean()` | The next token of the
    input as a `boolean` |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| `boolean` | `hasNextBoolean()` | `nextBoolean()` | 输入中的下一个标记作为 `boolean`
    类型 |'
- en: '| `byte` | `hasNextByte()` | `nextByte()` | The next token of the input as
    a `byte` |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `byte` | `hasNextByte()` | `nextByte()` | 输入中的下一个标记作为 `byte` 类型 |'
- en: '| `double` | `hasNextDouble()` | `nextDouble()` | The next token of the input
    as a `double` |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| `double` | `hasNextDouble()` | `nextDouble()` | 输入中的下一个标记作为 `double` 类型 |'
- en: '| `float` | `hasNextFloat()` | `nextFloat()` | The next token of the input
    as a `float` |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| `float` | `hasNextFloat()` | `nextFloat()` | 输入中的下一个标记作为 `float` 类型 |'
- en: '| `int` | `hasNextInt()` | `nextInt()` | The next token of the input as an
    `int` |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| `int` | `hasNextInt()` | `nextInt()` | 输入中的下一个标记作为 `int` 类型 |'
- en: '| `String` | N/A | `nextLine()` | Reads up to the end-of-line, including the
    line ending |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| `String` | N/A | `nextLine()` | 读取直到行尾，包括行尾标记 |'
- en: '| `long` | `hasNextLong()` | `nextLong()` | The next token of the input as
    a `long` |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| `long` | `hasNextLong()` | `nextLong()` | 输入中的下一个标记作为 `long` 类型 |'
- en: '| `short` | `hasNextShort()` | `nextShort()` | The next token of the input
    as a `short` |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| `short` | `hasNextShort()` | `nextShort()` | 输入中的下一个标记作为 `short` 类型 |'
- en: The `Scanner` class is constructed with an input source, which can be an `InputStream`,
    a `String`, or `Readable` (`Readable` is an interface that `Reader` and all its
    subclasses implement).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`Scanner` 类是使用输入源构造的，可以是 `InputStream`、`String` 或 `Readable`（`Readable` 是 `Reader`
    及其所有子类实现的接口）。'
- en: One way to use the `Scanner` class is based on the Iterator pattern, using `while
    (scanner.hasNext())` to control the iteration. [Example 10-5](#javacook-io-EX-4)
    shows the simple calculator from [Recipe 10.5](#javacook-io-SECT-4) rewritten^([4](ch10.html#idm45290655572552))
    to use the `Scanner` class.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Scanner` 类的一种方式是基于迭代器模式，使用 `while (scanner.hasNext())` 控制迭代。[示例 10-5](#javacook-io-EX-4)
    展示了从 [Recipe 10.5](#javacook-io-SECT-4)（简称）重写的简单计算器，以使用 `Scanner` 类。
- en: Example 10-5\. main/src/main/java/io/simpleCalcScanner.java (simple calculator
    using java.util.Scanner)
  id: totrans-181
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-5\. main/src/main/java/io/simpleCalcScanner.java（使用 java.util.Scanner
    的简单计算器）
- en: '[PRE23]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 10.7 Scanning Input with Grammatical Structure
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10.7 使用语法结构扫描输入
- en: Problem
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to parse a file whose structure can be described as grammatical (in
    the sense of computer languages, not natural languages).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要解析一个其结构可以描述为语法的文件（在计算机语言的意义上，而不是自然语言的意义上）。
- en: Solution
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use one of many parser generators.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 使用多个解析器生成器之一。
- en: Discussion
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'Although the `StreamTokenizer` class (see [Recipe 10.5](#javacook-io-SECT-4))
    and `Scanner` (see [Recipe 10.6](#javacook-io-SECT-5)) are useful, they know only
    a limited number of tokens and have no way of specifying that the tokens must
    appear in a particular order. To do more advanced scanning, you need some special-purpose
    scanning tools. Parser generators have a long history in computer science. The
    best-known examples are the C-language `yacc` (Yet Another Compiler Compiler)
    and `lex`, released with Seventh Edition Unix in the 1970s and discussed in *[lex
    & yacc](http://shop.oreilly.com/product/9781565920002.do)* by Doug Brown et al.
    (O’Reilly), and their open source clones *bison* and *flex*. These tools let you
    specify the lexical structure of your input using some pattern language such as
    regular expressions (see [Chapter 4](ch04.html#javacook-regex)). For example,
    you might say that an email address consists of a series of alphanumerics, followed
    by an at sign (@), followed by a series of alphanumerics with periods embedded,
    like this:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 `StreamTokenizer` 类（参见 [Recipe 10.5](#javacook-io-SECT-4)）和 `Scanner`（参见
    [Recipe 10.6](#javacook-io-SECT-5)）很有用，它们仅了解有限数量的标记，并且无法指定这些标记必须按特定顺序出现。要执行更高级的扫描，需要一些特殊用途的扫描工具。解析器生成器在计算机科学中有着悠久的历史。最著名的例子是
    C 语言中的 `yacc`（Yet Another Compiler Compiler）和 `lex`，它们在 1970 年代的第七版 Unix 中发布，并在
    *[lex & yacc](http://shop.oreilly.com/product/9781565920002.do)* 一书中由 Doug Brown
    等人（O’Reilly 出版）讨论过，以及它们的开源克隆 *bison* 和 *flex*。这些工具允许您使用诸如正则表达式之类的模式语言指定输入的词法结构。例如，您可以说一个电子邮件地址由一系列字母数字字符组成，后跟一个
    at 符号（@），后跟嵌入点的一系列字母数字字符，如下所示：
- en: '[PRE24]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The tool then writes code that recognizes the characters you have described.
    These tools also have a grammatical specification, which says, for example, that
    the keyword `EMAIL` must appear, followed by a colon, followed by a `name` token,
    as previously defined.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 该工具然后编写代码来识别你描述的字符。这些工具还有语法规范，例如关键字`EMAIL`必须出现，后跟一个冒号，然后是先前定义的`name`标记。
- en: 'There are several good third-party parser generator tools for Java. They vary
    widely based on complexity, power, and ease of use:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Java有几个好用的第三方解析器生成工具。它们根据复杂性、功能强大程度和易用性有很大的差异：
- en: One of the best known and most elaborate is [ANTLR](http://www.antlr.org).
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最著名和最复杂的之一是[ANTLR](http://www.antlr.org)。
- en: JavaCC is an open source project at [*https://javacc.org*](https://javacc.org).
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaCC是一个开源项目，位于[*https://javacc.org*](https://javacc.org)。
- en: JParsec lets you write the parser in straight Java, so it’s all built at compile
    time (most of the others require a separate parse generation step, with the build
    and debugging issues that raises). JParsec is on [GitHub](https://github.com/abailly/jparsec).
    * [JFlex](http://jflex.de) and [CUP](http://www2.cs.tum.edu/projects/cup) work
    together like the original *yacc* and *lex*, as grammar parser and lexical scanner,
    respectively.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JParsec允许你在纯Java中编写解析器，因此全部都是在编译时构建的（大多数其他工具需要单独的解析生成步骤，这会引起构建和调试问题）。JParsec位于[GitHub](https://github.com/abailly/jparsec)上。*[JFlex](http://jflex.de)和[CUP](http://www2.cs.tum.edu/projects/cup)共同工作，就像最初的*yacc*和*lex*一样，作为语法解析器和词法分析器。
- en: Parboiled uses *Parsing Expression Grammar* (PEG) to also build the parser at
    compile time. See [GitHub](https://github.com/sirthias/parboiled) for more information.
    * The *Rats!* parser generator is part of the [eXTensible Compiler Project](http://cs.nyu.edu/rgrimm/xtc)
    at New York University.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Parboiled使用*Parsing Expression Grammar*（PEG）也在编译时构建解析器。更多信息请参见[GitHub](https://github.com/sirthias/parboiled)。*
    *Rats!*解析器生成器是纽约大学的[eXTensible Compiler Project](http://cs.nyu.edu/rgrimm/xtc)的一部分。
- en: There are others; a more complete list is maintained at [Java Source](http://java-source.net/open-source/parser-generators).
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还有其他工具；维护在[Java Source](http://java-source.net/open-source/parser-generators)上的更完整的列表。
- en: These parser generators can be used to write grammars for a wide variety of
    programs, from simple calculators—such as the one in [Recipe 10.6](#javacook-io-SECT-5)—through
    HTML and CORBA/IDL, up to full Java and C/C++ parsers. Examples of these are included
    with the downloads. Unfortunately, the learning curve for parsers in general precludes
    providing a simple and comprehensive example here, let alone comparing them intelligently.
    Refer to the documentation and the numerous examples provided with each distribution.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这些解析器生成器可以用来编写各种程序的语法，从简单的计算器（例如[Recipe 10.6](#javacook-io-SECT-5)中的计算器）到HTML和CORBA/IDL，再到完整的Java和C/C++解析器。这些示例包含在下载中。不幸的是，解析器的学习曲线通常不允许在这里提供一个简单而全面的例子，更不用说智能地比较它们了。请参考每个发行版附带的文档和众多示例。
- en: As an alternative to using one of these, you could simply roll your own recursive
    descent parser; and once you learn how to do so, you may find it’s not really
    that difficult, quite possibly even less hassle than dealing with the extra parser
    generator software (depending on the complexity of the grammar involved, obviously).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 作为使用这些工具的替代方案，你可以简单地编写自己的递归下降解析器；一旦学会了如何做，你可能会发现这并不是真的那么困难，甚至可能比处理额外的解析器生成软件更少麻烦（显然这取决于所涉及语法的复杂性）。
- en: Java developers have a range of choices, including simple line-at-a-time scanners
    using `StringTokenizer`, fancier token-based scanners using `StreamTokenizer`,
    a `Scanner` class to scan simple tokens (see [Recipe 10.6](#javacook-io-SECT-5)),
    regular expressions (see [Chapter 4](ch04.html#javacook-regex)), and third-party
    solutions including grammar-based scanners based on the parsing tools listed here.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Java开发人员有多种选择，包括使用`StringTokenizer`进行逐行扫描、使用`StreamTokenizer`进行基于标记的扫描、使用`Scanner`类来扫描简单标记（参见[Recipe
    10.6](#javacook-io-SECT-5)）、使用正则表达式（参见[Chapter 4](ch04.html#javacook-regex)）以及基于这里列出的解析工具的基于语法的扫描器的第三方解决方案。
- en: 10.8 Copying a File
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10.8 复制文件
- en: Problem
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to copy a file in its entirety.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要完整地复制一个文件。
- en: Solution
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use one of the Java 11 `Files.copy()` methods. If on an older release, use the
    explicit read and write methods in the `Readers/Writer`s or `InputStream/OutputStream`s.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Java 11的`Files.copy()`方法之一。如果使用旧版本，请使用`Readers/Writer`或`InputStream/OutputStream`中的显式读取和写入方法。
- en: Discussion
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'The `Files` class has several overloads of a `copy` method that makes quick
    work of this requirement:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`Files`类有几个重载的`copy`方法，可以快速完成这个需求：'
- en: '[PRE25]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'For example:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE26]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Long ago, Java’s I/O facilities did not package a lot of the common operations
    like copying one file to another or reading a file into a `String`. So back then
    I wrote my own package of helper methods. Users of older JDK versions may want
    to use `FileIO` from my utilities package `com.darwinsys.util`. Here’s a simple
    demo program that uses `FileIO` to copy a source file to a backup file:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 很久以前，Java 的 I/O 设施并没有打包很多常见操作，比如复制一个文件到另一个文件或将文件读取到一个`String`中。所以那时我编写了自己的助手方法包。旧版
    JDK 的用户可能希望使用我工具包`com.darwinsys.util`中的`FileIO`。这里有一个简单的演示程序，使用`FileIO`将源文件复制到备份文件：
- en: '*main/src/demo/java/io/FileIoDemo.java*'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '*main/src/demo/java/io/FileIoDemo.java*'
- en: '[PRE27]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: My `copyFile` method takes several forms, depending on whether you have two
    filenames, a filename and a `PrintWriter`, and so on. The code for `FileIO` itself
    is not shown here but is online, in the darwinsys API download.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我的`copyFile`方法有几种形式，取决于你是否有两个文件名，一个文件名和一个`PrintWriter`等等。`FileIO`本身的代码没有显示在这里，但可以在线上找到，在
    darwinsys API 下载中。
- en: 10.9 Reassigning the Standard Streams
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10.9 重新分配标准流
- en: Problem
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to reassign one or more of the standard streams `System.in`, `System.out`,
    or `System.err`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要重新分配一个或多个标准流`System.in`，`System.out`或`System.err`。
- en: Solution
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Construct an `InputStream` or `PrintStream` as appropriate, and pass it to the
    appropriate set method in the `System` class.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 根据需要构造一个适当的`InputStream`或`PrintStream`，并将其传递给`System`类中的适当设置方法。
- en: Discussion
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: The ability to reassign these streams corresponds to what Unix (or DOS command
    line) users think of as *redirection*, or *piping*. This mechanism is commonly
    used to make a program read from or write to a file without having to explicitly
    open it and go through every line of code changing the read, write, print, etc.
    calls to refer to a different stream object. The open operation is performed by
    the command-line interpreter in Unix or DOS or by the calling class in Java.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 能够重新分配这些流对应于 Unix（或 DOS 命令行）用户所考虑的 *重定向* 或 *管道*。这种机制通常用于使程序从文件中读取或写入内容，而无需显式打开文件并逐行更改读取、写入、打印等调用以引用不同的流对象。在
    Unix 或 DOS 的命令行解释器中执行打开操作或在 Java 中调用的类中执行。
- en: 'Although you could just assign a new `PrintStream` to the variable `System.out`,
    best practice is to use the defined method to replace it:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以简单地将一个新的`PrintStream`赋给变量`System.out`，但最佳实践是使用定义的方法来替换它：
- en: '[PRE28]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The stream you use can be one that you’ve opened, as here, or one you inherited:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用的流可以是你打开的，如此处，也可以是你继承的：
- en: '[PRE29]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: It could also be a stream connected to or from another `Process` you’ve started
    (see [Recipe 18.1](ch18.html#javacook-otherlang-SECT-1)), a network socket, or
    a URL. Anything that gives you a stream can be used.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 它也可能是连接到或从另一个`Process`（参见 [Recipe 18.1](ch18.html#javacook-otherlang-SECT-1)）的流，一个网络套接字，或一个
    URL。任何提供流的东西都可以使用。
- en: 10.10 Duplicating a Stream as It Is Written; Reassigning Standard Streams
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10.10 在写入时复制流；重新分配标准流
- en: Problem
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want anything written to a stream, such as the standard output `System.out`
    or the standard error `System.err`, to appear there but *also* be logged in to
    a file.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望任何写入流的内容，比如标准输出`System.out`或标准错误`System.err`，既出现在那里，*也*被记录到文件中。
- en: Solution
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Subclass `PrintStream` and have its `write()` methods write to two streams.
    Then use `system.setErr()` or `setOut()` to replace the existing standard stream
    with a `PrintStream` subclass.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 子类化`PrintStream`并使其`write()`方法写入两个流。然后使用`system.setErr()`或`setOut()`来用一个`PrintStream`子类替换现有的标准流。
- en: Discussion
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'Some classes are meant to be subclassed. Here we’re just subclassing `PrintStream`
    and adding a bit of functionality: a second `PrintStream`! I wrote a class called
    `TeePrintStream`, named after the ancient Unix command *tee*. That command allowed
    you to duplicate, or tee off (from plumber’s pipe tee, not the game of golf or
    the local pest) a copy of the data being written on a pipeline between two programs.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 一些类是为了被子类化而设计的。在这里，我们只是子类化`PrintStream`并添加了一些功能：第二个`PrintStream`！我写了一个名为`TeePrintStream`的类，取名自古老的
    Unix 命令 *tee*。那个命令允许你在两个程序之间的管道上复制或“tee off”（来自水管工的管道tee，而不是高尔夫比赛或本地害虫）正在写入的数据的副本。
- en: 'The original Unix *tee* command is used like this: the `|` character creates
    a pipeline in which the standard output of one program becomes the standard input
    to the next. This often-used example of pipes shows how many users are logged
    into a Unix server:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 最初的Unix *tee*命令用法如下：`|`字符创建了一个管道，其中一个程序的标准输出成为下一个程序的标准输入。这个经常使用的管道示例展示了有多少用户登录到Unix服务器：
- en: '[PRE30]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This runs the *who* program (which lists who is logged in to the system, one
    name per line, along with the terminal port and login time) and sends its output,
    not to the terminal, but rather into the standard input of the word count (*wc*)
    program. Here, *wc* is being asked to count lines, not words, hence the `-l` option.
    To *tee* a copy of the intermediate data into a file, you might say:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 运行*who*程序（该程序列出已登录系统的用户，每行一个用户，以及终端端口和登录时间），并将其输出发送到*wc*程序的标准输入，而不是终端。这里，*wc*被要求计算行数，而不是单词数，因此使用了`-l`选项。要将中间数据的副本*tee*到文件中，可以这样说：
- en: '[PRE31]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'which creates a file *wholist* containing the data. For the curious, the file
    *wholist* might look something like this:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 创建包含数据的文件*wholist*。对于感兴趣的人，文件*wholist*可能看起来像这样：
- en: '[PRE32]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: So both the previous command sequences would print `3` as their output.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，前面两个命令序列的输出将打印`3`。
- en: '`TeePrintStream` is an attempt to capture the spirit of the *tee* command.
    It can be used like this:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`TeePrintStream`试图捕捉*tee*命令的精髓。可以像这样使用它：'
- en: '[PRE33]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '`System.setErr()` is a means of specifying the destination of text printed
    to `System.err` (there are also `System.setOut()` and `System.setIn()`). This
    code results in any messages that printed to `System.err` to print to wherever
    `System.err` was previously directed (normally the terminal, but possibly a text
    window in an IDE) and to the file *err.log*.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.setErr()`是指定将打印到`System.err`的文本输出目标的方法（还有`System.setOut()`和`System.setIn()`）。此代码导致打印到`System.err`的任何消息都打印到先前指定的位置（通常是终端，但可能是IDE中的文本窗口），以及文件*err.log*。'
- en: This technique is not limited to the three standard streams. A `TeePrintStream`
    can be passed to any method that wants a `PrintStream`. Or, for that matter, an
    `OutputStream`. And you can adapt the technique for `BufferedInputStreams`, `PrintWriters`,
    `BufferedReaders`, and so on.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术不仅限于三个标准流。可以将`TeePrintStream`传递给任何需要`PrintStream`的方法。或者，也可以适应于`BufferedInputStreams`、`PrintWriters`、`BufferedReaders`等。
- en: '[Example 10-6](#javacook-io-TeePrintStream) shows the source code for `TeePrintStream`.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 10-6](#javacook-io-TeePrintStream)展示了`TeePrintStream`的源代码。'
- en: Example 10-6\. main/src/main/java/io/TeePrintStream.java
  id: totrans-246
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-6\. main/src/main/java/io/TeePrintStream.java
- en: '[PRE34]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: It’s worth mentioning that I do *not* need to override all the polymorphic forms
    of `print()` and `println()`. Because these all ultimately use one of the forms
    of `write()`, if you override the `print` and `println` methods to do the *tee*-ing
    as well, you can get several additional copies of the data written out.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，我*不*需要重写所有`print()`和`println()`的多态形式。因为这些方法最终都使用`write()`的形式之一，如果你重写`print`和`println`方法来进行*tee*，你可以得到多个额外的数据副本输出。
- en: 10.11 Reading/Writing a Different Character Set
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10.11 读取/写入不同字符集
- en: Problem
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to read or write a text file using a particular encoding.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要使用特定编码读取或写入文本文件。
- en: Solution
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Convert the text to or from internal Unicode by specifying a converter when
    you construct an `InputStreamReader` or `PrintWriter`.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 当你构造一个`InputStreamReader`或`PrintWriter`时，通过指定转换器可以将文本转换为或从内部Unicode格式转换出来。
- en: Discussion
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Classes `InputStreamReader` and `OutputStreamWriter` are the bridge from byte-oriented
    `Stream`s to character-based `Reader`s. These classes read or write bytes and
    translate them to or from characters according to a specified character encoding.
    The UTF-16 character set used inside Java (`char` and `String` types) is a 16-bit
    character set. But most character sets—such as ASCII, Swedish, Spanish, Greek,
    Turkish, and many others—use only a small subset of that. In fact, many European
    language character sets fit nicely into 8-bit characters. Even the larger character
    sets (script-based and pictographic languages) don’t all use the same bit values
    for each particular character. The encoding, then, is a mapping between Java characters
    and an external storage format for characters drawn from a particular national
    or linguistic character set.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`InputStreamReader` 和 `OutputStreamWriter` 类是从字节导向的 `Stream` 到基于字符的 `Reader`
    的桥梁。这些类读取或写入字节并根据指定的字符编码将其转换为字符，或者从字符转换为字节。在 Java 中使用的 UTF-16 字符集（`char` 和 `String`
    类型）是一个 16 位字符集。但是，大多数字符集（如 ASCII、瑞典语、西班牙语、希腊语、土耳其语等）仅使用该字符集的一个小子集。事实上，许多欧洲语言字符集完全适合
    8 位字符。即使是更大的字符集（基于脚本和象形文字的语言），其每个特定字符并不都使用相同的位值。因此，编码是 Java 字符与从特定国家或语言字符集中提取的字符的外部存储格式之间的映射。'
- en: To simplify matters, the `InputStreamReader` and `OutputStreamWriter` constructors
    are the only places where you can specify the name of an encoding to be used in
    this translation. If you do not specify an encoding, the platform’s (or user’s)
    default encoding is used. `PrintWriters`, `BufferedReaders`, and the like all
    use whatever encoding the `InputStreamReader` or `OutputStreamWriter` class uses.
    Because these bridge classes only accept `Stream` arguments in their constructors,
    the implication is that if you want to specify a nondefault converter to read
    or write a file on disk, you must start by constructing not a `FileReader` or
    `FileWriter`, but a `FileInputStream` or `FileOutputStream`!
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 为简化事务，`InputStreamReader` 和 `OutputStreamWriter` 构造函数是此转换中唯一可以指定编码名称的地方。如果不指定编码，将使用平台（或用户）的默认编码。`PrintWriters`、`BufferedReaders`
    等都使用 `InputStreamReader` 或 `OutputStreamWriter` 类使用的编码。由于这些桥接类仅在其构造函数中接受 `Stream`
    参数，所以如果要指定非默认转换器以读取或写入磁盘上的文件，必须从构造`FileReader` 或 `FileWriter` 开始，而不是从`FileInputStream`
    或 `FileOutputStream` 开始！
- en: '[PRE35]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Not that it would necessarily make sense to read a single file from Kanji and
    output it in a Swedish encoding. For one thing, most fonts would not have all
    the characters of both character sets; and, at any rate, the Swedish encoding
    certainly has far fewer characters in it than the Kanji encoding. Besides, if
    that were all you wanted, you could use a JDK tool with the ill-fitting name *native2ascii*
    (see its documentation for details). A list of the supported encodings is also
    in the JDK documentation, in the file *docs/guide/internat/encoding.doc.html*.
    A more detailed description is found in Appendix B of *[Java I/O](http://shop.oreilly.com/product/9780596527501.do)*.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 并不是说从日语单个文件读取并以瑞典编码输出就一定有意义。首先，大多数字体并不包含两个字符集中的所有字符；而且，瑞典编码中的字符数肯定比日语编码少得多。此外，如果这是你想要的全部，你可以使用一个名字并不太合适的
    JDK 工具 *native2ascii*（详见其文档）。支持的编码列表也在 JDK 文档中，位于 *docs/guide/internat/encoding.doc.html*
    文件中。更详细的描述可见 *[Java I/O](http://shop.oreilly.com/product/9780596527501.do)* 的附录
    B。
- en: 10.12 Those Pesky End-of-Line Characters
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10.12 那些令人讨厌的换行字符
- en: Problem
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You really want to know about end-of-line characters.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 您真的想知道换行字符。
- en: Solution
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use `\r` and `\n` in whatever combination makes sense.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `\r` 和 `\n` 以合适的组合。
- en: Discussion
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: If you are reading text (or bytes containing ASCII characters) in line mode
    using the `readLine()` method, you’ll never see the end-of-line characters, and
    if you’re using a `PrintWriter` with its `println()` method, the same applies.
    Thus you won’t be cursed with having to figure out whether `\n`, `\r`, or `\r\n`
    appears at the end of each line.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用 `readLine()` 方法以行模式读取文本（或包含 ASCII 字符的字节），您将永远看不到换行字符；如果使用带有 `println()`
    方法的 `PrintWriter`，情况也是如此。因此，您无需费力弄清每行的 `\n`、`\r` 或 `\r\n` 的出现。
- en: 'If you want that level of detail, you have to read the characters or bytes
    one at a time, using the `read()` methods. The only time I’ve found this necessary
    is in networking code, where some of the line-mode protocols assume that the line
    ending is `\r\n`. Even here, though, you can still work in line mode. When writing,
    pass `\r\n` into the `print()` (not +deal with the characters:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要那种详细程度的信息，你必须逐个字符或字节地读取，使用 `read()` 方法。我发现这种情况必要的唯一时间是在网络编程中，其中一些线路模式协议假定行尾是
    `\r\n`。即使在这种情况下，你仍然可以在行模式下工作。在写入时，将 `\r\n` 传递给 `print()`（而不是 + 处理字符：
- en: '[PRE36]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: For the curious, the strange spelling of “hello” is used in SMTP, the mail sending
    protocol, where commands are four letters.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 对于好奇的人，"hello" 的奇怪拼写用于 SMTP，即邮件发送协议，其中命令是四个字母。
- en: 10.13 Beware Platform-Dependent File Code
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10.13 注意依赖于平台的文件代码
- en: Problem
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: Chastened by the previous recipe, you now wish to write only platform-independent
    code.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的示例中警觉之后，你现在希望编写仅限于平台的独立代码。
- en: Solution
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方法
- en: Use `readLine()` and `println()`. Avoid use of `\n` by itself; use `File.separator`
    if you must.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `readLine()` 和 `println()`。避免单独使用 `\n`；如果必须使用，使用 `File.separator`。
- en: Discussion
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'As mentioned in [Recipe 10.12](#javacook-io-SECT-12), if you just use `readLine()`
    and `println()`, you won’t have to think about the line endings. But a particular
    problem, especially for former programmers of C and related languages, is using
    the `\n` character in text strings to mean a newline. What is particularly distressing
    about this code is that it works—sometimes—usually on the developer’s own platform.
    But it will probably fail someday, on some other system:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [Recipe 10.12](#javacook-io-SECT-12) 中提到的，如果你只使用 `readLine()` 和 `println()`，就不需要考虑行尾符号。但是一个特别的问题，尤其是对于以前编写过
    C 语言及其相关语言的程序员来说，是在文本字符串中使用 `\n` 字符表示换行。这段代码特别让人不安的是它有时——通常在开发者自己的平台上——能够正常工作。但它可能某一天会在其他系统上失败：
- en: '[PRE37]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The real problem is not that it fails on some platforms, though. What’s really
    wrong is that it mixes formatting and I/O, or tries to. Don’t mix line-based display
    with `toString()`; avoid *multiline strings*—output from `toString()` or any other
    string-returning method. If you need to write multiple strings, then say what
    you mean:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 真正的问题不是它在某些平台上失败，虽然如此。真正的问题在于它混合了格式化和输入/输出，或者试图这样做。不要在 `toString()` 中混合基于行的显示；避免
    *多行字符串* ——从 `toString()` 或任何其他返回字符串的方法输出。如果你需要写多个字符串，那就明确表达你的意图：
- en: '[PRE38]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Alternatively, if you need multiple lines, you could return an array or `List`
    of strings.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果你需要多行，你可以返回一个字符串数组或 `List`。
- en: 10.14 Reading/Writing Binary Data
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10.14 读取/写入二进制数据
- en: Problem
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to read or write binary data, as opposed to text.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要读取或写入二进制数据，而不是文本。
- en: Solution
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方法
- en: Use a `DataInputStream` or `DataOutputStream`.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `DataInputStream` 或 `DataOutputStream`。
- en: Discussion
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'The `Stream` classes have been in Java since the beginning of time and are
    optimal for reading and writing bytes rather than characters. The data layer over
    them, comprising `DataInputStream` and `DataOutputStream`, is configured for reading
    and writing binary values, including all of Java’s built-in types. Suppose that
    you want to write a binary integer plus a binary floating-point value into a file
    and read it back later. This code shows the writing part:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stream` 类自 Java 诞生以来就存在，并且对于读写字节而非字符是最优的。它们的数据层，包括 `DataInputStream` 和 `DataOutputStream`，已配置为读写二进制值，包括
    Java 的所有内置类型。假设你想要将一个二进制整数加上一个二进制浮点数值写入文件并稍后读取它。这段代码展示了写入部分：'
- en: '[PRE39]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Should you need to write all the fields from an object, you should probably
    use one of the methods described in [Recipe 12.6](ch12.html#javacook-netclient-SECT-5).
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要写入对象的所有字段，应该使用 [Recipe 12.6](ch12.html#javacook-netclient-SECT-5) 中描述的方法之一。
- en: 10.15 Reading and Writing JAR or ZIP Archives
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10.15 读取和写入 JAR 或 ZIP 存档
- en: Problem
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to create and/or extract from a JAR archive or a file in the well-known
    ZIP archive format, as established by PkZip and used by Unix zip/unzip and WinZip.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要创建和/或从 JAR 存档或文件中提取，在由 PkZip 确定并由 Unix zip/unzip 和 WinZip 使用的众所周知的 ZIP 存档格式中。
- en: Solution
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方法
- en: You could use the *jar* program in the Java Development Kit because its file
    format is identical to the ZIP format with the addition of the *META-INF* directory
    to contain additional structural information. But because this is a book about
    programming, you are probably more interested in the `ZipFile` and `ZipEntry`
    classes and the stream classes to which they provide access.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用Java开发工具包中的*jar*程序，因为其文件格式与ZIP格式相同，并添加了*META-INF*目录以包含附加的结构信息。但因为这是一本关于编程的书籍，您可能更感兴趣的是`ZipFile`和`ZipEntry`类及其提供访问权限的流类。
- en: Discussion
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'The class `java.util.zip.ZipFile` is not an I/O class *per se*, but a utility
    class that allows you to read or write the contents of a JAR or ZIP-format file.^([5](ch10.html#idm45290653458856))
    When constructed, it creates a series of `ZipEntry` objects, one to represent
    each entry in the archive. In other words, the `ZipFile` represents the entire
    archive, and the `ZipEntry` represents one entry, or one file that has been stored
    (and compressed) in the archive. The `ZipEntry` has methods like `getName()`,
    which returns the name that the file had before it was put into the archive, and
    `getInputStream()`, which gives you an `InputStream` that will transparently uncompress
    the archive entry by filtering it as you read it. To create a `ZipFile` object,
    you need either the name of the archive file or a `File` object representing it:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 类`java.util.zip.ZipFile`本身不是一个I/O类，而是一个实用类，允许您读取或写入JAR或ZIP格式文件的内容。^([5](ch10.html#idm45290653458856))
    创建时，它会创建一系列`ZipEntry`对象，每个条目代表存档中的一个条目。换句话说，`ZipFile`表示整个存档，而`ZipEntry`表示一个条目或存储（和压缩）在存档中的一个文件。`ZipEntry`具有诸如`getName()`（返回文件在放入存档之前的名称）和`getInputStream()`（提供`InputStream`，通过透明地将存档条目解压缩来过滤它）等方法。要创建`ZipFile`对象，您需要存档文件的名称或表示它的`File`对象：
- en: '[PRE40]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'To see whether a given file is present in the archive, you can call the `getEntry()`
    method with a filename. More commonly, you’ll want to process all the entries;
    for this, use the `ZipFile` object to get a list of the entries in the archive,
    in the form of an `Enumeration` (see [Recipe 7.6](ch07.html#javacook-structure-iterate)),
    as is done here:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '要查看存档中是否存在给定文件，可以使用带有文件名的`getEntry()`方法。更常见的是，您可能希望处理所有条目；为此，请使用`ZipFile`对象获取存档中条目的枚举列表（如本处所示：[Recipe
    7.6](ch07.html#javacook-structure-iterate)）。  '
- en: '[PRE41]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We can then process each entry as we wish. A simple listing program could be
    this:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以按需处理每个条目。一个简单的列出程序可能是这样的：
- en: '[PRE42]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'A fancier version would extract the files. The program in [Example 10-7](#javacook-io-EX-8)
    does both: it lists by default, but with the `-x` (extract) switch, it actually
    extracts the files from the archive.'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 更高级的版本将提取文件。例如，[示例 10-7](#javacook-io-EX-8)中的程序默认列出文件，但是使用`-x`（提取）开关时，它实际上会从存档中提取文件。
- en: Example 10-7\. main/src/main/java/io/UnZip.java
  id: totrans-302
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-7\. main/src/main/java/io/UnZip.java
- en: '[PRE43]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: See Also
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: People sometimes confuse the ZIP archive file format with the similarly named
    gzip compression format. Gzip-compressed files can be read or written with the
    `GZipInputStream` and `GZipOutputStream` classes from `java.io`.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 有时人们会将ZIP存档文件格式与同名的gzip压缩格式混淆。可以使用`java.io`中的`GZipInputStream`和`GZipOutputStream`类来读取或写入gzip压缩文件。
- en: 10.16 Finding Files in a Filesystem-Neutral Way with getResource() and getResourceAsStream()
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10.16 使用`getResource()`和`getResourceAsStream()`以文件系统中立的方式查找文件
- en: Problem
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: 'You want to load objects or files without referring to their absolute location
    in the filesystem. You might want to do this for one of the following reasons:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望加载对象或文件，而不需要引用它们在文件系统中的绝对位置。您可能出于以下原因之一希望这样做：
- en: You are in a server (Java EE) environment.
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您位于服务器（Java EE）环境中。
- en: You want to be independent of file paths.
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您希望独立于文件路径。
- en: You want to read a file in a unit test.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您希望在单元测试中读取文件。
- en: You expect users to deploy the resource “somewhere” on the `LASSPATH` (possibly
    even inside a JAR file).
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您期望用户将资源“放置在某个地方”，在`LASSPATH`（甚至可能在JAR文件内部）中。
- en: Solution
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use `getClass()` or `getClassLoader()` and either `getResource()` or `getResourceAsStream()`.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`getClass()`或`getClassLoader()`以及`getResource()`或`getResourceAsStream()`。
- en: Discussion
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: There are three varieties of `getResource()` methods, some of which exist (with
    the exact same signature) both in the `Class` class (see [Chapter 17](ch17.html#javacook-reflection))
    and in the `ClassLoader` class (see [Recipe 17.5](ch17.html#javacook-reflection-SECT-4)).
    The methods in `Class` delegate to the `ClassLoader`, so there is little difference
    between them. The methods are summarized in [Table 10-6](#javacook-io-TABLE-getRes).
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '`getResource()` 方法有三种变体，其中一些存在于`Class`类（参见[Chapter 17](ch17.html#javacook-reflection)）和`ClassLoader`类（参见[Recipe
    17.5](ch17.html#javacook-reflection-SECT-4)）中，具有完全相同的签名。`Class`中的方法委托给`ClassLoader`，因此它们之间几乎没有区别。方法总结如[Table 10-6](#javacook-io-TABLE-getRes)所示。'
- en: Table 10-6\. The getResource* methods
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 表 10-6\. `getResource*` 方法
- en: '| Method signature | In Class | In ClassLoader |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '| 方法签名 | 在 Class 中 | 在 ClassLoader 中 |'
- en: '| --- | --- | --- |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `public InputStream getResourceAsStream(String);` | Y | Y |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '| `public InputStream getResourceAsStream(String);` | Y | Y |'
- en: '| `public URL getResource(String);` | Y | Y |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '| `public URL getResource(String);` | Y | Y |'
- en: '| `public Enumeration<URL> getResources(String) throws IOException;` | N |
    Y |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
  zh: '| `public Enumeration<URL> getResources(String) throws IOException;` | N |
    Y |'
- en: 'The first method is designed to quickly and easily locate a resource, or file,
    on your `CLASSPATH`. Using the `Class` version, or the other one with a standard
    `ClassLoader` implementation, the resource can be a physical file or a file inside
    a JAR file. If you define your own classloader, your imagination is the limit,
    as long as it can be represented as an `InputStream`. This is commonly used as
    shown here:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个方法旨在快速轻松地定位`CLASSPATH`上的资源或文件。使用`Class`版本，或者另一个带有标准`ClassLoader`实现的版本，资源可以是物理文件或JAR文件中的文件。如果你定义自己的类加载器，那么只要它可以表示为`InputStream`，你的想象力就是限制。这通常用于如下所示：
- en: '[PRE44]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The second form returns a `URL`, which can be interpreted in various ways (see
    the discussion of reading from a URL in [Recipe 12.1](ch12.html#javacook-netclient-rest-1)).
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种形式返回一个`URL`，可以以各种方式解释（参见[Recipe 12.1](ch12.html#javacook-netclient-rest-1)中有关从URL读取的讨论）。
- en: The third form, only usable with a `ClassLoader` instance, returns an `Enumeration`
    of `URL` objects. This is intended to return all the resources that match a given
    string; remember that a `CLASSPATH` can consist of pretty much any number of directories
    and/or JAR files, so this will search all of them. This is useful for finding
    a series of configuration files and merging them, perhaps. Or for finding out
    whether there is more than one resource/file of a given name on your `CLASSPATH`.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种形式，只能与`ClassLoader`实例一起使用，返回一个`Enumeration`对象，其中包含一系列`URL`对象。这意味着返回所有匹配给定字符串的资源；请记住，`CLASSPATH`可以由任意数量的目录和/或JAR文件组成，因此这将搜索所有这些目录。这对于查找一系列配置文件并合并它们可能很有用。或者查找是否在你的`CLASSPATH`上有多个具有相同名称的资源/文件。
- en: 'Note that the resource name can be given as either a relative path or as an
    absolute path. Assuming you are using Maven (see [Recipe 1.7](ch01.html#javacook-getstarted-maven)),
    then for the absolute path, place the file relative to *src/main/resources/* directory.
    For the relative path, place the file in the same directory as your source code.
    The same rules apply in an IDE, assuming you have made *src/main/java* and *src/main/resources*
    be treated as source folders in your IDE configuration. The idea is that resource
    files get copied to your `CLASSPATH` folder. For example, if you have two resource
    files, *src/main/resources/one.txt* and *src/main/java/MyPackage/two.txt*, and
    your project is configured as described, these two lines would work, if accessed
    from a program in `MyPackage`:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 注意资源名称可以是相对路径或绝对路径。假设你在使用 Maven（参见[Recipe 1.7](ch01.html#javacook-getstarted-maven)），对于绝对路径，将文件放置在*src/main/resources/*目录中。对于相对路径，将文件放置在与源代码相同的目录中。在IDE中也适用相同的规则，假设你已经在IDE配置中将*src/main/java*和*src/main/resources*设置为源文件夹。这样做的目的是为了将资源文件复制到你的`CLASSPATH`文件夹中。例如，如果你有两个资源文件，*src/main/resources/one.txt*和*src/main/java/MyPackage/two.txt*，并且你的项目已配置如上所述，那么如果从`MyPackage`中的程序访问，这两行代码将起作用：
- en: '[PRE45]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Warning
  id: totrans-329
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: In either case, `getResource()` and `getResourceAsStream()` will return `null`
    if they don’t find the resource; you should always check for `null` to guard against
    faulty deployment. If it doesn’t find anything matching, `getResources()` will
    return an empty `Enumeration`.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 无论哪种情况，如果`getResource()`和`getResourceAsStream()`找不到资源，它们都将返回`null`；你应该始终检查`null`以防止错误的部署。如果它找不到与之匹配的任何内容，`getResources()`将返回一个空的`Enumeration`。
- en: If the file path has slashes between components (as in *package/subpackage*),
    the name you path into any of the `getResource` methods should have a period in
    place of the slash.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件路径在组件之间有斜杠（如 *package/subpackage*），则在 `getResource` 方法中将斜杠替换为句点。
- en: '10.17 Getting File Information: Files and Path'
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10.17 获取文件信息：Files 和 Path
- en: Problem
  id: totrans-333
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to know all you can about a given file on disk.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要了解磁盘上给定文件的所有内容。
- en: Solution
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use `java.nio.file.Files` methods.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `java.nio.file.Files` 方法。
- en: Discussion
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: The `java.nio.file.Files` class has a plural name both to differentiate it from
    the legacy `File` class that it replaces and to remind us that it sometimes works
    on multiple files. There are two types of static methods in the `Files` class,
    information and operational. The informational ones (see [Table 10-7](#javacook-dirfile-Files-Methods-1))
    simply give you information about one file, such as `boolean exists()` or `long
    size()`. The operational ones (see [Table 10-8](#javacook-dirfile-Files-Methods-2))
    either make changes to the filesystem or open a file for reading or writing. Each
    of the operational ones can throw the checked exception `IOException`; only a
    few of the informational ones can.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.nio.file.Files` 类的名称使用复数形式，既是为了区别于它所替代的遗留 `File` 类，也是为了提醒我们它有时会处理多个文件。
    `Files` 类中有两种类型的静态方法，信息性方法和操作性方法。信息性方法（参见 [表 10-7](#javacook-dirfile-Files-Methods-1)）仅提供有关单个文件的信息，例如
    `boolean exists()` 或 `long size()`。操作性方法（参见 [表 10-8](#javacook-dirfile-Files-Methods-2)）则可能会更改文件系统或打开文件以供读取或写入。每个操作性方法都可能抛出已检查的异常
    `IOException`；只有少数信息性方法会抛出异常。'
- en: The vast majority of these methods have argument(s) of type `java.nio.file.Path`.
    A `Path` represents a path into the filesystem, that is, a set of directories
    and possibly a file, like “C:\Users\user\Downloads” or “/home/ian/Downloads”.
    The path may or may not exist as a file on disk at the time you create a `Path`
    representing it. The `Files` class can tell you whether the file represented by
    a given `Path` exists, can bring that `Path` into being as a file or as a directory,
    and can either change the corresponding file’s attributes or even destroy it if
    it does exist. `Path` objects are easily created with `Path.of(String name)`,
    which has several overloads.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 绝大多数这些方法都有 `java.nio.file.Path` 类型的参数。 `Path` 表示文件系统中的路径，即一组目录和可能的文件，例如 “C:\Users\user\Downloads”
    或 “/home/ian/Downloads”。在创建 `Path` 表示它时，该路径在磁盘上可能存在，也可能不存在。 `Files` 类可以告诉您，由给定
    `Path` 表示的文件是否存在，可以将该 `Path` 创建为文件或目录，并且可以更改相应文件的属性，甚至在存在时销毁它。 `Path` 对象可以使用 `Path.of(String
    name)` 轻松创建，该方法具有多个重载。
- en: '`Files` in conjunction with `Path` offers pretty well everything you’d need
    to write a full-blown file manager application, let alone the needs of a more
    typical application needing file information and/or directory access. The `Files`
    class has a series of static `boolean` methods that give basic information.'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '`Files` 和 `Path` 结合，几乎提供了编写完整的文件管理器应用所需的一切，更不用说更典型的需要文件信息和/或目录访问的应用程序。 `Files`
    类具有一系列静态的 `boolean` 方法，提供基本信息。'
- en: Table 10-7\. Public static informational methods in java.nio.file.Files
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 表 10-7\. `java.nio.file.Files` 中的公共静态信息性方法
- en: '| Return type | Method | Notes |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
  zh: '| 返回类型 | 方法 | 备注 |'
- en: '| --- | --- | --- |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| boolean | exists(Path, LinkOption…); |  |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
  zh: '| boolean | exists(Path, LinkOption…); |  |'
- en: '| Object | getAttribute(Path, String, LinkOption…); |  |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
  zh: '| Object | getAttribute(Path, String, LinkOption…); |  |'
- en: '| <V extends FileAttributeView> V | getFileAttributeView(Path, Class<V>, LinkOption…);
    |  |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
  zh: '| <V extends FileAttributeView> V | getFileAttributeView(Path, Class<V>, LinkOption…);
    |  |'
- en: '| FileTime | getLastModifiedTime(Path, LinkOption…); |  |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
  zh: '| FileTime | getLastModifiedTime(Path, LinkOption…); |  |'
- en: '| UserPrincipal | getOwner(Path, LinkOption…); |  |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
  zh: '| UserPrincipal | getOwner(Path, LinkOption…); |  |'
- en: '| Set<PosixFilePermission> | getPosixFilePermissions(Path, LinkOption…); |  |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '| Set<PosixFilePermission> | getPosixFilePermissions(Path, LinkOption…); |  |'
- en: '| boolean | isDirectory(Path, LinkOption…); |  |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
  zh: '| boolean | isDirectory(Path, LinkOption…); |  |'
- en: '| boolean | isExecutable(Path); | If Executable by current user |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
  zh: '| boolean | isExecutable(Path); | 如果当前用户可执行 |'
- en: '| boolean | isHidden(Path); | If a “dot file” on Unix, or “hidden” attribute
    set on some OSes |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '| boolean | isHidden(Path); | 如果是 Unix 上的“点文件”，或者某些操作系统上设置了“隐藏”属性 |'
- en: '| boolean | isReadable(Path); | If Readable by current user |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
  zh: '| boolean | isReadable(Path); | 如果当前用户可读 |'
- en: '| boolean | isRegularFile(Path, LinkOption…); |  |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
  zh: '| boolean | isRegularFile(Path, LinkOption…); |  |'
- en: '| boolean | isSameFile(Path, Path) throws IOException; | Has to unwind filesys
    complexities like “..”, symlinks, … |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
  zh: '| boolean | isSameFile(Path, Path) throws IOException; | 需要处理文件系统的复杂性，如“..”，符号链接等
    |'
- en: '| boolean | isSymbolicLink(Path); |  |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
  zh: '| boolean | isSymbolicLink(Path); |  |'
- en: '| boolean | isWritable(Path); | If Writable by current user |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
  zh: '| boolean | isWritable(Path); | 如果当前用户可写 |'
- en: '| long | mismatch(Path, Path); |  |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
  zh: '| long | mismatch(Path, Path); |  |'
- en: '| boolean | notExists(Path, LinkOption…); |  |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
  zh: '| boolean | notExists(Path, LinkOption…); |  |'
- en: '| String | probeContentType(Path) throws IOException; | Tries to return MIME
    type of data |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
  zh: '| String | probeContentType(Path) throws IOException; | 尝试返回数据的 MIME 类型 |'
- en: '| Path | readSymbolicLink(Path) throws IOException; |  |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
  zh: '| Path | readSymbolicLink(Path) throws IOException; |  |'
- en: '| long | size(Path); |  |'
  id: totrans-362
  prefs: []
  type: TYPE_TB
  zh: '| long | size(Path); |  |'
- en: By “current user” we mean the account under which the current JVM instance is
    being run.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: “当前用户”指的是当前 JVM 实例正在运行的账户。
- en: Most of these methods are demonstrated in [Example 10-8](#javacook-ch10-EX-files-infos).
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法大多数在 [Example 10-8](#javacook-ch10-EX-files-infos) 中有演示。
- en: Example 10-8\. main/src/main/java/io/FilesInfos.java
  id: totrans-365
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 10-8\. main/src/main/java/io/FilesInfos.java
- en: '[PRE46]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Obviously the paths chosen are somewhat system-specific, but when run on my
    Unix system, the `boolean` methods all returned `true`, and the last three returned
    this:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，所选路径在某种程度上是特定于系统的，但在我的 Unix 系统上运行时，“boolean” 方法都返回 `true`，而最后三个返回了这个：
- en: '[PRE47]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[Table 10-8](#javacook-dirfile-Files-Methods-2) shows the methods that make
    changes to filesystem entities.'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '[Table 10-8](#javacook-dirfile-Files-Methods-2) 显示了对文件系统实体进行更改的方法。'
- en: Table 10-8\. Public static operational methods in java.nio.file.Files
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: Table 10-8\. java.nio.file.Files 中的公共静态操作方法
- en: '| Return type | Method |'
  id: totrans-371
  prefs: []
  type: TYPE_TB
  zh: '| 返回类型 | 方法 |'
- en: '| --- | --- |'
  id: totrans-372
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| long | copy(InputStream, Path, CopyOption…); |'
  id: totrans-373
  prefs: []
  type: TYPE_TB
  zh: '| long | copy(InputStream, Path, CopyOption…); |'
- en: '| long | copy(Path, OutputStream); |'
  id: totrans-374
  prefs: []
  type: TYPE_TB
  zh: '| long | copy(Path, OutputStream); |'
- en: '| Path | copy(Path, Path, CopyOption…); |'
  id: totrans-375
  prefs: []
  type: TYPE_TB
  zh: '| Path | copy(Path, Path, CopyOption…); |'
- en: '| Path | createDirectories(Path, FileAttribute<?>…); |'
  id: totrans-376
  prefs: []
  type: TYPE_TB
  zh: '| Path | createDirectories(Path, FileAttribute<?>…); |'
- en: '| Path | createDirectory(Path, FileAttribute<?>…); |'
  id: totrans-377
  prefs: []
  type: TYPE_TB
  zh: '| Path | createDirectory(Path, FileAttribute<?>…); |'
- en: '| Path | createFile(Path, FileAttribute<?>…); |'
  id: totrans-378
  prefs: []
  type: TYPE_TB
  zh: '| Path | createFile(Path, FileAttribute<?>…); |'
- en: '| Path | createLink(Path, Path); |'
  id: totrans-379
  prefs: []
  type: TYPE_TB
  zh: '| Path | createLink(Path, Path); |'
- en: '| Path | createSymbolicLink(Path, Path, FileAttribute<?>…); |'
  id: totrans-380
  prefs: []
  type: TYPE_TB
  zh: '| Path | createSymbolicLink(Path, Path, FileAttribute<?>…); |'
- en: '| Path | createTempDirectory(Path, String, FileAttribute<?>…); |'
  id: totrans-381
  prefs: []
  type: TYPE_TB
  zh: '| Path | createTempDirectory(Path, String, FileAttribute<?>…); |'
- en: '| Path | createTempDirectory(String, FileAttribute<?>…); |'
  id: totrans-382
  prefs: []
  type: TYPE_TB
  zh: '| Path | createTempDirectory(String, FileAttribute<?>…); |'
- en: '| Path | createTempFile(Path, String, String, FileAttribute<?>…); |'
  id: totrans-383
  prefs: []
  type: TYPE_TB
  zh: '| Path | createTempFile(Path, String, String, FileAttribute<?>…); |'
- en: '| Path | createTempFile(String, String, FileAttribute<?>…); |'
  id: totrans-384
  prefs: []
  type: TYPE_TB
  zh: '| Path | createTempFile(String, String, FileAttribute<?>…); |'
- en: '| void | delete(Path); |'
  id: totrans-385
  prefs: []
  type: TYPE_TB
  zh: '| void | delete(Path); |'
- en: '| boolean | deleteIfExists(Path); |'
  id: totrans-386
  prefs: []
  type: TYPE_TB
  zh: '| boolean | deleteIfExists(Path); |'
- en: '| Stream<Path> | find(Path, int, BiPredicate<Path, BasicFileAttributes>, FileVisitOption…);
    |'
  id: totrans-387
  prefs: []
  type: TYPE_TB
  zh: '| Stream<Path> | find(Path, int, BiPredicate<Path, BasicFileAttributes>, FileVisitOption…);
    |'
- en: '| Stream<String> | lines(Path); |'
  id: totrans-388
  prefs: []
  type: TYPE_TB
  zh: '| Stream<String> | lines(Path); |'
- en: '| Stream<String> | lines(Path, Charset); |'
  id: totrans-389
  prefs: []
  type: TYPE_TB
  zh: '| Stream<String> | lines(Path, Charset); |'
- en: '| Stream<Path> | list(Path); |'
  id: totrans-390
  prefs: []
  type: TYPE_TB
  zh: '| Stream<Path> | list(Path); |'
- en: '| Path | move(Path, Path, CopyOption…); |'
  id: totrans-391
  prefs: []
  type: TYPE_TB
  zh: '| 路径 | move(Path, Path, CopyOption…); |'
- en: '| BufferedReader | newBufferedReader(Path); |'
  id: totrans-392
  prefs: []
  type: TYPE_TB
  zh: '| BufferedReader | newBufferedReader(Path); |'
- en: '| BufferedReader | newBufferedReader(Path, Charset); |'
  id: totrans-393
  prefs: []
  type: TYPE_TB
  zh: '| BufferedReader | newBufferedReader(Path, Charset); |'
- en: '| BufferedWriter | newBufferedWriter(Path, Charset, OpenOption…); |'
  id: totrans-394
  prefs: []
  type: TYPE_TB
  zh: '| BufferedWriter | newBufferedWriter(Path, Charset, OpenOption…); |'
- en: '| BufferedWriter | newBufferedWriter(Path, OpenOption…); |'
  id: totrans-395
  prefs: []
  type: TYPE_TB
  zh: '| BufferedWriter | newBufferedWriter(Path, OpenOption…); |'
- en: '| SeekableByteChannel | newByteChannel(Path, OpenOption…); |'
  id: totrans-396
  prefs: []
  type: TYPE_TB
  zh: '| SeekableByteChannel | newByteChannel(Path, OpenOption…); |'
- en: '| SeekableByteChannel | newByteChannel(Path, Set<? extends OpenOption>, FileAttribute<?>…);
    |'
  id: totrans-397
  prefs: []
  type: TYPE_TB
  zh: '| SeekableByteChannel | newByteChannel(Path, Set<? extends OpenOption>, FileAttribute<?>…);
    |'
- en: '| DirectoryStream<Path> | newDirectoryStream(Path); |'
  id: totrans-398
  prefs: []
  type: TYPE_TB
  zh: '| DirectoryStream<Path> | newDirectoryStream(Path); |'
- en: '| DirectoryStream<Path> | newDirectoryStream(Path, String); |'
  id: totrans-399
  prefs: []
  type: TYPE_TB
  zh: '| DirectoryStream<Path> | newDirectoryStream(Path, String); |'
- en: '| InputStream | newInputStream(Path, OpenOption…); |'
  id: totrans-400
  prefs: []
  type: TYPE_TB
  zh: '| InputStream | newInputStream(Path, OpenOption…); |'
- en: '| OutputStream | newOutputStream(Path, OpenOption…); |'
  id: totrans-401
  prefs: []
  type: TYPE_TB
  zh: '| OutputStream | newOutputStream(Path, OpenOption…); |'
- en: '| byte[] | readAllBytes(Path); |'
  id: totrans-402
  prefs: []
  type: TYPE_TB
  zh: '| byte[] | readAllBytes(Path); |'
- en: '| List<String> | readAllLines(Path); |'
  id: totrans-403
  prefs: []
  type: TYPE_TB
  zh: '| List<String> | readAllLines(Path); |'
- en: '| List<String> | readAllLines(Path, Charset); |'
  id: totrans-404
  prefs: []
  type: TYPE_TB
  zh: '| List<String> | readAllLines(Path, Charset); |'
- en: '| <A extends BasicFileAttributes> A | readAttributes(Path, Class<A>, LinkOption…);
    |'
  id: totrans-405
  prefs: []
  type: TYPE_TB
  zh: '| <A extends BasicFileAttributes> A | readAttributes(Path, Class<A>, LinkOption…);
    |'
- en: '| Map<String, Object> | readAttributes(Path, String, LinkOption…); |'
  id: totrans-406
  prefs: []
  type: TYPE_TB
  zh: '| Map<String, Object> | readAttributes(Path, String, LinkOption…); |'
- en: '| String | readString(Path); |'
  id: totrans-407
  prefs: []
  type: TYPE_TB
  zh: '| String | readString(Path); |'
- en: '| String | readString(Path, Charset); |'
  id: totrans-408
  prefs: []
  type: TYPE_TB
  zh: '| String | readString(Path, Charset); |'
- en: '| Path | setAttribute(Path, String, Object, LinkOption…); |'
  id: totrans-409
  prefs: []
  type: TYPE_TB
  zh: '| Path | setAttribute(Path, String, Object, LinkOption…); |'
- en: '| Path | setLastModifiedTime(Path, FileTime); |'
  id: totrans-410
  prefs: []
  type: TYPE_TB
  zh: '| Path | setLastModifiedTime(Path, FileTime); |'
- en: '| Path | setOwner(Path, UserPrincipal); |'
  id: totrans-411
  prefs: []
  type: TYPE_TB
  zh: '| Path | setOwner(Path, UserPrincipal); |'
- en: '| Path | setPosixFilePermissions(Path, Set<PosixFilePermission>); |'
  id: totrans-412
  prefs: []
  type: TYPE_TB
  zh: '| Path | setPosixFilePermissions(Path, Set<PosixFilePermission>); |'
- en: '| Path | write(Path, Iterable<? extends CharSequence>, Charset, OpenOption…);
    |'
  id: totrans-413
  prefs: []
  type: TYPE_TB
  zh: '| Path | write(Path, Iterable<? extends CharSequence>, Charset, OpenOption…);
    |'
- en: '| Path | write(Path, Iterable<? extends CharSequence>, OpenOption…); |'
  id: totrans-414
  prefs: []
  type: TYPE_TB
  zh: '| Path | write(Path, Iterable<? extends CharSequence>, OpenOption…); |'
- en: '| Path | write(Path, byte[], OpenOption…); |'
  id: totrans-415
  prefs: []
  type: TYPE_TB
  zh: '| Path | write(Path, byte[], OpenOption…); |'
- en: '| Path | writeString(Path, CharSequence, Charset, OpenOption…); |'
  id: totrans-416
  prefs: []
  type: TYPE_TB
  zh: '| Path | writeString(Path, CharSequence, Charset, OpenOption…); |'
- en: '| Path | writeString(Path, CharSequence, OpenOption…); |'
  id: totrans-417
  prefs: []
  type: TYPE_TB
  zh: '| Path | writeString(Path, CharSequence, OpenOption…); |'
- en: '`Path` is an interface whose implementation is provided by a provider class
    called `Filesystem`. `Path` has many methods, listed in [Table 10-9](#javacook-dirfile-Path-Methods).'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '`Path`是一个接口，其实现由名为`Filesystem`的提供者类提供。`Path`有许多方法，列在[表格 10-9](#javacook-dirfile-Path-Methods)中。'
- en: Table 10-9\. Public static operational methods in java.nio.file.Path
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 表格 10-9\. java.nio.file.Path 中的公共静态操作方法
- en: '| Access | Return type | Method |'
  id: totrans-420
  prefs: []
  type: TYPE_TB
  zh: '| Access | 返回类型 | 方法 |'
- en: '| --- | --- | --- |'
  id: totrans-421
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| static | Path | of(String, String…); |'
  id: totrans-422
  prefs: []
  type: TYPE_TB
  zh: '| static | Path | of(String, String…); |'
- en: '| static | Path | of(URI); |'
  id: totrans-423
  prefs: []
  type: TYPE_TB
  zh: '| static | Path | of(URI); |'
- en: '| abstract | FileSystem | getFileSystem(); |'
  id: totrans-424
  prefs: []
  type: TYPE_TB
  zh: '| abstract | FileSystem | getFileSystem(); |'
- en: '| abstract | boolean | isAbsolute(); |'
  id: totrans-425
  prefs: []
  type: TYPE_TB
  zh: '| abstract | boolean | isAbsolute(); |'
- en: '| abstract | Path | getRoot(); |'
  id: totrans-426
  prefs: []
  type: TYPE_TB
  zh: '| abstract | Path | getRoot(); |'
- en: '| abstract | Path | getFileName(); |'
  id: totrans-427
  prefs: []
  type: TYPE_TB
  zh: '| abstract | Path | getFileName(); |'
- en: '| abstract | Path | getParent(); |'
  id: totrans-428
  prefs: []
  type: TYPE_TB
  zh: '| abstract | Path | getParent(); |'
- en: '| abstract | int | getNameCount(); |'
  id: totrans-429
  prefs: []
  type: TYPE_TB
  zh: '| abstract | int | getNameCount(); |'
- en: '| abstract | Path | getName(int); |'
  id: totrans-430
  prefs: []
  type: TYPE_TB
  zh: '| abstract | Path | getName(int); |'
- en: '| abstract | Path | subpath(int, int); |'
  id: totrans-431
  prefs: []
  type: TYPE_TB
  zh: '| abstract | Path | subpath(int, int); |'
- en: '| abstract | boolean | startsWith(Path); |'
  id: totrans-432
  prefs: []
  type: TYPE_TB
  zh: '| abstract | boolean | startsWith(Path); |'
- en: '| default | boolean | startsWith(String); |'
  id: totrans-433
  prefs: []
  type: TYPE_TB
  zh: '| default | boolean | startsWith(String); |'
- en: '| abstract | boolean | endsWith(Path); |'
  id: totrans-434
  prefs: []
  type: TYPE_TB
  zh: '| abstract | boolean | endsWith(Path); |'
- en: '| default | boolean | endsWith(String); |'
  id: totrans-435
  prefs: []
  type: TYPE_TB
  zh: '| default | boolean | endsWith(String); |'
- en: '| abstract | Path | normalize(); |'
  id: totrans-436
  prefs: []
  type: TYPE_TB
  zh: '| abstract | Path | normalize(); |'
- en: '| abstract | Path | resolve(Path); |'
  id: totrans-437
  prefs: []
  type: TYPE_TB
  zh: '| abstract | Path | resolve(Path); |'
- en: '| default | Path | resolve(String); |'
  id: totrans-438
  prefs: []
  type: TYPE_TB
  zh: '| default | Path | resolve(String); |'
- en: '| default | Path | resolveSibling(Path); |'
  id: totrans-439
  prefs: []
  type: TYPE_TB
  zh: '| default | Path | resolveSibling(Path); |'
- en: '| default | Path | resolveSibling(String); |'
  id: totrans-440
  prefs: []
  type: TYPE_TB
  zh: '| default | Path | resolveSibling(String); |'
- en: '| abstract | Path | relativize(Path); |'
  id: totrans-441
  prefs: []
  type: TYPE_TB
  zh: '| abstract | Path | relativize(Path); |'
- en: '| abstract | URI | toUri(); |'
  id: totrans-442
  prefs: []
  type: TYPE_TB
  zh: '| abstract | URI | toUri(); |'
- en: '| abstract | Path | toAbsolutePath(); |'
  id: totrans-443
  prefs: []
  type: TYPE_TB
  zh: '| abstract | Path | toAbsolutePath(); |'
- en: '| abstract | Path | toRealPath(LinkOption…) throws IOException; |'
  id: totrans-444
  prefs: []
  type: TYPE_TB
  zh: '| abstract | Path | toRealPath(LinkOption…) throws IOException; |'
- en: '| default | File | toFile(); |'
  id: totrans-445
  prefs: []
  type: TYPE_TB
  zh: '| default | File | toFile(); |'
- en: '| abstract | WatchKey | register(WatchService, WatchEvent$Kind<?>[], WatchEvent$Modifier…)
    throws IOException; |'
  id: totrans-446
  prefs: []
  type: TYPE_TB
  zh: '| abstract | WatchKey | register(WatchService, WatchEvent$Kind<?>[], WatchEvent$Modifier…)
    throws IOException; |'
- en: '| default | WatchKey | register(WatchService, WatchEvent$Kind<?>…) throws IOException;
    |'
  id: totrans-447
  prefs: []
  type: TYPE_TB
  zh: '| default | WatchKey | register(WatchService, WatchEvent$Kind<?>…) throws IOException;
    |'
- en: '| default | Iterator<Path> | iterator(); |'
  id: totrans-448
  prefs: []
  type: TYPE_TB
  zh: '| default | Iterator<Path> | iterator(); |'
- en: '| abstract | int | compareTo(Path); |'
  id: totrans-449
  prefs: []
  type: TYPE_TB
  zh: '| abstract | int | compareTo(Path); |'
- en: '| abstract | boolean | equals(Object); |'
  id: totrans-450
  prefs: []
  type: TYPE_TB
  zh: '| abstract | boolean | equals(Object); |'
- en: '| abstract | int | hashCode(); |'
  id: totrans-451
  prefs: []
  type: TYPE_TB
  zh: '| abstract | int | hashCode(); |'
- en: '| abstract | String | toString(); |'
  id: totrans-452
  prefs: []
  type: TYPE_TB
  zh: '| abstract | String | toString(); |'
- en: '| default | int | compareTo(Object); |'
  id: totrans-453
  prefs: []
  type: TYPE_TB
  zh: '| default | int | compareTo(Object); |'
- en: To find the information about one file, you can use the informational methods
    in `Files` and `Path`, as shown in [Example 10-9](#javacook-dirfile-filestat).
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 要查找有关一个文件的信息，您可以使用`Files`和`Path`中的信息方法，如[示例 10-9](#javacook-dirfile-filestat)所示。
- en: Example 10-9\. main/src/main/java/dir_file/FileStatus.java (getting file information)
  id: totrans-455
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-9\. main/src/main/java/dir_file/FileStatus.java（获取文件信息）
- en: '[PRE48]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'When run on MS Windows with the three arguments shown, it produces this output:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 当在MS Windows上运行时，使用所示的三个参数，会产生如下输出：
- en: '[PRE49]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'As you can see, the so-called *canonical name* not only includes a leading
    directory root of *C:\*, but also has had the name converted to uppercase. You
    can tell I ran that on Windows. That version of Windows did not maintain timestamps
    on directories; the value `0L` gets interpreted as January 1, 1970 (not accidentally
    the same time base as used on Unix since that time). On Unix, it behaves differently:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，所谓的*规范名称*不仅包括*C:\*的前导目录根，还将名称转换为大写。你可以看出我是在Windows上运行的。这个版本的Windows不保留目录的时间戳；值`0L`被解释为1970年1月1日（与自Unix以来的时间基准相同）。在Unix上，它的行为有所不同：
- en: '[PRE50]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'A typical Unix system has no *autoexec.bat* file. And Unix filenames (like
    those on a Mac) can consist of upper- and lowercase characters: what you type
    is what you get.'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的 Unix 系统没有*autoexec.bat*文件。Unix 文件名（像 Mac 上的那些）可以由大写和小写字符组成：输入什么就是什么。
- en: Legacy compatibility
  id: totrans-462
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 旧版本兼容性
- en: 'To use a `Path` with legacy code that needs the older `java.io.File`, simply
    use `File oldType = Path.toFile()`:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 要在需要旧的`java.io.File`的旧代码中使用`Path`，简单地使用`File oldType = Path.toFile()`：
- en: '[PRE51]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'To go the other way, the `File` class has been retrofitted with a `toPath()`
    method:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 要反向操作，`File`类已经加入了一个`toPath()`方法：
- en: '[PRE52]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 10.18 Creating a New File or Directory
  id: totrans-467
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10.18 创建新文件或目录
- en: Problem
  id: totrans-468
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to create a new file on disk but not write any data into it; you need
    to create a directory before you can create files in it.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在磁盘上创建一个新文件，但不写入任何数据；在创建文件之前，你需要创建一个目录。
- en: Solution
  id: totrans-470
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: For an empty file, use a `java.nio.file.Files` object’s `createFile(Path)` method.
    Use the `Files` class’s `createDirectory()` or `createDirectories()` method to
    create a directory.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 对于空文件，使用`java.nio.file.Files`对象的`createFile(Path)`方法。使用`Files`类的`createDirectory()`或`createDirectories()`方法来创建目录。
- en: Discussion
  id: totrans-472
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Files
  id: totrans-473
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文件
- en: 'You could easily create a new file by constructing a `FileOutputStream` or
    `FileWriter` (see [Recipe 12.6](ch12.html#javacook-netclient-SECT-5)). But then
    you’d have to remember to close it as well. Sometimes you want a file to exist,
    but you don’t want to bother putting anything into it. This might be used, for
    example, as a simple form of interprogram communication: one program could test
    for the presence of a file and interpret that to mean that the other program has
    reached a certain state. [Example 10-10](#javacook-dirfile-creation) is code that
    simply creates an empty file for each name you give.'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过构建`FileOutputStream`或`FileWriter`（参见[Recipe 12.6](ch12.html#javacook-netclient-SECT-5)）轻松创建一个新文件。但是你还需要记得关闭它。有时候你希望文件存在，但并不想费力把任何东西放进去。例如，这可以作为一种简单的程序间通信形式使用：一个程序可以测试文件是否存在，并解释为另一个程序已达到某种状态。[Example 10-10](#javacook-dirfile-creation)
    是一段代码，简单地为你提供的每个名称创建一个空文件。
- en: Example 10-10\. main/src/main/java/dir_file/Creat.java (creation of a file on
    disk)
  id: totrans-475
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 10-10\. main/src/main/java/dir_file/Creat.java（在磁盘上创建文件）
- en: '[PRE53]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '`java.nio.file.createFile()` has an overload that takes a second argument of
    type `OpenOption`. This is an empty interface that is implemented by the `StandardOpenOption`
    enumeration. These options are listed in [Table 10-5](#javacook-dir_file-OPEN-OPTIONS).'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.nio.file.createFile()`有一个重载方法，接受第二个类型为`OpenOption`的参数。这是一个空接口，由`StandardOpenOption`枚举实现。这些选项在[Table 10-5](#javacook-dir_file-OPEN-OPTIONS)中列出。'
- en: Directories
  id: totrans-478
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 目录
- en: Of the two methods used for creating directories, `createDirectory()` creates
    just one directory, whereas `createDirectories()` creates any intermediate directories
    that are needed. For example, if */home/ian* exists and is a directory, the call
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 用于创建目录的两种方法中，`createDirectory()`只创建一个目录，而`createDirectories()`则创建所需的任何中间目录。例如，如果*/home/ian*存在且是一个目录，则调用
- en: '[PRE54]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: will succeed (unless the directory is already there), but the call
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 会成功（除非目录已存在），但调用
- en: '[PRE55]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'will fail with a `java.nio.file.NoSuchFileException` because the directory
    named *once* does not exist. To create this path of directories, as you might
    expect by now, use `createDirectories()` (plural):'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 将因为名为*once*的目录不存在而导致`java.nio.file.NoSuchFileException`异常。要创建这些目录路径，正如你现在可能期望的那样，请使用`createDirectories()`（复数形式）：
- en: '[PRE56]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Both variants return a `Path` object referring to the new directory if they
    succeed and throw an exception if they fail. Notice that it is possible (but not
    likely) for `createDirectories()` to create some of the directories and then fail;
    in this case, the newly created directories are left in the filesystem.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种变体如果成功会返回一个引用新目录的`Path`对象，如果失败会抛出异常。注意，`createDirectories()`可能（但不太可能）在创建一些目录后失败；在这种情况下，新创建的目录会留在文件系统中。
- en: 10.19 Changing a File’s Name or Other Attributes
  id: totrans-486
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10.19 更改文件名称或其他属性
- en: Problem
  id: totrans-487
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to change a file’s name on disk or some of its other attributes, such
    as setting the file to read-only or changing its modification time.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在磁盘上更改文件的名称或其它某些属性，例如将文件设置为只读或更改其修改时间。
- en: Solution
  id: totrans-489
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: To change the name (or location), use a `java.nio.file.Files` static `move()`
    method. For other attributes, use `setLastModifiedTime()` to change the timestamp,
    or one of several other setters for mode or permission attributes.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改名称（或位置），请使用`java.nio.file.Files`的静态`move()`方法。对于其他属性，请使用`setLastModifiedTime()`来更改时间戳，或者使用几种其他设置器来更改模式或权限属性。
- en: Discussion
  id: totrans-491
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'Similar to the Unix command line, there is no separate rename operation; the
    move methods provide all functions for putting a file somewhere else, whether
    that is to the same name in a different directory, a different name in the same
    directory, or a different name on a different disk or filesystem. Accordingly,
    the `Files.move()` method requires two `Path` objects, one referring to the existing
    file and another referring to the new name. Then call the `Files.move()` method,
    passing both path objects, first the existing and then the desired name. This
    is easier to see than to explain, so here goes:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 与Unix命令行类似，没有单独的重命名操作；移动方法提供了将文件放置在其他位置的所有功能，无论是在不同目录中的同名文件，同一目录中的不同名称文件，还是在不同磁盘或文件系统中的不同名称文件。因此，`Files.move()`方法需要两个`Path`对象，一个引用现有文件，另一个引用新名称。然后调用`Files.move()`方法，依次传递这两个路径对象，首先是现有的，然后是所需的名称。这比解释更容易看到，所以让我们开始吧：
- en: '[PRE57]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: For changing the attributes, there are several methods available, listed in
    [Table 10-10](#javacook-dir_file-filesetops). Each of these has a return value
    of type `boolean`, with `true` meaning success.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 若要更改属性，有几种可用的方法，列在[表 10-10](#javacook-dir_file-filesetops)中。其中每个方法的返回值都是`boolean`类型，`true`表示成功。
- en: Table 10-10\. Files attribute setters
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 表 10-10\. 文件属性设置器
- en: '| Method signature | Description |'
  id: totrans-496
  prefs: []
  type: TYPE_TB
  zh: '| 方法签名 | 描述 |'
- en: '| --- | --- |'
  id: totrans-497
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `setExecutable(boolean executable)` | Convenience method to set owner’s execute
    permission for this file |'
  id: totrans-498
  prefs: []
  type: TYPE_TB
  zh: '| `setExecutable(boolean executable)` | 为此文件设置所有者的执行权限的便捷方法 |'
- en: '| `setExecutable(boolean executable, boolean ownerOnly)` | Sets the owner’s
    or everybody’s execute permission for this file |'
  id: totrans-499
  prefs: []
  type: TYPE_TB
  zh: '| `setExecutable(boolean executable, boolean ownerOnly)` | 设置此文件的所有者或所有人的执行权限
    |'
- en: '| `setLastModified(long time)` | Sets the last-modified time of the file or
    directory that this file names |'
  id: totrans-500
  prefs: []
  type: TYPE_TB
  zh: '| `setLastModified(long time)` | 设置此文件或目录的最后修改时间的方法 |'
- en: '| `setReadable(boolean readable)` | Convenience method to set owner’s read
    permission for this file |'
  id: totrans-501
  prefs: []
  type: TYPE_TB
  zh: '| `setReadable(boolean readable)` | 为此文件设置所有者的读取权限的便捷方法 |'
- en: '| `setReadable(boolean readable, boolean ownerOnly)` | Sets the owner’s or
    everybody’s read permission for this file |'
  id: totrans-502
  prefs: []
  type: TYPE_TB
  zh: '| `setReadable(boolean readable, boolean ownerOnly)` | 设置此文件的所有者或所有人的读取权限 |'
- en: '| `setReadOnly()` | Convenience for `setReadable(false)` |'
  id: totrans-503
  prefs: []
  type: TYPE_TB
  zh: '| `setReadOnly()` | 为`setReadable(false)`提供便捷方式 |'
- en: '| `setWritable(boolean writable)` | A convenience method to set the owner’s
    write permission for this file |'
  id: totrans-504
  prefs: []
  type: TYPE_TB
  zh: '| `setWritable(boolean writable)` | 为此文件设置所有者的写入权限的便捷方法 |'
- en: '| `setWritable(boolean writable, boolean ownerOnly)` | Set owner’s or everybody’s
    write permission for this file |'
  id: totrans-505
  prefs: []
  type: TYPE_TB
  zh: '| `setWritable(boolean writable, boolean ownerOnly)` | 设置此文件的所有者或所有人的写入权限 |'
- en: For the methods that take two arguments, the first enables or disables the feature
    on the given file that matches the method name, and the second controls whether
    the operation applies to the owner only or to everyone. The second argument is
    ignored if the file lives on a filesystem that doesn’t support multiuser permissions
    or if the operating system doesn’t support that. All the methods described in
    this recipe return `true` if they succeed and `false` otherwise.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 对于需要两个参数的方法，第一个参数启用或禁用与方法名匹配的给定文件上的功能，而第二个参数则控制操作是仅适用于所有者还是所有人。如果文件所在的文件系统不支持多用户权限，或者操作系统不支持该功能，则忽略第二个参数。本示例中描述的所有方法都在成功时返回`true`，否则返回`false`。
- en: For example, `boolean setReadable(boolean readable, boolean ownerOnly)` lets
    you specify who can read the given file. The `readable` argument is true or false
    depending on whether you want it readable or not. The `ownerOnly` argument tries
    to extend the readability choice to all users on a multiuser operating system,
    and is ignored if not applicable.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`boolean setReadable(boolean readable, boolean ownerOnly)`允许您指定谁可以读取给定文件。`readable`参数是`true`或`false`，取决于您是否希望其可读。`ownerOnly`参数尝试将可读性选择扩展到多用户操作系统上的所有用户，并且如果不适用，则将其忽略。
- en: '`setLastModified()` allows you to play games with the modification time of
    a file. This is normally not a good game to play, but it is useful in some types
    of backup/restore programs. This method takes an argument that is the number of
    milliseconds (not seconds) since the beginning of Unix time (January 1, 1970).
    You can get the original value for the file by calling `getLastModified()` (see
    [Recipe 10.17](#javacook-dirfile-SECT-1)), or you can get the value for a given
    date by calling the `ZonedDateTime`’s `toInstant().getEpochSecond()` method (see
    [Recipe 6.3](ch06.html#javacook-dates-convert)) and multiplying by 1,000 to convert
    seconds to milliseconds.'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: '`setLastModified()` 允许您操纵文件的修改时间。通常情况下，这不是一个好的操作，但在某些类型的备份/还原程序中很有用。此方法接受一个参数，即自
    Unix 时间（1970 年 1 月 1 日）开始以来的毫秒数（而不是秒数）。您可以通过调用 `getLastModified()` 获取文件的原始值（参见
    [Recipe 10.17](#javacook-dirfile-SECT-1)），或者通过调用 `ZonedDateTime` 的 `toInstant().getEpochSecond()`
    方法获取特定日期的值（参见 [Recipe 6.3](ch06.html#javacook-dates-convert)），并乘以 1,000 将秒转换为毫秒。'
- en: I encourage you to explore the operation of these methods using JShell (see
    [Recipe 1.4](ch01.html#javacook-getstarted-JSHELL)). I’d suggest having a second
    window in which you can run `ls -l` or `dir` commands to see how the file is affected.
    [Example 10-11](#javacook-filesdir-setfileattrs-1) shows some of these methods
    being explored in JShell.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 我鼓励您使用 JShell 探索这些方法的操作（参见 [Recipe 1.4](ch01.html#javacook-getstarted-JSHELL)）。我建议您在第二个窗口中运行
    `ls -l` 或 `dir` 命令，以查看文件的影响。[Example 10-11](#javacook-filesdir-setfileattrs-1)
    展示了在 JShell 中探索这些方法的一些示例。
- en: Example 10-11\. Exploring Files
  id: totrans-510
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-11\. 探索文件
- en: '[PRE58]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 10.20 Deleting a File
  id: totrans-512
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10.20 删除文件
- en: Problem
  id: totrans-513
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to delete one or more files from the disk.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要从磁盘上删除一个或多个文件。
- en: Solution
  id: totrans-515
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use `java.nio.file.Files` object’s `delete(Path)` or `deleteIfExists(Path)`
    method. These delete the files referred to by the `Path` argument (subject of
    course to permissions) and directories (subject to permissions and to the directory
    being empty).
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `java.nio.file.Files` 对象的 `delete(Path)` 或 `deleteIfExists(Path)` 方法。这些方法删除由
    `Path` 参数引用的文件（当然要考虑权限）和目录（也要考虑权限和目录是否为空）。
- en: Discussion
  id: totrans-517
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'This is not complicated. Simply construct a `Path` object for the file you
    wish to delete, and call the static `Files.delete()` method:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不复杂。只需为要删除的文件构造一个 `Path` 对象，并调用静态的 `Files.delete()` 方法：
- en: '[PRE59]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Recall the caveat about permissions in the introduction to this chapter: if
    you don’t have permission, you can get a return value of false or, possibly, a
    `SecurityException`. Note also that there are some differences between platforms.
    Some versions of Windows allow Java to remove a read-only file, but Unix does
    not allow you to remove a file unless you have write permission on the directory
    it’s in. Nor does Unix allow you to remove a directory that isn’t empty (there
    is even an exception, `DirectoryNotEmptyException`, for the latter case). Here
    is a version of `Delete` with reporting of success or failure:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 请回忆一下本章开头关于权限的警告：如果您没有权限，则可能会得到 false 的返回值或者 `SecurityException`。还请注意，不同平台之间存在一些差异。某些
    Windows 版本允许 Java 删除只读文件，但 Unix 不允许您删除没有对其所在目录具有写权限的文件。Unix 也不允许您删除非空目录（对于后者甚至还有一个异常
    `DirectoryNotEmptyException`）。以下是带有成功或失败报告的 `Delete` 版本：
- en: '[PRE60]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The `-h` option allows this program to switch between `delete()` and `deleteIfExists()`;
    you can see the difference by running it on things that exist, don’t exist, and
    are not empty, using both methods. The output looks something like this on my
    Unix box:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: '`-h` 选项允许此程序在 `delete()` 和 `deleteIfExists()` 之间切换；您可以通过在存在、不存在和非空的情况下运行它，使用这两种方法来查看差异。在我的
    Unix 系统上，输出看起来像这样：'
- en: '[PRE61]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 10.21 Creating a Transient/Temporary File
  id: totrans-524
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10.21 创建临时文件
- en: Problem
  id: totrans-525
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to create a file with a unique temporary filename and/or or arrange
    for a file to be deleted when your program is finished.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要创建一个具有唯一临时文件名的文件，和/或在程序完成时安排文件被删除。
- en: Solution
  id: totrans-527
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the `java.nio.file.Files` `createTempFile()` or `createTempDirectory()`
    method. Use one of several methods to ensure your file is deleted on exit.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `java.nio.file.Files` 的 `createTempFile()` 或 `createTempDirectory()` 方法。使用多种方法之一确保文件在退出时被删除。
- en: Discussion
  id: totrans-529
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'The `Files` class has static methods for creating temporary files and directories.
    Note that a temporary file in this context is not deleted automatically; it is
    simply created in a directory that is set aside for temporary files on that operating
    system (e.g., /tmp on Unix). Here are the methods for creating tempory files and
    directories:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: '`Files`类有用于创建临时文件和目录的静态方法。请注意，在这种情况下临时文件不会自动删除；它只是在该操作系统上设置为临时文件的目录中创建（例如，在Unix上是/tmp）。以下是创建临时文件和目录的方法：'
- en: Path createTempFile(Path dir, String prefix, String suffix, FileAttribute<?>…
    attrs)
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: Path createTempFile(Path dir, String prefix, String suffix, FileAttribute<?>…
    attrs)
- en: Creates a new empty file in the specified directory, using the given prefix
    and suffix strings to generate its name
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 在指定目录中创建一个新的空文件，使用给定的前缀和后缀字符串生成其名称
- en: Path createTempFile(String prefix, String suffix, FileAttribute<?>… attrs)
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: Path createTempFile(String prefix, String suffix, FileAttribute<?>… attrs)
- en: Creates an empty file in the default temporary-file directory, using the given
    prefix and suffix to generate its name
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 在默认临时文件目录中创建一个空文件，使用给定的前缀和后缀生成其名称
- en: Path createTempDirectory(Path dir, String prefix, FileAttribute<?>… attrs)
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: Path createTempDirectory(Path dir, String prefix, FileAttribute<?>… attrs)
- en: Creates a new directory in the specified directory, using the given prefix to
    generate its name
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 在指定目录中创建一个新目录，使用给定的前缀生成其名称
- en: Path createTempDirectory(String prefix, FileAttribute<?>… attrs)
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: Path createTempDirectory(String prefix, FileAttribute<?>… attrs)
- en: Creates a new directory in the default temporary-file directory, using the given
    prefix to generate its name
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 在默认临时文件目录中创建一个新目录，使用给定的前缀生成其名称
- en: 'The file attributes are discussed in the sidebar [“Understanding I/O Options:
    StandardOpenOptions, FileAttribute, PosixFileAttribute, and More”](#javacook-ioOptions).'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 文件属性在侧边栏[“理解I/O选项：StandardOpenOptions、FileAttribute、PosixFileAttribute等”](#javacook-ioOptions)中讨论。
- en: 'There are various ways to arrange for a file to be deleted automatically. One
    is to use the legacy `java.io.File` class, which has a explicit `deleteOnExit()`
    method. This arranges for any file (no matter how it was created) to be deleted
    if it still exists when the program exits. Here we arrange for a backup copy of
    a program to be deleted on exit, and we also create a temporary file and arrange
    for it to be removed on exit. Both files are gone after the program runs:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以自动安排文件被删除。其中一种方法是使用旧的`java.io.File`类，该类具有显式的`deleteOnExit()`方法。这会安排在程序退出时删除任何文件（无论如何创建）。在这里，我们安排在退出时删除一个程序的备份副本，同时创建一个临时文件并安排在退出时删除。两个文件在程序运行后都消失了：
- en: '[PRE62]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'When run on a Unix system, this program looked like this, proving that the
    file was created but removed when the JVM exited:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unix系统上运行时，该程序看起来像这样，证明文件已创建但在JVM退出时被移除：
- en: '[PRE63]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The `createTempFile()` method is like `createNewFile()` (see [Recipe 10.18](#javacook-dirfile-SECT-2))
    in that it does create the file. Also be aware that, should the Java Virtual Machine
    terminate abnormally, the deletion probably will not occur. There is no way to
    undo the setting of `deleteOnExit()` short of renaming the file or something drastic
    like powering off the computer before the program exits.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: '`createTempFile()`方法类似于`createNewFile()`（见[食谱10.18](#javacook-dirfile-SECT-2)），它确实创建文件。同时要注意，如果Java虚拟机异常终止，删除可能不会发生。除了重命名文件或在程序退出之前关闭计算机等极端措施外，没有办法撤销`deleteOnExit()`的设置。'
- en: Another way to arrange for any file to be deleted when you are finished with
    it is to create it with the `DELETE_ON_CLOSE` option (see [Table 10-5](#javacook-dir_file-OPEN-OPTIONS))
    so it will be deleted when you close the file.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种安排文件在使用结束后被删除的方法是使用`DELETE_ON_CLOSE`选项创建文件（见[表10-5](#javacook-dir_file-OPEN-OPTIONS)），这样在关闭文件时它将被删除。
- en: A third, less likely method is to instead use a [JVM shutdown hook](https://darwinsys.com/java/shutdownhook.html).
    `DELETE_ON_CLOSE` is probably the best option, particularly in a long-running
    application, like most server-side apps. In these situations, the server could
    be running for weeks, months, or even years. In the meantime all the temp files
    would accumulate and the JVM would accumulate a large list of deferred work that
    it needs to perform upon shutdown. You’d probably run out of disk space or server
    memory or some other resource. For most long-running apps of this kind, it’s better
    to use `DELETE_ON_CLOSE` or even the explicit `delete()` operation. Another alternative
    is to use a scheduler service to periodically trigger removal of old temporary
    files.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种可能性的方法是使用[JVM关闭挂钩](https://darwinsys.com/java/shutdownhook.html)。`DELETE_ON_CLOSE`可能是最佳选项，特别是在像大多数服务器端应用程序这样的长时间运行的应用程序中。在这些情况下，服务器可能运行数周、数月甚至数年。与此同时，所有临时文件将累积，并且JVM将累积一大堆延迟执行的工作列表，需要在关闭时执行。您可能会因为某些资源不足而耗尽磁盘空间或服务器内存。对于大多数这种长时间运行的应用程序，最好使用`DELETE_ON_CLOSE`或甚至显式的`delete()`操作。另一种选择是使用调度程序服务定期触发删除旧临时文件。
- en: 10.22 Listing a Directory
  id: totrans-547
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10.22 列出一个目录
- en: Problem
  id: totrans-548
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to list the filesystem entries named in a directory.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要列出目录中命名的文件系统条目。
- en: Solution
  id: totrans-550
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the `java.nio.file.Files` static method `Stream<Path> list(Path dir)`, passing
    the `Path` representing the directory.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`java.nio.file.Files`的静态方法`Stream<Path> list(Path dir)`，传递代表目录的`Path`。
- en: Discussion
  id: totrans-552
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'The `java.nio.file.Files` class contains several methods for working with directories.
    If you just want to list the contents of a directory, use its `list(Path)` method.
    For example, to list the filesystem entities named in the current directory, just
    write the following:'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.nio.file.Files`类包含几种用于处理目录的方法。如果您只想列出目录的内容，请使用其`list(Path)`方法。例如，要列出当前目录中命名的文件系统实体，只需编写以下内容：'
- en: '[PRE64]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'This can become a complete program with as little as the following code. Note
    that on many systems the `Path` objects are returned in the order they occur in
    the directory, which isn’t sorted. In this simple example we use the `Stream.sorted()`
    method to order the entries alphabetically:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以仅用以下代码成为一个完整的程序。注意，在许多系统上，`Path`对象按照它们在目录中出现的顺序返回，这并不是按照排序的顺序。在这个简单的例子中，我们使用`Stream.sorted()`方法按字母顺序排序条目：
- en: '[PRE65]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Of course, there’s lots of room for elaboration. You could print the names in
    multiple columns across the page. Or even down the page because you know the number
    of items in the list before you print. You could omit filenames with leading periods,
    as does the Unix *ls* program. Or print the directory names first; I once used
    a directory lister called *lc* that did this, and I found it quite useful.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，还有很多可以详细阐述的地方。您可以在页面上跨多列打印名称。或者甚至在页面下方，因为您在打印之前知道列表中的项目数。您可以省略带有前导点的文件名，就像Unix的*ls*程序一样。或者首先打印目录名；我曾经使用过一个名为*lc*的目录列表工具，发现它非常有用。
- en: If you want to process the directory recursively, you should *not* check each
    entry to see if it’s a file or directory and recurse on directories. Instead,
    you should use one of the `walk()` or `walkFileTree()` methods discussed in [Recipe
    10.26](#javacook-dirfile-SECT-10); these handle recursion for you. There is also
    a set of `Files.newDirectoryStream()` methods, with and without filter callbacks
    and other arguments, that return a `DirectoryStream<Path>`.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望递归处理目录，则不应检查每个条目以查看它是文件还是目录，并在目录上进行递归。相反，您应该使用[Recipe 10.26](#javacook-dirfile-SECT-10)中讨论的`walk()`或`walkFileTree()`方法之一；这些方法会为您处理递归。还有一组`Files.newDirectoryStream()`方法，带有过滤回调和其他参数，返回一个`DirectoryStream<Path>`。
- en: 10.23 Getting the Directory Roots
  id: totrans-559
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10.23 获取目录根
- en: Problem
  id: totrans-560
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to know about the top-level directories, such as *C:\* and *D:\* on
    Windows.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 您想了解顶级目录，例如Windows上的*C:\*和*D:\*。
- en: Solution
  id: totrans-562
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the static method `FileSystems.getDefault().getRootDirectories()`, which
    returns an `Iterable` of `Path` objects, one for each root directory. You can
    print them or do other operations on them.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 使用静态方法`FileSystems.getDefault().getRootDirectories()`，它返回一个`Iterable`，其中包含每个根目录的`Path`对象。您可以打印它们或对它们进行其他操作。
- en: Discussion
  id: totrans-564
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Operating systems differ in how they organize filesystems out of multiple disk
    drives or partitions. Microsoft Windows has a low-level device-oriented approach
    in which each disk drive has a root directory named *A:\* for the first floppy
    (if you still have one!), *C:\* for the first hard drive, and other letters for
    CD-ROM and network drives. This approach requires you to know the physical device
    that a file is on. Unix, Linux, and macOS have a high-level approach with a single
    root directory */;* and different disks or partitions are mounted, or connected,
    into a single unified tree. This approach sometimes requires you to figure out
    where a device file is mounted. Perhaps neither is easier, though the Unix approach
    is a bit more consistent. Either way, Java makes it easy for you to get a list
    of the roots.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统在如何将多个磁盘驱动器或分区组织成文件系统方面存在差异。Microsoft Windows采用低级设备导向的方法，其中每个磁盘驱动器都有一个名为*A:\*（如果你还有软盘的话！）的根目录，*C:\*用于第一个硬盘驱动器，其他字母用于CD-ROM和网络驱动器。这种方法要求你知道文件所在的物理设备。Unix、Linux和macOS采用高级方法，只有一个根目录*/;*，不同的磁盘或分区被挂载或连接到一个统一的树中。这种方法有时要求你找出设备文件挂载的位置。也许两者都不容易，尽管Unix方法稍微更加一致一些。不管怎样，Java使得你能够轻松获取根目录的列表。
- en: 'The static method `FileSystems.getDefault().getRootDirectories()` returns an
    `Iterable<Path>` containing the available filesystem roots for whatever platform
    you are running on. Here is a short program to list these:'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 静态方法`FileSystems.getDefault().getRootDirectories()`返回一个包含当前平台可用文件系统根目录的`Iterable<Path>`。下面是列出这些根目录的简短程序：
- en: '[PRE66]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: As you can see, the program listed my floppy drive (even though the floppy drive
    was not only empty, but left at home while I wrote this recipe on my notebook
    computer in my car in a parking lot), the hard disk drive, and the CD-ROM drive.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，该程序列出了我的软盘驱动器（尽管软盘驱动器空空如也，并且在我写这篇配方的时候，我把它留在了家里，我是在我的汽车中的停车场上的笔记本电脑上写的），硬盘驱动器和CD-ROM驱动器。
- en: 'On Unix there is only one root directory:'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unix上只有一个根目录：
- en: '[PRE68]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: One thing that is left out of the list of roots is the so-called *UNC filename*.
    UNC filenames are used on some Microsoft platforms to refer to a network-available
    resource that hasn’t been mounted locally on a particular drive letter. If your
    system still uses these, be aware they will not show up in the `listDirectoryRoots()`
    output.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 根列表中遗漏的一件事是所谓的*UNC文件名*。UNC文件名在某些微软平台上用于引用未在特定驱动器上本地挂载的网络可用资源。如果你的系统仍然使用这些文件名，请注意它们不会显示在`listDirectoryRoots()`的输出中。
- en: 10.24 Using the FileWatcher Service to Get Notified About File Changes
  id: totrans-573
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10.24 使用FileWatcher服务来获取有关文件更改的通知
- en: Problem
  id: totrans-574
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to be notified when some other application updates one or more of the
    files in which you are interested.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 当你感兴趣的文件被其他应用程序更新时，你希望得到通知。
- en: Solution
  id: totrans-576
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the `java.nio.file.FileWatchService` to get notified of changes to files
    automatically, instead of having to examine the files periodically.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`java.nio.file.FileWatchService`自动获取文件更改的通知，而不必定期检查文件。
- en: Discussion
  id: totrans-578
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: It is fairly common for a large application to want to be notified of changes
    to files, without having to go and look at them periodically. For example, a Java
    Enterprise web server wants to know when Servlets and other components get updated.
    An IDE wants to know when files were modified by an external editor or a build
    script. Many modern operating systems have had this capability for some time,
    and now it is available in Java.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 大型应用程序通常希望在文件更改时得到通知，而无需定期查看它们。例如，Java企业Web服务器希望在Servlet和其他组件更新时得到通知。IDE想知道文件是否被外部编辑器或构建脚本修改。许多现代操作系统有这个能力已经有一段时间了，现在它在Java中也是可用的。
- en: 'These are the basic steps to using the `FileWatchService`:'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是使用`FileWatchService`的基本步骤：
- en: Create a `Path` object representing the directory you want to watch.
  id: totrans-581
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个表示要监视的目录的`Path`对象。
- en: Get a `WatchService` by calling, for example, `FileSystems.getDefault().newWatchService()`.
  id: totrans-582
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用例如`FileSystems.getDefault().newWatchService()`来获取`WatchService`。
- en: Create an array of `Kind` enumerations for the things you want to watch (in
    our example we watch for files being created or modified).
  id: totrans-583
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`Kind`枚举数组来监视你想要观察的内容（在我们的示例中，我们观察文件的创建或修改）。
- en: Register the `WatchService` and the `Kind` array onto the `Path` object.
  id: totrans-584
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注册`WatchService`和`Kind`数组到`Path`对象上。
- en: From then on, you wait for the watcher to notify you. A typical implementation
    is to enter a `while (true)` loop calling the `WatchService`’s `take()` method
    to get an event and interpret the events to figure out what just happened.
  id: totrans-585
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从那时起，您会等待监视器通知您。典型的实现方式是进入`while (true)`循环，调用`WatchService`的`take()`方法以获取事件，并解释事件以确定刚刚发生了什么。
- en: '[Example 10-12](#javacook-dirfile-fileWatchService-eg) is a program that does
    just that. In addition, it starts another thread to actually do some filesystem
    operations so that you can see the `WatchService` operating.'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 10-12](#javacook-dirfile-fileWatchService-eg) 是一个完成这些操作的程序。此外，它启动另一个线程来执行一些文件系统操作，这样您就可以看到`WatchService`的操作。'
- en: Example 10-12\. main/src/main/java/nio/FileWatchServiceDemo.java
  id: totrans-587
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-12\. main/src/main/java/nio/FileWatchServiceDemo.java
- en: '[PRE69]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '10.25 Program: Save User Data to Disk'
  id: totrans-589
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10.25 程序：将用户数据保存到磁盘
- en: Problem
  id: totrans-590
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to save user data to disk in a Java application. This may be in response
    to File→Save in a GUI application, saving the file in a text editor, or saving
    configuration data in a non-GUI application. You have heard (correctly) that a
    well-behaved application should never lose data.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 应用程序中，您需要将用户数据保存到磁盘上。这可能是响应于 GUI 应用程序中的文件→保存，保存文本编辑器中的文件，或保存非 GUI 应用程序中的配置数据。您可能听说过（正确地），一个表现良好的应用程序绝不应该丢失数据。
- en: Solution
  id: totrans-592
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Use this five-step plan, with appropriate variations:'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个五步计划，并根据情况进行适当的变化：
- en: Create a temporary file; arrange for it to be removed automatically with `deleteOnExit(true)`.
  id: totrans-594
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个临时文件；使用`deleteOnExit(true)`自动安排其在后续删除。
- en: Write the user data to this file. Data format translation errors, if any, will
    be thrown during this process, leaving the previous version of the user’s data
    file intact.
  id: totrans-595
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将用户数据写入此文件。在此过程中可能会抛出数据格式转换错误，但会保留用户数据文件的先前版本。
- en: Delete the backup file if it exists.
  id: totrans-596
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果备份文件存在，则删除备份文件。
- en: Rename the user’s previous file to **.bak*.
  id: totrans-597
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将用户先前的文件重命名为**.bak*。
- en: Rename the temporary file to the saved file.
  id: totrans-598
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将临时文件重命名为已保存文件。
- en: Discussion
  id: totrans-599
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'As developers, we have to deal with the fact that saving a file to disk is
    full of risk. There are many things that can go wrong in saving data, yet it is
    one of the most critical parts of most applications. If you lose data that a person
    has spent hours inputting, or even lose a setting that a user feels strongly about,
    she will despise your whole application. The disk might fill up while we’re writing
    it, or it might be full before we start. This is a user’s error, but we have to
    face it. So here’s a more detailed discussion of the little five-step dance we
    should go through:'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发人员，我们必须面对将文件保存到磁盘中充满风险的事实。在保存数据时可能出现许多问题，但这是大多数应用程序中最关键的部分之一。如果您丢失了一个人花了几小时输入的数据，甚至丢失了用户感到强烈关注的设置，她会憎恨您的整个应用程序。在写入过程中，磁盘可能会填满，或者在我们开始之前就已经满了。这是用户的错误，但我们必须面对它。因此，这里有一个更详细的讨论，介绍了我们应该进行的小五步舞蹈：
- en: Create a temporary file that we will write to. Set this file to `deleteOnExit(true)`
    so that if we fail in a later step we don’t clutter the disk. Because we are later
    going to rename this file to become the user’s real file, and we don’t want to
    run out of disk space during the rename, it is important that we create the file
    on the same disk drive partition (*drive letter* or *mount point*) as the user’s
    real file; otherwise the rename will silently morph into a copy-and-delete, which
    could fail due to lack of disk space. See [Recipe 10.21](#javacook-dirfile-SECT-5)
    for methods of deleting a file on exit.
  id: totrans-601
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个我们将要写入的临时文件。将此文件设置为`deleteOnExit(true)`，这样如果在后续步骤中失败，我们就不会在磁盘上留下残余文件。因为我们稍后将重命名此文件以成为用户的真实文件，而且我们不希望在重命名过程中因为磁盘空间不足而失败，所以很重要的一点是我们必须在与用户真实文件相同的磁盘驱动器分区（*驱动器号*或*挂载点*）上创建此文件；否则，重命名将悄无声息地变成复制和删除操作，这可能因为磁盘空间不足而失败。参见
    [Recipe 10.21](#javacook-dirfile-SECT-5) 了解在退出时删除文件的方法。
- en: Write the user data to this new temporary file. If we are transforming data—say,
    getting it from a JDBC ResultSet or writing objects using a XML transformer—an
    exception could be thrown. If we’re not careful, these exceptions can cause the
    user’s data to be lost.
  id: totrans-602
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将用户数据写入这个新的临时文件。如果我们在转换数据，比如从 JDBC ResultSet 获取数据或使用 XML 转换器写入对象时，可能会抛出异常。如果我们不小心，这些异常可能会导致用户的数据丢失。
- en: Delete the backup file if it exists. First time we do this it won’t exist; after
    that it probably will. Be prepared either way.
  id: totrans-603
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果备份文件存在，则删除备份文件。第一次执行时它不存在；之后可能会存在。无论如何都要有所准备。
- en: Rename the user’s previous file to **.bak*_.
  id: totrans-604
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将用户先前的文件重命名为**.bak*_。
- en: Rename the temporary file to the save file.
  id: totrans-605
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将临时文件重命名为保存文件。
- en: This may seem like overkill, but it prevents career kill. I’ve done pretty much
    this in numerous apps with various save file formats. This plan is the only really
    safe way around all the problems that can occur. For example, the final step has
    to be a rename not a copy, regardless of size considerations, to avoid the problem
    of the disk filling up. So, to be correct, you have to ensure that the temp file
    gets created on the same disk partition (drive letter or mount point) as the user’s
    file.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来有些多余，但可以防止职业生涯的破坏。我在多个应用程序中几乎都这样做，使用各种保存文件格式。这个计划是唯一真正安全的方法，可以避免所有可能发生的问题。例如，最后一步必须是重命名而不是复制，无论考虑大小，都要避免磁盘填满的问题。因此，要正确操作，必须确保临时文件在与用户文件相同的磁盘分区（驱动器号或挂载点）上创建。
- en: 'This is the basic plan to use the `FileSaver`:'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用 `FileSaver` 的基本计划：
- en: Instantiate it by calling the constructor.
  id: totrans-608
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过调用构造函数来实例化它。
- en: Call the `getWriter()` or `getOutputStream()` method.
  id: totrans-609
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用 `getWriter()` 或 `getOutputStream()` 方法。
- en: Use the output file to write the data.
  id: totrans-610
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用输出文件写入数据。
- en: Call `finish()` on the `FileSaver` object.
  id: totrans-611
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `FileSaver` 对象上调用 `finish()`。
- en: '*main/src/main/java/com/darwinsys/io/FileSaver.java*'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: '*main/src/main/java/com/darwinsys/io/FileSaver.java*'
- en: '[PRE70]'
  id: totrans-613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Acknowledgments
  id: totrans-614
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 致谢
- en: The code in this program is my own, based on my experience in various applications.
    I was prompted to package it up this way, and write it up, by a post by Brendon
    McLean to the mailing list for the now-defunct [Java Application Framework JSR-296](http://jcp.org/en/jsr/detail?id=296).
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序中的代码是我根据在各种应用程序中的经验自己编写的。我被 Brendon McLean 在现已废弃的 [Java 应用程序框架 JSR-296](http://jcp.org/en/jsr/detail?id=296)
    的邮件列表上的一篇帖子激发，以这种方式打包并写出它。
- en: '10.26 Program: Find—Walking a File Tree'
  id: totrans-616
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10.26 程序：Find —— 遍历文件树
- en: 'The program shown in [Example 10-13](#javacook-dirfile-SECT-10-ex) implements
    a subset of the Windows *Find Files* dialog or the Unix *find* command. It has
    most of the structure needed to build a more complete version of either of these.
    It accepts the following options from standard Unix `find` (with limits):'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 10-13](#javacook-dirfile-SECT-10-ex) 中的程序实现了 Windows 的 *查找文件* 对话框或 Unix
    的 *find* 命令的子集。它具有构建更完整版本所需的大部分结构。它从标准 Unix 的 `find` 命令接受以下选项（带有限制）：'
- en: '`-n *name*`'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: '`-n *name*`'
- en: Name to look for. Can include shell wildcards if quoted from the shell.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 要查找的名称。如果从 shell 引用，则可以包含 shell 通配符。
- en: '`-s *size*`'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: '`-s *size*`'
- en: Size of file to look for. Can prefix with a plus sign to indicate greater than
    or a minus sign to indicate less than.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 要查找的文件大小。可以以加号表示大于或减号表示小于。
- en: '`-a`, `-o`'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: '`-a`, `-o`'
- en: And or or, but only one of these, between a `-n` and a `-s`.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: And or or, but only one of these, between a `-n` and a `-s`.
- en: The `Files` class has four methods for walking a file tree. Two return a lazily
    populated `Stream<Path>`, and the other two invoke a callback `FileVisitor` for
    each file or directory found. My `find` implementation uses the first one; the
    four are summarized in [Table 10-11](#javacook-dir_file-Files-Walkers).
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: '`Files` 类有四种方法来遍历文件树。其中两种返回延迟填充的 `Stream<Path>`，另外两种为每个找到的文件或目录调用回调 `FileVisitor`。我的
    `find` 实现使用第一种；这四种方法在 [表 10-11](#javacook-dir_file-Files-Walkers) 中有概述。'
- en: Table 10-11\. Files tree walk methods
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 表 10-11\. 文件树遍历方法
- en: '| Return | Signature |'
  id: totrans-626
  prefs: []
  type: TYPE_TB
  zh: '| 返回 | 签名 |'
- en: '| --- | --- |'
  id: totrans-627
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Stream<Path>` | walk(Path start, FileVisitOption… options) |'
  id: totrans-628
  prefs: []
  type: TYPE_TB
  zh: '| `Stream<Path>` | walk(Path start, FileVisitOption… options) |'
- en: '| `Stream<Path>` | walk(Path start, int maxDepth, FileVisitOption… options)
    |'
  id: totrans-629
  prefs: []
  type: TYPE_TB
  zh: '| `Stream<Path>` | walk(Path start, int maxDepth, FileVisitOption… options)
    |'
- en: '| `Path` | walkFileTree(Path start, FileVisitor<? super Path> visitor) |'
  id: totrans-630
  prefs: []
  type: TYPE_TB
  zh: '| `Path` | walkFileTree(Path start, FileVisitor<? super Path> visitor) |'
- en: '| `Path` | walkFileTree(Path start, Set<FileVisitOption> options, int maxDepth,
    FileVisitor<? super Path> visitor) |'
  id: totrans-631
  prefs: []
  type: TYPE_TB
  zh: '| `Path` | walkFileTree(Path start, Set<FileVisitOption> options, int maxDepth,
    FileVisitor<? super Path> visitor) |'
- en: 'Using the `walk()` methods is as simple as this:'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `walk()` 方法就像这样简单：
- en: '[PRE71]'
  id: totrans-633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: That code is near the start of the `startWalkingAt()` method in [Example 10-13](#javacook-dirfile-SECT-10-ex).
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 那段代码位于 [示例 10-13](#javacook-dirfile-SECT-10-ex) 的 `startWalkingAt()` 方法的开头附近。
- en: Example 10-13\. main/src/main/java/dir_file/Find.java
  id: totrans-635
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-13\. main/src/main/java/dir_file/Find.java
- en: '[PRE72]'
  id: totrans-636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[Example 10-14](#javacook-dirfile-SECT-10-ex2) shows a class called `FindFilter`,
    the backend implementation of `Find`.'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 10-14](#javacook-dirfile-SECT-10-ex2) 展示了一个名为 `FindFilter` 的类，是 `Find`
    的后端实现。'
- en: Example 10-14\. main/src/main/java/dir_file/FindFilter.java
  id: totrans-638
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-14\. main/src/main/java/dir_file/FindFilter.java
- en: '[PRE73]'
  id: totrans-639
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '^([1](ch10.html#idm45290657814168-marker)) A poor choice of name: it was new
    in Java SE 1.4\. But newer than `InputStream`/`OutputStream` (Java 1.0) and `Reader`s/`Writer`s
    (1.1).'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch10.html#idm45290657814168-marker)) 名称选择不佳：它是在 Java SE 1.4 中新增的。但比 `InputStream`/`OutputStream`（Java
    1.0）和 `Reader`s/`Writer`s（1.1）更新。
- en: ^([2](ch10.html#idm45290657786632-marker)) Not strictly true; there is, but
    only in the `java.nio.FileChannel` class, which we’re not covering.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch10.html#idm45290657786632-marker)) 不完全正确；在 `java.nio.FileChannel` 类中是有的，但我们没有涵盖它。
- en: ^([3](ch10.html#idm45290656852712-marker)) The central character in Yann Martel’s
    novel *Life of Pi* would have been born in 1956, according to information in [Wikipedia](http://en.wikipedia.org/wiki/Life_of_pi).
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch10.html#idm45290656852712-marker)) 《少年派的奇幻漂流》中的中心人物应该是根据 [Wikipedia](http://en.wikipedia.org/wiki/Life_of_pi)
    中的信息于 1956 年出生。
- en: ^([4](ch10.html#idm45290655572552-marker)) If this were code in a maintained
    project, I might factor out some of the common code among these two calculators,
    as well as the one in [Recipe 5.12](ch05.html#javacook-numbers-SECT-19), and divide
    the code better using interfaces. However, this would detract from the simplicity
    of self-contained examples.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch10.html#idm45290655572552-marker)) 如果这是一个维护项目中的代码，我可能会将这两个计算器中的一些常见代码因子提取出来，以及
    [Recipe 5.12](ch05.html#javacook-numbers-SECT-19) 中的代码，并使用接口更好地划分代码。然而，这会减弱自包含示例的简洁性。
- en: ^([5](ch10.html#idm45290653458856-marker)) There is no support for adding files
    to an existing archive, so make sure you put all the files in at once or be prepared
    to re-create the archive from scratch.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch10.html#idm45290653458856-marker)) 不支持向现有存档添加文件，因此确保一次性将所有文件放入或准备好从头开始重新创建存档。
