- en: Chapter 7\. Working With Streams
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 7 章\. 使用流处理数据
- en: Streams utilize many of the functional features introduced in Java 8 to provide
    a declarative way to process data. The Stream API covers many use cases, but you
    need to know the different operations and available helper classes work to make
    the most of them.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 流利用了Java 8引入的许多函数特性，提供了一种声明性的方式来处理数据。流API涵盖了许多用例，但你需要了解不同的操作和可用的辅助类，以充分利用它们。
- en: '[Chapter 6](ch06.xhtml#_02-data-processing) concentrated on showing you the
    foundation of Streams. This chapter will build on that and teach you different
    ways to create and work with Streams for various use cases.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 6 章](ch06.xhtml#_02-data-processing) 着重介绍了流的基础知识。本章将在此基础上构建，并教你创建和处理流以解决各种用例。'
- en: Primitive Streams
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原始流
- en: 'In Java, generics only work with object-based types (yet^([1](ch07.xhtml#idm45115235898112))).
    That’s why `Stream<T>` can’t be used for sequences of primitive values like `int`.
    There are only two options for using primitive types with Streams:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，泛型仅适用于基于对象的类型（参见^([1](ch07.xhtml#idm45115235898112))）。这就是为什么`Stream<T>`不能用于像`int`这样的原始值序列的原因。使用原始类型与流的唯一两种选项是：
- en: Autoboxing
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动装箱
- en: Specialized Stream variants
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 专门的流变体
- en: 'Java’s autoboxing support — the automatic conversion between primitive types
    and the object-based counterparts like `int` and `Integer` — may seem like a simple
    workaround because it automagically works, as shown as follows:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Java的自动装箱支持 — 自动将原始类型与像`int`和`Integer`之类的基于对象的对应物转换 — 可能看起来像是一个简单的解决方案，因为它自动地工作，如下所示：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Autoboxing introduces multiple problems, though. For one, there’s the overhead
    associated with the conversion from primitive values to objects compared to using
    primitive types directly. Usually, the overhead is negligible. Still, in a data
    processing pipeline, the overhead of such frequent creation of wrapper types accumulates
    and can degrade overall performance.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管自动装箱引入了多个问题。例如，与直接使用原始类型相比，从原始值到对象的转换会导致开销。通常情况下，这种开销可以忽略不计。然而，在数据处理管道中，频繁创建包装类型的开销会累积，并可能降低整体性能。
- en: Another non-issue with primitive wrappers is the possibility of `null` elements.
    The direct conversion from primitive to object type never results in `null`, but
    any operation in the pipeline might return `null` if it has to deal with the wrapper
    type instead of a primitive.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 原始包装类型的另一个非问题是可能存在`null`元素的情况。从原始类型直接转换为对象类型永远不会产生`null`，但是如果在流水线操作中需要处理包装类型而不是原始类型，则任何操作可能返回`null`。
- en: To mitigate, the Stream API, like other functional features of the JDK, has
    specialized variants for primitive types `int`, `long`, and `double` without relying
    on autoboxing, as listed in [Table 7-1](#_02-streams_primitive-streams-equivalents).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少这种情况，与JDK的其他函数特性一样，Stream API为`int`、`long`和`double`等原始类型提供了专门的变体，而不依赖于自动装箱，如[表 7-1](#_02-streams_primitive-streams-equivalents)中所列。
- en: Table 7-1\. Primitive Streams and their equivalents
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7-1\. 原始流及其等价物
- en: '| Primitive Type | Primitive Stream | Boxed Stream |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| 原始类型 | 原始流 | 装箱流 |'
- en: '| --- | --- | --- |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `int` | `IntStream` | `Stream<Integer>` |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| `int` | `IntStream` | `Stream<Integer>` |'
- en: '| `long` | `LongStream` | `Stream<Long>` |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| `long` | `LongStream` | `Stream<Long>` |'
- en: '| `double` | `DoubleStream` | `Stream<Double>` |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| `double` | `DoubleStream` | `Stream<Double>` |'
- en: 'The available operations on primitive Streams are similar to their generic
    counterpart but use primitive functional interfaces. For example, an `IntStream`
    provides a `map` operation for transforming elements, just like `Stream<T>`. Unlike
    `Stream<T>` though, the required higher-order function to do so is the specialized
    variant `IntUnaryOperator`, which accepts and returns an `int`, as the following
    simplified interface declaration shows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 原始流上的可用操作与它们的通用对应物相似，但使用原始功能接口。例如，`IntStream`提供了一个`map`操作来转换元素，就像`Stream<T>`一样。不过，不同于`Stream<T>`，进行此操作所需的高阶函数是专门的变体`IntUnaryOperator`，它接受并返回`int`，如下简化的接口声明所示：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Operations accepting higher-order functions on primitive Streams use specialized
    functional interfaces, like `IntConsumer` or `IntPredicate`, to stay within the
    confines of the primitive Stream. That reduces the number of available operations
    compared to `Stream<T>`. Still, you can easily switch between a primitive Stream
    and a `Stream<T>` by either mapping to another type or converting the primitive
    Stream to its boxed variant:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在原始流上接受高阶函数的操作使用专门的功能接口，如`IntConsumer`或`IntPredicate`，以保持在原始流的限制范围内。与`Stream<T>`相比，这减少了可用操作的数量。不过，你可以通过将其映射到另一种类型或将原始流转换为其装箱变体来轻松地在原始流和`Stream<T>`之间切换：
- en: '`Stream<Integer> boxed()`'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stream<Integer> boxed()`'
- en: '`Stream<U> mapToObj(IntFunction<? extends U> mapper)`'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stream<U> mapToObj(IntFunction<? extends U> mapper)`'
- en: 'The other way around, from `Stream<T>` to a primitive Stream, is also supported,
    with `mapTo…​` and `flatMapTo…​` operations available on `Stream<T>`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 反过来，从`Stream<T>`到原始流也是支持的，`Stream<T>`上可用`mapTo...`和`flatMapTo...`操作：
- en: '`IntStream mapToInt(ToIntFunction<? super T> mapper)`'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IntStream mapToInt(ToIntFunction<? super T> mapper)`'
- en: '`IntStream flatMapToInt(Function<? super T, ? extends IntStream> mapper)`'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IntStream flatMapToInt(Function<? super T, ? extends IntStream> mapper)`'
- en: 'Besides the usual intermediate operations, primitive Streams have a set of
    self-explanatory arithmetic terminal operations for common tasks:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 除了常规的中间操作外，原始流还具有一组直观的算术终端操作用于常见任务：
- en: '`int sum()`'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int sum()`'
- en: '`OptionalInt min()`'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OptionalInt min()`'
- en: '`OptionalInt max()`'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OptionalInt max()`'
- en: '`OptionalDouble average()`'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OptionalDouble average()`'
- en: These operations don’t need any arguments because their behavior is non-negotiable
    for numbers. The returned types are the primitive equivalents you expect from
    similar `Stream<T>` operations.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作不需要任何参数，因为它们的行为对于数字是不可协商的。返回的类型是你从类似`Stream<T>`操作中期望的原始等价类型。
- en: As with primitive Streams in general, doing arithmetics with Streams has its
    use cases, like highly optimized parallel processing of humongous amounts of data.
    For simpler use cases, though, switching to primitive Streams compared to existing
    processing structures usually won’t be worth it.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 与一般的原始流一样，使用流进行算术运算有其用例，比如高度优化的并行处理大量数据。不过，对于更简单的用例，与现有的处理结构相比，切换到原始流通常不值得。
- en: Iterative Streams
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代流
- en: 'Stream pipelines and their internal iteration usually deal with existing sequences
    of elements or data structures readily convertible to sequences of elements. Compared
    to traditional looping constructs, you have to let go of controlling the iteration
    process and let the Stream take over. If you require more control, though, the
    Stream API still has you covered with its `static iterate` methods available on
    the `Stream<T>` type:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 流管道及其内部迭代通常处理现有元素序列或可轻松转换为元素序列的数据结构。与传统的循环结构相比，你必须放弃控制迭代过程，让流接管。然而，如果你需要更多控制，流API仍提供了在`Stream<T>`类型上可用的`static
    iterate`方法：
- en: '`<T> Stream<T> iterate(T seed, UnaryOperator<T> f)`'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<T> Stream<T> iterate(T seed, UnaryOperator<T> f)`'
- en: '`IntStream iterate(int seed, IntUnaryOperator f)`'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IntStream iterate(int seed, IntUnaryOperator f)`'
- en: 'Java 9 added two additional methods, including a `Predicate` variant to have
    an end condition:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9添加了两种额外的方法，包括一个`Predicate`变体来设定结束条件：
- en: '`<T> Stream<T> iterate(T seed, Predicate<T> hasNext, UnaryOperator<T> next)`'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<T> Stream<T> iterate(T seed, Predicate<T> hasNext, UnaryOperator<T> next)`'
- en: '`IntStream iterate(int seed, IntPredicate hasNext, IntUnaryOperator next)`'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IntStream iterate(int seed, IntPredicate hasNext, IntUnaryOperator next)`'
- en: Primitive `iterate` variants are available for `int`, `long`, and `double` on
    their corresponding Stream variants.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 对于它们对应的流变体，`int`、`long`和`double`都有原始的`iterate`变体可用。
- en: The iterative approach to Streams produces an *ordered* and potentially infinite
    sequence of elements by applying an `UnaryOperator` to a seed value. In other
    words, the Stream elements will be `[seed, f(seed), f(f(seed)), …​]`, and so on.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 流的迭代方法产生通过将`UnaryOperator`应用于种子值而成为*有序*且可能无限的元素序列。换句话说，流元素将是`[seed, f(seed),
    f(f(seed)), ...]`等等。
- en: 'If the general concept feels familiar, you’re right! It’s a Stream-equivalent
    to a `for`-loop:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这一般概念感觉熟悉，你是对的！它是`for`循环的流等价物：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[![1](assets/1.png)](#co_working_with_streams_CO1-1)'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_working_with_streams_CO1-1)'
- en: The seed, or initial iteration value.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 种子，或初始迭代值。
- en: '[![2](assets/2.png)](#co_working_with_streams_CO1-2)'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_working_with_streams_CO1-2)'
- en: The termination condition.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 终止条件。
- en: '[![3](assets/3.png)](#co_working_with_streams_CO1-3)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_working_with_streams_CO1-3)'
- en: The incrementation of the iteration value. The `for`-loop needs an assignment
    where the `Stream` requires a return value instead.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代值的增加。`for`循环需要赋值，而流需要返回值。
- en: Both loop and Streams variants produce the same elements for the loop body /
    subsequent Stream operations. Java 9 introduced an `iterate` variant that includes
    a limiting `Predicate`, so no additional operations are needed to restrict the
    overall elements.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 循环和流的变体为循环体/后续流操作产生相同的元素。Java 9引入了带有限制`Predicate`的`iterate`变体，因此不需要额外的操作来限制总体元素。
- en: The most significant advantage of an iterative Stream over a `for` loop is that
    you can still use a loop-like iteration but gain the benefits of a lazy functional
    Stream pipeline.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代流相比`for`循环的最大优势在于，您仍然可以使用类似循环的迭代，但获得惰性函数流管道的好处。
- en: The end condition doesn’t have to be defined on Stream creation. Instead, a
    later intermediate Stream operation, like `limit`, or a terminal condition, like
    `anyMatch`, may provide it.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 不必在流创建时定义结束条件。相反，稍后的中间流操作，如`limit`，或终端条件，如`anyMatch`，可以提供它。
- en: 'The characteristics of an iterative Stream are `ORDERED`, `IMMUTABLE`, and
    in the case of primitive Streams, `NONNULL`. If the iteration is number-based
    and the range is known beforehand, you can benefit from more Stream optimizations,
    like short-circuiting, by using the `static range…​` methods for Stream creation
    available on `IntStream` and `LongStream` instead:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代流的特性为`ORDERED`、`IMMUTABLE`，对于原始流而言还包括`NONNULL`。如果迭代基于数字且范围已知，可以通过`IntStream`和`LongStream`上的静态`range…​`方法获得更多流的优化，如短路。
- en: '`IntStream range(int startInclusive, int endExclusive)`'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IntStream range(int startInclusive, int endExclusive)`'
- en: '`IntStream rangeClosed(int startInclusive, int endInclusive)`'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IntStream rangeClosed(int startInclusive, int endInclusive)`'
- en: '`LongStream range(long startInclusive, +long endExclusive)`'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LongStream range(long startInclusive, +long endExclusive)`'
- en: '`LongStream rangeClosed(long startInclusive, long endInclusive)`'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LongStream rangeClosed(long startInclusive, long endInclusive)`'
- en: Even though the same results are achievable with `iterate`, the main difference
    is the underlying `Spliterator`. The returned Stream’s characteristics `ORDERED`,
    `SIZED`, `SUBSIZED`, `IMMUTABLE`, `NONNULL`, `DISTINCT`, and `SORTED`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 即使可以通过`iterate`获得相同的结果，主要区别在于底层的`Spliterator`。返回的流的特性为`ORDERED`、`SIZED`、`SUBSIZED`、`IMMUTABLE`、`NONNULL`、`DISTINCT`和`SORTED`。
- en: Choosing between iterative or ranged Stream creation depends on what you want
    to achieve. The iterative approach gives you more freedom for the iteration process,
    but you lose out on Stream characteristics enabling the most optimization possibilities,
    especially in parallel Streams.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 选择迭代或范围流的创建取决于您的需求。迭代方法为迭代过程提供更多自由度，但失去了流特性，尤其是在并行流中提供最优化可能性。
- en: Infinite Streams
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无限流
- en: The lazy nature of Streams allows for infinite sequences of elements as they
    are processed *on-demand*, and not *all at once*.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 流的惰性特性允许元素作为它们被*按需*处理，而不是*一次性*处理。
- en: All available Stream interfaces in the JDK — `Stream<T>` and its primitive brethren
    `IntStream`, `LongStream`, and `DoubleStream` — have `static` convenience methods
    to create infinite Streams either based on an iterative approach or an unordered
    generative one.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: JDK中所有可用的流接口 — `Stream<T>`及其原始衍生物`IntStream`、`LongStream`和`DoubleStream` — 都具有用于基于迭代方法或无序生成方法创建无限流的静态便捷方法。
- en: 'While the `iterate` methods from the previous section start with a *seed* and
    rely on applying their `UnaryOperator` on the current iteration value, the `static
    generate` methods only rely on a `Supplier` to generate their next Stream element:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然前面的`iterate`方法从一个*种子*开始，并依赖于在当前迭代值上应用它们的`UnaryOperator`，但`static generate`方法只依赖于`Supplier`生成它们的下一个流元素：
- en: '`<T> Stream<T> generate(Supplier<T> s)`'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<T> Stream<T> generate(Supplier<T> s)`'
- en: '`IntStream generate(IntSupplier s)`'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IntStream generate(IntSupplier s)`'
- en: '`LongStream generate(LongSupplier s)`'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LongStream generate(LongSupplier s)`'
- en: '`DoubleStream generate(DoubleSupplier s)`'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DoubleStream generate(DoubleSupplier s)`'
- en: 'The lack of a starting seed value affects the Stream’s characteristics, making
    it `UNORDERED`, which can be beneficial for parallel use. An unordered Stream
    created by a `Supplier` is helpful for constant non-interdependent sequences of
    elements, like random values. For example, creating an `UUID` Stream factory is
    quite simple:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 缺少起始种子值会影响流的特性，使其变为`UNORDERED`，这对并行使用很有益。通过`Supplier`创建的无序流对于常量、非相互依赖的元素序列（例如随机值）非常有帮助。例如，创建一个`UUID`流工厂非常简单：
- en: '[PRE3]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The downside of unordered Streams is that they won’t guarantee that a `limit`
    operation will pick the first `n` elements in a parallel environment. That may
    result in more calls to the element generating `Supplier` than are actually necessary
    for the result of the Stream.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 无序流的缺点在于，它们不能保证`limit`操作会在并行环境中选择前`n`个元素。这可能导致对元素生成`Supplier`的调用次数比实际结果流所需的次数多。
- en: 'Take the following example:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 参考以下示例：
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The expected output of the pipeline is `1000`. The output, though, will most
    likely be greater than `1000`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 流管道的预期输出是`1000`。但输出很可能大于`1000`。
- en: This behavior is expected from an unordered Stream in a parallel execution environment.
    Under most circumstances, it won’t matter much, but it highlights the necessity
    of choosing the right Stream type with favorable characteristics to gain maximum
    performance and the fewest invocations possible.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为在并行执行环境中的无序流中是预期的。在大多数情况下，这并不重要，但它突显了选择具有良好特性的正确流类型以获得最大性能和尽可能少的调用的必要性。
- en: Random Numbers
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 随机数
- en: The Stream API has special considerations for generating an infinite Stream
    of random numbers. Although it’s possible to create such a Stream with `Stream.generate`
    using, for example, `Random#next()`, there’s an easier way available.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 流 API 对生成无限随机数流有特殊考虑。虽然可以使用`Stream.generate`来创建这样的流，例如使用`Random#next()`，但也有更简单的方法可用。
- en: 'Three different random-number-generating types are capable of creating Streams:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种不同的随机数生成类型能够创建流：
- en: '`java.util.Random`'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.Random`'
- en: '`java.util.concurrent.ThreadLocalRandom`'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.concurrent.ThreadLocalRandom`'
- en: '`java.util.SplittableRandom`'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.SplittableRandom`'
- en: 'All three of them provide multiple methods to create Streams of random elements:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这三种类型都提供了多种方法来创建随机元素的流：
- en: '[PRE5]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Technically, the Streams are only *effectively infinite*, as it’s stated in
    their documentation^([2](ch07.xhtml#idm45115235350064)). If no `streamSize` is
    provided, the resulting Stream contains `Long.MAX_VALUE` elements. The upper and
    lower bounds are set with the `randomNumberOrigin` (inclusive) and `randomNumberBound`
    (exclusive).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 技术上，这些流只是*有效地无限*，如它们文档中所述^([2](ch07.xhtml#idm45115235350064))。如果未提供`streamSize`，结果流将包含`Long.MAX_VALUE`个元素。上限和下限由`randomNumberOrigin`（包括）和`randomNumberBound`（不包括）设置。
- en: 'General usage and performance characteristics will be discussed in [“Example:
    Random Numbers”](ch08.xhtml#_01-parallel-concurrent-async_seq-vs-para).'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 将在 [“示例：随机数”](ch08.xhtml#_01-parallel-concurrent-async_seq-vs-para) 中讨论一般使用和性能特征。
- en: Memory Isn’t Infinite
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记忆并非无限
- en: The most important thing to remember when using infinite Streams is that your
    memory is quite finite. Limiting your infinite Streams isn’t just important, it’s
    an absolute necessity! Forgetting to put a restricting intermediate or terminal
    operation will inevitably use up all memory available to the JVM and eventually
    throw an `OutOfMemoryError`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用无限流时最重要的一点是，你的内存是有限的。限制无限流不仅重要，而且是绝对必要的！忘记放置限制性的中间或终端操作将不可避免地使用完 JVM 可用的所有内存，并最终抛出`OutOfMemoryError`。
- en: The available operations to restrict any Stream are listed in [Table 7-2](#_02-streams_infinite-restricting-ops).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 列出了用于限制任何流的可用操作，见[表 7-2](#_02-streams_infinite-restricting-ops)。
- en: Table 7-2\. Stream-restricting operations
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7-2\. 流限制操作
- en: '| Operation Type | Operation | Description |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| 操作类型 | 操作 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Intermediate Operations | `limit(long maxSize)` | Limits a Stream to `maxSize`
    elements |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| 中间操作 | `limit(long maxSize)` | 将流限制为`maxSize`个元素 |'
- en: '| `takeWhile(Predicate<T> predicate)` | Takes elements until `predicate` evaluates
    `false` (Java 9+) |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `takeWhile(Predicate<T> predicate)` | 取元素直到`predicate`评估为`false`（Java 9+）
    |'
- en: '| Terminal Operations (guaranteed) | `Optional<T> findFirst()` | Returns the
    first element of the Stream |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| 终端操作（保证） | `Optional<T> findFirst()` | 返回流的第一个元素 |'
- en: '| `Optional<T> findAny()` | Return a single, non-deterministic Steam element
    |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `Optional<T> findAny()` | 返回单个、非确定性的流元素 |'
- en: '| Terminal Operations (non-guaranteed) | `boolean anyMatch(Predicate<T> predicate)`
    | Returns whether *any* Stream elements match `predicate` |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| 终端操作（不保证） | `boolean anyMatch(Predicate<T> predicate)` | 返回是否有*任何*流元素与`predicate`匹配
    |'
- en: '| `boolean allMatch(Predicate<T> predicate)` | Returns whether *all* Stream
    elements match `predicate` |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `boolean allMatch(Predicate<T> predicate)` | 返回是否*所有*流元素与`predicate`匹配 |'
- en: '| `boolean noneMatch(Predicate<T> predicate)` | Returns whether *no* Stream
    element matches `predicate` |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `boolean noneMatch(Predicate<T> predicate)` | 返回是否*没有*流元素与`predicate`匹配 |'
- en: The most straightforward choice is `limit`. Choice-based operations using `Predicate<T>`
    like `takeWhile` must be crafted with diligence, or you might still end up with
    a Stream consuming more memory than needed. For terminal operations, only the
    `find…​` operations are guaranteed to terminate the Stream.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的选择是`limit`。像`takeWhile`这样使用`Predicate<T>`的选择操作必须谨慎制定，否则可能仍会导致流消耗比需要更多的内存。对于终端操作，只有`find…​`操作能保证终止流。
- en: The `…​Match` operations suffer from the same problem as `takeWhile`. If the
    predicate doesn’t match according to their purpose, the Stream pipeline will process
    an *infinite* number of elements and, therefore, all the available memory.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`…​Match`操作与`takeWhile`存在相同的问题。如果谓词不符合它们的目的，流管道将处理*无限*数量的元素，并因此消耗所有可用内存。'
- en: As discussed in [“The Cost of Operations”](ch06.xhtml#_02-data-processing_order-matters),
    the position of the restricting operation in the Stream also makes a difference
    in how many elements will pass through. Even if the final result might be identical,
    restricting the flow of Stream elements as early as possible will save you more
    memory and CPU cycles.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如[“操作的成本”](ch06.xhtml#_02-data-processing_order-matters)中讨论的，流中限制操作的位置也会影响通过的元素数量。即使最终结果可能相同，尽早限制流元素的流动将节省更多内存和CPU周期。
- en: From Arrays to Streams and Back
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从数组到流，再从流到数组
- en: Arrays are a particular type of object. They’re a collection-like structure,
    holding elements of their *base type*, and only provide a method to access a specific
    element by its index, and the overall length of the array, besides the *usual*
    methods inherited from `java.lang.Object`. They’re also the only way to have a
    collection of primitive types until *Project Valhalla* becomes available in the
    future^([3](ch07.xhtml#idm45115235120224)).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是一种特殊类型的对象。它们是一种类似集合的结构，保存其*基本类型*的元素，并且仅提供一种通过索引访问特定元素以及数组的总长度的方法，除了从`java.lang.Object`继承的*通常*方法。它们也是未来直到*Valhalla项目*变得可用之前，拥有原始类型集合的唯一方式^([3](ch07.xhtml#idm45115235120224))。
- en: However, two characteristics make arrays a good match for Stream-based processing.
    First, their length is set on their creation and won’t change. Second, they’re
    an ordered sequence. That’s why there are multiple convenience methods available
    on `java.util.Arrays` to create an appropriate Stream for different base types.
    Creating an array from a Stream is done with an appropriate terminal operation.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，数组具有两个特征使其非常适合基于流的处理。首先，它们在创建时就确定了长度并且不会改变。其次，它们是有序序列。这就是为什么`java.util.Arrays`上有多个便利方法来为不同的基本类型创建适当流的原因。使用适当的终端操作可以从流创建数组。
- en: Object-Type Arrays
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象类型数组
- en: 'Creating a typical `Stream<T>` is supported by two `static` convenience methods
    on `java.util.Arrays`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 创建典型的`Stream<T>`由`java.util.Arrays`上的两个`static`便利方法支持：
- en: '`<T> Stream<T> stream(T[] array)`'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<T> Stream<T> stream(T[] array)`'
- en: '`<T> Stream<T> stream(T[] array, int startInclusive, int endExclusive)`'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<T> Stream<T> stream(T[] array, int startInclusive, int endExclusive)`'
- en: As you can see, creating a `Stream<T>` from an array is quite self-explanatory.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，从数组创建`Stream<T>`非常简单明了。
- en: 'The other way around, from `Stream<T>` to `T[]` is done by using one of these
    two terminal operations:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方式，从`Stream<T>`到`T[]`是通过使用以下两种终端操作之一来完成的：
- en: '`Object[] toArray()`'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Object[] toArray()`'
- en: '`<A> A[] toArray(IntFunction<A[]> generator)`'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<A> A[] toArray(IntFunction<A[]> generator)`'
- en: The first variant can only return an `Object[]` array regardless of the actual
    element type of the Stream due to how arrays are created by the JVM. If you need
    an array of the Stream’s elements type, you need to provide the Stream with a
    way to create an appropriate array. That’s where the second variant comes in.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种变体无论流的实际元素类型如何，都只能返回一个`Object[]`数组，这是由JVM创建数组的方式决定的。如果需要流元素类型的数组，必须为流提供一种创建适当数组的方法，这就是第二种变体的作用所在。
- en: 'The second variant requires an `IntFunction` that creates the array of the
    provided size. The most straightforward way is to use a method reference:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Warning
  id: totrans-115
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: There is no static type checking for using the created array in `toArray`. Types
    are checked at runtime when an element is stored in the allocated array, throwing
    an `ArrayStoreException` if the types aren’t compatible.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Primitive Arrays
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The three primitive Stream specializations, `IntStream`, `LongStream`, and
    `DoubleStream`, have all dedicated variants of the `static` method `Arrays.stream`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '`IntStream stream(int[] array)`'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IntStream stream(int[] array, int startInclusive, int endExclusive)`'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `LongStream` and `DoubleStream` variants only differ in the `array` type
    and the returned primitive Stream.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the element type is fixed in a primitive Stream, they only have a singular
    `toArray` method that doesn’t require an `IntFunction`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Low-Level Stream Creation
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, all Stream creation methods I’ve discussed were quite high-level, creating
    a Stream from another data source, iteration, generation, or arbitrary objects.
    They are directly available on their respective types, with as few arguments needed
    as possible. The auxiliary type `java.util.stream.StreamSupport` has also several
    low-level `static` convenience methods available for creating Streams directly
    from a Spliterator. This way, you can create a Stream representation for your
    own custom data structures.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'The following two methods accept a Spliterator to create a new Stream:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '`Stream<T> stream(Spliterator<T> spliterator, boolean parallel)`'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: The easiest way to create a sequential or parallel Stream from any source that
    is representable by a `Spliterator<T>`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '`Stream<T> stream(Supplier<? extends Spliterator<T>> supplier, int characteristics,
    boolean parallel)`'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Instead of using the Spliterator right away, the Supplier gets called once and
    only after the terminal operation of the Stream pipeline is invoked. That relays
    any possible interference with the source data structure to a smaller timeframe,
    making it safer for non-`IMMUTABLE` or non-`CONCURRENT` eager-bound Streams.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: It’s strongly recommended that the Spliterators used to create a `Stream<T>`
    are either `IMMUTABLE` or `CONCURRENT` to minimize possible interference or changes
    to the underlying data source during the traversal.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Another good option is using a *late-binding* Spliterator, meaning the elements
    aren’t fixed at the creation of the Spliterator. Instead, they’re bound on first
    use, when the Stream pipeline starts processing its elements after calling a terminal
    operation.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-133
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Low-level Stream creation methods also exist for the primitive Spliterator variants.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don’t have a `Spliterator<T>` but a `Iterator<T>`, the JDK got you covered.
    The type `java.util.Spliterators` has multiple convenience methods for creating
    Spliterators, with two methods designated for `Iterator<T>`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You can use the created `Spliterator<T>` instance in the previously discussed
    `Stream<T> stream(Spliterator<T> spliterator, boolean parallel)` method to finally
    create a `Stream<T>`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用先前讨论的 `Stream<T> stream(Spliterator<T> spliterator, boolean parallel)`
    方法中创建的创建的 `Spliterator<T>` 实例来最终创建一个 `Stream<T>`。
- en: Working with File I/O
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理文件I/O
- en: Streams aren’t only for collection-based traversal. They also provide an excellent
    way to traverse the filesystem with the help of the `java.nio.file.Files` class.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 流不仅用于基于集合的遍历。它们还提供了一个与 `java.nio.file.Files` 类一起遍历文件系统的绝佳方法。
- en: This section will look at several use cases for file I/O and Streams. Contrary
    to other Streams, I/O-related Streams must be explicitly closed by calling `Stream#close()`
    after you are finished using them. `Stream<T>` conforms to the `java.lang.AutoCloseable`
    interface, so the examples will use a `try-with-resources`-block, which will be
    explained in [“Caveats of File I/O Streams”](#_02-streams-file-io_caveats).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将讨论文件I/O和Streams的几个用例。与其他Streams不同，I/O相关的Streams必须在使用完毕后通过调用 `Stream#close()`
    显式关闭。 `Stream<T>` 符合 `java.lang.AutoCloseable` 接口，因此示例将使用 `try-with-resources`
    块进行处理，这将在 [“文件I/O流的注意事项”](#_02-streams-file-io_caveats) 中详细解释。
- en: 'All examples in this section use the files in the book’s [code repository](https://github.com/benweidig/a-functional-approach-to-java)
    as their source. The following filesystem tree represents the overall structure
    of the files used in the examples:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的所有示例都使用书籍的 [代码存储库](https://github.com/benweidig/a-functional-approach-to-java)
    中的文件作为它们的来源。以下文件系统树表示示例中使用的文件的整体结构：
- en: '[PRE9]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Reading Directory Contents
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读取目录内容
- en: 'Listing the contents of a directory can be done by calling the method `Files.list`
    to create a lazily populated `Stream<Path>` of the provided `Path`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用方法 `Files.list` 来列出目录内容，以创建所提供 `Path` 的惰性填充的 `Stream<Path>`：
- en: '[PRE10]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Its argument must be a directory, or else it will throw a `NotDirectoryException`.
    [Example 7-1](#_02-streams_list) shows how to list a directory.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 其参数必须是目录，否则将抛出 `NotDirectoryException`。[示例 7-1](#_02-streams_list) 展示了如何列出一个目录。
- en: Example 7-1\. Listing a directory
  id: totrans-147
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-1\. 列出一个目录
- en: '[PRE11]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The output lists the files of the directory `jshell` for [Chapter 4](ch04.xhtml#_02-data-structures):'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 输出列出了章节4的目录 `jshell` 中的文件：
- en: '[PRE12]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The order of retrieved content isn’t guaranteed, which I will go into more detail
    about in [“Caveats of File I/O Streams”](#_02-streams-file-io_caveats).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 检索的内容顺序不能保证，我将在 [“文件I/O流的注意事项”](#_02-streams-file-io_caveats) 中详细介绍。
- en: Depth-First Directory Traversal
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 深度优先目录遍历
- en: The two `walk` methods do, as their name suggests, “walk” the whole file tree
    from a specific starting point. The lazily populated `Stream<Path>` traverses
    *depth-first*, meaning if an element is a directory, it will be entered and traversed
    first before the next element in the current directory.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 两个 `walk` 方法如其名称所示，从特定起始点“遍历”整个文件树。惰性填充的 `Stream<Path>` 遵循*深度优先*，这意味着如果一个元素是目录，则会首先进入并遍历该目录，然后再遍历当前目录中的下一个元素。
- en: 'The difference between the two `walk` variants in `java.nio.file.Files` is
    the maximum directory depth they’re going to traverse:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.nio.file.Files` 中两个 `walk` 变体的区别在于它们将遍历的最大目录深度：'
- en: '[PRE13]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[![1](assets/1.png)](#co_working_with_streams_CO2-1)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_working_with_streams_CO2-1)'
- en: The starting point of the traversal.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历的起始点。
- en: '[![2](assets/2.png)](#co_working_with_streams_CO2-2)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_working_with_streams_CO2-2)'
- en: The maximum number of directory levels to traverse. `0` (zero) restricts the
    Stream to the starting level. The second variant without `maxDepth` has no depth
    limit.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 要遍历的最大目录级别。 `0`（零）将流限制为起始级别。第二个没有 `maxDepth` 的变体没有深度限制。
- en: '[![3](assets/3.png)](#co_working_with_streams_CO2-3)'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_working_with_streams_CO2-3)'
- en: Zero or more options on how to traverse the filesystem. So far, only `FOLLOW_LINKS`
    exists. Be aware that by following links, a possible cyclic traversal might occur.
    If the JDK detects this, it throws a `FileSystemLoopException`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 零个或多个选项用于遍历文件系统。到目前为止，只有 `FOLLOW_LINKS` 存在。请注意，通过跟随链接，可能会发生可能的循环遍历。如果JDK检测到这一点，它会抛出
    `FileSystemLoopException`。
- en: You can walk the filesystem as shown in [Example 7-2](#_02-streams_walk).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 可以按照 [示例 7-2](#_02-streams_walk) 所示的方式遍历文件系统。
- en: Example 7-2\. Walking the Filesystem
  id: totrans-163
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-2\. 遍历文件系统
- en: '[PRE14]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The traversal generates the following output:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历生成以下输出：
- en: '[PRE15]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The Stream will have at least one element, the starting point. If it’s not accessible,
    an `IOException` is thrown. As with `list`, the Stream elements encounter order
    isn’t guaranteed, which I will go into more detail in [“Caveats of File I/O Streams”](#_02-streams-file-io_caveats).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 流至少包含一个元素，即起始点。如果不可访问，则会抛出`IOException`。与`list`类似，流元素的遇见顺序不被保证，我将在[“文件I/O流的注意事项”](#_02-streams-file-io_caveats)中详细讨论这一点。
- en: Searching the Filesystem
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 搜索文件系统
- en: 'Although you can search for a particular `Path` with `walk`, you could use
    the method `find` instead. It bakes a `BiPredicate` with access to the `BasicFileAttribute`
    of the current element directly into the Stream creation, making the Stream more
    focused on your task’s requirements:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管可以使用`walk`搜索特定的`Path`，但也可以使用`find`方法。它将一个`BiPredicate`与当前元素的`BasicFileAttribute`直接集成到流创建中，使流更专注于您任务的需求：
- en: '[PRE16]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[![1](assets/1.png)](#co_working_with_streams_CO3-1)'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_working_with_streams_CO3-1)'
- en: The starting point of the search.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索的起始点。
- en: '[![2](assets/2.png)](#co_working_with_streams_CO3-2)'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_working_with_streams_CO3-2)'
- en: The maximum number of directory levels to traverse. `0` (zero) restricts it
    to the starting level. Unlike `Files.walk` no method variant without `maxDepth`
    exists.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历的最大目录级别。`0`（零）限制到起始级别。与`Files.walk`不同，不存在无需`maxDepth`的方法变体。
- en: '[![3](assets/3.png)](#co_working_with_streams_CO3-3)'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_working_with_streams_CO3-3)'
- en: Criteria for including a `Path` in the Stream.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 包含在流中的`Path`的条件。
- en: '[![4](assets/4.png)](#co_working_with_streams_CO3-4)'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_working_with_streams_CO3-4)'
- en: Zero or more options on how to traverse the filesystem. So far, only `FOLLOW_LINKS`
    exists. Be aware that by following links, a possible cyclic traversal might occur.
    If the JDK detects this, it throws a `FileSystemLoopException`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统遍历的零个或多个选项。目前只有`FOLLOW_LINKS`存在。请注意，通过跟踪链接可能会发生可能的循环遍历。如果JDK检测到这一点，它会抛出`FileSystemLoopException`。
- en: With it, [Example 7-2](#_02-streams_walk) can be implemented without needing
    to map the `Path` to a `File`, as shown in [Example 7-3](#_02-streams_find).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 使用它，可以实现[示例 7-2](#_02-streams_walk)而无需将`Path`映射到`File`，如[示例 7-3](#_02-streams_find)所示。
- en: Example 7-3\. Finding Files
  id: totrans-180
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-3\. 查找文件
- en: '[PRE17]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The output is equivalent to using `walk`, and the same assumptions — *depth-first*
    and non-guaranteed encounter order — apply to `find`, too. The real difference
    is the access to the `BasicFileAttributes` of the current element, which may affect
    performance. If you need to filter or match by file attributes, using `find` will
    save you reading the file attributes explicitly from the `Path` element, which
    could be slightly more performant. However, if you only require the `Path` element
    and no access to its file attributes, the `walk` method is just as good an alternative.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 输出与使用`walk`相当，同样的假设——*深度优先*和非保证遇见顺序——也适用于`find`。真正的区别在于对当前元素的`BasicFileAttributes`的访问，这可能影响性能。如果需要根据文件属性进行过滤或匹配，使用`find`将节省从`Path`元素显式读取文件属性的操作，这可能会略微提高性能。然而，如果只需要`Path`元素而不需要访问其文件属性，则`walk`方法同样是一个很好的选择。
- en: Reading Files Line-By-Line
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逐行读取文件
- en: 'The common task of reading a file and processing it line-by-line is a breeze
    with Streams, which provides the `lines` method. There are two variants, depending
    on the file’s `Charset`:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Streams轻松处理文件逐行读取的常见任务，该任务提供了`lines`方法。根据文件的`Charset`，有两种变体：
- en: '[PRE18]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[![1](assets/1.png)](#co_working_with_streams_CO4-1)'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_working_with_streams_CO4-1)'
- en: '`Path` pointing the file to read.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 指向要读取的文件的`Path`。
- en: '[![2](assets/2.png)](#co_working_with_streams_CO4-2)'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_working_with_streams_CO4-2)'
- en: The charset of the file. The second variant defaults to `StandardCharsets.UTF_8`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 文件的字符集。第二个变体默认为`StandardCharsets.UTF_8`。
- en: Tip
  id: totrans-190
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 小贴士
- en: Even though you can use any `Charset` you want, it will make a performance difference
    in parallel processing. The `lines` method is optimized for `UTF_8`, `US_ASCII`,
    and `ISO_8859_1`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你可以使用任何想要的`Charset`，但在并行处理中会有性能差异。`lines`方法经过优化，适用于`UTF_8`、`US_ASCII`和`ISO_8859_1`。
- en: Let’s look at a simple example of counting the words in *War and Peace* by Tolstoy,
    as seen in [Example 7-4](#_01-parallel-concurrent-async_war-and-peace).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个简单的例子，统计托尔斯泰《战争与和平》中的单词数，如[示例 7-4](#_01-parallel-concurrent-async_war-and-peace)所示。
- en: Example 7-4\. Counting words in “War and Peace”
  id: totrans-193
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-4\. 统计《战争与和平》中的单词数
- en: '[PRE19]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[![1](assets/1.png)](#co_working_with_streams_CO5-1)'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_working_with_streams_CO5-1)'
- en: The plain text version of *War and Peace* from Project Gutenberg^([4](ch07.xhtml#idm45115233771312))
    is used, so no formatting might get in the way of counting words.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Project Gutenberg的*《战争与和平》*普通文本版本^([4](ch07.xhtml#idm45115233771312))，因此没有格式可能会影响单词计数。
- en: '[![2](assets/2.png)](#co_working_with_streams_CO5-2)'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_working_with_streams_CO5-2)'
- en: The regular expressions are pre-compiled to prevent recompilation for each element.
    Such optimizations are essential because of the overhead of creating a `Pattern`
    for each element and `map` operation will quickly compound and affect the overall
    performance.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式预编译以防止为每个元素重新编译。这种优化非常重要，因为为每个元素和`map`操作创建`Pattern`会迅速累积并影响整体性能。
- en: '[![3](assets/3.png)](#co_working_with_streams_CO5-3)'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_working_with_streams_CO5-3)'
- en: The `lines` call returns a `Stream<String>` with the file’s lines as elements.
    The `try-with-resources` block is required because the I/O operation must be closed
    explicitly, which you’ll learn more about in [“Caveats of File I/O Streams”](#_02-streams-file-io_caveats).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`lines`调用返回文件的行作为元素的`Stream<String>`。`try-with-resources`块是必需的，因为I/O操作必须显式关闭，您将在[“文件I/O流的注意事项”](#_02-streams-file-io_caveats)中了解更多。'
- en: '[![4](assets/4.png)](#co_working_with_streams_CO5-4)'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_working_with_streams_CO5-4)'
- en: The punctuation needs to be removed, or identical words directly next to any
    punctuation will be counted as different words.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 需要移除标点符号，否则直接跟在标点符号旁边的相同单词将被计为不同的单词。
- en: '[![5](assets/5.png)](#co_working_with_streams_CO5-5)'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_working_with_streams_CO5-5)'
- en: The cleaned line is now split on whitespace characters which creates a `Stream<String[]>`.
    To actually count the words, the `flatMap` operation will flatten the Stream to
    a `Stream<String>`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在清理后的行根据空白字符分割，从而创建了一个`Stream<String[]>`。为了实际计数单词，`flatMap`操作将流扁平化为`Stream<String>`。
- en: '[![6](assets/6.png)](#co_working_with_streams_CO5-6)'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_working_with_streams_CO5-6)'
- en: The “word” matcher is an additional cleanup and selection step to only count
    the actual words.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: “word”匹配器是一个额外的清理和选择步骤，仅计数实际的单词。
- en: '[![7](assets/7.png)](#co_working_with_streams_CO5-7)'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_working_with_streams_CO5-7)'
- en: Mapping the element to lowercase ensures differently-cased words are counted
    as one.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 将元素映射为小写确保不同大小写的单词被视为一个单词。
- en: '[![8](assets/8.png)](#co_working_with_streams_CO5-8)'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '[![8](assets/8.png)](#co_working_with_streams_CO5-8)'
- en: The terminal operation creates a `Map<String, Integer>` with the word as its
    key and the occurrence count as its value.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 终端操作创建了一个`Map<String, Integer>`，以单词作为键，出现次数作为值。
- en: The Stream pipeline does what it was set out to do, taking over the task of
    reading the file and providing you with its content line-by-line so that you can
    concentrate your code on the processing steps.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 流管道完成了既定任务，接管文件读取任务并逐行提供内容，使您可以集中精力处理代码的处理步骤。
- en: We will revisit this particular example in [Chapter 8](ch08.xhtml#_01-parallel-streams)
    to take another look at how such a common task can be improved immensely by using
    a parallel Stream.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第8章](ch08.xhtml#_01-parallel-streams)中重新讨论此特定示例，再次查看如何通过使用并行流显著改进这样一个常见任务。
- en: Caveats of File I/O Streams
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件I/O流的注意事项
- en: 'Working with Streams and file I/O is pretty straightforward. However, there
    are three unusual aspects I mentioned before. They aren’t a big deal and don’t
    diminish the usability or usefulness of using Stream-based file I/O, although
    you need to be aware of them:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 使用流和文件I/O非常简单。然而，正如我之前提到的，有三个不寻常的方面。它们并不重要，不会减少使用基于流的文件I/O的可用性或有用性，尽管您需要注意它们：
- en: Closing the Streams is required
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要关闭流
- en: Directory contents are weakly consistent
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目录内容是弱一致的
- en: Non-guaranteed element order
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元素顺序不保证
- en: These aspects stem from dealing with I/O in general and are found in most I/O-related
    code, not only Stream pipelines.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方面源于一般的I/O处理，并且在大多数与I/O相关的代码中都能找到，不仅限于流管道。
- en: Explicit Closing of the Stream
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 明确关闭流
- en: Dealing with resources in Java, like file I/O, typically requires you to close
    them after use. An unclosed resource can *leak*, meaning the garbage collector
    can’t reclaim its memory after the resource is no longer required or used. The
    same is true for dealing with I/O with Streams. That’s why you need to close I/O-based
    Streams explicitly, at least compared to non-I/O Streams.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中处理资源，如文件I/O，通常需要在使用后关闭它们。未关闭的资源可能会*泄漏*，这意味着垃圾收集器在资源不再需要或使用后无法回收其内存。处理流的I/O也是如此。这就是为什么你需要显式关闭基于I/O的流，至少与非I/O流相比如此。
- en: 'The `Stream<T>` type extends `java.io.AutoClosable` through `BaseStream`, so
    the most straightforward way to close it is to use a `try-with-resources` block,
    as seen throughout the “Working with File I/O” section and in the following code:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stream<T>`类型通过`BaseStream`扩展了`java.io.AutoClosable`，因此关闭它的最简单方法是使用`try-with-resources`块，正如在“使用文件I/O”部分和下面的代码中所见：'
- en: '[PRE20]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: All Stream-related methods on `java.nio.file.Files` throw an `IOException` according
    to their signatures, so you need to handle that exception in some form. Combining
    a `try-with-resources`-block with an appropriate `catch`-block can solve both
    requirements in one fell swoop.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 所有与`java.nio.file.Files`上的流相关的方法根据它们的签名都会抛出`IOException`，因此你需要以某种形式处理该异常。结合合适的`try-with-resources`块和适当的`catch`块可以一举解决这两个要求。
- en: Weakly Consistent Directory Content
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 弱一致性的目录内容
- en: The `list`, `walk`, and `find` methods on `java.nio.file.Files` are *weakly
    consistent* and *lazily* populated. That means the actual directory content isn’t
    scanned once on Stream creation to have a fixed snapshot during traversal. Any
    updates to the filesystem may or may not be reflected after the `Stream<Path>`
    is created or traversed.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.nio.file.Files`上的`list`、`walk`和`find`方法是*弱一致性*并且是*惰性*填充的。这意味着在流创建时并不会一次性扫描实际的目录内容以获得遍历期间的固定快照。在创建或遍历`Stream<Path>`后，文件系统的任何更新可能会或可能不会反映出来。'
- en: The reasoning behind this constraint is quite most likely due to performance
    and optimization considerations. Stream pipelines are supposed to be lazy sequential
    pipelines with no distinction of their elements. A fixed snapshot of the file
    tree would require gathering all possible elements on Stream creation, not lazily
    on the actual Stream processing triggered by a terminal operation.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这种约束背后的推理很可能是出于性能和优化考虑。流管道应该是惰性顺序管道，没有区分它们的元素。文件树的固定快照将要求在流创建时收集所有可能的元素，而不是在由终端操作触发的实际流处理时进行惰性处理。
- en: Non-guaranteed Element Order
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 非保证元素顺序
- en: The lazy nature of Streams creates another aspect of file I/O Streams you might
    not expect. The encounter order of file I/O Streams isn’t guaranteed to be in
    natural order — in this case, alphabetically —  which is why you might need an
    additional `sorted` intermediate operation to ensure consistent element order.
    That’s because the Stream is populated by the filesystem, which isn’t guaranteed
    to return its files and directories in an ordered fashion.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 流的惰性特性带来了文件I/O流的另一个方面，这可能是你不会预料到的。文件I/O流的遭遇顺序不能保证按照自然顺序（例如字母顺序）——因此，你可能需要额外的`sorted`中间操作来确保一致的元素顺序。这是因为流是由文件系统填充的，而文件系统不保证以有序的方式返回其文件和目录。
- en: Dealing with Date and Time
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理日期和时间
- en: Dealing with dates is always a challenge with many edge cases. Thankfully, a
    new *Date & Time API*⁠^([5](ch07.xhtml#idm45115233615264)) was introduced in Java
    8. Its immutable nature fits nicely in any functional code and provides some Stream-related
    methods, too.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 处理日期始终是具有许多边缘情况的挑战。幸运的是，Java 8引入了一个*日期和时间API*⁠^([5](ch07.xhtml#idm45115233615264))。其不可变性很好地适合于任何函数式代码，并且也提供了一些与流相关的方法。
- en: Querying Temporal Types
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询时间类型
- en: 'The new Date and Time API provides a flexible and functional query interface
    for arbitrary properties. Like most Stream operations, you inject the actually
    required logic to do your task into the method via its arguments, making the methods
    themselves more general scaffolds with greater versatility:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 新的日期和时间API为任意属性提供了灵活和功能强大的查询接口。像大多数流操作一样，通过其参数将实际需要的逻辑注入到方法中，使方法本身成为具有更大通用性的更一般的支架：
- en: '[PRE21]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The generic signature allows querying for any type, making it quite flexible:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 通用签名允许查询任何类型，使其非常灵活：
- en: '[PRE22]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The utility class `java.time.temporal.TemporalQueries` provides pre-defined
    queries, shown in [Table 7-3](#_02-streams-jsr310_temporalquery), to eliminate
    the need to create common queries yourself.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Table 7-3\. Pre-defined `TemporalQuery<T>` in `java.time.temporal.TemporalQueries`
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '| `static` method | Return Type |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
- en: '| `chronology()` | `Chronology` |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
- en: '| `offset()` | `ZoneOffset` |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
- en: '| `localDate()` | `LocalDate` |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
- en: '| `localTime()` | `LocalTime` |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
- en: '| `precision()` | `TemporalUnit` |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
- en: '| `zoneId()` | `ZoneId` |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
- en: '| `zone()` | `ZoneId` |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
- en: Obviously, not all Time API types support each query type. For example, you
    can’t get a `ZoneId`/`ZoneOffset` from a `Local…​` type. Each method is documented^([6](ch07.xhtml#idm45115233447600))
    quite well with their supported types and intended use cases.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: LocalDate-Range Streams
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Java 9 introduced Stream capabilities for a single JSR 310 type, `java.time.LocalDate`,
    to create a consecutive range of `LocalDate` elements. You don’t have to worry
    about all the intricacies and edge cases of different calendar systems and how
    the date calculations are actually performed. The date and time API will handle
    them for you by giving you a consistent and easy-to-use abstraction.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: 'Two `LocalDate` instance methods create an ordered and consecutive Stream:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '`Stream<LocalDate> datesUntil(LocalDate endExclusive)`'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Stream<LocalDate> datesUntil(LocalDate endExclusive, Period step)`'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first variant is equivalent to using `Period.ofDays(1)`. Their implementation
    won’t overflow, meaning that any element plus `step` *must* be before `endExclusive`.
    The direction of the dates isn’t *future-only*, too. If `endExclusive` is in the
    past, you must provide a negative `step` to create a Stream going toward the past.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: Measuring Stream Performance with JMH
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout the book, I mention how Java’s functional techniques and tools, like
    Streams, incur a certain overhead compared to a *traditional* approach and that
    you have to consider it. This is why measuring the performance of Stream pipelines
    with benchmarks can be crucial. Streams aren’t an easy target for benchmarking
    because they are complex pipelines of multiple operations with many optimizations
    behind the scenes that depend on their data and operations.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: The JVM and its *just-in-time* compiler can be tricky to benchmark and determine
    the actual performance. That’s where the *Java Micro-Benchmarking Harness* comes
    in to help.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: The [JMH](https://openjdk.java.net/projects/code-tools/jmh/) takes care of JVM
    warm-up, iterations, and code-optimizations that might dilute the results, making
    them more reliable and, therefore, a better baseline for evaluation. It’s the
    *de-facto* standard for benchmarking and got included in the JDK with version
    12^([7](ch07.xhtml#idm45115233431088)).
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Plugins are available for IDEs and build systems like [Gradle](https://github.com/melix/jmh-gradle-plugin),
    [IntelliJ](https://github.com/artyushov/idea-jmh-plugin), [Jenkins](https://github.com/brianfromoregon/jmh-plugin),
    or [TeamCity](https://github.com/presidentio/teamcity-plugin-jmh).
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 可用于 IDE 和构建系统的插件，例如 [Gradle](https://github.com/melix/jmh-gradle-plugin)、[IntelliJ](https://github.com/artyushov/idea-jmh-plugin)、[Jenkins](https://github.com/brianfromoregon/jmh-plugin)
    或 [TeamCity](https://github.com/presidentio/teamcity-plugin-jmh)。
- en: The [JMH GitHub repository sample directory](https://github.com/openjdk/jmh/blob/master/jmh-samples/src/main/java/org/openjdk/jmh/samples/)
    has a myriad of well-documented benchmarks explaining the intricacies of its usage.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '[JMH GitHub 仓库的示例目录](https://github.com/openjdk/jmh/blob/master/jmh-samples/src/main/java/org/openjdk/jmh/samples/)有很多文档完整的基准测试，解释了其使用的复杂性。'
- en: I won’t talk further about how to benchmark Streams or lambdas in general because
    it is out of scope for this chapter and it could easily consume the space of an
    entire book. In fact, I recommend you check out *Optimizing Java* by Benjamin
    J Evans, James Gough, and Chris Newland^([8](ch07.xhtml#idm45115233423152)) and
    *Java Performance* by Scott Oaks^([9](ch07.xhtml#idm45115233422032)) to learn
    more about benchmarking and how to measure performance in Java.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会进一步讨论如何在一般情况下对流或 lambda 进行基准测试，因为这超出了本章的范围，而且很容易占用整本书的空间。事实上，我建议你查看**《Java
    优化》（Optimizing Java）**，作者是**本杰明·J·埃文斯**（Benjamin J Evans）、**詹姆斯·高夫**（James Gough）、**克里斯·纽兰德**（Chris
    Newland）^([8](ch07.xhtml#idm45115233423152))，以及**《Java 性能》（Java Performance）**，作者是**斯科特·奥克斯**（Scott
    Oaks）^([9](ch07.xhtml#idm45115233422032))，以了解更多关于基准测试和如何在 Java 中测量性能的信息。
- en: More about Collectors
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多关于收集器的信息
- en: '[Chapter 6](ch06.xhtml#_02-data-processing) introduced Collectors and the corresponding
    terminal operation `collect` as a powerful tool to aggregate a Stream pipeline’s
    elements into new data structures. The utility type `java.util.stream.Collectors`
    has a plethora of `static` factory methods to create Collectors for almost any
    task, from simple aggregation into a new `Collection` type, or even more complex,
    multi-step aggregation pipelines. Such more complex Collectors are done with the
    concept of *downstream Collectors*.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 6 章](ch06.xhtml#_02-data-processing)介绍了收集器和相应的终端操作 `collect`，作为将流水线的元素聚合到新数据结构中的强大工具。实用类型
    `java.util.stream.Collectors` 有大量的 `static` 工厂方法可以为几乎任何任务创建收集器，从简单的聚合到新的 `Collection`
    类型，甚至更复杂的多步聚合流水线。这种更复杂的收集器是通过*下游收集器*的概念完成的。'
- en: 'The general idea of Collectors is simple: collect elements into a new data
    structure. That’s a pretty straightforward operation if you want a Collection-based
    type like `List<T>` or `Set<T>`. In the case of a `Map<K, V>`, however, you usually
    need complex logic to get a correctly formed data structure that fulfills your
    goal.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 收集器的一般思想很简单：将元素收集到一个新的数据结构中。如果你想要一个基于集合的类型，比如 `List<T>` 或 `Set<T>`，这是一个非常直接的操作。然而，在
    `Map<K, V>` 的情况下，通常需要复杂的逻辑来获取一个正确形成的数据结构，以满足你的目标。
- en: Collecting a sequence of elements to a key-value-based data structure like `Map<K,
    V>` can be done in various ways, each with its own challenges. For example, even
    with a simple key-value mapping where each key has only one value, there’s already
    the problem of key collisions to be dealt with. But if you want to further transform
    the Map’s value-part, like grouping, reducing, or partitioning, you need a way
    to manipulate the collected values. That’s where downstream Collectors come into
    play.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 将一系列元素收集到基于键值的数据结构（如 `Map<K, V>`）可以通过多种方式完成，每种方式都有其挑战。例如，即使是简单的键值映射，每个键只有一个值，也存在处理键冲突的问题。但是，如果你想进一步转换
    Map 的值部分，比如分组、缩减或分区，你需要一种方法来操作已收集的值。这就是下游收集器发挥作用的地方。
- en: Downstream Collectors
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 下游收集器
- en: Some of the pre-defined Collectors available via `java.util.stream.Collectors`
    factory methods accept an additional Collector to manipulate *downstream* elements.
    Basically, this means that after the primary Collector has done its job, the downstream
    Collector makes further changes to the collected values. It’s almost like a secondary
    Stream pipeline working on the previously collected elements.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util.stream.Collectors` 工厂方法提供的一些预定义收集器可以接受一个额外的收集器来操作*下游*元素。基本上，这意味着在主要收集器完成其工作之后，下游收集器对收集的值进行进一步的更改。这几乎就像是在之前收集的元素上工作的二级流水线。'
- en: 'Typical tasks for downstream Collectors include:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 下游收集器的典型任务包括：
- en: Transforming
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换
- en: Reducing
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缩减
- en: Flattening
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扁平化
- en: Filtering
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过滤
- en: Composite Collector operations
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合收集器操作
- en: 'All examples of this section will use the following `User` Record and `users`
    data source:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的所有示例将使用以下 `User` 记录和 `users` 数据源：
- en: '[PRE23]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Transforming Elements
  id: totrans-275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 转换元素
- en: Grouping Stream elements into simple key-value Maps is easy with the `Collectors.groupingBy`
    methods. The value part of a key-value mapping, though, might not be represented
    in the form you need and require additional transformation.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Collectors.groupingBy` 方法将流元素分组到简单的键值映射中非常容易。然而，键值映射的值部分可能不是您需要的形式，可能需要额外的转换。
- en: 'For example, grouping a `Stream<User>` by its `group` creates a `Map<String,
    List<User>>`:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，通过其 `group` 对 `Stream<User>` 进行分组将创建一个 `Map<String, List<User>>`：
- en: '[PRE24]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Simple enough.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 简单明了。
- en: 'What if you don’t want the whole `User` and only its `id` in its place? You
    can’t use an intermediate `map` operation to transform the elements before collecting
    them because you wouldn’t have access to the `User` anymore to actually group
    them. Instead, you can use a downstream Collector to transform the collected elements.
    That’s why there are multiple `groupingBy` methods available, like the one we’re
    going to use in this section:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不希望整个 `User` 而只是其 `id` 处于其中位置，该怎么办？您不能使用中间 `map` 操作在收集之前转换元素，因为您不再能真正访问 `User`
    来实际分组它们。而是可以使用下游收集器来转换已收集的元素。这就是为什么有多个可用的 `groupingBy` 方法的原因，就像我们将在本节中使用的方法一样：
- en: '[PRE25]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Although the different generic types in this method signature might look intimidating,
    don’t fret! Let’s break the signature down into its parts to get a better understanding
    of what’s happening.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管此方法签名中的不同通用类型可能看起来令人生畏，但不要担心！让我们分解签名以更好地理解发生的情况。
- en: There are four types involved are listed in [Table 7-4](#_02-streams-downstream_generic-types-groupingBy).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 列出了涉及的四种类型在 [Table 7-4](#_02-streams-downstream_generic-types-groupingBy)。
- en: Table 7-4\. Generic types of `groupingBy`
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7-4\. `groupingBy` 的通用类型
- en: '| Generic Type | Used for |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| 通用类型 | 用于 |'
- en: '| --- | --- |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `T` | The Stream’s elements type before collecting. |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| `T` | 收集之前流的元素类型。 |'
- en: '| `K` | The `Map` result’s key type. |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| `K` | `Map` 结果的键类型。 |'
- en: '| `D` | The type of the result `Map` value part that is created by the downstream
    Collector. |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| `D` | 由下游收集器创建的结果 `Map` 值部分的类型。 |'
- en: '| `A` | The accumulator type of the downstream Collector. |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| `A` | 下游收集器的累加器类型。 |'
- en: As you can see, each type of the method-signature represents a part of the overall
    process. The `classifier` creates the keys, mapping the elements of type `T` to
    the key type `K`. The downstream Collector aggregates the elements of type `T`
    to the new result type `D`. The overall result will therefore be a `Map<K, D>`.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，每种方法签名的类型表示整个过程的一部分。`classifier` 创建键，将类型为 `T` 的元素映射到键类型 `K`。下游收集器将类型为 `T`
    的元素聚合到新的结果类型 `D` 中。因此，总体结果将是一个 `Map<K, D>`。
- en: Tip
  id: totrans-292
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Java’s type inference will usually do the heavy lifting of matching the correct
    types for you, so you don’t have to think much about the actual generic signatures
    if you only want to use such complex generic methods and not write them yourselves.
    If a type mismatch occurs and the compiler can’t deduct the types automatically,
    try to refactor the operation logic into dedicated variables with the help of
    your IDE to see the inferred types. It’s easier to tweak smaller blocks of code
    than an entire Stream pipeline at once.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: Java的类型推断通常会为您匹配正确的类型，因此如果您只想使用这些复杂的通用方法而不是自己编写它们，您不必太在意实际的通用签名。如果发生类型不匹配并且编译器无法自动推导类型，请尝试使用IDE的帮助将操作逻辑重构为专用变量，以查看推断的类型。与一次性调整整个流水线相比，调整较小的代码块要容易得多。
- en: In essence, each Collector accepting an additional downstream Collector consists
    of the original logic — in this case, the key-mapper — and a downstream Collector,
    affecting the values mapped to a key. You can think of the downstream collecting
    process as working like another Stream that’s collected. Instead of all elements,
    though, it only encounters the values associated with the key by the primary Collector.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，每个接受额外下游收集器的收集器都包含原始逻辑 — 在本例中是键映射器 — 和下游收集器，影响映射到键的值。您可以将下游收集过程视为另一个被收集的流。不过，它只遇到主收集器关联的键的值。
- en: Let’s get back to the lookup Map for `User` groups. The goal is to create a
    `Map<String, Set<UUID>>`, mapping the `User` groups to a list of distinct `id`
    instances. The best way to create a downstream Collector is to think about the
    particular steps required to achieve your goal and which factory methods of `java.util.stream.Collectors`
    could achieve them.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到查找`User`组的查找映射。目标是创建一个`Map<String, Set<UUID>>`，将`User`组映射到一组不同的`id`实例。创建下游收集器的最佳方法是考虑实现目标所需的具体步骤，以及`java.util.stream.Collectors`的哪些工厂方法可以实现这些步骤。
- en: First, you want the `id` of a `User` element, which is a mapping operation.
    The method `Collector<T, ?, R> mapping(Function<? super T, ? extends U> mapper,
    Collector<? super U, A, R> downstream)` creates a Collector that maps the collected
    elements before passing them down to another Collector. The reasoning behind requiring
    another downstream Collector is simple; the mapping Collector’s sole purpose is,
    you might have guessed, *mapping* the elements. The actual collection of mapped
    elements is outside its scope and therefore delegated to the downstream Collectors.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要`User`元素的`id`，这是一个映射操作。方法`Collector<T, ?, R> mapping(Function<? super
    T, ? extends U> mapper, Collector<? super U, A, R> downstream)`创建一个收集器，将收集的元素映射后传递给另一个收集器。需要另一个下游收集器的原因很简单；映射收集器的唯一目的是，您可能已经猜到的，*映射*元素。映射后的元素的实际收集超出了它的范围，因此委托给下游收集器。
- en: Second, you want to collect the mapped elements into a `Set`, which can be done
    by `Collectors.toSet()`.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，您希望将映射后的元素收集到一个`Set`中，可以通过`Collectors.toSet()`完成。
- en: 'By writing the Collectors separately, their intent and hierarchy become more
    visible:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 将收集器单独编写，可以使它们的意图和层次结构更加可见：
- en: '[PRE26]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'As I said before, you can usually let the compiler infer the types and use
    the `Collectors` factory methods directly. If you import the class statically,
    you can even forgo the repetitive `Collectors.` prefix. Combining all the Collectors
    and using them in the Stream pipeline leads to a straightforward collection pipeline:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前所说，通常可以让编译器推断类型并直接使用`Collectors`工厂方法。如果静态导入该类，甚至可以省略重复的`Collectors.`前缀。将所有收集器组合并在流管道中使用会导致简单直接的收集管道：
- en: '[PRE27]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The result type is inferable by the compiler, too. Still, I prefer to explicitly
    state it to communicate better what kind of type is returned by the Stream pipeline.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 结果类型也可以由编译器推断。尽管如此，我更喜欢显式声明，以便更好地传达由流管道返回的类型。
- en: An alternative approach is keeping the primary downstream Collector as a variable
    to keep the `collect` call simpler. The downside of this is the necessity to help
    the compiler infer the correct types if it’s not obvious, like in the case of
    using a lambda expression instead of a method reference.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是将主要的下游收集器保持为变量，以使`collect`调用更简单。这样做的缺点是，在使用 lambda 表达式而不是方法引用的情况下，必须帮助编译器推断出正确的类型。
- en: '[PRE28]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[![1](assets/1.png)](#co_working_with_streams_CO6-1)'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_working_with_streams_CO6-1)'
- en: The method reference tells the compiler which type the Stream’s elements are,
    so the downstream Collector knows it, too.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 方法引用告诉编译器流的元素类型，因此下游收集器也知道它。
- en: '[![2](assets/2.png)](#co_working_with_streams_CO6-2)'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_working_with_streams_CO6-2)'
- en: The lambda variant of `mapper` needs to know the type to work with. You can
    either provide an explicit type to the lambda argument or replace `var` with the
    more complicated generic `Collector<T, A , R>` signature.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '`mapper`的lambda变体需要知道要处理的类型。您可以为lambda参数提供显式类型，也可以将`var`替换为更复杂的泛型`Collector<T,
    A , R>`签名。'
- en: '[![3](assets/3.png)](#co_working_with_streams_CO6-3)'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_working_with_streams_CO6-3)'
- en: The `collect` call is still expressive thanks to the variable name. If certain
    aggregation operations are commonly used, you should consider refactoring them
    into an auxiliary type with factory methods, similar to `java.util.stream.Collectors`.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 由于变量名的存在，`collect`调用仍然很表达力。如果某些聚合操作经常使用，应考虑将它们重构为带有工厂方法的辅助类型，类似于`java.util.stream.Collectors`。
- en: Reducing Elements
  id: totrans-311
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 减少元素
- en: 'Sometimes, a reduction operation is needed instead of an aggregation. The general
    approach to designing a reducing downstream Collector is identical to the previous
    section: define your overall goal, dissect it into the necessary steps, and finally,
    create the downstream Collector.'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 有时需要减少操作而不是聚合操作。设计减少的下游收集器的一般方法与前一节相同：定义您的总体目标，分解成必要的步骤，最后创建下游收集器。
- en: For this example, instead of creating a lookup Map for `id` by `group`, let’s
    count the `logEntries` per `User`.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，不要为`group`按`id`创建查找 Map，让我们统计每个`User`的`logEntries`。
- en: The overall goal is to count the log entries per `User` element. The required
    steps are getting the log count of a `User` and summing them up to the final tally.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 总体目标是计算每个`User`元素的日志条目数。所需步骤是获取`User`的日志计数并将它们求和到最终的总数。
- en: 'You could use the `Collectors.mapping` factory method with another downstream
    Collector to achieve the goal:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`Collectors.mapping`工厂方法与另一个下游 Collector 来实现这个目标：
- en: '[PRE29]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Instead of requiring a mapping and reducing downstream Collector in tandem,
    you could use one of the other `Collector.reduce` variants which includes a `mapper`:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 与要求映射和减少下游 Collector 齐头并进不同，您可以使用其他`Collector.reduce`变体之一，其中包括一个`mapper`：
- en: '[PRE30]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This `reduce` variant needs, in addition to a seed value (`identity`) and the
    reduction operation (`op`), a `mapper` to transform the `User` elements into the
    desired value:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 这种`reduce`变体除了一个种子值（`identity`）和归约操作（`op`）外，还需要一个`mapper`来将`User`元素转换为所需的值：
- en: '[PRE31]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Like the `reduce` intermediate operation, using a reducing Collector for downstream
    operations is an incredibly flexible tool, being able to combine multiple steps
    into a single operation. Which method to choose, multi-downstream Collectors or
    single reduction, depends on personal preferences and the overall complexity of
    the collection process. If you only need to sum up numbers, though, the `java.util.stream.Collectors`
    type also gives you more specialized variants:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 像`reduce`中间操作一样，使用一个减少的 Collector 用于下游操作是一种非常灵活的工具，能够将多个步骤合并为单个操作。选择方法，是使用多个下游
    Collectors 还是单一的归约，取决于个人偏好和收集过程的整体复杂性。然而，如果你只需要对数字求和，`java.util.stream.Collectors`类型还提供了更专门的变体：
- en: '[PRE32]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `summing` Collector is available for the usual primitive types (`int`, `long`,
    `float`). Besides summing up numbers, you can calculate averages (prefixed with
    `averaging`) or simply count elements with `Collectors.counting()`.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '`summing` Collector 可用于通常的原始类型（`int`、`long`、`float`）。除了对数字求和外，您还可以计算平均值（前缀为`averaging`）或仅计数元素使用`Collectors.counting()`。'
- en: Flattening Collections
  id: totrans-324
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 展开集合
- en: Dealing with Collection-based elements in Streams usually requires a `flatMap`
    intermediate operation to “flatten” the Collection back into discrete elements
    to work with further down the pipeline, or you’ll end up with nested Collections
    like `List<List<String>>`. The same is true for the collecting process of a Stream.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在流中处理基于集合的元素通常需要一个`flatMap`中间操作将集合“展平”，以便将其返回到离散元素中以进一步处理管道，否则您将得到像`List<List<String>>`这样的嵌套集合。对流的收集过程也是如此。
- en: 'Grouping all `logEntries` by their `group` would result in a `Map<String, List<List<String>>>`,
    which most likely won’t be what you want. Java 9 added a new pre-defined Collector
    with built-in flattening capabilities:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 通过它们的`group`将所有`logEntries`分组将导致一个`Map<String, List<List<String>>>`，这很可能不是你想要的。Java
    9 添加了一个具有内置展平功能的新预定义 Collector：
- en: '[PRE33]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Like the other added Collector, `Collectors.filtering(…​)`, which I discussed
    in [“Filtering Elements”](#_02-streams_collecting-streams_filtering), it doesn’t
    provide any advantages over an explicit `flatMap` intermediate operation if used
    as the sole Collector. But, used in a multi-level reduction, like `groupingBy`
    or `partitionBy`, it gives you access to the original Stream element *and* allows
    for flattening the collected elements:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 就像其他添加的 Collector，`Collectors.filtering(…​)`，我在[“过滤元素”](#_02-streams_collecting-streams_filtering)中讨论过，如果作为唯一的
    Collector 使用，与显式的`flatMap`中间操作没有任何优势。但是，用于多级减少，如`groupingBy`或`partitionBy`，它让您可以访问原始流元素*并*允许展平收集的元素：
- en: '[PRE34]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Like with the transforming and reducing Collectors, you will quickly get the
    hang of when to use a flattening downstream Collector. If the result type of the
    Stream pipeline doesn’t match your expectations, you most likely need a downstream
    Collector to remedy the situation, either by using `Collectors.mapping` or `Collectors.flatMapping`.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 与转换和减少 Collectors 一样，当需要使用展平下游 Collector 时，您很快就会掌握它。如果流管道的结果类型不符合您的预期，您很可能需要一个下游
    Collector 来解决问题，可以通过使用`Collectors.mapping`或`Collectors.flatMapping`。
- en: Filtering Elements
  id: totrans-331
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 过滤元素
- en: 'Filtering Stream elements is an essential part of almost any Stream pipeline,
    done with the help of the intermediate `filter` operation. Java 9 added a new
    pre-defined Collector with built-in filtering capabilities, moving the step of
    filtering elements directly before the accumulation process:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'On its own, it’s no different from an intermediate `filter` operation. As a
    downstream Collector, though, its behavior is quite different to `filter`, easily
    seen when grouping elements:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'You might expect an equivalent result, but the order of operations leads to
    different results:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: Intermediate filter first, grouping second
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: Using an intermediate `filter` operation removes any undesired element before
    any collection occurs. Therefore, no groups of users that haven’t logged in today
    are included in the resulting `Map`, as illustrated in [Figure 7-1](#_02-streams_collectors_downstream-filter-first-grouping-second).
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '![Grouping elements with filter first, grouping second](assets/afaj_0701.png)'
  id: totrans-339
  prefs: []
  type: TYPE_IMG
- en: Figure 7-1\. Grouping elements with “filter first, grouping second”
  id: totrans-340
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Group first, filter downstream
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: Without an intermediate `filter` operation, the `groupingBy` Collector will
    encounter all `User` elements, regardless of their last login date. The downstream
    Collector — `Collectors.filtering` — is responsible for filtering the elements,
    so the returned `Map` still includes all user groups, regardless of the last login.
    The flow of elements is illustrated in [Figure 7-2](#_02-streams_collectors_downstream-group-first-filter-downstream).
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '![Grouping elements with group first, filter downstream](assets/afaj_0702.png)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
- en: Figure 7-2\. Grouping elements with “group first, filter downstream”
  id: totrans-344
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Which approach is preferable depends on your requirements. Filtering first returns
    the least amount of key-value pairs possible, but grouping first grants you access
    to all `Map` keys and their (maybe) empty values.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: Composite Collectors
  id: totrans-346
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The last Collector I want to discuss is `Collectors.teeing` Added in Java 12,
    it differs from the others because it accepts two downstream Collectors at once
    and combines both results into one.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-348
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The name *teeing* originates from one of the most common pipe fittings — the
    T-fitting — which has the shape of a capital letter T.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: The Stream’s elements first pass through both downstream Collectors, so a `BiFunction`
    can merge both results as the second step, as illustrated in [Figure 7-3](#_02-streams-collectors_teeing).
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '![Teeing Collector Flow of Elements](assets/afaj_0703.png)'
  id: totrans-351
  prefs: []
  type: TYPE_IMG
- en: Figure 7-3\. Teeing Collector Flow of Elements
  id: totrans-352
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Imagine you want to know how many users you have and how many of them never
    logged in. Without the `teeing` operation, you would have to traverse the elements
    twice: once for the overall count and another time for counting the never logged-in
    Users. Both counting tasks can be represented by dedicated Collectors, `counting`
    and `filtering`, so you only need to traverse the elements once and let `teeing`
    do the two counting tasks at the end of the pipeline. The results are then merged
    with a `BiFunction<Long, Long>` into the new data structure `UserStats`. [Example 7-5](#_02-streams-teeing-login-range)
    shows how to implement it.'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，您想知道有多少用户及其中多少从未登录。如果没有 `teeing` 操作，您将不得不遍历元素两次：一次用于总体计数，另一次用于计算从未登录的用户。这两个计数任务可以由专用的
    Collectors `counting` 和 `filtering` 表示，因此您只需遍历元素一次，并让 `teeing` 在管道末端执行这两个计数任务。然后，使用
    `BiFunction<Long, Long>` 将结果合并到新的数据结构 `UserStats` 中。[示例 7-5](#_02-streams-teeing-login-range)
    展示了如何实现它。
- en: Example 7-5\. Finding min and max login dates
  id: totrans-354
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-5\. 查找最小和最大登录日期
- en: '[PRE37]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[![1](assets/1.png)](#co_working_with_streams_CO7-1)'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_working_with_streams_CO7-1)'
- en: A local Record type is used as the result type because Java lacks dynamic tuples.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Java 缺乏动态元组，本地 Record 类型被用作结果类型。
- en: '[![2](assets/2.png)](#co_working_with_streams_CO7-2)'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_working_with_streams_CO7-2)'
- en: The first downstream Collector counts all elements.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个下游 Collector 用于计算所有元素的数量。
- en: '[![3](assets/3.png)](#co_working_with_streams_CO7-3)'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_working_with_streams_CO7-3)'
- en: The second downstream Collector filters first and uses an additional downstream
    Collector to count the remaining elements.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个下游 Collector 首先进行过滤，并使用附加的下游 Collector 计算剩余元素的数量。
- en: '[![4](assets/4.png)](#co_working_with_streams_CO7-4)'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_working_with_streams_CO7-4)'
- en: A method reference to the `UserStats` constructor serves as the merge function
    of the two downstream Collector results.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserStats` 构造函数的方法引用用作两个下游 Collector 结果的合并函数。'
- en: Like many functional additions, the `teeing` Collector might initially seem
    strange if you’re coming from a mainly object-oriented background. On its own,
    a `for`-loop with two out-of-body variables to count could achieve the same result.
    The difference lies in how the `teeing` Collector benefits from the Stream pipeline
    and its overall advantages and functional possibilities, not just the terminal
    operation itself.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多功能性添加类似，如果您主要来自面向对象的背景，`teeing` Collector 最初可能会显得有些奇怪。单独使用 `for` 循环以两个离散变量计数可以达到相同的结果。不同之处在于
    `teeing` Collector 如何从 Stream 管道及其整体优势和功能可能性中受益，而不仅仅是终端操作本身。
- en: Creating Your Own Collector
  id: totrans-365
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建您自己的 Collector
- en: The auxiliary type `java.util.stream.Collectors` gives you over 44 pre-defined
    factory methods in the current LTS Java version 17 at the time of writing this
    book. They cover most general use cases, especially if used in tandem. There may
    be times when you need a custom, more context-specific Collector that’s more domain-specific
    and easier to use than a pre-defined one. That way, you can also share such specific
    Collectors in a custom auxiliary class, like `Collectors`.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 辅助类型 `java.util.stream.Collectors` 在撰写本书时的最新 LTS Java 版本 17 中提供了超过 44 个预定义的工厂方法。这些方法涵盖了大多数常见用例，特别是在联合使用时。有时您可能需要一个定制的、更具上下文特定性的
    Collector，比预定义的更易于使用。这样一来，您还可以在类似 `Collectors` 的自定义辅助类中共享这些特定的 Collectors。
- en: 'Recall from [Chapter 6](ch06.xhtml#_02-data-processing) that Collectors aggregate
    elements with the help of four methods:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾[第 6 章](ch06.xhtml#_02-data-processing)中提到，Collectors 借助四种方法聚合元素：
- en: '`Supplier<A> supplier()`'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Supplier<A> supplier()`'
- en: '`BiConsumer<A, T> accumulator()`'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BiConsumer<A, T> accumulator()`'
- en: '`BinaryOperator<A> combiner()`'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BinaryOperator<A> combiner()`'
- en: '`Function<A, R> finisher()`'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Function<A, R> finisher()`'
- en: One method of the `Collector` interface I haven’t mentioned before is `Set<Characteristics>
    characteristics()`. Like Streams, Collectors have a set of characteristics that
    allow for different optimization techniques. The three currently available options
    are listed in [Table 7-5](#_02-streams_collector-characteristics).
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前未提及的 `Collector` 接口的一种方法是 `Set<Characteristics> characteristics()`。与 Streams
    类似，Collectors 具有一组特性，允许不同的优化技术。当前提供的三个选项列在[表 7-5](#_02-streams_collector-characteristics)中。
- en: Table 7-5\. Available java.util.Collector.Characteristics
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7-5\. 可用的 java.util.Collector.Characteristics
- en: '| Characteristic | Description |'
  id: totrans-374
  prefs: []
  type: TYPE_TB
  zh: '| 特征 | 描述 |'
- en: '| --- | --- |'
  id: totrans-375
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `CONCURRENT` | Supports parallel processing |'
  id: totrans-376
  prefs: []
  type: TYPE_TB
  zh: '| `CONCURRENT` | 支持并行处理 |'
- en: '| `IDENTITY_FINISH` | The finisher is the identity function, returning the
    accumulator itself. In this case, only a cast is required instead of calling the
    finisher itself. |'
  id: totrans-377
  prefs: []
  type: TYPE_TB
  zh: '| `IDENTITY_FINISH` | 完成器是恒等函数，返回累加器本身。在这种情况下，只需要进行类型转换，而不是调用完成器本身。 |'
- en: '| `UNORDERED` | Indicates that the order of Stream elements isn’t necessarily
    preserved. |'
  id: totrans-378
  prefs: []
  type: TYPE_TB
  zh: '| `UNORDERED` | 表示流元素的顺序不一定会保留。 |'
- en: To better understand how these parts fit together, we’re going to recreate one
    of the existing Collectors, `Collectors.joining(CharSequence delimiter)`, which
    joins `CharSequence` elements, separated by the `delimiter` argument. [Example 7-6](#_02-streams_collector_joinector-full)
    shows how to implement the `Collector<T, A, R>` interface with a `java.util.StringJoiner`
    to achieve the required functionality.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这些部分是如何结合在一起的，我们将重现一个现有的收集器，`Collectors.joining(CharSequence delimiter)`，它将
    `CharSequence` 元素连接起来，以 `delimiter` 参数分隔。[示例 7-6](#_02-streams_collector_joinector-full)
    显示了如何使用 `java.util.StringJoiner` 实现 `Collector<T, A, R>` 接口，以实现所需的功能。
- en: Example 7-6\. Custom Collector for joining String elements
  id: totrans-380
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-6。用于连接字符串元素的自定义 Collector
- en: '[PRE38]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[![1](assets/1.png)](#co_working_with_streams_CO8-1)'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_working_with_streams_CO8-1)'
- en: The `StringJoiner` type is the perfect mutable results container due to its
    public API and delimiter support.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '`StringJoiner` 类型是完美的可变结果容器，因为它具有公共 API 和分隔符支持。'
- en: '[![2](assets/2.png)](#co_working_with_streams_CO8-2)'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_working_with_streams_CO8-2)'
- en: The accumulation logic for adding new elements to the container is as simple
    as using the proper method reference.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 向容器中添加新元素的累加逻辑就像使用适当的方法引用一样简单。
- en: '[![3](assets/3.png)](#co_working_with_streams_CO8-3)'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_working_with_streams_CO8-3)'
- en: The logic for combining multiple containers is also available via method reference.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 通过方法引用也可以实现多个容器的组合逻辑。
- en: '[![4](assets/4.png)](#co_working_with_streams_CO8-4)'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_working_with_streams_CO8-4)'
- en: The last step, transforming the results container to the actual result, is done
    with the container’s `toString` method.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步，将结果容器转换为实际结果，是通过容器的 `toString` 方法完成的。
- en: '[![5](assets/5.png)](#co_working_with_streams_CO8-5)'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_working_with_streams_CO8-5)'
- en: The `Joinector` doesn’t have any of the available Collector characteristics,
    so an empty `Set` is returned.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '`Joinector` 不具有任何可用的 Collector 特性，因此返回一个空的 `Set`。'
- en: 'Simple enough, but it’s still a lot of code for very little functionality consisting
    mostly of returning method references. Thankfully, there are convenience factory
    methods called `of` available on `Collector` to simplify the code:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 足够简单，但这仍然是大量的代码，功能非常少，主要是返回方法引用。幸运的是，`Collector` 上有方便的工厂方法 `of`，可以简化代码：
- en: '[PRE39]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This shorter version is equivalent to the previous full implementation of the
    interfaces.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简短版本相当于之前接口的完整实现。
- en: Note
  id: totrans-395
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The last argument of the `Collector.of(…​)` method isn’t always visible, if
    not set; it’s a vararg of the Collector’s characteristics.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '`Collector.of(…​)` 方法的最后一个参数并不总是可见，如果未设置，它是 Collector 特性的一组可变参数。'
- en: Creating your own Collectors should be reserved for custom result data structures
    or to simplify domain-specific tasks. Even then, you should first try to achieve
    the results with the available Collectors and a mix of downstream Collectors.
    The Java team has invested a lot of time and knowledge to give you safe and easy-to-use
    generic solutions that can be combined into quite complex and powerful solutions.
    Then, if you have a working Collectors, you can still refactor it into an auxiliary
    class to make it reusable and easier on the eyes.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 创建自己的收集器应保留用于自定义结果数据结构或简化特定领域任务。即便如此，你应该首先尝试使用可用的收集器和下游收集器的组合来实现结果。Java 团队投入了大量时间和知识，为你提供了安全且易于使用的通用解决方案，这些解决方案可以组合成相当复杂且强大的解决方案。然后，如果你有一个可用的收集器，你仍然可以将其重构为辅助类，使其可重用且易于阅读。
- en: Final Thoughts on (Sequential) Streams
  id: totrans-398
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于（顺序）流的最终想法
- en: The Java Streams API is, in my opinion, an absolute game changer, and that’s
    why it’s important to know about the multitude of available operations and ways
    to use Streams for different tasks. Streams give you a fluent, concise, and straightforward
    approach to data processing, with an option to go parallel if needed, as you’ll
    learn more about in [Chapter 8](ch08.xhtml#_01-parallel-streams). Still, they
    aren’t designed to replace preexisting constructs like loops, merely complementing
    them.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，Java Streams API是一个绝对的游戏改变者，因此了解可用操作和使用流处理不同任务的方式非常重要。流提供了一种流畅、简洁且直接的数据处理方法，如果需要，还可以并行处理，正如你将在[第8章](ch08.xhtml#_01-parallel-streams)中了解到的那样。然而，它们并不是设计来替代现有的循环结构，而是作为其补充。
- en: The most important skill you as a Java developer should acquire regarding Streams
    is finding the balance between using just enough Stream pipelines to improve the
    readability and reasonability of your code without sacrificing performance by
    ignoring traditional looping constructs.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 作为Java开发者，你应该掌握的关于Streams最重要的技能是在使用足够的流管道来提高代码可读性和合理性之间找到平衡，同时不要通过忽略传统的循环结构来牺牲性能。
- en: Not every loop needs to be a Stream. However, not every Stream would be better
    off being a loop, either. The more you get used to using Streams for data processing,
    the easier you will find a healthy balance between the two approaches to data
    processing.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 并非每个循环都需要成为流。然而，并非每个流都最好成为循环。当您习惯使用流进行数据处理时，您将更容易找到两种数据处理方法之间的健康平衡。
- en: Takeaways
  id: totrans-402
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 要点
- en: The Stream API provides a wide range of possibilities to create Streams, from
    iterative approaches that are similar to traditional looping constructs to specialized
    variants for certain types like file I/O or the new Date and Time API.
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Stream API提供了多种可能性来创建流，从类似传统循环结构的迭代方法到特定类型的专门变体，如文件I/O或新的日期和时间API。
- en: Like functional interfaces, most Streams and their operations support primitive
    types via specialized types to reduce the amount of autoboxing. These specialized
    variants can give you a performance-wise edge if needed but will restrict the
    available operations. But you can always switch between primitive and non-primitive
    Streams in a pipeline to gain the benefits of both worlds.
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与功能接口类似，大多数流及其操作通过专门类型支持原始类型，以减少自动装箱的数量。这些专门的变体在需要时可以为您提供性能优势，但会限制可用的操作。但是，您可以在管道中在原始和非原始流之间随时切换，以获得两个世界的优势。
- en: Downstream Collectors can affect the collection process in multiple ways, like
    transforming or filtering, to manipulate the result into the representation required
    for your task.
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下游收集器可以通过多种方式影响集合过程，例如转换或过滤，以将结果操作为任务所需的表示形式。
- en: If a combination of downstream Collectors cannot fulfill your task, you can
    fall back on creating your own Collector instead.
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一组下游收集器的组合无法满足您的任务需求，您可以退而自行创建收集器。
- en: ^([1](ch07.xhtml#idm45115235898112-marker)) *Project Valhalla*, as discussed
    in [“Project Valhalla and Specialized Generics”](ch03.xhtml#_01-functions_project-valhalla),
    will allow value-based types, like primitives, to be used as generic type boundaries.
    Unfortunately, though, at the point of writing this book, no targeted availability
    date is known.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch07.xhtml#idm45115235898112-marker)) 正如在[“Project Valhalla和专用泛型”](ch03.xhtml#_01-functions_project-valhalla)中讨论的那样，*Project
    Valhalla*将允许像原始类型这样的值类型用作泛型类型边界。然而，截至本书撰写之时，尚不清楚其具体可用日期。
- en: ^([2](ch07.xhtml#idm45115235350064-marker)) For example, the [documentation
    of `Random#ints()`](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Random.xhtml#ints())
    states that the method is implemented to be an equivalent of `Random.ints(Long.MAX_VALUE)`.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch07.xhtml#idm45115235350064-marker)) 例如，[`Random#ints()`的文档](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Random.xhtml#ints())指出该方法被实现为`Random.ints(Long.MAX_VALUE)`的等效方法。
- en: ^([3](ch07.xhtml#idm45115235120224-marker)) See the sidebar [“Project Valhalla
    and Specialized Generics”](ch03.xhtml#_01-functions_project-valhalla) for more
    information about *Project Valhalla*.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch07.xhtml#idm45115235120224-marker)) 有关*Project Valhalla*的更多信息，请参见侧边栏[“Project
    Valhalla和专用泛型”](ch03.xhtml#_01-functions_project-valhalla)。
- en: ^([4](ch07.xhtml#idm45115233771312-marker)) Project Gutenberg provides multiple
    versions of [War and Peace](https://www.gutenberg.org/ebooks/2600) for free.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch07.xhtml#idm45115233771312-marker)) Project Gutenberg提供多个免费版本的[《战争与和平》](https://www.gutenberg.org/ebooks/2600)。
- en: ^([5](ch07.xhtml#idm45115233615264-marker)) The [Java *Date & Time API* (JSR310)](https://openjdk.java.net/projects/threeten)
    set out to replace `java.util.Date` with a comprehensive set of types allowing
    for a consistent and complete way to deal with date- and time-related types in
    an immutable fashion.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch07.xhtml#idm45115233615264-marker)) [Java *日期与时间 API*（JSR310）](https://openjdk.java.net/projects/threeten)
    的目标是用一套全面的类型替换 `java.util.Date`，以一种不可变的方式提供一致和完整的日期和时间处理方法。
- en: ^([6](ch07.xhtml#idm45115233447600-marker)) The [official documentation of `java.time.temporal.TemporalQueries`](https://docs.oracle.com/javase/8/docs/api/java/time/temporal/TemporalQueries.xhtml)
    lists in detail which types are supported by each pre-defined `TemporalQuery`
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch07.xhtml#idm45115233447600-marker)) [官方文档 `java.time.temporal.TemporalQueries`](https://docs.oracle.com/javase/8/docs/api/java/time/temporal/TemporalQueries.xhtml)
    详细列出了每个预定义 `TemporalQuery` 支持的类型。
- en: '^([7](ch07.xhtml#idm45115233431088-marker)) JMH is also supported for Java
    versions before 12, but you need to include its two dependencies manually: [JMH
    Core](https://mvnrepository.com/artifact/org.openjdk.jmh/jmh-core) and the [JMH
    Generators/Annotation Processors](https://mvnrepository.com/artifact/org.openjdk.jmh/jmh-generator-annprocess).'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: ^([7](ch07.xhtml#idm45115233431088-marker)) JMH 也支持 Java 12 之前的版本，但您需要手动包含其两个依赖项：[JMH
    Core](https://mvnrepository.com/artifact/org.openjdk.jmh/jmh-core) 和 [JMH Generators/Annotation
    Processors](https://mvnrepository.com/artifact/org.openjdk.jmh/jmh-generator-annprocess)。
- en: ^([8](ch07.xhtml#idm45115233423152-marker)) Evans, Benjamin J., Gough, James,
    Newland, Chris. 2018\. “Optimizing Java.” O’Reilly Media. 978-1-492-02579-5
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: ^([8](ch07.xhtml#idm45115233423152-marker)) Evans, Benjamin J., Gough, James,
    Newland, Chris. 2018\. “优化 Java。” O’Reilly Media. 978-1-492-02579-5
- en: ^([9](ch07.xhtml#idm45115233422032-marker)) Oaks, Scott. 2020\. “Java Performance,
    2nd Edition.” O’Reilly Media. ISBN 978-1-492-05611-9.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: ^([9](ch07.xhtml#idm45115233422032-marker)) Oaks, Scott. 2020\. “Java 性能，第二版。”
    O’Reilly Media. ISBN 978-1-492-05611-9.
