- en: Chapter 13\. Server-Side Java
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 13.0 Introduction
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sockets form the underpinnings of almost all networking protocols. JDBC, RMI,
    CORBA, EJB, and the non-Java RPC (Remote Procedure Call) and NFS (Network File
    System) are all implemented by connecting various types of sockets together. Socket
    connections can be implemented in most any language, not just Java: C, C++, Perl,
    and Python are also popular, and many others are possible. A client or server
    written in any one of these languages can communicate with its opposite written
    in any of the other languages. Therefore, it’s worth taking a quick look at how
    the `ServerSocket` behaves, even if you wind up utilizing the higher-level services
    such as RMI, JDBC, CORBA, or EJB.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'The discussion looks first at the `ServerSocket` itself, then at writing data
    over a socket in various ways. Finally, I show a complete implementation of a
    usable network server written in Java: the chat server from the client in the
    previous chapter.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-4
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Most production work in server-side Java uses the Java Enterprise Edition (Java
    EE), recently transferred from Oracle to the Eclipse Software Foundation and renamed
    to Jakarta but widely referred to by the previous name (and occasionally by its
    very old name, “J2EE,” which was retired in 2005). Java EE provides scalability
    and support for building well-structured, multitiered distributed applications.
    EE provides the servlet framework; a servlet is a strategy object that can be
    installed into any standard Java EE web server. EE also provides two web view
    technologies: the original JSP (JavaServer Pages) and the newer, component-based
    JSF (JavaServer Faces). Finally, EE provides a number of other network-based services,
    including EJB3 remote access and Java Messaging Service (JMS). These are outside
    the scope of this book; they are covered in other books, such as Arun Gupta’s
    *[Java EE 7 Essentials: Enterprise Developer Handbook](http://shop.oreilly.com/product/0636920030614.do)*.
    This chapter is only for those who need or want to build their own server from
    the ground up.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: 13.1 Opening a Server Socket for Business
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to write a socket-based server.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a `ServerSocket` for the given port number.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `ServerSocket` represents the other end of a connection, the server that
    waits patiently for clients to come along and connect to it. You construct a `ServerSocket`
    with just the port number.^([1](ch13.html#idm45290642028248)) Because it doesn’t
    need to connect to another host, it doesn’t need a particular host’s address as
    the client socket constructor does.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Assuming the `ServerSocket` constructor doesn’t throw an exception, you’re in
    business. Your next step is to await client activity, which you do by calling
    `accept()`. This call blocks until a client connects to your server; at that point,
    the `accept()` returns to you a `Socket` object (not a `ServerSocket`) that is
    connected in both directions to the `ServerSocket` object on the client (or its
    equivalent, if written in another language). [Example 13-1](#javacook-netserver-EX-1)
    shows the code for a socket-based server.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`ServerSocket`构造函数不会抛出异常，您就可以开始工作了。您的下一步是等待客户端活动，这可以通过调用`accept()`来实现。此调用将阻塞，直到客户端连接到您的服务器；此时，`accept()`将向您返回一个`Socket`对象（而不是`ServerSocket`），该对象在客户端的`ServerSocket`对象（或其等价对象，如果用另一种语言编写）中双向连接。[示例 13-1](#javacook-netserver-EX-1)展示了基于套接字的服务器的代码。
- en: Example 13-1\. main/src/main/java/network/Listen.java
  id: totrans-14
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 13-1\. main/src/main/java/network/Listen.java
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You would normally use the same socket for both reading and writing, as shown
    in the next few recipes.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您会在读取和写入时使用相同的套接字，如下几个示例所示。
- en: You may want to listen only on a particular network interface. Though we tend
    to think of network addresses as computer addresses, the two are not the same.
    A network address is actually the address of a particular network card, or network
    interface connection, on a given computing device. A desktop computer, laptop,
    tablet, or mobile phone might have only a single interface, hence a single network
    address. But a large server machine might have two or more interfaces, usually
    when it is connected to several networks. A network router is a box, either special
    purpose (e.g., a Cisco router), or general purpose (e.g., a Unix host), that has
    interfaces on multiple networks *and* has both the capability and the administrative
    permission to forward packets from one network to another. A program running on
    such a server machine might want to provide services only to its inside network
    or its outside network. One way to accomplish this is by specifying the network
    interface to be listened on. Suppose you want to provide a different view of web
    pages for your intranet than you provide to outside customers. For security reasons,
    you probably wouldn’t run both these services on the same machine. But if you
    wanted to, you could do this by providing the network interface addresses as arguments
    to the `ServerSocket` constructor.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能只想侦听特定的网络接口。尽管我们倾向于将网络地址视为计算机地址，但两者并不相同。网络地址实际上是给定计算设备上的特定网络卡或网络接口连接的地址。台式计算机、笔记本电脑、平板电脑或手机可能只有一个接口，因此只有一个网络地址。但是大型服务器可能有两个或更多接口，通常当它连接到多个网络时。网络路由器是一个盒子，可以是专用用途的（例如Cisco路由器），也可以是通用用途的（例如Unix主机），它在多个网络上都有接口，并且具有转发数据包的能力和管理权限。在这样的服务器上运行的程序可能希望仅向其内部网络或外部网络提供服务。通过指定要侦听的网络接口，可以实现这一目标。假设您希望为内部网提供与外部客户不同的网页视图。出于安全原因，您可能不会在同一台机器上运行这两种服务。但是如果您希望这样做，可以通过将网络接口地址作为参数提供给`ServerSocket`构造函数来实现。
- en: However, to use this form of the constructor, you don’t have the option of using
    a string for the network address’s name, as you did with the client socket; you
    must convert it to an `InetAddress` object. You also have to provide a backlog
    argument, which is the number of connections that can queue up to be accepted
    before clients are told that your server is too busy. The complete setup is shown
    in [Example 13-2](#javacook-netserver-EX-2).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，要使用构造函数的这种形式，您不能像客户端套接字那样使用字符串作为网络地址的名称；您必须将其转换为`InetAddress`对象。您还必须提供一个backlog参数，这是在客户端被告知您的服务器太忙之前可以排队等待接受的连接数。完整的设置如[示例 13-2](#javacook-netserver-EX-2)所示。
- en: Example 13-2\. main/src/main/java/network/ListenInside.java
  id: totrans-19
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 13-2\. main/src/main/java/network/ListenInside.java
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`InetAddress.getByName()` looks up the given hostname in a system-dependent
    way, referring to a configuration file in the */etc* or *\windows* directory,
    or to some kind of resolver such as the Domain Name System. Consult a good book
    on networking and system administration if you need to modify this data.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`InetAddress.getByName()`以系统相关的方式查找给定主机名，在*/etc*或*\windows*目录下的配置文件中，或者通过诸如域名系统这样的解析器来引用。如果需要修改此数据，请参考有关网络和系统管理的好书。'
- en: 13.2 Finding Network Interfaces
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 13.2 查找网络接口
- en: Problem
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You wish to find out about the computer’s networking arrangements.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望了解计算机的网络安排。
- en: Solution
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the `NetworkInterface` class.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`NetworkInterface`类。
- en: Discussion
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Every computer on a network has one or more “network interfaces.” On typical
    desktop machines, a network interface represents a network card or network port
    or some software network interface, such as the loopback interface. Each interface
    has an operating system–defined name. On most versions of Unix, these devices
    have a two- or three-character device driver name plus a digit (starting from
    0), for example, `eth0` or `en0` for the first Ethernet on systems that hide the
    details of the card manufacturer, or `de0` and `de1` for the first and second
    Digital Equipment^([2](ch13.html#idm45290641414168)) DC21x4x-based Ethernet card,
    `xl0` for a 3Com EtherLink XL, and so on. The loopback interface is almost invariably
    `lo0` on all Unix-like platforms.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 网络中的每台计算机都有一个或多个“网络接口”。在典型的台式机上，网络接口代表网络卡或网络端口，或者某些软件网络接口，如环回接口。每个接口都有一个操作系统定义的名称。在大多数Unix版本中，这些设备有一个两个或三个字符的设备驱动程序名称加上一个数字（从0开始），例如，`eth0`或`en0`表示第一台以太网设备，系统隐藏了卡片制造商的细节；或者`de0`和`de1`表示第一和第二个基于Digital
    Equipment的DC21x4x以太网卡，`xl0`表示3Com EtherLink XL，等等。环回接口在所有类Unix平台上几乎都是`lo0`。
- en: So what? Most of the time this is of no consequence to you. If you have only
    one network connection, like a cable link to your ISP, you really don’t care.
    Where this matters is on a server, where you might need to find the address for
    a given network, for example. The `NetworkInterface` class lets you find out.
    It has static methods for listing the interfaces and other methods for finding
    the addresses associated with a given interface. The program in [Example 13-3](#javacook-netserver-EX-14)
    shows some examples of using this class. Running it prints the names of all the
    local interfaces. If you happen to be on a computer named *laptop*, it prints
    the machine’s network address; if not, you probably want to change it to accept
    the local computer’s name from the command line; this is left as an exercise for
    the reader.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 那又怎样？大多数情况下这对你来说无关紧要。如果你只有一个网络连接，比如与ISP的电缆连接，你真的不在乎。这在服务器上很重要，例如你可能需要找到特定网络的地址。`NetworkInterface`类允许你找到。它具有用于列出接口的静态方法和用于查找与给定接口关联的地址的其他方法。示例[Example 13-3](#javacook-netserver-EX-14)中的程序展示了使用此类的一些示例。运行它会打印所有本地接口的名称。如果你恰好在名为*laptop*的计算机上，它会打印机器的网络地址；如果不是，你可能想要从命令行接受本地计算机的名称；这留给读者作为练习。
- en: Example 13-3\. main/src/main/java/network/NetworkInterfaceDemo.java
  id: totrans-30
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 13-3\. main/src/main/java/network/NetworkInterfaceDemo.java
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 13.3 Returning a Response (String or Binary)
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 13.3 返回响应（字符串或二进制）
- en: Problem
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to write a string or binary data to the client.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要向客户端写入字符串或二进制数据。
- en: Solution
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: The socket gives you an `InputStream` and an `OutputStream`. Use them.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 套接字提供了一个`InputStream`和一个`OutputStream`。使用它们。
- en: Discussion
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: The client socket examples in the previous chapter called the `getInputStream()`
    and `getOutputStream()` methods. These examples do the same. The main difference
    is that these ones get the socket from a `ServerSocket`’s `accept()` method. Another
    distinction is, by definition, that normally the server creates or modifies the
    data and sends it to the client. [Example 13-4](#javacook-netserver-EX-3) is a
    simple `Echo` server, which the `Echo` client of [Recipe 12.5](ch12.html#javacook-netclient-SECT-4)
    can connect to. This server handles one complete connection with a client, then
    goes back and does the `accept()` to wait for the next client.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章中的客户端套接字示例调用了`getInputStream()`和`getOutputStream()`方法。这些示例也一样。主要区别在于，这些示例从`ServerSocket`的`accept()`方法中获取套接字。另一个区别是，按照定义，通常是服务器创建或修改数据并将其发送到客户端。[Example 13-4](#javacook-netserver-EX-3)是一个简单的`Echo`服务器，[Recipe
    12.5](ch12.html#javacook-netclient-SECT-4)中的`Echo`客户端可以连接到它。此服务器处理一个完整的客户端连接，然后返回并等待下一个客户端的`accept()`。
- en: Example 13-4\. main/src/main/java/network/EchoServer.java
  id: totrans-39
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 13-4\. main/src/main/java/network/EchoServer.java
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: To send a string across an arbitrary network connection, some authorities recommend
    sending both the carriage return and the newline character; many protocol specifications
    require that you do so. This explains the `\r\n` in the code. If the other end
    is a DOS program or a Telnet-like program, it may be expecting both characters.
    On the other hand, if you are writing both ends, you can simply use `println()`—followed
    always by an explicit `flush()` before you read—to prevent the deadlock of having
    both ends trying to read with one end’s data still in the `PrintWriter`’s buffer!
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在任意网络连接上发送字符串，一些权威建议同时发送回车和换行字符；许多协议规范要求如此做。这就解释了代码中的`\r\n`。如果另一端是DOS程序或类似Telnet的程序，可能期望同时接收这两个字符。另一方面，如果你同时编写两端，可以简单地使用`println()`——在读取之前始终紧接着显式地使用`flush()`，以防止出现一端的数据仍在`PrintWriter`缓冲区中导致死锁的情况！
- en: 'If you need to process binary data, use the data streams from `java.io` instead
    of the readers/writers. I need a server for the `DaytimeBinary` program of [Recipe
    12.6](ch12.html#javacook-netclient-SECT-5). In operation, it should look like
    the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要处理二进制数据，请使用`java.io`中的数据流而不是读取器/写入器。我需要一个服务器用于[食谱 12.6](ch12.html#javacook-netclient-SECT-5)的`DaytimeBinary`程序。在操作中，它应该如下所示：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Well, it happens that I have such a program in my arsenal, so I present it in
    [Example 13-5](#javacook-netserver-EX-4). Note that it directly uses certain public
    constants defined in the client class. Normally these are defined in the server
    class and used by the client, but I wanted to present the client code first.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，我的武器库中正好有这样一个程序，所以我在[示例 13-5](#javacook-netserver-EX-4)中呈现它。请注意，它直接使用了客户端类中定义的某些公共常量。通常这些常量在服务器类中定义并由客户端使用，但我想先呈现客户端代码。
- en: Example 13-5\. main/src/main/java/network/DaytimeServer.java
  id: totrans-45
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 13-5\. main/src/main/java/network/DaytimeServer.java
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 13.4 Returning Object Information Across a Network Connection
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 13.4 在网络连接中返回对象信息
- en: Problem
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to return an object across a network connection.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要通过网络连接返回一个对象。
- en: Solution
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Create the object you need, and write it using an `ObjectOutputStream` created
    on top of the socket’s output stream.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 创建所需的对象，并使用套接字输出流顶部的`ObjectOutputStream`将其写入。
- en: Discussion
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: The program in [Example 12-7](ch12.html#javacook-netclient-EX-7) in the previous
    chapter reads a `Date` object over an `ObjectInputStream`. [Example 13-6](#javacook-netserver-EX-5),
    the `DaytimeObjectServer` (the other end of that process), is a program that constructs
    a `Date` object each time it’s connected to and returns it to the client.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 前一章节中[示例 12-7](ch12.html#javacook-netclient-EX-7)的程序读取一个`Date`对象，使用`ObjectInputStream`。[示例 13-6](#javacook-netserver-EX-5)，`DaytimeObjectServer`（该过程的另一端），是一个每次连接时构造一个`Date`对象并返回给客户端的程序。
- en: Example 13-6\. main/src/main/java/network/DaytimeObjectServer.java
  id: totrans-54
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 13-6\. main/src/main/java/network/DaytimeObjectServer.java
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 13.5 Handling Multiple Clients
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 13.5 处理多个客户端
- en: Problem
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: Your server needs to handle multiple clients.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你的服务器需要处理多个客户端。
- en: Solution
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use a thread for each.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 对每个使用一个线程。
- en: Discussion
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: In the C world, several mechanisms allow a server to handle multiple clients.
    One is to use a special system call `select()` or `poll()`, which notifies the
    server when any of a set of file/socket descriptors is ready to read, ready to
    write, or has an error. By including its rendezvous socket (equivalent to our
    `ServerSocket`) in this list, the C-based server can read from any of a number
    of clients in any order. Java does not provide this call, because it is not readily
    implementable on some Java platforms. Instead, Java uses the general-purpose `Thread`
    mechanism, as described in [Chapter 16](ch16.html#javacook-threads) (threads are
    now commonplace in many programming languages, though not always under that name).
    Each time the code accepts a new connection from the `ServerSocket`, it immediately
    constructs and starts a new thread object to process that client.^([3](ch13.html#idm45290640666504))
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在C语言世界中，有几种机制允许服务器处理多个客户端。其中一种是使用特殊的系统调用`select()`或`poll()`，它通知服务器哪些文件/套接字描述符准备好读取、准备好写入或有错误。通过在这个列表中包括它的约会套接字（相当于我们的`ServerSocket`），基于C的服务器可以按任何顺序从多个客户端读取。Java不提供这个调用，因为它在某些Java平台上不容易实现。相反，Java使用通用的`Thread`机制，如[第16章](ch16.html#javacook-threads)所述（线程现在在许多编程语言中很常见，尽管不总是以这个名称）。每当代码从`ServerSocket`接受新连接时，它立即构造并启动一个新的线程对象来处理该客户端。^([3](ch13.html#idm45290640666504))
- en: 'The Java code to implement accepting on a socket is pretty simple, apart from
    having to catch `IOException`s:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 实现在套接字上接受的 Java 代码非常简单，除了必须捕获 `IOException` 外：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To use a thread, you must either subclass `Thread` or implement `Runnable`.
    The `Handler` class must be a subclass of `Thread` for this code to work as written;
    if `Handler` instead implemented the `Runnable` interface, the code would pass
    an instance of the `Runnable` into the constructor for `Thread`, as in:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用线程，你必须要么继承 `Thread` 类，要么实现 `Runnable` 接口。为了使这段代码按照原样运行，`Handler` 类必须是 `Thread`
    的子类；如果 `Handler` 实现了 `Runnable` 接口，那么代码将会把 `Runnable` 的实例传递给 `Thread` 的构造函数，就像这样：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'But as written, `Handler` is constructed using the normal socket returned by
    `accept()` and normally calls the socket’s `getInputStream()` and `getOutputStream()`
    methods and holds its conversation in the usual way. I’ll present a full implementation,
    a threaded echo client. First, a session showing it in use:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 但按照原样，`Handler` 是使用 `accept()` 返回的普通套接字构造的，并且通常调用套接字的 `getInputStream()` 和 `getOutputStream()`
    方法，以正常方式进行通信。我将展示一个完整的实现，一个多线程回显客户端。首先，一个显示其使用情况的会话：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here I connected to the server once with my `EchoClient` program and, while
    still connected, called it up again (and again) with an operating system–provided
    Telnet client. The server communicated with all the clients concurrently, sending
    the answers from the first client back to the first client, and the data from
    the second client back to the second client. In short, it works. I ended the sessions
    with the end-of-file character in the program and used the normal disconnect mechanism
    from the Telnet client. [Example 13-7](#javacook-netserver-EX-6-ch16) is the code
    for the server.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我使用我的 `EchoClient` 程序连接了一次服务器，并且在仍然连接的情况下，使用操作系统提供的 Telnet 客户端多次调用它。服务器同时与所有客户端通信，将第一个客户端的答复发送回给第一个客户端，将第二个客户端的数据发送回给第二个客户端。简而言之，它有效果。我在程序中使用文件结束符号结束了会话，并使用
    Telnet 客户端的正常断开机制。[示例 13-7](#javacook-netserver-EX-6-ch16) 是服务器的代码。
- en: Example 13-7\. main/src/main/java/network/EchoServerThreaded.java
  id: totrans-70
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 13-7\. 主代码/src/main/java/network/EchoServerThreaded.java
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: A lot of short transactions can degrade performance, because each client causes
    the creation of a new threaded object. If you know or can reliably predict the
    degree of concurrency that is needed, an alternative paradigm involves the precreation
    of a fixed number of threads. But then how do you control their access to the
    `ServerSocket`? A look at the `ServerSocket` class documentation reveals that
    the `accept()` method is not synchronized, meaning that any number of threads
    can call the method concurrently. This could cause bad things to happen. So I
    use the `synchronized` keyword around this call to ensure that only one client
    runs in it at a time, because it updates global data. When no clients are connected,
    you will have one (randomly selected) thread running in the `ServerSocket` object’s
    `accept()` method, waiting for a connection, plus *n-1* threads waiting for the
    first thread to return from the method. As soon as the first thread manages to
    accept a connection, it goes off and holds its conversation, releasing its lock
    in the process so that another randomly chosen thread is allowed into the `accept()`
    method. Each thread’s `run()` method has an infinite loop beginning with an `accept()`
    and then holding the conversation. The result is that client connections can get
    started more quickly, at a cost of slightly greater server startup time. Doing
    it this way also avoids the overhead of constructing a new `Handler` or `Thread`
    object each time a request comes along. This general approach is similar to what
    the popular Apache web server does, although it normally creates a number or pool
    of identical processes (instead of threads) to handle client connections. Accordingly,
    I have modified the `EchoServerThreaded` class shown in [Example 13-7](#javacook-netserver-EX-6-ch16)
    to work this way, as you can see in [Example 13-8](#javacook-netserver-EX-7).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 大量的短交易可能会降低性能，因为每个客户端都会导致创建一个新的线程对象。如果你知道或者可以可靠地预测所需的并发度，另一种范例涉及预先创建固定数量的线程。但是你如何控制它们对`ServerSocket`的访问呢？查看`ServerSocket`类文档会发现`accept()`方法没有同步，这意味着任何数量的线程可以同时调用该方法。这可能会导致糟糕的事情发生。因此，我在此调用周围使用`synchronized`关键字来确保一次只有一个客户端在其中运行，因为它更新全局数据。当没有客户端连接时，你将会有一个（随机选择的）线程在`ServerSocket`对象的`accept()`方法中运行，等待连接，加上*n-1*个线程等待第一个线程从方法返回。一旦第一个线程成功接受连接，它就会离开并进行对话，释放其锁，以便另一个随机选择的线程被允许进入`accept()`方法。每个线程的`run()`方法都有一个从`accept()`开始的无限循环，然后进行对话。结果是客户端连接可以更快地启动，但稍微增加了服务器启动时间。这样做还可以避免每次请求到来时构造一个新的`Handler`或`Thread`对象的开销。这种一般方法类似于流行的Apache
    Web服务器所做的，尽管它通常会创建一组相同的进程（而不是线程）来处理客户端连接。因此，我已经修改了[示例 13-7](#javacook-netserver-EX-6-ch16)中显示的`EchoServerThreaded`类，使其以这种方式工作，你可以在[示例 13-8](#javacook-netserver-EX-7)中看到。
- en: Example 13-8\. main/src/main/java/network/EchoServerThreaded2.java
  id: totrans-73
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 13-8\. main/src/main/java/network/EchoServerThreaded2.java
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: It is quite possible to implement a server of this sort with NIO, the “new”
    (back in J2SE 1.4) I/O package. However, the code to do so outweighs anything
    in this chapter, and it is fraught with issues. There are several good tutorials
    on the internet for the person who truly needs the performance gain of using NIO
    to manage server connections.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 用NIO实现这种服务器是完全可能的，这是“新的”（在J2SE 1.4时）I/O包。然而，要做到这一点的代码超过了本章的任何内容，并且充满了问题。有几篇关于如何利用NIO管理服务器连接获得性能提升的好教程可以在互联网上找到。
- en: 13.6 Serving the HTTP Protocol
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 13.6 提供HTTP协议
- en: Problem
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to serve up a protocol such as HTTP.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要提供像HTTP这样的协议。
- en: Solution
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Create a `ServerSocket` and write some code that speaks the particular protocol.
    Or, better, use a Java-powered web server such as Apache Tomcat or a Java Enterprise
    Edition (Java EE) server such as JBoss WildFly.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个`ServerSocket`，并编写一些能够使用特定协议的代码。或者更好的是，使用一个Java驱动的Web服务器，比如Apache Tomcat或Java企业版（Java
    EE）服务器，比如JBoss WildFly。
- en: Discussion
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: You can implement your own HTTP protocol server for very simple applications,
    which we’ll do here. For any serious development, you want to use the Java Enterprise
    Edition; see the note at the beginning of this chapter.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为非常简单的应用程序实现自己的HTTP协议服务器，我们将在这里做到这一点。对于任何严肃的开发，你都想要使用Java企业版；请参阅本章开头的说明。
- en: This example just constructs a `ServerSocket` and listens on it. When connections
    come in, they are replied to using the HTTP protocol. So it is somewhat more involved
    than the simple `Echo` server presented in [Recipe 13.3](#javacook-netserver-SECT-2).
    However, it’s not a complete web server; the filename in the request is ignored,
    and a standard message is always returned. This is thus a *very* simple web server;
    it follows only the bare minimum of the HTTP protocol needed to send its response
    back. For a real web server written in Java, get Tomcat from the [Apache Tomcat
    website](http://tomcat.apache.org) or any of the Jakarta/JavaEE Application Servers.
    The code shown in [Example 13-9](#javacook-netserver-EX-8), however, is enough
    to understand how to build a simple server that responds to requests using a protocol.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Example 13-9\. main/src/main/java/network/WebServer0.java
  id: totrans-84
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 13.7 Securing a Web Server with SSL and JSSE
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to protect your network traffic from prying eyes or malicious modification
    while the data is in transit.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the Java Secure Socket Extension, JSSE, to encrypt your traffic.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JSSE provides services at a number of levels, but the simplest way to use it
    is simply to get your `ServerSocket` from an `SSLServerSocketFactory` instead
    of using the `ServerSocket` constructor directly. SSL is the Secure Sockets Layer;
    a revised version is known as TLS. It is specifically for use on the web. To secure
    other protocols, you’d have to use a different form of the `SocketFactory`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: The `SSLServerSocketFactory` returns a `ServerSocket` that is set up to do SSL
    encryption. [Example 13-10](#javacook-netserver-EX-9) uses this technique to override
    the `getServerSocket()` method in [Recipe 13.6](#javacook-netserver-SECT-5). If
    you’re thinking this is too easy, you’re wrong!
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Example 13-10\. main/src/main/java/network/JSSEWebServer0
  id: totrans-94
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'That is, indeed, all the Java code one needs to write. You do have to set up
    an SSL Certificate. For demonstration purposes, this can be a self-signed certificate;
    the steps in [*https://darwinsys.com/java/selfsigncert.html*](https://darwinsys.com/java/selfsigncert.html)
    (steps 1–4) will suffice. You have to tell the JSSE layer where to find your keystore:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The typical client browser raises its eyebrows at a self-signed certificate
    (see [Figure 13-1](#javacook-netserver-FIG-1)), but, if the user okays it, will
    accept the certificate.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 13-2](#javacook-netserver-FIG-2) shows the output of the simple `WebServer0`
    being displayed over the HTTPS protocol (notice the padlock in the lower-right
    corner).'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '![jcb4 1301](assets/jcb4_1301.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
- en: Figure 13-1\. Browser caution
  id: totrans-101
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '![jcb4 1302](assets/jcb4_1302.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
- en: Figure 13-2\. With encryption
  id: totrans-103
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: See Also
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JSSE can do much more than encrypt web server traffic; this is, however, sometimes
    seen as its most exciting application. For more information on JSSE, see [the
    Sun website](http://java.sun.com/products/jsse) or *[Java Security](http://shop.oreilly.com/product/9780596001575.do)*
    by Scott Oaks (O’Reilly).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: JSSE不仅可以加密Web服务器流量，而且有时被视为其最激动人心的应用程序。有关JSSE的更多信息，请参见[Sun网站](http://java.sun.com/products/jsse)或*《Java安全》*（由Scott
    Oaks编写，O’Reilly出版）。
- en: 13.8 Creating a REST Service with JAX-RS
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 13.8 使用JAX-RS创建REST服务
- en: Problem
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to implement a RESTful server by using the provided Java EE/Jakarta
    EE APIs.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 您想要通过使用提供的Java EE/Jakarta EE API来实现一个RESTful服务器。
- en: Solution
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use JAX-RS annotations on a class that provides a service; install it in an
    enterprise application server.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在提供服务的类上使用JAX-RS注解，并将其安装在企业应用服务器中。
- en: Discussion
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: This operation consists of both coding and configuration.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 该操作包括编码和配置两部分。
- en: The coding steps consist of creating a class that extends the JAX-RS `Application`
    class and adding annotations to a class that provides a service.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 编码步骤包括创建一个扩展JAX-RS `Application`类的类，并在提供服务的类上添加注解。
- en: 'Here is a minimal `Application` class:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个最小化的`Application`类示例：
- en: '[PRE15]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[Example 13-11](#javacook-netserver-EX-REST) is a “Hello, World"–type service
    class with the annotations needed to make it a service class and to have three
    sample methods.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 13-11](#javacook-netserver-EX-REST) 是一个类似“Hello, World”的服务类，带有使其成为服务类以及具有三个示例方法所需的注解。'
- en: Example 13-11\. restdemo/src/main/java/rest/RestService.java
  id: totrans-117
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 13-11\. restdemo/src/main/java/rest/RestService.java
- en: '[PRE16]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now the class must be deployed. If we have created a proper Maven project structure
    (see [Recipe 1.7](ch01.html#javacook-getstarted-maven)) and have provided an application-server-specific
    Maven plug-in, and our development server is running, we can use some variation
    on `mvn deploy`. In the present case I have set this up, in the *rest* subdirectory,
    for deployment to WildFly, a Java Enterprise server from the JBoss open source
    community (though somewhat dated), funded by RedHat Inc. I need only say `mvn
    wildfly:deploy` to have the application compiled, packaged, and deployed to my
    server.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在必须部署该类。如果我们已经创建了适当的Maven项目结构（参见[Recipe 1.7](ch01.html#javacook-getstarted-maven)）并提供了特定于应用服务器的Maven插件，并且我们的开发服务器正在运行，则可以使用类似`mvn
    deploy`的变体。在这种情况下，我已经为在WildFly上部署设置了这个，在*rest*子目录下，只需执行`mvn wildfly:deploy`即可编译、打包并部署应用程序到我的服务器。
- en: For deploying REST services as a microservice based on Eclipse MicroProfile,
    you may wish to investigate the [Quarkus Framework](https://quarkus.io).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要基于Eclipse MicroProfile部署REST服务作为微服务，您可能希望研究[Quarkus框架](https://quarkus.io)。
- en: 'Once the service is deployed, you can explore it interactively with a browser
    or, for simple GET requests, a Telnet client:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦服务部署完成，您可以使用浏览器或简单的GET请求的Telnet客户端进行交互探索：
- en: '[PRE17]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: An issue with REST is that there is not an official standard for documenting
    the API or protocol offered by a server (there are several competing specifications).
    So people writing clients must either rely on plain documentation offered by the
    server’s developers, or use trial and error to discover the protocol. Our example
    here is simple enough that we don’t have this problem, but imagine a class with
    20 or 30 methods in it.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: REST的一个问题是缺乏官方标准来文档化服务器提供的API或协议（存在几个竞争的规范）。因此，编写客户端的人必须依赖服务器开发者提供的纯文档，或者通过试验发现协议。我们这里的例子足够简单，不会遇到这个问题，但想象一下一个类中有20或30个方法的情况。
- en: The Spring Framework offers an API that is very similar to the JAX-RS API used
    here; if you are already using Spring, it may be simpler to use their annotations.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Spring框架提供了一个与此处使用的JAX-RS API非常相似的API；如果您已经在使用Spring，可能更简单使用它们的注解。
- en: 13.9 Network Logging
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 13.9 网络日志记录
- en: Problem
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: Your class is running inside a server container, and its debugging output is
    hard to obtain.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 您的类正在服务器容器中运行，其调试输出难以获得。
- en: Solution
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use a network-based logger like the Java Logging API (JUL), the Apache Logging
    Services Project’s `Log4j`, or the simple one shown here.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 使用像Java Logging API (JUL)、Apache Logging Services项目的`Log4j`或这里展示的简单网络日志记录器。
- en: Discussion
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Getting the debug output from a desktop client is fairly easy on most operating
    systems. But if the program you want to debug is running in a container like a
    servlet engine or an EJB server, it can be difficult to obtain debugging output,
    particularly if the container is running on a remote computer. It would be convenient
    if you could have your program send messages back to a program on your desktop
    machine for immediate display. Needless to say, it’s not that hard to do this
    with Java’s socket mechanism.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'Many logging APIs can handle this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Java has had for years a standard logging API JUL (discussed in [Recipe 13.12](#javacook-netserver-SECT-9))
    that talks to various logging mechanisms, including Unix `syslog`.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Apache Logging Services Project produces `Log4j`, which is used in many
    open source projects that require logging (see [Recipe 13.11](#javacook-netserver-SECT-8)).
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The Apache Jakart Commons Logging (JCL)](http://commons.apache.org/proper/commons-logging).
    Not discussed here; similar to the others.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SLF4J (Simple Logging Facade For Java, see [Recipe 13.10](#javacook-netserver-slf4j))
    is the newest and, as the name implies, a facade that can use the others.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And, before these became widely used, I wrote a small, simple API to handle
    this type of logging function. My `netlog` is not discussed here because it is
    preferable to use one of the standard logging mechanisms; its code is in the *logging*
    subdirectory of the *javasrc* repo if you want to exhume it.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The JDK logging API, `Log4j`, and `SFL4J` are more fully fleshed out and can
    write to such destinations as a file; an `OutputStream` or `Writer`; or a remote
    `Log4j`, Unix `syslog`, or Windows Event Log server.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: The program being debugged is the client from the logging API’s point of view—even
    though it may be running in a server-side container such as a web server or application
    server—because the network client is the program that initiates the connection.
    The program that runs on your desktop machine is the “server” program for sockets
    because it waits for a connection to come along.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: If you want to run any network-based logger reachable from any public network,
    you need to be more aware of security issues. One common form of attack is a simple
    denial-of-service (DoS), during which the attacker makes a lot of connections
    to your server in order to slow it down. If you are writing the log to disk, for
    example, the attacker could fill up your disk by sending lots of garbage. In common
    use, your log listener would be behind a firewall and not reachable from outside;
    but if this is not the case, beware of the DoS attack.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: 13.10 Setting Up SLF4J
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to use a logging API that lets you use any of the other logging APIs,
    for example, so that your code can be used in other projects without requiring
    them to switch logging APIs.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use SLF4J: get a `Logger` from the `LoggerFactory`, and use its various methods
    for logging.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using SLF4J requires only one JAR file to compile, *slf4j-api-1.x.y.jar* (where
    *x* and *y* will change over time). To actually get logging output, you need to
    add one of several implementation JARs to your runtime `CLASSPATH`, the simplest
    of which is *slf4j-simple-1.x.y.jar* (where *x* and *y* should match between the
    two files).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 SLF4J 仅需要一个 JAR 文件进行编译，*slf4j-api-1.x.y.jar*（其中 *x* 和 *y* 将随时间变化）。要实际获得日志输出，您需要将多个实现
    JAR 添加到运行时 `CLASSPATH`，其中最简单的是 *slf4j-simple-1.x.y.jar*（其中 *x* 和 *y* 应该在这两个文件之间匹配）。
- en: Once you’ve added those JAR files to your build script or on your `CLASSPATH`,
    you can get a `Logger` by calling `LoggerFactory.getLogger()`, passing either
    the string name of a class or package or just the current `Class` reference. Then
    call the logger’s logging methods. A simple example is in [Example 13-12](#javacook-netserver-slf4j-ex1).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦将这些 JAR 文件添加到构建脚本或您的 `CLASSPATH` 上，您可以通过调用 `LoggerFactory.getLogger()` 来获取
    `Logger`，传递类或包的字符串名称或当前 `Class` 引用。然后调用记录器的记录方法。一个简单的示例在 [Example 13-12](#javacook-netserver-slf4j-ex1)
    中。
- en: Example 13-12\. main/src/main/java/logging/Slf4jDemo.java
  id: totrans-149
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 13-12\. main/src/main/java/logging/Slf4jDemo.java
- en: '[PRE18]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: There are various methods used to log information at different levels of severity,
    which are shown in [Table 13-1](#javacook-netserver-TABLE-0).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 有各种方法用于记录不同严重程度的信息，这些方法显示在 [Table 13-1](#javacook-netserver-TABLE-0) 中。
- en: Table 13-1\. SLF4j logging methods
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Table 13-1\. SLF4j 记录方法
- en: '| Name | Meaning |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 含义 |'
- en: '| --- | --- |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| trace | Verbose debugging (disabled by default) |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| trace | 冗长的调试信息（默认禁用） |'
- en: '| debug | Verbose debugging |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| debug | 冗长的调试信息 |'
- en: '| info | Low-level informational message |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| info | 低级别信息消息 |'
- en: '| warn | Possible error |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| warn | 可能的错误 |'
- en: '| error | Serious error |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| error | 严重错误 |'
- en: 'One of the advantages of SLF4j over most of the other logging APIs is the avoidance
    of the dead string anti-pattern. In the use of many other logger APIs you may
    find code like the following:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: SLF4j 相对于大多数其他日志记录 API 的优势之一是避免了死字符串反模式。在使用许多其他记录器 API 时，您可能会发现以下代码：
- en: '[PRE19]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This can lead to a performance problem, in that the object’s `toString()` is
    implicitly called, and two string concatenations are performed, before we even
    know if the logger is going to use them! If this is in code that is called repeatedly,
    a lot of overhead can be wasted.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能会导致性能问题，因为隐式调用了对象的 `toString()`，并且执行了两次字符串连接，甚至在我们知道日志记录器是否要使用它们之前！如果这是重复调用的代码，可能会浪费大量开销。
- en: 'This led the other logging packages to offer code guards, based on logger methods
    that can find out very quickly if a logger is enabled, leading to code like the
    following:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致其他日志包提供了代码保护功能，基于能够非常快速地查找日志记录器是否启用的记录器方法，导致出现以下代码：
- en: '[PRE20]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This solves the performance problem but clutters the code! SLF4J’s solution
    is to use a mechanism similar to (but not quite compatible with) Java’s `MessageFormat`
    mechanism, as shown in [Example 13-13](#javacook-netserver-slf4j-ex1-ch16).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这解决了性能问题，但使代码混乱！SLF4J 的解决方案是使用类似于（但不完全兼容）Java 的 `MessageFormat` 机制，如 [Example 13-13](#javacook-netserver-slf4j-ex1-ch16)
    中所示。
- en: Example 13-13\. main/src/main/java/logging/Slf4jDemo2.java
  id: totrans-166
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 13-13\. main/src/main/java/logging/Slf4jDemo2.java
- en: '[PRE21]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Although this doesn’t demonstrate network logging, it is easy to accomplish
    that in conjunction with a logging implementation like Log4j or JUL (Java Util
    Logging, a standard part of the JDK), which allow you to provide configurable
    logging. `Log4j` is described in the next recipe.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这并不演示网络日志记录，但可以与 Log4j 或 JUL（Java Util Logging，JDK 的标准部分）等日志记录实现一起轻松实现，这些实现允许您提供可配置的日志记录。下一个配方中描述了
    `Log4j`。
- en: See Also
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The SLF4J website contains a [manual](http://www.slf4j.org/manual.html) that
    discusses the various `CLASSPATH` options. There are also some [Maven artifacts](http://mvnrepository.com/artifact/org.slf4j)
    for the various options.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: SLF4J 网站包含一个[手册](http://www.slf4j.org/manual.html)，讨论了各种 `CLASSPATH` 选项。还有一些[
    Maven artifact](http://mvnrepository.com/artifact/org.slf4j)提供了各种选项。
- en: 13.11 Network Logging with Log4j
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 13.11 使用 Log4j 进行网络日志记录
- en: Problem
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You wish to write log file messages using Log4j.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望使用 Log4j 写入日志文件消息。
- en: Solution
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Get a `Logger` and use its `log()` method or the convenience methods. Control
    logging by changing a properties file. Use the `org.apache.logging.log4j.net`
    package to make it network based.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 获取 `Logger` 并使用其 `log()` 方法或便利方法。通过更改属性文件来控制日志记录。使用 `org.apache.logging.log4j.net`
    包使其基于网络。
- en: Discussion
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Warning
  id: totrans-177
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: This recipe describes Version 2 of the Log4j API. Between Version 1 and Version
    2, there are changes to the package names, filenames, and the method used to obtain
    a logger. If you see code using, for example, `Logger.getLogger("class name")`,
    that code is written to the older API, which is no longer maintained (the Log4j
    website refers to Log4j 1.2, and versions up to 2.12, as “legacy”; we are using
    2.13 in this recipe). A good degree of compatibility is offered for code written
    to the 1.x API; see [*https://logging.apache.org/log4j/2.x/manual/compatibility.html*](https://logging.apache.org/log4j/2.x/manual/compatibility.html).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'Logging using Log4j is simple, convenient, and flexible. You need to get a
    `Logger` object from the static method `LogManager.getLogger()`, The `Logger`
    has public void methods (`debug()`, `info()`, `warn()`, `error()`, and `fatal()`),
    each of which takes one `Object` to be logged (and an optional `Throwable`). As
    with `System.out.println()`, if you pass in anything that is not a `String`, its
    `toString()` method is called. A generic logging method is also included:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `Level` class is defined in the Log4j 2 API. The standard levels are, in
    order, `DEBUG` < `INFO` < `WARN` < `ERROR` < `FATAL`. That is, debug messages
    are considered the least important, and fatal the most important. Each `Logger`
    has a level associated with it; messages whose level is less than the `Logger`’s
    level are silently discarded.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple application can log messages using these few statements:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If you compile and run this program with no *log4j2.properties* file, it does
    not produce any logging output (see the *log4j2demos* script in the source folder).
    We need to create a configuration file whose default name is *log4j2.properties*.
    You can also provide the logfile name via System Properties: `-Dlog4j​.configurationFile=URL`.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-185
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Log4j configuration is very flexible, and therefore very complex. Even their
    own documentation admits that “Trying to configure Log4j without understanding
    [the logging architecture] will lead to frustration.” See this [Apache website
    for full details on the logging configuration file location and format](https://logging.apache.org/log4j/2.x/manual/configuration.html).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: 'Every `Logger` has a `Level` to specify what level of messages to write. It
    will also have an `Appender`, which is the code that writes the messages out.
    A `ConsoleAppender` writes to `System.out`, of course; other loggers write to
    files, operating system–level loggers, and so on. A simple configuration file
    looks something like this:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This file gives the root logger a level of `DEBUG`, which causes it to write
    all messages. The config file also sets up an appender of `APPENDER1`, which is
    configured on the next few lines. Note that I didn’t have to refer to the `com.darwinsys
    Logger`. Because every `Logger` inherits from the root logger, a simple application
    needs to configure only the root logger. The properties file can also be an XML
    document, or you can write your own configuration parser (almost nobody does this).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件将根记录器的级别设置为`DEBUG`，这会导致它写入所有消息。配置文件还设置了一个名为`APPENDER1`的附加器，该附加器在接下来的几行上进行了配置。请注意，我不必引用`com.darwinsys
    Logger`。因为每个`Logger`都继承自根记录器，所以一个简单的应用程序只需要配置根记录器。属性文件也可以是XML文档，或者您可以编写自己的配置解析器（几乎没有人这样做）。
- en: Warning
  id: totrans-190
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: If the logging configuration file is not found, the default root logger defaults
    the root logger to `Level.ERROR`, so you will not see any output below the `ERROR`
    level.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找不到日志配置文件，则默认的根记录器将根记录器默认为`Level.ERROR`，因此您将看不到`ERROR`级别以下的任何输出。
- en: 'With the configuration file in place, the demonstration works better. Running
    this program (with the appropriate `CLASSPATH` as done in the scripts) produces
    this output:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 配置文件就位后，演示效果更好。运行此程序（使用脚本中所做的适当的`CLASSPATH`）会产生以下输出：
- en: '[PRE25]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: A common use of logging is to log a caught `Exception`, as shown in [Example 13-14](#javacook-netserver-EX-12).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 日志记录的常见用法是记录捕获的`Exception`，如[示例 13-14](#javacook-netserver-EX-12)所示。
- en: Example 13-14\. main/src/main/java/Log4JDemo2.java (Log4j—catching and logging)
  id: totrans-195
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 13-14。main/src/main/java/Log4JDemo2.java（Log4j—捕获和记录）
- en: '[PRE26]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'When run, `Log4JDemo2` produces the expected output:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时，`Log4JDemo2`产生预期的输出：
- en: '[PRE27]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Much of the flexibility of Log4j 2 stems from its use of external configuration
    files; you can enable or disable logging without recompiling the application.
    A properties file that eliminates most logging might have this entry:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: Log4j 2的灵活性很大程度上来自于其使用外部配置文件；您可以在不重新编译应用程序的情况下启用或禁用日志记录。消除大部分日志记录的属性文件可能包含以下条目：
- en: '[PRE28]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Only fatal error messages print; all levels less than that are ignored.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 只打印致命错误消息；所有比它低的级别都被忽略。
- en: 'To log from a client to a server on a remote machine, the `SocketAppender`
    can be used. There is also an `SmtpAppender` to send urgent notices via email.
    See [*https://logging.apache.org/log4j/2.x/manual/appenders.html*](https://logging.apache.org/log4j/2.x/manual/appenders.html)
    for details on all the supported Appenders. Here is *log4j2-network.properties*,
    the socket-based networking version of the configuration file:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 要从客户端记录到远程机器上的服务器，可以使用`SocketAppender`。还有一个`SmtpAppender`通过电子邮件发送紧急通知。有关所有受支持的附加器的详细信息，请参阅[*https://logging.apache.org/log4j/2.x/manual/appenders.html*](https://logging.apache.org/log4j/2.x/manual/appenders.html)。这是*log4j2-network.properties*，配置文件的基于套接字的网络版本：
- en: '[PRE29]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This file gets passed to the demo programs via a Java System Property in the
    `netdemos` script:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件通过`netdemos`脚本中的Java系统属性传递给演示程序：
- en: '[PRE30]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'When run with the *log4j2-network.properties* file, you have to arrange for
    a listener on the other end. On Unix systems the `nc` (or `netcat`) program will
    work fine:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时使用*log4j2-network.properties*文件，你需要在另一端安排一个监听器。在Unix系统上，`nc`（或`netcat`）程序可以正常工作：
- en: '[PRE31]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '`Netcat` option `-l` says to listen on the numbered port; `-k` tells it to
    keep listening, that is, to reopen the connection when the client closes it, as
    happens when each demo program exits.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`Netcat`选项`-l`表示监听编号端口；`-k`告诉它继续监听，也就是说，当客户端关闭连接时重新打开连接，就像每个演示程序退出时一样发生的情况。'
- en: There is a performance issue with some logging calls. Consider some expensive
    operation, like a `toString()` or two along with several string concatenations
    passed to a `Log.info()` call in an often-used piece of code. If this is placed
    into production with a higher logging level, all the work will be done but the
    resultant string will never be used. In older APIs we used to use “code guards,”
    methods like “isLoggerEnabled(Level),” to determine whether to bother creating
    the string. Nowadays, the preferred method is to create the string inside a lambda
    expression (see [Chapter 9](ch09.html#javacook-fp)). All the log methods have
    an overload that accepts a `Supplier` argument ([Example 13-15](#javacook-network-SECT8-log4jlambda)).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Example 13-15\. main/src/main/java/logging/Log4J2Lambda.java
  id: totrans-210
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This way the string operations will only be performed if needed: if the logger
    is operating at the `INFO` level it will call the `Supplier` and if not, it won’t
    do the expensive operation.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 'When run as part of the *log4j2demos* script, this prints:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: For more information on Log4j, visit its [main website](http://logging.apache.org/log4j).
    Log4j 2 is free software, distributed under the Apache Software Foundation license.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: 13.12 Network Logging with java.util.logging
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You wish to write logging messages using the Java logging mechanism.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Get a `Logger`, and use it to log your messages and/or exceptions.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Java Logging API (package `java.util.logging`) is similar to, and was obviously
    inspired by, the Log4j package. You acquire a `Logger` object by calling the static
    `Logger.getLogger()` with a descriptive `String`. You then use instance methods
    to write to the log; these methods include the following:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'As with Log4j, every `Logger` object has a given logging level, and messages
    below that level are silently discarded:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'As with Log4j, objects handle the writing of the log. Each logger has a `Handler`:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Each `Handler` has a `Formatter`, which formats a `LogRecord` for display. By
    providing your own `Formatter`, you have more control over how the information
    being passed into the log gets formatted.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Unlike Log4j, the Java SE logging mechanism has a default configuration, so
    [Example 13-16](#jullogdemojava) is a minimal logging example program.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Example 13-16\. main/src/main/java/logging/JulLogDemo.java
  id: totrans-230
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Running it prints the following:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: As with Log4j, one common use is in logging caught exceptions; the code for
    this is in [Example 13-17](#javacook-netserver-EX-13).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Example 13-17\. main/src/main/java/logging/JulLogDemo2.java (catching and logging
    an exception)
  id: totrans-235
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As with Log4j, `java.util.logging` accepts a lambda expression (and has since
    Java 8); see [Example 13-18](#javacook-network-sect8-jullambda).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: Example 13-18\. main/src/main/java/logging/JulLambdaDemo.java
  id: totrans-238
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: See Also
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A good general reference on this chapter’s topic is *[Java Network Programming](http://oreil.ly/java-network-prgamming)*
    by Elliotte Harold.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: 'The server side of any network mechanism is extremely sensitive to security
    issues. It is easy for one misconfigured or poorly written server program to compromise
    the security of an entire network! Of the many books on network security, two
    stand out: *Firewalls and Internet Security* by William R. Cheswick et al. (Addison-Wesley)
    and a series of books with *Hacking Exposed* in the title, the first in the series
    by Stuart McClure et al. (McGraw-Hill).'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 任何网络机制的服务器端都极其敏感于安全问题。一个配置错误或编写不佳的服务器程序很容易 compromise 整个网络的安全性！关于网络安全的许多书籍中，两本书显著：*Firewalls
    and Internet Security*，作者是William R. Cheswick等人（Addison-Wesley），以及系列书籍中标题为*Hacking
    Exposed*的第一本，作者是Stuart McClure等人（McGraw-Hill）。
- en: This completes my discussion of server-side Java using sockets. A chat server
    could be implemented using several technologies, such as RMI (Remote Methods Invocation),
    an HTTP web service, JMS (Java Message Service), and a Java Enterprise API that
    handles store-and-forward message processing. This is beyond the scope of this
    book, but there’s an example of an RMI chat server in the *chat* folder of the
    source distribution, and there’s an example of a JMS chat server in *[Java Message
    Service](http://shop.oreilly.com/product/9780596522056.do)* by Mark Richards et
    al. (O’Reilly).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我对使用套接字的服务器端Java的讨论。聊天服务器可以使用多种技术来实现，例如RMI（远程方法调用），HTTP Web服务，JMS（Java消息服务），以及处理存储转发消息处理的Java企业API。这超出了本书的范围，但在源代码分发的*chat*文件夹中有一个RMI聊天服务器的示例，还有一个JMS聊天服务器的示例在*[Java消息服务](http://shop.oreilly.com/product/9780596522056.do)*中，作者是Mark
    Richards等人（O'Reilly）。
- en: ^([1](ch13.html#idm45290642028248-marker)) You may not be able to pick just
    any port number for your own service, of course. Certain well-known port numbers
    are reserved for specific services and listed in your *services* file, such as
    22 for Secure Shell and 25 for SMTP. Also, on server-based operating systems,
    ports below 1024 are considered privileged ports and require root or administrator
    privilege to create. This was an early security mechanism; today, with zillions
    of single-user desktops connected to the internet, it provides little real security,
    but the restriction remains.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch13.html#idm45290642028248-marker)) 当然，你可能不能随意为自己的服务选择任何端口号。某些众所周知的端口号专门保留用于特定服务，并在你的*services*文件中列出，例如Secure
    Shell的22端口和SMTP的25端口。此外，在基于服务器的操作系统上，低于1024的端口被视为特权端口，需要root或管理员权限来创建。这是早期的安全机制；今天，随着无数单用户桌面连接到互联网，这种限制提供的实际安全性已经很小，但限制仍然存在。
- en: ^([2](ch13.html#idm45290641414168-marker)) Digital Equipment was absorbed by
    Compaq, which was then absorbed by HP, but the name remains `de` because the engineers
    who name such things don’t care for corporate mergers anyway.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch13.html#idm45290641414168-marker)) 数字设备被康柏吸收，随后被惠普吸收，但名称仍然是`de`，因为负责命名这类东西的工程师们并不关心企业并购。
- en: ^([3](ch13.html#idm45290640666504-marker)) There are some limits to how many
    threads you can have, which affect only very large, enterprise-scale servers.
    You can’t expect to have thousands of threads running in the standard Java runtime.
    For large, high-performance servers, you may wish to resort to native code (see
    [Recipe 18.6](ch18.html#javacook-otherlang-SECT-5)) using `select()` or `poll()`.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch13.html#idm45290640666504-marker)) 有一些限制影响着你可以拥有的线程数量，这只影响非常大型的企业级服务器。你不能期望在标准的Java运行时中运行成千上万的线程。对于大型高性能服务器，你可能希望使用本地代码（参见[Recipe
    18.6](ch18.html#javacook-otherlang-SECT-5)）使用`select()`或`poll()`。
