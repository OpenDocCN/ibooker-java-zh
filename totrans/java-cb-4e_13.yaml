- en: Chapter 13\. Server-Side Java
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 13.0 Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sockets form the underpinnings of almost all networking protocols. JDBC, RMI,
    CORBA, EJB, and the non-Java RPC (Remote Procedure Call) and NFS (Network File
    System) are all implemented by connecting various types of sockets together. Socket
    connections can be implemented in most any language, not just Java: C, C++, Perl,
    and Python are also popular, and many others are possible. A client or server
    written in any one of these languages can communicate with its opposite written
    in any of the other languages. Therefore, it’s worth taking a quick look at how
    the `ServerSocket` behaves, even if you wind up utilizing the higher-level services
    such as RMI, JDBC, CORBA, or EJB.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The discussion looks first at the `ServerSocket` itself, then at writing data
    over a socket in various ways. Finally, I show a complete implementation of a
    usable network server written in Java: the chat server from the client in the
    previous chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Most production work in server-side Java uses the Java Enterprise Edition (Java
    EE), recently transferred from Oracle to the Eclipse Software Foundation and renamed
    to Jakarta but widely referred to by the previous name (and occasionally by its
    very old name, “J2EE,” which was retired in 2005). Java EE provides scalability
    and support for building well-structured, multitiered distributed applications.
    EE provides the servlet framework; a servlet is a strategy object that can be
    installed into any standard Java EE web server. EE also provides two web view
    technologies: the original JSP (JavaServer Pages) and the newer, component-based
    JSF (JavaServer Faces). Finally, EE provides a number of other network-based services,
    including EJB3 remote access and Java Messaging Service (JMS). These are outside
    the scope of this book; they are covered in other books, such as Arun Gupta’s
    *[Java EE 7 Essentials: Enterprise Developer Handbook](http://shop.oreilly.com/product/0636920030614.do)*.
    This chapter is only for those who need or want to build their own server from
    the ground up.'
  prefs: []
  type: TYPE_NORMAL
- en: 13.1 Opening a Server Socket for Business
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to write a socket-based server.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a `ServerSocket` for the given port number.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `ServerSocket` represents the other end of a connection, the server that
    waits patiently for clients to come along and connect to it. You construct a `ServerSocket`
    with just the port number.^([1](ch13.html#idm45290642028248)) Because it doesn’t
    need to connect to another host, it doesn’t need a particular host’s address as
    the client socket constructor does.
  prefs: []
  type: TYPE_NORMAL
- en: Assuming the `ServerSocket` constructor doesn’t throw an exception, you’re in
    business. Your next step is to await client activity, which you do by calling
    `accept()`. This call blocks until a client connects to your server; at that point,
    the `accept()` returns to you a `Socket` object (not a `ServerSocket`) that is
    connected in both directions to the `ServerSocket` object on the client (or its
    equivalent, if written in another language). [Example 13-1](#javacook-netserver-EX-1)
    shows the code for a socket-based server.
  prefs: []
  type: TYPE_NORMAL
- en: Example 13-1\. main/src/main/java/network/Listen.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You would normally use the same socket for both reading and writing, as shown
    in the next few recipes.
  prefs: []
  type: TYPE_NORMAL
- en: You may want to listen only on a particular network interface. Though we tend
    to think of network addresses as computer addresses, the two are not the same.
    A network address is actually the address of a particular network card, or network
    interface connection, on a given computing device. A desktop computer, laptop,
    tablet, or mobile phone might have only a single interface, hence a single network
    address. But a large server machine might have two or more interfaces, usually
    when it is connected to several networks. A network router is a box, either special
    purpose (e.g., a Cisco router), or general purpose (e.g., a Unix host), that has
    interfaces on multiple networks *and* has both the capability and the administrative
    permission to forward packets from one network to another. A program running on
    such a server machine might want to provide services only to its inside network
    or its outside network. One way to accomplish this is by specifying the network
    interface to be listened on. Suppose you want to provide a different view of web
    pages for your intranet than you provide to outside customers. For security reasons,
    you probably wouldn’t run both these services on the same machine. But if you
    wanted to, you could do this by providing the network interface addresses as arguments
    to the `ServerSocket` constructor.
  prefs: []
  type: TYPE_NORMAL
- en: However, to use this form of the constructor, you don’t have the option of using
    a string for the network address’s name, as you did with the client socket; you
    must convert it to an `InetAddress` object. You also have to provide a backlog
    argument, which is the number of connections that can queue up to be accepted
    before clients are told that your server is too busy. The complete setup is shown
    in [Example 13-2](#javacook-netserver-EX-2).
  prefs: []
  type: TYPE_NORMAL
- en: Example 13-2\. main/src/main/java/network/ListenInside.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`InetAddress.getByName()` looks up the given hostname in a system-dependent
    way, referring to a configuration file in the */etc* or *\windows* directory,
    or to some kind of resolver such as the Domain Name System. Consult a good book
    on networking and system administration if you need to modify this data.'
  prefs: []
  type: TYPE_NORMAL
- en: 13.2 Finding Network Interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You wish to find out about the computer’s networking arrangements.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the `NetworkInterface` class.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every computer on a network has one or more “network interfaces.” On typical
    desktop machines, a network interface represents a network card or network port
    or some software network interface, such as the loopback interface. Each interface
    has an operating system–defined name. On most versions of Unix, these devices
    have a two- or three-character device driver name plus a digit (starting from
    0), for example, `eth0` or `en0` for the first Ethernet on systems that hide the
    details of the card manufacturer, or `de0` and `de1` for the first and second
    Digital Equipment^([2](ch13.html#idm45290641414168)) DC21x4x-based Ethernet card,
    `xl0` for a 3Com EtherLink XL, and so on. The loopback interface is almost invariably
    `lo0` on all Unix-like platforms.
  prefs: []
  type: TYPE_NORMAL
- en: So what? Most of the time this is of no consequence to you. If you have only
    one network connection, like a cable link to your ISP, you really don’t care.
    Where this matters is on a server, where you might need to find the address for
    a given network, for example. The `NetworkInterface` class lets you find out.
    It has static methods for listing the interfaces and other methods for finding
    the addresses associated with a given interface. The program in [Example 13-3](#javacook-netserver-EX-14)
    shows some examples of using this class. Running it prints the names of all the
    local interfaces. If you happen to be on a computer named *laptop*, it prints
    the machine’s network address; if not, you probably want to change it to accept
    the local computer’s name from the command line; this is left as an exercise for
    the reader.
  prefs: []
  type: TYPE_NORMAL
- en: Example 13-3\. main/src/main/java/network/NetworkInterfaceDemo.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 13.3 Returning a Response (String or Binary)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to write a string or binary data to the client.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The socket gives you an `InputStream` and an `OutputStream`. Use them.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The client socket examples in the previous chapter called the `getInputStream()`
    and `getOutputStream()` methods. These examples do the same. The main difference
    is that these ones get the socket from a `ServerSocket`’s `accept()` method. Another
    distinction is, by definition, that normally the server creates or modifies the
    data and sends it to the client. [Example 13-4](#javacook-netserver-EX-3) is a
    simple `Echo` server, which the `Echo` client of [Recipe 12.5](ch12.html#javacook-netclient-SECT-4)
    can connect to. This server handles one complete connection with a client, then
    goes back and does the `accept()` to wait for the next client.
  prefs: []
  type: TYPE_NORMAL
- en: Example 13-4\. main/src/main/java/network/EchoServer.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: To send a string across an arbitrary network connection, some authorities recommend
    sending both the carriage return and the newline character; many protocol specifications
    require that you do so. This explains the `\r\n` in the code. If the other end
    is a DOS program or a Telnet-like program, it may be expecting both characters.
    On the other hand, if you are writing both ends, you can simply use `println()`—followed
    always by an explicit `flush()` before you read—to prevent the deadlock of having
    both ends trying to read with one end’s data still in the `PrintWriter`’s buffer!
  prefs: []
  type: TYPE_NORMAL
- en: 'If you need to process binary data, use the data streams from `java.io` instead
    of the readers/writers. I need a server for the `DaytimeBinary` program of [Recipe
    12.6](ch12.html#javacook-netclient-SECT-5). In operation, it should look like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Well, it happens that I have such a program in my arsenal, so I present it in
    [Example 13-5](#javacook-netserver-EX-4). Note that it directly uses certain public
    constants defined in the client class. Normally these are defined in the server
    class and used by the client, but I wanted to present the client code first.
  prefs: []
  type: TYPE_NORMAL
- en: Example 13-5\. main/src/main/java/network/DaytimeServer.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 13.4 Returning Object Information Across a Network Connection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to return an object across a network connection.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create the object you need, and write it using an `ObjectOutputStream` created
    on top of the socket’s output stream.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The program in [Example 12-7](ch12.html#javacook-netclient-EX-7) in the previous
    chapter reads a `Date` object over an `ObjectInputStream`. [Example 13-6](#javacook-netserver-EX-5),
    the `DaytimeObjectServer` (the other end of that process), is a program that constructs
    a `Date` object each time it’s connected to and returns it to the client.
  prefs: []
  type: TYPE_NORMAL
- en: Example 13-6\. main/src/main/java/network/DaytimeObjectServer.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 13.5 Handling Multiple Clients
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your server needs to handle multiple clients.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use a thread for each.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the C world, several mechanisms allow a server to handle multiple clients.
    One is to use a special system call `select()` or `poll()`, which notifies the
    server when any of a set of file/socket descriptors is ready to read, ready to
    write, or has an error. By including its rendezvous socket (equivalent to our
    `ServerSocket`) in this list, the C-based server can read from any of a number
    of clients in any order. Java does not provide this call, because it is not readily
    implementable on some Java platforms. Instead, Java uses the general-purpose `Thread`
    mechanism, as described in [Chapter 16](ch16.html#javacook-threads) (threads are
    now commonplace in many programming languages, though not always under that name).
    Each time the code accepts a new connection from the `ServerSocket`, it immediately
    constructs and starts a new thread object to process that client.^([3](ch13.html#idm45290640666504))
  prefs: []
  type: TYPE_NORMAL
- en: 'The Java code to implement accepting on a socket is pretty simple, apart from
    having to catch `IOException`s:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'To use a thread, you must either subclass `Thread` or implement `Runnable`.
    The `Handler` class must be a subclass of `Thread` for this code to work as written;
    if `Handler` instead implemented the `Runnable` interface, the code would pass
    an instance of the `Runnable` into the constructor for `Thread`, as in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'But as written, `Handler` is constructed using the normal socket returned by
    `accept()` and normally calls the socket’s `getInputStream()` and `getOutputStream()`
    methods and holds its conversation in the usual way. I’ll present a full implementation,
    a threaded echo client. First, a session showing it in use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here I connected to the server once with my `EchoClient` program and, while
    still connected, called it up again (and again) with an operating system–provided
    Telnet client. The server communicated with all the clients concurrently, sending
    the answers from the first client back to the first client, and the data from
    the second client back to the second client. In short, it works. I ended the sessions
    with the end-of-file character in the program and used the normal disconnect mechanism
    from the Telnet client. [Example 13-7](#javacook-netserver-EX-6-ch16) is the code
    for the server.
  prefs: []
  type: TYPE_NORMAL
- en: Example 13-7\. main/src/main/java/network/EchoServerThreaded.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: A lot of short transactions can degrade performance, because each client causes
    the creation of a new threaded object. If you know or can reliably predict the
    degree of concurrency that is needed, an alternative paradigm involves the precreation
    of a fixed number of threads. But then how do you control their access to the
    `ServerSocket`? A look at the `ServerSocket` class documentation reveals that
    the `accept()` method is not synchronized, meaning that any number of threads
    can call the method concurrently. This could cause bad things to happen. So I
    use the `synchronized` keyword around this call to ensure that only one client
    runs in it at a time, because it updates global data. When no clients are connected,
    you will have one (randomly selected) thread running in the `ServerSocket` object’s
    `accept()` method, waiting for a connection, plus *n-1* threads waiting for the
    first thread to return from the method. As soon as the first thread manages to
    accept a connection, it goes off and holds its conversation, releasing its lock
    in the process so that another randomly chosen thread is allowed into the `accept()`
    method. Each thread’s `run()` method has an infinite loop beginning with an `accept()`
    and then holding the conversation. The result is that client connections can get
    started more quickly, at a cost of slightly greater server startup time. Doing
    it this way also avoids the overhead of constructing a new `Handler` or `Thread`
    object each time a request comes along. This general approach is similar to what
    the popular Apache web server does, although it normally creates a number or pool
    of identical processes (instead of threads) to handle client connections. Accordingly,
    I have modified the `EchoServerThreaded` class shown in [Example 13-7](#javacook-netserver-EX-6-ch16)
    to work this way, as you can see in [Example 13-8](#javacook-netserver-EX-7).
  prefs: []
  type: TYPE_NORMAL
- en: Example 13-8\. main/src/main/java/network/EchoServerThreaded2.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: It is quite possible to implement a server of this sort with NIO, the “new”
    (back in J2SE 1.4) I/O package. However, the code to do so outweighs anything
    in this chapter, and it is fraught with issues. There are several good tutorials
    on the internet for the person who truly needs the performance gain of using NIO
    to manage server connections.
  prefs: []
  type: TYPE_NORMAL
- en: 13.6 Serving the HTTP Protocol
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to serve up a protocol such as HTTP.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a `ServerSocket` and write some code that speaks the particular protocol.
    Or, better, use a Java-powered web server such as Apache Tomcat or a Java Enterprise
    Edition (Java EE) server such as JBoss WildFly.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can implement your own HTTP protocol server for very simple applications,
    which we’ll do here. For any serious development, you want to use the Java Enterprise
    Edition; see the note at the beginning of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: This example just constructs a `ServerSocket` and listens on it. When connections
    come in, they are replied to using the HTTP protocol. So it is somewhat more involved
    than the simple `Echo` server presented in [Recipe 13.3](#javacook-netserver-SECT-2).
    However, it’s not a complete web server; the filename in the request is ignored,
    and a standard message is always returned. This is thus a *very* simple web server;
    it follows only the bare minimum of the HTTP protocol needed to send its response
    back. For a real web server written in Java, get Tomcat from the [Apache Tomcat
    website](http://tomcat.apache.org) or any of the Jakarta/JavaEE Application Servers.
    The code shown in [Example 13-9](#javacook-netserver-EX-8), however, is enough
    to understand how to build a simple server that responds to requests using a protocol.
  prefs: []
  type: TYPE_NORMAL
- en: Example 13-9\. main/src/main/java/network/WebServer0.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 13.7 Securing a Web Server with SSL and JSSE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to protect your network traffic from prying eyes or malicious modification
    while the data is in transit.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the Java Secure Socket Extension, JSSE, to encrypt your traffic.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JSSE provides services at a number of levels, but the simplest way to use it
    is simply to get your `ServerSocket` from an `SSLServerSocketFactory` instead
    of using the `ServerSocket` constructor directly. SSL is the Secure Sockets Layer;
    a revised version is known as TLS. It is specifically for use on the web. To secure
    other protocols, you’d have to use a different form of the `SocketFactory`.
  prefs: []
  type: TYPE_NORMAL
- en: The `SSLServerSocketFactory` returns a `ServerSocket` that is set up to do SSL
    encryption. [Example 13-10](#javacook-netserver-EX-9) uses this technique to override
    the `getServerSocket()` method in [Recipe 13.6](#javacook-netserver-SECT-5). If
    you’re thinking this is too easy, you’re wrong!
  prefs: []
  type: TYPE_NORMAL
- en: Example 13-10\. main/src/main/java/network/JSSEWebServer0
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'That is, indeed, all the Java code one needs to write. You do have to set up
    an SSL Certificate. For demonstration purposes, this can be a self-signed certificate;
    the steps in [*https://darwinsys.com/java/selfsigncert.html*](https://darwinsys.com/java/selfsigncert.html)
    (steps 1–4) will suffice. You have to tell the JSSE layer where to find your keystore:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The typical client browser raises its eyebrows at a self-signed certificate
    (see [Figure 13-1](#javacook-netserver-FIG-1)), but, if the user okays it, will
    accept the certificate.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 13-2](#javacook-netserver-FIG-2) shows the output of the simple `WebServer0`
    being displayed over the HTTPS protocol (notice the padlock in the lower-right
    corner).'
  prefs: []
  type: TYPE_NORMAL
- en: '![jcb4 1301](assets/jcb4_1301.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13-1\. Browser caution
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '![jcb4 1302](assets/jcb4_1302.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13-2\. With encryption
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JSSE can do much more than encrypt web server traffic; this is, however, sometimes
    seen as its most exciting application. For more information on JSSE, see [the
    Sun website](http://java.sun.com/products/jsse) or *[Java Security](http://shop.oreilly.com/product/9780596001575.do)*
    by Scott Oaks (O’Reilly).
  prefs: []
  type: TYPE_NORMAL
- en: 13.8 Creating a REST Service with JAX-RS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to implement a RESTful server by using the provided Java EE/Jakarta
    EE APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use JAX-RS annotations on a class that provides a service; install it in an
    enterprise application server.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This operation consists of both coding and configuration.
  prefs: []
  type: TYPE_NORMAL
- en: The coding steps consist of creating a class that extends the JAX-RS `Application`
    class and adding annotations to a class that provides a service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a minimal `Application` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 13-11](#javacook-netserver-EX-REST) is a “Hello, World"–type service
    class with the annotations needed to make it a service class and to have three
    sample methods.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 13-11\. restdemo/src/main/java/rest/RestService.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Now the class must be deployed. If we have created a proper Maven project structure
    (see [Recipe 1.7](ch01.html#javacook-getstarted-maven)) and have provided an application-server-specific
    Maven plug-in, and our development server is running, we can use some variation
    on `mvn deploy`. In the present case I have set this up, in the *rest* subdirectory,
    for deployment to WildFly, a Java Enterprise server from the JBoss open source
    community (though somewhat dated), funded by RedHat Inc. I need only say `mvn
    wildfly:deploy` to have the application compiled, packaged, and deployed to my
    server.
  prefs: []
  type: TYPE_NORMAL
- en: For deploying REST services as a microservice based on Eclipse MicroProfile,
    you may wish to investigate the [Quarkus Framework](https://quarkus.io).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the service is deployed, you can explore it interactively with a browser
    or, for simple GET requests, a Telnet client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: An issue with REST is that there is not an official standard for documenting
    the API or protocol offered by a server (there are several competing specifications).
    So people writing clients must either rely on plain documentation offered by the
    server’s developers, or use trial and error to discover the protocol. Our example
    here is simple enough that we don’t have this problem, but imagine a class with
    20 or 30 methods in it.
  prefs: []
  type: TYPE_NORMAL
- en: The Spring Framework offers an API that is very similar to the JAX-RS API used
    here; if you are already using Spring, it may be simpler to use their annotations.
  prefs: []
  type: TYPE_NORMAL
- en: 13.9 Network Logging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your class is running inside a server container, and its debugging output is
    hard to obtain.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use a network-based logger like the Java Logging API (JUL), the Apache Logging
    Services Project’s `Log4j`, or the simple one shown here.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Getting the debug output from a desktop client is fairly easy on most operating
    systems. But if the program you want to debug is running in a container like a
    servlet engine or an EJB server, it can be difficult to obtain debugging output,
    particularly if the container is running on a remote computer. It would be convenient
    if you could have your program send messages back to a program on your desktop
    machine for immediate display. Needless to say, it’s not that hard to do this
    with Java’s socket mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many logging APIs can handle this:'
  prefs: []
  type: TYPE_NORMAL
- en: Java has had for years a standard logging API JUL (discussed in [Recipe 13.12](#javacook-netserver-SECT-9))
    that talks to various logging mechanisms, including Unix `syslog`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Apache Logging Services Project produces `Log4j`, which is used in many
    open source projects that require logging (see [Recipe 13.11](#javacook-netserver-SECT-8)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The Apache Jakart Commons Logging (JCL)](http://commons.apache.org/proper/commons-logging).
    Not discussed here; similar to the others.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SLF4J (Simple Logging Facade For Java, see [Recipe 13.10](#javacook-netserver-slf4j))
    is the newest and, as the name implies, a facade that can use the others.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And, before these became widely used, I wrote a small, simple API to handle
    this type of logging function. My `netlog` is not discussed here because it is
    preferable to use one of the standard logging mechanisms; its code is in the *logging*
    subdirectory of the *javasrc* repo if you want to exhume it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The JDK logging API, `Log4j`, and `SFL4J` are more fully fleshed out and can
    write to such destinations as a file; an `OutputStream` or `Writer`; or a remote
    `Log4j`, Unix `syslog`, or Windows Event Log server.
  prefs: []
  type: TYPE_NORMAL
- en: The program being debugged is the client from the logging API’s point of view—even
    though it may be running in a server-side container such as a web server or application
    server—because the network client is the program that initiates the connection.
    The program that runs on your desktop machine is the “server” program for sockets
    because it waits for a connection to come along.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to run any network-based logger reachable from any public network,
    you need to be more aware of security issues. One common form of attack is a simple
    denial-of-service (DoS), during which the attacker makes a lot of connections
    to your server in order to slow it down. If you are writing the log to disk, for
    example, the attacker could fill up your disk by sending lots of garbage. In common
    use, your log listener would be behind a firewall and not reachable from outside;
    but if this is not the case, beware of the DoS attack.
  prefs: []
  type: TYPE_NORMAL
- en: 13.10 Setting Up SLF4J
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to use a logging API that lets you use any of the other logging APIs,
    for example, so that your code can be used in other projects without requiring
    them to switch logging APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use SLF4J: get a `Logger` from the `LoggerFactory`, and use its various methods
    for logging.'
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using SLF4J requires only one JAR file to compile, *slf4j-api-1.x.y.jar* (where
    *x* and *y* will change over time). To actually get logging output, you need to
    add one of several implementation JARs to your runtime `CLASSPATH`, the simplest
    of which is *slf4j-simple-1.x.y.jar* (where *x* and *y* should match between the
    two files).
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve added those JAR files to your build script or on your `CLASSPATH`,
    you can get a `Logger` by calling `LoggerFactory.getLogger()`, passing either
    the string name of a class or package or just the current `Class` reference. Then
    call the logger’s logging methods. A simple example is in [Example 13-12](#javacook-netserver-slf4j-ex1).
  prefs: []
  type: TYPE_NORMAL
- en: Example 13-12\. main/src/main/java/logging/Slf4jDemo.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: There are various methods used to log information at different levels of severity,
    which are shown in [Table 13-1](#javacook-netserver-TABLE-0).
  prefs: []
  type: TYPE_NORMAL
- en: Table 13-1\. SLF4j logging methods
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Meaning |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| trace | Verbose debugging (disabled by default) |'
  prefs: []
  type: TYPE_TB
- en: '| debug | Verbose debugging |'
  prefs: []
  type: TYPE_TB
- en: '| info | Low-level informational message |'
  prefs: []
  type: TYPE_TB
- en: '| warn | Possible error |'
  prefs: []
  type: TYPE_TB
- en: '| error | Serious error |'
  prefs: []
  type: TYPE_TB
- en: 'One of the advantages of SLF4j over most of the other logging APIs is the avoidance
    of the dead string anti-pattern. In the use of many other logger APIs you may
    find code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This can lead to a performance problem, in that the object’s `toString()` is
    implicitly called, and two string concatenations are performed, before we even
    know if the logger is going to use them! If this is in code that is called repeatedly,
    a lot of overhead can be wasted.
  prefs: []
  type: TYPE_NORMAL
- en: 'This led the other logging packages to offer code guards, based on logger methods
    that can find out very quickly if a logger is enabled, leading to code like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This solves the performance problem but clutters the code! SLF4J’s solution
    is to use a mechanism similar to (but not quite compatible with) Java’s `MessageFormat`
    mechanism, as shown in [Example 13-13](#javacook-netserver-slf4j-ex1-ch16).
  prefs: []
  type: TYPE_NORMAL
- en: Example 13-13\. main/src/main/java/logging/Slf4jDemo2.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Although this doesn’t demonstrate network logging, it is easy to accomplish
    that in conjunction with a logging implementation like Log4j or JUL (Java Util
    Logging, a standard part of the JDK), which allow you to provide configurable
    logging. `Log4j` is described in the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The SLF4J website contains a [manual](http://www.slf4j.org/manual.html) that
    discusses the various `CLASSPATH` options. There are also some [Maven artifacts](http://mvnrepository.com/artifact/org.slf4j)
    for the various options.
  prefs: []
  type: TYPE_NORMAL
- en: 13.11 Network Logging with Log4j
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You wish to write log file messages using Log4j.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Get a `Logger` and use its `log()` method or the convenience methods. Control
    logging by changing a properties file. Use the `org.apache.logging.log4j.net`
    package to make it network based.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This recipe describes Version 2 of the Log4j API. Between Version 1 and Version
    2, there are changes to the package names, filenames, and the method used to obtain
    a logger. If you see code using, for example, `Logger.getLogger("class name")`,
    that code is written to the older API, which is no longer maintained (the Log4j
    website refers to Log4j 1.2, and versions up to 2.12, as “legacy”; we are using
    2.13 in this recipe). A good degree of compatibility is offered for code written
    to the 1.x API; see [*https://logging.apache.org/log4j/2.x/manual/compatibility.html*](https://logging.apache.org/log4j/2.x/manual/compatibility.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Logging using Log4j is simple, convenient, and flexible. You need to get a
    `Logger` object from the static method `LogManager.getLogger()`, The `Logger`
    has public void methods (`debug()`, `info()`, `warn()`, `error()`, and `fatal()`),
    each of which takes one `Object` to be logged (and an optional `Throwable`). As
    with `System.out.println()`, if you pass in anything that is not a `String`, its
    `toString()` method is called. A generic logging method is also included:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `Level` class is defined in the Log4j 2 API. The standard levels are, in
    order, `DEBUG` < `INFO` < `WARN` < `ERROR` < `FATAL`. That is, debug messages
    are considered the least important, and fatal the most important. Each `Logger`
    has a level associated with it; messages whose level is less than the `Logger`’s
    level are silently discarded.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple application can log messages using these few statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'If you compile and run this program with no *log4j2.properties* file, it does
    not produce any logging output (see the *log4j2demos* script in the source folder).
    We need to create a configuration file whose default name is *log4j2.properties*.
    You can also provide the logfile name via System Properties: `-Dlog4j​.configurationFile=URL`.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Log4j configuration is very flexible, and therefore very complex. Even their
    own documentation admits that “Trying to configure Log4j without understanding
    [the logging architecture] will lead to frustration.” See this [Apache website
    for full details on the logging configuration file location and format](https://logging.apache.org/log4j/2.x/manual/configuration.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Every `Logger` has a `Level` to specify what level of messages to write. It
    will also have an `Appender`, which is the code that writes the messages out.
    A `ConsoleAppender` writes to `System.out`, of course; other loggers write to
    files, operating system–level loggers, and so on. A simple configuration file
    looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This file gives the root logger a level of `DEBUG`, which causes it to write
    all messages. The config file also sets up an appender of `APPENDER1`, which is
    configured on the next few lines. Note that I didn’t have to refer to the `com.darwinsys
    Logger`. Because every `Logger` inherits from the root logger, a simple application
    needs to configure only the root logger. The properties file can also be an XML
    document, or you can write your own configuration parser (almost nobody does this).
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If the logging configuration file is not found, the default root logger defaults
    the root logger to `Level.ERROR`, so you will not see any output below the `ERROR`
    level.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the configuration file in place, the demonstration works better. Running
    this program (with the appropriate `CLASSPATH` as done in the scripts) produces
    this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: A common use of logging is to log a caught `Exception`, as shown in [Example 13-14](#javacook-netserver-EX-12).
  prefs: []
  type: TYPE_NORMAL
- en: Example 13-14\. main/src/main/java/Log4JDemo2.java (Log4j—catching and logging)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'When run, `Log4JDemo2` produces the expected output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Much of the flexibility of Log4j 2 stems from its use of external configuration
    files; you can enable or disable logging without recompiling the application.
    A properties file that eliminates most logging might have this entry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Only fatal error messages print; all levels less than that are ignored.
  prefs: []
  type: TYPE_NORMAL
- en: 'To log from a client to a server on a remote machine, the `SocketAppender`
    can be used. There is also an `SmtpAppender` to send urgent notices via email.
    See [*https://logging.apache.org/log4j/2.x/manual/appenders.html*](https://logging.apache.org/log4j/2.x/manual/appenders.html)
    for details on all the supported Appenders. Here is *log4j2-network.properties*,
    the socket-based networking version of the configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This file gets passed to the demo programs via a Java System Property in the
    `netdemos` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'When run with the *log4j2-network.properties* file, you have to arrange for
    a listener on the other end. On Unix systems the `nc` (or `netcat`) program will
    work fine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '`Netcat` option `-l` says to listen on the numbered port; `-k` tells it to
    keep listening, that is, to reopen the connection when the client closes it, as
    happens when each demo program exits.'
  prefs: []
  type: TYPE_NORMAL
- en: There is a performance issue with some logging calls. Consider some expensive
    operation, like a `toString()` or two along with several string concatenations
    passed to a `Log.info()` call in an often-used piece of code. If this is placed
    into production with a higher logging level, all the work will be done but the
    resultant string will never be used. In older APIs we used to use “code guards,”
    methods like “isLoggerEnabled(Level),” to determine whether to bother creating
    the string. Nowadays, the preferred method is to create the string inside a lambda
    expression (see [Chapter 9](ch09.html#javacook-fp)). All the log methods have
    an overload that accepts a `Supplier` argument ([Example 13-15](#javacook-network-SECT8-log4jlambda)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 13-15\. main/src/main/java/logging/Log4J2Lambda.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This way the string operations will only be performed if needed: if the logger
    is operating at the `INFO` level it will call the `Supplier` and if not, it won’t
    do the expensive operation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When run as part of the *log4j2demos* script, this prints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: For more information on Log4j, visit its [main website](http://logging.apache.org/log4j).
    Log4j 2 is free software, distributed under the Apache Software Foundation license.
  prefs: []
  type: TYPE_NORMAL
- en: 13.12 Network Logging with java.util.logging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You wish to write logging messages using the Java logging mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Get a `Logger`, and use it to log your messages and/or exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Java Logging API (package `java.util.logging`) is similar to, and was obviously
    inspired by, the Log4j package. You acquire a `Logger` object by calling the static
    `Logger.getLogger()` with a descriptive `String`. You then use instance methods
    to write to the log; these methods include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'As with Log4j, every `Logger` object has a given logging level, and messages
    below that level are silently discarded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'As with Log4j, objects handle the writing of the log. Each logger has a `Handler`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Each `Handler` has a `Formatter`, which formats a `LogRecord` for display. By
    providing your own `Formatter`, you have more control over how the information
    being passed into the log gets formatted.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike Log4j, the Java SE logging mechanism has a default configuration, so
    [Example 13-16](#jullogdemojava) is a minimal logging example program.
  prefs: []
  type: TYPE_NORMAL
- en: Example 13-16\. main/src/main/java/logging/JulLogDemo.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Running it prints the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: As with Log4j, one common use is in logging caught exceptions; the code for
    this is in [Example 13-17](#javacook-netserver-EX-13).
  prefs: []
  type: TYPE_NORMAL
- en: Example 13-17\. main/src/main/java/logging/JulLogDemo2.java (catching and logging
    an exception)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: As with Log4j, `java.util.logging` accepts a lambda expression (and has since
    Java 8); see [Example 13-18](#javacook-network-sect8-jullambda).
  prefs: []
  type: TYPE_NORMAL
- en: Example 13-18\. main/src/main/java/logging/JulLambdaDemo.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A good general reference on this chapter’s topic is *[Java Network Programming](http://oreil.ly/java-network-prgamming)*
    by Elliotte Harold.
  prefs: []
  type: TYPE_NORMAL
- en: 'The server side of any network mechanism is extremely sensitive to security
    issues. It is easy for one misconfigured or poorly written server program to compromise
    the security of an entire network! Of the many books on network security, two
    stand out: *Firewalls and Internet Security* by William R. Cheswick et al. (Addison-Wesley)
    and a series of books with *Hacking Exposed* in the title, the first in the series
    by Stuart McClure et al. (McGraw-Hill).'
  prefs: []
  type: TYPE_NORMAL
- en: This completes my discussion of server-side Java using sockets. A chat server
    could be implemented using several technologies, such as RMI (Remote Methods Invocation),
    an HTTP web service, JMS (Java Message Service), and a Java Enterprise API that
    handles store-and-forward message processing. This is beyond the scope of this
    book, but there’s an example of an RMI chat server in the *chat* folder of the
    source distribution, and there’s an example of a JMS chat server in *[Java Message
    Service](http://shop.oreilly.com/product/9780596522056.do)* by Mark Richards et
    al. (O’Reilly).
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch13.html#idm45290642028248-marker)) You may not be able to pick just
    any port number for your own service, of course. Certain well-known port numbers
    are reserved for specific services and listed in your *services* file, such as
    22 for Secure Shell and 25 for SMTP. Also, on server-based operating systems,
    ports below 1024 are considered privileged ports and require root or administrator
    privilege to create. This was an early security mechanism; today, with zillions
    of single-user desktops connected to the internet, it provides little real security,
    but the restriction remains.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch13.html#idm45290641414168-marker)) Digital Equipment was absorbed by
    Compaq, which was then absorbed by HP, but the name remains `de` because the engineers
    who name such things don’t care for corporate mergers anyway.
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch13.html#idm45290640666504-marker)) There are some limits to how many
    threads you can have, which affect only very large, enterprise-scale servers.
    You can’t expect to have thousands of threads running in the standard Java runtime.
    For large, high-performance servers, you may wish to resort to native code (see
    [Recipe 18.6](ch18.html#javacook-otherlang-SECT-5)) using `select()` or `poll()`.
  prefs: []
  type: TYPE_NORMAL
