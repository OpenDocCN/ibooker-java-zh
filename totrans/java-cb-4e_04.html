<html><head></head><body><section data-pdf-bookmark="Chapter 4. Pattern Matching with Regular Expressions" data-type="chapter" epub:type="chapter"><div class="chapter" id="javacook-regex">&#13;
<h1><span class="label">Chapter 4. </span>Pattern Matching with Regular Expressions</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="4.0 Introduction" data-type="sect1"><div class="sect1" id="javacook-regex-intro">&#13;
<h1>4.0 Introduction</h1>&#13;
&#13;
<p><a data-primary="pattern matching" data-type="indexterm" id="pm_ch"/><a data-primary="pattern matching" data-secondary="with regular expressions" data-type="indexterm" id="pm_re"/><a data-primary="regular expressions (regex)" data-secondary="pattern matching with" data-type="indexterm" id="re_pm"/>Suppose you have been on the internet for a few years and have been faithful about saving all your correspondence, just in case you (or your lawyers, or the prosecution) need a copy. The result is that you have a 5 GB disk partition dedicated to saved mail. Let’s further suppose that you remember that somewhere in there is an email message from someone named Angie or Anjie. Or was it Angy? But you don’t remember what you called it or where you stored it. Obviously, you have to look for it.</p>&#13;
&#13;
<p>But while some of you go and try to open up all 15,000,000 documents in a word processor, I’ll just find it with one simple command. Any system that provides regular expression support allows me to search for the pattern in several ways. The simplest to understand is:</p>&#13;
&#13;
<pre data-type="programlisting">Angie|Anjie|Angy</pre>&#13;
&#13;
<p>which you can probably guess means just to search for any of the variations. A more concise form (more thinking, less typing) is:</p>&#13;
&#13;
<pre data-type="programlisting">An[^ dn]</pre>&#13;
&#13;
<p>The syntax will become clear as we go through this chapter. Briefly, the “A” and the “n” match themselves, in effect finding words that begin with “An”, while the cryptic <code>[^ dn]</code> requires the “An” to be followed by a character other than (<em>^</em> means <em>not</em> in this context) a space (to eliminate the very common English word “an” at the start of a sentence) or “d” (to eliminate the common word “and”) or “n” (to eliminate “Anne,” “Announcing,” etc.). Has your word processor gotten past its splash screen yet? Well, it doesn’t matter, because I’ve already found the missing file. To find the answer, I just typed this command:</p>&#13;
&#13;
<pre data-type="programlisting">grep 'An[^ dn]' *</pre>&#13;
&#13;
<p><a data-primary="regular expressions (regex)" data-secondary="about" data-type="indexterm" id="idm45290687175784"/><em>Regular expressions</em>, or <em>regexes</em> for short, provide a concise and precise specification of patterns to be matched in text.&#13;
One good way to think of regular expressions is as a little language&#13;
for matching patterns of characters in text contained in strings.&#13;
A regular expression API is an&#13;
<a href="https://en.wikipedia.org/wiki/Interpreter_(computing)">interpreter</a>&#13;
for matching regular expressions.</p>&#13;
&#13;
<p>As another example of the power of regular expressions, consider the problem of bulk-updating hundreds of files. When I started with Java, the syntax for declaring array references was <code>baseType arrayVariableName[]</code>. For example, a method with an array argument, such as every program’s main method, was commonly written like this:</p>&#13;
&#13;
<pre data-type="programlisting">public static void main(String args[]) {</pre>&#13;
&#13;
<p>But as time went by, it became clear to the stewards of the Java language that it would be better to write it as <code>baseType[] arrayVariableName</code>, like this:</p>&#13;
&#13;
<pre data-type="programlisting">public static void main(String[] args) {</pre>&#13;
&#13;
<p>This is better Java style because it associates the “array-ness” of the type with the type&#13;
itself, rather than with the local argument name, and the compiler still accepts both modes.&#13;
I wanted to change all occurrences of <code>main</code> written the old way to the new way. I used&#13;
the pattern <em><code>main(String [a-z]</code></em> with the <em>grep</em> utility described earlier to find the&#13;
names of all the files containing old-style main declarations (i.e., <code>main(String</code>&#13;
followed by a space and a name character rather than an open square bracket). I then used&#13;
another regex-based Unix tool, the stream editor <em>sed</em>, in a little shell script to change&#13;
all occurrences in those files from <em><code>main(String *([a-z][a-z]*)[]</code></em> to&#13;
<em><code>main(String[] $1</code></em> (the regex syntax used here is discussed later in this chapter). Again,&#13;
the regex-based approach was orders of magnitude faster than doing it interactively, even&#13;
using a reasonably powerful editor such as <code>vi</code> or <code>emacs</code>, let alone trying to use a&#13;
graphical word processor.</p>&#13;
&#13;
<p>Historically, the syntax of regexes has changed as they get incorporated into more tools and more languages, so the exact syntax in the previous examples is not exactly what you’d use in Java, but it does convey the conciseness and power of the regex mechanism.<a data-primary="grep" data-type="indexterm" id="idm45290687163256"/><a data-primary="Windows" data-secondary="grep" data-type="indexterm" id="idm45290687162552"/><a data-primary="CygWin" data-type="indexterm" id="idm45290687161608"/><a data-primary="GnuWin32" data-type="indexterm" id="idm45290687160936"/><a data-primary="findstr command" data-type="indexterm" id="idm45290687160264"/><sup><a data-type="noteref" href="ch04.html#idm45290687159592" id="idm45290687159592-marker">1</a></sup></p>&#13;
&#13;
<p>As a third example, consider parsing an Apache web server logfile, where some fields are delimited with quotes, others with square brackets, and others with spaces. <span class="keep-together">Writing</span> ad hoc code to parse this is messy in any language, but a well-crafted regex can break the line into all its constituent fields in one operation (this example is developed in <a data-type="xref" href="#javacook-regex-SECT-10">Recipe 4.10</a>).</p>&#13;
&#13;
<p>These same time gains can be had by Java developers.&#13;
Regular expression support has been in the standard Java runtime for ages&#13;
and is well integrated (e.g., there are regex methods in&#13;
the standard class <code>java.lang.String</code> and in the new I/O package).&#13;
There are a few other regex packages for Java, and you may occasionally&#13;
encounter code using them, but pretty well all code from this century&#13;
can be expected to use the built-in package.&#13;
The syntax of Java regexes themselves is discussed in&#13;
<a data-type="xref" href="#javacook-regex-SECT-1">Recipe 4.1</a>, and the syntax of the Java API for using&#13;
regexes is described in <a data-type="xref" href="#javacook-regex-SECT-2">Recipe 4.2</a>.  The remaining&#13;
recipes show some applications of regex technology in Java.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="See Also" data-type="sect2"><div class="sect2" id="javacook-regex-intro.2">&#13;
<h2>See Also</h2>&#13;
&#13;
<p><a data-primary="Mastering Regular Expressions (Friedl)" data-type="indexterm" id="idm45290687147128"/><a data-primary="Friedl, Jeffrey" data-secondary="Mastering Regular Expressions" data-type="indexterm" id="idm45290687146264"/><em><a class="orm:hideurl" href="http://shop.oreilly.com/product/9780596528126.do">Mastering Regular Expressions</a></em> by Jeffrey Friedl (O’Reilly) is the definitive guide to all the details of regular expressions. Most introductory books on Unix and Perl include some discussion of regexes; <a data-primary="Unix Power Tools (Loukides, O'Reilly, Peek and Powers)" data-type="indexterm" id="idm45290687143896"/><a data-primary="O'Reilly, Tim" data-secondary="Unix Power Tools" data-type="indexterm" id="idm45290687143224"/><a data-primary="Peek, Jerry" data-secondary="Unix Power Tools" data-type="indexterm" id="idm45290687142280"/><a data-primary="Powers, Shelley" data-secondary="Unix Power Tools" data-type="indexterm" id="idm45290687141336"/><a data-primary="Loukides, Mike" data-secondary="Unix Power Tools" data-type="indexterm" id="idm45290687140392"/><em><a class="orm:hideurl" href="http://shop.oreilly.com/product/9780596003302.do">Unix Power Tools</a></em> by Mike Loukides, Tim O’Reilly, Jerry Peek, and Shelley Powers (O’Reilly) devotes a chapter to them.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="4.1 Regular Expression Syntax" data-type="sect1"><div class="sect1" id="javacook-regex-SECT-1">&#13;
<h1>4.1 Regular Expression Syntax</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="javacook-regex-SECT-1.1">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="regular expressions (regex)" data-secondary="syntax" data-type="indexterm" id="re_syn"/>You need to learn the syntax of Java regular expressions.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="javacook-regex-SECT-1.2">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Consult <a data-type="xref" href="#javacook-regex-TABLE-2">Table 4-1</a> for a list of the regular expression characters.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="javacook-regex-SECT-1.3">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>These pattern characters let you specify regexes of considerable power. In building&#13;
patterns, you can use any combination of ordinary text and the<a data-primary="metacharacters" data-type="indexterm" id="idm45290687128408"/> <em>metacharacters</em>, or&#13;
special characters, in <a data-type="xref" href="#javacook-regex-TABLE-2">Table 4-1</a>. These can all be used in any&#13;
combination that makes sense. For example, <code>a+</code> means any number of occurrences of the&#13;
letter <code>a</code>, from one up to a million or a gazillion. The pattern <code>Mrs?</code>\. matches <code>Mr.</code> or&#13;
<code>Mrs.</code> And <code>.*</code> indicates any character, any number of times, and is similar in meaning to&#13;
most command-line interpreters’ meaning of the <code>\*</code> alone. The pattern <code>\d+</code> means any&#13;
number of numeric digits. <code>\d{2,3}</code> means a two- or three-digit number.</p>&#13;
<table class="less_space pagebreak-before" id="javacook-regex-TABLE-2">&#13;
<caption><span class="label">Table 4-1. </span>Regular expression metacharacter syntax</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Subexpression</th>&#13;
<th>Matches</th>&#13;
<th>Notes</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>General</strong></p></td>&#13;
<td/>&#13;
<td/>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>\^</code></p></td>&#13;
<td><p>Start of line/string</p></td>&#13;
<td/>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>$</code></p></td>&#13;
<td><p>End of line/string</p></td>&#13;
<td/>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>\b</code></p></td>&#13;
<td><p>Word boundary</p></td>&#13;
<td/>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>\B</code></p></td>&#13;
<td><p>Not a word boundary</p></td>&#13;
<td/>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>\A</code></p></td>&#13;
<td><p>Beginning of entire string</p></td>&#13;
<td/>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>\z</code></p></td>&#13;
<td><p>End of entire string</p></td>&#13;
<td/>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>\Z</code></p></td>&#13;
<td><p>End of entire string (except allowable final line terminator)</p></td>&#13;
<td><p>See <a data-type="xref" href="#javacook-regex-SECT-9">Recipe 4.9</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>.</p></td>&#13;
<td><p>Any one character (except line terminator)</p></td>&#13;
<td/>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>[…]</code></p></td>&#13;
<td><p>“Character class”; any one character from those listed</p></td>&#13;
<td/>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>[\^…]</code></p></td>&#13;
<td><p>Any one character not from those listed</p></td>&#13;
<td><p>See <a data-type="xref" href="#javacook-regex-SECT-2">Recipe 4.2</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Alternation and grouping</strong></p></td>&#13;
<td/>&#13;
<td/>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>(…)</code></p></td>&#13;
<td><p>Grouping (capture groups)</p></td>&#13;
<td><p>See <a data-type="xref" href="#javacook-regex-SECT-3">Recipe 4.3</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>|</code></p></td>&#13;
<td><p>Alternation</p></td>&#13;
<td/>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>(?</code>:_<code>re</code>_ <code>)</code></p></td>&#13;
<td><p>Noncapturing parenthesis</p></td>&#13;
<td/>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>\G</code></p></td>&#13;
<td><p>End of the previous match</p></td>&#13;
<td/>&#13;
</tr>&#13;
<tr>&#13;
<td><p>+\+<em><code>n</code></em></p></td>&#13;
<td><p>Back-reference to capture group number <em><code>n</code></em></p></td>&#13;
<td/>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Normal (greedy) quantifiers</strong></p></td>&#13;
<td/>&#13;
<td/>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>{</code> <em><code>m</code></em>,<em><code>n</code></em> <code>}</code></p></td>&#13;
<td><p>Quantifier for from <em><code>m</code></em> to <em><code>n</code></em> repetitions</p></td>&#13;
<td><p>See <a data-type="xref" href="#javacook-regex-SECT-4">Recipe 4.4</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>{</code> <em><code>m</code></em> <code>,}</code></p></td>&#13;
<td><p>Quantifier for <em><code>m</code></em> or more repetitions</p></td>&#13;
<td/>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>{</code> <em><code>m</code></em> <code>}</code></p></td>&#13;
<td><p>Quantifier for exactly <em><code>m</code></em> repetitions</p></td>&#13;
<td><p>See <a data-type="xref" href="#javacook-regex-SECT-10">Recipe 4.10</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>{</code>,<em><code>n</code></em> <code>}</code></p></td>&#13;
<td><p>Quantifier for 0 up to <em><code>n</code></em> repetitions</p></td>&#13;
<td/>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>\*</code></p></td>&#13;
<td><p>Quantifier for 0 or more repetitions</p></td>&#13;
<td><p>Short for <code>{0,}</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>+</code></p></td>&#13;
<td><p>Quantifier for 1 or more repetitions</p></td>&#13;
<td><p>Short for <code>{1,}</code>; see <a data-type="xref" href="#javacook-regex-SECT-2">Recipe 4.2</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>?</code></p></td>&#13;
<td><p>Quantifier for 0 or 1 repetitions (i.e., present exactly once, or not at all)</p></td>&#13;
<td><p>Short for <code>{0,1}</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Reluctant (nongreedy) quantifiers</strong></p></td>&#13;
<td/>&#13;
<td/>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>{</code> <em><code>m</code></em>,<em><code>n</code></em> <code>}?</code></p></td>&#13;
<td><p>Reluctant quantifier for from <em><code>m</code></em> to <em><code>n</code></em> repetitions</p></td>&#13;
<td/>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>{</code> <em><code>m</code></em> <code>,}?</code></p></td>&#13;
<td><p>Reluctant quantifier for <em><code>m</code></em> or more repetitions</p></td>&#13;
<td/>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>{</code>,<em><code>n</code></em> <code>}?</code></p></td>&#13;
<td><p>Reluctant quantifier for 0 up to <em><code>n</code></em> repetitions</p></td>&#13;
<td/>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>\*?</code></p></td>&#13;
<td><p>Reluctant quantifier: 0 or more</p></td>&#13;
<td/>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>+?</code></p></td>&#13;
<td><p>Reluctant quantifier: 1 or more</p></td>&#13;
<td><p>See <a data-type="xref" href="#javacook-regex-SECT-10">Recipe 4.10</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>??</code></p></td>&#13;
<td><p>Reluctant quantifier: 0 or 1 times</p></td>&#13;
<td/>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Possessive (very greedy) quantifiers</strong></p></td>&#13;
<td/>&#13;
<td/>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>{</code> <em><code>m</code></em>,<em><code>n</code></em> <code>}+</code></p></td>&#13;
<td><p>Possessive quantifier for from <em><code>m</code></em> to <em><code>n</code></em> repetitions</p></td>&#13;
<td/>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>{</code> <em><code>m</code></em> <code>,}+</code></p></td>&#13;
<td><p>Possessive quantifier for <em><code>m</code></em> or more repetitions</p></td>&#13;
<td/>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>{</code>,<em><code>n</code></em> <code>}+</code></p></td>&#13;
<td><p>Possessive quantifier for 0 up to <em><code>n</code></em> repetitions</p></td>&#13;
<td/>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>\*+</code></p></td>&#13;
<td><p>Possessive quantifier: 0 or more</p></td>&#13;
<td/>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>++</code></p></td>&#13;
<td><p>Possessive quantifier: 1 or more</p></td>&#13;
<td/>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>?+</code></p></td>&#13;
<td><p>Possessive quantifier: 0 or 1 times</p></td>&#13;
<td/>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Escapes and shorthands</strong></p></td>&#13;
<td/>&#13;
<td/>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>\</code></p></td>&#13;
<td><p>Escape (quote) character: turns most metacharacters off; turns subsequent alphabetic into metacharacters</p></td>&#13;
<td/>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>\Q</code></p></td>&#13;
<td><p>Escape (quote) all characters up to <code>\E</code></p></td>&#13;
<td/>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>\E</code></p></td>&#13;
<td><p>Ends quoting begun with <code>\Q</code></p></td>&#13;
<td/>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>\t</code></p></td>&#13;
<td><p>Tab character</p></td>&#13;
<td/>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>\r</code></p></td>&#13;
<td><p>Return (carriage return) character</p></td>&#13;
<td/>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>\n</code></p></td>&#13;
<td><p>Newline character</p></td>&#13;
<td><p>See <a data-type="xref" href="#javacook-regex-SECT-9">Recipe 4.9</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>\f</code></p></td>&#13;
<td><p>Form feed</p></td>&#13;
<td/>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>\w</code></p></td>&#13;
<td><p>Character in a word</p></td>&#13;
<td><p>Use <code>\w+</code> for a word; see <a data-type="xref" href="#javacook-regex-SECT-10">Recipe 4.10</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>\W</code></p></td>&#13;
<td><p>A nonword character</p></td>&#13;
<td/>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>\d</code></p></td>&#13;
<td><p>Numeric digit</p></td>&#13;
<td><p>Use <code>\d+</code> for an integer; see <a data-type="xref" href="#javacook-regex-SECT-2">Recipe 4.2</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>\D</code></p></td>&#13;
<td><p>A nondigit character</p></td>&#13;
<td/>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>\s</code></p></td>&#13;
<td><p>Whitespace</p></td>&#13;
<td><p>Space, tab, etc., as determined by <code>java.lang.Character.isWhitespace()</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>\S</code></p></td>&#13;
<td><p>A nonwhitespace character</p></td>&#13;
<td><p>See <a data-type="xref" href="#javacook-regex-SECT-10">Recipe 4.10</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Unicode blocks (representative samples)</strong></p></td>&#13;
<td/>&#13;
<td/>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>\p{InGreek}</code></p></td>&#13;
<td><p>A character in the Greek block</p></td>&#13;
<td><p>(Simple block)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>\P{InGreek}</code></p></td>&#13;
<td><p>Any character not in the Greek block</p></td>&#13;
<td/>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>\p{Lu}</code></p></td>&#13;
<td><p>An uppercase letter</p></td>&#13;
<td><p>(Simple category)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>\p{Sc}</code></p></td>&#13;
<td><p>A currency symbol</p></td>&#13;
<td/>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>POSIX-style character classes (defined only for US-ASCII)</strong></p></td>&#13;
<td/>&#13;
<td/>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>\p{Alnum}</code></p></td>&#13;
<td><p>Alphanumeric characters</p></td>&#13;
<td><p><code>[A-Za-z0-9]</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>\p{Alpha}</code></p></td>&#13;
<td><p>Alphabetic characters</p></td>&#13;
<td><p><code>[A-Za-z]</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>\p{ASCII}</code></p></td>&#13;
<td><p>Any ASCII character</p></td>&#13;
<td><p><code>[\x00-\x7F]</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>\p{Blank}</code></p></td>&#13;
<td><p>Space and tab characters</p></td>&#13;
<td/>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>\p{Space}</code></p></td>&#13;
<td><p>Space characters</p></td>&#13;
<td><p><code>[ \t\n\x0B\f\r]</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>\p{Cntrl}</code></p></td>&#13;
<td><p>Control characters</p></td>&#13;
<td><p><code>[\x00-\x1F\x7F]</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>\p{Digit}</code></p></td>&#13;
<td><p>Numeric digit characters</p></td>&#13;
<td><p><code>[0-9]</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>\p{Graph}</code></p></td>&#13;
<td><p>Printable and visible characters (not spaces or control characters)</p></td>&#13;
<td/>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>\p{Print}</code></p></td>&#13;
<td><p>Printable characters</p></td>&#13;
<td><p>Same as <code>\p{Graph}</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>\p{Punct}</code></p></td>&#13;
<td><p>Punctuation characters</p></td>&#13;
<td><p>One of <code>!"#$%&amp;'()\*+,-./:;&lt;=&gt;?@[]\^_`{|}\~</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>\p{Lower}</code></p></td>&#13;
<td><p>Lowercase characters</p></td>&#13;
<td><p><code>[a-z]</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>\p{Upper}</code></p></td>&#13;
<td><p>Uppercase characters</p></td>&#13;
<td><p><code>[A-Z]</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>\p{XDigit}</code></p></td>&#13;
<td><p>Hexadecimal digit characters</p></td>&#13;
<td><p><code>[0-9a-fA-F]</code></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>Regexes match any place possible in the string. Patterns followed by greedy quantifiers (the only type that existed in traditional Unix regexes) consume (match) as much as possible without compromising any subexpressions that follow. Patterns followed by possessive quantifiers match as much as possible without regard to following subexpressions. Patterns followed by reluctant quantifiers consume as few characters as possible to still get a match.</p>&#13;
&#13;
<p>Also, unlike regex packages in some other languages, the Java regex package was designed to handle Unicode characters from the beginning. The standard Java escape sequence <code>\u+nnnn</code> is used to specify a Unicode character in the pattern. We use methods of <code>java.lang.Character</code> to determine Unicode character properties, such as whether a given character is a space.&#13;
Again, note that the backslash must be doubled if this is in a Java&#13;
string that is being compiled because the compiler would otherwise&#13;
parse this as “backslash-u” followed by some numbers.</p>&#13;
&#13;
<p>To help you learn how regexes work, I provide a little program called <a data-primary="REDemo" data-type="indexterm" id="idm45290686930568"/>REDemo.<sup><a data-type="noteref" href="ch04.html#idm45290686929656" id="idm45290686929656-marker">2</a></sup> The code for REDemo is too long to include in the book; in the online directory <em>regex</em> of the <em>darwinsys-api</em> repo, you will find <em>REDemo.java</em>, which you can run to explore how regexes work.</p>&#13;
&#13;
<p>In the uppermost text box (see <a data-type="xref" href="#javacook-regex-FIG-1">Figure 4-1</a>), type the regex pattern you want to test. Note that as you type each character, the regex is checked for syntax; if the syntax is OK, you see a checkmark beside it. You can then select Match, Find, or Find All. Match means that the entire string must match the regex, and Find means the regex must be found somewhere in the string (Find All counts the number of occurrences that are found). Below that, you type a string that the regex is to match against. Experiment to your heart’s content. When you have the regex the way you want it, you can paste it into your Java program. You’ll need to escape (backslash) any characters that are treated specially by both the Java compiler and the Java regex package, such as the backslash itself, double quotes, and others.&#13;
Once you get a regex the way you want it, there is a Copy button&#13;
(not shown in these screenshots) to export the regex to the clipboard,&#13;
with or without backslash doubling, depending on how you want to use it.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>Remember that because a regex is entered as a string that will be compiled by a Java compiler, you usually need two levels of escaping for any special characters, including backslash and double quotes. For example, the regex (which includes the double quotes):</p>&#13;
&#13;
<pre data-type="programlisting">"You said it\."</pre>&#13;
&#13;
<p>has to be typed like this to be a valid compile-time Java language <code>String</code>:</p>&#13;
&#13;
<pre data-type="programlisting">String pattern = "\"You said it\\.\""</pre>&#13;
&#13;
<p>In Java 14+ you could also use a text block to avoid escaping the quotes:</p>&#13;
&#13;
<pre data-type="programlisting">String pattern = """&#13;
	"You said it\\.""""</pre>&#13;
&#13;
<p>I can’t tell you how many times I’ve made the mistake of forgetting the extra backslash in <code>\d+</code>, <code>\w+</code>, and their kin!</p>&#13;
</div>&#13;
&#13;
<p>In <a data-type="xref" href="#javacook-regex-FIG-1">Figure 4-1</a>, I typed <code>qu</code> into the <code>REDemo</code> program’s Pattern box, which is a syntactically valid regex pattern: any ordinary characters stand as regexes for themselves, so this looks for the letter <code>q</code> followed by <code>u</code>. In the top version, I typed only a <code>q</code> into the string, which is not matched. In the second, I have typed <code>quack</code> and the <code>q</code> of a second <code>quack</code>. Because I have selected Find All, the count shows one match. As soon as I type the second <code>u</code>, the count is updated to two, as shown in the third version.</p>&#13;
&#13;
<p>Regexes can do far more than just character matching. For example,&#13;
the two-character regex <code>^T</code> would match beginning of line (<code>^</code>)&#13;
immediately followed by a capital T—that is, any line beginning with&#13;
a capital T. It doesn’t matter whether the line begins with “Tiny trumpets,” “Titanic tubas,” or “Triumphant twisted trombones,” as&#13;
long as the capital T is present in the first position.</p>&#13;
&#13;
<p>But here we’re not very far ahead. Have we really invested all this effort in regex technology just to be able to do what we could already do with the <code>java.lang.String</code> method <a data-primary="startsWith() method" data-type="indexterm" id="idm45290686734712"/><code>startsWith()</code>? Hmmm, I can hear some of you getting a bit restless. Stay in your seats! What if you wanted to match not only a letter T in the first position, but also a vowel immediately after it, followed by any number of letters in a word, followed by an exclamation point? Surely you could do this in Java by checking <code>startsWith("T")</code> and <code>charAt(1) == 'a' || charAt(1) == 'e'</code>, and so on? Yes, but by the time you did that, you’d have written a lot of very highly specialized code that you couldn’t use in any other application. With regular expressions, you can just give the pattern <code>^T[aeiou]\w*!</code>. That is, <code>^</code> and <code>T</code> as before, followed by a character class listing the vowels, followed by any number of word characters (<code>\w*</code>), followed by the exclamation point.</p>&#13;
&#13;
<figure><div class="figure" id="javacook-regex-FIG-1">&#13;
<img alt="jcb4 0401" src="assets/jcb4_0401.png"/>&#13;
<h6><span class="label">Figure 4-1. </span>REDemo with simple examples</h6>&#13;
</div></figure>&#13;
&#13;
<p>“But wait, there’s more!” as my late, great boss&#13;
<a href="https://en.wikipedia.org/wiki/Yuri_Rubinsky">Yuri Rubinsky</a> used to say.&#13;
What if you want to be able to change the pattern you’re looking for <em>at runtime</em>? Remember all that Java code you just wrote to match <code>T</code> in column 1, plus a vowel, some word characters, and an exclamation point? Well, it’s time to throw it out. Because this morning we need to match <code>Q</code>, followed by a letter other than <code>u</code>, followed by a number of digits, followed by a period. While some of you start writing a new function to do that, the rest of us will just saunter over to the RegEx Bar &amp; Grille, order a <code>^Q[^u]\d+\.</code>. from the bartender, and be on our way.</p>&#13;
&#13;
<p>OK, if you want an explanation: the <code>[^u]</code> means match&#13;
any one character that is not the character <code>u</code>. The <code>\d+</code> means one or more numeric digits. The&#13;
<code>+</code> is a quantifier meaning one or more occurrences of what it&#13;
follows, and <code>\d</code> is any one numeric digit. So <code>\d+</code> means a number&#13;
with one, two, or more digits. Finally, the <code>\.</code>? Well, . by itself&#13;
is a metacharacter. Most single metacharacters are switched off by&#13;
preceding them with an escape character. Not the Esc key on your&#13;
keyboard, of course. The regex escape character is the backslash.&#13;
Preceding a metacharacter like . with this escape turns off its&#13;
special meaning, so we look for a literal period rather than any character.&#13;
Preceding a few selected alphabetic characters&#13;
(e.g., <code>n</code>, <code>r</code>, <code>t</code>, <code>s</code>, <code>w</code>) with escape turns them into&#13;
metacharacters. <a data-type="xref" href="#javacook-regex-FIG-2">Figure 4-2</a> shows the <code>^Q[^u]\d+\..</code>&#13;
regex in action. In the first frame, I have typed part of the regex&#13;
as <code>^Q[^u</code>. Because there is an unclosed square bracket, the&#13;
Syntax OK flag is turned off; when I complete the regex, it will&#13;
be turned back on. In the second frame, I have finished typing the regex,&#13;
and I’ve typed the data string as <code>QA577</code> (which you should expect to match&#13;
the <code>$$^Q[^u]\d+$$</code> but not the period since I haven’t typed&#13;
it). In the third frame, I’ve typed the period so the Matches flag&#13;
is set to Yes.</p>&#13;
&#13;
<figure><div class="figure" id="javacook-regex-FIG-2">&#13;
<img alt="jcb4 0402" src="assets/jcb4_0402.png"/>&#13;
<h6><span class="label">Figure 4-2. </span>REDemo with “Q not followed by u” example</h6>&#13;
</div></figure>&#13;
&#13;
<p>Because backslashes need to be escaped when pasting the regex into Java code, the current version of <code>REDemo</code> has both a <code>Copy Pattern</code> button, which copies the regex verbatim for use in documentation and in Unix commands, and a <code>Copy Pattern Backslashed</code> button, which copies the regex to the clipboard with backslashes doubled, for pasting into Java strings.</p>&#13;
&#13;
<p>By now you should have at least a basic grasp of how regexes work&#13;
in practice. The rest of this chapter gives more examples and&#13;
explains some of the more powerful topics, such as capture groups.&#13;
As for how regexes work in theory—and there are a lot of theoretical&#13;
details and differences among regex flavors—the interested reader&#13;
is referred to <em><a class="orm:hideurl" href="http://shop.oreilly.com/product/9780596528126.do">Mastering Regular Expressions</a></em>. Meanwhile,&#13;
let’s start learning how to write Java programs that use&#13;
regular expressions.<a data-primary="" data-startref="re_syn" data-type="indexterm" id="idm45290686708840"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="4.2 Using Regexes in Java: Test for a Pattern" data-type="sect1"><div class="sect1" id="javacook-regex-SECT-2">&#13;
<h1>4.2 Using Regexes in Java: Test for a Pattern</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="javacook-regex-SECT-2.1">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="pattern matching" data-secondary="testing for patterns" data-type="indexterm" id="pm_tp"/><a data-primary="regular expressions (regex)" data-secondary="patterns, testing for" data-type="indexterm" id="re_pt"/><a data-primary="testing" data-secondary="for patterns" data-type="indexterm" id="te_pa"/>You’re ready to get started using regular expression processing to beef up your Java code by testing to see if a given pattern can match in a given string.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="javacook-regex-SECT-2.2">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Use the Java Regular Expressions Package, <code>java.util.regex</code>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="javacook-regex-SECT-2.3">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>The good news is that the Java API for regexes is actually easy to use. If all you need is to find out whether a given regex matches a string, you can use the convenient <a data-primary="boolean matches() method" data-type="indexterm" id="idm45290686696056"/><code>boolean matches()</code> method of the <code>String</code> class, which accepts a regex pattern in <code>String</code> form as its argument:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="k">if</code> <code class="o">(</code><code class="n">inputString</code><code class="o">.</code><code class="na">matches</code><code class="o">(</code><code class="n">stringRegexPattern</code><code class="o">))</code> <code class="o">{</code>&#13;
    <code class="c1">// it matched... do something with it...</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p>This is, however, a convenience routine, and convenience always comes at a price. If the regex is going to be used more than once or twice in a program, it is more efficient to construct and use a <code>Pattern</code> and its <code>Matcher</code>(s). A complete program constructing a <code>Pattern</code> and using it to <code>match</code> is shown here:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">class</code> <code class="nc">RESimple</code> <code class="o">{</code>&#13;
    <code class="kd">public</code> <code class="kd">static</code> <code class="kt">void</code> <code class="nf">main</code><code class="o">(</code><code class="n">String</code><code class="o">[]</code> <code class="n">argv</code><code class="o">)</code> <code class="o">{</code>&#13;
        <code class="n">String</code> <code class="n">pattern</code> <code class="o">=</code> <code class="s">"^Q[^u]\\d+\\."</code><code class="o">;</code>&#13;
        <code class="n">String</code><code class="o">[]</code> <code class="n">input</code> <code class="o">=</code> <code class="o">{</code>&#13;
            <code class="s">"QA777. is the next flight. It is on time."</code><code class="o">,</code>&#13;
            <code class="s">"Quack, Quack, Quack!"</code>&#13;
        <code class="o">};</code>&#13;
&#13;
        <code class="n">Pattern</code> <code class="n">p</code> <code class="o">=</code> <code class="n">Pattern</code><code class="o">.</code><code class="na">compile</code><code class="o">(</code><code class="n">pattern</code><code class="o">);</code>&#13;
&#13;
        <code class="k">for</code> <code class="o">(</code><code class="n">String</code> <code class="n">in</code> <code class="o">:</code> <code class="n">input</code><code class="o">)</code> <code class="o">{</code>&#13;
            <code class="kt">boolean</code> <code class="n">found</code> <code class="o">=</code> <code class="n">p</code><code class="o">.</code><code class="na">matcher</code><code class="o">(</code><code class="n">in</code><code class="o">).</code><code class="na">lookingAt</code><code class="o">();</code>&#13;
&#13;
            <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="s">"'"</code> <code class="o">+</code> <code class="n">pattern</code> <code class="o">+</code> <code class="s">"'"</code> <code class="o">+</code>&#13;
            <code class="o">(</code><code class="n">found</code> <code class="o">?</code> <code class="s">" matches '"</code> <code class="o">:</code> <code class="s">" doesn't match '"</code><code class="o">)</code> <code class="o">+</code> <code class="n">in</code> <code class="o">+</code> <code class="s">"'"</code><code class="o">);</code>&#13;
        <code class="o">}</code>&#13;
    <code class="o">}</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p>The <code>java.util.regex</code> package contains two classes, <code>Pattern</code> and <code>Matcher</code>, which provide the public API shown in <a data-type="xref" href="#javacook-regex-EX-1">Example 4-1</a>.</p>&#13;
<div data-type="example" id="javacook-regex-EX-1">&#13;
<h5><span class="label">Example 4-1. </span>Regex public API</h5>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="cm">/**</code>&#13;
<code class="cm"> * The main public API of the java.util.regex package.</code>&#13;
<code class="cm"> */</code>&#13;
&#13;
<code class="kn">package</code> <code class="n">java</code><code class="o">.</code><code class="na">util</code><code class="o">.</code><code class="na">regex</code><code class="o">;</code>&#13;
&#13;
<code class="kd">public</code> <code class="kd">final</code> <code class="kd">class</code> <code class="nc">Pattern</code> <code class="o">{</code>&#13;
    <code class="c1">// Flags values ('or' together)</code>&#13;
    <code class="kd">public</code> <code class="kd">static</code> <code class="kd">final</code> <code class="kt">int</code>&#13;
        <code class="n">UNIX_LINES</code><code class="o">,</code> <code class="n">CASE_INSENSITIVE</code><code class="o">,</code> <code class="n">COMMENTS</code><code class="o">,</code> <code class="n">MULTILINE</code><code class="o">,</code>&#13;
        <code class="n">DOTALL</code><code class="o">,</code> <code class="n">UNICODE_CASE</code><code class="o">,</code> <code class="n">CANON_EQ</code><code class="o">;</code>&#13;
    <code class="c1">// No public constructors; use these Factory methods</code>&#13;
    <code class="kd">public</code> <code class="kd">static</code> <code class="n">Pattern</code> <code class="nf">compile</code><code class="o">(</code><code class="n">String</code> <code class="n">patt</code><code class="o">);</code>&#13;
    <code class="kd">public</code> <code class="kd">static</code> <code class="n">Pattern</code> <code class="nf">compile</code><code class="o">(</code><code class="n">String</code> <code class="n">patt</code><code class="o">,</code> <code class="kt">int</code> <code class="n">flags</code><code class="o">);</code>&#13;
    <code class="c1">// Method to get a Matcher for this Pattern</code>&#13;
    <code class="kd">public</code> <code class="n">Matcher</code> <code class="nf">matcher</code><code class="o">(</code><code class="n">CharSequence</code> <code class="n">input</code><code class="o">);</code>&#13;
    <code class="c1">// Information methods</code>&#13;
    <code class="kd">public</code> <code class="n">String</code> <code class="nf">pattern</code><code class="o">();</code>&#13;
    <code class="kd">public</code> <code class="kt">int</code> <code class="nf">flags</code><code class="o">();</code>&#13;
    <code class="c1">// Convenience methods</code>&#13;
    <code class="kd">public</code> <code class="kd">static</code> <code class="kt">boolean</code> <code class="nf">matches</code><code class="o">(</code><code class="n">String</code> <code class="n">pattern</code><code class="o">,</code> <code class="n">CharSequence</code> <code class="n">input</code><code class="o">);</code>&#13;
    <code class="kd">public</code> <code class="n">String</code><code class="o">[]</code> <code class="nf">split</code><code class="o">(</code><code class="n">CharSequence</code> <code class="n">input</code><code class="o">);</code>&#13;
    <code class="kd">public</code> <code class="n">String</code><code class="o">[]</code> <code class="nf">split</code><code class="o">(</code><code class="n">CharSequence</code> <code class="n">input</code><code class="o">,</code> <code class="kt">int</code> <code class="n">max</code><code class="o">);</code>&#13;
<code class="o">}</code>&#13;
&#13;
<code class="kd">public</code> <code class="kd">final</code> <code class="kd">class</code> <code class="nc">Matcher</code> <code class="o">{</code>&#13;
    <code class="c1">// Action: find or match methods</code>&#13;
    <code class="kd">public</code> <code class="kt">boolean</code> <code class="nf">matches</code><code class="o">();</code>&#13;
    <code class="kd">public</code> <code class="kt">boolean</code> <code class="nf">find</code><code class="o">();</code>&#13;
    <code class="kd">public</code> <code class="kt">boolean</code> <code class="nf">find</code><code class="o">(</code><code class="kt">int</code> <code class="n">start</code><code class="o">);</code>&#13;
    <code class="kd">public</code> <code class="kt">boolean</code> <code class="nf">lookingAt</code><code class="o">();</code>&#13;
    <code class="c1">// "Information about the previous match" methods</code>&#13;
    <code class="kd">public</code> <code class="kt">int</code> <code class="nf">start</code><code class="o">();</code>&#13;
    <code class="kd">public</code> <code class="kt">int</code> <code class="nf">start</code><code class="o">(</code><code class="kt">int</code> <code class="n">whichGroup</code><code class="o">);</code>&#13;
    <code class="kd">public</code> <code class="kt">int</code> <code class="nf">end</code><code class="o">();</code>&#13;
    <code class="kd">public</code> <code class="kt">int</code> <code class="nf">end</code><code class="o">(</code><code class="kt">int</code> <code class="n">whichGroup</code><code class="o">);</code>&#13;
    <code class="kd">public</code> <code class="kt">int</code> <code class="nf">groupCount</code><code class="o">();</code>&#13;
    <code class="kd">public</code> <code class="n">String</code> <code class="nf">group</code><code class="o">();</code>&#13;
    <code class="kd">public</code> <code class="n">String</code> <code class="nf">group</code><code class="o">(</code><code class="kt">int</code> <code class="n">whichGroup</code><code class="o">);</code>&#13;
    <code class="c1">// Reset methods</code>&#13;
    <code class="kd">public</code> <code class="n">Matcher</code> <code class="nf">reset</code><code class="o">();</code>&#13;
    <code class="kd">public</code> <code class="n">Matcher</code> <code class="nf">reset</code><code class="o">(</code><code class="n">CharSequence</code> <code class="n">newInput</code><code class="o">);</code>&#13;
    <code class="c1">// Replacement methods</code>&#13;
    <code class="kd">public</code> <code class="n">Matcher</code> <code class="nf">appendReplacement</code><code class="o">(</code><code class="n">StringBuffer</code> <code class="n">where</code><code class="o">,</code> <code class="n">String</code> <code class="n">newText</code><code class="o">);</code>&#13;
    <code class="kd">public</code> <code class="n">StringBuffer</code> <code class="nf">appendTail</code><code class="o">(</code><code class="n">StringBuffer</code> <code class="n">where</code><code class="o">);</code>&#13;
    <code class="kd">public</code> <code class="n">String</code> <code class="nf">replaceAll</code><code class="o">(</code><code class="n">String</code> <code class="n">newText</code><code class="o">);</code>&#13;
    <code class="kd">public</code> <code class="n">String</code> <code class="nf">replaceFirst</code><code class="o">(</code><code class="n">String</code> <code class="n">newText</code><code class="o">);</code>&#13;
    <code class="c1">// information methods</code>&#13;
    <code class="kd">public</code> <code class="n">Pattern</code> <code class="nf">pattern</code><code class="o">();</code>&#13;
<code class="o">}</code>&#13;
&#13;
<code class="cm">/* String, showing only the RE-related methods */</code>&#13;
<code class="kd">public</code> <code class="kd">final</code> <code class="kd">class</code> <code class="nc">String</code> <code class="o">{</code>&#13;
    <code class="kd">public</code> <code class="kt">boolean</code> <code class="nf">matches</code><code class="o">(</code><code class="n">String</code> <code class="n">regex</code><code class="o">);</code>&#13;
    <code class="kd">public</code> <code class="n">String</code> <code class="nf">replaceFirst</code><code class="o">(</code><code class="n">String</code> <code class="n">regex</code><code class="o">,</code> <code class="n">String</code> <code class="n">newStr</code><code class="o">);</code>&#13;
    <code class="kd">public</code> <code class="n">String</code> <code class="nf">replaceAll</code><code class="o">(</code><code class="n">String</code> <code class="n">regex</code><code class="o">,</code> <code class="n">String</code> <code class="n">newStr</code><code class="o">);</code>&#13;
    <code class="kd">public</code> <code class="n">String</code><code class="o">[]</code> <code class="nf">split</code><code class="o">(</code><code class="n">String</code> <code class="n">regex</code><code class="o">);</code>&#13;
    <code class="kd">public</code> <code class="n">String</code><code class="o">[]</code> <code class="nf">split</code><code class="o">(</code><code class="n">String</code> <code class="n">regex</code><code class="o">,</code> <code class="kt">int</code> <code class="n">max</code><code class="o">);</code>&#13;
<code class="o">}</code></pre></div>&#13;
&#13;
<p>This API is large enough to require some explanation. These are the normal steps for regex matching in a production program:</p>&#13;
<ol>&#13;
<li>&#13;
<p>Create a <code>Pattern</code> by calling the static method <a data-primary="Pattern.compile() method" data-type="indexterm" id="idm45290686556056"/><code>Pattern.compile()</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>Request a <code>Matcher</code> from the pattern by calling <code>pattern.matcher(CharSequence)</code> for each <code>String</code> (or other <code>CharSequence</code>) you wish to look through.</p>&#13;
</li>&#13;
<li>&#13;
<p>Call (once or more) one of the finder methods (discussed later in this section) in the resulting <code>Matcher</code>.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>The <code>java.lang.CharSequence</code> interface provides simple read-only access to objects containing a collection of characters. The standard implementations are <code>String</code> and <code>StringBuffer</code>/<code>StringBuilder</code> (described in <a data-type="xref" href="ch03.html#javacook-strings">Chapter 3</a>), and the new I/O class <code>java.nio.CharBuffer</code>.</p>&#13;
&#13;
<p>Of course, you can perform regex matching in other ways, such as using the convenience methods in <code>Pattern</code> or even in <code>java.lang.String</code>, like this:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">class</code> <code class="nc">StringConvenience</code> <code class="o">{</code>&#13;
    <code class="kd">public</code> <code class="kd">static</code> <code class="kt">void</code> <code class="nf">main</code><code class="o">(</code><code class="n">String</code><code class="o">[]</code> <code class="n">argv</code><code class="o">)</code> <code class="o">{</code>&#13;
&#13;
        <code class="n">String</code> <code class="n">pattern</code> <code class="o">=</code> <code class="s">".*Q[^u]\\d+\\..*"</code><code class="o">;</code>&#13;
        <code class="n">String</code> <code class="n">line</code> <code class="o">=</code> <code class="s">"Order QT300. Now!"</code><code class="o">;</code>&#13;
        <code class="k">if</code> <code class="o">(</code><code class="n">line</code><code class="o">.</code><code class="na">matches</code><code class="o">(</code><code class="n">pattern</code><code class="o">))</code> <code class="o">{</code>&#13;
            <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="n">line</code> <code class="o">+</code> <code class="s">" matches \""</code> <code class="o">+</code> <code class="n">pattern</code> <code class="o">+</code> <code class="s">"\""</code><code class="o">);</code>&#13;
        <code class="o">}</code> <code class="k">else</code> <code class="o">{</code>&#13;
            <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="s">"NO MATCH"</code><code class="o">);</code>&#13;
        <code class="o">}</code>&#13;
    <code class="o">}</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p>But the three-step list is the standard pattern for matching. You’d&#13;
likely use the <code>String</code> convenience routine in a program that only used the regex once; if&#13;
the regex were being used more than once, it is worth taking the time to compile it because the compiled version runs faster.</p>&#13;
&#13;
<p>In addition, the <code>Matcher</code> has several finder methods, which provide more flexibility than the&#13;
<code>String</code> convenience routine <code>match()</code>. These are the <code>Matcher</code> methods:</p>&#13;
<dl>&#13;
<dt><a data-primary="match() method" data-type="indexterm" id="idm45290685966536"/><code>match()</code></dt>&#13;
<dd>&#13;
<p>Used to compare the entire string against the pattern; this is the same as&#13;
the routine in <code>java.lang.String</code>. Because it matches the entire <code>String</code>, I had to put <code>.*</code>&#13;
before and after the pattern.</p>&#13;
</dd>&#13;
<dt><a data-primary="lookingAt() method" data-type="indexterm" id="idm45290685963032"/><code>lookingAt()</code></dt>&#13;
<dd>&#13;
<p>Used to match the pattern only at the beginning of the string.</p>&#13;
</dd>&#13;
<dt><a data-primary="find() method (regex)" data-type="indexterm" id="idm45290685960920"/><code>find()</code></dt>&#13;
<dd>&#13;
<p>Used to match the pattern in the string (not necessarily at the first character of the string), starting at the beginning of the string or, if the method was previously called and succeeded, at the first character not matched by the previous match.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>Each of these methods returns <code>boolean</code>, with <code>true</code> meaning a match and <code>false</code> meaning no match. To check whether a given string matches a given pattern, you need only type something like the following:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="n">Matcher</code> <code class="n">m</code> <code class="o">=</code> <code class="n">Pattern</code><code class="o">.</code><code class="na">compile</code><code class="o">(</code><code class="n">patt</code><code class="o">).</code><code class="na">matcher</code><code class="o">(</code><code class="n">line</code><code class="o">);</code>&#13;
<code class="k">if</code> <code class="o">(</code><code class="n">m</code><code class="o">.</code><code class="na">find</code><code class="o">(</code> <code class="o">))</code> <code class="o">{</code>&#13;
    <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="n">line</code> <code class="o">+</code> <code class="s">" matches "</code> <code class="o">+</code> <code class="n">patt</code><code class="o">)</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p>But you may also want to extract the text that matched, which is the subject of the next recipe.</p>&#13;
&#13;
<p>The following recipes cover uses of the Matcher API. Initially, the examples just use arguments of type <code>String</code> as the input source. Use of other <code>CharSequence</code> types is covered in <a data-type="xref" href="#javacook-regex-SECT-5">Recipe 4.5</a>.<a data-primary="" data-startref="pm_tp" data-type="indexterm" id="idm45290685930808"/><a data-primary="" data-startref="re_pt" data-type="indexterm" id="idm45290685929832"/><a data-primary="" data-startref="te_pa" data-type="indexterm" id="idm45290685928888"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="4.3 Finding the Matching Text" data-type="sect1"><div class="sect1" id="javacook-regex-SECT-3">&#13;
<h1>4.3 Finding the Matching Text</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="javacook-regex-SECT-3.1">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="pattern matching" data-secondary="finding matching text" data-type="indexterm" id="pm_fmt"/>You need to find the text that the regex matched.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="javacook-regex-SECT-3.2">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Sometimes you need to know more than just whether a regex matched a string. In editors and&#13;
many other tools, you want to know exactly what characters were matched. Remember that&#13;
with quantifiers such as *, the length of the text that was matched may have no&#13;
relationship to the length of the pattern that matched it. Do not underestimate the mighty&#13;
<code>.*</code>, which happily matches thousands or millions of characters if allowed to. As you saw&#13;
in the previous recipe, you can find out whether a given match succeeds just by using&#13;
<a data-primary="find() method (regex)" data-type="indexterm" id="idm45290686064520"/><code>find()</code> or <a data-primary="matches() method" data-type="indexterm" id="idm45290686063432"/><code>matches()</code>. But in other applications, you will want to get the characters&#13;
that the pattern matched.</p>&#13;
&#13;
<p>After a successful call to one of the preceding methods, you can use these information methods on the <code>Matcher</code> to get information on the match:</p>&#13;
<dl>&#13;
<dt><a data-primary="start() method" data-type="indexterm" id="idm45290686060424"/><a data-primary="end() method" data-type="indexterm" id="idm45290686059720"/><code>start(), end()</code></dt>&#13;
<dd>&#13;
<p>Returns the character position in the string of the starting and ending characters that matched.</p>&#13;
</dd>&#13;
<dt><a data-primary="groupCount() method" data-type="indexterm" id="idm45290686057528"/><code>groupCount()</code></dt>&#13;
<dd>&#13;
<p>Returns the number of parenthesized capture groups, if any; returns 0 if no groups were used.</p>&#13;
</dd>&#13;
<dt><a data-primary="group() method" data-type="indexterm" id="idm45290686055304"/><code>group(int i)</code></dt>&#13;
<dd>&#13;
<p>Returns the characters matched by group <em><code>i</code></em> of the current match, if&#13;
<em><code>i</code></em> is greater than or equal to zero and less than or equal to the return value of <code>groupCount()</code>.&#13;
Group 0 is the entire match, so <code>group(0)</code> (or just <code>group()</code>) returns the entire portion&#13;
of the input that matched.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>The notion of parentheses, or capture groups, is central to regex processing. Regexes may be nested to any level of complexity. The <code>group(int)</code> method lets you retrieve the characters that matched a given parenthesis group. If you haven’t used any explicit parens, you can just treat whatever matched as level zero. <a data-type="xref" href="#part-of-rematch.java">Example 4-2</a> shows part of <em>REMatch.java</em>.</p>&#13;
<div data-type="example" id="part-of-rematch.java">&#13;
<h5><span class="label">Example 4-2. </span>Part of main/src/main/java/regex/REMatch.java</h5>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">class</code> <code class="nc">REmatch</code> <code class="o">{</code>&#13;
    <code class="kd">public</code> <code class="kd">static</code> <code class="kt">void</code> <code class="nf">main</code><code class="o">(</code><code class="n">String</code><code class="o">[]</code> <code class="n">argv</code><code class="o">)</code> <code class="o">{</code>&#13;
&#13;
        <code class="n">String</code> <code class="n">patt</code> <code class="o">=</code> <code class="s">"Q[^u]\\d+\\."</code><code class="o">;</code>&#13;
        <code class="n">Pattern</code> <code class="n">r</code> <code class="o">=</code> <code class="n">Pattern</code><code class="o">.</code><code class="na">compile</code><code class="o">(</code><code class="n">patt</code><code class="o">);</code>&#13;
        <code class="n">String</code> <code class="n">line</code> <code class="o">=</code> <code class="s">"Order QT300. Now!"</code><code class="o">;</code>&#13;
        <code class="n">Matcher</code> <code class="n">m</code> <code class="o">=</code> <code class="n">r</code><code class="o">.</code><code class="na">matcher</code><code class="o">(</code><code class="n">line</code><code class="o">);</code>&#13;
        <code class="k">if</code> <code class="o">(</code><code class="n">m</code><code class="o">.</code><code class="na">find</code><code class="o">())</code> <code class="o">{</code>&#13;
            <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="n">patt</code> <code class="o">+</code> <code class="s">" matches \""</code> <code class="o">+</code>&#13;
                <code class="n">m</code><code class="o">.</code><code class="na">group</code><code class="o">(</code><code class="mi">0</code><code class="o">)</code> <code class="o">+</code>&#13;
                <code class="s">"\" in \""</code> <code class="o">+</code> <code class="n">line</code> <code class="o">+</code> <code class="s">"\""</code><code class="o">);</code>&#13;
        <code class="o">}</code> <code class="k">else</code> <code class="o">{</code>&#13;
            <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="s">"NO MATCH"</code><code class="o">);</code>&#13;
        <code class="o">}</code>&#13;
    <code class="o">}</code>&#13;
<code class="o">}</code></pre></div>&#13;
&#13;
<p>When run, this prints:</p>&#13;
&#13;
<pre data-type="programlisting">Q[\^u]\d+\. matches "QT300." in "Order QT300. Now!"</pre>&#13;
&#13;
<p>With the <code>Match</code> button checked, REDemo provides a display of&#13;
all the capture groups in a given regex; one example is shown in&#13;
<a data-type="xref" href="#javacook-regex-FIG-3">Figure 4-3</a>.</p>&#13;
&#13;
<figure><div class="figure" id="javacook-regex-FIG-3">&#13;
<img alt="jcb4 0403" src="assets/jcb4_0403.png"/>&#13;
<h6><span class="label">Figure 4-3. </span>REDemo in action</h6>&#13;
</div></figure>&#13;
&#13;
<p>It is also possible to get the starting and ending indices and the&#13;
length of the text that the pattern matched (remember that terms&#13;
with quantifiers, such as the <code>\d+</code> in this example, can match&#13;
an arbitrary number of characters in the string). You can use these&#13;
in conjunction with the <a data-primary="String.substring() methods" data-type="indexterm" id="idm45290685828456"/><code>String.substring()</code> methods as follows:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting">        <code class="n">String</code> <code class="n">patt</code> <code class="o">=</code> <code class="s">"Q[^u]\\d+\\."</code><code class="o">;</code>&#13;
        <code class="n">Pattern</code> <code class="n">r</code> <code class="o">=</code> <code class="n">Pattern</code><code class="o">.</code><code class="na">compile</code><code class="o">(</code><code class="n">patt</code><code class="o">);</code>&#13;
        <code class="n">String</code> <code class="n">line</code> <code class="o">=</code> <code class="s">"Order QT300. Now!"</code><code class="o">;</code>&#13;
        <code class="n">Matcher</code> <code class="n">m</code> <code class="o">=</code> <code class="n">r</code><code class="o">.</code><code class="na">matcher</code><code class="o">(</code><code class="n">line</code><code class="o">);</code>&#13;
        <code class="k">if</code> <code class="o">(</code><code class="n">m</code><code class="o">.</code><code class="na">find</code><code class="o">())</code> <code class="o">{</code>&#13;
            <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="n">patt</code> <code class="o">+</code> <code class="s">" matches \""</code> <code class="o">+</code>&#13;
                <code class="n">line</code><code class="o">.</code><code class="na">substring</code><code class="o">(</code><code class="n">m</code><code class="o">.</code><code class="na">start</code><code class="o">(</code><code class="mi">0</code><code class="o">),</code> <code class="n">m</code><code class="o">.</code><code class="na">end</code><code class="o">(</code><code class="mi">0</code><code class="o">))</code> <code class="o">+</code>&#13;
                <code class="s">"\" in \""</code> <code class="o">+</code> <code class="n">line</code> <code class="o">+</code> <code class="s">"\""</code><code class="o">);</code>&#13;
        <code class="o">}</code> <code class="k">else</code> <code class="o">{</code>&#13;
            <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="s">"NO MATCH"</code><code class="o">);</code>&#13;
        <code class="o">}</code></pre>&#13;
&#13;
<p>Suppose you need to extract several items from a string. If the input is</p>&#13;
&#13;
<pre data-type="programlisting">Smith, John&#13;
Adams, John Quincy</pre>&#13;
&#13;
<p>and you want to get out</p>&#13;
&#13;
<pre data-type="programlisting">John Smith&#13;
John Quincy Adams</pre>&#13;
&#13;
<p>just use the following: <a data-primary="" data-startref="pm_fmt" data-type="indexterm" id="idm45290685689160"/></p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">class</code> <code class="nc">REmatchTwoFields</code> <code class="o">{</code>&#13;
    <code class="kd">public</code> <code class="kd">static</code> <code class="kt">void</code> <code class="nf">main</code><code class="o">(</code><code class="n">String</code><code class="o">[]</code> <code class="n">args</code><code class="o">)</code> <code class="o">{</code>&#13;
        <code class="n">String</code> <code class="n">inputLine</code> <code class="o">=</code> <code class="s">"Adams, John Quincy"</code><code class="o">;</code>&#13;
        <code class="c1">// Construct an RE with parens to "grab" both field1 and field2</code>&#13;
        <code class="n">Pattern</code> <code class="n">r</code> <code class="o">=</code> <code class="n">Pattern</code><code class="o">.</code><code class="na">compile</code><code class="o">(</code><code class="s">"(.*), (.*)"</code><code class="o">);</code>&#13;
        <code class="n">Matcher</code> <code class="n">m</code> <code class="o">=</code> <code class="n">r</code><code class="o">.</code><code class="na">matcher</code><code class="o">(</code><code class="n">inputLine</code><code class="o">);</code>&#13;
        <code class="k">if</code> <code class="o">(!</code><code class="n">m</code><code class="o">.</code><code class="na">matches</code><code class="o">())</code>&#13;
            <code class="k">throw</code> <code class="k">new</code> <code class="nf">IllegalArgumentException</code><code class="o">(</code><code class="s">"Bad input"</code><code class="o">);</code>&#13;
        <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="n">m</code><code class="o">.</code><code class="na">group</code><code class="o">(</code><code class="mi">2</code><code class="o">)</code> <code class="o">+</code> <code class="sc">' '</code> <code class="o">+</code> <code class="n">m</code><code class="o">.</code><code class="na">group</code><code class="o">(</code><code class="mi">1</code><code class="o">));</code>&#13;
    <code class="o">}</code>&#13;
<code class="o">}</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="4.4 Replacing the Matched Text" data-type="sect1"><div class="sect1" id="javacook-regex-SECT-4">&#13;
<h1>4.4 Replacing the Matched Text</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="idm45290685565000">&#13;
<h2>Problem</h2>&#13;
&#13;
<p>Having found some text using a Pattern, you want to replace the text&#13;
with different text, without disturbing the rest of the string.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="idm45290685563272">&#13;
<h2>Solution</h2>&#13;
&#13;
<p><a data-primary="pattern matching" data-secondary="replacing matched text" data-type="indexterm" id="pm_rmt"/>As we saw in the previous recipe, regex patterns involving quantifiers can match a lot of characters with very few metacharacters. We need a way to replace the text that the regex matched without changing other text before or after it. We could do this manually using the <code>String</code> method <a data-primary="substring() method" data-type="indexterm" id="idm45290685560024"/><code>substring()</code>. However, because it’s such a common requirement, the Java Regular Expression API provides some substitution methods.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="idm45290685558504">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>The <code>Matcher</code> class provides several methods for replacing just the text&#13;
that matched the pattern. In all these methods, you pass in the replacement text, or “righthand side,” of the substitution (this term is historical: in a command-line text editor’s substitute command, the lefthand side is the pattern and the righthand side is the replacement text). These are the replacement methods:</p>&#13;
<dl>&#13;
<dt><a data-primary="replaceAll() method" data-type="indexterm" id="idm45290685555384"/><code>replaceAll(newString)</code></dt>&#13;
<dd>&#13;
<p>Replaces all occurrences that matched with the new string</p>&#13;
</dd>&#13;
<dt><a data-primary="replaceFirst() method" data-type="indexterm" id="idm45290685553272"/><code>replaceFirst(newString)</code></dt>&#13;
<dd>&#13;
<p>As above but only the first occurence</p>&#13;
</dd>&#13;
<dt><a data-primary="appendReplacement() method" data-type="indexterm" id="idm45290685551160"/><code>appendReplacement(StringBuffer, newString)</code></dt>&#13;
<dd>&#13;
<p>Copies up to before the first match, plus the given <code>newString</code></p>&#13;
</dd>&#13;
<dt><a data-primary="appendTail() method" data-type="indexterm" id="idm45290685548760"/><code>appendTail(StringBuffer)</code></dt>&#13;
<dd>&#13;
<p>Appends text after the last match (normally used after <code>appendReplacement</code>)</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>Despite their names, the <code>replace*</code> methods behave in accord with&#13;
the immutability of <code>Strings</code> (see <a data-type="xref" href="ch03.html#strings-are-immutable">“Timeless, Immutable, and Unchangeable”</a>):&#13;
they create a new <code>String</code> object with the replacement performed; they do not&#13;
(indeed, could not) modify the string referred to in the <code>Matcher</code> object.</p>&#13;
&#13;
<p><a data-type="xref" href="#javacook-regex-EX-2">Example 4-3</a> shows use of these three methods.</p>&#13;
<div data-type="example" id="javacook-regex-EX-2">&#13;
<h5><span class="label">Example 4-3. </span>main/src/main/java/regex/ReplaceDemo.java</h5>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="cm">/**</code>&#13;
<code class="cm"> * Quick demo of RE substitution: correct U.S. 'favor'</code>&#13;
<code class="cm"> * to Canadian/British 'favour', but not in "favorite"</code>&#13;
<code class="cm"> * @author Ian F. Darwin, http://www.darwinsys.com/</code>&#13;
<code class="cm"> */</code>&#13;
<code class="kd">public</code> <code class="kd">class</code> <code class="nc">ReplaceDemo</code> <code class="o">{</code>&#13;
    <code class="kd">public</code> <code class="kd">static</code> <code class="kt">void</code> <code class="nf">main</code><code class="o">(</code><code class="n">String</code><code class="o">[]</code> <code class="n">argv</code><code class="o">)</code> <code class="o">{</code>&#13;
&#13;
        <code class="c1">// Make an RE pattern to match as a word only (\b=word boundary)</code>&#13;
        <code class="n">String</code> <code class="n">patt</code> <code class="o">=</code> <code class="s">"\\bfavor\\b"</code><code class="o">;</code>&#13;
&#13;
        <code class="c1">// A test input</code>&#13;
        <code class="n">String</code> <code class="n">input</code> <code class="o">=</code> <code class="s">"Do me a favor? Fetch my favorite."</code><code class="o">;</code>&#13;
        <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="s">"Input: "</code> <code class="o">+</code> <code class="n">input</code><code class="o">);</code>&#13;
&#13;
        <code class="c1">// Run it from a RE instance and see that it works</code>&#13;
        <code class="n">Pattern</code> <code class="n">r</code> <code class="o">=</code> <code class="n">Pattern</code><code class="o">.</code><code class="na">compile</code><code class="o">(</code><code class="n">patt</code><code class="o">);</code>&#13;
        <code class="n">Matcher</code> <code class="n">m</code> <code class="o">=</code> <code class="n">r</code><code class="o">.</code><code class="na">matcher</code><code class="o">(</code><code class="n">input</code><code class="o">);</code>&#13;
        <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="s">"ReplaceAll: "</code> <code class="o">+</code> <code class="n">m</code><code class="o">.</code><code class="na">replaceAll</code><code class="o">(</code><code class="s">"favour"</code><code class="o">));</code>&#13;
&#13;
        <code class="c1">// Show the appendReplacement method</code>&#13;
        <code class="n">m</code><code class="o">.</code><code class="na">reset</code><code class="o">();</code>&#13;
        <code class="n">StringBuffer</code> <code class="n">sb</code> <code class="o">=</code> <code class="k">new</code> <code class="n">StringBuffer</code><code class="o">();</code>&#13;
        <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">print</code><code class="o">(</code><code class="s">"Append methods: "</code><code class="o">);</code>&#13;
        <code class="k">while</code> <code class="o">(</code><code class="n">m</code><code class="o">.</code><code class="na">find</code><code class="o">())</code> <code class="o">{</code>&#13;
            <code class="c1">// Copy to before first match,</code>&#13;
            <code class="c1">// plus the word "favor"</code>&#13;
            <code class="n">m</code><code class="o">.</code><code class="na">appendReplacement</code><code class="o">(</code><code class="n">sb</code><code class="o">,</code> <code class="s">"favour"</code><code class="o">);</code>&#13;
        <code class="o">}</code>&#13;
        <code class="n">m</code><code class="o">.</code><code class="na">appendTail</code><code class="o">(</code><code class="n">sb</code><code class="o">);</code>        <code class="c1">// copy remainder</code>&#13;
        <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="n">sb</code><code class="o">.</code><code class="na">toString</code><code class="o">());</code>&#13;
    <code class="o">}</code>&#13;
<code class="o">}</code></pre></div>&#13;
&#13;
<p>Sure enough, when you run it, it does what we expect:</p>&#13;
&#13;
<pre data-type="programlisting">Input: Do me a favor? Fetch my favorite.&#13;
ReplaceAll: Do me a favour? Fetch my favorite.&#13;
Append methods: Do me a favour? Fetch my favorite.</pre>&#13;
&#13;
<p>The <a data-primary="replaceAll() method" data-type="indexterm" id="idm45290685536792"/><code>replaceAll()</code> method handles the case of making the same change&#13;
all through a string.&#13;
If you want to change each matching occurrence to a different value,&#13;
you can use <a data-primary="replaceFirst() method" data-type="indexterm" id="idm45290685343672"/><code>replaceFirst()</code> in a loop, as in <a data-type="xref" href="#javacook-regex-EX-2b">Example 4-4</a>.&#13;
Here we make a pass through an entire string, turning each occurrence&#13;
of either <code>cat</code> or <code>dog</code> into <code>feline</code> or <code>canine</code>.&#13;
This is simplified from a real example that looked for <em>bit.ly</em> URLs&#13;
and replaced them with the actual URL; the <a data-primary="computeReplacement method" data-type="indexterm" id="idm45290685339624"/><code>computeReplacement</code> method&#13;
there used the network client code from <a data-type="xref" href="ch12.html#javacook-netclient-rest-1">Recipe 12.1</a>.</p>&#13;
<div data-type="example" id="javacook-regex-EX-2b">&#13;
<h5><span class="label">Example 4-4. </span>main/src/main/java/regex/ReplaceMulti.java</h5>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="cm">/**</code>&#13;
<code class="cm"> * To perform multiple distinct substitutions in the same String,</code>&#13;
<code class="cm"> * you need a loop, and must call reset() on the matcher.</code>&#13;
<code class="cm"> */</code>&#13;
<code class="kd">public</code> <code class="kd">class</code> <code class="nc">ReplaceMulti</code> <code class="o">{</code>&#13;
    <code class="kd">public</code> <code class="kd">static</code> <code class="kt">void</code> <code class="nf">main</code><code class="o">(</code><code class="n">String</code><code class="o">[]</code> <code class="n">args</code><code class="o">)</code> <code class="o">{</code>&#13;
&#13;
        <code class="n">Pattern</code> <code class="n">patt</code> <code class="o">=</code> <code class="n">Pattern</code><code class="o">.</code><code class="na">compile</code><code class="o">(</code><code class="s">"cat|dog"</code><code class="o">);</code>&#13;
        <code class="n">String</code> <code class="n">line</code> <code class="o">=</code> <code class="s">"The cat and the dog never got along well."</code><code class="o">;</code>&#13;
        <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="s">"Input: "</code> <code class="o">+</code> <code class="n">line</code><code class="o">);</code>&#13;
        <code class="n">Matcher</code> <code class="n">matcher</code> <code class="o">=</code> <code class="n">patt</code><code class="o">.</code><code class="na">matcher</code><code class="o">(</code><code class="n">line</code><code class="o">);</code>&#13;
        <code class="k">while</code> <code class="o">(</code><code class="n">matcher</code><code class="o">.</code><code class="na">find</code><code class="o">())</code> <code class="o">{</code>&#13;
            <code class="n">String</code> <code class="n">found</code> <code class="o">=</code> <code class="n">matcher</code><code class="o">.</code><code class="na">group</code><code class="o">(</code><code class="mi">0</code><code class="o">);</code>&#13;
            <code class="n">String</code> <code class="n">replacement</code> <code class="o">=</code> <code class="n">computeReplacement</code><code class="o">(</code><code class="n">found</code><code class="o">);</code>&#13;
            <code class="n">line</code> <code class="o">=</code> <code class="n">matcher</code><code class="o">.</code><code class="na">replaceFirst</code><code class="o">(</code><code class="n">replacement</code><code class="o">);</code>&#13;
            <code class="n">matcher</code><code class="o">.</code><code class="na">reset</code><code class="o">(</code><code class="n">line</code><code class="o">);</code>&#13;
        <code class="o">}</code>&#13;
        <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="s">"Final: "</code> <code class="o">+</code> <code class="n">line</code><code class="o">);</code>&#13;
    <code class="o">}</code>&#13;
&#13;
    <code class="kd">static</code> <code class="n">String</code> <code class="nf">computeReplacement</code><code class="o">(</code><code class="n">String</code> <code class="n">in</code><code class="o">)</code> <code class="o">{</code>&#13;
        <code class="k">switch</code><code class="o">(</code><code class="n">in</code><code class="o">)</code> <code class="o">{</code>&#13;
        <code class="k">case</code> <code class="s">"cat"</code><code class="o">:</code> <code class="k">return</code> <code class="s">"feline"</code><code class="o">;</code>&#13;
        <code class="k">case</code> <code class="s">"dog"</code><code class="o">:</code> <code class="k">return</code> <code class="s">"canine"</code><code class="o">;</code>&#13;
        <code class="k">default</code><code class="o">:</code> <code class="k">return</code> <code class="s">"animal"</code><code class="o">;</code>&#13;
        <code class="o">}</code>&#13;
    <code class="o">}</code>&#13;
<code class="o">}</code></pre></div>&#13;
&#13;
<p>If you need to refer to portions of the occurrence that matched the regex,&#13;
you can mark them with extra parentheses in the pattern and&#13;
refer to the matching portion with <code>$1</code>, <code>$2</code>, and so on in the replacement&#13;
string.&#13;
<a data-type="xref" href="#javacook-regex-EX-2c">Example 4-5</a> uses this to interchange two fields, in this case,&#13;
turn names in the form <code>Firstname Lastname</code> into <code>Lastname, FirstName</code>.<a data-primary="" data-startref="pm_rmt" data-type="indexterm" id="idm45290685147432"/></p>&#13;
<div data-type="example" id="javacook-regex-EX-2c">&#13;
<h5><span class="label">Example 4-5. </span>main/src/main/java/regex/ReplaceDemo2.java</h5>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">class</code> <code class="nc">ReplaceDemo2</code> <code class="o">{</code>&#13;
    <code class="kd">public</code> <code class="kd">static</code> <code class="kt">void</code> <code class="nf">main</code><code class="o">(</code><code class="n">String</code><code class="o">[]</code> <code class="n">argv</code><code class="o">)</code> <code class="o">{</code>&#13;
&#13;
        <code class="c1">// Make an RE pattern</code>&#13;
        <code class="n">String</code> <code class="n">patt</code> <code class="o">=</code> <code class="s">"(\\w+)\\s+(\\w+)"</code><code class="o">;</code>&#13;
&#13;
        <code class="c1">// A test input</code>&#13;
        <code class="n">String</code> <code class="n">input</code> <code class="o">=</code> <code class="s">"Ian Darwin"</code><code class="o">;</code>&#13;
        <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="s">"Input: "</code> <code class="o">+</code> <code class="n">input</code><code class="o">);</code>&#13;
&#13;
        <code class="c1">// Run it from a RE instance and see that it works</code>&#13;
        <code class="n">Pattern</code> <code class="n">r</code> <code class="o">=</code> <code class="n">Pattern</code><code class="o">.</code><code class="na">compile</code><code class="o">(</code><code class="n">patt</code><code class="o">);</code>&#13;
        <code class="n">Matcher</code> <code class="n">m</code> <code class="o">=</code> <code class="n">r</code><code class="o">.</code><code class="na">matcher</code><code class="o">(</code><code class="n">input</code><code class="o">);</code>&#13;
        <code class="n">m</code><code class="o">.</code><code class="na">find</code><code class="o">();</code>&#13;
        <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="s">"Replaced: "</code> <code class="o">+</code> <code class="n">m</code><code class="o">.</code><code class="na">replaceFirst</code><code class="o">(</code><code class="s">"$2, $1"</code><code class="o">));</code>&#13;
&#13;
        <code class="c1">// The short inline version:</code>&#13;
        <code class="c1">// System.out.println(input.replaceFirst("(\\w+)\\s+(\\w+)", "$2, $1"));</code>&#13;
    <code class="o">}</code>&#13;
<code class="o">}</code></pre></div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="4.5 Printing All Occurrences of a Pattern" data-type="sect1"><div class="sect1" id="javacook-regex-SECT-5">&#13;
<h1>4.5 Printing All Occurrences of a Pattern</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="javacook-regex-SECT-5.1">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="pattern matching" data-secondary="printing occurrences of" data-type="indexterm" id="pm_po"/><a data-primary="printing" data-type="indexterm" id="p_po"/>You need to find all the strings that match a given regex in one or more files or other sources.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="javacook-regex-SECT-5.2">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>This example reads through a file one line at a time. Whenever a match is found, I extract it from the <code>line</code> and print it.</p>&#13;
&#13;
<p>This code takes the <a data-primary="group() method" data-type="indexterm" id="idm45290685098584"/><code>group()</code> methods from <a data-type="xref" href="#javacook-regex-SECT-3">Recipe 4.3</a>, the <a data-primary="substring() method" data-type="indexterm" id="idm45290685096216"/><code>substring</code> method from the <code>CharacterIterator</code> interface, and the <a data-primary="match() method" data-type="indexterm" id="idm45290685094680"/><code>match()</code> method from the regex and simply puts them all together. I coded it to extract all the names from a given file; in running the program through itself, it prints the words <code>import</code>, <code>java</code>, <code>until</code>, <code>regex</code>, and so on, each on its own line:</p>&#13;
<pre data-type="programlisting" id="I_4_tt121">&#13;
C:\&gt; <strong>java ReaderIter.java ReaderIter.java</strong>&#13;
import&#13;
java&#13;
util&#13;
regex&#13;
import&#13;
java&#13;
io&#13;
Print&#13;
all&#13;
the&#13;
strings&#13;
that&#13;
match&#13;
given&#13;
pattern&#13;
from&#13;
file&#13;
public&#13;
...&#13;
C:\\&gt;</pre>&#13;
&#13;
<p>I interrupted it here to save paper. This can be written two ways: a line-at-a-time pattern shown in <a data-type="xref" href="#javacook-regex-EX-3">Example 4-6</a> and a more compact form using new I/O shown in <a data-type="xref" href="#javacook-regex-EX-4">Example 4-7</a> (the new I/O package used in both examples is described in <a data-type="xref" href="ch10.html#javacook-io">Chapter 10</a>).</p>&#13;
<div data-type="example" id="javacook-regex-EX-3">&#13;
<h5><span class="label">Example 4-6. </span>main/src/main/java/regex/ReaderIter.java</h5>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">class</code> <code class="nc">ReaderIter</code> <code class="o">{</code>&#13;
    <code class="kd">public</code> <code class="kd">static</code> <code class="kt">void</code> <code class="nf">main</code><code class="o">(</code><code class="n">String</code><code class="o">[]</code> <code class="n">args</code><code class="o">)</code> <code class="kd">throws</code> <code class="n">IOException</code> <code class="o">{</code>&#13;
        <code class="c1">// The RE pattern</code>&#13;
        <code class="n">Pattern</code> <code class="n">patt</code> <code class="o">=</code> <code class="n">Pattern</code><code class="o">.</code><code class="na">compile</code><code class="o">(</code><code class="s">"[A-Za-z][a-z]+"</code><code class="o">);</code>&#13;
        <code class="c1">// See the I/O chapter</code>&#13;
        <code class="c1">// For each line of input, try matching in it.</code>&#13;
        <code class="n">Files</code><code class="o">.</code><code class="na">lines</code><code class="o">(</code><code class="n">Path</code><code class="o">.</code><code class="na">of</code><code class="o">(</code><code class="n">args</code><code class="o">[</code><code class="mi">0</code><code class="o">])).</code><code class="na">forEach</code><code class="o">(</code><code class="n">line</code> <code class="o">-&gt;</code> <code class="o">{</code>&#13;
            <code class="c1">// For each match in the line, extract and print it.</code>&#13;
            <code class="n">Matcher</code> <code class="n">m</code> <code class="o">=</code> <code class="n">patt</code><code class="o">.</code><code class="na">matcher</code><code class="o">(</code><code class="n">line</code><code class="o">);</code>&#13;
            <code class="k">while</code> <code class="o">(</code><code class="n">m</code><code class="o">.</code><code class="na">find</code><code class="o">())</code> <code class="o">{</code>&#13;
                <code class="c1">// Simplest method:</code>&#13;
                <code class="c1">// System.out.println(m.group(0));</code>&#13;
&#13;
                <code class="c1">// Get the starting position of the text</code>&#13;
                <code class="kt">int</code> <code class="n">start</code> <code class="o">=</code> <code class="n">m</code><code class="o">.</code><code class="na">start</code><code class="o">(</code><code class="mi">0</code><code class="o">);</code>&#13;
                <code class="c1">// Get ending position</code>&#13;
                <code class="kt">int</code> <code class="n">end</code> <code class="o">=</code> <code class="n">m</code><code class="o">.</code><code class="na">end</code><code class="o">(</code><code class="mi">0</code><code class="o">);</code>&#13;
                <code class="c1">// Print whatever matched.</code>&#13;
                <code class="c1">// Use CharacterIterator.substring(offset, end);</code>&#13;
                <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="n">line</code><code class="o">.</code><code class="na">substring</code><code class="o">(</code><code class="n">start</code><code class="o">,</code> <code class="n">end</code><code class="o">));</code>&#13;
            <code class="o">}</code>&#13;
        <code class="o">});</code>&#13;
    <code class="o">}</code>&#13;
<code class="o">}</code></pre></div>&#13;
<div data-type="example" id="javacook-regex-EX-4">&#13;
<h5><span class="label">Example 4-7. </span>main/src/main/java/regex/GrepNIO.java</h5>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">class</code> <code class="nc">GrepNIO</code> <code class="o">{</code>&#13;
    <code class="kd">public</code> <code class="kd">static</code> <code class="kt">void</code> <code class="nf">main</code><code class="o">(</code><code class="n">String</code><code class="o">[]</code> <code class="n">args</code><code class="o">)</code> <code class="kd">throws</code> <code class="n">IOException</code> <code class="o">{</code>&#13;
&#13;
        <code class="k">if</code> <code class="o">(</code><code class="n">args</code><code class="o">.</code><code class="na">length</code> <code class="o">&lt;</code> <code class="mi">2</code><code class="o">)</code> <code class="o">{</code>&#13;
            <code class="n">System</code><code class="o">.</code><code class="na">err</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="s">"Usage: GrepNIO patt file [...]"</code><code class="o">);</code>&#13;
            <code class="n">System</code><code class="o">.</code><code class="na">exit</code><code class="o">(</code><code class="mi">1</code><code class="o">);</code>&#13;
        <code class="o">}</code>&#13;
&#13;
        <code class="n">Pattern</code> <code class="n">p</code><code class="o">=</code><code class="n">Pattern</code><code class="o">.</code><code class="na">compile</code><code class="o">(</code><code class="n">args</code><code class="o">[</code><code class="mi">0</code><code class="o">]);</code>&#13;
        <code class="k">for</code> <code class="o">(</code><code class="kt">int</code> <code class="n">i</code><code class="o">=</code><code class="mi">1</code><code class="o">;</code> <code class="n">i</code><code class="o">&lt;</code><code class="n">args</code><code class="o">.</code><code class="na">length</code><code class="o">;</code> <code class="n">i</code><code class="o">++)</code>&#13;
            <code class="n">process</code><code class="o">(</code><code class="n">p</code><code class="o">,</code> <code class="n">args</code><code class="o">[</code><code class="n">i</code><code class="o">]);</code>&#13;
    <code class="o">}</code>&#13;
&#13;
    <code class="kd">static</code> <code class="kt">void</code> <code class="nf">process</code><code class="o">(</code><code class="n">Pattern</code> <code class="n">pattern</code><code class="o">,</code> <code class="n">String</code> <code class="n">fileName</code><code class="o">)</code> <code class="kd">throws</code> <code class="n">IOException</code> <code class="o">{</code>&#13;
&#13;
        <code class="c1">// Get a FileChannel from the given file</code>&#13;
        <code class="n">FileInputStream</code> <code class="n">fis</code> <code class="o">=</code> <code class="k">new</code> <code class="n">FileInputStream</code><code class="o">(</code><code class="n">fileName</code><code class="o">);</code>&#13;
        <code class="n">FileChannel</code> <code class="n">fc</code> <code class="o">=</code> <code class="n">fis</code><code class="o">.</code><code class="na">getChannel</code><code class="o">();</code>&#13;
&#13;
        <code class="c1">// Map the file's content</code>&#13;
        <code class="n">ByteBuffer</code> <code class="n">buf</code> <code class="o">=</code> <code class="n">fc</code><code class="o">.</code><code class="na">map</code><code class="o">(</code><code class="n">FileChannel</code><code class="o">.</code><code class="na">MapMode</code><code class="o">.</code><code class="na">READ_ONLY</code><code class="o">,</code> <code class="mi">0</code><code class="o">,</code> <code class="n">fc</code><code class="o">.</code><code class="na">size</code><code class="o">());</code>&#13;
&#13;
        <code class="c1">// Decode ByteBuffer into CharBuffer</code>&#13;
        <code class="n">CharBuffer</code> <code class="n">cbuf</code> <code class="o">=</code>&#13;
            <code class="n">Charset</code><code class="o">.</code><code class="na">forName</code><code class="o">(</code><code class="s">"ISO-8859-1"</code><code class="o">).</code><code class="na">newDecoder</code><code class="o">().</code><code class="na">decode</code><code class="o">(</code><code class="n">buf</code><code class="o">);</code>&#13;
&#13;
        <code class="n">Matcher</code> <code class="n">m</code> <code class="o">=</code> <code class="n">pattern</code><code class="o">.</code><code class="na">matcher</code><code class="o">(</code><code class="n">cbuf</code><code class="o">);</code>&#13;
        <code class="k">while</code> <code class="o">(</code><code class="n">m</code><code class="o">.</code><code class="na">find</code><code class="o">())</code> <code class="o">{</code>&#13;
            <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="n">m</code><code class="o">.</code><code class="na">group</code><code class="o">(</code><code class="mi">0</code><code class="o">));</code>&#13;
        <code class="o">}</code>&#13;
        <code class="n">fis</code><code class="o">.</code><code class="na">close</code><code class="o">();</code>&#13;
    <code class="o">}</code>&#13;
<code class="o">}</code></pre></div>&#13;
&#13;
<p>The non-blocking I/O (NIO) version shown in <a data-type="xref" href="#javacook-regex-EX-4">Example 4-7</a> relies on the fact that an NIO <code>Buffer</code> can be used as a <code>CharSequence</code>. This program is more general in that the pattern argument is taken from the command-line argument. It prints the same output as the previous example if invoked with the pattern argument from the previous program on the command line:</p>&#13;
<pre data-type="programlisting" id="I_4_tt122"><strong>java regex.GrepNIO "[A-Za-z][a-z]+"  ReaderIter.java</strong></pre>&#13;
&#13;
<p>You might think of using <code>\w+</code> as the pattern; the only difference is that my pattern looks for well-formed capitalized words, whereas <code>\w+</code> would include Java-centric oddities like <code>theVariableName</code>, which have capitals in nonstandard positions.</p>&#13;
&#13;
<p>Also note that the NIO version will probably be more efficient because it doesn’t reset the <code>Matcher</code> to a new input source on each line of input as <code>ReaderIter</code> does.<a data-primary="" data-startref="pm_po" data-type="indexterm" id="idm45290684689912"/><a data-primary="" data-startref="p_po" data-type="indexterm" id="idm45290684688904"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="4.6 Printing Lines Containing a Pattern" data-type="sect1"><div class="sect1" id="javacook-regex-SECT-6">&#13;
<h1>4.6 Printing Lines Containing a Pattern</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="javacook-regex-SECT-6.1">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="pattern matching" data-secondary="printing lines containing" data-type="indexterm" id="idm45290684684888"/>You need to look for lines matching a given regex in one or more files.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="javacook-regex-SECT-6.2">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Write a simple <em>grep</em>-like program.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="javacook-regex-SECT-6.3">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>As I’ve mentioned, once you have a regex package, you can write a <em>grep</em>-like program. I gave an example of the <a data-primary="grep" data-type="indexterm" id="idm45290684678680"/><a data-primary="Unix" data-secondary="grep" data-type="indexterm" id="idm45290684677976"/>Unix <em>grep</em> program earlier. <em>grep</em> is called with some optional arguments, followed by one required regular expression pattern, followed by an arbitrary number of filenames. It prints any line that contains the pattern, differing from <a data-type="xref" href="#javacook-regex-SECT-5">Recipe 4.5</a>, which prints only the matching text itself. Here’s an example:</p>&#13;
<pre data-type="programlisting" id="I_4_tt123"><strong>grep "[dD]arwin" *.txt </strong></pre>&#13;
&#13;
<p>The code searches for lines containing either <code>darwin</code> or <code>Darwin</code> in every line of every file whose name ends in <em>.txt</em>.<sup><a data-type="noteref" href="ch04.html#idm45290684672008" id="idm45290684672008-marker">3</a></sup> <a data-type="xref" href="#javacook-regex-EX-5">Example 4-8</a> is the source for the first version of a program to do this, called <em>Grep0</em>. It reads lines from the standard input and doesn’t take any optional arguments, but it handles the full set of regular expressions that the <code>Pattern</code> class implements (it is, therefore, not identical to the Unix programs of the same name). We haven’t covered the <code>java.io</code> package for input and output yet (see <a data-type="xref" href="ch10.html#javacook-io">Chapter 10</a>), but our use of it here is simple enough that you can probably intuit it. The online source includes <em>Grep1</em>, which does the same thing but is better structured (and therefore longer). Later in this chapter, <a data-type="xref" href="#javacook-regex-SECT-12">Recipe 4.11</a> presents a <em>JGrep</em> program that parses a set of command-line options.</p>&#13;
<div data-type="example" id="javacook-regex-EX-5">&#13;
<h5><span class="label">Example 4-8. </span>main/src/main/java/regex/Grep0.java</h5>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">class</code> <code class="nc">Grep0</code> <code class="o">{</code>&#13;
    <code class="kd">public</code> <code class="kd">static</code> <code class="kt">void</code> <code class="nf">main</code><code class="o">(</code><code class="n">String</code><code class="o">[]</code> <code class="n">args</code><code class="o">)</code> <code class="kd">throws</code> <code class="n">IOException</code> <code class="o">{</code>&#13;
        <code class="n">BufferedReader</code> <code class="n">is</code> <code class="o">=</code>&#13;
            <code class="k">new</code> <code class="nf">BufferedReader</code><code class="o">(</code><code class="k">new</code> <code class="n">InputStreamReader</code><code class="o">(</code><code class="n">System</code><code class="o">.</code><code class="na">in</code><code class="o">));</code>&#13;
        <code class="k">if</code> <code class="o">(</code><code class="n">args</code><code class="o">.</code><code class="na">length</code> <code class="o">!=</code> <code class="mi">1</code><code class="o">)</code> <code class="o">{</code>&#13;
            <code class="n">System</code><code class="o">.</code><code class="na">err</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="s">"Usage: MatchLines pattern"</code><code class="o">);</code>&#13;
            <code class="n">System</code><code class="o">.</code><code class="na">exit</code><code class="o">(</code><code class="mi">1</code><code class="o">);</code>&#13;
        <code class="o">}</code>&#13;
        <code class="n">Pattern</code> <code class="n">patt</code> <code class="o">=</code> <code class="n">Pattern</code><code class="o">.</code><code class="na">compile</code><code class="o">(</code><code class="n">args</code><code class="o">[</code><code class="mi">0</code><code class="o">]);</code>&#13;
        <code class="n">Matcher</code> <code class="n">matcher</code> <code class="o">=</code> <code class="n">patt</code><code class="o">.</code><code class="na">matcher</code><code class="o">(</code><code class="s">""</code><code class="o">);</code>&#13;
        <code class="n">String</code> <code class="n">line</code> <code class="o">=</code> <code class="kc">null</code><code class="o">;</code>&#13;
        <code class="k">while</code> <code class="o">((</code><code class="n">line</code> <code class="o">=</code> <code class="n">is</code><code class="o">.</code><code class="na">readLine</code><code class="o">())</code> <code class="o">!=</code> <code class="kc">null</code><code class="o">)</code> <code class="o">{</code>&#13;
            <code class="n">matcher</code><code class="o">.</code><code class="na">reset</code><code class="o">(</code><code class="n">line</code><code class="o">);</code>&#13;
            <code class="k">if</code> <code class="o">(</code><code class="n">matcher</code><code class="o">.</code><code class="na">find</code><code class="o">())</code> <code class="o">{</code>&#13;
                <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="s">"MATCH: "</code> <code class="o">+</code> <code class="n">line</code><code class="o">);</code>&#13;
            <code class="o">}</code>&#13;
        <code class="o">}</code>&#13;
    <code class="o">}</code>&#13;
<code class="o">}</code></pre></div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="4.7 Controlling Case in Regular Expressions" data-type="sect1"><div class="sect1" id="javacook-regex-SECT-7">&#13;
<h1>4.7 Controlling Case in Regular Expressions</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="javacook-regex-SECT-7.1">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="case" data-type="indexterm" id="idm45290684422824"/><a data-primary="regular expressions (regex)" data-secondary="controlling case in" data-type="indexterm" id="idm45290684422120"/>You want to find text regardless of case.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="javacook-regex-SECT-7.2">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Compile the <code>Pattern</code> passing in the <code>flags</code> argument <code>Pattern.CASE_INSENSITIVE</code> <span class="keep-together">to indicate</span> that matching should be case-independent (i.e., that it should fold, ignore differences in case). If your code might run in different locales (see&#13;
<a data-type="xref" href="ch03.html#javacook-i18n-SECT-8">Recipe 3.12</a>), <span class="keep-together">then you</span> should add <code>Pattern.UNICODE_CASE</code>. Without these flags, the default is normal, case-sensitive matching behavior. This flag (and others) are passed to the <a data-primary="Pattern.compile() method" data-type="indexterm" id="idm45290684414424"/><span class="keep-together"><code>Pattern.compile()</code></span> method, like this:</p>&#13;
&#13;
<pre data-type="programlisting">// regex/CaseMatch.java&#13;
Pattern  reCaseInsens = Pattern.compile(pattern, Pattern.CASE_INSENSITIVE |&#13;
    Pattern.UNICODE_CASE);&#13;
reCaseInsens.matches(input);        // will match case-insensitively</pre>&#13;
&#13;
<p>This flag must be passed when you create the <code>Pattern</code>; because <code>Pattern</code> objects are immutable, they cannot be changed once constructed.</p>&#13;
&#13;
<p>The full source code for this example is online as <em>CaseMatch.java</em>.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="javacook-regex-SIDEBAR-2">&#13;
<h5>Pattern.compile() Flags</h5>&#13;
<p>Half a dozen flags can be passed as the second argument to <code>Pattern.compile()</code>. If more than one value is needed, they can be or’d together using the bitwise or operator <code>|</code>. In alphabetical order, these are the flags:</p>&#13;
<dl>&#13;
<dt><a data-primary="CANON-EQ flag" data-type="indexterm" id="idm45290684406776"/><code>CANON_EQ</code></dt>&#13;
<dd>&#13;
<p>Enables so-called canonical equivalence. In other words, characters are matched by their base character so that the character <code>e</code> followed by the combining character mark for the acute accent (<code>´</code>) can be matched either by the composite character <code>é</code> or the letter <code>e</code> followed by the character mark for the accent (see <a data-type="xref" href="#javacook-regex-SECT-8">Recipe 4.8</a>).</p>&#13;
</dd>&#13;
<dt><a data-primary="CASE_INSENSITIVE flag" data-type="indexterm" id="idm45290684401416"/><code>CASE_INSENSITIVE</code></dt>&#13;
<dd>&#13;
<p>Turns on case-insensitive matching (see <a data-type="xref" href="#javacook-regex-SECT-7">Recipe 4.7</a>).</p>&#13;
</dd>&#13;
<dt><a data-primary="COMMENTS flag (regex)" data-type="indexterm" id="idm45290684398408"/><code>COMMENTS</code></dt>&#13;
<dd>&#13;
<p>Causes whitespace and comments (from <code>#</code> to end-of-line) to be ignored in the pattern. See <em>CommentedRegEx.java</em> in the <em>regex</em> source directory.</p>&#13;
</dd>&#13;
<dt><a data-primary="DOTALL flag" data-type="indexterm" id="idm45290684394920"/><code>DOTALL</code></dt>&#13;
<dd>&#13;
<p>Allows dot (.) to match any regular character or the newline, not just any regular character other than newline (see <a data-type="xref" href="#javacook-regex-SECT-9">Recipe 4.9</a>).</p>&#13;
</dd>&#13;
<dt><a data-primary="MULTILINE flag" data-type="indexterm" id="idm45290684391848"/><code>MULTILINE</code></dt>&#13;
<dd>&#13;
<p>Specifies multiline mode (see <a data-type="xref" href="#javacook-regex-SECT-9">Recipe 4.9</a>).</p>&#13;
</dd>&#13;
<dt><a data-primary="UNICODE_CASE flag" data-type="indexterm" id="idm45290684388904"/><code>UNICODE_CASE</code></dt>&#13;
<dd>&#13;
<p>Enables Unicode-aware case folding (see <a data-type="xref" href="#javacook-regex-SECT-7">Recipe 4.7</a>).</p>&#13;
</dd>&#13;
<dt><a data-primary="UNIX_LINES flag" data-type="indexterm" id="idm45290684385896"/><code>UNIX_LINES</code></dt>&#13;
<dd>&#13;
<p>Makes <code>\n</code> the only valid newline sequence for <code>MULTILINE</code> mode (see <a data-type="xref" href="#javacook-regex-SECT-9">Recipe 4.9</a>).</p>&#13;
</dd>&#13;
</dl>&#13;
</div></aside>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="4.8 Matching Accented, or Composite, Characters" data-type="sect1"><div class="sect1" id="javacook-regex-SECT-8">&#13;
<h1>4.8 Matching Accented, or Composite, Characters</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="javacook-regex-SECT-8.1">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="accented characters" data-type="indexterm" id="idm45290684379048"/><a data-primary="composite characters, matching" data-type="indexterm" id="idm45290684378344"/><a data-primary="pattern matching" data-secondary="accented characters" data-type="indexterm" id="idm45290684377656"/><a data-primary="pattern matching" data-secondary="composite characters" data-type="indexterm" id="idm45290684376712"/>You want characters to match regardless of the form in which they are entered.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="javacook-regex-SECT-8.2">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Compile the <code>Pattern</code> with the <code>flags</code> argument <code>Pattern.CANON_EQ</code> for canonical <span class="keep-together">equality</span>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="javacook-regex-SECT-8.3">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>Composite characters can be entered in various forms. Consider, as a single example, the letter <code>e</code> with an acute accent. This character may be found in various forms in Unicode text, such as the single character <code>é</code> (Unicode character <code>\u00e9</code>) or the two-character sequence <code>e´</code> (e followed by the Unicode combining acute accent, <code>\u0301</code>). To allow you to match such characters regardless of which of possibly multiple fully decomposed forms are used to enter them, the regex package has an option for <a data-primary="canonical matching" data-type="indexterm" id="idm45290684366872"/><em>canonical matching</em>, which treats any of the forms as equivalent. This option is enabled by passing <code>CANON_EQ</code> as (one of) the flags in the second argument to <code>Pattern.compile()</code>. This program shows <code>CANON_EQ</code> being used to match several forms:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">class</code> <code class="nc">CanonEqDemo</code> <code class="o">{</code>&#13;
    <code class="kd">public</code> <code class="kd">static</code> <code class="kt">void</code> <code class="nf">main</code><code class="o">(</code><code class="n">String</code><code class="o">[]</code> <code class="n">args</code><code class="o">)</code> <code class="o">{</code>&#13;
        <code class="n">String</code> <code class="n">pattStr</code> <code class="o">=</code> <code class="s">"\u00e9gal"</code><code class="o">;</code> <code class="c1">// egal</code>&#13;
        <code class="n">String</code><code class="o">[]</code> <code class="n">input</code> <code class="o">=</code> <code class="o">{</code>&#13;
                <code class="s">"\u00e9gal"</code><code class="o">,</code> <code class="c1">// egal - this one had better match :-)</code>&#13;
                <code class="s">"e\u0301gal"</code><code class="o">,</code> <code class="c1">// e + "Combining acute accent"</code>&#13;
                <code class="s">"e\u02cagal"</code><code class="o">,</code> <code class="c1">// e + "modifier letter acute accent"</code>&#13;
                <code class="s">"e'gal"</code><code class="o">,</code> <code class="c1">// e + single quote</code>&#13;
                <code class="s">"e\u00b4gal"</code><code class="o">,</code> <code class="c1">// e + Latin-1 "acute"</code>&#13;
        <code class="o">};</code>&#13;
        <code class="n">Pattern</code> <code class="n">pattern</code> <code class="o">=</code> <code class="n">Pattern</code><code class="o">.</code><code class="na">compile</code><code class="o">(</code><code class="n">pattStr</code><code class="o">,</code> <code class="n">Pattern</code><code class="o">.</code><code class="na">CANON_EQ</code><code class="o">);</code>&#13;
        <code class="k">for</code> <code class="o">(</code><code class="kt">int</code> <code class="n">i</code> <code class="o">=</code> <code class="mi">0</code><code class="o">;</code> <code class="n">i</code> <code class="o">&lt;</code> <code class="n">input</code><code class="o">.</code><code class="na">length</code><code class="o">;</code> <code class="n">i</code><code class="o">++)</code> <code class="o">{</code>&#13;
            <code class="k">if</code> <code class="o">(</code><code class="n">pattern</code><code class="o">.</code><code class="na">matcher</code><code class="o">(</code><code class="n">input</code><code class="o">[</code><code class="n">i</code><code class="o">]).</code><code class="na">matches</code><code class="o">())</code> <code class="o">{</code>&#13;
                <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code>&#13;
                    <code class="n">pattStr</code> <code class="o">+</code> <code class="s">" matches input "</code> <code class="o">+</code> <code class="n">input</code><code class="o">[</code><code class="n">i</code><code class="o">]);</code>&#13;
            <code class="o">}</code> <code class="k">else</code> <code class="o">{</code>&#13;
                <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code>&#13;
                    <code class="n">pattStr</code> <code class="o">+</code> <code class="s">" does not match input "</code> <code class="o">+</code> <code class="n">input</code><code class="o">[</code><code class="n">i</code><code class="o">]);</code>&#13;
            <code class="o">}</code>&#13;
        <code class="o">}</code>&#13;
    <code class="o">}</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p>This program correctly matches the combining accent and rejects the other characters, some of which, unfortunately, look like the accent on a printer, but are not considered combining accent characters:</p>&#13;
&#13;
<pre data-type="programlisting">égal matches input égal&#13;
égal matches input e?gal&#13;
égal does not match input e?gal&#13;
égal does not match input e'gal&#13;
égal does not match input e´gal</pre>&#13;
&#13;
<p>For more details, see the <a href="http://www.unicode.org">character charts</a>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="4.9 Matching Newlines in Text" data-type="sect1"><div class="sect1" id="javacook-regex-SECT-9">&#13;
<h1>4.9 Matching Newlines in Text</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="javacook-regex-SECT-9.1">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="newlines, matching in text" data-type="indexterm" id="idm45290684157976"/><a data-primary="pattern matching" data-secondary="newlines in text" data-type="indexterm" id="idm45290684157304"/>You need to match newlines in text.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="javacook-regex-SECT-9.2">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Use <code>\n</code> or <code>\r</code> in your regex pattern. See also the flags constant <code>Pattern.MULTILINE</code>, which makes newlines match as beginning-of-line and end-of-line (<code>\^</code> and <code>$</code>).</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="javacook-regex-SECT-9.3">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>Though line-oriented tools from Unix such as<a data-primary="sed" data-type="indexterm" id="idm45290684363928"/><a data-primary="grep" data-type="indexterm" id="idm45290684149240"/> <em>sed</em> and <em>grep</em> match regular expressions one line at a time, not all tools do. The <a data-primary="sam text editor" data-type="indexterm" id="idm45290684147576"/><em>sam</em> text editor from Bell Laboratories was the first interactive tool I know of to allow multiline regular expressions; the Perl scripting language followed shortly after. In the Java API, the newline character by default has no special significance. The <code>BufferedReader</code> method <code>readLine()</code> normally strips out whichever newline characters it finds. If you read in gobs of characters using some method other than <code>readLine()</code>, you may have some number of <code>\n</code>, <code>\r</code>, or <code>\r\n</code> sequences in your text string.<sup><a data-type="noteref" href="ch04.html#idm45290684143384" id="idm45290684143384-marker">4</a></sup> Normally all of these are treated as equivalent to <code>\n</code>. If you want only <code>\n</code> to match, use the <code>UNIX_LINES</code> flag to the <code>Pattern.compile()</code> method.</p>&#13;
&#13;
<p>In Unix, <code>^</code> and <code>$</code> are commonly used to match the beginning or end of a line, respectively. In this API, the regex metacharacters <code>\^</code> and <code>$</code> ignore line terminators and only match at the beginning and the end, respectively, of the entire string. However, if you pass the <code>MULTILINE</code> flag into <a data-primary="Pattern.compile() method" data-type="indexterm" id="idm45290684136584"/><code>Pattern.compile()</code>, these expressions match just after or just before, respectively, a line terminator; <code>$</code> also matches the very end of the string. Because the line ending is just an ordinary character, you can match it with . or similar expressions; and, if you want to know exactly where it is, <code>\n</code> or <code>\r</code> in the pattern match it as well. In other words, to this API, a newline character is just another character with no special significance. See the sidebar <a data-type="xref" href="#javacook-regex-SIDEBAR-2">“Pattern.compile() Flags”</a>. An example of newline matching is shown in <a data-type="xref" href="#javacook-regex-EX-6">Example 4-9</a>.</p>&#13;
<div data-type="example" id="javacook-regex-EX-6">&#13;
<h5><span class="label">Example 4-9. </span>main/src/main/java/regex/NLMatch.java</h5>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">class</code> <code class="nc">NLMatch</code> <code class="o">{</code>&#13;
    <code class="kd">public</code> <code class="kd">static</code> <code class="kt">void</code> <code class="nf">main</code><code class="o">(</code><code class="n">String</code><code class="o">[]</code> <code class="n">argv</code><code class="o">)</code> <code class="o">{</code>&#13;
&#13;
        <code class="n">String</code> <code class="n">input</code> <code class="o">=</code> <code class="s">"I dream of engines\nmore engines, all day long"</code><code class="o">;</code>&#13;
        <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="s">"INPUT: "</code> <code class="o">+</code> <code class="n">input</code><code class="o">);</code>&#13;
        <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">();</code>&#13;
&#13;
        <code class="n">String</code><code class="o">[]</code> <code class="n">patt</code> <code class="o">=</code> <code class="o">{</code>&#13;
            <code class="s">"engines.more engines"</code><code class="o">,</code>&#13;
            <code class="s">"ines\nmore"</code><code class="o">,</code>&#13;
            <code class="s">"engines$"</code>&#13;
        <code class="o">};</code>&#13;
&#13;
        <code class="k">for</code> <code class="o">(</code><code class="kt">int</code> <code class="n">i</code> <code class="o">=</code> <code class="mi">0</code><code class="o">;</code> <code class="n">i</code> <code class="o">&lt;</code> <code class="n">patt</code><code class="o">.</code><code class="na">length</code><code class="o">;</code> <code class="n">i</code><code class="o">++)</code> <code class="o">{</code>&#13;
            <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="s">"PATTERN "</code> <code class="o">+</code> <code class="n">patt</code><code class="o">[</code><code class="n">i</code><code class="o">]);</code>&#13;
&#13;
            <code class="kt">boolean</code> <code class="n">found</code><code class="o">;</code>&#13;
            <code class="n">Pattern</code> <code class="n">p1l</code> <code class="o">=</code> <code class="n">Pattern</code><code class="o">.</code><code class="na">compile</code><code class="o">(</code><code class="n">patt</code><code class="o">[</code><code class="n">i</code><code class="o">]);</code>&#13;
            <code class="n">found</code> <code class="o">=</code> <code class="n">p1l</code><code class="o">.</code><code class="na">matcher</code><code class="o">(</code><code class="n">input</code><code class="o">).</code><code class="na">find</code><code class="o">();</code>&#13;
            <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="s">"DEFAULT match "</code> <code class="o">+</code> <code class="n">found</code><code class="o">);</code>&#13;
&#13;
            <code class="n">Pattern</code> <code class="n">pml</code> <code class="o">=</code> <code class="n">Pattern</code><code class="o">.</code><code class="na">compile</code><code class="o">(</code><code class="n">patt</code><code class="o">[</code><code class="n">i</code><code class="o">],</code>&#13;
                <code class="n">Pattern</code><code class="o">.</code><code class="na">DOTALL</code><code class="o">|</code><code class="n">Pattern</code><code class="o">.</code><code class="na">MULTILINE</code><code class="o">);</code>&#13;
            <code class="n">found</code> <code class="o">=</code> <code class="n">pml</code><code class="o">.</code><code class="na">matcher</code><code class="o">(</code><code class="n">input</code><code class="o">).</code><code class="na">find</code><code class="o">();</code>&#13;
            <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="s">"MultiLine match "</code> <code class="o">+</code> <code class="n">found</code><code class="o">);</code>&#13;
            <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">();</code>&#13;
        <code class="o">}</code>&#13;
    <code class="o">}</code>&#13;
<code class="o">}</code></pre></div>&#13;
&#13;
<p>If you run this code, the first pattern (with the wildcard character .) always matches, whereas the second pattern (with <code>$</code>) matches only when <code>MATCH_MULTILINE</code> is set:</p>&#13;
<pre data-type="programlisting" id="I_4_tt127">&gt; <strong>java regex.NLMatch</strong>&#13;
INPUT: I dream of engines&#13;
more engines, all day long&#13;
&#13;
PATTERN engines&#13;
more engines&#13;
DEFAULT match true&#13;
MULTILINE match: true&#13;
&#13;
PATTERN engines$&#13;
DEFAULT match false&#13;
MULTILINE match: true</pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="4.10 Program: Apache Logfile Parsing" data-type="sect1"><div class="sect1" id="javacook-regex-SECT-10">&#13;
<h1>4.10 Program: Apache Logfile Parsing</h1>&#13;
&#13;
<p>The Apache<a data-primary="Apache Logfile Parsing program" data-type="indexterm" id="idm45290683948584"/> web server is the world’s leading web server and has been for most of the web’s history. It is one of the world’s best-known open source projects, and it’s the first of many fostered by the Apache Foundation. The name Apache is often claimed to be a pun on the origins of the server; its developers began with the free NCSA server and kept hacking at it, or patching, it until it did what they wanted. When it was sufficiently different from the original, a new name was needed. Because it was now a patchy server, the name Apache was chosen. Officialdom denies the story, but it’s cute anyway. One place actual patchiness does show through is in the logfile format. Consider <a data-type="xref" href="#apache-example">Example 4-10</a>.</p>&#13;
<div data-type="example" id="apache-example">&#13;
<h5><span class="label">Example 4-10. </span>Apache log file excerpt</h5>&#13;
&#13;
<pre data-type="programlisting">123.45.67.89 - - [27/Oct/2000:09:27:09 -0400] "GET /java/javaResources.html&#13;
HTTP/1.0" 200 10450 "-" "Mozilla/4.6 [en] (X11; U; OpenBSD 2.8 i386; Nav)"</pre></div>&#13;
&#13;
<p>The file format was obviously designed for human inspection but not for easy parsing. The problem is that different delimiters are used: square brackets for the date, quotes for the request line, and spaces sprinkled all through. Consider trying to use a <code>StringTokenizer</code>; you might be able to get it working, but you’d spend a lot of time fiddling with it. Actually, no, you wouldn’t get it working. However, this somewhat contorted regular expression<sup><a data-type="noteref" href="ch04.html#idm45290683942808" id="idm45290683942808-marker">5</a></sup> makes it easy to parse (this is one single Moby-sized regex; we had to break it over two lines to make it fit the book’s margins):</p>&#13;
&#13;
<pre data-type="programlisting">\^([\d.]+) (\S+) (\S+) \[([\w:/]+\s[+\-]\d{4})\] "(.+?)" (\d{3}) (\d+)&#13;
  "([\^"]+)" "([\^"]+)"</pre>&#13;
&#13;
<p>You may find it informative to refer back to <a data-type="xref" href="#javacook-regex-TABLE-2">Table 4-1</a> and review the full syntax used here. Note in particular the use of the nongreedy quantifier <code>+?</code> in <code>\"(.+?)\</code>" to match a quoted string; you can’t just use <code>.+</code> because that would match too much (up to the quote at the end of the line). Code to extract the various fields such as IP address, request, referrer URL, and browser version is shown in <a data-type="xref" href="#javacook-regex-EX-7">Example 4-11</a>.</p>&#13;
<div data-type="example" id="javacook-regex-EX-7">&#13;
<h5><span class="label">Example 4-11. </span>main/src/main/java/regex/LogRegExp.java</h5>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">class</code> <code class="nc">LogRegExp</code> <code class="o">{</code>&#13;
&#13;
    <code class="kd">final</code> <code class="kd">static</code> <code class="n">String</code> <code class="n">logEntryPattern</code> <code class="o">=</code>&#13;
            <code class="s">"^([\\d.]+) (\\S+) (\\S+) \\[([\\w:/]+\\s[+-]\\d{4})\\] "</code> <code class="o">+</code>&#13;
            <code class="s">"\"(.+?)\" (\\d{3}) (\\d+) \"([^\"]+)\" \"([^\"]+)\""</code><code class="o">;</code>&#13;
&#13;
    <code class="kd">public</code> <code class="kd">static</code> <code class="kt">void</code> <code class="nf">main</code><code class="o">(</code><code class="n">String</code> <code class="n">argv</code><code class="o">[])</code> <code class="o">{</code>&#13;
&#13;
        <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="s">"RE Pattern:"</code><code class="o">);</code>&#13;
        <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="n">logEntryPattern</code><code class="o">);</code>&#13;
&#13;
        <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="s">"Input line is:"</code><code class="o">);</code>&#13;
        <code class="n">String</code> <code class="n">logEntryLine</code> <code class="o">=</code> <code class="n">LogParseInfo</code><code class="o">.</code><code class="na">LOG_ENTRY_LINE</code><code class="o">;</code>&#13;
        <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="n">logEntryLine</code><code class="o">);</code>&#13;
&#13;
        <code class="n">Pattern</code> <code class="n">p</code> <code class="o">=</code> <code class="n">Pattern</code><code class="o">.</code><code class="na">compile</code><code class="o">(</code><code class="n">logEntryPattern</code><code class="o">);</code>&#13;
        <code class="n">Matcher</code> <code class="n">matcher</code> <code class="o">=</code> <code class="n">p</code><code class="o">.</code><code class="na">matcher</code><code class="o">(</code><code class="n">logEntryLine</code><code class="o">);</code>&#13;
        <code class="k">if</code> <code class="o">(!</code><code class="n">matcher</code><code class="o">.</code><code class="na">matches</code><code class="o">()</code> <code class="o">||</code>&#13;
            <code class="n">LogParseInfo</code><code class="o">.</code><code class="na">MIN_FIELDS</code> <code class="o">&gt;</code> <code class="n">matcher</code><code class="o">.</code><code class="na">groupCount</code><code class="o">())</code> <code class="o">{</code>&#13;
            <code class="n">System</code><code class="o">.</code><code class="na">err</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="s">"Bad log entry (or problem with regex):"</code><code class="o">);</code>&#13;
            <code class="n">System</code><code class="o">.</code><code class="na">err</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="n">logEntryLine</code><code class="o">);</code>&#13;
            <code class="k">return</code><code class="o">;</code>&#13;
        <code class="o">}</code>&#13;
        <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="s">"IP Address: "</code> <code class="o">+</code> <code class="n">matcher</code><code class="o">.</code><code class="na">group</code><code class="o">(</code><code class="mi">1</code><code class="o">));</code>&#13;
        <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="s">"UserName: "</code> <code class="o">+</code> <code class="n">matcher</code><code class="o">.</code><code class="na">group</code><code class="o">(</code><code class="mi">3</code><code class="o">));</code>&#13;
        <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="s">"Date/Time: "</code> <code class="o">+</code> <code class="n">matcher</code><code class="o">.</code><code class="na">group</code><code class="o">(</code><code class="mi">4</code><code class="o">));</code>&#13;
        <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="s">"Request: "</code> <code class="o">+</code> <code class="n">matcher</code><code class="o">.</code><code class="na">group</code><code class="o">(</code><code class="mi">5</code><code class="o">));</code>&#13;
        <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="s">"Response: "</code> <code class="o">+</code> <code class="n">matcher</code><code class="o">.</code><code class="na">group</code><code class="o">(</code><code class="mi">6</code><code class="o">));</code>&#13;
        <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="s">"Bytes Sent: "</code> <code class="o">+</code> <code class="n">matcher</code><code class="o">.</code><code class="na">group</code><code class="o">(</code><code class="mi">7</code><code class="o">));</code>&#13;
        <code class="k">if</code> <code class="o">(!</code><code class="n">matcher</code><code class="o">.</code><code class="na">group</code><code class="o">(</code><code class="mi">8</code><code class="o">).</code><code class="na">equals</code><code class="o">(</code><code class="s">"-"</code><code class="o">))</code>&#13;
            <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="s">"Referer: "</code> <code class="o">+</code> <code class="n">matcher</code><code class="o">.</code><code class="na">group</code><code class="o">(</code><code class="mi">8</code><code class="o">));</code>&#13;
        <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="s">"User-Agent: "</code> <code class="o">+</code> <code class="n">matcher</code><code class="o">.</code><code class="na">group</code><code class="o">(</code><code class="mi">9</code><code class="o">));</code>&#13;
    <code class="o">}</code>&#13;
<code class="o">}</code></pre></div>&#13;
&#13;
<p>The <code>implements</code> clause is for an interface that just defines the input string; it was used in a demonstration to compare the regular expression mode with the use of a <code>StringTokenizer</code>. The source for both versions is in the online source for this chapter. Running the program against the sample input from <a data-type="xref" href="#apache-example">Example 4-10</a> gives this output:</p>&#13;
&#13;
<pre data-type="programlisting">Using regex Pattern:&#13;
\^([\d.]+) (\S+) (\S+) \[([\w:/]+\s[+\-]\d{4})\] "(.+?)" (\d{3}) (\d+) "([\^"]+)"&#13;
"([\^"]+)"&#13;
Input line is:&#13;
123.45.67.89 - - [27/Oct/2000:09:27:09 -0400] "GET /java/javaResources.html&#13;
HTTP/1.0" 200 10450 "-" "Mozilla/4.6 [en] (X11; U; OpenBSD 2.8 i386; Nav)"&#13;
IP Address: 123.45.67.89&#13;
Date&amp;Time: 27/Oct/2000:09:27:09 -0400&#13;
Request: GET /java/javaResources.html HTTP/1.0&#13;
Response: 200&#13;
Bytes Sent: 10450&#13;
Browser: Mozilla/4.6 [en] (X11; U; OpenBSD 2.8 i386; Nav)</pre>&#13;
&#13;
<p>The program successfully parsed the entire logfile format entry with one call to<a data-primary="matcher.matches() method" data-type="indexterm" id="idm45290683666232"/> <code>matcher.matches()</code>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="4.11 Program: Full Grep" data-type="sect1"><div class="sect1" id="javacook-regex-SECT-12">&#13;
<h1>4.11 Program: Full Grep</h1>&#13;
&#13;
<p><a data-primary="JGrep program" data-type="indexterm" id="idm45290683663368"/><a data-primary="regular expressions (regex)" data-secondary="JGrep program" data-type="indexterm" id="idm45290683662504"/>Now that we’ve seen how the regular expressions package works, it’s time to write JGrep, a full-blown version of the line-matching program with option parsing. <a data-type="xref" href="#javacook-regex-TABLE-3">Table 4-2</a> lists some typical command-line options that a Unix implementation of <em>grep</em> might include.&#13;
For those not familiar with <em>grep</em>, it is a command-line tool that searches&#13;
for regular expressions in text files. There are three or four programs&#13;
in the standard <em>grep</em> family, and a newer replacement<a data-primary="ripgrep (rg)" data-type="indexterm" id="idm45290683659064"/> <em>ripgrep</em>, or <em>rg</em>.&#13;
This program is my addition to this family of programs.</p>&#13;
<table id="javacook-regex-TABLE-3">&#13;
<caption><span class="label">Table 4-2. </span>Grep command-line options</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Option</th>&#13;
<th>Meaning</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p>-c</p></td>&#13;
<td><p>Count only; don’t print lines, just count them</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>-C</p></td>&#13;
<td><p>Context; print some lines above and below each line that matches (not implemented in this version; left as an exercise for the reader)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>-f pattern</p></td>&#13;
<td><p>Take pattern from file named after <code>-f</code> instead of from command line</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>-h</p></td>&#13;
<td><p>Suppress printing filename ahead of lines</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>-i</p></td>&#13;
<td><p>Ignore case</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>-l</p></td>&#13;
<td><p>List filenames only: don’t print lines, just the names they’re found in</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>-n</p></td>&#13;
<td><p>Print line numbers before matching lines</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>-s</p></td>&#13;
<td><p>Suppress printing certain error messages</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>-v</p></td>&#13;
<td><p>Invert: print only lines that do NOT match the pattern</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>The <a data-primary="Unix" data-secondary="getopt library" data-type="indexterm" id="idm45290683638360"/><a data-primary="getopt library" data-type="indexterm" id="idm45290683637352"/>Unix world features several <em>getopt</em> library routines for parsing&#13;
command-line arguments, so I have a reimplementation of this in Java.&#13;
As usual, because <code>main()</code> runs in a static context but our application main line does not, we could wind up passing a lot of information into the constructor.&#13;
To save space, this version just uses global variables to track the settings from the command line.&#13;
Unlike the Unix <em>grep</em> tool, this one does not yet handle combined options, so <code>-l -r -i</code> is OK,&#13;
but <code>-lri</code> will fail, due to a limitation in the <code>GetOpt</code> parser used.</p>&#13;
&#13;
<p>The program basically just reads lines, matches the pattern in them, and, if a match is found (or not found, with <code>-v</code>), prints the line (and optionally some other stuff, too). Having said all that, the code is shown in <a data-type="xref" href="#javacook-regex-EX-9">Example 4-12</a>.<a data-primary="" data-startref="pm_re" data-type="indexterm" id="idm45290683631848"/><a data-primary="" data-startref="re_pm" data-type="indexterm" id="idm45290683630872"/><a data-primary="" data-startref="pm_ch" data-type="indexterm" id="idm45290683629928"/></p>&#13;
<div data-type="example" id="javacook-regex-EX-9">&#13;
<h5><span class="label">Example 4-12. </span>darwinsys-api/src/main/java/regex/JGrep.java</h5>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="cm">/** A command-line grep-like program. Accepts some command-line options,</code>&#13;
<code class="cm"> * and takes a pattern and a list of text files.</code>&#13;
<code class="cm"> * N.B. The current implementation of GetOpt does not allow combining short</code>&#13;
<code class="cm"> * arguments, so put spaces e.g., "JGrep -l -r -i pattern file..." is OK, but</code>&#13;
<code class="cm"> * "JGrep -lri pattern file..." will fail. Getopt will hopefully be fixed soon.</code>&#13;
<code class="cm"> */</code>&#13;
<code class="kd">public</code> <code class="kd">class</code> <code class="nc">JGrep</code> <code class="o">{</code>&#13;
    <code class="kd">private</code> <code class="kd">static</code> <code class="kd">final</code> <code class="n">String</code> <code class="n">USAGE</code> <code class="o">=</code>&#13;
        <code class="s">"Usage: JGrep pattern [-chilrsnv][-f pattfile][filename...]"</code><code class="o">;</code>&#13;
    <code class="cm">/** The pattern we're looking for */</code>&#13;
    <code class="kd">protected</code> <code class="n">Pattern</code> <code class="n">pattern</code><code class="o">;</code>&#13;
    <code class="cm">/** The matcher for this pattern */</code>&#13;
    <code class="kd">protected</code> <code class="n">Matcher</code> <code class="n">matcher</code><code class="o">;</code>&#13;
    <code class="kd">private</code> <code class="kt">boolean</code> <code class="n">debug</code><code class="o">;</code>&#13;
    <code class="cm">/** Are we to only count lines, instead of printing? */</code>&#13;
    <code class="kd">protected</code> <code class="kd">static</code> <code class="kt">boolean</code> <code class="n">countOnly</code> <code class="o">=</code> <code class="kc">false</code><code class="o">;</code>&#13;
    <code class="cm">/** Are we to ignore case? */</code>&#13;
    <code class="kd">protected</code> <code class="kd">static</code> <code class="kt">boolean</code> <code class="n">ignoreCase</code> <code class="o">=</code> <code class="kc">false</code><code class="o">;</code>&#13;
    <code class="cm">/** Are we to suppress printing of filenames? */</code>&#13;
    <code class="kd">protected</code> <code class="kd">static</code> <code class="kt">boolean</code> <code class="n">dontPrintFileName</code> <code class="o">=</code> <code class="kc">false</code><code class="o">;</code>&#13;
    <code class="cm">/** Are we to only list names of files that match? */</code>&#13;
    <code class="kd">protected</code> <code class="kd">static</code> <code class="kt">boolean</code> <code class="n">listOnly</code> <code class="o">=</code> <code class="kc">false</code><code class="o">;</code>&#13;
    <code class="cm">/** Are we to print line numbers? */</code>&#13;
    <code class="kd">protected</code> <code class="kd">static</code> <code class="kt">boolean</code> <code class="n">numbered</code> <code class="o">=</code> <code class="kc">false</code><code class="o">;</code>&#13;
    <code class="cm">/** Are we to be silent about errors? */</code>&#13;
    <code class="kd">protected</code> <code class="kd">static</code> <code class="kt">boolean</code> <code class="n">silent</code> <code class="o">=</code> <code class="kc">false</code><code class="o">;</code>&#13;
    <code class="cm">/** Are we to print only lines that DONT match? */</code>&#13;
    <code class="kd">protected</code> <code class="kd">static</code> <code class="kt">boolean</code> <code class="n">inVert</code> <code class="o">=</code> <code class="kc">false</code><code class="o">;</code>&#13;
    <code class="cm">/** Are we to process arguments recursively if directories? */</code>&#13;
    <code class="kd">protected</code> <code class="kd">static</code> <code class="kt">boolean</code> <code class="n">recursive</code> <code class="o">=</code> <code class="kc">false</code><code class="o">;</code>&#13;
&#13;
    <code class="cm">/** Construct a Grep object for the pattern, and run it</code>&#13;
<code class="cm">     * on all input files listed in args.</code>&#13;
<code class="cm">     * Be aware that a few of the command-line options are not</code>&#13;
<code class="cm">     * acted upon in this version - left as an exercise for the reader!</code>&#13;
<code class="cm">     * @param args args</code>&#13;
<code class="cm">     */</code>&#13;
    <code class="kd">public</code> <code class="kd">static</code> <code class="kt">void</code> <code class="nf">main</code><code class="o">(</code><code class="n">String</code><code class="o">[]</code> <code class="n">args</code><code class="o">)</code> <code class="o">{</code>&#13;
&#13;
        <code class="k">if</code> <code class="o">(</code><code class="n">args</code><code class="o">.</code><code class="na">length</code> <code class="o">&lt;</code> <code class="mi">1</code><code class="o">)</code> <code class="o">{</code>&#13;
            <code class="n">System</code><code class="o">.</code><code class="na">err</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="n">USAGE</code><code class="o">);</code>&#13;
            <code class="n">System</code><code class="o">.</code><code class="na">exit</code><code class="o">(</code><code class="mi">1</code><code class="o">);</code>&#13;
        <code class="o">}</code>&#13;
        <code class="n">String</code> <code class="n">patt</code> <code class="o">=</code> <code class="kc">null</code><code class="o">;</code>&#13;
&#13;
        <code class="n">GetOpt</code> <code class="n">go</code> <code class="o">=</code> <code class="k">new</code> <code class="n">GetOpt</code><code class="o">(</code><code class="s">"cf:hilnrRsv"</code><code class="o">);</code>&#13;
&#13;
        <code class="kt">char</code> <code class="n">c</code><code class="o">;</code>&#13;
        <code class="k">while</code> <code class="o">((</code><code class="n">c</code> <code class="o">=</code> <code class="n">go</code><code class="o">.</code><code class="na">getopt</code><code class="o">(</code><code class="n">args</code><code class="o">))</code> <code class="o">!=</code> <code class="mi">0</code><code class="o">)</code> <code class="o">{</code>&#13;
            <code class="k">switch</code><code class="o">(</code><code class="n">c</code><code class="o">)</code> <code class="o">{</code>&#13;
                <code class="k">case</code> <code class="sc">'c'</code><code class="o">:</code>&#13;
                    <code class="n">countOnly</code> <code class="o">=</code> <code class="kc">true</code><code class="o">;</code>&#13;
                    <code class="k">break</code><code class="o">;</code>&#13;
                <code class="k">case</code> <code class="sc">'f'</code><code class="o">:</code>    <code class="cm">/* External file contains the pattern */</code>&#13;
                    <code class="k">try</code> <code class="o">(</code><code class="n">BufferedReader</code> <code class="n">b</code> <code class="o">=</code>&#13;
                        <code class="k">new</code> <code class="nf">BufferedReader</code><code class="o">(</code><code class="k">new</code> <code class="n">FileReader</code><code class="o">(</code><code class="n">go</code><code class="o">.</code><code class="na">optarg</code><code class="o">())))</code> <code class="o">{</code>&#13;
                        <code class="n">patt</code> <code class="o">=</code> <code class="n">b</code><code class="o">.</code><code class="na">readLine</code><code class="o">();</code>&#13;
                    <code class="o">}</code> <code class="k">catch</code> <code class="o">(</code><code class="n">IOException</code> <code class="n">e</code><code class="o">)</code> <code class="o">{</code>&#13;
                        <code class="n">System</code><code class="o">.</code><code class="na">err</code><code class="o">.</code><code class="na">println</code><code class="o">(</code>&#13;
                            <code class="s">"Can't read pattern file "</code> <code class="o">+</code> <code class="n">go</code><code class="o">.</code><code class="na">optarg</code><code class="o">());</code>&#13;
                        <code class="n">System</code><code class="o">.</code><code class="na">exit</code><code class="o">(</code><code class="mi">1</code><code class="o">);</code>&#13;
                    <code class="o">}</code>&#13;
                    <code class="k">break</code><code class="o">;</code>&#13;
                <code class="k">case</code> <code class="sc">'h'</code><code class="o">:</code>&#13;
                    <code class="n">dontPrintFileName</code> <code class="o">=</code> <code class="kc">true</code><code class="o">;</code>&#13;
                    <code class="k">break</code><code class="o">;</code>&#13;
                <code class="k">case</code> <code class="sc">'i'</code><code class="o">:</code>&#13;
                    <code class="n">ignoreCase</code> <code class="o">=</code> <code class="kc">true</code><code class="o">;</code>&#13;
                    <code class="k">break</code><code class="o">;</code>&#13;
                <code class="k">case</code> <code class="sc">'l'</code><code class="o">:</code>&#13;
                    <code class="n">listOnly</code> <code class="o">=</code> <code class="kc">true</code><code class="o">;</code>&#13;
                    <code class="k">break</code><code class="o">;</code>&#13;
                <code class="k">case</code> <code class="sc">'n'</code><code class="o">:</code>&#13;
                    <code class="n">numbered</code> <code class="o">=</code> <code class="kc">true</code><code class="o">;</code>&#13;
                    <code class="k">break</code><code class="o">;</code>&#13;
                <code class="k">case</code> <code class="sc">'r'</code><code class="o">:</code>&#13;
                <code class="k">case</code> <code class="sc">'R'</code><code class="o">:</code>&#13;
                    <code class="n">recursive</code> <code class="o">=</code> <code class="kc">true</code><code class="o">;</code>&#13;
                    <code class="k">break</code><code class="o">;</code>&#13;
                <code class="k">case</code> <code class="sc">'s'</code><code class="o">:</code>&#13;
                    <code class="n">silent</code> <code class="o">=</code> <code class="kc">true</code><code class="o">;</code>&#13;
                    <code class="k">break</code><code class="o">;</code>&#13;
                <code class="k">case</code> <code class="sc">'v'</code><code class="o">:</code>&#13;
                    <code class="n">inVert</code> <code class="o">=</code> <code class="kc">true</code><code class="o">;</code>&#13;
                    <code class="k">break</code><code class="o">;</code>&#13;
                <code class="k">case</code> <code class="sc">'?'</code><code class="o">:</code>&#13;
                    <code class="n">System</code><code class="o">.</code><code class="na">err</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="s">"Getopts was not happy!"</code><code class="o">);</code>&#13;
                    <code class="n">System</code><code class="o">.</code><code class="na">err</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="n">USAGE</code><code class="o">);</code>&#13;
                    <code class="k">break</code><code class="o">;</code>&#13;
            <code class="o">}</code>&#13;
        <code class="o">}</code>&#13;
&#13;
        <code class="kt">int</code> <code class="n">ix</code> <code class="o">=</code> <code class="n">go</code><code class="o">.</code><code class="na">getOptInd</code><code class="o">();</code>&#13;
&#13;
        <code class="k">if</code> <code class="o">(</code><code class="n">patt</code> <code class="o">==</code> <code class="kc">null</code><code class="o">)</code>&#13;
            <code class="n">patt</code> <code class="o">=</code> <code class="n">args</code><code class="o">[</code><code class="n">ix</code><code class="o">++];</code>&#13;
&#13;
        <code class="n">JGrep</code> <code class="n">prog</code> <code class="o">=</code> <code class="kc">null</code><code class="o">;</code>&#13;
        <code class="k">try</code> <code class="o">{</code>&#13;
            <code class="n">prog</code> <code class="o">=</code> <code class="k">new</code> <code class="n">JGrep</code><code class="o">(</code><code class="n">patt</code><code class="o">);</code>&#13;
        <code class="o">}</code> <code class="k">catch</code> <code class="o">(</code><code class="n">PatternSyntaxException</code> <code class="n">ex</code><code class="o">)</code> <code class="o">{</code>&#13;
            <code class="n">System</code><code class="o">.</code><code class="na">err</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="s">"RE Syntax error in "</code> <code class="o">+</code> <code class="n">patt</code><code class="o">);</code>&#13;
            <code class="k">return</code><code class="o">;</code>&#13;
        <code class="o">}</code>&#13;
&#13;
        <code class="k">if</code> <code class="o">(</code><code class="n">args</code><code class="o">.</code><code class="na">length</code> <code class="o">==</code> <code class="n">ix</code><code class="o">)</code> <code class="o">{</code>&#13;
            <code class="n">dontPrintFileName</code> <code class="o">=</code> <code class="kc">true</code><code class="o">;</code> <code class="c1">// Don't print filenames if stdin</code>&#13;
            <code class="k">if</code> <code class="o">(</code><code class="n">recursive</code><code class="o">)</code> <code class="o">{</code>&#13;
                <code class="n">System</code><code class="o">.</code><code class="na">err</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="s">"Warning: recursive search of stdin!"</code><code class="o">);</code>&#13;
            <code class="o">}</code>&#13;
            <code class="n">prog</code><code class="o">.</code><code class="na">process</code><code class="o">(</code><code class="k">new</code> <code class="n">InputStreamReader</code><code class="o">(</code><code class="n">System</code><code class="o">.</code><code class="na">in</code><code class="o">),</code> <code class="kc">null</code><code class="o">);</code>&#13;
        <code class="o">}</code> <code class="k">else</code> <code class="o">{</code>&#13;
            <code class="k">if</code> <code class="o">(!</code><code class="n">dontPrintFileName</code><code class="o">)</code>&#13;
                <code class="n">dontPrintFileName</code> <code class="o">=</code> <code class="n">ix</code> <code class="o">==</code> <code class="n">args</code><code class="o">.</code><code class="na">length</code> <code class="o">-</code> <code class="mi">1</code><code class="o">;</code> <code class="c1">// Nor if only one file</code>&#13;
            <code class="k">if</code> <code class="o">(</code><code class="n">recursive</code><code class="o">)</code>&#13;
                <code class="n">dontPrintFileName</code> <code class="o">=</code> <code class="kc">false</code><code class="o">;</code>                <code class="c1">// unless a directory!</code>&#13;
&#13;
            <code class="k">for</code> <code class="o">(</code><code class="kt">int</code> <code class="n">i</code><code class="o">=</code><code class="n">ix</code><code class="o">;</code> <code class="n">i</code><code class="o">&lt;</code><code class="n">args</code><code class="o">.</code><code class="na">length</code><code class="o">;</code> <code class="n">i</code><code class="o">++)</code> <code class="o">{</code> <code class="c1">// note starting index</code>&#13;
                <code class="k">try</code> <code class="o">{</code>&#13;
                    <code class="n">prog</code><code class="o">.</code><code class="na">process</code><code class="o">(</code><code class="k">new</code> <code class="n">File</code><code class="o">(</code><code class="n">args</code><code class="o">[</code><code class="n">i</code><code class="o">]));</code>&#13;
                <code class="o">}</code> <code class="k">catch</code><code class="o">(</code><code class="n">Exception</code> <code class="n">e</code><code class="o">)</code> <code class="o">{</code>&#13;
                    <code class="n">System</code><code class="o">.</code><code class="na">err</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="n">e</code><code class="o">);</code>&#13;
                <code class="o">}</code>&#13;
            <code class="o">}</code>&#13;
        <code class="o">}</code>&#13;
    <code class="o">}</code>&#13;
&#13;
    <code class="cm">/**</code>&#13;
<code class="cm">     * Construct a JGrep object.</code>&#13;
<code class="cm">     * @param patt The regex to look for</code>&#13;
<code class="cm">     * @throws PatternSyntaxException if pattern is not a valid regex</code>&#13;
<code class="cm">     */</code>&#13;
    <code class="kd">public</code> <code class="nf">JGrep</code><code class="o">(</code><code class="n">String</code> <code class="n">patt</code><code class="o">)</code> <code class="kd">throws</code> <code class="n">PatternSyntaxException</code> <code class="o">{</code>&#13;
        <code class="k">if</code> <code class="o">(</code><code class="n">debug</code><code class="o">)</code> <code class="o">{</code>&#13;
            <code class="n">System</code><code class="o">.</code><code class="na">err</code><code class="o">.</code><code class="na">printf</code><code class="o">(</code><code class="s">"JGrep.JGrep(%s)%n"</code><code class="o">,</code> <code class="n">patt</code><code class="o">);</code>&#13;
        <code class="o">}</code>&#13;
        <code class="c1">// compile the regular expression</code>&#13;
        <code class="kt">int</code> <code class="n">caseMode</code> <code class="o">=</code> <code class="n">ignoreCase</code> <code class="o">?</code>&#13;
            <code class="n">Pattern</code><code class="o">.</code><code class="na">UNICODE_CASE</code> <code class="o">|</code> <code class="n">Pattern</code><code class="o">.</code><code class="na">CASE_INSENSITIVE</code> <code class="o">:</code>&#13;
            <code class="mi">0</code><code class="o">;</code>&#13;
        <code class="n">pattern</code> <code class="o">=</code> <code class="n">Pattern</code><code class="o">.</code><code class="na">compile</code><code class="o">(</code><code class="n">patt</code><code class="o">,</code> <code class="n">caseMode</code><code class="o">);</code>&#13;
        <code class="n">matcher</code> <code class="o">=</code> <code class="n">pattern</code><code class="o">.</code><code class="na">matcher</code><code class="o">(</code><code class="s">""</code><code class="o">);</code>&#13;
    <code class="o">}</code>&#13;
&#13;
    <code class="cm">/** Process one command line argument (file or directory)</code>&#13;
<code class="cm">     * @param file The input File</code>&#13;
<code class="cm">     * @throws FileNotFoundException If the file doesn't exist</code>&#13;
<code class="cm">     */</code>&#13;
    <code class="kd">public</code> <code class="kt">void</code> <code class="nf">process</code><code class="o">(</code><code class="n">File</code> <code class="n">file</code><code class="o">)</code> <code class="kd">throws</code> <code class="n">FileNotFoundException</code> <code class="o">{</code>&#13;
        <code class="k">if</code> <code class="o">(!</code><code class="n">file</code><code class="o">.</code><code class="na">exists</code><code class="o">()</code> <code class="o">||</code> <code class="o">!</code><code class="n">file</code><code class="o">.</code><code class="na">canRead</code><code class="o">())</code> <code class="o">{</code>&#13;
            <code class="k">throw</code> <code class="k">new</code> <code class="nf">FileNotFoundException</code><code class="o">(</code>&#13;
                <code class="s">"Can't read file "</code> <code class="o">+</code> <code class="n">file</code><code class="o">.</code><code class="na">getAbsolutePath</code><code class="o">());</code>&#13;
        <code class="o">}</code>&#13;
        <code class="k">if</code> <code class="o">(</code><code class="n">file</code><code class="o">.</code><code class="na">isFile</code><code class="o">())</code> <code class="o">{</code>&#13;
            <code class="n">process</code><code class="o">(</code><code class="k">new</code> <code class="n">BufferedReader</code><code class="o">(</code><code class="k">new</code> <code class="n">FileReader</code><code class="o">(</code><code class="n">file</code><code class="o">)),</code>&#13;
                <code class="n">file</code><code class="o">.</code><code class="na">getAbsolutePath</code><code class="o">());</code>&#13;
            <code class="k">return</code><code class="o">;</code>&#13;
        <code class="o">}</code>&#13;
        <code class="k">if</code> <code class="o">(</code><code class="n">file</code><code class="o">.</code><code class="na">isDirectory</code><code class="o">())</code> <code class="o">{</code>&#13;
            <code class="k">if</code> <code class="o">(!</code><code class="n">recursive</code><code class="o">)</code> <code class="o">{</code>&#13;
                <code class="n">System</code><code class="o">.</code><code class="na">err</code><code class="o">.</code><code class="na">println</code><code class="o">(</code>&#13;
                    <code class="s">"ERROR: -r not specified but directory given "</code> <code class="o">+</code>&#13;
                    <code class="n">file</code><code class="o">.</code><code class="na">getAbsolutePath</code><code class="o">());</code>&#13;
                <code class="k">return</code><code class="o">;</code>&#13;
            <code class="o">}</code>&#13;
            <code class="k">for</code> <code class="o">(</code><code class="n">File</code> <code class="n">nf</code> <code class="o">:</code> <code class="n">file</code><code class="o">.</code><code class="na">listFiles</code><code class="o">())</code> <code class="o">{</code>&#13;
                <code class="n">process</code><code class="o">(</code><code class="n">nf</code><code class="o">);</code>    <code class="c1">// "Recursion, n.: See Recursion."</code>&#13;
            <code class="o">}</code>&#13;
            <code class="k">return</code><code class="o">;</code>&#13;
        <code class="o">}</code>&#13;
        <code class="n">System</code><code class="o">.</code><code class="na">err</code><code class="o">.</code><code class="na">println</code><code class="o">(</code>&#13;
            <code class="s">"WEIRDNESS: neither file nor directory: "</code> <code class="o">+</code> <code class="n">file</code><code class="o">.</code><code class="na">getAbsolutePath</code><code class="o">());</code>&#13;
    <code class="o">}</code>&#13;
&#13;
    <code class="cm">/** Do the work of scanning one file</code>&#13;
<code class="cm">     * @param    ifile    Reader    Reader object already open</code>&#13;
<code class="cm">     * @param    fileName String    Name of the input file</code>&#13;
<code class="cm">     */</code>&#13;
    <code class="kd">public</code> <code class="kt">void</code> <code class="nf">process</code><code class="o">(</code><code class="n">Reader</code> <code class="n">ifile</code><code class="o">,</code> <code class="n">String</code> <code class="n">fileName</code><code class="o">)</code> <code class="o">{</code>&#13;
&#13;
        <code class="n">String</code> <code class="n">inputLine</code><code class="o">;</code>&#13;
        <code class="kt">int</code> <code class="n">matches</code> <code class="o">=</code> <code class="mi">0</code><code class="o">;</code>&#13;
&#13;
        <code class="k">try</code> <code class="o">(</code><code class="n">BufferedReader</code> <code class="n">reader</code> <code class="o">=</code> <code class="k">new</code> <code class="n">BufferedReader</code><code class="o">(</code><code class="n">ifile</code><code class="o">))</code> <code class="o">{</code>&#13;
&#13;
            <code class="k">while</code> <code class="o">((</code><code class="n">inputLine</code> <code class="o">=</code> <code class="n">reader</code><code class="o">.</code><code class="na">readLine</code><code class="o">())</code> <code class="o">!=</code> <code class="kc">null</code><code class="o">)</code> <code class="o">{</code>&#13;
                <code class="n">matcher</code><code class="o">.</code><code class="na">reset</code><code class="o">(</code><code class="n">inputLine</code><code class="o">);</code>&#13;
                <code class="k">if</code> <code class="o">(</code><code class="n">matcher</code><code class="o">.</code><code class="na">find</code><code class="o">())</code> <code class="o">{</code>&#13;
                    <code class="k">if</code> <code class="o">(</code><code class="n">listOnly</code><code class="o">)</code> <code class="o">{</code>&#13;
                        <code class="c1">// -l, print filename on first match, and we're done</code>&#13;
                        <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="n">fileName</code><code class="o">);</code>&#13;
                        <code class="k">return</code><code class="o">;</code>&#13;
                    <code class="o">}</code>&#13;
                    <code class="k">if</code> <code class="o">(</code><code class="n">countOnly</code><code class="o">)</code> <code class="o">{</code>&#13;
                        <code class="n">matches</code><code class="o">++;</code>&#13;
                    <code class="o">}</code> <code class="k">else</code> <code class="o">{</code>&#13;
                        <code class="k">if</code> <code class="o">(!</code><code class="n">dontPrintFileName</code><code class="o">)</code> <code class="o">{</code>&#13;
                            <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">print</code><code class="o">(</code><code class="n">fileName</code> <code class="o">+</code> <code class="s">": "</code><code class="o">);</code>&#13;
                        <code class="o">}</code>&#13;
                        <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="n">inputLine</code><code class="o">);</code>&#13;
                    <code class="o">}</code>&#13;
                <code class="o">}</code> <code class="k">else</code> <code class="k">if</code> <code class="o">(</code><code class="n">inVert</code><code class="o">)</code> <code class="o">{</code>&#13;
                    <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="n">inputLine</code><code class="o">);</code>&#13;
                <code class="o">}</code>&#13;
            <code class="o">}</code>&#13;
            <code class="k">if</code> <code class="o">(</code><code class="n">countOnly</code><code class="o">)</code>&#13;
                <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="n">matches</code> <code class="o">+</code> <code class="s">" matches in "</code> <code class="o">+</code> <code class="n">fileName</code><code class="o">);</code>&#13;
        <code class="o">}</code> <code class="k">catch</code> <code class="o">(</code><code class="n">IOException</code> <code class="n">e</code><code class="o">)</code> <code class="o">{</code>&#13;
            <code class="n">System</code><code class="o">.</code><code class="na">err</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="n">e</code><code class="o">);</code>&#13;
        <code class="o">}</code>&#13;
    <code class="o">}</code>&#13;
<code class="o">}</code></pre></div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<div data-type="footnotes"><p data-type="footnote" id="idm45290687159592"><sup><a href="ch04.html#idm45290687159592-marker">1</a></sup> Non-Unix fans fear not, for you can use tools like <em>grep</em> on Windows systems using one of several packages. One is an open source package alternately called CygWin (after Cygnus Software) or <a href="http://sources.redhat.com/cygwin">GnuWin32</a>. Another is Microsoft’s <em>findstr</em> command for Windows. Or you can use my <em>Grep</em> program in <a data-type="xref" href="#javacook-regex-SECT-6">Recipe 4.6</a> if you don’t have <em>grep</em> on your system. Incidentally, the name <em>grep</em> comes from an ancient Unix line editor command <em>g/RE/p</em>, the command to find the regex globally in all lines in the edit buffer and print the lines that match—just what the <em>grep</em> program does to lines in files.</p><p data-type="footnote" id="idm45290686929656"><sup><a href="ch04.html#idm45290686929656-marker">2</a></sup> REDemo was inspired by (but does not use any code from) a similar program provided with the now-retired Apache Jakarta Regular Expressions package.</p><p data-type="footnote" id="idm45290684672008"><sup><a href="ch04.html#idm45290684672008-marker">3</a></sup> On Unix, the shell or command-line interpreter expands <em>*.txt</em> to all the matching filenames before running the program, but the normal Java interpreter does this for you on systems where the shell isn’t energetic or bright enough to do it.</p><p data-type="footnote" id="idm45290684143384"><sup><a href="ch04.html#idm45290684143384-marker">4</a></sup> Or a few related Unicode characters, including the next-line (<code>\u0085</code>), line-separator (<code>\u2028</code>), and paragraph-separator (<code>\u2029</code>) characters.</p><p data-type="footnote" id="idm45290683942808"><sup><a href="ch04.html#idm45290683942808-marker">5</a></sup> You might think this would hold some kind of world record for complexity in regex competitions, but I’m sure it’s been outdone many times.</p></div></div></section></body></html>