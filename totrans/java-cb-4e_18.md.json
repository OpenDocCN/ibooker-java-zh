["```java\npublic class ExecDemoSimple {\n    public static void main(String av[]) throws Exception {\n\n        // Run the \"notepad\" program or a similar editor\n        Process p = Runtime.getRuntime().exec(\"kwrite\");\n\n        p.waitFor();\n    }\n}\n```", "```java\n$ javac -d . ExecDemoSimple.java\n$ java otherlang.ExecDemoSimple # causes a KWrite window to appear.\n$\n```", "```java\npublic class ExecDemoNS extends JFrame {\n    private static final String BROWSER = \"firefox\";\n\n    Logger logger = Logger.getLogger(ExecDemoNS.class.getSimpleName());\n\n    /** The name of the help file. */\n    protected final static String HELPFILE = \"./help/index.html\";\n\n    /** A stack of process objects; each entry tracks one running process */\n    Stack<Process> pStack = new Stack<>();\n\n    /** main - instantiate and run */\n    public static void main(String av[]) throws Exception {\n        String program = av.length == 0 ? BROWSER : av[0];\n        new ExecDemoNS(program).setVisible(true);\n    }\n\n    /** The path to the binary executable that we will run */\n    protected static String program;\n\n    /** Constructor - set up strings and things. */\n    public ExecDemoNS(String program) {\n        super(\"ExecDemo: \" + program);\n        this.program = program;\n\n        Container cp = getContentPane();\n        cp.setLayout(new FlowLayout());\n        JButton b;\n        cp.add(b=new JButton(\"Exec\"));\n        b.addActionListener(e -> runProgram());\n        cp.add(b=new JButton(\"Wait\"));\n        b.addActionListener(e -> doWait());\n        cp.add(b=new JButton(\"Exit\"));\n        b.addActionListener(e -> System.exit(0));\n        pack();\n    }\n\n    /** Start the help, in its own Thread. */\n    public void runProgram() {\n\n        new Thread() {\n            public void run() {\n\n                try {\n                    // Get a \"file:\" URL for the Help File\n                    URL helpURL = this.getClass().getClassLoader().\n                        getResource(HELPFILE);\n\n                    // Start the external browser from the Java Application.\n\n                    String osname = System.getProperty(\"os.name\");\n                    String run;\n                    if (\"Mac OS X\".equals(osname)) {\n                        run = \"open -a \" + program;\n                        // \"if\" allows for other OSes needing special handling\n                    } else {\n                        run = program;\n                    }\n\n                    pStack.push(Runtime.getRuntime().exec(run + \" \" + helpURL));\n\n                    logger.info(\"In main after exec \" + pStack.size());\n\n                } catch (Exception ex) {\n                    JOptionPane.showMessageDialog(ExecDemoNS.this,\n                        \"Error\" + ex, \"Error\",\n                        JOptionPane.ERROR_MESSAGE);\n                }\n            }\n        }.start();\n\n    }\n\n    public void doWait() {\n        if (pStack.size() == 0) {\n            logger.info(\"Nothing to wait for.\");\n            return;\n        }\n        logger.info(\"Waiting for process \" + pStack.size());\n        try {\n            Process p = pStack.pop();\n            p.waitFor();\n            // wait for process to complete\n            // (may not work as expected for some old Windows programs)\n            logger.info(\"Process \" + p + \" is done.\");\n        } catch (Exception ex) {\n            JOptionPane.showMessageDialog(this,\n                \"Error\" + ex, \"Error\",\n                JOptionPane.ERROR_MESSAGE);\n        }\n    }\n\n}\n```", "```java\n        List<String> command = new ArrayList<>();            ![1](assets/1.png)\n        command.add(\"notepad\");\n        command.add(\"foo.txt\");\n        ProcessBuilder builder = new ProcessBuilder(command);![2](assets/2.png)\n        builder.environment().put(\"PATH\",\n                \"/windows;/windows/system32;/winnt\");        ![3](assets/3.png)\n        final Process godot = builder.directory(\n            new File(System.getProperty(\"user.home\"))).      ![4](assets/4.png)\n            start();\n        System.err.println(\"Waiting for Godot\");             ![5](assets/5.png)\n        godot.waitFor();                                     ![6](assets/6.png)\n```", "```java\npublic class ExecDemoLs {\n\n    private static Logger logger =\n        Logger.getLogger(ExecDemoLs.class.getSimpleName());\n\n    /** The program to run */\n    public static final String PROGRAM = \"ls\"; // \"dir\" for Windows\n    /** Set to true to end the loop */\n    static volatile boolean done = false;\n\n    public static void main(String argv[]) throws IOException {\n\n        final Process p;         // Process tracks one external native process\n        BufferedReader is;    // reader for output of process\n        String line;\n\n        p = Runtime.getRuntime().exec(PROGRAM);\n\n        logger.info(\"In Main after exec\");\n\n        // Optional: start a thread to wait for the process to terminate.\n        // Don't just wait in main line, but here set a \"done\" flag and\n        // use that to control the main reading loop below.\n        Thread waiter = new Thread() {\n            public void run() {\n                try {\n                    p.waitFor();\n                } catch (InterruptedException ex) {\n                    // OK, just quit.\n                    return;\n                }\n                System.out.println(\"Program terminated!\");\n                done = true;\n            }\n        };\n        waiter.start();\n\n        // getInputStream gives an Input stream connected to\n        // the process p's standard output (and vice versa). We use\n        // that to construct a BufferedReader so we can readLine() it.\n        is = new BufferedReader(new InputStreamReader(p.getInputStream()));\n\n        while (!done && ((line = is.readLine()) != null))\n            System.out.println(line);\n\n        logger.info(\"In Main after EOF\");\n\n        return;\n    }\n}\n```", "```java\n    /** Need a Runtime object for any of these methods */\n    protected final static Runtime r = Runtime.getRuntime();\n\n    /** Run the command given as a String, output to System.out\n * @param cmd The command\n * @return The command's exit status\n * @throws IOException if the command isn't found\n */\n    public static int run(String cmd) throws IOException {\n        return run(cmd, new OutputStreamWriter(System.out));\n    }\n\n    /** Run the command given as a String, output to \"out\"\n * @param cmd The command and list of arguments\n * @param out The output file\n * @return The command's exit status\n * @throws IOException if the command isn't found\n */\n    public static int run(String cmd, Writer out) throws IOException {\n\n        Process p = r.exec(cmd);\n\n        FileIO.copyFile(new InputStreamReader(p.getInputStream()), out, true);\n        try {\n            p.waitFor();    // wait for process to complete\n        } catch (InterruptedException e) {\n            return -1;\n        }\n        return p.exitValue();\n    }\n```", "```java\n-rw-------  1 ian  wheel  0 Jan 29 14:29 file1\n-rw-------  1 ian  wheel  0 Jan 29 14:29 file2\n-rw-------  1 ian  wheel  0 Jan 29 14:29 file3\n```", "```java\n        // Get and save the Runtime object.\n        Runtime rt = Runtime.getRuntime();\n\n        // Create three temporary files (the slow way!)\n        rt.exec(\"mktemp file1\");\n        rt.exec(\"mktemp file2\");\n        rt.exec(\"mktemp file3\");\n\n        // Run the \"ls\" (directory lister) program\n        // with its output sent into a file\n        String[] args = { \"ls\", \"-l\", \"file1\", \"file2\", \"file3\" };\n        ExecAndPrint.run(args);\n\n        rt.exec(\"rm file1 file2 file3\");\n```", "```java\n        // A Runtime object has methods for dealing with the OS\n        Runtime r = Runtime.getRuntime();\n        Process p;         // Process tracks one external native process\n        BufferedReader is;    // reader for output of process\n        String line;\n\n        // Our argv[0] contains the program to run; remaining elements\n        // of argv contain args for the target program. This is just\n        // what is needed for the String[] form of exec.\n        p = r.exec(argv);\n\n        System.out.println(\"In Main after exec\");\n\n        // getInputStream gives an Input stream connected to\n        // the process p's standard output. Just use it to make\n        // a BufferedReader to readLine() what the program writes out.\n        is = new BufferedReader(new InputStreamReader(p.getInputStream()));\n\n        while ((line = is.readLine()) != null)\n            System.out.println(line);\n\n        System.out.println(\"In Main after EOF\");\n        System.out.flush();\n        try {\n            p.waitFor();    // wait for process to complete\n        } catch (InterruptedException e) {\n            System.err.println(e);    // \"Can't Happen\"\n            return;\n        }\n        System.err.println(\"Process done, exit status was \" + p.exitValue());\n```", "```java\npublic class ScriptEnginesDemo {\n\n    public static void main(String[] args) throws ScriptException {\n        ScriptEngineManager scriptEngineManager = new ScriptEngineManager();\n\n        // Print list of supported languages\n        scriptEngineManager.getEngineFactories().forEach(factory ->\n            System.out.println(factory.getLanguageName()));\n\n        // Run a script in the JavaScript language\n        String lang = \"JavaScript\";\n        ScriptEngine engine =\n            scriptEngineManager.getEngineByName(lang);\n        if (engine == null) {\n            System.err.println(\"Could not find engine\");\n            return;\n        }\n        engine.eval(\"print(\\\"Hello from \" + lang + \"\\\");\");\n    }\n}\n```", "```java\n/**\n * demo using Python (jython) to get a Java variable, print, and change it.\n * @author Ian Darwin\n */\npublic class PythonFromJava {\n    private static final String PY_SCRIPTNAME = \"pythonfromjava.py\";\n\n    public static void main(String[] args) throws Exception {\n        ScriptEngineManager scriptEngineManager = new ScriptEngineManager();\n\n        ScriptEngine engine = scriptEngineManager.getEngineByName(\"python\");\n        if (engine == null) {\n            final String message =\n                \"Could not find 'python' engine; add its jar to CLASSPATH\";\n            System.out.println(message);\n            System.out.println(\"Available script engines are: \");\n            scriptEngineManager.getEngineFactories().forEach(factory ->\n                System.out.println(factory.getLanguageName()));\n            throw new IllegalStateException(message);\n        }\n\n        final Bindings bindings = engine.getBindings(ScriptContext.ENGINE_SCOPE);\n        bindings.put(\"meaning\", 42);\n\n        // Let's run a python script stored on disk (well, on classpath):\n        InputStream is =\n            PythonFromJava.class.getResourceAsStream(\"/\" + PY_SCRIPTNAME);\n        if (is == null) {\n            throw new IOException(\"Could not find file \" + PY_SCRIPTNAME);\n        }\n        engine.eval(new InputStreamReader(is));\n        System.out.println(\"Java: Meaning is now \" + bindings.get(\"meaning\"));\n    }\n}\n```", "```java\n$ gu install python\nDownloading: Component catalog from www.graalvm.org\nProcessing component archive: Graal.Python\nDownloading: Component python: Graal.Python  from github.com\nInstalling new component: Graal.Python (org.graalvm.python, version 19.2.0.1)\n\nIMPORTANT NOTE:\n---------------\nSet of GraalVM components that provide language implementations have changed.\n  The Polyglot native image and polyglot native C library may be out of sync:\n- new languages may not be accessible\n- removed languages may cause the native binary to fail on missing resources\n  or libraries.\nTo rebuild and refresh the native binaries, use the following command:\n      Library/Java/JavaVirtualMachines/graalvm-ce-19.2.0.1/Contents/Home/bin/gu\n      rebuild-images\n\nYou may need to install \"native-image\" component which provide the rebuild tools.\n```", "```java\nimport java.io.*;\nimport java.util.stream.*;\nimport org.graalvm.polyglot.*;\n\n/**\n * GraalVM polyglot: calling Python from Java/\n */\n// tag::main[]\npublic class JavaCallPython {\n\n    public static void main(String[] args) throws java.io.IOException {\n\n         try (Context context = Context.create(\"jython\")) {\n            Value result = context.execute(\"2 + 2\");\n            System.out.println(result.asString());\n        }\n    }\n}\n// end::main[]\n```", "```java\n#! /usr/bin/perl\n# Calling Java from Perl\n\nuse strict;\nuse warnings;\n\nuse Text::Levenshtein qw( );\n  # Perl module from CPAN to measure string similarity\n\nuse Inline 0.44 \"JAVA\" =&gt; \"DATA\";  # pointer to the Inline java source\nuse Inline::Java qw(caught);  # helper function to determine exception type\n\nmy $show = new Showit;     # construct Java object using Perl syntax\n$show-&gt;show(\"Just another Perl hacker\");            # call method on that object\n\neval {\n  # Call a method that will call back to Perl;\n  # catch exceptions, if any.\n  print \"matcher: \", $show-&gt;match(\"Japh\", shift||\"Java\"),\n  \" (displayed from Perl)\\n\";\n};\nif ($@) {\n  print STDERR \"Caught:\", caught($@), \"\\n\";\n  die $@ unless caught(\"java.lang.Exception\");\n  print STDERR $@-&gt;getMessage( ), \"\\n\";\n}\n\n__END_  _\n\n__JAVA_  _\n// Java starts here\nimport javax.swing.*;\nimport org.perl.inline.java.*;\n\nclass Showit extends InlineJavaPerlCaller {\n  // extension only neeeded if calling back into Perl\n\n  /** Simple Java class to be called from Perl, and to call back to Perl\n   */\n  public Showit( ) throws InlineJavaException { }\n\n  /** Simple method */\n  public void show(String str) {\n    System.out.println(str + \" inside Java\");\n  }\n\n  /** Method calling back into Perl */\n  public int match(String target, String pattern)\n      throws InlineJavaException, InlineJavaPerlException {\n\n    // Calling a function residing in a Perl Module\n    String str = (String)CallPerl(\"Text::Levenshtein\", \"distance\",\n          new Object [] {target, pattern});\n\n    // Show result\n    JOptionPane.showMessageDialog(null, \"Edit distance between '\" + target +\n        \"' and '\" + pattern + \"' is \" + str,\n        \"Swinging Perl\", JOptionPane.INFORMATION_MESSAGE);\n    return Integer.parseInt(str);\n  }\n\n}\n```", "```java\n$ perl -MCPAN -e shell\n> install Text::Levenshtein\n> install Inline::Java\n> quit\n```", "```java\n$ doas pkg_add p5-Text-LevenshteinXS\n```", "```java\nperl Swinging.pl\n```", "```java\n/**\n * A trivial class to show Java Native Interface 1.1 usage from Java.\n */\npublic class HelloJni {\n  int myNumber = 42; // used to show argument passing\n\n  // declare native class\n  public native void displayHelloJni();\n\n  // Application main, call its display method\n  public static void main(String[] args) {\n    System.out.println(\"HelloJni starting; args.length=\"+\n                       args.length+\"...\");\n    for (int i=0; i<args.length; i++)\n                       System.out.println(\"args[\"+i+\"]=\"+args[i]);\n    HelloJni hw = new HelloJni();\n    hw.displayHelloJni();// call the native function\n    System.out.println(\"Back in Java, \\\"myNumber\\\" now \" + hw.myNumber);\n  }\n\n  // Static code blocks are executed once, when class file is loaded\n  static {\n    System.loadLibrary(\"hello\");\n  }\n}\n```", "```java\njavah jni.HelloJni           // produces HelloJni.h\n```", "```java\nJNIEXPORT void JNICALL Java_HelloJni_displayHelloWorld(JNIEnv *env,\n    jobject this);\n```", "```java\n#include <jni.h>\n#include \"HelloJni.h\"\n#include <stdio.h>\n/*\n * This is the Java Native implementation of displayHelloJni.\n */\nJNIEXPORT void JNICALL Java_HelloJni_displayHelloJni(JNIEnv *env, jobject this) {\n  jfieldID fldid;\n  jint n, nn;\n\n  (void)printf(\"Hello from a Native Method\\n\");\n\n  if (this == NULL) {\n    fprintf(stderr, \"'this.' pointer is null!\\n\");\n    return;\n  }\n  if ((fldid = (*env)->GetFieldID(env,\n        (*env)->GetObjectClass(env, this), \"myNumber\", \"I\")) == NULL) {\n    fprintf(stderr, \"GetFieldID failed\");\n    return;\n  }\n\n  n = (*env)->GetIntField(env, this, fldid);/* retrieve myNumber */\n  printf(\"\\\"myNumber\\\" value is %d\\n\", n);\n\n  (*env)->SetIntField(env, this, fldid, ++n);/* increment it! */\n  nn = (*env)->GetIntField(env, this, fldid);\n\n  printf(\"\\\"myNumber\\\" value now %d\\n\", nn); /* make sure */\n  return;\n}\n```", "```java\n> set JAVA_HOME=C:\\java              # or wherever\n> set INCLUDE=%JAVA_HOME%\\include;%JAVA_HOME%\\include\\Win32;%INCLUDE%\n> set LIB=%JAVA_HOME%\\lib;%LIB%\n> cl HelloJni.c -Fehello.dll -MD -LD\n```", "```java\n$ export JAVAHOME=/local/java   # or wherever\n$ cc -I$JAVAHOME/include -I$JAVAHOME/include/solaris \\\n\t-G HelloJni.c -o libhello.so\n```", "```java\n# Configuration Section\n\nCFLAGS_FOR_SO = -G # Solaris\nCFLAGS_FOR_SO = -shared\nCSRCS        = HelloJni.c\n# JAVA_HOME should be been set in the environment\n#INCLUDES    = -I$(JAVA_HOME)/include -I$(JAVAHOME)/include/solaris\n#INCLUDES    = -I$(JAVA_HOME)/include -I$(JAVAHOME)/include/openbsd\nINCLUDES    = -I$(JAVA_HOME)/include\n\nall:        testhello testjavafromc\n\n# This part of the Makefile is for C called from Java, in HelloJni\ntesthello:        hello.all\n        @echo\n        @echo \"Here we test the Java code \\\"HelloJni\\\" that calls C code.\"\n        @echo\n        LD_LIBRARY_PATH=`pwd`:. java HelloJni\n\nhello.all:        HelloJni.class libhello.so\n\nHelloJni.class: HelloJni.java\n        javac HelloJni.java\n\nHelloJni.h:    HelloJni.class\n        javah -jni HelloJni\n\nHelloJni.o::    HelloJni.h\n\nlibhello.so:    $(CSRCS) HelloJni.h\n    $(CC) $(INCLUDES) $(CFLAGS_FOR_SO) $(CSRCS) -o libhello.so\n\n# This part of the Makefile is for Java called from C, in javafromc\ntestjavafromc:    javafromc.all hello.all\n    @echo\n    @echo \"Now we test HelloJni using javafromc instead of java\"\n    @echo\n    ./javafromc HelloJni\n    @echo\n    @echo \"That was, in case you didn't notice, C->Java->C. And,\"\n    @echo \"incidentally, a replacement for JDK program \\\"java\\\" itself!\"\n    @echo\n\njavafromc.all:    javafromc\n\njavafromc:    javafromc.o\n    $(CC) -L$(LIBDIR) javafromc.o -ljava -o $@\n\njavafromc.o:    javafromc.c\n    $(CC) -c $(INCLUDES) javafromc.c\n\nclean:\n    rm -f core *.class *.o *.so HelloJni.h\nclobber: clean\n    rm -f javafromc\n```", "```java\nC> java jni.HelloJni\nHello from a Native Method      // from C\n\"myNumber\" value is 42          // from C\n\"myNumber\" value now 43         // from C\nValue of myNumber now 43        // from Java\n```", "```java\n/*\n * This is a C program that calls Java code.\n * This could be used as a model for building Java into an\n * existing application as an extention language, for example.\n */\n\n#include <stdio.h>\n#include <jni.h>\n\nint\nmain(int argc, char *argv[]) {\n    int i;\n    JavaVM *jvm;        /* The Java VM we will use */\n    JNIEnv *myEnv;        /* pointer to native environment */\n    JDK1_1InitArgs jvmArgs; /* JNI initialization arguments */\n    jclass myClass, stringClass;    /* pointer to the class type */\n    jmethodID myMethod;    /* pointer to the main() method */\n    jarray args;        /* becomes an array of Strings */\n    jthrowable tossed;    /* Exception object, if we get one. */\n\n    JNI_GetDefaultJavaVMInitArgs(&jvmArgs);    /* set up the argument pointer */\n    /* Could change values now, like: jvmArgs.classpath = ...; */\n\n    /* initialize the JVM! */\n    if (JNI_CreateJavaVM(&jvm, &myEnv, &jvmArgs) < 0) {\n        fprintf(stderr, \"CreateJVM failed\\n\");\n        exit(1);\n    }\n\n    /* find the class named in argv[1] */\n    if ((myClass = (*myEnv)->FindClass(myEnv, argv[1])) == NULL) {\n        fprintf(stderr, \"FindClass %s failed\\n\", argv[1]);\n        exit(1);\n    }\n\n    /* find the static void main(String[]) method of that class */\n    myMethod = (*myEnv)->GetStaticMethodID(\n        myEnv, myClass, \"main\", \"([Ljava/lang/String;)V\");\n    /* myMethod = (*myEnv)->GetMethodID(myEnv, myClass, \"test\", \"(I)I\"); */\n    if (myMethod == NULL) {\n        fprintf(stderr, \"GetStaticMethodID failed\\n\");\n        exit(1);\n    }\n\n    /* Since we're calling main, must pass along the command line arguments,\n * in the form of Java String array\n */\n    if ((stringClass = (*myEnv)->FindClass(myEnv, \"java/lang/String\")) == NULL){\n        fprintf(stderr, \"get of String class failed!!\\n\");\n        exit(1);\n    }\n\n    /* make an array of Strings, subtracting 1 for progname & 1 for the\n * java class name */\n    if ((args = (*myEnv)->NewObjectArray(myEnv, argc-2, stringClass, NULL))==NULL) {\n        fprintf(stderr, \"Create array failed!\\n\");\n        exit(1);\n    }\n\n    /* fill the array */\n    for (i=2; i<argc; i++)\n        (*myEnv)->SetObjectArrayElement(myEnv,\n            args, i-2, (*myEnv)->NewStringUTF(myEnv, argv[i]));\n\n    /* finally, call the method. */\n    (*myEnv)->CallStaticVoidMethodA(myEnv, myClass, myMethod, &args);\n\n    /* And check for exceptions */\n    if ((tossed = (*myEnv)->ExceptionOccurred(myEnv)) != NULL) {\n        fprintf(stderr, \"%s: Exception detected:\\n\", argv[0]);\n        (*myEnv)->ExceptionDescribe(myEnv);    /* writes on stderr */\n        (*myEnv)->ExceptionClear(myEnv);    /* OK, we're done with it. */\n    }\n\n    (*jvm)->DestroyJavaVM(jvm);    /* no error checking as we're done anyhow */\n    return 0;\n}\n```"]