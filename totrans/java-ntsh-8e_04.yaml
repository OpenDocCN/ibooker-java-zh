- en: Chapter 3\. Object-Oriented Programming in Java
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。Java面向对象编程
- en: Now that we’ve covered fundamental Java syntax, we are ready to begin object-oriented
    programming in Java. All Java programs use objects, and the type of an object
    is defined by its *class* or *interface*. Every Java program is defined as a class,
    and nontrivial programs include a number of classes and interface definitions.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讲解了基本的Java语法，可以开始在Java中进行面向对象编程了。所有Java程序都使用对象，对象的类型由其 *类* 或 *接口* 定义。每个Java程序都定义为一个类，复杂的程序包括多个类和接口定义。
- en: This chapter explains how to define new classes (and records) and how to do
    object-oriented programming with them. We also introduce the concept of an interface,
    but a full discussion of interfaces and Java’s type system is deferred until [Chapter 4](ch04.xhtml#javanut8-CHP-4).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将解释如何定义新的类（和记录），以及如何使用它们进行面向对象编程。我们还介绍了接口的概念，但对接口和Java类型系统的全面讨论将推迟到[第4章](ch04.xhtml#javanut8-CHP-4)。
- en: Note
  id: totrans-3
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If you have experience with OO programming, however, be careful. The term “object-oriented”
    has different meanings in different languages. Don’t assume that Java works the
    same way as your favorite OO language. (This is particularly true for JavaScript
    or Python programmers.)
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果您有面向对象编程经验，请小心。术语“面向对象”在不同语言中有不同的含义。不要假设Java与您喜欢的其他面向对象语言工作方式相同。（这对JavaScript或Python程序员特别适用。）
- en: This is a fairly lengthy chapter, so let’s begin with an overview and some definitions.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个相当长的章节，让我们从概述和一些定义开始。
- en: Overview of Classes and Records
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类和记录概述
- en: Classes are the most fundamental structural element of all Java programs. You
    cannot write Java code without defining a class. All Java statements appear within
    classes, and all methods are implemented within classes.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 类是所有Java程序中最基本的结构元素。在定义类之前无法编写Java代码。所有Java语句都出现在类中，并且所有方法都在类中实现。
- en: Basic OO Definitions
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本面向对象定义
- en: 'Here are some important definitions:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些重要的定义：
- en: Class
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 类
- en: A *class* is a collection of data fields that hold values, along with methods
    that operate on those values. A class defines a new reference type, such as the
    `Account` type defined in [Chapter 2](ch02.xhtml#javanut8-CHP-2).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*类* 是包含保存值的数据字段以及操作这些值的方法的集合。类定义了一个新的引用类型，例如[第2章](ch02.xhtml#javanut8-CHP-2)中定义的`Account`类型。'
- en: The `Account` class defines a type that represents customer accounts within
    a banking system.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`Account`类定义了银行系统中客户账户的类型。'
- en: From Java 17 onwards, the language also includes support for records—which are
    a special kind of class that have additional semantics.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 从Java 17开始，语言还包括对记录的支持——这是一种具有附加语义的特殊类。
- en: Object
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 对象
- en: An *object* is an *instance* of a class.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*对象* 是类的 *实例*。'
- en: 'An `Account` object is a value of that type: it represents a specific customer
    bank account.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`Account`对象是该类型的一个值：它表示一个特定的客户银行账户。'
- en: 'Objects are often created by *instantiating* a class with the `new` keyword
    and a constructor invocation, as shown here:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对象通常通过使用`new`关键字和构造函数调用来 *实例化*，如下所示：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Constructors are covered in detail later in this chapter in [“Creating and Initializing
    Objects”](#javanut8-CHP-3-SECT-3).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数将在本章稍后详细讲解，参见[“创建和初始化对象”](#javanut8-CHP-3-SECT-3)。
- en: A class definition consists of a *signature* and a *body*. The class signature
    defines the name of the class and may also specify other important information.
    The body of a class is a set of *members* enclosed in curly braces. The members
    of a class usually include fields and methods, and may also include constructors,
    initializers, and nested types.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 类定义由 *签名* 和 *主体* 组成。类签名定义了类的名称，可能还指定其他重要信息。类的主体是一组用大括号括起来的 *成员*。类的成员通常包括字段和方法，还可能包括构造函数、初始化程序和嵌套类型。
- en: Members can be *static* or nonstatic. A static member belongs to the class itself,
    while a nonstatic member is associated with the instances of a class (see [“Fields
    and Methods”](#javanut8-CHP-3-SECT-2)).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 成员可以是 *静态* 的或非静态的。静态成员属于类本身，而非静态成员与类的实例关联（参见[“字段和方法”](#javanut8-CHP-3-SECT-2)）。
- en: Note
  id: totrans-22
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: There are four very common kinds of members—class fields, class methods, instance
    fields, and instance methods. The majority of work done with Java involves interacting
    with these kinds of members.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 有四种非常常见的成员类型——类字段、类方法、实例字段和实例方法。大多数Java工作涉及与这些类型的成员交互。
- en: The signature of a class may declare that the class *extends* another class.
    The extended class is known as the *superclass* and the extension is known as
    the *subclass*. A subclass *inherits* the members of its superclass and may declare
    new members or *override* inherited methods with new implementations.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 类的签名可以声明类*扩展*另一个类。扩展的类称为*超类*，扩展称为*子类*。子类*继承*其超类的成员，可以声明新的成员或使用新实现*覆盖*继承的方法。
- en: The members of a class may have *access modifiers* `public`, `protected`, or
    `private`.^([1](ch03.xhtml#idm45927749308000)) These modifiers specify their visibility
    and accessibility to clients and to subclasses. This allows classes to control
    access to members that are not part of their public API. This ability to hide
    members enables an object-oriented design technique known as *data encapsulation*,
    which we discuss in [“Data Hiding and Encapsulation”](#javanut8-CHP-3-SECT-5).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 类的成员可以具有*访问修饰符*`public`、`protected`或`private`。^([1](ch03.xhtml#idm45927749308000))
    这些修饰符指定了它们对客户端和子类的可见性和访问权限。这使得类能够控制对不属于其公共API的成员的访问。隐藏成员的能力支持一种称为*数据封装*的面向对象设计技术，我们在[“数据隐藏和封装”](#javanut8-CHP-3-SECT-5)中讨论。
- en: Records
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记录
- en: A *record* (or *record class*) is a special form of class that provides additional
    semantic guarantees that general classes do not.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*记录*（或*记录类*）是一种提供了比一般类更多语义保证的特殊形式。'
- en: Specifically, a record guarantees that the instance fields precisely define
    the only meaningful state of an object of that type. This can be expressed as
    the principle (or *pattern*) that the record class is a *data carrier* or “just
    holds fields.” Agreeing to this principle imposes constraints on programmers,
    but it also frees them from needing to be explicit about some design details.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 具体而言，记录（*record*）保证实例字段精确地定义了该类型对象的唯一有意义的状态。这可以表达为该记录类是一个*数据载体*或“仅持有字段”的原则（或*模式*）。同意这一原则对程序员施加了约束，但也使他们无需明确某些设计细节。
- en: 'A record class is defined like this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 记录类定义如下：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: There is no need to explicitly declare a constructor, or accessor methods for
    the fields—for a record class the compiler automatically generates these members
    and adds them to the class definition. The accessor methods are named exactly
    the same as the underlying fields they provide access to. It is possible to add
    additional methods to a record, but it is not necessary to do so if all that is
    needed is the basic data carrier form.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要显式声明构造函数或字段的访问方法，因为对于记录类，编译器会自动生成这些成员并将它们添加到类定义中。访问方法的名称与它们提供访问权限的底层字段完全相同。虽然可以向记录添加额外的方法，但如果所需的仅仅是基本的数据载体形式，则不必这样做。
- en: 'Instances of record classes (or just records) are created and instantiated
    in the same way as for regular classes, and we can call the accessors on the objects
    we create:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 记录类的实例（或称为记录）的创建和实例化方式与常规类相同，我们可以在创建的对象上调用访问器：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: One other aspect of records is that they are always immutable. Once created,
    the value of a record’s fields cannot be altered. This means that there is no
    need for setter methods for the fields, as they cannot be modified.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 记录（*record*）的另一个方面是它们始终是不可变的。一旦创建，记录字段的值就不能被修改。这意味着不需要为字段编写setter方法，因为它们不能被修改。
- en: 'The contract that Java records have is that the parameter name (as specified
    in the record declaration), the field name, and the method name are all identical:
    if there’s a record parameter `x` of type `double` then the class has a field
    called `x` of type `double` and an instance method called `x()` that returns `double`.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Java记录的契约是，参数名（如记录声明中指定的）与字段名和方法名都完全相同：如果有一个类型为`double`的记录参数`x`，那么类就有一个名称为`x`、类型为`double`的字段和一个名称为`x()`的实例方法，返回`double`。
- en: Records have certain other methods that are also automatically generated by
    the compiler. We will have more to say about them in [Chapter 5](ch05.xhtml#javanut8-CHP-5)
    when we discuss how to use records as part of object-oriented design.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 记录还具有某些其他方法，这些方法也是由编译器自动生成的。在我们讨论如何将记录作为面向对象设计的一部分时，我们将详细介绍它们，见[第5章](ch05.xhtml#javanut8-CHP-5)。
- en: Other Reference Types
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他引用类型
- en: The signature of a class may also declare that the class *implements* one or
    more interfaces. An *interface* is a reference type similar to a class that defines
    method signatures but does not usually include method bodies to implement the
    methods.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 类的签名还可以声明该类*实现*一个或多个接口。*接口*是一种类似于类的引用类型，它定义了方法签名，但通常不包括实现方法的方法体。
- en: However, from Java 8 onward, interfaces may use the keyword `default` to indicate
    that a method specified in the interface is optional. If a method is optional,
    the interface file must include a default implementation (hence the choice of
    keyword), which will be used by all implementing classes that do not provide an
    implementation of the optional method.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，从Java 8开始，接口可以使用关键字`default`来指示接口中指定的方法是可选的。如果方法是可选的，则接口文件必须包含默认实现（因此选择了关键字），该实现将被所有未提供可选方法实现的实现类使用。
- en: A class that implements an interface is required to provide bodies for the interface’s
    nondefault methods. Instances of a class that implement an interface are also
    instances of the interface type.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 实现接口的类需要为接口的非默认方法提供方法体。实现接口的类的实例也是接口类型的实例。
- en: Classes and interfaces are the most important of the five fundamental reference
    types defined by Java. Arrays, enumerated types (or “enums”), and annotation types
    (usually just called “annotations”) are the other three. Arrays are covered in
    [Chapter 2](ch02.xhtml#javanut8-CHP-2). Enums are a specialized kind of class,
    and annotations are a specialized kind of interface—both are discussed later in
    [Chapter 4](ch04.xhtml#javanut8-CHP-4), along with a full discussion of interfaces.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 类和接口是Java定义的五种基本引用类型中最重要的两种。数组、枚举类型（或“enums”）和注解类型（通常称为“注解”）是另外三种。数组在[第二章](ch02.xhtml#javanut8-CHP-2)中有所涉及。枚举是一种特殊的类，而注解是一种特殊的接口——它们将在[第四章](ch04.xhtml#javanut8-CHP-4)中讨论，同时还会全面讨论接口。
- en: Class Definition Syntax
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类定义语法
- en: At its simplest level, a class definition consists of the keyword `class` followed
    by the name of the class and a set of class members within curly braces. The `class`
    keyword may be preceded by modifier keywords and annotations. If the class extends
    another class, the class name is followed by the `extends` keyword and the name
    of the class being extended. If the class implements one or more interfaces, then
    the class name or the `extends` clause is followed by the `implements` keyword
    and a comma-separated list of interface names. For example, for the `Integer`
    class in `java.lang`
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在其最简单的级别上，类定义由关键字`class`后跟类名和一组在大括号内的类成员组成。`class`关键字前可以有修饰符关键字和注解。如果类扩展另一个类，则类名后跟`extends`关键字和被扩展的类的名称。如果类实现一个或多个接口，则类名或`extends`子句后跟`implements`关键字和逗号分隔的接口名称列表。例如，对于`java.lang`中的`Integer`类
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Java also includes the ability to declare *generic classes* that allow an entire
    family of types to be created from a single class declaration. We will meet this
    feature, along with its supporting mechanisms (such as *type parameters* and *wildcards*),
    in [Chapter 4](ch04.xhtml#javanut8-CHP-4).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Java还包括声明*泛型类*的能力，允许从单个类声明中创建整个类型族。我们将在[第四章](ch04.xhtml#javanut8-CHP-4)中遇到此功能，以及支持其的机制（如*类型参数*和*通配符*）。
- en: 'Class declarations may include modifier keywords. In addition to the access
    control modifiers (`public`, `protected`, etc.), these include:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 类声明可以包括修饰符关键字。除了访问控制修饰符（`public`、`protected`等）外，还包括：
- en: '`abstract`'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`abstract`'
- en: An `abstract` class is one whose implementation is incomplete and cannot be
    instantiated. Any class with one or more `abstract` methods must be declared `abstract`.
    Abstract classes are discussed in [“Abstract Classes and Methods”](#javanut8-CHP-3-SECT-6).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`abstract`类是一个实现不完整且无法实例化的类。任何具有一个或多个`abstract`方法的类必须声明为`abstract`。抽象类在[“抽象类和方法”](#javanut8-CHP-3-SECT-6)中讨论。
- en: '`final`'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`final`'
- en: The `final` modifier specifies that the class may not be extended. A class cannot
    be declared to be both `abstract` and `final`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`final`修饰符指定类不可扩展。类不能同时声明为`abstract`和`final`。'
- en: '`sealed`'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`sealed`'
- en: Sealed classes are those that may be extended only by a known set of subclasses.
    Sealed classes provide a halfway house between `final` classes and the default,
    open for extension classes. The use of sealed classes is discussed in more detail
    in [Chapter 5](ch05.xhtml#javanut8-CHP-5). Sealed classes are available only in
    Java 17 and above.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 密封类是只能由已知子类集扩展的类。密封类提供了`final`类和默认开放扩展类之间的中间地带。密封类的使用在[第五章](ch05.xhtml#javanut8-CHP-5)中有更详细的讨论。密封类仅在Java
    17及以上版本中可用。
- en: '`strictfp`'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`strictfp`'
- en: A class can be declared `strictfp`; all its methods behave as if they were declared
    `strictfp`, and thus exactly follow the formal semantics of the floating-point
    standard. This modifier is *extremely* rarely used, and is in fact a no-op in
    Java 17, for the reasons discussed in [Chapter 2](ch02.xhtml#javanut8-CHP-2).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类可以声明为`strictfp`；其所有方法的行为都像它们被声明为`strictfp`一样，并且严格遵循浮点标准的形式语义。这个修饰符在Java 17中实际上是一个无操作符，因为其原因在[第二章](ch02.xhtml#javanut8-CHP-2)中讨论过。
- en: Fields and Methods
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字段和方法
- en: A class can be viewed as a collection of data (also referred to as *state*)
    and code to operate on that state. The data is stored in fields, and the code
    is organized into methods.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类可以被视为数据（也称为*状态*）和操作该状态的代码的集合。数据存储在字段中，而代码组织成方法。
- en: 'This section covers fields and methods, the two most important kinds of class
    members. Fields and methods come in two distinct types: class members (also known
    as static members) are associated with the class itself, while instance members
    are associated with individual instances of the class (i.e., with objects). This
    gives us four kinds of members:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍字段和方法，这两种是类成员中最重要的。字段和方法有两种不同的类型：类成员（也称为静态成员）与类本身关联，而实例成员与类的各个实例（即对象）关联。这使得我们有四种成员：
- en: Class fields
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类字段
- en: Class methods
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类方法
- en: Instance fields
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例字段
- en: Instance methods
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例方法
- en: The simple class definition for the class `Circle`, shown in [Example 3-1](#javanut8-CHP-3-EX-1),
    contains all four types of members.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 类`Circle`的简单定义，如[示例3-1](#javanut8-CHP-3-EX-1)所示，包含了所有四种类型的成员。
- en: Example 3-1\. A simple class and its members
  id: totrans-63
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例3-1\. 一个简单的类及其成员
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Warning
  id: totrans-65
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: It is not good practice to have a public instance field such as `r` in our example.
    It would be much better to have a private field `r` and a method `radius()` (or
    `r()`) to provide access to it. The reason for this will be explained later, in
    [“Data Hiding and Encapsulation”](#javanut8-CHP-3-SECT-5). For now, we use a public
    field simply to give examples of how to work with instance fields.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，有一个公共实例字段`r`并不是好的做法。最好有一个私有字段`r`和一个方法`radius()`（或`r()`）来提供对它的访问。这个原因稍后将在[“数据隐藏与封装”](#javanut8-CHP-3-SECT-5)中解释。现在，我们使用公共字段只是为了给出如何使用实例字段的示例。
- en: The following sections explain all four common kinds of members. First, we cover
    the declaration syntax for fields. (The syntax for declaring methods is covered
    later in this chapter in [“Data Hiding and Encapsulation”](#javanut8-CHP-3-SECT-5).)
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的部分解释了所有四种常见成员。首先，我们介绍字段的声明语法。（方法的声明语法稍后在[“数据隐藏与封装”](#javanut8-CHP-3-SECT-5)章节中讨论。）
- en: Field Declaration Syntax
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字段声明语法
- en: Field declaration syntax is much like the syntax for declaring local variables
    (see [Chapter 2](ch02.xhtml#javanut8-CHP-2)) except that field definitions may
    also include modifiers. The simplest field declaration consists of the field type
    followed by the field name.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 字段声明语法与声明局部变量的语法非常相似（参见[第二章](ch02.xhtml#javanut8-CHP-2)）。不同之处在于字段定义可能还包括修饰符。最简单的字段声明由字段类型后跟字段名称组成。
- en: 'The type may be preceded by zero or more modifier keywords or annotations,
    and the name may be followed by an equals sign and initializer expression that
    provides the initial value of the field. If two or more fields share the same
    type and modifiers, the type may be followed by a comma-separated list of field
    names and initializers. Here are some valid field declarations:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 类型可能由零个或多个修饰符关键字或注解前缀，并且名称后面可能跟着一个等号和初始化表达式，该表达式提供字段的初始值。如果两个或更多字段共享相同的类型和修饰符，类型后面可以跟着一个逗号分隔的字段名称和初始化器列表。以下是一些有效的字段声明：
- en: '[PRE5]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Field modifier keywords comprise zero or more of the following keywords:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 字段修饰关键字由以下零个或多个关键字组成：
- en: '`public`, `protected`, `private`'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`public`, `protected`, `private`'
- en: These access modifiers specify whether and where a field can be used outside
    of the class that defines it.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这些访问修饰符指定字段是否以及在类定义之外的地方能否使用。
- en: '`static`'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`static`'
- en: If present, this modifier specifies that the field is associated with the defining
    class itself rather than with each instance of the class.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在这个修饰符，它指定字段与定义类本身相关联，而不是与类的每个实例相关联。
- en: '`final`'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`final`'
- en: This modifier specifies that once the field has been initialized, its value
    may never be changed. Fields that are both `static` and `final` are compile-time
    constants that `javac` may inline. `final` fields can also be used to create classes
    whose instances are immutable.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个修饰符指定一旦字段被初始化，其值就永远不能改变。同时具有`static`和`final`修饰符的字段是编译时常量，`javac`可以内联它们。`final`字段也可以用于创建其实例是不可变的类。
- en: '`transient`'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`transient`'
- en: This modifier specifies that a field is not part of the persistent state of
    an object and that it need not be serialized along with the rest of the object.
    This modifier is very rarely seen.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这个修饰符指定字段不是对象的持久状态的一部分，因此它不需要与对象的其余部分一起序列化。这个修饰符非常少见。
- en: '`volatile`'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`volatile`'
- en: This modifier indicates that the field has extra semantics for concurrent use
    by two or more threads. The `volatile` modifier says that the value of a field
    must always be read from and flushed to main memory, and that it may not be cached
    by a thread (in a register or CPU cache). See [Chapter 6](ch06.xhtml#javanut8-CHP-6)
    for more details.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这个修饰符指示该字段具有用于两个或多个线程并发使用的额外语义。`volatile`修饰符表示必须始终从主内存读取字段的值并刷新到主内存，并且它可能不会被线程（在寄存器或CPU缓存中）缓存。详见[第6章](ch06.xhtml#javanut8-CHP-6)了解更多细节。
- en: Class Fields
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类字段
- en: 'A *class field* is associated with the class in which it is defined rather
    than with an instance of the class. The following line declares a class field:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*类字段*与定义它的类相关联，而不是与类的实例相关联。以下行声明了一个类字段：'
- en: '[PRE6]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This line declares a field of type `double` named `PI` and assigns it a value
    of `3.14159`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这行声明了一个名为`PI`的`double`类型字段，并赋予它值`3.14159`。
- en: The `static` modifier says that the field is a class field. Class fields are
    sometimes called static fields because of this `static` modifier. The `final`
    modifier says that the value of the field cannot be reassigned directly. Because
    the field `PI` represents a constant, we declare it `final` so that it cannot
    be changed.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`static`修饰符表示该字段是一个类字段。由于这个`static`修饰符，类字段有时也称为静态字段。`final`修饰符表示字段的值不能直接重新分配。因为字段`PI`表示一个常量，我们将其声明为`final`，以确保它不可更改。'
- en: It is a convention in Java (and many other languages) that constants are named
    with capital letters, which is why our field is named `PI`, not `pi`. Defining
    constants like this is a common use for class fields, meaning that the `static`
    and `final` modifiers are often used together. Not all class fields are constants,
    however. In other words, a field can be declared `static` without being declared
    `final`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java（以及许多其他语言）中，常量通常使用大写字母命名，这就是为什么我们的字段命名为`PI`而不是`pi`的惯例。像这样定义常量是类字段的常见用途，因此`static`和`final`修饰符经常一起使用。然而，并非所有的类字段都是常量。换句话说，字段可以被声明为`static`而不声明为`final`。
- en: Note
  id: totrans-89
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The use of public fields that are not `final` is a code smell—as multiple threads
    could update the field and cause behavior that is extremely hard to debug. Beginning
    Java programmers should not use public fields that are not final.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 使用非`final`的公共字段是一种代码异味——因为多个线程可能更新字段并导致极难调试的行为。初学者不应该使用非`final`的公共字段。
- en: A public static field is essentially a global variable. The names of class fields
    are qualified by the unique names of the classes that contain them, however. Thus,
    Java does not suffer from the name collisions that can affect other languages
    when different modules of code define global variables with the same name.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 公共静态字段本质上是全局变量。类字段的名称由包含它们的类的唯一名称限定。因此，在不同代码模块定义具有相同名称的全局变量时，Java 不会遇到名称冲突的问题。
- en: The key point to understand about a static field is that there is only a single
    copy of it. This field is associated with the class itself, not with instances
    of the class. If you look at the various methods of the `Circle` class, you’ll
    see that they use this field. From inside the `Circle` class, the field can be
    referred to simply as `PI`. Outside the class, however, both class and field names
    are required to uniquely specify the field. Methods that are not part of `Circle`
    access this field as `Circle.PI`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 关于静态字段的关键是它只有一个副本。该字段与类本身相关联，而不是类的实例。如果你查看`Circle`类的各种方法，你会发现它们使用了这个字段。在`Circle`类内部，可以简单地将该字段称为`PI`。然而，在类外部，为了唯一指定该字段，需要同时使用类名和字段名。不属于`Circle`的方法将该字段访问为`Circle.PI`。
- en: Class Methods
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类方法
- en: 'As with class fields, *class methods* are declared with the `static` modifier.
    They are also known as *static methods*:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 与类字段类似，*类方法*使用`static`修饰符声明。它们也被称为*静态方法*：
- en: '[PRE7]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This line declares a class method named `radiansToDegrees()`. It has a single
    parameter of type `double` and returns a `double` value.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 此行声明了一个名为`radiansToDegrees()`的类方法。它有一个`double`类型的单参数，并返回一个`double`值。
- en: 'Like class fields, class methods are associated with a class, rather than with
    an object. When invoking a class method from code that exists outside the class,
    you must specify both the name of the class and the method. For example:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 类方法与类相关联，而不是对象。在从类外部代码调用类方法时，必须同时指定类名和方法名。例如：
- en: '[PRE8]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If you want to invoke a class method from inside the class in which it is defined,
    you don’t have to specify the class name. You can also shorten the amount of typing
    required via the use of a static import (as discussed in [Chapter 2](ch02.xhtml#javanut8-CHP-2)).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要在定义它的类内部调用类方法，不必指定类名。还可以通过静态导入来缩短所需的输入量（如[第2章](ch02.xhtml#javanut8-CHP-2)中讨论的）。
- en: Note that the body of our `Circle.radiansToDegrees()` method uses the class
    field `PI`. A class method can use any class fields and class methods of its own
    class (or of any other class that is visible to it).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们的`Circle.radiansToDegrees()`方法体使用了类字段`PI`。类方法可以使用其自身类的任何类字段和类方法（或任何其他可见的类）。
- en: A class method cannot use any instance fields or instance methods because class
    methods are not associated with an instance of the class. In other words, although
    the `radiansToDegrees()` method is defined in the `Circle` class, it cannot use
    the instance part of any `Circle` objects.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 类方法不能使用任何实例字段或实例方法，因为类方法不与类的实例相关联。换句话说，尽管`radiansToDegrees()`方法在`Circle`类中定义，但它不能使用任何`Circle`对象的实例部分。
- en: Note
  id: totrans-102
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: One way to think about this is that in any instance, we always have a reference—`this`—to
    the current object. The `this` reference is passed as an implicit parameter to
    any instance method. However, class methods are not associated with a specific
    instance, so they have no `this` reference and no access to instance fields.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 一个思考方式是，在任何实例中，我们总是有一个引用`this`指向当前对象。`this`引用作为隐式参数传递给任何实例方法。然而，类方法不与特定实例关联，因此它们没有`this`引用，也无法访问实例字段。
- en: As we discussed earlier, a class field is essentially a global variable. In
    a similar way, a class method is a global method, or global function. Although
    `radiansToDegrees()` does not operate on `Circle` objects, it is defined within
    the `Circle` class because it is a utility method that is sometimes useful when
    you’re working with circles, and so it makes sense to package it along with the
    other functionality of the `Circle` class.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的，类字段本质上是全局变量。类方法类似地是全局方法或全局函数。尽管`radiansToDegrees()`不在`Circle`对象上操作，但它在`Circle`类中定义，因为它是一个在处理圆时有时有用的实用方法，所以将它与`Circle`类的其他功能打包是有意义的。
- en: Instance Fields
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实例字段
- en: 'Any field declared without the `static` modifier is an *instance field*:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 没有`static`修饰符声明的任何字段都是*实例字段*：
- en: '[PRE9]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Instance fields are associated with instances of the class, so every `Circle`
    object we create has its own copy of the `double` field `r`. In our example, `r`
    represents the radius of a specific circle. Each `Circle` object can have a radius
    independent of all other `Circle` objects.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 实例字段与类的实例相关联，因此我们创建的每个`Circle`对象都有其自己的`double`类型字段`r`的副本。在我们的示例中，`r`表示特定圆的半径。每个`Circle`对象可以具有与所有其他`Circle`对象独立的半径。
- en: 'Inside a class definition, instance fields are referred to by name alone. You
    can see an example of this if you look at the method body of the `circumference()`
    instance method. In code outside the class, the name of an instance method must
    be prefixed with a reference to the object that contains it. For example, if the
    variable `c` holds a reference to a `Circle` object, we use the expression `c.r`
    to refer to the radius of that circle:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在类定义内部，实例字段仅通过名称引用。如果查看`circumference()`实例方法的方法体，可以看到一个示例。在类外部的代码中，实例方法的名称必须前缀引用包含该方法的对象。例如，如果变量`c`持有`Circle`对象的引用，则使用表达式`c.r`来引用该圆的半径：
- en: '[PRE10]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Instance fields are key to object-oriented programming. Instance fields hold
    the state of an object; the values of those fields make one object distinct from
    another.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 实例字段是面向对象编程的关键。实例字段保存对象的状态；这些字段的值使一个对象与另一个对象不同。
- en: Instance Methods
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实例方法
- en: An *instance* *method* operates on a specific instance of a class (an object),
    and any method not declared with the `static` keyword is automatically an instance
    method.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*实例方法* 是针对类的特定实例（对象）运行的方法，未声明为`static`关键字的任何方法都自动成为实例方法。'
- en: Instance methods are the feature that makes object-oriented programming start
    to get interesting. The `Circle` class defined in [Example 3-1](#javanut8-CHP-3-EX-1)
    contains two instance methods, `area()` and `circumference()`, that compute and
    return the area and circumference of the circle represented by a given `Circle`
    object.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 实例方法是使面向对象编程开始变得有趣的特性。在[Example 3-1](https://example.org/javanut8-CHP-3-EX-1)中定义的`Circle`类包含两个实例方法，`area()`和`circumference()`，用于计算并返回给定`Circle`对象表示的圆的面积和周长。
- en: 'To use an instance method from outside the class in which it is defined, we
    must prefix it with a reference to the instance that is to be operated on. For
    example:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 要从定义它的类的外部使用实例方法，必须前缀引用要操作的实例。例如：
- en: '[PRE11]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-117
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: This is why it is called object-oriented programming; the object is the focus
    here, not the method call.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么它被称为面向对象编程；对象是焦点，而不是方法调用。
- en: From within an instance method, we naturally have access to all the instance
    fields that belong to the object the method was called on. Recall that an object
    is often best considered to be a bundle containing state (represented as the fields
    of the object), and behavior (the methods to act on that state).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在实例方法内部，我们自然地可以访问所有属于调用该方法的对象的实例字段。请记住，一个对象通常被认为是一个包含状态（表示为对象的字段）和行为（操作该状态的方法）的捆绑体。
- en: All instance methods are implemented by using an implicit parameter not shown
    in the method signature. The implicit argument is named `this`; it holds a reference
    to the object through which the method is invoked. In our example, that object
    is a `Circle`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 所有实例方法都使用一个在方法签名中未显示的隐式参数来实现。隐式参数被命名为`this`；它保存通过它调用方法的对象的引用。在我们的示例中，该对象是一个`Circle`。
- en: Note
  id: totrans-121
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'The bodies of the `area()` and `circumference()` methods both use the class
    field `PI`. We saw earlier that class methods can use only class fields and class
    methods, not instance fields or methods. Instance methods are not restricted in
    this way: they can use any member of a class, whether it is declared `static`
    or not.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`area()`和`circumference()`方法的主体都使用类字段`PI`。我们前面看到，类方法只能使用类字段和类方法，而不是实例字段或方法。实例方法没有这种限制：它们可以使用类的任何成员，无论它是声明为`static`还是非`static`的。'
- en: How the this Reference Works
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: this引用的工作原理
- en: The implicit `this` parameter is not shown in method signatures because it is
    usually not needed; whenever a Java method accesses the instance fields in its
    class, it is implicit that it is accessing fields in the object referred to by
    the `this` parameter. The same is true when an instance method invokes another
    instance method in the same class—it’s taken that this means “call the instance
    method on the current object.”
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式的`this`参数在方法签名中未显示，因为通常不需要；每当一个Java方法访问其类中的实例字段时，隐含地它正在访问`this`参数所引用的对象的字段。当一个实例方法在同一个类中调用另一个实例方法时，情况也是如此——这意味着“在当前对象上调用实例方法”。
- en: 'However, you can use the `this` keyword explicitly when you want to make it
    clear that a method is accessing its own fields and/or methods. For example, we
    can rewrite the `area()` method to use `this` explicitly to refer to instance
    fields:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当您希望明确指出方法正在访问其自身字段和/或方法时，可以显式使用`this`关键字。例如，我们可以重写`area()`方法，显式使用`this`来引用实例字段：
- en: '[PRE12]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This code also uses the class name explicitly to refer to class field `PI`.
    In a method this simple, it is not normally necessary to be quite so explicit.
    In more complicated cases, however, you may sometimes find that it increases the
    clarity of your code to use an explicit `this` even when it is not strictly required.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码还显式使用类名来引用类字段*PI*。在如此简单的方法中，通常不必这样明确。然而，在更复杂的情况下，即使不严格要求，有时使用显式的*this* 可以增加代码的清晰度。
- en: In some cases, the `this` keyword *is* required, however. For example, when
    a method parameter or local variable in a method has the same name as one of the
    fields of the class, you must use `this` to refer to the field. This is because
    the field name used alone refers to the method parameter or local variable, as
    discussed in [“Lexical Scoping and Local Variables”](ch04.xhtml#javanut8-CHP-4-SECT-4.4).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，*this* 关键字是必需的。例如，当方法参数或方法中的局部变量与类的某个字段同名时，必须使用*this* 来引用该字段。这是因为单独使用字段名称会引用方法参数或局部变量，详见[“词法作用域和局部变量”](ch04.xhtml#javanut8-CHP-4-SECT-4.4)。
- en: 'For example, we can add the following method to the `Circle` class:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以将以下方法添加到*Circle* 类中：
- en: '[PRE13]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Some developers will deliberately choose the names of their method arguments
    in such a way that they don’t clash with field names, so the use of `this` can
    largely be avoided. However, accessor methods (setter) generated by any of the
    major Java IDEs will use the `this.x = x` style shown here.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 一些开发人员会有意地选择方法参数的名称，以避免与字段名称冲突，因此可以大部分避免使用*this*。然而，由任何主要Java IDE生成的访问方法（setter）将使用此处所示的*this.x
    = x* 样式。
- en: Finally, note that while instance methods can use the `this` keyword, class
    methods cannot because class methods are not associated with individual objects.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请注意，虽然实例方法可以使用*this* 关键字，但类方法不能，因为类方法不与单个对象相关联。
- en: Creating and Initializing Objects
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和初始化对象
- en: Now that we’ve covered fields and methods, let’s move on to other important
    members of a class. In particular, we’ll look at constructors—these are class
    members whose job is to initialize the fields of a class as new instances of the
    class are created.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了字段和方法，让我们继续了解类的其他重要成员。特别是，我们将看看构造函数——这些是类的成员，其工作是在创建类的新实例时初始化类的字段。
- en: 'Take another look at how we’ve been creating `Circle` objects:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 再看一下我们如何创建*Circle* 对象：
- en: '[PRE14]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This can easily be read as creating a new instance of `Circle`, by calling something
    that looks a bit like a method. In fact, `Circle()` is an example of a *constructor*.
    This is a member of a class that has the same name as the class, and it has a
    body, like a method.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可以轻松地看作是通过调用类似方法的东西来创建*Circle* 的新实例。事实上，*Circle()* 就是*构造函数* 的一个示例。这是类的成员，与类同名，并且有一个像方法一样的主体。
- en: Here’s how a constructor works. The `new` operator indicates that we need to
    create a new instance of the class. First of all, memory is allocated (in the
    Java heap) to hold the new object instance. Then, the constructor body is called,
    with any arguments that have been specified. The constructor uses these arguments
    to do whatever initialization of the new object is necessary.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数的工作方式如下。*new* 操作符表示我们需要创建类的一个新实例。首先，在Java堆中分配内存以容纳新对象实例。然后，调用构造函数体，传入任何指定的参数。构造函数使用这些参数来执行新对象的任何初始化工作。
- en: Every class in Java has at least one *constructor*, and their purpose is to
    perform any necessary initialization for a new object. If the programmer does
    not explicitly define a constructor for a class, the `javac` compiler automatically
    creates a constructor (called the default constructor) that takes no arguments
    and performs no special initialization. The `Circle` class seen in [Example 3-1](#javanut8-CHP-3-EX-1)
    used this mechanism to automatically declare a constructor.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Java 中的每个类至少有一个*构造函数*，其目的是为新对象执行任何必要的初始化。如果程序员未显式为类定义构造函数，则*javac* 编译器会自动创建一个构造函数（称为默认构造函数），它不接受任何参数并且不执行任何特殊初始化。在[示例 3-1](#javanut8-CHP-3-EX-1)
    中看到的*Circle* 类使用了这种机制来自动声明一个构造函数。
- en: Defining a Constructor
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义构造函数
- en: There is some obvious initialization we could do for our `Circle` objects, so
    let’s define a constructor. [Example 3-2](#javanut8-CHP-3-EX-2) shows a new definition
    for `Circle` that contains a constructor that lets us specify the radius of a
    new `Circle` object. We’ve also taken the opportunity to make the field `r` protected
    (to prevent access to it from arbitary objects).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的 `Circle` 对象，有一些明显的初始化工作可以做，因此让我们定义一个构造函数。[示例 3-2](#javanut8-CHP-3-EX-2)
    展示了 `Circle` 的新定义，包含了一个构造函数，允许我们指定新 `Circle` 对象的半径。我们还利用这个机会将字段 `r` 设为受保护状态（以防止任意对象访问）。
- en: Example 3-2\. A constructor for the Circle class
  id: totrans-142
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-2\. Circle 类的构造函数
- en: '[PRE15]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'When we relied on the default constructor supplied by the compiler, we had
    to write code like this to initialize the radius explicitly:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们依赖编译器提供的默认构造函数时，我们必须编写类似以下的代码来显式初始化半径：
- en: '[PRE16]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'With the new constructor, the initialization becomes part of the object creation
    step:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 使用新的构造函数，初始化成为对象创建步骤的一部分：
- en: '[PRE17]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here are some basics regarding naming, declaring, and writing constructors:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有关于命名、声明和编写构造函数的一些基础知识：
- en: The constructor name is always the same as the class name.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数的名称始终与类名相同。
- en: A constructor is declared without a return type (not even the `void` placeholder).
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数声明时没有返回类型（甚至不是 `void` 占位符）。
- en: The body of a constructor is the code that initializes the object. You can think
    of this as setting up the contents of the `this` reference.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数的主体是初始化对象的代码。您可以将其视为设置 `this` 引用的内容。
- en: A constructor does not return `this` (or any other value).
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数不会返回 `this`（或任何其他值）。
- en: Defining Multiple Constructors
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义多个构造函数
- en: 'Sometimes you want to initialize an object in a number of different ways, depending
    on what is most convenient in a particular circumstance. For example, we might
    want to initialize the radius of a circle to a specified value or a reasonable
    default value. Here’s how we can define two constructors for `Circle`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您希望根据特定情况的方便程度以多种不同的方式初始化对象。例如，我们可能希望将圆的半径初始化为指定值或合理的默认值。以下是我们如何为 `Circle`
    定义两个构造函数的方式：
- en: '[PRE18]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Because our `Circle` class has only a single instance field, we can’t initialize
    it in too many ways, of course. But in more complex classes, it is often convenient
    to define a variety of constructors.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，因为我们的 `Circle` 类只有一个实例字段，所以我们不能以太多的方式初始化它。但在更复杂的类中，通常方便定义各种构造函数。
- en: It is perfectly legal to define multiple constructors for a class, as long as
    each constructor has a different parameter list. The compiler determines which
    constructor you wish to use based on the number and type of arguments you supply.
    This ability to define multiple constructors is analogous to method overloading.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 定义多个构造函数为一个类是完全合法的，只要每个构造函数有不同的参数列表。编译器根据您提供的参数数量和类型确定您希望使用的构造函数。定义多个构造函数的能力类似于方法重载的能力。
- en: Invoking One Constructor from Another
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从另一个构造函数中调用
- en: 'A specialized use of the `this` keyword arises when a class has multiple constructors;
    it can be used from a constructor to invoke one of the other constructors of the
    same class. In other words, we can rewrite the two previous `Circle` constructors
    as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个类有多个构造函数时，`this` 关键字的一个特殊用法是从一个构造函数中调用同一类的另一个构造函数。换句话说，我们可以将前面两个 `Circle`
    构造函数重写如下：
- en: '[PRE19]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This is a useful technique when a number of constructors share a significant
    amount of initialization code, as it avoids repetition of that code. In more complex
    cases, where the constructors do a lot more initialization, this can be a very
    useful technique.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当多个构造函数共享大量初始化代码时，这是一种有用的技术，因为它避免了重复编写该代码。在更复杂的情况下，如果构造函数进行了更多的初始化操作，这将是一种非常有用的技术。
- en: 'There is an important restriction on using `this()`: it can appear only as
    the first statement in a constructor, but the call may be followed by any additional
    initialization a particular constructor needs to perform. The reason for this
    restriction involves the automatic invocation of superclass constructors, which
    we’ll explore later in this chapter.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `this()` 有一个重要的限制：它只能作为构造函数中的第一条语句出现，但随后可以跟随特定构造函数需要执行的任何额外初始化操作。这个限制涉及到超类构造函数的自动调用，我们将在本章后面探讨这个问题。
- en: Field Defaults and Initializers
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字段默认值和初始化器
- en: The fields of a class do not necessarily require initialization. If their initial
    values are not specified, the fields are automatically initialized to the default
    value `false`, `\u0000`, `0`, `0.0`, or `null`, depending on their type (see [Table 2-1](ch02.xhtml#javanut8-CHP-2-TABLE-1)
    for more details). These default values are specified by the Java language specification
    and apply to both instance fields and class fields.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 类的字段不一定需要初始化。如果它们的初始值未指定，则字段将自动初始化为默认值`false`、`\u0000`、`0`、`0.0`或`null`，具体取决于它们的类型（有关更多详细信息，请参见[表
    2-1](ch02.xhtml#javanut8-CHP-2-TABLE-1)）。这些默认值由 Java 语言规范指定，并适用于实例字段和类字段。
- en: Note
  id: totrans-165
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The default values are essentially the “natural” interpretation of the zero
    bit pattern for each type.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 默认值实际上是每种类型的零位模式的“自然”解释。
- en: 'If the default field value is not appropriate for your field, you can instead
    explicitly provide a different initial value. For example:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果默认字段值不适合您的字段，则可以显式提供不同的初始值。例如：
- en: '[PRE20]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Field declarations are not part of any method. Instead, the Java compiler generates
    initialization code for the field automatically and puts it into all the constructors
    for the class. The initialization code is inserted into a constructor in the order
    in which it appears in the source code, which means that a field initializer can
    use the initial values of any fields declared before it.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 字段声明不属于任何方法。相反，Java 编译器会自动生成字段的初始化代码，并将其放入类的所有构造函数中。初始化代码按照其在源代码中出现的顺序插入到构造函数中，这意味着字段初始化程序可以使用其之前声明的任何字段的初始值。
- en: 'Consider the following code excerpt, which shows a constructor and two instance
    fields of a hypothetical class:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 请考虑以下代码摘录，显示了假设类的构造函数和两个实例字段：
- en: '[PRE21]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In this case, the code generated by `javac` for the constructor is actually
    equivalent to:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，由`javac`为构造函数生成的代码实际上等效于：
- en: '[PRE22]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If a constructor begins with a `this()` call to another constructor, the field
    initialization code does not appear in the first constructor. Instead, the initialization
    is handled in the constructor invoked by the `this()` call.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果构造函数以对另一个构造函数的`this()`调用开始，则字段初始化代码不会出现在第一个构造函数中。相反，初始化在由`this()`调用的构造函数中处理。
- en: So, if instance fields are initialized in the constructor, where are class fields
    initialized? These fields are associated with the class, even if no instances
    of the class are ever created. Logically, this means they need to be initialized
    even before a constructor is called.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果实例字段在构造函数中初始化，那么类字段在哪里初始化呢？即使永远不创建类的实例，这些字段也与类关联。从逻辑上讲，这意味着它们需要在调用构造函数之前初始化。
- en: To support this, `javac` generates a class initialization method automatically
    for every class. Class fields are initialized in the body of this method, which
    is invoked exactly once before the class is first used (often when the class is
    first loaded by the Java VM).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持这一点，`javac` 为每个类自动生成一个类初始化方法。类字段在该方法体中初始化，该方法在类第一次使用之前恰好调用一次（通常是在 Java VM
    第一次加载类时）。
- en: As with instance field initialization, class field initialization expressions
    are inserted into the class initialization method in the order in which they appear
    in the source code. This means that the initialization expression for a class
    field can use the class fields declared before it.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 与实例字段初始化类似，类字段初始化表达式按照其在源代码中出现的顺序插入到类初始化方法中。这意味着类字段的初始化表达式可以使用在其之前声明的类字段。
- en: The class initialization method is an internal method that is hidden from Java
    programmers. In the class file, it bears the name `<clinit>` (and you could see
    this method by, for example, examining the class file with `javap`—see [Chapter 13](ch13.xhtml#javanut8-CHP-13)
    for more details on how to use `javap` to do this).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 类初始化方法是一个对 Java 程序员隐藏的内部方法。在类文件中，它被命名为`<clinit>`（例如，可以使用`javap`检查类文件，详细信息请参见[第
    13 章](ch13.xhtml#javanut8-CHP-13)）。
- en: Initializer blocks
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 初始化块
- en: So far, we’ve seen that objects can be initialized through the initialization
    expressions for their fields and by arbitrary code in their constructors. A class
    has a class initialization method (which is like a constructor), but we cannot
    explicitly define the body of this method in Java, although it is perfectly legal
    to do so in bytecode.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到对象可以通过其字段的初始化表达式和构造函数中的任意代码进行初始化。一个类有一个类初始化方法（类似于构造函数），但我们不能在Java中显式定义此方法的主体，尽管在字节码中这样做是完全合法的。
- en: 'Java does however allow us to express class initialization with a construct
    known as a *static initializer*. A static initializer is simply the keyword `static`
    followed by a block of code in curly braces. A static initializer can appear in
    a class definition anywhere a field or method definition can appear. For example,
    consider the following code that performs some nontrivial initialization for two
    class fields:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Java确实允许我们使用称为*静态初始化器*的结构来表达类的初始化。静态初始化器只是关键字`static`后跟一对花括号内的代码块。静态初始化器可以出现在类定义的任何地方，就像字段或方法定义一样。例如，考虑以下代码，它对两个类字段执行一些非平凡的初始化：
- en: '[PRE23]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: A class can have any number of static initializers. The body of each initializer
    block is incorporated into the class initialization method, along with any static
    field initialization expressions. A static initializer is like a class method
    in that it cannot use the `this` keyword or any instance fields or instance methods
    of the class.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 类可以有任意数量的静态初始化器。每个初始化器块的主体都会与类初始化方法一起合并，以及任何静态字段初始化表达式。静态初始化器类似于类方法，因为它不能使用`this`关键字或类的任何实例字段或实例方法。
- en: Record Constructors
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记录构造函数
- en: 'Record classes, introduced as a standard feature in Java 16, implicitly define
    one constructor: the canonical constructor defined by the parameter list. There
    may be circumstances, however, when developers need to provide additional (aka
    auxiliary) constructors for record classes. For example, to provide default values
    for some of the record parameters, as in:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 记录类作为Java 16的标准特性引入，隐式定义一个构造函数：由参数列表定义的标准构造函数。然而，开发人员可能需要为记录类提供额外的（也称为辅助）构造函数的情况。例如，为记录参数提供默认值，如：
- en: '[PRE24]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Records also provide for another refinement to class constructors: the *compact
    constructor*. This is used when some sort of validation or other checking code
    is helpful for creating valid record objects. For example:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 记录还提供了类构造函数的另一种改进：*紧凑构造函数*。这在帮助创建有效的记录对象时，某些验证或其他检查代码很有用。例如：
- en: '[PRE25]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note that in the compact constructor syntax, the parameter list does not need
    to be repeated (as it is inferred from the record declaration) and the parameters
    (in our example, `x` and `y`) are already in scope. Compact constructors, like
    the canonical constructor, also implicitly initialize the fields from the parameter
    values.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在紧凑构造函数语法中，请注意参数列表不需要重复（因为可以从记录声明中推断出来），而且参数（在我们的示例中为`x`和`y`）已经在范围内。紧凑构造函数与标准构造函数一样，也会从参数值隐式初始化字段。
- en: Subclasses and Inheritance
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 子类和继承
- en: The `Circle` defined earlier is a simple class that distinguishes circle objects
    only by their radii. Suppose, instead, that we want to represent circles that
    have both a size and a position. For example, a circle of radius 1.0 centered
    at point 0,0 in the Cartesian plane is different from the circle of radius 1.0
    centered at point 1,2\. To do this, we need a new class, which we’ll call `PlaneCircle`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 早些时候定义的`Circle`是一个简单的类，仅通过其半径区分圆对象。假设我们想要表示既有大小又有位置的圆。例如，在笛卡尔平面上以点0,0为中心的半径为1.0的圆与以点1,2为中心的半径为1.0的圆是不同的。为此，我们需要一个新类，我们称之为`PlaneCircle`。
- en: We’d like to add the ability to represent the position of a circle without losing
    any of the existing functionality of the `Circle` class. We do this by defining
    `PlaneCircle` as a subclass of `Circle` so that `PlaneCircle` inherits the fields
    and methods of its superclass, `Circle`. The ability to add functionality to a
    class by subclassing, or extending, is central to the object-oriented programming
    paradigm.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望能够表示圆的位置，而不丢失`Circle`类的任何现有功能。我们通过将`PlaneCircle`定义为`Circle`的子类来实现这一点，这样`PlaneCircle`就继承了其超类`Circle`的字段和方法。通过子类化或扩展类来添加功能是面向对象编程范式的核心。
- en: Extending a Class
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展类
- en: In [Example 3-3](#javanut8-CHP-3-EX-3), we show how we can implement `PlaneCircle`
    as a subclass of the `Circle` class.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [示例 3-3](#javanut8-CHP-3-EX-3) 中，我们展示了如何将 `PlaneCircle` 实现为 `Circle` 类的子类。
- en: Example 3-3\. Extending the Circle class
  id: totrans-195
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-3\. 扩展 Circle 类
- en: '[PRE26]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note the use of the keyword `extends` in the first line of [Example 3-3](#javanut8-CHP-3-EX-3).
    This keyword tells Java that `PlaneCircle` extends, or subclasses, `Circle`, meaning
    that it inherits the fields and methods of that class.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 注意第一行中 [示例 3-3](#javanut8-CHP-3-EX-3) 中关键字 `extends` 的使用。此关键字告诉 Java `PlaneCircle`
    类扩展或子类化了 `Circle`，这意味着它继承了该类的字段和方法。
- en: 'The definition of the `isInside()` method shows field inheritance; this method
    uses the field `r` (defined by the `Circle` class) as if it were defined right
    in `PlaneCircle` itself. `PlaneCircle` also inherits the methods of `Circle`.
    Therefore, if we have a `PlaneCircle` object referenced by variable `pc`, we can
    say:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`isInside()` 方法的定义展示了字段继承；此方法使用了 `r` 字段（由 `Circle` 类定义），就好像它是在 `PlaneCircle`
    类自身定义的一样。`PlaneCircle` 还继承了 `Circle` 的方法。因此，如果我们有一个变量 `pc` 引用的是 `PlaneCircle`
    对象，我们可以说：'
- en: '[PRE27]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This works just as if the `area()` and `circumference()` methods were defined
    in `PlaneCircle` itself.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这就像 `area()` 和 `circumference()` 方法是在 `PlaneCircle` 类自身定义的一样。
- en: 'Another feature of subclassing is that every `PlaneCircle` object is also a
    perfectly legal `Circle` object. If `pc` refers to a `PlaneCircle` object, we
    can assign it to a `Circle` variable and forget all about its extra positioning
    capabilities:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 子类化的另一个特点是每个 `PlaneCircle` 对象也是一个完全合法的 `Circle` 对象。如果 `pc` 引用的是 `PlaneCircle`
    对象，我们可以将其分配给 `Circle` 变量，并忘记其额外的定位能力：
- en: '[PRE28]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This assignment of a `PlaneCircle` object to a `Circle` variable can be done
    without a cast. As we discussed in [Chapter 2](ch02.xhtml#javanut8-CHP-2), a conversion
    like this is always legal. The value held in the `Circle` variable `c` is still
    a valid `PlaneCircle` object, but the compiler cannot know this for sure, so it
    doesn’t allow us to do the opposite (narrowing) conversion without a cast:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将 `PlaneCircle` 对象分配给 `Circle` 变量而无需强制转换。正如我们在 [第二章](ch02.xhtml#javanut8-CHP-2)
    中讨论的那样，这样的转换始终是合法的。存储在 `Circle` 变量 `c` 中的值仍然是有效的 `PlaneCircle` 对象，但是编译器无法确定这一点，因此不允许我们在没有强制转换的情况下进行相反的（缩小范围）转换：
- en: '[PRE29]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This distinction is covered in more detail in [“Nested Types”](ch04.xhtml#javanut8-CHP-4-SECT-5),
    where we talk about the distinction between the compile and runtime type of an
    object.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这种区别在 [“嵌套类型”](ch04.xhtml#javanut8-CHP-4-SECT-5) 中有更详细的介绍，我们在那里讨论了对象的编译时和运行时类型之间的区别。
- en: Final classes
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 最终类
- en: 'When a class is declared with the `final` modifier, it means that it cannot
    be extended or subclassed. `java.lang.String` is an example of a `final` class.
    Declaring a class `final` prevents unwanted extensions to the class: if you invoke
    a method on a `String` object, you know that the method is the one defined by
    the `String` class itself, even if the `String` is passed to you from some unknown
    outside source.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个类使用 `final` 修饰符声明时，意味着它不能被扩展或子类化。`java.lang.String` 就是 `final` 类的一个例子。声明类为
    `final` 可以防止不需要的类扩展：如果您在 `String` 对象上调用方法，您知道该方法是由 `String` 类自身定义的，即使这个 `String`
    是从某个未知外部来源传递给您的。
- en: In general, many of the classes that Java developers create should be `final`.
    Think carefully about whether it will make sense to allow other (possibly unknown)
    code to extend your classes—if it doesn’t, then disallow the mechanism by declaring
    your classes `final`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，Java 开发者创建的许多类应该是 `final` 的。仔细考虑是否允许其他（可能未知的）代码扩展您的类是否合理——如果不合理，则通过声明您的类为
    `final` 来禁止此机制。
- en: Superclasses, Object, and the Class Hierarchy
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 超类、Object 和类层次结构
- en: 'In our example, `PlaneCircle` is a subclass of `Circle`. We can also say that
    `Circle` is the superclass of `PlaneCircle`. The superclass of a class is specified
    in its `extends` clause, and a class may have only a single direct superclass:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，`PlaneCircle` 是 `Circle` 的子类。我们还可以说 `Circle` 是 `PlaneCircle` 的超类。类的超类在其
    `extends` 子句中指定，并且一个类可能只有一个直接的超类：
- en: '[PRE30]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Every class the programmer defines has a superclass. If the superclass is not
    specified with an `extends` clause, then the superclass is taken to be the class
    `java.lang.Object`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员定义的每个类都有一个超类。如果超类未在 `extends` 子句中指定，则超类被认为是 `java.lang.Object` 类。
- en: 'As a result, the `Object` class is special for a couple of reasons:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`Object` 类对于几个特定原因非常特殊：
- en: It is the only class in Java that does not have a superclass.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是 Java 中唯一一个没有超类的类。
- en: All Java classes inherit (directly or indirectly) the methods of `Object`.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有Java类（直接或间接）继承`Object`的方法。
- en: Because every class (except `Object`) has a superclass, classes in Java form
    a class hierarchy, which can be represented as a tree with `Object` at its root.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 因为每个类（除了`Object`）都有一个超类，Java类形成一个类层次结构，可以将其表示为以`Object`为根的树形结构。
- en: Note
  id: totrans-217
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '`Object` has no superclass, but every other class has exactly one superclass.
    A subclass cannot extend more than one superclass; see [Chapter 4](ch04.xhtml#javanut8-CHP-4)
    for more information on how to achieve a similar result using interfaces.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object`没有超类，但每个其他类都恰好有一个超类。子类不能扩展多个超类；详见[第四章](ch04.xhtml#javanut8-CHP-4)了解如何使用接口实现类似结果的更多信息。'
- en: '[Figure 3-1](#javanut8-CHP-3-FIG-1) shows a partial class hierarchy diagram
    that includes our `Circle` and `PlaneCircle` classes, as well as some of the standard
    classes from the Java API.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 3-1](#javanut8-CHP-3-FIG-1)展示了一个部分类层次结构图，包括我们的`Circle`和`PlaneCircle`类，以及一些来自Java
    API的标准类。'
- en: '![JN7 0301](assets/jns8_0301.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![JN7 0301](assets/jns8_0301.png)'
- en: Figure 3-1\. A class hierarchy diagram
  id: totrans-221
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-1\. 类层次结构图
- en: Subclass Constructors
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 子类构造函数
- en: 'Look again at the `PlaneCircle()` constructor from [Example 3-3](#javanut8-CHP-3-EX-3):'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 再看一下来自[示例 3-3](#javanut8-CHP-3-EX-3)的`PlaneCircle()`构造函数：
- en: '[PRE31]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Although this constructor explicitly initializes the `cx` and `cy` fields newly
    defined by `PlaneCircle`, it relies on the superclass `Circle()` constructor to
    initialize the inherited fields of the class. To invoke the superclass constructor,
    our constructor calls `super()`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然此构造函数显式初始化了由`PlaneCircle`新定义的`cx`和`cy`字段，但它依赖于超类`Circle()`构造函数来初始化类的继承字段。为了调用超类构造函数，我们的构造函数调用了`super()`。
- en: '`super` is a reserved word in Java. One of its main uses is to invoke the constructor
    of a superclass from within a subclass constructor. This use is analogous to the
    use of `this()` to invoke one constructor of a class from within another constructor
    of the same class. Invoking a constructor using `super()` is subject to the same
    restrictions as is using `this()`:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`super`是Java中的保留字。其主要用途之一是从子类构造函数中调用超类的构造函数。这与使用`this()`从同一类的另一个构造函数中调用构造函数类似。使用`super()`调用构造函数的限制与使用`this()`相同：'
- en: '`super()` can be used in this way only within a constructor.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`super()`只能在构造函数中以这种方式使用。'
- en: The call to the superclass constructor must appear as the first statement within
    the constructor, even before local variable declarations.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须将对超类构造函数的调用作为构造函数中的第一条语句出现，甚至在局部变量声明之前。
- en: The arguments passed to `super()` must match the parameters of the superclass
    constructor. If the superclass defines more than one constructor, `super()` can
    be used to invoke any one of them, depending on the arguments passed.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给`super()`的参数必须与超类构造函数的参数匹配。如果超类定义了多个构造函数，则可以使用`super()`来调用其中任何一个，具体取决于传递的参数。
- en: Constructor Chaining and the Default Constructor
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构造函数链和默认构造函数
- en: Java guarantees that the constructor of a class is called whenever an instance
    of that class is created. It also guarantees that the constructor is called whenever
    an instance of any subclass is created. In order to guarantee this second point,
    Java must ensure that every constructor calls its superclass constructor.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: Java保证每当创建该类的实例时都会调用该类的构造函数。它还保证每当创建任何子类的实例时都会调用构造函数。为了保证第二点，Java必须确保每个构造函数调用其超类的构造函数。
- en: Thus, if the first statement in a constructor does not explicitly invoke another
    constructor with `this()` or `super()`, the `javac` compiler inserts the call
    `super()` (i.e., it calls the superclass constructor with no arguments). If the
    superclass does not have a visible constructor that takes no arguments, this implicit
    invocation causes a compilation error.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果构造函数中的第一个语句没有显式地使用`this()`或`super()`调用另一个构造函数，`javac`编译器会插入调用`super()`（即调用没有参数的超类构造函数）。如果超类没有一个可见且不带参数的构造函数，这种隐式调用将导致编译错误。
- en: 'Consider what happens when we create a new instance of the `PlaneCircle` class:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑当我们创建`PlaneCircle`类的新实例时会发生什么：
- en: First, the `PlaneCircle` constructor is invoked.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，调用了`PlaneCircle`构造函数。
- en: This constructor explicitly calls `super(r)` to invoke a `Circle` constructor.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此构造函数显式调用`super(r)`来调用`Circle`构造函数。
- en: That `Circle()` constructor implicitly calls `super()` to invoke the constructor
    of its superclass, `Object` (`Object` only has one constructor).
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 那个`Circle()`构造函数隐式调用`super()`来调用其超类`Object`的构造函数（`Object`只有一个构造函数）。
- en: At this point, we’ve reached the top of the hierarchy and constructors start
    to run.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到这一点，我们已经到达了层次结构的顶部，并且构造函数开始运行。
- en: The body of the `Object` constructor runs first.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Object`构造函数的主体首先运行。'
- en: When it returns, the body of the `Circle()` constructor runs.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当它返回时，`Circle()`构造函数的主体运行。
- en: Finally, when the call to `super(r)` returns, the remaining statements of the
    `PlaneCircle()` constructor are executed.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，当对`super(r)`的调用返回时，会执行`PlaneCircle()`构造函数的剩余语句。
- en: What all this means is that constructor calls are chained; any time an object
    is created, a sequence of constructors is invoked, from subclass to superclass
    on up to `Object` at the root of the class hierarchy.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些意味着构造函数调用是链式的；每次创建对象时，会调用一系列构造函数，从子类到超类直到`Object`在类层次结构的根部。
- en: Because a superclass constructor is always invoked as the first statement of
    its subclass constructor, the body of the `Object` constructor always runs first,
    followed by the constructor of its subclass and on down the class hierarchy to
    the class that is being instantiated.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 因为超类构造函数总是作为其子类构造函数的第一个语句调用，所以`Object`构造函数的主体总是首先运行，然后是其子类的构造函数，以及类层次结构直到被实例化的类。
- en: Whenever a constructor is invoked, it can count on the fields of its superclass
    to be initialized by the time the constructor starts to run.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 每当调用构造函数时，它可以确保其超类的字段在构造函数开始运行时已被初始化。
- en: The default constructor
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 默认构造函数
- en: There is one missing piece in the previous description of constructor chaining.
    If a constructor does not invoke a superclass constructor, Java does so implicitly.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前对构造函数链的描述中，有一个遗漏的部分。如果一个构造函数没有调用超类的构造函数，Java会隐式地这样做。
- en: Note
  id: totrans-246
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If a class is declared without a constructor, Java implicitly adds a constructor
    to the class. This default constructor does nothing but invoke the superclass
    constructor.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个类声明时没有构造函数，Java会隐式地为该类添加一个构造函数。这个默认构造函数什么也不做，只调用超类的构造函数。
- en: 'For example, if we don’t declare a constructor for the `PlaneCircle` class,
    Java implicitly inserts this constructor:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们没有为`PlaneCircle`类声明构造函数，Java会隐式插入这个构造函数：
- en: '[PRE32]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Classes declared `public` are given `public` constructors. All other classes
    are given a default constructor that is declared without any visibility modifier;
    such a constructor has default visibility.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 声明为`public`的类具有`public`构造函数。所有其他类都将获得默认构造函数，该构造函数声明时没有任何可见性修饰符；这样的构造函数具有默认可见性。
- en: One very important point is that if a class declares constructors that take
    parameters but does not define a no-argument constructor, then all its subclasses
    must define constructors that explicitly invoke a constructor with the necessary
    arguments.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常重要的点是，如果一个类声明了带参数的构造函数但没有定义无参数构造函数，那么它的所有子类必须定义构造函数来显式调用具有必要参数的构造函数。
- en: Note
  id: totrans-252
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If you are creating a `public` class that should not be publicly instantiated,
    declare at least one non-`public` constructor to prevent the insertion of a default
    `public` constructor.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在创建一个不应公开实例化的`public`类，请至少声明一个非`public`构造函数，以防止插入默认的`public`构造函数。
- en: Classes that should never be instantiated (such as `java.lang.Math` or `java.lang.System`)
    should define only a `private` constructor. Such a constructor can never be invoked
    from outside of the class, and it prevents the automatic insertion of the default
    constructor. The overall effect is that the class will never be instantiated,
    as it is not instantiated by the class itself and no other class has the correct
    access.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 永远不应该实例化的类（如`java.lang.Math`或`java.lang.System`）应该只定义一个`private`构造函数。这样的构造函数永远不能从类的外部调用，并且它阻止默认构造函数的自动插入。总体效果是该类永远不会被实例化，因为它不会被类本身实例化，也没有其他类有正确的访问权限。
- en: Hiding Superclass Fields
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隐藏超类字段
- en: 'For the sake of example, imagine that our `PlaneCircle` class needs to know
    the distance between the center of the circle and the origin (0,0). We can add
    another instance field to hold this value:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，假设我们的`PlaneCircle`类需要知道圆心与原点（0,0）之间的距离。我们可以添加另一个实例字段来保存这个值：
- en: '[PRE33]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Adding the following line to the constructor computes the value of the field:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下行添加到构造函数会计算字段的值：
- en: '[PRE34]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'But wait; this new field `r` has the same name as the radius field `r` in the
    `Circle` superclass. When this happens, we say that the field `r` of `PlaneCircle`
    *hides* the field `r` of `Circle`. (This is a contrived example, of course: the
    new field really should be called `distanceFromOrigin`.)'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，请注意；这个新字段`r`与`Circle`超类中的半径字段`r`名称相同。当这种情况发生时，我们称`PlaneCircle`的字段`r`*隐藏*了`Circle`的字段`r`。（当然，这是一个刻意构造的例子：这个新字段应该被称为`distanceFromOrigin`。）
- en: Note
  id: totrans-261
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: In code that you write, you should avoid declaring fields with names that hide
    superclass fields. It is almost always a sign of bad code.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在你写的代码中，应避免声明名称隐藏超类字段的字段。这几乎总是糟糕代码的标志。
- en: 'With this new definition of `PlaneCircle`, the expressions `r` and `this.r`
    both refer to the field of `PlaneCircle`. How, then, can we refer to the field
    `r` of `Circle` that holds the radius of the circle? A special syntax for this
    uses the `super` keyword:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`PlaneCircle`的这个新定义，表达式`r`和`this.r`都指的是`PlaneCircle`的字段。那么，我们如何引用`Circle`中持有圆的半径的字段`r`呢？一种特殊的语法使用`super`关键字：
- en: '[PRE35]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Another way to refer to a hidden field is to cast `this` (or any instance of
    the class) to the appropriate superclass and then access the field:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 引用隐藏字段的另一种方法是将`this`（或任何类的实例）转型为适当的超类，然后访问字段：
- en: '[PRE36]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This casting technique is particularly useful when you need to refer to a hidden
    field defined in a class that is not the immediate superclass. Suppose, for example,
    that classes `A`, `B`, and `C` all define a field named `x` and that `C` is a
    subclass of `B`, which is a subclass of `A`. Then, in the methods of class `C`,
    you can refer to these different fields as follows:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要引用定义在不是直接超类的类中的隐藏字段时，这种转型技术特别有用。例如，类`A`、`B`和`C`都定义了一个名为`x`的字段，并且`C`是`B`的子类，`B`是`A`的子类。那么在类`C`的方法中，你可以如下引用这些不同的字段：
- en: '[PRE37]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note
  id: totrans-269
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You cannot refer to a hidden field `x` in the superclass of a superclass with
    `super.super.x`. This is not legal syntax.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能使用`super.super.x`来引用超类的超类中隐藏的字段`x`。这不是合法的语法。
- en: 'Similarly, if you have an instance `c` of class `C`, you can refer to the three
    fields named `x` like this:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，如果你有一个类`C`的实例`c`，你可以像这样引用三个名为`x`的字段：
- en: '[PRE38]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'So far, we’ve been discussing instance fields. Class fields can also be hidden.
    You can use the same `super` syntax to refer to the hidden value of the field,
    but this is never necessary, as you can always refer to a class field by prepending
    the name of the desired class. Suppose, for example, that the implementer of `PlaneCircle`
    decides that the `Circle.PI` field does not declare to enough decimal places.
    She can define her own class field `PI`:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在讨论实例字段。类字段也可以被隐藏。你可以使用相同的`super`语法来引用字段的隐藏值，但这从未是必要的，因为你总是可以通过在所需类名前添加来引用类字段。例如，假设`PlaneCircle`的实现者决定`Circle.PI`字段的精度不够。她可以定义自己的类字段`PI`：
- en: '[PRE39]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now code in `PlaneCircle` can use this more accurate value with the expressions
    `PI` or `PlaneCircle.PI`. It can also refer to the old, less accurate value with
    the expressions `super.PI` and `Circle.PI`. However, the `area()` and `circumference()`
    methods inherited by `PlaneCircle` are defined in the `Circle` class, so they
    use the value `Circle.PI`, even though that value is hidden now by `PlaneCircle.PI`.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`PlaneCircle`中的代码可以使用这个更精确的值，表达式`PI`或`PlaneCircle.PI`。它还可以通过表达式`super.PI`和`Circle.PI`引用旧的、不太精确的值。然而，`PlaneCircle`继承的`area()`和`circumference()`方法是在`Circle`类中定义的，因此它们使用`Circle.PI`的值，即使现在被`PlaneCircle.PI`隐藏了。
- en: Overriding Superclass Methods
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 覆盖超类方法
- en: When a class defines an instance method using the same name, return type, and
    parameters as a method in its superclass, that method *overrides* the method of
    the superclass. When the method is invoked for an object of the class, it is the
    new definition of the method that is called, not the old definition from the superclass.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个类定义一个与其超类中方法相同名称、返回类型和参数的实例方法时，该方法*覆盖*了超类的方法。当为该类的对象调用方法时，调用的是该方法的新定义，而不是超类中的旧定义。
- en: Tip
  id: totrans-278
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: The return type of the overriding method may be a subclass of the return type
    of the original method (instead of being exactly the same type). This is known
    as a *covariant return*.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖方法的返回类型可以是原始方法返回类型的子类（而不是完全相同的类型）。这被称为*协变返回*。
- en: Method overriding is an important and useful technique in object-oriented programming.
    `PlaneCircle` does not override either of the methods defined by `Circle`, and
    in fact it is difficult to think of a good example where any of the methods defined
    by `Circle` could have a well-defined override.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 方法覆盖是面向对象编程中一种重要且有用的技术。`PlaneCircle` 并没有覆盖 `Circle` 定义的任何方法，实际上很难想象出一个能够清晰定义覆盖
    `Circle` 方法的好例子。
- en: Warning
  id: totrans-281
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Don’t be tempted to consider subclassing `Circle` with a class like `Ellipse`—this
    would actually violate a core principle of object-oriented development (the Liskov
    principle, which we will meet later in this chapter).
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 不要试图用像 `Ellipse` 这样的类对 `Circle` 进行子类化——这实际上违反了面向对象开发的核心原则（里斯科夫原则，我们将在本章后面讨论）。
- en: 'Instead, let’s look at a different example that does work with method overriding:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，让我们看一个确实使用方法覆盖的不同示例：
- en: '[PRE40]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This is a bit more complex, but it will illustrate the concepts behind overriding.
    Along with the `Car` class, we also have a specialized class, `SportsCar`. This
    has several differences: it has a fixed-size fuel tank and comes only in a two-door
    version. It may also have a much higher top speed than the regular form, but if
    the top speed rises above 200 km/h then the fuel efficiency of the car suffers,
    and as a result the overall range of the car starts to decrease:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这有点复杂，但它将说明覆盖背后的概念。与 `Car` 类一起，我们还有一个特殊化的类 `SportsCar`。这有几个区别：它有一个固定大小的燃料箱，只有两门版本。它的最高速度可能比常规形式高得多，但如果最高速度超过
    200 公里/小时，则汽车的燃油效率会下降，因此汽车的整体续航开始减少：
- en: '[PRE41]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The upcoming discussion of method overriding considers only instance methods.
    Class (aka static) methods behave quite differently, and they cannot be overridden.
    Just like fields, class methods can be hidden by a subclass but not overridden.
    As noted earlier in this chapter, it is good programming style to always prefix
    a class method invocation with the name of the class in which it is defined. If
    you consider the class name part of the class method name, the two methods have
    different names, so nothing is actually hidden at all.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 即将讨论的方法覆盖仅考虑实例方法。类（也称为静态）方法的行为完全不同，并且它们不能被覆盖。就像字段一样，子类可以隐藏类方法，但不能覆盖它们。正如本章前面所述，始终在类方法调用之前加上定义它的类名是良好的编程风格。如果你认为类名是类方法名称的一部分，那么这两个方法实际上具有不同的名称，因此并没有隐藏任何内容。
- en: Note
  id: totrans-288
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The code example for the `SportsCar` includes the syntax construct `@Override`.
    This is known as an *annotation*, and we shall meet this piece of Java syntax
    properly in [Chapter 4](ch04.xhtml#javanut8-CHP-4).
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '`SportsCar` 的代码示例包括语法结构 `@Override`。这被称为*注解*，我们将在[第四章](ch04.xhtml#javanut8-CHP-4)中详细介绍这个
    Java 语法。'
- en: Before we go any further with the discussion of method overriding, you should
    understand the difference between method overriding and method overloading. As
    we discussed in [Chapter 2](ch02.xhtml#javanut8-CHP-2), method overloading refers
    to the practice of defining multiple methods (in the same class) that have the
    same name but different parameter lists.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在进一步讨论方法覆盖之前，你应该理解方法覆盖和方法重载之间的区别。正如我们在[第二章](ch02.xhtml#javanut8-CHP-2)中讨论的，方法重载指的是在同一个类中定义多个方法，它们具有相同的名称但参数列表不同。
- en: On the other hand, a method overrides a method in its superclass when the instance
    method uses the same name, return type, and parameter list as a method in its
    superclass. These two features are very different from each other, so don’t get
    them confused.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，当实例方法与其超类中的方法具有相同的名称、返回类型和参数列表时，该方法覆盖其超类中的方法。这两个特性在本质上是非常不同的，所以不要混淆它们。
- en: Overriding is not hiding
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 覆盖并非隐藏
- en: 'Although Java treats the fields and methods of a class analogously in many
    ways, method overriding is not at all like field hiding. You can refer to hidden
    fields simply by casting an object to an instance of the appropriate superclass,
    but you cannot invoke overridden instance methods with this technique. The following
    code illustrates this crucial difference:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Java 在许多方面类似地对待类的字段和方法，但方法覆盖与字段隐藏毫不相同。你可以通过将对象强制转换为适当超类的实例来引用隐藏字段，但不能使用此技术调用被覆盖的实例方法。以下代码说明了这一关键区别：
- en: '[PRE42]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: While this difference between method overriding and field hiding may seem surprising
    at first, a little thought makes the purpose clear.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管方法覆盖与字段隐藏之间的区别乍看起来令人惊讶，稍加思考就能明确其目的。
- en: Suppose we are manipulating a bunch of `Car` and `SportsCar` objects and store
    them in an array of type `Car[]`. We can do this because `SportsCar` is a subclass
    of `Car`, so all `SportsCar` objects are legal `Car` objects.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在操作一堆`Car`和`SportsCar`对象，并将它们存储在类型为`Car[]`的数组中。我们可以这样做是因为`SportsCar`是`Car`的子类，因此所有`SportsCar`对象都是合法的`Car`对象。
- en: When we loop through the elements of this array, we don’t have to know or care
    whether the element is actually a `Car` or a `SportsCar`. What we do care about
    very much, however, is that the correct value is computed when we invoke the `range()`
    method of any element of the array. In other words, we don’t want to use the formula
    for the range of a car when the object is actually a sports car!
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们遍历这个数组的元素时，我们不需要知道或关心元素实际上是`Car`还是`SportsCar`。然而，我们非常关心的是，在调用数组中任何元素的`range()`方法时，计算出正确的值。换句话说，当对象实际上是跑车时，我们不希望使用汽车范围的公式！
- en: All we really want is for the objects we’re computing the ranges of to “do the
    right thing”—the `Car` objects to use their definition of how to compute their
    own range, and the `SportsCar` objects to use the definition that is correct for
    them.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们真正想要的是，我们正在计算其范围的对象“做正确的事情”——`Car`对象使用它们自己定义的计算范围的方式，而`SportsCar`对象使用适合它们的定义。
- en: Seen in this context, it is not surprising that Java handles method overriding
    differently than field hiding.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下看，Java处理方法重写与字段隐藏的方式有所不同并不奇怪。
- en: Virtual method lookup
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 虚拟方法查找
- en: If we have a `Car[]` array that holds `Car` and `SportsCar` objects, how does
    `javac` know whether to call the `range()` method of the `Car` class or the `SportsCar`
    class for any given item in the array? In fact, the source code compiler cannot
    know this at compilation time.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个`Car[]`数组，其中包含`Car`和`SportsCar`对象，`javac`如何知道对数组中的任何给定项调用`range()`方法时是调用`Car`类还是`SportsCar`类的`range()`方法？实际上，源代码编译器无法在编译时知道这一点。
- en: Instead, `javac` creates bytecode that uses *virtual* method lookup at runtime.
    When the interpreter runs the code, it looks up the appropriate `range()` method
    to call for each of the objects in the array. That is, when the interpreter interprets
    the expression `o.range()`, it checks the actual runtime type of the object referred
    to by the variable `o` and then finds the `range()` method that is appropriate
    for that type.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，`javac`创建的字节码在运行时使用*虚拟*方法查找。当解释器运行代码时，它查找适合数组中每个对象调用的适当`range()`方法。也就是说，当解释器解释表达式`o.range()`时，它检查变量`o`引用的对象的实际运行时类型，然后找到适合该类型的`range()`方法。
- en: Note
  id: totrans-303
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Some other languages (such as C# or C++) do not do virtual lookup by default
    and instead have a `virtual` keyword that programmers must explicitly use if they
    want subclasses to be able to override a method.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 某些其他语言（如C#或C++）默认不会进行虚拟查找，而是通过`virtual`关键字明确指定，以允许子类覆盖方法。
- en: This is another way of approaching the concept of method overriding, which we
    discussed earlier. If the version of the `range()` method associated with the
    static type of `o` was used, without the runtime (aka virtual) lookup, then overriding
    would not work properly.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这是方法重写概念的另一种方式，我们之前讨论过。如果使用`o`的静态类型关联的`range()`方法版本，而没有运行时（也称为虚拟）查找，则重写将无法正常工作。
- en: Virtual method lookup is the default for Java instance methods. See [Chapter 4](ch04.xhtml#javanut8-CHP-4)
    for more details about compile-time and runtime types and how they affect virtual
    method lookup.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Java实例方法，默认为虚拟方法查找。有关编译时和运行时类型及其对虚拟方法查找的影响的更多详细信息，请参见[第4章](ch04.xhtml#javanut8-CHP-4)。
- en: Invoking an overridden method
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调用重写方法
- en: 'We’ve seen the important differences between method overriding and field hiding.
    Nevertheless, the Java syntax for invoking an overridden method is quite similar
    to the syntax for accessing a hidden field: both use the `super` keyword. The
    following code illustrates:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了方法重写和字段隐藏之间的重要差异。尽管如此，调用重写方法的Java语法与访问隐藏字段的语法非常相似：两者都使用`super`关键字。以下代码说明了这一点：
- en: '[PRE43]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Recall that when you use `super` to refer to a hidden field, it is the same
    as casting `this` to the superclass type and accessing the field through it. Using
    `super` to invoke an overridden method, however, is not the same as casting the
    `this` reference. In other words, in the previous code, the expression `super.f()`
    is not the same as `((A)this).f()`.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当您使用`super`引用隐藏字段时，它等同于将`this`强制转换为超类类型并通过它访问字段。然而，使用`super`来调用覆盖的方法并不同于转换`this`引用。换句话说，在前面的代码中，表达式`super.f()`与`((A)this).f()`不同。
- en: When the interpreter invokes an instance method with the `super` syntax, a modified
    form of virtual method lookup is performed. The first step, as in regular virtual
    method lookup, is to determine the actual class of the object through which the
    method is invoked. Normally, the runtime search for an appropriate method definition
    would begin with this class. When a method is invoked with the `super` syntax,
    however, the search begins at the superclass of the class. If the superclass implements
    the method directly, that version of the method is invoked. If the superclass
    inherits the method, the inherited version of the method is invoked.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 当解释器使用`super`语法调用实例方法时，执行一种修改后的虚拟方法查找。首先步骤，与常规虚拟方法查找一样，确定通过其调用方法的对象的实际类。通常，运行时搜索适当方法定义的过程将从这个类开始。然而，当使用`super`语法调用方法时，搜索从类的超类开始。如果超类直接实现该方法，则调用该方法的版本。如果超类继承该方法，则调用继承的版本。
- en: 'Note that the `super` keyword invokes the most immediately overridden version
    of a method. Suppose class `A` has a subclass `B` that has a subclass `C` and
    that all three classes define the same method `f()`. The method `C.f()` can invoke
    the method `B.f()`, which it overrides directly, with `super.f()`. But there is
    no way for `C.f()` to invoke `A.f()` directly: `super.super.f()` is not legal
    Java syntax. Of course, if `C.f()` invokes `B.f()`, it is reasonable to suppose
    that `B.f()` might also invoke `A.f()`.'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`super`关键字调用的是方法的最直接覆盖版本。假设类`A`有一个子类`B`，`B`有一个子类`C`，并且这三个类都定义了相同的方法`f()`。方法`C.f()`可以使用`super.f()`调用它直接覆盖的方法`B.f()`。但是没有办法让`C.f()`直接调用`A.f()`：`super.super.f()`不是合法的Java语法。当然，如果`C.f()`调用`B.f()`，那么假设`B.f()`可能也会调用`A.f()`是合理的。
- en: 'This kind of chaining is relatively common with overridden methods: it is a
    way of augmenting the behavior of a method without replacing the method entirely.'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 这种链式调用在覆盖方法中比较常见：这是一种在不完全替换方法的情况下增强方法行为的方式。
- en: Note
  id: totrans-314
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Don’t confuse the use of `super` to invoke an overridden method with the `super()`
    method call used in a constructor to invoke a superclass constructor. Although
    they both use the same keyword, these are two entirely different syntaxes. In
    particular, you can use `super` to invoke an overridden method anywhere in the
    overriding class, while you can use `super()` only to invoke a superclass constructor
    as the very first statement of a constructor.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 不要混淆使用`super`来调用覆盖方法和在构造函数中用`super()`调用超类构造函数的方法。尽管它们都使用相同的关键字，但这是两种完全不同的语法。特别是，您可以在覆盖类中的任何地方使用`super`来调用覆盖方法，但只能在构造函数的第一个语句中使用`super()`来调用超类构造函数。
- en: It is also important to remember that `super` can be used only to invoke an
    overridden method from within the class that overrides it. Given a reference to
    a `SportsCar` object `e`, there is no way for a program that uses `e` to invoke
    the `range()` method defined by the `Car` class on `e`.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 还要记住，`super`只能在覆盖它的类内部使用来调用覆盖的方法。给定对`SportsCar`对象`e`的引用，程序无法使用`e`来调用`Car`类定义的`range()`方法。
- en: Sealed Classes
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 封闭类
- en: 'Until this point, we have only encountered two possibilities for class inheritance:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只遇到了类继承的两种可能性：
- en: Unrestricted ability to subclass (which is the default and has no keyword associated
    with it)
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无限制的子类化能力（这是默认情况，没有与之关联的关键字）
- en: Complete prevention of subclassing with the `final` keyword applied to a class
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`final`关键字应用于类完全防止子类化
- en: 'As of Java 17, there is a third possibility, which is controlled by the `sealed`
    keyword. A *sealed class* is one that can be subclassed but only by a specific
    list of known classes. This is done by using the `permits` keyword to enumerate
    the list of possible subclasses (which must all be in the same package as the
    base class) upfront, when the sealed class is declared. Like this:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 截至Java 17，有第三种可能性，由`sealed`关键字控制。*封闭类*是一种可以被特定已知类别的类继承的类。声明封闭类时，使用`permits`关键字列举可能的子类列表（这些子类必须与基类在同一个包中）。示例如下：
- en: '[PRE44]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In this example, we have declared both `Circle` and `Triangle` as `final`, so
    they cannot be further subclassed. This is the usual approach, but it is also
    possible to declare a subtype of a sealed class as either `sealed` (with a further
    set of permitted subclasses), or as `non-sealed`, which restores the default Java
    behavior of unrestricted subclassing.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们将`Circle`和`Triangle`都声明为`final`，因此它们无法进一步被子类化。这是一种常见的做法，但也可以将封闭类的子类型声明为`sealed`（具有进一步允许的子类集合），或者声明为`non-sealed`，恢复Java默认的无限制子类化行为。
- en: 'This last option (`non-sealed`) should not be used without a very good reason,
    as it undermines much of the semantic point of using class sealing in the first
    place. For this reason, it is a compile-time error to try to subclass a sealed
    class without providing one of the three sealing modifiers: there is no default
    behavior here.'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 这最后一个选项（`non-sealed`）不应该没有非常充分的理由而使用，因为这将首先破坏使用类封闭的语义目的。因此，尝试对封闭类进行子类化而不提供三个封闭修饰符之一会在编译时产生错误：这里没有默认行为。
- en: Note
  id: totrans-325
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The introduction of `non-sealed` is the first example of a *hyphenated keyword*
    that’s been seen in Java.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '`non-sealed`的引入是Java中首次出现的*连字符关键字*的例子。'
- en: In this example we’ve used an abstract sealed base class (`Shape`). This is
    not always necessary but it is often a good practice, as it means that any instances
    of the type that we encounter are known to be one of the “leaf types,” such as
    `Circle` or `Triangle`. We will meet abstract classes properly later in the chapter.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们使用了一个抽象的封闭基类（`Shape`）。这并非总是必要的，但通常是一个良好的实践，因为这意味着我们遇到的类型实例必定是“叶子类型”之一，例如`Circle`或`Triangle`。我们稍后将在本章更详细地介绍抽象类。
- en: Although sealed classes are new with Java 17, we expect that many developers
    will adopt them quickly—along with records, they represent a “missing concept”
    that fits very naturally into Java’s view of OO. We will have more to say about
    this in [Chapter 5](ch05.xhtml#javanut8-CHP-5) when we discuss aspects of object-oriented
    design related to sealed types.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然封闭类是Java 17的新特性，但我们预计许多开发者会快速采用它们——连同记录（records）一起，它们代表了Java面向对象视角中一个“遗漏的概念”。在我们讨论与封闭类型相关的面向对象设计方面时，我们将在[第5章](ch05.xhtml#javanut8-CHP-5)中详细阐述此点。
- en: Data Hiding and Encapsulation
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据隐藏和封装
- en: We started this chapter by describing a class as a collection of data and methods.
    One of the most important object-oriented techniques we haven’t discussed so far
    is hiding the data within the class and making it available only through the methods.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从描述类为数据和方法的集合开始了本章。到目前为止我们尚未讨论的最重要的面向对象技术之一是隐藏类内部数据，并且只通过方法来访问数据。
- en: This technique is known as *encapsulation* because it contains the data (and
    internal methods) safely inside the “capsule” of the class, where it can be accessed
    only by trusted users (i.e., the methods of the class).
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术被称为*封装*，因为它将数据（和内部方法）安全地包含在类的“胶囊”内部，只有信任的用户（即类的方法）可以访问它。
- en: Why would you want to do this? The most important reason is to hide the internal
    implementation details of your class. If you prevent programmers from relying
    on those details, you can safely modify the implementation without worrying that
    you will break existing code that uses the class.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么要这样做？最重要的原因是隐藏类的内部实现细节。如果阻止程序员依赖这些细节，您可以安全地修改实现，而不必担心会破坏使用该类的现有代码。
- en: Note
  id: totrans-333
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You should always encapsulate your code. It is almost always impossible to reason
    through and ensure the correctness of code that hasn’t been well-encapsulated,
    especially in multithreaded environments (and essentially all Java programs are
    multithreaded).
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该始终封装您的代码。几乎不可能推理和确保没有良好封装的代码的正确性，特别是在多线程环境中（而且基本上所有Java程序都是多线程的）。
- en: Another reason for encapsulation is to protect your class against accidental
    or willful stupidity. A class often contains a number of interdependent fields
    that must be in a consistent state. If you allow programmers (including yourself)
    to manipulate those fields directly, they may change one field without changing
    important related fields, leaving the class in an inconsistent state. If instead
    the programmer has to call a method to change the field, that method can be sure
    to do everything necessary to keep the state consistent. Similarly, if a class
    defines certain methods for internal use only, hiding these methods prevents users
    of the class from calling them.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 封装的另一个原因是保护你的类免受意外或故意的愚蠢。一个类通常包含许多相互依赖的字段，这些字段必须保持一致的状态。如果允许程序员（包括你自己）直接操作这些字段，他们可能只改变一个字段而不改变重要的相关字段，导致类处于不一致的状态。相反，如果程序员必须调用一个方法来改变字段，那么这个方法可以确保做一切必要的工作以保持状态的一致性。同样，如果一个类定义了某些只供内部使用的方法，隐藏这些方法可以防止类的用户调用它们。
- en: 'Here’s another way to think about encapsulation: when all the data for a class
    is hidden, the methods define the only possible operations that can be performed
    on objects of that class.'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有另一种封装的思考方式：当一个类的所有数据都被隐藏时，方法定义了对该类对象可以执行的唯一可能操作。
- en: Once you have carefully tested and debugged your methods, you can be confident
    that the class will work as expected. On the other hand, if all the fields of
    the class can be directly manipulated, the number of possibilities you have to
    test becomes unmanageable.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你仔细测试和调试了你的方法，你可以确信类将按预期工作。另一方面，如果类的所有字段都可以直接操作，那么你需要测试的可能性就变得难以管理。
- en: Note
  id: totrans-338
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: This idea can be carried to a very powerful conclusion, as we will see in [“Safe
    Java Programming”](ch05.xhtml#javanut8-CHP-5-SECT-safe-programming) when we discuss
    the *safety* of Java programs (which differs from the concept of *type safety*
    of the Java programming language).
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法可以得出一个非常强有力的结论，正如我们将在[“安全的Java编程”](ch05.xhtml#javanut8-CHP-5-SECT-safe-programming)中看到的那样，当我们讨论Java程序的*安全性*（这与Java编程语言的*类型安全性*概念不同）。
- en: 'Other, secondary, reasons to hide fields and methods of a class include:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 隐藏类的字段和方法的其他次要原因包括：
- en: Internal fields and methods that are visible outside the class just clutter
    up the API. Keeping visible fields to a minimum keeps your class tidy and therefore
    easier to use and understand.
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对外可见的内部字段和方法只会混淆API。保持可见字段的最小化可以使你的类更整洁，因此更容易使用和理解。
- en: If a method is visible to the users of your class, you have to document it.
    Save yourself time and effort by hiding it instead.
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个方法对你的类的用户可见，你必须对其进行文档化。相反，隐藏它可以节省时间和精力。
- en: Access Control
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问控制
- en: Java defines access control rules that can restrict members of a class from
    being used outside the class. In a number of examples in this chapter, you’ve
    seen the `public` modifier used in field and method declarations. This `public`
    keyword, along with `protected` and `private` (and one other, special one) are
    *access* *control* *modifiers*; they specify the access rules for the field or
    method.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: Java定义了访问控制规则，可以限制类的成员在类外部的使用。在本章的许多示例中，你已经看到`public`修饰符在字段和方法声明中的使用。这个`public`关键字，以及`protected`、`private`（还有一个特殊的关键字），是*访问*
    *控制* *修饰符*；它们指定了字段或方法的访问规则。
- en: Access to modules
  id: totrans-345
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模块访问
- en: One of the biggest changes in Java 9 was the arrival of Java platform modules.
    These are a grouping of code that is larger than a single package and intended
    as the future way to deploy code for reuse. As Java is often used in large applications
    and environments, the arrival of modules should make it easier to build and manage
    enterprise codebases.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9中最大的变化之一是Java平台模块的到来。这些模块是比单个包更大的代码组合，旨在作为未来部署重用代码的方式。由于Java经常用于大型应用和环境中，模块的到来应该使得构建和管理企业代码库变得更加容易。
- en: The modules technology is an advanced topic, and if Java is one of the first
    programming languages you have encountered, you should not try to learn it until
    you have gained some language proficiency. An introductory treatment of modules
    is provided in [Chapter 12](ch12.xhtml#javanut8-CHP-12), and we defer discussing
    the access control impact of modules until then.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 模块技术是一个高级的主题，如果Java是你接触的第一种编程语言之一，你不应该在没有获得一些语言熟练程度之前尝试学习它。在[第12章](ch12.xhtml#javanut8-CHP-12)中提供了模块的介绍，我们推迟讨论模块的访问控制影响直到那时。
- en: Access to packages
  id: totrans-348
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 包访问
- en: Access control on a per-package basis is not directly part of the core Java
    language and instead is provided by the modules mechanism. In the normal course
    of programming, access control is usually done at the level of classes and members
    of classes.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 包内基础上的访问控制并非直接属于核心Java语言的一部分，而是由模块机制提供。在正常的编程过程中，访问控制通常是在类及其成员级别上进行的。
- en: Note
  id: totrans-350
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: A package that has been loaded is always accessible to code defined within the
    same package. Whether it is accessible to code from other packages depends on
    the way the package is deployed on the host system. When the class files that
    comprise a package are stored in a directory, for example, a user must have read
    access to the directory and the files within it to have access to the package.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 已加载的包始终对同一包内定义的代码可访问。它是否对来自其他包的代码可访问取决于包在主机系统上的部署方式。例如，当包含构成包的类文件存储在一个目录中时，用户必须对该目录及其内部文件具有读取权限才能访问该包。
- en: Access to classes
  id: totrans-352
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类的访问
- en: By default, top-level classes are accessible within the package in which they
    are defined. However, if a top-level class is declared `public`, it is accessible
    everywhere.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，顶级类在其定义的包内可访问。然而，如果顶级类声明为`public`，则可在任何地方访问。
- en: Tip
  id: totrans-354
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: In [Chapter 4](ch04.xhtml#javanut8-CHP-4), we’ll meet nested classes. These
    are classes that can be defined as members of other classes. Because these inner
    classes are members of a class, they obey the member access-control rules.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](ch04.xhtml#javanut8-CHP-4)，我们将会遇到嵌套类。这些是可以定义为其他类成员的类。由于这些内部类是类的成员，它们遵守成员访问控制规则。
- en: Access to members
  id: totrans-356
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 成员访问
- en: The members of a class are always accessible within the body of the class. By
    default, members are also accessible throughout the package in which the class
    is defined. This default level of access is often called *package access*.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 类的成员在类的主体内部始终是可访问的。默认情况下，成员在定义类的包中也是可访问的。这种默认访问级别通常称为*包访问*。
- en: 'It is one of four possible levels of access. The other three levels are defined
    by the `public`, `protected`, and `private` modifiers. Here is some example code
    that uses these modifiers:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 这是四种可能的访问级别之一。其他三个级别由`public`、`protected`和`private`修饰符定义。以下是使用这些修饰符的一些示例代码：
- en: '[PRE45]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'These access rules apply to members of a class:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 这些访问规则适用于类的成员：
- en: All the fields and methods of a class can always be used within the body of
    the class itself.
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类的所有字段和方法都可以在类本身的主体内部使用。
- en: If a member of a class is declared with the `public` modifier, it means that
    the member is accessible anywhere the containing class is accessible. This is
    the least restrictive type of access control.
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果类的成员使用`public`修饰符声明，则意味着该成员可以在包含类可访问的任何地方访问。这是最不严格的访问控制类型。
- en: If a member of a class is declared `private`, the member is never accessible,
    except within the class itself. This is the most restrictive type of access control.
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果类的成员声明为`private`，则该成员除了在类本身内部外不可访问。这是最严格的访问控制类型。
- en: If a member of a class is declared `protected`, it is accessible to all classes
    within the package (the same as the default package accessibility) and also accessible
    within the body of any subclass of the class, regardless of the package in which
    that subclass is defined.
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果类的成员声明为`protected`，则在包内的所有类（与默认包访问权限相同），以及在该类的任何子类主体内，无论该子类定义在哪个包中，都可以访问该成员。
- en: If a member of a class is not declared with any of these modifiers, it has *default*
    access (sometimes called *package* access), and it is accessible to code within
    all classes that are defined in the same package but inaccessible outside of the
    package.
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果类的成员没有使用这些修饰符声明，则具有*默认*访问权限（有时称为*包*访问权限），可以在同一包内定义的所有类的代码中访问，但在包外部无法访问。
- en: Warning
  id: totrans-366
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Default access is *more* restrictive than `protected`—as default access does
    not allow access by subclasses outside the package.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 默认访问权限比`protected`更为严格，因为默认访问权限不允许子类在包外访问。
- en: '`protected` access requires more elaboration. Suppose class `A` declares a
    `protected` field `x` and is extended by a class `B`, which is defined in a different
    package (this last point is important). Class `B` inherits the `protected` field
    `x`, and its code can access that field in the current instance of `B` or in any
    other instances of `B` that the code can refer to. This does not mean, however,
    that the code of class `B` can start reading the protected fields of arbitrary
    instances of `A`.'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '`protected`访问需要更多阐述。假设类`A`声明了一个`protected`字段`x`，并且由一个类`B`扩展，该类在一个不同的包中定义（这一点很重要）。类`B`继承了`protected`字段`x`，并且它的代码可以访问当前`B`实例中的该字段，或者代码可以引用的任何其他`B`实例中的该字段。但这并不意味着类`B`的代码可以开始读取任意`A`实例的受保护字段。'
- en: 'Let’s look at this language detail in code. Here’s the definition for `A`:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在代码中详细查看这个语言细节。以下是`A`的定义：
- en: '[PRE46]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Here’s the definition for `B`:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`B`的定义：
- en: '[PRE47]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Note
  id: totrans-373
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Java packages do not “nest,” so `javanut8.ch03.different` is just a different
    package than `javanut8.ch03`; it is not contained inside it or related to it in
    any way.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: Java包不会“嵌套”，所以`javanut8.ch03.different`只是与`javanut8.ch03`不同的包，它不包含在其中，也没有任何关联。
- en: 'However, if we try to add this new method to `B`, we will get a compilation
    error, because instances of `B` do not have access to arbitary instances of `A`:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们尝试将此新方法添加到`B`，我们将收到编译错误，因为`B`的实例没有访问任意`A`实例的权限：
- en: '[PRE48]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'If we change the method to this:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将方法更改为：
- en: '[PRE49]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: then the compiler is happy, because instances of the same exact type can always
    see each other’s `protected` fields. Of course, if `B` was in the same package
    as `A,` then any instance of `B` could read any protected field of any instance
    of `A` because `protected` fields are visible to every class in the same package.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 那么编译器会很高兴，因为相同类型的实例总是可以看到彼此的`protected`字段。当然，如果`B`与`A`在同一个包中，那么`B`的任何实例都可以读取`A`的任何实例的`protected`字段，因为`protected`字段对同一包中的每个类都是可见的。
- en: Access control and inheritance
  id: totrans-380
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 访问控制和继承
- en: 'The Java specification states that:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: Java规范说明了：
- en: A subclass inherits all the instance fields and instance methods of its superclass
    accessible to it.
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子类继承其可访问的超类的所有实例字段和实例方法。
- en: If the subclass is defined in the same package as the superclass, it inherits
    all non-`private` instance fields and methods.
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果子类在与超类相同的包中定义，它将继承所有非`private`实例字段和方法。
- en: If the subclass is defined in a different package, it inherits all `protected`
    and `public` instance fields and methods.
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果子类在不同的包中定义，它将继承所有`protected`和`public`实例字段和方法。
- en: '`private` fields and methods are never inherited; neither are class fields
    or class methods.'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`private`字段和方法永远不会被继承；类字段或类方法也不会被继承。'
- en: Constructors are not inherited (instead, they are chained, as described earlier
    in this chapter).
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数不会被继承（而是链接，如本章前面描述的）。
- en: 'However, some programmers are confused by the statement that a subclass does
    not inherit the inaccessible fields and methods of its superclass. Let us be explicit:
    Every instance of a subclass includes a complete instance of the superclass within
    it, including all private fields and methods. When you create an instance of a
    subclass, memory is allocated for all `private` fields defined by the superclass;
    however, the subclass does not have access to these fields directly.'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，一些程序员对子类不继承其超类的不可访问字段和方法的说法感到困惑。让我们明确一下：每个子类的实例都包含其中完整的超类实例，包括所有私有字段和方法。当您创建子类的实例时，为超类定义的所有`private`字段都分配了内存；但是，子类不能直接访问这些字段。
- en: This existence of potentially inaccessible members seems to be in conflict with
    the statement that the members of a class are always accessible within the body
    of the class. To clear up this confusion, we define “inherited members” to mean
    those superclass members that are accessible.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 这种存在可能无法访问的成员似乎与类的成员始终在类体内部可访问的说法相冲突。为了消除这种混淆，我们定义“继承成员”为指那些可访问的超类成员。
- en: 'Then the correct statement about member accessibility is: “All inherited members
    and all members defined in this class are accessible.” An alternative way of saying
    this is:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 那么关于成员可访问性的正确说明是：“所有继承成员和所有在此类中定义的成员都是可访问的。”这种说法的另一种表述方式是：
- en: A class inherits *all* instance fields and instance methods (but not constructors)
    of its superclass.
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类继承其超类的*所有*实例字段和实例方法（但不包括构造函数）。
- en: The body of a class can always access all the fields and methods it declares
    itself. It can also access the *accessible* fields and members it inherits from
    its superclass.
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类的主体始终可以访问其自身声明的所有字段和方法。它还可以访问其从超类继承的 *可访问* 字段和成员。
- en: Member access summary
  id: totrans-392
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 成员访问摘要
- en: We summarize the member access rules in [Table 3-1](#javanut8-CHP-3-TABLE-1).
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 [Table 3-1](#javanut8-CHP-3-TABLE-1) 中总结了成员访问规则。
- en: Table 3-1\. Class member accessibility
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: Table 3-1\. 类成员访问性
- en: '|   | Member visibility |   |   |   |'
  id: totrans-395
  prefs: []
  type: TYPE_TB
  zh: '|   | 成员可见性 |   |   |   |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-396
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| Accessible to | Public | Protected | Default | Private |'
  id: totrans-397
  prefs: []
  type: TYPE_TB
  zh: '| 可访问 | 公共 | 保护的 | 默认 | 私有 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-398
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| Defining class | Yes | Yes | Yes | Yes |'
  id: totrans-399
  prefs: []
  type: TYPE_TB
  zh: '| 定义类 | 是 | 是 | 是 | 是 |'
- en: '| Class in same package | Yes | Yes | Yes | No |'
  id: totrans-400
  prefs: []
  type: TYPE_TB
  zh: '| 同一包中的类 | 是 | 是 | 是 | 否 |'
- en: '| Subclass in different package | Yes | Yes | No | No |'
  id: totrans-401
  prefs: []
  type: TYPE_TB
  zh: '| 不同包中的子类 | 是 | 是 | 否 | 否 |'
- en: '| Nonsubclass different package | Yes | No | No | No |'
  id: totrans-402
  prefs: []
  type: TYPE_TB
  zh: '| 非子类不同包 | 是 | 否 | 否 | 否 |'
- en: 'There are a few generally observed rules about what parts of a Java program
    should use each visibility modifier. It is important that even beginning Java
    programmers follow these rules:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: Java 程序的哪些部分应使用每种可见性修饰符有一些普遍遵循的规则。即使是初学者的 Java 程序员也应遵循这些规则：
- en: Use `public` only for methods and constants that form part of the public API
    of the class. The only acceptable usage of `public` fields is for constants or
    immutable objects, and they must be also declared `final`.
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅对类的公共 API 的方法和常量使用 `public`。`public` 字段的唯一可接受用法是常量或不可变对象，并且它们必须同时声明为 `final`。
- en: Use `protected` for fields and methods that aren’t required by most programmers
    using the class but that may be of interest to anyone creating a subclass as part
    of a different package.
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于大多数程序员不使用但可能对创建子类的任何人有兴趣的字段和方法，请使用 `protected`。
- en: Note
  id: totrans-406
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注：
- en: '`protected` members are technically part of the exported API of a class. They
    must be documented and cannot be changed without potentially breaking code that
    relies on them.'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '`protected` 成员在技术上是类的导出 API 的一部分。它们必须有文档说明，且不能更改，否则可能会破坏依赖它们的代码。'
- en: Use the default package visibility for fields and methods that are internal
    implementation details but are used by cooperating classes in the same package.
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于内部实现细节但被同一包中的协作类使用的字段和方法，请使用默认的包可见性。
- en: Use `private` for fields and methods that are used only inside the class and
    should be hidden everywhere else.
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于仅在类内部使用且应在其他任何地方隐藏的字段和方法，请使用 `private`。
- en: If you are not sure whether to use `protected`, package, or `private` accessibility,
    start with `private`. If this is overly restrictive, you can always relax the
    access restrictions slightly (or provide accessor methods, in the case of fields).
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不确定是否使用 `protected`、包或 `private` 访问性，请从 `private` 开始。如果这太严格，您可以稍微放松访问限制（或在字段的情况下提供访问器方法）。
- en: This is especially important for designing APIs because increasing access restrictions
    is not a backward-compatible change and can break code that relies on access to
    those members.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于设计 API 尤为重要，因为增加访问限制不是向后兼容的更改，可能会破坏依赖于这些成员访问的代码。
- en: Data Accessor Methods
  id: totrans-412
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据访问方法
- en: In the `Circle` example, we declared the circle radius to be a `public` field.
    The `Circle` class is one in which it may be reasonable to keep that field publicly
    accessible; it is a simple enough class, with no dependencies between its fields.
    On the other hand, our current implementation of the class allows a `Circle` object
    to have a negative radius, and circles with negative radii simply should not exist.
    As long as the radius is stored in a `public` field, however, any programmer can
    set the field to any value they want, no matter how unreasonable. The only solution
    is to restrict the programmer’s direct access to the field and define `public`
    methods that provide indirect access to the field. Providing `public` methods
    to read and write a field is not the same as making the field itself `public`.
    The crucial difference is that methods can perform error checking.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Circle`的例子中，我们声明了圆的半径为`public`字段。`Circle`类是一个可能合理地保持该字段公开访问的类；它是一个足够简单的类，没有字段之间的依赖关系。另一方面，我们当前的类实现允许一个`Circle`对象具有负半径，而具有负半径的圆根本不应该存在。然而，只要半径存储在一个`public`字段中，任何程序员都可以将字段设置为任何他们想要的值，无论多么不合理。唯一的解决方案是限制程序员对字段的直接访问，并定义`public`方法提供对字段的间接访问。提供读取和写入字段的`public`方法并不等同于使字段本身成为`public`。关键区别在于方法可以执行错误检查。
- en: We might, for example, want to prevent `Circle` objects with negative radii—these
    are obviously not sensible, but our current implementation does not prohibit this.
    In [Example 3-4](#javanut8-CHP-3-EX-4), we show how we might change the definition
    of `Circle` to prevent this.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可能希望阻止具有负半径的`Circle`对象——这些显然是不明智的，但我们当前的实现不会禁止这样做。在[例子 3-4](#javanut8-CHP-3-EX-4)中，我们展示了如何修改`Circle`的定义以防止这种情况发生。
- en: This version of `Circle` declares the `r` field to be `protected` and defines
    accessor methods named `getRadius()` and `setRadius()` to read and write the field
    value while enforcing the restriction on negative radius values. Because the `r`
    field is `protected`, it is directly (and more efficiently) accessible to subclasses.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`Circle`的版本将`r`字段声明为`protected`，并定义了名为`getRadius()`和`setRadius()`的访问器方法来读取和写入字段值，同时强制限制半径值为负。因为`r`字段是`protected`的，所以它可以直接（并且更有效地）被子类访问。
- en: Example 3-4\. The Circle class using data hiding and encapsulation
  id: totrans-416
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 例子 3-4\. 使用数据隐藏和封装的 Circle 类
- en: '[PRE50]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We have defined the `Circle` class within a package named `javanut8.ch03.shapes`;
    `r` is `protected` so any other classes in the `javanut8.ch03.shapes` package
    have direct access to that field and can set it however they like. The assumption
    here is that all classes within the `javanut8.ch03.shapes` package were written
    by the same author or a closely cooperating group of authors, and that the classes
    all trust each other not to abuse their privileged level of access to each other’s
    implementation details.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在一个名为`javanut8.ch03.shapes`的包中定义了`Circle`类；`r`是`protected`的，因此`javanut8.ch03.shapes`包中的任何其他类都可以直接访问该字段并按照他们喜欢的方式设置它。这里的假设是`javanut8.ch03.shapes`包中的所有类都由同一作者或紧密合作的一组作者编写，并且这些类之间相互信任，不滥用对彼此实现细节的特权级别。
- en: Finally, the code that enforces the restriction against negative radius values
    is itself placed within a `protected` method, `checkRadius()`. Although users
    of the `Circle` class cannot call this method, subclasses of the class can call
    it and even override it if they want to change the restrictions on the radius.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，强制限制半径值为负数的代码本身放置在一个`protected`方法`checkRadius()`中。虽然`Circle`类的用户无法调用此方法，但类的子类可以调用它，甚至可以覆盖它，如果他们想要改变对半径的限制。
- en: Note
  id: totrans-420
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: One set of common (but older) conventions in Java—known as Java Beans conventions—is
    that data accessor methods begin with the prefixes “get” and “set.” But if the
    field being accessed is of type `boolean`, the `get()` method may be replaced
    with an equivalent method that begins with “is”—the accessor method for a `boolean`
    field named `readable` is typically called `isReadable()` instead of `getReadable()`.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 一组常见（但较旧的）Java约定之一——称为Java Bean约定——是数据访问器方法以前缀“get”和“set”开头。但是，如果被访问的字段是`boolean`类型，则`get()`方法可以被一个以“is”开头的等效方法替换——一个名为`readable`的`boolean`字段的访问器方法通常被称为`isReadable()`而不是`getReadable()`。
- en: Abstract Classes and Methods
  id: totrans-422
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象类和方法
- en: 'In [Example 3-4](#javanut8-CHP-3-EX-4), we declared our `Circle` class to be
    part of a package named `shapes`. Suppose we plan to implement a number of shape
    classes: `Rectangle`, `Square`, `Hexagon`, `Triangle`, and so on. We can give
    these shape classes our two basic `area()` and `circumference()` methods. Now,
    to make it easy to work with an array of shapes, it would be helpful if all our
    shape classes had a common superclass, `Shape`. If we structure our class hierarchy
    this way, every shape object, regardless of the actual type of shape it represents,
    can be assigned to variables, fields, or array elements of type `Shape`. We want
    the `Shape` class to encapsulate whatever features all our shapes have in common
    (e.g., the `area()` and `circumference()` methods). But our generic `Shape` class
    doesn’t represent any real kind of shape, so it cannot define useful implementations
    of the methods. Java handles this situation with *abstract methods*.'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [示例 3-4](#javanut8-CHP-3-EX-4) 中，我们声明了我们的 `Circle` 类是属于名为 `shapes` 的包的一部分。假设我们计划实现许多形状类：`Rectangle`、`Square`、`Hexagon`、`Triangle`
    等等。我们可以给这些形状类我们的两个基本的 `area()` 和 `circumference()` 方法。现在，为了便于使用形状数组，如果我们的所有形状类都有一个公共的超类
    `Shape` 就会很有帮助。如果我们以这种方式结构化我们的类层次结构，那么无论形状对象表示的实际形状类型如何，都可以将其分配给类型为 `Shape` 的变量、字段或数组元素。我们希望
    `Shape` 类封装所有我们的形状共有的特征（例如 `area()` 和 `circumference()` 方法）。但是我们的通用 `Shape` 类并不表示任何实际的形状，因此它不能定义有用的方法实现。Java
    使用 *抽象方法* 处理这种情况。
- en: 'Java lets us define a method without implementing it by declaring the method
    with the `abstract` modifier. An `abstract` method has no body; it simply has
    a signature definition followed by a semicolon.^([2](ch03.xhtml#idm45927744054480))
    Here are the rules about `abstract` methods and the `abstract` classes that contain
    them:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: Java 允许我们通过声明带有 `abstract` 修饰符的方法来定义一个方法而不实现它。一个 `abstract` 方法没有主体；它只是有一个签名定义，后面跟着一个分号。^([2](ch03.xhtml#idm45927744054480))
    关于 `abstract` 方法和包含它们的 `abstract` 类的规则如下：
- en: Any class with an `abstract` method is automatically `abstract` itself and must
    be declared as such. To fail to do so is a compilation error.
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何带有 `abstract` 方法的类自动成为 `abstract`，必须声明为这样。不这样做会导致编译错误。
- en: An `abstract` class cannot be instantiated.
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象类不能被实例化。
- en: A subclass of an `abstract` class can be instantiated only if it overrides each
    of the `abstract` methods of its superclass and provides an implementation (i.e.,
    a method body) for all of them. Such a class is often called a *concrete* subclass,
    to emphasize the fact that it is not `abstract`.
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象类的子类只有在覆盖了其超类的每个 `abstract` 方法并为所有方法提供实现（即方法体）时才能被实例化。这样的类通常被称为 *具体* 子类，以强调它不是
    `abstract`。
- en: If a subclass of an `abstract` class does not implement all the `abstract` methods
    it inherits, that subclass is itself `abstract` and must be declared as such.
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果抽象类的子类没有实现它继承的所有 `abstract` 方法，那么该子类本身就是 `abstract` 的，必须声明为这样。
- en: '`static`, `private`, and `final` methods cannot be `abstract`, because these
    types of methods cannot be overridden by a subclass. Similarly, a `final` class
    cannot contain any `abstract` methods.'
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`static`, `private`, and `final` 方法不能是 `abstract`，因为这些类型的方法不能被子类覆盖。同样，一个 `final`
    类不能包含任何 `abstract` 方法。'
- en: A class can be declared `abstract` even if it does not actually have any `abstract`
    methods. Declaring such a class `abstract` indicates that the implementation is
    somehow incomplete and is meant to serve as a superclass for one or more subclasses
    that complete the implementation. Such a class cannot be instantiated.
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使一个类实际上没有任何 `abstract` 方法，也可以声明该类为 `abstract`。声明这样一个类为 `abstract` 表示该实现在某种程度上是不完整的，是为一个或多个子类提供实现的超类。这样的类不能被实例化。
- en: Note
  id: totrans-431
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The `ClassLoader` class that we will meet in [Chapter 11](ch11.xhtml#javanut8-CHP-11)
    is a good example of an abstract class that does not have any abstract methods.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 [第 11 章](ch11.xhtml#javanut8-CHP-11) 中遇到的 `ClassLoader` 类是一个没有任何抽象方法的抽象类的好例子。
- en: Let’s look at an example of how these rules work. If we define the `Shape` class
    to have `abstract` `area()` and `circumference()` methods, any subclass of `Shape`
    is required to provide implementations of these methods so that it can be instantiated.
    In other words, every `Shape` object is guaranteed to have implementations of
    these methods defined. [Example 3-5](#javanut8-CHP-3-EX-5) shows how this might
    work. It defines an `abstract` `Shape` class and a concrete subclass of it. You
    should also imagine that the `Circle` class from [Example 3-4](#javanut8-CHP-3-EX-4)
    has been modified so that it `extends Shape`.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个示例，说明这些规则是如何工作的。如果我们定义`Shape`类具有`abstract` `area()`和`circumference()`方法，那么`Shape`的任何子类都必须提供这些方法的实现，以便可以实例化它。换句话说，每个`Shape`对象都保证具有这些方法的实现。[示例3-5](#javanut8-CHP-3-EX-5)展示了这是如何工作的。它定义了一个`abstract`的`Shape`类和它的一个具体子类。您还应该想象，从[示例3-4](#javanut8-CHP-3-EX-4)中的`Circle`类已被修改为`extends
    Shape`。
- en: Example 3-5\. An abstract class and concrete subclass
  id: totrans-434
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例3-5. 一个抽象类和具体子类
- en: '[PRE51]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Each `abstract` method in `Shape` has a semicolon right after its parentheses.
    Method declarations of this sort have no curly braces, and no method body is defined.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`Shape`类中的`abstract`方法在其括号后面都有一个分号。这种类型的方法声明没有花括号，并且没有定义方法体。
- en: Note that we could have declared the class `Shape` as a sealed class, but we
    have deliberately chosen not to. This is so other programmers can define their
    own shape classes as new subclasses of `Shape`, should they wish to.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们本可以将`Shape`类声明为密封类，但故意选择不这样做。这样其他程序员就可以定义自己的形状类作为`Shape`的新子类，如果他们希望的话。
- en: 'Using the classes defined in [Example 3-5](#javanut8-CHP-3-EX-5), we can now
    write code such as:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[示例3-5](#javanut8-CHP-3-EX-5)中定义的类，我们现在可以编写如下代码：
- en: '[PRE52]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Notice two important points here:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 这里要注意两个重要点：
- en: Subclasses of `Shape` can be assigned to elements of an array of `Shape`. No
    cast is necessary. This is another example of a widening reference type conversion
    (discussed in [Chapter 2](ch02.xhtml#javanut8-CHP-2)).
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Shape`的子类可以分配给`Shape`数组的元素。不需要转换。这是引用类型扩展的另一个示例（见[第2章](ch02.xhtml#javanut8-CHP-2)讨论）。'
- en: You can invoke the `area()` and `circumference()` methods for any `Shape` object,
    even though the `Shape` class does not define a body for these methods. When you
    do this, the method to be invoked is found using virtual lookup, which we met
    earlier. In our case, this means that the area of a circle is computed using the
    method defined by `Circle`, and the area of a rectangle is computed using the
    method defined by `Rectangle`.
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以为任何`Shape`对象调用`area()`和`circumference()`方法，即使`Shape`类没有定义这些方法的具体实现。在这种情况下，通过虚拟查找找到要调用的方法，我们之前已经遇到过。在我们的例子中，这意味着圆的面积是使用`Circle`定义的方法计算的，而矩形的面积是使用`Rectangle`定义的方法计算的。
- en: Reference Type Conversions
  id: totrans-443
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引用类型转换
- en: Object references can be converted between different reference types. As with
    primitive types, reference type conversions can be widening conversions (allowed
    automatically by the compiler) or narrowing conversions that require a cast (and
    possibly a runtime check). In order to understand reference type conversions,
    you need to understand that reference types form a hierarchy, usually called the
    *class hierarchy*.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在不同的引用类型之间转换对象引用。与原始类型一样，引用类型转换可以是宽化转换（编译器自动允许）或需要转型的窄化转换（可能需要运行时检查）。为了理解引用类型转换，您需要了解引用类型形成的层次结构，通常称为*类层次结构*。
- en: Every Java reference type *extends* some other type, known as its *superclass*.
    A type inherits the fields and methods of its superclass and then defines its
    own additional fields and methods. A special class named `Object` serves as the
    root of the class hierarchy in Java. All Java classes extend `Object` directly
    or indirectly. The `Object` class defines a number of special methods that are
    inherited (or overridden) by all objects.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Java引用类型*扩展*其他某个类型，称为其*超类*。类型继承其超类的字段和方法，然后定义其自己的额外字段和方法。一个名为`Object`的特殊类作为Java类层次结构的根。所有Java类直接或间接扩展`Object`。`Object`类定义了一些特殊方法，这些方法被所有对象继承（或重写）。
- en: The predefined `String` class and the `Account` class we discussed earlier in
    this chapter both extend `Object`. Thus, we can say that all `String` objects
    are also `Object` objects. We can also say that all `Account` objects are `Object`
    objects. The opposite is not true, however. We cannot say that every `Object`
    is a `String` because, as we’ve just seen, some `Object` objects are `Account`
    objects.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 我们前面讨论的预定义`String`类和`Account`类都扩展自`Object`。因此，我们可以说所有`String`对象也是`Object`对象。我们还可以说所有`Account`对象也是`Object`对象。然而，反之不成立。我们不能说每个`Object`都是`String`，因为正如我们刚刚看到的，一些`Object`对象是`Account`对象。
- en: 'With this simple understanding of the class hierarchy, we can define the rules
    of reference type conversion:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对类层次结构的简单理解，我们可以定义引用类型转换的规则：
- en: An object reference cannot be converted to an unrelated type. The Java compiler
    does not allow you to convert a `String` to a `Account`, for example, even if
    you use a cast operator.
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个对象引用不能转换为不相关的类型。例如，即使使用强制类型转换运算符，Java 编译器也不允许你将`String`转换为`Account`。
- en: An object reference can be converted to the type of its superclass or of any
    ancestor class. This is a widening conversion, so no cast is required. For example,
    a `String` value can be assigned to a variable of type `Object` or passed to a
    method where an `Object` parameter is expected.
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以将对象引用转换为其超类或任何祖先类的类型。这是一种扩展转换，因此不需要强制类型转换。例如，`String`值可以赋给类型为`Object`的变量，或者传递给期望`Object`参数的方法。
- en: Note
  id: totrans-450
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: No conversion is actually performed; the object is simply treated as if it were
    an instance of the superclass. This is a simple form of the Liskov substitution
    principle, after Barbara Liskov, the computer scientist who first explicitly formulated
    it.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上不会执行任何转换；该对象仅被视为超类的实例。这是Liskov替换原则的一个简单形式，以巴巴拉·利斯科夫命名，她首次明确表述了该原则。
- en: 'An object reference can be converted to the type of a subclass, but this is
    a narrowing conversion and requires a cast. The Java compiler provisionally allows
    this kind of conversion, but the Java interpreter checks at runtime to make sure
    it is valid. Only cast a reference to the type of a subclass if you are sure,
    based on the logic of your program, that the object is actually an instance of
    the subclass. If it is not, the interpreter throws a `ClassCastException`. For
    example, if we assign a `String` reference to a variable of type `Object`, we
    can later cast the value of that variable back to type `String`:'
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以将对象引用转换为子类的类型，但这是一种窄化转换，需要进行强制类型转换。Java 编译器暂时允许这种类型的转换，但Java解释器在运行时会检查其是否有效。只有在基于程序逻辑确信对象实际上是子类的实例时，才可以将引用转换为子类的类型。如果不是，则解释器会抛出`ClassCastException`异常。例如，如果我们将`String`引用赋给类型为`Object`的变量，稍后可以将该变量的值强制转换回`String`类型：
- en: '[PRE53]'
  id: totrans-453
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Arrays are objects and follow some conversion rules of their own. First, any
    array can be converted to an `Object` value through a widening conversion. A narrowing
    conversion with a cast can convert such an object value back to an array. Here’s
    an example:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是对象，并遵循其自己的一些转换规则。首先，通过扩展转换，任何数组都可以转换为`Object`值。通过强制类型转换，可以将这样的对象值转换回数组。这里是一个例子：
- en: '[PRE54]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'In addition to converting an array to an object, we can convert an array to
    another type of array if the “base types” of the two arrays are reference types
    that can themselves be converted. For example:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 除了将数组转换为对象外，还可以将数组转换为另一种数组类型，如果两个数组的“基本类型”是可以自身转换的引用类型。例如：
- en: '[PRE55]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Note that these array conversion rules apply only to arrays of objects and
    arrays of arrays. An array of primitive type cannot be converted to any other
    array type, even if the primitive base types can be converted:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这些数组转换规则仅适用于对象数组和数组数组。原始类型数组不能转换为任何其他数组类型，即使原始基本类型可以转换：
- en: '[PRE56]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Modifier Summary
  id: totrans-460
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修饰符概要
- en: As we’ve seen, classes, interfaces, and their members can be declared with one
    or more *modifiers*—keywords such as `public`, `static`, and `final`. Let’s conclude
    this chapter by listing the Java modifiers, explaining what types of Java constructs
    they can modify, and explaining what they do. [Table 3-2](#javanut8-CHP-3-TABLE-2)
    has the details; you can also refer to [“Overview of Classes and Records”](#javanut8-CHP-3-SECT-1),
    [“Field Declaration Syntax”](#javanut8-CHP-3-SECT-2.1), and [“Method Modifiers”](ch02.xhtml#javanut8-CHP-2-SECT-6.2).
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: Table 3-2\. Java modifiers
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: '| Modifier | Used on | Meaning |'
  id: totrans-463
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-464
  prefs: []
  type: TYPE_TB
- en: '| `abstract` | Class | The class cannot be instantiated and may contain unimplemented
    methods. |'
  id: totrans-465
  prefs: []
  type: TYPE_TB
- en: '|  | Interface | All interfaces are `abstract`. The modifier is optional in
    interface declarations. |'
  id: totrans-466
  prefs: []
  type: TYPE_TB
- en: '|  | Method | No body is provided for the method; it is provided by a subclass.
    The signature is followed by a semicolon. The enclosing class must also be `abstract`.
    |'
  id: totrans-467
  prefs: []
  type: TYPE_TB
- en: '| `default` | Method | Implementation of this interface method is optional.
    The interface provides a default implementation for classes that elect not to
    implement it. See [Chapter 4](ch04.xhtml#javanut8-CHP-4) for more details. |'
  id: totrans-468
  prefs: []
  type: TYPE_TB
- en: '| `final` | Class | The class cannot be subclassed. |'
  id: totrans-469
  prefs: []
  type: TYPE_TB
- en: '|  | Method | The method cannot be overridden. |'
  id: totrans-470
  prefs: []
  type: TYPE_TB
- en: '|  | Field | The field cannot have its value changed. `static final` fields
    are compile-time constants. |'
  id: totrans-471
  prefs: []
  type: TYPE_TB
- en: '|  | Variable | A local variable, method parameter, or exception parameter
    cannot have its value changed. |'
  id: totrans-472
  prefs: []
  type: TYPE_TB
- en: '| `native` | Method | The method is implemented in some platform-dependent
    way (often in C). No body is provided; the signature is followed by a semicolon.
    |'
  id: totrans-473
  prefs: []
  type: TYPE_TB
- en: '| `non-sealed` | Class | The class inherits from a sealed type but itself has
    unrestricted open inheritance. |'
  id: totrans-474
  prefs: []
  type: TYPE_TB
- en: '| <None> (package) | Class | A non-`public` class is accessible only in its
    package. |'
  id: totrans-475
  prefs: []
  type: TYPE_TB
- en: '|  | Interface | A non-`public` interface is accessible only in its package.
    |'
  id: totrans-476
  prefs: []
  type: TYPE_TB
- en: '|  | Member | A member that is not `private`, `protected`, or `public` has
    package visibility and is accessible only within its package. |'
  id: totrans-477
  prefs: []
  type: TYPE_TB
- en: '| `private` | Member | The member is accessible only within the class that
    defines it. |'
  id: totrans-478
  prefs: []
  type: TYPE_TB
- en: '| `protected` | Member | The member is accessible only within the package in
    which it is defined and within subclasses. |'
  id: totrans-479
  prefs: []
  type: TYPE_TB
- en: '| `public` | Class | The class is accessible anywhere its package is. |'
  id: totrans-480
  prefs: []
  type: TYPE_TB
- en: '|  | Interface | The interface is accessible anywhere its package is. |'
  id: totrans-481
  prefs: []
  type: TYPE_TB
- en: '|  | Member | The member is accessible anywhere its class is. |'
  id: totrans-482
  prefs: []
  type: TYPE_TB
- en: '| `sealed` | Class | The class can be subclassed only by a known list of subclasses,
    as given by the `permits` clause. If the permits clause is missing, the class
    can be subclassed only by classes within the same compilation unit. |'
  id: totrans-483
  prefs: []
  type: TYPE_TB
- en: '| `static` | Class | An inner class declared `static` is a top-level class
    not associated with a member of the containing class. See [Chapter 4](ch04.xhtml#javanut8-CHP-4)
    for more details. |'
  id: totrans-484
  prefs: []
  type: TYPE_TB
- en: '|  | Method | A `static` method is a class method. It is not passed an implicit
    `this` object reference. It can be invoked through the class name. |'
  id: totrans-485
  prefs: []
  type: TYPE_TB
- en: '|  | Field | A `static` field is a class field. There is only one instance
    of the field, regardless of the number of class instances created. It can be accessed
    through the class name. |'
  id: totrans-486
  prefs: []
  type: TYPE_TB
- en: '|  | Initializer | The initializer is run when the class is loaded rather than
    when an instance is created. |'
  id: totrans-487
  prefs: []
  type: TYPE_TB
- en: '| `strictfp` | Class | All methods of the class are implicitly `strictfp`.
    |'
  id: totrans-488
  prefs: []
  type: TYPE_TB
- en: '|  | Method | All floating-point computation done by the method must be performed
    in a way that strictly conforms to the IEEE 754 standard. In particular, all values,
    including intermediate results, must be expressed as IEEE `float` or `double`
    values and cannot take advantage of any extra precision or range offered by native
    platform floating-point formats or hardware. This modifier is extremely rarely
    used, and is a no-op in Java 17, as the language now always uses strict conformance
    to the standard. |'
  id: totrans-489
  prefs: []
  type: TYPE_TB
- en: '| `synchronized` | Method | The method makes nonatomic modifications to the
    class or instance, so care must be taken to ensure that two threads cannot modify
    the class or instance at the same time. For a `static` method, a lock for the
    class is acquired before executing the method. For a non-`static` method, a lock
    for the specific object instance is acquired. See [Chapter 5](ch05.xhtml#javanut8-CHP-5)
    for more details. |'
  id: totrans-490
  prefs: []
  type: TYPE_TB
- en: '| `transient` | Field | The field is not part of the persistent state of the
    object and should not be serialized with the object. Used with object serialization;
    see `java.io.ObjectOutputStream`. |'
  id: totrans-491
  prefs: []
  type: TYPE_TB
- en: '| `volatile` | Field | The field can be accessed by unsynchronized threads,
    so certain optimizations must not be performed on it. This modifier can sometimes
    be used as an alternative to `synchronized`. See [Chapter 5](ch05.xhtml#javanut8-CHP-5)
    for more details. |'
  id: totrans-492
  prefs: []
  type: TYPE_TB
- en: Summary
  id: totrans-493
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Java, like all object-oriented languages, has its own model of how OO should
    work. In this chapter we have met the basic concepts of this model: static typing,
    fields, methods, inheritance, access control, encapsulation, overloading, overriding,
    and sealing. To become a proficient Java programmer, you will need to gain proficiency
    in handling all of these concepts and understand the relationship between them
    and how they interact.'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: The next two chapters are devoted to exploring these features further and understanding
    how the basic aspects of object-oriented design in Java arise directly from this
    relatively small set of basic concepts.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch03.xhtml#idm45927749308000-marker)) There is also the default, aka package,
    visibility that we will meet later.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch03.xhtml#idm45927744054480-marker)) An `abstract` method in Java is
    something like a pure virtual function in C++ (i.e., a virtual function that is
    declared `= 0`). In C++, a class that contains a pure virtual function is called
    an abstract class and cannot be instantiated. The same is true of Java classes
    that contain `abstract` methods.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch03.xhtml#idm45927744054480-marker)) 在 Java 中，`abstract` 方法类似于 C++ 中的纯虚函数（即声明为
    `= 0` 的虚函数）。在 C++ 中，包含纯虚函数的类称为抽象类，不能被实例化。Java 中包含 `abstract` 方法的类也是如此。
