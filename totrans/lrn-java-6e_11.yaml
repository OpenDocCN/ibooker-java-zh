- en: Chapter 11\. Functional Approaches in Java
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Java is—and remains—an object-oriented language. All of the design patterns
    and class types we saw in [Chapter 5](ch05.html#learnjava6-CHP-5) are still core
    to how most developers write Java code. Java is also flexible, with individual
    and corporate contributors proposing and making improvements. As *functional programming*
    (FP) moves back into the limelight, Java is keeping up. FP represents an alternate
    way to approach programming: functions, rather than objects, are the focus.'
  prefs: []
  type: TYPE_NORMAL
- en: Starting as far back as Java 8, Java has supported a reasonable set of functional
    features with the `java.util.function` package. This package includes several
    classes and interfaces that allow developers to use popular functional approaches
    to problem-solving. We’ll explore some of these approaches in this chapter, but
    we want to emphasize that verb, *allow*. If you don’t enjoy functional programming,
    you can safely ignore this chapter. We hope you’ll try some of the examples, though.
    There are some nice features that can make your code more compact while retaining
    its readability.
  prefs: []
  type: TYPE_NORMAL
- en: Functions 101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The roots of functional programming extend all the way back to the 1930s, with
    American mathematician Alonzo Church and his lambda calculus. Church wasn’t running
    his calculus on any hardware, but lambda calculus formalized a way of problem-solving
    that would lead to early programming languages written for real, operating machines.^([1](ch11.html#id2199))
    The Lisp language was developed in the 1950s at MIT and ran on early iterations
    of modern computers like the IBM 700 series. If you can picture an old black-and-white
    photo with bookshelf-sized walls of blinking lights, you’ve got the right idea
    for how far back FP ideas and patterns go in the history of computing.
  prefs: []
  type: TYPE_NORMAL
- en: But FP is not the only way to program a computer. Other paradigms, such as procedural
    programming and object-oriented programming (OOP), regularly vie for popularity.
    Happily, you can accomplish the same goals in any of those paradigms. The paradigm
    you choose usually comes down to the problem domain and more than a bit of personal
    preference.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the simple tasks of adding two numbers and assigning that result to
    a variable. We can do this in object-oriented languages like Java, in functional
    languages like Clojure,^([2](ch11.html#id2202)) or procedural languages like C:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Java hit the digital scene as OOP was (again) on the rise, and it reflects those
    roots. Still, FP has always had its evangelists. Java 8 offered some substantial
    additions to the language and opened the door for fans of functional programming
    to work with Java. Let’s take a look at some of those additions and see how they
    integrate with the larger world of Java.
  prefs: []
  type: TYPE_NORMAL
- en: Lambdas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Inspired by the lambda calculus, *lambda expressions* (or more simply, lambdas)
    form the core unit of functional programming in Java. Lambdas are a means of encapsulating
    a bit of logic. In a functional language, functions are “first-class citizens”
    and can be created, stored, referenced, used, and passed around just like objects
    in Java. To mimic that, uh, functionality, Java 8 introduced some new syntax alongside
    several special interfaces. These additions allow you to quickly define a function
    that can replace an entire inner class. The result of that definition is still
    an object under the hood, of course, but one whose “objectness” is mostly hidden.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll cover lambda expressions and those special interfaces in more detail throughout
    the rest of this section. Then we’ll look at a popular, concrete example of using
    these expressions to do real work.
  prefs: []
  type: TYPE_NORMAL
- en: Lambda Expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Lambda expressions are small bits of code that can accept parameters and return
    values, just like methods. Unlike methods, though, you can easily pass a lambda
    as an argument to some other method or store it in a variable like you might with
    an object reference. FP proponents prize this ability to move code around like
    data. It allows you to write interesting and dynamic code without the clutter
    of creating inner or anonymous inner classes.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Lambdas are not meant to provide a performance boost. Although judicious use
    of lambdas often makes for more compact, more concise source code, that compression
    does not remove any complexity. Lambdas may require less typing, but they don’t
    do less work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall the `run()` method used by threads, which we saw so often in [Chapter 9](ch09.html#learnjava6-CHP-9).
    We created more than a few small classes that implemented the `Runnable` interface
    to supply a “body” to our threads. Small classes that do not include any state
    as instance variables are prime candidates for using lambdas: you have a well-defined
    task that you use in a well-defined situation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s revisit one of our thread demonstrations and then take a peek at how
    we could use a lambda expression as an alternative to the explicit use of `Runnable`.
    We’ll simplify the `VirtualDemo` class from [“Death of a Thread”](ch09.html#learnjava6-CHP-9-SECT-2)
    and concentrate on the anonymous inner class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We create a new instance of `Runnable` with a simple `run()` method that prints
    a greeting and the thread’s ID number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Great. Everything works as expected. Now let’s replace that `runnable` variable
    with a lambda expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We still start a new virtual thread, and we still store that thread in a variable
    (`t`, in both examples), but there is no evidence of the `Runnable` interface.
    We passed a somewhat strange argument to the `startVirtualThread()` method instead
    of a reference to some object. That “strange argument” is our lambda expression,
    annotated in [Figure 11-1](#learnjava6-CHP-11-FIG-lambda-1).
  prefs: []
  type: TYPE_NORMAL
- en: '![ljv6 1101](assets/ljv6_1101.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-1\. Basic structure of a lambda expression
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This particular lambda is very simple. We don’t pass it any arguments, and it
    does not return a value. Often that’s all you need. But lambdas are capable of
    much more. Lambda expressions also support arguments, can return values, and can
    have more interesting bodies.
  prefs: []
  type: TYPE_NORMAL
- en: Passing arguments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we think about lambdas as bits of code, it’s reasonable to compare them to
    regular methods. Regular methods do encapsulate logic, just like lambdas. But
    many of the methods we’ve seen in previous chapters also accept arguments. Can
    we supply arguments to a lambda?
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider an iterator that walks through the elements of a Java collection.
    We saw several examples in [Chapter 7](ch07.html#learnjava6-CHP-7). In those examples,
    we used an iterator inside a loop, with the body of the loop doing something with
    the given element of the collection on each pass. Recall our tree-painting loop
    from [“Application: Trees on the Field”](ch07.html#learnjava6-CHP-7-SECT-8):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The alternate `for` loop uses the iterator from `trees` to get every individual
    tree, and then tells that tree to draw itself on our field. We could replace that
    loop with a lambda and the `forEach()` method of the `Iterable` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You can see the same arrow operator, but instead of an empty pair of parentheses,
    we have a variable, `t` on the lefthand side. That variable receives one tree
    at a time from the `trees` collection, just like the alternate `for` loop from
    the first snippet. And just like the body of that `for` loop, you can use the
    current tree on the righthand side of the expression. With this arrangement, we
    get a slightly more concise version of our loop, but it retains its readability.
    You can use this handy trick with any collection that implements the `Iterable`
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Terms like *concise* and *readable* are subjective judgments. Proponents of
    FP definitely find the more compact syntax of lambdas easier to read, but those
    folks are already comfortable with the notation. We hope you’ll try the examples
    and exercises in this chapter to gain a little of that familiarity. We do like
    lambdas and use them in a number of situations, but they are never required. If
    you don’t find lambdas useful or readable after trying them out, you don’t need
    to use them in your own code.
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that our first lambda expression for a simple thread body
    took no arguments, so we used an empty set of parentheses on the lefthand side.
    But in this most recent example, we had one argument and no parentheses. The single
    argument form is so common that the compiler allows this shorthand with no parentheses.
    If you have no arguments, or more than one argument, the parentheses are required.
  prefs: []
  type: TYPE_NORMAL
- en: Expression bodies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Lambda expressions shine in situations where you would otherwise use an anonymous
    inner class. You can’t substitute lambdas for all situations that call for anonymous
    inner classes, but there are a surprising number of spots throughout Java that
    do work with lambdas. With this variety of applications comes the need for more
    complex computing beyond print statements. If you need to perform a few statements
    or work with a temporary variable, for example, you can enclose the body of the
    expression in curly braces, just like a method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine the trees in our game are seasonal. You could specify the color of
    their leaves before drawing them. You can still use a lambda:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Presumably our fictitious `getSeasonalColor()` method does some nice date-based
    calculating and returns an appropriate color. Notice that you can use methods
    (and most variables) from the rest of the class inside our lambda expression.
    Lambdas are quite powerful. But part of their power comes from judicious use—a
    20-line expression body would probably hurt the readability of your code. But
    if you have a few lambdas with a few lines, you’re in good shape.
  prefs: []
  type: TYPE_NORMAL
- en: Beyond keeping your lambdas readable, we want to point out a few quirks that
    might crop up for you. If you do want to use a local variable from the enclosing
    scope, it must be “effectively final” per the documentation. Recall that `final`
    variables can’t be modified. *Effectively final* variables are ones that *are
    not* modified even though they might not have the official `final` keyword in
    their declaration. If you try to use a nonfinal, local variable, the compiler
    will complain. Happily, this restriction only applies to local variables. You
    are free to use (and even modify) variables declared as members of the enclosing
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other quirk revolves around the keyword `this`. If you recall from [“The
    “this” reference”](ch05.html#learnjava6-CHP-5-SECT-2.2.1), `this` gives you a
    reference to the current object. It’s handy when methods or constructors have
    argument names that overlap with member variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: While you might reasonably think that `this` inside a lambda body would refer
    to the lambda itself, it actually still refers to the enclosing class. This quirk
    means you can use `this` inside a lambda just as you would with the constructor
    in the previous example. It makes sure your lambdas have access to the stuff in
    your class, even if a local variable would otherwise shadow something.
  prefs: []
  type: TYPE_NORMAL
- en: Returning values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Whether your lambda is a pithy one-liner or includes a readability-busting
    dozen lines, you can also return a value. A (deceptively) simple example is an
    incrementing function that takes an integer argument and returns an integer that
    is one more than the input. The expression itself would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In this form, Java will compute the answer to `x + 1` and return it. If we
    have a multiline body that should return a value, we can use the `return` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Explicit returns can be handy when you have `if` statements in the body. But
    the simpler form is preferable if your expression fits.
  prefs: []
  type: TYPE_NORMAL
- en: Functional Interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You may be wondering how Java categorizes our simple lambda expression. Is
    it an `int` like the input, or the result? Is it an object like so much of Java?
    Is it something we haven’t seen yet? Let’s see if *jshell* can shed any light:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Hmm, not really what we were hoping for, but that phrase *functional interface*
    is a clue. Let’s try that `var` keyword we saw in [“Inferring types”](ch04.html#learnjava6-CHP-4-SECT-4.2.1)
    and see if our lambda expression can be inferred:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Shoot. *jshell* did recognize our lambda expression, but that recognition isn’t
    enough to establish a type.
  prefs: []
  type: TYPE_NORMAL
- en: 'So what is a lambda expression’s type? In the case of our simple incrementing
    lambda, it turns out to be an `IntFunction`, a function that accepts one `int`
    as an argument and returns an `int`. The `IntFunction` interface lives in the
    `java.util.function` package alongside several other functional interfaces. Each
    interface in this package represents a different “shape” that a lambda expression
    can take. Let’s try it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Hooray! We didn’t get an error! (Although that resulting value looks rather
    daunting.) Happily, we don’t need to worry about the internal details of our lambda,
    as long as we can apply it to some data. But just how would we apply it?
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the [online documentation](https://oreil.ly/pgX7J) for the interface
    and you’ll see it has one method, `apply()`, appropriately enough:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Another hooray! Our incrementor increments! The other interfaces have a similar
    method defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'The shapes that we mentioned cover the different arrangements of the arguments
    and results of lambda expressions. If we wanted to work with `double` values instead
    of `int`s, for example, we could use the `DoubleFunction` interface. If we want
    to supply an object as an argument but don’t need to return a value, we could
    use the `Consumer<T>` interface. (Since `Consumer` works on reference types, it
    is parameterized. If we really did want to store a lambda that accepted a string,
    we would use the type `Consumer<String>`.) Or maybe we have a lambda that takes
    no arguments but generates a `long` value: the `LongSupplier` interface will do
    the trick. We won’t reproduce the full list of functional interfaces here, but
    it’s worth looking at the [package summary](https://oreil.ly/ksK1Z) online.'
  prefs: []
  type: TYPE_NORMAL
- en: As you find more situations where you can use lambdas, you’ll see how all these
    different shapes get used. But it’s important to point out that the term *functional
    interface* can apply to any interface that has a single abstract method (often
    abbreviated as SAM in the documentation). In [Chapter 12](ch12.html#learnjava6-CHP-12),
    for example, we’ll use lambdas to handle user interface events like clicking a
    button. Button events are reported to `ActionListener`s. The `ActionListener`
    interface has one abstract method, `actionPerformed()`, so it qualifies as a functional
    interface, even though it was part of Java long before these functional features
    were added.
  prefs: []
  type: TYPE_NORMAL
- en: Method References
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One other feature is associated with Java’s functional approach: a *method
    reference*. Sometimes your lambda expressions are really just wrappers for other
    methods. Consider the very popular task of printing out the contents of a collection.
    We could use the `forEach()` method we just learned about and print the elements
    of a list using a lambda:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: You can see that our lambda expression simply shuttles each string to the `System.out.println()`
    method. This is just the right candidate for a method reference.
  prefs: []
  type: TYPE_NORMAL
- en: 'We specify such a reference with a double-colon operator separating the method
    from its object (or its class, in the case of a `static` method):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Very compact and still readable. Method references only work in a narrow set
    of circumstances, but they are popular options wherever they’re allowed. As with
    lambda expressions in general, there is no real performance benefit versus using
    a lambda. Indeed, the Java compiler creates a lambda expression out of our method
    reference behind the scenes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Feel free to use method references where they fit, but it’s also fine to stick
    with an explicit lambda expression if you find it easier to read.
  prefs: []
  type: TYPE_NORMAL
- en: 'Practical Lambdas: Sorting'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Gosh, that was a lot of theory! It’s time to put these lambda expressions to
    use in some code you often find in real applications: sorting data. Sorting is
    a common task; we talked about it in [“A Closer Look: The sort() Method”](ch07.html#learnjava6-CHP-7-SECT-7)
    while discussing collections. Where do lambdas fit in?'
  prefs: []
  type: TYPE_NORMAL
- en: To put any list in order, you need a way of comparing two elements in the list
    so you know which one should come before the other. Some lists—say a list of employee
    salaries or a list of file and subfolder names in a given directory—have a fairly
    natural ordering that suffices in most cases. But sometimes you need a more complex
    ordering, like sorting the subfolders to the top before the files. You could implement
    the `Comparable` interface like you did before, or create a custom class that
    implements the closely related `Comparator` interface, but you could also supply
    a lambda.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a lambda expression to help with sorting, it needs to behave like the `compare()`
    method of `Comparator`. We need an expression that takes two arguments, say `a`
    and `b`, and returns one of three `int` values:'
  prefs: []
  type: TYPE_NORMAL
- en: Something less than zero if `a < b`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Something greater than zero if `a > b`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zero if `a == b`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The magic of lambdas allows us to decide *how* we organize a list in a dynamic
    way. The `java.util.Collections` helper class contains a `sort()` method that
    accepts a collection to sort, along with a comparator to provide the ordering.
    We can use a lambda to do that comparing. For example, we could create a simple
    lambda to sort our `names` list in alphabetical order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Arranged as expected, although we could have used any of Java’s sorting tricks
    to get this default ordering. Let’s reverse the ordering:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Neat! All we had to do was swap the order of the arguments using the `compareTo()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lambdas can do more, of course, especially when you need to order something
    a little more complex than a list of names. Imagine taking the trees in our apple
    tossing game and sorting them by their distance from the origin, `(0,0)`, using
    a slightly more interesting lambda:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We made this expression body more verbose than necessary to emphasize that
    lambdas can have many lines of code. This lambda probably strains readability,
    but it also highlights a handy side effect of such expressions: you get to see
    the code being used to sort right where the sorting is done. This self-documenting
    feature is another reason FP has so many proponents.'
  prefs: []
  type: TYPE_NORMAL
- en: Streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we’ve noted before, lambda expressions don’t do anything that you couldn’t
    accomplish using other features of Java, but they provide a different way to think
    about problems. In that same vein, the Java Streams API (not to be confused with
    all of the various “Stream” classes, like `PrintStream` in the `java.io` package)
    provides a different way to think about data.
  prefs: []
  type: TYPE_NORMAL
- en: You can get a stream from one of the classes in the `java.util.stream` package
    or by using the `stream()` method of a collection. A stream provides a steady
    flow of objects, and you perform *operations* on each object as you encounter
    it. Operations can filter out unwanted objects, count them, or even alter them
    before passing them along. In situations where you have very large amounts of
    data, streams offer a concise way to process all of that data. As a programmer,
    you can concentrate on how you handle a single object and let the stream do the
    work of getting those single objects ready for you.
  prefs: []
  type: TYPE_NORMAL
- en: Sources and Operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To try out streams, we’ll need a source of data. An easy start is using the
    `stream()` method on any class implementing the `Collection` interface or one
    of its descendants. (Arrays don’t have a built-in stream option, but you can create
    one easily enough with the `Stream.of()` static method.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have a stream going, we can operate on it. We’ll look at many more
    operations next, but a popular and simple starting point is the `count()` operation.
    Not surprisingly, this operation counts each element of the stream as it goes
    by and produces a single result. For example, we can use our `names` list in *jshell*
    and find out how many friends are in our list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Admittedly, this example doesn’t do anything amazing, but we’ll build up to
    more complex operations. The important thing to note is the way we attach an operation
    to our stream. The `stream()` returns a stream object, and we use the dot operator
    (`.`) immediately to get our count.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could use another operation to print out our names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We supplied a method reference to the `forEach()` operation, but you can also
    provide a lambda that takes one argument (the current name from the stream) and
    does not return a value.
  prefs: []
  type: TYPE_NORMAL
- en: Stream reuse
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You may have noticed that we did not store our stream in a variable for reuse
    between our `count()` example and the similar `forEach()` example. Streams are
    one-way and single use. You can actually store a stream in a variable, but if
    you try to reuse the stream after you have processed it, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We created a parameterized `Stream` object for our stream of `String` objects.
    We successfully started the stream and used the `count()` operation, but we failed
    to use that same stream for our `forEach()` operation. Processing a stream does
    not alter the original source, so you can safely start a new stream as often as
    needed. But once a stream has ended, it cannot be restarted.
  prefs: []
  type: TYPE_NORMAL
- en: Stream generators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another source of stream data is a *generator*. Generators create data according
    to some rule. Some generators produce a fixed value over and over, while others
    produce random content. You can generate simple things like numbers or complex
    things like objects. If getting real data is an expensive operation, you can use
    generators to more easily test your stream logic. Similarly, you can use a generator
    to create good (or quirky, or error-filled) data to test other parts of your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Stream.generate()` method takes an instance of the `Supplier` interface.
    A supplier has one job: to supply an infinite stream of elements. It has one method:
    `get()`, which returns an element of the appropriate type. And the element’s type
    is really the only restriction that Java places on your generator. Let’s try generating
    something simple: a steady stream of the number 42:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Our `Supplier` in this case is the very simple lambda, `() → 42`. There are
    no arguments, and every time the lambda expression is used or evaluated, the result
    is 42\. Notice that we follow our `generate()` method with a new method, `limit()`,
    that sits between the generator and our `println()` step. On their own, generators
    generate forever. We’ll discuss `limit()` and other related methods in the next
    section, but we need something in the short term to rein in our generators. If
    you don’t believe us, try removing that piece. Just be ready to hit Ctrl-C quickly
    (and repeatedly) to stop the onslaught of infinite 42s!
  prefs: []
  type: TYPE_NORMAL
- en: 'We can implement the `Supplier` interface (or any of its base-type cousins
    such as `IntSupplier`) in a class when we need a more interesting set of generated
    data. Consider a stream of random day names. We need a random number generator
    and a list of valid days. Those requirements would probably make for a messy inline
    lambda, but they’re trivial in a small class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `main()` method here isn’t necessary, but it makes it easy to test. Just
    compile and run the class from the *ch11/examples* folder. You should see five
    random days of the week:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Try running it a few times just to confirm that the random feature is working.
    Your generating class can be as rich as necessary. You just need to make sure
    `get()` returns an appropriate object or value: notice we implemented a parameterized
    version of our interface: `Suppler<String>`, and our `get()` method returns `String`.
    Now you’re good to go!'
  prefs: []
  type: TYPE_NORMAL
- en: Stream iterators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In addition to generators, streams can be built from iterators. These iterators
    aren’t quite the same as the iterators you use to walk through a collection, but
    the idea is similar. *Stream iterators* have the same notion of a “next” value
    as collection iterators, but for streams, that next value comes from performing
    a calculation on the previous value. If you need a range of sequential numbers,
    for example, an iterator is ideal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The `iterate()` source method takes two arguments: a starting value and a lambda
    expression. The lambda takes one argument and uses it to create the next element.
    That second element will be put back through the same lambda expression to create
    the third, and so on. We certainly could have done that with a custom `Supplier`,
    but for many sequences, iterators offer a simpler entry point. And you aren’t
    restricted to iterating on numbers—you can iterate on any object type that suits
    your needs. As long as you have a way to calculate the next object for the stream,
    you can use an iterator as a source. Let’s try creating a sequence of `LocalDate`
    objects as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We use the `LocalDate.now()` static method to get the current date for our starting
    value. The iterating expression takes a `LocalDate` object as input, uses the
    `plus()` method to add one day, and returns the new `LocalDate`. (And we end on
    such a lovely date.)
  prefs: []
  type: TYPE_NORMAL
- en: Filtering Streams
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Both the `count()` and the `forEach()` operations in the previous snippets are
    examples of *terminal* operations. Terminal operations “terminate” a stream. You
    can have only one, final terminating operation when processing a stream. The `limit()`
    operation, in contrast, is an example of an *intermediate* operation. An intermediate
    operation may alter or remove some of the data in the stream, but the stream continues.
    Filtering is a popular type of intermediate operation, and limiting the number
    of elements that continue on down the stream is a form of filtering. But you can
    filter for all kinds of reasons. You can filter to select desirable data or to
    toss out undesirable data. You can filter out duplicates. You can input a stream
    of objects to your filter and have it output an essentially new stream for use
    by the next operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'As luck would have it, generic filters are just lambdas that return `boolean`
    values. This is the `Predicate` shape from the big list of functional interfaces
    in the `java.util.function` package. You send one argument in, and either `true`
    or `false` comes out. For example, we could use a filter to count the names that
    contain the letter “o” like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Our filtering lambda takes one name and uses the `indexOf()` operation to see
    if the name contains an “o”. Since `indexOf()` returns an `int` value, we compare
    it to an impossible index, -1, to create the required `boolean` result. If the
    predicate returns `true`, that name will be passed along. If the predicate returns
    `false`, the name is simply dropped from the stream.
  prefs: []
  type: TYPE_NORMAL
- en: 'The important detail again is the “in the middle” nature of a filter. We can
    keep doing things with our stream. It’s common to stack multiple filters, for
    example. Each filter selects different desired elements (or removes unwanted elements,
    depending on how you look at it). Another popular built-in filter is the `distinct()`
    operation that weeds out duplicates. Let’s add some repeated names to our list
    and try using two intermediate operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'You can stack as many filters as you need, although it’s still important to
    keep your code readable. (If you have a gauntlet of 20 filters, you may want to
    reconsider how you process the source for the stream.) But you can do more than
    simply filter the elements in your stream: you can turn them into something else!'
  prefs: []
  type: TYPE_NORMAL
- en: Mapping Streams
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In streams, *mapping* is the process of altering an element in a stream before
    passing it along. Like filtering, you use a lambda expression to perform the alteration.
    You can map simple changes, like adding sales tax to a stream of prices, or you
    can create complex maps that convert one type of object into a wholly different
    type. Or you can do both! Mapping is also an intermediate operation, so you can
    stack map operations just as you did with filters. Indeed, you will see many examples
    online of programmers mixing maps and filters to achieve their final result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by trying the task of adding sales tax. We’ll start with a short
    list of `double` values and a 5% tax. We can `map()` the tax onto the prices like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The formatting of our prices isn’t very polished, but the tax has been correctly
    applied. While we have them handy, we can try out another useful terminal operation,
    `sum()`, to add up all the prices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Again, the output isn’t nicely formatted, but we summed up an entire array of
    numbers in one line!
  prefs: []
  type: TYPE_NORMAL
- en: Mapping object attributes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can also use maps to peer inside objects. Let’s create a simplified variation
    of our `Employee` class from [Chapter 7](ch07.html#learnjava6-CHP-7) with an additional
    `salary` attribute. We’ll call this version a `PaidEmployee`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In a stream of employees, we can now use `map()` to extract specific attributes,
    like their names. Let’s write a test class that creates a few example employee
    objects and then uses a stream to process the employees:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `publishNames()` method uses `map()` to take our `PaidEmployee` object and
    grab the employee’s name. That name (a simple `String` object) continues on down
    the stream. With the names available, we could add filters, like our “names with
    an o” filter from earlier examples, or watch out for duplicate employee records.
    Any time you need to massage your data, `map()` is the method to use.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping conversions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the previous example, we quietly converted our stream from one with `PaidEmployee`
    objects to one with `String` objects. Because both types are reference types,
    we don’t really have to worry about the fact that we have different before and
    after types. If you need to move from a reference type to a base type—or vice
    versa—you have to be a little more explicit about the conversion. This is definitely
    a common task, so Java supplies some handy variations of `map()` for just this
    purpose. Let’s get a sum of all our employees’ annual salaries to know what our
    wage budget should be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 11-2](#learnjava6-CHP-11-FIG-obj-to-int) illustrates the data moving
    through this budget-calculating stream.'
  prefs: []
  type: TYPE_NORMAL
- en: '![ljv6 1102](assets/ljv6_1102.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-2\. Converting between objects and ints in a stream
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Similar classes exist for moving to two other base types: `mapToDouble()` and
    `mapToLong()`. If you already have a stream of numbers and want to move to an
    object, the base type streams, like `IntStream`, all include the `mapToObj()`
    operation.'
  prefs: []
  type: TYPE_NORMAL
- en: Flatmaps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We want to introduce one other type of mapping operation commonly used with
    streams: the *flatmap*. The flatmap operation takes lumpy inputs and smooths them
    into a single (you might even say flat!) stream of elements. What do we mean by
    lumpy input? It’s mostly a cute way of saying multidimensional data. Consider
    the array-of-arrays chessboard we discussed in [“Multidimensional Arrays”](ch04.html#learnjava6-CHP-4-SECT-6.5).
    We can play with a similar setup in *jshell* using simple `int` values. The “board”
    is an array of rows, where each row is an array of numbers. What happens if we
    try to start a stream from our two-dimensional array? Let’s try it out with a
    reduced 4 × 4 matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Hmm, that appears to be a stream of `int[]` objects, not individual integers.
    (Those ugly blobs are Java’s default way of printing objects that don’t have a
    pretty `toString()` method. The format is “object type @ memory address”.) What
    if we try to start a stream from the first row?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: That output looks better—it’s a list of our made-up chess piece values, but
    it’s only one row. We could put the stream in the middle of a `for` loop and process
    a separate stream for every row, but that seems cumbersome and would make any
    kind of counting or summing step much more difficult.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a nice, stream-friendly way to get all of our chess pieces into one stream,
    we’ll use `flatMap()`, or in our case of going from an object (each row is an
    array object) to a base type (each chess piece is an `int`), we’ll use `flatMapToInt()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Hooray, it worked! We started with a stream of dense objects and broke up those
    dense objects into a single stream of smaller parts. You can use `flatMap()` and
    its base-type cousins to toss any tabular, cubic, or generic multidimensional
    data into a pleasant stream of individual elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at another example that combines several of the stream topics we’ve
    covered so far. A common task for system and network administrators is parsing
    log files. Web servers, for example, log each visitor’s Internet Protocol (IP)
    address and the resource they requested. Here’s a small example, with the long
    lines truncated for readability:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Each line contains lots of information: that IP address, the date and time
    of the request, what was requested, how it was requested, and (if you peek at
    the real log file in the *ch11/examples* folder) information about what browser
    or user agent made the request. Real-world log files can be huge, and admins usually
    keep them compressed on disk.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use all our stream skills. We’ll start with a GZIP file and load its
    contents with some I/O streams, then break up the uncompressed data into lines.
    We can use `flatMap()` to turn the functional stream of lines into a stream of
    space-separated tokens. With our tokens in hand, we can finally get to the information
    we really want: a count of unique visitor IP addresses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Very nice. Once we have the stream of lines from our decompressed file, we can
    get our count using the functional approach to processing data with a compact,
    efficient, and readable list of steps. Again, you do not *have* to use functional
    streams and lambdas, but more and more programmers are looking into this way of
    solving problems—even in erstwhile object-oriented languages like Java.
  prefs: []
  type: TYPE_NORMAL
- en: Reducing and Collecting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ve looked at several examples using streams in this chapter. Each example
    has ended the stream with one of three terminal operations: a `forEach()` that
    we typically use to print the elements, a `count()` to know how many elements
    there are, or with `sum()` as a way to add up all of the numerical elements. Counting
    and summing are examples of *reducing* a stream. You “reduce” all the elements
    in your stream to a single answer.'
  prefs: []
  type: TYPE_NORMAL
- en: Streams in Java have several built-in reducers, as shown in [Table 11-1](#learnjava6-CHP-11-TABLE-1).
  prefs: []
  type: TYPE_NORMAL
- en: Table 11-1\. Terminal reduction operations
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `count()` | Returns the number of elements in the stream |'
  prefs: []
  type: TYPE_TB
- en: '| `findAny()` | Returns an element (if any exist) from the stream |'
  prefs: []
  type: TYPE_TB
- en: '| `findFirst()` | Returns the first element (if it exists) from the stream
    |'
  prefs: []
  type: TYPE_TB
- en: '| `matchAll()` | Returns `true` if all elements of the stream match the given
    criteria |'
  prefs: []
  type: TYPE_TB
- en: '| `matchAny()` | Returns `true` if at least one element in the stream matches
    the given criteria |'
  prefs: []
  type: TYPE_TB
- en: '| `max()` | Using a provided comparator, returns the “largest” element (if
    any) |'
  prefs: []
  type: TYPE_TB
- en: '| `min()` | Using a provided comparator, returns the “smallest” element (if
    any) |'
  prefs: []
  type: TYPE_TB
- en: 'You might wonder why the `sum()` operation we’ve used a few times isn’t listed.
    It is definitely a reducer, but the built-in version is available only on the
    base-type streams: `IntStream`, `LongStream`, and `DoubleStream`.'
  prefs: []
  type: TYPE_NORMAL
- en: Optional values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before looking deeper at reducers (including how to create a custom reducer),
    we need to be prepared for a potentially dire outcome: an empty stream.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Any time you filter a stream, it’s possible you won’t have anything left on
    the other side of the filter. As a quick example, what if the filter in our `names`
    example earlier had been looking for the letter “a” instead of “o”? None of our
    names contain an “a,” so the filter would end up dropping every name from our
    list. The `count()` operation can handle that situation fine: it simply returns
    an answer of zero. But what if we had used `min()` or `findFirst()`? Those reducers
    expect to give you a matching element from your stream. If there are no elements
    left, what should a reducer return? It might be acceptable in some scenarios to
    return a `null` value, but if your stream ends with base-type elements, like `int`
    values, you can’t use `null`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Rather than force you to construct some strange rule or throw an exception,
    Java streams support the notion of an *optional* answer. These answers are wrapped
    in a class, appropriately called `Optional`, from the `java.util` package. An
    `Optional` object has two key methods that we’ll work with in this section: `isPresent()`
    tells us whether a value exists or not, and `get()` returns that value. (If you
    call `get()` when no value is present, you’ll “get” a `NoSuchElementException`.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can test this optional idea by revisiting our name filtering example. Rather
    than counting the results, though, we’ll use `findFirst()` to return the first
    matching name. Since there might not be any matches at all, we’ll get the result
    wrapped in an `Optional`. Feel free to reuse the `names` collection if it’s still
    in your *jshell*, but here’s a quick recap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s run those names through a filter and look for the first match. We’ll
    try our filter with an “o” (which should have an answer) and then with an “a”
    (which should not have an answer). Notice how we use the `Optional` result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: While it makes your code a little more verbose to test if your value `isPresent()`,
    `Optional` provides a clear interface for handling both the good and the “bad”
    outcomes of your stream processing. And as with so many other classes and methods
    in this functional arena, you can use the `OptionalInt`, `OptionalLong`, and `Optional`
    `Double` classes to catch potentially missing base-type results.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a custom reducer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What if the built-in reducers don’t cover your needs? You may not be surprised
    to learn that you can supply a lambda to create a custom reducer. The `Stream`
    class includes a `reduce()` operation that accepts a lambda with the `BinaryOperator`
    shape from the `java.util.function` package we discussed in [“Functional Interfaces”](#learnjava6-CHP-11-SECT-2.2).
    `BinaryOperator` accepts two arguments of the same type and returns a value (also
    of the same type). Depending on your needs, you can either use `reduce()` with
    just the binary operator lambda, or you can use a second form that also takes
    an initial value of the same type used by the binary operator. Let’s try out this
    second form to create a custom factorial reducer.
  prefs: []
  type: TYPE_NORMAL
- en: '*Factorials* are big numbers—or they can be, anyway. If the term doesn’t sound
    familiar, it’s similar to a summing operation, but instead of adding each number
    in the sequence, you multiply. You typically use the exclamation mark to indicate
    this operation: `5!` (pronounced “five factorial”) will multiply 5 and 4 making
    20, then 20 × 3 makes 60, then 60 × 2 makes 120, and finally 120 × 1 leaves 120\.
    It may look simple enough, but factorial numbers get very big, very quickly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'If you look carefully at the result of `12!`, you’ll notice it is just under
    half a billion, so it still fits within the (positive) range of values for the
    `int` type. But `13!` would be roughly 6.5 billion, so we can’t store that answer
    with `int`s. We could calculate it with `long`s, but even that type can’t hold
    anything after `20!`. Fortunately, Java is ready with some fun classes from `java.math`:
    `BigInteger` and `BigDecimal`. These classes can house arbitrarily large values,
    perfect for removing the limits of base types in our factorial work.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use a simple iterator as our source, since multiplication doesn’t require
    a particular order of operations. Our factorial reducer will always produce an
    answer similar to `count()` or `sum()`,^([3](ch11.html#id2290)) so we’ll use the
    second form with a starting value of 1\. We can try this out in *jshell*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The output of `99!` is so large we had to arbitrarily chop it up to make it
    fit the printed edition of this book.^([4](ch11.html#id2291)) But our custom reducer
    worked!
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can implement the `BinaryOperator` interface in a class if your reducing
    logic is too complex for the simple, inline lambda. Then you can supply an instance
    of that class to `reduce()` instead of the lambdas we used in our examples.
  prefs: []
  type: TYPE_NORMAL
- en: Collectors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The answers that reducers produce are often very useful. How many lines did
    you process? How many times did you see a particular word? What’s the average
    of some column in tabular data? But what if you want more than a single answer?
    When filtering, for example, you might want to keep all of the items from the
    stream that match, rather than counting or summing them.
  prefs: []
  type: TYPE_NORMAL
- en: What if you want a new list of just the names containing the letter “o”? We
    can use a collector.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `java.util.stream.Collector` interface allows for some impressive flexibility
    in how you collect and organize the results of processing your stream. We won’t
    be tackling custom collectors in this book, but happily, the related `Collectors`
    class includes several common collectors as static methods. For example, we can
    use one of those static methods to get that list of o-having names we were curious
    about:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Excellent. Now `onames` is a regular `List<String>` object that we can use anywhere
    else we might need it. There are many, many other collecting methods that we encourage
    you to peek at in the [online documentation for `Collectors`](https://oreil.ly/R3vmF).
    The code exercises at the end of this chapter give you the chance to try out another
    popular collector, `groupingBy()`, but we don’t have time to cover all of the
    other wonderful options available.
  prefs: []
  type: TYPE_NORMAL
- en: Using Lambdas Directly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We want to highlight one other feature of lambdas in Java: you can use them
    in your own code. While you will probably start by using lambdas in a few tasks
    like sorting collections or filtering long streams of data, eventually you may
    want to write methods that accept a lambda as an argument to be used in the body
    of that method. Since lambda expressions are just instances of some functional
    interface, Java makes accepting lambdas fairly straightforward.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a digital sensor: perhaps some gadget attached to a USB port. Many
    of these sensors are stable and consistent, but they are consistently off by some
    factor. Maybe a thermometer thinks your home office is always three degrees warmer
    than it is, or maybe a light sensor underestimates ambient light by 10%. You could
    write separate adjustment methods that “add 3” to a reading or that “reduce by
    10%” every value, but you can also use lambdas to create a generic adjustment
    method and let the caller supply the adjusting logic.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how you might write such a method. To make your method accept a lambda,
    you need to decide what shape it should have. You can always create your own shape,
    of course, but often you can simply use one of the interfaces from the `java.util.function`
    package. For our sensor-reading adjustments, we’ll use the `DoubleUnaryOperator`
    shape. (A *unary operator* operates on one value the same way a binary operator
    works on two.) We’ll accept one `double` argument and return an adjusted `double`
    as the result. We can put our amazingly flexible adjuster in a simple test harness
    to try out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see that our `adjust()` method takes two arguments: the value we want
    to adjust, and the lambda that will do the adjusting. (And yes, you could implement
    the `DoubleUnaryOperator` in a class and supply an instance of that implementation
    as an alternative.) When we call `adjust()`, we get to use the same compact syntax
    that we’ve seen with other parts of the official JDK. It feels a bit like using
    forbidden magic, but it is entirely encouraged!'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you compile and run this demo, you should see output similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Exactly what we expected. And we could write other adjustments without having
    to rewrite our actual `adjust()` method. You probably won’t need this type of
    dynamic logic for every problem you tackle in Java, but it’s worth putting this
    trick into your toolbox so you can pull it out when you do.
  prefs: []
  type: TYPE_NORMAL
- en: Next Steps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with so many features of Java, we could write an entire book just on lambda
    expressions or streams. [Others have!](https://oreil.ly/4Eb4c) We hope this introduction
    whets your appetite for learning more about FP topics. If you want more interactive
    practice with these topics, we highly recommend the labs available through O’Reilly’s
    [online platform](https://oreil.ly/gRFDW). Our own Marc Loy has created two series,
    one on [Java lambdas](https://oreil.ly/QNmjK) and another on [Java streams](https://oreil.ly/XquFS),
    both with practical examples of the topics we touched on in this chapter. These
    labs take advantage of O’Reilly’s Interactive Learning Environment, where you
    can edit, compile, and execute Java code right in your browser.
  prefs: []
  type: TYPE_NORMAL
- en: Review Questions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Which package contains the majority of functional interfaces introduced in Java
    8?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do you need to use any special flags when compiling or running Java applications
    that use functional features like lambdas?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you create lambda expressions with multiple statements in the body?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can lambda expressions be void? Can they return values?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can you reuse a stream after you have processed it?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How might you take a stream of objects and convert it to a stream of integers?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you have a stream that filters out empty lines from a file, what operation
    might you use to tell you how many lines had some content?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Code Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our `Adjuster` demonstration allows us to pass any lambda that accepts and returns
    a `double` value. We aren’t restricted to simple changes like adding a fixed amount.
    Add one more line of output that converts the number from a Fahrenheit reading
    to Celsius. (As a quick refresher, C = (F – 32) * 5 / 9\. Our reading of 70.2
    should come out around 21.2.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the `PaidEmployee` and `Report` classes from [“Mapping object attributes”](#learnjava6-CHP-11-SECT-3.3.1),
    add a simple report similar to `publishBudget()` that displays the average salary
    of all employees.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Advanced Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s explore more of the collectors we touched on at the end of the chapter.
    Add a “role” attribute (of type `String`) to the `PaidEmployee` class. Be sure
    to update the `buildEmployeeList()` method in the `Report` class to assign roles
    as well. Feel free to pick whatever roles you like but make sure at least two
    employees share the same role (for testing purposes).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now look at the [documentation for the `groupingBy()` collector](https://oreil.ly/miu1t).
    It returns a map of the groups and their members. In our example, the keys of
    this map will be the roles you created. The associated values will be lists of
    all the employees who share that role. You can add one more “report” to the `Report`
    class that creates this map and then prints out the roles and their associated
    employees.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ^([1](ch11.html#id2199-marker)) Indeed, Church’s student and computing pioneer
    Alan Turing proved that the lambda calculus was equivalent to Turing’s own system
    (the foundational Turing machine) for performing computation.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch11.html#id2202-marker)) We mention Clojure rather than the myriad other
    modern functional languages because it runs on the JVM and can integrate with
    Java classes and methods. Neat!
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch11.html#id2290-marker)) A quirk of the factorial process is that `0!`
    is defined as “the number of ways to arrange items in an empty set”—which is exactly
    one. Even if our stream has no elements, we can still correctly return the starting
    value.
  prefs: []
  type: TYPE_NORMAL
- en: ^([4](ch11.html#id2291-marker)) That’s 9.3e+155 if scientific notation is easier
    for you to parse at that size. Popular estimates for the number of atoms in the
    known universe come in around 10e+82, in case you were wondering just how big
    `99!` really is.
  prefs: []
  type: TYPE_NORMAL
