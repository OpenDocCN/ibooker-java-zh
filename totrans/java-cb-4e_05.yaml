- en: Chapter 5\. Numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 5.0 Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Numbers are basic to just about any computation. They’re used for array indices,
    temperatures, salaries, ratings, and an infinite variety of things. Yet they’re
    not as simple as they seem. With floating-point numbers, how accurate is accurate?
    With random numbers, how random is random? With strings that should contain a
    number, what actually constitutes a number?
  prefs: []
  type: TYPE_NORMAL
- en: Java has several built-in, or *primitive*, types that can be used to represent
    numbers, summarized in [Table 5-1](#javacook-numbers-TABLE-1) with their *wrapper*
    (object) types, as well as some numeric types that do not represent primitive
    types. Note that unlike languages such as C or Perl, which don’t specify the size
    or precision of numeric types, Java—with its goal of portability—specifies these
    exactly and states that they are the same on all platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Table 5-1\. Numeric types
  prefs: []
  type: TYPE_NORMAL
- en: '| Built-in type | Object wrapper | Size of built-in (bits) | Contents |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `byte` | `Byte` | 8 | Signed integer |'
  prefs: []
  type: TYPE_TB
- en: '| `short` | `Short` | 16 | Signed integer |'
  prefs: []
  type: TYPE_TB
- en: '| `int` | `Integer` | 32 | Signed integer |'
  prefs: []
  type: TYPE_TB
- en: '| `long` | `Long` | 64 | Signed integer |'
  prefs: []
  type: TYPE_TB
- en: '| `float` | `Float` | 32 | IEEE-754 floating point |'
  prefs: []
  type: TYPE_TB
- en: '| `double` | `Double` | 64 | IEEE-754 floating point |'
  prefs: []
  type: TYPE_TB
- en: '| `char` | `Character` | 16 | Unsigned Unicode character |'
  prefs: []
  type: TYPE_TB
- en: '| n/a | `BigInteger` | unlimited | Arbitrary-size immutable integer value |'
  prefs: []
  type: TYPE_TB
- en: '| n/a | `BigDecimal` | unlimited | Arbitrary-size-and-precision immutable floating-point
    value |'
  prefs: []
  type: TYPE_TB
- en: As you can see, Java provides a numeric type for just about any purpose. There
    are four sizes of signed integers for representing various sizes of whole numbers.
    There are two sizes of floating-point numbers to approximate real numbers. There
    is also a type specifically designed to represent and allow operations on Unicode
    characters. The primitive numeric types are discussed here. The “Big” value types
    are described in [Recipe 5.12](#javacook-numbers-SECT-19).
  prefs: []
  type: TYPE_NORMAL
- en: When you read a string representing a number from user input or a text file,
    you need to convert it to the appropriate type. The object wrapper classes in
    the second column have several functions, one of which is to provide this basic
    conversion functionality—replacing the C programmer’s *atoi*/*atof* family of
    functions and the numeric arguments to *scanf*.
  prefs: []
  type: TYPE_NORMAL
- en: Going the other way, you can convert any number (indeed, anything at all in
    Java) to a string just by using string concatenation. If you want a little bit
    of control over numeric formatting, [Recipe 5.5](#javacook-numbers-SECT-8) shows
    you how to use some of the object wrappers’ conversion routines. And if you want
    full control, that recipe also shows the use of `NumberFormat` and its related
    classes to provide full control of formatting.
  prefs: []
  type: TYPE_NORMAL
- en: As the name *object wrapper* implies, these classes are also used to wrap a
    number in a Java object, as many parts of the standard API are defined in terms
    of objects. Later on, [“Solution”](ch12.html#javacook-netclient-SECT-5.2) shows
    using an `Integer` object to save an `int`’s value to a file using object serialization
    and retrieving the value later.
  prefs: []
  type: TYPE_NORMAL
- en: 'But I haven’t yet mentioned the issues of floating point. Real numbers, you
    may recall, are numbers with a fractional part. There is an infinite number of
    real numbers. A floating-point number—what a computer uses to approximate a real
    number—is not the same as a real number. The number of floating-point numbers
    is finite, with only 2^32 different bit patterns for `float`s, and 2^64 for `double`s.
    Thus, most real values have only an approximate correspondence to floating point.
    The result of printing the real number 0.3 works correctly, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'That code results in this printout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'But the difference between a real value and its floating-point approximation
    can accumulate if the value is used in a computation; this is often called a *rounding
    error*. Continuing the previous example, the real 0.3 multiplied by 3 yields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Surprised? Not only is it off by a bit from what you might expect, but you will
    of course get the same output on any conforming Java implementation. I ran it
    on machines as disparate as an AMD/Intel PC with OpenBSD, a PC with Windows and
    the standard JDK, and on macOS. Always the same answer.
  prefs: []
  type: TYPE_NORMAL
- en: 'And what about random numbers? How random are they? You have probably heard
    the term *Pseudorandom Number Generator*, or PRNG. All conventional random number
    generators, whether written in Fortran, C, or Java, generate pseudorandom numbers.
    That is, they’re not truly random! True randomness comes only from specially built
    hardware: an analog source of Brownian noise connected to an analog-to-digital
    converter, for example.^([1](ch05.html#idm45290682381560)) Your average PC of
    today may have some good sources of entropy, or even hardware-based sources of
    randomness (which have not been widely used or tested yet). However, pseudorandom
    number generators are good enough for most purposes, so we use them. Java provides
    one random generator in the base library `java.lang.Math`, and several others;
    we’ll examine these in [Recipe 5.9](#javacook-numbers-SECT-13).'
  prefs: []
  type: TYPE_NORMAL
- en: The class `java.lang.Math` contains an entire math library in one class, including
    trigonometry, conversions (including degrees to radians and back), rounding, truncating,
    square root, minimum, and maximum. It’s all there. Check the javadoc for `java.lang.Math`.
  prefs: []
  type: TYPE_NORMAL
- en: The package `java.math` contains support for *big numbers*—those larger than
    the normal built-in long integers, for example. See [Recipe 5.12](#javacook-numbers-SECT-19).
  prefs: []
  type: TYPE_NORMAL
- en: Java works hard to ensure that your programs are reliable. The usual ways you’d
    notice this are in the common requirement to catch potential exceptions—all through
    the Java API—and in the need to *cast*, or convert, when storing a value that
    might or might not fit into the variable you’re trying to store it in. I’ll show
    examples of these.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, Java’s handling of numeric data fits well with the ideals of portability,
    reliability, and ease of programming.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The [Java Language Specification](https://docs.oracle.com/javase/specs), and
    the javadoc page for `java.lang.Math`.
  prefs: []
  type: TYPE_NORMAL
- en: 5.1 Checking Whether a String Is a Valid Number
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to check whether a given string contains a valid number, and, if so,
    convert it to binary (internal) form.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To accomplish this, use the appropriate wrapper class’s conversion routine
    and catch the `NumberFormatException`. This code converts a string to a `double`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This code lets you validate only numbers in the format that the designers of
    the wrapper classes expected. If you need to accept a different definition of
    numbers, you could use regular expressions (see [Chapter 4](ch04.html#javacook-regex))
    to make the determination.
  prefs: []
  type: TYPE_NORMAL
- en: 'There may also be times when you want to tell if a given number is an integer
    number or a floating-point number. One way is to check for the characters ., `d`,
    `e`, or `f` in the input; if one of these characters is present, convert the number
    as a `double`. Otherwise, convert it as an `int`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A more involved form of parsing is offered by the `DecimalFormat` class, discussed
    in [Recipe 5.5](#javacook-numbers-SECT-8).
  prefs: []
  type: TYPE_NORMAL
- en: There is also the `Scanner` class; see [Recipe 10.6](ch10.html#javacook-io-SECT-5).
  prefs: []
  type: TYPE_NORMAL
- en: 5.2 Converting Numbers to Objects and Vice Versa
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to convert numbers to objects and objects to numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the object wrapper classes listed in [Table 5-1](#javacook-numbers-TABLE-1)
    at the beginning of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Often you have a primitive number and you need to pass it into a method where
    an `Object` is required, or vice versa. Long ago you had to invoke the conversion
    routines that are part of the `wrapper` classes, but now you can generally use
    automatic conversion (called *auto-boxing*/*auto-unboxing*). See [Example 5-1](#javacook-CHP-8-EX-6)
    for examples of both.
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-1\. main/src/main/java/structure/AutoboxDemo.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_numbers_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Auto-boxing: `int 42` is converted to `Integer(42)`. Also auto-unboxing: the
    `Integer` returned from `foo()` is auto-unboxed to assign to `int result`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_numbers_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: 'No auto-boxing: `valueOf()` returns `Integer`. If the line said `return Integer.intValueOf(123)`,
    then it would be a second example of auto-boxing because the method return value
    is `Integer`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To explicitly convert between an `int` and an `Integer` object, or vice versa,
    you can use the `wrapper` class methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 5.3 Taking a Fraction of an Integer Without Using Floating Point
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to multiply an integer by a fraction without converting the fraction
    to a floating-point number.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Multiply the integer by the numerator and divide by the denominator.
  prefs: []
  type: TYPE_NORMAL
- en: This technique should be used only when efficiency is more important than clarity
    because it tends to detract from the readability—and therefore the maintainability—of
    your code.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Because integers and floating-point numbers are stored differently, it may
    sometimes be desirable and feasible, for efficiency purposes, to multiply an integer
    by a fractional value without converting the values to floating point and back,
    and without requiring a cast:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: You should beware of the possibility of numeric overflow and avoid this optimization
    if you cannot guarantee that the multiplication by the numerator will not overflow.
  prefs: []
  type: TYPE_NORMAL
- en: 5.4 Working with Floating-Point Numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to be able to compare and round floating-point numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Compare with the `INFINITY` constants, and use `isNaN()` to check for `NaN`
    (not a number).
  prefs: []
  type: TYPE_NORMAL
- en: Compare floating values with an epsilon value.
  prefs: []
  type: TYPE_NORMAL
- en: Round floating point values with `Math.round()` or custom code.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Comparisons can be a bit tricky: fixed-point operations that can do things
    like divide by zero result in Java notifying you abruptly by throwing an exception.
    This is because integer division by zero is considered a *logic error*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Floating-point operations, however, do not throw an exception because they
    are defined over an (almost) infinite range of values. Instead, they signal errors
    by producing the constant `POSITIVE_INFINITY` if you divide a positive floating-point
    number by zero, the constant `NEGATIVE_INFINITY` if you divide a negative floating-point
    value by zero, and `NaN` if you otherwise generate an invalid result. Values for
    these three public constants are defined in both the `Float` and the `Double`
    wrapper classes. The value `NaN` has the unusual property that it is not equal
    to itself (i.e., `NaN` != `NaN`). Thus, it would hardly make sense to compare
    a (possibly suspect) number against `NaN`, because the following expression can
    never be true:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, the methods `Float.isNaN(float)` and `Double.isNaN(double)` must be
    used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that this, by itself, is not sufficient to ensure that floating-point
    calculations have been done with adequate accuracy. For example, the following
    program demonstrates a contrived calculation—Heron’s formula for the area of a
    triangle—both in `float` and in `double`. The double values are correct, but the
    floating-point value comes out as zero due to rounding errors. This happens because,
    in Java, operations involving only `float` values are performed as 32-bit calculations.
    Related languages such as C automatically promote these to double during the computation,
    which can eliminate some loss of accuracy. Let’s take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If in doubt, use `double`!
  prefs: []
  type: TYPE_NORMAL
- en: To ensure consistency of very large-magnitude double computations on different
    Java implementations, Java provides the keyword `strictfp`, which can apply to
    classes, interfaces, or methods within a class.^([2](ch05.html#idm45290681215064))
    If a computation is Strict-FP, then it must always, for example, return the value
    `INFINITY` if a calculation would overflow the value of `Double.MAX_VALUE` (or
    underflow the value `Double.MIN_VALUE`). Non-Strict-FP calculations—the default—are
    allowed to perform calculations on a greater range and can return a valid final
    result that is in range even if the interim product was out of range. This is
    pretty esoteric and affects only computations that approach the bounds of what
    fits into a double.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing floating-point values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Based on what we’ve just discussed, you probably won’t just go comparing two
    floats or doubles for equality. You might expect the floating-point wrapper classes,
    `Float` and `Double`, to override the `equals()` method, which they do. The `equals()`
    method returns `true` if the two values are the same bit for bit (i.e., if and
    only if the numbers are the same or are both `NaN`). It returns `false` otherwise,
    including if the argument passed in is null, or if one object is +0.0 and the
    other is –0.0.
  prefs: []
  type: TYPE_NORMAL
- en: 'I said earlier that `NaN != Nan`, but if you compare with `equals()`, the result
    is true:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: If this sounds weird, remember that the complexity comes partly from the nature
    of doing real number computations in the less-precise floating-point hardware.
    It also comes partly from the details of the IEEE Standard 754, which specifies
    the floating-point functionality that Java tries to adhere to so that underlying
    floating-point processor hardware can be used even when Java programs are being
    interpreted.
  prefs: []
  type: TYPE_NORMAL
- en: 'To actually compare floating-point numbers for equality, it is generally desirable
    to compare them within some tiny range of allowable differences; this range is
    often regarded as a tolerance or as *epsilon*. [Example 5-2](#javacook-numbers-EX-1)
    shows an `equals()` method you can use to do this comparison, as well as comparisons
    on values of `NaN`. When run, it prints that the first two numbers are equal within
    epsilon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Example 5-2\. main/src/main/java/numbers/FloatCmp.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note that neither of the `System.err` messages about incorrect returns prints.
    The point of this example with `NaN`s is that you should always make sure values
    are not `NaN` before entrusting them to `Double.equals()`.
  prefs: []
  type: TYPE_NORMAL
- en: Rounding
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you simply cast a floating value to an integer value, Java truncates the
    value. A value like 3.999999 cast to an `int` or `long` becomes 3, not 4\. To
    round floating-point numbers properly, use `Math.round()`. It has two overloads:
    if you give it a `double`, you get a `long` result; if you give it a `float`,
    you get an `int`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'What if you don’t like the rounding rules used by `round`? If, for some bizarre
    reason, you wanted to round numbers greater than 0.54 instead of the normal 0.5,
    you could write your own version of `round()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: If, on the other hand, you simply want to display a number with less precision
    than it normally gets, you probably want to use a `DecimalFormat` object or a
    `Formatter` object, which we look at in [Recipe 5.5](#javacook-numbers-SECT-8).
  prefs: []
  type: TYPE_NORMAL
- en: 5.5 Formatting Numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to format numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use a `NumberFormat` subclass.
  prefs: []
  type: TYPE_NORMAL
- en: Java did not originally provide C-style `printf/scanf` functions because they
    tend to mix together formatting and input/output in a very inflexible way. Programs
    using `printf/scanf` can be hard to internationalize, for example. Of course,
    by popular demand, Java did eventually introduce `printf()`, which along with
    `String.format()` is now standard in Java; see [Recipe 10.4](ch10.html#javacook-io-SECT-3).
  prefs: []
  type: TYPE_NORMAL
- en: Java has an entire package, `java.text`, full of formatting routines as general
    and flexible as anything you might imagine. As with `printf`, it has an involved
    formatting language, described in the javadoc page. Consider the presentation
    of long numbers. In North America, the number one thousand twenty-four and a quarter
    is written 1,024.25; in most of Europe it is 1 024,25; and in some other part
    of the world it might be written 1.024,25\. Not to mention how currencies and
    percentages are formatted! Trying to keep track of this yourself would drive the
    average small software shop around the bend rather quickly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, the `java.text` package includes a `Locale` class; and, furthermore,
    the Java runtime automatically sets a default `Locale` object based on the user’s
    environment (on the Macintosh and Windows, the user’s preferences, and on Unix,
    the user’s environment variables). To provide a nondefault locale in code, see
    [Recipe 3.12](ch03.html#javacook-i18n-SECT-8). To provide formatters customized
    for numbers, currencies, and percentages, the `NumberFormat` class has static
    *factory methods* that normally return a `DecimalFormat` with the correct pattern
    already instantiated. A `DecimalFormat` object appropriate to the user’s locale
    can be obtained from the factory method `NumberFormat.getInstance()` and manipulated
    using `set` methods. Surprisingly, the method `setMinimumIntegerDigits()` turns
    out to be the easy way to generate a number format with leading zeros. Here is
    an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This prints the contents of the array using the `NumberFormat` instance `form`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: You can also construct a `DecimalFormat` with a particular pattern or change
    the pattern dynamically using `applyPattern()`. Some of the more common pattern
    characters are shown in [Table 5-2](#javacook-numbers-TABLE-2).
  prefs: []
  type: TYPE_NORMAL
- en: Table 5-2\. DecimalFormat pattern characters
  prefs: []
  type: TYPE_NORMAL
- en: '| Character | Meaning |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `#` | Numeric digit (leading zeros suppressed) |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | Numeric digit (leading zeros provided) |'
  prefs: []
  type: TYPE_TB
- en: '| . | Locale-specific decimal separator (decimal point) |'
  prefs: []
  type: TYPE_TB
- en: '| , | Locale-specific grouping separator (comma in English) |'
  prefs: []
  type: TYPE_TB
- en: '| `-` | Locale-specific negative indicator (minus sign) |'
  prefs: []
  type: TYPE_TB
- en: '| `%` | Shows the value as a percentage |'
  prefs: []
  type: TYPE_TB
- en: '| `;` | Separates two formats: the first for positive and the second for negative
    values |'
  prefs: []
  type: TYPE_TB
- en: '| '' | Escapes one of the above characters so it appears |'
  prefs: []
  type: TYPE_TB
- en: '| Anything else | Appears as itself |'
  prefs: []
  type: TYPE_TB
- en: 'The `NumFormatDemo` program uses one `DecimalFormat` to print a number with
    only two decimal places and a second to format the number according to the default
    locale:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This program prints the given pattern and then formats the same number using
    several formats:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Human-readable number formatting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To print a number in what Linux/Unix calls “human readable format” (many display
    commands accept `a -h` argument for this format), use the Java 12 `CompactNumberFormat`,
    as shown in [Example 5-3](#javacook-numbers-EX-cnf).
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-3\. nmain/src/main/java/numbers/CompactFormatDemo.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Roman numeral formatting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To work with roman numerals, use my `RomanNumberFormat` class, as in this demo:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Running `RomanNumberSimple` in 2020 produces this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The source of the `RomanNumberFormat` class is in *src/main/java/numbers/RomanNumberFormat.java*.
    Several of the public methods are required because I wanted it to be a subclass
    of `Format`, which is abstract. This accounts for some of the complexity, like
    having three different format methods.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `RomanNumberFormat.parseObject( )` method is also required, but
    the code doesn’t implement parsing in this version.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*[Java I/O](http://shop.oreilly.com/product/9780596527501.do)* by Elliotte
    Harold (O’Reilly) includes an entire chapter on `NumberFormat` and develops the
    subclass `ExponentialNumberFormat`.'
  prefs: []
  type: TYPE_NORMAL
- en: 5.6 Converting Among Binary, Octal, Decimal, and Hexadecimal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to display an integer as a series of bits—for example, when interacting
    with certain hardware devices—or in some alternative number base (binary is base
    2, octal is base 8, decimal is 10, hexadecimal is 16). You want to convert a binary
    number or a hexadecimal value into an integer.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The class `java.lang.Integer` provides the solutions. Most of the time you can
    use `Integer.parseInt(String input, int radix)` to convert from any type of number
    to an `Integer`, and `Integer.toString(int input, int radix)` to go the other
    way. [Example 5-4](#javacook-recipe-FILE) shows some examples of using the `Integer`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-4\. main/src/main/java/numbers/IntegerBinOctHexEtc.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This program prints the binary string as an integer in various bases, and the
    integer 42 in those same number bases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are also specialized versions of `toString(int)` that don’t require you
    to specify the radix, for example, `toBinaryString()` to convert an integer to
    binary, `toHexString()` for hexadecimal, `toOctalString()`, and so on. The javadoc
    page for the `Integer` class is your friend here.
  prefs: []
  type: TYPE_NORMAL
- en: The `String` class itself includes a series of static methods—`valueOf(int)`,
    `val⁠ue​Of(double)`, and so on—that also provide default formatting. That is,
    they return the given numeric value formatted as a string.
  prefs: []
  type: TYPE_NORMAL
- en: 5.7 Operating on a Series of Integers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to work on a range of integers.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For a contiguous set, use `IntStream::range` and `rangeClosed`, or the older
    `for` loop.
  prefs: []
  type: TYPE_NORMAL
- en: For discontinuous ranges of numbers, use a `java.util.BitSet`.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To process a contiguous set of integers, Java provides both `range()` / `rangeClosed()`
    methods in the `IntStream` and `LongStream` classes. These take a starting and
    ending number; `range()` excludes the ending number while `rangeClosed()` closes
    on, or includes, the ending number. You can also iterate over a range of numbers
    using the traditional `for` loop. Loop control for the `for` loop is in three
    parts: initialize, test, and change. If the test part is initially false, the
    loop will never be executed, not even once. You can iterate over the elements
    of an array or collection (see [Chapter 7](ch07.html#javacook-structure)) using
    a for-each loop.'
  prefs: []
  type: TYPE_NORMAL
- en: The program in [Example 5-5](#javacook-numbers-EX-NUMBER) demonstrates these
    techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-5\. main/src/main/java/numbers/NumSeries.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 5.8 Formatting with Correct Plurals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You’re printing something like `"We used " + n + " items"`, but in English,
    “We used 1 items” is ungrammatical. You want “We used 1 item.”
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use a `ChoiceFormat` or a conditional statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use Java’s ternary operator (`cond ? trueval` : `falseval`) in a string concatenation.
    Both zero and plurals get an “s” appended to the noun in English (“no books, one
    book, two books”), so we test for `n==1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Does it work?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The final `println` statement is effectively equivalent to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This is a lot longer, so the ternary conditional operator is worth learning.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ChoiceFormat` is ideal for this. It is actually capable of much more,
    but here I’ll show only this simplest use. I specify the values 0, 1, and 2 (or
    more), and the string values to print corresponding to each number. The numbers
    are then formatted according to the range they fall into:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This generates the same output as the basic version. It is slightly longer,
    but more general, and lends itself better to internationalization.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to `ChoiceFormat`, the same result can be achieved with a `MessageFormat`.
    The online source in file *main/src/main/java/i18n/MessageFormatDemo.java* has
    an example.
  prefs: []
  type: TYPE_NORMAL
- en: 5.9 Generating Random Numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to generate pseudorandom numbers in a hurry.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use `java.lang.Math.random()` to generate random numbers. There is no claim
    that the random values it returns are very *good* random numbers, however. Like
    most software-only implementations, these are *Pseudorandom Number Generators*
    (PRNGs), meaning that the numbers are not totally random, but devised from an
    algorithm. That said, they are adequate for casual use. This code exercises the
    `random()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that this method only generates double values. If you need integers, construct
    a `java.util.Random` object and call its `nextInt()` method; if you pass it an
    integer value, this will become the upper bound. Here I generate integers from
    1 to 10:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'To see if my `RandomInt` demo was really working well, I used the Unix tools
    *sort* and *uniq*, which together give a count of how many times each value was
    chosen. For 1,000 integers, each of 10 values should be chosen about 100 times.
    I ran it twice to get a better idea of the distribution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The next step is to run these through a statistical program to see how really
    random they are; we’ll return to this in a minute.
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, to generate random numbers, you need to construct a `java.util.Random`
    object (not just any old random object) and call its `next*()` methods. These
    methods include `nextBoolean()`, `nextBytes()` (which fills the given array of
    bytes with random values), `nextDouble()`, `nextFloat()`, `nextInt()`, and `nextLong()`.
    Don’t be confused by the capitalization of `Float`, `Double`, etc. They return
    the primitive types `boolean`, `float`, `double`, etc., not the capitalized wrapper
    objects. Clear enough? Maybe an example will help:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: A fixed value (*starting seed*) can be provided to generate repeatable values,
    as for testing. You can also use the `java.util.Random nextGaussian()` method,
    as shown next. The `nextDouble()` methods try to give a flat distribution between
    0 and 1.0, in which each value has an equal chance of being selected. A Gaussian
    or normal distribution is a bell curve of values from negative infinity to positive
    infinity, with the majority of the values around zero (0.0).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: To illustrate the different distributions, I generated 10,000 numbers using
    `nextRandom()` first and then using `nextGaussian()`. The code for this is in
    *Random4.java* (not shown here) and is a combination of the previous programs
    with code to print the results into files. I then plotted histograms using the
    R statistics package (see [Chapter 11](ch11.html#javacook-ds) and [*http://www.r-project.org*](http://www.r-project.org)).
    The R script used to generate the graph, *randomnesshistograms.r*, is in *javasrc*
    under *main/src/main/resources*. The results are shown in [Figure 5-1](#javacook-numbers-FIG-1).
  prefs: []
  type: TYPE_NORMAL
- en: Looks like both PRNGs do their job!
  prefs: []
  type: TYPE_NORMAL
- en: '![jcb4 0501](assets/jcb4_0501.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-1\. Flat (left) and Gaussian (right) distributions
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The javadoc documentation for `java.util.Random`, and the warning in [Recipe
    5.0](#javacook-numbers-intro) about pseudorandomness versus real randomness.
  prefs: []
  type: TYPE_NORMAL
- en: For cryptographic use, see class `java.security.SecureRandom`, which provides
    cryptographically strong pseudorandom number generators.
  prefs: []
  type: TYPE_NORMAL
- en: 5.10 Multiplying Matrices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to multiply a pair of two-dimensional arrays, as is common in mathematical
    and engineering applications.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the following code as a model.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is straightforward to multiply an array of a numeric type. In real life you
    would probably use a full-blown package such as the [Efficient Java Matrix Library
    (EJML)](http://ejml.org/wiki/index.php?title=Main_Page) or DeepLearning4Java’s
    [ND4J package](https://deeplearning4j.org/docs/latest/nd4j-overview). However
    a simple implementation can serve to show the concepts involved; the code in [Example 5-6](#javacook-numbers-EX-3)
    implements matrix multiplication.
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-6\. Matrix.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a program that uses the `Matrix` class to multiply two arrays of `int`s:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Consult a book on numerical methods for more things to do with matrices; one
    of our reviewers recommends the series of *Numerical Recipes* books, available
    from [*http://nrbook.com*](http://nrbook.com). (Note that this site has a link
    to their new web presence, [*https://numerical.recipes*](https://numerical.recipes)
    however, that site requires Adobe Flash, which most browsers no longer support
    due to security concerns.) There are several translations of the book’s code into
    various languages, including [Java](http://numerical.recipes/aboutJava.html).
    Pricing varies by package.
  prefs: []
  type: TYPE_NORMAL
- en: Commercial software packages can do some of these calculations for you; for
    one example, see the numeric libraries available from [Rogue Wave Software](http://www.roguewave.com).
  prefs: []
  type: TYPE_NORMAL
- en: 5.11 Using Complex Numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to manipulate complex numbers, as is common in mathematical, scientific,
    or engineering applications.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Java does not provide any explicit support for dealing with complex numbers.
    You could keep track of the real and imaginary parts and do the computations yourself,
    but that is not a very well-structured solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'A better solution, of course, is to use a class that implements complex numbers.
    I once wrote just such a class, but now I recommend using the Apache Commons Math
    library for this. The build coordinates for this are `org.apache.commons:commons-math3:3.6.1`
    (or later). First, an example of using Apache’s library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this demo program produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 5-7](#javacook-numbers-EX-4) is the source for my version of the `Complex`
    class and shouldn’t require much explanation. The Apache one is admittedly more
    sophisticated, but I leave mine here just to demystify the basic operation of
    complex numbers.'
  prefs: []
  type: TYPE_NORMAL
- en: To keep the API general, I provide—for each of add, subtract, and multiply—both
    a static method that works on two complex objects and a nonstatic method that
    applies the operation to the given object and one other object.
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-7\. main/src/main/java/numbers/Complex.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 5.12 Handling Very Large Numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to handle integer numbers larger than `Long.MAX_VALUE` or floating-point
    values larger than `Double.MAX_VALUE`.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the `BigInteger` or `BigDecimal` values in package `java.math`, as shown
    in [Example 5-8](#javacook-recipe-BigNums).
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-8\. main/src/main/java/numbers/BigNums.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Note that the constructor takes the number as a string. Obviously you couldn’t
    just type the numeric digits because, by definition, these classes are designed
    to represent numbers larger than will fit in a Java `long`.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Both `BigInteger` and `BigDecimal` objects are immutable; that is, once constructed,
    they always represent a given number. That said, a number of methods return new
    objects that are mutations of the original, such as `negate()`, which returns
    the negative of the given `BigInteger` or `BigDecimal`. There are also methods
    corresponding to most of the Java language built-in operators defined on the base
    types `int`/`long` and `float`/`double`. The division method makes you specify
    the rounding method; consult a book on numerical analysis for details. [Example 5-9](#javacook-numbers-EX-5)
    is a simple stack-based calculator using `BigDecimal` as its numeric data type.
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-9\. main/src/main/java/numbers/BigNumCalc.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this produces the expected (very large) value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The current version has its inputs hardcoded, as does the JUnit test program,
    but in real life you can use regular expressions to extract words or operators
    from an input stream (as in [Recipe 4.5](ch04.html#javacook-regex-SECT-5)), or
    you can use the `StreamTokenizer` approach of the simple calculator (see [Recipe
    10.5](ch10.html#javacook-io-SECT-4)). The stack of numbers is maintained using
    a `java.util.Stack` (see [Recipe 7.16](ch07.html#javacook-structure-SECT-14)).
  prefs: []
  type: TYPE_NORMAL
- en: '`BigInteger` is mainly useful in cryptographic and security applications. Its
    method `isProbablyPrime()` can create prime pairs for public key cryptography.
    `BigDecimal` might also be useful in computing the size of the universe.'
  prefs: []
  type: TYPE_NORMAL
- en: '5.13 Program: TempConverter'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The program shown in [Example 5-10](#javacook-numbers-EX-6) prints a table of
    Fahrenheit temperatures (still used in daily weather reporting in the US and its
    territories, Liberia, and some countries in the Caribbean) and the corresponding
    Celsius temperatures (used in science everywhere and in daily life in the rest
    of the world).
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-10\. main/src/main/java/numbers/TempConverter.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This works, but these numbers print with about 15 digits of (useless) decimal
    fractions! The second version of this program subclasses the first and uses `printf`
    (see [Recipe 10.4](ch10.html#javacook-io-SECT-3)) to control the formatting of
    the converted temperatures (see [Example 5-11](#javacook-numbers-EX-7)). It will
    now look right, assuming you’re printing in a monospaced font.
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-11\. main/src/main/java/numbers/TempConverter2.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '5.14 Program: Number Palindromes'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'My wife, Betty, recently reminded me of a theorem that I must have studied
    in high school but whose name I have long since forgotten: that any positive integer
    number can be used to generate a palindrome by adding to it the number comprised
    of its digits in reverse order. Palindromes are sequences that read the same in
    either direction, such as the name “Anna” or the phrase “Madam, I’m Adam” (ignoring
    spaces and punctuation). We normally think of palindromes as composed of text,
    but the concept can be applied to numbers: 13,531 is a palindrome. Start with
    the number 72, for example, and add to it the number 27\. The results of this
    addition is 99, which is a (short) palindrome. Starting with 142, add 241, and
    you get 383\. Some numbers take more than one try to generate a palindrome. 1,951
    + 1,591 yields 3,542, which is not palindromic. The second round, however, 3,542
    + 2,453, yields 5,995, which is. The number 17,892, which my son Benjamin picked
    out of the air, requires 12 rounds to generate a palindrome, but it does terminate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'If this sounds to you like a natural candidate for recursion, you are correct.
    *Recursion* involves dividing a problem into simple and identical steps that can
    be implemented by a function that calls itself and provides a way of termination.
    Our basic approach, as shown in method `findPalindrome`, is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: That is, if the starting number is already a palindromic number, return it;
    otherwise, add it to its reverse, and try again. The version of the code shown
    here handles simple cases directly (single digits are always palindromic, for
    example). We won’t think about negative numbers because these have a character
    at the front that loses its meaning if placed at the end, and hence are not strictly
    palindromic. Further, palindromic forms of certain numbers are too long to fit
    in Java’s 64-bit `long` integer. These cause underflow, which is trapped. As a
    result, an error message like “too big” is reported.^([3](ch05.html#idm45290676556776))
    Having said all that, [Example 5-12](#javacook-numbers-EX-9) shows the code.
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-12\. main/src/main/java/numbers/Palindrome.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'While it’s not strictly a numerical solution, Daniel Hinojosa noted that you
    can use `StringBuilder` to do the reversal portion, resulting in shorter, more
    elegant code that is only fractionally slower:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: A full version of his code is in the file *PalindromeViaStringBuilder.java*.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: People using Java in scientific or large-scale numeric computing may wish to
    check out the value types forthcoming from [“Project Valhalla” in Java](https://wiki.openjdk.java.net/display/valhalla/Main).
    See also a 2019 presentation titled [“Vectors and Numerics on the JVM”](https://www.youtube.com/watch?v=UlnoCj4B8pU).
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch05.html#idm45290682381560-marker)) For a low-cost source of randomness,
    check out the now-defunct [Lavarand](http://en.wikipedia.org/wiki/Lavarand). The
    process used digitized video of 1970s lava lamps to provide “hardware-based” randomness.
    Fun!
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch05.html#idm45290681215064-marker)) Note that an expression consisting
    entirely of compile-time constants, like `Math.PI \* 2.1e17`, is also considered
    to be Strict-FP.
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch05.html#idm45290676556776-marker)) Certain values do not work; for example,
    Ashish Batia reported that this version gets an exception on the value 8,989 (which
    it does).
  prefs: []
  type: TYPE_NORMAL
