<html><head></head><body><section data-pdf-bookmark="Chapter 8. Static Methods to Top-Level Functions" data-type="chapter" epub:type="chapter"><div class="chapter" id="static-methods-to-top-level-functions">&#13;
<h1><span class="label">Chapter 8. </span>Static Methods to Top-Level Functions</h1>&#13;
&#13;
<blockquote data-type="epigraph" epub:type="epigraph">&#13;
<p>Standalone functions are one of the fundamental building blocks of software.&#13;
They have to be declared as methods on a class in Java, but in Kotlin we can declare them as top-level entities.&#13;
When should we prefer top-level functions, and how do we refactor our way there from Java?</p>&#13;
</blockquote>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Java Statics" data-type="sect1"><div class="sect1" id="idm46393399167704">&#13;
<h1>Java Statics</h1>&#13;
&#13;
<p>All<a data-primary="static methods to top-level functions" data-secondary="Java statics" data-type="indexterm" id="idm46393399165752"/><a data-primary="members" data-type="indexterm" id="idm46393399164728"/><a data-primary="fields" data-type="indexterm" id="idm46393399164056"/><a data-primary="methods" data-type="indexterm" id="idm46393399163384"/><a data-primary="Java" data-secondary="static methods in" data-type="indexterm" id="idm46393399162712"/> values and functions in a Java program have to belong to a class: they are <em>members</em> of that class.&#13;
Java calls member-values <em>fields</em>, and member-functions <em>methods</em>.&#13;
By default, fields values are per-instance of the class: different instances have different values.&#13;
Methods are also per-instance in that they have access to the state of the instance that they are invoked on.&#13;
If we mark fields as <code>static</code>, though, they are shared between all instances of the class.&#13;
Static methods only have access to this shared state (and visible static fields in other classes), but in return for this restriction, we can invoke them without needing an instance of the class.</p>&#13;
&#13;
<p>To<a data-primary="class-scoped static state" data-type="indexterm" id="idm46393399159160"/> simplify Java, the language designers tied all code and data to classes.&#13;
We have class-scoped static state, so we need class-scoped static methods.&#13;
They could have added freestanding data and functions, but static fields and methods will do.&#13;
If the language had options, then developers would have to choose between them, and less choice is often better.&#13;
The designers then carried this language design decision forward to the Java Virtual Machine, which in turn has no way to express top-level code or data.</p>&#13;
<aside class="pagebreak-before less_space" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46393399157672">&#13;
<h5>Static State</h5>&#13;
<p>In<a data-primary="static state" data-type="indexterm" id="idm46393399155912"/> the early days of Java, static state was a lot more common than it is today.&#13;
We wrote singletons and argued about how to initialize them in a lazy but safe way.&#13;
We used static fields to implement per-class caches of instances.&#13;
Then the new millennium fad for testing code all but killed static state.&#13;
That’s because it’s very difficult to isolate one test from another when they are coupled by state, and very hard to uncouple them when that state is static and so shared between all tests in a JVM.&#13;
(Note that <em>state</em> here refers to mutable data. Immutable data—constants—are less of a problem.)</p>&#13;
&#13;
<p>So we learned to keep otherwise static state in object fields and used dependency injection to arrange for there to be only one shared instance of the object in our application.&#13;
(When we say “dependency injection” here, your authors mean “passing an object to a constructor” rather than the use of a framework.)</p>&#13;
&#13;
<p>In this chapter, we’ll focus on code rather than state.</p>&#13;
</div></aside>&#13;
&#13;
<p>Sometimes we have a class with both nonstatic and static methods acting on the same type—for example, the email class with a static parsing method we saw in <a data-type="xref" href="ch03.html#java-to-kotlin-classes">Chapter 3</a>.&#13;
Often, though, we end up with a class composed of only static methods.&#13;
When there is no static state for them to share, these methods are really just stand-alone functions grouped together and called via their class name, like the methods from the <code>java.util.Collections</code> class, for example:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="n">var</code> <code class="n">max</code> <code class="o">=</code> <code class="n">Collections</code><code class="o">.</code><code class="na">max</code><code class="o">(</code><code class="n">list</code><code class="o">);</code></pre>&#13;
&#13;
<p>Amazingly, the industry didn’t really notice how much of a pain that <code>Collections.</code> prefix was for a while.&#13;
This was because we wrote our programs by adding more and more methods to types that we owned, so we rarely needed static functions.&#13;
Static functions are useful when we want to add functionality <em>without</em> adding a method to the type that they act on.&#13;
This might be because our classes are already sagging under the weight of all the methods that we have already added to them, or because we don’t own the class and so can’t add the method to it.&#13;
Another reason for using static functions rather than methods is because the functionality only applies to some instantiations of a generic type, so it cannot be declared as a member of the generic.&#13;
That <code>Collections.max</code>, for example, only applies to a collection with comparable elements.</p>&#13;
&#13;
<p>Over time, we began to appreciate the advantages of using standard interfaces, like the Java collections, instead of working with our own abstractions.&#13;
Java 5 (with its generics) was the first release that allowed us to use collections directly rather than wrapping them with our own classes.&#13;
It’s no accident then that Java 5 also brought the ability to <code>import static java.util.Collections.max</code> so that we could then write:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="n">var</code> <code class="n">m</code> <code class="o">=</code> <code class="n">max</code><code class="o">(</code><code class="n">list</code><code class="o">);</code></pre>&#13;
&#13;
<p>Note that this is really only a convenience provided by the compiler, because the JVM still only actually supports static methods rather than true top-level functions.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Kotlin Top-Level Functions, Objects, and Companions" data-type="sect1"><div class="sect1" id="idm46393399167080">&#13;
<h1>Kotlin Top-Level Functions, Objects, and Companions</h1>&#13;
&#13;
<p>Kotlin<a data-primary="static methods to top-level functions" data-secondary="top-level functions, objects, and companions" data-type="indexterm" id="idm46393399127592"/> allows functions (and properties and constants) to be declared outside of classes.&#13;
In this case, because the JVM has nowhere else for them to go, the compiler generates a class with static members for these top-level declarations.&#13;
By default, it derives the name of the class from the name of the file defining the functions.&#13;
For example, functions defined in <code>top-level.kt</code> end up as static methods on a class called <code>Top_levelKt</code>.&#13;
If we know the name of the class, we can reference it from Java by either static importing <code>Top_LevelKt.foo</code> or directly invoking <code>Top_levelKt.foo()</code>.&#13;
If we don’t like the ugliness of <code>Top_LevelKt</code>, we can explicitly name the generated class by adding an annotation, <code>@file:JvmName</code>, to the top of the file, as we’ll see later in this chapter.</p>&#13;
&#13;
<p>As well as these top-level functions, Kotlin also allows us to define properties and functions scoped, like Java statics, to a class rather than an instance.&#13;
Instead<a data-primary="object declarations" data-type="indexterm" id="idm46393399122840"/> of just marking these as <code>static</code>, Kotlin borrows from Scala and collects them into <code>object</code> declarations.&#13;
This type of <code>object</code> declaration (as opposed to the <code>object</code> expression that creates anonymous types) defines a singleton: a type with only one instance that provides a global point of access to that instance.&#13;
All the members of an <code>object</code> will be compiled to members of a class with the name of the object.&#13;
They won’t actually be static methods unless specifically marked with <code>@JvmStatic</code>, though.&#13;
This is because Kotlin allows these objects to extend classes and implement interfaces, and that is incompatible with static declarations.</p>&#13;
&#13;
<p>When we need to group static and nonstatic members in the same class, we can declare the static parts in a <code>companion object</code> inside the (otherwise nonstatic) class declaration.&#13;
This groups them in the file, and code in a companion object can access private state in instances of its containing class.&#13;
Companion objects can also extend another class and implement interfaces—something that Java statics cannot do.&#13;
Compared to Java statics though, companion objects are cumbersome if we just want to define one or two static methods.</p>&#13;
&#13;
<p>In Kotlin, then, we can write non-instance-scoped functions as either top-level functions or methods on a singleton object, and this object may be a companion object or not scoped to a type.</p>&#13;
&#13;
<p>Of these, all things being equal, we should default to top-level functions.&#13;
They are the simplest to declare and reference, and can be moved from file to file within a package without affecting Kotlin client code (but see the caveat in <a data-type="xref" href="#moving-top-level-functions">“Moving Top-Level Functions”</a>).&#13;
We reserve declaring functions as methods on a singleton object instead of top-level functions for when we need the ability to implement an interface, or otherwise group functions more tightly.&#13;
We use a companion object when we need to mix static and nonstatic behavior within a class, or to write factory methods with names like <code>MyType.of(...)</code>.</p>&#13;
&#13;
<p>As with many aspects of programming, we start with the simplest thing that could work, which is usually a top-level function, and refactor to a more complicated solution only when it brings benefits, such as a more expressive API for our clients, or better maintainability for us.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Refactoring from Static Methods to Top-Level Functions" data-type="sect1"><div class="sect1" id="idm46393399090648">&#13;
<h1>Refactoring from Static Methods to Top-Level Functions</h1>&#13;
&#13;
<p>While<a data-primary="static methods to top-level functions" data-secondary="refactoring" data-type="indexterm" id="SMTFref08"/><a data-primary="refactoring" data-secondary="static methods to top-level functions" data-type="indexterm" id="Rstatic08"/> we prefer to use top-level declarations, the Java to Kotlin conversion built into IntelliJ doesn’t.&#13;
It converts our Java statics into object methods.&#13;
Let’s see how to refactor from Java, through object declarations, to top-level functions.</p>&#13;
&#13;
<p>At Travelator, we allow our customers to build shortlists, such as a shortlist of routes when planning their trip, or a shortlist of hotel rooms on those routes.&#13;
The user can rank items in a shortlist by different criteria and discard items to narrow down the results to a final choice.&#13;
Following the guidance in <a data-type="xref" href="ch06.html#dont-mutate-shared-collections">“Don’t Mutate Shared Collections”</a>, a shortlist is stored as an immutable list.&#13;
The functions for manipulating a shortlist (returning a modified copy rather than mutating the list) are implemented as static methods of the <code>Shortlists</code> class:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">class</code> <code class="nc">Shortlists</code> <code class="o">{</code>&#13;
    <code class="kd">public</code> <code class="kd">static</code> <code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code> <code class="n">List</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code> <code class="n">sorted</code><code class="o">(</code>&#13;
        <code class="n">List</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code> <code class="n">shortlist</code><code class="o">,</code>&#13;
        <code class="n">Comparator</code><code class="o">&lt;?</code> <code class="kd">super</code> <code class="n">T</code><code class="o">&gt;</code> <code class="n">ordering</code>&#13;
    <code class="o">)</code> <code class="o">{</code>&#13;
        <code class="k">return</code> <code class="n">shortlist</code><code class="o">.</code><code class="na">stream</code><code class="o">()</code>&#13;
            <code class="o">.</code><code class="na">sorted</code><code class="o">(</code><code class="n">ordering</code><code class="o">)</code>&#13;
            <code class="o">.</code><code class="na">collect</code><code class="o">(</code><code class="n">toUnmodifiableList</code><code class="o">());</code>&#13;
    <code class="o">}</code>&#13;
&#13;
    <code class="kd">public</code> <code class="kd">static</code> <code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code> <code class="n">List</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code> <code class="n">removeItemAt</code><code class="o">(</code><code class="n">List</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code> <code class="n">shortlist</code><code class="o">,</code> <code class="kt">int</code> <code class="n">index</code><code class="o">)</code> <code class="o">{</code>&#13;
        <code class="k">return</code> <code class="n">Stream</code><code class="o">.</code><code class="na">concat</code><code class="o">(</code>&#13;
            <code class="n">shortlist</code><code class="o">.</code><code class="na">stream</code><code class="o">().</code><code class="na">limit</code><code class="o">(</code><code class="n">index</code><code class="o">),</code>&#13;
            <code class="n">shortlist</code><code class="o">.</code><code class="na">stream</code><code class="o">().</code><code class="na">skip</code><code class="o">(</code><code class="n">index</code> <code class="o">+</code> <code class="mi">1</code><code class="o">)</code>&#13;
        <code class="o">).</code><code class="na">collect</code><code class="o">(</code><code class="n">toUnmodifiableList</code><code class="o">());</code>&#13;
    <code class="o">}</code>&#13;
&#13;
    <code class="kd">public</code> <code class="kd">static</code> <code class="n">Comparator</code><code class="o">&lt;</code><code class="n">HasRating</code><code class="o">&gt;</code> <code class="nf">byRating</code><code class="o">()</code> <code class="o">{</code>&#13;
        <code class="k">return</code> <code class="nf">comparingDouble</code><code class="o">(</code><code class="nl">HasRating:</code><code class="o">:</code><code class="n">getRating</code><code class="o">).</code><code class="na">reversed</code><code class="o">();</code>&#13;
    <code class="o">}</code>&#13;
&#13;
    <code class="kd">public</code> <code class="kd">static</code> <code class="n">Comparator</code><code class="o">&lt;</code><code class="n">HasPrice</code><code class="o">&gt;</code> <code class="nf">byPriceLowToHigh</code><code class="o">()</code> <code class="o">{</code>&#13;
        <code class="k">return</code> <code class="nf">comparing</code><code class="o">(</code><code class="nl">HasPrice:</code><code class="o">:</code><code class="n">getPrice</code><code class="o">);</code>&#13;
    <code class="o">}</code>&#13;
&#13;
    <code class="o">...</code> <code class="n">and</code> <code class="n">other</code> <code class="n">comparators</code>&#13;
<code class="o">}</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=8.1&amp;show=file">Example 8.1 [static-to-top-level.0:src/main/java/travelator/Shortlists.java]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=8.1&amp;show=diff">(diff)</a>&#13;
</div>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46393398680280">&#13;
<h5>Convenience Functions</h5>&#13;
<p><code>sorted</code> and <code>removeItemAt</code> are<a data-primary="sorted function" data-type="indexterm" id="idm46393398678216"/><a data-primary="removeItemAt function" data-type="indexterm" id="idm46393398677480"/> complicated for what they do.&#13;
Nat discovered Kotlin after watching Duncan try to use the Java Streams API to analyze some publishing data.&#13;
He was so horrified at the difficulty of performing basic operations that he went looking for a JVM language that would ease the pain.&#13;
It certainly seems that although the Java APIs have improved recently, for many years the designers seemed to have had a policy of never knowingly adding a convenience function.</p>&#13;
&#13;
<p>In contrast, the Kotlin standard library seems to go out of its way to provide functionality just where and when we need it, often in the form of extension functions (<a data-type="xref" href="ch10.html#functions-to-extension-functions">Chapter 10</a>) on existing types.</p>&#13;
</div></aside>&#13;
&#13;
<p>The functions in <code>Shortlists</code> are static methods, and have to be referenced as such.&#13;
Spelled out longhand, this looks like:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="n">var</code> <code class="n">reordered</code> <code class="o">=</code> <code class="n">Shortlists</code><code class="o">.</code><code class="na">sorted</code><code class="o">(</code><code class="n">items</code><code class="o">,</code> <code class="n">Shortlists</code><code class="o">.</code><code class="na">byValue</code><code class="o">());</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=8.2&amp;show=file">Example 8.2 [static-to-top-level.5:src/test/java/travelator/ShortlistsTest.java]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=8.2&amp;show=diff">(diff)</a>&#13;
</div>&#13;
&#13;
<p>We usually <code>static import</code> the methods though, and they are named to read better that way:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="n">var</code> <code class="n">reordered</code> <code class="o">=</code> <code class="n">sorted</code><code class="o">(</code><code class="n">items</code><code class="o">,</code> <code class="n">byPriceLowToHigh</code><code class="o">());</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=8.3&amp;show=file">Example 8.3 [static-to-top-level.5:src/test/java/travelator/ShortlistsTest.java]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=8.3&amp;show=diff">(diff)</a>&#13;
</div>&#13;
&#13;
<p>Converting the Java to Kotlin with IntelliJ we get:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">object</code> <code class="nc">Shortlists</code> <code class="p">{</code>&#13;
    <code class="n">@JvmStatic</code>&#13;
    <code class="k">fun</code> <code class="err">&lt;</code><code class="nf">T</code><code class="p">&gt;</code> <code class="n">sorted</code><code class="p">(</code><code class="n">shortlist</code><code class="p">:</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;,</code> <code class="n">ordering</code><code class="p">:</code> <code class="n">Comparator</code><code class="p">&lt;</code><code class="k">in</code> <code class="n">T</code><code class="p">&gt;):</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;</code> <code class="p">{</code>&#13;
        <code class="k">return</code> <code class="n">shortlist</code><code class="p">.</code><code class="n">stream</code><code class="p">().</code><code class="n">sorted</code><code class="p">(</code><code class="n">ordering</code><code class="p">)</code>&#13;
            <code class="p">.</code><code class="n">collect</code><code class="p">(</code><code class="n">toUnmodifiableList</code><code class="p">())</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="n">@JvmStatic</code>&#13;
    <code class="k">fun</code> <code class="err">&lt;</code><code class="nf">T</code><code class="p">&gt;</code> <code class="n">removeItemAt</code><code class="p">(</code><code class="n">shortlist</code><code class="p">:</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;,</code> <code class="n">index</code><code class="p">:</code> <code class="n">Int</code><code class="p">):</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;</code> <code class="p">{</code>&#13;
        <code class="k">return</code> <code class="n">Stream</code><code class="p">.</code><code class="n">concat</code><code class="p">(</code>&#13;
            <code class="n">shortlist</code><code class="p">.</code><code class="n">stream</code><code class="p">().</code><code class="n">limit</code><code class="p">(</code><code class="n">index</code><code class="p">.</code><code class="n">toLong</code><code class="p">()),</code>&#13;
            <code class="n">shortlist</code><code class="p">.</code><code class="n">stream</code><code class="p">().</code><code class="n">skip</code><code class="p">((</code><code class="n">index</code> <code class="p">+</code> <code class="m">1</code><code class="p">).</code><code class="n">toLong</code><code class="p">())</code>&#13;
        <code class="p">).</code><code class="n">collect</code><code class="p">(</code><code class="n">toUnmodifiableList</code><code class="p">())</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="n">@JvmStatic</code>&#13;
    <code class="k">fun</code> <code class="nf">byRating</code><code class="p">():</code> <code class="n">Comparator</code><code class="p">&lt;</code><code class="n">HasRating</code><code class="p">&gt;</code> <code class="p">{</code>&#13;
        <code class="k">return</code> <code class="n">comparingDouble</code><code class="p">(</code><code class="n">HasRating</code><code class="o">::</code><code class="n">rating</code><code class="p">).</code><code class="n">reversed</code><code class="p">()</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="n">@JvmStatic</code>&#13;
    <code class="k">fun</code> <code class="nf">byPriceLowToHigh</code><code class="p">():</code> <code class="n">Comparator</code><code class="p">&lt;</code><code class="n">HasPrice</code><code class="p">&gt;</code> <code class="p">{</code>&#13;
        <code class="k">return</code> <code class="n">comparing</code><code class="p">(</code><code class="n">HasPrice</code><code class="o">::</code><code class="n">price</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="p">...</code> <code class="n">and</code> <code class="n">other</code> <code class="n">comparators</code>&#13;
<code class="p">}</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=8.4&amp;show=file">Example 8.4 [static-to-top-level.5:src/main/java/travelator/Shortlists.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=8.4&amp;show=diff">(diff)</a>&#13;
</div>&#13;
&#13;
<p>Actually, that isn’t quite true.&#13;
At the time of writing, the converter added some spurious nullability to types, undid static imports (leaving us with <code>Collectors.to​Un⁠modi⁠fiableList()</code>, for example), and managed to create an imports list that didn’t compile.&#13;
Fixing up the file manually gives us confidence that the machines won’t take our jobs for a few years yet.</p>&#13;
&#13;
<p>In <a data-type="xref" href="ch03.html#java-to-kotlin-classes">Chapter 3</a>, we saw that converting a Java class with static <em>and</em> nonstatic methods produced a Kotlin class with a companion object.&#13;
Here the conversion has produced only a top-level object.&#13;
Because this Java class had no nonstatic methods or state, there is no need for the Kotlin translation to include an instantiable class.&#13;
Classes with both static and nonstatic methods are less suitable for conversion to top-level functions.</p>&#13;
&#13;
<p>While the conversion didn’t go completely smoothly at the Kotlin level, on the plus side, no Java code was harmed in the process.&#13;
The client code remains unchanged, because the <code>@JvmStatic</code> annotations allow Java code to see the methods as static methods on a <code>Shortlists</code> class, as they were before the conversion.</p>&#13;
&#13;
<p>We want to convert the methods to be top-level functions, but we can’t just move them, because Java only understands methods, not functions.&#13;
If these functions were compiled to methods on a class called <code>Shortlists</code>, Java would be happy, and that is the job of the <code>@file:JvmName</code> annotation we mentioned earlier.&#13;
We can manually add the annotation at the top of the file, and remove the <code>object</code> scope and <code>@JvmStatic</code> annotations to get:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="n">@file</code><code class="p">:</code><code class="n">JvmName</code><code class="p">(</code><code class="s">"Shortlists"</code><code class="p">)</code>&#13;
<code class="k">package</code> <code class="nn">travelator</code>&#13;
&#13;
<code class="p">...</code>&#13;
&#13;
<code class="k">fun</code> <code class="err">&lt;</code><code class="nf">T</code><code class="p">&gt;</code> <code class="n">sorted</code><code class="p">(</code><code class="n">shortlist</code><code class="p">:</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;,</code> <code class="n">ordering</code><code class="p">:</code> <code class="n">Comparator</code><code class="p">&lt;</code><code class="k">in</code> <code class="n">T</code><code class="p">&gt;):</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="n">shortlist</code><code class="p">.</code><code class="n">stream</code><code class="p">().</code><code class="n">sorted</code><code class="p">(</code><code class="n">ordering</code><code class="p">)</code>&#13;
        <code class="p">.</code><code class="n">collect</code><code class="p">(</code><code class="n">toUnmodifiableList</code><code class="p">())</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="k">fun</code> <code class="err">&lt;</code><code class="nf">T</code><code class="p">&gt;</code> <code class="n">removeItemAt</code><code class="p">(</code><code class="n">shortlist</code><code class="p">:</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;,</code> <code class="n">index</code><code class="p">:</code> <code class="n">Int</code><code class="p">):</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="n">Stream</code><code class="p">.</code><code class="n">concat</code><code class="p">(</code>&#13;
        <code class="n">shortlist</code><code class="p">.</code><code class="n">stream</code><code class="p">().</code><code class="n">limit</code><code class="p">(</code><code class="n">index</code><code class="p">.</code><code class="n">toLong</code><code class="p">()),</code>&#13;
        <code class="n">shortlist</code><code class="p">.</code><code class="n">stream</code><code class="p">().</code><code class="n">skip</code><code class="p">((</code><code class="n">index</code> <code class="p">+</code> <code class="m">1</code><code class="p">).</code><code class="n">toLong</code><code class="p">())</code>&#13;
    <code class="p">).</code><code class="n">collect</code><code class="p">(</code><code class="n">toUnmodifiableList</code><code class="p">())</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="p">...</code> <code class="n">etc</code><code class="p">.</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=8.5&amp;show=file">Example 8.5 [static-to-top-level.6:src/main/java/travelator/Shortlists.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=8.5&amp;show=diff">(diff)</a>&#13;
</div>&#13;
&#13;
<p>This keeps our Java happy, but irritatingly, it breaks some Kotlin code that was calling the methods.&#13;
Here, for example, are the imports for a test:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">import</code> <code class="nn">org.junit.jupiter.api.Test</code>&#13;
<code class="k">import</code> <code class="nn">travelator.Shortlists.byPriceLowToHigh</code>&#13;
<code class="k">import</code> <code class="nn">travelator.Shortlists.byRating</code>&#13;
<code class="k">import</code> <code class="nn">travelator.Shortlists.byRelevance</code>&#13;
<code class="k">import</code> <code class="nn">travelator.Shortlists.byValue</code>&#13;
<code class="k">import</code> <code class="nn">travelator.Shortlists.removeItemAt</code>&#13;
<code class="k">import</code> <code class="nn">travelator.Shortlists.sorted</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=8.6&amp;show=file">Example 8.6 [static-to-top-level.6:src/test/java/travelator/hotels/ShortlistScenarioTest.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=8.6&amp;show=diff">(diff)</a>&#13;
</div>&#13;
&#13;
<p>These were importing the static Java methods, but Kotlin can’t import its own top-level functions in the same way, so these lines fail with <code>Unresolved reference: Shortlists</code>.&#13;
As far as Kotlin is concerned, the functions are defined in the scope of the package, not in a class in that package.&#13;
The compiler may compile them to static methods of a JVM class called <code>ShortlistsKt</code>, but that class is an implementation detail of how the compiler maps Kotlin language concepts to the JVM platform and is not visible to our Kotlin code at compile time.</p>&#13;
&#13;
<p>We could go through all the compilation errors and manually fix the imports to refer to the function at package scope.&#13;
For example, we would have to change <code>import</code> &#13;
<span class="keep-together"><code>travelator.Shortlists.sorted</code></span> to <code>import travelator.sorted</code>.&#13;
This is easy enough if the change affects a few files, but if the change has had a wide impact, fixing all the imports is a tedious job, albeit one that <em>might</em> be achieved with a single global search and replace.</p>&#13;
&#13;
<p>Luckily, while we were writing this book, IntelliJ gained a “Move to top level” refactoring.&#13;
Let’s revert the last Kotlin change, back to the object declaration, and try again.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Move to Top Level" data-type="sect1"><div class="sect1" id="idm46393399089704">&#13;
<h1>Move to Top Level</h1>&#13;
&#13;
<p>As we write this, the refactoring is so new that it isn’t available on the refactoring menu, but Alt-Enter on an object method name gives the option “Move to top level”.&#13;
We’ll do <code>sorted</code> first.&#13;
IntelliJ moves the method out of the object scope to the file level:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="n">@JvmStatic</code>&#13;
<code class="k">fun</code> <code class="err">&lt;</code><code class="nf">T</code><code class="p">&gt;</code> <code class="n">sorted</code><code class="p">(</code><code class="n">shortlist</code><code class="p">:</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;,</code> <code class="n">ordering</code><code class="p">:</code> <code class="n">Comparator</code><code class="p">&lt;</code><code class="k">in</code> <code class="n">T</code><code class="p">&gt;):</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="n">shortlist</code><code class="p">.</code><code class="n">stream</code><code class="p">().</code><code class="n">sorted</code><code class="p">(</code><code class="n">ordering</code><code class="p">)</code>&#13;
        <code class="p">.</code><code class="n">collect</code><code class="p">(</code><code class="n">toUnmodifiableList</code><code class="p">())</code>&#13;
<code class="p">}</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=8.7&amp;show=file">Example 8.7 [static-to-top-level.7:src/main/java/travelator/Shortlists.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=8.7&amp;show=diff">(diff)</a>&#13;
</div>&#13;
&#13;
<p>Unfortunately, it failed to remove the <code>@JvmStatic</code> annotation, so we have to delete that ourselves to get the code to compile.&#13;
Once we do, we find that it has at least fixed up the callers, which was the problem we had when we just moved the method ourselves.&#13;
Where we explicitly referenced the method in Java as <code>ShortLists.sorted</code>, we now have:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="n">var</code> <code class="n">reordered</code> <code class="o">=</code> <code class="n">ShortlistsKt</code><code class="o">.</code><code class="na">sorted</code><code class="o">(</code><code class="n">items</code><code class="o">,</code> <code class="n">Shortlists</code><code class="o">.</code><code class="na">byValue</code><code class="o">());</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=8.8&amp;show=file">Example 8.8 [static-to-top-level.8:src/test/java/travelator/ShortlistsTest.java]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=8.8&amp;show=diff">(diff)</a>&#13;
</div>&#13;
&#13;
<p>For some reason, where we had a static import, things have become worse:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="n">var</code> <code class="n">reordered</code> <code class="o">=</code> <code class="n">travelator</code><code class="o">.</code><code class="na">ShortlistsKt</code><code class="o">.</code><code class="na">sorted</code><code class="o">(</code><code class="n">items</code><code class="o">,</code> <code class="n">byPriceLowToHigh</code><code class="o">());</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=8.9&amp;show=file">Example 8.9 [static-to-top-level.8:src/test/java/travelator/ShortlistsTest.java]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=8.9&amp;show=diff">(diff)</a>&#13;
</div>&#13;
&#13;
<p>We can fix that with Alt-Enter and “Add on demand static import…”.&#13;
We have to do that once in each affected file; we should have checked in before the refactor so that we could easily see which files it changed:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="n">var</code> <code class="n">reordered</code> <code class="o">=</code> <code class="n">sorted</code><code class="o">(</code><code class="n">items</code><code class="o">,</code> <code class="n">byPriceLowToHigh</code><code class="o">());</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=8.10&amp;show=file">Example 8.10 [static-to-top-level.9:src/test/java/travelator/ShortlistsTest.java]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=8.10&amp;show=diff">(diff)</a>&#13;
</div>&#13;
&#13;
<p>Compared to our previous manual approach of adding an <code>@file:JvmName("Shortlists")</code> annotation, our Java clients are now exposed to that icky <code>ShortlistsKt</code> name.&#13;
Because the methods names were designed to be used with static imports though, it is almost always hidden in the imports block where no one ever looks, so we’re prepared to put up with this.&#13;
In return for this sacrifice, the conversion has also fixed up the Kotlin callers of <code>sorted</code>.&#13;
It is now referenced in Kotlin as <code>travelator.sorted</code> rather than <code>travalator.Shortlists.sorted</code>, which was the point.</p>&#13;
&#13;
<p>We can now move the rest of the methods on <code>Shortlists</code> in the same way.&#13;
It’s a little tedious, but at least when it moves the last method, IntelliJ deletes the empty object, leaving us:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="err">&lt;</code><code class="nf">T</code><code class="p">&gt;</code> <code class="n">sorted</code><code class="p">(</code><code class="n">shortlist</code><code class="p">:</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;,</code> <code class="n">ordering</code><code class="p">:</code> <code class="n">Comparator</code><code class="p">&lt;</code><code class="k">in</code> <code class="n">T</code><code class="p">&gt;):</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="n">shortlist</code><code class="p">.</code><code class="n">stream</code><code class="p">().</code><code class="n">sorted</code><code class="p">(</code><code class="n">ordering</code><code class="p">)</code>&#13;
        <code class="p">.</code><code class="n">collect</code><code class="p">(</code><code class="n">toUnmodifiableList</code><code class="p">())</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="k">fun</code> <code class="err">&lt;</code><code class="nf">T</code><code class="p">&gt;</code> <code class="n">removeItemAt</code><code class="p">(</code><code class="n">shortlist</code><code class="p">:</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;,</code> <code class="n">index</code><code class="p">:</code> <code class="n">Int</code><code class="p">):</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="n">Stream</code><code class="p">.</code><code class="n">concat</code><code class="p">(</code>&#13;
        <code class="n">shortlist</code><code class="p">.</code><code class="n">stream</code><code class="p">().</code><code class="n">limit</code><code class="p">(</code><code class="n">index</code><code class="p">.</code><code class="n">toLong</code><code class="p">()),</code>&#13;
        <code class="n">shortlist</code><code class="p">.</code><code class="n">stream</code><code class="p">().</code><code class="n">skip</code><code class="p">((</code><code class="n">index</code> <code class="p">+</code> <code class="m">1</code><code class="p">).</code><code class="n">toLong</code><code class="p">())</code>&#13;
    <code class="p">).</code><code class="n">collect</code><code class="p">(</code><code class="n">toUnmodifiableList</code><code class="p">())</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="k">fun</code> <code class="nf">byRating</code><code class="p">():</code> <code class="n">Comparator</code><code class="p">&lt;</code><code class="n">HasRating</code><code class="p">&gt;</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="n">comparingDouble</code><code class="p">(</code><code class="n">HasRating</code><code class="o">::</code><code class="n">rating</code><code class="p">).</code><code class="n">reversed</code><code class="p">()</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="k">fun</code> <code class="nf">byPriceLowToHigh</code><code class="p">():</code> <code class="n">Comparator</code><code class="p">&lt;</code><code class="n">HasPrice</code><code class="p">&gt;</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="n">comparing</code><code class="p">(</code><code class="n">HasPrice</code><code class="o">::</code><code class="n">price</code><code class="p">)</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="p">...</code> <code class="n">and</code> <code class="n">other</code> <code class="n">comparators</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=8.11&amp;show=file">Example 8.11 [static-to-top-level.10:src/main/java/travelator/Shortlists.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=8.11&amp;show=diff">(diff)</a>&#13;
</div>&#13;
&#13;
<p>As we write this, the “Move to top level” refactor is limited to a single method at a time.&#13;
If methods depend on each other, this can lead to some problems, as we will see in <a data-type="xref" href="ch10.html#functions-to-extension-functions">Chapter 10</a>.<a data-primary="" data-startref="SMTFref08" data-type="indexterm" id="idm46393397822392"/><a data-primary="" data-startref="Rstatic08" data-type="indexterm" id="idm46393397821416"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Kotlinify" data-type="sect1"><div class="sect1" id="idm46393398135176">&#13;
<h1>Kotlinify</h1>&#13;
&#13;
<p>Of<a data-primary="static methods to top-level functions" data-secondary="idiomatic Kotlin" data-type="indexterm" id="idm46393397818584"/> course, we didn’t move our methods to top-level functions just for the sake of it.&#13;
Well, not <em>just</em> for the sake of it anyway.&#13;
Now that our functions are in the idiomatic Kotlin place, let’s finish the idiomatic Kotlin job.</p>&#13;
&#13;
<p><a data-type="xref" href="ch13.html#streams-to-sequences">Chapter 13</a> gives<a data-primary="sortedWith extension function" data-type="indexterm" id="idm46393397815720"/> guidance on converting Java streams to Kotlin; in the case of <code>sorted</code>, we can just use the Kotlin <code>sortedWith</code> extension function:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="err">&lt;</code><code class="nf">T</code><code class="p">&gt;</code> <code class="n">sorted</code><code class="p">(</code><code class="n">shortlist</code><code class="p">:</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;,</code> <code class="n">ordering</code><code class="p">:</code> <code class="n">Comparator</code><code class="p">&lt;</code><code class="k">in</code> <code class="n">T</code><code class="p">&gt;):</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="n">shortlist</code><code class="p">.</code><code class="n">sortedWith</code><code class="p">(</code><code class="n">ordering</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=8.12&amp;show=file">Example 8.12 [static-to-top-level.11:src/main/java/travelator/Shortlists.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=8.12&amp;show=diff">(diff)</a>&#13;
</div>&#13;
&#13;
<p>This makes a very logical extension function (<a data-type="xref" href="ch10.html#functions-to-extension-functions">Chapter 10</a>):</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="err">&lt;</code><code class="nf">T</code><code class="p">&gt;</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;.</code><code class="n">sorted</code><code class="p">(</code><code class="n">ordering</code><code class="p">:</code> <code class="n">Comparator</code><code class="p">&lt;</code><code class="k">in</code> <code class="n">T</code><code class="p">&gt;):</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="n">sortedWith</code><code class="p">(</code><code class="n">ordering</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=8.13&amp;show=file">Example 8.13 [static-to-top-level.12:src/main/java/travelator/Shortlists.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=8.13&amp;show=diff">(diff)</a>&#13;
</div>&#13;
&#13;
<p>Java still calls this as a static method:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="n">var</code> <code class="n">reordered</code> <code class="o">=</code> <code class="n">sorted</code><code class="o">(</code><code class="n">items</code><code class="o">,</code> <code class="n">byPriceLowToHigh</code><code class="o">());</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=8.14&amp;show=file">Example 8.14 [static-to-top-level.12:src/test/java/travelator/ShortlistsTest.java]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=8.14&amp;show=diff">(diff)</a>&#13;
</div>&#13;
&#13;
<p>Calling from Kotlin reads nicely too:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">val</code> <code class="py">hotelsByPrice</code> <code class="p">=</code> <code class="n">hotels</code><code class="p">.</code><code class="n">sorted</code><code class="p">(</code><code class="n">byPriceLowToHigh</code><code class="p">())</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=8.15&amp;show=file">Example 8.15 [static-to-top-level.12:src/test/java/travelator/hotels/ShortlistScenarioTest.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=8.15&amp;show=diff">(diff)</a>&#13;
</div>&#13;
&#13;
<p class="pagebreak-before">These Kotlin usages really aren’t gaining us anything over the raw Kotlin API, so we can just inline them:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">val</code> <code class="py">hotelsByPrice</code> <code class="p">=</code> <code class="n">hotels</code><code class="p">.</code><code class="n">sortedWith</code><code class="p">(</code><code class="n">byPriceLowToHigh</code><code class="p">())</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=8.16&amp;show=file">Example 8.16 [static-to-top-level.13:src/test/java/travelator/hotels/ShortlistScenarioTest.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=8.16&amp;show=diff">(diff)</a>&#13;
</div>&#13;
&#13;
<p>This leaves the <code>sorted</code> function for Java to call.&#13;
Looking at it, it really has nothing to do with shortlists anymore.&#13;
Should we move it to a more generic namespace?&#13;
Maybe later; for now we’ll just follow through on the rest of the file to give:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="err">&lt;</code><code class="nf">T</code><code class="p">&gt;</code> <code class="n">Iterable</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;.</code><code class="n">sorted</code><code class="p">(</code><code class="n">ordering</code><code class="p">:</code> <code class="n">Comparator</code><code class="p">&lt;</code><code class="k">in</code> <code class="n">T</code><code class="p">&gt;):</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;</code> <code class="p">=</code>&#13;
    <code class="n">sortedWith</code><code class="p">(</code><code class="n">ordering</code><code class="p">)</code>&#13;
&#13;
<code class="k">fun</code> <code class="err">&lt;</code><code class="nf">T</code><code class="p">&gt;</code> <code class="n">Iterable</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;.</code><code class="n">withoutItemAt</code><code class="p">(</code><code class="n">index</code><code class="p">:</code> <code class="n">Int</code><code class="p">):</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;</code> <code class="p">=</code>&#13;
    <code class="n">take</code><code class="p">(</code><code class="n">index</code><code class="p">)</code> <code class="p">+</code> <code class="n">drop</code><code class="p">(</code><code class="n">index</code> <code class="p">+</code> <code class="m">1</code><code class="p">)</code>&#13;
&#13;
<code class="k">fun</code> <code class="nf">byRating</code><code class="p">():</code> <code class="n">Comparator</code><code class="p">&lt;</code><code class="n">HasRating</code><code class="p">&gt;</code> <code class="p">=</code>&#13;
    <code class="n">comparingDouble</code><code class="p">(</code><code class="n">HasRating</code><code class="o">::</code><code class="n">rating</code><code class="p">).</code><code class="n">reversed</code><code class="p">()</code>&#13;
&#13;
<code class="k">fun</code> <code class="nf">byPriceLowToHigh</code><code class="p">():</code> <code class="n">Comparator</code><code class="p">&lt;</code><code class="n">HasPrice</code><code class="p">&gt;</code> <code class="p">=</code>&#13;
    <code class="n">comparing</code><code class="p">(</code><code class="n">HasPrice</code><code class="o">::</code><code class="n">price</code><code class="p">)</code>&#13;
&#13;
<code class="p">...</code> <code class="n">and</code> <code class="n">other</code> <code class="n">comparators</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=8.17&amp;show=file">Example 8.17 [static-to-top-level.14:src/main/java/travelator/Shortlists.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=8.17&amp;show=diff">(diff)</a>&#13;
</div>&#13;
&#13;
<p>You may have noticed that we have renamed <code>removeItemAt</code> to <code>withoutItemAt</code>.&#13;
Prepositions like <em>with</em> and <em>without</em> are a useful device to let the reader know that we are not mutating an object but returning a copy.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="moving-top-level-functions">&#13;
<h5>Moving Top-Level Functions</h5>&#13;
<p>The <code>withoutItemAt</code> Kotlin function looks to be useful, and we wonder why we can’t find a version in the standard library.&#13;
Now that it is a top-level function, we can move it out of <code>Shortlists.kt</code> to a different file in the same package without changing the Kotlin source that calls it.&#13;
If we do though, that function will now be defined as a static method of a different JVM class in the compiled output.</p>&#13;
&#13;
<p>If we publish Kotlin library code in a JAR file, all is fine provided dependent code is recompiled against the new version.&#13;
The Kotlin compiler generates class files with metadata sections that let it map Kotlin names to JVM classes and methods.&#13;
All may <em>not</em> be fine if dependent code uses our JAR as a binary dependency, and upgrades without recompiling.&#13;
The JVM doesn’t use the metadata that the Kotlin compiler generated.&#13;
If a top-level function has moved from one class to another between versions of a binary dependency, dependent code can find a <code>NoSuchMethodError</code> thrown at &#13;
<span class="keep-together">runtime</span>.</p>&#13;
&#13;
<p class="pagebreak-before">We can use the <code>@JvmMultifileClass</code> and <code>@JvmName</code> annotations to control how our top-level declarations appear in JVM class files, so that moving declarations between source files won’t break binary compatibility.&#13;
However, none of our Kotlin test or example code will have changed, so we can’t rely on them to warn us about this kind of breakage.&#13;
We just have to take extra care if we move top-level functions published in a library, or use tools to check binary compatibility for us.</p>&#13;
</div></aside>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Moving On" data-type="sect1"><div class="sect1" id="idm46393397819560">&#13;
<h1>Moving On</h1>&#13;
&#13;
<p>Static functions are the bread and butter of our programs.&#13;
In Java these have to be static methods on a class, but in Kotlin we can and should default to defining them as top-level functions.</p>&#13;
&#13;
<p>Automatically converting a Java class of static methods to Kotlin will create an <code>object</code> declaration, accessible from both Java and Kotlin.&#13;
We can then move the methods on the object to the top level individually, remaining accessible to both languages, before applying other refactorings to take advantage of more Kotliny goodness.</p>&#13;
&#13;
<p>The most likely next refactor is to refactor our top-level functions into extension functions, the subject of <a data-type="xref" data-xrefstyle="chap-num-title" href="ch10.html#functions-to-extension-functions">Chapter 10, <em>Functions to Extension Functions</em></a>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section></body></html>