<html><head></head><body><section data-pdf-bookmark="Chapter 1. Reactive in a Nutshell" data-type="chapter" epub:type="chapter"><div class="chapter" id="introduction">&#13;
<h1><span class="label">Chapter 1. </span>Reactive in a Nutshell</h1>&#13;
&#13;
&#13;
<p><em>Reactive</em> is an overloaded word.&#13;
You may have searched for <em>reactive</em> with a search engine to understand what it’s all about.&#13;
If you haven’t, no worries—you’ve saved yourself a lot of confusion.&#13;
There are many <em>reactive things</em>: Reactive Systems, Reactive Programming, Reactive extensions, Reactive messaging.&#13;
Every day new ones pop up.&#13;
Are all these “reactives” the same reactive?&#13;
Are they different?</p>&#13;
&#13;
<p>These are the questions we are going to answer in this chapter.&#13;
We are going to sneak a peek at the reactive landscape to identify and help you understand the various nuances of <em>reactive</em>, what they mean, the concepts associated with them, and how they relate to one another.&#13;
Because yes, without spoiling too much, all these “reactives” are related.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>As noted in the preface, we use the noun <em>Reactive</em>, with an uppercase <em>R</em>, to aggregate all the various facets of the reactive landscape, such as reactive programming, reactive systems, reactive streams, and so on.</p>&#13;
</div>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="What Do We Mean by Reactive?" data-type="sect1"><div class="sect1" id="idm45358844111568">&#13;
<h1>What Do We Mean by Reactive?</h1>&#13;
&#13;
<p><a data-primary="reactive (term)" data-type="indexterm" id="idm45358844110160"/>Let’s start at the beginning.&#13;
Forget about software and IT for a few minutes, and use an old-fashioned approach.&#13;
If we look for <em>reactive</em> in the <a href="https://oreil.ly/nL7Fp"><em>Oxford English Dictionary</em></a>, we find the following definition:</p>&#13;
<blockquote>&#13;
<p><em>reactive</em>&#13;
(adjective)</p>&#13;
&#13;
<p>Showing a response to a stimulus.&#13;
1.1 Acting in response to a situation rather than creating or controlling it.&#13;
1.2 Having a tendency to react chemically.&#13;
1.3 (Physiology) Showing an immune response to a specific antigen.&#13;
1.4 (Of a disease or illness) Caused by a reaction to something.&#13;
1.5 (Physics) Relating to reactance.</p></blockquote>&#13;
&#13;
<p>Among these definitions, two are relevant in our context.&#13;
The first definition, <em>showing a response to a stimulus</em>, refers to some kind of reaction.&#13;
Being reactive means reacting to stimuli, whatever they are.&#13;
Subdefinition 1.1 says that being reactive is also about facing unexpected and uncontrolled situations.&#13;
You will see throughout this book that cloud native applications, and distributed systems in general, face plenty of these kinds of situations. While these definitions are interesting, they don’t apply to software.&#13;
<a data-primary="Reactive" data-secondary="defined" data-type="indexterm" id="idm45358844104800"/>But we can take these definitions into account to make a new one specific to software:</p>&#13;
<blockquote>&#13;
<p>1.6 (Software) An application reacting to stimuli, such as user events, requests,&#13;
and failures.</p></blockquote>&#13;
&#13;
<p>Yet, as you will see in this book, today’s <em>reactive</em> goes beyond this.&#13;
Reactive is an approach to designing, implementing, and reasoning about your system in terms of events and flows. Reactive is about building <em>responsive</em>, <em>resilient</em>, and <em>elastic</em> applications.&#13;
Reactive is also about resource utilization through efficient management of resources and communication. To put it another way: Reactive is about designing and building better distributed systems—more robust and more efficient.&#13;
We call them <em>reactive systems</em>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Reactive Software Is Not New" data-type="sect1"><div class="sect1" id="idm45358844099712">&#13;
<h1>Reactive Software Is Not New</h1>&#13;
&#13;
<p><a data-primary="Reactive" data-secondary="foundation of ideas behind" data-type="indexterm" id="idm45358844098512"/>But wait, the definition (1.6) we just gave is not groundbreaking.&#13;
On the contrary, you may feel some déjà vu, no? Isn’t the nature of software to <em>react</em> to user inputs and operating system signals?&#13;
How does software behave when you hit a keystroke? It reacts.&#13;
So, why are there so many books, talks, and debates about Reactive if it’s just regular software?<sup><a data-type="noteref" href="ch01.html#idm45358844096576" id="idm45358844096576-marker">1</a></sup>&#13;
Please be patient; there is a bit more to it.</p>&#13;
&#13;
<p>But you are right; Reactive is <em>not</em> new.&#13;
It’s actually pretty old.&#13;
We can track the foundation of the ideas behind reactive software to just after the appearance of computers in the ’50s.&#13;
The <a href="https://oreil.ly/ehP7l">DYSEAC</a>, a first-generation computer (in operation in 1954), was already using hardware interrupts as an optimization, eliminating waiting time in polling loops.&#13;
This computer was one of the first systems to use reactive and event-driven architecture!</p>&#13;
&#13;
<p>Reacting to events implies being event-driven.&#13;
<a data-primary="event-driven software" data-type="indexterm" id="idm45358844092544"/><em>Event-driven software</em> receives and produces events.&#13;
The received events determine the flow of the program.&#13;
<a data-primary="asynchronousity, event-driven software and" data-type="indexterm" id="idm45358844091456"/>A fundamental aspect of being event-driven is asynchronicity: you don’t know when you are going to receive events.<sup><a data-type="noteref" href="ch01.html#idm45358844090400" id="idm45358844090400-marker">2</a></sup>&#13;
That is precisely definition 1.1 from the previous section.&#13;
You cannot plan when you will receive events, are not in control of which events you will get, and you need to be prepared to handle them. That’s the essence of being reactive: being asynchronous.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The Reactive Landscape" data-type="sect1"><div class="sect1" id="idm45358844088160">&#13;
<h1>The Reactive Landscape</h1>&#13;
&#13;
<p><a data-primary="Reactive" data-secondary="landscape" data-type="indexterm" id="ix_introduction-adoc0"/>From this idea of being asynchronous and event-driven, many forms of <em>Reactive</em> have emerged.&#13;
The reactive landscape is broad and crowded. <a data-type="xref" href="#image:landscape">Figure 1-1</a> depicts an excerpt of this landscape and the relationships among the main <em>reactive things</em>.</p>&#13;
&#13;
<figure><div class="figure" id="image:landscape">&#13;
<img alt="The reactive landscape" src="assets/rsij_0101.png"/>&#13;
<h6><span class="label">Figure 1-1. </span>The reactive landscape</h6>&#13;
</div></figure>&#13;
&#13;
<p>But don’t forget our objective: building better distributed systems—reactive systems.&#13;
The other “reactives” are here to help us implement these systems.</p>&#13;
&#13;
<p>The reasons for Reactive, and reactive systems in particular, come from distributed systems.&#13;
As you will see in <a data-type="xref" href="ch03.html#distributed-system">Chapter 3</a>, building distributed systems is hard.&#13;
<a data-primary="&quot;The Reactive Manifesto&quot;" data-primary-sortas="Reactive Manifesto" data-type="indexterm" id="idm45358844079456"/>In 2013, distributed system experts wrote the first version of <a href="https://oreil.ly/6z8mt">“The Reactive Manifesto”</a> and introduced the concept of reactive systems.</p>&#13;
&#13;
<p>Yes, you can build distributed systems without applying reactive principles.&#13;
Reactive provides a blueprint to ensure that no significant known concerns were overlooked while architecting and developing your system.&#13;
On the other hand, you can apply these principles on nondistributed systems.</p>&#13;
&#13;
<p><a data-primary="reactive systems" data-secondary="characteristics of" data-type="indexterm" id="ix_introduction-adoc1"/>A reactive system is first and foremost responsive.&#13;
It must handle requests in a timely fashion even under load or when facing failures.&#13;
To achieve this responsiveness, the manifesto proposes using asynchronous message passing as the primary way to communicate between the components forming the system.&#13;
You will see in <a data-type="xref" href="ch04.html#reactive-systems">Chapter 4</a> how this communication method enables elasticity and resilience, two essential attributes of solid distributed systems.&#13;
The objective of this book is to show you how to build such reactive systems with Quarkus.&#13;
So, building reactive systems is our primary goal.</p>&#13;
&#13;
<p><a data-primary="asynchronous message passing" data-secondary="requirements for" data-type="indexterm" id="idm45358844073504"/>Infusing asynchronous message passing at the core of distributed systems does not come without consequences.&#13;
Your application needs to use asynchronous code and nonblocking I/O, the ability provided by the operating system to enqueue I/O interactions without having to actively wait for the completion. (We cover nonblocking I/Os in <a data-type="xref" href="ch04.html#reactive-systems">Chapter 4</a>).&#13;
The latter is essential to improve resource utilization, such as CPU and memory, another important aspect of Reactive.&#13;
Today, many toolkits and frameworks, such as Quarkus, <a href="https://vertx.io">Eclipse Vert.x</a>, <a href="https://micronaut.io">Micronaut</a>, <a href="https://helidon.io">Helidon</a>, and <a href="https://netty.io">Netty</a>, are using nonblocking I/O for this very reason: doing more with limited resources.</p>&#13;
&#13;
<p>Yet having a runtime leveraging nonblocking I/O is not enough to be reactive.&#13;
You also need to write asynchronous code embracing the nonblocking I/O mechanics.&#13;
Otherwise, the resource utilization benefits would vanish.&#13;
Writing asynchronous code is a paradigm shift.&#13;
From the traditional (imperative), <code>do x; do y;</code>, you are now going to shape your code as <code>on event(e) do x; on event(f) do y;</code>.&#13;
In other words, to be reactive, not only is your system an event-driven architecture, but also your code is going to become event-driven.&#13;
<a data-primary="callbacks" data-type="indexterm" id="idm45358844066336"/>One of the most straightforward approaches to implementing such code is callbacks: you register functions invoked when events are received.&#13;
Like futures, promises, and coroutines, every other approach is based on callbacks and offers higher-level APIs.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>You may wonder why spreadsheets are in the landscape.&#13;
Spreadsheets are reactive.&#13;
When you write a formula in a cell and change a value read (in another cell) by the formula, the result of this formula is updated.&#13;
The cell reacts to the update of a value (event), and the outcome (reaction) is the new result.&#13;
Yes, your manager may be a better reactive developer than you are!&#13;
But don’t worry, this book will change this.</p>&#13;
</div>&#13;
&#13;
<p>Reactive programming, addressed in <a data-type="xref" href="ch05.html#reactive-programming">Chapter 5</a>, is also an approach to writing asynchronous code.&#13;
It uses data streams to structure your code.&#13;
You observe the data transiting in these streams and react to it.&#13;
Reactive programming provides a powerful abstraction and APIs to shape event-driven code.</p>&#13;
&#13;
<p>But using data streams comes with an issue.&#13;
If you have a fast producer directly connected to a slow consumer, you may flood the consumer.&#13;
As you will see, we can buffer or use a message broker in between, but imagine flooding a consumer without them.&#13;
That would be against the responsiveness and anti-fragile ideas promoted by Reactive.&#13;
<a data-primary="backpressure" data-secondary="Reactive Streams and" data-type="indexterm" id="idm45358844061472"/><a data-primary="Reactive Streams" data-secondary="backpressure and" data-type="indexterm" id="idm45358844060496"/>To help us with that particular issue, <a href="https://oreil.ly/5c275">Reactive Streams</a> proposes an asynchronous and nonblocking backpressure protocol where the consumer signals to the producer its availability.&#13;
As you can imagine, this may not be applicable everywhere, as some data sources cannot be slowed down.</p>&#13;
&#13;
<p>The popularity of Reactive Streams has increased over the past few years. For example, <a href="https://rsocket.io">RSocket</a> is a network protocol based on Reactive Streams. <a href="https://r2dbc.io">R2DBC</a> proposes asynchronous database access using Reactive Streams. Also, <a href="https://oreil.ly/QNEOJ">RxJava</a>, <a href="https://oreil.ly/eUHAL">Project Reactor</a>, and <a href="https://oreil.ly/A17fF">SmallRye Mutiny</a> adopted reactive streams to handle backpressure. Finally, Vert.x allows mapping the Vert.x backpressure model to Reactive Streams<a data-startref="ix_introduction-adoc1" data-type="indexterm" id="idm45358839697120"/>.<sup><a data-type="noteref" href="ch01.html#idm45358839696288" id="idm45358839696288-marker">3</a></sup></p>&#13;
&#13;
<p>That concludes our quick tour of the reactive landscape.&#13;
As we said, it’s crowded with many terms, and many tools.&#13;
But never lose sight of the overall objective of Reactive: to build better distributed systems.&#13;
That’s the primary focus of this book.<a data-startref="ix_introduction-adoc0" data-type="indexterm" id="idm45358839694384"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Why Are Reactive Architectures So Well-Suited for Cloud Native Applications?" data-type="sect1"><div class="sect1" id="idm45358844087568">&#13;
<h1>Why Are Reactive Architectures So Well-Suited for Cloud Native Applications?</h1>&#13;
&#13;
<p><a data-primary="cloud native applications" data-secondary="Reactive architectures and" data-type="indexterm" id="idm45358839692304"/><a data-primary="Reactive" data-secondary="cloud native applications and" data-type="indexterm" id="idm45358839691344"/>The cloud—public, private, or hybrid—has put Reactive in the spotlight.&#13;
The cloud is a distributed system.&#13;
When you run your application on the cloud, that application faces a high degree of uncertainty.&#13;
The provisioning of your application can be slow, or fast, or even fail.&#13;
Communication disruptions are common, because of network failures or partitions.&#13;
You may hit quota restrictions, resource shortages, and &#13;
<span class="keep-together">hardware</span> failures.&#13;
Some services you are using can be unavailable at times or moved to other locations.</p>&#13;
&#13;
<p>While the cloud provides outstanding facilities for the infrastructure layer, it covers only half of the story.&#13;
The second half is your application.&#13;
It needs to be designed to be a part of a distributed system.&#13;
It needs to understand the challenges of being part of such a system.</p>&#13;
&#13;
<p>The reactive principles we cover in this book help to embrace the inherent uncertainty and challenges of distributed systems and cloud applications.&#13;
It won’t hide them—to the contrary, it embraces them.</p>&#13;
&#13;
<p>As microservices and <a href="https://oreil.ly/IH6wY">serverless computing</a> are becoming prominent architectural styles, the reactive principles become even more important.&#13;
They can help ensure that you design your system on a solid foundation.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Reactive Is Not a Silver Bullet" data-type="sect1"><div class="sect1" id="idm45358839686144">&#13;
<h1>Reactive Is Not a Silver Bullet</h1>&#13;
&#13;
<p><a data-primary="Reactive" data-secondary="limitations" data-type="indexterm" id="idm45358839685088"/>As with everything, Reactive has pros and cons.&#13;
It’s not a magic weapon.&#13;
No solution works everywhere.</p>&#13;
&#13;
<p>Remember microservices in the late 2010s?&#13;
They quickly became exceedingly popular, and many organizations implemented them in areas for which they may not have been well-suited.&#13;
This often traded one set of problems for another.&#13;
Much like microservice architectures, reactive architectures have areas in which they are well-suited.&#13;
They shine for distributed and cloud applications but can be disastrous on more monolithic and computation-centric systems.&#13;
If your system relies on remote communication, event processing, or high efficiency, Reactive will be interesting.&#13;
If your system uses mostly in-process interactions, handles just a few requests per day, or is computation-intensive, then Reactive won’t bring anything but complexity.</p>&#13;
&#13;
<p>With Reactive, you put the notion of events at the core of your system.&#13;
If you are used to the traditional synchronous and imperative way of building applications, the path to become reactive can be steep.&#13;
The need to become asynchronous disrupts most traditional frameworks.&#13;
We are moving away from the well-known Remote Procedure Call (RPC) and HTTP endpoints. So, with that disclaimer, it’s time to start our journey!<a data-primary="accessing data" data-see="data access" data-type="indexterm" id="idm45358839681872"/><a data-primary="Apache Kafka" data-see="Kafka" data-type="indexterm" id="idm45358839680896"/><a data-primary="container orchestration" data-see="Kubernetes" data-type="indexterm" id="idm45358839679952"/><a data-primary="monitoring" data-see="observability" data-type="indexterm" id="idm45358839679008"/><a data-primary="Quarkus" data-secondary="reactive engine" data-see="reactive engine" data-type="indexterm" id="idm45358839678064"/><a data-primary="Reactive Messaging" data-secondary="event bus" data-see="event bus" data-type="indexterm" id="idm45358839676848"/><a data-primary="SmallRye Mutiny" data-see="Mutiny" data-type="indexterm" id="idm45358839675632"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<div data-type="footnotes"><p data-type="footnote" id="idm45358844096576"><sup><a href="ch01.html#idm45358844096576-marker">1</a></sup> You can find a <a href="https://oreil.ly/SyGxB">plethora of talks about Reactive on YouTube</a>.</p><p data-type="footnote" id="idm45358844090400"><sup><a href="ch01.html#idm45358844090400-marker">2</a></sup> Asynchronous is the opposite of synchronous. Being <em>asynchronous</em> means happening at a different point in time, while being <em>synchronous</em> means happening at the same time.</p><p data-type="footnote" id="idm45358839696288"><sup><a href="ch01.html#idm45358839696288-marker">3</a></sup> See <a href="https://oreil.ly/t2noI">Vert.x Reactive Streams Integration</a> for more details.</p></div></div></section></body></html>