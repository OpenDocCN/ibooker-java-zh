- en: Chapter 9\. Observability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you’ll learn about observability and why it is important to
    have in the microservices architecture. Observability answers the question of
    how your system is behaving by observing some parameters like error codes, performance,
    or any kind of business metric. Quarkus integrates with several technologies used
    for observability natively.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will include recipes for how to accomplish the following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Define health checks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide metrics to the monitoring system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configure distributed tracing to have an overview of a request inside the mesh
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 9.1 Using Automatic Health Checks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to check whether the service is up and running and able to handle requests
    correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The MicroProfile Health specification provides an API to probe the state of
    a service from another machine (e.g., Kubernetes Controller).
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable MicroProfile Health in a Quarkus application, you need to register
    only the `quarkus-smallrye-health` extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'With the extension in the classpath, Quarkus automatically registers a default
    liveness and readiness probe, which both return `UP` when the service is up and
    running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_observability_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Liveness URL
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_observability_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Status is `UP`
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_observability_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: No checks (just defaults)
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_observability_CO1-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Readiness URL
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The MicroProfile Health specification provides two kinds of health checks:'
  prefs: []
  type: TYPE_NORMAL
- en: Liveness
  prefs: []
  type: TYPE_NORMAL
- en: Returns a 200 OK with result UP if the service has been started, 503 Service
    Unavailable with result DOWN if the service is not live, and 500 Server Error
    if the health check couldn’t be calculated. The liveness probe endpoint is registered
    by default at the */health/live* endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Readiness
  prefs: []
  type: TYPE_NORMAL
- en: Returns a 200 OK with result UP if the service is ready to process requests.
    This is different from the liveness probe because liveness simply means that the
    service is up but might not be able to process any request yet (e.g., because
    it is executing a database migration). A 503 Service Unavailable with result DOWN
    is returned if the service cannot yet accept any request, and a 500 Server Error
    is returned if the health check couldn’t be calculated. The readiness probe endpoint
    is registered by default at the */health/ready* endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: If you are configuring Quarkus to use an SQL database (JDBC), it will automatically
    register a readiness health check (in the `checks` section) that validates that
    the connection to the database is possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following extensions provide automatic readiness/liveness probes:'
  prefs: []
  type: TYPE_NORMAL
- en: Datasource
  prefs: []
  type: TYPE_NORMAL
- en: A readiness probe to check database connection status.
  prefs: []
  type: TYPE_NORMAL
- en: Kafka
  prefs: []
  type: TYPE_NORMAL
- en: A readiness probe to check Kafka connection status. It is disabled by default
    and needs to be enabled by setting `quarkus.kafka.health.enabled` property to
    `true`.
  prefs: []
  type: TYPE_NORMAL
- en: MongoDB
  prefs: []
  type: TYPE_NORMAL
- en: A readiness probe to check MongoDB connection status.
  prefs: []
  type: TYPE_NORMAL
- en: Neo4j
  prefs: []
  type: TYPE_NORMAL
- en: A readiness probe to check Neo4j connection status.
  prefs: []
  type: TYPE_NORMAL
- en: Artemis
  prefs: []
  type: TYPE_NORMAL
- en: A readiness probe to check Artemis JMS connection status.
  prefs: []
  type: TYPE_NORMAL
- en: Kafka Streams
  prefs: []
  type: TYPE_NORMAL
- en: Liveness (for stream state) and readiness (topics created) probes.
  prefs: []
  type: TYPE_NORMAL
- en: Vault
  prefs: []
  type: TYPE_NORMAL
- en: A readiness probe to check Vault status.
  prefs: []
  type: TYPE_NORMAL
- en: 'The automatic generation of the probes can be disabled by setting the `quarkus.*component*.health.enabled`
    to `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To learn more about the MicroProfile Health specification, see the following
    page on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[MicroProfile Health](https://oreil.ly/wZjHC)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 9.2 Creating Custom Health Checks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to customize how to check that a service is up and running and that
    it is able to handle requests correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The MicroProfile Health specification enables you to create custom liveness
    and readiness health checks. In some circumstances, a custom health-check logic
    might be needed for either liveness or readiness probes.
  prefs: []
  type: TYPE_NORMAL
- en: The MicroProfile Health specification allows you to create custom health checks
    by creating a method annotated with `@org.eclipse.microprofile.health.Liveness`
    and `@org.eclipse.microprofile.health.Readiness` and returning an implementation
    of `org.eclipse.microprofile.health.HealthCheck` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new class at `org.acme.quickstart.LivenessCheck.java` to implement
    a custom liveness probe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_observability_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Needs to be a CDI class
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_observability_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets health check as liveness
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_observability_CO2-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Implements `HealthCheck` as a requirement
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_observability_CO2-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets health check name
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](Images/5.png)](#co_observability_CO2-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets result as up
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](Images/6.png)](#co_observability_CO2-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets result as down
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s check that this liveness probe works as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Because health checks are registered as CDI beans, you can also produce health
    checks in factory objects, as explained in [Recipe 5.7](ch05.xhtml#creating_factories).
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new factory class to contain the new health check—in this case, a
    readiness check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_observability_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Needs to be a CDI class
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_observability_CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The method produces a health check
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_observability_CO3-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Readiness probe
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_observability_CO3-4)'
  prefs: []
  type: TYPE_NORMAL
- en: '`HealthStatus` is a utility class that implements the `HealthCheck` interface
    for you'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s check that this readiness probe works as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The MicroProfile Health specification is perfect for defining Kubernetes liveness
    and readiness probes. You can learn about them at the following website:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Kubernetes: Configure Liveness, Readiness, and Startup Probes](https://oreil.ly/nTaaa)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 9.3 Exposing Metrics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to proactively check the current status of a service in production
    by exposing service metrics in order to detect any misbehavior as quickly as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The MicroProfile Metrics specification provides a way to build and expose metrics
    from your application to a monitoring tool (e.g., Prometheus).
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable MicroProfile Metrics in a Quarkus application, you need to register
    only the `quarkus-smallrye-metrics` extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'With the extension in the classpath, Quarkus provides monitoring parameters
    by default, exposing them at the `/metrics` endpoint in Prometheus format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The output format can be changed to JSON by adding `application/json` type
    in the HTTP `Accept` header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Knowing how a service is behaving in microservices architectures is critical
    in anticipating any problem that might affect all your applications.
  prefs: []
  type: TYPE_NORMAL
- en: With monolith applications, monitoring service behavior was fairly easy because
    you had only three or four elements to monitor; but now with (micro)services architectures,
    you might have hundreds of elements to monitor.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many possible values to monitor, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disk space
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JVM resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance of critical methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Business metrics (e.g., the number of payments per second)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overall health of your cluster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you look closely at the output, you’ll see that the parameters are prefixed
    with either `base` or `vendor`. MicroProfile Metrics categorizes the metrics under
    three categories:'
  prefs: []
  type: TYPE_NORMAL
- en: base
  prefs: []
  type: TYPE_NORMAL
- en: The core information of the server. These metrics are always required because
    they are specified in the specification. Access them at */metrics/base*.
  prefs: []
  type: TYPE_NORMAL
- en: vendor
  prefs: []
  type: TYPE_NORMAL
- en: Vendor-specific information. Each implementation might provide different ones.
    Access them at */metrics/vendor*.
  prefs: []
  type: TYPE_NORMAL
- en: application
  prefs: []
  type: TYPE_NORMAL
- en: Custom information developed ad hoc for that service using the MicroProfile
    Metrics extension mechanism. Access them at */metrics/application*.
  prefs: []
  type: TYPE_NORMAL
- en: You can configure where metrics are exposed by setting the `quarkus.smallrye-metrics.path`
    property to the path where you want to expose them. By default, this property
    is set to `/metrics`.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To learn more about MicroProfile Metrics, visit the following page on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Metrics for Eclipse MicroProfile](https://oreil.ly/Q875g)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 9.4 Creating Metrics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to monitor some custom metrics, such as performance metrics or business
    metrics.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The MicroProfile Metrics specification provides different annotations to register
    different kinds of monitoring parameters like counters, durations, and gauges.
    With these annotations, you can create custom metrics that might be related to
    business or performance parameters instead of physical values like memory, and
    CPU.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the MicroProfile Metrics annotations:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Annotation | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '`org.eclipse.microprofile.metrics.annotation.Counted`'
  prefs: []
  type: TYPE_NORMAL
- en: '| Counts number of invocations. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '`org.eclipse.microprofile.metrics.annotation.Timed`'
  prefs: []
  type: TYPE_NORMAL
- en: '| Tracks the duration of invocations. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '`org.eclipse.microprofile.metrics.annotation.SimplyTimed`'
  prefs: []
  type: TYPE_NORMAL
- en: '| Tracks the duration of invocations without mean and distribution calculations.
    A simplified version of `Timed`. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '`org.eclipse.microprofile.metrics.annotation.Metered`'
  prefs: []
  type: TYPE_NORMAL
- en: '| Tracks the frequency of invocations. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '`org.eclipse.microprofile.metrics.annotation.Gauge`'
  prefs: []
  type: TYPE_NORMAL
- en: '| Samples a discrete value of an annotated field or method. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '`org.eclipse.microprofile.metrics.annotation.ConcurrentGauge`'
  prefs: []
  type: TYPE_NORMAL
- en: '| Gauge to count parallel invocations. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '`org.eclipse.microprofile.metrics.annotation.Metric`'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Used to inject a metric. Valid types are `Meter`, `Timer`, `Counter` and `Histogram`.
    `Gauge` with `Metric` can only be used in a CDI producer.
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at how to use metrics annotations and how to create an histogram
    metric.
  prefs: []
  type: TYPE_NORMAL
- en: Counter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *counter* increments invocations that are done to a method annotated with
    `@Counted` and can be used at method or class level.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, the number of invocations of a method is counted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_observability_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Registers the counter
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_observability_CO4-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Name of the counter
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_observability_CO4-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets a display name
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_observability_CO4-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Description of the counter
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s check the counter monitor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Gauge
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A *gauge* is a simple value that you want to expose to be measured, similar
    to a gas gauge on a car. To register it, you need to annotate either a field or
    a method with `@Gauge`, and the value/return value will be exposed automatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_observability_CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Field to store the highest transaction
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_observability_CO5-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Updates the field if the current transaction is higher
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_observability_CO5-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets return value as a gauge
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_observability_CO5-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Name of the gauge
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](Images/5.png)](#co_observability_CO5-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Metrics of this gauge (e.g., seconds, percentage, per second, bytes, etc.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the following commands to run the application, seed some metrics data,
    and view the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Metered
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A *metered* metric measures the rate at which a method is called. The `@Metered`
    annotation can be used at the method or class level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_observability_CO6-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Registers the metered metric
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_observability_CO6-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets units as seconds
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the following commands to run the application, seed some metrics data,
    and view the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Timed
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A *timed* metric measures the duration of a call. The `@Timed` annotation can
    be used at method or class level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_observability_CO7-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Registers the timed metric
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the following commands to run the application, seed some metrics data,
    and view the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Histogram
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A *histogram* measures the distribution of values across time; it measures
    things like min, max, standard deviation, or quantiles like the median or 95th.
    Histograms do not have a proper annotation, but the `org.eclipse.microprofile.metrics.Histogram`
    class is used to update the metric:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_observability_CO8-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Injects a histogram with given name
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_observability_CO8-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Updates the histogram with a new value
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the following commands to run the application, seed some metrics data,
    and view the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can get metadata information from any metric by querying into a specific
    endpoint using the `OPTION` HTTP method. The metadata is exposed at `/metrics/*scope*/*metric_name*`,
    where the *`scope`* is `base`, `vendor`, or `application` and the *`metric_name`*
    is the name of the metric (in case of application one, the one set in `name` attribute).
  prefs: []
  type: TYPE_NORMAL
- en: 9.5 Using Distributed Tracing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to profile and monitor the whole application.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The MicroProfile OpenTracing specification uses the [OpenTracing standard API](https://opentracing.io)
    for instrumenting microservices for distributed tracing. Quarkus integrates with
    the MicroProfile OpenTracing specification as a solution for distributed tracing.
  prefs: []
  type: TYPE_NORMAL
- en: Distributed tracing is a method used to profile and monitor your distributed
    systems. It can be used to detect failures in the communication between services,
    determine which points are performance problems, or perform a log record of all
    requests and responses that are happening within the network mesh.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five important concepts in OpenTracing that you must understand before
    proceeding with distributed tracing:'
  prefs: []
  type: TYPE_NORMAL
- en: Span
  prefs: []
  type: TYPE_NORMAL
- en: A named operation representing a unit of work done (e.g., a service executed).
    A span can contain more spans in a child-parent form.
  prefs: []
  type: TYPE_NORMAL
- en: Span context
  prefs: []
  type: TYPE_NORMAL
- en: Trace information that is propagated from service to service (e.g., span ID).
  prefs: []
  type: TYPE_NORMAL
- en: Baggage items
  prefs: []
  type: TYPE_NORMAL
- en: Custom key/value pairs that are propagated from service to service.
  prefs: []
  type: TYPE_NORMAL
- en: Tags
  prefs: []
  type: TYPE_NORMAL
- en: Key/value pairs defined by the user that are set in spans so they can be queried
    and filtered (e.g., `http.status_code`).
  prefs: []
  type: TYPE_NORMAL
- en: Logs
  prefs: []
  type: TYPE_NORMAL
- en: Key/value pairs associated with a span that contains logging messages or other
    important information. Logs are used to identify a specific moment in the span;
    meanwhile, tags apply to the whole span independently of time.
  prefs: []
  type: TYPE_NORMAL
- en: For this example, the [Jaeger](https://www.jaegertracing.io) server is used
    to collect all traces from your application and make them available to be consumed
    or queried. [Figure 9-1](#microjaeger) shows the interaction between services
    and Jaeger.
  prefs: []
  type: TYPE_NORMAL
- en: '![qucb 0902](Images/qucb_0902.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-1\. Microservices and Jaeger
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The Jaeger concepts explained in the previous paragraph are illustrated in [Figure 9-2](#jaegerconcepts).
  prefs: []
  type: TYPE_NORMAL
- en: '![qucb 0901](Images/qucb_0901.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-2\. Jaeger concepts
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The `jaegertracing/all-in-one` container image is used because it contains
    all of the Jaeger backend components and the UI in a single image. This is not
    meant to be used in production, but, for the sake of simplicity, this is the image
    used in [Recipe 9.5](#using_distributed_tracing):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: To enable MicroProfile OpenTracing in a Quarkus application, you need to register
    only the `quarkus-smallrye-opentracing` extension.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: With the extension in the classpath, Quarkus/MicroProfile OpenTracing sends
    default tracing information to the Jaeger server. The only thing you need to do
    is configure the Jaeger endpoint where all tracing information should be sent.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default tracing information collected includes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Hardware metrics like CPU, memory, and available processors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JVM metrics like memory heap and thread pool.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MicroProfile OpenTracing creates a new span for every inbound request. The default
    name of this new span is `*HTTP method*:*package name*.*class name*.*method name*`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spans created for incoming requests will contain the following tags with correct
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Tags.SPAN_KIND` = `Tags.SPAN_KIND_SERVER`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Tags.HTTP_METHOD` with the HTTP method used in the incoming request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Tags.HTTP_URL` with the URL of incoming endpoints'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Tags.HTTP_STATUS` with the HTTP status result code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Tags.COMPONENT` = `"jaxrs"`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Tags.ERROR` to `true` if a server error (5XX error code) occurred; if an exception
    has a provided object, two logs are added, one with `event=error` and another
    one with `error.object=<error object instance>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In cases of outbound requests, a new span is created that is a child of the
    current active span (if it exists). The default name of the new span is `<HTTP
    method>`. Spans created for outgoing requests will contain the following tags
    with correct values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Tags.SPAN_KIND`=`Tags.SPAN_KIND_SCLIENT`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Tags.HTTP_METHOD` with the HTTP method used in outgoing request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Tags.HTTP_URL` with the URL of the outgoing endpoint'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Tags.HTTP_STATUS` with the *HTTP* status result code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Tags.COMPONENT` = `"jaxrs"`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Tags.ERROR` to `true` if a client error (4XX error code) occurred; if an exception
    has a provided object, two logs are added, one with `event=error` and another
    one with `error.object=<error object instance>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The last thing to do is configure the Jaeger parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_observability_CO9-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Service name to be identified inside Jaeger
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_observability_CO9-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Set up a sampler
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_observability_CO9-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Percentage of requests to sample in percentage (1 is sampling all)
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_observability_CO9-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The Jaeger server location
  prefs: []
  type: TYPE_NORMAL
- en: Then start the application and send some requests to one of the endpoints defined
    in the service. After that, inspect all distributed tracings by accessing Jaeger
    UI. Open a browser, and visit [*http://localhost:16686*](http://localhost:16686)
    (the Jaeger UI) to see the tracing information.
  prefs: []
  type: TYPE_NORMAL
- en: In the initial page, you can filter by several parameters, but one of them is
    used to select the service that will be used to view the completed requests.
  prefs: []
  type: TYPE_NORMAL
- en: The home page of Jaeger is shown in [Figure 9-3](#jaegerinitial).
  prefs: []
  type: TYPE_NORMAL
- en: '![qucb 0903](Images/qucb_0903.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-3\. Jaeger’s home page
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Push the Find Traces button to select all the traces that meet the given criteria,
    and you should see the image shown in [Figure 9-4](#jaegerfindtraces).
  prefs: []
  type: TYPE_NORMAL
- en: '![qucb 0904](Images/qucb_0904.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-4\. Find traces
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You’ll see all the requests that meet the criteria. In this case, the requests
    are all traces that are involved in the `shopping-cart` service, as seen in [Figure 9-5](#jaegerviewtraces).
  prefs: []
  type: TYPE_NORMAL
- en: '![qucb 0903](Images/qucb_0903.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-5\. View traces
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you click on any of the requests, more detail of the specific request is
    shown, as shown in [Figure 9-6](#jaegerdetail).
  prefs: []
  type: TYPE_NORMAL
- en: '![qucb 0906](Images/qucb_0906.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-6\. Detail of a request
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In case of errors, a new log entry is added that sets the error message, as
    shown in [Figure 9-7](#jaegererror).
  prefs: []
  type: TYPE_NORMAL
- en: '![qucb 0907](Images/qucb_0907.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-7\. Error log message
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Disabling Tracing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Any request (incoming or outgoing) is traced by default. Disable the tracing
    of a specific class or method by annotating it with `@org.eclipse.microprofile.opentracing.Traced`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Configure OpenTracing by setting options in the *src/main/resources/application.properties*
    file or by using any other method discussed in [Recipe 9.6](#custom-distributed-tracing).
    Some of the most important configuration properties are listed in [Table 9-1](#opentracing-config-properties-table).
  prefs: []
  type: TYPE_NORMAL
- en: Table 9-1\. OpenTracing configuration properties
  prefs: []
  type: TYPE_NORMAL
- en: '| Property | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '`quarkus.jaeger.enabled`'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'Defines if the Jaeger extension is enabled (default: `true`). It is a build
    property and cannot be modified at runtime.'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '`quarkus.jaeger.endpoint`'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Traces server endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '`quarkus.jaeger.auth-token`'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Authentication token to the endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '`quarkus.jaeger.user`'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Username to send as part of authentication to the endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '`quarkus.jaeger.password`'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Password to send as part of authentication to the endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '`quarkus.jaeger.sampler-type`'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: The sampler type (`const`, `probabilistic`, `ratelimiting`. or `remote`).
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '`quarkus.jaeger.sampler-param`'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Percentage of traffic sampled (0.0-1.0).
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '`quarkus.jaeger.service-name`'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: The service name.
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '`quarkus.jaeger.tags`'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: A comma-separated list of key/value tags that are added to all spans. Environment
    variables are supported by using `${environmentVar:default}`.
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '`quarkus.jaeger.propagation`'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: The format used to propagate the trace context (default is `jaeger`). Possible
    values are `jaeger` and `b3`.
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '`quarkus.jaeger.sender-factory`'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: The sender factory class name.
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See [Quarkus’s guide to using OpenTracing](https://oreil.ly/A2GJu) for the full
    list of supported properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'More information about MicroProfile OpenTracing specification can be found
    at the following page on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[MicroProfile OpenTracing](https://oreil.ly/v7kjr)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 9.6 Custom Distributed Tracing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to add custom information in the current tracing span.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The MicroProfile OpenTracing specification uses the `io.opentracing.Tracer`
    class to add new information in the current span.
  prefs: []
  type: TYPE_NORMAL
- en: In some situations, it is required to create a new child span or add information
    in the current span, like a new tag, logging information, or a baggage item. To
    add this information, MicroProfile OpenTracing produces an instance of the `io.opentracing.Tracer`
    class to manipulate the current span.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose you want to tag all requests that are made by important customers.
    For this example, important customers are those whose ID starts with `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_observability_CO10-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Injects a `Tracer` instance
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_observability_CO10-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Creates a new tag in the current span
  prefs: []
  type: TYPE_NORMAL
- en: Then any request for an important customer is tagged accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Custom tags are presented as shown in [Figure 9-8](#customtags).
  prefs: []
  type: TYPE_NORMAL
- en: '![qucb 0908](Images/qucb_0908.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-8\. Custom tags
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Quarkus supports one of the OpenTracing customizations to instrument JDBC, so
    if you want to monitor SQL queries, you don’t need to customize the current span
    yourself; you can use the integration provided in the form of dependency.
  prefs: []
  type: TYPE_NORMAL
- en: 'Register the `opentracing-jdbc` artifact into your build tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Then activate tracing for JDBC connections. This is done by adding the word
    `tracing` in the JDBC URL. Because Quarkus uses JPA, you also need to configure
    the datasource and Hibernate to use the dedicated tracing driver:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_observability_CO11-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Updates JDBC URL with `tracing`
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_observability_CO11-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets the `TracingDriver` instead of the database driver
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_observability_CO11-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Configure dialect of the real database
  prefs: []
  type: TYPE_NORMAL
- en: All queries that are done in a request are also reflected in the Jaeger UI.
  prefs: []
  type: TYPE_NORMAL
- en: JDBC traces are presented as shown in [Figure 9-9](#jdbctraces).
  prefs: []
  type: TYPE_NORMAL
- en: '![qucb 0909](Images/qucb_0909.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-9\. JDBC traces
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you look closely at the screenshot, you’ll notice that there is a new tag,
    with the name `db.statement`, that reflects the query that has been traced. Also,
    notice that there is one *shopping-cart* span that at the same time contains six
    more spans, one for each query.
  prefs: []
  type: TYPE_NORMAL
- en: To ignore specific queries, you can set (multiple times) the `ignoreForTracing`
    property with the queries to ignore (e.g., `jdbc:tracing:h2:mem:test?ignoreForTracing=SELECT
    * FROM \"TEST\"`).
  prefs: []
  type: TYPE_NORMAL
