<html><head></head><body>
<div id="sbo-rt-content"><section data-pdf-bookmark="Chapter 6. Data Processing with Streams" data-type="chapter" epub:type="chapter"><div class="chapter" id="_02-data-processing">
<h1><span class="label">Chapter 6. </span>Data Processing with Streams</h1>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45115239575440">
<h1>A Note for Early Release Readers</h1>
<p>With Early Release ebooks, you get books in their earliest form—the author’s raw and unedited content as they write—so you can take advantage of these technologies long before the official release of these titles.</p>
<p>This will be the 6th chapter of the final book. Please note that the GitHub repo will be made active later on.</p>
<p>If you have comments about how we might improve the content and/or examples in this book, or if you notice missing material within this chapter, please reach out to the editor at <em>rfernando@oreilly.com</em>.</p>
</div></aside>
<p>Almost any program has to deal with processing data, most likely in the form of collections.
An imperative approach uses loops to iterate over elements, working with each element in sequence.
Functional languages, though, prefer a declarative approach and sometimes don’t even have a classical loop statement, to begin with.</p>
<p>The <em>Streams API</em>, introduced in Java 8, provides a fully declarative and lazily evaluated approach to processing data that benefits from Java’s functional additions by utilizing higher-order functions for most of its operations.</p>
<p>This chapter will teach you the differences between imperative and declarative data processing.
You will then have a visual introduction to Streams that highlights their underlying concepts and shows you how to get the most out of their flexibility to achieve a more functional approach to data processing.</p>
<section data-pdf-bookmark="Data Processing with Iteration" data-type="sect1"><div class="sect1" id="idm45115239570784">
<h1>Data Processing with Iteration</h1>
<p>Processing data is an everyday task you’ve probably encountered a million times before and will continue to do so in the future.</p>
<p>From a broad point of view, any type of data processing works like a pipeline, with a data structure like a collection providing elements, one or more operations like filtering or transforming elements, and finally, delivering some form of a result.
The result might be another data structure or even using it to run another task.</p>
<p>Let’s start with a simple data processing example.</p>
<section data-pdf-bookmark="External Iteration" data-type="sect2"><div class="sect2" id="idm45115239542288">
<h2>External Iteration</h2>
<p>Say that we need to find the three science-fiction books before 1970 sorted by title from a collection of <code>Book</code> instances.
<a data-type="xref" href="#_02-data-processing_for-loop">Example 6-1</a> shows how to do this using a typical imperative approach with a <code>for</code>-loop.</p>
<div data-type="example" id="_02-data-processing_for-loop">
<h5><span class="label">Example 6-1. </span>Finding books with a <code>for</code>-loop</h5>
<pre data-code-language="java" data-type="programlisting"><code class="kd">record</code> <code class="nc">Book</code><code class="p">(</code><code class="n">String</code> <code class="n">title</code><code class="p">,</code> <code class="kt">int</code> <code class="n">year</code><code class="p">,</code> <code class="n">Genre</code> <code class="n">genre</code><code class="p">)</code> <code class="p">{</code>
  <code class="c1">// NO BODY</code>
<code class="p">}</code>

<code class="c1">// DATA PREPARATION</code>

<code class="n">List</code><code class="o">&lt;</code><code class="n">Book</code><code class="o">&gt;</code> <code class="n">books</code> <code class="o">=</code> <code class="p">.</code><code class="p">.</code><code class="p">.</code><code class="p">;</code> <a class="co" href="#callout_data_processing_with_streams_CO1-1" id="co_data_processing_with_streams_CO1-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a>

<code class="n">Collections</code><code class="p">.</code><code class="na">sort</code><code class="p">(</code><code class="n">books</code><code class="p">,</code> <code class="n">Comparator</code><code class="p">.</code><code class="na">comparing</code><code class="p">(</code><code class="n">Book</code><code class="p">:</code><code class="p">:</code><code class="n">title</code><code class="p">)</code><code class="p">)</code><code class="p">;</code> <a class="co" href="#callout_data_processing_with_streams_CO1-2" id="co_data_processing_with_streams_CO1-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a>

<code class="c1">// FOR-LOOP</code>

<code class="n">List</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code> <code class="n">result</code> <code class="o">=</code> <code class="k">new</code> <code class="n">ArrayList</code><code class="o">&lt;</code><code class="o">&gt;</code><code class="p">(</code><code class="p">)</code><code class="p">;</code>

<code class="k">for</code> <code class="p">(</code><code class="kd">var</code> <code class="n">book</code> <code class="p">:</code> <code class="n">books</code><code class="p">)</code> <code class="p">{</code>

    <code class="k">if</code> <code class="p">(</code><code class="n">book</code><code class="p">.</code><code class="na">year</code><code class="p">(</code><code class="p">)</code> <code class="o">&gt;</code><code class="o">=</code> <code class="mi">1970</code><code class="p">)</code> <code class="p">{</code> <a class="co" href="#callout_data_processing_with_streams_CO1-3" id="co_data_processing_with_streams_CO1-3"><img alt="3" height="12" src="assets/3.png" width="12"/></a>
        <code class="k">continue</code><code class="p">;</code>
    <code class="p">}</code>

    <code class="k">if</code> <code class="p">(</code><code class="n">book</code><code class="p">.</code><code class="na">genre</code><code class="p">(</code><code class="p">)</code> <code class="o">!</code><code class="o">=</code> <code class="n">Genre</code><code class="p">.</code><code class="na">SCIENCE_FICTION</code><code class="p">)</code> <code class="p">{</code> <a class="co" href="#callout_data_processing_with_streams_CO1-3" id="co_data_processing_with_streams_CO1-4"><img alt="3" height="12" src="assets/3.png" width="12"/></a>
        <code class="k">continue</code><code class="p">;</code>
    <code class="p">}</code>

    <code class="kd">var</code> <code class="n">title</code> <code class="o">=</code> <code class="n">book</code><code class="p">.</code><code class="na">title</code><code class="p">(</code><code class="p">)</code><code class="p">;</code> <a class="co" href="#callout_data_processing_with_streams_CO1-4" id="co_data_processing_with_streams_CO1-5"><img alt="4" height="12" src="assets/4.png" width="12"/></a>
    <code class="n">result</code><code class="p">.</code><code class="na">add</code><code class="p">(</code><code class="n">title</code><code class="p">)</code><code class="p">;</code>

    <code class="k">if</code> <code class="p">(</code><code class="n">result</code><code class="p">.</code><code class="na">size</code><code class="p">(</code><code class="p">)</code> <code class="o">=</code><code class="o">=</code> <code class="mi">3</code><code class="p">)</code> <code class="p">{</code> <a class="co" href="#callout_data_processing_with_streams_CO1-5" id="co_data_processing_with_streams_CO1-6"><img alt="5" height="12" src="assets/5.png" width="12"/></a>
        <code class="k">break</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">}</code></pre></div>
<dl class="calloutlist">
<dt><a class="co" href="#co_data_processing_with_streams_CO1-1" id="callout_data_processing_with_streams_CO1-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p>An unsorted Collection of books.
It must be mutable, so it can be sorted in-place in the next step.</p></dd>
<dt><a class="co" href="#co_data_processing_with_streams_CO1-2" id="callout_data_processing_with_streams_CO1-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a></dt>
<dd><p>The collection has to be sorted first, or the elements in <code>result</code> won’t be the first three titles in alphabetical order of the original collection.</p></dd>
<dt><a class="co" href="#co_data_processing_with_streams_CO1-3" id="callout_data_processing_with_streams_CO1-3"><img alt="3" height="12" src="assets/3.png" width="12"/></a></dt>
<dd><p>Ignore any unwanted books, like the ones not published before 1970 or non-science-fiction.</p></dd>
<dt><a class="co" href="#co_data_processing_with_streams_CO1-5" id="callout_data_processing_with_streams_CO1-4"><img alt="4" height="12" src="assets/4.png" width="12"/></a></dt>
<dd><p>The book title is all we are interested in.</p></dd>
<dt><a class="co" href="#co_data_processing_with_streams_CO1-6" id="callout_data_processing_with_streams_CO1-5"><img alt="5" height="12" src="assets/5.png" width="12"/></a></dt>
<dd><p>Restrict the found titles to a maximum of three.</p></dd>
</dl>
<p>Although the code works for what it needs to do, it has several shortcomings compared to other approaches.
The most obvious downside is the amount of boilerplate code required for an iteration-based loop.</p>
<p>Loop statements, either a <code>for</code>- or <code>while</code>-loop, contain their data processing logic in their body, to create a new scope for each iteration.
Depending on your requirements, the loop’s body contains multiple statements, including decision-making about the iteration process itself in the form of <code>continue</code> and <code>break</code>.
Overall, the data processing code is obscured by all this boilerplate and doesn’t present itself fluently or is easily followable, especially for a more complex loop than the previous example.</p>
<p>The origin of these problems is blending “what you are doing” (working with data) and “how it’s done” (iterating over elements).
This kind of iteration is called <em>external iteration</em>.
Behind the scenes, the <code>for</code>-loop, in this case, the <code>for-each</code> variant, uses a <code>java.util.Iterator&lt;E&gt;</code> to traverse the collection.
The traversal process calls <code>hasNext</code> and <code>next</code> to control the iteration, as illustrated in <a data-type="xref" href="#_02-data-processing_external-iteration">Figure 6-1</a>.</p>
<figure><div class="figure" id="_02-data-processing_external-iteration">
<img alt="External iteration" height="362" src="assets/afaj_0601.png" width="379"/>
<h6><span class="label">Figure 6-1. </span>External iteration</h6>
</div></figure>
<p>In the case of a “traditional” <code>for</code>-loop, you have to manage going over the elements until an end condition is reached yourself, which in a way is similar to an <code>Iterator&lt;E&gt;</code> and the <code>hasNext</code> and <code>next</code> method.</p>
<p>If you count the number of code lines that have to do with “what you’re doing” and “how it’s done,” you’d notice that it spends more time on traversal management than data processing, as listed in, as detailed in <a data-type="xref" href="#_02-data-processing_loc-imp">Table 6-1</a>.</p>
<table id="_02-data-processing_loc-imp">
<caption><span class="label">Table 6-1. </span>Lines of code per data processing per task</caption>
<thead>
<tr>
<th>Task</th>
<th>Lines of code</th>
</tr>
</thead>
<tbody>
<tr>
<td><p><strong>Data preparation</strong><br/>
   Sorting the initial data and preparing a result Collection</p></td>
<td><p>2</p></td>
</tr>
<tr>
<td><p><strong>Traversal process</strong><br/>
   Looping and controlling the loop with <code>continue</code> and <code>break</code></p></td>
<td><p>4</p></td>
</tr>
<tr>
<td><p><strong>Data processing</strong><br/>
   Choosing, transforming, and gathering the correct elements and data</p></td>
<td><p>4</p></td>
</tr>
</tbody>
</table>
<p>However, requiring a lot of boilerplate code to traverse isn’t the only drawback associated with external iteration.
Another downside is the inherent serial traversal process.
You need to rework the whole loop if you require parallel data processing and deal with all the associated gotchas, like the dreaded <code>ConcurrentModificationException</code>.</p>
</div></section>
<section data-pdf-bookmark="Internal Iteration" data-type="sect2"><div class="sect2" id="idm45115239541696">
<h2>Internal Iteration</h2>
<p>The opposite approach to <em>external</em> iteration is, predictably, <em>internal</em> iteration.
With internal iteration, you give up explicit control of the traversal process and let the data source itself handle “how it’s done,” as illustrated in <a data-type="xref" href="#_02-data-processing_internal-iteration">Figure 6-2</a>.</p>
<figure><div class="figure" id="_02-data-processing_internal-iteration">
<img alt="Internal iteration" height="362" src="assets/afaj_0602.png" width="347"/>
<h6><span class="label">Figure 6-2. </span>Internal iteration</h6>
</div></figure>
<p>Instead of using an iterator to control the traversal, the data processing logic is prepared beforehand to build a pipeline that does the iteration by itself.
The iteration process becomes more opaque, but the logic influences which elements traverse the pipeline.
This way, you can focus your energy and code on “what you want to do” rather than on the tedious and often repetitive details of “how it’s done.”</p>
<p>Streams are such data pipelines with internal iteration.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="Streams as Functional Data Pipelines" data-type="sect1"><div class="sect1" id="_02-data-processing-what-is-a-stream">
<h1>Streams as Functional Data Pipelines</h1>
<p>Streams, as a data processing approach, get the job done like any other one but have specific advantages due to having an internal iterator.
These advantages are especially beneficial from a functional point of view.
The advantages are as follows:</p>
<dl>
<dt>Declarative approach</dt>
<dd>
<p>Build concise and comprehensible multi-step data processing pipelines with a single fluent call chain.</p>
</dd>
<dt>Composability</dt>
<dd>
<p>Stream operations provide a scaffold made of higher-order functions to be filled with data processing logic.
They can be mixed as needed.
If you design their logic in a functional way, you automatically gain all their advantages, like composability.</p>
</dd>
<dt>Laziness</dt>
<dd>
<p>Instead of iteration over all elements, they get pulled one by one through the pipeline after the last operation is attached to it, reducing the required amount of operations to a minimum.</p>
</dd>
<dt>Performance optimization</dt>
<dd>
<p>Streams optimize the traversal process automatically depending on their data source and different kinds of operations used, including short-circuiting operations if possible.</p>
</dd>
<dt>Parallel data processing</dt>
<dd>
<p>Built-in support for parallel processing is used by simply changing a single call in the call chain.</p>
</dd>
</dl>
<p>In concept, Streams could be considered just another alternative to traditional loop constructs for data processing.
In reality, though, Streams are special in <em>how</em> they go about providing those data processing capabilities.</p>
<p>The first thing to consider is the overall Stream workflow.
Streams can be summed up as <em>lazy sequential data pipelines</em>.
Such pipelines are a higher-level abstraction for traversing sequential data.
They are sequences of higher-order functions to process their elements in a fluent, expressive, and functional way.
The general workflow is representable by three steps, as seen in <a data-type="xref" href="#_02-data-processing_concept">Figure 6-3</a>.</p>
<figure><div class="figure" id="_02-data-processing_concept">
<img alt="Different aspects of Java Streams" height="324" src="assets/afaj_0603.png" width="566"/>
<h6><span class="label">Figure 6-3. </span>The Basic Concept of Java Streams</h6>
</div></figure>
<dl>
<dt>(1) Creating a Stream</dt>
<dd>
<p>The first step is creating a Stream out of an existing data source.
Streams aren’t limited to collection-like types, though.
Any data source that can provide sequential elements is a possible data source for a Stream.</p>
</dd>
<dt>(2) Doing the Work</dt>
<dd>
<p>So-called <em>intermediate operations</em> — higher-order functions available as methods on the <code>java.util.stream.Stream&lt;T&gt;</code> — work on the elements passing through the pipeline, doing different tasks, like filtering, mapping, sorting, etc.
Each one returns a new Stream, which can be connected with as many intermediate operations as needed.</p>
</dd>
<dt>(3) Getting a Result</dt>
<dd>
<p>To finish the data processing pipeline, a final — <em>terminal</em> — operation is needed to get back a result instead of a Stream.
Such a terminal operation completes the Stream pipeline blueprint and starts the actual data processing.</p>
</dd>
</dl>
<p>To see this in action, let’s revisit the earlier task of finding three science-fiction book titles from 1999.
This time, instead of using a <code>for</code>-loop as we did in <a data-type="xref" href="#_02-data-processing_for-loop">Example 6-1</a>, we will use a Stream pipeline in <a data-type="xref" href="#_02-data-processing_stream">Example 6-2</a>.
Don’t worry too much about the Stream code yet; I’ll explain the various methods shortly.
Read through it, and you should be able to get the gist of it for now.</p>
<div data-type="example" id="_02-data-processing_stream">
<h5><span class="label">Example 6-2. </span>Finding books with a Stream</h5>
<pre data-code-language="java" data-type="programlisting"><code class="n">List</code><code class="o">&lt;</code><code class="n">Book</code><code class="o">&gt;</code> <code class="n">books</code> <code class="o">=</code> <code class="p">.</code><code class="p">.</code><code class="p">.</code><code class="p">;</code> <a class="co" href="#callout_data_processing_with_streams_CO2-1" id="co_data_processing_with_streams_CO2-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a>

<code class="n">List</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code> <code class="n">result</code> <code class="o">=</code>
  <code class="n">books</code><code class="p">.</code><code class="na">stream</code><code class="p">(</code><code class="p">)</code>
       <code class="p">.</code><code class="na">filter</code><code class="p">(</code><code class="n">book</code> <code class="o">-</code><code class="o">&gt;</code> <code class="n">book</code><code class="p">.</code><code class="na">year</code><code class="p">(</code><code class="p">)</code> <code class="o">&lt;</code> <code class="mi">1970</code><code class="p">)</code> <a class="co" href="#callout_data_processing_with_streams_CO2-2" id="co_data_processing_with_streams_CO2-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a>
       <code class="p">.</code><code class="na">filter</code><code class="p">(</code><code class="n">book</code> <code class="o">-</code><code class="o">&gt;</code> <code class="n">book</code><code class="p">.</code><code class="na">genre</code><code class="p">(</code><code class="p">)</code> <code class="o">=</code><code class="o">=</code> <code class="n">Genre</code><code class="p">.</code><code class="na">SCIENCE_FICTION</code><code class="p">)</code> <a class="co" href="#callout_data_processing_with_streams_CO2-3" id="co_data_processing_with_streams_CO2-3"><img alt="3" height="12" src="assets/3.png" width="12"/></a>
       <code class="p">.</code><code class="na">map</code><code class="p">(</code><code class="n">Book</code><code class="p">:</code><code class="p">:</code><code class="n">title</code><code class="p">)</code> <a class="co" href="#callout_data_processing_with_streams_CO2-4" id="co_data_processing_with_streams_CO2-4"><img alt="4" height="12" src="assets/4.png" width="12"/></a>
       <code class="p">.</code><code class="na">sorted</code><code class="p">(</code><code class="p">)</code> <a class="co" href="#callout_data_processing_with_streams_CO2-5" id="co_data_processing_with_streams_CO2-5"><img alt="5" height="12" src="assets/5.png" width="12"/></a>
       <code class="p">.</code><code class="na">limit</code><code class="p">(</code><code class="mi">3</code><code class="p">)</code> <a class="co" href="#callout_data_processing_with_streams_CO2-6" id="co_data_processing_with_streams_CO2-6"><img alt="6" height="12" src="assets/6.png" width="12"/></a>
       <code class="p">.</code><code class="na">collect</code><code class="p">(</code><code class="n">Collectors</code><code class="p">.</code><code class="na">toList</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code class="p">;</code> <a class="co" href="#callout_data_processing_with_streams_CO2-7" id="co_data_processing_with_streams_CO2-7"><img alt="7" height="12" src="assets/7.png" width="12"/></a></pre></div>
<dl class="calloutlist">
<dt><a class="co" href="#co_data_processing_with_streams_CO2-1" id="callout_data_processing_with_streams_CO2-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p>An unsorted collection of books.</p></dd>
<dt><a class="co" href="#co_data_processing_with_streams_CO2-2" id="callout_data_processing_with_streams_CO2-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a></dt>
<dd><p>Ignore any books not published in 1999.</p></dd>
<dt><a class="co" href="#co_data_processing_with_streams_CO2-3" id="callout_data_processing_with_streams_CO2-3"><img alt="3" height="12" src="assets/3.png" width="12"/></a></dt>
<dd><p>Ignore any non-science-fiction books.</p></dd>
<dt><a class="co" href="#co_data_processing_with_streams_CO2-4" id="callout_data_processing_with_streams_CO2-4"><img alt="4" height="12" src="assets/4.png" width="12"/></a></dt>
<dd><p>Transform the element from the whole <code>Book</code> element to its <code>title</code> value.</p></dd>
<dt><a class="co" href="#co_data_processing_with_streams_CO2-5" id="callout_data_processing_with_streams_CO2-5"><img alt="5" height="12" src="assets/5.png" width="12"/></a></dt>
<dd><p>Sort the titles.</p></dd>
<dt><a class="co" href="#co_data_processing_with_streams_CO2-6" id="callout_data_processing_with_streams_CO2-6"><img alt="6" height="12" src="assets/6.png" width="12"/></a></dt>
<dd><p>Restrict the found titles to a maximum of three.</p></dd>
<dt><a class="co" href="#co_data_processing_with_streams_CO2-7" id="callout_data_processing_with_streams_CO2-7"><img alt="7" height="12" src="assets/7.png" width="12"/></a></dt>
<dd><p>Aggregate the titles into a <code>List&lt;String&gt;</code>.</p></dd>
</dl>
<p>From a high-level point of view, both implementations shown in <a data-type="xref" href="#_02-data-processing_for-loop">Example 6-1</a> and <a data-type="xref" href="#_02-data-processing_stream">Example 6-2</a> represent pipelines that elements can traverse, with multiple exit points for unneeded data.
But, notice how the functionality of the <code>for</code>-loop with its multiple statements is now condensed into a singular fluent Stream call?</p>
<p>This leads us to how Streams optimize the flow of their elements.
You don’t have to explicitly manage the traversal with <code>continue</code> or <code>break</code> because the elements will traverse the pipeline depending on the result of the operations.
<a data-type="xref" href="#_02-data-processing_albums-stream-steps">Figure 6-4</a> illustrates how the different Stream operations affect the element flow of <a data-type="xref" href="#_02-data-processing_stream">Example 6-2</a>.</p>
<figure><div class="figure" id="_02-data-processing_albums-stream-steps">
<img alt="Element Flow of Book Stream" height="553" src="assets/afaj_0604.png" width="600"/>
<h6><span class="label">Figure 6-4. </span>Element Flow of Book Stream</h6>
</div></figure>
<p>The elements flow one by one through the Stream and are funneled to the least amount needed to process the data.</p>
<p>Instead of needing to prepare the data beforehand and wrapping the processing logic in a loop statement’s body, Streams are built with a fluent class of the different processing steps.
Like other functional approaches, Stream code reflects “what” is happening in a more expressive and declarative fashion, without the typical verbiage of “how” it’s actually done.</p>
<section data-pdf-bookmark="Stream Features" data-type="sect2"><div class="sect2" id="_02-data-processing_properties">
<h2>Stream Features</h2>
<p>Streams are a functional API with specific behaviors and expectations built in.
In a way, this confines their possibilities, at least, compared to the blank canvas of traditional loops.
By being non-blank canvases, though, they provide you with lots of pre-defined building blocks and guaranteed properties that you would have to do yourself with alternative approaches.</p>
<section data-pdf-bookmark="Lazy Evaluation" data-type="sect3"><div class="sect3" id="idm45115239005488">
<h3>Lazy Evaluation</h3>
<p>The most significant advantage of Streams over loops is their laziness.
Each time you call an intermediate operation on a Stream, it’s not applied immediately.
Instead, the call simply “extends” the pipeline further and returns a new lazily evaluated Stream.
The pipeline accumulates all operations, and no work starts before you call its terminal operation, which will trigger the actual element traversal, as seen in <a data-type="xref" href="#_02-streams_laziness">Figure 6-5</a>.</p>
<figure><div class="figure" id="_02-streams_laziness">
<img alt="Lazy Evaluation of Streams" height="338" src="assets/afaj_0605.png" width="600"/>
<h6><span class="label">Figure 6-5. </span>Lazy evaluation of Streams</h6>
</div></figure>
<p>Instead of providing all elements to a code block, like a loop, the terminal operation is asking for more data as needed, and the Stream tries to comply.
Streams, as a data source, don’t have to “over-provide” or buffer any elements if no one is requesting more elements.
If you look back at <a data-type="xref" href="#_02-data-processing_albums-stream-steps">Figure 6-4</a>, that means not every element will traverse through every operation.</p>
<p>The flow of Stream elements follows a “depth-first” approach, reducing the required CPU cycles, memory footprint, and stack depth.
This way, even infinite data sources are possible because the pipeline is responsible for requesting the required elements and terminating the Stream.</p>
<p>You can read more about the importance of laziness in functional programming in <a data-type="xref" href="ch11.xhtml#_02-lazy-evaluation">Chapter 11</a>.</p>
</div></section>
<section data-pdf-bookmark="(Mostly) Stateless and Non-Interfering" data-type="sect3"><div class="sect3" id="idm45115238998144">
<h3>(Mostly) Stateless and Non-Interfering</h3>
<p>As you’ve learned in <a data-type="xref" href="ch04.xhtml#_02-data-structures">Chapter 4</a>, an immutable state is an essential functional programming concept, and Streams do their best to adhere.
Almost all intermediate operations are stateless and detached from the rest of the pipeline, only having access to the current element they’re processing.
Certain intermediate operations, however, require some form of state to fulfill their purpose, like <code>limit</code> or <code>skip</code>.</p>
<p>Another advantage of using Streams is their separation of the data source and the elements themselves.
That way, operations won’t affect the underlying data source in any way, nor does the Stream store any elements itself.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>Even though you can create Java stateful lambdas with side effects, you should strive to design the behavioral arguments of your data manipulation pipelines stateless and as pure functions.
Any dependence on an out-of-scope state can severely impact safety and performance and make the whole pipeline nondeterministic and incorrect due to unintended side effects.
One exception is certain terminal operations for doing “side-effect only” code, which can help immensely fit functional Stream pipelines in existing imperative designs.</p>
</div>
<p>Streams are <em>non-interfering</em> and <em>pass-through</em> pipelines that will let their elements traverse as freely as possible without interference, if not absolutely necessary.</p>
</div></section>
<section data-pdf-bookmark="Optimizations included" data-type="sect3"><div class="sect3" id="idm45115238991952">
<h3>Optimizations included</h3>
<p>The internal iteration and fundamental design of higher-order functions allow Streams to optimize themselves quite efficiently.
They utilize multiple techniques to improve their performance:</p>
<ul>
<li>
<p>Fusion<sup><a data-type="noteref" href="ch06.xhtml#idm45115238989296" id="idm45115238989296-marker">1</a></sup> of (stateless) operations</p>
</li>
<li>
<p>Removal of redundant operations</p>
</li>
<li>
<p>Short-circuiting pipeline paths</p>
</li>
</ul>
<p>Iteration-related code optimizations aren’t restricted to Streams, though.
Traditional loops get optimized by the JVM, too, if possible<sup><a data-type="noteref" href="ch06.xhtml#idm45115238985136" id="idm45115238985136-marker">2</a></sup>.</p>
<p>Also, loops like <code>for</code> and <code>while</code> are language features, and can therefore be optimized to another degree.
Streams are ordinary types with all the costs affiliated with them.
They still need to be created by wrapping a data source, and the pipeline is a call chain requiring a new stack frame for each call.
In most real-world scenarios, their general advantages outweigh the possible performance impact of such an overhead compared to a built-in statement like <code>for</code> or <code>while</code>.</p>
</div></section>
<section data-pdf-bookmark="Less boilerplate" data-type="sect3"><div class="sect3" id="idm45115238981392">
<h3>Less boilerplate</h3>
<p>As seen in <a data-type="xref" href="#_02-data-processing_stream">Example 6-2</a>, Streams condense data processing into a singular fluent method call chain.
The call is designed to consist of small and on-point operations like <code>filter</code>, <code>map</code>, or <code>findFirst</code>, providing an expressive and straightforward scaffold around the data processing logic.
Call chains should be easy to grasp, both visually and conceptually.
Therefore, a Stream pipeline consumes as little visual real estate and cognitive bandwidth as necessary.</p>
</div></section>
<section data-pdf-bookmark="Non-Reusable" data-type="sect3"><div class="sect3" id="idm45115238977600">
<h3>Non-Reusable</h3>
<p>Stream pipelines are <em>single-use</em> only.
They’re bound to their data source and traverse them exactly once after the terminal operation is called.</p>
<p>If you try to use a Stream again, an <code>IllegalStateException</code> gets thrown.
You can’t check if a Stream is already consumed, though.</p>
<p>As Streams don’t change or affect their underlying data source, you can always create another Stream from the same data source.</p>
</div></section>
<section data-pdf-bookmark="Primitive Streams" data-type="sect3"><div class="sect3" id="idm45115238974160">
<h3>Primitive Streams</h3>
<p>As with the functional interfaces introduced in <a data-type="xref" href="ch02.xhtml#_01-functional-java">Chapter 2</a>, the Stream API contains specialized variants for dealing with primitives to minimize autoboxing overhead.</p>
<p>Both <code>Stream</code> and the specialized variants <code>IntStream</code>, <code>LongStream</code>, and <code>DoubleStream</code>, share a common base interface, <code>BaseStream</code>, as illustrated in <a data-type="xref" href="#_02-data-processing_type-hierachy">Figure 6-6</a>.
Many of the available primitive Stream operations mirror their non-primitive counterpart, but not all of them.</p>
<figure><div class="figure" id="_02-data-processing_type-hierachy">
<img alt="Stream type hierarchy" height="194" src="assets/afaj_0606.png" width="518"/>
<h6><span class="label">Figure 6-6. </span>Stream type hierarchy</h6>
</div></figure>
<p>That’s why I discuss in <a data-type="xref" href="ch07.xhtml#_02-streams">Chapter 7</a> when to use a primitive Stream and how to switch between non-primitive and primitive Streams with a single operation.</p>
</div></section>
<section data-pdf-bookmark="Easy Parallelization" data-type="sect3"><div class="sect3" id="idm45115238964544">
<h3>Easy Parallelization</h3>
<p>Data processing with traditional loop constructs is inherently serial.
Concurrency is hard to do right and easy to do wrong, especially if you have to do it yourself.
Streams are designed to support parallel execution from the ground up, utilizing the <a href="https://openjdk.java.net/projects/jdk7/features/#f515">Fork/Join framework</a> introduced with Java 7.</p>
<p>Parallelizing a Stream is done by simply calling the <code>parallel</code> method at any point of the pipeline.
Although not every Stream pipeline is a good match for parallel processing.
The Stream source must have enough elements, and the operations have to be costly enough to justify the overhead of multiple threads.
Switching threads — so-called <a href="https://en.wikipedia.org/wiki/Context_switch#Cost">context switches</a> — is an expensive task.</p>
<p>In <a data-type="xref" href="ch08.xhtml#_01-parallel-streams">Chapter 8</a>, you’ll learn more about parallel Stream processing and concurrency in general.</p>
</div></section>
<section data-pdf-bookmark="(Lack of) Exception Handling" data-type="sect3"><div class="sect3" id="idm45115238959248">
<h3>(Lack of) Exception Handling</h3>
<p>Streams do a great job of reducing the verbosity of your code by introducing a functional approach to data processing.
However, this doesn’t make them immune to dealing with exceptions in their operations.</p>
<p>Lambda expressions, and therefore the logic of Stream operations, don’t have any special considerations or syntactic sugar to handle exceptions more concisely than you’re used to with <code>try</code>-<code>catch</code>.
You can read more about the general problem of exceptions in functional Java code and how to handle them in different ways in <a data-type="xref" href="ch10.xhtml#_02-exception-handling">Chapter 10</a>.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="Spliterator, the Backbone of Streams" data-type="sect2"><div class="sect2" id="_02-data-processing_spliterator">
<h2>Spliterator, the Backbone of Streams</h2>
<p>Just like “traditional” <em>for-each</em>-loop is built around the <code>Iterator&lt;T&gt;</code> type for traversing a sequence of elements, Streams have their own iteration interface: <code>java.util.Spliterator&lt;T&gt;</code>.</p>
<p>The <code>Iterator&lt;T&gt;</code> interface is solely based on the concept of “next” with only a few methods, which makes it a universal iterator for Java’s Collection API.
The concept behind <code>Spliterator&lt;T&gt;</code>, however, is that it has the ability to split off a subsequence of its elements into another <code>Spliterator&lt;T&gt;</code> based on certain characteristics.
This particular advantage over the <code>Iterator&lt;T&gt;</code> type makes it the core of the Stream API and allows Streams to process such subsequences in parallel, and still be able to iterate over Java Collection API types.</p>
<p><a data-type="xref" href="#_02-streams_spliterator-interface">Example 6-3</a> shows a simplified variant of <code>java.util.Spliterator</code>.</p>
<div data-type="example" id="_02-streams_spliterator-interface">
<h5><span class="label">Example 6-3. </span>The <code>java.util.Spliterator</code> interface</h5>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">interface</code> <code class="nc">Spliterator</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code> <code class="p">{</code>

    <code class="c1">// CHARACTERISTICS</code>
    <code class="kt">int</code> <code class="nf">characteristics</code><code class="p">();</code>
    <code class="k">default</code> <code class="kt">boolean</code> <code class="nf">hasCharacteristics</code><code class="p">(</code><code class="kt">int</code> <code class="n">characteristics</code><code class="p">)</code> <code class="p">{</code>
        <code class="c1">// ...</code>
    <code class="p">}</code>

    <code class="c1">// ITERATION</code>

    <code class="kt">boolean</code> <code class="nf">tryAdvance</code><code class="p">(</code><code class="n">Consumer</code><code class="o">&lt;?</code> <code class="kd">super</code> <code class="n">T</code><code class="o">&gt;</code> <code class="n">action</code><code class="p">);</code>
    <code class="k">default</code> <code class="kt">void</code> <code class="nf">forEachRemaining</code><code class="p">(</code><code class="n">Consumer</code><code class="o">&lt;?</code> <code class="kd">super</code> <code class="n">T</code><code class="o">&gt;</code> <code class="n">action</code><code class="p">)</code> <code class="p">{</code>
        <code class="c1">// ...</code>
    <code class="p">}</code>

    <code class="c1">// SPLITTING</code>
    <code class="n">Spliterator</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code> <code class="nf">trySplit</code><code class="p">();</code>

    <code class="c1">// SIZE</code>
    <code class="kt">long</code> <code class="nf">estimateSize</code><code class="p">();</code>
    <code class="k">default</code> <code class="kt">long</code> <code class="nf">getExactSizeIfKnown</code><code class="p">()</code> <code class="p">{</code>
        <code class="c1">// ...</code>
    <code class="p">}</code>

    <code class="c1">// COMPARATOR</code>
    <code class="k">default</code> <code class="n">Comparator</code><code class="o">&lt;?</code> <code class="kd">super</code> <code class="n">T</code><code class="o">&gt;</code> <code class="nf">getComparator</code><code class="p">()</code> <code class="p">{</code>
        <code class="c1">// ...</code>
    <code class="p">}</code>
<code class="p">}</code></pre></div>
<p>For the iteration process, the <code>boolean tryAdvance(Consumer action)</code> and <code>Spliterator&lt;T&gt; trySplit()</code> methods are the most important ones.
Still, a Spliterator’s characteristics decree the capabilities of all its operations.</p>
<p>Regarding Streams, the Spliterator’s characteristics are responsible for how a Stream iterates internally and what optimizations it supports.
There are eight combinable characteristics, defined as <code>static int</code> constants on the <code>Spliterator&lt;T&gt;</code> type, as listed in <a data-type="xref" href="#_02-data-processing-characteristics">Table 6-2</a>.
Even though it looks like the characteristics match expected Stream behavior, not all of them are actually used in the current Stream implementations.</p>
<table id="_02-data-processing-characteristics">
<caption><span class="label">Table 6-2. </span>Spliterator characteristics</caption>
<thead>
<tr>
<th>Characteristic</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><p><code>CONCURRENT</code></p></td>
<td><p>The underlying data source can safely be concurrently modified during traversal.<br/>
   Only affects the data source itself and has no implications for Stream-behavior.</p></td>
</tr>
<tr>
<td><p><code>DISTINCT</code></p></td>
<td><p>The data source only contains unique elements, like a <code>Set&lt;T&gt;</code>.<br/>
   Any pair of elements in a Stream is guaranteed to be <code>x.equals(y) == false</code>.</p></td>
</tr>
<tr>
<td><p><code>IMMUTABLE</code></p></td>
<td><p>The data source itself is immutable.
   No element can be added, replaced, or removed during traversal.<br/>
   Only affects the data source itself and has no implications for Stream-behavior.</p></td>
</tr>
<tr>
<td><p><code>NONNULL</code></p></td>
<td><p>The underlying data source guarantees not to contain any <code>null</code> values.<br/>
   Only affects the data source itself and has no implications for Stream-behavior.</p></td>
</tr>
<tr>
<td><p><code>ORDERED</code></p></td>
<td><p>There is a defined order for the elements of the data source.<br/>
   During traversal, the encountered elements will be in that particular order.</p></td>
</tr>
<tr>
<td><p><code>SORTED</code></p></td>
<td><p>If the <code>Spliterator&lt;T&gt;</code> is <code>SORTED</code>, its <code>getComparator()</code> method returns the associated <code>Comparator&lt;T&gt;</code>, or <code>null</code>, if the source is naturally sorted.<br/>
<code>SORTED</code> <code>Spliterators</code> must also be <code>ORDERED</code>.</p></td>
</tr>
<tr>
<td><p><code>SIZED</code></p></td>
<td><p>The data source knows its exact size.<br/>
<code>estimateSize()</code> returns the actual size, not an estimate.</p></td>
</tr>
<tr>
<td><p><code>SUBSIZED</code></p></td>
<td><p>Signifies that all split up chunk after calling <code>trySplit()</code> are also <code>SIZED</code>.<br/>
   Only affects the data source itself and has no implications for Stream-behavior.</p></td>
</tr>
</tbody>
</table>
<p>Stream characteristics don’t have to be fixed and can depend on the underlying data source.
<code>HashSet</code> is an example of a Spliterator with dynamic characteristics.
It uses the nested <code>HashMap.KeySpliterator</code> class which depends on the actual data, as seen in <a data-type="xref" href="#_02-data-processing_spliterator_characteristics-hashset">Example 6-4</a>.</p>
<div data-type="example" id="_02-data-processing_spliterator_characteristics-hashset">
<h5><span class="label">Example 6-4. </span>Spliterator characteristics of HashSet&lt;T&gt;</h5>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kt">int</code> <code class="nf">characteristics</code><code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="p">(</code><code class="n">fence</code> <code class="o">&lt;</code> <code class="mi">0</code> <code class="o">||</code> <code class="n">est</code> <code class="o">==</code> <code class="n">map</code><code class="p">.</code><code class="na">size</code> <code class="o">?</code> <code class="n">Spliterator</code><code class="p">.</code><code class="na">SIZED</code> <code class="p">:</code> <code class="mi">0</code><code class="p">)</code> <code class="o">|</code>
                <code class="n">Spliterator</code><code class="p">.</code><code class="na">DISTINCT</code><code class="p">;</code>
<code class="p">}</code></pre></div>
<p>The way <code>HashSet</code> creates its <code>KeySpliterator</code> shows that a Spliterator can use its surrounding context to make an informed decision about its capabilities.</p>
<p>You don’t need to think much about a Stream’s characteristics most of the time.
Usually, the underlying capabilities of a data source won’t change <em>magically</em> just because it’s traversed with a Stream.
A <code>Set&lt;T&gt;</code> will still provide distinct elements in an unordered fashion, regardless of being used with a <code>for</code>-loop or a Stream.
So choose the most fitting data source for the task, no matter the form of traversal used.</p>
<p>When using Streams, you usually don’t need to create a Spliterator yourself, as the convenience methods I’m going to discuss in the next chapter will do it behind the scenes for you.
Still, if you need to create a Spliterator for a custom data structure, you don’t necessarily have to implement the interface yourself, either.
You can use one of the many convenience methods of <code>java.util.Spliterators</code>, instead.
The easiest variant is the following method:</p>
<pre data-code-language="java" data-type="programlisting"><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code> <code class="n">Spliterator</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code> <code class="nf">spliterator</code><code class="p">(</code><code class="n">Iterator</code><code class="o">&lt;?</code> <code class="kd">extends</code> <code class="n">T</code><code class="o">&gt;</code> <code class="n">iterator</code><code class="p">,</code>
                               <code class="kt">long</code> <code class="n">size</code><code class="p">,</code>
                               <code class="kt">int</code> <code class="n">characteristics</code><code class="p">)</code></pre>
<p>The resulting Spliterator might not be the most optimized Spliterator with only limited parallel support, but it’s the simplest way to use existing <code>Iterator</code>-compatible data structures in Streams that don’t support them out of the box.</p>
<p>Check out the official <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Spliterators.xhtml">documentation</a> for more information about the 20+ convenience methods provided by the <code>java.util.Spliterators</code> type.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="Building Stream Pipelines" data-type="sect1"><div class="sect1" id="idm45115239226304">
<h1>Building Stream Pipelines</h1>
<p>The Stream API is extensive, and a detailed explanation of each operation and possible use case could easily fill a book itself.
Let’s take a higher-level view of building Stream pipelines with the available higher-order functions instead.
This overview will still help you to replace many data processing tasks with Stream pipelines in your code, especially those following the <em>map/filter/reduce</em> philosophy.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="_02-data-processing_map-filter-reduce">
<h1>Map/Filter/Reduce</h1>
<p>Most data processing follows the same scheme and can be distilled to only three elemental kinds of operations:</p>
<dl>
<dt class="horizontal">Map</dt>
<dd>
<p>Transforming data.</p>
</dd>
<dt class="horizontal">Filter</dt>
<dd>
<p>Choosing data.</p>
</dd>
<dt class="horizontal">Reduce</dt>
<dd>
<p>Deriving a result.</p>
</dd>
</dl>
<p>In many functional languages, these three steps have more explicit meanings, though.
They are readily available functions on collection types and are the building blocks for any data processing.</p>
<p>The <em>map/filter/reduce</em> pattern treats a sequence of elements as a unit.
It allows the removal of any control statements using internal iteration by
combining self-contained, pure functions into a bigger chain of operations.</p>
<p>As you might have guessed from the description, Java Streams fit nicely into this pattern.
Every single Stream operation falls into one of the three kinds.
<em>Intermediate</em> operations represent <em>map</em> and <em>filter</em> steps, and <em>terminal</em> operations the <em>reduce</em> step.</p>
</div></aside>
<p>The Stream API actually has operations named <code>map</code>, <code>filter</code>, and <code>reduce</code>.
Still, it provides a lot more operations than these three.
The logic of most of these additional operations can be replicated by <code>map</code>/<code>filter</code>/<code>reduce</code>, and internally, that’s often the case.
The extra operations give you a convenient way to avoid implementing common use cases yourself, with many different specialized operations readily available to you.</p>
<section data-pdf-bookmark="Creating a Stream" data-type="sect2"><div class="sect2" id="_02-data-processing_how-to-create">
<h2>Creating a Stream</h2>
<p>Every Stream pipeline starts with creating a new Stream instance from an existing data source.
The most commonly used data source are collection types.
That’s why the three methods <code>Stream&lt;E&gt; stream()</code>, <code>Stream&lt;E&gt; parallelStream()</code>, and <code>Spliterator&lt;E&gt; spliterator()</code> were retrofitted to <code>java.util.Collection</code> with the introduction of Streams in Java 8, as seen in <a data-type="xref" href="#_02-data-processing_how-to-create-retrofit">Example 6-5</a>.</p>
<div data-type="example" id="_02-data-processing_how-to-create-retrofit">
<h5><span class="label">Example 6-5. </span>Simplified Stream creation for Collection types</h5>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">interface</code> <code class="nc">Collection</code><code class="o">&lt;</code><code class="n">E</code><code class="o">&gt;</code> <code class="kd">extends</code> <code class="n">Iterable</code><code class="o">&lt;</code><code class="n">E</code><code class="o">&gt;</code> <code class="p">{</code>

  <code class="k">default</code> <code class="n">Stream</code><code class="o">&lt;</code><code class="n">E</code><code class="o">&gt;</code> <code class="nf">stream</code><code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="n">StreamSupport</code><code class="p">.</code><code class="na">stream</code><code class="p">(</code><code class="n">spliterator</code><code class="p">(),</code> <code class="kc">false</code><code class="p">);</code>
  <code class="p">}</code>

  <code class="k">default</code> <code class="n">Stream</code><code class="o">&lt;</code><code class="n">E</code><code class="o">&gt;</code> <code class="nf">parallelStream</code><code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="n">StreamSupport</code><code class="p">.</code><code class="na">stream</code><code class="p">(</code><code class="n">spliterator</code><code class="p">(),</code> <code class="kc">true</code><code class="p">);</code>
  <code class="p">}</code>

  <code class="nd">@Override</code>
  <code class="k">default</code> <code class="n">Spliterator</code><code class="o">&lt;</code><code class="n">E</code><code class="o">&gt;</code> <code class="nf">spliterator</code><code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="n">Spliterators</code><code class="p">.</code><code class="na">spliterator</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="mi">0</code><code class="p">);</code>
  <code class="p">}</code>

  <code class="c1">// ...</code>
<code class="p">}</code></pre></div>
<p>The <code>stream</code> method is the simplest way to create a new Stream instance from any <code>Collection</code>-based data structure, like <code>List</code> or <code>Set</code>.
It utilizes an <code>IMMUTABLE</code> and <code>CONCURRENT</code> <code>Spliterator</code> as its default implementation.
However, many <code>Collection</code> types provide their own implementations with optimized characteristics and behavior.</p>
<p>Even though the <code>stream</code> method on <code>Collection</code> might be the most convenient method to create a Stream, the JDK provides many other ways to create Streams as <code>static</code> convenience methods, like <code>Stream.of(T…​ values)</code>.
In <a data-type="xref" href="ch07.xhtml#_02-streams">Chapter 7</a>, you’ll learn more ways to create Streams for different use cases, like infinite Streams or working with I/O.</p>
</div></section>
<section data-pdf-bookmark="Doing the Work" data-type="sect2"><div class="sect2" id="_02-data-processing_doing-the-work">
<h2>Doing the Work</h2>
<p>Now that you have a Stream, the next step is working with its elements.</p>
<p>Working with Stream elements is done by <em>intermediate operations</em>, which fall into three categories: transforming (<em>map</em>) elements, selecting (<em>filter</em>) elements, or modifying general Stream behavior.</p>
<div data-type="tip"><h6>Tip</h6>
<p>All Stream operations are aptly named and have ample <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/stream/Stream.xhtml">documentation</a> and examples.
Many methods use the “not-yet a standard” addition to JavaDoc<sup><a data-type="noteref" href="ch06.xhtml#idm45115238384128" id="idm45115238384128-marker">3</a></sup> <code>@implSpec</code> to refer to implementation-specific behavior.
So make sure to check out either the online documentation or the JavaDoc itself in case of your IDE isn’t rendering all of the documentation correctly.</p>
</div>
<p>In this section, I will be using a simple <code>Shape</code> Record, shown in <a data-type="xref" href="#_01-streams_operations_shape">Example 6-6</a>, to demonstrate the different operations.</p>
<div data-type="example" id="_01-streams_operations_shape">
<h5><span class="label">Example 6-6. </span>A simple Shape type</h5>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">record</code> <code class="nc">Shape</code><code class="p">(</code><code class="kt">int</code> <code class="n">corners</code><code class="p">)</code> <code class="kd">implements</code> <code class="n">Comparable</code><code class="o">&lt;</code><code class="n">Shape</code><code class="o">&gt;</code> <code class="p">{</code>

  <code class="c1">// HELPER METHODS</code>

  <code class="kd">public</code> <code class="kt">boolean</code> <code class="nf">hasCorners</code><code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="n">corners</code><code class="p">()</code> <code class="o">&gt;</code> <code class="mi">0</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="kd">public</code> <code class="n">List</code><code class="o">&lt;</code><code class="n">Shape</code><code class="o">&gt;</code> <code class="nf">twice</code><code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="n">List</code><code class="p">.</code><code class="na">of</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="k">this</code><code class="p">);</code>
  <code class="p">}</code>

  <code class="nd">@Override</code>
  <code class="kd">public</code> <code class="kt">int</code> <code class="nf">compareTo</code><code class="p">(</code><code class="n">Shape</code> <code class="n">o</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="n">Integer</code><code class="p">.</code><code class="na">compare</code><code class="p">(</code><code class="n">corners</code><code class="p">(),</code> <code class="n">o</code><code class="p">.</code><code class="na">corners</code><code class="p">());</code>
  <code class="p">}</code>

  <code class="c1">// FACTORY METHODS</code>

  <code class="kd">public</code> <code class="kd">static</code> <code class="n">Shape</code> <code class="nf">circle</code><code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">new</code> <code class="n">Shape</code><code class="p">(</code><code class="mi">0</code><code class="p">);</code>
  <code class="p">}</code>

  <code class="kd">public</code> <code class="kd">static</code> <code class="n">Shape</code> <code class="nf">triangle</code><code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">new</code> <code class="n">Shape</code><code class="p">(</code><code class="mi">3</code><code class="p">);</code>
  <code class="p">}</code>

  <code class="kd">public</code> <code class="kd">static</code> <code class="n">Shape</code> <code class="nf">square</code><code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">new</code> <code class="n">Shape</code><code class="p">(</code><code class="mi">4</code><code class="p">);</code>
  <code class="p">}</code>
<code class="p">}</code></pre></div>
<p>There won’t be a dedicated code example for every operation, as there are just too many.
However, each operation and its element flow is illustrated.</p>
<section data-pdf-bookmark="Selecting Elements" data-type="sect3"><div class="sect3" id="idm45115238233712">
<h3>Selecting Elements</h3>
<p>The first common task of data processing is selecting the correct elements, either by filtering with a <code>Predicate</code> or by choosing based on the number of elements.</p>
<dl>
<dt><code>Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)</code></dt>
<dd>
<p>The most straightforward way of filtering elements.
If the <code>Predicate</code> evaluates to <code>true</code>, the element is considered for further processing.
The <code>static</code> method <code>Predicate&lt;T&gt;.not(Predicate&lt;T&gt;)</code> allows for an easy negation of a Predicate without losing the advantage of method references.
Common tasks, like <code>null</code> checks, are available via the <code>java.util.Objects</code> class and are usable as method references.
See <a data-type="xref" href="#_02-data-processing_intermediate-ops_filter">Figure 6-7</a>.</p>
</dd>
</dl>
<figure><div class="figure" id="_02-data-processing_intermediate-ops_filter">
<img alt="Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)" height="269" src="assets/afaj_0607.png" width="350"/>
<h6><span class="label">Figure 6-7. </span><code>Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)</code></h6>
</div></figure>
<dl>
<dt><code>Stream&lt;T&gt; dropWhile(Predicate&lt;? super T&gt; predicate)</code></dt>
<dd>
<p>Discards — or <em>drops</em> — any element passing through the operation as long as the <code>Predicate</code> evaluates to <code>true</code>.
This operation is designed for <code>ORDERED</code> Streams.
The dropped elements won’t be deterministic if the Stream isn’t <code>ORDERED</code>.
For sequential Streams, dropping elements is a cheap operation.
A parallel Stream, though, has to coordinate between the underlying threads, making the operation quite costly.
The operation was introduced with Java 9.
See <a data-type="xref" href="#_02-data-processing_intermediate-ops_dropWhile">Figure 6-8</a>.</p>
</dd>
</dl>
<figure><div class="figure" id="_02-data-processing_intermediate-ops_dropWhile">
<img alt="Stream&lt;T&gt; dropWhile(Predicate&lt;? super T&gt; predicate)" height="269" src="assets/afaj_0608.png" width="350"/>
<h6><span class="label">Figure 6-8. </span><code>Stream&lt;T&gt; dropWhile(Predicate&lt;? super T&gt; predicate)</code></h6>
</div></figure>
<dl>
<dt><code>Stream&lt;T&gt; takeWhile(Predicate&lt;? super T&gt; predicate)</code></dt>
<dd>
<p>The antagonist to <code>dropWhile</code>, choosing elements until the <code>Predicate</code> evaluates to <code>false</code>.
The operation was introduced with Java 9.
See <a data-type="xref" href="#_02-data-processing_intermediate-ops_takeWhile">Figure 6-9</a>.</p>
</dd>
</dl>
<figure><div class="figure" id="_02-data-processing_intermediate-ops_takeWhile">
<img alt="Stream&lt;T&gt; takeWhile(Predicate&lt;? super T&gt; predicate)" height="269" src="assets/afaj_0609.png" width="350"/>
<h6><span class="label">Figure 6-9. </span><code>Stream&lt;T&gt; takeWhile(Predicate&lt;? super T&gt; predicate)</code></h6>
</div></figure>
<dl>
<dt><code>Stream&lt;T&gt; limit(long maxSize)</code></dt>
<dd>
<p>Limits the maximum amount of elements passing through this operation to <code>maxSize</code>.
See <a data-type="xref" href="#_02-data-processing_intermediate-ops_limit">Figure 6-10</a>.</p>
</dd>
</dl>
<figure><div class="figure" id="_02-data-processing_intermediate-ops_limit">
<img alt="Stream&lt;T&gt; limit(long maxSize)" height="269" src="assets/afaj_0610.png" width="350"/>
<h6><span class="label">Figure 6-10. </span><code>Stream&lt;T&gt; limit(long maxSize)</code></h6>
</div></figure>
<dl>
<dt><code>Stream&lt;T&gt; skip(long n)</code></dt>
<dd>
<p>The antagonist to <code>limit</code>, skipping <code>n</code> elements before passing all remaining elements to the subsequent Stream operations.
See <a data-type="xref" href="#_02-data-processing_intermediate-ops_skip">Figure 6-11</a>.</p>
</dd>
</dl>
<figure><div class="figure" id="_02-data-processing_intermediate-ops_skip">
<img alt="Stream&lt;T&gt; skip(long n)" height="269" src="assets/afaj_0611.png" width="350"/>
<h6><span class="label">Figure 6-11. </span><code>Stream&lt;T&gt; skip(long n)</code></h6>
</div></figure>
<dl>
<dt><code>Stream&lt;T&gt; distinct()</code></dt>
<dd>
<p>Compares elements with <code>Object#equals(Object)</code> to return only distinct elements.
This operation needs to buffer all elements passing through to compare them.
There’s no integrated way to provide a custom <code>Comparator&lt;T&gt;</code> to determine distinctness.
See <a data-type="xref" href="#_02-data-processing_intermediate-ops_distinct">Figure 6-12</a>.</p>
</dd>
</dl>
<figure><div class="figure" id="_02-data-processing_intermediate-ops_distinct">
<img alt="Stream&lt;T&gt; distinct()" height="269" src="assets/afaj_0612.png" width="350"/>
<h6><span class="label">Figure 6-12. </span><code>Stream&lt;T&gt; distinct()</code></h6>
</div></figure>
<dl>
<dt><code>Stream&lt;T&gt; sorted()</code></dt>
<dd>
<p>Sorts the elements in their natural order if they conform to <code>java.util.Comparable</code>.
Otherwise, a <code>java.lang.ClassCastException</code> is thrown on Stream consumption.
<a data-type="xref" href="#_02-data-processing_intermediate-ops_sorted">Figure 6-13</a> assumes the natural sorting for shapes is by their number of corners.
This operation needs to buffer all elements passing through to sort them.
See <a data-type="xref" href="#_02-data-processing_intermediate-ops_sorted">Figure 6-13</a>.</p>
</dd>
</dl>
<figure><div class="figure" id="_02-data-processing_intermediate-ops_sorted">
<img alt="Stream&lt;T&gt; sorted()" height="305" src="assets/afaj_0613.png" width="350"/>
<h6><span class="label">Figure 6-13. </span><code>Stream&lt;T&gt; sorted()</code></h6>
</div></figure>
<dl>
<dt><code>Stream&lt;T&gt; sorted(Comparator&lt;? super T&gt; comparator)</code></dt>
<dd>
<p>A more flexible version of <code>sorted</code> where you can provide a custom <code>comparator</code>.</p>
</dd>
</dl>
</div></section>
<section data-pdf-bookmark="Mapping Elements" data-type="sect3"><div class="sect3" id="idm45115238233120">
<h3>Mapping Elements</h3>
<p>Another significant category of operation is <em>mapping</em> — or transforming — elements.
Not many Streams and their elements start out in the desired form.
Sometimes you need a different representation or are only interested in a subset of an element’s properties.</p>
<p>Initially, only two mapping operations were available to Streams:</p>
<dl>
<dt><code>Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper)</code></dt>
<dd>
<p>The <code>mapper</code> function is applied to the elements, and the new element is returned down the Stream.
See <a data-type="xref" href="#_02-data-processing_intermediate-ops_map">Figure 6-14</a>.</p>
</dd>
</dl>
<figure><div class="figure" id="_02-data-processing_intermediate-ops_map">
<img alt="Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper)" height="269" src="assets/afaj_0614.png" width="350"/>
<h6><span class="label">Figure 6-14. </span><code>Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper)</code></h6>
</div></figure>
<dl>
<dt><code>Stream&lt;R&gt; flatMap(Function&lt;? super T, ? extends Stream&lt;? extends R&gt;&gt; mapper)</code></dt>
<dd>
<p>The <code>mapper</code> function is still applied to the elements.
However, instead of returning a new element, a <code>Stream&lt;R&gt;</code> needs to be returned.
If <code>map</code> were used, the result would be a nested <code>Stream&lt;Stream&lt;R&gt;&gt;</code>, which is most likely not what you want.
The <code>flatMap</code> operation “flattens” a container-like element, like a collection or Optional, into a new Stream of multiple elements which are used in subsequent operations.
See <a data-type="xref" href="#_02-data-processing_intermediate-ops_flatMap">Figure 6-15</a>.</p>
</dd>
</dl>
<figure><div class="figure" id="_02-data-processing_intermediate-ops_flatMap">
<img alt="Stream&lt;R&gt; flatMap(Function&lt;? super T, ? extends Stream&lt;? extends R&gt;&gt; mapper)" height="413" src="assets/afaj_0615.png" width="350"/>
<h6><span class="label">Figure 6-15. </span><code>Stream&lt;R&gt; flatMap(Function&lt;? super T, ? extends Stream&lt;? extends R&gt;&gt; mapper)</code></h6>
</div></figure>
<p>Java 16 introduced an additional mapping method (and its three primitive counterparts) that has a similar role as <code>flatMap</code>:</p>
<dl>
<dt><code>Stream&lt;R&gt; mapMulti(BiConsumer&lt;? super T, ? super Consumer&lt;R&gt;&gt; mapper)</code></dt>
<dd>
<p>The <code>mapMulti</code> operation doesn’t require the mapper to return a Stream instance.
Instead, a <code>Consumer&lt;R&gt;</code> conveys the elements further down the Stream.</p>
</dd>
</dl>
<p>In its current form, the <code>Shape</code> type doesn’t lead to cleaner code when the <code>mapMulti</code> operation is used, as seen in <a data-type="xref" href="#_02-data-processing_flatmap-vs-mapMulti">Example 6-7</a>.</p>
<div data-type="example" id="_02-data-processing_flatmap-vs-mapMulti">
<h5><span class="label">Example 6-7. </span>Shape <code>flatMap</code> versus <code>mapMulti</code></h5>
<pre data-code-language="java" data-type="programlisting"><code class="c1">// FLATMAP</code>

<code class="n">Stream</code><code class="o">&lt;</code><code class="n">Shape</code><code class="o">&gt;</code> <code class="n">flatMap</code> <code class="o">=</code>
  <code class="n">Stream</code><code class="p">.</code><code class="na">of</code><code class="p">(</code><code class="n">Shape</code><code class="p">.</code><code class="na">square</code><code class="p">(),</code> <code class="n">Shape</code><code class="p">.</code><code class="na">triangle</code><code class="p">(),</code> <code class="n">Shape</code><code class="p">.</code><code class="na">circle</code><code class="p">())</code>
        <code class="p">.</code><code class="na">map</code><code class="p">(</code><code class="n">Shape</code><code class="p">::</code><code class="n">twice</code><code class="p">)</code>
        <code class="p">.</code><code class="na">flatMap</code><code class="p">(</code><code class="n">List</code><code class="p">::</code><code class="n">stream</code><code class="p">);</code>

<code class="c1">// MAPMULTI</code>

<code class="n">Stream</code><code class="o">&lt;</code><code class="n">Shape</code><code class="o">&gt;</code> <code class="n">mapMulti</code> <code class="o">=</code>
  <code class="n">Stream</code><code class="p">.</code><code class="na">of</code><code class="p">(</code><code class="n">Shape</code><code class="p">.</code><code class="na">square</code><code class="p">(),</code> <code class="n">Shape</code><code class="p">.</code><code class="na">triangle</code><code class="p">(),</code> <code class="n">Shape</code><code class="p">.</code><code class="na">circle</code><code class="p">())</code>
        <code class="p">.</code><code class="na">mapMulti</code><code class="p">((</code><code class="n">shape</code><code class="p">,</code> <code class="n">downstream</code><code class="p">)</code> <code class="o">-&gt;</code> <code class="n">shape</code><code class="p">.</code><code class="na">twice</code><code class="p">()</code>
                                              <code class="p">.</code><code class="na">forEach</code><code class="p">(</code><code class="n">downstream</code><code class="p">::</code><code class="n">accept</code><code class="p">));</code></pre></div>
<p>The winner in terms of conciseness and readability is clearly <code>flatMap</code>.
Still, the main advantage of <code>multiMap</code> is that it condenses two operations, <code>map</code> and <code>flatMap</code>, into a single one.</p>
<p>The default implementation of <code>mapMulti</code> actually uses <code>flatMap</code> to create a new Stream for you, so your mapped elements don’t need to know how to create a Stream themselves.
By calling the downstream <code>Consumer</code> yourself, <em>you</em> decide which mapped elements belong to the new Stream, and the pipeline is responsible for creating it.</p>
<p>The <code>mapMulti</code> operations aren’t supposed to replace <code>flatMap</code> operations.
They are merely a complementary addition to Stream’s repertoire of operations.
There are use-cases where <code>mapMulti</code> is preferable to <code>flatMap</code>, though:</p>
<ul>
<li>
<p>Only a small number of elements, or even zero, are mapped down the Stream pipeline.
Using <code>mapMulti</code> avoids the overhead of creating a new Stream for every group of mapped elements, as done by <code>flatMap</code>.</p>
</li>
<li>
<p>When an iterative approach to providing the mapped results is more straightforward than creating a new Stream instance.
This gives you more freedom for the mapping process before feeding an element to the <code>Consumer</code>.</p>
</li>
</ul>
</div></section>
<section data-pdf-bookmark="Peeking into a Stream" data-type="sect3"><div class="sect3" id="idm45115238087264">
<h3>Peeking into a Stream</h3>
<p>One intermediate operation doesn’t fit into the <em>map/filter/reduce</em> philosophy: <code>peek</code>.</p>
<p>The conciseness of Streams can pack a lot of functionality into a singular fluent call.
Even though that’s one of their main selling points, debugging them is way more challenging than traditional imperative loop constructs.
To ease this pain point, the Stream API includes a particular operation, <code>peek(Consumer&lt;? super T&gt; action)</code>, to, well, “peek” into the Stream without interfering with the elements, as seen in <a data-type="xref" href="#_02-data-processing_peek">Example 6-8</a></p>
<div data-type="example" id="_02-data-processing_peek">
<h5><span class="label">Example 6-8. </span>Peeking into a Stream</h5>
<pre data-code-language="java" data-type="programlisting"><code class="n">List</code><code class="o">&lt;</code><code class="n">Shape</code><code class="o">&gt;</code> <code class="n">result</code> <code class="o">=</code>
  <code class="n">Stream</code><code class="p">.</code><code class="na">of</code><code class="p">(</code><code class="n">Shape</code><code class="p">.</code><code class="na">square</code><code class="p">(),</code> <code class="n">Shape</code><code class="p">.</code><code class="na">triangle</code><code class="p">(),</code> <code class="n">Shape</code><code class="p">.</code><code class="na">circle</code><code class="p">())</code>
        <code class="p">.</code><code class="na">map</code><code class="p">(</code><code class="n">Shape</code><code class="p">::</code><code class="n">twice</code><code class="p">)</code>
        <code class="p">.</code><code class="na">flatMap</code><code class="p">(</code><code class="n">List</code><code class="p">::</code><code class="n">stream</code><code class="p">)</code>
        <code class="p">.</code><code class="na">peek</code><code class="p">(</code><code class="n">shape</code> <code class="o">-&gt;</code> <code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="s">"current: "</code> <code class="o">+</code> <code class="n">shape</code><code class="p">))</code>
        <code class="p">.</code><code class="na">filter</code><code class="p">(</code><code class="n">shape</code> <code class="o">-&gt;</code> <code class="n">shape</code><code class="p">.</code><code class="na">corners</code><code class="p">()</code> <code class="o">&lt;</code> <code class="mi">4</code><code class="p">)</code>
        <code class="p">.</code><code class="na">collect</code><code class="p">(</code><code class="n">Collectors</code><code class="p">.</code><code class="na">toList</code><code class="p">());</code>

<code class="c1">// OUTPUT</code>
<code class="c1">// current: Shape[corners=4]</code>
<code class="c1">// current: Shape[corners=4]</code>
<code class="c1">// current: Shape[corners=3]</code>
<code class="c1">// current: Shape[corners=3]</code>
<code class="c1">// current: Shape[corners=0]</code>
<code class="c1">// current: Shape[corners=0]</code></pre></div>
<p>The <code>peek</code> operation is mainly intended to support debugging.
It might get skipped for optimizing the Stream if the operation isn’t necessarily required for the final result, like counting elements, and the pipeline can get short-circuited.</p>
<p>The short-circuiting of operations will be explained more in <a data-type="xref" href="#_02-data-processing_order-matters">“The Cost of Operations”</a>.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="Terminating the Stream" data-type="sect2"><div class="sect2" id="idm45115238467376">
<h2>Terminating the Stream</h2>
<p>A <em>terminal</em> operation is the final step of a Stream pipeline that initiates the actual processing of the elements to produce a result or side effect.
Unlike intermediate operations and their delayed nature, terminal operations evaluate eagerly.</p>
<p>The available terminal operations fall into four different groups:</p>
<ul>
<li>
<p>Reductions</p>
</li>
<li>
<p>Aggregations</p>
</li>
<li>
<p>Finding and matching</p>
</li>
<li>
<p>Consuming</p>
</li>
</ul>
<section data-pdf-bookmark="Reducing Elements" data-type="sect3"><div class="sect3" id="_02-data-processing_reduce">
<h3>Reducing Elements</h3>
<p><em>Reduction operations</em>, also known as <em>fold</em> operations, reduce the Stream’s elements to a single result by repeatedly applying an <em>accumulator</em> operator.
Such an operator uses the previous result to combine it with the current element to generate a new result, as shown in <a data-type="xref" href="#_02-data-processing_intermediate-ops_reduce">Figure 6-16</a>.
The <em>accumulator</em> is supposed to always return a new value without requiring an intermediate data structure.</p>
<figure><div class="figure" id="_02-data-processing_intermediate-ops_reduce">
<img alt="Reducing shapes by combining them next to each other" height="305" src="assets/afaj_0616.png" width="358"/>
<h6><span class="label">Figure 6-16. </span>Reducing shapes by combining them next to each other</h6>
</div></figure>
<p>Like many functional tools, reductions often feel alien at first due to their nomenclature, especially if you come from an imperative background.
The simplest way to better understand the general concept behind such tools is by looking at the involved parts and how they would work in a more familiar form.</p>
<p>In the case of reduction, there are three parts involved:</p>
<dl>
<dt>The elements</dt>
<dd>
<p>Data processing is, well, about processing data elements.
The familiar equivalent to a Stream would be any collection type.</p>
</dd>
<dt>The initial value</dt>
<dd>
<p>The accumulation of data has to start somewhere.
Sometimes this initial value is explicit, but certain reduction variants omit it by replacing it with the first element or allowing for an optional result if no element is present.</p>
</dd>
<dt>The accumulator function</dt>
<dd>
<p>The reduction logic solely works with the current element and the previous result or initial value.
Depending only on its input to create a new value makes this a pure function.</p>
</dd>
</dl>
<p>Take finding the biggest value of a <code>Collection&lt;Integer&gt;</code> for an example.
You have to go through each element and compare it with the next one, returning the greater number at each step, as shown in <a data-type="xref" href="#_02-data-processing_terminal-ops_reduce-for-loop-specific">Example 6-9</a>.
All three parts of a reduction are represented.</p>
<div data-type="example" id="_02-data-processing_terminal-ops_reduce-for-loop-specific">
<h5><span class="label">Example 6-9. </span>Finding the biggest number in a <code>Collection&lt;Integer&gt;</code></h5>
<pre data-code-language="java" data-type="programlisting"><code class="n">Integer</code> <code class="nf">max</code><code class="p">(</code><code class="n">Collection</code><code class="o">&lt;</code><code class="n">Integer</code><code class="o">&gt;</code> <code class="n">numbers</code><code class="p">)</code> <code class="p">{</code>
  <code class="kt">int</code> <code class="n">result</code> <code class="o">=</code> <code class="n">Integer</code><code class="p">.</code><code class="na">MIN_VALUE</code><code class="p">;</code> <a class="co" href="#callout_data_processing_with_streams_CO3-1" id="co_data_processing_with_streams_CO3-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a>

  <code class="k">for</code> <code class="p">(</code><code class="kd">var</code> <code class="n">value</code> <code class="p">:</code> <code class="n">numbers</code><code class="p">)</code> <code class="p">{</code> <a class="co" href="#callout_data_processing_with_streams_CO3-2" id="co_data_processing_with_streams_CO3-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a>
    <code class="n">result</code> <code class="o">=</code> <code class="n">Math</code><code class="p">.</code><code class="na">max</code><code class="p">(</code><code class="n">result</code><code class="p">,</code> <code class="n">value</code><code class="p">)</code><code class="p">;</code> <a class="co" href="#callout_data_processing_with_streams_CO3-3" id="co_data_processing_with_streams_CO3-3"><img alt="3" height="12" src="assets/3.png" width="12"/></a>
  <code class="p">}</code>

  <code class="k">return</code> <code class="n">result</code><code class="p">;</code> <a class="co" href="#callout_data_processing_with_streams_CO3-4" id="co_data_processing_with_streams_CO3-4"><img alt="4" height="12" src="assets/4.png" width="12"/></a>
<code class="p">}</code></pre></div>
<dl class="calloutlist">
<dt><a class="co" href="#co_data_processing_with_streams_CO3-1" id="callout_data_processing_with_streams_CO3-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p>The initial value depends on the required task.
In this case, comparing against the smallest possible <code>int</code> value is the logical choice to find the greatest number.</p></dd>
<dt><a class="co" href="#co_data_processing_with_streams_CO3-2" id="callout_data_processing_with_streams_CO3-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a></dt>
<dd><p>The reduction logic has to be applied to each element.</p></dd>
<dt><a class="co" href="#co_data_processing_with_streams_CO3-3" id="callout_data_processing_with_streams_CO3-3"><img alt="3" height="12" src="assets/3.png" width="12"/></a></dt>
<dd><p>The actual reduction logic, representing the accumulator function.</p></dd>
<dt><a class="co" href="#co_data_processing_with_streams_CO3-4" id="callout_data_processing_with_streams_CO3-4"><img alt="4" height="12" src="assets/4.png" width="12"/></a></dt>
<dd><p>The reduced value.</p></dd>
</dl>
<p>To better reflect a reduction operation in general, the previous example allows you to derive a generic reduction operation as shown in <a data-type="xref" href="#_02-data-processing_terminal-ops_reduce-for-loop">Example 6-10</a>.</p>
<div data-type="example" id="_02-data-processing_terminal-ops_reduce-for-loop">
<h5><span class="label">Example 6-10. </span>Reduce-like <code>for</code>-loop</h5>
<pre data-code-language="java" data-type="programlisting"><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code> <code class="n">T</code> <code class="nf">reduce</code><code class="p">(</code><code class="n">Collection</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code> <code class="n">elements</code><code class="p">,</code>
             <code class="n">T</code> <code class="n">initialValue</code><code class="p">,</code>
             <code class="n">BinaryOperator</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code> <code class="n">accumulator</code><code class="p">)</code> <code class="p">{</code>

  <code class="n">T</code> <code class="n">result</code> <code class="o">=</code> <code class="n">initialValue</code><code class="p">;</code>

  <code class="k">for</code> <code class="p">(</code><code class="n">T</code> <code class="n">element</code> <code class="p">:</code> <code class="n">elements</code><code class="p">)</code> <code class="p">{</code>
    <code class="n">result</code> <code class="o">=</code> <code class="n">accumulator</code><code class="p">.</code><code class="na">apply</code><code class="p">(</code><code class="n">result</code><code class="p">,</code> <code class="n">element</code><code class="p">);</code>
  <code class="p">}</code>

  <code class="k">return</code> <code class="n">result</code><code class="p">;</code>
<code class="p">}</code></pre></div>
<p>The generic variant again highlights that a functional approach separates <em>how</em> a task is done from <em>what</em> the task is actually doing.
This way, the previous example of finding the maximum value can be simplified to a single method call by using the generic variant:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">Integer</code> <code class="nf">max</code><code class="p">(</code><code class="n">Collection</code><code class="o">&lt;</code><code class="n">Integer</code><code class="o">&gt;</code> <code class="n">numbers</code><code class="p">)</code> <code class="p">{</code>
  <code class="k">return</code> <code class="n">reduce</code><code class="p">(</code><code class="n">elements</code><code class="p">,</code>
                <code class="n">Integer</code><code class="p">.</code><code class="na">MIN_VALUE</code><code class="p">,</code>
                <code class="n">Math</code><code class="p">::</code><code class="n">max</code><code class="p">);</code>
<code class="p">}</code></pre>
<p>The <code>max</code> method is also an example of why the Stream API provides more than just a <code>reduce</code> method: specialization to cover common use cases.</p>
<p>Even though all the specialized Stream operations can be implemented with one of the three available <code>reduce</code> methods — some of them actually are --⁠, the specialized variants create a more expressive fluent Stream call for typical reduction operations.</p>
<p>The Stream API has three different explicit <code>reduce</code> operations:</p>
<dl>
<dt><code>T reduce(T identity, BinaryOperator&lt;T&gt; accumulator)</code></dt>
<dd>
<p>The <code>identity</code> is the seed — initial — value for the chain of <code>accumulator</code> operations.
Although it’s equivalent to <a data-type="xref" href="#_02-data-processing_terminal-ops_reduce-for-loop">Example 6-10</a>, it’s not constrained by the sequential nature of a <code>for</code>-loop.</p>
</dd>
<dt><code>Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator)</code></dt>
<dd>
<p>Instead of requiring a seed value, this operation picks the first encountered element as its initial value.
That’s why it returns an <code>Optional&lt;T&gt;</code>, which you will learn more about in <a data-type="xref" href="ch09.xhtml#_02-optionals">Chapter 9</a>.
An empty <code>Optional&lt;T&gt;</code> is returned if the Stream doesn’t contain any elements.</p>
</dd>
<dt><code>U reduce(U identity, BiFunction&lt;U, ? super T, U&gt; accumulator, <br/>BinaryOperator&lt;U&gt; combiner)</code></dt>
<dd>
<p>This variant combines a <code>map</code> and <code>reduce</code> operation, which is required if the Stream contains elements of type <code>T</code>, but the desired reduced result is of type <code>U</code>.
Alternatively, you can use an explicit <code>map</code> and <code>reduce</code> operation separately.
Such a Stream pipeline might be more straightforward than using the combined <code>reduce</code> operations, as seen in <a data-type="xref" href="#_02-data-processing_terminal-ops_reduce-map-reduce">Example 6-11</a> for summing up all characters in a <code>Stream&lt;String&gt;</code>.</p>
</dd>
</dl>
<div data-type="example" id="_02-data-processing_terminal-ops_reduce-map-reduce">
<h5><span class="label">Example 6-11. </span>Three-arguments <code>reduce</code> operation versus <code>map</code> + two-arguments <code>reduce</code></h5>
<pre data-code-language="java" data-type="programlisting"><code class="kd">var</code> <code class="n">reduceOnly</code> <code class="o">=</code> <code class="n">Stream</code><code class="p">.</code><code class="na">of</code><code class="p">(</code><code class="s">"apple"</code><code class="p">,</code> <code class="s">"orange"</code><code class="p">,</code> <code class="s">"banana"</code><code class="p">)</code>
                       <code class="p">.</code><code class="na">reduce</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code>
                               <code class="p">(</code><code class="n">acc</code><code class="p">,</code> <code class="n">str</code><code class="p">)</code> <code class="o">-&gt;</code> <code class="n">acc</code> <code class="o">+</code> <code class="n">str</code><code class="p">.</code><code class="na">length</code><code class="p">(),</code>
                               <code class="n">Integer</code><code class="p">::</code><code class="n">sum</code><code class="p">);</code>


<code class="kd">var</code> <code class="n">mapReduce</code> <code class="o">=</code> <code class="n">Stream</code><code class="p">.</code><code class="na">of</code><code class="p">(</code><code class="s">"apple"</code><code class="p">,</code> <code class="s">"orange"</code><code class="p">,</code> <code class="s">"banana"</code><code class="p">)</code>
                      <code class="p">.</code><code class="na">mapToInt</code><code class="p">(</code><code class="n">String</code><code class="p">::</code><code class="n">length</code><code class="p">)</code>
                      <code class="p">.</code><code class="na">reduce</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code> <code class="p">(</code><code class="n">acc</code><code class="p">,</code> <code class="n">length</code><code class="p">)</code> <code class="o">-&gt;</code> <code class="n">acc</code> <code class="o">+</code> <code class="n">length</code><code class="p">);</code></pre></div>
<p>Which to choose — a single <code>reduce</code> or separate <code>map</code> and <code>reduce</code> — depends on your preferences and if the lambda expressions can be generalized or refactored, so you could use method references instead.</p>
<p>As mentioned before, some typical reduction tasks are available as specialized operations, including any variants for primitive Streams, as listed in <a data-type="xref" href="#_02-data-processing_terminal-typical-operations">Table 6-3</a>.
The listed methods belong to <code>IntStream</code> but are also available for <code>LongStream</code> and <code>DoubleStream</code> with their related types.</p>
<table id="_02-data-processing_terminal-typical-operations">
<caption><span class="label">Table 6-3. </span>Typical reduction operations</caption>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td colspan="2"><p>Stream&lt;T&gt;</p></td>
</tr>
<tr>
<td><p><code>Optional&lt;T&gt; min(Comparator&lt;? super T&gt; comparator)<br/>
Optional&lt;T&gt; max(Comparator&lt;? super T&gt; comparator)</code></p></td>
<td><p>Returns the minimum/maximum element of the Stream according to the provided <code>comparator</code>.
   An empty <code>Optional&lt;T&gt;</code> is returned if no elements reach the operation.</p></td>
</tr>
<tr>
<td><p><code>long count()</code></p></td>
<td><p>Returns the element count present at the end of the Stream pipeline.
   Be aware that certain Stream implementations may choose <em>not</em> to execute all intermediate operations if the count is determinable from the Stream itself, e.g., its characteristics contain <code>SIZED</code>, and no filtering is going on in the pipeline.</p></td>
</tr>
<tr>
<td colspan="2"><p>Primitive Streams</p></td>
</tr>
<tr>
<td><p><code>int sum()</code></p></td>
<td><p>Sums up the elements of the Stream.</p></td>
</tr>
<tr>
<td><p><code>OptionalDouble average()</code></p></td>
<td><p>Calculates the arithmetic mean of the Stream elements.
   If the Stream contains no elements at the point of the terminal operation, an empty <code>OptionalDouble</code> is returned.</p></td>
</tr>
<tr>
<td><p><code>IntSummaryStatistics summaryStatistics()</code></p></td>
<td><p>Returns a summary of the Stream elements, containing the <em>count</em>, <em>sum</em>, <em>min</em>, and <em>max</em> of the Stream elements.</p></td>
</tr>
</tbody>
</table>
<p>Even after migrating your code towards a more functional approach, reduction operations might not be your go-to operations for terminating a Stream.
That’s because there’s another type of reduction operation available that feels more common to the ways you’re used to: <em>aggregation operations</em>.</p>
</div></section>
<section data-pdf-bookmark="Aggregating Elements with Collectors" data-type="sect3"><div class="sect3" id="idm45115237769136">
<h3>Aggregating Elements with Collectors</h3>
<p>A ubiquitous step for every data processing task, be it Streams or an imperative approach with loops, is aggregating the resulting elements into a new data structure.
Most commonly, you want the resulting elements in a new <code>List</code>, a unique <code>Set</code>, or some form of <code>Map</code>.</p>
<p>Reducing the elements to a new value, in this case, a collection-like type, fits the bill of a reduction operation from the previous section, as shown in <a data-type="xref" href="#_02-data-processing_aggregation-reduce">Example 6-12</a>.</p>
<div data-type="example" id="_02-data-processing_aggregation-reduce">
<h5><span class="label">Example 6-12. </span>Aggregate elements with a <code>reduce</code> operation</h5>
<pre data-code-language="java" data-type="programlisting"><code class="kd">var</code> <code class="n">fruits</code> <code class="o">=</code> <code class="n">Stream</code><code class="p">.</code><code class="na">of</code><code class="p">(</code><code class="s">"</code><code class="s">apple</code><code class="s">"</code><code class="p">,</code> <code class="s">"</code><code class="s">orange</code><code class="s">"</code><code class="p">,</code> <code class="s">"</code><code class="s">banana</code><code class="s">"</code><code class="p">,</code> <code class="s">"</code><code class="s">peach</code><code class="s">"</code><code class="p">)</code>
                   <code class="p">.</code><code class="p">.</code><code class="p">.</code>
                   <code class="p">.</code><code class="na">reduce</code><code class="p">(</code><code class="k">new</code> <code class="n">ArrayList</code><code class="o">&lt;</code><code class="o">&gt;</code><code class="p">(</code><code class="p">)</code><code class="p">,</code> <a class="co" href="#callout_data_processing_with_streams_CO4-1" id="co_data_processing_with_streams_CO4-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a>
                           <code class="p">(</code><code class="n">acc</code><code class="p">,</code> <code class="n">fruit</code><code class="p">)</code> <code class="o">-</code><code class="o">&gt;</code> <code class="p">{</code>
                             <code class="kd">var</code> <code class="n">list</code> <code class="o">=</code> <code class="k">new</code> <code class="n">ArrayList</code><code class="o">&lt;</code><code class="o">&gt;</code><code class="p">(</code><code class="n">acc</code><code class="p">)</code><code class="p">;</code> <a class="co" href="#callout_data_processing_with_streams_CO4-2" id="co_data_processing_with_streams_CO4-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a>
                             <code class="n">list</code><code class="p">.</code><code class="na">add</code><code class="p">(</code><code class="n">fruit</code><code class="p">)</code><code class="p">;</code>
                             <code class="k">return</code> <code class="n">list</code><code class="p">;</code>
                   <code class="p">}</code><code class="p">,</code>
                   <code class="p">(</code><code class="n">lhs</code><code class="p">,</code> <code class="n">rhs</code><code class="p">)</code> <code class="o">-</code><code class="o">&gt;</code> <code class="p">{</code> <a class="co" href="#callout_data_processing_with_streams_CO4-3" id="co_data_processing_with_streams_CO4-3"><img alt="3" height="12" src="assets/3.png" width="12"/></a>
                     <code class="kd">var</code> <code class="n">list</code> <code class="o">=</code> <code class="k">new</code> <code class="n">ArrayList</code><code class="o">&lt;</code><code class="o">&gt;</code><code class="p">(</code><code class="n">lhs</code><code class="p">)</code><code class="p">;</code>
                     <code class="n">list</code><code class="p">.</code><code class="na">addAll</code><code class="p">(</code><code class="n">rhs</code><code class="p">)</code><code class="p">;</code>
                     <code class="k">return</code> <code class="n">list</code><code class="p">;</code>
                   <code class="p">}</code><code class="p">)</code><code class="p">;</code></pre></div>
<dl class="calloutlist">
<dt><a class="co" href="#co_data_processing_with_streams_CO4-1" id="callout_data_processing_with_streams_CO4-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p>The three-argument <code>reduce</code> operation is used because the resulting type isn’t the same type as the Stream elements.</p></dd>
<dt><a class="co" href="#co_data_processing_with_streams_CO4-2" id="callout_data_processing_with_streams_CO4-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a></dt>
<dd><p>Reduce operations are supposed to return new values, so instead of using a shared <code>ArrayList</code> to aggregate the elements, a new <code>ArrayList</code> is created for each accumulation step.</p></dd>
<dt><a class="co" href="#co_data_processing_with_streams_CO4-3" id="callout_data_processing_with_streams_CO4-3"><img alt="3" height="12" src="assets/3.png" width="12"/></a></dt>
<dd><p>The combiner merges multiple <code>ArrayList</code> instances by creating a new one in the case of parallel processing.</p></dd>
</dl>
<p>That’s quite a lot of verbose code to reduce Stream down to a simple <code>List</code>, with new instances of <code>ArrayList</code> created for each element, plus additional <code>ArrayList</code> instances if run in parallel!</p>
<p>Of course, you could <em>cheat</em> and reuse the <code>ArrayList acc</code> variable in the aggregator function instead of creating and returning a new one.
However, that would go against the general concept of <code>reduce</code> of being an <em>immutable</em> reduction operation.
That’s why there’s a better solution available: <em>aggregation operations</em>.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Even though I call them “aggregation operations” throughout the chapter, technically, they’re known as “mutable reduction operations” to differentiate them from reduction operations known as “immutable reduction operations.”</p>
</div>
<p>The <code>Stream&lt;T&gt;</code> type’s terminal operation <code>collect</code> accepts a Collector to aggregate elements.
Instead of reducing elements by combining Stream elements to a single result by repeatedly applying an <em>accumulator</em> operator, these operations use a <em>mutable results container</em> as an intermediate data structure, as seen in <a data-type="xref" href="#_02-data-processing_aggregation_collect-figure">Figure 6-17</a>.</p>
<figure><div class="figure" id="_02-data-processing_aggregation_collect-figure">
<img alt="Collection Stream elements" height="359" src="assets/afaj_0617.png" width="350"/>
<h6><span class="label">Figure 6-17. </span>Collecting Stream elements</h6>
</div></figure>
<p>The Stream’s elements are aggregated — or collected — with the help of the <code>java.util.stream.Collector&lt;T, A, R&gt;</code> type.
The interface’s generic types represent the different parts involved in the collection process:</p>
<ul>
<li>
<p><code>T</code>: The <em>type</em> of Stream elements.</p>
</li>
<li>
<p><code>A</code>: The <em>mutable result container</em> type.</p>
</li>
<li>
<p><code>R</code>: The final <em>result type</em> of the collection process which may differ from the intermediate container type.</p>
</li>
</ul>
<p>A <code>Collector</code> consists of multiple steps that match perfectly to its <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/stream/Collector.xhtml">interface definition</a>, as seen in <a data-type="xref" href="#_01-sterams-terminal-collector">Figure 6-18</a>.</p>
<figure><div class="figure" id="_01-sterams-terminal-collector">
<img alt="Inner workings of a Collector&lt;T,A,R&gt;" height="426" src="assets/afaj_0618.png" width="542"/>
<h6><span class="label">Figure 6-18. </span>Inner workings of a Collector&lt;T, A, R&gt;</h6>
</div></figure>
<dl>
<dt>Step 1: <code>Supplier&lt;A&gt; supplier()</code></dt>
<dd>
<p>The <code>Supplier</code> returns a new instance of the mutable result container used throughout the collection process.</p>
</dd>
<dt>Step 2: <code>BiConsumer&lt;A, T&gt; accumulator()</code></dt>
<dd>
<p>The core of the <code>Collector</code>, as this <code>BiConsumer</code> is responsible for accumulating the Stream elements of type <code>T</code> into the container of type <code>A</code> by accepting the result container and the current element as its arguments.</p>
</dd>
<dt>Step 3: <code>BinaryOperator&lt;A&gt; combiner()</code></dt>
<dd>
<p>In the case of parallel Stream processing, where multiple accumulators may do their work, the returned combiner <code>BinaryOperator</code> merges partial results container into a single one.</p>
</dd>
<dt>Step 4: <code>Function&lt;A, R&gt; finisher()</code></dt>
<dd>
<p>The finisher transforms the intermediate result container to the actual return object of type <code>R</code>.
The necessity of this step depends on the implementation of the <code>Collector</code>.</p>
</dd>
<dt>Step 5: The final result</dt>
<dd>
<p>The collected instance, e.g., a <code>List</code>, a <code>Map</code>, or even a single value.</p>
</dd>
</dl>
<p>The JDK comes with the <code>java.util.Collectors</code> utility class, providing a variety of Collectors for many use cases.
Listing and explaining them all in detail could fill another whole chapter.
That’s why I only introduce their particular use-case groups here.
<a data-type="xref" href="ch07.xhtml#_02-streams">Chapter 7</a> will have more examples and details about them and how you can create your own Collectors.
Also, you should check out the <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/stream/Collectors.xhtml">official documentation</a> for more details, including intended use-cases and examples.</p>
<dl>
<dt>Collect into a <code>java.util.Collection</code> type</dt>
<dd>
<p>The most used variants, collecting Stream elements into new <code>Collection</code> types include:</p>
<ul>
<li>
<p><code>toCollection(Supplier&lt;C&gt; collectionFactory)</code></p>
</li>
<li>
<p><code>toList()</code></p>
</li>
<li>
<p><code>toSet()</code></p>
</li>
<li>
<p><code>toUnmodifiableList()</code> (Java 10+)</p>
</li>
<li>
<p><code>toUnmodifiableSet()</code> (Java 10+)</p>
</li>
</ul>
</dd>
</dl>
<p>The original <code>toList()</code> / <code>toSet()</code> have no guarantees on the returned collection’s underlying type, mutability, serializability, or thread safety.
That’s why the <code>Unmodifiable</code> variants were introduced in Java 10 to close that gap.</p>
<dl>
<dt>Collect into a <code>java.util.Map</code> (key-value)</dt>
<dd>
<p>Another frequently used <code>Collector</code> task is creating a <code>Map&lt;K, V&gt;</code> by mapping the key and value from the Stream’s elements.
That’s why each variant must have at least a key- and value mapper function:
Key- and value-mapper functions must be provided.</p>
<ul>
<li>
<p><code>toMap(…​)</code> (3 variants)</p>
</li>
<li>
<p><code>toConcurrentMap(…​)</code> (3 variants)</p>
</li>
<li>
<p><code>toUnmodifiableMap(…​)</code> (2 variants, Java 10+)</p>
</li>
</ul>
</dd>
</dl>
<p>Like the collection-based Collector methods, the original <code>toMap()</code> variants do not guarantee the returned Map’s underlying type, mutability, serializability, or thread safety.
That’s why the <code>Unmodifiable</code> variants were introduced in Java 10 to close that gap.
Concurrent variants are also available for a more efficient collection of parallel Streams.</p>
<dl>
<dt>Collect into a <code>java.util.Map</code> (grouped)</dt>
<dd>
<p>Instead of a simple key-value relationship, the following Collectors group the values by a key, usually with a Collection-based type as the value for the returned <code>Map</code>:</p>
<ul>
<li>
<p><code>groupingBy()</code> (3 variants)</p>
</li>
<li>
<p><code>groupingByConcurrent()</code> (3 variants)</p>
</li>
</ul>
</dd>
<dt>Collect into a <code>java.util.Map</code> (partitioned)</dt>
<dd>
<p>Partitioned maps group their elements based on a provided <code>Predicate</code>.</p>
<ul>
<li>
<p><code>partitionBy(…​)</code> (2 variants)</p>
</li>
</ul>
</dd>
<dt>Arithmetic and comparison operations</dt>
<dd>
<p>There’s a certain overlap between the reduction operations and Collectors, like the arithmetic- and comparison-related Collectors.</p>
<ul>
<li>
<p><code>averagingInt(ToIntFunction&lt;? super T&gt; mapper)</code></p>
</li>
<li>
<p><code>summingInt(ToIntFunction&lt;? super T&gt; mapper)</code></p>
</li>
<li>
<p><code>summarizingInt(ToIntFunction&lt;? super T&gt; mapper)</code></p>
</li>
<li>
<p><code>counting()</code></p>
</li>
<li>
<p><code>minBy(Comparator&lt;? super T&gt; comparator)</code></p>
</li>
<li>
<p><code>maxBy(Comparator&lt;? super T&gt; comparator)</code></p>
</li>
</ul>
</dd>
<dt>String operations</dt>
<dd>
<p>There are three variants for joining elements together to a singular <code>String</code>:</p>
<ul>
<li>
<p><code>joining()</code> (3 variants)</p>
</li>
</ul>
</dd>
<dt>Advanced use cases</dt>
<dd>
<p>In more advanced use cases, like multi-level reductions or complicated groupings/partitions, multiple collection steps are required with the help of “downstream” Collectors.</p>
<ul>
<li>
<p><code>reducing(…​)</code> (3 variants)</p>
</li>
<li>
<p><code>collectingAndThen(Collector&lt;T,A,R&gt; downstream, Function&lt;R,RR&gt; finisher)</code></p>
</li>
<li>
<p><code>mapping(Function&lt;? super T, ? extends U&gt; mapper, Collector&lt;? super U, A, R&gt; downstream)</code> (Java 9+)</p>
</li>
<li>
<p><code>filtering(Predicate&lt;? super T&gt; predicate, Collector&lt;? super T, A, R&gt; downstream)</code> (Java 9+)</p>
</li>
<li>
<p><code>teeing(Collector&lt;? super T, ?, R1&gt; downstream1, Collector&lt;? super T, ?, R2&gt; downstream2, BiFunction&lt;? super R1, ? super R2, R&gt; merger)</code> (Java 12+)</p>
</li>
</ul>
</dd>
</dl>
<p><a data-type="xref" href="ch07.xhtml#_02-streams">Chapter 7</a> will detail how to use different Collectors and create complex collection workflows, including downstream collection.</p>
</div></section>
<section data-pdf-bookmark="Reducing Versus Collecting Elements" data-type="sect3"><div class="sect3" id="_02-data-processing_reduce-vs-collect">
<h3>Reducing Versus Collecting Elements</h3>
<p>The terminal operations <code>reduce</code> and <code>collect</code> are two sides of the same coin: both are reduction — or fold — operations.
The difference lies in the general approach to recombining the results: <em>immutable</em> versus <em>mutable</em> accumulation.
This difference leads to quite different performance characteristics.</p>
<p>The more abstract approach of <em>immutable</em> accumulation with the <code>reduce</code> operation is the best fit if sub-results are cheap to create, like summing up numbers as shown in <a data-type="xref" href="#_02-data-processing_immutable-reduction-stream">Example 6-13</a></p>
<div data-type="example" id="_02-data-processing_immutable-reduction-stream">
<h5><span class="label">Example 6-13. </span>Immutable accumulation of numbers with a Stream</h5>
<pre data-code-language="java" data-type="programlisting"><code class="kd">var</code> <code class="n">numbers</code> <code class="o">=</code> <code class="n">List</code><code class="p">.</code><code class="na">of</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">5</code><code class="p">,</code> <code class="mi">6</code><code class="p">)</code><code class="p">;</code>

<code class="kt">int</code> <code class="n">total</code> <code class="o">=</code> <code class="n">numbers</code><code class="p">.</code><code class="na">stream</code><code class="p">(</code><code class="p">)</code>
                   <code class="p">.</code><code class="na">reduce</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code> <a class="co" href="#callout_data_processing_with_streams_CO5-1" id="co_data_processing_with_streams_CO5-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a>
                           <code class="n">Integer</code><code class="p">:</code><code class="p">:</code><code class="n">sum</code><code class="p">)</code><code class="p">;</code> <a class="co" href="#callout_data_processing_with_streams_CO5-2" id="co_data_processing_with_streams_CO5-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a></pre></div>
<dl class="calloutlist">
<dt><a class="co" href="#co_data_processing_with_streams_CO5-1" id="callout_data_processing_with_streams_CO5-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p>The initial value — the <em>seed</em> — is used for every parallel reduction operation.</p></dd>
<dt><a class="co" href="#co_data_processing_with_streams_CO5-2" id="callout_data_processing_with_streams_CO5-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a></dt>
<dd><p>The method reference translates into a <code>BiFunction&lt;Integer, Integer, Integer&gt;</code> to accumulate the previous (or initial) value with the current Stream element.</p></dd>
</dl>
<p>Every reduction operation builds upon the previous one, as seen in <a data-type="xref" href="#_02-data-processing_immutable-reduction">Figure 6-19</a>.</p>
<figure><div class="figure" id="_02-data-processing_immutable-reduction">
<img alt="Immutable accumulation of numbers" height="503" src="assets/afaj_0619.png" width="544"/>
<h6><span class="label">Figure 6-19. </span>Immutable accumulation of numbers</h6>
</div></figure>
<p>This approach isn’t feasible for all scenarios, especially if creating an intermediate result is costly.
Take the <code>String</code> type, for example.
In <a data-type="xref" href="ch04.xhtml#_02-data-structures">Chapter 4</a>, you’ve learned about its immutable nature and why performing modifications can be costly.
That’s why it’s usually advisable to use an optimized intermediate container, like <code>StringBuilder</code> or <code>StringBuffer</code>, to reduce the required processing power.</p>
<p>Concatenating a list of <code>String</code> objects with an <em>immutable</em> reduction requires creating a new <code>String</code> for every step, leading to a runtime of <math alttext="upper O left-parenthesis n squared right-parenthesis">
<mrow>
<mi>O</mi>
<mo>(</mo>
<msup><mi>n</mi> <mn>2</mn> </msup>
<mo>)</mo>
</mrow>
</math> with <code>n</code> being the number of characters.
Let’s compare an <em>immutable</em> and <em>mutable</em> variant of <code>String</code> concatenation in <a data-type="xref" href="#_02-data-processing_reduce-vs-collect-concat-strings">Example 6-14</a>.</p>
<div data-type="example" id="_02-data-processing_reduce-vs-collect-concat-strings">
<h5><span class="label">Example 6-14. </span>Concatenating String elements with reduce and collect</h5>
<pre data-code-language="java" data-type="programlisting"><code class="kd">var</code> <code class="n">strings</code> <code class="o">=</code> <code class="n">List</code><code class="p">.</code><code class="na">of</code><code class="p">(</code><code class="s">"</code><code class="s">a</code><code class="s">"</code><code class="p">,</code> <code class="s">"</code><code class="s">b</code><code class="s">"</code><code class="p">,</code> <code class="s">"</code><code class="s">c</code><code class="s">"</code><code class="p">,</code> <code class="s">"</code><code class="s">d</code><code class="s">"</code><code class="p">,</code> <code class="s">"</code><code class="s">e</code><code class="s">"</code><code class="p">)</code><code class="p">;</code>

<code class="c1">// STREAM REDUCE</code>

<code class="kd">var</code> <code class="n">reduced</code> <code class="o">=</code> <code class="n">strings</code><code class="p">.</code><code class="na">stream</code><code class="p">(</code><code class="p">)</code>
                     <code class="p">.</code><code class="na">reduce</code><code class="p">(</code><code class="s">"</code><code class="s">"</code><code class="p">,</code> <a class="co" href="#callout_data_processing_with_streams_CO6-1" id="co_data_processing_with_streams_CO6-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a>
                             <code class="n">String</code><code class="p">:</code><code class="p">:</code><code class="n">concat</code><code class="p">)</code><code class="p">;</code> <a class="co" href="#callout_data_processing_with_streams_CO6-2" id="co_data_processing_with_streams_CO6-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a>

<code class="c1">// STREAM COLLECT - CUSTOM</code>

<code class="kd">var</code> <code class="n">joiner</code> <code class="o">=</code><code class="n">strings</code><code class="p">.</code><code class="na">stream</code><code class="p">(</code><code class="p">)</code>
                   <code class="p">.</code><code class="na">collect</code><code class="p">(</code><code class="n">Collector</code><code class="p">.</code><code class="na">of</code><code class="p">(</code><code class="p">(</code><code class="p">)</code> <code class="o">-</code><code class="o">&gt;</code> <code class="k">new</code> <code class="n">StringJoiner</code><code class="p">(</code><code class="s">"</code><code class="s">"</code><code class="p">)</code><code class="p">,</code> <a class="co" href="#callout_data_processing_with_streams_CO6-3" id="co_data_processing_with_streams_CO6-3"><img alt="3" height="12" src="assets/3.png" width="12"/></a>
                                         <code class="n">StringJoiner</code><code class="p">:</code><code class="p">:</code><code class="n">add</code><code class="p">,</code> <a class="co" href="#callout_data_processing_with_streams_CO6-4" id="co_data_processing_with_streams_CO6-4"><img alt="4" height="12" src="assets/4.png" width="12"/></a>
                                         <code class="n">StringJoiner</code><code class="p">:</code><code class="p">:</code><code class="n">merge</code><code class="p">,</code> <a class="co" href="#callout_data_processing_with_streams_CO6-5" id="co_data_processing_with_streams_CO6-5"><img alt="5" height="12" src="assets/5.png" width="12"/></a>
                                         <code class="n">StringJoiner</code><code class="p">:</code><code class="p">:</code><code class="n">toString</code><code class="p">)</code><code class="p">)</code><code class="p">;</code> <a class="co" href="#callout_data_processing_with_streams_CO6-6" id="co_data_processing_with_streams_CO6-6"><img alt="6" height="12" src="assets/6.png" width="12"/></a>

<code class="c1">// STREAM COLLECT - PRE-DEFINED</code>

<code class="kd">var</code> <code class="n">collectWithCollectors</code> <code class="o">=</code> <code class="n">strings</code><code class="p">.</code><code class="na">stream</code><code class="p">(</code><code class="p">)</code>
                                   <code class="p">.</code><code class="na">collect</code><code class="p">(</code><code class="n">Collectors</code><code class="p">.</code><code class="na">joining</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code class="p">;</code> <a class="co" href="#callout_data_processing_with_streams_CO6-7" id="co_data_processing_with_streams_CO6-7"><img alt="7" height="12" src="assets/7.png" width="12"/></a></pre></div>
<dl class="calloutlist">
<dt><a class="co" href="#co_data_processing_with_streams_CO6-1" id="callout_data_processing_with_streams_CO6-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p>The initial value is the first <code>String</code> creation.</p></dd>
<dt><a class="co" href="#co_data_processing_with_streams_CO6-2" id="callout_data_processing_with_streams_CO6-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a></dt>
<dd><p>Every reduction step creates another new <code>String</code>, so the required processing power and memory scale with element count.</p></dd>
<dt><a class="co" href="#co_data_processing_with_streams_CO6-3" id="callout_data_processing_with_streams_CO6-3"><img alt="3" height="12" src="assets/3.png" width="12"/></a></dt>
<dd><p>The first argument specifies a <code>Supplier&lt;A&gt;</code> for the mutable container.</p></dd>
<dt><a class="co" href="#co_data_processing_with_streams_CO6-4" id="callout_data_processing_with_streams_CO6-4"><img alt="4" height="12" src="assets/4.png" width="12"/></a></dt>
<dd><p>The second argument is the reduction <code>BiConsumer&lt;A, T&gt;</code> accepting the container and the current element.</p></dd>
<dt><a class="co" href="#co_data_processing_with_streams_CO6-5" id="callout_data_processing_with_streams_CO6-5"><img alt="5" height="12" src="assets/5.png" width="12"/></a></dt>
<dd><p>The third argument defines a <code>BinaryOperator&lt;A&gt;</code> of how to merge multiple containers in the case of parallel processing.</p></dd>
<dt><a class="co" href="#co_data_processing_with_streams_CO6-6" id="callout_data_processing_with_streams_CO6-6"><img alt="6" height="12" src="assets/6.png" width="12"/></a></dt>
<dd><p>And the last argument, a <code>Function&lt;A, R&gt;</code> tells the <code>Collector</code> how to build the final result of type <code>R</code>.</p></dd>
<dt><a class="co" href="#co_data_processing_with_streams_CO6-7" id="callout_data_processing_with_streams_CO6-7"><img alt="7" height="12" src="assets/7.png" width="12"/></a></dt>
<dd><p>The <code>java.util.stream.Collectors</code> utility class provides many <em>ready-to-use</em> Collectors, making Stream pipelines more reasonable than creating a <code>Collector</code> inline.</p></dd>
</dl>
<p>The <code>Collector</code> requires more arguments than an <em>immutable</em> reduction to do its work.
Still, these additional arguments allow it to use a <em>mutable</em> container and, therefore, a different approach to reducing the Stream’s elements in the first place.
For many common tasks, in this case, concatenating Strings, you can use one of the pre-defined Collectors available from <code>java.util.stream.Collectors</code>.</p>
<p>Which type of reduction to choose — <em>immutable</em> or <em>mutable</em> — depends highly on your requirements.
My personal <em>rule of thumb</em> is simple and stems from the names of the actual methods: choose <code>collect</code> if the result is a collection-based type, like <code>List</code> or <code>Map</code>; choose <code>reduce</code> if the result is an accumulated single value.
But don’t forget performance and memory considerations.</p>
<p><a data-type="xref" href="ch07.xhtml#_02-streams">Chapter 7</a> goes into more detail about Collectors and how to create your own.</p>
</div></section>
<section data-pdf-bookmark="Aggregate Elements Directly" data-type="sect3"><div class="sect3" id="idm45115237019136">
<h3>Aggregate Elements Directly</h3>
<p>The <code>Collector</code> type is a powerful and versatile tool for collecting elements into new data structures.
Still, sometimes, a simpler solution would suffice.
The <code>Stream&lt;T&gt;</code> type provides more terminal aggregation operations for common tasks:</p>
<dl>
<dt>Returning a <code>List&lt;T&gt;</code></dt>
<dd>
<p>Java 16 added the terminal operation <code>toList()</code> to simplify the most commonly used aggregation to create a new <code>List&lt;T&gt;</code>.
It doesn’t use a Collector-based workflow to aggregate the elements, leading to fewer allocations and requiring less memory.
That makes it optimal to use when the stream size is known in advance, and a more concise alternative to <code>collect(Collectors.toList())</code>.
There are no guarantees on the implementation type of the returned list or its serializability, just like with using <code>collect(Collectors.toList())</code>.
Unlike it, however, the return list is an unmodifiable variant.</p>
</dd>
<dt>Returning an array</dt>
<dd>
<p>Returning the Stream’s elements as an array doesn’t require a reduction or Collector.
Instead, you can use two operations:</p>
<ul>
<li>
<p><code>Object[] toArray()</code></p>
</li>
<li>
<p><code>A[] toArray(IntFunction&lt;A[]&gt; generator)</code></p>
</li>
</ul>
</dd>
</dl>
<p>The second variant of <code>toArray</code> allows you to create an array of a specific type instead of <code>Object[]</code> by providing an “array generator,” which most likely is a method reference to the constructor:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">String</code><code class="o">[]</code> <code class="n">fruits</code> <code class="o">=</code> <code class="n">Stream</code><code class="p">.</code><code class="na">of</code><code class="p">(</code><code class="s">"apple"</code><code class="p">,</code> <code class="s">"orange"</code><code class="p">,</code> <code class="s">"banana"</code><code class="p">,</code> <code class="s">"peach"</code><code class="p">)</code>
                        <code class="p">...</code>
                        <code class="p">.</code><code class="na">toArray</code><code class="p">(</code><code class="n">String</code><code class="o">[]</code><code class="p">::</code><code class="k">new</code><code class="p">);</code></pre>
</div></section>
<section data-pdf-bookmark="Finding and Matching Elements" data-type="sect3"><div class="sect3" id="idm45115236622160">
<h3>Finding and Matching Elements</h3>
<p>Besides aggregating Stream elements into a new representation, finding a particular element is another common task for Streams.
There are multiple terminal operations available to either find an element or determine its existence:</p>
<dl>
<dt><code>Optional&lt;T&gt; findFirst()</code></dt>
<dd>
<p>Returns the first encountered element of the Stream.
If the Stream is unordered, any element might be returned.
Empty Streams return an empty <code>Optional&lt;T&gt;</code>.</p>
</dd>
<dt><code>Optional&lt;T&gt; findAny()</code></dt>
<dd>
<p>Returns any element of the Stream in a non-deterministic fashion.
If the Stream itself is empty, an empty <code>Optional&lt;T&gt;</code> is returned.</p>
</dd>
</dl>
<p>As you can see, both methods have no arguments, so a prior <code>filter</code> operation might be necessary to get the desired element.</p>
<p>If you don’t require the element itself, you should use one of the matching operations, which matches the elements against a <code>Predicate&lt;T&gt;</code> instead:</p>
<dl>
<dt><code>boolean anyMatch(Predicate&lt;? super T&gt; predicate)</code></dt>
<dd>
<p>Returns <code>true</code> if <em>any</em> element of the Stream matches the <code>predicate</code>.</p>
</dd>
<dt><code>boolean allMatch(Predicate&lt;? super T&gt; predicate)</code></dt>
<dd>
<p>Returns <code>true</code> if <em>all</em> elements of the Stream match the <code>predicate</code>.</p>
</dd>
<dt><code>boolean noneMatch(Predicate&lt;? super T&gt; predicate)</code></dt>
<dd>
<p>Returns <code>true</code> if <em>none</em> of the elements match the given <code>predicate</code>.</p>
</dd>
</dl>
</div></section>
<section data-pdf-bookmark="Consuming Elements" data-type="sect3"><div class="sect3" id="idm45115236567008">
<h3>Consuming Elements</h3>
<p>The last group of terminal operations is <em>side-effects-only</em> operations.
Instead of returning a value, the <code>forEach</code> methods only accept a <code>Consumer&lt;T&gt;</code>.</p>
<dl>
<dt><code>void forEach(Consumer&lt;? super T&gt; action)</code></dt>
<dd>
<p>Performs the <code>action</code> for each element.
The execution order is explicitly nondeterministic to maximize the performance, especially for parallel Streams.</p>
</dd>
<dt><code>void forEachOrdered(Consumer&lt;? super T&gt; action)</code></dt>
<dd>
<p>The <code>action</code> is performed for every element in the encountered order if the Stream is <code>ORDERED</code>.</p>
</dd>
</dl>
<p>From a functional point of view, these operations seem out of place.
As a developer trying to transition imperative code into a more functional direction, however, they can be quite useful.</p>
<p>Localized side effects aren’t inherently harmful.
Not all code is easily refactorable to prevent them, if even at all.
Just like with all the other operations, the conciseness of the contained logic determines how straightforward and readable the Stream pipeline will be.
If more than a method reference or a simple non-block lambda is needed, it’s always a good idea to extract/refactor the logic into a new method and call it instead to maintain the conciseness and readability of the Stream pipeline.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="The Cost of Operations" data-type="sect2"><div class="sect2" id="_02-data-processing_order-matters">
<h2>The Cost of Operations</h2>
<p>The beauty of Streams is their ability to concatenate multiple operations into a single pipeline,
but you have to remember one thing: every operation might get called until an item gets rejected downstream.</p>
<p>Let’s look at the simple Stream pipeline in <a data-type="xref" href="#_02-data-processing_order-matters-01">Example 6-15</a>.</p>
<div data-type="example" id="_02-data-processing_order-matters-01">
<h5><span class="label">Example 6-15. </span>Fruit pipeline (naïve)</h5>
<pre data-code-language="java" data-type="programlisting"><code class="n">Stream</code><code class="p">.</code><code class="na">of</code><code class="p">(</code><code class="s">"</code><code class="s">ananas</code><code class="s">"</code><code class="p">,</code> <code class="s">"</code><code class="s">oranges</code><code class="s">"</code><code class="p">,</code> <code class="s">"</code><code class="s">apple</code><code class="s">"</code><code class="p">,</code> <code class="s">"</code><code class="s">pear</code><code class="s">"</code><code class="p">,</code> <code class="s">"</code><code class="s">banana</code><code class="s">"</code><code class="p">)</code>
      <code class="p">.</code><code class="na">map</code><code class="p">(</code><code class="n">String</code><code class="p">:</code><code class="p">:</code><code class="n">toUpperCase</code><code class="p">)</code> <a class="co" href="#callout_data_processing_with_streams_CO7-1" id="co_data_processing_with_streams_CO7-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a>
      <code class="p">.</code><code class="na">sorted</code><code class="p">(</code><code class="p">)</code> <a class="co" href="#callout_data_processing_with_streams_CO7-2" id="co_data_processing_with_streams_CO7-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a>
      <code class="p">.</code><code class="na">filter</code><code class="p">(</code><code class="n">s</code> <code class="o">-</code><code class="o">&gt;</code> <code class="n">s</code><code class="p">.</code><code class="na">startsWith</code><code class="p">(</code><code class="s">"</code><code class="s">A</code><code class="s">"</code><code class="p">)</code><code class="p">)</code> <a class="co" href="#callout_data_processing_with_streams_CO7-3" id="co_data_processing_with_streams_CO7-3"><img alt="3" height="12" src="assets/3.png" width="12"/></a>
      <code class="p">.</code><code class="na">forEach</code><code class="p">(</code><code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">:</code><code class="p">:</code><code class="n">println</code><code class="p">)</code><code class="p">;</code> <a class="co" href="#callout_data_processing_with_streams_CO7-4" id="co_data_processing_with_streams_CO7-4"><img alt="4" height="12" src="assets/4.png" width="12"/></a></pre></div>
<dl class="calloutlist">
<dt><a class="co" href="#co_data_processing_with_streams_CO7-1" id="callout_data_processing_with_streams_CO7-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p>Process elements to the desired form.</p></dd>
<dt><a class="co" href="#co_data_processing_with_streams_CO7-2" id="callout_data_processing_with_streams_CO7-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a></dt>
<dd><p>Sort naturally.</p></dd>
<dt><a class="co" href="#co_data_processing_with_streams_CO7-3" id="callout_data_processing_with_streams_CO7-3"><img alt="3" height="12" src="assets/3.png" width="12"/></a></dt>
<dd><p>Reject unwanted elements.</p></dd>
<dt><a class="co" href="#co_data_processing_with_streams_CO7-4" id="callout_data_processing_with_streams_CO7-4"><img alt="4" height="12" src="assets/4.png" width="12"/></a></dt>
<dd><p>Finally, work with the remaining elements.</p></dd>
</dl>
<p>In this fruit pipeline example, you have three intermediate and one terminal operation, for processing five elements.
How many operation calls do you guess are done by this simple code?
Let’s count them!</p>
<p>The Stream pipeline calls <code>map</code> five times, <code>sorted</code> eight times, <code>filter</code> five times, and finally <code>forEach</code> two times.
That’s <em>20</em> operations to output <em>two</em> values!
Even though the pipeline does what it’s supposed to, that’s ridiculous!
Let’s rearrange the operations to reduce the overall calls significantly, as seen in <a data-type="xref" href="#_02-data-processing_order-matters-02">Example 6-16</a>.</p>
<div data-type="example" id="_02-data-processing_order-matters-02">
<h5><span class="label">Example 6-16. </span>Fruit pipeline (improved)</h5>
<pre data-code-language="java" data-type="programlisting"><code class="n">Stream</code><code class="p">.</code><code class="na">of</code><code class="p">(</code><code class="s">"</code><code class="s">ananas</code><code class="s">"</code><code class="p">,</code> <code class="s">"</code><code class="s">oranges</code><code class="s">"</code><code class="p">,</code> <code class="s">"</code><code class="s">apple</code><code class="s">"</code><code class="p">,</code> <code class="s">"</code><code class="s">pear</code><code class="s">"</code><code class="p">,</code> <code class="s">"</code><code class="s">banana</code><code class="s">"</code><code class="p">)</code>
      <code class="p">.</code><code class="na">filter</code><code class="p">(</code><code class="n">s</code> <code class="o">-</code><code class="o">&gt;</code> <code class="n">s</code><code class="p">.</code><code class="na">startsWith</code><code class="p">(</code><code class="s">"</code><code class="s">a</code><code class="s">"</code><code class="p">)</code><code class="p">)</code> <a class="co" href="#callout_data_processing_with_streams_CO8-1" id="co_data_processing_with_streams_CO8-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a>
      <code class="p">.</code><code class="na">map</code><code class="p">(</code><code class="n">String</code><code class="p">:</code><code class="p">:</code><code class="n">toUpperCase</code><code class="p">)</code> <a class="co" href="#callout_data_processing_with_streams_CO8-2" id="co_data_processing_with_streams_CO8-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a>
      <code class="p">.</code><code class="na">sorted</code><code class="p">(</code><code class="p">)</code> <a class="co" href="#callout_data_processing_with_streams_CO8-3" id="co_data_processing_with_streams_CO8-3"><img alt="3" height="12" src="assets/3.png" width="12"/></a>
      <code class="p">.</code><code class="na">forEach</code><code class="p">(</code><code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">:</code><code class="p">:</code><code class="n">println</code><code class="p">)</code><code class="p">;</code> <a class="co" href="#callout_data_processing_with_streams_CO8-4" id="co_data_processing_with_streams_CO8-4"><img alt="4" height="12" src="assets/4.png" width="12"/></a></pre></div>
<dl class="calloutlist">
<dt><a class="co" href="#co_data_processing_with_streams_CO8-1" id="callout_data_processing_with_streams_CO8-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p>Reject unwanted elements first.</p></dd>
<dt><a class="co" href="#co_data_processing_with_streams_CO8-2" id="callout_data_processing_with_streams_CO8-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a></dt>
<dd><p>Transform elements to the desired form.</p></dd>
<dt><a class="co" href="#co_data_processing_with_streams_CO8-3" id="callout_data_processing_with_streams_CO8-3"><img alt="3" height="12" src="assets/3.png" width="12"/></a></dt>
<dd><p>Sort naturally.</p></dd>
<dt><a class="co" href="#co_data_processing_with_streams_CO8-4" id="callout_data_processing_with_streams_CO8-4"><img alt="4" height="12" src="assets/4.png" width="12"/></a></dt>
<dd><p>Finally, work with the remaining elements.</p></dd>
</dl>
<p>By filtering first, the calls of the <code>map</code> operation and the work of the stateful <code>sorted</code> operation are reduced to a minimum:
<code>filter</code> is called five times, <code>map</code> two times, <code>sorted</code> one time, and <code>forEach</code> two times, saving <em>50%</em> operations in total without changing the result.</p>
<p>Always remember that Stream elements are not being pushed through the Stream pipeline and its operations until they reach the terminal operation.
Instead, the terminal operation pulls the elements through the pipeline.
The fewer elements that flow through the pipeline, the better its performance will be.
That’s why some operations are considered <em>short-circuiting</em> in nature, meaning they can cut the Stream short.
Essentially, short-circuiting operations, as listed in <a data-type="xref" href="#_02-data-processing_short-circuiting-ops">Table 6-4</a>, are operations that might carry out their intended purpose without requiring the Stream to traverse all of its elements.</p>
<table id="_02-data-processing_short-circuiting-ops">
<caption><span class="label">Table 6-4. </span>Short-circuiting Stream operations</caption>
<thead>
<tr>
<th>Intermediate Operations</th>
<th>Terminal Operations</th>
</tr>
</thead>
<tbody>
<tr>
<td><p><code>limit<br/>
takeWhile<br/></code></p></td>
<td><p><code>findAny<br/>
findFirst<br/>
anyMatch<br/>
allMatch<br/>
noneMatch</code></p></td>
</tr>
</tbody>
</table>
<p>This behavior allows them to even process an infinite Stream and may still produce a finite Stream (intermediate ops) or finish their task in finite time (terminal ops).</p>
<p>A non-short-circuiting operation with heavily optimized behavior is the terminal <code>count()</code> operation.
If the overall element count of a Stream terminated by <code>count()</code> is derivable from the Stream itself, any prior operations that won’t affect the count might get dropped, as the following code demonstrates:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">var</code> <code class="n">result</code> <code class="o">=</code> <code class="n">Stream</code><code class="p">.</code><code class="na">of</code><code class="p">(</code><code class="s">"apple"</code><code class="p">,</code> <code class="s">"orange"</code><code class="p">,</code> <code class="s">"banana"</code><code class="p">,</code> <code class="s">"melon"</code><code class="p">)</code>
                   <code class="p">.</code><code class="na">peek</code><code class="p">(</code><code class="n">str</code> <code class="o">-&gt;</code> <code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="s">"peek 1: "</code> <code class="o">+</code> <code class="n">str</code><code class="p">))</code>
                   <code class="p">.</code><code class="na">map</code><code class="p">(</code><code class="n">str</code> <code class="o">-&gt;</code> <code class="p">{</code>
                     <code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="s">"map: "</code> <code class="o">+</code> <code class="n">str</code><code class="p">);</code>
                     <code class="k">return</code> <code class="n">str</code><code class="p">.</code><code class="na">toUpperCase</code><code class="p">();</code>
                   <code class="p">})</code>
                   <code class="p">.</code><code class="na">peek</code><code class="p">(</code><code class="n">str</code> <code class="o">-&gt;</code> <code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="s">"peek 2: "</code> <code class="o">+</code> <code class="n">str</code><code class="p">))</code>
                   <code class="p">.</code><code class="na">count</code><code class="p">();</code>
<code class="c1">// NO OUTPUT</code></pre>
<p>Even though there are three operations with a <code>System.out.println</code> call in the pipeline, all of them are dropped.
The reasoning behind this behavior is simple: <code>map</code> and <code>peek</code> operations don’t inject or remove any elements in the Stream pipeline, so they don’t affect the final count in any way, therefore, they aren’t actually required.</p>
<p>Dropping operations is at the Stream’s discretion if it deems it possible.
For example, the preceding code runs all operations if a <code>filter</code> operation is added to the pipeline, shown as follows:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">var</code> <code class="n">result</code> <code class="o">=</code> <code class="n">Stream</code><code class="p">.</code><code class="na">of</code><code class="p">(</code><code class="s">"apple"</code><code class="p">,</code> <code class="s">"orange"</code><code class="p">,</code> <code class="s">"banana"</code><code class="p">,</code> <code class="s">"melon"</code><code class="p">)</code>
                   <code class="p">.</code><code class="na">filter</code><code class="p">(</code><code class="n">str</code> <code class="o">-&gt;</code> <code class="n">str</code><code class="p">.</code><code class="na">contains</code><code class="p">(</code><code class="s">"e"</code><code class="p">))</code>
                   <code class="p">.</code><code class="na">peek</code><code class="p">(</code><code class="n">str</code> <code class="o">-&gt;</code> <code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="s">"peek 1: "</code> <code class="o">+</code> <code class="n">str</code><code class="p">))</code>
                   <code class="p">.</code><code class="na">map</code><code class="p">(</code><code class="n">str</code> <code class="o">-&gt;</code> <code class="p">{</code>
                     <code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="s">"map: "</code> <code class="o">+</code> <code class="n">str</code><code class="p">);</code>
                     <code class="k">return</code> <code class="n">str</code><code class="p">.</code><code class="na">toUpperCase</code><code class="p">();</code>
                   <code class="p">})</code>
                   <code class="p">.</code><code class="na">peek</code><code class="p">(</code><code class="n">str</code> <code class="o">-&gt;</code> <code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="s">"peek 2: "</code> <code class="o">+</code> <code class="n">str</code><code class="p">))</code>
                   <code class="p">.</code><code class="na">count</code><code class="p">();</code>
<code class="c1">// OUTPUT</code>
<code class="c1">// peek 1: apple</code>
<code class="c1">// map: apple</code>
<code class="c1">// peek 2: APPLE</code>
<code class="c1">// peek 1: orange</code>
<code class="c1">// map: orange</code>
<code class="c1">// peek 2: ORANGE</code>
<code class="c1">// peek 1: melon</code>
<code class="c1">// map: melon</code>
<code class="c1">// peek 2: MELON</code></pre>
<p>That doesn’t mean every kind of Stream pipeline will drop <em>possible</em> unnecessary operations, either.
If you require “side-effects” in your Stream pipeline, you should use one of the two <code>forEach</code> terminal operation variants, which are intended as “side-effects-only” operations.</p>
</div></section>
<section data-pdf-bookmark="Modifying Stream Behavior" data-type="sect2"><div class="sect2" id="idm45115236558288">
<h2>Modifying Stream Behavior</h2>
<p>A Stream’s characteristics, as explained in <a data-type="xref" href="#_02-data-processing_spliterator">“Spliterator, the Backbone of Streams”</a>, are initially set on its creation.
Not every Stream operation is a good match for every characteristic, though.
Especially in parallel Streams, the encountered order of elements might significantly impact performance.
For example, selecting elements with the <code>filter</code> operation is an easily parallelizable task, but <code>takeWhile</code> needs to synchronize between tasks if run in parallel.
That’s why particular Stream characteristics can be switched by the intermediate operations listed in <a data-type="xref" href="#_02-data-processing_intermediate_mod">Table 6-5</a>, which return an equivalent Stream with changed traits.</p>
<table id="_02-data-processing_intermediate_mod">
<caption><span class="label">Table 6-5. </span>Modifying Stream Behavior</caption>
<thead>
<tr>
<th>Operation</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><p><code>parallel()</code></p></td>
<td><p>Enables parallel processing.<br/>
   May return <code>this</code> if the Stream is already parallel.</p></td>
</tr>
<tr>
<td><p><code>sequential()</code></p></td>
<td><p>Enables sequential processing.<br/>
   May return <code>this</code> if the Stream is already sequential.</p></td>
</tr>
<tr>
<td><p><code>unordered()</code></p></td>
<td><p>Returns a Stream with unordered encounter order.
   May return <code>this</code> if the Stream is already unordered.</p></td>
</tr>
<tr>
<td><p><code><span class="keep-together">onClose(Runnable closeHandler)</span></code></p></td>
<td><p>Adds an additional close handler to be called after the Stream is finished.</p></td>
</tr>
</tbody>
</table>
<p>Switching Stream behavior is just a single method call away.
However, that doesn’t mean it’s always a good idea.
In fact, switching to parallel processing is often a bad idea if the pipeline and the underlying Stream aren’t designed to run in parallel in the first place.</p>
<p>See <a data-type="xref" href="ch08.xhtml#_01-parallel-streams">Chapter 8</a> to learn how to make an informed decision about using parallel processing for Stream pipelines.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="To Use Streams, or Not?" data-type="sect1"><div class="sect1" id="idm45115235946720">
<h1>To Use Streams, or Not?</h1>
<p>Streams are an excellent way to make your data processing more expressive and utilize many of the functional features available in Java.
You may feel a strong urge to (over)use Streams for all kinds of data processing.
I know I certainly overdid it at first.
You have to keep in mind, though, that not every data processing pipeline benefits equally from becoming a Stream.</p>
<p>Your decision to use Streams — or not to use one — should rely always be an informed decision based on the following intertwined factors:</p>
<dl>
<dt>How complex is the required task?</dt>
<dd>
<p>A simple loop that’s a few lines long won’t benefit much from being a Stream with one or two small operations.
It depends on how easy it is to fit the whole task and required logic into a mental model.<br/>
<br/>
If I can grasp what’s happening with ease, a simple <em>for-each</em>-loop might be the better choice.
On the other hand, compressing a multi-page long loop into a more accessible Stream pipeline with well-defined operations will improve its readability and maintainability.</p>
</dd>
<dt>How functional is the Stream pipeline?</dt>
<dd>
<p>Stream pipelines are mere scaffolds to be filled with your logic.
If the logic isn’t a good fit for a functional approach, like side-effect-laden code, you won’t get all the benefits and safety guarantees that Streams have to offer.<br/>
<br/>
Refactoring or redesigning code to be more functional, pure, or immutable is always a good idea and makes it a better match for the Stream API.
Sill, forcing your code to fit into a Stream pipeline without the actual need is deciding on a solution without really understanding the problem first.
A certain degree of adapting your code to enable new features that benefit productivity, reasonability, and maintainability is good.<br/>
<br/>
However, it should be a conscious decision on what’s best for your code and project in the long run, not just a “requirement” to use a feature.</p>
</dd>
<dt>How many elements are processed?</dt>
<dd>
<p>  The overhead of creating the scaffold that holds the Stream pipeline together diminishes with the number of processed elements.
  For small data sources, the relation between the required instances, method calls, stack frames, and memory consumption is not as negligible as for processing more significant quantities of elements.<br/>
<br/>
  In a direct comparison of raw performance, a “perfectly optimized” <code>for</code>-loop wins out over a sequential Stream for a simple reason.
Traditional Java looping constructs are implemented at the language level, giving the JVM more optimization possibilities, especially for small loops.
  On the other hand, Streams are implemented as ordinary Java types, creating an unavoidable runtime overhead.
That doesn’t mean their execution won’t be optimized, though!
As you’ve learned in this chapter, a Stream pipeline can short-circuit or fuse operations to maximize pipeline throughput.</p>
</dd>
</dl>
<p>None of these factors in isolation should affect your decision to use Stream, only in tandem.
Especially the most common concern of many developers — performance — is seldom the most significant criterion for designing code and choosing the right tools.</p>
<p>Your code could always be more performant.
Dismissing a tool out of performance anxiety before measuring and verifying the actual performance might deprive you of a better solution for your actual problem.</p>
<p>Sir Tony Hoare<sup><a data-type="noteref" href="ch06.xhtml#idm45115235918800" id="idm45115235918800-marker">4</a></sup> once said, “We should forget about small efficiencies, say about 97% of the time: premature optimization is the root of all evil.”</p>
<p>This advice can be applied when deciding whether to use Streams or loops.
Most of the time — around 97% — you do not need to concern yourself with raw performance, and Streams may be the most simple and straightforward solution for you with all the benefits the Stream API offers.
Once in a while — the 3% — you will need to focus on raw performance to achieve your goals, and Streams might not be the best solution for you.
Although in <a data-type="xref" href="ch08.xhtml#_01-parallel-streams">Chapter 8</a> you will learn how to improve processing performance by leveraging parallel Streams.</p>
<p>When deciding whether or not to use Streams, you might think about how willing you are to use something new and unfamiliar.
When you first learned to program, I bet all the loop constructs you’re now quite familiar with appeared to be complicated.
Everything seemed hard at first until, over time and repeated use, you became familiar and more comfortable with using those loop contracts.
The same is going to be true for using Streams.
Learning the ins and outs of the Steam API will take some time, but it will become easier and more obvious when and how to use Streams efficiently to create concise and straightforward data processing pipelines.</p>
<p>Another thing you have to keep in mind is that the primary goal of Streams isn’t to achieve the best raw performance possible or to replace all other looping constructs.
Streams are supposed to be a more declarative and expressive way of processing data.
They give you the equivalent of the classical map-filter-reduce pattern backed by Java’s strong type system but also designed with all the powerful functional techniques introduced in Java 8 in mind.
Designing a functional Stream pipeline is the most straightforward and concise way to apply functional code to a sequence of objects.</p>
<p>Finally, the general idea of combining pure functions with immutable data leads to a looser coupling between data structures and their data processing logic.
Each operation only needs to know how to handle a single element in its current form.
This decoupling enables greater reusability and maintainability of smaller domain-specific operations that can be composed into bigger, more sophisticated tasks if necessary.</p>
</div></section>
<section data-pdf-bookmark="Takeaways" data-type="sect1"><div class="sect1" id="idm45115235915392">
<h1>Takeaways</h1>
<ul>
<li>
<p>The Stream API provides a fluent and declarative way to create <em>map/filter/reduce</em>-like data processing pipelines without the need for external iteration.</p>
</li>
<li>
<p>Concatenable higher-order functions are the building blocks for a Stream pipeline.</p>
</li>
<li>
<p>Streams use internal iteration, which entrusts more control over the traversal process to the data source itself.</p>
</li>
<li>
<p>Many common and specialized operations are available besides the classical <em>map/filter/reduce</em> operations.</p>
</li>
<li>
<p>Streams are lazy; no work is done until a terminal operation is called.</p>
</li>
<li>
<p>Sequential processing is the default, but switching to parallel processing is easy.</p>
</li>
<li>
<p>Parallel processing might not be the best approach to all data processing problems and usually needs to be verified to solve the problem more efficiently.</p>
</li>
</ul>
</div></section>
<div data-type="footnotes"><p data-type="footnote" id="idm45115238989296"><sup><a href="ch06.xhtml#idm45115238989296-marker">1</a></sup> Brian Goetz, the Java Language Architect at Oracle, explains fusing operations <a href="https://stackoverflow.com/questions/35069055/java-stream-operation-fusion-and-stateful-intermediate-operations/35070889#35070889">on StackOverflow</a>.</p><p data-type="footnote" id="idm45115238985136"><sup><a href="ch06.xhtml#idm45115238985136-marker">2</a></sup> Newland, Chris and Ben Evans. 2019. “Loop Unrolling: An elaborate mechanism for reducing loop iterations improves performance but can be thwarted by inadvertent coding.” <a href="https://blogs.oracle.com/javamagazine/loop-unrolling">Java magazine</a>.</p><p data-type="footnote" id="idm45115238384128"><sup><a href="ch06.xhtml#idm45115238384128-marker">3</a></sup> Even though there are several new annotations used in JavaDoc since the release of Java 8, they aren’t an <em>official</em> standard as of writing this book. The informal proposal is available at the official OpenJDK bug-tracker as <a href="https://bugs.openjdk.java.net/browse/JDK-8068562">JDK-8068562</a></p><p data-type="footnote" id="idm45115235918800"><sup><a href="ch06.xhtml#idm45115235918800-marker">4</a></sup> Sir Charles Antony Richard Hoare is a British computer scientist and recipient of the Turing Award — regarded as the highest distinction in the field of computer science — who has made foundational contributions to programming languages, algorithms, operating systems, formal verification, and concurrent computing.</p></div></div></section></div></body></html>