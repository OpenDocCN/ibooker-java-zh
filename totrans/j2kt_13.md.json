["```java\npublic static double averageNonBlankLength(List<String> strings) {\n    var sum = 0;\n    for (var s : strings) {\n        if (!s.isBlank())\n            sum += s.length();\n    }\n    return sum / (double) strings.size();\n}\n```", "```java\npublic static double averageNonBlankLength(List<String> strings) {\n    return strings\n        .stream()\n        .filter(s -> !s.isBlank())\n        .mapToInt(String::length)\n        .sum()\n        / (double) strings.size();\n}\n```", "```java\npublic static double averageNonBlankLength(List<String> strings) {\n    return strings\n        .parallelStream() ![1](assets/1.png)\n        .filter(s -> !s.isBlank())\n        .mapToInt(String::length)\n        .sum()\n        / (double) strings.size();\n}\n```", "```java\npublic static List<String> translatedWordsUntilSTOP(List<String> strings) {\n    var result = new ArrayList<String>();\n    for (var word: strings) {\n        String translation = translate(word);\n        if (translation.equalsIgnoreCase(\"STOP\"))\n            break;\n        else\n            result.add(translation);\n    }\n    return result;\n}\n```", "```java\npublic static List<String> translatedWordsUntilSTOP(List<String> strings) {\n    return strings\n        .stream()\n        .map(word -> translate(word))\n        .takeWhile(translation -> !translation.equalsIgnoreCase(\"STOP\"))\n        .collect(toList());\n}\n```", "```java\nfun averageNonBlankLength(strings: List<String>): Double =\n    (strings\n        .filter { it.isNotBlank() }\n        .map(String::length)\n        .sum()\n        / strings.size.toDouble())\n```", "```java\nfun averageNonBlankLength(strings: List<String>): Double =\n    (strings\n        .asSequence()\n        .filter { it.isNotBlank() }\n        .map(String::length)\n        .sum()\n        / strings.size.toDouble())\n```", "```java\nfun averageNonBlankLength(strings: List<String>): Double =\n    (strings\n        .asSequence()\n        .filter { it.isNotBlank() }\n        .sumBy(String::length)\n        / strings.size.toDouble())\n```", "```java\npublic static double averageNonBlankLength(List<String> strings) {\n    return averageNonBlankLength(strings.stream());\n}\n\npublic static double averageNonBlankLength(Stream<String> strings) {\n    return strings\n        .filter(s -> !s.isBlank())\n        .mapToInt(String::length)\n        .sum()\n        / (double) strings.count();\n}\n```", "```java\nfun averageNonBlankLength(strings: List<String>): Double =\n    averageNonBlankLength(strings.asSequence())\n\nfun averageNonBlankLength(strings: Sequence<String>): Double =\n    (strings\n        .filter { it.isNotBlank() }\n        .sumBy(String::length)\n        / strings.count().toDouble())\n```", "```java\nfun averageNonBlankLength(strings: Iterator<String>): Double =\n    averageNonBlankLength(strings.asSequence())\n```", "```java\nfun averageNonBlankLength(strings: Sequence<String>): Double {\n    var count = 0\n    return (strings\n        .onEach { count++ }\n        .filter { it.isNotBlank() }\n        .sumBy(String::length)\n        / count.toDouble())\n}\n```", "```java\nclass CountingSequence<T>(\n    private val wrapped: Sequence<T>\n) : Sequence<T> {\n    var count = 0\n    override fun iterator() =\n        wrapped.onEach { count++ }.iterator()\n}\n\nfun averageNonBlankLength(strings: Sequence<String>): Double {\n    val countingSequence = CountingSequence(strings)\n    return (countingSequence\n            .filter { it.isNotBlank() }\n            .sumBy(String::length)\n            / countingSequence.count.toDouble())\n}\n```", "```java\nfun averageNonBlankLength(strings: List<String>): Double =\n    (strings\n        .stream()\n        .filter { it.isNotBlank() }\n        .mapToInt(String::length)\n        .sum()\n        / strings.size.toDouble())\n```", "```java\npublic static List<String> translatedWordsUntilSTOP(List<String> strings) {\n    return strings\n        .stream()\n        .map(word -> translate(word))\n        .takeWhile(translation -> !translation.equalsIgnoreCase(\"STOP\"))\n        .collect(toList());\n}\n```", "```java\nfun translatedWordsUntilSTOP(strings: List<String>): List<String> =\n    strings\n        .map { translate(it) }\n        .takeWhile { !it.equals(\"STOP\", ignoreCase = true) }\n```", "```java\nfun translatedWordsUntilSTOP(strings: List<String>): List<String> =\n    strings\n        .asSequence()\n        .map { translate(it) }\n        .takeWhile { !it.equals(\"STOP\", ignoreCase = true) }\n        .toList()\n```", "```java\nclass CountingSequence<T>(\n    private val wrapped: Sequence<T>\n) : Sequence<T> {\n    var count = 0\n    override fun iterator() =\n        wrapped.onEach { count++ }.iterator()\n}\n\nfun averageNonBlankLength(strings: Sequence<String>): Double {\n    val countingSequence = CountingSequence(strings)\n    return (countingSequence\n            .filter { it.isNotBlank() }\n            .sumBy(String::length)\n            / countingSequence.count.toDouble())\n}\n```", "```java\nfun averageNonBlankLength(strings: Sequence<String>): Double =\n    strings\n        .map { if (it.isBlank()) 0 else it.length }\n        .average()\n```", "```java\ninline fun <T> Sequence<T>.averageBy(selector: (T) -> Int): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += selector(element)\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n```", "```java\nfun averageNonBlankLength(strings: Sequence<String>): Double =\n    strings.averageBy {\n        if (it.isBlank()) 0 else it.length\n    }\n```", "```java\npublic static double averageNonBlankLength(List<String> strings) {\n    var sum = 0;\n    for (var s : strings) {\n        if (!s.isBlank())\n            sum += s.length();\n    }\n    return sum / (double) strings.size();\n}\n```", "```java\npublic static double averageNonBlankLength(List<String> strings) {\n    return strings\n        .stream()\n        .filter(s -> !s.isBlank())\n        .mapToInt(String::length)\n        .sum()\n        / (double) strings.size();\n}\n```", "```java\npublic static double averageNonBlankLength(List<String> strings) {\n    var sum = 0;\n    for (var s : strings) {\n        sum += s.isBlank() ? 0 : s.length();\n    }\n    return sum / (double) strings.size();\n}\n```", "```java\npublic static double averageNonBlankLength(List<String> strings) {\n    return strings\n        .stream()\n        .mapToInt(s -> s.isBlank() ? 0 : s.length())\n        .average()\n        .orElse(Double.NaN);\n}\n```", "```java\npublic interface EventStore {\n\n    Iterator<Map<String, Object>> query(String query);\n\n    default Stream<Map<String, Object>> queryAsStream(String query) {\n        Iterable<Map<String, Object>> iterable = () -> query(query);\n        return StreamSupport.stream(iterable.spliterator(), false);\n    }\n}\n```", "```java\npublic double averageNumberOfEventsPerCompletedBooking(\n    String timeRange\n) {\n    Stream<Map<String, Object>> eventsForSuccessfulBookings =\n        eventStore\n            .queryAsStream(\"type=CompletedBooking&timerange=\" + timeRange)\n            .flatMap(event -> {\n                String interactionId = (String) event.get(\"interactionId\");\n                return eventStore.queryAsStream(\"interactionId=\" + interactionId);\n            });\n    Map<String, List<Map<String, Object>>> bookingEventsByInteractionId =\n        eventsForSuccessfulBookings.collect(groupingBy(\n            event -> (String) event.get(\"interactionId\"))\n        );\n    var averageNumberOfEventsPerCompletedBooking =\n        bookingEventsByInteractionId\n            .values()\n            .stream()\n            .mapToInt(List::size)\n            .average();\n    return averageNumberOfEventsPerCompletedBooking.orElse(Double.NaN);\n}\n```", "```java\nfun averageNumberOfEventsPerCompletedBooking(\n    timeRange: String\n): Double {\n    val eventsForSuccessfulBookings = eventStore\n        .queryAsStream(\"type=CompletedBooking&timerange=$timeRange\")\n        .flatMap { event: Map<String?, Any?> ->\n            val interactionId = event[\"interactionId\"] as String?\n            eventStore.queryAsStream(\"interactionId=$interactionId\")\n        }\n    val bookingEventsByInteractionId = eventsForSuccessfulBookings.collect(\n        Collectors.groupingBy(\n            Function { event: Map<String, Any> ->\n                event[\"interactionId\"] as String?\n            }\n        )\n    )\n    val averageNumberOfEventsPerCompletedBooking = bookingEventsByInteractionId\n        .values\n        .stream()\n        .mapToInt { obj: List<Map<String, Any>> -> obj.size }\n        .average()\n    return averageNumberOfEventsPerCompletedBooking.orElse(Double.NaN)\n}\n```", "```java\nfun averageNumberOfEventsPerCompletedBooking(\n    timeRange: String\n): Double {\n    val eventsForSuccessfulBookings = eventStore\n        .queryAsStream(\"type=CompletedBooking&timerange=$timeRange\")\n        .flatMap { event ->\n            val interactionId = event[\"interactionId\"] as String\n            eventStore.queryAsStream(\"interactionId=$interactionId\")\n        }\n    val bookingEventsByInteractionId = eventsForSuccessfulBookings.collect(\n        groupingBy { event -> event[\"interactionId\"] as String }\n    )\n    val averageNumberOfEventsPerCompletedBooking = bookingEventsByInteractionId\n        .values\n        .stream()\n        .mapToInt { it.size }\n        .average()\n    return averageNumberOfEventsPerCompletedBooking.orElse(Double.NaN)\n}\n```", "```java\nval eventsForSuccessfulBookings = eventStore\n    .queryAsStream(\"type=CompletedBooking&timerange=$timeRange\")\n    .flatMap { event ->\n        val interactionId = event[\"interactionId\"] as String\n        eventStore.queryAsStream(\"interactionId=$interactionId\")\n    }\nval bookingEventsByInteractionId = eventsForSuccessfulBookings.collect(\n    groupingBy { event -> event[\"interactionId\"] as String }\n)\n```", "```java\nval averageNumberOfEventsPerCompletedBooking = bookingEventsByInteractionId\n    .values\n    .stream()\n    .mapToInt { it.size }\n    .average()\nreturn averageNumberOfEventsPerCompletedBooking.orElse(Double.NaN)\n```", "```java\nval averageNumberOfEventsPerCompletedBooking = bookingEventsByInteractionId\n    .values\n    .map { it.size }\n    .average()\nreturn averageNumberOfEventsPerCompletedBooking\n```", "```java\nval values = bookingEventsByInteractionId.values\nreturn values.sumBy { it.size } / values.size.toDouble()\n```", "```java\nval values = bookingEventsByInteractionId.values\nreturn averageBy(values)\n```", "```java\nprivate fun averageBy(\n    values: MutableCollection<MutableList<MutableMap<String, Any>>>\n): Double {\n    return values.sumBy { it.size } / values.size.toDouble()\n}\n```", "```java\nprivate fun averageBy(\n    values: Collection<MutableList<MutableMap<String, Any>>>,\n    selector: (MutableList<MutableMap<String, Any>>) -> Int\n): Double {\n    return values.sumBy(selector) / values.size.toDouble()\n}\n```", "```java\nprivate fun <T : MutableList<MutableMap<String, Any>>> averageBy(\n    values: Collection<T>,\n    selector: (T) -> Int\n): Double {\n    return values.sumBy(selector) / values.size.toDouble()\n}\n```", "```java\nprivate fun <T> averageBy(\n    values: Collection<T>,\n    selector: (T) -> Int\n): Double {\n    return values.sumBy(selector) / values.size.toDouble()\n}\n```", "```java\nval values = bookingEventsByInteractionId.values\nreturn averageBy<MutableList<MutableMap<String, Any>>>(values) { it.size }\n```", "```java\ninline fun <T> Collection<T>.averageBy(selector: (T) -> Int): Double =\n    sumBy(selector) / size.toDouble()\n```", "```java\nfun averageNumberOfEventsPerCompletedBooking(\n    timeRange: String\n): Double {\n    val eventsForSuccessfulBookings = eventStore\n        .queryAsStream(\"type=CompletedBooking&timerange=$timeRange\")\n        .flatMap { event ->\n            val interactionId = event[\"interactionId\"] as String\n            eventStore.queryAsStream(\"interactionId=$interactionId\")\n        }\n    val bookingEventsByInteractionId = eventsForSuccessfulBookings.collect(\n        groupingBy { event -> event[\"interactionId\"] as String }\n    )\n    return bookingEventsByInteractionId.values.averageBy { it.size }\n}\n```", "```java\nval bookingEventsByInteractionId = eventsForSuccessfulBookings\n    .asSequence()\n    .groupBy { event ->\n        event[\"interactionId\"] as String\n    }\n```", "```java\nval eventsForSuccessfulBookings = eventStore\n    .queryAsStream(\"type=CompletedBooking&timerange=$timeRange\")\n    .flatMap { event ->\n        val interactionId = event[\"interactionId\"] as String\n        eventStore.queryAsStream(\"interactionId=$interactionId\")\n    }\n```", "```java\nval eventsForSuccessfulBookings = eventStore\n    .queryAsStream(\"type=CompletedBooking&timerange=$timeRange\")\n    .asSequence()\n    .flatMap { event ->\n        val interactionId = event[\"interactionId\"] as String\n        eventStore\n            .queryAsStream(\"interactionId=$interactionId\")\n            .asSequence()\n    }\n```", "```java\nval bookingEventsByInteractionId = eventsForSuccessfulBookings\n    .asSequence()\n    .groupBy { event ->\n        event[\"interactionId\"] as String\n    }\n```", "```java\nval bookingEventsByInteractionId = eventsForSuccessfulBookings\n    .groupBy { event ->\n        event[\"interactionId\"] as String\n    }\n```", "```java\nval eventsForSuccessfulBookings = eventStore\n    .queryAsStream(\"type=CompletedBooking&timerange=$timeRange\")\n    .asSequence()\n    .flatMap { event ->\n        val interactionId = event[\"interactionId\"] as String\n        eventStore\n            .queryAsStream(\"interactionId=$interactionId\")\n            .asSequence()\n    }\n```", "```java\nfun EventStore.queryAsSequence(query: String) =\n    this.queryAsStream(query).asSequence()\n```", "```java\nfun averageNumberOfEventsPerCompletedBooking(\n    timeRange: String\n): Double {\n    val eventsForSuccessfulBookings = eventStore\n        .queryAsSequence(\"type=CompletedBooking&timerange=$timeRange\")\n        .flatMap { event ->\n            val interactionId = event[\"interactionId\"] as String\n            eventStore\n                .queryAsSequence(\"interactionId=$interactionId\")\n        }\n    val bookingEventsByInteractionId = eventsForSuccessfulBookings\n        .groupBy { event ->\n            event[\"interactionId\"] as String\n        }\n    return bookingEventsByInteractionId.values.averageBy { it.size }\n}\n```", "```java\nfun averageNumberOfEventsPerCompletedBooking(\n    timeRange: String\n): Double {\n    return eventStore\n        .queryAsSequence(\"type=CompletedBooking&timerange=$timeRange\")\n        .flatMap { event ->\n            val interactionId = event[\"interactionId\"] as String\n            eventStore\n                .queryAsSequence(\"interactionId=$interactionId\")\n        }.groupBy { event ->\n            event[\"interactionId\"] as String\n        }.values\n        .averageBy { it.size }\n}\n```", "```java\nfun averageNumberOfEventsPerCompletedBooking(\n    timeRange: String\n): Double {\n    return allEventsInSameInteractions(timeRange)\n        .groupBy { event ->\n            event[\"interactionId\"] as String\n        }.values\n        .averageBy { it.size }\n}\n\nprivate fun allEventsInSameInteractions(timeRange: String) = eventStore\n    .queryAsSequence(\"type=CompletedBooking&timerange=$timeRange\")\n    .flatMap { event ->\n        val interactionId = event[\"interactionId\"] as String\n        eventStore\n            .queryAsSequence(\"interactionId=$interactionId\")\n    }\n```", "```java\nfun averageNumberOfEventsPerCompletedBooking(\n    timeRange: String\n): Double {\n    return allEventsInSameInteractions(\n        eventStore\n            .queryAsSequence(\"type=CompletedBooking&timerange=$timeRange\")\n    )\n        .groupBy { event ->\n            event[\"interactionId\"] as String\n        }.values\n        .averageBy { it.size }\n}\n\nprivate fun allEventsInSameInteractions(\n    sequence: Sequence<MutableMap<String, Any?>>\n) = sequence\n    .flatMap { event ->\n        val interactionId = event[\"interactionId\"] as String\n        eventStore\n            .queryAsSequence(\"interactionId=$interactionId\")\n    }\n```", "```java\nfun averageNumberOfEventsPerCompletedBooking(\n    timeRange: String\n): Double {\n    return eventStore\n        .queryAsSequence(\"type=CompletedBooking&timerange=$timeRange\")\n        .allEventsInSameInteractions()\n        .groupBy { event ->\n            event[\"interactionId\"] as String\n        }.values\n        .averageBy { it.size }\n}\n\nfun Sequence<Map<String, Any?>>.allEventsInSameInteractions() =\n    flatMap { event ->\n        val interactionId = event[\"interactionId\"] as String\n        eventStore\n            .queryAsSequence(\"interactionId=$interactionId\")\n    }\n```", "```java\ntypealias Event = Map<String, Any?>\n\nval Event.interactionId: String? get() =\n    this[\"interactionId\"] as? String\n```", "```java\nclass MarketingAnalytics(\n    private val eventStore: EventStore\n) {\n    fun averageNumberOfEventsPerCompletedBooking(\n        timeRange: String\n    ): Double = eventStore\n        .queryAsSequence(\"type=CompletedBooking&timerange=$timeRange\")\n        .allEventsInSameInteractions()\n        .groupBy(Event::interactionId)\n        .values\n        .averageBy { it.size }\n\n    private fun Sequence<Event>.allEventsInSameInteractions() =\n        flatMap { event ->\n            eventStore.queryAsSequence(\n                \"interactionId=${event.interactionId}\"\n            )\n        }\n}\n\ninline fun <T> Collection<T>.averageBy(selector: (T) -> Int): Double =\n    sumBy(selector) / size.toDouble()\n\nfun EventStore.queryAsSequence(query: String) =\n    this.queryAsStream(query).asSequence()\n```"]