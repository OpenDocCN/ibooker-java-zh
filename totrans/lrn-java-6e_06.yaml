- en: Chapter 6\. Error Handling
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章 错误处理
- en: You will always encounter errors in the real world. How you handle them helps
    show the quality of your code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中，你总会遇到错误。你如何处理这些错误可以显示你代码的质量。
- en: Java has its roots in embedded systems—software that runs inside specialized
    devices, such as the handheld computers, cellular phones, and fancy toasters that
    we might consider part of the internet of things (IoT) these days. In those applications,
    it’s especially important that software errors be handled robustly. Most users
    would agree that it’s unacceptable for their phone to crash on a regular basis
    or for their toast (and perhaps their house) to burn because some software failed.
    Given that we can’t eliminate the possibility of software errors, recognizing
    and dealing with application-level errors methodically is a good step in the right
    direction.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Java的根源是嵌入式系统——运行在专用设备内部的软件，例如手持计算机、手机以及我们今天可能认为属于物联网（IoT）一部分的高级烤面包机。在这些应用中，稳健地处理软件错误尤为重要。大多数用户都认为，他们的手机经常崩溃或者他们的面包（甚至房子）因为某些软件故障而烧焦是不可接受的。鉴于我们无法消除软件错误的可能性，有条不紊地识别和处理应用级错误是朝正确方向迈出的良好步骤。
- en: Some languages leave the responsibility for handling errors entirely with the
    programmer. The language itself provides no help in identifying error types and
    no tools for dealing with them easily. In the C language, for example, functions
    generally indicate a failure by returning an “unreasonable” value (like the idiomatic
    `-1` or a `null`). As the programmer, you must know what constitutes a bad result
    and what it means. It’s often awkward to work around the limitations of passing
    error values in the normal path of data flow.^([1](ch06.html#id1273)) An even
    worse problem is that certain types of errors can legitimately occur almost anywhere,
    and it’s slow and costly to test for them explicitly at every point in the software.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 一些语言完全将处理错误的责任交给程序员。语言本身不提供帮助来识别错误类型，也没有简便的工具来处理它们。例如，在C语言中，函数通常通过返回一个“不合理”的值（如习惯上的
    `-1` 或 `null`）来表示失败。作为程序员，你必须知道什么构成了一个糟糕的结果以及它意味着什么。在正常的数据流路径中传递错误值的限制通常让人感到尴尬。^([1](ch06.html#id1273))
    更糟糕的问题是，某些类型的错误几乎可以在任何地方合法地发生，而在软件的每个点显式测试它们是缓慢且昂贵的。
- en: In this chapter we’ll consider how Java tackles the problem of problems. We’ll
    go over the notion of exceptions to look at how and why they occur, as well as
    how and where to handle them. We’ll also be looking at errors and assertions.
    *Errors* are more serious problems that often cannot be fixed at runtime but can
    still be logged for debugging. *Assertions* are a popular way of inoculating your
    code against exceptions or errors by verifying ahead of time that safe conditions
    exist.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨Java如何处理问题。我们将讨论异常的概念，看看它们为何如何以及何时出现，以及如何在何处处理它们。我们还将研究错误和断言。*错误*是更严重的问题，通常在运行时无法修复，但仍可以记录以进行调试。*断言*是通过事先验证安全条件来使你的代码免受异常或错误的流行方法。
- en: Exceptions
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常
- en: Java offers an elegant solution to aid the programmer in addressing common coding
    and runtime problems through exceptions. (Java exception handling is similar to,
    but not quite the same as, exception handling in C++.) An *exception* indicates
    an unusual condition or an error condition. When a problem occurs, the runtime
    transfers control (or “throws”) to a specially designated section of your code
    that can handle (or “catch”) the condition. In this way, error handling is independent
    of the normal flow of the program. We don’t need special return values for all
    of our methods; errors are handled by a separate mechanism. Java can pass control
    a long distance from a deeply nested routine and handle errors in a single location
    when that is desirable, or an error can be handled immediately at its source.
    A few standard Java methods still return a special value such as `-1`, but these
    are generally limited to situations where expecting and handling a special value
    is relatively straightforward.^([2](ch06.html#id1274))
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Java 提供了一个优雅的解决方案，通过异常来帮助程序员解决常见的编码和运行时问题。（Java 异常处理与 C++ 中的异常处理类似，但并非完全相同。）*异常*
    表示异常条件或错误条件。当问题发生时，运行时将控制（或“抛出”）到您代码中的一个特定指定的部分，该部分可以处理（或“捕获”）这种条件。通过这种方式，错误处理与程序的正常流程无关。我们不需要为所有方法返回特殊值；错误通过一个单独的机制处理。Java
    可以在非常深的嵌套过程中传递控制并在需要时在单个位置处理错误，或者错误可以立即在其源头处理。一些标准的 Java 方法仍然返回特殊值，比如 `-1`，但这些通常仅限于期望和处理特殊值相对简单的情况。^([2](ch06.html#id1274))
- en: You must specify any known exceptions your methods can throw, and the compiler
    makes sure that callers of the method handle them. In this way, Java treats information
    about what errors a method can produce with the same level of importance as its
    argument and return types. You may still decide to punt and ignore some errors,
    but in Java you must do so explicitly. (We’ll discuss runtime exceptions and errors,
    which don’t require this explicit declaration, in a moment.)
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须指定方法可能抛出的任何已知异常，编译器会确保调用方法的代码处理它们。通过这种方式，Java 对方法可能产生的错误信息的处理与其参数和返回类型的重要性水平相同。您可能仍然决定忽略一些错误，但在
    Java 中，您必须明确地这样做。（我们将讨论运行时异常和错误，这些异常不需要此显式声明。）
- en: Exceptions and Error Classes
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异常和错误类
- en: Exceptions are represented by instances of the class `java.lang.Exception` and
    its subclasses. Subclasses of `Exception` can hold specialized information (and
    possibly behavior) for different kinds of exceptional conditions. However, more
    often they are simply “logical” subclasses that serve only to identify a new exception
    type. [Figure 6-1](#learnjava6-CHP-6-FIG-1) shows the subclasses of `Exception`
    in the `java.lang` package. It should give you a feel for how exceptions are organized.
    Most packages define their own exception types, which usually are subclasses of
    `Exception` itself or of its important subclass `RuntimeException`, which we’ll
    get to in a moment.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 异常由 `java.lang.Exception` 类及其子类的实例表示。`Exception` 的子类可以保存不同种类异常条件的专用信息（可能还有行为）。然而，它们更常见的是简单的“逻辑”子类，仅用于标识新的异常类型。[Figure 6-1](#learnjava6-CHP-6-FIG-1)
    展示了 `java.lang` 包中 `Exception` 的子类。它应该让你对异常如何组织有所感觉。大多数包定义它们自己的异常类型，这些类型通常是 `Exception`
    本身或其重要子类 `RuntimeException` 的子类，我们马上会谈到。
- en: 'For example, let’s look at another important exception class: `java.io.IOException`.
    The `IOException` class extends `Exception` and has many subclasses of its own
    for typical I/O problems, such as a `FileNotFoundException`. Notice how explicit
    (and useful) the class name is. Many network exceptions further extend `IOException`—they
    do involve input and output—but following conventions, exceptions like `MalformedURLException`
    belong to the `java.net` package alongside other networking classes.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们看另一个重要的异常类：`java.io.IOException`。`IOException` 类扩展了 `Exception` 并且有许多自己的子类，用于典型的
    I/O 问题，比如 `FileNotFoundException`。请注意类名是多么明确（和有用）。许多网络异常进一步扩展了 `IOException` ——
    它们确实涉及输入和输出 —— 但按照惯例，像 `MalformedURLException` 这样的异常属于 `java.net` 包，与其他网络类一起。
- en: '![ljv6 0601](assets/ljv6_0601.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 0601](assets/ljv6_0601.png)'
- en: Figure 6-1\. The `java.lang.Exception` subclasses
  id: totrans-12
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-1\. `java.lang.Exception` 的子类
- en: 'The runtime creates an `Exception` object at the point where the error condition
    arises. It can be designed to hold any information necessary to describe the exceptional
    condition. It also includes a full stack trace for debugging. A *stack trace*
    is the (occasionally unwieldy) list of all the methods called and the order in
    which they were called from your `main()` method up to the point where the exception
    was thrown. (We’ll look at these useful lists in more detail in [“Stack Traces”](#learnjava6-CHP-6-SECT-1.4).)
    The `Exception` object is passed as an argument to the handling block of code,
    along with the flow of control. This is where the terms *throw* and *catch* come
    from: the `Exception` object is thrown from one point in the code and caught by
    another, where execution resumes, as shown in [Figure 6-2](#learnjava6-CHP-6-FIG-throw-flow).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在出现错误条件的地方，运行时会创建一个`Exception`对象。它可以设计为包含描述异常条件所需的任何信息。它还包括用于调试的完整堆栈跟踪。*堆栈跟踪*是调用所有方法及其调用顺序的列表，从您的`main()`方法到抛出异常的地方（有时可能很冗长）。`Exception`对象作为参数传递到处理代码块，与控制流一起。这就是*抛出*和*捕获*这些术语的来源：`Exception`对象从代码的一个点抛出并在另一个点被捕获，执行恢复，如图6-2所示。
- en: '![ljv6 0602](assets/ljv6_0602.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 0602](assets/ljv6_0602.png)'
- en: Figure 6-2\. The flow of control when an exception occurs
  id: totrans-15
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-2。异常发生时的控制流
- en: Java also defines the `java.lang.Error` class for unrecoverable errors. The
    subclasses of `Error` in the `java.lang` package are shown in [Figure 6-3](#learnjava6-CHP-6-FIG-2).
    A notable `Error` type is `AssertionError`, which is used by the Java `assert`
    statement (more on this statement later in this chapter) to indicate a failure.
    A few other packages define their own subclasses of `Error`, but subclasses of
    `Error` are much less common (and less useful) than subclasses of `Exception`.
    You generally won’t need to worry about these errors in your code; they are intended
    to indicate fatal problems or virtual machine errors, which usually cause the
    Java interpreter to display a message and exit. Java’s designers actively discourage
    developers from trying to catch or recover from these errors because they are
    supposed to indicate a fatal program bug, possibly in the JVM itself, not a routine
    condition.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Java还为不可恢复错误定义了`java.lang.Error`类。`java.lang`包中`Error`的子类如图6-3所示。一个显著的`Error`类型是`AssertionError`，它被Java的`assert`语句（本章后面将更详细地介绍此语句）用来指示失败。其他一些包定义了它们自己的`Error`子类，但是`Error`的子类比`Exception`的子类要少得多（也不太有用）。通常情况下，您不需要在代码中担心这些错误；它们旨在指示致命问题或虚拟机错误，通常会导致Java解释器显示消息并退出。Java的设计人员积极不鼓励开发人员尝试捕获或恢复这些错误，因为它们应该指示一个致命的程序错误，可能是在JVM本身中而不是常规情况中。
- en: Both `Exception` and `Error` are subclasses of `Throwable`. The `Throwable`
    class is the base class for objects that can be “thrown” with the `throw` statement.
    While you can technically extend `Throwable` yourself, you should generally extend
    only `Exception`, `Error`, or one of their subclasses if you want to create your
    own throwable type.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`Exception`和`Error`都是`Throwable`的子类。`Throwable`类是可以使用`throw`语句“抛出”的对象的基类。虽然你在技术上可以扩展`Throwable`自己，但如果你想创建自己的可抛出类型，通常应该只扩展`Exception`、`Error`或它们的某个子类。'
- en: '![ljv6 0603](assets/ljv6_0603.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 0603](assets/ljv6_0603.png)'
- en: Figure 6-3\. The `java.lang.Error` subclasses
  id: totrans-19
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-3。`java.lang.Error`的子类
- en: Exception Handling
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异常处理
- en: 'To catch and handle an _Italicized Textixexception, you wrap blocks of your
    code in `try/catch` guarding statements:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要捕获和处理斜体文本例外，您可以将代码块包装在`try/catch`守卫语句中：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this example, any exceptions that occur within the body of the `try` portion
    of the statement are directed to the `catch` clause for possible handling. The
    `catch` clause acts like a method; it specifies the type of exception it wants
    to handle. If it’s invoked, the clause receives the `Exception` object as an argument.
    Here, we receive the object in the variable `e` and print it along with a message.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，任何发生在`try`语句块内部的异常都会被传递到`catch`子句以进行可能的处理。`catch`子句的作用类似于一个方法；它指定了它想要处理的异常类型。如果被调用，该子句会接收`Exception`对象作为参数。在这里，我们将对象赋给变量`e`，并打印出来以及相应的消息。
- en: 'We can try this ourselves. Recall the simple program to calculate the greatest
    common denominator (GCD) using the Euclid algorithm back in [Chapter 4](ch04.html#learnjava6-CHP-4).
    We could augment that program to allow the user to pass in the two numbers `a`
    and `b` as command-line arguments via that `args[]` array in the `main()` method.
    However, that array is of type `String`. If we cheat a little bit and steal some
    code from [“Parsing Primitive Numbers”](ch08.html#learnjava6-CHP-8-SECT-2.1),
    we can use a text parsing method to turn those strings into `int` values. However,
    that parsing method can throw an exception if we don’t pass a valid number. Here’s
    a look at our new `Euclid2` class:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以自己尝试一下。回想一下使用欧几里得算法计算最大公约数（GCD）的简单程序，这是在[第四章](ch04.html#learnjava6-CHP-4)中完成的。我们可以增强该程序，允许用户通过`main()`方法中的`args[]`数组将两个数字`a`和`b`作为命令行参数传递。然而，该数组是`String`类型的。如果我们稍微作弊，从[“解析基本数字”](ch08.html#learnjava6-CHP-8-SECT-2.1)中借用一些代码，我们可以使用文本解析方法将这些字符串转换为`int`值。然而，如果我们未传递有效数字，该解析方法可能会抛出异常。这里是我们新的`Euclid2`类的样子：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Notice that we limit our `try/catch` to just the potentially problematic code.
    It’s common to see several different `try/catch` blocks in a method. This small
    scope allows us to better tailor the code in the `catch` block to whatever problems
    we’re anticipating. In this case, we know we might get some bad input from the
    user, so we can check for the (very) specific `NumberFormatException` and print
    a friendly message for the user.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们仅将`try/catch`限制为潜在有问题的代码。在方法中看到几个不同的`try/catch`块是很常见的。这个小范围允许我们更好地将`catch`块中的代码调整为我们预期的任何问题。在这种情况下，我们知道可能会从用户那里得到一些不良输入，因此我们可以检查非常具体的`NumberFormatException`并为用户打印友好的消息。
- en: 'If we run this program from a terminal window or use the command-line arguments
    option in our IDE like we did in [Figure 2-10](ch02.html#learnjava6-CHP-2-FIG-9),
    we can now find the GCD of several number pairs without recompiling:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从终端窗口运行此程序或在IDE中使用命令行参数选项，就像我们在[图2-10](ch02.html#learnjava6-CHP-2-FIG-9)中所做的那样，我们现在可以在不重新编译的情况下找到多个数对的GCD。
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'But if we pass in arguments that are not numeric, we’ll get that `NumberFormatException`
    and see our error message. Note, however, that our code recovers gracefully and
    still provides some output. This recovery is the essence of error handling:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们传入的参数不是数字，我们将得到`NumberFormatException`并看到我们的错误消息。但是，请注意，我们的代码可以优雅地恢复并仍然提供一些输出。这种恢复是错误处理的本质：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'A `try` statement can have multiple `catch` clauses that specify different
    types (subclasses) of `Exception`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`try`语句可以有多个指定不同类型（子类）的`Exception`的`catch`子句：'
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `catch` clauses are evaluated in order, and Java picks the first assignable
    match. At most, one `catch` clause is executed, which means that the exceptions
    should be listed from most specific to most generic. In the previous example,
    we anticipate that the hypothetical `readFromFile()` method can throw two different
    kinds of exceptions: one for a file not found and another for a more general read
    error. Maybe the file exists but we don’t have permission to open it. `FileNotFoundException`
    is a subclass of `IOException`, so if we had swapped the first two `catch` clauses,
    the more general `IOException` clause would catch the missing file exception.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`catch`子句按顺序评估，并且Java选择第一个可分配的匹配项。最多只执行一个`catch`子句，这意味着异常应该从最具体到最通用进行列出。在前面的示例中，我们预期假设的`readFromFile()`方法可能会抛出两种不同类型的异常：一种是文件未找到，另一种是更一般的读取错误。也许文件存在，但我们没有权限打开它。`FileNotFoundException`是`IOException`的子类，因此如果我们交换了前两个`catch`子句，更通用的`IOException`子句将捕获缺少文件异常。'
- en: What if we completely reverse the order of the `catch` clauses? You can assign
    any subclass of `Exception` to the parent type `Exception`, so that clause catches
    *every* exception. If you use a `catch` with type `Exception`, always put it as
    the last possible clause. It acts like the `default` case in a `switch` statement
    and handles any remaining possibilities.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果完全颠倒`catch`子句的顺序会怎样？您可以将`Exception`的任何子类分配给父类型`Exception`，因此该子句捕获*每个*异常。如果您使用类型为`Exception`的`catch`，请始终将其放置在可能的最后一个子句中。它的作用类似于`switch`语句中的`default`情况，并处理任何剩余可能性。
- en: One advantage of the `try/catch` scheme is that any statement in the `try` block
    can assume that all previous statements in the block succeeded. A problem won’t
    arise suddenly because you forgot to check the return value from a method. If
    an earlier statement fails, execution jumps immediately to a `catch` clause; later
    statements inside the `try` are never executed.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`try/catch` 方案的一个优点是，`try` 块中的任何语句都可以假定该块中的所有前面语句都成功执行了。不会因为忘记检查方法的返回值而突然出现问题。如果早期语句失败，执行立即跳转到
    `catch` 子句；`try` 内部的后续语句将不会执行。'
- en: 'There is an alternative to using multiple `catch` clauses. You can handle multiple
    discrete exception types in a single `catch` clause, using the *or syntax* (written
    using the pipe character, “|”):'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 使用多个 `catch` 子句的另一种选择是使用单个 `catch` 子句处理多个离散的异常类型，使用 *或语法*（使用管道字符“|”写成）：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Using this “|” syntax, we receive both types of exception in the same `catch`
    clause.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种“|”语法，我们可以在同一个 `catch` 子句中接收两种类型的异常。
- en: What is the actual type of the `e` variable that we are passing to our log method?
    What can we do with it? In this case, `e`’s type will be neither `ZipException`
    nor `SSLException` but `IOException`, which is the nearest common ancestor (the
    closest parent class type to which they are both assignable) for the two exceptions.
    In many cases, the nearest common type among the two or more argument exception
    types may simply be `Exception`, the parent of all exception types.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递给日志方法的 `e` 变量的实际类型是什么？我们可以对它做什么？在这种情况下，`e` 的类型既不是 `ZipException` 也不是 `SSLException`，而是
    `IOException`，它是这两种异常的最近公共祖先（它们都可以分配到的最近的父类类型）。在许多情况下，两个或多个参数异常类型之间的最近公共类型可能只是
    `Exception`，所有异常类型的父类。
- en: The difference between catching these discrete exception types with a multiple-type
    `catch` clause and simply catching the common parent exception type is that we
    are limiting our `catch` to only these specifically enumerated exception types.
    We will not catch any of the other `IOException` types. Combining multiple-type
    `catch` clauses with ordering the clauses from specific to broad types gives you
    great flexibility in handling exceptions. You can consolidate error-handling logic
    where appropriate and avoid repeating code. There are more nuances to this feature,
    and we will return to it after we have discussed “throwing” and “re-throwing”
    exceptions.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 使用多类型 `catch` 子句捕获这些离散异常类型与仅捕获共同父异常类型的区别在于，我们将 `catch` 限制为仅这些特定枚举的异常类型。我们不会捕获任何其他
    `IOException` 类型。将多类型 `catch` 子句与按照特定到广泛类型的顺序排列结合使用，可以在处理异常时提供很大的灵活性。在适当的情况下，您可以合并错误处理逻辑并避免重复代码。此功能还有更多细微差别，我们在讨论“抛出”和“重新抛出”异常后将返回这个话题。
- en: Bubbling Up
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 冒泡上升
- en: What if we hadn’t caught the exception? Where would it have gone? Well, if there
    is no enclosing `try/catch` statement, the exception pops up from the method in
    which it originated (halting further execution of that method) and is thrown from
    that method up to its caller. If that calling method has a `try` clause, control
    passes to the corresponding `catch` clause. Otherwise, the exception continues
    propagating up the call stack, from one method to its caller. The exception bubbles
    up until it’s caught or until it pops out of the top of the program and terminates
    it with a runtime error message. Sometimes there’s a bit more to it; the compiler
    might force you to deal with the exception along the way. [“Checked and Unchecked
    Exceptions”](#learnjava6-CHP-6-SECT-1.5) talks about this distinction in more
    detail.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有捕获异常会怎么样？它会去哪里？如果没有包围的 `try/catch` 语句，异常会从它产生的方法中弹出（停止该方法的进一步执行），并从该方法中抛出到其调用者。如果调用方法有
    `try` 子句，控制将传递给相应的 `catch` 子句。否则，异常会继续向上传播到调用堆栈中的上一方法。异常会一直冒泡直到被捕获，或者直到从程序顶部弹出并以运行时错误消息终止程序。有时情况可能更为复杂；编译器可能会强制你在途中处理异常。[“已检查和未检查的异常”](#learnjava6-CHP-6-SECT-1.5)更详细地讨论了这种区别。
- en: Let’s look at another example. In [Figure 6-4](#learnjava6-CHP-6-FIG-propagation),
    the method `getContent()` invokes the method `openConnection()` from within a
    `try/catch` statement (step 1 in the figure). In turn, `openConnection()` invokes
    the method `sendRequest()` (step 2), which calls the method `write()` to send
    some data.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看另一个例子。在 [图 6-4](#learnjava6-CHP-6-FIG-propagation) 中，方法 `getContent()` 在
    `try/catch` 语句内调用方法 `openConnection()`（图中步骤1）。然后，`openConnection()` 调用方法 `sendRequest()`（步骤2），后者调用方法
    `write()` 以发送一些数据。
- en: '![ljv6 0604](assets/ljv6_0604.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 0604](assets/ljv6_0604.png)'
- en: Figure 6-4\. Exception propagation
  id: totrans-45
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-4\. 异常传播
- en: In this figure, the second call to `write()` throws an `IOException` (step 3).
    Since `sendRequest()` doesn’t contain a `try/catch` statement to handle the exception,
    it’s thrown again from the point where it was called in the method `openConnection()`
    (step 4). But `openConnection()` doesn’t catch the exception either, so it’s thrown
    once more (step 5). Finally, it’s caught by the `try` statement in `getContent()`
    and handled by its `catch` clause. Notice that each throwing method must declare
    that it can throw a particular type of exception with a `throws` clause. We’ll
    discuss this in [“Checked and Unchecked Exceptions”](#learnjava6-CHP-6-SECT-1.5).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，第二次调用`write()`抛出了一个`IOException`（步骤 3）。由于`sendRequest()`方法中没有`try/catch`语句来处理这个异常，它会再次从调用它的`openConnection()`方法（步骤
    4）抛出。但是`openConnection()`也没有捕获这个异常，所以它会再次被抛出（步骤 5）。最后，它被`getContent()`方法中的`try`语句捕获，并由其`catch`子句处理。请注意，每个可能抛出异常的方法必须使用`throws`子句声明可以抛出特定类型的异常。我们将在[“检查异常和未检查异常”](#learnjava6-CHP-6-SECT-1.5)中讨论这个问题。
- en: Adding a high-level `try` statement early in your code can also help handle
    errors that might bubble up from background threads. We’ll discuss threads in
    much more detail in [Chapter 9](ch09.html#learnjava6-CHP-9), but uncaught exceptions
    can lead to debugging headaches in larger, more complex programs.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的早期添加一个高级别的`try`语句也可以帮助处理可能从后台线程冒出的错误。我们将在[第 9 章](ch09.html#learnjava6-CHP-9)中详细讨论线程，但是在更大更复杂的程序中，未捕获的异常可能导致调试困难。
- en: Stack Traces
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 堆栈跟踪
- en: 'Because an exception can bubble up quite a distance before it is caught and
    handled, we need a way to determine exactly where it was thrown. It’s also important
    to know how that problematic code was reached. Which methods called which other
    methods to get to that point? For debugging, all exceptions can dump a *stack
    trace* that lists their method of origin and all the nested method calls they
    took to arrive there. Most commonly, the user sees a stack trace when it is printed
    using the `printStackTrace()` method:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 因为异常可能在被捕获和处理之前冒出相当长的距离，我们需要一种方法来确定它被抛出的确切位置。了解到问题代码是如何被触发的也很重要。哪些方法调用了哪些其他方法来到达这一点？对于调试，所有异常都可以通过打印它们的*堆栈跟踪*来列出它们的起源方法以及它们到达那里所经历的所有嵌套方法调用。当用户使用`printStackTrace()`方法打印堆栈跟踪时，最常见的是看到一个堆栈跟踪：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Such a stack trace for an exception might look like this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的异常堆栈跟踪可能看起来像这样：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This stack trace indicates that line 5 (in your source code) of the `main()`
    method of the class `MyApplication` called the method `loadFile()`. The `loadFile()`
    method then tried to construct a `FileInputStream` at line 137, which threw the
    `FileNotFound``Exception`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 此堆栈跟踪指示在`MyApplication`类的`main()`方法的第 5 行（在您的源代码中）调用了`loadFile()`方法。然后，`loadFile()`方法尝试在第
    137 行构造`FileInputStream`，它抛出了`FileNotFound``Exception`异常。
- en: Once the stack trace reaches Java system classes (like `FileInputStream`), the
    line numbers may be lost. This can also happen if the code has been optimized.
    Usually, there is a way to disable the optimization temporarily to find the exact
    line numbers, but sometimes other debugging techniques may be required. We’ll
    look at many of those techniques later in this chapter.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦堆栈跟踪到达Java系统类（如`FileInputStream`），行号可能会丢失。如果代码已经优化，也可能会发生这种情况。通常可以通过暂时禁用优化来找到确切的行号，但有时可能需要其他调试技术。我们将在本章后面讨论许多这些技术。
- en: Methods in the `Throwable` class allow you to retrieve the stack trace information
    programmatically, by using the `getStackTrace()` method. (Recall that `Throwable`
    is the parent class of `Exception` and `Error`.) This method returns an array
    of `StackTraceElement` objects, each of which represents a method call on the
    stack. You can ask a `StackTraceElement` for details about that method’s location
    using the methods `getFileName()`, `getClassName()`, `getMethodName()`, and `getLineNumber()`.
    Element zero of the array is the top of the stack, the final line of code that
    caused the exception; subsequent elements step back one method call each until
    the original `main()` method is reached in the last element.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`Throwable`类中的方法允许您通过使用`getStackTrace()`方法以编程方式检索堆栈跟踪信息。（回想一下，`Throwable`是`Exception`和`Error`的父类。）该方法返回一个`StackTraceElement`对象数组，每个对象表示堆栈上的一个方法调用。您可以使用`getFileName()`、`getClassName()`、`getMethodName()`和`getLineNumber()`方法询问`StackTraceElement`关于该方法位置的详细信息。数组的第一个元素是堆栈的顶部，导致异常的最后一行代码；随后的元素逐步回退到原始`main()`方法，直到最后一个元素。'
- en: Checked and Unchecked Exceptions
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查异常和未检查异常
- en: 'We mentioned earlier that Java forces us to be explicit about our error handling,
    but it’s not necessary to require that every conceivable type of error be handled
    explicitly in every situation. Java exceptions are therefore divided into two
    categories: *checked* and *unchecked*. Most application-level exceptions are checked,
    which means that any method that throws one must declare it with a special `throws`
    clause in its definition, like this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到过，Java要求我们明确地处理错误，但并不需要在每种情况下都要求明确处理每种可能的错误类型。因此，Java异常被分为两类：*已检查*和*未检查*。大多数应用程序级异常都是已检查的，这意味着任何抛出它的方法必须在其定义中用特殊的`throws`子句声明它，如下所示：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Our `readFile()` method anticipates throwing two types of exceptions: by generating
    them itself (as we’ll discuss in [“Throwing Exceptions”](#learnjava6-CHP-6-SECT-1.6))
    and by ignoring ones that occur within it. For now, all you need to know is that
    methods have to declare the checked exceptions they can throw or allow to be thrown.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`readFile()`方法预计会抛出两种类型的异常：通过自身生成异常（正如我们将在[“抛出异常”](#learnjava6-CHP-6-SECT-1.6)中讨论的那样），以及忽略在其内部发生的异常。目前，你只需知道方法必须声明其可能抛出或允许抛出的已检查异常。
- en: The `throws` clause tells the compiler that a method is a possible source of
    that type of checked exception and that anyone calling that method must be prepared
    to deal with it. The caller must then either use a `try/catch` block to handle
    it or, in turn, declare that it can throw the exception from itself.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`throws`子句告诉编译器，方法可能是该类型已检查异常的来源，并且调用该方法的任何人必须准备好处理它。然后，调用者必须使用`try/catch`块处理它，或者反过来，声明自己可以从自身抛出异常。'
- en: In contrast, exceptions that are subclasses of either the class `java.lang.RuntimeException`
    or the class `java.lang.Error` are unchecked. See [Figure 6-1](#learnjava6-CHP-6-FIG-1)
    for the subclasses of `RuntimeException`. It’s not a compile-time error to ignore
    the possibility of these exceptions; methods also don’t have to declare they can
    throw them. In all other respects, unchecked exceptions behave the same as other
    exceptions. You are free to catch them if you wish, but in this case you aren’t
    required to.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，属于`java.lang.RuntimeException`类或`java.lang.Error`类的子类的异常是未检查的。请参见[图 6-1](#learnjava6-CHP-6-FIG-1)，了解`RuntimeException`的子类。忽略这些异常的可能性不是编译时错误；方法也不必声明它们可能会抛出它们。在其他方面，未检查异常的行为与其他异常相同。您可以选择捕获它们，但在这种情况下，您不是必须的。
- en: Checked exceptions are intended to cover application-level problems, such as
    missing files and unavailable network hosts. As good programmers (and upstanding
    citizens), we should design software to recover gracefully from these kinds of
    conditions. Unchecked exceptions are intended for system-level problems, such
    as “array index out of bounds.” While these may indicate application-level programming
    errors, they can occur almost anywhere. Fortunately, because they are unchecked
    exceptions, you don’t have to wrap every one of your array operations in a `try/catch`
    statement or declare all of the calling methods as a potential source of them.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 已检查异常旨在涵盖应用程序级问题，例如丢失文件和不可用网络主机。作为优秀的程序员（和正直的公民），我们应该设计软件，从这些类型的情况中优雅地恢复。未检查异常旨在处理系统级问题，例如“数组索引超出范围”。虽然这些可能表明应用程序级编程错误，但它们几乎可以在任何地方发生。幸运的是，因为它们是未检查异常，你不必在每一个数组操作中都包装一个`try/catch`语句，也不必声明所有调用方法都可能是它们的来源。
- en: To sum up, checked exceptions are problems that a reasonable application should
    try to handle gracefully. Unchecked exceptions (runtime exceptions or errors)
    are problems from which we would not normally expect our software to recover,
    but you can provide a polite and hopefully informative message to the user about
    what happened. Error types, such as “out of memory” errors, are conditions we
    typically cannot recover from.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，已检查异常是合理的应用程序应尝试优雅处理的问题。未检查异常（运行时异常或错误）是我们不希望软件通常能够恢复的问题，但您可以向用户提供礼貌且希望有用的消息，说明发生了什么。错误类型，例如“内存不足”错误，是我们通常无法从中恢复的条件。
- en: Throwing Exceptions
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抛出异常
- en: 'We can throw our own exceptions—either instances of `Exception`, one of its
    existing subclasses, or our own specialized exception classes. All we have to
    do is create an instance of the appropriate exception class and throw it with
    the `throw` statement:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以抛出自己的异常——可以是`Exception`的实例，它的一个现有子类，或我们自己的专门异常类。我们所需做的就是创建适当异常类的实例，并用`throw`语句抛出它：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Execution stops and is transferred to the nearest enclosing `try/catch` statement
    that can handle the exception type. Notice we didn’t put the new exception into
    a variable. There is little point in keeping a reference to the `IOException`
    object we’ve created here, as the `throw` statement immediately halts the current
    flow through our code.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 执行会停止，并转移到最接近的封闭的`try/catch`语句，该语句能够处理异常类型。请注意，我们没有将新异常放入变量中。在这里，保留对我们创建的`IOException`对象的引用没有多少意义，因为`throw`语句会立即停止当前代码的执行流程。
- en: 'An alternative constructor for exceptions lets us specify a string with an
    error message:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 异常的另一种构造方法允许我们指定带有错误消息的字符串：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You can retrieve this string by using the `Exception` object’s `getMessage()`
    method. Often, though, you can just print the exception object itself to get the
    message and stack trace.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用`Exception`对象的`getMessage()`方法来检索此字符串。不过，通常情况下，您可以直接打印异常对象本身以获取消息和堆栈跟踪信息。
- en: 'By convention, all types of `Exception` have a `String` constructor like this.
    The “Sunspots!” message is whimsical but not very helpful. Normally, you will
    throw a more specific subclass of `Exception`, which captures extra details about
    the fault or at least provides a more useful string explanation. Here’s another
    example:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，所有类型的`Exception`都有一个像这样的`String`构造函数。“太阳黑子！”消息是异想天开的，但并不是非常有用。通常情况下，您会抛出一个更具体的`Exception`子类，它捕获关于故障的额外细节或至少提供更有用的字符串解释。这里是另一个例子：
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this code, we partially implement a method to check for an illegal path.
    If we find one, we throw a `SecurityException` with some information about the
    transgression.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们部分实现了一个检查非法路径的方法。如果找到了一个，我们会抛出一个带有关于违规行为的一些信息的`SecurityException`。
- en: 'Of course, we could include any other information that is useful in our own
    specialized subclasses of `Exception`. Often, though, just having a new type of
    exception is good enough because it’s sufficient to help direct the flow of control.
    For example, if we are building a program to read and parse the contents of a
    web page, we might want to make our own kind of exception to indicate a particular
    failure:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以在`Exception`的专门子类中包含任何其他有用的信息。不过，通常情况下，仅仅有一个新类型的异常已经足够了，因为它足以帮助控制流程。例如，如果我们正在构建一个程序来读取和解析网页的内容，我们可能希望制作我们自己的异常类型来指示特定的失败：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'See [“Constructors”](ch05.html#learnjava6-CHP-5-SECT-3.1) for a full description
    of classes and class constructors. The body of our `Exception` class here simply
    allows a `ParseException` to be created in the conventional ways (either generically
    or with a little extra information). Now that we have our new exception type,
    we can guard against any poorly formatted content like this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 请参见[“构造函数”](ch05.html#learnjava6-CHP-5-SECT-3.1)以获取有关类和类构造函数的完整描述。我们这里的`Exception`类体简单地允许按照传统方式（通用或带有少量额外信息）创建`ParseException`。现在我们有了我们的新异常类型，我们可以防范像这样任何格式不当的内容：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Even without special information like the line number where our input caused
    a problem, our custom exception lets us distinguish a parse error from some other
    I/O error in the same chunk of code.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 即使没有特殊信息（比如我们的输入导致问题的行号），我们的自定义异常也能让我们区分解析错误和同一段代码中的其他 I/O 错误。
- en: Chaining and re-throwing exceptions
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 异常的链接和重新抛出
- en: Sometimes you’ll want to take some action based on an exception and then turn
    around and throw a new exception in its place. This is common when building frameworks
    where low-level detailed exceptions are handled and represented by higher-level
    exceptions that can be managed more easily. For example, you might want to catch
    an `IOException` in a communications package, possibly perform some cleanup, and
    then throw a higher-level exception of your own, maybe something like `LostServerConnection`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您会希望根据异常采取一些操作，然后立即抛出一个新的异常。在构建处理低级详细异常并由更易于管理的高级异常表示的框架时，这是常见的做法。例如，您可能想在通信包中捕获`IOException`，可能执行一些清理工作，然后抛出自己的高级异常，也许类似于`LostServerConnection`。
- en: 'You can do this in the obvious way by simply catching the exception and then
    throwing a new one, but then you lose important information, including the stack
    trace of the original “causal” exception. To deal with this, you can use the technique
    of *exception chaining*. This means that you include the causal exception in the
    new exception that you throw. Java has explicit support for exception chaining.
    The base `Exception` class can be constructed with an exception as an argument
    or the standard `String` message and an exception:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过简单捕获异常然后抛出新异常的方式来完成这一点，但是这样会丢失重要信息，包括原始“因果”异常的堆栈跟踪。为了处理这个问题，您可以使用*异常链*技术。这意味着您在抛出的新异常中包含原因异常。Java
    明确支持异常链。基本的`Exception`类可以用异常作为参数或标准的`String`消息和异常来构造：
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You can get access to the wrapped exception later with the `getCause()` method.
    More importantly, Java automatically prints both exceptions and their respective
    stack traces if you print the exception or if it is shown to the user.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以稍后使用`getCause()`方法访问包装的异常。更重要的是，如果打印异常或向用户显示异常，Java 会自动打印两个异常及其各自的堆栈跟踪。
- en: 'You can add this kind of constructor to your own exception subclasses (delegating
    to the parent constructor). You can also take advantage of this pattern by using
    the `Throwable` method `initCause()` to set the causal exception explicitly after
    constructing your own exception and before throwing it:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在自己的异常子类中添加这种构造方法（委托给父构造函数）。您还可以通过在构造自己的异常后并在抛出异常之前使用`Throwable`方法`initCause()`显式设置因果异常来利用此模式：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Sometimes it’s enough to simply do some logging or take some intermediate action
    and then re-throw the original exception:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 有时仅需执行一些日志记录或采取一些中间操作，然后重新抛出原始异常即可：
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You see this pattern crop up when you have exceptions that don’t contain enough
    information to handle locally. You can do something with what information is available
    (like printing an error message to help during debugging), but you don’t have
    enough information to recover from the problem. You have to pass on the exception
    and hope that some calling method with more resources will know what to do.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当异常中不包含足够的信息来进行本地处理时，您会看到这种模式出现。您可以利用可用的信息做些事情（比如在调试期间打印错误消息以帮助），但是您没有足够的信息来解决问题。您必须传递异常，并希望某个资源更丰富的调用方法知道该怎么做。
- en: try Creep
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试蠕动
- en: 'The `try` statement imposes a condition on the statements that it guards. It
    says that if an exception occurs within it, the remaining statements will be abandoned.
    This has consequences for local variable initialization. If the compiler can’t
    determine whether a local variable assignment placed inside a `try/catch` block
    will happen, it won’t let us use the variable. For example:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`try`语句对它保护的语句施加了一个条件。它表示如果其中发生异常，剩余的语句将被放弃。这对局部变量初始化有影响。如果编译器无法确定放置在`try/catch`块内的局部变量赋值是否会发生，它就不会允许我们使用该变量。例如：'
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In this example, we can’t use `foo` in the indicated place because there’s
    a chance it was never assigned a value. One option is to move the assignment for
    `bar` inside the `try` statement:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们无法在指定的地方使用`foo`，因为有可能从未给它赋值。一种选择是将`bar`的赋值移到`try`语句内部：
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Sometimes this works just fine. However, now we have the same problem if we
    want to use `bar` later in `myMethod()`. If we’re not careful, we might end up
    pulling everything into the `try` statement. The situation changes, however, if
    we transfer control out of the method in the `catch` clause:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 有时这样做效果很好。然而，如果我们稍后在`myMethod()`中想使用`bar`，我们就会遇到同样的问题。如果不小心的话，我们可能会将所有内容都引入到`try`语句中。然而，如果在`catch`子句中控制方法的传递，情况就会发生变化：
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The compiler is smart enough to know that if an error had occurred in the `try`
    clause, we wouldn’t have reached the `bar` assignment, so it allows us to refer
    to `foo`. Your code may have different requirements; we just want you to be aware
    of the options.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器足够聪明，知道如果`try`子句中发生错误，我们就不会达到`bar`赋值，因此允许我们引用`foo`。您的代码可能有不同的要求；我们只是希望您意识到这些选项。
- en: The finally Clause
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最终子句
- en: 'What if we have something important to do before we exit our method from one
    of the `catch` clauses? To avoid duplicating the code in each `catch` branch and
    to make the cleanup more explicit, you can use the `finally` clause. A `finally`
    clause can be added after a `try` block and its associated `catch` clauses. Any
    statements in the body of the `finally` clause are guaranteed to be executed no
    matter how control leaves the `try` body, whether an exception is thrown or not:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在一个 `catch` 子句中退出方法之前有重要的事情要做怎么办？为了避免在每个 `catch` 分支中重复代码并使清理更加明确，您可以使用 `finally`
    子句。 `finally` 子句可以在 `try` 块及其相关的 `catch` 子句之后添加。 `finally` 子句体中的任何语句都保证会在控制权离开
    `try` 体时执行，无论是否抛出异常：
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In this example, the statements at the cleanup point are executed eventually,
    no matter how control leaves the `try`. If control transfers to one of the `catch`
    clauses, the statements in `finally` are executed after the `catch` completes.
    If none of the `catch` clauses handles the exception, the `finally` statements
    are executed before the exception propagates to the next level.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，清理点处的语句最终会被执行，无论控制权如何离开 `try`。如果控制权转移到 `catch` 子句之一，则在 `catch` 完成后执行 `finally`
    中的语句。如果没有 `catch` 子句处理异常，则在异常传播到下一级之前执行 `finally` 中的语句。
- en: 'Even if the statements in the `try` execute cleanly, or if we perform a `return`,
    `break`, or `continue`, the statements in the `finally` clause are still executed.
    To guarantee that some operations will run, we can even use `try` and `finally`
    without any `catch` clauses:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 即使 `try` 中的语句执行干净，或者我们执行 `return`、`break` 或 `continue`，`finally` 子句中的语句仍然会执行。为了保证某些操作将运行，我们甚至可以在没有任何
    `catch` 子句的情况下使用 `try` 和 `finally`：
- en: '[PRE21]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Exceptions that occur in a `catch` or `finally` clause are handled normally;
    the search for an enclosing `try/catch` begins outside the offending `try` statement,
    after the `finally` has been executed.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 发生在 `catch` 或 `finally` 子句中的异常会被正常处理；在执行 `finally` 之后，搜索包围异常 `try/catch` 的范围开始于异常
    `try` 语句之外。
- en: try with Resources
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用资源的尝试
- en: 'A common use of the `finally` clause is to ensure that resources used in a
    `try` clause are cleaned up, no matter how the code exits the block. Consider
    opening a network socket (more on these in [Chapter 13](ch13.html#learnjava6-CHP-13)):'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`finally` 子句的一个常见用途是确保清理 `try` 子句中使用的资源，无论代码如何退出该块。考虑打开网络套接字（有关详细信息，请参见 [第
    13 章](ch13.html#learnjava6-CHP-13)）：'
- en: '[PRE22]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: What we mean by “cleaning up” here is deallocating expensive resources or closing
    connections to things such as files, network sockets, or databases. In some cases,
    these resources might get cleaned up on their own eventually as Java reclaims
    the garbage, but at best, that would happen at an unknown time in the future.
    At worst, the cleanup may never happen or may not happen before you run out of
    resources. You should always guard against these situations.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这里所说的“清理”是指释放昂贵的资源或关闭与诸如文件、网络套接字或数据库等事物的连接。在某些情况下，这些资源可能会在 Java 回收垃圾时自动清理，但最好的情况是，这将在未来的某个未知时间发生。在最坏的情况下，清理可能永远不会发生，或者可能在您耗尽资源之前不会发生。您应该始终防范这些情况。
- en: In the real world, however, there are two problems with staying on top of such
    resource allocation. First, it requires extra work to carry out a proper cleanup
    pattern in all of your code, including important things like null checks, as shown
    in our hypothetical example. Second, if you are juggling multiple resources in
    a single `finally` block, you have the possibility of your cleanup code itself
    throwing an exception (e.g., on `close()`) and leaving the job unfinished.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在现实世界中，保持对这种资源分配的控制存在两个问题。首先，需要额外的工作来在所有代码中执行正确的清理模式，包括重要的事项，如我们的假设示例中所示的空值检查。其次，如果您在单个
    `finally` 块中操作多个资源，您的清理代码本身可能会引发异常（例如，在 `close()` 上），并且使工作未完成。
- en: 'The “try with resources” form of the `try` clause can help. In this extended
    form, you place one or more resource initialization statements within parentheses
    after the `try` keyword. Those resources will automatically be “closed” for you
    when control leaves the `try` block:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: “使用资源的尝试”形式的 `try` 子句可以帮助。在这种扩展形式中，您在 `try` 关键字后的括号中放置一个或多个资源初始化语句。当控制权离开 `try`
    块时，这些资源将自动“关闭”：
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In this example, we initialize both a `Socket` object and a `FileWriter` object
    within the `try`-with-resources clause, and we can use them within the body of
    the `try` statement. When control leaves the `try` statement, either after successful
    completion or because of an exception, Java automatically closes both resources
    by calling their respective `close()` methods. Java closes these resources in
    the *reverse of the order* in which you constructed them, so you can accommodate
    any dependencies among them.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们在`try-with-resources`子句中初始化了一个`Socket`对象和一个`FileWriter`对象，并且可以在`try`语句的主体中使用它们。当控制离开`try`语句时，无论是因为成功完成还是因为异常，Java都会通过调用它们各自的`close()`方法自动关闭这两个资源。Java按你构造它们的相反顺序关闭这些资源，因此你可以适应它们之间的任何依赖关系。
- en: Java supports this behavior for any class that implements the `AutoCloseable`
    interface (which, at current count, over one hundred different built-in classes
    do). The `close()` method of this interface is prescribed to release all resources
    associated with the object, and you can implement this easily in your own classes
    as well. Now when using `try`-with-resources, we don’t have to add any code specifically
    to close the file or socket; it is done for us automatically.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Java支持任何实现了`AutoCloseable`接口的类的此行为（目前超过一百种不同的内置类实现了该接口）。该接口的`close()`方法被规定用于释放与对象相关联的所有资源，并且你也可以轻松地在自己的类中实现这一点。现在，使用`try-with-resources`时，我们不必专门添加任何代码来关闭文件或套接字；它会自动完成。
- en: 'Another problem that `try`-with-resources solves is the pesky situation where
    an exception is thrown during a close operation. Looking back to the prior example
    in which we used a `finally` clause to do our cleanup, if an exception had been
    raised by the `close()` method, the new exception would have been thrown at that
    point, completely abandoning the original exception from the body of the `try`
    clause. But `try`-with-resources preserves the original exception. If an exception
    occurs within the body of the `try` and one or more exceptions are raised during
    the subsequent auto-closing operations, it is the original exception from the
    body of the `try` that will bubble up to the caller. Let’s look at an example:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`try-with-resources`解决的另一个问题是在关闭操作期间抛出异常的麻烦情况。回顾我们在先前示例中使用`finally`子句进行清理的情况，如果`close()`方法引发了异常，新异常将在那一点抛出，完全放弃`try`子句体中的原始异常。但是`try-with-resources`保留了原始异常。如果在`try`体内发生异常，并且在随后的自动关闭操作中引发了一个或多个异常，将是`try`体中的原始异常将向上传递给调用方。让我们看一个例子：'
- en: '[PRE24]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Once the `try` has begun, if an exception occurs at exception point #1, Java
    will attempt to close both resources in reverse order, leading to potential exceptions
    at locations #2 and #3\. In this case, the calling code will still receive exception
    #1\. Exceptions #2 and #3 are not lost, however; they are merely “suppressed.”
    You can retrieve them via the `getSuppressed()` method of the exception thrown
    to the caller. This method returns an array of all of the suppressed exceptions.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`try`块开始执行，如果在异常点#1处发生异常，Java将尝试按相反的顺序关闭两个资源，导致可能在位置#2和#3出现异常。在这种情况下，调用代码仍将接收到异常#1。然而，异常#2和#3并未丢失；它们仅仅是“抑制”了。你可以通过抛出给调用方的异常的`getSuppressed()`方法来检索它们。此方法返回所有被抑制的异常的数组。
- en: Performance Issues
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能问题
- en: Because of the way the Java VM is implemented, using a `try` block to guard
    against an exception being thrown is free, meaning it doesn’t add any overhead
    to the execution of your code. However, throwing an exception is not free. When
    an exception is thrown, Java has to locate the appropriate `try/catch` block and
    perform other time-consuming activities at runtime.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Java虚拟机的实现方式，使用`try`块来防范抛出异常是免费的，这意味着它不会增加代码的执行开销。然而，抛出异常是不免费的。当抛出异常时，Java必须定位适当的`try/catch`块，并在运行时执行其他耗时的活动。
- en: That’s why you should throw exceptions only in truly “exceptional” circumstances
    and avoid using them for expected conditions, especially when performance is an
    issue. For example, if you have a loop, it may be better to perform a small test
    on each pass and avoid a `try` block rather than potentially throwing an exception
    several times over the run of the loop. On the other hand, if the exception is
    thrown only once in a gazillion times, you may want to eliminate the overhead
    of your small checks and not worry about the cost of throwing that very rare exception.
    The general rule should be that exceptions are used for abnormal situations, not
    routine or expected conditions (such as the end of a file or a missing web resource).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么你应该只在真正的“异常”情况下抛出异常，并避免在预期的条件下使用它们，特别是在性能是一个问题时。例如，如果你有一个循环，每次通过可能更好地执行一次小的测试，并避免`try`块，而不是在循环运行过程中可能多次抛出异常。另一方面，如果异常只在亿万次中抛出一次，你可能希望消除小测试的开销，并且不必担心抛出那个非常罕见异常的成本。一般的规则应该是异常用于异常情况，而不是例行或预期条件（比如文件结束或缺少的网络资源）。
- en: Assertions
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 断言
- en: 'Java supports assertions as another mechanism for validating the state of your
    program. An *assertion* is a simple pass/fail test of some condition, performed
    while your application is running. You can use assertions to “sanity check” your
    code. Assertions are distinct from other kinds of tests because they check conditions
    that should never be violated at a logical level: if the assertion fails, it means
    some code you wrote is not doing its job and the application generally halts with
    an appropriate error message. Assertions are supported directly by the Java language,
    and they can be turned on or off at runtime to remove any performance penalty
    associated with including them in your code.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Java 支持断言（assertions）作为验证程序状态的另一种机制。*断言* 是在应用程序运行时执行的一种简单的通过/失败测试某些条件的方式。你可以使用断言来“健全检查”你的代码。断言与其他类型的测试不同，因为它们检查在逻辑层面上不应该被违反的条件：如果断言失败，意味着你编写的某些代码未能完成其工作，应用程序通常会以适当的错误消息停止运行。Java
    语言直接支持断言，并且可以在运行时打开或关闭它们，以消除将其包含在代码中带来的任何性能损失。
- en: Using assertions to test for the correct behavior of your application is a simple
    but powerful technique for ensuring software quality. It fills a gap between those
    aspects of software that the compiler can check automatically and those more generally
    checked by “unit tests” or human testing. Assertions test your own assumptions
    about program behavior and turn those assumptions into guarantees (at least while
    assertions are activated).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 使用断言来测试应用程序的正确行为是一种简单但强大的技术，用于确保软件质量。它填补了编译器可以自动检查的软件方面与那些由“单元测试”或人工测试更普遍检查的方面之间的空白。断言测试你对程序行为的假设，并将这些假设转化为保证（至少在激活断言时是这样）。
- en: If you have programmed before, you may have seen something like the following:^([3](ch06.html#id1370))
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你以前有编程经验，可能见过类似以下的内容：^([3](ch06.html#id1370))
- en: '[PRE25]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: An assertion in Java is equivalent to this example, but you use the `assert`
    keyword. It takes a Boolean condition and an optional expression value. If the
    assertion fails, an `AssertionError` is thrown, which usually causes Java to bail
    out of the application. The idea behind bailing out is that an assertion failure
    reveals a logical flaw in your code—and it is your responsibility as the programmer
    to find and fix that flaw.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 中，断言等同于这个例子，但你使用`assert`关键字。它接受一个布尔条件和一个可选的表达式值。如果断言失败，将抛出`AssertionError`，通常导致
    Java 应用程序停止运行。中止应用程序的想法是，断言失败揭示了代码中的逻辑缺陷，作为程序员，你有责任找出并修复这个缺陷。
- en: 'The optional expression may evaluate to either a primitive value or object
    type. Either way, its sole purpose is to be turned into a string and shown to
    the user if the assertion fails. Most often you’ll use a string message explicitly.
    Here are some examples:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 可选表达式可以评估为原始值或对象类型。无论哪种方式，它的唯一目的是将其转换为字符串，并在断言失败时显示给用户。通常情况下，你会显式地使用一个字符串消息。以下是一些示例：
- en: '[PRE26]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the event of failure, the first two assertions print only a generic message.
    The third prints the value of `a`, and the last prints the `foo is null!` message.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在失败的情况下，前两个断言仅打印一个通用消息。第三个打印`a`的值，最后一个打印`foo is null!`消息。
- en: The important thing about assertions is not just that they are more terse than
    the equivalent `if` condition, but that you can enable or disable them when you
    run the application. Disabling assertions means that their test conditions are
    not even evaluated, so there is no performance penalty for including them in your
    code (other than, perhaps, still consuming a small bit of space in the class files
    when they are loaded).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 断言的重要之处不仅在于它们比等效的`if`条件更简洁，而且你可以在运行应用程序时启用或禁用它们。禁用断言意味着它们的测试条件甚至不会被评估，因此在你的代码中包含它们不会产生性能惩罚（除了在加载时可能仍然占用一小部分类文件空间之外）。
- en: Enabling and Disabling Assertions
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用和禁用断言
- en: You turn assertions on or off at runtime. When disabled, assertions still exist
    in the class files but are not executed and do not consume CPU time. You can enable
    and disable assertions for an entire application, package by package, or even
    class by class. Remember, assertions are meant to be sanity checks for *you* during
    development. They are not usually meant to be seen by your end users. Using them
    as you work on your project but disabling them for “production” is a common tactic.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在运行时打开或关闭断言。当禁用时，断言仍然存在于类文件中，但不会被执行，也不会消耗 CPU 时间。你可以为整个应用程序、按包或甚至按类启用和禁用断言。请记住，断言是为了*你*在开发过程中的理智检查而设计的。它们通常不是为了被你的最终用户所看到。在你开发项目时使用它们，但在“生产”中禁用它们是一种常见的策略。
- en: 'By default, assertions are turned off in Java. To enable them for your code,
    use the `java` command flag `-ea` or `-enableassertions`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 中，默认情况下，断言是关闭的。要为你的代码启用它们，请使用`java`命令标志`-ea`或`-enableassertions`：
- en: '[PRE27]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'To turn on assertions for a particular class, append the class name:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要为特定类启用断言，请附加类名：
- en: '[PRE28]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To turn on assertions just for particular packages, append the package name
    with trailing ellipses (…​):'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 要仅为特定包启用断言，附加包名称后跟省略号（…​）：
- en: '[PRE29]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'When you enable assertions for a package, Java also enables all subordinate
    package names (e.g., `com.oreilly.examples.text`). However, you can be more selective
    by using the corresponding `-da` or `-disableassertions` flag to negate individual
    packages or classes. You can combine all this to achieve arbitrary groupings,
    like this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当你为一个包启用断言时，Java 还会启用所有下级包的断言（例如，`com.oreilly.examples.text`）。然而，你可以通过使用相应的`-da`或`-disableassertions`标志来对个别包或类进行否定，以实现更有选择性的操作。你可以将所有这些组合起来，实现任意分组，就像这样：
- en: '[PRE30]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This example enables assertions for the `com.oreilly.examples` package as a
    whole, excludes the package `com.oreilly.examples.text`, but then turns exceptions
    on for the `MonkeyTypewriters` class in that package.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例为整个`com.oreilly.examples`包启用了断言，排除了包`com.oreilly.examples.text`，但然后为该包中的`MonkeyTypewriters`类启用了异常。
- en: Using Assertions
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用断言
- en: An assertion enforces a rule about something that should be stable in your code
    and would otherwise go unchecked. You can use an assertion for added safety anywhere
    you want to verify your assumptions about program behavior that the compiler may
    not be able to check.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 断言是对代码中应该稳定的事物的规则的强制执行，否则这些事物将不会被检查。你可以在任何想要验证编译器可能无法检查的程序行为假设的地方使用断言来增加安全性。
- en: 'A common situation that cries out for an assertion is testing for multiple
    conditions or values where one should always be found. In this case, a failing
    assertion as the default or “fall through” behavior indicates the code is broken.
    For example, suppose we have a value called `direction` that should always contain
    one of two constants, `LEFT` or `RIGHT`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的情况是测试多个条件或值，其中应始终找到一个。在这种情况下，作为默认或“穿透”行为的断言失败表明代码有问题。例如，假设我们有一个称为`direction`的值，它应始终包含两个常量之一，`LEFT`或`RIGHT`：
- en: '[PRE31]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The same applies to the default case of a switch:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 对于开关的默认情况也是一样的：
- en: '[PRE32]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In general, you should not use assertions for checking the validity of arguments
    to methods. You want that validating behavior to be part of your application,
    not just a quality control test that can be turned off. Methods require valid
    input as part of their *preconditions*, and you should usually throw an exception
    if any preconditions are not met. Using exceptions elevates the preconditions
    to part of the method’s “contract” with the user. However, checking the correctness
    of the results of your methods with assertions before returning them can be useful.
    These wrap-up checks are called *postconditions*.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，您不应该使用断言来检查方法的参数有效性。您希望这种验证行为成为应用程序的一部分，而不仅仅是可以关闭的质量控制测试。方法需要有效的输入作为其*前置条件*的一部分，如果未满足任何前置条件，通常应该抛出异常。使用异常将前置条件提升为方法与用户之间的“合同”一部分。然而，在返回结果之前使用断言检查方法的正确性是有用的。这些封装检查被称为*后置条件*。
- en: Sometimes determining what is or is not a precondition depends on your point
    of view. For example, when a method is used internally within a class, its preconditions
    may already be guaranteed by the methods that call it. Public methods of the class
    should probably throw exceptions when their preconditions are violated, but a
    private method might use assertions because its callers are always closely related
    code that should obey the correct behavior.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候确定什么是前置条件或者不是前置条件取决于您的观点。例如，当一个方法在类内部使用时，其前置条件可能已由调用它的方法保证。类的公共方法在违反前置条件时可能会抛出异常，但私有方法可能使用断言，因为它们的调用者总是与正确行为密切相关的代码。
- en: Real-World Exceptions
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 真实世界的异常
- en: Java’s adoption of exceptions as an error-handling technique makes it much simpler
    for developers to write robust code. The compiler forces you to think about checked
    exceptions ahead of time. Unchecked exceptions will definitely pop up, but assertions
    can help you watch out for those runtime problems and hopefully prevent a crash.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Java 采用异常作为错误处理技术，使得开发者编写健壮代码变得更加简单。编译器强制您提前考虑检查异常。未经检查的异常肯定会出现，但断言可以帮助您注意这些运行时问题，希望能够避免崩溃。
- en: The try-with-resources feature makes it even simpler for developers to keep
    their code clean and “do the right thing” when interacting with limited system
    resources, such as files and network connections. As we noted at the beginning
    of the chapter, other languages certainly have facilities or customs for dealing
    with these problems. Java, as a language, works hard to help you thoughtfully
    consider issues that can arise in your code. The more you work through resolving
    those issues, the more stable your application (and the happier your users) will
    be.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 try-with-resources 功能使开发者在处理有限系统资源（如文件和网络连接）时更加简洁和“正确”。正如我们在本章开头提到的，其他语言当然也有处理这些问题的设施或习惯。作为一种语言，Java
    努力帮助您深思熟虑代码中可能出现的问题。您越是解决这些问题，您的应用程序（以及您的用户）就会更加稳定。
- en: Many of our examples so far have been straightforward and have not really required
    any fancy error checking. Rest assured we’ll be exploring more interesting code
    with, many things that merit exception handling. Later chapters will cover topics
    like multithreaded programming and networking. Those topics are rife with situations
    that can go wrong at runtime, such as a big calculation running amok or a WiFi
    connection dropping. Pardon the pun, but you’ll be `try`ing all of these new exception
    tricks soon enough!
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的许多示例都很直接，并且实际上并不需要任何复杂的错误检查。请放心，我们将探讨更多需要异常处理的有趣代码。后续章节将涵盖多线程编程和网络编程等主题。这些主题充满了可能在运行时出现问题的情况，例如大型计算失控或
    WiFi 连接断开。原谅这句双关语，但您很快就会学习到所有这些新的异常技巧！
- en: Review Questions
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复习问题
- en: What statement should you use to manage potential exceptions in your code?
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的代码中管理潜在异常时，应该使用哪个语句？
- en: Which exceptions does the compiler require you to handle or throw?
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译器在哪些异常情况下要求您处理或抛出？
- en: Where do you place any cleanup code that you want to always run after using
    some resources in a `try` block?
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `try` 块中使用后，您应该将任何清理代码放在哪里？
- en: Do assertions have much of a performance penalty when they are disabled?
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当禁用时，断言会对性能产生多大的影响？
- en: Code Exercises
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码练习
- en: The *Pause.java* program in the *ch06/exercises* folder will not compile. It
    uses a method, `Thread.sleep()`, to pause the program for five seconds. That `sleep()`
    method can throw a checked exception. Fix the program so it compiles and runs.
    (We’ll be seeing more of threads and `Thread.sleep()` in [Chapter 9](ch09.html#learnjava6-CHP-9).)
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*Pause.java*程序位于*ch06/exercises*文件夹中，无法编译。它使用了`Thread.sleep()`方法来暂停程序五秒钟。这个`sleep()`方法可能会抛出一个已检查异常。修复程序使其能够编译和运行。（我们将在[第9章](ch09.html#learnjava6-CHP-9)中更深入地学习线程和`Thread.sleep()`。）'
- en: The exercises include another variation of our “Hello, World” program from [Chapter 2](ch02.html#learnjava6-CHP-2)
    called `HelloZero`. Use an assertion to make sure that the initial x and y coordinates
    for the graphical message are greater than zero.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 练习包括我们在[第2章](ch02.html#learnjava6-CHP-2)中另一个“Hello, World”程序的变体，名为`HelloZero`。使用断言确保图形消息的初始
    x 和 y 坐标大于零。
- en: Try running the program and enabling assertions. What happens if you assign
    a negative number to one of the coordinates? Run the program again but leave assertions
    disabled. (Recall that “disabled” is the default behavior, so just don’t enable
    them.) What happens in this case?
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 尝试运行程序并启用断言。如果将负数赋值给其中一个坐标，会发生什么？再次运行程序，但不要禁用断言。（记住，“禁用”是默认行为，所以只需不启用它们。）在这种情况下会发生什么？
- en: Advanced Exercises
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高级练习
- en: Let’s pretend that a greatest common denominator (GCD) of 1 is an error condition
    that we need to flag. Create a new class, `Euclid3` , that will do the usual work
    of finding the GCD but will throw an exception if that common denominator is 1\.
    (Feel free to start by copying any of your other Euclidean classes.) Create a
    custom exception class called `GCDException` that stores the offending pair of
    numbers as details of the exception.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设最大公约数（GCD）为1是一个错误情况，我们需要标记它。创建一个名为`Euclid3`的新类，它将执行查找GCD的常规工作，但如果公约数为1，则会抛出异常。（可以从其他欧几里得类中复制开始。）创建一个名为`GCDException`的自定义异常类，将导致异常的数字对作为异常的详细信息存储起来。
- en: Modify `Euclid3` to test for a GCD of 1 and throw your new `GCDException` if
    that is the result. (Supplying two prime numbers is a quick way to guarantee a
    result of 1.)
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 修改`Euclid3`以测试是否存在最大公约数为1，并在结果为1时抛出新的`GCDException`异常。（提供两个素数是确保结果为1的快速方法。）
- en: Before you add any exception handling code, try compiling. Did *javac* warn
    you about the exception? It should! Go ahead and add a `try/catch` guard or edit
    the definition of `main()` to throw your exception. If you do handle the new exception,
    be sure to print a nice error message to the user that includes the “bad” numbers
    from the caught exception.
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在添加任何异常处理代码之前，请尝试编译。*javac*是否提醒您有异常？应该会！继续添加`try/catch`保护或编辑`main()`方法的定义以抛出异常。如果您处理了新的异常，请确保向用户输出包含捕获异常中“坏”数字的友好错误消息。
- en: ^([1](ch06.html#id1273-marker)) The somewhat obscure `setjmp()` and `longjmp()`
    statements in C can save a point in the execution of code and later return to
    it unconditionally from a deeply buried location. In a limited sense, this is
    the functionality of exceptions in Java that we explore in this chapter.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch06.html#id1273-marker)) 在C语言中，有些相对晦涩的`setjmp()`和`longjmp()`语句可以保存代码执行的点，并能从深埋的位置无条件地返回到该点。从某种有限的意义上来说，这正是我们在本章中探讨的Java异常的功能。
- en: ^([2](ch06.html#id1274-marker)) For example, the `getHeight()` method of the
    AWT `Image` class returns `-1` if the height isn’t known yet. No error has occurred;
    the height will be available once the image is loaded. In this situation, throwing
    an exception would be excessive and could impact performance.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch06.html#id1274-marker)) 例如，AWT `Image` 类的`getHeight()`方法如果高度尚未知晓，则返回`-1`。这并不表示发生了错误；一旦图像加载完成，高度将会得到更新。在这种情况下，抛出异常会显得过度，并可能影响性能。
- en: ^([3](ch06.html#id1370-marker)) If you have done some programming, we hope your
    error messages are not this opaque! The more helpful and explanatory your messages,
    the better.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch06.html#id1370-marker)) 如果您已经做过一些编程，希望您的错误消息不会像这样难以理解！错误消息越有帮助和解释性，就越好。
