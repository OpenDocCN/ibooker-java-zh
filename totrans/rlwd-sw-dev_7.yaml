- en: Chapter 7\. Extending Twootr
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。扩展 Twootr
- en: The Challenge
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 挑战
- en: Previously, on Twootr, Joe had wanted a modern online communication system to
    be implemented. The previous chapter presented a potential design for Twootr and
    the implementation of the core business domain was described, including driving
    out that design through tests. You learned about some of the design and data modeling
    decisions involved and how to break down the initial problem and structure your
    solution. That didn’t cover the whole of the Twootr project, so it’s up to this
    chapter to complete the narrative.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 之前在 Twootr 上，Joe 想要实现一个现代化的在线通信系统。上一章介绍了 Twootr 的潜在设计和核心业务域的实现，包括通过测试驱动设计的方法来实现该设计。您了解了涉及的一些设计和数据建模决策，以及如何分解初始问题并构建解决方案。这并没有涵盖整个
    Twootr 项目，因此本章需要完成这个叙述。
- en: The Goal
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 目标
- en: 'This chapter extends and completes the progress made in the previous chapter
    by helping you understand about the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章通过帮助您了解以下主题，扩展并完善了前一章中取得的进展：
- en: Avoiding coupling with the Dependency Inversion Principle and Dependency Injection
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免依赖倒置原则和依赖注入的耦合
- en: Persistence with the Repository pattern and the Query Object pattern.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Repository 模式和查询对象模式进行持久化。
- en: A brief introduction to functional programming that will show you how you can
    make use of the ideas from this in a Java-specific context and a real application.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简要介绍函数式编程，将向您展示如何在 Java 特定的上下文和实际应用程序中使用这些想法。
- en: Recap
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'Since we’re continuing the Twootr project from the previous chapter, it’s probably
    worth recapping the key concepts in our design at this point. If you’re continuing
    from the previous chapter in a marathon reading session, then we’re glad you’re
    enjoying the book, but feel free to skip this section:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们从前一章继续进行 Twootr 项目，因此现在可能值得回顾我们设计中的关键概念。如果您正在一场马拉松式的阅读中继续前一章节，那么我们很高兴您喜欢这本书，但请随意跳过本节。
- en: '`Twootr` is the parent class that instantiates the business logic and orchestrates
    the system.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Twootr` 是实例化业务逻辑并编排系统的父类。'
- en: A `Twoot` is a single instance of a message broadcast by a user in our system.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Twoot` 是我们系统中用户广播的消息的单个实例。'
- en: A `ReceiverEndPoint` is an interface that is implemented by a UI adapter and
    pushes `Twoot` objects out to the UI.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReceiverEndPoint` 是一个由 UI 适配器实现的接口，用于向 UI 推送 `Twoot` 对象。'
- en: The `SenderEndPoint` has methods that correspond to events being sent into the
    system from a user.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SenderEndPoint` 具有与用户从系统中发送的事件相对应的方法。'
- en: Password management and hashing are performed by the `KeyGenerator` class.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密码管理和哈希由 `KeyGenerator` 类执行。
- en: Persistence and the Repository Pattern
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持久化和 Repository 模式
- en: 'So we’ve now got a system that can support much of the core twooting operations.
    Unfortunately, if we restart the Java process in any way all the twoots and user
    information is lost. We need a way of persisting the information that we’re storing
    in order to survive a restart. Earlier in the discussion of software architecture
    we talked about ports and adapters and how we would like to keep the core of our
    application agnostic of the storage backend. There’s, in fact, a commonly used
    pattern that helps us do this: the *Repository* pattern.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个能够支持大部分核心 Twootr 操作的系统。不幸的是，如果我们以任何方式重新启动 Java 进程，所有的 Twoots 和用户信息都会丢失。我们需要一种持久化信息的方法，以便在重新启动后能够存活下来。在讨论软件架构的早期，我们谈到了端口和适配器以及如何希望使我们应用程序的核心与存储后端无关。事实上，有一种常用的模式可以帮助我们做到这一点：*Repository*
    模式。
- en: 'The Repository pattern defines an interface between the domain logic and storage
    backend. In addition to allowing us to use a different storage backend over time
    as our application evolves, this approach offers several advantages:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Repository 模式定义了领域逻辑和存储后端之间的接口。除了允许我们随着应用程序的演进在不同的存储后端之间切换外，这种方法还提供了几个优点：
- en: Centralizing logic for mapping data from our storage backend to the domain model.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据从存储后端映射到领域模型的逻辑集中化。
- en: Enables unit testing of core business logic without having to spin up a database.
    This can speed up the execution of tests.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使核心业务逻辑的单元测试成为可能，而不必启动数据库。这可以加快测试的执行速度。
- en: Improves maintainability and readability by keeping each class single responsibility.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过保持每个类单一职责，提高了可维护性和可读性。
- en: 'You can think of a repository as a being like a collection of objects, but
    instead of just storing the objects in memory, the repository persists them somewhere.
    When evolving the design of our application we drove the design of the repositories
    through tests; however, to save time here we will just describe the final implementation.
    Since a repository is a collection of objects we need two of them in Twootr: one
    to store `User` objects and one for `Twoot` objects. Most repositories have a
    series of common operations that are implemented:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将存储库视为类似于对象集合，但存储库不仅仅将对象存储在内存中，还会将它们持久化在某个地方。在演化我们应用程序设计时，我们通过测试推动了存储库的设计；但是，为了节省时间，我们只会描述最终实现。由于存储库是对象的集合，我们在Twootr中需要两个存储库：一个用于存储`User`对象，另一个用于存储`Twoot`对象。大多数存储库具有一系列常见的操作，这些操作已经实现：
- en: '`add()`'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`add()`'
- en: Stores a new instance of the object into the repository.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 将对象的新实例存储到存储库中。
- en: '`get()`'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`get()`'
- en: Looks up a single object based on an identifier.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 根据标识符查找单个对象。
- en: '`delete()`'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`delete()`'
- en: Deletes an instance from the persistence backend.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 从持久性后端删除实例。
- en: '`update()`'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`update()`'
- en: Ensures that the values saved for this object are equal to the instance fields.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 确保为此对象保存的值等于实例字段。
- en: Some people use the acronym CRUD to describe these kind of operations. This
    stands for Create, Read, Update, and Delete. We’ve used `add` and `get` instead
    of `create` and `read` as the naming is more inline with common Java usage, for
    example, in the collections framework.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人使用CRUD缩写来描述这些操作。这代表Create，Read，Update和Delete。我们使用`add`和`get`而不是`create`和`read`，因为命名更符合常见的Java用法，例如，在集合框架中。
- en: Designing the Repositories
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计存储库
- en: In our case we’ve designed things top-down and driven the development of the
    repositories from tests. The implication of this is that not all the operations
    are defined on both repositories. The `UserRepository`, shown in [Example 7-1](#UserRepository_definition),
    doesn’t have an operation to delete a `User`. That’s because there’s no requirement
    that has actually driven an operation to delete a user. We asked our customer,
    Joe, about this and he said “once you Twoot, you can’t stop!”
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们从顶向下设计事物，并通过测试驱动存储库的开发。这意味着，并非所有操作都在两个存储库上定义。如[示例 7-1](#UserRepository_definition)所示的`UserRepository`，没有一个操作来删除一个`User`。这是因为实际上没有要求执行删除用户操作。我们问了我们的客户，乔，关于这个问题，他说“一旦你开始Twoot，你就停不下来了！”
- en: When working on your own, you might be tempted to add functionality just to
    have the “normal” operations in the repository, but we would strongly caution
    against going down that route. Unused code, or *dead code* as it’s often known,
    is a liability. In some sense all code is a liability, but if the code is actually
    doing something useful then it has a benefit to your system, while if it unused
    it’s merely a liability. As your requirements evolve you need to refactor and
    improve your codebase and the more unused code that you have lying around, the
    more difficult this task is.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当独自工作时，您可能会想要添加功能，只是为了使存储库中有“正常”的操作，但我们强烈警告不要走这条路。未使用的代码，或者通常被称为*死代码*，是一种负担。从某种意义上说，所有的代码都是一种负担，但是如果代码实际上是有用的，那么它对您的系统有益处，而如果它没有被使用，那么它只是一种负担。随着您的需求的演变，您需要重构和改进您的代码库，而如果您有很多未使用的代码，这个任务就会变得更加困难。
- en: 'There’s a guiding principle here that we’ve been alluding to throughout the
    chapter, but not mentioned until now: *YAGNI*. This stands for *You ain’t gonna
    need it*. This doesn’t mean don’t introduce abstractions and different concepts
    like repositories. It just means don’t write code that you think you’re going
    to need in the future—only write it when you actually need it.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个指导原则，我们在整章中一直在暗示，但直到现在才提到：*YAGNI*。这代表*You ain’t gonna need it*。这并不意味着不要引入抽象和不同的概念，比如存储库。它只是表示在实际需要时才编写代码，而不是认为将来会需要它时编写代码。
- en: Example 7-1\. UserRepository
  id: totrans-35
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-1\. UserRepository
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: There are also differences between the design of our two repositories due to
    the nature of the objects that they are storing. Our `Twoot` objects are immutable,
    so the `TwootRepository` shown in [Example 7-2](#TwootRepository_definition) doesn’t
    need to implement an `update()` operation.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们存储的对象的性质不同，我们的两个存储库的设计也有所不同。我们的`Twoot`对象是不可变的，因此[示例 7-2](#TwootRepository_definition)中显示的`TwootRepository`不需要实现`update()`操作。
- en: Example 7-2\. TwootRepository
  id: totrans-38
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-2\. TwootRepository
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Normally the `add()` method in a repository simply takes the object in question
    and persists it to the database. In the case of the `TwootRepository`, we have
    taken a different approach. This method takes some specific parameters and actually
    creates the object in question. The motivation behind this approach was that the
    data source would be the one to assign the next `Position` object to the `Twoot`.
    We’re delegating the responsibility of ensuring a unique and ordered object to
    the data layer that will have the appropriate tool for creating such a sequence.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，存储库中的 `add()` 方法只是将相关对象持久化到数据库中。在 `TwootRepository` 的情况下，我们采取了不同的方法。这个方法接受一些特定的参数，并且实际上创建了相关对象。采用这种方法的动机是数据源将负责为
    `Twoot` 分配下一个 `Position` 对象。我们将确保唯一和有序对象的责任委托给将具有创建此类序列的适当工具的数据层。
- en: Another alternative might have been to take a `Twoot` object that doesn’t have
    a `position` assigned to it and then have the `position` field set when it is
    added. Now one of the key goals of an object’s constructor should be to ensure
    that all the internal state is completely initialized, ideally checked with `final`
    fields. By not assigning the position at object creation time we would have created
    an object that wasn’t completely instantiated, breaking one of our principles
    around creating objects.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择可能是接受一个没有分配 `position` 的 `Twoot` 对象，然后在添加时设置 `position` 字段。现在，对象构造函数的一个关键目标应该是确保所有的内部状态都被完全初始化，理想情况下应该使用
    `final` 字段进行检查。通过在对象创建时不分配位置，我们将创建一个未完全实例化的对象，违反了我们围绕创建对象的原则之一。
- en: Some implementations of the Repository pattern introduce a generic interface—for
    example, something like [Example 7-3](#AbstractRepository). In our case this wouldn’t
    be appropriate as the `TwootRepository` doesn’t have an `update()` method and
    the `UserRepository` doesn’t have a `delete()` method. If you want to write code
    that abstracts over different repositories, then this might be useful. Trying
    to avoid forcing different implementations into the same interface for the sake
    of it is a key part of designing a good abstraction.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Repository 模式的一些实现引入了一个通用接口，例如，类似 [示例 7-3](#AbstractRepository) 的内容。在我们的情况下，这并不合适，因为
    `TwootRepository` 没有 `update()` 方法，而 `UserRepository` 没有 `delete()` 方法。如果你想编写能够抽象不同存储库的代码，那么这可能会很有用。为了设计一个良好的抽象，避免仅仅为了这个目的而强行将不同的实现合并到同一个接口中是很重要的。
- en: Example 7-3\. AbstractRepository
  id: totrans-43
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-3\. 抽象存储库
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Query Objects
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询对象
- en: Another key distinction between different repositories is how they support querying.
    In the case of Twootr our `UserRepository` doesn’t need any querying capability,
    but when it comes to `Twoot` objects we need to be able to look up the twoots
    to replay when a user logs on. What is the best way to implement this functionality?
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 不同存储库之间的另一个关键区别是它们如何支持查询。在 Twootr 的情况下，我们的 `UserRepository` 不需要任何查询功能，但是当涉及到
    `Twoot` 对象时，我们需要能够查找 twoots 以便在用户登录时重放它们。实现这个功能的最佳方式是什么？
- en: Well, there are several different choices that we could make here. The simplest
    is that we could simply try our repository like a pure `Java` `Collection` and
    have a way of iterating over the different `Twoot` objects. The logic to query/filter
    could then be written in normal Java code. This is lovely, but potentially quite
    slow as it requires us to retrieve all the rows from our data store into our Java
    application in order to do the querying, when in reality we may only want a few
    of them. Often data store backends such as SQL databases have highly optimized
    and efficient implementations of how to query and sort data, and it’s best to
    leave the querying to them.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，我们在这里可以做几种不同的选择。最简单的方法是，我们可以简单地将我们的存储库视为一个纯粹的 `Java` `Collection`，并且有一种方法可以迭代不同的
    `Twoot` 对象。然后，查询/过滤的逻辑可以以正常的 Java 代码编写。这很好，但是可能会相当慢，因为它要求我们从数据存储中检索所有行到我们的 Java
    应用程序中以便进行查询，而实际上我们可能只想要其中的一些行。通常，像 SQL 数据库这样的数据存储后端具有高度优化和高效的数据查询和排序实现，最好将查询交给它们来处理。
- en: Having decided that the repository implementation needs to have the responsibility
    for querying the data store we need to decide how best to expose this through
    the `TwootRepository` interface. One choice would have been to add a method that
    is tied to our business logic that performs the querying operation. For example,
    we could have written something like the `twootsForLogon()` method from [Example 7-4](#twootsForLogon)
    that takes the user object and looks up twoots associated with it. The downside
    of this is that we’ve now coupled the specific business logic functionality to
    our repository implementation—something that the introduction of our repository
    abstraction was designed to avoid. This will make it harder for us to evolve our
    implementation in line with requirements as we’ll have to modify the repository
    as well as the core domain logic and also breaches the Single Responsibility Principle.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 决定仓库实现需要负责查询数据存储后，我们需要决定如何最好地通过`TwootRepository`接口公开这一功能。一种选择是添加一个与我们的业务逻辑耦合的方法来执行查询操作。例如，我们可以从[示例 7-4](#twootsForLogon)编写像`twootsForLogon()`方法来获取与用户关联的twoots。这样做的缺点是，我们现在将特定的业务逻辑功能耦合到了我们的仓库实现中——这与引入仓库抽象的初衷相悖。这将使我们难以根据需求演化我们的实现，因为我们不得不修改仓库以及核心域逻辑，并且违反了单一职责原则。
- en: Example 7-4\. twootsForLogon
  id: totrans-49
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-4\. twootsForLogon
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: What we want to design is something that enables us to harness the power of
    a data store’s querying capability without tying the business logic to the data
    store in question. We could add a specific method to query the repository for
    a given business criteria, as shown by [Example 7-5](#twootsFromUsersAfterPosition).
    This approach is much better than the first two, but can still be refined a little
    bit. The problem with hardcoding each query to a given method is that as your
    application evolves over time and adds more querying functionality, we add more
    and more methods to the Repository interface, bloating it and making it harder
    to understand.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要设计的是一种能够利用数据存储的查询能力，而不将业务逻辑与所讨论的数据存储耦合在一起的东西。我们可以为给定的业务条件向仓库添加一个特定的查询方法，正如[示例 7-5](#twootsFromUsersAfterPosition)所示。这种方法比前两种方法要好得多，但仍然可以稍作调整。将每个查询硬编码到特定方法中的问题在于，随着应用程序随时间的推移演变并增加更多查询功能，我们将不得不添加越来越多的方法到Repository接口中，这会使其变得臃肿并且难以理解。
- en: Example 7-5\. twootsFromUsersAfterPosition
  id: totrans-52
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-5\. twootsFromUsersAfterPosition
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This brings us to the next querying iteration, shown in [Example 7-6](#queryWithList).
    Here we’ve abstracted out the criteria that we query our `TwootRepository` on
    into its own object. Now we can add additional properties to this criteria to
    query on without having the number of query methods be a combinatorial explosion
    of different properties to query about. The definition of our `TwootQuery` object
    is shown in [Example 7-7](#TwootQuery_definition).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这引导我们进入下一个查询迭代，显示在[示例 7-6](#queryWithList)中。在这里，我们将我们的`TwootRepository`查询条件抽象成了自己的对象。现在，我们可以添加额外的属性到这个条件中进行查询，而无需将查询方法的数量变成关于不同属性的组合爆炸。我们的`TwootQuery`对象的定义如[示例 7-7](#TwootQuery_definition)所示。
- en: Example 7-6\. query
  id: totrans-55
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-6\. query
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Example 7-7\. TwootQuery
  id: totrans-57
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-7\. TwootQuery
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This isn’t the final design approach taken for querying the twoots, though.
    By returning a `List` of objects it means that we need to load into memory all
    the `Twoot` objects that are going to be returned in one go. This isn’t a terribly
    good idea when this `List` may grow to be very large. We may not want to query
    all of the objects in one go either. That’s the case here—we want to push each
    of the `Twoot` objects out to our UI without needing to have them all in memory
    at one point in time. Some repository implementations create an object to model
    the set of results returned. These objects let you page or iterate through the
    values.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是查询twoots的最终设计方法。通过返回一个`List`对象，意味着我们需要一次性将要返回的所有`Twoot`对象加载到内存中。当这个`List`可能变得非常大时，这并不是一个好主意。我们也许不想一次性查询所有对象。在这种情况下——我们想要将每个`Twoot`对象推送到我们的UI中，而不需要一次性将它们全部保存在内存中。一些仓库实现会创建一个对象来模拟返回的结果集。这些对象让你可以分页或迭代访问这些值。
- en: 'In this case we’re going to do something simpler: just take a `Consumer<Twoot>`
    callback. That’s a function that the caller is going to pass in that takes a single
    argument—a `Twoot`—and returns void. We can implement this interface using either
    a lambda expression or a method reference. You can see our final approach in [Example 7-8](#finalQuery).'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-8\. query
  id: totrans-61
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: See [Example 7-9](#twoot_query_example) to see how you would use this query
    method. This is how our `onLogon()` method calls the query. It takes the user
    who has logged on, and uses the set of users that this user is following as the
    user part of the query. It then uses the last seen position for that part of the
    query. The callback that receives the results of this query is `user::receiveTwoot`,
    a method reference to the function that we described earlier that publishes the
    `Twoot` object to the UI `ReceiverEndPoint`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-9\. An example of using the query method
  id: totrans-64
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: That’s it—that’s our repository interface designed and usable in the core of
    the application logic.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: There is another feature that some repository implementations use that we haven’t
    described here, and that’s the *Unit of Work* pattern. We don’t use the Unit of
    Work pattern in Twootr, but it’s often used in conjunction with the Repository
    pattern so its worth mentioning it here. A common thing for line-of-business applications
    to do is to have a single operation that performs many interactions with the data
    store. For example, you might be transferring money between two bank accounts
    and want to remove money from one back account and add it to the other bank account
    in the same operation. You don’t want either of these operations to succeed without
    the other one succeeding—you don’t want to put money into the creditor’s account
    when there isn’t enough money in the debtor’s account. You also don’t want to
    reduce the debtor’s balance without ensuring that you can put money into the creditor
    account.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Databases often implement transactions and ACID compliance in order to enable
    people to perform these kinds of operations. A transaction is essentially a group
    of different database operations that are logically performed as a single, atomic
    operation. A Unit of Work is a design pattern that helps you perform database
    transactions. Essentially, each operation that you perform on your repository
    gets registered with a unit of work object. Your unit of work object can then
    delegate to one of more repositories, wrapping these operations in a transaction.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: One thing we haven’t talked about so far is how we actually implement the repository
    interfaces that we’ve designed. As with everything else in software development,
    there are often different routes we can go down. The Java ecosystem contains many
    Object-Relational Mappers (ORMs) that try to automate the task of this implementation
    for you. The most popular ORM is [Hibernate](http://hibernate.org/). ORMs tend
    to be a simple approach that can automate some of the work for you; however, they
    often end up producing sub-optimal database querying code and can sometimes introduce
    more complexity than they help remove.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止我们还没有讨论如何实际实现我们设计的存储库接口。就像软件开发中的其他事物一样，通常有不同的路线可选。Java 生态系统包含许多对象关系映射（ORM）工具，试图为您自动化这些实现任务。最流行的
    ORM 是 [Hibernate](http://hibernate.org/)。ORM 通常是一种简单的方法，可以为您自动化一些工作；然而，它们往往会产生不够优化的数据库查询代码，并且有时会引入更多复杂性，而不是帮助减少。
- en: In the example project we provide two implementations of each of the repositories.
    One of them is a very simple in-memory implementation suitable for testing that
    won’t persist the data over restarts. The other approach uses plain SQL and the
    JDBC API. We won’t go into much detail about the implementation as most of it
    doesn’t illustrate any particularly interesting Java programming ideas; however,
    in [“Functional Programming”](#ch06_Functional_Programming) we will talk about
    how we use some ideas from functional programming in the implementation.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例项目中，我们为每个存储库提供了两种实现方式。其中一种是非常简单的内存实现，适合用于测试，不会在重新启动时保留数据。另一种方法使用了普通的 SQL
    和 JDBC API。我们不会详细讨论实现细节，因为大部分并未展示出特别有趣的 Java 编程思想；然而，在[“函数式编程”](#ch06_Functional_Programming)章节中，我们将讨论如何在实现中应用一些函数式编程的思想。
- en: Functional Programming
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式编程
- en: Functional programming is a style of computer programming that treats methods
    as operating like mathematical functions. This means that it avoids mutable state
    and changing data. You can program in this style in any language, but some programming
    languages offer features to help make it easier and better—we call those *functional
    programming languages*. Java isn’t a functional programming language, but in version
    8, 20 years after it was first released, it started to add a number of features
    that helped make functional programming in Java a reality. Those features include
    lambda expressions, the Streams and Collectors API, and the `Optional` class.
    In this section we’ll talk a little bit about how those functional programming
    features can be used and how we use them in Twootr.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程是一种将方法视为数学函数运行的计算机编程风格。这意味着它避免了可变状态和数据改变。你可以在任何语言中以这种风格编程，但有些编程语言提供了功能来帮助简化和改进——我们称之为*函数式编程语言*。Java
    不是一种函数式编程语言，但在发布20年后的第8版中，它开始添加了一些功能，帮助实现了在 Java 中进行函数式编程。这些功能包括 lambda 表达式、Streams
    和 Collectors API，以及 `Optional` 类。在本节中，我们将简要介绍这些函数式编程特性的使用及在 Twootr 中的应用。
- en: 'There are limits to the level of abstractions that library writers could use
    in Java before Java 8\. A good example of this was the lack of efficient parallel
    operations over large collections of data. Java from 8 onward allows you to write
    complex collection-processing algorithms, and simply by changing a single method
    call you can efficiently execute this code on multicore CPUs. In order to enable
    writing of these kinds of bulk data parallel libraries, however, Java needed a
    new language change: lambda expressions.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 8 之前，库编写者在使用抽象级别上存在限制。一个很好的例子是缺乏对大型数据集进行有效并行操作的能力。从 Java 8 开始，你可以编写复杂的集合处理算法，通过改变一个方法调用，就能在多核
    CPU 上高效执行这些代码。然而，为了能够编写这类大数据并行库，Java 需要进行一次新的语言改变：lambda 表达式。
- en: Of course there’s a cost, in that you must learn to write and read lambda-enabled
    code, but it’s a good trade-off. It’s easier for programmers to learn a small
    amount of new syntax and a few new idioms than to have to handwrite a large quantity
    of complex thread-safe code. Good libraries and frameworks have significantly
    reduced the cost and time associated with developing enterprise business applications,
    and any barrier to developing easy-to-use and efficient libraries should be removed.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这也是有成本的，因为你必须学会编写和阅读支持 Lambda 的代码，但这是一个很好的权衡。程序员学习少量新语法和几种新习惯比手写大量复杂的线程安全代码要容易得多。优秀的库和框架显著降低了开发企业业务应用程序的成本和时间，应该消除开发易于使用和高效库的任何障碍。
- en: Abstraction is a concept that is familiar to anyone who does object-oriented
    programming. The difference is that object-oriented programming is mostly about
    abstracting over data, while functional programming is mostly about abstracting
    over behavior. The real world has both of these things, and so do our programs,
    so we can and should learn from both influences.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象是任何进行面向对象编程的人熟悉的概念。不同之处在于，面向对象编程主要是抽象化数据，而函数式编程主要是抽象化行为。现实世界有这两种东西，我们的程序也有，因此我们可以并且应该从两者的影响中学习。
- en: There are other benefits to this new abstraction as well. For many of us who
    aren’t writing performance-critical code all the time, these are more important
    wins. You can write easier-to-read code—code that spends time expressing the intent
    of its business logic rather than the mechanics of how it’s achieved. Easier-to-read
    code is also easier to maintain, more reliable, and less error-prone than code
    that is more difficult to read.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这种新抽象还有其他好处。对于我们中的许多人来说，不是一直编写性能关键代码，这些更重要的优势更胜一筹。您可以编写更易于阅读的代码——花时间表达其业务逻辑意图而不是其实现机制的代码。易于阅读的代码比难以阅读的代码更易于维护，更可靠，更少出错。
- en: Lambda Expressions
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Lambda 表达式
- en: 'We will define a lambda expression as a concise way of describing an anonymous
    function. We appreciate that’s quite a lot to take in at once, so we’re going
    to explain what lambda expressions are by working through an example of some existing
    Java code. Let’s start by taking a interface used to represent a callback in our
    codebase: `ReceiverEndPoint`, shown in [Example 7-10](#ReceiverEndPoint_definition_2).'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义一个 Lambda 表达式作为描述匿名函数的简洁方式。我们理解一次性掌握这么多内容可能有些困难，因此我们将通过实际的 Java 代码示例来解释
    Lambda 表达式是什么。让我们从我们代码库中用于表示回调的接口 `ReceiverEndPoint` 开始，如示例 [7-10](#ReceiverEndPoint_definition_2)
    所示。
- en: Example 7-10\. ReceiverEndPoint
  id: totrans-79
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 7-10\. ReceiverEndPoint
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this example, we’re creating a new object that provides an implementation
    of the `ReceiverEndPoint` interface. This interface has a single method, `onTwoot`,
    which is called by the Twootr object when it is sending a `Twoot` object to the
    UI adapter. The class listed in [Example 7-11](#PrintingEndPoint_definition) provides
    an implementation of this method. In this case to keep things simple we’re just
    printing it out on the command line rather than sending a serialized version to
    an actual UI.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们正在创建一个新对象，该对象提供了 `ReceiverEndPoint` 接口的实现。这个接口有一个方法 `onTwoot`，当 Twootr
    对象将一个 `Twoot` 对象发送到 UI 适配器时，将调用此方法。在 [Example 7-11](#PrintingEndPoint_definition)
    中列出的类提供了此方法的实现。在这种情况下，为了保持简单，我们只是在命令行上打印它，而不是将序列化版本发送到实际的 UI。
- en: Example 7-11\. Implementing ReceiverEndPoint with a class
  id: totrans-82
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 7-11\. 使用类实现 ReceiverEndPoint
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-84
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: This is actually an example of behavior parameterization—we’re parameterizing
    over the different behaviors to send a message to the UI.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是行为参数化的一个例子——我们正在对不同的行为进行参数化，以向 UI 发送消息。
- en: There are seven lines of boilerplate code required in order to call the single
    line of actual behavior here. Anonymous inner classes were designed to make it
    easier for Java programmers to represent and pass around behaviors. You can see
    an example in [Example 7-12](#PrintingEndPoint_anonymous_definition), which reduces
    the boilerplate a bit but they still don’t make it easy enough if you want to
    make passing behavior around really easy.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里调用实际行为的单行代码之前，需要七行样板代码。匿名内部类旨在使 Java 程序员更容易表示和传递行为。您可以在 [Example 7-12](#PrintingEndPoint_anonymous_definition)
    中看到一个例子，它减少了一些样板，但如果您希望轻松传递行为，它们仍然不足够简单。
- en: Example 7-12\. Implementing ReceiverEndPoint with an anonymous class
  id: totrans-87
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 7-12\. 使用匿名类实现 ReceiverEndPoint
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Boilerplate isn’t the only issue, though: this code is fairly hard to read
    because it obscures the programmer’s intent. We don’t want to pass in an object;
    what we really want to do is pass in some behavior. In Java 8 or later, we would
    write this code example as a lambda expression, as shown in [Example 7-13](#PrintingEndPoint_lambda_definition).'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Boilerplate 不是唯一的问题，这段代码很难阅读，因为它掩盖了程序员的意图。我们不想传递一个对象；我们真正想做的是传递一些行为。在 Java 8
    或更高版本中，我们会将这段代码示例写成一个lambda表达式，如示例 [7-13](#PrintingEndPoint_lambda_definition)
    所示。
- en: Example 7-13\. Implementing ReceiverEndPoint with a lambda expression
  id: totrans-90
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-13\. 使用lambda表达式实现ReceiverEndPoint
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Instead of passing in an object that implements an interface, we’re passing
    in a block of code—a function without a name. `twoot` is the name of a parameter,
    the same parameter as in the anonymous inner class example. `->` separates the
    parameter from the body of the lambda expression, which is just some code that
    is run when the twoot gets published.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是传递实现接口的对象，我们传递了一块代码——一个没有名字的函数。`twoot` 是参数的名称，与匿名内部类示例中的参数相同。`->` 分隔参数和lambda表达式的主体，它只是一些在发布
    `twoot` 时运行的代码。
- en: 'Another difference between this example and the anonymous inner class is how
    we declare the variable event. Previously, we needed to explicitly provide its
    type: `Twoot twoot`. In this example, we haven’t provided the type at all, yet
    this example still compiles. What is happening under the hood is that javac is
    inferring the type of the variable event from it’s context—here, from the signature
    of `onTwoot`. What this means is that you don’t need to explicitly write out the
    type when it’s obvious.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子和匿名内部类之间的另一个区别是如何声明变量 `event`。以前，我们需要显式地提供它的类型：`Twoot twoot`。在这个例子中，我们根本没有提供类型，但这个例子仍然可以编译。底层发生的事情是
    javac 从 `onTwoot` 的签名中推断出变量 `event` 的类型。这意味着当类型显而易见时，你不需要显式地写出类型。
- en: Note
  id: totrans-94
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Although lambda method parameters require less boilerplate code than was needed
    previously, they are still statically typed. For the sake of readability and familiarity,
    you have the option to include the type declarations, and sometimes the compiler
    just can’t work it out!
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管lambda方法参数比以前需要的样板代码少，它们仍然是静态类型的。为了可读性和熟悉性，你可以选择包含类型声明，有时编译器确实无法解析！
- en: Method References
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法引用
- en: A common idiom you may have noticed is the creation of a lambda expression that
    calls a method on its parameter. If we want a lambda expression that gets the
    content of a `Twoot`, we would write something like [Example 7-14](#method_references_eg_1).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到的一个常见习语是创建一个lambda表达式来调用其参数上的方法。如果我们想要一个lambda表达式来获取一个 `Twoot` 的内容，我们会写出类似
    [7-14](#method_references_eg_1) 的代码。
- en: Example 7-14\. Get the content of a twoot
  id: totrans-98
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-14\. 获取两推的内容
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This is such a common idiom that there’s actually an abbreviated syntax for
    this that lets you reuse an existing method, called a method reference. If we
    were to write the previous lambda expression using a method reference, it would
    look like [Example 7-15](#method_references_eg_2).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常常见的习惯用法，实际上有一种简写语法可以让你重用现有的方法，称为方法引用。如果我们要使用方法引用来编写前面的lambda表达式，它将类似于
    [7-15](#method_references_eg_2)。
- en: Example 7-15\. A method reference
  id: totrans-101
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-15\. 方法引用
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The standard form is `Classname::methodName`. Remember that even though it’s
    a method, you don’t need to use brackets because you’re not actually calling the
    method. You’re providing the equivalent of a lambda expression that can be called
    in order to call the method. You can use method references in the same places
    as lambda expressions.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 标准形式是 `类名::方法名`。请记住，尽管它是一个方法，但你不需要使用括号，因为你实际上没有调用这个方法。你提供的是一个lambda表达式的等价形式，可以在需要时调用方法。你可以在与lambda表达式相同的地方使用方法引用。
- en: You can also call constructors using the same abbreviated syntax. If you were
    to use a lambda expression to create a `SenderEndPoint`, you might write [Example 7-16](#method_references_eg_3).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用相同的简写语法调用构造函数。如果你要使用lambda表达式来创建一个 `SenderEndPoint`，你可能会写出 [7-16](#method_references_eg_3)。
- en: Example 7-16\. Lambda to create a new SenderEndPoint
  id: totrans-105
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-16\. 使用lambda创建一个新的SenderEndPoint
- en: '[PRE15]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You can also write this using method references, as shown in [Example 7-17](#method_references_eg_4).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用方法引用来写，如 [7-17](#method_references_eg_4) 所示。
- en: Example 7-17\. Method reference to create a new SenderEndPoint
  id: totrans-108
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-17\. 方法引用来创建一个新的SenderEndPoint
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This code is not only shorter, but also a lot easier to read. `SenderEndPoint::new`
    immediately tells you that you’re creating a new `SenderEndPoint` without your
    having to scan the whole line of code. Another thing to notice here is that method
    references automatically support multiple parameters, as long as you have the
    right functional interface.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码不仅更短，而且更易于阅读。`SenderEndPoint::new` 立即告诉您正在创建一个新的 `SenderEndPoint`，而无需扫描整行代码。另一个需要注意的地方是，方法引用自动支持多个参数，只要您有正确的函数接口。
- en: When we were first exploring the Java 8 changes, a friend of ours said that
    method references “feel like cheating.” What he meant was that, having looked
    at how we can use lambda expressions to pass code around as if it were data, it
    felt like cheating to be able to reference a method directly.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们首次探索 Java 8 的变化时，我们的一个朋友说过方法引用“感觉像是作弊”。他的意思是，通过研究我们如何使用 lambda 表达式将代码传递作为数据，直接引用方法感觉像是作弊。
- en: In fact, method references are really making the concept of first-class functions
    explicit. This is the idea that we can pass behavior around and treat it like
    another value. For example, we can compose functions together.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，方法引用确实使一等函数的概念显式化。这意味着我们可以传递行为并像处理另一个值一样对待它。例如，我们可以将函数组合在一起。
- en: Execute Around
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行周围
- en: 'The *Execute Around* pattern is a common functional design pattern. You may
    encounter a situation where you have common initialization and cleanup code that
    you always want to do, but parameterize different business logic that runs within
    the initialization and cleanup code. An example of the general pattern is shown
    in [Figure 7-1](#ch06_execute_around_img). There are a number of example situations
    in which you can use execute around, for example:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '*执行周围*模式是一种常见的函数设计模式。您可能会遇到这样的情况，即您有共同的初始化和清理代码，但需要对初始化和清理代码之间运行的不同业务逻辑进行参数化。通用模式示例如
    [图 7-1](#ch06_execute_around_img) 所示。有许多可以使用执行周围的示例情况，例如：'
- en: Files
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 文件
- en: Open a file before you use it, and close it when you’ve finished using the file.
    You may also want to log an exception when something goes wrong. The parameterized
    code can read from or write to the file.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用文件之前打开文件，在使用完文件后关闭文件。如果出现问题，您可能还希望记录异常。参数化代码可以从文件中读取或写入数据。
- en: Locks
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 锁
- en: Acquire a lock before your critical section, release the lock after your critical
    section. The parameterized code is the critical section.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在关键部分之前获取锁，在关键部分之后释放锁。参数化代码是关键部分。
- en: Database connections
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库连接
- en: Open a connection to a database upon initialization, close it when finished.
    This is often even more useful if you pool your database connections as it also
    allows your open logic to also retrieve the connection from your pool.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化时打开数据库连接，在完成后关闭连接。如果您还希望池化数据库连接，这通常会更加有用，因为它还允许您的打开逻辑从池中检索连接。
- en: '![Execute Around pattern](Images/rwsd_0701.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![执行周围模式](Images/rwsd_0701.png)'
- en: Figure 7-1\. Execute Around pattern
  id: totrans-122
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-1\. 执行周围模式
- en: Because the initialization and cleanup logic is being used in many places, it
    is possible to get into a situation where this logic is duplicated. This means
    that if you want to modify this common initialization or cleanup code, then you
    will have to modify multiple different parts of your application. It also exposes
    the risk that these different code snippets could become inconsistent, introducing
    potential bugs into your application.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 由于初始化和清理逻辑在许多地方都在使用，可能会遇到这样的情况，即此逻辑被复制。这意味着如果您想修改这些通用初始化或清理代码，那么您将不得不修改应用程序的多个不同部分。这也暴露了这些不同代码片段可能变得不一致的风险，从而在您的应用程序中引入潜在的错误。
- en: The Execute Around pattern solves this problem by extracting a common method
    that defines both the initialization and cleanup code. This method takes a parameter
    containing the behavior that differs between use cases of the same overall pattern.
    The parameter will use an interface to enable it to be implemented by different
    blocks of code, usually using lambda expressions.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 执行周围模式通过提取一个通用方法来解决这个问题，该方法定义了初始化和清理代码。此方法接受一个参数，其中包含了在同一整体模式的不同用例中行为差异的定义。该参数将使用接口来实现，以便能够由不同的代码块实现，通常使用
    lambda 表达式。
- en: '[Example 7-18](#extract_definition) shows a concrete example of an `extract`
    method. This is used within Twootr in order to run SQL statements against the
    database. It creates a prepared statement object for a given SQL statement and
    and then runs our `extractor` behavior on the statement. The `extractor` is just
    a callback that extracts a result, i.e., reads some data from the database, using
    the `PreparedStatement`.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 7-18](#extract_definition) 展示了提取方法的具体示例。在 Twootr 中，此方法用于对数据库运行 SQL 语句。它创建一个给定
    SQL 语句的预处理语句对象，然后运行我们的 `extractor` 行为于该语句上。`extractor` 只是一个回调函数，用于从数据库中提取结果，使用
    `PreparedStatement`。'
- en: Example 7-18\. Use of the Execute Around pattern in the extract method
  id: totrans-126
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-18\. 在提取方法中使用执行环绕模式
- en: '[PRE17]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Streams
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Streams
- en: The most important functional programming features in Java are focused around
    the Collections API and *Streams*. Streams allow us to write collections-processing
    code at a higher level of abstraction than we would be able to do with loops.
    The `Stream` interface contains a series of functions that we’ll explore throughout
    this chapter, each of which corresponds to a common operation that you might perform
    on a `Collection`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Java 中最重要的函数式编程特性集中在 Collections API 和 *Streams* 上。Streams 允许我们以比使用循环更高的抽象级别编写集合处理代码。`Stream`
    接口包含一系列函数，我们将在本章中探索这些函数，每个函数对应于在 `Collection` 上执行的常见操作。
- en: map()
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: map()
- en: If you’ve got a function that converts a value of one type into another, `map()`
    lets you apply this function to a stream of values, producing another stream of
    the new values.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个将一个类型的值转换为另一个类型的值的函数，`map()` 允许你将此函数应用于值的流，生成另一个新值的流。
- en: You may very well have been doing some kind of map operations for years already
    with for loops. In our `DatabaseTwootRepository` we’ve built up a tuple to be
    used in a query `String` containing all the `id` values of the different users
    whom a user is following. Each `id` value is a quoted `String` and the whole tuple
    is surrounded by brackets. For example, if they followed users with IDs `"richardwarburto"`
    and `"raoulUK"` we would produce a tuple `String` of `"(*richardwarburto*,*raoulOK*)"`.
    In order to generate this tuple you would use a mapping pattern, transforming
    each `id` into `"*id*"` and then adding them into a `List`. The `String.join()`
    method can then be used to join them with commas between. [Example 7-19](#map_example_1)
    is code written in this style.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经多年使用 for 循环进行某种类型的映射操作了。在我们的 `DatabaseTwootRepository` 中，我们已经构建了一个用于查询的元组
    `String`，包含用户关注的所有不同用户的 `id` 值。每个 `id` 值都是一个带引号的 `String`，而整个元组则用括号括起来。例如，如果他们关注的用户有
    `"richardwarburto"` 和 `"raoulUK"` 的 ID，我们将生成一个元组 `String`，内容为 `"(*richardwarburto*,*raoulOK*)"`。为了生成这个元组，你可以使用映射模式，将每个
    `id` 转换为 `"*id*"`，然后将它们添加到一个 `List` 中。然后可以使用 `String.join()` 方法以逗号分隔它们。[示例 7-19](#map_example_1)
    就是以这种风格编写的代码。
- en: Example 7-19\. Building a user tuple with a for loop
  id: totrans-133
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-19\. 使用 for 循环构建用户元组
- en: '[PRE18]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`map()` is one of the most commonly used `Stream` operations. [Example 7-20](#map_example_2)
    is the same example of building up the user tuple but using `map()`. It also takes
    advantage of the `joining()` collector, which allows us to join the elements in
    the `Stream` together into a `String`.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`map()` 是最常用的 `Stream` 操作之一。[示例 7-20](#map_example_2) 展示了构建用户元组的同样示例，但使用了 `map()`。它还利用了
    `joining()` 收集器，允许我们将 `Stream` 中的元素连接成一个 `String`。'
- en: Example 7-20\. Building a user tuple using map
  id: totrans-136
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-20\. 使用 map 构建用户元组
- en: '[PRE19]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The lambda expression passed into `map()` both takes a `String` as its only
    argument and returns a `String`. It isn’t necessary for both the argument and
    the result to be the same type, but the lambda expression passed in must be an
    instance of `Function`. This is a generic functional interface with only one argument.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给 `map()` 的 lambda 表达式接受一个 `String` 作为其唯一参数，并返回一个 `String`。参数和结果不必是相同类型，但传递的
    lambda 表达式必须是 `Function` 的实例。这是一个只有一个参数的通用函数接口。
- en: forEach()
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: forEach()
- en: The `forEach()` operation is useful when you want to perform a side effect for
    each value in the `Stream`. For example, suppose you want to print out the name
    of a user or save each transaction in your stream to a database. `forEach()` takes
    a single argument—a `Consumer` callback executed that gets invoked with every
    element in the stream as an argument.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想要对 `Stream` 中的每个值执行副作用时，`forEach()` 操作很有用。例如，假设你想打印用户的名称或将流中的每个事务保存到数据库中。`forEach()`
    接受一个参数 —— 一个 `Consumer` 回调函数，它会在流中的每个元素上执行。
- en: filter()
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: filter()
- en: Any time you’re looping over some data and checking each element with an if
    statement, you might want to think about using the `Stream.filter()` method.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 每当您循环一些数据并使用 if 语句检查每个元素时，您可能想考虑使用`Stream.filter()`方法。
- en: For example, the `InMemoryTwootRepository` needs to query the different `Twoot`
    objects in order to find twoots that meet its `TwootQuery`. Specifically, that
    the position is after the last seen position and that user is being followed.
    An example of this being written in for loop style is shown in [Example 7-21](#filter_example_1).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`InMemoryTwootRepository` 需要查询不同的 `Twoot` 对象以找到符合其 `TwootQuery` 的 twoots。具体来说，位置在上次查看的位置之后，且用户正在被关注。这种写法的示例在
    [Example 7-21](#filter_example_1) 中显示为循环样式。
- en: Example 7-21\. Looping over twoots and using an if statement
  id: totrans-144
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-21\. 遍历 twoots 并使用 if 语句
- en: '[PRE20]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You have probably written some code that looks like this: it’s called the `filter`
    pattern. The central idea of filter is to retain some elements of the `Stream`,
    while throwing others out. [Example 7-22](#filter_example_2) shows how you would
    write the same code in a functional style.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能编写过类似于这样的代码：它被称为`filter`模式。过滤器的中心思想是保留`Stream`的一些元素，同时淘汰其他元素。 [Example 7-22](#filter_example_2)
    展示了如何以函数式风格编写相同的代码。
- en: Example 7-22\. Functional style
  id: totrans-147
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-22\. 函数式风格
- en: '[PRE21]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Much like `map()`, `filter()` is a method that takes just a single function
    as an argument—here we’re using a lambda expression. This function does the same
    job that the expression in the if statement did earlier. Here, it returns `true`
    if the `String` starts with a digit. If you’re refactoring legacy code, the presence
    of an if statement in the middle of a for loop is a pretty strong indicator that
    you really want to use filter. Because this function is doing the same job as
    the if statement, it must return either `true` or `false` for a given value. The
    `Stream` after the `filter` has the elements of the `Stream` beforehand, which
    evaluated to `true`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 与`map()`类似，`filter()`是一个只接受一个函数作为参数的方法——在这里我们使用了 lambda 表达式。这个函数做的工作与前面的 if
    语句中的表达式相同。在这里，如果`String`以数字开头，则返回`true`。如果您正在重构遗留代码，则在循环中间存在 if 语句的存在很可能表明您确实想要使用
    filter。因为这个函数正在执行与 if 语句相同的工作，所以它必须为给定的值返回`true`或`false`。`filter`后面的`Stream`具有前面`Stream`的元素，这些元素在`filter`之前被求值为`true`。
- en: reduce()
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: reduce()
- en: '`reduce` is a pattern that will also be familiar to anyone who has used loops
    to operate on collections. It’s the kind of code that you write when you want
    to collapse down an entire list of values into a single value—for example, finding
    the sum of all the values of different transactions. The general pattern that
    you would see with reduction when writing a loop is shown in [Example 7-23](#reduce_example_1).
    Use the `reduce` operation when you’ve got a collection of values and you want
    to generate a single result.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`reduce` 是一种模式，对于使用循环操作集合的人来说也很熟悉。当你想要将整个值列表折叠成单个值时，就会写出这样的代码——例如，找到不同交易的所有值的总和。编写循环时，您将看到减少的一般模式显示在
    [Example 7-23](#reduce_example_1) 中。当您有一组值并且想要生成单个结果时，请使用`reduce`操作。'
- en: Example 7-23\. The reduce pattern
  id: totrans-152
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-23\. 减少模式
- en: '[PRE22]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: An `accumulator` gets pushed through the body of the loop, with the final value
    of the `accumulator` being the value that we were trying to compute. The `accumulator`
    starts with an `initialValue` and then gets combined together with each element
    of the list by calling the `combine` operation.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`accumulator`通过循环体被推送，`accumulator`的最终值是我们试图计算的值。`accumulator`从`initialValue`开始，然后通过调用`combine`操作将列表的每个元素组合在一起。
- en: The things that differ between implementations of this pattern are the `initialValue`
    and the combining function. In the original example, we used the first element
    in the list as our `initialValue`, but it doesn’t have to be. In order to find
    the shortest value in a list, our combine would return the shorter track of out
    of the current element and the `accumulator`. We’ll now take a look at how this
    general pattern can be codified by an operation in the Streams API itself.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式的实现之间的差异在于`initialValue`和组合函数。在原始示例中，我们使用列表中的第一个元素作为我们的`initialValue`，但不一定非要这样。为了在列表中找到最短的值，我们的组合将返回当前元素和`accumulator`中的较短跟踪的较短值。我们现在将看看如何通过流
    API 本身的操作来将这种一般模式编码化。
- en: Let’s demonstrate the reduce operation by adding a feature that combines together
    different twoots into one large twoot. The operation will have a list of `Twoot`
    objects, the sender of the `Twoot`, and its `id` provided as arguments. It will
    need to combine together the different content value and return the highest position
    of the twoots being combined. The overall code is demonstrated in [Example 7-24](#reduce_example_2).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过添加一个功能来展示`reduce`操作，该功能将不同的两推组合成一个大的两推。操作将具有`Twoot`对象列表、`Twoot`的发送者以及其`id`作为参数。它需要将不同的内容值组合在一起，并返回组合两推的最高位置。整体代码在[示例 7-24](#reduce_example_2)中展示。
- en: We start with a new `Twoot` object created using the `id`, `senderId` with empty
    content and the lowest possible position—the `INITIAL_POSITION`. The reduce then
    folds together each element with an `accumulator`, combining the element to the
    `accumulator` at every step. When we reach the final `Stream` element, our `accumulator`
    has the sum of all the elements.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个新创建的`Twoot`对象开始，使用`id`、空内容和最低可能的位置——`INITIAL_POSITION`。然后`reduce`将每个元素与累加器结合在一起，在每一步都将元素与累加器组合。当我们到达最后的`Stream`元素时，我们的累加器包含了所有元素的总和。
- en: The lambda expression, known as a reducer, performs the combining and takes
    two arguments. `acc` is the `accumulator` and holds the previous twoots that have
    been combined. It is also passed in the current `Twoot` in the `Stream`. The reducer
    in our example creates a new `Twoot`, with the max of the two positions, the concatenation
    of their content, and the specified `id` and `senderId`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: lambda表达式，即reducer，执行组合并接受两个参数。`acc`是累加器，保存了已组合的先前两推。同时在`Stream`中传递当前的`Twoot`。我们的示例中的reducer创建了一个新的`Twoot`，其中包含两个位置的最大值、它们内容的连接，以及指定的`id`和`senderId`。
- en: Example 7-24\. Implementing sum using reduce
  id: totrans-159
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-24\. 使用reduce实现求和
- en: '[PRE23]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Of course these `Stream` operations aren’t that interesting on their own. They
    become really powerful when you combine them together to form a pipeline. [Example 7-25](#stream_onSendTwoot_definition)
    shows some code from `Twootr.onSendTwoot()` where we send twoots to the followers
    of a user. The first step is to call the `followers()` method, which returns a
    `Stream<User>`. We then use the `filter` operation to find the users who are actually
    logged in who we want to send the twoot to. Then we use the `forEach` operation
    to produce the desired side effect: sending a twoot to a user and recording the
    result.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这些`Stream`操作单独来看并不那么有趣。它们在组合在一起形成管道时变得非常强大。[示例 7-25](#stream_onSendTwoot_definition)展示了从`Twootr.onSendTwoot()`中的一些代码，我们在这里向用户的关注者发送了两推。第一步是调用`followers()`方法，该方法返回一个`Stream<User>`。然后我们使用`filter`操作找到实际登录的用户，这些用户我们想要发送两推给他们。接着我们使用`forEach`操作产生期望的副作用：向用户发送一条两推并记录结果。
- en: Example 7-25\. Use of Stream within the onSendTwoot method
  id: totrans-162
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-25\. 在onSendTwoot方法中使用Stream
- en: '[PRE24]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Optional
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可选
- en: '`Optional` is a core Java library data type, introduced in Java 8, that is
    designed to provide a better alternative to `null`. There’s quite a lot of hatred
    for the old null value. Even the man who invented the concept, Tony Hoare, described
    it as [“my billion-dollar mistake”](https://oreil.ly/OaXWj). That’s the trouble
    with being an influential computer scientist—you can make a billion-dollar mistake
    without even seeing the billion dollars yourself!'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`Optional`是Java 8引入的核心Java库数据类型，旨在提供比`null`更好的替代方案。对于旧的null值存在相当多的厌恶情绪。即使是发明这个概念的人，Tony
    Hoare，也将其描述为[“我的十亿美元错误”](https://oreil.ly/OaXWj)。这就是作为一名有影响力的计算机科学家的麻烦之处——你甚至可能在看不到十亿美元的情况下犯下十亿美元的错误！'
- en: '`null` is often used to represent the absence of a value, and this is the use
    case that `Optional` is replacing. The problem with using `null` in order to represent
    absence is the dreaded `NullPointerException`. If you refer to a variable that
    is `null`, your code blows up. The goal of `Optional` is twofold. First, it encourages
    the coder to make ap‐ propriate checks as to whether a variable is absent in order
    to avoid bugs. Second, it documents values that are expected to be absent in a
    class’s API. This makes it easier to see where the bodies are buried.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`null`通常用来表示值的缺失，而`Optional`则是用来替代这种用法。使用`null`表示缺失值的问题在于可怕的`NullPointerException`。如果引用一个为`null`的变量，你的代码就会崩溃。`Optional`的目标是双重的。首先，它鼓励程序员适当地检查变量是否缺失，以避免错误。其次，它在类的API中文档化了预期缺失的值。这使得更容易看到哪些值是被隐藏的。'
- en: Let’s take a look at the API for `Optional` in order to get a feel for how to
    use it. If you want to create an `Optional` instance from a value, there is a
    factory method called `of()`. The `Optional` is now a container for this value,
    which can be pulled out with `get`, as shown in [Example 7-26](#optional_example_1).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下`Optional`的API，以便了解如何使用它。 如果你想从一个值创建一个`Optional`实例，有一个名为`of()`的工厂方法。 现在，`Optional`是这个值的一个容器，可以用`get`来取出，如[Example 7-26](#optional_example_1)所示。
- en: Example 7-26\. Creating an Optional from a value
  id: totrans-168
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 7-26\. 从一个值创建一个Optional
- en: '[PRE25]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Because an `Optional` may also represent an absent value, there’s also a factory
    method called `empty()`, and you can convert a nullable value into an `Optional`
    using the `ofNullable()` method. You can see both of these methods in [Example 7-27](#optional_example_2),
    along with the use of the `isPresent()` method, which indicates whether the `Optional`
    is holding a value.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`Optional`也可以表示一个不存在的值，所以还有一个名为`empty()`的工厂方法，你可以使用`ofNullable()`方法将可空值转换为`Optional`。
    你可以在[Example 7-27](#optional_example_2)中看到这两种方法，以及`isPresent()`方法的使用，它指示`Optional`是否持有一个值。
- en: Example 7-27\. Creating an empty Optional and checking whether it contains a
    value
  id: totrans-171
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 7-27\. 创建一个空的Optional并检查它是否包含一个值
- en: '[PRE26]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: One approach to using `Optional` is to guard any call to `get()` by checking
    `isPresent()`—this is needed because a call to `get()` can throw a `NoSuchElementException`.
    Unfortunately, this approach isn’t a very good coding pattern for using `Optional`.
    If you use it this way, all you’ve really done is to replicate the existing patterns
    for using `null`—where you would check if a value isn’t `null` as a guard.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Optional`的一种方法是在调用`get()`之前通过检查`isPresent()`来保护任何调用 —— 这是必需的，因为调用`get()`可能会抛出一个`NoSuchElementException`。
    不幸的是，这种方法并不是一个很好的使用`Optional`的编码模式。 如果你以这种方式使用它，你实际上只是复制了使用`null`的现有模式 —— 在这种模式中，你会检查一个值是否不是`null`作为守卫。
- en: A neater approach is to call the `orElse()` method, which provides an alternative
    value in case the `Optional` is empty. If creating an alternative value is computationally
    expensive, the `orElseGet()` method should be used. This allows you to pass in
    a `Supplier` function that is called only if the `Optional` is genuinely empty.
    Both of these methods are demonstrated in [Example 7-28](#optional_example_3).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更简洁的方法是调用`orElse()`方法，它提供了一个替代值，以防`Optional`为空。 如果创建替代值的计算成本很高，应该使用`orElseGet()`方法。
    这允许您传入一个`Supplier`函数，只有在`Optional`真正为空时才调用该函数。 这两种方法都在[Example 7-28](#optional_example_3)中演示。
- en: Example 7-28\. Using orElse() and orElseGet()
  id: totrans-175
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 7-28\. 使用orElse()和orElseGet()
- en: '[PRE27]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`Optional` also has a series of methods defined that can be used like the `Stream`
    API; for example, `filter()`, `map()`, and `ifPresent()`. You can think of these
    methods applying to the `Optional` API similarly to the `Stream` API, but in this
    case your `Stream` can only contain 1 or 0 elements. So `Optional.filter()` will
    retain an element in the `Optional` if it meets the criteria and return an empty
    `Optional` if the `Optional` was previously empty or if the predicate fails to
    apply. Similarly, `map()` transforms the value inside the `Optional`, but if it’s
    empty it doesn’t apply the function at all. That’s what makes these functions
    safer than using `null`—they only operate on the `Optional` if there’s really
    something inside of it. `ifPresent` is the `Optional` dual of `forEach`—it applies
    a `Consumer` callback if there’s a value there, but not otherwise.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`Optional`还定义了一系列可以像`Stream`API一样使用的方法；例如，`filter()`，`map()`和`ifPresent()`。
    您可以将这些方法想象为类似于`Stream`API的`Optional`API，但在这种情况下，您的`Stream`只能包含1个或0个元素。 因此，如果满足条件，`Optional.filter()`将在`Optional`中保留一个元素，并且如果`Optional`之前为空或谓词未能应用，则返回一个空的`Optional`。
    同样，`map()`转换`Optional`中的值，但如果它为空，则根本不应用该函数。 这就是这些函数比使用`null`更安全的地方 —— 它们仅在`Optional`中确实有内容时才操作`Optional`。
    `ifPresent`是`forEach`的`Optional`对偶 —— 如果有值存在，它将应用`Consumer`回调，但否则不会。'
- en: You can see an extract of the code from the `Twootr.onLogon()` method in [Example 7-29](#optional_onLogon_definition).
    This is an example of how we can put together these different operations to perform
    a more complex operation. We start off by looking up the `User` from their ID
    by calling `UserRepository.get()`, which returns an `Optional`. We then validate
    the user’s password matchers using `filter`. We use `ifPresent` to notify the
    `User` of the twoots that they’ve missed. Finally, we `map` the `User` object
    into a new `SenderEndPoint` that is returned from the method.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 [Example 7-29](#optional_onLogon_definition) 中看到来自 `Twootr.onLogon()` 方法的代码片段。这是一个示例，展示了如何组合这些不同的操作以执行更复杂的操作。我们首先通过调用
    `UserRepository.get()` 根据用户ID查找 `User`，该方法返回一个 `Optional`。然后我们使用 `filter` 验证用户的密码匹配。我们使用
    `ifPresent` 通知用户他们错过的 twoots。最后，我们将 `User` 对象映射为一个新的 `SenderEndPoint` 并从方法中返回。
- en: Example 7-29\. Use of Optional within the onLogon method
  id: totrans-179
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 7-29\. 在 onLogon 方法中使用 Optional
- en: '[PRE28]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In this section we’ve really only scratched the surface of functional programming.
    If you are interested in learning about functional programming in greater depth,
    we recommend [*Java 8 In Action*](https://oreil.ly/wGImJ) and [*Java 8 Lambdas*](https://oreil.ly/hDrfH).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们只是浅尝辄止了函数式编程的表面。如果你有兴趣深入学习函数式编程，我们推荐阅读[*Java 8 In Action*](https://oreil.ly/wGImJ)
    和 [*Java 8 Lambdas*](https://oreil.ly/hDrfH)。
- en: User Interface
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户界面
- en: Throughout this chapter we’ve avoided talking too much about the user interface
    to this system, because we’re focused on the design of the core problem domain.
    That said, it’s worth delving a little into what the example project delivers
    as part of its UI just in order to understand how the event modeling fits together.
    In our example project we ship a single-page website that uses JavaScript to implement
    its dynamic functionality. In order to keep things simple and not delve too much
    into the myriad framework wars, we’ve just used `jquery` to update the raw HTML
    page, but kept a simple separation of concerns in the code.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们避免过多讨论系统的用户界面，因为我们专注于核心问题域的设计。尽管如此，了解示例项目作为其 UI 的一部分提供了什么，有助于理解事件建模如何组合在一起。在我们的示例项目中，我们提供了一个单页面网站，使用
    JavaScript 实现其动态功能。为了保持简单，并且不深入探讨各种框架之争，我们只是使用 `jquery` 来更新原始 HTML 页面，并在代码中保持了简单的关注点分离。
- en: When you browse to the Twootr web page it connects back to the host using WebSockets.
    These were one of the event communication choices discussed back in [“From Events
    to Design”](ch06.xhtml#events_to_design). All the code for communicating with
    it lies in the `web_adapter` subpackage of `chapter_06`. The `WebSocketEndPoint`
    class implements the `ReceiverEndPoint` and also invokes any needed methods on
    the `SenderEndPoint`. For example, when the `ReceiverEndPoint` receives and parses
    a message to follow another user it invokes the `SenderEndPoint.onFollow()`, passing
    the username through. The returned `enum`—`FollowStatus` then gets converted into
    a wire format response and written down the WebSocket connection.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当您浏览到 Twootr 网页时，它会使用 WebSockets 连接回主机。这些是我们在 [“From Events to Design”](ch06.xhtml#events_to_design)
    中讨论的事件通信选择之一。所有与其通信的代码都位于 `chapter_06` 的 `web_adapter` 子包中。`WebSocketEndPoint`
    类实现了 `ReceiverEndPoint`，并在 `SenderEndPoint` 上调用任何需要的方法。例如，当 `ReceiverEndPoint`
    接收并解析要关注另一个用户的消息时，它调用 `SenderEndPoint.onFollow()`，通过用户名传递。返回的 `enum`—`FollowStatus`
    然后被转换为一种线格式的响应并写入 WebSocket 连接。
- en: All communication between the JavaScript frontend and the server is done using
    the [*JavaScript Object Notation* (JSON) standard](http://www.json.org/). JSON
    was chosen as it’s very easy for a JavaScript UI to deserialize or serialize.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 前端与服务器之间的所有通信都使用 [*JavaScript Object Notation* (JSON) standard](http://www.json.org/)。选择
    JSON 是因为 JavaScript UI 非常容易对其进行反序列化或序列化。
- en: Within the `WebSocketEndPoint` we need to map to and from JSON within Java code.
    There are many libraries that can be used for this purpose, here we’ve chosen
    the [Jackson library](https://github.com/FasterXML/jackson), which is commonly
    used and well maintained. JSON is often used in applications that take a request/response
    approach rather than an event-driven approach as well. In our case we manually
    extract the fields from the JSON object to keep things simple, but its also possible
    to use a higher-level JSON API, such as a binding API.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `WebSocketEndPoint` 内部，我们需要在 Java 代码中进行 JSON 的映射。有许多库可以用于此目的，这里我们选择了 [Jackson
    库](https://github.com/FasterXML/jackson)，这是一种常用且维护良好的库。JSON 在采用请求/响应方式而不是事件驱动方式的应用程序中经常被使用。在我们的情况下，我们手动从
    JSON 对象中提取字段，以保持简单性，但也可以使用更高级的 JSON API，如绑定 API。
- en: Dependency Inversion and Dependency Injection
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖反转和依赖注入
- en: 'We’ve talked a lot about decoupling patterns in this chapter. Our overall application
    uses the Ports and Adapters pattern and the Repository pattern to decouple business
    logic away from implementation details. There is in fact a large, unifying principle
    that we can think of when we see these patterns—*Dependency Inversion*. The Dependency
    Inversion Principle is the final of our five SOLID patterns that we’ve talked
    about in this book, and like the others was introduced by Robert Martin. It states
    that:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中我们讨论了很多关于解耦模式的内容。我们的整体应用程序使用了端口和适配器模式以及仓储模式，将业务逻辑与实现细节分离开来。事实上，当我们看到这些模式时，我们可以想到一个大的、统一的原则——*依赖反转*。依赖反转原则是我们在这本书中讨论的五个
    SOLID 原则中的最后一个，像其他原则一样，它也是由 Robert Martin 引入的。它指出：
- en: High-level modules should not depend upon low-level modules. Both should depend
    upon abstractions.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级模块不应依赖于低级模块。两者都应依赖于抽象。
- en: Abstractions should not depend upon details. Details should depend upon abstractions.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象不应依赖于细节，细节应依赖于抽象。
- en: The principle is called an inversion because in traditional imperative, structured
    programming it is often the case that high-level modules compose down to produce
    low-level modules. It’s often a side effect of the top-down design that we talked
    about in this chapter. You split up a big problem into different subproblems,
    write a module to solve each of those subproblems, and then the main problem (the
    high-level module) depends on the subproblems (the low-level modules).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这个原则之所以称为反转，是因为在传统的命令式、结构化编程中，高级模块通常组合以生成低级模块。这往往是我们在本章讨论的自顶向下设计的一个副作用。你将一个大问题分解成不同的子问题，为每个子问题编写一个模块来解决，然后主问题（高级模块）依赖于子问题（低级模块）。
- en: In the design of Twootr we’ve avoided this problem through the introduction
    of abstractions. We have a high-level entry point class, called `Twootr`, and
    it doesn’t depend upon the low-level modules such as our `DataUserRepository`.
    It depends upon the abstraction—the `UserRepository` interface. We perform the
    same inversion at the UI port. `Twootr` doesn’t depend upon the `WebSocketEndPoint`—it
    depends upon the `ReceiverEndPoint`. We program to the interface, not the implementation.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Twootr 的设计中，我们通过引入抽象来避免了这个问题。我们有一个高级入口点类，名为 `Twootr`，它不依赖于低级模块，比如我们的 `DataUserRepository`。它依赖于抽象——`UserRepository`
    接口。在 UI 端口上也是如此。`Twootr` 不依赖于 `WebSocketEndPoint`，而是依赖于 `ReceiverEndPoint`。我们编程时依赖接口，而不是具体实现。
- en: A related term is the concept of *Dependency Injection*, or *DI*. To understand
    what DI is and why we need it, let’s undertake a thought experiment on our design.
    Our architecture has determined that the main `Twootr` class needs to depend upon
    the `UserRepository` and `TwootRepository` in order to store `User` and `Twoot`
    objects. We have defined fields inside `Twootr` to store instances of these objects,
    as shown in [Example 7-30](#Twootr_fields_definition). The question is, how do
    we instantiate them?
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 一个相关的术语是*依赖注入*，或者简称*DI*。为了理解 DI 是什么以及为什么我们需要它，让我们对我们的设计进行一个思想实验。我们的架构已经确定，主要的
    `Twootr` 类需要依赖于 `UserRepository` 和 `TwootRepository` 来存储 `User` 和 `Twoot` 对象。我们在
    `Twootr` 内部定义了字段来存储这些对象的实例，如 [Example 7-30](#Twootr_fields_definition) 所示。问题是，我们如何实例化它们？
- en: Example 7-30\. Dependencies within the Twootr class
  id: totrans-194
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-30\. Twootr 类内的依赖项
- en: '[PRE29]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The first strategy that we could use for populating the fields is to try and
    call constructors using the `new` keyword, as shown in [Example 7-31](#hardcoded_fields).
    Here we’ve hardcoded the use of the database-based repositories into the codebase.
    Now most of the code in the class still programs to the interface, so we could
    change the implementation here quite easily without having to replace all our
    code, but it’s a bit of a hack. We have to always use the database repositories,
    which means our tests for the `Twootr` class depend upon the database and run
    more slowly.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Not only that, but if we want to ship different versions of Twootr to different
    customers—for example, an in-house Twootr for enterprise customers that uses SQL
    and a cloud-based version that uses a NoSQL backend—we would have to cut the builds
    from two different versions of the codebase. It’s not enough to just define interfaces
    and separate implementation—we also have to have a way of wiring up the right
    implementation in a way that doesn’t break our abstraction and decoupling approach.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-31\. Hardcoding the field instantiation
  id: totrans-198
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: A commonly used design pattern for instantiating different dependencies is the
    Abstract Factory Design pattern. [Example 7-32](#factory_instantiation) demonstrates
    this pattern, where we have a factory method that we can use to create an instance
    of our interface using the `getInstance()` method. When we want to set up the
    right implementations to use, we can call a `setInstance()`. So, for example,
    we could use `setInstance()` in tests to create an in-memory implementation, in
    an on-premise installation to use a SQL database, or in our cloud environment
    to use a NoSQL database. We’ve decoupled the implementation from the interface
    and can call this wiring code wherever we want.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-32\. Creating the instances with factories
  id: totrans-201
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Unfortunately this factory method approach has its downsides as well. For a
    start, we’ve now created a big ball of shared mutable state. Any situation where
    we want to run a single JVM with different `Twootr` instances with different dependencies
    isn’t possible. We’ve also coupled together lifetimes—perhaps we sometimes want
    to instantiate a new `TwootRepository` when we start `Twootr`, or perhaps we sometimes
    want to reuse an existing one. The factory method approach won’t let us directly
    do this. It can also become rather complicated to have a factory for every dependency
    that we want to create in our application.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: This is where Dependency Injection comes in. DI can be thought of as an example
    of the Hollywood Agent approach—don’t call us, we’ll call you. With DI instead
    of creating dependencies explicitly or using factories to create them, you simply
    take a parameter and whatever instantiates your object has the responsibiltiy
    for passing in the required dependencies. It might be a test class’s setup method
    passing in a mock. It might be the `main()` method of your application passing
    in a SQL database implementation. An example of this in use with the `Twootr`
    class is shown in [Example 7-33](#dependency_injection). Dependency Inversion
    is a strategy; Dependency Injection and the Repository pattern are tactics.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是依赖注入发挥作用的地方。DI可以被视为好莱坞代理人方法的一个例子——不要打电话给我们，我们会打电话给你。使用DI，你不是显式地创建依赖项或使用工厂来创建它们，而是简单地接受一个参数，任何实例化你的对象的东西都有责任传递所需的依赖项。这可能是一个测试类的设置方法传入一个模拟对象，也可能是你的应用程序的`main()`方法传入一个SQL数据库实现。在`Twootr`类中使用这个示例见[示例7-33](#dependency_injection)。依赖反转是一种策略；依赖注入和仓储模式是具体的战术。
- en: Example 7-33\. Creating the instances using Dependency Injection
  id: totrans-205
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例7-33\. 使用依赖注入创建实例
- en: '[PRE32]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Taking objects this way not only makes it easier to write tests for your objects,
    but it has the advantage of externalizing the creation of the objects themselves.
    This allows your application code or a framework to control when the `UserRepository`
    is created and what dependencies are wired into it. Many developers find it convenient
    to use DI frameworks, such as Spring and Guice, that offer many features on top
    of basic DI. For example, they define lifecycles for beans that standardize hooks
    to be called after the objects are instantiated or before they are destroyed if
    required. They can also offer scopes for objects, such as Singleton objects that
    are only instantiated once during the lifetime of a process or per-request objects.
    Furthermore, these DI frameworks often hook nicely into web development frameworks
    such as Dropwizard or Spring Boot and provide a productive out-of-the-box experience.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式处理对象不仅使得为对象编写测试变得更容易，而且外部化了对象本身的创建过程。这允许你的应用程序代码或框架控制`UserRepository`的创建时间以及注入到其中的依赖项。许多开发人员发现使用诸如Spring和Guice等提供许多高级特性的DI框架非常方便。例如，它们可以为bean定义生命周期，标准化对象实例化后或在需要时销毁前调用的钩子。它们还可以为对象提供作用域，例如仅在进程生命周期内实例化一次的Singleton对象或每个请求的对象。此外，这些DI框架通常能够很好地与诸如Dropwizard或Spring
    Boot之类的Web开发框架集成，并提供即开即用的高效开发体验。
- en: Packages and Build Systems
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包和构建系统
- en: Java allows you to split your codebase into different packages. Throughout this
    book we’ve put the code for each chapter into its own package and Twootr is the
    first project where we’ve split out multiple subpackages within the project itself.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: Java允许你将代码库拆分成不同的包。在本书中，我们将每个章节的代码放入其自己的包中，而Twootr是第一个在项目本身中拆分出多个子包的项目。
- en: 'Here are the packages can you look at for the different components within the
    project:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是可以查看项目内不同组件的包：
- en: '`com.iteratrlearning.shu_book.chapter_06` is the top-level package for the
    project.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`com.iteratrlearning.shu_book.chapter_06`是项目的顶层包。'
- en: '`com.iteratrlearning.shu_book.chapter_06.database` contains the adapter for
    SQL database persistence.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`com.iteratrlearning.shu_book.chapter_06.database`包含了SQL数据库持久化的适配器。'
- en: '`com.iteratrlearning.shu_book.chapter_06.in_memory` contains the adapter for
    in-memory persistence.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`com.iteratrlearning.shu_book.chapter_06.in_memory`包含了内存持久化的适配器。'
- en: '`com.iteratrlearning.shu_book.chapter_06.web_adapter` contains the adapter
    for the WebSockets-based UI.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`com.iteratrlearning.shu_book.chapter_06.web_adapter`包含了基于WebSockets的UI适配器。'
- en: Splitting out large projects into different packages can be helpful to structure
    code and make it easier for developers to find. Just in the same way that classes
    group together related methods and state, packages group together related classes.
    Packages should follow similar coupling and cohesion rules to your classes. Put
    classes in the same package when they’re likely to change at the same time and
    are related to the same structure. For example, in the Twootr project if we want
    to alter the SQL database persistence code we know we go to the `database` subpackage.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 将大型项目拆分为不同的包有助于组织代码，使开发人员更容易找到所需内容。就像类将相关方法和状态分组在一起一样，包将相关类分组在一起。包应遵循与类相似的耦合和内聚规则。当可能同时更改且与同一结构相关联时，将类放在同一个包中。例如，在
    Twootr 项目中，如果我们想要修改 SQL 数据库持久化代码，我们知道要进入`database`子包。
- en: Packages also enable information hiding. We discussed the idea of having a package-scoped
    constructor method back in [Example 4-3](ch04.xhtml#document_definition) in order
    to prevent objects from being instantiated outside of the package. We can also
    have package scoping for classes and methods. This prevents objects outside of
    the package from accessing the details of the class and helps us achieve loose
    coupling. For example, `WebSocketEndPoint` is package-scoped implementation of
    the `ReceiverEndPoint` interface that lives in the `web_adapter` package. No other
    code in the project should talk to this class directly—only through the `ReceiverEndPoint`
    interface that acts as the port.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 包还可以实现信息隐藏。我们在 [示例 4-3](ch04.xhtml#document_definition) 中讨论了有一个包作用域构造方法的想法，以防止对象在包外实例化。我们还可以对类和方法进行包作用域。这可以防止包外的对象访问类的细节，并帮助我们实现松耦合。例如，`WebSocketEndPoint`
    是 `web_adapter` 包中实现了 `ReceiverEndPoint` 接口的包作用域实现。项目中的其他代码不应直接与这个类交互，只能通过作为端口的
    `ReceiverEndPoint` 接口进行交互。
- en: Our approach of having a package per adapter in Twootr fits nicely with the
    hexagonal architectural pattern that we’ve used throughout this module. Not every
    application is hexagonal, however, and there are two common package structures
    that you may well encounter in other projects.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 Twootr 中每个适配器都有一个包的方法很好地符合我们在整个模块中使用的六边形架构模式。然而，并非每个应用程序都是六边形的，其他项目可能会遇到两种常见的包结构。
- en: One very common approach to structuring packages is to structure them by layer—for
    example, grouping together all code that generates HTML views in a website into
    a `views` package, and all the code that relates to handling web requests into
    a `controller` package. Despite being popular, this can be a poor choice of structure
    as it results in poor coupling and cohesion. If you want to modify an existing
    web page to add an additional parameter and display a value based upon that parameter,
    you would end up touching the `controller` and the `view` packages, and probably
    several others as well.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 一种常见的包结构方法是按层次结构化它们，例如，将所有生成网站 HTML 视图的代码放在`views`包中，并将处理网页请求相关的所有代码放在`controller`包中。尽管这种方法很流行，但它可能导致耦合性和内聚性不佳。如果要修改现有网页以添加额外参数并基于该参数显示值，则需要修改`controller`和`view`包，以及可能还有其他几个包。
- en: An alternative way of structuring code is to group code by feature. So, for
    example, if you were writing an ecommerce site you might have a `cart` package
    for your shopping cart, a `product` package for code related to product listings,
    a `payment` package code related to taking card payments, etc. This can often
    be more cohesive. If you want to add support for receiving payment by Mastercard
    as well as Visa, then you would only need to modify the `payment` package.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种代码结构的替代方法是按特性组织代码。例如，如果您编写电子商务网站，可以为购物车使用一个`cart`包，为产品列表相关的代码使用一个`product`包，为接受信用卡支付相关的代码使用一个`payment`包，等等。这通常会更具内聚性。如果要添加支持通过
    Mastercard 和 Visa 接收付款，则只需修改`payment`包即可。
- en: In [“Using Maven”](ch03.xhtml#using_maven) we talked about how to set up a basic
    build structure using the Maven build tool. In the project structure for this
    book we have one Maven project and the different chapters of the book are different
    Java packages within that one project. That’s a nice and simple project structure
    that will work for a wide range of different software projects, but it’s not the
    only one. Both Maven and Gradle offer project structures that build and output
    many build artifacts from a single top-level project.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在[“使用Maven”](ch03.xhtml#using_maven)中，我们讨论了如何使用Maven构建工具设置基本的构建结构。在本书的项目结构中，我们有一个Maven项目，而书中的不同章节则是该项目中的不同Java包。这是一个简单而清晰的项目结构，适用于各种不同的软件项目，但不是唯一的选择。Maven和Gradle都提供了从单个顶级项目构建和输出多个构建产品的项目结构。
- en: This can make sense if you want to deploy different build artifacts. For example,
    suppose you’ve got a client/server project where you want to have a single build
    that builds both the client and the server, but the client and the server are
    different binaries running on different machines. It’s best not to overthink or
    over-modularize build scripts, though.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想部署不同的构建产品，这是有道理的。例如，假设你有一个客户端/服务器项目，你希望有一个单一的构建同时构建客户端和服务器，但客户端和服务器是运行在不同机器上的不同二进制文件。不过，最好不要过于深思熟虑或过于模块化构建脚本。
- en: They’re something that you and your team will be running on your machines regularly
    and the highest priority is for them to be simple, fast, and easy to use. That’s
    why we went down the route of having one single project for the entire book, rather
    than submodule per project.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是你和你的团队经常在自己的机器上运行的东西，最高优先级是它们要简单、快速和易于使用。这就是为什么我们选择在整本书中只有一个单一项目，而不是每个项目一个子模块的路线。
- en: Limitations and Simplifications
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 限制和简化
- en: You’ve seen how we implement Twootr and learned about our design decisions along
    the way, but does that mean that the Twootr codebase that we’ve seen so far is
    the only or the best way to write it? Of course not! In fact, there are a number
    of limitations to our approach and simplifications that we’ve deliberately taken
    in order to make the codebase explainable in a single chapter.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了我们如何实现Twootr，并了解了我们沿途做出的设计决策，但这是否意味着我们迄今为止看到的Twootr代码库是唯一或最佳的写法呢？当然不是！事实上，我们的方法存在一些限制和我们故意采取的简化，以便将代码库解释在单一章节中。
- en: For a start we’ve written Twootr as though it will be run on a single thread
    and completely ignored the issue of concurrency. In practice we may want to have
    multiple threads responding to and emitting events in our Twootr implementation.
    That way we can make use of modern multicore CPUs and serve a larger number customers
    on one box.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们把Twootr写成了只能在单个线程上运行的形式，并完全忽略了并发的问题。实际上，我们可能希望在我们的Twootr实现中有多个线程响应和发出事件。这样我们就可以利用现代多核CPU，并在一台服务器上为更多的客户提供服务。
- en: In a bigger-picture sense, we’ve also ignored any kind of failover that would
    allow our service to continue to run if the server that it was hosted on fell
    over. We’ve also ignored scalability. For example, requiring all our twoots have
    a single defined order is something that is easy and efficient to implement on
    a single server but would present a serious scalability/contention bottleneck.
    Similarly, seeing all the twoots when you log on would cause a bottleneck as well.
    What if you go on holiday for a week and when you log back on you get 20,000 twoots!
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 从更宏观的角度来看，我们也忽略了任何能够在服务器宕机时使我们的服务继续运行的故障转移。我们也忽略了可扩展性。例如，要求所有的Twoot都有一个单一定义的顺序，在单一服务器上实现起来既容易又高效，但会带来严重的可扩展性/争用瓶颈。同样地，当你登录时看到所有的Twoot也会导致瓶颈。如果你去度假一周，当你重新登录时会得到20000条Twoot，这会怎么样！
- en: Addressing these issues in detail goes beyond the scope of this chapter. However,
    these are important topics if you wish to go further with Java, and we plan to
    address them in greater detail in future books in this series.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 对这些问题进行详细的讨论超出了本章的范围。然而，如果你希望在Java方面深入学习，这些是重要的话题，并且我们计划在本系列的未来书籍中更详细地讨论它们。
- en: Takeaways
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: You can now decouple data storage from business logic using the Repository pattern.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在你可以使用存储库模式将数据存储与业务逻辑解耦。
- en: You have seen implementations of two different types of repositories within
    this approach.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你已经看到了在这种方法中实现的两种不同类型的存储库。
- en: You were introduced to the ideas of functional programming, including Java 8
    Streams.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你已经介绍了函数式编程的概念，包括Java 8的Streams。
- en: You’ve seen how to structure a larger project with different packages.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你已经看到如何结构化一个具有不同包的较大项目。
- en: Iterating on You
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代你自己
- en: If you want to extend and solidify the knowledge from this section you could
    try one of the following activities.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想扩展并巩固这一节的知识，你可以尝试以下其中一项活动。
- en: Suppose that we had taken a pull model for Twootr. Instead of having messages
    continuously pushed out to a browser-based client over WebSockets, we had used
    HTTP to poll for the latest messages since a position.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们对Twootr采用了拉取模型。与其通过WebSockets持续向基于浏览器的客户端推送消息，我们可以使用HTTP来定期轮询获取自某个位置以来的最新消息。
- en: Brainstorm how our design would have changed. Try drawing a diagram of the different
    classes and how data would flow between them.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 思考我们的设计会如何改变。尝试绘制不同类之间数据流动的图表。
- en: Implement, using TDD, this alternative model for Twootr. You don’t need to implement
    the HTTP parts, just the underlying classes following this model.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用TDD实现Twootr的这种替代模型。你不需要实现HTTP部分，只需按照这种模型实现底层类。
- en: Completing the Challenge
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成挑战
- en: We built the product and it worked. Unfortunately, Joe realized when he launched
    that someone called Jack had released a similar product, with a similar name,
    taking billions in VC funding and with hundreds of millions of users. Jack only
    got there first by 11 years; it was bad luck for Joe, really.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开发了这个产品，它运行良好。不幸的是，当Joe推出时，他意识到有人叫Jack发布了一个类似的产品，名字也很相似，获得了数十亿美元的风投资金和数亿用户。事实上，Jack只比Joe早了11年到达这个地步；对Joe来说真是个倒霉的运气。
