- en: Chapter 3\. Functional Interfaces of the JDK
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 3 章。JDK 的功能接口
- en: Many functional programming languages only use a singular and dynamic concept
    of “functions” to describe their lambdas, regardless of their arguments, return
    type, or actual use case. Java, on the other hand, is a strictly typed language
    requiring tangible types for everything, including lambdas. That’s why the JDK
    provides you with over 40 readily available functional interfaces in its `java.util.functional`
    package to kickstart your functional toolset.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 许多功能性编程语言仅使用“函数”的单一和动态概念来描述它们的 lambda，而不管其参数、返回类型或实际用例如何。另一方面，Java 是一种严格类型的语言，需要对所有内容（包括
    lambda）进行具体类型。这就是为什么 JDK 在其 `java.util.functional` 包中为您提供了 40 多个现成的功能接口，以启动您的功能工具集。
- en: This chapter will show you the most important functional interfaces, explain
    why there are so many variations, and show how you can extend your own code to
    be more functional.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将向您展示最重要的功能接口，解释为什么会有这么多变体，并展示如何扩展自己的代码以变得更加功能性。
- en: The Big Four Functional Interface Categories
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 四大功能接口类别
- en: 'The 40+ functional interfaces in `java.util.functional` fall into four main
    categories with each category representing an essential functional use case:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `java.util.functional` 中的 40 多个功能接口分为四个主要类别，每个类别代表一个基本的功能用例：
- en: '*Functions* accept arguments and return a result.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*函数* 接受参数并返回结果。'
- en: '*Consumers* only accept arguments but do not return a result.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*消费者* 只接受参数但不返回结果。'
- en: '*Suppliers* do not accept arguments and only return a result.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*供应商* 不接受参数，只返回结果。'
- en: '*Predicates* accept arguments to test against an expression and return a `boolean`
    primitive as their result.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*断言* 接受参数以测试表达式，并返回一个`boolean`基元作为结果。'
- en: These four categories cover many use cases and their names relate to functional
    interface types and their variants.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这四个类别涵盖了许多用例，它们的名称与功能接口类型及其变体相关。
- en: Let’s take a look at the four main categories of functional interfaces.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看四大功能接口的主要分类。
- en: Functions
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数
- en: 'Functions with their corresponding `java.util.functional.Function<T, R>` interface,
    are one of the most central functional interfaces. They represent a “classical”
    function with a single input and output, as seen in [Figure 3-1](#_01-functions_big-four_function):'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 函数及其对应的 `java.util.functional.Function<T, R>` 接口是最为核心的功能接口之一。它们代表了一个“经典”函数，具有单一的输入和输出，如
    [图 3-1](#_01-functions_big-four_function) 所示：
- en: '![Function<T, R>](assets/afaj_0301.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![Function<T, R>](assets/afaj_0301.png)'
- en: Figure 3-1\. `Function<T, R>`
  id: totrans-14
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-1\. `Function<T, R>`
- en: 'The single abstract method of `Function<T, R>` is called `apply` and accepts
    an argument of a type `T` and produces a result of type `R`:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`Function<T, R>` 的单个抽象方法称为 `apply`，接受一个类型为 `T` 的参数，并产生类型为 `R` 的结果：'
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following code shows how to `null`-check and convert a `String` to its
    length as an `Integer`:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了如何对 `null` 进行检查并将 `String` 转换为其长度作为 `Integer`：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The input type `T` and output type `R` can be identical. However, in [“Function
    Arity”](#_01-functions_function-arity) I discuss specialized functional interface
    variants with identical types.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 输入类型 `T` 和输出类型 `R` 可以相同。但是，在 [“函数元数”](#_01-functions_function-arity) 中，我讨论了具有相同类型的专用功能接口变体。
- en: Consumers
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消费者
- en: As the name suggests, a Consumer only *consumes* an input parameter but doesn’t
    return anything, as shown in [Figure 3-2](#_01-functions_big-four_consumer). The
    central Consumer functional interface is `java.util.functional.Consumer<T>`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名称所示，Consumer 只 *消耗* 一个输入参数，但不返回任何东西，如 [图 3-2](#_01-functions_big-four_consumer)
    所示。中心 Consumer 功能接口是 `java.util.functional.Consumer<T>`。
- en: '![Consumer<T>](assets/afaj_0302.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![Consumer<T>](assets/afaj_0302.png)'
- en: Figure 3-2\. `Consumer<T>`
  id: totrans-23
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-2\. `Consumer<T>`
- en: 'The single abstract method of `Consumer<T>` is called `accept` and requires
    an argument of a type `T`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`Consumer<T>` 的单个抽象方法称为 `accept`，需要一个类型为 `T` 的参数：'
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following code consumes a `String` to print it:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码消耗一个 `String` 并将其打印出来：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Even though the sole consumption of a value in an expression might not fit into
    “pure” functional concepts, it’s an essential component for employing a more functional
    coding style in Java, bridging many gaps between non-functional code and higher-order
    functions.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在表达式中仅对值进行消费可能不符合“纯”功能概念，但它是在 Java 中采用更功能性编码风格的重要组成部分，可以弥合非功能性代码与高阶函数之间的许多差距。
- en: The `Consumer<T>` interface is similar to the Java 5+ `Callable<V>` found in
    the `java.util.concurrent` package, except the latter, throws a checked exception.
    The concept of checked and unchecked exceptions and their implications for functional
    code in Java will be explored in detail in [Chapter 10](ch10.xhtml#_02-exception-handling).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`Consumer<T>` 接口类似于 Java 5+ 中 `java.util.concurrent` 包中的 `Callable<V>`，但后者会抛出已检查异常。在
    Java 中，已检查异常和未检查异常的概念及其对函数式代码的影响将在 [第10章](ch10.xhtml#_02-exception-handling) 中详细探讨。'
- en: Suppliers
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Suppliers
- en: Suppliers are the antithesis of Consumers. Based around the central functional
    interface `java.util.functional.Supplier<T>`, the different Supplier variants
    don’t accept any input parameters but return a single value of type `T`, as shown
    in [Figure 3-3](#_01-functions_big-four_supplier).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Suppliers 是 Consumers 的反义词。基于中心函数接口 `java.util.functional.Supplier<T>`，不同的 Supplier
    变体不接受任何输入参数，但返回类型为 `T` 的单个值，如 [图 3-3](#_01-functions_big-four_supplier) 所示。
- en: '![Supplier<T>](assets/afaj_0303.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![Supplier<T>](assets/afaj_0303.png)'
- en: Figure 3-3\. `Supplier<T>`
  id: totrans-33
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-3\. `Supplier<T>`
- en: 'The single abstract method of `Supplier<T>` is called `get`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`Supplier<T>` 的单一抽象方法被称为 `get`：'
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following supplier provides a new random value on calling `get()`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以下的供应商在调用 `get()` 时会提供一个新的随机值：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Suppliers are often used for deferred execution, like wrapping an expensive
    task into them and only calling `get` when needed, as I will discuss in [Chapter 11](ch11.xhtml#_02-lazy-evaluation).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Suppliers 经常用于延迟执行，例如将昂贵的任务封装在其中，仅在需要时调用 `get`，正如我将在 [第11章](ch11.xhtml#_02-lazy-evaluation)
    中讨论的那样。
- en: Predicates
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 谓词
- en: Predicates are functions that accept a single argument to be tested against
    its logic and return either `true` or `false`. The syntax for the main functional
    interface `java.util.functional.Predicate<T>` is illustrated in [Figure 3-4](#_01-functions_big-four_predicate).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 谓词是接受单一参数并根据其逻辑进行测试并返回 `true` 或 `false` 的函数。主要函数式接口 `java.util.functional.Predicate<T>`
    的语法在 [图 3-4](#_01-functions_big-four_predicate) 中说明。
- en: '![Predicate<T>](assets/afaj_0304.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![Predicate<T>](assets/afaj_0304.png)'
- en: Figure 3-4\. `Predicate<T>`
  id: totrans-42
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-4\. `Predicate<T>`
- en: 'The single abstract method is called `test` and accepts an argument of a type
    `T` and returns a `boolean` primitive:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 单抽象方法被称为 `test`，接受一个 `T` 类型的参数并返回一个 `boolean` 原始类型：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It’s the go-to functional interface for decision-making, like `filter` methods
    of the functional pattern *map/filter/reduce* you will learn more about later
    on in [Chapter 6](ch06.xhtml#_02-data-processing).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 它是决策制定的首选函数接口，例如函数式模式 *map/filter/reduce* 中的 `filter` 方法，稍后您将在 [第6章](ch06.xhtml#_02-data-processing)
    中详细学习。
- en: 'The following code tests an `Integer` to be over 9000:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码测试一个 `Integer` 是否超过 9000：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Why So Many Functional Interface Variants?
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么会有这么多函数接口的变体？
- en: Although the big four categories and their main functional interface representations
    already cover many use cases, there are also variations and more specialized variants
    you can use. All these different types are necessary to fit lambdas into Java
    without a trade-off in backward compatibility. Due to this, though, using lambdas
    in Java is a little bit more complicated than in other languages. Still, integrating
    such a feature without breaking the vast ecosystem is worth it in my opinion.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管大四类别及其主要函数式接口的表示已经涵盖了许多用例，但您也可以使用各种变体和更专业化的变体。所有这些不同类型都是为了在 Java 中使用 lambda
    而不会影响向后兼容性。因此，使用 lambda 在 Java 中比其他语言稍微复杂一些。尽管如此，在不破坏庞大生态系统的情况下集成这样一个功能是值得的。
- en: There are ways to bridge between different functional interfaces, and each variant
    has its own optimal problem context to be used in. Handling so many different
    types might seem intimidating at first, but it will become almost second nature
    to know which type to use for what scenario after using a more functional approach
    for a while.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以在不同的函数接口之间进行桥接，每个变体都有自己的最佳问题环境可供使用。一开始处理这么多不同类型可能看起来令人生畏，但在使用更函数化的方法一段时间后，知道在什么场景使用哪种类型将变得几乎是第二天性。
- en: Function Arity
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数元数
- en: 'The concept of *arity* describes the number of operands that a function accepts.
    For example, an arity of one means that a lambda accepts a single argument, as
    follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*Arity* 的概念描述了函数接受的操作数数量。例如，元数为一意味着 lambda 接受单一参数，如下所示：'
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As the number of arguments in Java methods, like a SAM, is fixed^([1](ch03.xhtml#idm45115249764864)),
    there must be an explicit functional interface representing every required arity.
    To support arities higher than one, the JDK includes specialized variants of the
    main functional interface categories that accept arguments, as listed in [Table 3-1](#_01-functions_arity_types).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Java 方法中的参数数量，如 SAM，是固定的^([1](ch03.xhtml#idm45115249764864))，因此必须有一个显式的功能接口来表示每个所需的元数。为了支持大于一的元数，JDK
    包括了接受参数的主要功能接口类别的专门变体，如[表 3-1](#_01-functions_arity_types)所列。
- en: Table 3-1\. Arity-based Functional Interfaces
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3-1\. 基于元数的函数接口
- en: '| Arity of one | Arity of two |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| 元数为一 | 元数为二 |'
- en: '| --- | --- |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Function<T, R>` | `BiFunction<T, U, R>` |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `Function<T, R>` | `BiFunction<T, U, R>` |'
- en: '| `Consumer<T>` | `BiConsumer<T, U>` |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `Consumer<T>` | `BiConsumer<T, U>` |'
- en: '| `Predicate<T>` | `BiPredicate<T, U>` |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `Predicate<T>` | `BiPredicate<T, U>` |'
- en: Only functions interfaces with an arity of up to two are supported out-of-the-box.
    Looking at the functional APIs and use cases in Java, arities of one or two cover
    the most common tasks. That’s most likely why the Java language designers decided
    to stop there and didn’t add any higher arities out-of-the-box.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 仅支持最多两个元数的函数接口。查看 Java 中的功能 API 和使用案例，一到两个元数覆盖了最常见的任务。这很可能是 Java 语言设计者决定停在那里并且没有在开箱即用时添加更高元数的原因。
- en: 'Adding higher arities is simple though, like in the following code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 添加更高的元数非常简单，就像下面的代码中所示：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: However, I wouldn’t recommend it unless it’s an absolute necessity. As you will
    see throughout this chapter and the book, the included functional interface give
    you a lot of additional functionality through `static` and `default` methods.
    That’s why relying on them ensures the best compatibility and well-understood
    usage patterns.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，除非绝对必要，我不建议这样做。正如您将在本章和本书中看到的那样，包含的函数接口通过`static`和`default`方法为您提供了大量额外的功能。因此，依赖它们确保了最佳的兼容性和被广泛理解的使用模式。
- en: Functional Operators
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数操作符
- en: 'The concept of operators simplifies the two most commonly used arities by giving
    you functional interfaces with identical generic types. For example, if you require
    a function to accept two `String` arguments to create another `String` value,
    the type definition of `BiFunctuon<String, String, String>` would be quite repetitive.
    Instead, you can use a `BinaryOperator<String>` which is defined as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 操作符的概念通过为您提供具有相同泛型类型的功能接口来简化两个最常用的元数。例如，如果您需要一个函数接受两个 `String` 参数以创建另一个 `String`
    值，则`BiFunction<String, String, String>` 的类型定义将非常重复。相反，您可以使用`BinaryOperator<String>`，其定义如下：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Implementing a comment super interface allows you to write more concise code
    with more meaningful types.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 实现一个评论超级接口使您能够使用更有意义的类型编写更简洁的代码。
- en: The available operator functional interfaces are listed in [Table 3-2](#_01-functions_operator_types).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的操作符功能接口列在[表 3-2](#_01-functions_operator_types)中。
- en: Table 3-2\. Operator Functional Interfaces
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3-2\. 操作符功能接口
- en: '| Arity | Operator | Super Interface |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 元数 | 操作符 | 超级接口 |'
- en: '| --- | --- | --- |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 1 | `UnaryOperator<T>` | `Function<T, T>` |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| 1 | `UnaryOperator<T>` | `Function<T, T>` |'
- en: '| 2 | `BinaryOperator<T>` | `BiFunction<T, T, T>` |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| 2 | `BinaryOperator<T>` | `BiFunction<T, T, T>` |'
- en: Be aware that operator types and their `super` interface aren’t interchangeable,
    though. That’s especially important when designing APIs.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，操作符类型及其`super`接口不能互换使用。在设计 API 时特别重要。
- en: Imagine a method signature requires a `UnaryOperator<String>` as an argument,
    it won’t be compatible with `Function<String, String>`. However, the other way
    around works, as shown in [Example 3-1](#_01-functions_arity_compatibility).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个方法签名需要一个 `UnaryOperator<String>` 作为参数，它将与 `Function<String, String>` 不兼容。然而，反过来可以，如[示例 3-1](#_01-functions_arity_compatibility)所示。
- en: Example 3-1\. Java arity compatibility
  id: totrans-77
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-1\. Java 元数兼容性
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: That example highlights that you should choose the most common denominator for
    method arguments, in this case, `Function<String, String>`, as they give you the
    most compatibility. Even though it increases the verbosity of your method signatures,
    it’s an acceptable trade-off, in my opinion, because it maximizes usability and
    doesn’t restrict an argument to a specialized functional interface. When creating
    a lambda, on the other hand, the specialized type allows for more concise code
    without losing any expressiveness in your code.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子突出了选择方法参数的最常见公分母的重要性，例如`Function<String, String>`，因为它们提供了最大的兼容性。尽管这增加了方法签名的冗长，但在我看来，这是一个可以接受的折衷，因为它最大化了可用性，并且不限制参数为专门的函数接口。另一方面，创建lambda时，专门的类型允许更简洁的代码，而不会在代码表达上失去任何表现力。
- en: Primitive Types
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原始类型
- en: Most of the functional interfaces you’ve encountered so far had a generic type
    definition, but that’s not always the case. Primitive types can’t be used as generic
    types (yet). That’s why there are specialized functional interfaces for primitives.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您遇到的大多数函数接口都有通用类型定义，但并非总是如此。原始类型目前不能用作通用类型。这就是为什么有专门的原始类型函数接口的原因。
- en: You *could* use any generic functional interface for the object wrapper type
    and let autoboxing take care of the rest. However, auto-boxing isn’t *free*, so
    it can have a performance impact.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 您*可以*使用任何对象包装类型的通用函数接口，并让自动装箱来处理其余部分。但是，自动装箱并非*免费*，因此可能会影响性能。
- en: Note
  id: totrans-83
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Autoboxing and unboxing is the automatic conversion between primitive value
    types and their object-based counterparts so they can be used indiscriminately.
    For example, autoboxing an `int` to an `Integer`. The other way around is called
    unboxing.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 自动装箱和拆箱是原始值类型与基于对象的对应类型之间的自动转换，以便它们可以被无差别地使用。例如，将`int`自动装箱为`Integer`。反之被称为拆箱。
- en: That’s why many of the functional interfaces provided by the JDK deal with primitive
    types to avoid autoboxing. Such primitive functional interfaces, like the arity
    specializations, aren’t available for all primitives, though. They are mostly
    concentrated around the numeric primitives `int`, `long`, and `double`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么JDK提供的许多函数接口处理原始类型，以避免自动装箱的原因。这种原始函数接口，例如特定的数目专业化，虽然不是所有原始类型都有，但大多数集中在数值原始类型`int`、`long`和`double`周围。
- en: '[Table 3-3](#_01-functions_primitive-functional-interfaces) lists the available
    functional interfaces for `int`, but there are equivalent interfaces for `long`
    and `double` as well.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 3-3](#_01-functions_primitive-functional-interfaces) 列出了`int`的可用函数接口，但对于`long`和`double`也有等效接口。'
- en: Table 3-3\. Functional Interfaces for the integer primitive
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3-3\. 整数原始类型的函数接口
- en: '| Category | Functional Interface | Boxed Alternative |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| 类别 | 函数接口 | 包装类型替代 |'
- en: '| --- | --- | --- |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Functions | `IntFunction<R>` | `Function<Integer, R>` |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | `IntFunction<R>` | `Function<Integer, R>` |'
- en: '| `IntUnaryOperator` | `UnaryOperator<Integer>` |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `IntUnaryOperator` | `UnaryOperator<Integer>` |'
- en: '| `IntBinaryOperator` | `BinaryOperator<Integer>` |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `IntBinaryOperator` | `BinaryOperator<Integer>` |'
- en: '| `ToIntFunction<T>` | `Function<T, Integer>` |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `ToIntFunction<T>` | `Function<T, Integer>` |'
- en: '| `ToIntBiFunction<T, U>` | `BiFunction<T, U, Integer>` |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `ToIntBiFunction<T, U>` | `BiFunction<T, U, Integer>` |'
- en: '| `IntToDoubleFunction` | `Function<Integer, Double>` |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `IntToDoubleFunction` | `Function<Integer, Double>` |'
- en: '| `IntToLongFunction` | `Function<Integer, Long>` |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `IntToLongFunction` | `Function<Integer, Long>` |'
- en: '| Consumers | `IntConsumer` | `Consumer<Integer>` |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| 消费者 | `IntConsumer` | `Consumer<Integer>` |'
- en: '| `ObjIntConsumer<T>` | `BiConsumer<T, Integer>` |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `ObjIntConsumer<T>` | `BiConsumer<T, Integer>` |'
- en: '| Suppliers | `IntSupplier` | `Supplier<Integer>` |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| 供应者 | `IntSupplier` | `Supplier<Integer>` |'
- en: '| Predicates | `IntPredicate` | `Predicate<Integer>` |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| 断言 | `IntPredicate` | `Predicate<Integer>` |'
- en: 'The `boolean` primitive has only a single specialized variant available: `BooleanSupplier`.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`boolean`原始类型只有一个专门的变体可用：`BooleanSupplier`。'
- en: Functional interfaces for primitives aren’t the only special consideration in
    the new functional parts of Java to accommodate primitives. As you will learn
    later in this book, Streams and Optionals provide specialized types, too, to reduce
    the unnecessary overhead incurred by autoboxing.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Java新功能部分中，针对基本类型的函数接口并不是唯一需要考虑的特殊情况。正如您将在本书后面学到的那样，Streams和Optionals也提供了专门的类型，以减少自动装箱带来的不必要开销。
- en: Bridging Functional Interfaces
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接函数接口
- en: 'Functional interfaces are, well, interfaces, and lambda expressions are concrete
    implementations of these interfaces. Type inference makes it easy to forget that
    you can’t use them interchangeably or simply cast between unrelated interfaces.
    Even if their method signatures are identical, an exception is thrown, as seen
    previously in [“Creating Lambdas”](ch02.xhtml#_01-functional-java_lambdas-in-action-creating):'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 功能接口就是接口，而lambda表达式则是这些接口的具体实现。类型推断使人容易忘记你不能在它们之间互换使用，或者简单地在不相关的接口之间进行强制转换。即使它们的方法签名相同，异常也会被抛出，就像在[“创建Lambda”](ch02.xhtml#_01-functional-java_lambdas-in-action-creating)中看到的那样：
- en: '[PRE12]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'From a lambda-based point of view, both SAMs are identical. They both accept
    a `String` argument and return an `boolean` result. For Java’s type-system, though,
    they have no connection whatsoever, making a cast between them impossible. Still,
    the gap between “lambda-compatible but type-incompatible” functional interfaces
    can be bridged by a feature I discussed in the previous chapter: *method references*.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 从基于lambda的角度看，这两个SAM是相同的。它们都接受一个`String`参数并返回一个`boolean`结果。然而，对于Java的类型系统来说，它们完全没有关联，这使得它们之间的强制转换变得不可能。不过，可以通过我在上一章中讨论过的特性来弥合“lambda兼容但类型不兼容”的功能接口之间的差距：*方法引用*。
- en: 'By using a method reference instead of trying to cast between the “identical
    but incompatible” functional interfaces, you can refer to the SAM instead to make
    your code compile:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用方法引用而不是试图在“相同但不兼容”的功能接口之间进行强制转换，你可以引用SAM以使你的代码编译通过：
- en: '[PRE13]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Using a method reference creates a new dynamic call site to be invoked by the
    bytecode opcode `invokedynamic` instead of trying to implicitly or explicitly
    cast the functional interface itself.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方法引用创建一个新的动态调用点，由字节码操作码`invokedynamic`来调用，而不是试图隐式或显式地强制转换功能接口本身。
- en: Like re-finalizing variables that you’ve learned about in [“Re-finalizing a
    Reference”](ch02.xhtml#_01-functions-refinalize), bridging functional interfaces
    with method references is another “band-aid” to deal with code that can’t be refactored
    or redesigned another way. Still, it’s an easy-to-use and sometimes necessary
    tool to have in your functional kit, especially if you’re transitioning from a
    legacy code base to a more functional approach, or work with third-party code
    that provides its own functional interfaces.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 像重新为你学习的[“重新定位引用”](ch02.xhtml#_01-functions-refinalize)一样，使用方法引用来连接功能接口是另一种“临时措施”，用来处理无法重构或以其他方式重新设计的代码。但这是一个易于使用且有时必不可少的工具，尤其是在从传统代码库过渡到更功能化方法，或者与提供自己功能接口的第三方代码一起工作时。
- en: Functional Composition
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能组合
- en: Functional composition is an essential part of the functional approach to combine
    small functional units into a bigger, more complex task, and Java got you covered.
    However, it’s done in a typical Java fashion to ensure backward compatibility.
    Instead of introducing a new keyword, or changing any language semantics, Java
    uses “glue” methods that are directly implemented on the functional interfaces
    themselves as `default` methods. With their help, you can compose the big four
    categories of functional interfaces easily. Such glue methods build the bridge
    between two functional interfaces by returning a new one with the combined functionality.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 功能组合是功能方法的重要组成部分，它将小功能单元组合成更大、更复杂的任务，而Java则为你提供了支持。但是，它是用典型的Java方式完成的，以确保向后兼容性。Java没有引入新的关键字或更改任何语言语义，而是直接在功能接口上实现“粘合”方法作为`default`方法。借助它们，你可以轻松地组合四大类功能接口。这些粘合方法通过返回一个具有组合功能的新接口来构建两个功能接口之间的桥梁。
- en: 'In the case of `Function<T, R>`, two `default` methods are available:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Function<T, R>`，有两个`default`方法可用：
- en: '`<V> Function<V, R> compose(Function<? super V, ? extends T> before)`'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<V> Function<V, R> compose(Function<? super V, ? extends T> before)`'
- en: '`<V> Function<T, V> andThen(Function<? super R, ? extends V> after)`'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<V> Function<T, V> andThen(Function<? super R, ? extends V> after)`'
- en: The difference between these two methods is the direction of the composition,
    as indicated by the argument names and the returned `Function` and its generic
    types. The first one, `compose`, creates a composed function that applies the
    `before` argument to its input and the result to `this`. The second one, `andThen`,
    is the antagonist to `compose`, as it evaluates `this` and then applies `after`
    to the previous result.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法的区别在于组合的方向，由参数名称和返回的`Function`及其泛型类型指示。第一个方法`compose`创建一个组合函数，它将`before`参数应用于其输入并将结果应用于`this`。第二个方法`andThen`则与`compose`相反，它先评估`this`，然后将`after`应用于前一个结果。
- en: Which direction of functional composition to choose, `compose` or `andThen`,
    depends on the context and personal preference. The call `fn1.compose(fn2)` leads
    to an equivalent call like `fn1(fn2(input))`. To achieve the same flow with the
    `andThen` method, the compositional order must be reversed to a `fn2.andThen(fn1(input))`
    call, as illustrated in [Figure 3-5](#_01-functions_functional-composition_direction-figure).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 选择函数组合的方向，`compose`还是`andThen`，取决于上下文和个人偏好。调用`fn1.compose(fn2)`会导致等效调用`fn1(fn2(input))`。要使用`andThen`方法实现相同的流程，组合顺序必须反转为`fn2.andThen(fn1(input))`的调用，如[图 3-5](#_01-functions_functional-composition_direction)所示。
- en: '![Function<T, R> composition order](assets/afaj_0305.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![Function<T, R> 组合顺序](assets/afaj_0305.png)'
- en: Figure 3-5\. Function<T, R> composition order
  id: totrans-119
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-5\. Function<T, R> 组合顺序
- en: Personally, I prefer `andThen(…​)` because the resulting prose-like fluent method
    call-chain mirrors the logical flow of functions that’s easier to grasp for other
    readers that aren’t versed with functional programming naming conventions.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 就我个人而言，我更喜欢`andThen(…​)`，因为生成的类似散文般的流畅方法调用链反映了函数的逻辑流程，对于不熟悉函数式编程命名约定的其他读者更易于理解。
- en: Think of manipulating a `String` by removing occurrences of any lowercase “a”
    and uppercasing the result. The overall tasks consist of two `Function<String,
    String>` doing a singular thing. Composing them can be done either way without
    a difference in the final result, if you use the appropriate glue method, as seen
    in [Example 3-2](#_01-functions_functional-composition_direction).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下通过删除任何小写“a”的出现并大写结果来操作`String`。整体任务由两个执行单一任务的`Function<String, String>`组成。通过适当的粘合方法，可以以任一方式进行组合而不影响最终结果，如[示例 3-2](#_01-functions_functional-composition_direction)中所见。
- en: Example 3-2\. Functional composition direction
  id: totrans-122
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-2\. 函数组合方向
- en: '[PRE14]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Be aware that not every functional interface provides such “glue methods” to
    easily support composition, even if it would be sensible to do so. The following
    list gives you a summary of how the different main interfaces of the big four
    categories support composition out of the box:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，并非每个功能接口都提供这种“粘合方法”以便轻松支持组合，即使这样做是合理的。以下列表总结了四大类主要接口如何在原生支持组合方面的支持情况：
- en: '`Function<T, R>`'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`Function<T, R>`'
- en: '`Function<T, R>`, and its specialized arities, like `UnaryOperator<T>`, support
    composition in both directions. The `Bi…​` variants only support `andThen`.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`Function<T, R>`及其类似`UnaryOperator<T>`的专门继承，支持两个方向的组合。`Bi…​`变体仅支持`andThen`。'
- en: '`Predicate<T>`'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`Predicate<T>`'
- en: 'Predicates support various methods to compose a new Predicate with common operations
    associated with them: `and`, `or`, `negate`.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 谓词支持各种方法来组合具有常见操作的新谓词：`and`、`or`、`negate`。
- en: '`Consumer<T>`'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`Consumer<T>`'
- en: Only `andThen` is supported, which will compose two Consumers to accept a value
    in sequence.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 只支持`andThen`，它将两个`Consumer`组合以便按顺序接受值。
- en: Specialized primitive functional interfaces
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 专门的原始功能接口
- en: The support for functional composition among the specialized functional interfaces
    for primitives is not on par with their generic brethren. Even among themselves,
    the support differs between the primitive types.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 特定于原始类型的专门功能接口之间的功能组合支持与其通用兄弟接口不尽相同。即使在它们之间，对于原始类型的支持也有所不同。
- en: But don’t fret! Writing your own functional compositional helper is easy, as
    I will discuss in the next section.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 但不要担心！编写自己的函数组合辅助工具很容易，下一节我会详细讨论。
- en: Extending Functional Support
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展功能支持
- en: Most functional interfaces usually give you more than just their single abstract
    method defining the lambda signature. Usually, they provide additional `default`
    methods to support concepts like functional composition, or `static` helpers to
    simplify common use cases of that type.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数函数式接口通常不仅仅提供定义 lambda 签名的单个抽象方法。通常，它们提供额外的 `default` 方法来支持函数组合等概念，或者提供 `static`
    辅助方法来简化该类型的常见用例。
- en: 'As you can’t change the types of the JDK yourself, you can still make your
    own types more functional instead. There are three approaches you can choose that
    are also used by the JDK itself:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你无法自己更改 JDK 的类型，但仍然可以使你自己的类型更加功能化。你可以选择 JDK 自身也在使用的三种方法之一：
- en: Add `default` methods to an interface to make existing types more functional.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向接口添加 `default` 方法，使现有类型更具功能性。
- en: Implement a functional interface explicitly.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显式地实现一个函数式接口。
- en: Create `static` helpers to provide common functional operations.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 `static` 辅助方法来提供常见的函数操作。
- en: Adding Default Methods
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加默认方法
- en: Adding new functionality to an interface always requires you to implement new
    methods on all implementations. When dealing with a small project, it might be
    fine to just update any implementation, but in bigger and shared projects it’s
    often not as easy. In library code it’s even worse, you might break the code of
    anyone using your library. That’s where `default` methods come in to save the
    day.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 向接口添加新功能始终需要在所有实现上实现新方法。在处理小项目时，仅更新任何实现可能是可行的，但在更大和共享的项目中通常不太容易。在库代码中更糟糕，你可能会破坏任何使用你的库的人的代码。这就是
    `default` 方法派上用场的地方。
- en: Instead of solely changing the contract of a type’s interface and letting anyone
    implementing it deal with the fallout — adding the new method on any type that
    implements the interface --⁠, you can use `default` methods to supply a “common-sense”
    implementation. Such an implementation provides a general variant of the intended
    logic to all other types down the line, so you don’t have to throw an `UnsupportedOperationException`.
    This way, your code is backward-compatible because only the interface itself has
    changed, but any type that implements the interface has still a chance to create
    its own, more fitting implementation if necessary. That’s exactly how the JDK
    added Stream-support to any type implementing the interface `java.util.Collection<E>`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 而不仅仅是改变类型接口的契约，让任何实现它的人来处理其影响 —— 在任何实现该接口的类型上添加新方法 --⁠，你可以使用 `default` 方法来提供“常识”实现。这样的实现为所有其他类型提供了预期逻辑的一般变体，因此你不必抛出
    `UnsupportedOperationException`。这种方式使得你的代码向后兼容，因为只有接口本身发生了变化，但是任何实现该接口的类型仍然有机会根据需要创建自己更合适的实现。这正是
    JDK 如何向任何实现 `java.util.Collection<E>` 接口的类型添加 Stream 支持的方式。
- en: 'The following code shows the actual `default` methods that give any `Collection`-based
    type Stream capabilities out of the box at no additional (implementation) cost:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了实际的 `default` 方法，使任何基于 `Collection` 的类型在没有额外（实现）成本的情况下立即具备了 Stream 功能：
- en: '[PRE15]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The two `default` methods create new `Stream<E>` instances by calling the `static`
    helper `StreamSupport.stream(…​)` and the `default` method `spliterator()`. The
    `spliterator()` is initially defined in `java.util.Iterable<E>` but is overridden
    as necessary, as shown in [Example 3-3](#_01-functional-jdk_default-method-hierarchy).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个 `default` 方法通过调用 `static` 辅助方法 `StreamSupport.stream(…​)` 和 `default` 方法
    `spliterator()` 来创建新的 `Stream<E>` 实例。`spliterator()` 最初在 `java.util.Iterable<E>`
    中定义，但根据需要进行了重写，如 [示例 3-3](#_01-functional-jdk_default-method-hierarchy) 所示。
- en: Example 3-3\. Default Method Hierarchy
  id: totrans-146
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-3\. 默认方法层次结构
- en: '[PRE16]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[![1](assets/1.png)](#co_functional_interfaces_of_the_jdk_CO1-1)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_functional_interfaces_of_the_jdk_CO1-1)'
- en: The original definition of `spliterator()` with a common-sense implementation
    based on all the available information for the type.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`spliterator()` 的原始定义，基于类型的所有可用信息提供了一个常识实现。'
- en: '[![2](assets/2.png)](#co_functional_interfaces_of_the_jdk_CO1-4)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_functional_interfaces_of_the_jdk_CO1-4)'
- en: The `Collection` interface can use more information to create a more specific
    `Spliterator<E>` that is available to all of its implementations.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`Collection` 接口可以使用更多信息来创建一个更具体的 `Spliterator<E>`，该 `Spliterator<E>` 可用于其所有实现。'
- en: '[![3](assets/3.png)](#co_functional_interfaces_of_the_jdk_CO1-5)'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_functional_interfaces_of_the_jdk_CO1-5)'
- en: The concrete implementation `ArrayList<E>`, which implements `Collection<E>`
    via `List<E>`, provides an even further specialized `Spliterator<E>`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 具体实现 `ArrayList<E>` 实现了 `Collection<E>`，通过 `List<E>`，进一步提供了更专业化的 `Spliterator<E>`。
- en: A hierarchy of `default` methods gives you the power to add new functionality
    to an interface without breaking any implementations and still providing a common-sense
    variant of the new method. Even if a type never implements a more specific variant
    for itself, it can fall back to the logic provided by the `default` method.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`default`方法的层次结构赋予你向接口添加新功能的能力，而不会破坏任何实现，并且仍然提供新方法的常识变体。即使一个类型从未为自己实现更具体的变体，它也可以回退到`default`方法提供的逻辑。
- en: Implementing Functional Interfaces Explicitly
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显式实现功能接口
- en: Functional interfaces can be implemented implicitly via lambda or method references,
    but they are also useful when implemented explicitly by one of your types so they
    are usable in higher-order functions. Some of your types might already implement
    one of the retroactively functional interfaces like `java.util.Comparator<T>`
    or `java.lang.Runnable`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 功能接口可以通过lambda或方法引用隐式实现，但当它们由你的类型之一显式实现时，它们也非常有用，因此它们可以在高阶函数中使用。你的一些类型可能已经实现了诸如`java.util.Comparator<T>`或`java.lang.Runnable`之类的后续功能接口中的一个。
- en: Implementing a functional interface directly creates a bridge between previously
    “non-functional” types and their easy usage in functional code. A good example
    is the object-oriented *command design pattern*⁠^([2](ch03.xhtml#idm45115248733296)).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 直接实现功能接口在以前的“非功能”类型和它们在功能代码中的易用性之间创建了一个桥梁。一个很好的例子是面向对象的*命令设计模式*⁠^([2](ch03.xhtml#idm45115248733296))。
- en: Note
  id: totrans-158
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The command pattern encapsulates an action, or “command”, and all data required
    to execute it in an object. This approach decouples the creation of commands from
    consuming them.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 命令模式封装了一个动作或“命令”，以及执行它所需的所有数据。这种方法将命令的创建与消费分离开来。
- en: 'Usually, a command already has a dedicated interface. Imagine a text editor
    with its common commands like opening a file or saving it. A shared command interface
    between these commands could be as simple as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一个命令已经有了一个专用的接口。想象一个文本编辑器和其常见命令，如打开文件或保存文件。这些命令之间的共享命令接口可以简单地如下所示：
- en: '[PRE17]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The concrete command classes would accept the required arguments, but the executed
    command would simply return the updated editor content. If you look closely, you
    see that the interface matches a `Supplier<String>`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 具体的命令类将接受所需的参数，但执行的命令将简单地返回更新后的编辑器内容。如果你仔细观察，你会发现该接口匹配了一个`Supplier<String>`。
- en: 'As I discussed in [“Bridging Functional Interfaces”](#_01-functional-jdk_bridging-functional-interfaces),
    the mere logical equivalency between functional interfaces isn’t enough to create
    compatibility. However, by extending `TextEditorCommand` with `Supplier<String>`,
    you bridge the gap with a `default` method, as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在[“桥接功能接口”](#_01-functional-jdk_bridging-functional-interfaces)中讨论的那样，仅仅是功能接口之间的逻辑等价并不足以创建兼容性。然而，通过将`TextEditorCommand`扩展为`Supplier<String>`，你可以通过`default`方法弥合差距，如下所示：
- en: '[PRE18]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Interfaces allow multiple inheritance, so adding a functional interface shouldn’t
    be an issue. The functional interface’s SAM is a simple `default` method calling
    the actual method doing the work. This way, not a single command needs to be changed
    but all of them gain compatibility with any higher-order function accepting a
    `Supplier<String>` without requiring a method reference as a bridge.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 接口允许多重继承，因此添加一个功能接口不应该成为问题。功能接口的SAM是一个简单的`default`方法，调用实际执行工作的方法。这种方式不需要更改任何单个命令，但它们都可以与任何接受`Supplier<String>`的高阶函数兼容，而无需方法引用作为桥接。
- en: Warning
  id: totrans-166
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Look out for method signature collisions if existing interfaces implement a
    functional interface, so you don’t accidentally override an existing one.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 注意方法签名冲突，如果现有接口实现一个功能接口，这样你就不会意外覆盖一个现有的接口。
- en: Implementing one or more functional interfaces is a great way to give your types
    a functional starting point, including all the additional `default` methods available
    on the functional interfaces.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 实现一个或多个功能接口是给你的类型提供功能起点的好方法，包括功能接口上可用的所有额外的`default`方法。
- en: Creating Static Helpers
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建静态帮助器
- en: Functional interfaces usually extend their versatility by having `default` methods
    and `static` helpers for common tasks. If you don’t have control over the type,
    though, like a functional interface provided by the JDK itself, you can create
    a helper type accumulating `static` methods.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 功能接口通常通过具有`default`方法和常见任务的`static`帮助器来扩展其多功能性。但是，如果你无法控制类型，比如由JDK本身提供的功能接口，你可以创建一个累积`static`方法的帮助器类型。
- en: In [“Functional Composition”](#_01-functional-jdk_functional-composition), I
    discussed functional composition with the help of the available `default` methods
    on the big four interfaces. Even though the most common use cases are covered,
    certain different functional interfaces aren’t covered. You can create them yourself,
    however.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在“Functional Composition”中，我讨论了通过大四接口上的可用`default`方法进行功能组成的功能组成。尽管覆盖了最常见的用例，但某些不同的功能接口却未被覆盖。但是，您可以自己创建它们。
- en: Let’s take a look at how `Function<T, R>` implements^([3](ch03.xhtml#idm45115248649152))
    its `compose` method in [Example 3-4](#_01-functional-java_func-compoisition_simplified-function-interface),
    so we can develop a compositor helper type to accept other types, too.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下[Example3-4](#_01-functional-java_func-compoisition_simplified-function-interface)中的`Function<T,
    R>`如何实现了其`compose`方法，以便我们可以开发一个辅助组合类型来接受其他类型。
- en: Example 3-4\. Simplified `Function<T, R>` interface
  id: totrans-173
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例3-4。 简化的`Function<T, R>`接口
- en: '[PRE19]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[![1](assets/1.png)](#co_functional_interfaces_of_the_jdk_CO2-1)'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_functional_interfaces_of_the_jdk_CO2-1)'
- en: The composed function isn’t bound to the original type `T` and introduces `V`
    in its method signature.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 组合函数不再限制于原始类型 `T`，在其方法签名中引入了 `V`。
- en: '[![2](assets/2.png)](#co_functional_interfaces_of_the_jdk_CO2-2)'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_functional_interfaces_of_the_jdk_CO2-2)'
- en: A `null`-check helper to throw a `NullPointerException` on composition and not
    only on the first use of the returned lambda.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`null`-check helper来在组成上抛出一个`NullPointerException`而不仅仅是在返回lambda的第一次使用上。
- en: '[![3](assets/3.png)](#co_functional_interfaces_of_the_jdk_CO2-3)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_functional_interfaces_of_the_jdk_CO2-3)'
- en: The returned lambda accepts a value of the newly introduced type `V`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的lambda接受新引入类型`V`的值。
- en: '[![4](assets/4.png)](#co_functional_interfaces_of_the_jdk_CO2-4)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_functional_interfaces_of_the_jdk_CO2-4)'
- en: The `before` function is evaluated first.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 首先评估 `before` 函数。
- en: '[![5](assets/5.png)](#co_functional_interfaces_of_the_jdk_CO2-5)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_functional_interfaces_of_the_jdk_CO2-5)'
- en: The `result` is then applied to the original `Function<T, R>`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 结果然后应用于原始`Function<T, R>`。
- en: 'To create your own compositional methods, you have to first think about what
    exactly you want to achieve. The involved functional interfaces and their compositional
    order dictate the overall type chain that the method signature has to reflect:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建自己的组合方法，首先必须考虑你想要实现的具体目标。所涉及的功能接口及其组合顺序将决定方法签名必须反映的整体类型链：
- en: '`Function<T, R>#compose(Function<V, T>)`'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`Function<T, R>#compose(Function<V, T>)`'
- en: '`V` → `T` → `R`'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`V` → `T` → `R`'
- en: '`Function<T, R>#andThen(Function<R, V)`'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`Function<T, R>#andThen(Function<R, V)`'
- en: '`T` → `R` → `V`.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`T` → `R` → `V`.'
- en: Let’s develop a compositor for `Function<T, R>` and `Supplier`/`Consumer`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开发一个组合器为`Function<T, R>`和`Supplier`/ `Consumer`。
- en: 'Only two combinations are possible because `Supplier` won’t accept arguments,
    so it can’t evaluate the result of the `Function<T, R>`. The opposite reason is
    true for `Supplier`. Because we can’t extend the `Function<T, R>` interface directly,
    an indirect compositor in form of a `static` helper is needed. That leads to the
    following method signatures in which the compositional order is reflected by the
    argument order:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `Supplier` 不接受参数，因此只有两种组合是可能的；因此无法评估 `Function<T, R>` 的结果。 对于 `Supplier`，原因是反向的。
    由于直接扩展 `Function<T, R>`  接口不可能，所以需要使用 `static` 辅助程序的间接组合器。 这导致了以下方法签名，其中参数顺序反映了组合顺序：
- en: '`Supplier<R> compose(Supplier<T> before, Function<T, R> fn)`'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Supplier<R> compose(Supplier<T> before, Function<T, R> fn)`'
- en: '`Consumer<T> compose(Function<T, R> fn, Consumer<R> after)`'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Consumer<T> compose(Function<T, R> fn, Consumer<R> after)`'
- en: '[Example 3-5](#_01-functional-java_func-compositor) shows a simple compositor
    implementation that won’t differ much from the JDK’s implementation of equivalent
    methods.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '[Example3-5](#_01-functional-java_func-compositor)显示了一个简单的组合器实现，其与JDK的等效方法实现不会有太大的不同。'
- en: Example 3-5\. Functional Compositor
  id: totrans-195
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-5\. 函数组合器
- en: '[PRE20]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Composing the previous `String` operation from [Example 3-2](#_01-functions_functional-composition_direction)
    with an additional `Consumer<String>` for printing the result is now easy, as
    shown in [Example 3-6](#_01-functional-java_func-compositor-usage):'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 将以前的“String”操作与[Example3-2](#_01-functions_functional-composition_direction)与一个额外的“Consumer<String>”打印结果很容易进行组合，如[Example3-6](#_01-functional-java_func-compositor-usage)所示。
- en: Example 3-6\. Using the Functional Compositor
  id: totrans-198
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例3-6。 使用功能组合器
- en: '[PRE21]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: A simple compositor passing values between functional interfaces is an obvious
    use case for functional composition. Still, it’s useful for other use cases, too,
    like introducing a certain degree of logic and decision-making. For example, you
    could safeguard a `Consumer` with a `Predicate` as shown in [Example 3-7](#_01-functional-java_func-compositor-improved)
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数接口之间传递值的简单组合器是功能组合的明显用例。但它也适用于其他用例，例如引入某种程度的逻辑和决策制定。例如，您可以像在[示例 3-7](#_01-functional-java_func-compositor-improved)中所示的那样使用`Predicate`来保护`Consumer`。
- en: Example 3-7\. Improved Functional Compositor
  id: totrans-201
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-7\. 改进的功能组合器
- en: '[PRE22]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You can fill the gaps left by the JDK by adding new `static` helpers to your
    types as needed. From personal experience, I would suggest only adding helpers
    as required instead of trying to fill the gaps proactively. Only implement what
    you currently need because it can be quite hard to foresee what you need in the
    future. Any additional line of code that’s not used right now will need maintenance
    over time and might need changes or refactoring anyway if you want to use it and
    the actual requirements become clear.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过根据需要向您的类型添加新的`static`帮助程序来填补 JDK 留下的空白。从个人经验来看，我建议仅在需要时添加帮助程序，而不是试图积极填补空白。只实现当前需要的内容，因为很难预见未来需要什么。任何现在没有使用的额外代码行都需要随着时间的推移进行维护，并且如果您希望使用它并且实际需求变得明确，则可能需要更改或重构。
- en: Takeaways
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 要点
- en: 'The JDK provides 40+ functional interfaces because Java’s type system requires
    tangible interfaces for different use cases. The available functional interfaces
    fall into four categories: Functions, Consumers, Suppliers, and Predicates.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JDK 提供了 40 多个功能接口，因为 Java 的类型系统需要不同用例的可触及接口。可用的功能接口分为四类：函数、消费者、供应者和断言。
- en: More specialized functional interface variants exist for arities up to two.
    Method signatures, however, should use their equivalent `super` interface instead
    to maximize compatibility.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存在专门的功能接口变体，适用于高达两个的 arity。然而，方法签名应使用它们的等效`super`接口以最大化兼容性。
- en: Primitives are supported by either using *autoboxing*, or a respective functional
    interface variant for `int`, `long`, `double`, and `boolean`.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用*自动装箱*或用于`int`、`long`、`double`和`boolean`的相应功能接口变体，支持原始类型。
- en: Functional interfaces behave like any other interface and require a common ancestor
    to be used interchangeably. However, bridging the gap between “identical but incompatible”
    functional interfaces is possible by using a method reference of a SAM.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能接口的行为类似于任何其他接口，并且需要一个共同的祖先才能互换使用。但是，通过使用 SAM 的方法引用，可以弥合“相同但不兼容”的功能接口之间的差距。
- en: Adding functional support to your own types is easy. Use `default` methods on
    your interfaces to cover functional use cases without requiring you to change
    any implementations.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将功能支持添加到您自己的类型很容易。使用您的接口上的`default`方法来覆盖功能用例，而无需更改任何实现。
- en: Common or missing functional tasks can be accumulated in a helper type with
    `static` methods.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见或缺失的功能任务可以在具有`static`方法的辅助类型中累积。
- en: ^([1](ch03.xhtml#idm45115249764864-marker)) Varargs method arguments, like `String…​`,
    appear to have a dynamic arity, as the method accepts a non-fixed amount of arguments.
    However, behind the scenes, the arguments are converted to an array, making the
    actual arity one.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch03.xhtml#idm45115249764864-marker)) 可变参数方法参数，如`String…​`，似乎具有动态的 arity，因为该方法接受非固定数量的参数。然而，在幕后，这些参数被转换为数组，使实际的
    arity 为一。
- en: '^([2](ch03.xhtml#idm45115248733296-marker)) The command pattern is one of many
    object-oriented design patterns described by the *gang of four*. Gamma, E., Helm,
    R., Johnson, R., & Vlissides, J. (1994). Design patterns: Elements of reusable
    object-oriented software. Boston, MA: Addison Wesley.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '^([2](ch03.xhtml#idm45115248733296-marker)) 命令模式是由 *四人帮* 描述的许多面向对象设计模式之一。Gamma,
    E., Helm, R., Johnson, R., & Vlissides, J. (1994). Design patterns: Elements of
    reusable object-oriented software. Boston, MA: Addison Wesley.'
- en: ^([3](ch03.xhtml#idm45115248649152-marker)) The shown `Function<T, R>` interface
    is a simplified variant of the [source code](https://github.com/openjdk/jdk/blob/jdk-17+35/src/java.base/share/classes/java/util/function/Function.java)
    present in the JDK to increase readability.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch03.xhtml#idm45115248649152-marker)) 所示的`Function<T, R>`接口是 JDK 中存在的源代码的简化变体，以增加可读性。
