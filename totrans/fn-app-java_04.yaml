- en: Chapter 3\. Functional Interfaces of the JDK
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many functional programming languages only use a singular and dynamic concept
    of “functions” to describe their lambdas, regardless of their arguments, return
    type, or actual use case. Java, on the other hand, is a strictly typed language
    requiring tangible types for everything, including lambdas. That’s why the JDK
    provides you with over 40 readily available functional interfaces in its `java.util.functional`
    package to kickstart your functional toolset.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will show you the most important functional interfaces, explain
    why there are so many variations, and show how you can extend your own code to
    be more functional.
  prefs: []
  type: TYPE_NORMAL
- en: The Big Four Functional Interface Categories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The 40+ functional interfaces in `java.util.functional` fall into four main
    categories with each category representing an essential functional use case:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Functions* accept arguments and return a result.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Consumers* only accept arguments but do not return a result.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Suppliers* do not accept arguments and only return a result.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Predicates* accept arguments to test against an expression and return a `boolean`
    primitive as their result.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These four categories cover many use cases and their names relate to functional
    interface types and their variants.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a look at the four main categories of functional interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Functions with their corresponding `java.util.functional.Function<T, R>` interface,
    are one of the most central functional interfaces. They represent a “classical”
    function with a single input and output, as seen in [Figure 3-1](#_01-functions_big-four_function):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Function<T, R>](assets/afaj_0301.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-1\. `Function<T, R>`
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The single abstract method of `Function<T, R>` is called `apply` and accepts
    an argument of a type `T` and produces a result of type `R`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code shows how to `null`-check and convert a `String` to its
    length as an `Integer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The input type `T` and output type `R` can be identical. However, in [“Function
    Arity”](#_01-functions_function-arity) I discuss specialized functional interface
    variants with identical types.
  prefs: []
  type: TYPE_NORMAL
- en: Consumers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As the name suggests, a Consumer only *consumes* an input parameter but doesn’t
    return anything, as shown in [Figure 3-2](#_01-functions_big-four_consumer). The
    central Consumer functional interface is `java.util.functional.Consumer<T>`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Consumer<T>](assets/afaj_0302.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-2\. `Consumer<T>`
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The single abstract method of `Consumer<T>` is called `accept` and requires
    an argument of a type `T`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code consumes a `String` to print it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Even though the sole consumption of a value in an expression might not fit into
    “pure” functional concepts, it’s an essential component for employing a more functional
    coding style in Java, bridging many gaps between non-functional code and higher-order
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: The `Consumer<T>` interface is similar to the Java 5+ `Callable<V>` found in
    the `java.util.concurrent` package, except the latter, throws a checked exception.
    The concept of checked and unchecked exceptions and their implications for functional
    code in Java will be explored in detail in [Chapter 10](ch10.xhtml#_02-exception-handling).
  prefs: []
  type: TYPE_NORMAL
- en: Suppliers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Suppliers are the antithesis of Consumers. Based around the central functional
    interface `java.util.functional.Supplier<T>`, the different Supplier variants
    don’t accept any input parameters but return a single value of type `T`, as shown
    in [Figure 3-3](#_01-functions_big-four_supplier).
  prefs: []
  type: TYPE_NORMAL
- en: '![Supplier<T>](assets/afaj_0303.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-3\. `Supplier<T>`
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The single abstract method of `Supplier<T>` is called `get`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The following supplier provides a new random value on calling `get()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Suppliers are often used for deferred execution, like wrapping an expensive
    task into them and only calling `get` when needed, as I will discuss in [Chapter 11](ch11.xhtml#_02-lazy-evaluation).
  prefs: []
  type: TYPE_NORMAL
- en: Predicates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Predicates are functions that accept a single argument to be tested against
    its logic and return either `true` or `false`. The syntax for the main functional
    interface `java.util.functional.Predicate<T>` is illustrated in [Figure 3-4](#_01-functions_big-four_predicate).
  prefs: []
  type: TYPE_NORMAL
- en: '![Predicate<T>](assets/afaj_0304.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-4\. `Predicate<T>`
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The single abstract method is called `test` and accepts an argument of a type
    `T` and returns a `boolean` primitive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: It’s the go-to functional interface for decision-making, like `filter` methods
    of the functional pattern *map/filter/reduce* you will learn more about later
    on in [Chapter 6](ch06.xhtml#_02-data-processing).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code tests an `Integer` to be over 9000:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Why So Many Functional Interface Variants?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although the big four categories and their main functional interface representations
    already cover many use cases, there are also variations and more specialized variants
    you can use. All these different types are necessary to fit lambdas into Java
    without a trade-off in backward compatibility. Due to this, though, using lambdas
    in Java is a little bit more complicated than in other languages. Still, integrating
    such a feature without breaking the vast ecosystem is worth it in my opinion.
  prefs: []
  type: TYPE_NORMAL
- en: There are ways to bridge between different functional interfaces, and each variant
    has its own optimal problem context to be used in. Handling so many different
    types might seem intimidating at first, but it will become almost second nature
    to know which type to use for what scenario after using a more functional approach
    for a while.
  prefs: []
  type: TYPE_NORMAL
- en: Function Arity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The concept of *arity* describes the number of operands that a function accepts.
    For example, an arity of one means that a lambda accepts a single argument, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As the number of arguments in Java methods, like a SAM, is fixed^([1](ch03.xhtml#idm45115249764864)),
    there must be an explicit functional interface representing every required arity.
    To support arities higher than one, the JDK includes specialized variants of the
    main functional interface categories that accept arguments, as listed in [Table 3-1](#_01-functions_arity_types).
  prefs: []
  type: TYPE_NORMAL
- en: Table 3-1\. Arity-based Functional Interfaces
  prefs: []
  type: TYPE_NORMAL
- en: '| Arity of one | Arity of two |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Function<T, R>` | `BiFunction<T, U, R>` |'
  prefs: []
  type: TYPE_TB
- en: '| `Consumer<T>` | `BiConsumer<T, U>` |'
  prefs: []
  type: TYPE_TB
- en: '| `Predicate<T>` | `BiPredicate<T, U>` |'
  prefs: []
  type: TYPE_TB
- en: Only functions interfaces with an arity of up to two are supported out-of-the-box.
    Looking at the functional APIs and use cases in Java, arities of one or two cover
    the most common tasks. That’s most likely why the Java language designers decided
    to stop there and didn’t add any higher arities out-of-the-box.
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding higher arities is simple though, like in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: However, I wouldn’t recommend it unless it’s an absolute necessity. As you will
    see throughout this chapter and the book, the included functional interface give
    you a lot of additional functionality through `static` and `default` methods.
    That’s why relying on them ensures the best compatibility and well-understood
    usage patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Functional Operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The concept of operators simplifies the two most commonly used arities by giving
    you functional interfaces with identical generic types. For example, if you require
    a function to accept two `String` arguments to create another `String` value,
    the type definition of `BiFunctuon<String, String, String>` would be quite repetitive.
    Instead, you can use a `BinaryOperator<String>` which is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Implementing a comment super interface allows you to write more concise code
    with more meaningful types.
  prefs: []
  type: TYPE_NORMAL
- en: The available operator functional interfaces are listed in [Table 3-2](#_01-functions_operator_types).
  prefs: []
  type: TYPE_NORMAL
- en: Table 3-2\. Operator Functional Interfaces
  prefs: []
  type: TYPE_NORMAL
- en: '| Arity | Operator | Super Interface |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | `UnaryOperator<T>` | `Function<T, T>` |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | `BinaryOperator<T>` | `BiFunction<T, T, T>` |'
  prefs: []
  type: TYPE_TB
- en: Be aware that operator types and their `super` interface aren’t interchangeable,
    though. That’s especially important when designing APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine a method signature requires a `UnaryOperator<String>` as an argument,
    it won’t be compatible with `Function<String, String>`. However, the other way
    around works, as shown in [Example 3-1](#_01-functions_arity_compatibility).
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-1\. Java arity compatibility
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: That example highlights that you should choose the most common denominator for
    method arguments, in this case, `Function<String, String>`, as they give you the
    most compatibility. Even though it increases the verbosity of your method signatures,
    it’s an acceptable trade-off, in my opinion, because it maximizes usability and
    doesn’t restrict an argument to a specialized functional interface. When creating
    a lambda, on the other hand, the specialized type allows for more concise code
    without losing any expressiveness in your code.
  prefs: []
  type: TYPE_NORMAL
- en: Primitive Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most of the functional interfaces you’ve encountered so far had a generic type
    definition, but that’s not always the case. Primitive types can’t be used as generic
    types (yet). That’s why there are specialized functional interfaces for primitives.
  prefs: []
  type: TYPE_NORMAL
- en: You *could* use any generic functional interface for the object wrapper type
    and let autoboxing take care of the rest. However, auto-boxing isn’t *free*, so
    it can have a performance impact.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Autoboxing and unboxing is the automatic conversion between primitive value
    types and their object-based counterparts so they can be used indiscriminately.
    For example, autoboxing an `int` to an `Integer`. The other way around is called
    unboxing.
  prefs: []
  type: TYPE_NORMAL
- en: That’s why many of the functional interfaces provided by the JDK deal with primitive
    types to avoid autoboxing. Such primitive functional interfaces, like the arity
    specializations, aren’t available for all primitives, though. They are mostly
    concentrated around the numeric primitives `int`, `long`, and `double`.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-3](#_01-functions_primitive-functional-interfaces) lists the available
    functional interfaces for `int`, but there are equivalent interfaces for `long`
    and `double` as well.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 3-3\. Functional Interfaces for the integer primitive
  prefs: []
  type: TYPE_NORMAL
- en: '| Category | Functional Interface | Boxed Alternative |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Functions | `IntFunction<R>` | `Function<Integer, R>` |'
  prefs: []
  type: TYPE_TB
- en: '| `IntUnaryOperator` | `UnaryOperator<Integer>` |'
  prefs: []
  type: TYPE_TB
- en: '| `IntBinaryOperator` | `BinaryOperator<Integer>` |'
  prefs: []
  type: TYPE_TB
- en: '| `ToIntFunction<T>` | `Function<T, Integer>` |'
  prefs: []
  type: TYPE_TB
- en: '| `ToIntBiFunction<T, U>` | `BiFunction<T, U, Integer>` |'
  prefs: []
  type: TYPE_TB
- en: '| `IntToDoubleFunction` | `Function<Integer, Double>` |'
  prefs: []
  type: TYPE_TB
- en: '| `IntToLongFunction` | `Function<Integer, Long>` |'
  prefs: []
  type: TYPE_TB
- en: '| Consumers | `IntConsumer` | `Consumer<Integer>` |'
  prefs: []
  type: TYPE_TB
- en: '| `ObjIntConsumer<T>` | `BiConsumer<T, Integer>` |'
  prefs: []
  type: TYPE_TB
- en: '| Suppliers | `IntSupplier` | `Supplier<Integer>` |'
  prefs: []
  type: TYPE_TB
- en: '| Predicates | `IntPredicate` | `Predicate<Integer>` |'
  prefs: []
  type: TYPE_TB
- en: 'The `boolean` primitive has only a single specialized variant available: `BooleanSupplier`.'
  prefs: []
  type: TYPE_NORMAL
- en: Functional interfaces for primitives aren’t the only special consideration in
    the new functional parts of Java to accommodate primitives. As you will learn
    later in this book, Streams and Optionals provide specialized types, too, to reduce
    the unnecessary overhead incurred by autoboxing.
  prefs: []
  type: TYPE_NORMAL
- en: Bridging Functional Interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Functional interfaces are, well, interfaces, and lambda expressions are concrete
    implementations of these interfaces. Type inference makes it easy to forget that
    you can’t use them interchangeably or simply cast between unrelated interfaces.
    Even if their method signatures are identical, an exception is thrown, as seen
    previously in [“Creating Lambdas”](ch02.xhtml#_01-functional-java_lambdas-in-action-creating):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'From a lambda-based point of view, both SAMs are identical. They both accept
    a `String` argument and return an `boolean` result. For Java’s type-system, though,
    they have no connection whatsoever, making a cast between them impossible. Still,
    the gap between “lambda-compatible but type-incompatible” functional interfaces
    can be bridged by a feature I discussed in the previous chapter: *method references*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'By using a method reference instead of trying to cast between the “identical
    but incompatible” functional interfaces, you can refer to the SAM instead to make
    your code compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Using a method reference creates a new dynamic call site to be invoked by the
    bytecode opcode `invokedynamic` instead of trying to implicitly or explicitly
    cast the functional interface itself.
  prefs: []
  type: TYPE_NORMAL
- en: Like re-finalizing variables that you’ve learned about in [“Re-finalizing a
    Reference”](ch02.xhtml#_01-functions-refinalize), bridging functional interfaces
    with method references is another “band-aid” to deal with code that can’t be refactored
    or redesigned another way. Still, it’s an easy-to-use and sometimes necessary
    tool to have in your functional kit, especially if you’re transitioning from a
    legacy code base to a more functional approach, or work with third-party code
    that provides its own functional interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Functional Composition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functional composition is an essential part of the functional approach to combine
    small functional units into a bigger, more complex task, and Java got you covered.
    However, it’s done in a typical Java fashion to ensure backward compatibility.
    Instead of introducing a new keyword, or changing any language semantics, Java
    uses “glue” methods that are directly implemented on the functional interfaces
    themselves as `default` methods. With their help, you can compose the big four
    categories of functional interfaces easily. Such glue methods build the bridge
    between two functional interfaces by returning a new one with the combined functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of `Function<T, R>`, two `default` methods are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<V> Function<V, R> compose(Function<? super V, ? extends T> before)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<V> Function<T, V> andThen(Function<? super R, ? extends V> after)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The difference between these two methods is the direction of the composition,
    as indicated by the argument names and the returned `Function` and its generic
    types. The first one, `compose`, creates a composed function that applies the
    `before` argument to its input and the result to `this`. The second one, `andThen`,
    is the antagonist to `compose`, as it evaluates `this` and then applies `after`
    to the previous result.
  prefs: []
  type: TYPE_NORMAL
- en: Which direction of functional composition to choose, `compose` or `andThen`,
    depends on the context and personal preference. The call `fn1.compose(fn2)` leads
    to an equivalent call like `fn1(fn2(input))`. To achieve the same flow with the
    `andThen` method, the compositional order must be reversed to a `fn2.andThen(fn1(input))`
    call, as illustrated in [Figure 3-5](#_01-functions_functional-composition_direction-figure).
  prefs: []
  type: TYPE_NORMAL
- en: '![Function<T, R> composition order](assets/afaj_0305.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-5\. Function<T, R> composition order
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Personally, I prefer `andThen(…​)` because the resulting prose-like fluent method
    call-chain mirrors the logical flow of functions that’s easier to grasp for other
    readers that aren’t versed with functional programming naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: Think of manipulating a `String` by removing occurrences of any lowercase “a”
    and uppercasing the result. The overall tasks consist of two `Function<String,
    String>` doing a singular thing. Composing them can be done either way without
    a difference in the final result, if you use the appropriate glue method, as seen
    in [Example 3-2](#_01-functions_functional-composition_direction).
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-2\. Functional composition direction
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Be aware that not every functional interface provides such “glue methods” to
    easily support composition, even if it would be sensible to do so. The following
    list gives you a summary of how the different main interfaces of the big four
    categories support composition out of the box:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Function<T, R>`'
  prefs: []
  type: TYPE_NORMAL
- en: '`Function<T, R>`, and its specialized arities, like `UnaryOperator<T>`, support
    composition in both directions. The `Bi…​` variants only support `andThen`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Predicate<T>`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Predicates support various methods to compose a new Predicate with common operations
    associated with them: `and`, `or`, `negate`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Consumer<T>`'
  prefs: []
  type: TYPE_NORMAL
- en: Only `andThen` is supported, which will compose two Consumers to accept a value
    in sequence.
  prefs: []
  type: TYPE_NORMAL
- en: Specialized primitive functional interfaces
  prefs: []
  type: TYPE_NORMAL
- en: The support for functional composition among the specialized functional interfaces
    for primitives is not on par with their generic brethren. Even among themselves,
    the support differs between the primitive types.
  prefs: []
  type: TYPE_NORMAL
- en: But don’t fret! Writing your own functional compositional helper is easy, as
    I will discuss in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Extending Functional Support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most functional interfaces usually give you more than just their single abstract
    method defining the lambda signature. Usually, they provide additional `default`
    methods to support concepts like functional composition, or `static` helpers to
    simplify common use cases of that type.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can’t change the types of the JDK yourself, you can still make your
    own types more functional instead. There are three approaches you can choose that
    are also used by the JDK itself:'
  prefs: []
  type: TYPE_NORMAL
- en: Add `default` methods to an interface to make existing types more functional.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement a functional interface explicitly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create `static` helpers to provide common functional operations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding Default Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Adding new functionality to an interface always requires you to implement new
    methods on all implementations. When dealing with a small project, it might be
    fine to just update any implementation, but in bigger and shared projects it’s
    often not as easy. In library code it’s even worse, you might break the code of
    anyone using your library. That’s where `default` methods come in to save the
    day.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of solely changing the contract of a type’s interface and letting anyone
    implementing it deal with the fallout — adding the new method on any type that
    implements the interface --⁠, you can use `default` methods to supply a “common-sense”
    implementation. Such an implementation provides a general variant of the intended
    logic to all other types down the line, so you don’t have to throw an `UnsupportedOperationException`.
    This way, your code is backward-compatible because only the interface itself has
    changed, but any type that implements the interface has still a chance to create
    its own, more fitting implementation if necessary. That’s exactly how the JDK
    added Stream-support to any type implementing the interface `java.util.Collection<E>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows the actual `default` methods that give any `Collection`-based
    type Stream capabilities out of the box at no additional (implementation) cost:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The two `default` methods create new `Stream<E>` instances by calling the `static`
    helper `StreamSupport.stream(…​)` and the `default` method `spliterator()`. The
    `spliterator()` is initially defined in `java.util.Iterable<E>` but is overridden
    as necessary, as shown in [Example 3-3](#_01-functional-jdk_default-method-hierarchy).
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-3\. Default Method Hierarchy
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_functional_interfaces_of_the_jdk_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The original definition of `spliterator()` with a common-sense implementation
    based on all the available information for the type.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_functional_interfaces_of_the_jdk_CO1-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The `Collection` interface can use more information to create a more specific
    `Spliterator<E>` that is available to all of its implementations.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_functional_interfaces_of_the_jdk_CO1-5)'
  prefs: []
  type: TYPE_NORMAL
- en: The concrete implementation `ArrayList<E>`, which implements `Collection<E>`
    via `List<E>`, provides an even further specialized `Spliterator<E>`.
  prefs: []
  type: TYPE_NORMAL
- en: A hierarchy of `default` methods gives you the power to add new functionality
    to an interface without breaking any implementations and still providing a common-sense
    variant of the new method. Even if a type never implements a more specific variant
    for itself, it can fall back to the logic provided by the `default` method.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Functional Interfaces Explicitly
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Functional interfaces can be implemented implicitly via lambda or method references,
    but they are also useful when implemented explicitly by one of your types so they
    are usable in higher-order functions. Some of your types might already implement
    one of the retroactively functional interfaces like `java.util.Comparator<T>`
    or `java.lang.Runnable`.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a functional interface directly creates a bridge between previously
    “non-functional” types and their easy usage in functional code. A good example
    is the object-oriented *command design pattern*⁠^([2](ch03.xhtml#idm45115248733296)).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The command pattern encapsulates an action, or “command”, and all data required
    to execute it in an object. This approach decouples the creation of commands from
    consuming them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Usually, a command already has a dedicated interface. Imagine a text editor
    with its common commands like opening a file or saving it. A shared command interface
    between these commands could be as simple as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The concrete command classes would accept the required arguments, but the executed
    command would simply return the updated editor content. If you look closely, you
    see that the interface matches a `Supplier<String>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As I discussed in [“Bridging Functional Interfaces”](#_01-functional-jdk_bridging-functional-interfaces),
    the mere logical equivalency between functional interfaces isn’t enough to create
    compatibility. However, by extending `TextEditorCommand` with `Supplier<String>`,
    you bridge the gap with a `default` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Interfaces allow multiple inheritance, so adding a functional interface shouldn’t
    be an issue. The functional interface’s SAM is a simple `default` method calling
    the actual method doing the work. This way, not a single command needs to be changed
    but all of them gain compatibility with any higher-order function accepting a
    `Supplier<String>` without requiring a method reference as a bridge.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Look out for method signature collisions if existing interfaces implement a
    functional interface, so you don’t accidentally override an existing one.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing one or more functional interfaces is a great way to give your types
    a functional starting point, including all the additional `default` methods available
    on the functional interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Static Helpers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Functional interfaces usually extend their versatility by having `default` methods
    and `static` helpers for common tasks. If you don’t have control over the type,
    though, like a functional interface provided by the JDK itself, you can create
    a helper type accumulating `static` methods.
  prefs: []
  type: TYPE_NORMAL
- en: In [“Functional Composition”](#_01-functional-jdk_functional-composition), I
    discussed functional composition with the help of the available `default` methods
    on the big four interfaces. Even though the most common use cases are covered,
    certain different functional interfaces aren’t covered. You can create them yourself,
    however.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a look at how `Function<T, R>` implements^([3](ch03.xhtml#idm45115248649152))
    its `compose` method in [Example 3-4](#_01-functional-java_func-compoisition_simplified-function-interface),
    so we can develop a compositor helper type to accept other types, too.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-4\. Simplified `Function<T, R>` interface
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_functional_interfaces_of_the_jdk_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The composed function isn’t bound to the original type `T` and introduces `V`
    in its method signature.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_functional_interfaces_of_the_jdk_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: A `null`-check helper to throw a `NullPointerException` on composition and not
    only on the first use of the returned lambda.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_functional_interfaces_of_the_jdk_CO2-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The returned lambda accepts a value of the newly introduced type `V`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_functional_interfaces_of_the_jdk_CO2-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The `before` function is evaluated first.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_functional_interfaces_of_the_jdk_CO2-5)'
  prefs: []
  type: TYPE_NORMAL
- en: The `result` is then applied to the original `Function<T, R>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create your own compositional methods, you have to first think about what
    exactly you want to achieve. The involved functional interfaces and their compositional
    order dictate the overall type chain that the method signature has to reflect:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Function<T, R>#compose(Function<V, T>)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`V` → `T` → `R`'
  prefs: []
  type: TYPE_NORMAL
- en: '`Function<T, R>#andThen(Function<R, V)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`T` → `R` → `V`.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s develop a compositor for `Function<T, R>` and `Supplier`/`Consumer`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Only two combinations are possible because `Supplier` won’t accept arguments,
    so it can’t evaluate the result of the `Function<T, R>`. The opposite reason is
    true for `Supplier`. Because we can’t extend the `Function<T, R>` interface directly,
    an indirect compositor in form of a `static` helper is needed. That leads to the
    following method signatures in which the compositional order is reflected by the
    argument order:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Supplier<R> compose(Supplier<T> before, Function<T, R> fn)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Consumer<T> compose(Function<T, R> fn, Consumer<R> after)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example 3-5](#_01-functional-java_func-compositor) shows a simple compositor
    implementation that won’t differ much from the JDK’s implementation of equivalent
    methods.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-5\. Functional Compositor
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Composing the previous `String` operation from [Example 3-2](#_01-functions_functional-composition_direction)
    with an additional `Consumer<String>` for printing the result is now easy, as
    shown in [Example 3-6](#_01-functional-java_func-compositor-usage):'
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-6\. Using the Functional Compositor
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: A simple compositor passing values between functional interfaces is an obvious
    use case for functional composition. Still, it’s useful for other use cases, too,
    like introducing a certain degree of logic and decision-making. For example, you
    could safeguard a `Consumer` with a `Predicate` as shown in [Example 3-7](#_01-functional-java_func-compositor-improved)
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-7\. Improved Functional Compositor
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: You can fill the gaps left by the JDK by adding new `static` helpers to your
    types as needed. From personal experience, I would suggest only adding helpers
    as required instead of trying to fill the gaps proactively. Only implement what
    you currently need because it can be quite hard to foresee what you need in the
    future. Any additional line of code that’s not used right now will need maintenance
    over time and might need changes or refactoring anyway if you want to use it and
    the actual requirements become clear.
  prefs: []
  type: TYPE_NORMAL
- en: Takeaways
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The JDK provides 40+ functional interfaces because Java’s type system requires
    tangible interfaces for different use cases. The available functional interfaces
    fall into four categories: Functions, Consumers, Suppliers, and Predicates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More specialized functional interface variants exist for arities up to two.
    Method signatures, however, should use their equivalent `super` interface instead
    to maximize compatibility.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Primitives are supported by either using *autoboxing*, or a respective functional
    interface variant for `int`, `long`, `double`, and `boolean`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional interfaces behave like any other interface and require a common ancestor
    to be used interchangeably. However, bridging the gap between “identical but incompatible”
    functional interfaces is possible by using a method reference of a SAM.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding functional support to your own types is easy. Use `default` methods on
    your interfaces to cover functional use cases without requiring you to change
    any implementations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common or missing functional tasks can be accumulated in a helper type with
    `static` methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ^([1](ch03.xhtml#idm45115249764864-marker)) Varargs method arguments, like `String…​`,
    appear to have a dynamic arity, as the method accepts a non-fixed amount of arguments.
    However, behind the scenes, the arguments are converted to an array, making the
    actual arity one.
  prefs: []
  type: TYPE_NORMAL
- en: '^([2](ch03.xhtml#idm45115248733296-marker)) The command pattern is one of many
    object-oriented design patterns described by the *gang of four*. Gamma, E., Helm,
    R., Johnson, R., & Vlissides, J. (1994). Design patterns: Elements of reusable
    object-oriented software. Boston, MA: Addison Wesley.'
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch03.xhtml#idm45115248649152-marker)) The shown `Function<T, R>` interface
    is a simplified variant of the [source code](https://github.com/openjdk/jdk/blob/jdk-17+35/src/java.base/share/classes/java/util/function/Function.java)
    present in the JDK to increase readability.
  prefs: []
  type: TYPE_NORMAL
