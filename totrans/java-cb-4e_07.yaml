- en: Chapter 7\. Structuring Data with Java
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 7.0 Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Almost every application beyond “Hello, World” needs to keep track of some structured
    data. A simple numeric problem might work with three or four numbers only, but
    most applications have groups of similar data items. A GUI-based application may
    need to keep track of a number of dialog windows. A personal information manager,
    or PIM, needs to keep track of a number of, well, persons. An operating system
    needs to keep track of who is allowed to log in, who is currently logged in, and
    what those users are doing. A library needs to keep track of who has books checked
    out and when they’re due. A network server may need to keep track of its active
    clients. A pattern emerges here, and it revolves around variations of what has
    traditionally been called *data* *structuring*.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are data structures in the memory of a running program; there is structure
    in the data in a file on disk, and there is structure in the information stored
    in a database. In this chapter, we concentrate on the first aspect: in-memory
    data. We’ll cover the second aspect in [Chapter 10](ch10.html#javacook-io); the
    third is out of scope for this book.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you had to think about in-memory data, you might want to compare it to a
    collection of index cards in a filing box or to a treasure hunt where each clue
    leads to the next. Or you might think of it like my desk—apparently scattered,
    but actually a very powerful collection filled with meaningful information. Each
    of these is a good analogy for a type of data structuring that Java provides.
    An array is a fixed-length linear collection of data items, like the card filing
    box: it can only hold so much, then it overflows. The treasure hunt is like a
    data structure called a *linked list*. The first release of Java had no standard
    linked list class, but you could write your own traditional data structure classes
    (and still can; you see a DIY linked list implementation in [Recipe 7.8](#javacook-structure-SECT-5)).
    The complex collection represents Java’s `Collection` classes. A document entitled
    *Collections Framework Overview*, distributed with the Java Development Kit documentation
    (and stored therein as file *…/docs/guide/collections/overview.html* [online](http://docs.oracle.com/javase/8/docs/technotes/guides/collections/index.html)),
    provides a detailed discussion of the Collections Framework. The framework aspects
    of Java collections are summarized in [Recipe 7.3](#javacook-structure-collections).'
  prefs: []
  type: TYPE_NORMAL
- en: Beware of typographic issues. The word `Arrays` (in constant width font) refers
    to the class `java.util.Arrays`; but in the normal typeface, the word “arrays”
    is simply the plural of “array” (and will be found capitalized at the beginning
    of a sentence). Also, note that `HashMap` and `HashSet` follow the rule of having
    a midcapital at each word boundary, whereas the older `Hashtable` does not (the
    *t* is not capitalized).
  prefs: []
  type: TYPE_NORMAL
- en: The `java.util` package has become something of a catch-all over the years.
    Besides the legacy date/time API covered in [Recipe 6.9](ch06.html#javacook-dates-legacy),
    several other classes from `java.util` are not covered in this chapter. All the
    classes whose names begin with `Abstract` are, in fact, abstract, and we’ll discuss
    their nonabstract subclasses. The `StringTokenizer` class is covered in [Recipe
    3.1](ch03.html#javacook-strings-SECT-1). `BitSet` is used less frequently than
    some of the classes discussed here and is simple enough to learn on your own.
    `BitSet` stores the bits very compactly in memory, but because it predates the
    Collection API and wasn’t retrofitted, it doesn’t implement any of the standard
    collection interfaces. Also not covered here are `EnumSet` and `EnumMap`, specialized
    for efficient storage/retrieval of enums. These are newer than `BitSet` and *do*
    implement the modern collection interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: We start our discussion of data structuring techniques with one of the oldest
    structures, the array. We’ll discuss the overall structure of `java.util`’s Collections
    Framework. Then we’ll go through a variety of structuring techniques using classes
    from `java.util`.
  prefs: []
  type: TYPE_NORMAL
- en: 7.1 Using Arrays for Data Structuring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to keep track of a fixed amount of information and retrieve it (usually)
    sequentially.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use an array.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Arrays can be used to hold any linear collection of data. The items in an array
    must all be of the same type. You can make an array of any primitive type or any
    object type. For *arrays of primitive types*, such as `int`s and `boolean`s, the
    data is stored in the array. For *arrays of objects*, a reference is stored in
    the array, so the normal rules of reference variables and casting apply. Note
    in particular that if the array is declared as `Object[]`, object references of
    any type can be stored in it without casting, although a valid cast is required
    to take an `Object` reference out and use it as its original type. I’ll say a
    bit more on two-dimensional arrays in [Recipe 7.17](#javacook-structure-SECT-15);
    otherwise, you should treat this as a review example:'
  prefs: []
  type: TYPE_NORMAL
- en: '*main/src/main/java/lang/Array1.java*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Arrays in Java work nicely. The type checking provides reasonable integrity,
    and array bounds are always checked by the runtime system, further contributing
    to reliability.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only problem with arrays is: what if the array fills up and you still have
    data coming in? See [Recipe 7.2](#javacook-structure-SECT-2).'
  prefs: []
  type: TYPE_NORMAL
- en: 7.2 Resizing an Array
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The array filled up, and you got an `ArrayIndexOutOfBoundsException`.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make the array bigger. Or, use an `ArrayList`.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One approach is to allocate the array at a reasonable size to begin with; but
    if you find yourself with more data than will fit, reallocate a new, bigger array
    and copy the elements into it.^([1](ch07.html#idm45290673293208)) Here is code
    that does so:'
  prefs: []
  type: TYPE_NORMAL
- en: '*main/src/main/java/lang/Array2.java*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_structuring_data_with_java_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: A good guess is necessary; know your data!
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_structuring_data_with_java_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The growth factor is arbitary; 2 is a good value here but will continue to double
    exponentially. You might want to use a factor like 1.5, which would mean more
    allocations at the low end but less explosive growth. You need to manage this
    somehow!
  prefs: []
  type: TYPE_NORMAL
- en: This technique works reasonably well for simple or relatively small linear collections
    of data. For data with a more variable structure, you probably want to use a more
    dynamic approach, as in [Recipe 7.4](#javacook-structure-SECT-3).
  prefs: []
  type: TYPE_NORMAL
- en: 7.3 The Collections Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You’re having trouble keeping track of all these lists, sets, and iterators.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There’s a pattern to it. See [Figure 7-1](#javacook-structure-FIG-3) and [Table 7-1](#javacook-structure-TABLE-2).
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`List`, `Set`, `Map`, and `Queue` are the four fundamental data structures
    of the Collections Framework. `List` and `Set` are both sequences, with the difference
    that `List` preserves order and allows duplicate entries, whereas `Set`, true
    to the mathematical concept behind it, does not. `Map` is a key/value store, also
    known as a hash, a dictionary, or an associative store. Queues are, as the same
    suggests, structures that you can push into at one end and pull out from the other.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 7-1](#javacook-structure-TABLE-2) shows some of the important collection-based
    classes from package `java.util`. It is intentionally not 100% complete due to
    space limitations.'
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The javadoc documentation on `Collections`, `Arrays`, `List`, `Set`, and the
    classes that implement them provides more details than there’s room for here.
    [Table 7-1](#javacook-structure-TABLE-2) may further help you to absorb the regularity
    of the Collections Framework.
  prefs: []
  type: TYPE_NORMAL
- en: Table 7-1\. Java collections
  prefs: []
  type: TYPE_NORMAL
- en: '| Interfaces | Implementations |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Resizable array | Hashed table | Linked list | Balanced tree |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: '| `List` | `ArrayList, Vector` |  | `LinkedList` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `Set` |  | `HashSet` |  | `TreeSet` |'
  prefs: []
  type: TYPE_TB
- en: '| `Map` |  | `HashMap, HashTable` |  | `TreeMap` |'
  prefs: []
  type: TYPE_TB
- en: '| `Queue` | `Deque`s, `BlockingQueue`s, etc. |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '[Figure 7-1](#javacook-structure-FIG-3) shows the relationships among several
    of these types.'
  prefs: []
  type: TYPE_NORMAL
- en: '![jcb4 0701](assets/jcb4_0701.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-1\. The Collections Framework: Rectangles are interfaces; ovals classes;
    Solid lines are inheritance; dashed lines represent `implements`'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`Queue` and its subtypes are treated in [Chapter 16](ch16.html#javacook-threads).'
  prefs: []
  type: TYPE_NORMAL
- en: 7.4 Like an Array, but More Dynamic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You don’t want to worry about storage reallocation (often because you don’t
    know how big the incoming dataset is going to be); you want a standard class to
    handle it for you. You want to store your data in any of the `Collection` classes
    defined in [Chapter 7](#javacook-structure) with type safety and without having
    to write downcasts when retrieving data from the collection.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use a `List` implementation or one of the other Collections classes, along with
    Java’s Generic Types mechanism, declaring the `Collection` with a *type parameter*
    identifying the type of your data. The type parameter name appears in angle brackets
    after the declaration and instantiation.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first of the `Collections` classes we will discuss, `ArrayList`, is a standard
    class from `java.util` that encapsulates the functionality of an array but allows
    it to expand automatically. You can just keep on adding things to it, and each
    addition behaves the same. If you watch *really* closely, you might notice a brief
    extra pause once in a while when adding objects as the `ArrayList` reallocates
    and copies. But you don’t have to think about it.
  prefs: []
  type: TYPE_NORMAL
- en: However, because `ArrayList` is a class and isn’t part of the syntax of Java,
    you can’t use Java’s array syntax; you must use methods to access the `ArrayList`’s
    data. It has methods to add objects, retrieve objects, find objects, and tell
    you how big the `List` is and how big it can become without having to reallocate
    (note that the `ArrayList` class is but one implementation of the `List` interface;
    more on that later). Like the other collection classes in `java.util`, `ArrayList`’s
    storing and retrieval methods were originally defined to have parameters and return
    values of `java.lang.Object`. Because `Object` is the ancestor of every defined
    type, you can store objects of any type in a `List` (or any collection) and cast
    it when retrieving it. If you need to store a small number of built-ins (like
    `int` and `float`) into a collection containing other data, use the appropriate
    wrapper class (see the introduction to [Chapter 5](ch05.html#javacook-numbers)).
    To store `boolean`s, either store them directly in a `java.util.BitSet` (see the
    online documentation) or store them in a `List` using the `Boolean` wrapper class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because `Object` is usually too general for accurate work, all modern versions
    of Java provide the *generic types* mechanism. Nowadays, you declare an `ArrayList`
    (or other collection) with a type parameter in angle brackets, and the parameters
    and returns are treated as being of that type by the compiler, ensuring that objects
    of the wrong type don’t make it into your collections, and avoiding the need to
    write casts when retrieving objects. For example, this is how you declare an `ArrayList`
    for holding `String` object references:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: It is a good practice to *declare* the variable as the interface type `List`,
    even though you are *defining* it (constructing it) as an `ArrayList`. This makes
    it easier to change from one `List` implementation to another, and it avoids accidentally
    depending on an implementation-specific method not in the `List` interface (which
    would also make it harder to change the implementation).
  prefs: []
  type: TYPE_NORMAL
- en: The `<>` in the definition part is a vestige of legacy Java versions, in which
    you had to repeat the type definition, so you’d write `new ArrayList<String>()`
    in that example. Nowadays just use `<>` (as in the example) to indicate that you
    want the type copied from the declaration. The <> is called the *diamond operator*.
  prefs: []
  type: TYPE_NORMAL
- en: 'As of Java 13, you can simplify by using the new `var` keyword (for local variables
    only):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[Table 7-2](#javacook-structure-TABLE-1) shows some of the most important methods
    of the `List` interface, which is implemented by `ArrayList` and other `List`
    implementations. This means that the exact same methods can be used with the older
    `Vector` class and several other implementing classes. You’d just have to change
    the name used in the constructor call.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 7-2\. Common List<T> methods
  prefs: []
  type: TYPE_NORMAL
- en: '| Method signature | Usage |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `add(T o)` | Add the given element at the end |'
  prefs: []
  type: TYPE_TB
- en: '| `add(int i, T o)` | Insert the given element at the specified position |'
  prefs: []
  type: TYPE_TB
- en: '| `clear()` | Remove all element references from the `Collection` |'
  prefs: []
  type: TYPE_TB
- en: '| `contains(T o)` | True if the `List` contains the given object |'
  prefs: []
  type: TYPE_TB
- en: '| `forEach(lambda)` | Perform the lambda for each element |'
  prefs: []
  type: TYPE_TB
- en: '| `get(int i)` | Return the object reference at the specified position |'
  prefs: []
  type: TYPE_TB
- en: '| `indexOf(T o)` | Return the index where the given object is found, or –1
    |'
  prefs: []
  type: TYPE_TB
- en: '| `of(T t, …)` | Create a list from multiple objects |'
  prefs: []
  type: TYPE_TB
- en: '| `remove(T o), remove(int i)` | Remove an object by reference or by position
    |'
  prefs: []
  type: TYPE_TB
- en: '| `toArray()` | Return an array containing the objects in the `Collection`
    |'
  prefs: []
  type: TYPE_TB
- en: '`ArrayListDemo` stores data in an `ArrayList` and retrieves it for processing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The older `Vector` and `Hashtable` classes predate the Collections Framework,
    so they offer additional methods with different names: `Vector` provides `addElement()`
    and `elementAt()`. You may still run across these in legacy code, but you should
    use the `Collection` methods `add()` and `get()` instead. Another difference is
    that the methods of `Vector` are synchronized, meaning that they can be accessed
    safely from multiple threads (see [Recipe 16.5](ch16.html#javacook-threads-SECT-5)).
    This does mean more overhead, though, so for single-threaded access it is faster
    to use an `ArrayList` (see timing results in [Recipe 7.19](#javacook-structure-SECT-17)).'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are various conversion methods. [Table 7-2](#javacook-structure-TABLE-1)
    mentions `toArray()`, which will expose the contents of a `List` as an array.
    The `List` interface in Java 9+ features a static `of()` method, which converts
    in the other direction, from an array into a `List`. In conjunction with the variable
    arguments feature of modern Java, you can create and populate a list in one call
    to `List.of()`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In legacy code that you will find in older apps and in web searches, `Arrays.asList()`
    provided this functionality, so you will come across code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Java does indeed get less verbose as time goes by!
  prefs: []
  type: TYPE_NORMAL
- en: You can still instantiate classes such as `ArrayList` without using a specific
    type. In this case, you will get a compiler warning, and the class will behave
    as in the old days; that is, the objects returned from a `Collection` or `Iterator`
    will be of type `java.lang.Object` and must be downcast before you can call any
    class-specific methods or use them in any application-specific method calls.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a further example, consider the `Map` interface mentioned in [Chapter 7](#javacook-structure).
    A `Map` requires a key and a value in its `put()` method. A `Map`, therefore,
    has two parameterized types. To set up a `Map` whose keys are `Person` objects
    and whose values are `Address` objects (assuming these two classes exist in your
    application), you could define it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This `Map` expects a `Person` as its key and an `Address` as its value in the
    `put()` method. The `get()` method returns an `Address` object, the `keySet()`
    method returns `Set<Person>` (i.e., a `Set` specialized for `Person` objects).
    There are also convenience routines for when you want to create a `Map` from existing
    objects. The most useful is several overloads of before existing `Map.of(key,value,key,value…)`
    similar to `List.of()` (but limited to 10 pairs), and so on.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although the generics avoid your having to write downcasts, the casts still
    occur at runtime; they are just provided by the compiler. The compiler techniques
    used in compiling these new constructs in a backward-compatible way include *erasure*
    and *bridging*, topics discussed in [*Java Generics and Collections*](http://shop.oreilly.com/product/9780596527754.do)
    by Maurice Naftalin and Philip Wadler.
  prefs: []
  type: TYPE_NORMAL
- en: 7.5 Using Generic Types in Your Own Class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You wish to define your own container classes using the generic type mechanism
    to avoid needless casting.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Define a class using `<` *`TypeName`* `>` where the container type is declared
    and *`TypeName`* where it is used.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Consider the very simple `Stack` class in [Example 7-1](#javacook-CHP-8-EX-4).
    (We discuss the nature and uses of stack classes in [Recipe 7.16](#javacook-structure-SECT-14).)
  prefs: []
  type: TYPE_NORMAL
- en: This version has been parameterized to take a type whose local name is `T`.
    This type `T` will be the type of the argument of the `push()` method, the return
    type of the `pop()` method, and so on. Because of this return type—more specific
    than the `Object` return type of the original Collections—the return value from
    `pop()` does not need to be downcasted. All containers in the Collections Framework
    (`java.util`) are parameterized similarly.
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-1\. main/src/main/java/structure/MyStack.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The association of a particular type is done at the time the class is instantiated.
    For example, to instantiate a `MyStack` specialized for holding `BankAccount`
    objects, you would need to code only the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If you don’t provide a type parameter `T`, this collection, like the ones in
    `java.util`, will behave as they did in the days before generic collections—accepting
    input arguments of any type, returning `java.lang.Object` from getter methods,
    and requiring downcasting—as their default, backward-compatible behavior. [Example 7-2](#javacook-CHP-8-EX-5)
    shows a program that creates two instances of `MyStack`, one specialized for `String`s
    and one left general. The general one, called `ms2`, is loaded up with the same
    two `String` objects as `ms1` but also includes a `Date` object. The printing
    code is now broken, because it will throw a `ClassCastException`: a `Date` is
    not a `String`. I handle this case specially for pedantic purposes: it is illustrative
    of the kinds of errors you can get into when using nonparameterized container
    classes.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-2\. main/src/main/java/structure/MyStackDemo.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Because of this potential for error, the compiler warns that you have unchecked
    raw types. Like the deprecation warnings discussed in [Recipe 1.9](ch01.html#javacook-getstarted-SECT-9),
    by default, these warnings are not printed in detail by the *javac* compiler (they
    will appear in most IDEs). You ask for them with the rather lengthy option `-Xlint:unchecked`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: I say more about the development and evolution of `MyStack` in [Recipe 7.16](#javacook-structure-SECT-14).
  prefs: []
  type: TYPE_NORMAL
- en: 7.6 How Shall I Iterate Thee? Let Me Enumerate the Ways
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to iterate over some structured data.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Java provides many ways to iterate over collections of data. Here they are,
    in newest-first order:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Stream.forEach()` method (Java 8)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Iterable.forEach()` method (Java 8)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java “foreach” loop (Java 5)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.util.Iterator` (Java 2)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Three-part `for` loop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`while` loop * Enumeration'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pick one and use it. Or learn them all and save!
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A few words on each of the iteration methods are given here. Note that the first
    few are the most common.
  prefs: []
  type: TYPE_NORMAL
- en: Stream.forEach method (Java 8)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Stream` mechanism introduced as part of Java’s functional programming
    provides one of the two most-recent ways of iterating, `Stream.forEach()`, and
    is discussed in [Recipe 9.3](ch09.html#javacook-fp-streams1-1). For now, here’s
    a quick example, using the `BufferedReader` method `lines()` that returns a `Stream`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Iterable.forEach method (Java 8)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The other recent iteration technique is the `Iterable.forEach()` method, added
    in Java 8. This method can be called on any `Iterable` (unfortunately, the array
    class does not yet implement `Iterable`) and takes one argument implementing the
    *functional interface* `java.util.function.Consumer`. Functional interfaces are
    discussed in [Chapter 9](ch09.html#javacook-fp), but here is one example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_structuring_data_with_java_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Declare a `Collection` (a `Collection` is an `Iterable`).
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_structuring_data_with_java_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Populate it with `Arrays.of()` with an array or sequence of objects (see [Recipe
    7.4](#javacook-structure-SECT-3) for how this arbitrary argument list becomes
    an array).
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_structuring_data_with_java_CO2-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Invoke the collection’s `forEach()` method, passing a lambda expression (see
    [Chapter 9](ch09.html#javacook-fp) for a discussion of how `s`→`System.out.println(s)`
    gets mapped to a `Consumer` interface implementation without your even having
    to import this interface).
  prefs: []
  type: TYPE_NORMAL
- en: This style of iteration—sometimes called *internal iteration*—inverts the control
    from the traditional `for` loop; the collection is in charge of when and how the
    iteration works.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Both `Stream.forEach` and `Iterable.forEach()` take one argument, of type `java.util.function.Consumer`,
    so they work largely the same way, at least syntactically. This is intentional.
  prefs: []
  type: TYPE_NORMAL
- en: Java “foreach” loop (Java 5)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is the for-each loop syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The for-each loop is probably the most common style of loop in modern Java code.
    The `Iterable` can be an array or anything that implements `Iterable` (the `Collection`
    implementations included).
  prefs: []
  type: TYPE_NORMAL
- en: This style is used throughout the book. In addition, many third-party frameworks/libraries
    provide their own types that implement `Iterable` for use with the `for` loop.
  prefs: []
  type: TYPE_NORMAL
- en: java.util.Iterator (Java 2)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The older `Iterator` interface has three methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'It was once common to write code like this, which you’ll still find occasionally
    in older code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `remove()` method throws an `UnsupportedOperationException` if called on
    a read-only collection. In conjunction with `Stream`s and default methods, there
    is now a fourth method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Three-part for loop
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is the traditional `for` loop invented by Dennis Ritchie in the early
    1970s for the C language:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Its most common form is with an `int` “index variable” or “loop variable”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: while loop
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A `while` loop executes its loop body as long as (while) the test condition
    is true. It’s commonly used in conjunction with an `Enumeration` or `Iterator`,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Enumeration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An `Enumeration` is like an `Iterator` (shown earlier), but it lacks the `remove()`
    method, and the control methods have longer names—for example, `hasMore​Ele⁠ments()`
    and `nextElement()`. For new code, there is little to recommend implementing `Enumeration`.
  prefs: []
  type: TYPE_NORMAL
- en: 7.7 Eschewing Duplicates with a Set
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want a structure that will avoid storing duplicates.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use a `Set` implementation instead of a `List` (e.g., `Set<String> myNames =
    new HashSet<>()`).
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Set` interface is similar to the `List` interface,^([2](ch07.html#idm45290671381032))
    with methods like `add()`, `remove()`, `contains()`, `size()`, and `isEmpty()`.
    The difference is that it doesn’t preserve order; instead, it enforces uniqueness—if
    you add the same item (as considered by its `equals()` method) twice or more,
    it will only be present once in the set. For this reason, the index-based methods
    such as `add(int, Object)` and `get(int)` are missing from the `Set` implementation:
    you might know that you’ve added seven objects but only five of those were unique,
    so calling `get()` to retrieve the sixth one would have to throw an `ArrayIndexOutOfBoundsException`!
    It’s better not to think of a `Set` as being indexed.'
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'As the Java 7 `Set` document states: “Note: Great care must be exercised if
    mutable objects are used as set elements. The behavior of a set is not specified
    if the value of an object is changed in a manner that affects equals comparisons
    while the object is an element in the set. A special case of this prohibition
    is that it is not permissible for a set to contain itself as an element.”'
  prefs: []
  type: TYPE_NORMAL
- en: 'This code shows a duplicate entry being made to a `Set`, which will contain
    only one copy of the string `"One"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Not surprisingly, only the three distinct values are printed.
  prefs: []
  type: TYPE_NORMAL
- en: If you need a sorted `Set`, there is in fact a `SortedSet` interface, of which
    the most common implementation is a `TreeSet`; see a `TreeSet` example in [Recipe
    7.12](#javacook-structure-SECT-9).
  prefs: []
  type: TYPE_NORMAL
- en: 'As with `List`s, the `Set` interface offers the `of` method as of Java 9:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 7.8 Structuring Data in a Linked List
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your data isn’t suitable for use in an array.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use a linked list; Java’s `LinkedList` class is quite suitable.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Anybody who’s taken Computer Science 101 (or any computer science course) should
    be familiar with data structuring, such as linked lists and binary trees. A linked
    list is commonly used when you have an unpredictably large number of data items,
    you wish to allocate just the right amount of storage, and you want to access
    them in the same order that you created them. [Figure 7-2](#javacook-structure-FIG-1)
    is a diagram showing the normal arrangement.
  prefs: []
  type: TYPE_NORMAL
- en: '![jcb4 0702](assets/jcb4_0702.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-2\. Linked list structure
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Of course, the Collections API provides a `LinkedList` class; here is a simple
    program that uses it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `ListIterator` used here is a subinterface of `Iterator`, which was discussed
    in [Recipe 7.6](#javacook-structure-iterate).
  prefs: []
  type: TYPE_NORMAL
- en: 'Just to show how this kind of list works, here is code that shows part of the
    implemention of a simple linked list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This is just to show how the implementation of a linked list might work. Do
    not use the simple `LinkList` class shown here; use the real one, `java.util.LinkedList`,
    shown in action in the first example.
  prefs: []
  type: TYPE_NORMAL
- en: 7.9 Mapping with Hashtable and HashMap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need a one-way mapping from one data item to another.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use a `HashMap`.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`HashMap` provides a one-way mapping from one set of object references to another.
    They are completely general purpose. I’ve used them to map from Swing push buttons
    to the URL that is to be opened when the button is pushed, to map names to addresses,
    and to implement a simple in-memory cache in a web server. You can map from anything
    to anything. In the following example, we map from company names to addresses;
    the addresses here are `String` objects, but in real life they’d probably be `Address`
    objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'For this version we used both a `for` loop and a `forEach()` loop; the latter
    uses the return from `entrySet()`, a set of `Map.Entry`, each of which contains
    one key and one value (this may be faster on large maps because it avoids going
    back into the map to get the value each time through the loop). If you are modifying
    the list as you are going through it (e.g., removing elements), either inside
    the loop or in another thread, then these forms will fail with a `ConcurrentModificationException`.
    You then need to use the `Iterator` explicitly to control the loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'A more functional (see [Chapter 9](ch09.html#javacook-fp)) way of writing the
    removal, not involving explicit looping, would be this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`HashMap` methods are not synchronized. The older and similar `Hashtable` methods
    are synchronized, for use with multiple threads.'
  prefs: []
  type: TYPE_NORMAL
- en: 7.10 Storing Strings in Properties and Preferences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to store keys and values that are both strings, possibly with persistence
    across runs of a program—for example, program customization.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use a `java.util.prefs.Preferences` object or a `java.util.Properties` object.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here are three approaches to customization based on the user’s environment.
    Java offers `Preferences` and `Properties` for cross-platform customizations.
  prefs: []
  type: TYPE_NORMAL
- en: Preferences
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Preferences` class `java.util.prefs.Preferences` provides an easy-to-use
    mechanism for storing user customizations in a system-dependent way (which might
    mean dot files on Unix, a preferences file on the Mac, or the registry on Windows
    systems). This class provides a hierarchical set of nodes representing a user’s
    preferences. Data is stored in the system-dependent storage format but can also
    be exported to or imported from an XML format. Here is a simple demonstration
    of `Preferences`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run the `PrefsDemo` program the first time, of course, it doesn’t
    find any settings, so the calls to `preferences.get()` return the default values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'On subsequent runs, it finds and returns the user-provided settings (I’ve elided
    the XML output from the second run because most of the XML output is the same):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Properties` class is similar to a `HashMap` or `Hashtable` (it extends
    the latter) but with methods defined specifically for string storage and retrieval
    and for loading/saving. `Properties` objects are used throughout Java, for everything
    from setting the platform font names to customizing user applications into different
    `Locale` settings as part of internationalization and localization. When stored
    on disk, a `Properties` object looks just like a series of `name=value` assignments,
    with optional comments. Comments are added when you edit a `Properties` file by
    hand, ignored when the `Properties` object reads itself, and lost when you ask
    the `Properties` object to save itself to disk. Here is an example of a `Properties`
    file that could be used to internationalize the menus in a GUI-based program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is another example, showing some personalization properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'A `Properties` object can be loaded from a file. The rules are flexible: either
    `=`, :, or spaces can be used after a key name and its values. Spaces after a
    nonspace character are ignored in the key. A backslash can be used to continue
    lines or to escape other characters. Comment lines may begin with either `#` or
    `!`. Thus, a `Properties` file containing the previous items, if prepared by hand,
    could look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Fortunately, when a `Properties` object writes itself to a file, it uses the
    following simple format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example of a program that creates a `Properties` object and adds
    into it the list of companies and their locations from [Recipe 7.9](#javacook-structure-SECT-6).
    It then loads additional properties from disk. To simplify the I/O processing,
    the program assumes that the `Properties` file to be loaded is contained in the
    standard input, as would be done using a command-line redirection on either Unix
    or DOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Running it as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'produces the following output in the file *PropsDemo.out*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In case you didn’t notice in either the `HashMap` or the `Properties` examples,
    the order in which the outputs appear in these examples is neither sorted nor
    in the order we put them in. The hashing classes and the `Properties` subclass
    make no claim about the order in which objects are retrieved. If you need them
    sorted, see [Recipe 7.11](#javacook-structure-SECT-8).
  prefs: []
  type: TYPE_NORMAL
- en: 'As a convenient shortcut, my `FileProperties` class includes a constructor
    that takes a filename:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Note that constructing a `FileProperties` object causes it to be loaded, and
    therefore the constructor may throw a checked exception of class `IOException`.
  prefs: []
  type: TYPE_NORMAL
- en: 7.11 Sorting a Collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You put your data into a collection in random order or used a `Properties` object
    that doesn’t preserve the order, and now you want it sorted.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the static method `Arrays.sort()` or `Collections.sort()`, optionally providing
    a `Comparator`.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If your data is in an array, then you can sort it using the static `sort()`
    method of the `Arrays` utility class. If it is in a `Collection`, you can use
    the static `sort()` method of the `Collections` class. Here is a set of strings
    being sorted in place in an `Array`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'What if the default sort order isn’t what you want? Well, you can create an
    object that implements the `Comparator<T>` interface and pass that as the second
    argument to sort. Fortunately, for the most common ordering next to the default,
    you don’t have to: a public constant `String.CASE_INSENSITIVE_ORDER` can be passed
    as this second argument. The `String` class defines it as a `Comparator<String>`
    that orders `String` objects as by `compareToIgnoreCase`. But if you need something
    fancier, you probably need to write a `Comparator<T>`. In some cases you may be
    able to use the `Comparator.comparing()` method and other static methods on `Comparator`
    to create a custom comparator without having to create a class. Suppose that,
    for some strange reason, you need to sort strings using all but the first character
    of the string. One way to do this would be to write this `Comparator<String>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Using it is just a matter of passing it as the `Comparator` argument to the
    correct form of `sort()`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, a more functional (see [Chapter 9](ch09.html#javacook-fp)) way of writing
    this might be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output of running it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: And this is all as it should be.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, you may be writing a class and want to build in the comparison
    functionality so that you don’t always have to remember to pass the `Comparator`
    with it. In this case, you can directly implement the `java.lang.Comparable` interface,
    as is done by many classes in the standard API. These include `String` class;
    the wrapper classes `Byte`, `Character`, `Double`, `Float`, `Long`, `Short`, and
    `Integer`; `BigInteger` and `BigDecimal` from `java.math`; most objects in the
    date/time API in `java.time`; and `java.text.CollationKey`. Arrays or `Collections`
    of these types can be sorted without providing a `Comparator`. Classes that implement
    `Comparable` are said to have a natural ordering. The documentation strongly recommends
    that a class’s natural ordering be consistent with its `equals()` method. It is
    consistent with `equals()` if and only if `e1.compareTo((Object)e2)` has the same
    Boolean value as `e1.equals((Object)e2)` for every instance `e1` and `e2` of the
    given class. This means that if you implement `Comparable`, you should also implement
    `equals()`, and the logic of `equals()` should be consistent with the logic of
    the `compareTo()` method. If you implement `equals()`, incidentally, you also
    should implement `hashCode()` (as discussed in [“hashCode() and equals()”](ch08.html#javacook-oo-SECT-2.x.1)).
    Here, for example, is part of the appointment class `Appt` from a hypothetical
    scheduling program. The class has a `LocalDate` date variable and a `LocalTime`
    time variable; the latter may be null (e.g., an all-day appointment or a to-do
    item); this complicates the `compareTo()` function a little.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: If you’re still confused between `Comparable` and `Comparator`, you’re probably
    not alone. [Table 7-3](#javacook-structure-compcompcomp) summarizes the two comparison
    interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Table 7-3\. Comparable compared with Comparator
  prefs: []
  type: TYPE_NORMAL
- en: '| Interface name | Description | Method(s) |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `java.lang.Comparable<T>` | Provides a natural ordering to objects. Written
    in the class whose objects are being sorted. | `int compareTo(T o);` |'
  prefs: []
  type: TYPE_TB
- en: '| `java.util.Comparator<T>` | Provides total control over sorting objects of
    another class. Standalone strategy object; pass to `sort()` method or `Collection`
    constructor. | `int compare(T o1, T o2); boolean equals(T c2)` |'
  prefs: []
  type: TYPE_TB
- en: 7.12 Avoiding the Urge to Sort
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your data needs to be sorted, but you don’t want to stop and sort it periodically.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Not everything that requires order requires an explicit *sort* operation. Just
    keep the data sorted at all times.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can avoid the overhead and elapsed time of an explicit sorting operation
    by ensuring that the data is in the correct order at all times, though this may
    or may not be faster overall, depending on your data and how you choose to keep
    it sorted. You can keep it sorted either manually or by using a `TreeSet` or a
    `TreeMap`. First, here is some code from a call tracking program that I first
    wrote on the very first public release of Java (the code has been modernized slightly!)
    to keep track of people I had extended contact with. Far less functional than
    a Rolodex, my `CallTrack` program maintained a list of people sorted by last name
    and first name. It also had the city, phone number, and email address of each
    person. Here is a very small portion of the code surrounding the event handling
    for the New User push button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This code uses the `String` class `compareTo(String)` routine.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This code uses a linear search, which was fine for the original application
    but could get very slow on large lists (it is *O(n)*). You’d need to use hashing
    or a binary search to find where to put the values on large lists.
  prefs: []
  type: TYPE_NORMAL
- en: 'If I were writing this code today, I might well use a `TreeSet` (which keeps
    objects in order) or a `TreeMap` (which keeps the keys in order and maps from
    keys to values; the keys would be the name and the values would be the `Person`
    objects). Both insert the objects into a tree in the correct order, so an `Iterator`
    that traverses the tree always returns the objects in sorted order. In addition,
    they have methods such as `headSet()` and `headMap()`, which give a new `Set`
    or `Map` of objects of the same class, containing the objects lexically before
    a given value. The `tailSet()` and `tailMap()` methods, similarly, return objects
    greater than a given value, and `subSet()` and `subMap()` return a range. The
    `first()` and `last()` methods retrieve the obvious components from the collection.
    The following program uses a `TreeSet` to sort some names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'One last point to note is that if you have a `Hashtable` or `HashMap`, you
    can convert it to a `TreeMap`, and therefore get it sorted, just by passing it
    to the `TreeMap` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 7.13 Finding an Object in a Collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to see whether a given collection contains a particular value.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ask the collection if it contains an object of the given value.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you have created the contents of a collection, you probably know what is
    in it and what is not. But if the collection is prepared by another part of a
    large application, or even if you’ve just been putting objects into it and now
    need to find out if a given value was found, this recipe’s for you. There is quite
    a variety of methods, depending on which collection class you have. The methods
    in [Table 7-4](#javacook-structure-collectionmethods) can be used.
  prefs: []
  type: TYPE_NORMAL
- en: Table 7-4\. Finding objects in a collection
  prefs: []
  type: TYPE_NORMAL
- en: '| Method(s) | Meaning | Implementing classes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `binarySearch()` | Fairly fast search | `Arrays`, `Collections` |'
  prefs: []
  type: TYPE_TB
- en: '| `contains()` | Search | `ArrayList`, `HashSet`, `Hashtable`, `LinkList`,
    `Properties`, `Vector` |'
  prefs: []
  type: TYPE_TB
- en: '| `containsKey()`, `containsValue()` | Checks if the collection contains the
    object as a `Key` or as a `Value` | `HashMap`, `Hashtable`, `Properties`, `TreeMap`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `indexOf()` | Returns location where object is found | `ArrayList`, `LinkedList`,
    `List`, `Stack`, `Vector` |'
  prefs: []
  type: TYPE_TB
- en: '| `search()` | Search | `Stack` |'
  prefs: []
  type: TYPE_TB
- en: The methods whose names start with `contains` will use a linear search if the
    collection is a collection (`List`, `Set`) but will be quite fast if the collection
    is hashed (`HashSet`, `HashMap`). So you do have to know what implementation is
    being used in order to think about performance, particularly when the collection
    is (or is likely to grow) large.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next example plays a little game of find the hidden number (or needle in
    a haystack): the numbers to look through are stored in an array. As games go,
    it’s fairly pathetic: the computer plays against itself, so you probably know
    who’s going to win. I wrote it that way so I would know that the data array contains
    valid numbers. The interesting part is not the generation of the random numbers
    (discussed in [Recipe 5.9](ch05.html#javacook-numbers-SECT-13)). The array to
    be used with `Arrays.binarySearch()` must be in sorted order, but because we just
    filled it with random numbers, it isn’t initially sorted. Hence, we call `Arrays.sort()`
    on the array. Then we are in a position to call `Arrays.binarySearch()`, passing
    in the array and the value to look for. If you run the program with a number,
    it runs that many games and reports on how it fared overall. If you don’t bother,
    it plays only one game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '`Collections.binarySearch()` works almost exactly the same way, except it looks
    in a `Collection`, which must be sorted (presumably using `Collections.sort`,
    as discussed in [Recipe 7.11](#javacook-structure-SECT-8)).'
  prefs: []
  type: TYPE_NORMAL
- en: 7.14 Converting a Collection to an Array
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have a `Collection` but you need a Java language array.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the `Collection` method `toArray()`.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you have an `ArrayList` or other `Collection` and you need an array, you
    can get it just by calling the `Collection`’s `toArray()` method. With no arguments,
    you get an array whose type is `Object[]`. You can optionally provide an array
    argument, which is used for two purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: The type of the array argument determines the type of array returned.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the array is big enough (and you can ensure that it is by allocating the
    array based on the `Collection`’s `size()` method), then this array is filled
    and returned. If the array is not big enough, a new array is allocated instead.
    If you provide an array and objects in the `Collection` cannot be cast to this
    type, then you will get an `ArrayStoreException`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example 7-3](#javacook-structure-EX-1) shows code for converting an `ArrayList`
    to an array of type `Object`.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-3\. main/src/main/java/structure/ToArray.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 7.15 Making Your Data Iterable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have written your own data structure, and you want to publish the data to
    be iterable so it can be used in the for-each loop.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Make your data class `Iterable`: this interace has only one method, `iterator()`.
    Write your own `Iterator`. Just implement (or provide an inner class that implements)
    the `Iterator` interface.'
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To be usable in the modern Java for-each loop, your data class must implement
    `Iterable`, a simple interface with one method, `Iterator<T> iterator()`. Whether
    you use this interface or want to use the older `Iterator` interface directly,
    the way to make data from one part of your program available in a storage-independent
    way to other parts of the code is to generate an `Iterator`. Here is a short program
    that constructs, upon request, an `Iterator` for some data that it is storing—in
    this case, in an array. The `Iterator` interface has only three methods—`hasNext()`,
    `next()`, and `remove()`—demonstrated in [Example 7-4](#javacook-structure-EX-42).
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-4\. main/src/main/java/structure//IterableDemo
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The comments on the `remove()` method remind me of an interesting point. This
    interface introduces `java.util`’s attempt at something Java doesn’t really have,
    the optional method. Because there is no syntax for this, and they didn’t want
    to introduce any new syntax, the developers of the Collections Framework decided
    on an implementation using existing syntax. Optional methods that are not implemented
    are required to throw an `UnsupportedOperationException` if they ever get called.
    My `remove()` method does just that. Note that `UnsupportedOperationException`
    is subclassed from `RuntimeException`, so it is not required to be declared or
    caught.
  prefs: []
  type: TYPE_NORMAL
- en: This code is simplistic, but it does show the syntax and demonstrates how the
    `Iterator` interface works. In real code, the `Iterator` and the data are usually
    separate objects (the `Iterator` might be an inner class from the data store class).
    Also, you don’t even need to write this code for an array; you can just construct
    an `ArrayList` object, copy the array elements into it, and ask it to provide
    the `Iterator`. However, I believe it’s worth showing this simple example of the
    internals of an `Iterator` so that you can understand both how it works and how
    you could provide one for a more sophisticated data structure, should the need
    arise.
  prefs: []
  type: TYPE_NORMAL
- en: The `Iterable` interface has only one nondefault method, `iterator()`, which
    must provide an `Iterator` for objects of the given type. Because the `ArrayIterator`
    class implements this as well, we can use an object of type `ArrayIterator` in
    a “foreach” loop, as in [Example 7-5](#javacook-structure-EX-123).
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-5\. *main/src/main/java/structure/ArrayIteratorDemo.java*
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Java 8 Iterable.foreach
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Java 8 adds `foreach` to the `Iterator` interface, a *default method* (discussed
    in [Recipe 9.0](ch09.html#javacook-fp-intro)) that you don’t have to write. Thus,
    without changing the `ArrayIterator`, after moving to Java 8 we can use the newest-style
    loop, `Iterator.foreach(Consumer)`, with a lambda expression (see [Chapter 9](ch09.html#javacook-fp))
    to print each element (see [Example 7-5](#javacook-structure-EX-123)).
  prefs: []
  type: TYPE_NORMAL
- en: 7.16 Using a Stack of Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to process data in the order of last in, first out (LIFO) or most recently
    added.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Write your own code for creating a stack; it’s easy. Or, use a `java.util.Stack`.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to put things into a holding area quickly and retrieve them in last-in,
    first-out order. This is a common data structuring operation and is often used
    to reverse the order of objects. The basic operations of any stack are `push()`
    (add to stack), `pop()` (remove from stack), and `peek()` (examine top element
    without removing). `ToyStack` in [Example 7-6](#javacook-structure-toystack) is
    a simple class for stacking values of the primitive type `int`. I’ll expand it
    in a page or two to allow stacking of user-defined objects.
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-6\. main/src/main/java/structure/ToyStack.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: If you are not familiar with the basic idea of a stack, you should work through
    the code here; if you are familiar with it, you can skip ahead. While looking
    at it, of course, think about what happens if `pop()` or `peek()` is called when
    `push()` has never been called or if `push()` is called to stack more data than
    will fit.
  prefs: []
  type: TYPE_NORMAL
- en: 'While working on `ToyStack2` (not shown but in the online source), I extracted
    its interface into `SimpleStack`, which just lists the operations. At the same
    time I added the `empty()` method for some compatibility with the standard `java.util.Stack`
    class. And importantly, I made it a generic type, so it can be used with values
    of any type. This is shown in `SimpleStack`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'I then made another demo stack class, `MyStack`, to implement the new interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: This version has a lot more error checking (and a unit test, in the *src/test/java/structure*
    folder), as well as some additional methods not in the original. One example is
    `hasRoom()`. Unlike the full-blown `java.util.Stack`, `MyStack` does not expand
    beyond its original size, so we need a way to see if it is full without throwing
    an exception.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you see how a stack works, I recommend using the provided `java.util.Stack`
    instead of my demo versions; it is more fully fleshed out, more fully tested,
    and widely used. Unlike the major Collections API components `List`, `Set`, and
    `Map`, `java.util.Stack` does not have an interface and implementation class(es);
    it is based on `Vector`, which is a `List` implementation. The real `java.util.Stack`
    works in a similar manner to mine but has more methods and more flexibility. To
    see that in operation, [Recipe 5.12](ch05.html#javacook-numbers-SECT-19) provides
    a simple stack-based numeric calculator.
  prefs: []
  type: TYPE_NORMAL
- en: 7.17 Multidimensional Structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need a multidimensional array or `ArrayList`.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: No problem. Java supports this.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned back in [Recipe 7.1](#javacook-structure-SECT-1), Java arrays can
    hold any reference type. Because an array is a reference type, it follows that
    you can have arrays of arrays or, in other terminology, *multidimensional* arrays.
    Further, because each array has its own length attribute, the columns of a two-dimensional
    array, for example, do not all have to be the same length (see [Figure 7-3](#javacook-structure-FIG-2)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is code to allocate a couple of two-dimensional arrays, one using a loop
    and the other using an initializer. Both are selectively printed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '![jcb4 0703](assets/jcb4_0703.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-3\. Multidimensional arrays
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Running it produces this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The same kind of logic can be applied to any of the `Collections`. You could
    have an `ArrayList` of `ArrayLists`, or a `Vector` of linked lists, or whatever
    your little heart desires.
  prefs: []
  type: TYPE_NORMAL
- en: As [Figure 7-3](#javacook-structure-FIG-2) shows, it is not necessary for the
    array to be regular (i.e., it’s possible for each column of the 2D array to have
    a different height). That is why I used `array[0].length` for the length of the
    first column in the code example.
  prefs: []
  type: TYPE_NORMAL
- en: 7.18 Simplifying Data Objects with Lombok or Record
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You waste time writing data classes that are Plain Old Java Objects (POJO),
    with boilerplate code such as setters and getters, `equals()`, and `toString()`.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use Lombok to autogenerate boilerplate methods. In Java 14+, use the new `record`
    data type, which generates the boilerplate methods for you.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When Java was new, before there were good IDEs, developers had to write getters
    and setters by hand, or by copy-paste-change. Back then I did a study of one existing
    large code base and found about a 1/2% failure rate. The setter stored the value
    in the wrong place or the getter retrieved the wrong value. Assuming random distribution,
    this meant that one getter call in a hundred gave the wrong answer! The application
    still worked, so I must assume those wrong answers didn’t matter.
  prefs: []
  type: TYPE_NORMAL
- en: Now we have IDEs that can generate all the boilerplate methods such as setters/getters,
    equals, `toString()`, and so on. But you still have to remember to invoke these
    generators.
  prefs: []
  type: TYPE_NORMAL
- en: Lombok
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Project Lombok provides one solution. It reads your *.class* files looking for
    its own annotations and, when it finds them, rewrites the class files to have
    the chosen methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use Lombok, you need to add the dependency `org.projectlombok:lombok:1.18.4`
    (or newer) to your build script. Or, if you are using an IDE, download the Lombok
    JAR file from [*https://projectlombok.org*](https://projectlombok.org) and install
    it as per the instructions there. Then you can annotate your class with annotations
    like these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Presto! No more forgetting to generate these methods; Lombok will do the work
    for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other annotations include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: For data classes, there is even `@Data`, which is a shortcut for `@ToString`,
    `@EqualsAndHashCode`, `@Getter` on all fields, `@Setter` on all nonfinal fields,
    and `@RequiredArgsConstructor`!
  prefs: []
  type: TYPE_NORMAL
- en: Java 14 record (preview)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The new `record` type provides another solution. A `record` is a class-like
    construct for data classes, a restricted form of class like enums and annotations.
    You need only write the name of a data object and its fields, and the compiler
    will provide a constructor, getters, `hashCode()` and `equals()`, and `toString()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The provided constructor has the same signature as the record declaration.
    All fields are implicitly final, and the `record` provides getters but not setters.
    The getters have the name of the field; they do not follow the JavaBeans *getName()*
    pattern. Immutable objects are important for reliable code (see [Recipe 9.0](ch09.html#javacook-fp-intro)).
    You can provide other members such as extra constructors, static fields, and static
    or instance methods. Records cannot be abstract and cannot declare additional
    instance fields. All in keeping with the fact that the state of the object is
    as declared in the `record` header. Here I create a `Person` record and make an
    instance of it, all in JShell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'One-line record definitions typically don’t need to be in a source file all
    their own. To show a complete example, I baked the `Person` record into a new
    demo program `PersonRecordDemo`. We can save this into a file, compile it with
    *javac*, and then use *javap* to view the class’s structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The *$* in the filename has to be escaped from the Unix shell. We see that the
    compiler has generated the constructor, `toString()`, `hashCode()` and `equals()`,
    and read-only accessors `name()` and `email()`.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As of Java 14 the `record` mechanism is a preview, so it may change from what
    is described here or might even (however unlikely) not appear in the final Java
    14 or in a future Java release (though we hope it will appear as is, nonpreview,
    in Java 15). If you are using Java 14 you need the `--enable-preview` option on
    commands like *javap*, *javac*, and *jshell*, as well as `--source 14` on commands
    that read the source file.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The original description of and rationale for the `record` mechanism is in [Java
    Enhancement Proposal JEP-359](https://openjdk.java.net/jeps/359) at OpenJDK.net.
  prefs: []
  type: TYPE_NORMAL
- en: '7.19 Program: Timing Comparisons'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'New developers sometimes worry about the overhead of these collections and
    think they should use arrays instead of data structures. To investigate, I wrote
    a program that creates and accesses 250,000 objects, once through a Java array
    and again through an `ArrayList`. This is a lot more objects than most programs
    use. First the code for the `Array` version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'And here’s the code for the `ArrayList` version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The `Vector`-based version, `ArrayVec`, is sufficiently similar that I don’t
    feel the need to kill a tree reprinting its code—it’s online.
  prefs: []
  type: TYPE_NORMAL
- en: How can we time this? As covered in [Recipe 17.7](ch17.html#javacook-reflection-SECT-5),
    you can either use the operating system’s *time* command, if available, or just
    use a bit of Java that times a run of your main program. To be portable, I chose
    to use the latter on an older, slower machine. Its exact speed doesn’t matter
    because the important thing is to compare only versions of this program running
    on the same machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally (drum roll, please), the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Notice that I have ignored one oft-quoted bit of advice that recommends giving
    a good initial estimate on the size of the `ArrayList`. I did time it that way
    as well; in this example, it made a difference of less than 4% in the total runtime.
  prefs: []
  type: TYPE_NORMAL
- en: The bottom line is that the efficiency of `ArrayList` is not totally awful compared
    to arrays. Obviously there is more overhead in calling a “get” method than in
    retrieving an element from an array. The overhead of objects whose methods actually
    do some computation probably outweighs the overhead of fetching and storing objects
    in an `ArrayList` rather than in an `Array`. Unless you are dealing with large
    numbers of objects, you may not need to worry about it. `Vector` is slightly slower
    but still only about two-thirds the speed of the original array version. If you
    are concerned about the time, once the finished size of the `ArrayList` is known,
    you can convert the `ArrayList` to an array (see [Recipe 7.14](#javacook-structure-SECT-12)).
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch07.html#idm45290673293208-marker)) You could copy it yourself using
    a `for` loop if you wish, but `System.arrayCopy()` is likely to be faster because
    it’s implemented in native code.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch07.html#idm45290671381032-marker)) Both `List` and `Set` extend `Collection`.
  prefs: []
  type: TYPE_NORMAL
