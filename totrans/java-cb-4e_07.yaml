- en: Chapter 7\. Structuring Data with Java
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章 用Java结构化数据
- en: 7.0 Introduction
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.0 引言
- en: Almost every application beyond “Hello, World” needs to keep track of some structured
    data. A simple numeric problem might work with three or four numbers only, but
    most applications have groups of similar data items. A GUI-based application may
    need to keep track of a number of dialog windows. A personal information manager,
    or PIM, needs to keep track of a number of, well, persons. An operating system
    needs to keep track of who is allowed to log in, who is currently logged in, and
    what those users are doing. A library needs to keep track of who has books checked
    out and when they’re due. A network server may need to keep track of its active
    clients. A pattern emerges here, and it revolves around variations of what has
    traditionally been called *data* *structuring*.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每个超出“Hello, World”的应用程序都需要跟踪一些结构化数据。一个简单的数值问题可能只涉及三四个数字，但大多数应用程序有一组类似的数据项。基于
    GUI 的应用程序可能需要跟踪多个对话框窗口。个人信息管理器（PIM）需要跟踪多个人的信息。操作系统需要跟踪谁有登录权限，当前谁已登录以及这些用户正在做什么。图书馆需要跟踪借出书籍的人以及归还日期。网络服务器可能需要跟踪其活跃客户端。这里出现了一个模式，围绕传统称为*数据*
    *结构化*的变体。
- en: 'There are data structures in the memory of a running program; there is structure
    in the data in a file on disk, and there is structure in the information stored
    in a database. In this chapter, we concentrate on the first aspect: in-memory
    data. We’ll cover the second aspect in [Chapter 10](ch10.html#javacook-io); the
    third is out of scope for this book.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行程序的内存中存在数据结构；在磁盘文件中的数据中存在结构；以及存储在数据库中的信息也有结构。在本章中，我们集中讨论第一个方面：内存中的数据。我们将在[第10章](ch10.html#javacook-io)中讨论第二个方面；第三个方面不在本书的范围之内。
- en: 'If you had to think about in-memory data, you might want to compare it to a
    collection of index cards in a filing box or to a treasure hunt where each clue
    leads to the next. Or you might think of it like my desk—apparently scattered,
    but actually a very powerful collection filled with meaningful information. Each
    of these is a good analogy for a type of data structuring that Java provides.
    An array is a fixed-length linear collection of data items, like the card filing
    box: it can only hold so much, then it overflows. The treasure hunt is like a
    data structure called a *linked list*. The first release of Java had no standard
    linked list class, but you could write your own traditional data structure classes
    (and still can; you see a DIY linked list implementation in [Recipe 7.8](#javacook-structure-SECT-5)).
    The complex collection represents Java’s `Collection` classes. A document entitled
    *Collections Framework Overview*, distributed with the Java Development Kit documentation
    (and stored therein as file *…/docs/guide/collections/overview.html* [online](http://docs.oracle.com/javase/8/docs/technotes/guides/collections/index.html)),
    provides a detailed discussion of the Collections Framework. The framework aspects
    of Java collections are summarized in [Recipe 7.3](#javacook-structure-collections).'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要考虑内存中的数据，你可能想把它比作存放在文件盒中的索引卡集合，或者像一场寻宝游戏，每一个线索都指向下一个。或者你可以把它想象成我的书桌——看似散乱，实际上是一个充满有意义信息的强大集合。每一个都是Java提供的数据结构化类型的好比喻。数组是一种固定长度的线性数据项集合，就像卡片文件盒：它只能容纳那么多，然后溢出。寻宝游戏就像一个称为*链表*的数据结构。Java的第一个发布版本没有标准链表类，但你可以编写自己的传统数据结构类（现在仍然可以；你可以在[食谱7.8](#javacook-structure-SECT-5)看到DIY链表的实现）。复杂的集合代表了Java的`Collection`类。名为*Collections
    Framework Overview*的文档，分布在Java开发工具包文档中（并存储在文件*…/docs/guide/collections/overview.html*
    [在线链接](http://docs.oracle.com/javase/8/docs/technotes/guides/collections/index.html)），详细讨论了集合框架。Java集合框架的框架方面在[食谱7.3](#javacook-structure-collections)中总结。
- en: Beware of typographic issues. The word `Arrays` (in constant width font) refers
    to the class `java.util.Arrays`; but in the normal typeface, the word “arrays”
    is simply the plural of “array” (and will be found capitalized at the beginning
    of a sentence). Also, note that `HashMap` and `HashSet` follow the rule of having
    a midcapital at each word boundary, whereas the older `Hashtable` does not (the
    *t* is not capitalized).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 警惕印刷问题。以常宽字体书写的`Arrays`指的是`java.util.Arrays`类；而在正常字体中，“arrays”仅仅是“array”的复数形式（并且会在句首大写）。此外，请注意，`HashMap`和`HashSet`遵循每个单词边界都有大写字母的规则，而旧的`Hashtable`不遵循这一规则（*t*不大写）。
- en: The `java.util` package has become something of a catch-all over the years.
    Besides the legacy date/time API covered in [Recipe 6.9](ch06.html#javacook-dates-legacy),
    several other classes from `java.util` are not covered in this chapter. All the
    classes whose names begin with `Abstract` are, in fact, abstract, and we’ll discuss
    their nonabstract subclasses. The `StringTokenizer` class is covered in [Recipe
    3.1](ch03.html#javacook-strings-SECT-1). `BitSet` is used less frequently than
    some of the classes discussed here and is simple enough to learn on your own.
    `BitSet` stores the bits very compactly in memory, but because it predates the
    Collection API and wasn’t retrofitted, it doesn’t implement any of the standard
    collection interfaces. Also not covered here are `EnumSet` and `EnumMap`, specialized
    for efficient storage/retrieval of enums. These are newer than `BitSet` and *do*
    implement the modern collection interfaces.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，`java.util`包已经成为一个大杂烩。除了在[Recipe 6.9](ch06.html#javacook-dates-legacy)中涵盖的遗留日期/时间API外，`java.util`中还有几个其他类未在本章中涵盖。所有以`Abstract`开头的类实际上都是抽象的，我们将讨论它们的非抽象子类。`StringTokenizer`类在[Recipe
    3.1](ch03.html#javacook-strings-SECT-1)中有所涵盖。`BitSet`比本章讨论的某些类使用频率低，并且足够简单，可以自行学习。`BitSet`在内存中非常紧凑地存储位，但因为它早于Collection
    API并且没有进行后续更新，所以它没有实现任何标准的集合接口。还未在此处涵盖的是`EnumSet`和`EnumMap`，这些专门用于枚举的高效存储/检索。它们比`BitSet`更新，*确实*实现了现代集合接口。
- en: We start our discussion of data structuring techniques with one of the oldest
    structures, the array. We’ll discuss the overall structure of `java.util`’s Collections
    Framework. Then we’ll go through a variety of structuring techniques using classes
    from `java.util`.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从数据结构技术讨论开始，其中一个最古老的结构是数组。我们将讨论`java.util`集合框架的总体结构。然后我们将通过使用`java.util`中的类进行各种结构化技术的讨论。
- en: 7.1 Using Arrays for Data Structuring
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.1 使用数组进行数据结构化
- en: Problem
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to keep track of a fixed amount of information and retrieve it (usually)
    sequentially.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要跟踪一定量的信息并（通常）按顺序检索它。
- en: Solution
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use an array.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数组。
- en: Discussion
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'Arrays can be used to hold any linear collection of data. The items in an array
    must all be of the same type. You can make an array of any primitive type or any
    object type. For *arrays of primitive types*, such as `int`s and `boolean`s, the
    data is stored in the array. For *arrays of objects*, a reference is stored in
    the array, so the normal rules of reference variables and casting apply. Note
    in particular that if the array is declared as `Object[]`, object references of
    any type can be stored in it without casting, although a valid cast is required
    to take an `Object` reference out and use it as its original type. I’ll say a
    bit more on two-dimensional arrays in [Recipe 7.17](#javacook-structure-SECT-15);
    otherwise, you should treat this as a review example:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 数组可以用来保存任何线性的数据集合。数组中的项必须是相同类型的。您可以创建任何原始类型或对象类型的数组。对于*原始类型的数组*（如`int`和`boolean`），数据存储在数组中。对于*对象数组*，存储的是引用，因此适用于引用变量和转型的常规规则。特别要注意的是，如果数组声明为`Object[]`，则可以在其中存储任何类型的对象引用，而无需转型，尽管在将`Object`引用取出并用作其原始类型时需要有效的转型。在[Recipe
    7.17](#javacook-structure-SECT-15)中，我会稍微介绍二维数组；否则，您应该将此视为复习示例：
- en: '*main/src/main/java/lang/Array1.java*'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*main/src/main/java/lang/Array1.java*'
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Arrays in Java work nicely. The type checking provides reasonable integrity,
    and array bounds are always checked by the runtime system, further contributing
    to reliability.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Java中的数组工作得很好。类型检查提供了合理的完整性，数组边界始终由运行时系统检查，进一步增加了可靠性。
- en: 'The only problem with arrays is: what if the array fills up and you still have
    data coming in? See [Recipe 7.2](#javacook-structure-SECT-2).'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的问题是数组填满后如果仍有数据进来怎么办？请参见[Recipe 7.2](#javacook-structure-SECT-2)。
- en: 7.2 Resizing an Array
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.2 调整数组大小
- en: Problem
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: The array filled up, and you got an `ArrayIndexOutOfBoundsException`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 数组已经填满，并且出现了`ArrayIndexOutOfBoundsException`。
- en: Solution
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Make the array bigger. Or, use an `ArrayList`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 扩大数组大小，或者使用`ArrayList`。
- en: Discussion
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'One approach is to allocate the array at a reasonable size to begin with; but
    if you find yourself with more data than will fit, reallocate a new, bigger array
    and copy the elements into it.^([1](ch07.html#idm45290673293208)) Here is code
    that does so:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法是一开始就为数组分配一个合理大小；但是如果发现自己的数据超出了容量，就需要重新分配一个更大的数组，并将元素复制到其中。^([1](ch07.html#idm45290673293208))
    下面是实现此操作的代码：
- en: '*main/src/main/java/lang/Array2.java*'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*main/src/main/java/lang/Array2.java*'
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[![1](assets/1.png)](#co_structuring_data_with_java_CO1-1)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_structuring_data_with_java_CO1-1)'
- en: A good guess is necessary; know your data!
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一个良好的猜测是必要的；了解你的数据！
- en: '[![2](assets/2.png)](#co_structuring_data_with_java_CO1-2)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_structuring_data_with_java_CO1-2)'
- en: The growth factor is arbitary; 2 is a good value here but will continue to double
    exponentially. You might want to use a factor like 1.5, which would mean more
    allocations at the low end but less explosive growth. You need to manage this
    somehow!
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 增长因子是任意的；2 是一个好的值，但会继续呈指数倍增。你可能想使用像 1.5 这样的因子，这意味着在低端会有更多的分配，但增长不会那么爆炸性。你需要以某种方式管理这个！
- en: This technique works reasonably well for simple or relatively small linear collections
    of data. For data with a more variable structure, you probably want to use a more
    dynamic approach, as in [Recipe 7.4](#javacook-structure-SECT-3).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术对于简单或相对较小的线性数据集合来说效果还不错。对于结构更为复杂的数据，你可能希望使用更动态的方法，就像 [Recipe 7.4](#javacook-structure-SECT-3)
    中描述的那样。
- en: 7.3 The Collections Framework
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.3 集合框架
- en: Problem
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You’re having trouble keeping track of all these lists, sets, and iterators.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你在跟踪所有这些列表、集合和迭代器时遇到了困难。
- en: Solution
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: There’s a pattern to it. See [Figure 7-1](#javacook-structure-FIG-3) and [Table 7-1](#javacook-structure-TABLE-2).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这有一个模式。参见 [Figure 7-1](#javacook-structure-FIG-3) 和 [Table 7-1](#javacook-structure-TABLE-2)。
- en: Discussion
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Discussion
- en: '`List`, `Set`, `Map`, and `Queue` are the four fundamental data structures
    of the Collections Framework. `List` and `Set` are both sequences, with the difference
    that `List` preserves order and allows duplicate entries, whereas `Set`, true
    to the mathematical concept behind it, does not. `Map` is a key/value store, also
    known as a hash, a dictionary, or an associative store. Queues are, as the same
    suggests, structures that you can push into at one end and pull out from the other.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`List`、`Set`、`Map` 和 `Queue` 是集合框架的四种基本数据结构。`List` 和 `Set` 都是序列，区别在于 `List`
    保留顺序并允许重复条目，而 `Set` 则不允许。`Map` 是一个键/值存储，也称为哈希、字典或关联存储。队列是，正如其名字所暗示的，你可以从一端推入，从另一端拉出的结构。'
- en: '[Table 7-1](#javacook-structure-TABLE-2) shows some of the important collection-based
    classes from package `java.util`. It is intentionally not 100% complete due to
    space limitations.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '[Table 7-1](#javacook-structure-TABLE-2) 显示了来自 `java.util` 包中一些重要的基于集合的类。由于空间限制，它故意不是
    100% 完整的。'
- en: See Also
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The javadoc documentation on `Collections`, `Arrays`, `List`, `Set`, and the
    classes that implement them provides more details than there’s room for here.
    [Table 7-1](#javacook-structure-TABLE-2) may further help you to absorb the regularity
    of the Collections Framework.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`Collections`、`Arrays`、`List`、`Set` 及其实现类的 javadoc 文档提供了比这里提供的更多的细节。[Table 7-1](#javacook-structure-TABLE-2)
    可能会帮助你更好地吸收集合框架的规律性。'
- en: Table 7-1\. Java collections
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7-1\. Java 集合
- en: '| Interfaces | Implementations |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 接口 | 实现 |'
- en: '| --- | --- |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Resizable array | Hashed table | Linked list | Balanced tree |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 可调整大小的数组 | 散列表 | 链表 | 平衡树 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '|  |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '| `List` | `ArrayList, Vector` |  | `LinkedList` |  |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `List` | `ArrayList, Vector` |  | `LinkedList` |  |'
- en: '| `Set` |  | `HashSet` |  | `TreeSet` |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `Set` |  | `HashSet` |  | `TreeSet` |'
- en: '| `Map` |  | `HashMap, HashTable` |  | `TreeMap` |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `Map` |  | `HashMap, HashTable` |  | `TreeMap` |'
- en: '| `Queue` | `Deque`s, `BlockingQueue`s, etc. |  |  |  |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `Queue` | `Deque`、`BlockingQueue` 等 |  |  |  |'
- en: '[Figure 7-1](#javacook-structure-FIG-3) shows the relationships among several
    of these types.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '[Figure 7-1](#javacook-structure-FIG-3) 显示了几种类型之间的关系。'
- en: '![jcb4 0701](assets/jcb4_0701.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![jcb4 0701](assets/jcb4_0701.png)'
- en: 'Figure 7-1\. The Collections Framework: Rectangles are interfaces; ovals classes;
    Solid lines are inheritance; dashed lines represent `implements`'
  id: totrans-55
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-1\. 集合框架：矩形为接口；椭圆形为类；实线表示继承；虚线代表 `implements`
- en: '`Queue` and its subtypes are treated in [Chapter 16](ch16.html#javacook-threads).'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`Queue` 及其子类型在 [Chapter 16](ch16.html#javacook-threads) 中有所描述。'
- en: 7.4 Like an Array, but More Dynamic
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.4 像数组一样，但更动态
- en: Problem
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You don’t want to worry about storage reallocation (often because you don’t
    know how big the incoming dataset is going to be); you want a standard class to
    handle it for you. You want to store your data in any of the `Collection` classes
    defined in [Chapter 7](#javacook-structure) with type safety and without having
    to write downcasts when retrieving data from the collection.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你不想担心存储重新分配（通常是因为你不知道传入数据集的大小）；你想要一个标准的类来为你处理它。你希望将数据存储在 [第 7 章](#javacook-structure)
    中定义的任何 `Collection` 类中，具有类型安全性，而不必在从集合检索数据时编写 downcasts。
- en: Solution
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use a `List` implementation or one of the other Collections classes, along with
    Java’s Generic Types mechanism, declaring the `Collection` with a *type parameter*
    identifying the type of your data. The type parameter name appears in angle brackets
    after the declaration and instantiation.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`List`实现或其他`Collections`类，以及Java的泛型类型机制，声明`Collection`时加上*类型参数*以标识数据类型。类型参数名称在声明和实例化之后出现在尖括号中。
- en: Discussion
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: The first of the `Collections` classes we will discuss, `ArrayList`, is a standard
    class from `java.util` that encapsulates the functionality of an array but allows
    it to expand automatically. You can just keep on adding things to it, and each
    addition behaves the same. If you watch *really* closely, you might notice a brief
    extra pause once in a while when adding objects as the `ArrayList` reallocates
    and copies. But you don’t have to think about it.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论的第一个`Collections`类是`ArrayList`，它是来自`java.util`的标准类，封装了数组的功能，但允许它自动扩展。你可以不断地向其添加内容，每次添加的行为都是相同的。如果你非常仔细地观察，你可能会注意到在添加对象时偶尔会有一个短暂的额外暂停，这是因为`ArrayList`在重新分配和复制时发生了。但你无需去思考这些。
- en: However, because `ArrayList` is a class and isn’t part of the syntax of Java,
    you can’t use Java’s array syntax; you must use methods to access the `ArrayList`’s
    data. It has methods to add objects, retrieve objects, find objects, and tell
    you how big the `List` is and how big it can become without having to reallocate
    (note that the `ArrayList` class is but one implementation of the `List` interface;
    more on that later). Like the other collection classes in `java.util`, `ArrayList`’s
    storing and retrieval methods were originally defined to have parameters and return
    values of `java.lang.Object`. Because `Object` is the ancestor of every defined
    type, you can store objects of any type in a `List` (or any collection) and cast
    it when retrieving it. If you need to store a small number of built-ins (like
    `int` and `float`) into a collection containing other data, use the appropriate
    wrapper class (see the introduction to [Chapter 5](ch05.html#javacook-numbers)).
    To store `boolean`s, either store them directly in a `java.util.BitSet` (see the
    online documentation) or store them in a `List` using the `Boolean` wrapper class.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于`ArrayList`是一个类，并不是Java语法的一部分，所以你不能使用Java的数组语法；你必须使用方法来访问`ArrayList`的数据。它有添加对象、检索对象、查找对象以及告诉你`List`大小及其可以在不需重新分配的情况下变得多大的方法（注意，`ArrayList`类只是`List`接口的一种实现；稍后会详细介绍更多）。就像`java.util`中的其他集合类一样，`ArrayList`的存储和检索方法最初是定义为具有`java.lang.Object`的参数和返回值。由于`Object`是每个定义类型的祖先，你可以将任何类型的对象存储在`List`（或任何集合）中，并在检索时进行转换。如果你需要将少量的内建类型（如`int`和`float`）存储到包含其他数据的集合中，请使用适当的包装类（参见[第5章](ch05.html#javacook-numbers)的介绍）。要存储`boolean`，可以直接存储在`java.util.BitSet`中（请参阅在线文档），或者使用`Boolean`包装类存储在`List`中。
- en: 'Because `Object` is usually too general for accurate work, all modern versions
    of Java provide the *generic types* mechanism. Nowadays, you declare an `ArrayList`
    (or other collection) with a type parameter in angle brackets, and the parameters
    and returns are treated as being of that type by the compiler, ensuring that objects
    of the wrong type don’t make it into your collections, and avoiding the need to
    write casts when retrieving objects. For example, this is how you declare an `ArrayList`
    for holding `String` object references:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`Object`通常对于准确的工作来说太过于普遍，所有现代版本的Java都提供了*泛型*机制。如今，你可以在尖括号中声明一个类型参数，比如声明一个`ArrayList`（或其他集合），编译器会将参数和返回值视为该类型，确保错误类型的对象不会进入你的集合，并避免在检索对象时写转换语句。例如，这是如何声明一个用于保存`String`对象引用的`ArrayList`：
- en: '[PRE2]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It is a good practice to *declare* the variable as the interface type `List`,
    even though you are *defining* it (constructing it) as an `ArrayList`. This makes
    it easier to change from one `List` implementation to another, and it avoids accidentally
    depending on an implementation-specific method not in the `List` interface (which
    would also make it harder to change the implementation).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你正在*定义*（构造）它作为`ArrayList`，但将变量声明为接口类型`List`是一个良好的实践。这样做可以更容易地从一个`List`实现切换到另一个，并且避免意外依赖于接口中不存在的实现特定方法（这也会使得更改实现更加困难）。
- en: The `<>` in the definition part is a vestige of legacy Java versions, in which
    you had to repeat the type definition, so you’d write `new ArrayList<String>()`
    in that example. Nowadays just use `<>` (as in the example) to indicate that you
    want the type copied from the declaration. The <> is called the *diamond operator*.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义部分的`<>`是旧版Java的遗留物，旧版Java需要在类型定义中重复，因此在示例中你会写`new ArrayList<String>()`。现在只需使用`<>`（如示例中所示），表示你希望类型从声明中复制。`<>`称为*钻石操作符*。
- en: 'As of Java 13, you can simplify by using the new `var` keyword (for local variables
    only):'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 截至Java 13，你可以通过使用新的`var`关键字（仅限局部变量）来简化：
- en: '[PRE3]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[Table 7-2](#javacook-structure-TABLE-1) shows some of the most important methods
    of the `List` interface, which is implemented by `ArrayList` and other `List`
    implementations. This means that the exact same methods can be used with the older
    `Vector` class and several other implementing classes. You’d just have to change
    the name used in the constructor call.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '[Table 7-2](#javacook-structure-TABLE-1)展示了`List`接口的一些最重要的方法，这些方法由`ArrayList`和其他`List`实现类实现。这意味着旧的`Vector`类和其他实现类也可以使用完全相同的方法。你只需更改构造函数调用中使用的名称。'
- en: Table 7-2\. Common List<T> methods
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 表7-2。`List<T>`的常见方法
- en: '| Method signature | Usage |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| 方法签名 | 用法 |'
- en: '| --- | --- |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `add(T o)` | Add the given element at the end |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `add(T o)` | 在末尾添加给定元素 |'
- en: '| `add(int i, T o)` | Insert the given element at the specified position |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `add(int i, T o)` | 在指定位置插入给定的元素 |'
- en: '| `clear()` | Remove all element references from the `Collection` |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `clear()` | 从`Collection`中删除所有元素引用 |'
- en: '| `contains(T o)` | True if the `List` contains the given object |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `contains(T o)` | 如果`List`包含给定对象，则返回true |'
- en: '| `forEach(lambda)` | Perform the lambda for each element |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `forEach(lambda)` | 对每个元素执行lambda |'
- en: '| `get(int i)` | Return the object reference at the specified position |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `get(int i)` | 返回指定位置的对象引用 |'
- en: '| `indexOf(T o)` | Return the index where the given object is found, or –1
    |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `indexOf(T o)` | 返回找到给定对象的索引，如果未找到则返回-1 |'
- en: '| `of(T t, …)` | Create a list from multiple objects |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `of(T t, …)` | 从多个对象创建列表 |'
- en: '| `remove(T o), remove(int i)` | Remove an object by reference or by position
    |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `remove(T o), remove(int i)` | 通过引用或位置删除对象 |'
- en: '| `toArray()` | Return an array containing the objects in the `Collection`
    |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `toArray()` | 返回包含`Collection`中对象的数组 |'
- en: '`ArrayListDemo` stores data in an `ArrayList` and retrieves it for processing:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`ArrayListDemo`将数据存储在`ArrayList`中，并检索进行处理：'
- en: '[PRE4]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The older `Vector` and `Hashtable` classes predate the Collections Framework,
    so they offer additional methods with different names: `Vector` provides `addElement()`
    and `elementAt()`. You may still run across these in legacy code, but you should
    use the `Collection` methods `add()` and `get()` instead. Another difference is
    that the methods of `Vector` are synchronized, meaning that they can be accessed
    safely from multiple threads (see [Recipe 16.5](ch16.html#javacook-threads-SECT-5)).
    This does mean more overhead, though, so for single-threaded access it is faster
    to use an `ArrayList` (see timing results in [Recipe 7.19](#javacook-structure-SECT-17)).'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 旧版的`Vector`和`Hashtable`类早于集合框架，因此它们提供了不同名称的额外方法：`Vector`提供了`addElement()`和`elementAt()`。你可能仍然会在遗留代码中遇到这些，但应该使用`Collection`的`add()`和`get()`方法。另一个区别是`Vector`的方法是同步的，这意味着它们可以安全地从多个线程访问（参见[Recipe
    16.5](ch16.html#javacook-threads-SECT-5)）。不过，这也意味着更多的开销，因此对于单线程访问，使用`ArrayList`速度更快（请参阅[Recipe
    7.19](#javacook-structure-SECT-17)中的计时结果）。
- en: 'There are various conversion methods. [Table 7-2](#javacook-structure-TABLE-1)
    mentions `toArray()`, which will expose the contents of a `List` as an array.
    The `List` interface in Java 9+ features a static `of()` method, which converts
    in the other direction, from an array into a `List`. In conjunction with the variable
    arguments feature of modern Java, you can create and populate a list in one call
    to `List.of()`, like this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 有各种转换方法。[Table 7-2](#javacook-structure-TABLE-1)提到`toArray()`，它会将`List`的内容暴露为数组。Java
    9+中的`List`接口具有静态的`of()`方法，可以在数组和`List`之间进行转换。结合现代Java的可变参数特性，你可以通过一次调用`List.of()`来创建和填充一个列表，例如：
- en: '[PRE5]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In legacy code that you will find in older apps and in web searches, `Arrays.asList()`
    provided this functionality, so you will come across code like this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在旧应用程序和网络搜索中找到的遗留代码中，`Arrays.asList()`提供了这种功能，因此你可能会遇到类似以下的代码：
- en: '[PRE6]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Java does indeed get less verbose as time goes by!
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Java随着时间的推移确实变得不那么冗长！
- en: You can still instantiate classes such as `ArrayList` without using a specific
    type. In this case, you will get a compiler warning, and the class will behave
    as in the old days; that is, the objects returned from a `Collection` or `Iterator`
    will be of type `java.lang.Object` and must be downcast before you can call any
    class-specific methods or use them in any application-specific method calls.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 您仍然可以实例化诸如`ArrayList`之类的类而不使用特定类型。在这种情况下，您将得到一个编译器警告，并且类将像以往一样运行；也就是说，从`Collection`或`Iterator`返回的对象将是`java.lang.Object`类型，必须在调用任何类特定方法或在任何应用特定方法调用之前进行向下转型。
- en: 'As a further example, consider the `Map` interface mentioned in [Chapter 7](#javacook-structure).
    A `Map` requires a key and a value in its `put()` method. A `Map`, therefore,
    has two parameterized types. To set up a `Map` whose keys are `Person` objects
    and whose values are `Address` objects (assuming these two classes exist in your
    application), you could define it like this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 作为进一步的示例，考虑在[第 7 章](#javacook-structure)中提到的`Map`接口。`Map`在其`put()`方法中需要一个键和一个值。因此，`Map`具有两个参数化类型。要设置一个`Map`，其键是`Person`对象，值是`Address`对象（假设这两个类在您的应用程序中存在），可以像这样定义它：
- en: '[PRE7]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This `Map` expects a `Person` as its key and an `Address` as its value in the
    `put()` method. The `get()` method returns an `Address` object, the `keySet()`
    method returns `Set<Person>` (i.e., a `Set` specialized for `Person` objects).
    There are also convenience routines for when you want to create a `Map` from existing
    objects. The most useful is several overloads of before existing `Map.of(key,value,key,value…)`
    similar to `List.of()` (but limited to 10 pairs), and so on.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`Map`期望其`put()`方法的键是`Person`，值是`Address`。`get()`方法返回一个`Address`对象，`keySet()`方法返回`Set<Person>`（即专门用于`Person`对象的`Set`）。当您想要从现有对象创建一个`Map`时，还有方便的例程。最有用的是与`List.of()`类似的几个重载版本的已经存在的`Map.of(key,value,key,value…)`，以及其他功能。
- en: See Also
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Although the generics avoid your having to write downcasts, the casts still
    occur at runtime; they are just provided by the compiler. The compiler techniques
    used in compiling these new constructs in a backward-compatible way include *erasure*
    and *bridging*, topics discussed in [*Java Generics and Collections*](http://shop.oreilly.com/product/9780596527754.do)
    by Maurice Naftalin and Philip Wadler.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管泛型避免了您必须编写向下转型，但转型仍然发生在运行时；它们只是由编译器提供的。编译器在编译这些新构造时使用的技术包括*擦除*和*桥接*，这些主题在《*Java泛型与集合*》（http://shop.oreilly.com/product/9780596527754.do）中有讨论，作者是莫里斯·纳夫特林和菲利普·沃德勒。
- en: 7.5 Using Generic Types in Your Own Class
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.5 在自己的类中使用泛型类型
- en: Problem
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You wish to define your own container classes using the generic type mechanism
    to avoid needless casting.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望使用泛型类型机制定义自己的容器类，以避免不必要的转型。
- en: Solution
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Define a class using `<` *`TypeName`* `>` where the container type is declared
    and *`TypeName`* where it is used.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`<` *`TypeName`* `>`定义一个类，其中声明了容器类型，使用`*TypeName*`来使用它。
- en: Discussion
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Consider the very simple `Stack` class in [Example 7-1](#javacook-CHP-8-EX-4).
    (We discuss the nature and uses of stack classes in [Recipe 7.16](#javacook-structure-SECT-14).)
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑在[示例 7-1](#javacook-CHP-8-EX-4)中的非常简单的`Stack`类。（我们在[配方 7.16](#javacook-structure-SECT-14)中讨论了堆栈类的性质和用途。）
- en: This version has been parameterized to take a type whose local name is `T`.
    This type `T` will be the type of the argument of the `push()` method, the return
    type of the `pop()` method, and so on. Because of this return type—more specific
    than the `Object` return type of the original Collections—the return value from
    `pop()` does not need to be downcasted. All containers in the Collections Framework
    (`java.util`) are parameterized similarly.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 此版本已经参数化为接受一个名为`T`的类型。这种类型`T`将是`push()`方法参数的类型，`pop()`方法返回类型等。由于这个返回类型比原始集合的`Object`返回类型更具体，从`pop()`返回的值不需要进行向下转型。集合框架（`java.util`）中的所有容器都类似地进行了参数化。
- en: Example 7-1\. main/src/main/java/structure/MyStack.java
  id: totrans-107
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-1\. main/src/main/java/structure/MyStack.java
- en: '[PRE8]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The association of a particular type is done at the time the class is instantiated.
    For example, to instantiate a `MyStack` specialized for holding `BankAccount`
    objects, you would need to code only the following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 特定类型的关联是在实例化类时完成的。例如，要实例化一个专门用于持有`BankAccount`对象的`MyStack`，您只需要编写以下代码：
- en: '[PRE9]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If you don’t provide a type parameter `T`, this collection, like the ones in
    `java.util`, will behave as they did in the days before generic collections—accepting
    input arguments of any type, returning `java.lang.Object` from getter methods,
    and requiring downcasting—as their default, backward-compatible behavior. [Example 7-2](#javacook-CHP-8-EX-5)
    shows a program that creates two instances of `MyStack`, one specialized for `String`s
    and one left general. The general one, called `ms2`, is loaded up with the same
    two `String` objects as `ms1` but also includes a `Date` object. The printing
    code is now broken, because it will throw a `ClassCastException`: a `Date` is
    not a `String`. I handle this case specially for pedantic purposes: it is illustrative
    of the kinds of errors you can get into when using nonparameterized container
    classes.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不提供类型参数 `T`，则这个集合（如 `java.util` 中的集合）将表现得像在泛型集合出现之前的那些日子一样——接受任何类型的输入参数，从
    getter 方法返回 `java.lang.Object`，并需要向下转型——作为它们默认的向后兼容行为。[例子7-2](#javacook-CHP-8-EX-5)展示了一个创建两个
    `MyStack` 实例的程序，一个专门用于 `String`，另一个保持一般化。通用的那个，称为 `ms2`，加载了与 `ms1` 相同的两个 `String`
    对象，但还包括一个 `Date` 对象。现在打印代码已经失效，因为它将抛出 `ClassCastException`：`Date` 不是 `String`。出于学术目的，我特别处理了这种情况：这说明了在使用非参数化容器类时可能遇到的错误类型。
- en: Example 7-2\. main/src/main/java/structure/MyStackDemo.java
  id: totrans-112
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-2\. main/src/main/java/structure/MyStackDemo.java
- en: '[PRE10]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Because of this potential for error, the compiler warns that you have unchecked
    raw types. Like the deprecation warnings discussed in [Recipe 1.9](ch01.html#javacook-getstarted-SECT-9),
    by default, these warnings are not printed in detail by the *javac* compiler (they
    will appear in most IDEs). You ask for them with the rather lengthy option `-Xlint:unchecked`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种潜在的错误可能性，编译器会警告您存在未检查的原始类型。与[第1.9节](ch01.html#javacook-getstarted-SECT-9)讨论的弃用警告类似，默认情况下，*javac*
    编译器不会详细打印这些警告（它们将出现在大多数集成开发环境中）。您可以使用相当冗长的选项 `-Xlint:unchecked` 请求它们：
- en: '[PRE11]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: I say more about the development and evolution of `MyStack` in [Recipe 7.16](#javacook-structure-SECT-14).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我在[第7.16节](#javacook-structure-SECT-14)中更详细地讨论了 `MyStack` 的开发和演变。
- en: 7.6 How Shall I Iterate Thee? Let Me Enumerate the Ways
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.6 我应该如何迭代你？让我列举一下方法
- en: Problem
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to iterate over some structured data.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 需要迭代一些结构化数据。
- en: Solution
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Java provides many ways to iterate over collections of data. Here they are,
    in newest-first order:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Java 提供了许多迭代数据集合的方法。以下按照最新的顺序列出：
- en: '`Stream.forEach()` method (Java 8)'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stream.forEach()` 方法（Java 8）'
- en: '`Iterable.forEach()` method (Java 8)'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Iterable.forEach()` 方法（Java 8）'
- en: Java “foreach” loop (Java 5)
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java “foreach” 循环（Java 5）
- en: '`java.util.Iterator` (Java 2)'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.Iterator`（Java 2）'
- en: Three-part `for` loop
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三部分 `for` 循环
- en: '`while` loop * Enumeration'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`while` 循环 * 枚举'
- en: Pick one and use it. Or learn them all and save!
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 选择一个并使用它。或者学习它们并保存！
- en: Discussion
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: A few words on each of the iteration methods are given here. Note that the first
    few are the most common.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这里对每种迭代方法都简要说明了一些词。请注意，前几种是最常见的。
- en: Stream.forEach method (Java 8)
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Stream.forEach 方法（Java 8）
- en: 'The `Stream` mechanism introduced as part of Java’s functional programming
    provides one of the two most-recent ways of iterating, `Stream.forEach()`, and
    is discussed in [Recipe 9.3](ch09.html#javacook-fp-streams1-1). For now, here’s
    a quick example, using the `BufferedReader` method `lines()` that returns a `Stream`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 Java 函数式编程的一部分引入的 `Stream` 机制提供了两种最近的迭代方式之一，`Stream.forEach()`，在[第9.3节](ch09.html#javacook-fp-streams1-1)中有讨论。现在，这里有一个快速的例子，使用
    `BufferedReader` 的 `lines()` 方法返回一个 `Stream`：
- en: '[PRE12]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Iterable.forEach method (Java 8)
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Iterable.forEach 方法（Java 8）
- en: 'The other recent iteration technique is the `Iterable.forEach()` method, added
    in Java 8. This method can be called on any `Iterable` (unfortunately, the array
    class does not yet implement `Iterable`) and takes one argument implementing the
    *functional interface* `java.util.function.Consumer`. Functional interfaces are
    discussed in [Chapter 9](ch09.html#javacook-fp), but here is one example:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`Iterable.forEach()` 方法是最近新增的迭代技术之一，Java 8 中引入。该方法可以在任何 `Iterable` 上调用（不幸的是，数组类尚未实现
    `Iterable`），接受一个实现了*函数接口* `java.util.function.Consumer` 的参数。关于函数接口的讨论见[第9章](ch09.html#javacook-fp)，以下是一个例子：'
- en: '[PRE13]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[![1](assets/1.png)](#co_structuring_data_with_java_CO2-1)'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_structuring_data_with_java_CO2-1)'
- en: Declare a `Collection` (a `Collection` is an `Iterable`).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 声明一个 `Collection`（`Collection` 是 `Iterable`）。
- en: '[![2](assets/2.png)](#co_structuring_data_with_java_CO2-2)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_structuring_data_with_java_CO2-2)'
- en: Populate it with `Arrays.of()` with an array or sequence of objects (see [Recipe
    7.4](#javacook-structure-SECT-3) for how this arbitrary argument list becomes
    an array).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Arrays.of()` 将数组或对象序列填充进去（参见[Recipe 7.4](#javacook-structure-SECT-3)，了解任意参数列表如何成为数组）。
- en: '[![3](assets/3.png)](#co_structuring_data_with_java_CO2-3)'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_structuring_data_with_java_CO2-3)'
- en: Invoke the collection’s `forEach()` method, passing a lambda expression (see
    [Chapter 9](ch09.html#javacook-fp) for a discussion of how `s`→`System.out.println(s)`
    gets mapped to a `Consumer` interface implementation without your even having
    to import this interface).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 调用集合的 `forEach()` 方法，传递一个 lambda 表达式（参见[第9章](ch09.html#javacook-fp)，了解 `s`→`System.out.println(s)`
    如何映射到 `Consumer` 接口实现，而不需要显式导入该接口）。
- en: This style of iteration—sometimes called *internal iteration*—inverts the control
    from the traditional `for` loop; the collection is in charge of when and how the
    iteration works.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这种迭代方式——有时被称为 *内部迭代*——颠覆了传统 `for` 循环的控制方式；集合负责迭代的时间和方式。
- en: Tip
  id: totrans-144
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Both `Stream.forEach` and `Iterable.forEach()` take one argument, of type `java.util.function.Consumer`,
    so they work largely the same way, at least syntactically. This is intentional.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stream.forEach` 和 `Iterable.forEach()` 都接受一个类型为 `java.util.function.Consumer`
    的参数，因此它们在语法上基本相同。这是有意为之。'
- en: Java “foreach” loop (Java 5)
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Java “foreach” 循环（Java 5）
- en: 'This is the for-each loop syntax:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 for-each 循环的语法：
- en: '[PRE14]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The for-each loop is probably the most common style of loop in modern Java code.
    The `Iterable` can be an array or anything that implements `Iterable` (the `Collection`
    implementations included).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: for-each 循环可能是现代 Java 代码中最常见的循环风格。`Iterable` 可以是数组或任何实现了 `Iterable` 的东西（包括 `Collection`
    实现）。
- en: This style is used throughout the book. In addition, many third-party frameworks/libraries
    provide their own types that implement `Iterable` for use with the `for` loop.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中广泛采用这种风格。此外，许多第三方框架/库提供自己的类型来实现 `Iterable`，以便与 `for` 循环一起使用。
- en: java.util.Iterator (Java 2)
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: java.util.Iterator（Java 2）
- en: 'The older `Iterator` interface has three methods:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 旧的 `Iterator` 接口有三种方法：
- en: '[PRE15]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'It was once common to write code like this, which you’ll still find occasionally
    in older code:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 曾经常见的代码编写方式如下，您仍然可能在旧代码中找到：
- en: '[PRE16]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `remove()` method throws an `UnsupportedOperationException` if called on
    a read-only collection. In conjunction with `Stream`s and default methods, there
    is now a fourth method:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在只读集合上调用 `remove()` 方法，则会抛出 `UnsupportedOperationException`。与 `Stream` 和默认方法结合使用，现在有第四种方法：
- en: '[PRE17]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Three-part for loop
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 三部分 for 循环
- en: 'This is the traditional `for` loop invented by Dennis Ritchie in the early
    1970s for the C language:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Dennis Ritchie 在 1970 年代早期为 C 语言发明的传统 `for` 循环：
- en: '[PRE18]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Its most common form is with an `int` “index variable” or “loop variable”:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 其最常见的形式是使用一个 `int` “索引变量”或“循环变量”：
- en: '[PRE19]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: while loop
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: while 循环
- en: 'A `while` loop executes its loop body as long as (while) the test condition
    is true. It’s commonly used in conjunction with an `Enumeration` or `Iterator`,
    like this:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`while` 循环会在测试条件为真时执行其循环体。通常与 `Enumeration` 或 `Iterator` 结合使用，例如：'
- en: '[PRE20]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Enumeration
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 枚举
- en: An `Enumeration` is like an `Iterator` (shown earlier), but it lacks the `remove()`
    method, and the control methods have longer names—for example, `hasMore​Ele⁠ments()`
    and `nextElement()`. For new code, there is little to recommend implementing `Enumeration`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`Enumeration` 类似于之前展示的 `Iterator`，但它缺少 `remove()` 方法，控制方法的名称更长，例如 `hasMore​Ele⁠ments()`
    和 `nextElement()`。对于新代码，建议尽量避免实现 `Enumeration`。'
- en: 7.7 Eschewing Duplicates with a Set
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.7 使用 Set 避免重复
- en: Problem
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want a structure that will avoid storing duplicates.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望一个结构，可以避免存储重复项。
- en: Solution
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use a `Set` implementation instead of a `List` (e.g., `Set<String> myNames =
    new HashSet<>()`).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Set` 实现而不是 `List`（例如 `Set<String> myNames = new HashSet<>()`）。
- en: Discussion
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'The `Set` interface is similar to the `List` interface,^([2](ch07.html#idm45290671381032))
    with methods like `add()`, `remove()`, `contains()`, `size()`, and `isEmpty()`.
    The difference is that it doesn’t preserve order; instead, it enforces uniqueness—if
    you add the same item (as considered by its `equals()` method) twice or more,
    it will only be present once in the set. For this reason, the index-based methods
    such as `add(int, Object)` and `get(int)` are missing from the `Set` implementation:
    you might know that you’ve added seven objects but only five of those were unique,
    so calling `get()` to retrieve the sixth one would have to throw an `ArrayIndexOutOfBoundsException`!
    It’s better not to think of a `Set` as being indexed.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`Set` 接口类似于 `List` 接口，^([2](ch07.html#idm45290671381032)) 其方法包括 `add()`、`remove()`、`contains()`、`size()`
    和 `isEmpty()`。不同之处在于它不保留顺序；相反，它强制唯一性——如果多次添加相同的项（根据其 `equals()` 方法），它将在集合中仅出现一次。因此，索引为基础的方法如
    `add(int, Object)` 和 `get(int)` 在 `Set` 实现中是缺失的：你可能知道你添加了七个对象，但其中只有五个是唯一的，因此调用
    `get()` 来检索第六个对象将会抛出 `ArrayIndexOutOfBoundsException` 异常！最好不要将 `Set` 视为具有索引的集合。'
- en: Warning
  id: totrans-175
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: 'As the Java 7 `Set` document states: “Note: Great care must be exercised if
    mutable objects are used as set elements. The behavior of a set is not specified
    if the value of an object is changed in a manner that affects equals comparisons
    while the object is an element in the set. A special case of this prohibition
    is that it is not permissible for a set to contain itself as an element.”'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 正如 Java 7 中的 `Set` 文档所述：“注意：如果将可变对象用作集合元素，则必须非常小心。如果以影响等式比较的方式更改对象的值，则集合的行为未指定。此禁止的特殊情况是，集合不能包含自身作为元素。”
- en: 'This code shows a duplicate entry being made to a `Set`, which will contain
    only one copy of the string `"One"`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码展示了向 `Set` 中添加重复条目的情况，它将只包含一个字符串 `"One"` 的副本：
- en: '[PRE21]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Not surprisingly, only the three distinct values are printed.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 不出所料，只打印了三个不同的值。
- en: If you need a sorted `Set`, there is in fact a `SortedSet` interface, of which
    the most common implementation is a `TreeSet`; see a `TreeSet` example in [Recipe
    7.12](#javacook-structure-SECT-9).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要排序的 `Set`，实际上有一个 `SortedSet` 接口，其中最常见的实现是 `TreeSet`；查看 [Recipe 7.12](#javacook-structure-SECT-9)
    中的 `TreeSet` 示例。
- en: 'As with `List`s, the `Set` interface offers the `of` method as of Java 9:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `List` 一样，`Set` 接口从 Java 9 开始提供了 `of` 方法：
- en: '[PRE22]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 7.8 Structuring Data in a Linked List
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.8 在链表中结构化数据
- en: Problem
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: Your data isn’t suitable for use in an array.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 你的数据不适合在数组中使用。
- en: Solution
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use a linked list; Java’s `LinkedList` class is quite suitable.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 使用链表；Java 的 `LinkedList` 类非常适合。
- en: Discussion
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Anybody who’s taken Computer Science 101 (or any computer science course) should
    be familiar with data structuring, such as linked lists and binary trees. A linked
    list is commonly used when you have an unpredictably large number of data items,
    you wish to allocate just the right amount of storage, and you want to access
    them in the same order that you created them. [Figure 7-2](#javacook-structure-FIG-1)
    is a diagram showing the normal arrangement.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 任何参加过计算机科学 101（或任何计算机科学课程）的人都应该熟悉数据结构，如链表和二叉树。当你有一个不可预测的大量数据项，希望分配恰到好处的存储空间，并且希望按照创建顺序访问它们时，通常使用链表。[图 7-2](#javacook-structure-FIG-1)
    是显示正常排列的图表。
- en: '![jcb4 0702](assets/jcb4_0702.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![jcb4 0702](assets/jcb4_0702.png)'
- en: Figure 7-2\. Linked list structure
  id: totrans-191
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-2\. 链表结构
- en: 'Of course, the Collections API provides a `LinkedList` class; here is a simple
    program that uses it:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，Collections API 提供了 `LinkedList` 类；这里是一个使用它的简单程序：
- en: '[PRE23]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `ListIterator` used here is a subinterface of `Iterator`, which was discussed
    in [Recipe 7.6](#javacook-structure-iterate).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 此处使用的 `ListIterator` 是 `Iterator` 的子接口，如 [Recipe 7.6](#javacook-structure-iterate)
    所述。
- en: 'Just to show how this kind of list works, here is code that shows part of the
    implemention of a simple linked list:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示这种列表的工作方式，这里是显示简单链表实现的部分代码：
- en: '[PRE24]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Warning
  id: totrans-197
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: This is just to show how the implementation of a linked list might work. Do
    not use the simple `LinkList` class shown here; use the real one, `java.util.LinkedList`,
    shown in action in the first example.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是展示链表实现可能的方式。不要使用此处显示的简单 `LinkList` 类；请使用真正的 `java.util.LinkedList`，如第一个示例中展示的那样。
- en: 7.9 Mapping with Hashtable and HashMap
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.9 使用 Hashtable 和 HashMap 进行映射
- en: Problem
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need a one-way mapping from one data item to another.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要一个从一个数据项到另一个数据项的单向映射。
- en: Solution
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use a `HashMap`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `HashMap`。
- en: Discussion
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: '`HashMap` provides a one-way mapping from one set of object references to another.
    They are completely general purpose. I’ve used them to map from Swing push buttons
    to the URL that is to be opened when the button is pushed, to map names to addresses,
    and to implement a simple in-memory cache in a web server. You can map from anything
    to anything. In the following example, we map from company names to addresses;
    the addresses here are `String` objects, but in real life they’d probably be `Address`
    objects:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`HashMap` 提供了一种从一组对象引用到另一组对象引用的单向映射。它们完全是通用的。我用它们来映射从 Swing 按钮到按钮被按下时要打开的 URL，将名称映射到地址，以及在
    Web 服务器中实现一个简单的内存缓存。您可以将任何东西映射到任何东西。在下面的示例中，我们将公司名称映射到地址；这里的地址是 `String` 对象，但在实际生活中它们可能是
    `Address` 对象：'
- en: '[PRE25]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'For this version we used both a `for` loop and a `forEach()` loop; the latter
    uses the return from `entrySet()`, a set of `Map.Entry`, each of which contains
    one key and one value (this may be faster on large maps because it avoids going
    back into the map to get the value each time through the loop). If you are modifying
    the list as you are going through it (e.g., removing elements), either inside
    the loop or in another thread, then these forms will fail with a `ConcurrentModificationException`.
    You then need to use the `Iterator` explicitly to control the loop:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个版本，我们既使用了 `for` 循环，也使用了 `forEach()` 循环；后者使用 `entrySet()` 的返回值，即包含一个键和一个值的
    `Map.Entry` 集合（在大型映射上可能更快，因为它避免了每次循环时重新进入映射获取值）。如果您在循环内或在另一个线程中修改列表（例如，删除元素），那么这些形式将会因为
    `ConcurrentModificationException` 而失败。然后，您需要显式使用 `Iterator` 来控制循环：
- en: '[PRE26]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'A more functional (see [Chapter 9](ch09.html#javacook-fp)) way of writing the
    removal, not involving explicit looping, would be this:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更为实用的（参见[第9章](ch09.html#javacook-fp)）编写移除操作的方法，不涉及显式循环，可以是这样的：
- en: '[PRE27]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Tip
  id: totrans-211
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: '`HashMap` methods are not synchronized. The older and similar `Hashtable` methods
    are synchronized, for use with multiple threads.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`HashMap` 方法不是同步的。旧的类似 `Hashtable` 的方法是同步的，适用于多线程。'
- en: 7.10 Storing Strings in Properties and Preferences
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.10 在属性和偏好中存储字符串
- en: Problem
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to store keys and values that are both strings, possibly with persistence
    across runs of a program—for example, program customization.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要存储的键和值都是字符串，可能会跨程序运行保持不变，例如程序定制。
- en: Solution
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use a `java.util.prefs.Preferences` object or a `java.util.Properties` object.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `java.util.prefs.Preferences` 对象或 `java.util.Properties` 对象。
- en: Discussion
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Here are three approaches to customization based on the user’s environment.
    Java offers `Preferences` and `Properties` for cross-platform customizations.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是基于用户环境的三种定制方法。Java 提供了 `Preferences` 和 `Properties` 用于跨平台定制。
- en: Preferences
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 偏好
- en: 'The `Preferences` class `java.util.prefs.Preferences` provides an easy-to-use
    mechanism for storing user customizations in a system-dependent way (which might
    mean dot files on Unix, a preferences file on the Mac, or the registry on Windows
    systems). This class provides a hierarchical set of nodes representing a user’s
    preferences. Data is stored in the system-dependent storage format but can also
    be exported to or imported from an XML format. Here is a simple demonstration
    of `Preferences`:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`Preferences` 类 `java.util.prefs.Preferences` 提供了一种易于使用的机制，用于以系统相关方式存储用户定制（这可能意味着在
    Unix 上是点文件，在 Mac 上是偏好文件，在 Windows 系统上是注册表）。该类提供了一组表示用户偏好的节点层次结构。数据以系统相关的存储格式存储，但也可以导出到或导入自
    XML 格式。下面是 `Preferences` 的一个简单演示：'
- en: '[PRE28]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'When you run the `PrefsDemo` program the first time, of course, it doesn’t
    find any settings, so the calls to `preferences.get()` return the default values:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 当您第一次运行 `PrefsDemo` 程序时，当然，它找不到任何设置，所以对 `preferences.get()` 的调用将返回默认值：
- en: '[PRE29]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'On subsequent runs, it finds and returns the user-provided settings (I’ve elided
    the XML output from the second run because most of the XML output is the same):'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '在后续运行中，它会找到并返回用户提供的设置（我省略了第二次运行的 XML 输出，因为大部分 XML 输出是相同的）:'
- en: '[PRE30]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Properties
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 属性
- en: 'The `Properties` class is similar to a `HashMap` or `Hashtable` (it extends
    the latter) but with methods defined specifically for string storage and retrieval
    and for loading/saving. `Properties` objects are used throughout Java, for everything
    from setting the platform font names to customizing user applications into different
    `Locale` settings as part of internationalization and localization. When stored
    on disk, a `Properties` object looks just like a series of `name=value` assignments,
    with optional comments. Comments are added when you edit a `Properties` file by
    hand, ignored when the `Properties` object reads itself, and lost when you ask
    the `Properties` object to save itself to disk. Here is an example of a `Properties`
    file that could be used to internationalize the menus in a GUI-based program:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`Properties`类类似于`HashMap`或`Hashtable`（它扩展了后者），但定义了专门用于字符串存储和检索以及加载/保存的方法。`Properties`对象在Java中被广泛使用，从设置平台字体名称到在国际化和本地化的一部分中将用户应用程序定制为不同的`Locale`设置。当存储在磁盘上时，`Properties`对象看起来就像一系列的`name=value`赋值，带有可选的注释。编辑`Properties`文件时会添加注释，`Properties`对象读取自身时会忽略注释，并且在要求`Properties`对象将自身保存到磁盘时会丢失注释。这里是一个可用于在基于GUI的程序中国际化菜单的`Properties`文件示例：'
- en: '[PRE31]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Here is another example, showing some personalization properties:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一个示例，显示了一些个性化属性：
- en: '[PRE32]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'A `Properties` object can be loaded from a file. The rules are flexible: either
    `=`, :, or spaces can be used after a key name and its values. Spaces after a
    nonspace character are ignored in the key. A backslash can be used to continue
    lines or to escape other characters. Comment lines may begin with either `#` or
    `!`. Thus, a `Properties` file containing the previous items, if prepared by hand,
    could look like this:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 可以从文件加载`Properties`对象。规则很灵活：可以在键名和其值后使用`=`、`:`或空格。在键中忽略非空格字符后的空格。反斜杠可用于续行或转义其他字符。注释行可以以`#`或`!`开头。因此，如果手工准备的`Properties`文件包含前述项目，则可能如下所示：
- en: '[PRE33]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Fortunately, when a `Properties` object writes itself to a file, it uses the
    following simple format:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，当`Properties`对象将自身写入文件时，它使用以下简单格式：
- en: '[PRE34]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Here is an example of a program that creates a `Properties` object and adds
    into it the list of companies and their locations from [Recipe 7.9](#javacook-structure-SECT-6).
    It then loads additional properties from disk. To simplify the I/O processing,
    the program assumes that the `Properties` file to be loaded is contained in the
    standard input, as would be done using a command-line redirection on either Unix
    or DOS:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个创建`Properties`对象并将其中列出的公司及其位置从[Recipe 7.9](https://javacookbook.example.org/structure/SECT-6)添加到其中的程序示例。然后从磁盘加载附加属性。为简化I/O处理，程序假定要加载的`Properties`文件包含在标准输入中，就像在Unix或DOS上使用命令行重定向一样：
- en: '[PRE35]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Running it as
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 将其运行为
- en: '[PRE36]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'produces the following output in the file *PropsDemo.out*:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下输出产生到文件*PropsDemo.out*中：
- en: '[PRE37]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In case you didn’t notice in either the `HashMap` or the `Properties` examples,
    the order in which the outputs appear in these examples is neither sorted nor
    in the order we put them in. The hashing classes and the `Properties` subclass
    make no claim about the order in which objects are retrieved. If you need them
    sorted, see [Recipe 7.11](#javacook-structure-SECT-8).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在`HashMap`或`Properties`示例中没有注意到，这些示例中输出出现的顺序既不排序也不按我们放置它们的顺序。哈希类和`Properties`子类对检索对象的顺序不做任何声明。如果需要它们排序，请参阅[Recipe
    7.11](https://javacookbook.example.org/structure/SECT-8)。
- en: 'As a convenient shortcut, my `FileProperties` class includes a constructor
    that takes a filename:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 作为方便的快捷方式，我的`FileProperties`类包括一个接受文件名的构造函数：
- en: '[PRE38]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Note that constructing a `FileProperties` object causes it to be loaded, and
    therefore the constructor may throw a checked exception of class `IOException`.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，构造`FileProperties`对象会导致其被加载，因此构造函数可能抛出`IOException`类的已检查异常。
- en: 7.11 Sorting a Collection
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.11 对集合进行排序
- en: Problem
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You put your data into a collection in random order or used a `Properties` object
    that doesn’t preserve the order, and now you want it sorted.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 您将数据以随机顺序放入集合中或使用不保留顺序的`Properties`对象，现在您希望对其进行排序。
- en: Solution
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the static method `Arrays.sort()` or `Collections.sort()`, optionally providing
    a `Comparator`.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 使用静态方法`Arrays.sort()`或`Collections.sort()`，可选提供`Comparator`。
- en: Discussion
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'If your data is in an array, then you can sort it using the static `sort()`
    method of the `Arrays` utility class. If it is in a `Collection`, you can use
    the static `sort()` method of the `Collections` class. Here is a set of strings
    being sorted in place in an `Array`:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的数据在一个数组中，那么你可以使用`Arrays`实用类的静态`sort()`方法对其进行排序。如果它在一个`Collection`中，你可以使用`Collections`类的静态`sort()`方法。这里是一个字符串集合在`Array`中原地排序的示例：
- en: '[PRE39]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'What if the default sort order isn’t what you want? Well, you can create an
    object that implements the `Comparator<T>` interface and pass that as the second
    argument to sort. Fortunately, for the most common ordering next to the default,
    you don’t have to: a public constant `String.CASE_INSENSITIVE_ORDER` can be passed
    as this second argument. The `String` class defines it as a `Comparator<String>`
    that orders `String` objects as by `compareToIgnoreCase`. But if you need something
    fancier, you probably need to write a `Comparator<T>`. In some cases you may be
    able to use the `Comparator.comparing()` method and other static methods on `Comparator`
    to create a custom comparator without having to create a class. Suppose that,
    for some strange reason, you need to sort strings using all but the first character
    of the string. One way to do this would be to write this `Comparator<String>`:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如果默认排序顺序不是你想要的呢？那么，你可以创建一个实现了`Comparator<T>`接口的对象，并将其作为第二个参数传递给`sort`方法。幸运的是，对于除默认排序外最常见的排序，你不需要这样做：可以将`String.CASE_INSENSITIVE_ORDER`作为第二个参数传递。`String`类将其定义为一个`Comparator<String>`，按`compareToIgnoreCase`方法对`String`对象排序。但如果你需要更复杂的排序，可能需要编写一个`Comparator<T>`。在某些情况下，你可以使用`Comparator.comparing()`方法和`Comparator`的其他静态方法来创建自定义比较器，而不必创建一个类。假设出于某种奇怪的原因，你需要使用除了字符串的第一个字符之外的所有字符进行排序。可以编写以下`Comparator<String>`来实现：
- en: '[PRE40]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Using it is just a matter of passing it as the `Comparator` argument to the
    correct form of `sort()`, as shown here:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 使用它只需要将其作为`sort()`的`Comparator`参数传递即可，如下所示：
- en: '[PRE41]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Again, a more functional (see [Chapter 9](ch09.html#javacook-fp)) way of writing
    this might be the following:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，一个更为函数式的（见[第9章](ch09.html#javacook-fp)）编写方式可能如下所示：
- en: '[PRE42]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Here is the output of running it:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这是运行它的输出：
- en: '[PRE43]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: And this is all as it should be.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都应该如此。
- en: On the other hand, you may be writing a class and want to build in the comparison
    functionality so that you don’t always have to remember to pass the `Comparator`
    with it. In this case, you can directly implement the `java.lang.Comparable` interface,
    as is done by many classes in the standard API. These include `String` class;
    the wrapper classes `Byte`, `Character`, `Double`, `Float`, `Long`, `Short`, and
    `Integer`; `BigInteger` and `BigDecimal` from `java.math`; most objects in the
    date/time API in `java.time`; and `java.text.CollationKey`. Arrays or `Collections`
    of these types can be sorted without providing a `Comparator`. Classes that implement
    `Comparable` are said to have a natural ordering. The documentation strongly recommends
    that a class’s natural ordering be consistent with its `equals()` method. It is
    consistent with `equals()` if and only if `e1.compareTo((Object)e2)` has the same
    Boolean value as `e1.equals((Object)e2)` for every instance `e1` and `e2` of the
    given class. This means that if you implement `Comparable`, you should also implement
    `equals()`, and the logic of `equals()` should be consistent with the logic of
    the `compareTo()` method. If you implement `equals()`, incidentally, you also
    should implement `hashCode()` (as discussed in [“hashCode() and equals()”](ch08.html#javacook-oo-SECT-2.x.1)).
    Here, for example, is part of the appointment class `Appt` from a hypothetical
    scheduling program. The class has a `LocalDate` date variable and a `LocalTime`
    time variable; the latter may be null (e.g., an all-day appointment or a to-do
    item); this complicates the `compareTo()` function a little.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，你可能正在编写一个类，并希望内置比较功能，这样就不必每次都记得传递`Comparator`。在这种情况下，你可以直接实现`java.lang.Comparable`接口，就像标准API中的许多类所做的那样。这些类包括`String`类；包装类`Byte`、`Character`、`Double`、`Float`、`Long`、`Short`和`Integer`；`java.math`中的`BigInteger`和`BigDecimal`；`java.time`中日期/时间API中的大多数对象；以及`java.text.CollationKey`。可以对这些类型的数组或`Collections`进行排序，而无需提供`Comparator`。实现`Comparable`接口的类被称为具有自然顺序。文档强烈建议类的自然顺序与其`equals()`方法一致。如果`e1.compareTo((Object)e2)`的布尔值与`e1.equals((Object)e2)`对于给定类的每个实例`e1`和`e2`具有相同的布尔值，则它与`equals()`一致。这意味着如果你实现了`Comparable`，你也应该实现`equals()`，并且`equals()`的逻辑应该与`compareTo()`方法的逻辑一致。如果你实现了`equals()`，顺便说一句，你也应该实现`hashCode()`（如在[“hashCode()
    and equals()”](ch08.html#javacook-oo-SECT-2.x.1)中讨论的那样）。例如，这是一个假设调度程序中的约会类`Appt`的一部分。该类有一个`LocalDate`日期变量和一个`LocalTime`时间变量；后者可能为空（例如全天约会或待办事项），这会稍微复杂化`compareTo()`函数。
- en: '[PRE44]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: If you’re still confused between `Comparable` and `Comparator`, you’re probably
    not alone. [Table 7-3](#javacook-structure-compcompcomp) summarizes the two comparison
    interfaces.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仍然困惑于`Comparable`和`Comparator`之间的区别，你可能并不孤单。[表 7-3](#javacook-structure-compcompcomp)
    总结了这两个比较接口。
- en: Table 7-3\. Comparable compared with Comparator
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7-3\. `Comparable` 与 `Comparator` 的比较
- en: '| Interface name | Description | Method(s) |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| 接口名称 | 描述 | 方法 |'
- en: '| --- | --- | --- |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `java.lang.Comparable<T>` | Provides a natural ordering to objects. Written
    in the class whose objects are being sorted. | `int compareTo(T o);` |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| `java.lang.Comparable<T>` | 为对象提供自然排序。写在正在排序其对象的类中。 | `int compareTo(T o);`
    |'
- en: '| `java.util.Comparator<T>` | Provides total control over sorting objects of
    another class. Standalone strategy object; pass to `sort()` method or `Collection`
    constructor. | `int compare(T o1, T o2); boolean equals(T c2)` |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| `java.util.Comparator<T>` | 提供对另一个类的对象进行排序的完全控制。独立的策略对象；传递给`sort()`方法或`Collection`构造函数。
    | `int compare(T o1, T o2); boolean equals(T c2)` |'
- en: 7.12 Avoiding the Urge to Sort
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.12 避免排序的冲动
- en: Problem
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: Your data needs to be sorted, but you don’t want to stop and sort it periodically.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 你的数据需要排序，但你不想停下来周期性地进行排序。
- en: Solution
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Not everything that requires order requires an explicit *sort* operation. Just
    keep the data sorted at all times.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有需要排序的东西都需要显式的*排序*操作。只需始终保持数据有序即可。
- en: Discussion
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'You can avoid the overhead and elapsed time of an explicit sorting operation
    by ensuring that the data is in the correct order at all times, though this may
    or may not be faster overall, depending on your data and how you choose to keep
    it sorted. You can keep it sorted either manually or by using a `TreeSet` or a
    `TreeMap`. First, here is some code from a call tracking program that I first
    wrote on the very first public release of Java (the code has been modernized slightly!)
    to keep track of people I had extended contact with. Far less functional than
    a Rolodex, my `CallTrack` program maintained a list of people sorted by last name
    and first name. It also had the city, phone number, and email address of each
    person. Here is a very small portion of the code surrounding the event handling
    for the New User push button:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 通过确保数据始终按正确顺序排列，你可以避免显式排序操作的开销和经过时间，尽管这可能在总体上是否更快取决于你的数据以及你选择如何保持其排序。你可以通过手动方式或者使用`TreeSet`或者`TreeMap`来保持其排序。首先，这里有一些来自我在Java首次公开发布时编写的呼叫跟踪程序的代码（代码已稍作现代化处理！），用于跟踪我与之有长时间接触的人员。比转盘名片座机功能少得多，我的`CallTrack`程序维护了一个按姓和名排序的人员列表。它还包括每个人的城市、电话号码和电子邮件地址。这是围绕“新用户”按钮的事件处理的一小部分代码：
- en: '[PRE45]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This code uses the `String` class `compareTo(String)` routine.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码使用`String`类的`compareTo(String)`例程。
- en: Warning
  id: totrans-280
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: This code uses a linear search, which was fine for the original application
    but could get very slow on large lists (it is *O(n)*). You’d need to use hashing
    or a binary search to find where to put the values on large lists.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码使用线性搜索，对于原始应用程序来说是可以的，但在大型列表上可能变得非常缓慢（它是*O(n)*）。对于大型列表，你需要使用哈希或二进制搜索来查找放置值的位置。
- en: 'If I were writing this code today, I might well use a `TreeSet` (which keeps
    objects in order) or a `TreeMap` (which keeps the keys in order and maps from
    keys to values; the keys would be the name and the values would be the `Person`
    objects). Both insert the objects into a tree in the correct order, so an `Iterator`
    that traverses the tree always returns the objects in sorted order. In addition,
    they have methods such as `headSet()` and `headMap()`, which give a new `Set`
    or `Map` of objects of the same class, containing the objects lexically before
    a given value. The `tailSet()` and `tailMap()` methods, similarly, return objects
    greater than a given value, and `subSet()` and `subMap()` return a range. The
    `first()` and `last()` methods retrieve the obvious components from the collection.
    The following program uses a `TreeSet` to sort some names:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我今天编写这段代码，我可能会使用`TreeSet`（保持对象顺序）或者`TreeMap`（保持键顺序并映射到值；键将是姓名，值将是`Person`对象）。两者都将对象插入树中的正确顺序，因此遍历树的`Iterator`始终按排序顺序返回对象。此外，它们还有诸如`headSet()`和`headMap()`等方法，返回同一类的新的`Set`或`Map`，其中包含在给定值之前的对象。类似地，`tailSet()`和`tailMap()`方法返回大于给定值的对象，而`subSet()`和`subMap()`返回一个范围。`first()`和`last()`方法从集合中获取明显的组件。以下程序使用`TreeSet`对一些姓名进行排序：
- en: '[PRE46]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'One last point to note is that if you have a `Hashtable` or `HashMap`, you
    can convert it to a `TreeMap`, and therefore get it sorted, just by passing it
    to the `TreeMap` constructor:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 最后需要注意的一点是，如果你有一个`Hashtable`或者`HashMap`，你可以将其转换为`TreeMap`，从而获得排序，并且只需将其传递给`TreeMap`构造函数：
- en: '[PRE47]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 7.13 Finding an Object in a Collection
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.13 在集合中查找对象
- en: Problem
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to see whether a given collection contains a particular value.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要查看给定的集合是否包含特定的值。
- en: Solution
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Ask the collection if it contains an object of the given value.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 询问集合是否包含给定值的对象。
- en: Discussion
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: If you have created the contents of a collection, you probably know what is
    in it and what is not. But if the collection is prepared by another part of a
    large application, or even if you’ve just been putting objects into it and now
    need to find out if a given value was found, this recipe’s for you. There is quite
    a variety of methods, depending on which collection class you have. The methods
    in [Table 7-4](#javacook-structure-collectionmethods) can be used.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经创建了一个集合的内容，你可能知道其中的内容和不在其中的内容。但是，如果集合是由大型应用程序的另一部分准备的，或者如果你只是将对象放入其中，现在需要查找是否找到了给定的值，则可以使用此方法。根据你使用的集合类别，有各种方法。可以使用表 7-4
    中的方法。
- en: Table 7-4\. Finding objects in a collection
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 表格 7-4\. 在集合中查找对象
- en: '| Method(s) | Meaning | Implementing classes |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 含义 | 实现类别 |'
- en: '| --- | --- | --- |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `binarySearch()` | Fairly fast search | `Arrays`, `Collections` |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '| `binarySearch()` | 较快的搜索 | `Arrays`、`Collections` |'
- en: '| `contains()` | Search | `ArrayList`, `HashSet`, `Hashtable`, `LinkList`,
    `Properties`, `Vector` |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
  zh: '| `contains()` | 查找 | `ArrayList`、`HashSet`、`Hashtable`、`LinkList`、`Properties`、`Vector`
    |'
- en: '| `containsKey()`, `containsValue()` | Checks if the collection contains the
    object as a `Key` or as a `Value` | `HashMap`, `Hashtable`, `Properties`, `TreeMap`
    |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
  zh: '| `containsKey()`、`containsValue()` | 检查集合是否包含对象作为`Key`或`Value` | `HashMap`、`Hashtable`、`Properties`、`TreeMap`
    |'
- en: '| `indexOf()` | Returns location where object is found | `ArrayList`, `LinkedList`,
    `List`, `Stack`, `Vector` |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '| `indexOf()` | 返回对象被找到的位置 | `ArrayList`、`LinkedList`、`List`、`Stack`、`Vector`
    |'
- en: '| `search()` | Search | `Stack` |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
  zh: '| `search()` | 查找 | `Stack` |'
- en: The methods whose names start with `contains` will use a linear search if the
    collection is a collection (`List`, `Set`) but will be quite fast if the collection
    is hashed (`HashSet`, `HashMap`). So you do have to know what implementation is
    being used in order to think about performance, particularly when the collection
    is (or is likely to grow) large.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 如果集合是一个集合（`List`、`Set`），那么以`contains`开头的方法将使用线性搜索；如果集合是散列的（`HashSet`、`HashMap`），那么它将非常快速。因此，你必须知道正在使用的实现方式，才能考虑性能问题，特别是当集合很大（或可能会增长）时。
- en: 'The next example plays a little game of find the hidden number (or needle in
    a haystack): the numbers to look through are stored in an array. As games go,
    it’s fairly pathetic: the computer plays against itself, so you probably know
    who’s going to win. I wrote it that way so I would know that the data array contains
    valid numbers. The interesting part is not the generation of the random numbers
    (discussed in [Recipe 5.9](ch05.html#javacook-numbers-SECT-13)). The array to
    be used with `Arrays.binarySearch()` must be in sorted order, but because we just
    filled it with random numbers, it isn’t initially sorted. Hence, we call `Arrays.sort()`
    on the array. Then we are in a position to call `Arrays.binarySearch()`, passing
    in the array and the value to look for. If you run the program with a number,
    it runs that many games and reports on how it fared overall. If you don’t bother,
    it plays only one game:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个例子是一个小游戏：找到隐藏的数字（或者说是大海捞针）：要查找的数字存储在一个数组中。作为游戏来说，它相当无趣：计算机自己对弈，所以你可能知道谁会赢。我之所以这样写，是因为我想知道数据数组包含有效的数字。有趣的部分不是随机数的生成（见[配方
    5.9](ch05.html#javacook-numbers-SECT-13)）。用于`Arrays.binarySearch()`的数组必须是排序的，但是因为我们刚刚用随机数填充了它，所以它最初并不是排序的。因此，我们在数组上调用`Arrays.sort()`。然后我们可以调用`Arrays.binarySearch()`，传入数组和要查找的值。如果你用一个数字运行程序，它会运行那么多次游戏，并报告整体表现如何。如果你不在乎，它只会玩一次游戏：
- en: '[PRE48]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '`Collections.binarySearch()` works almost exactly the same way, except it looks
    in a `Collection`, which must be sorted (presumably using `Collections.sort`,
    as discussed in [Recipe 7.11](#javacook-structure-SECT-8)).'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '`Collections.binarySearch()`工作方式几乎完全相同，只是它查找`Collection`中的元素，该`Collection`必须是排序的（可能使用`Collections.sort`，如[配方
    7.11](#javacook-structure-SECT-8)中所述）。'
- en: 7.14 Converting a Collection to an Array
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.14 将集合转换为数组
- en: Problem
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You have a `Collection` but you need a Java language array.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 你有一个`Collection`，但是你需要一个Java语言数组。
- en: Solution
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the `Collection` method `toArray()`.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Collection`的`toArray()`方法。
- en: Discussion
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'If you have an `ArrayList` or other `Collection` and you need an array, you
    can get it just by calling the `Collection`’s `toArray()` method. With no arguments,
    you get an array whose type is `Object[]`. You can optionally provide an array
    argument, which is used for two purposes:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个`ArrayList`或其他`Collection`，并且你需要一个数组，你可以通过调用`Collection`的`toArray()`方法轻松获取它。如果不提供参数，你会得到一个`Object[]`类型的数组。你还可以选择提供一个数组参数，用于两个目的：
- en: The type of the array argument determines the type of array returned.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组参数的类型决定了返回的数组类型。
- en: If the array is big enough (and you can ensure that it is by allocating the
    array based on the `Collection`’s `size()` method), then this array is filled
    and returned. If the array is not big enough, a new array is allocated instead.
    If you provide an array and objects in the `Collection` cannot be cast to this
    type, then you will get an `ArrayStoreException`.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果数组足够大（你可以通过根据`Collection`的`size()`方法分配数组来保证它足够大），那么这个数组就会被填充并返回。如果数组不够大，那么会分配一个新数组。如果你提供了一个数组，并且`Collection`中的对象不能转换为该类型，那么你将会得到一个`ArrayStoreException`。
- en: '[Example 7-3](#javacook-structure-EX-1) shows code for converting an `ArrayList`
    to an array of type `Object`.'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 7-3](#javacook-structure-EX-1)展示了将`ArrayList`转换为`Object`类型数组的代码。'
- en: Example 7-3\. main/src/main/java/structure/ToArray.java
  id: totrans-315
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-3\. main/src/main/java/structure/ToArray.java
- en: '[PRE49]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 7.15 Making Your Data Iterable
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.15 使你的数据可迭代
- en: Problem
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You have written your own data structure, and you want to publish the data to
    be iterable so it can be used in the for-each loop.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经编写了自己的数据结构，并希望发布数据以便在 for-each 循环中使用。
- en: Solution
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Make your data class `Iterable`: this interace has only one method, `iterator()`.
    Write your own `Iterator`. Just implement (or provide an inner class that implements)
    the `Iterator` interface.'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 使你的数据类实现 `Iterable` 接口：这个接口只有一个方法 `iterator()`。编写你自己的 `Iterator`。只需实现（或提供一个实现了）`Iterator`
    接口的内部类即可。
- en: Discussion
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: To be usable in the modern Java for-each loop, your data class must implement
    `Iterable`, a simple interface with one method, `Iterator<T> iterator()`. Whether
    you use this interface or want to use the older `Iterator` interface directly,
    the way to make data from one part of your program available in a storage-independent
    way to other parts of the code is to generate an `Iterator`. Here is a short program
    that constructs, upon request, an `Iterator` for some data that it is storing—in
    this case, in an array. The `Iterator` interface has only three methods—`hasNext()`,
    `next()`, and `remove()`—demonstrated in [Example 7-4](#javacook-structure-EX-42).
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 要在现代的 Java for-each 循环中可用，你的数据类必须实现 `Iterable` 接口，这是一个简单的接口，有一个方法 `Iterator<T>
    iterator()`。无论你使用这个接口还是想直接使用老旧的 `Iterator` 接口，将程序中的数据以一种与存储无关的方式提供给代码的其他部分的方法是生成一个
    `Iterator`。以下是一个简短的程序，根据请求构造一个 `Iterator` 来访问某些数据，此例中是数组中的数据。`Iterator` 接口只有三个方法
    — `hasNext()`、`next()` 和 `remove()` — 在 [示例 7-4](#javacook-structure-EX-42) 中有演示。
- en: Example 7-4\. main/src/main/java/structure//IterableDemo
  id: totrans-324
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-4\. main/src/main/java/structure//IterableDemo
- en: '[PRE50]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The comments on the `remove()` method remind me of an interesting point. This
    interface introduces `java.util`’s attempt at something Java doesn’t really have,
    the optional method. Because there is no syntax for this, and they didn’t want
    to introduce any new syntax, the developers of the Collections Framework decided
    on an implementation using existing syntax. Optional methods that are not implemented
    are required to throw an `UnsupportedOperationException` if they ever get called.
    My `remove()` method does just that. Note that `UnsupportedOperationException`
    is subclassed from `RuntimeException`, so it is not required to be declared or
    caught.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '`remove()` 方法的注释让我想起了一个有趣的点。这个接口引入了 `java.util` 尝试的一个 Java 实际上并没有的东西，即可选方法。因为没有语法支持，而且他们不想引入任何新的语法，Collections
    Framework 的开发者们决定使用现有的语法来实现。如果调用未实现的可选方法，它们将要求抛出 `UnsupportedOperationException`
    异常。我的 `remove()` 方法正是这样做的。请注意，`UnsupportedOperationException` 是从 `RuntimeException`
    派生的，因此不需要声明或捕获它。'
- en: This code is simplistic, but it does show the syntax and demonstrates how the
    `Iterator` interface works. In real code, the `Iterator` and the data are usually
    separate objects (the `Iterator` might be an inner class from the data store class).
    Also, you don’t even need to write this code for an array; you can just construct
    an `ArrayList` object, copy the array elements into it, and ask it to provide
    the `Iterator`. However, I believe it’s worth showing this simple example of the
    internals of an `Iterator` so that you can understand both how it works and how
    you could provide one for a more sophisticated data structure, should the need
    arise.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码很简单，但展示了语法并演示了 `Iterator` 接口的工作原理。在真实的代码中，`Iterator` 和数据通常是分开的对象（`Iterator`
    可能是数据存储类的内部类）。此外，即使对于数组，你也不必编写这段代码；你可以直接构造一个 `ArrayList` 对象，将数组元素复制进去，并请求它提供 `Iterator`。然而，我认为展示这个
    `Iterator` 内部工作原理的简单示例是值得的，这样你可以理解它的工作方式，以及在需要时如何为更复杂的数据结构提供 `Iterator`。
- en: The `Iterable` interface has only one nondefault method, `iterator()`, which
    must provide an `Iterator` for objects of the given type. Because the `ArrayIterator`
    class implements this as well, we can use an object of type `ArrayIterator` in
    a “foreach” loop, as in [Example 7-5](#javacook-structure-EX-123).
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '`Iterable` 接口只有一个非默认方法 `iterator()`，必须为给定类型的对象提供一个 `Iterator`。因为 `ArrayIterator`
    类也实现了这一点，我们可以在 “foreach” 循环中使用 `ArrayIterator` 类型的对象，就像在 [示例 7-5](#javacook-structure-EX-123)
    中那样。'
- en: Example 7-5\. *main/src/main/java/structure/ArrayIteratorDemo.java*
  id: totrans-329
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-5\. *main/src/main/java/structure/ArrayIteratorDemo.java*
- en: '[PRE51]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Java 8 Iterable.foreach
  id: totrans-331
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Java 8 中的 Iterable.foreach
- en: Java 8 adds `foreach` to the `Iterator` interface, a *default method* (discussed
    in [Recipe 9.0](ch09.html#javacook-fp-intro)) that you don’t have to write. Thus,
    without changing the `ArrayIterator`, after moving to Java 8 we can use the newest-style
    loop, `Iterator.foreach(Consumer)`, with a lambda expression (see [Chapter 9](ch09.html#javacook-fp))
    to print each element (see [Example 7-5](#javacook-structure-EX-123)).
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8为`Iterator`接口添加了`foreach`，这是一个*默认方法*（在[Recipe 9.0](ch09.html#javacook-fp-intro)中讨论），你不必编写它。因此，在迁移到Java
    8后，我们可以使用最新风格的循环`Iterator.foreach(Consumer)`，结合lambda表达式（参见[Chapter 9](ch09.html#javacook-fp)）来打印每个元素（参见[Example 7-5](#javacook-structure-EX-123)）。
- en: 7.16 Using a Stack of Objects
  id: totrans-333
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.16 使用对象栈
- en: Problem
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to process data in the order of last in, first out (LIFO) or most recently
    added.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 需要按照后进先出（LIFO）或最近添加的顺序处理数据。
- en: Solution
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Write your own code for creating a stack; it’s easy. Or, use a `java.util.Stack`.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 为创建一个栈编写你自己的代码很容易。或者，使用`java.util.Stack`。
- en: Discussion
  id: totrans-338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: You need to put things into a holding area quickly and retrieve them in last-in,
    first-out order. This is a common data structuring operation and is often used
    to reverse the order of objects. The basic operations of any stack are `push()`
    (add to stack), `pop()` (remove from stack), and `peek()` (examine top element
    without removing). `ToyStack` in [Example 7-6](#javacook-structure-toystack) is
    a simple class for stacking values of the primitive type `int`. I’ll expand it
    in a page or two to allow stacking of user-defined objects.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 需要快速将物品放入一个保持区，并以后进先出的顺序取出它们。这是一个常见的数据结构操作，通常用于颠倒对象的顺序。任何栈的基本操作包括`push()`（添加到栈）、`pop()`（从栈中移除）和`peek()`（查看顶部元素而不移除）。`ToyStack`在[Example 7-6](#javacook-structure-toystack)中是一个简单的类，用于堆叠原始类型`int`的值。我将在一页或两页中扩展它，以允许堆叠用户定义的对象。
- en: Example 7-6\. main/src/main/java/structure/ToyStack.java
  id: totrans-340
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 7-6\. main/src/main/java/structure/ToyStack.java
- en: '[PRE52]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: If you are not familiar with the basic idea of a stack, you should work through
    the code here; if you are familiar with it, you can skip ahead. While looking
    at it, of course, think about what happens if `pop()` or `peek()` is called when
    `push()` has never been called or if `push()` is called to stack more data than
    will fit.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对栈的基本概念不熟悉，你应该先阅读这里的代码；如果你已经熟悉，可以跳过。
- en: 'While working on `ToyStack2` (not shown but in the online source), I extracted
    its interface into `SimpleStack`, which just lists the operations. At the same
    time I added the `empty()` method for some compatibility with the standard `java.util.Stack`
    class. And importantly, I made it a generic type, so it can be used with values
    of any type. This is shown in `SimpleStack`:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在工作中`ToyStack2`（未显示但在在线源代码中），我将其接口提取为`SimpleStack`，只列出操作。同时，我添加了`empty()`方法，以便与标准的`java.util.Stack`类兼容。更重要的是，我使其成为一个泛型类型，因此可以用于任何类型的值。这在`SimpleStack`中展示：
- en: '[PRE53]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'I then made another demo stack class, `MyStack`, to implement the new interface:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 我接着又制作了另一个演示栈类`MyStack`，来实现这个新接口：
- en: '[PRE54]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This version has a lot more error checking (and a unit test, in the *src/test/java/structure*
    folder), as well as some additional methods not in the original. One example is
    `hasRoom()`. Unlike the full-blown `java.util.Stack`, `MyStack` does not expand
    beyond its original size, so we need a way to see if it is full without throwing
    an exception.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本增加了许多错误检查（以及一个单元测试，在*src/test/java/structure*文件夹中），以及一些原始版本中没有的额外方法。一个例子是`hasRoom()`。不像完整的`java.util.Stack`，`MyStack`不会扩展超出其原始大小，因此我们需要一种方法来查看它是否已满，而不是抛出异常。
- en: Now that you see how a stack works, I recommend using the provided `java.util.Stack`
    instead of my demo versions; it is more fully fleshed out, more fully tested,
    and widely used. Unlike the major Collections API components `List`, `Set`, and
    `Map`, `java.util.Stack` does not have an interface and implementation class(es);
    it is based on `Vector`, which is a `List` implementation. The real `java.util.Stack`
    works in a similar manner to mine but has more methods and more flexibility. To
    see that in operation, [Recipe 5.12](ch05.html#javacook-numbers-SECT-19) provides
    a simple stack-based numeric calculator.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到栈是如何工作的，我建议使用提供的`java.util.Stack`而不是我的演示版本；它更加完整、经过了更多测试，并且被广泛使用。与主要的集合API组件`List`、`Set`和`Map`不同，`java.util.Stack`没有接口和实现类；它基于`Vector`，这是`List`的一种实现。真正的`java.util.Stack`与我的类似，但是有更多的方法和更大的灵活性。要查看它的运行方式，[Recipe
    5.12](ch05.html#javacook-numbers-SECT-19)提供了一个简单的基于栈的数值计算器。
- en: 7.17 Multidimensional Structures
  id: totrans-349
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.17 多维结构
- en: Problem
  id: totrans-350
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need a multidimensional array or `ArrayList`.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要一个多维数组或`ArrayList`。
- en: Solution
  id: totrans-352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: No problem. Java supports this.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 没问题。Java支持这一点。
- en: Discussion
  id: totrans-354
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: As mentioned back in [Recipe 7.1](#javacook-structure-SECT-1), Java arrays can
    hold any reference type. Because an array is a reference type, it follows that
    you can have arrays of arrays or, in other terminology, *multidimensional* arrays.
    Further, because each array has its own length attribute, the columns of a two-dimensional
    array, for example, do not all have to be the same length (see [Figure 7-3](#javacook-structure-FIG-2)).
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 如[Recipe 7.1](#javacook-structure-SECT-1)中提到的，Java数组可以持有任何引用类型。因为数组是一个引用类型，所以您可以有数组的数组，或者换种说法，*多维*数组。此外，由于每个数组都有自己的长度属性，例如，二维数组的列不必都具有相同的长度（参见[Figure 7-3](#javacook-structure-FIG-2)）。
- en: 'Here is code to allocate a couple of two-dimensional arrays, one using a loop
    and the other using an initializer. Both are selectively printed:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是分配一对二维数组的代码，一个使用循环，另一个使用初始化程序。两者都有选择地打印：
- en: '[PRE55]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '![jcb4 0703](assets/jcb4_0703.png)'
  id: totrans-358
  prefs: []
  type: TYPE_IMG
  zh: '![jcb4 0703](assets/jcb4_0703.png)'
- en: Figure 7-3\. Multidimensional arrays
  id: totrans-359
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7-3\. 多维数组
- en: 'Running it produces this output:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 运行它将产生以下输出：
- en: '[PRE56]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The same kind of logic can be applied to any of the `Collections`. You could
    have an `ArrayList` of `ArrayLists`, or a `Vector` of linked lists, or whatever
    your little heart desires.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的逻辑可以应用于任何`Collections`。您可以有`ArrayList`的`ArrayList`，或者`Vector`的链表，或者您心之所欲的任何内容。
- en: As [Figure 7-3](#javacook-structure-FIG-2) shows, it is not necessary for the
    array to be regular (i.e., it’s possible for each column of the 2D array to have
    a different height). That is why I used `array[0].length` for the length of the
    first column in the code example.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 如[Figure 7-3](#javacook-structure-FIG-2)所示，数组不必是规则的（即二维数组的每列可以具有不同的高度）。这就是为什么在代码示例中我使用了`array[0].length`来获取第一列的长度的原因。
- en: 7.18 Simplifying Data Objects with Lombok or Record
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.18 使用Lombok或记录简化数据对象
- en: Problem
  id: totrans-365
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You waste time writing data classes that are Plain Old Java Objects (POJO),
    with boilerplate code such as setters and getters, `equals()`, and `toString()`.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 您浪费时间编写数据类，这些类是普通的旧Java对象（POJO），具有诸如setter和getter、`equals()`和`toString()`等样板代码。
- en: Solution
  id: totrans-367
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use Lombok to autogenerate boilerplate methods. In Java 14+, use the new `record`
    data type, which generates the boilerplate methods for you.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Lombok自动生成样板方法。在Java 14+中，请使用新的`record`数据类型，该类型为您生成样板方法。
- en: Discussion
  id: totrans-369
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: When Java was new, before there were good IDEs, developers had to write getters
    and setters by hand, or by copy-paste-change. Back then I did a study of one existing
    large code base and found about a 1/2% failure rate. The setter stored the value
    in the wrong place or the getter retrieved the wrong value. Assuming random distribution,
    this meant that one getter call in a hundred gave the wrong answer! The application
    still worked, so I must assume those wrong answers didn’t matter.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java刚出现时，在没有好的IDE的情况下，开发人员必须手工编写getter和setter，或者复制粘贴修改。当时我研究了一个现有的大型代码库，发现了约0.5%的失败率。setter把值存储在错误的位置，或者getter检索了错误的值。假设随机分布，这意味着百分之一的getter调用会给出错误的答案！应用程序仍然工作，所以我必须假设那些错误的答案并不重要。
- en: Now we have IDEs that can generate all the boilerplate methods such as setters/getters,
    equals, `toString()`, and so on. But you still have to remember to invoke these
    generators.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了可以生成所有样板方法的IDE，例如setter/getter、equals、`toString()`等等。但是您仍然需要记住调用这些生成器。
- en: Lombok
  id: totrans-372
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Lombok
- en: Project Lombok provides one solution. It reads your *.class* files looking for
    its own annotations and, when it finds them, rewrites the class files to have
    the chosen methods.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: Project Lombok提供了一个解决方案。它读取您的*.class*文件，查找其自己的注解，当找到它们时，重写类文件以具有所选的方法。
- en: 'To use Lombok, you need to add the dependency `org.projectlombok:lombok:1.18.4`
    (or newer) to your build script. Or, if you are using an IDE, download the Lombok
    JAR file from [*https://projectlombok.org*](https://projectlombok.org) and install
    it as per the instructions there. Then you can annotate your class with annotations
    like these:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Lombok，您需要将依赖项`org.projectlombok:lombok:1.18.4`（或更新版本）添加到您的构建脚本中。或者，如果您使用的是IDE，请从[*https://projectlombok.org*](https://projectlombok.org)下载Lombok
    JAR文件，并按照那里的说明安装它。然后，您可以使用类似以下的注解来注释您的类：
- en: '[PRE57]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Presto! No more forgetting to generate these methods; Lombok will do the work
    for you.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: Presto！不再忘记生成这些方法；Lombok将为您完成这项工作。
- en: 'Other annotations include the following:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 其他注解包括以下内容：
- en: '[PRE58]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: For data classes, there is even `@Data`, which is a shortcut for `@ToString`,
    `@EqualsAndHashCode`, `@Getter` on all fields, `@Setter` on all nonfinal fields,
    and `@RequiredArgsConstructor`!
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数据类，甚至还有`@Data`，它是`@ToString`、`@EqualsAndHashCode`、所有字段的`@Getter`，所有非final字段的`@Setter`以及`@RequiredArgsConstructor`的快捷方式！
- en: Java 14 record (preview)
  id: totrans-380
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Java 14 `record`（预览）
- en: 'The new `record` type provides another solution. A `record` is a class-like
    construct for data classes, a restricted form of class like enums and annotations.
    You need only write the name of a data object and its fields, and the compiler
    will provide a constructor, getters, `hashCode()` and `equals()`, and `toString()`:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`record`类型提供了另一种解决方案。`record`是用于数据类的类似类的构造，是类似于枚举和注解的受限类形式。您只需编写数据对象的名称及其字段，编译器将提供构造函数、getter、`hashCode()`、`equals()`和`toString()`：
- en: '[PRE59]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The provided constructor has the same signature as the record declaration.
    All fields are implicitly final, and the `record` provides getters but not setters.
    The getters have the name of the field; they do not follow the JavaBeans *getName()*
    pattern. Immutable objects are important for reliable code (see [Recipe 9.0](ch09.html#javacook-fp-intro)).
    You can provide other members such as extra constructors, static fields, and static
    or instance methods. Records cannot be abstract and cannot declare additional
    instance fields. All in keeping with the fact that the state of the object is
    as declared in the `record` header. Here I create a `Person` record and make an
    instance of it, all in JShell:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的构造函数与记录声明具有相同的签名。所有字段都隐式为final，并且`record`提供了getter但不提供setter。Getter的名称与字段相同；它们不遵循JavaBeans
    *getName()*模式。对于可靠的代码，不可变对象至关重要（参见[食谱 9.0](ch09.html#javacook-fp-intro)）。您可以提供其他成员，如额外的构造函数、静态字段以及静态或实例方法。记录不能是抽象的，也不能声明额外的实例字段。所有这些都与对象的状态如`record`头部声明的内容一致。在这里，我在JShell中创建了一个`Person`记录，并生成了一个实例：
- en: '[PRE60]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'One-line record definitions typically don’t need to be in a source file all
    their own. To show a complete example, I baked the `Person` record into a new
    demo program `PersonRecordDemo`. We can save this into a file, compile it with
    *javac*, and then use *javap* to view the class’s structure:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 单行记录定义通常不需要单独的源文件。为了展示一个完整的示例，我将`Person`记录集成到一个名为`PersonRecordDemo`的新演示程序中。我们可以将其保存到一个文件中，用*javac*编译它，然后使用*javap*查看类的结构：
- en: '[PRE61]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The *$* in the filename has to be escaped from the Unix shell. We see that the
    compiler has generated the constructor, `toString()`, `hashCode()` and `equals()`,
    and read-only accessors `name()` and `email()`.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 文件名中的*$*必须从Unix shell中转义。我们可以看到编译器已生成了构造函数、`toString()`、`hashCode()`和`equals()`，以及`name()`和`email()`的只读访问器。
- en: Warning
  id: totrans-388
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: As of Java 14 the `record` mechanism is a preview, so it may change from what
    is described here or might even (however unlikely) not appear in the final Java
    14 or in a future Java release (though we hope it will appear as is, nonpreview,
    in Java 15). If you are using Java 14 you need the `--enable-preview` option on
    commands like *javap*, *javac*, and *jshell*, as well as `--source 14` on commands
    that read the source file.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 从Java 14开始，`record`机制是一个预览功能，因此可能与此处描述的内容有所不同，甚至（虽然不太可能）在最终的Java 14版本或未来的Java版本中可能不会出现（尽管我们希望它会如预期那样在Java
    15中以非预览形式出现）。如果您使用Java 14，您需要在诸如*javap*、*javac*和*jshell*之类的命令上加上`--enable-preview`选项，以及在读取源文件的命令上加上`--source
    14`选项。
- en: See Also
  id: totrans-390
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The original description of and rationale for the `record` mechanism is in [Java
    Enhancement Proposal JEP-359](https://openjdk.java.net/jeps/359) at OpenJDK.net.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '`record`机制的原始描述和理由在[Java Enhancement Proposal JEP-359](https://openjdk.java.net/jeps/359)中可以找到，位于OpenJDK.net上。'
- en: '7.19 Program: Timing Comparisons'
  id: totrans-392
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.19 程序：时间比较
- en: 'New developers sometimes worry about the overhead of these collections and
    think they should use arrays instead of data structures. To investigate, I wrote
    a program that creates and accesses 250,000 objects, once through a Java array
    and again through an `ArrayList`. This is a lot more objects than most programs
    use. First the code for the `Array` version:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 新开发人员有时会担心这些集合的开销，认为他们应该使用数组而不是数据结构。为了调查，我编写了一个程序，创建并访问了25万个对象，一次通过Java数组，再通过`ArrayList`。这比大多数程序使用的对象要多得多。首先是`Array`版本的代码：
- en: '[PRE62]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'And here’s the code for the `ArrayList` version:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`ArrayList`版本的代码：
- en: '[PRE63]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The `Vector`-based version, `ArrayVec`, is sufficiently similar that I don’t
    feel the need to kill a tree reprinting its code—it’s online.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 基于`Vector`的版本`ArrayVec`与其相似到足以不需要大量重复其代码，这些代码可以在线查找到。
- en: How can we time this? As covered in [Recipe 17.7](ch17.html#javacook-reflection-SECT-5),
    you can either use the operating system’s *time* command, if available, or just
    use a bit of Java that times a run of your main program. To be portable, I chose
    to use the latter on an older, slower machine. Its exact speed doesn’t matter
    because the important thing is to compare only versions of this program running
    on the same machine.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 怎样计时呢？如同 [Recipe 17.7](ch17.html#javacook-reflection-SECT-5) 所述，如果可用，你可以使用操作系统的
    *time* 命令，或者只需使用一点 Java 来计时你的主程序运行。为了可移植性，我选择在一台较老、较慢的机器上使用后者。其确切速度并不重要，因为重要的是仅比较在同一台机器上运行的该程序的不同版本。
- en: 'Finally (drum roll, please), the results:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 最后（鼓声响起），结果如下：
- en: '[PRE64]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Notice that I have ignored one oft-quoted bit of advice that recommends giving
    a good initial estimate on the size of the `ArrayList`. I did time it that way
    as well; in this example, it made a difference of less than 4% in the total runtime.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我忽略了一个经常引用的建议，即给出 `ArrayList` 大小的良好初始估计。我也以那种方式计时过；在这个例子中，它使总运行时间减少不到 4%。
- en: The bottom line is that the efficiency of `ArrayList` is not totally awful compared
    to arrays. Obviously there is more overhead in calling a “get” method than in
    retrieving an element from an array. The overhead of objects whose methods actually
    do some computation probably outweighs the overhead of fetching and storing objects
    in an `ArrayList` rather than in an `Array`. Unless you are dealing with large
    numbers of objects, you may not need to worry about it. `Vector` is slightly slower
    but still only about two-thirds the speed of the original array version. If you
    are concerned about the time, once the finished size of the `ArrayList` is known,
    you can convert the `ArrayList` to an array (see [Recipe 7.14](#javacook-structure-SECT-12)).
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 底线是，`ArrayList` 的效率与数组相比并非完全糟糕。显然，调用“get”方法会有更多开销，而不是从数组中检索元素。实际执行一些计算的对象方法的开销可能会超过将对象存储在
    `ArrayList` 而不是 `Array` 中的开销。除非你处理大量对象，否则可能不需要担心这个问题。`Vector` 稍慢一些，但仍然只有原始数组版本速度的三分之二左右。如果你关心时间，一旦知道
    `ArrayList` 的最终大小，可以将 `ArrayList` 转换为数组（参见 [Recipe 7.14](#javacook-structure-SECT-12)）。
- en: ^([1](ch07.html#idm45290673293208-marker)) You could copy it yourself using
    a `for` loop if you wish, but `System.arrayCopy()` is likely to be faster because
    it’s implemented in native code.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch07.html#idm45290673293208-marker)) 如果你愿意，可以使用 `for` 循环自己复制它，但是 `System.arrayCopy()`
    可能会更快，因为它是用本地代码实现的。
- en: ^([2](ch07.html#idm45290671381032-marker)) Both `List` and `Set` extend `Collection`.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch07.html#idm45290671381032-marker)) `List` 和 `Set` 都扩展自 `Collection`。
