<html><head></head><body>
<div id="sbo-rt-content"><section data-pdf-bookmark="Chapter 2. Functional Java" data-type="chapter" epub:type="chapter"><div class="chapter" id="_01-functional-java">
<h1><span class="label">Chapter 2. </span>Functional Java</h1>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45115256983552">
<h1>A Note for Early Release Readers</h1>
<p>With Early Release ebooks, you get books in their earliest form—the author’s raw and unedited content as they write—so you can take advantage of these technologies long before the official release of these titles.</p>
<p>This will be the 2nd chapter of the final book. Please note that the GitHub repo will be made active later on.</p>
<p>If you have comments about how we might improve the content and/or examples in this book, or if you notice missing material within this chapter, please reach out to the editor at <em>rfernando@oreilly.com</em>.</p>
</div></aside>
<p>Unsurprisingly, <em>lambda expressions</em> are the key to having a functional approach in Java.</p>
<p>In this chapter, you will learn how to use lambdas in Java, why they are so important, how to use them efficiently, and how they work internally.</p>
<section data-pdf-bookmark="What Are Java Lambdas?" data-type="sect1"><div class="sect1" id="idm45115256979280">
<h1>What Are Java Lambdas?</h1>
<p>A lambda expression is a single line or block of Java code that zero or more parameters and might return a value.
From a simplified point of view, a lambda is like an <em>anonymous method</em> that doesn’t belong to any object:</p>
<pre data-code-language="java" data-type="programlisting"><code class="p">()</code> <code class="o">-&gt;</code> <code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="s">"Hello, lambda!"</code><code class="p">)</code></pre>
<p>Let’s look at the details of the syntax and how lambdas are implemented in Java.</p>
<section data-pdf-bookmark="Lambda Syntax" data-type="sect2"><div class="sect2" id="idm45115256972336">
<h2>Lambda Syntax</h2>
<p>The Java syntax for lambdas is quite similar to the mathematical notation you saw in <a data-type="xref" href="ch01.xhtml#_01-an-introduction">Chapter 1</a> for lambda calculus:</p>
<pre data-type="programlisting">(&lt;parameters&gt;) -&gt; { &lt;body&gt; };</pre>
<p>The syntax consists of three distinct parts:</p>
<dl>
<dt>Parameters</dt>
<dd>
<p>A comma-separated list of parameters, just like a method argument list.
Unlike method arguments, though, you can omit the argument types if the compiler can infer them.
Mixing implicitly and explicitly typed parameters is not allowed.
You don’t need parentheses for a single parameter, but they are required if none or more than one parameter is present.</p>
</dd>
<dt>Arrow</dt>
<dd>
<p>The <code>-&gt;</code> (arrow) separates the parameters from the lambda body.
It’s the equivalent to <math alttext="lamda">
<mi>λ</mi>
</math> in lambda calculus.</p>
</dd>
<dt>Body</dt>
<dd>
<p>Either a single expression or a code block.
Single-line expressions don’t require curly braces, and their evaluated result returns implicitly without a <code>return</code> statement.
A typical Java code block is used if the body is represented by more than a single expression.
It must be wrapped in curly braces and explicitly use a <code>return</code> statement if a value is supposed to be returned.</p>
</dd>
</dl>
<p>That is all the syntax definition there is for lambdas in Java.
With its multiple ways of declaring a lambda, you can write the same lambda with different levels of verbosity, as seen in <a data-type="xref" href="#_01-functions_java-lambdas_syntax-compare">Example 2-1</a>.</p>
<div data-type="example" id="_01-functions_java-lambdas_syntax-compare">
<h5><span class="label">Example 2-1. </span>Different ways of writing the same lambda</h5>
<pre data-code-language="java" data-type="programlisting"><code class="p">(</code><code class="n">String</code> <code class="n">input</code><code class="p">)</code> <code class="o">-</code><code class="o">&gt;</code> <code class="p">{</code> <a class="co" href="#callout_functional_java_CO1-1" id="co_functional_java_CO1-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a>
  <code class="k">return</code> <code class="n">input</code> <code class="o">!</code><code class="o">=</code> <code class="kc">null</code><code class="p">;</code>
<code class="p">}</code>

<code class="n">input</code> <code class="o">-</code><code class="o">&gt;</code> <code class="p">{</code> <a class="co" href="#callout_functional_java_CO1-2" id="co_functional_java_CO1-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a>
  <code class="k">return</code> <code class="n">input</code> <code class="o">!</code><code class="o">=</code> <code class="kc">null</code><code class="p">;</code>
<code class="p">}</code>

<code class="p">(</code><code class="n">String</code> <code class="n">input</code><code class="p">)</code> <code class="o">-</code><code class="o">&gt;</code> <code class="n">input</code> <code class="o">!</code><code class="o">=</code> <code class="kc">null</code><code class="p">;</code> <a class="co" href="#callout_functional_java_CO1-3" id="co_functional_java_CO1-3"><img alt="3" height="12" src="assets/3.png" width="12"/></a>

<code class="n">input</code> <code class="o">-</code><code class="o">&gt;</code> <code class="n">input</code> <code class="o">!</code><code class="o">=</code> <code class="kc">null</code><code class="p">;</code> <a class="co" href="#callout_functional_java_CO1-4" id="co_functional_java_CO1-4"><img alt="4" height="12" src="assets/4.png" width="12"/></a></pre></div>
<dl class="calloutlist">
<dt><a class="co" href="#co_functional_java_CO1-1" id="callout_functional_java_CO1-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p>The most verbose variant: an explicitly typed parameter in parenthesis and a body block.</p></dd>
<dt><a class="co" href="#co_functional_java_CO1-2" id="callout_functional_java_CO1-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a></dt>
<dd><p>The first mixed variant: type inference for parameters allows removing the explicit type, and a single parameter doesn’t need parenthesis.
That shortens the lambda declaration slightly without removing information due to the surrounding context.</p></dd>
<dt><a class="co" href="#co_functional_java_CO1-3" id="callout_functional_java_CO1-3"><img alt="3" height="12" src="assets/3.png" width="12"/></a></dt>
<dd><p>The second mixed variant: an explicitly typed parameter in parenthesis but a single expression body instead of a block, no curly braces or <code>return</code> statement are needed.</p></dd>
<dt><a class="co" href="#co_functional_java_CO1-4" id="callout_functional_java_CO1-4"><img alt="4" height="12" src="assets/4.png" width="12"/></a></dt>
<dd><p>The most concise variant: As the body is reducible to a single expression.</p></dd>
</dl>
<p>Which variant to choose depends highly on the context and personal preference.
Usually, the compiler can infer the types, but that doesn’t mean a human reader is as good at understanding the shortest code possible as a compiler does.</p>
<p>Even though you should always strive for clean and more concise code, that doesn’t mean it has to be as minimal as possible.
A certain amount of verbosity might help any reader — you included — to understand the reasoning behind the code better and make the mental model of your code more graspable.</p>
</div></section>
<section data-pdf-bookmark="Functional Interfaces" data-type="sect2"><div class="sect2" id="_01-functions_functional-interfaces">
<h2>Functional Interfaces</h2>
<p>So far, we’ve only looked at the general concept of lambdas in isolation.
However, they still have to exist inside Java and its concepts and language rules as well.</p>
<p>Java is known for its backward compatibility.
That’s why even though the lambda syntax is a breaking change to the Java syntax itself, they’re still based on ordinary interfaces to be backward compatible and feel quite familiar to any Java developer.</p>
<p>To achieve their <em>first-class citizenship</em>, lambdas in Java require a representation comparable to the existing types, like objects and primitives, as discussed in <a data-type="xref" href="ch01.xhtml#_01-an-introduction_concepts_first-class">“First-Class and Higher-Order Functions”</a>.
Therefore, lambdas are represented by a specialized subtype of interfaces, so-called <em>functional interfaces</em>.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45115256785360">
<h1>Interfaces in Java</h1>
<p>Interface declarations consist of a name with optional generic bounds, inherited interfaces, and its body.
Such a body is allowed to contain the following content:</p>
<dl>
<dt>Method signatures</dt>
<dd>
<p>Body-less — <code>abstract</code> — method signatures that must be implemented by any class conforming to the interface.
Only these method signatures count towards the <em>single abstract method</em> constraint of <em>functional interfaces</em>.</p>
</dd>
<dt>Default methods</dt>
<dd>
<p>Methods signatures can have a “default” implementation, signified by the <code>default</code> keyword and a body block.
Any class implementing the interface <em>can</em> override it but <em>isn’t required</em> to do so.</p>
</dd>
<dt>Static methods</dt>
<dd>
<p>Like the class-based counterparts, they’re associated with the type itself and must provide an implementation.
But unlike <code>default</code> methods, they aren’t inherited and can’t be overridden.</p>
</dd>
<dt>Constant values</dt>
<dd>
<p>Values that are automatic <code>public</code>, <code>static</code>, and <code>final</code>.</p>
</dd>
</dl>
</div></aside>
<p>There isn’t any explicit syntax or language keyword for <em>functional interfaces</em>.
They look and feel like any other interface, can extend or be extended by other interfaces, and classes can implement them.
If they are just like “normal” interfaces, what makes them a “functional” interface then?
It’s their enforced requirement that they may only define a <em>single abstract method</em> (SAM).</p>
<p>As the name signifies, the SAM count only applies to <code>abstract</code> methods.
There’s no limit to any additional, non-<code>abstract</code> methods.
Neither <code>default</code> nor <code>static</code> methods are abstract, hence not relevant for the SAM count.
That’s why they are often used to complement the capabilities of the lambda type.</p>
<div data-type="tip"><h6>Tip</h6>
<p>Most functional interfaces of the JDK give you additional <code>default</code> and <code>static</code> methods related to the type.
Checking out the interface declarations of any functional interface might reveal many hidden gems of functionality.</p>
</div>
<p>Consider <a data-type="xref" href="#_01-functions-functional-interfaces_predicate">Example 2-2</a>, which shows a simplified version<sup><a data-type="noteref" href="ch02.xhtml#idm45115256766512" id="idm45115256766512-marker">1</a></sup> of the functional interface <code>java.util.function.Predicate&lt;T&gt;</code>.
A <code>Predicate</code> is a functional interface for testing conditions, which will be explained in more detail in <a data-type="xref" href="ch03.xhtml#_01-functions_the-big-four">“The Big Four Functional Interface Categories”</a>.
Besides having a single abstract method, <code>boolean test(T t)</code>, it provides five additional methods (three <code>default</code>, two <code>static</code>).</p>
<div data-type="example" id="_01-functions-functional-interfaces_predicate">
<h5><span class="label">Example 2-2. </span>Simplified <code>java.util.functional.Predicate&lt;T&gt;</code></h5>
<pre data-code-language="java" data-type="programlisting"><code class="kn">package</code> <code class="nn">java.util.function</code><code class="p">;</code>

<code class="nd">@FunctionalInterface</code> <a class="co" href="#callout_functional_java_CO2-1" id="co_functional_java_CO2-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a>
<code class="kd">public</code> <code class="kd">interface</code> <code class="nc">Predicate</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code> <code class="p">{</code>

  <code class="kt">boolean</code> <code class="nf">test</code><code class="p">(</code><code class="n">T</code> <code class="n">t</code><code class="p">)</code><code class="p">;</code> <a class="co" href="#callout_functional_java_CO2-2" id="co_functional_java_CO2-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a>

  <code class="k">default</code> <code class="n">Predicate</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code> <code class="nf">and</code><code class="p">(</code><code class="n">Predicate</code><code class="o">&lt;</code><code class="o">?</code> <code class="kd">super</code> <code class="n">T</code><code class="o">&gt;</code> <code class="n">other</code><code class="p">)</code> <code class="p">{</code> <a class="co" href="#callout_functional_java_CO2-3" id="co_functional_java_CO2-3"><img alt="3" height="12" src="assets/3.png" width="12"/></a>
    <code class="c1">// ...</code>
  <code class="p">}</code>

  <code class="k">default</code> <code class="n">Predicate</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code> <code class="nf">negate</code><code class="p">(</code><code class="p">)</code> <code class="p">{</code> <a class="co" href="#callout_functional_java_CO2-3" id="co_functional_java_CO2-4"><img alt="3" height="12" src="assets/3.png" width="12"/></a>
    <code class="c1">// ...</code>
  <code class="p">}</code>

  <code class="k">default</code> <code class="n">Predicate</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code> <code class="nf">or</code><code class="p">(</code><code class="n">Predicate</code><code class="o">&lt;</code><code class="o">?</code> <code class="kd">super</code> <code class="n">T</code><code class="o">&gt;</code> <code class="n">other</code><code class="p">)</code> <code class="p">{</code> <a class="co" href="#callout_functional_java_CO2-3" id="co_functional_java_CO2-5"><img alt="3" height="12" src="assets/3.png" width="12"/></a>
    <code class="c1">// ...</code>
  <code class="p">}</code>

  <code class="kd">static</code> <code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code> <code class="n">Predicate</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code> <code class="nf">isEqual</code><code class="p">(</code><code class="n">Object</code> <code class="n">targetRef</code><code class="p">)</code> <code class="p">{</code> <a class="co" href="#callout_functional_java_CO2-4" id="co_functional_java_CO2-6"><img alt="4" height="12" src="assets/4.png" width="12"/></a>
    <code class="c1">// ...</code>
  <code class="p">}</code>

  <code class="kd">static</code> <code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code> <code class="n">Predicate</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code> <code class="nf">not</code><code class="p">(</code><code class="n">Predicate</code><code class="o">&lt;</code><code class="o">?</code> <code class="kd">super</code> <code class="n">T</code><code class="o">&gt;</code> <code class="n">target</code><code class="p">)</code> <code class="p">{</code> <a class="co" href="#callout_functional_java_CO2-4" id="co_functional_java_CO2-7"><img alt="4" height="12" src="assets/4.png" width="12"/></a>
    <code class="c1">// ...</code>
  <code class="p">}</code>
<code class="p">}</code></pre></div>
<dl class="calloutlist">
<dt><a class="co" href="#co_functional_java_CO2-1" id="callout_functional_java_CO2-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p>The type has a <code>@FunctionalInterface</code> annotation, which isn’t explicitly required.</p></dd>
<dt><a class="co" href="#co_functional_java_CO2-2" id="callout_functional_java_CO2-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a></dt>
<dd><p>The single abstract method of the type <code>Predicate&lt;T&gt;</code>.</p></dd>
<dt><a class="co" href="#co_functional_java_CO2-3" id="callout_functional_java_CO2-3"><img alt="3" height="12" src="assets/3.png" width="12"/></a></dt>
<dd><p>Several <code>default</code> methods provide support for functional composition.</p></dd>
<dt><a class="co" href="#co_functional_java_CO2-6" id="callout_functional_java_CO2-4"><img alt="4" height="12" src="assets/4.png" width="12"/></a></dt>
<dd><p>Convenience <code>static</code> methods are used to simplify creation or to wrap existing lambdas.</p></dd>
</dl>
<p>Any interface with a single abstract method is automatically a functional interface.
Therefore, any of their implementations is representable by a lambda, too.</p>
<p>Java 8 added the marker annotation <code>@FunctionalInterface</code> to enforce the SAM requirement at the compiler level.
It isn’t mandatory, but it tells the compiler and possibly other annotation-based tooling that an interface should be a functional interface and, therefore, that the single abstract method requirement must be enforced.
If you add another <code>abstract</code> method, the Java compiler will refuse to compile your code.
That’s why adding the annotation to any functional interface makes a lot of sense, even if you don’t explicitly need it.
It clarifies the reasoning behind your code and the intention of such an interface and fortifies your code against unintentional changes that might break it in the future.</p>
<p>The optional nature of the <code>@FunctionalInterface</code> annotation also enables the backward compatibility of existing interfaces.
As long as an interface fulfills the SAM requirements, it’s representable as a lambda.
I’ll talk about the functional interfaces of the JDK later in this chapter.</p>
</div></section>
<section data-pdf-bookmark="Lambdas and Outside Variables" data-type="sect2"><div class="sect2" id="_01-introduction_pure-lambas-effectively-final">
<h2>Lambdas and Outside Variables</h2>
<p><a data-type="xref" href="ch01.xhtml#_01-an-introduction_pure-functions">“Pure Functions and Referential Transparency”</a> introduced the concept of <em>pure</em> — self-contained and side-effect-free — functions that won’t affect any outside state and only rely on their arguments.
Even though lambdas follow the same gist, they also allow a certain degree of impurity to be more flexible.
They can “capture” constants and variables from their creation scope in which the lambda is defined, which makes such variables available to them even if the original scope no longer exists, as shown in <a data-type="xref" href="#_01-functions_pure-lambas_capture">Example 2-3</a>.</p>
<div data-type="example" id="_01-functions_pure-lambas_capture">
<h5><span class="label">Example 2-3. </span>Lambda variable capture</h5>
<pre data-code-language="java" data-type="programlisting"><code class="kt">void</code> <code class="nf">capture</code><code class="p">(</code><code class="p">)</code> <code class="p">{</code>

  <code class="kd">var</code> <code class="n">theAnswer</code> <code class="o">=</code> <code class="mi">42</code><code class="p">;</code> <a class="co" href="#callout_functional_java_CO3-1" id="co_functional_java_CO3-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a>

  <code class="n">Runnable</code> <code class="n">printAnswer</code> <code class="o">=</code>
    <code class="p">(</code><code class="p">)</code> <code class="o">-</code><code class="o">&gt;</code> <code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="s">"</code><code class="s">the answer is </code><code class="s">"</code> <code class="o">+</code> <code class="n">theAnswer</code><code class="p">)</code><code class="p">;</code> <a class="co" href="#callout_functional_java_CO3-2" id="co_functional_java_CO3-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a>

  <code class="n">run</code><code class="p">(</code><code class="n">printAnswer</code><code class="p">)</code><code class="p">;</code> <a class="co" href="#callout_functional_java_CO3-3" id="co_functional_java_CO3-3"><img alt="3" height="12" src="assets/3.png" width="12"/></a>
<code class="p">}</code>

<code class="kt">void</code> <code class="nf">run</code><code class="p">(</code><code class="n">Runnable</code> <code class="n">r</code><code class="p">)</code> <code class="p">{</code>
  <code class="n">r</code><code class="p">.</code><code class="na">run</code><code class="p">(</code><code class="p">)</code><code class="p">;</code>
<code class="p">}</code>

<code class="n">capture</code><code class="p">(</code><code class="p">)</code><code class="p">;</code>
<code class="c1">// OUTPUT:</code>
<code class="c1">// the answer is 42</code></pre></div>
<dl class="calloutlist">
<dt><a class="co" href="#co_functional_java_CO3-1" id="callout_functional_java_CO3-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p>The variable <code>theAnswer</code> is declared in the scope of <code>capture()</code>.</p></dd>
<dt><a class="co" href="#co_functional_java_CO3-2" id="callout_functional_java_CO3-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a></dt>
<dd><p>The lambda <code>printAnswer</code> captures the variable in its body.</p></dd>
<dt><a class="co" href="#co_functional_java_CO3-3" id="callout_functional_java_CO3-3"><img alt="3" height="12" src="assets/3.png" width="12"/></a></dt>
<dd><p>The lambda can be run in another method and scope but still has access to <code>theAnswer</code>.</p></dd>
</dl>
<p>The big difference between <em>capture</em> and <em>non-capture</em> lambdas is the optimization strategies of the JVM.
The JVM optimizes lambdas with different strategies based on their actual usage pattern.
If no variables get captured, a lambda might end up being a simple <code>static</code> method behind the scenes, beating out the performance of alternative approaches like anonymous classes.
The implications of capturing variables on performance are not as clear-cut, though.</p>
<p>There are multiple ways the JVM might translate your code if it captures variables, leading to additional object allocation, affecting performance, and garbage collector times.
That doesn’t mean that capturing variables is inherently a bad design choice.
The main goal of a more functional approach should be improved productivity, more straightforward reasoning, and more concise code.
Still, you should avoid unnecessary capturing, especially if you require the least amount of allocations or the best performance possible.</p>
<p>Another reason to avoid capturing variables is their necessity of being <em>effectively</em> <code>final</code>.</p>
<section data-pdf-bookmark="Effectively final" data-type="sect3"><div class="sect3" id="_01-functions_lambdas_effectively-final">
<h3>Effectively final</h3>
<p>The JVM has to make special considerations to use captured variables safely and achieve the best performance possible.
That’s why there’s an essential requirement: only <em>effectively</em> <code>final</code> variables are allowed to be captured.</p>
<p>In simple terms, any captured variable must be an immutable reference that isn’t allowed to change after its initialization.
They <em>must</em> be <code>final</code>, either by explicitly using the <code>final</code> keyword or by <em>never</em> changing after their initialization, making them <em>effectively</em> <code>final</code>.</p>
<p>Be aware that this requirement is actually for the <em>reference</em> to a variable and <em>not</em> the underlying data structure itself.
A reference to a <code>List&lt;String&gt;</code> might be <code>final</code>, and therefore usable in a lambda, but you can still add new items, as seen in <a data-type="xref" href="#_01-functions-effecitvely-final_mutable">Example 2-4</a>.
Only reassigning the variable is prohibited.</p>
<div data-type="example" id="_01-functions-effecitvely-final_mutable">
<h5><span class="label">Example 2-4. </span>Change data behind a <code>final</code> variable</h5>
<pre data-code-language="java" data-type="programlisting"><code class="kd">final</code> <code class="n">List</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code> <code class="n">wordList</code> <code class="o">=</code> <code class="k">new</code> <code class="n">ArrayList</code><code class="o">&lt;</code><code class="o">&gt;</code><code class="p">(</code><code class="p">)</code><code class="p">;</code> <a class="co" href="#callout_functional_java_CO4-1" id="co_functional_java_CO4-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a>

<code class="c1">// COMPILES FINE</code>
<code class="n">Runnable</code> <code class="n">addItemInLambda</code> <code class="o">=</code> <code class="p">(</code><code class="p">)</code> <code class="o">-</code><code class="o">&gt;</code>
  <code class="n">wordList</code><code class="p">.</code><code class="na">add</code><code class="p">(</code><code class="s">"</code><code class="s">adding is fine</code><code class="s">"</code><code class="p">)</code><code class="p">;</code> <a class="co" href="#callout_functional_java_CO4-2" id="co_functional_java_CO4-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a>


<code class="c1">// WON'T COMPILE</code>
<code class="n">wordList</code> <code class="o">=</code> <code class="n">List</code><code class="p">.</code><code class="na">of</code><code class="p">(</code><code class="s">"</code><code class="s">assigning</code><code class="s">"</code><code class="p">,</code> <code class="s">"</code><code class="s">another</code><code class="s">"</code><code class="p">,</code> <code class="s">"</code><code class="s">List</code><code class="s">"</code><code class="p">,</code> <code class="s">"</code><code class="s">is</code><code class="s">"</code><code class="p">,</code> <code class="s">"</code><code class="s">not</code><code class="s">"</code><code class="p">)</code><code class="p">;</code> <a class="co" href="#callout_functional_java_CO4-3" id="co_functional_java_CO4-3"><img alt="3" height="12" src="assets/3.png" width="12"/></a></pre></div>
<dl class="calloutlist">
<dt><a class="co" href="#co_functional_java_CO4-1" id="callout_functional_java_CO4-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p>The variable <code>list</code> is explicitly <code>final</code>, making the reference immutable.</p></dd>
<dt><a class="co" href="#co_functional_java_CO4-2" id="callout_functional_java_CO4-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a></dt>
<dd><p>Capturing and using the variable in a lambda works without problems.
However, the <code>final keyword does not affect the +List</code> itself, allowing you to add additional items.</p></dd>
<dt><a class="co" href="#co_functional_java_CO4-3" id="callout_functional_java_CO4-3"><img alt="3" height="12" src="assets/3.png" width="12"/></a></dt>
<dd><p>Reassigning the variable is prohibited due to the <code>final</code> keyword and won’t compile.</p></dd>
</dl>
<p>The simplest way to test whether a variable is <em>effectively</em> <code>final</code> or not is by making it explicitly <code>final</code>.
If your code still compiles with the additional <code>final</code> keyword, it will compile without it.
So why not make every variable <code>final</code>?
Because the compiler ensures that “out-of-body” references are <em>effectively</em> <code>final</code>, the keyword won’t help with actual immutability anyways.
Making every variable <code>final</code> would only create more visual noise in your code without much benefit.
Adding a modifier like <code>final</code> should always be a conscious decision with intent.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>If you run any of the shown <em>effectively</em> <code>final</code>-related examples in <code>jshell</code>, they might not behave as expected.
That’s because <code>jshell</code> has special semantics regarding top-level expressions and declarations, which affects <code>final</code> or effectively <code>final</code> values at top-level<sup><a data-type="noteref" href="ch02.xhtml#idm45115252733520" id="idm45115252733520-marker">2</a></sup>.
Even though you can reassign any reference, making it non-effectively <code>final</code>, you can still use them in lambdas, as long as you’re not in the top-level scope.</p>
</div>
</div></section>
<section data-pdf-bookmark="Re-finalizing a Reference" data-type="sect3"><div class="sect3" id="_01-functions-refinalize">
<h3>Re-finalizing a Reference</h3>
<p>Sometimes a reference might not be <em>effectively</em> <code>final</code>, but you still need them to be available in a lambda.
If refactoring your code isn’t an option, there’s a simple trick to <em>re-finalize</em> them.
Remember, the requirement is just for the reference and not the underlying data structure itself.</p>
<p>You can create a new <em>effectively</em> <code>final</code> reference to the non-<em>effectively</em> <code>final</code> variable by simply referencing the original one and not changing it further, as shown in <a data-type="xref" href="#_01-functions-effecitvely-final_refinalize">Example 2-5</a>.</p>
<div data-type="example" id="_01-functions-effecitvely-final_refinalize">
<h5><span class="label">Example 2-5. </span>Re-finalize a variable</h5>
<pre data-code-language="java" data-type="programlisting"><code class="kd">var</code> <code class="n">nonEffectivelyFinal</code> <code class="o">=</code> <code class="mi">1_000L</code><code class="p">;</code> <a class="co" href="#callout_functional_java_CO5-1" id="co_functional_java_CO5-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a>
<code class="n">nonEffectivelyFinal</code> <code class="o">=</code> <code class="mi">9_000L</code><code class="p">;</code> <a class="co" href="#callout_functional_java_CO5-2" id="co_functional_java_CO5-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a>

<code class="kd">var</code> <code class="n">finalAgain</code> <code class="o">=</code> <code class="n">nonEffectivelyFinal</code><code class="p">;</code> <a class="co" href="#callout_functional_java_CO5-3" id="co_functional_java_CO5-3"><img alt="3" height="12" src="assets/3.png" width="12"/></a>

<code class="n">Predicate</code><code class="o">&lt;</code><code class="n">Long</code><code class="o">&gt;</code> <code class="n">isOver9000</code> <code class="o">=</code> <code class="n">input</code> <code class="o">-</code><code class="o">&gt;</code> <code class="n">input</code> <code class="o">&gt;</code> <code class="n">finalAgain</code><code class="p">;</code></pre></div>
<dl class="calloutlist">
<dt><a class="co" href="#co_functional_java_CO5-1" id="callout_functional_java_CO5-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p>At this point, <code>nonEffectivelyFinal</code> is still <em>effectively</em> <code>final</code>.</p></dd>
<dt><a class="co" href="#co_functional_java_CO5-2" id="callout_functional_java_CO5-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a></dt>
<dd><p>Changing the variable after its initialization makes it unusable in lambda.</p></dd>
<dt><a class="co" href="#co_functional_java_CO5-3" id="callout_functional_java_CO5-3"><img alt="3" height="12" src="assets/3.png" width="12"/></a></dt>
<dd><p>By creating a new variable and not changing it after its initialization, you “re-finalized” the reference to the underlying data structure.</p></dd>
</dl>
<p>Keep in mind that re-finalizing a reference is just a “band-aid”, and
needing a band-aid means you scraped your knees first.
So the best approach is trying not to need it at all.
Refactoring or redesigning your code should always be the preferred option instead of bending the code to your will with tricks like re-finalizing a reference.</p>
<p>Such safeguards for using variables in lambdas like the effectively <code>final</code> requirement might feel like an additional burden at first.
However, instead of capturing “out-of-body” variables, your lambdas should strive to be self-sufficient and require all necessary data as arguments.
That automatically leads to more reasonable code, increased reusability, and allows for easier refactoring and testing.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="What about Anonymous Classes?" data-type="sect2"><div class="sect2" id="_01-functions_java-lambda_lambdas-vs-anonymous-classes">
<h2>What about Anonymous Classes?</h2>
<p>After learning about lambdas and functional interfaces, you’re most likely reminded of their similarities to <em>anonymous inner classes</em>: the combined declaration and instantiation of types.
An interface or extended class can be implemented “on-the-fly” without needing a separate Java class, so what differs between a lambda expression and an anonymous class if they both have to implement a concrete interface?</p>
<p>On the surface, a functional interface implemented by an anonymous class looks quite similar to its lambda representation, except for the additional boilerplate, as seen in <a data-type="xref" href="#_01-functions_java-lambdas_anonymous-classes">Example 2-6</a>.</p>
<div data-type="example" id="_01-functions_java-lambdas_anonymous-classes">
<h5><span class="label">Example 2-6. </span>Anonymous class vs. lambda expression</h5>
<pre data-code-language="java" data-type="programlisting"><code class="c1">// FUNCTIONAL INTERFACE (implicit)</code>

<code class="kd">interface</code> <code class="nc">HelloWorld</code> <code class="p">{</code>
  <code class="n">String</code> <code class="nf">sayHello</code><code class="p">(</code><code class="n">String</code> <code class="n">name</code><code class="p">);</code>
<code class="p">}</code>


<code class="c1">// AS ANONYMOUS CLASS</code>

<code class="kd">var</code> <code class="n">helloWorld</code> <code class="o">=</code> <code class="k">new</code> <code class="n">HelloWorld</code><code class="p">()</code> <code class="p">{</code>

  <code class="nd">@Override</code>
  <code class="kd">public</code> <code class="n">String</code> <code class="nf">sayHello</code><code class="p">(</code><code class="n">String</code> <code class="n">name</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="s">"hello, "</code> <code class="o">+</code> <code class="n">name</code> <code class="o">+</code> <code class="s">"!"</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">};</code>

<code class="c1">// AS LAMBDA</code>

<code class="n">HelloWorld</code> <code class="n">helloWorldLambda</code> <code class="o">=</code> <code class="n">name</code> <code class="o">-&gt;</code> <code class="s">"hello, "</code> <code class="o">+</code> <code class="n">name</code> <code class="o">+</code> <code class="s">"!"</code><code class="p">;</code></pre></div>
<p>Does that mean that lambda expressions are just <em>syntactic sugar</em> for implementing a functional interface as an anonymous class then?</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="_01-functions-syntactic-sugar">
<h1>Syntactic Sugar</h1>
<p><em>Syntactic sugar</em> describes features that are additions to a language or to make your life as a developer “sweeter,” so certain constructs can be expressed more concisely or clearly, or in an alternative manner.</p>
<p>Peter J. Landin coined the term in 1964<sup><a data-type="noteref" href="ch02.xhtml#idm45115252515552" id="idm45115252515552-marker">3</a></sup>, describing how the keyword <code>where</code> replaced <math alttext="lamda">
<mi>λ</mi>
</math> in an ALGOL-like language.</p>
<p>Java’s <code>import</code> statement, for example, allows you to use types without their fully qualified names.
Another example is type inference with <code>var</code> for references or the diamond operator <code>&lt;&gt;</code> for generic types.
Both features simplify your code for “human consumption.”
The compiler will “desugar” the code and deal directly with its “bitterness.”</p>
</div></aside>
<p>Lambda expressions might look like syntactic sugar, but they’re so much more in reality.
The <em>real</em> difference — besides verbosity — lies in the generated bytecode, as seen in <a data-type="xref" href="#_01-functions_java-lambdas_syntax-lambda-as-anonymous_bytecode">Example 2-7</a>, and how the runtime handles it.</p>
<div data-type="example" id="_01-functions_java-lambdas_syntax-lambda-as-anonymous_bytecode">
<h5><span class="label">Example 2-7. </span>Bytecode differences between anonymous classes and lambdas</h5>
<pre data-type="programlisting">// ANONYMOUS CLASS

0: new #7 // class HelloWorldAnonymous$1 <a class="co" href="#callout_functional_java_CO6-1" id="co_functional_java_CO6-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a>
3: dup
4: invokespecial #9 // Method HelloWorldAnonymous$1."&lt;init&gt;":()V <a class="co" href="#callout_functional_java_CO6-2" id="co_functional_java_CO6-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a>
7: astore_1
8: return


// LAMBDA

0: invokedynamic #7, 0 // InvokeDynamic #0:sayHello:()LHelloWorld; <a class="co" href="#callout_functional_java_CO6-3" id="co_functional_java_CO6-3"><img alt="3" height="12" src="assets/3.png" width="12"/></a>
5: astore_1
6: return</pre></div>
<dl class="calloutlist">
<dt><a class="co" href="#co_functional_java_CO6-1" id="callout_functional_java_CO6-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p>A new object of the anonymous inner class <code>HelloWorldAnonymous$1</code> is created in the surrounding class <code>HelloWorldAnonymous</code>.</p></dd>
<dt><a class="co" href="#co_functional_java_CO6-2" id="callout_functional_java_CO6-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a></dt>
<dd><p>The constructor of the anonymous class is called.
Object creation is a two-step process in the JVM.</p></dd>
<dt><a class="co" href="#co_functional_java_CO6-3" id="callout_functional_java_CO6-3"><img alt="3" height="12" src="assets/3.png" width="12"/></a></dt>
<dd><p>The <code>invokedynamic</code> opcode hides the whole logic behind creating the lambda.</p></dd>
</dl>
<p>Both variants have the <code>astore_1</code> call in common, which stores a reference into a local variable, and the <code>return</code> call, so both won’t be part of analyzing the bytecode.</p>
<p>The anonymous class version creates a new object of the anonymous type <code>Anonymous$1</code>, resulting in three opcodes:</p>
<dl>
<dt><code>new</code></dt>
<dd>
<p>Create a new uninitialized instance of a type.</p>
</dd>
<dt><code>dup</code></dt>
<dd>
<p>Put the value on top of the stack by duplicating it.</p>
</dd>
<dt><code>invokespecial</code></dt>
<dd>
<p>Call the constructor method of the newly created object to finalize its initialization.</p>
</dd>
</dl>
<p>The lambda version, on the other hand, doesn’t need to create an instance that needs to be put on the stack.
Instead, it delegates the whole task of creating the lambda to the JVM with a single opcode: <code>invokedynamic</code>.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="_01-functional-java_invokedynamic">
<h1>The <code>invokedynamic</code> Instruction</h1>
<p>Java 7 introduced the new JVM opcode <code>invokedynamic</code>⁠<sup><a data-type="noteref" href="ch02.xhtml#idm45115252465520" id="idm45115252465520-marker">4</a></sup> to allow more flexible method invocation methods to support dynamic languages like <a href="https://groovy-lang.org">Groovy</a> or <a href="https://www.jruby.org">JRuby</a>.
The opcode is a more versatile invocation variant because its actual target, like a method call or lambda body, is unknown on class-loading.
Instead of linking such a target at compile-time, the JVM links a dynamic call site with the actual target method instead.</p>
<p>The runtime then uses a “bootstrap method”<sup><a data-type="noteref" href="ch02.xhtml#idm45115252462144" id="idm45115252462144-marker">5</a></sup> on the first <code>invokedynamic</code> call to determine what method should actually be called.</p>
<p>You can think of it like a recipe for lambda creation which utilizes reflection directly in the JVM.
This way, the JVM can optimize the creation task by using different strategies, like dynamic proxies, anonymous inner classes, or <code>java.lang.invoke.MethodHandle</code>.</p>
</div></aside>
<p>Another big difference between lambdas and anonymous inner classes is their respective scope.
An inner class creates its own scope, hiding its local variables from the enclosing one.
That’s why the keyword <code>this</code> references the instance of the inner class itself, not the surrounding scope.
Lambdas, on the other hand, live fully in their surrounding scope.
Variables can’t be re-declared with the same name, and <code>this</code> refers to the instance the lambda was created in, if not <code>static</code>.</p>
<p>As you can see, lambda expressions are <em>not</em> syntactic sugar at all.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="Lambdas In Action" data-type="sect1"><div class="sect1" id="_01-functional-java_lambdas-in-action">
<h1>Lambdas In Action</h1>
<p>As you saw in the previous section, lambdas are an extraordinary addition to Java to improve its functional programming abilities that’s much more than just syntactic sugar for previously available approaches.
Their first-class citizenship allows them to be statically typed, concise, and anonymous functions that are just like any other variable.
Although the arrow syntax might be new, the overall use pattern should feel familiar to any programmer.
In this section, we’ll jump right into actually using lambdas and seeing them in action.</p>
<section data-pdf-bookmark="Creating Lambdas" data-type="sect2"><div class="sect2" id="_01-functional-java_lambdas-in-action-creating">
<h2>Creating Lambdas</h2>
<p>To create a lambda expression, it needs to represent a singular functional interface.
The actual type might not be evident because a receiving method argument dictates the required type, or the compiler will infer it if possible.</p>
<p>Let’s take a look at <code>Predicate&lt;T&gt;</code> again to better illustrate that point.</p>
<p>Creating a new instance requires the type to be defined on the left-hand side:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">Predicate</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code> <code class="n">isNull</code> <code class="o">=</code> <code class="n">value</code> <code class="o">-&gt;</code> <code class="n">value</code> <code class="o">==</code> <code class="kc">null</code><code class="p">;</code></pre>
<p>Even if you use explicit types for the arguments, the functional interface type is still required:</p>
<pre data-code-language="java" data-type="programlisting"><code class="c1">// WON'T COMPILE</code>
<code class="kd">var</code> <code class="n">isNull</code> <code class="o">=</code> <code class="p">(</code><code class="n">String</code> <code class="n">value</code><code class="p">)</code> <code class="o">-&gt;</code> <code class="n">value</code> <code class="o">==</code> <code class="kc">null</code><code class="p">;</code></pre>
<p>The method signature of <code>Predicate&lt;String&gt;</code> SAM might be inferable:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kt">boolean</code> <code class="nf">test</code><code class="p">(</code><code class="n">String</code> <code class="n">input</code><code class="p">)</code></pre>
<p>Still, the Java compiler requires a concrete type for the reference, not just a method signature.
This requirement stems from Java’s propensity for backward compatibility, as I previously mentioned.
By using the pre-existing statically-typed system, lambdas fit perfectly into Java, granting lambdas the same compile-time safety as any other type or approach before them.</p>
<p>However, obeying the type system makes Java lambdas less dynamic than their counterparts in other languages.
Just because two lambdas share the same SAM signature doesn’t mean they are interchangeable.</p>
<p>Take the following functional interface for example:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">interface</code> <code class="nc">LikePredicate</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code> <code class="p">{</code>
  <code class="kt">boolean</code> <code class="nf">test</code><code class="p">(</code><code class="n">T</code> <code class="n">value</code><code class="p">);</code>
<code class="p">}</code></pre>
<p>Even though it’s SAM is identical to <code>Predicate&lt;T&gt;</code>, the types can’t be used interchangeably, as shown in the following code:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">LikePredicate</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code> <code class="n">isNull</code> <code class="o">=</code> <code class="n">value</code> <code class="o">-</code><code class="o">&gt;</code> <code class="n">value</code> <code class="o">=</code><code class="o">=</code> <code class="kc">null</code><code class="p">;</code> <a class="co" href="#callout_functional_java_CO7-1" id="co_functional_java_CO7-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a>

<code class="n">Predicate</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code> <code class="n">wontCompile</code> <code class="o">=</code> <code class="n">isNull</code><code class="p">;</code> <a class="co" href="#callout_functional_java_CO7-2" id="co_functional_java_CO7-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a>
<code class="c1">// Error:</code>
<code class="c1">// incompatible types: LikePredicate&lt;java.lang.String&gt; cannot be converted</code>
<code class="c1">// to java.util.function.Predicate&lt;java.lang.String&gt;</code></pre>
<dl class="calloutlist">
<dt><a class="co" href="#co_functional_java_CO7-1" id="callout_functional_java_CO7-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p>The lambda is created as before.</p></dd>
<dt><a class="co" href="#co_functional_java_CO7-2" id="callout_functional_java_CO7-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a></dt>
<dd><p>Trying to assign it to a functional interface with an identical SAM won’t compile.</p></dd>
</dl>
<p>Due to this incompatibility, you should try to rely on the available interfaces in the <code>java.util.function</code> package that will be discussed in <a data-type="xref" href="ch03.xhtml#_01-functional-jdk">Chapter 3</a> to maximize interoperability.
You’re still going to encounter pre-Java 8 interfaces like <code>java.util.concurrent.Callable&lt;V&gt;</code> that are identical to a Java 8+ one, in this case, <code>java.util.function.Supplier&lt;T&gt;</code>, though.
If that happens, there’s a neat shortcut for switching a lambda to another identical type.
You’ll learn about this in <a data-type="xref" href="ch03.xhtml#_01-functional-jdk_bridging-functional-interfaces">“Bridging Functional Interfaces”</a>.</p>
<p>Ad-hoc created lambdas as method arguments and return types don’t suffer from any type incompatibility, as demonstrated by the following:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">List</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code> <code class="nf">filter1</code><code class="p">(</code><code class="n">List</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code> <code class="n">values</code><code class="p">,</code>
                     <code class="n">Predicate</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code> <code class="n">predicate</code><code class="p">)</code> <code class="p">{</code>
  <code class="c1">// ...</code>
<code class="p">}</code>

<code class="n">List</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code> <code class="nf">filter2</code><code class="p">(</code><code class="n">List</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code> <code class="n">values</code><code class="p">,</code>
                     <code class="n">LikePredicate</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code> <code class="n">predicate</code><code class="p">)</code> <code class="p">{</code>
  <code class="c1">// ...</code>
<code class="p">}</code>

<code class="kd">var</code> <code class="n">values</code> <code class="o">=</code> <code class="n">Arrays</code><code class="p">.</code><code class="na">asList</code><code class="p">(</code><code class="s">"a"</code><code class="p">,</code> <code class="kc">null</code><code class="p">,</code> <code class="s">"c"</code><code class="p">);</code>

<code class="kd">var</code> <code class="n">result1</code> <code class="o">=</code> <code class="n">filter1</code><code class="p">(</code><code class="n">values</code><code class="p">,</code>
                      <code class="n">value</code> <code class="o">-&gt;</code> <code class="n">value</code> <code class="o">!=</code> <code class="kc">null</code><code class="p">);</code>

<code class="kd">var</code> <code class="n">result2</code> <code class="o">=</code> <code class="n">filter2</code><code class="p">(</code><code class="n">values</code><code class="p">,</code>
                      <code class="n">value</code> <code class="o">-&gt;</code> <code class="n">value</code> <code class="o">!=</code> <code class="kc">null</code><code class="p">);</code></pre>
<p>The compiler infers the type of ad-hoc lambdas directly from the method signature, so you can concentrate on <em>what</em> you want to achieve with the lambda.
The same is true for return types:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">Predicate</code><code class="o">&lt;</code><code class="n">Integer</code><code class="o">&gt;</code> <code class="nf">isGreaterThan</code><code class="p">(</code><code class="kt">int</code> <code class="n">value</code><code class="p">)</code> <code class="p">{</code>
  <code class="k">return</code> <code class="n">compareValue</code> <code class="o">-&gt;</code> <code class="n">compareValue</code> <code class="o">&gt;</code> <code class="n">value</code><code class="p">;</code>
<code class="p">}</code></pre>
<p>Now that you know how to create lambdas, you then need to call them.</p>
</div></section>
<section data-pdf-bookmark="Calling Lambdas" data-type="sect2"><div class="sect2" id="idm45115251999824">
<h2>Calling Lambdas</h2>
<p>As discussed, lambdas are effectively concrete implementations of their respective functional interfaces.
Other, more functionally inclined languages are usually treating lambdas more dynamically.
That’s why Java’s usage patterns can differ from such languages.</p>
<p>In JavaScript, for example, you can call a lambda and pass an argument directly, as shown in the following code:</p>
<pre data-code-language="javascript" data-type="programlisting"><code class="kd">let</code> <code class="nx">helloWorldJs</code> <code class="o">=</code> <code class="nx">name</code> <code class="o">=&gt;</code> <code class="sb">`hello, </code><code class="si">${</code><code class="nx">name</code><code class="si">}</code><code class="sb">!`</code>

<code class="kd">let</code> <code class="nx">resultJs</code> <code class="o">=</code> <code class="nx">helloWorldJs</code><code class="p">(</code><code class="s1">'Ben'</code><code class="p">)</code></pre>
<p>In Java, however, lambdas behave like any other instances of an interface, so you need to explicitly call its SAM, as demonstrated as follows:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">Function</code><code class="o">&lt;</code><code class="n">String</code><code class="p">,</code> <code class="n">String</code><code class="o">&gt;</code> <code class="n">helloWorld</code> <code class="o">=</code> <code class="n">name</code> <code class="o">-</code><code class="o">&gt;</code> <code class="s">"</code><code class="s">hello, </code><code class="s">"</code> <code class="o">+</code> <code class="n">name</code> <code class="o">+</code> <code class="s">"</code><code class="s">!</code><code class="s">"</code><code class="p">;</code>

<code class="kd">var</code> <code class="n">result</code> <code class="o">=</code> <code class="n">helloWorld</code><code class="p">.</code><code class="na">apply</code><code class="p">(</code><code class="s">"</code><code class="s">Ben</code><code class="s">"</code><code class="p">)</code><code class="p">;</code> <a class="co" href="#callout_functional_java_CO8-2" id="co_functional_java_CO8-1"><img alt="2" height="12" src="assets/2.png" width="12"/></a></pre>
<p>Calling the <em>single abstract method</em> might not be as concise as in other languages, but the benefit is Java’s continued backward compatibility.</p>
</div></section>
<section data-pdf-bookmark="Method References" data-type="sect2"><div class="sect2" id="_01-functional_method-references">
<h2>Method References</h2>
<p>Besides lambdas, Java 8 introduced another new feature with a language syntax change as a new way to create lambda expressions: <em>method references</em>.
It’s shorthand syntactic sugar, using the new <code>::</code> (double-colon) operator to reference an existing method in place of creating a lambda expression from an existing method, and therefore streamlining your functional code.</p>
<p><a data-type="xref" href="#_01-functions-method-references_stream">Example 2-8</a> shows how a Stream pipeline’s readability is improved by converting the lambdas to method references.
Don’t worry about the details!
You will learn about Streams in <a data-type="xref" href="ch06.xhtml#_02-data-processing">Chapter 6</a>, just think of it as a fluent call with lambda accepting methods.</p>
<div data-type="example" id="_01-functions-method-references_stream">
<h5><span class="label">Example 2-8. </span>Method references and Streams</h5>
<pre data-code-language="java" data-type="programlisting"><code class="n">List</code><code class="o">&lt;</code><code class="n">Customer</code><code class="o">&gt;</code> <code class="n">customers</code> <code class="o">=</code> <code class="p">...;</code>

<code class="c1">// LAMBDAS</code>

<code class="n">customers</code><code class="p">.</code><code class="na">stream</code><code class="p">()</code>
         <code class="p">.</code><code class="na">filter</code><code class="p">(</code><code class="n">customer</code> <code class="o">-&gt;</code> <code class="n">customer</code><code class="p">.</code><code class="na">isActive</code><code class="p">())</code>
         <code class="p">.</code><code class="na">map</code><code class="p">(</code><code class="n">customer</code> <code class="o">-&gt;</code> <code class="n">customer</code><code class="p">.</code><code class="na">getName</code><code class="p">())</code>
         <code class="p">.</code><code class="na">map</code><code class="p">(</code><code class="n">name</code> <code class="o">-&gt;</code> <code class="n">name</code><code class="p">.</code><code class="na">toUpperCase</code><code class="p">())</code>
         <code class="p">.</code><code class="na">peek</code><code class="p">(</code><code class="n">name</code> <code class="o">-&gt;</code> <code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="n">name</code><code class="p">))</code>
         <code class="p">.</code><code class="na">toArray</code><code class="p">(</code><code class="n">count</code> <code class="o">-&gt;</code> <code class="k">new</code> <code class="n">String</code><code class="o">[</code><code class="n">count</code><code class="o">]</code><code class="p">);</code>

<code class="c1">// METHOD-REFERENCES</code>

<code class="n">customers</code><code class="p">.</code><code class="na">stream</code><code class="p">()</code>
         <code class="p">.</code><code class="na">filter</code><code class="p">(</code><code class="n">Customer</code><code class="p">::</code><code class="n">isActive</code><code class="p">)</code>
         <code class="p">.</code><code class="na">map</code><code class="p">(</code><code class="n">Customer</code><code class="p">::</code><code class="n">getName</code><code class="p">)</code>
         <code class="p">.</code><code class="na">map</code><code class="p">(</code><code class="n">String</code><code class="p">::</code><code class="n">toUpperCase</code><code class="p">)</code>
         <code class="p">.</code><code class="na">peek</code><code class="p">(</code><code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">::</code><code class="n">println</code><code class="p">)</code>
         <code class="p">.</code><code class="na">toArray</code><code class="p">(</code><code class="n">String</code><code class="o">[]</code><code class="p">::</code><code class="k">new</code><code class="p">);</code></pre></div>
<p>Replacing lambdas with method references removes a lot of <em>noise</em> without compromising the readability or understandability of your code too much.
There is no need for the input arguments to have actual names or types, or to call the reference method explicitly.
Also, modern IDEs usually provide you with automatic refactoring to convert lambdas to method references, if applicable.</p>
<p>There are four types of method references you can use, depending on the lambda expression you want to replace and what kind of method you need to reference:</p>
<ul>
<li>
<p>Static method references</p>
</li>
<li>
<p>Bound non-<code>static</code> method references</p>
</li>
<li>
<p>Unbound non-<code>static</code> method references</p>
</li>
<li>
<p>Constructor references</p>
</li>
</ul>
<p>Let’s take a look at the different kinds and how and when to use them.</p>
<section data-pdf-bookmark="Static Method References" data-type="sect3"><div class="sect3" id="idm45115251641760">
<h3>Static Method References</h3>
<p>A <em>static method reference</em> refers to a <code>static</code> method of a specific type, like the <code>toHexString</code> method available on <code>Integer</code>:</p>
<pre data-code-language="java" data-type="programlisting"><code class="c1">// EXCERPT FROM java.lang.Integer</code>
<code class="kd">public</code> <code class="kd">class</code> <code class="nc">Integer</code> <code class="kd">extends</code> <code class="n">Number</code> <code class="p">{</code>

  <code class="kd">public</code> <code class="kd">static</code> <code class="n">String</code> <code class="nf">toHexString</code><code class="p">(</code><code class="kt">int</code> <code class="n">i</code><code class="p">)</code> <code class="p">{</code>
    <code class="c1">// ..</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="c1">// LAMBDA</code>
<code class="n">Function</code><code class="o">&lt;</code><code class="n">Integer</code><code class="p">,</code> <code class="n">String</code><code class="o">&gt;</code> <code class="n">asLambda</code> <code class="o">=</code> <code class="n">i</code> <code class="o">-&gt;</code> <code class="n">Integer</code><code class="p">.</code><code class="na">toHexString</code><code class="p">(</code><code class="n">i</code><code class="p">);</code>

<code class="c1">// STATIC METHOD REFERENCE</code>
<code class="n">Function</code><code class="o">&lt;</code><code class="n">Integer</code><code class="p">,</code> <code class="n">String</code><code class="o">&gt;</code> <code class="n">asRef</code> <code class="o">=</code> <code class="n">Integer</code><code class="p">::</code><code class="n">toHexString</code><code class="p">;</code></pre>
<p>The general syntax for static method references is <code>ClassName::staticMethodName</code>.</p>
</div></section>
<section data-pdf-bookmark="Bound non-static Method References" data-type="sect3"><div class="sect3" id="idm45115251587152">
<h3>Bound non-static Method References</h3>
<p>If you want to refer to a non-<code>static</code> method of an already existing object, you need a <em>bound non-static method reference</em>.
The lambda arguments are passed as the method arguments to the reference method of that specific object:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">var</code> <code class="n">now</code> <code class="o">=</code> <code class="n">LocalDate</code><code class="p">.</code><code class="na">now</code><code class="p">();</code>

<code class="c1">// LAMBDA BASED ON EXISTING OBJECT</code>
<code class="n">Predicate</code><code class="o">&lt;</code><code class="n">LocalDate</code><code class="o">&gt;</code> <code class="n">isAfterNowAsLambda</code> <code class="o">=</code> <code class="n">date</code> <code class="o">-&gt;</code> <code class="n">$</code><code class="p">.</code><code class="na">isAfter</code><code class="p">(</code><code class="n">now</code><code class="p">);</code>

<code class="c1">// BOUND NON-STATIC METHOD REFERENCE</code>
<code class="n">Predicate</code><code class="o">&lt;</code><code class="n">LocalDate</code><code class="o">&gt;</code> <code class="n">isAfterNowAsRef</code> <code class="o">=</code> <code class="n">now</code><code class="p">::</code><code class="n">isAfter</code><code class="p">;</code></pre>
<p>You don’t even need an intermediate variable; you can combine the return value of another method call or field access directly with <code>::</code> operator:</p>
<pre data-code-language="java" data-type="programlisting"><code class="c1">// BIND RETURN VALUE</code>
<code class="n">Predicate</code><code class="o">&lt;</code><code class="n">LocalDate</code><code class="o">&gt;</code> <code class="n">isAfterNowAsRef</code> <code class="o">=</code> <code class="n">LocalDate</code><code class="p">.</code><code class="na">now</code><code class="p">()::</code><code class="n">isAfter</code><code class="p">;</code>

<code class="c1">// BIND STATIC FIELD</code>
<code class="n">Function</code><code class="o">&lt;</code><code class="n">Object</code><code class="p">,</code> <code class="n">String</code><code class="o">&gt;</code> <code class="n">castToStr</code> <code class="o">=</code> <code class="n">String</code><code class="p">.</code><code class="na">class</code><code class="p">::</code><code class="n">cast</code><code class="p">;</code></pre>
<p>You can also reference methods from the current instance with <code>this::</code> or the <code>super</code> implementation with <code>super::</code>, as shown as follows:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">class</code> <code class="nc">SuperClass</code> <code class="p">{</code>

  <code class="kd">public</code> <code class="n">String</code> <code class="nf">doWork</code><code class="p">(</code><code class="n">String</code> <code class="n">input</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="s">"super: "</code> <code class="o">+</code> <code class="n">input</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="kd">public</code> <code class="kd">class</code> <code class="nc">SubClass</code> <code class="kd">extends</code> <code class="n">SuperClass</code> <code class="p">{</code>

  <code class="nd">@Override</code>
  <code class="kd">public</code> <code class="n">String</code> <code class="nf">doWork</code><code class="p">(</code><code class="n">String</code> <code class="n">input</code><code class="p">){</code>
    <code class="k">return</code> <code class="s">"this: "</code> <code class="o">+</code> <code class="n">input</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="kd">public</code> <code class="kt">void</code> <code class="nf">superAndThis</code><code class="p">(</code><code class="n">String</code> <code class="n">input</code><code class="p">)</code> <code class="p">{</code>

    <code class="n">Function</code><code class="o">&lt;</code><code class="n">String</code><code class="p">,</code> <code class="n">String</code><code class="o">&gt;</code> <code class="n">thisWorker</code> <code class="o">=</code> <code class="k">this</code><code class="p">::</code><code class="n">doWork</code><code class="p">;</code>
    <code class="kd">var</code> <code class="n">thisResult</code> <code class="o">=</code> <code class="n">thisWorker</code><code class="p">.</code><code class="na">apply</code><code class="p">(</code><code class="n">input</code><code class="p">);</code>
    <code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="n">thisResult</code><code class="p">);</code>

    <code class="n">Function</code><code class="o">&lt;</code><code class="n">String</code><code class="p">,</code> <code class="n">String</code><code class="o">&gt;</code> <code class="n">superWorker</code> <code class="o">=</code> <code class="n">SubClass</code><code class="p">.</code><code class="na">super</code><code class="p">::</code><code class="n">doWork</code><code class="p">;</code>
    <code class="kd">var</code> <code class="n">superResult</code> <code class="o">=</code> <code class="n">superWorker</code><code class="p">.</code><code class="na">apply</code><code class="p">(</code><code class="n">input</code><code class="p">);</code>
    <code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="n">superResult</code><code class="p">);</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="k">new</code> <code class="n">SubClass</code><code class="p">().</code><code class="na">superAndThis</code><code class="p">(</code><code class="s">"hello, World!"</code><code class="p">);</code>
<code class="c1">// OUTPUT:</code>
<code class="c1">// this: hello, World!</code>
<code class="c1">// super: hello, World!</code></pre>
<p>Bound method references are a great way to use already existing methods on variables, the current instance, or <code>super</code>.
It also allows you to refactor non-trivial or more complex lambdas to methods and use method references instead.
Especially fluent pipelines, like Streams in <a data-type="xref" href="ch06.xhtml#_02-data-processing">Chapter 6</a> or Optionals in <a data-type="xref" href="ch09.xhtml#_02-optionals">Chapter 9</a>, profit immensely from the improved readability of short method references.</p>
<p>The general syntax for bound non-static method references is <span class="keep-together"><code>objectName::instanceMethodName</code></span>.</p>
</div></section>
<section data-pdf-bookmark="Unbound non-static Method References" data-type="sect3"><div class="sect3" id="idm45115251157984">
<h3>Unbound non-static Method References</h3>
<p><em>Unbound non-static method references</em> are, as their name suggests, not bound to a specific object.
Instead, they refer to an instance method of a type:</p>
<pre data-code-language="java" data-type="programlisting"><code class="c1">// EXCERPT FROM java.lang.String</code>
<code class="kd">public</code> <code class="kd">class</code> <code class="nc">String</code> <code class="kd">implements</code> <code class="p">...</code> <code class="p">{</code>

  <code class="kd">public</code> <code class="n">String</code> <code class="nf">toLowerCase</code><code class="p">()</code> <code class="p">{</code>
    <code class="c1">// ...</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="c1">// LAMBDA</code>
<code class="n">Function</code><code class="o">&lt;</code><code class="n">String</code><code class="p">,</code> <code class="n">String</code><code class="o">&gt;</code> <code class="n">toLowerCaseLambda</code> <code class="o">=</code> <code class="n">str</code> <code class="o">-&gt;</code> <code class="n">str</code><code class="p">.</code><code class="na">toLowerCase</code><code class="p">();</code>

<code class="c1">// UNBOUND NON-STATIC METHOD REFERENCE</code>
<code class="n">Function</code><code class="o">&lt;</code><code class="n">String</code><code class="p">,</code> <code class="n">String</code><code class="o">&gt;</code> <code class="n">toLowerCaseRef</code> <code class="o">=</code> <code class="n">String</code><code class="p">::</code><code class="n">toLowerCase</code><code class="p">;</code></pre>
<p>The general syntax for unbound non-static method references is <span class="keep-together"><code>ClassName::instanceMethodName</code></span>.</p>
<p>This type of method reference can be confused with a <em>static method reference</em>.
For <em>Unbound non-static method references</em>, however, the <code>ClassName</code> signifies the instance type in which the referenced instance method is defined.
It’s also the first argument of the lambda expression.
This way, the reference method is called on the incoming instance and not on an explicitly referenced instance of that type.</p>
</div></section>
<section data-pdf-bookmark="Constructor References" data-type="sect3"><div class="sect3" id="idm45115251036448">
<h3>Constructor References</h3>
<p>The last type of method reference refers to a type’s constructor.
A constructor method reference looks like the following:</p>
<pre data-code-language="java" data-type="programlisting"><code class="c1">// LAMBDA</code>
<code class="n">Function</code><code class="o">&lt;</code><code class="n">String</code><code class="p">,</code> <code class="n">Locale</code><code class="o">&gt;</code> <code class="n">newLocaleLambda</code> <code class="o">=</code> <code class="n">language</code> <code class="o">-&gt;</code> <code class="k">new</code> <code class="n">Locale</code><code class="p">(</code><code class="n">language</code><code class="p">);</code>

<code class="c1">// CONSTRUCTOR REFERENCE</code>
<code class="n">Function</code><code class="o">&lt;</code><code class="n">String</code><code class="p">,</code> <code class="n">Locale</code><code class="o">&gt;</code> <code class="n">newLocaleLambda</code> <code class="o">=</code> <code class="n">Locale</code><code class="p">::</code><code class="k">new</code><code class="p">;</code></pre>
<p>At first glance, constructor method references look like static or unbound non-static method references.
The referenced method isn’t an actual method but a reference to a constructor via the <code>new</code> keyword.</p>
<p>The general syntax for constructor method references is <code>ClassName::new</code>.</p>
</div></section>
</div></section>
</div></section>
<section data-pdf-bookmark="Functional Programming Concepts in Java" data-type="sect1"><div class="sect1" id="idm45115251855136">
<h1>Functional Programming Concepts in Java</h1>
<p><a data-type="xref" href="ch01.xhtml#_01-an-introduction">Chapter 1</a> tackled the core concepts that make a programming language functional from a mostly theoretical viewpoint.
So let’s take another look at them from a Java developer’s point of view.</p>
<section data-pdf-bookmark="Pure Functions and Referential Transparency" data-type="sect2"><div class="sect2" id="_01-functions_pure-and-ref-trans">
<h2>Pure Functions and Referential Transparency</h2>
<p>The concept of pure functions is based on two guarantees that aren’t necessarily bound to functional programming:</p>
<ul>
<li>
<p>Function logic is self-contained without any kind of side effect.</p>
</li>
<li>
<p>The <em>same</em> input will <em>always</em> create the same output.
Therefore, repeated calls can be replaced by the initial result, making the call referentially transparent.</p>
</li>
</ul>
<p>These two principles make sense even in your imperative code.
Making your code self-contained makes it predictable and more straightforward.
From a Java perspective, how can you achieve these beneficial properties?</p>
<p>First, check for uncertainty.
Is there non-predictive logic that doesn’t depend on the input arguments?
Prime examples are random number generators or the current date.
Using such data in a function removes a function’s predictability, making it <em>impure</em>.</p>
<p>Next, look for side effects and mutable state.</p>
<ul>
<li>
<p>Does your function affect any state outside of the function itself, like an instance or global variable?</p>
</li>
<li>
<p>Does it change the inner data of its arguments, like adding new elements to a collection or changing an object property?</p>
</li>
<li>
<p>Does it do any other <em>impure</em> work, like I/O?</p>
</li>
</ul>
<p>However, side effects aren’t restricted to mutable state.
A simple <code>System.out.println(…​)</code> call is a side-effect, even if it might look harmless.
Any kind of I/O, like accessing the file system, making network requests, or printing to <code>System.out</code> is a side-effect.
The reasoning is simple: repeated calls with the same arguments can’t be replaced with the result of the first evaluation.
A good indicator for an <em>impure</em> method is a <code>void</code> return type.
If a method doesn’t return anything, all it does are side effects, or it does nothing at all.</p>
<p>Pure functions are inherently <em>referentially transparent</em>.
Hence, you can replace any subsequent calls with the same arguments with the previously calculated result.
This interchangeability allows for an optimization technique called <em>memoization</em>.
Originating from the Latin word “memorandum" — <em>to be remembered</em> --⁠, this technique describes “remembering” previously evaluated expressions.
It trades memory <em>space</em> for saving computational <em>time</em>.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45115250891440">
<h1>Space-time trade-off</h1>
<p>Algorithms depend on two significant factors: <em>space</em> (e.g., memory) and <em>time</em> (e.g., computational or response time).
Both might be available in vast quantities these days, but they are still finite.</p>
<p>The <em>space-time trade-off</em> states that you can decrease one of the factors by increasing the other.
If you want to save time, you need more memory for storing results.
Or you can save permanently needed memory by constantly recalculating them.</p>
</div></aside>
<p>You’re most likely already using the general idea behind referential transparency in your code in the form of <em>caching</em>.
From dedicated cache libraries, like Ehcache<sup><a data-type="noteref" href="ch02.xhtml#idm45115250887264" id="idm45115250887264-marker">6</a></sup> to simple <code>HashMap</code>-based lookup tables, it’s all about “remembering” a value against a set of input arguments.</p>
<p>The Java compiler doesn’t support automatic memoization of lambda expressions or methods calls.
Some frameworks provide annotations, like <code>@Cacheable</code> in Spring<sup><a data-type="noteref" href="ch02.xhtml#idm45115250884688" id="idm45115250884688-marker">7</a></sup> or <code>@Cached</code> in Apache Tapestry<sup><a data-type="noteref" href="ch02.xhtml#idm45115250882416" id="idm45115250882416-marker">8</a></sup>, and generate the required code automatically behind the scenes.</p>
<p>Creating your own lambda expression caching isn’t too hard either, thanks to some of the newer additions to Java 8+.
So let’s do that right now.</p>
<p>Building your own <em>memoization</em> by creating an “on-demand” lookup table requires the answer to two questions:</p>
<ul>
<li>
<p>How do you identify the function and its input arguments uniquely?</p>
</li>
<li>
<p>How can you store the evaluated result?</p>
</li>
</ul>
<p>If your function or method call has only a single argument with a constant <code>hashCode</code> or other deterministic value, you can create a simple <code>Map</code>-based lookup table.
For multi-argument calls, you must first define how to create a lookup key.</p>
<p>Java 8 introduced multiple functional additions to the <code>Map&lt;K, V&gt;</code> type.
One of these additions, the <code>computeIfAbsent</code> method, is a great aid to easily implement memoization, as shown in <a data-type="xref" href="#_01-functions_memoization_computeIfAbsent">Example 2-9</a>.</p>
<div data-type="example" id="_01-functions_memoization_computeIfAbsent">
<h5><span class="label">Example 2-9. </span>Memoization with <code>Map#computeIfAbsent</code></h5>
<pre data-code-language="java" data-type="programlisting"><code class="n">Map</code><code class="o">&lt;</code><code class="n">String</code><code class="p">,</code> <code class="n">Object</code><code class="o">&gt;</code> <code class="n">cache</code> <code class="o">=</code> <code class="k">new</code> <code class="n">HashMap</code><code class="o">&lt;</code><code class="o">&gt;</code><code class="p">(</code><code class="p">)</code><code class="p">;</code> <a class="co" href="#callout_functional_java_CO8-1" id="co_functional_java_CO8-2"><img alt="1" height="12" src="assets/1.png" width="12"/></a>

<code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code> <code class="n">T</code> <code class="nf">memoize</code><code class="p">(</code><code class="n">String</code> <code class="n">identifier</code><code class="p">,</code> <code class="n">Supplier</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code> <code class="n">fn</code><code class="p">)</code> <code class="p">{</code> <a class="co" href="#callout_functional_java_CO8-2" id="co_functional_java_CO8-3"><img alt="2" height="12" src="assets/2.png" width="12"/></a>
  <code class="k">return</code> <code class="p">(</code><code class="n">T</code><code class="p">)</code> <code class="n">cache</code><code class="p">.</code><code class="na">computeIfAbschent</code><code class="p">(</code><code class="n">identifier</code><code class="p">,</code>
                                   <code class="n">key</code> <code class="o">-</code><code class="o">&gt;</code> <code class="n">fn</code><code class="p">.</code><code class="na">get</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code class="p">;</code>
<code class="p">}</code>

<code class="n">Integer</code> <code class="nf">expensiveCall</code><code class="p">(</code><code class="n">String</code> <code class="n">arg0</code><code class="p">,</code> <code class="kt">int</code> <code class="n">arg1</code><code class="p">)</code> <code class="p">{</code> <a class="co" href="#callout_functional_java_CO8-3" id="co_functional_java_CO8-4"><img alt="3" height="12" src="assets/3.png" width="12"/></a>
    <code class="c1">// ...</code>
<code class="p">}</code>

<code class="n">Integer</code> <code class="nf">memoizedCall</code><code class="p">(</code><code class="n">String</code> <code class="n">arg0</code><code class="p">,</code> <code class="kt">int</code> <code class="n">arg1</code><code class="p">)</code> <code class="p">{</code> <a class="co" href="#callout_functional_java_CO8-4" id="co_functional_java_CO8-5"><img alt="4" height="12" src="assets/4.png" width="12"/></a>
  <code class="kd">var</code> <code class="n">compoundKey</code> <code class="o">=</code> <code class="n">String</code><code class="p">.</code><code class="na">format</code><code class="p">(</code><code class="s">"</code><code class="s">expensiveCall:%s-%d</code><code class="s">"</code><code class="p">,</code> <code class="n">arg0</code><code class="p">,</code> <code class="n">arg1</code><code class="p">)</code><code class="p">;</code>

  <code class="k">return</code> <code class="n">memoize</code><code class="p">(</code><code class="n">compoundKey</code><code class="p">,</code>
                 <code class="p">(</code><code class="p">)</code> <code class="o">-</code><code class="o">&gt;</code> <code class="n">expensiveCall</code><code class="p">(</code><code class="n">arg0</code><code class="p">,</code> <code class="n">arg1</code><code class="p">)</code><code class="p">)</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">var</code> <code class="n">calculated</code> <code class="o">=</code> <code class="n">memoizedCall</code><code class="p">(</code><code class="s">"</code><code class="s">hello, world!</code><code class="s">"</code><code class="p">,</code> <code class="mi">42</code><code class="p">)</code><code class="p">;</code> <a class="co" href="#callout_functional_java_CO8-5" id="co_functional_java_CO8-6"><img alt="5" height="12" src="assets/5.png" width="12"/></a>

<code class="kd">var</code> <code class="n">cached</code> <code class="o">=</code> <code class="n">memoizedCall</code><code class="p">(</code><code class="s">"</code><code class="s">hello, world!</code><code class="s">"</code><code class="p">,</code> <code class="mi">42</code><code class="p">)</code><code class="p">;</code> <a class="co" href="#callout_functional_java_CO8-6" id="co_functional_java_CO8-7"><img alt="6" height="12" src="assets/6.png" width="12"/></a></pre></div>
<dl class="calloutlist">
<dt><a class="co" href="#co_functional_java_CO8-2" id="callout_functional_java_CO8-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p>The results are cached in a simple <code>HashMap&lt;String, Object&gt;</code> so it can cache any kind of call based on an identifier.
Depending on your requirements, there might be special considerations, like caching results per request in a web application or requiring a “time-to-live” concept.
This example is supposed to show the simplest form of a lookup table.</p></dd>
<dt><a class="co" href="#co_functional_java_CO8-1" id="callout_functional_java_CO8-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a></dt>
<dd><p>The <code>memoize</code> method accepts an identifier and a <code>Supplier&lt;T&gt;</code> in case the cache doesn’t have a result yet.</p></dd>
<dt><a class="co" href="#co_functional_java_CO8-4" id="callout_functional_java_CO8-3"><img alt="3" height="12" src="assets/3.png" width="12"/></a></dt>
<dd><p>The <code>expensiveCall</code> is the method that gets memoized.</p></dd>
<dt><a class="co" href="#co_functional_java_CO8-5" id="callout_functional_java_CO8-4"><img alt="4" height="12" src="assets/4.png" width="12"/></a></dt>
<dd><p>For convenience, a specialized memoized call method exists, so you don’t have to build an identifier manually each time you call <code>memoize</code>.
It has the same arguments as the calculation method and delegates the actual memoization process.</p></dd>
<dt><a class="co" href="#co_functional_java_CO8-6" id="callout_functional_java_CO8-5"><img alt="5" height="12" src="assets/5.png" width="12"/></a></dt>
<dd><p>The convenience method allows you to replace the method name of the call to use the memoized version instead of the original one.</p></dd>
<dt><a class="co" href="#co_functional_java_CO8-7" id="callout_functional_java_CO8-6"><img alt="6" height="12" src="assets/6.png" width="12"/></a></dt>
<dd><p>The second call returns the cached result immediately without any additional evaluation.</p></dd>
</dl>
<p>This implementation is quite simplistic and is not a one-size-fits-all solution.
Still, it confers the general concept of storing a call result via an intermediate method doing the actual memoization.</p>
<p>The functional additions to <code>Map&lt;K, V&gt;</code> don’t stop there.
It provides the tools to create associations “on the fly,” and more tools giving you more fine-grained control if a value is already present or not.
You will learn more about it in <a data-type="xref" href="ch11.xhtml#_02-lazy-evaluation">Chapter 11</a>.</p>
</div></section>
<section data-pdf-bookmark="Immutability" data-type="sect2"><div class="sect2" id="idm45115250906256">
<h2>Immutability</h2>
<p>The classical approach to Java with OOP is based on mutable program state, most prominently represented by JavaBeans and POJOs.
There’s no clear definition of how program state should be handled in OOP, and immutability is no pre-requisite or unique feature of FP.
Still, mutable state is a thorn in the side of many functional programming concepts because they expect <em>immutable</em> data structures to ensure data integrity and safe overall use.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>POJOs are “plain old Java Objects” that aren’t bound by special restrictions, other than those imposed by the Java language.
JavaBeans are a special type of POJOs.
You will learn more about them in <a data-type="xref" href="ch04.xhtml#_02-data-sructures_mutability">“Mutability and Data Structures in OOP”</a>.</p>
</div>
<p>Java’s support for immutability is quite limited compared to other languages.
That’s why it has to enforce constructs like <em>effectively</em> <code>final</code> as discussed in <a data-type="xref" href="#_01-introduction_pure-lambas-effectively-final">“Lambdas and Outside Variables”</a>.
To support “full” immutability, you need to design your data structures from the ground up as immutable, which can be cumbersome and error-prone.
Third-party libraries are an often chosen approach to minimize the required boilerplate code and rely on battle-tested implementations.
Finally, with Java 14+, immutable data classes — <em>Records</em> — were introduced to bridge the gap, which I will discuss in <a data-type="xref" href="ch05.xhtml#_02-records">Chapter 5</a>.</p>
<p>Immutability is a complex subject that you’ll learn more about and its importance and how to utilize it properly — either with built-in tools or with a do-it-yourself approach — in <a data-type="xref" href="ch04.xhtml#_02-data-structures">Chapter 4</a>.</p>
</div></section>
<section data-pdf-bookmark="First-Class and Higher-Order" data-type="sect2"><div class="sect2" id="idm45115250582704">
<h2>First-Class and Higher-Order</h2>
<p>With Java <em>lambas</em> being concrete implementations of functional interfaces, they gain <em>first-class</em> citizenship and are usable as variables, arguments, and return values, as seen in <a data-type="xref" href="#_01-functions_first-class">Example 2-10</a>.</p>
<div data-type="example" id="_01-functions_first-class">
<h5><span class="label">Example 2-10. </span>First-class Java Lambdas</h5>
<pre data-code-language="java" data-type="programlisting"><code class="c1">// VARIABLE ASSIGNMENT</code>

<code class="n">UnaryOperator</code><code class="o">&lt;</code><code class="n">Integer</code><code class="o">&gt;</code> <code class="n">quadraticFn</code> <code class="o">=</code> <code class="n">x</code> <code class="o">-</code><code class="o">&gt;</code> <code class="n">x</code> <code class="o">*</code> <code class="n">x</code><code class="p">;</code> <a class="co" href="#callout_functional_java_CO9-1" id="co_functional_java_CO9-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a>

<code class="n">quadraticFn</code><code class="p">.</code><code class="na">apply</code><code class="p">(</code><code class="mi">5</code><code class="p">)</code><code class="p">;</code> <a class="co" href="#callout_functional_java_CO9-2" id="co_functional_java_CO9-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a>
<code class="c1">// =&gt; 25</code>


<code class="c1">// METHOD ARGUMENT</code>

<code class="kd">public</code> <code class="n">Integer</code> <code class="nf">apply</code><code class="p">(</code><code class="n">Integer</code> <code class="n">input</code><code class="p">,</code>
                     <code class="n">UnaryOperator</code><code class="o">&lt;</code><code class="n">Integer</code><code class="o">&gt;</code> <code class="n">operation</code><code class="p">)</code> <code class="p">{</code>
  <code class="k">return</code> <code class="n">operation</code><code class="p">.</code><code class="na">apply</code><code class="p">(</code><code class="n">input</code><code class="p">)</code><code class="p">;</code> <a class="co" href="#callout_functional_java_CO9-3" id="co_functional_java_CO9-3"><img alt="3" height="12" src="assets/3.png" width="12"/></a>
<code class="p">}</code>


<code class="c1">// RETURN VALUE</code>

<code class="kd">public</code> <code class="n">UnaryOperator</code><code class="o">&lt;</code><code class="n">Integer</code><code class="o">&gt;</code> <code class="nf">multiplyWith</code><code class="p">(</code><code class="n">Integer</code> <code class="n">multiplier</code><code class="p">)</code> <code class="p">{</code>
  <code class="k">return</code> <code class="n">x</code> <code class="o">-</code><code class="o">&gt;</code> <code class="n">multiplier</code> <code class="o">*</code> <code class="n">x</code><code class="p">;</code> <a class="co" href="#callout_functional_java_CO9-4" id="co_functional_java_CO9-4"><img alt="4" height="12" src="assets/4.png" width="12"/></a>
<code class="p">}</code>

<code class="n">UnaryOperator</code><code class="o">&lt;</code><code class="n">Integer</code><code class="o">&gt;</code> <code class="n">multiplyWithFive</code> <code class="o">=</code> <code class="n">multiplyWith</code><code class="p">(</code><code class="mi">5</code><code class="p">)</code><code class="p">;</code>

<code class="n">multiplyWithFive</code><code class="p">.</code><code class="na">apply</code><code class="p">(</code><code class="mi">6</code><code class="p">)</code><code class="p">;</code>
<code class="c1">// =&gt; 30</code></pre></div>
<dl class="calloutlist">
<dt><a class="co" href="#co_functional_java_CO9-1" id="callout_functional_java_CO9-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p>Assigning a Java lambda to the variable <code>quadraticFn</code>.</p></dd>
<dt><a class="co" href="#co_functional_java_CO9-2" id="callout_functional_java_CO9-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a></dt>
<dd><p>It can be used like any other “normal” Java variable, calling the <code>apply</code> method of its interface.</p></dd>
<dt><a class="co" href="#co_functional_java_CO9-3" id="callout_functional_java_CO9-3"><img alt="3" height="12" src="assets/3.png" width="12"/></a></dt>
<dd><p>Lambdas are usable like any other type for arguments.</p></dd>
<dt><a class="co" href="#co_functional_java_CO9-4" id="callout_functional_java_CO9-4"><img alt="4" height="12" src="assets/4.png" width="12"/></a></dt>
<dd><p>Returning a lambda is like returning any other Java variable.</p></dd>
</dl>
<p>Accepting lambdas as arguments and returning lambdas is essential for the next concept, <em>functional composition</em>.</p>
</div></section>
<section data-pdf-bookmark="Functional Composition" data-type="sect2"><div class="sect2" id="idm45115250380304">
<h2>Functional Composition</h2>
<p>The idea of creating complex systems by composing smaller components is a cornerstone of programming, regardless of the chosen paradigm to follow.
In OOP, objects can be composed of smaller ones, building a more complex API.
In FP, two functions are combined to build a new function, which then can be combined further.</p>
<p>Functional composition is arguably one of the essential aspects of a functional programming mindset.
It allows you to build complex systems by composing smaller, reusable functions into a larger chain, fulfilling a more complex task, as illustrated in <a data-type="xref" href="#_01-functional-java_functional-composition">Figure 2-1</a>.</p>
<figure><div class="figure" id="_01-functional-java_functional-composition">
<img alt="Composing complex tasks from multiple functions" height="347" src="assets/afaj_0201.png" width="362"/>
<h6><span class="label">Figure 2-1. </span>Composing complex tasks from multiple functions</h6>
</div></figure>
<p>Java’s functional composition capabilities depend highly on the involved concrete types.
In <a data-type="xref" href="ch03.xhtml#_01-functional-jdk_functional-composition">“Functional Composition”</a>, I will discuss how to combine the different functional interfaces provided by the JDK.</p>
</div></section>
<section data-pdf-bookmark="Lazy Evaluation" data-type="sect2"><div class="sect2" id="idm45115250373824">
<h2>Lazy Evaluation</h2>
<p>Even though Java, at least in principle, is a non-lazy — <em>strict</em> or <em>eager</em> — language, it supports multiple lazy constructs:</p>
<ul>
<li>
<p>Logical short-circuit operators</p>
</li>
<li>
<p><code>if</code>-<code>else</code> and the <code>:?</code> (ternary) operator</p>
</li>
<li>
<p><code>for</code> and <code>while</code> loops</p>
</li>
</ul>
<p>Logical short-circuit operators are a simple example of laziness:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">var</code> <code class="n">result1</code> <code class="o">=</code> <code class="n">simple</code><code class="p">()</code> <code class="o">&amp;&amp;</code> <code class="n">complex</code><code class="p">();</code>

<code class="kd">var</code> <code class="n">result2</code> <code class="o">=</code> <code class="n">simple</code><code class="p">()</code> <code class="o">||</code> <code class="n">complex</code><code class="p">();</code></pre>
<p>The evaluation <code>complex()</code> depends on the outcome of <code>simple()</code> and the logical operator used in the overall expression.
That’s why the JVM can discard expressions that don’t need evaluation, as will be explained in more detail in <a data-type="xref" href="ch11.xhtml#_02-lazy-evaluation">Chapter 11</a>.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="Takeaways" data-type="sect1"><div class="sect1" id="idm45115250330368">
<h1>Takeaways</h1>
<ul>
<li>
<p>Functional interfaces are concrete types and representations of Java lambdas.</p>
</li>
<li>
<p>Java’s lambda syntax is close to the underlying mathematical notation of lambda calculus.</p>
</li>
<li>
<p>Lambdas can be expressed with multiple levels of verbosity, depending on the surrounding context and your requirements.
Shorter isn’t always as expressive as it should be, especially if others are reading your code.</p>
</li>
<li>
<p>Lamba expressions are not <em>syntactic sugar</em> thanks to the JVM using the opcode <code>invokedynamic</code>.
This allows for multiple optimization techniques to get better performance as alternatives like anonymous classes.</p>
</li>
<li>
<p>Outside variables need to be <em>effectively</em> <code>final</code> to be used in lambdas, but this makes only the references immutable, not the underlying data structure.</p>
</li>
<li>
<p>Method references are a concise alternative for matching method signatures and lambda definitions.
They even provide a simple way to use “identical but incompatible” functional interface types.</p>
</li>
</ul>
</div></section>
<div data-type="footnotes"><p data-type="footnote" id="idm45115256766512"><sup><a href="ch02.xhtml#idm45115256766512-marker">1</a></sup> The simplified version of <code>java.util.function.Predicate</code> is based on the source code for the latest Git tag of the LTS version at the time of writing: 17+35. You can check out the <a href="https://github.com/openjdk/jdk/blob/dfacda488bfbe2e11e8d607a6d08527710286982/src/java.base/share/classes/java/util/function/Predicate.java">official source code repository</a> to see the original file.</p><p data-type="footnote" id="idm45115252733520"><sup><a href="ch02.xhtml#idm45115252733520-marker">2</a></sup> The <a href="https://docs.oracle.com/en/java/javase/17/docs/api/jdk.jshell/jdk/jshell/JShell.xhtml#eval(java.lang.String)">official documentation</a> sheds some light on the special semantics and requirements for top-level expressions and declarations.</p><p data-type="footnote" id="idm45115252515552"><sup><a href="ch02.xhtml#idm45115252515552-marker">3</a></sup> Landin, Peter J. (1964). “The mechanical evaluation of expressions.” <a href="https://doi.org/10.1093/comjnl/6.4.308">The Computer Journal. Computer Journal. 6 (4)</a>.</p><p data-type="footnote" id="idm45115252465520"><sup><a href="ch02.xhtml#idm45115252465520-marker">4</a></sup> The Java Magazine has <a href="https://blogs.oracle.com/javamagazine/post/understanding-java-method-invocation-with-invokedynamic">an article</a> by Java Champion Ben Evans that explains method invocation with <code>invokedynamic</code> in more detail.</p><p data-type="footnote" id="idm45115252462144"><sup><a href="ch02.xhtml#idm45115252462144-marker">5</a></sup> The class <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/invoke/LambdaMetafactory.xhtml"><code>java.lang.invoke.LambdaMetaFactory</code></a> is responsible for creating “bootstrap methods.”</p><p data-type="footnote" id="idm45115250887264"><sup><a href="ch02.xhtml#idm45115250887264-marker">6</a></sup> <a href="https://www.ehcache.org/">Ehcache</a> is a widely-used Java cache library.</p><p data-type="footnote" id="idm45115250884688"><sup><a href="ch02.xhtml#idm45115250884688-marker">7</a></sup> The official documentation of <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/cache/annotation/Cacheable.xhtml">like <code>@Cacheable</code></a> explains the inner workings including key mechanics.</p><p data-type="footnote" id="idm45115250882416"><sup><a href="ch02.xhtml#idm45115250882416-marker">8</a></sup> The <a href="https://tapestry.apache.org/5.8.2/apidocs/org/apache/tapestry5/annotations/Cached.xhtml">Tapestry annotation</a> doesn’t support key-based caching, but can be bound to a field instead.</p></div></div></section></div></body></html>