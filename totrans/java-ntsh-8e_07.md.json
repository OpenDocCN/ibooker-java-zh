["```java\npublic static void main(String args[]) {\n  int bigArray[] = new int[100000];\n\n  // Do some computations with bigArray and get a result.\n  int result = compute(bigArray);\n\n  // We no longer need bigArray. It will get garbage collected when\n  // there are no more references to it. Because bigArray is a local\n  // variable, it refers to the array until this method returns. But\n  // this method doesn't return.\n  // If we explicitly sever the reference by assigning it to\n  // null then the garbage collector knows it can reclaim the array.\n  bigArray = null;\n\n  // Loop forever, handling the user's input\n  for(;;) handle_input(result);\n}\n```", "```java\n-XX:+UseShenandoahGC\n```", "```java\n-XX:+UseZGC\n```", "```java\nThread t = new Thread(() -> {System.out.println(\"Hello Thread\");});\nt.start();\n```", "```java\ntry {\n    Thread.sleep(2000);\n} catch (InterruptedException e) {\n    e.printStackTrace();\n}\n```", "```java\npublic class Account {\n    private double balance = 0.0; // Must be >= 0\n    // Assume the existence of other field (e.g., name) and methods\n    // such as deposit(), checkBalance(), and dispenseNotes()\n\n    public Account(double openingBal) {\n        balance = openingBal;\n    }\n\n    public boolean withdraw(double amount) {\n        if (balance >= amount) {\n            try {\n                Thread.sleep(2000); // Simulate risk checks\n            } catch (InterruptedException e) {\n                return false;\n            }\n            balance = balance - amount;\n            dispenseNotes(amount);\n            return true;\n        }\n        return false;\n    }\n}\n```", "```java\npublic class Counter {\n    private int i = 0;\n\n    public int increment() {\n        return i = i + 1;\n    }\n    public int getCounter() { return i; }\n}\n```", "```java\n    Counter c = new Counter();\n    int REPEAT = 10_000_000;\n    Runnable r = () -> {\n        for (int i = 0; i < REPEAT; i++) {\n            c.increment();\n        }\n    };\n    Thread t1 = new Thread(r);\n    Thread t2 = new Thread(r);\n\n    t1.start();\n    t2.start();\n    t1.join();\n    t2.join();\n\n    int anomaly = (2 * REPEAT) - c.getCounter();\n    double perc = ((double) anomaly * 100) / (2 * REPEAT);\n    System.out.println(\"Lost updates: \"+ anomaly +\" ; % = \" + perc);\n```", "```java\nprivate volatile boolean shutdown = false;\n\npublic void shutdown() {\n    shutdown = true;\n}\n\npublic void run() {\n    while (!shutdown) {\n        // ... process another task\n    }\n}\n```", "```java\n// This thread just throws an exception\nThread handledThread =\n  new Thread(() -> { throw new UnsupportedOperationException(); });\n\n// Giving threads a name helps with debugging\nhandledThread.setName(\"My Broken Thread\");\n\n// Here's a handler for the error.\nhandledThread.setUncaughtExceptionHandler((t, e) -> {\n    System.err.printf(\"Exception in thread %d '%s':\" +\n        \"%s at line %d of %s%n\",\n        t.getId(),    // Thread id\n        t.getName(),  // Thread name\n        e.toString(), // Exception name and message\n        e.getStackTrace()[0].getLineNumber(),\n        e.getStackTrace()[0].getFileName()); });\nhandledThread.start();\n```", "```java\n/*\n * One thread calls push() to put an object on the queue.\n * Another calls pop() to get an object off the queue. If there is no\n * data, pop() waits until there is some, using wait()/notify().\n */\npublic class WaitingQueue<E> {\n    LinkedList<E> q = new LinkedList<E>(); // storage\n    public synchronized void push(E o) {\n        q.add(o);         // Append the object to the end of the list\n        this.notifyAll(); // Tell waiting threads that data is ready\n    }\n    public synchronized E pop() {\n        while(q.size() == 0) {\n            try { this.wait(); }\n            catch (InterruptedException ignore) {}\n        }\n        return q.remove();\n    }\n}\n```"]