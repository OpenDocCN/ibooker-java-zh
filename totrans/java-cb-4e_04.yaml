- en: Chapter 4\. Pattern Matching with Regular Expressions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 4 章：使用正则表达式进行模式匹配
- en: 4.0 Introduction
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.0 简介
- en: Suppose you have been on the internet for a few years and have been faithful
    about saving all your correspondence, just in case you (or your lawyers, or the
    prosecution) need a copy. The result is that you have a 5 GB disk partition dedicated
    to saved mail. Let’s further suppose that you remember that somewhere in there
    is an email message from someone named Angie or Anjie. Or was it Angy? But you
    don’t remember what you called it or where you stored it. Obviously, you have
    to look for it.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经在互联网上几年了，并且一直在保留所有通讯记录，以防万一您（或您的律师或检察官）需要一份副本。结果是您有一个专门用于保存邮件的 5 GB 磁盘分区。让我们进一步假设您记得在其中的某个位置有一封来自某个名叫
    Angie 或 Anjie 的人的电子邮件。还是说是 Angy？但您不记得您如何称呼它或者您将其存储在何处。显然，您得去找它。
- en: 'But while some of you go and try to open up all 15,000,000 documents in a word
    processor, I’ll just find it with one simple command. Any system that provides
    regular expression support allows me to search for the pattern in several ways.
    The simplest to understand is:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 但是当你们中的一些人试图在文字处理器中打开所有 15,000,000 个文档时，我只需用一个简单的命令找到它。任何提供正则表达式支持的系统都允许我以几种方式搜索模式。最简单易懂的是：
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'which you can probably guess means just to search for any of the variations.
    A more concise form (more thinking, less typing) is:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能猜到这意味着只需搜索任何变体。更简洁的形式（更多思考，更少打字）是：
- en: '[PRE1]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The syntax will become clear as we go through this chapter. Briefly, the “A”
    and the “n” match themselves, in effect finding words that begin with “An”, while
    the cryptic `[^ dn]` requires the “An” to be followed by a character other than
    (*^* means *not* in this context) a space (to eliminate the very common English
    word “an” at the start of a sentence) or “d” (to eliminate the common word “and”)
    or “n” (to eliminate “Anne,” “Announcing,” etc.). Has your word processor gotten
    past its splash screen yet? Well, it doesn’t matter, because I’ve already found
    the missing file. To find the answer, I just typed this command:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 语法将在我们进行本章讨论时变得清晰。简而言之，“A”和“n”会自动匹配它们自己，实际上找到以“An”开头的单词，而神秘的`[^ dn]`要求“An”后面跟着一个不是（*^*在这里的意思是*not*）空格的字符（以消除在句子开头非常常见的英语单词“an”）或“d”（以消除常见词“and”）或“n”（以消除“Anne”、“Announcing”等）。您的文字处理器是否已经跳过了它的闪屏页面？好吧，这没关系，因为我已经找到了丢失的文件。要找到答案，我只需输入这个命令：
- en: '[PRE2]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Regular expressions*, or *regexes* for short, provide a concise and precise
    specification of patterns to be matched in text. One good way to think of regular
    expressions is as a little language for matching patterns of characters in text
    contained in strings. A regular expression API is an [interpreter](https://en.wikipedia.org/wiki/Interpreter_(computing))
    for matching regular expressions.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*正则表达式*，或称为*regexes*，提供了一种简洁而精确的模式规范，用于在文本中匹配。一种好的理解正则表达式的方式是它是用于在字符串中匹配字符模式的一种小语言。正则表达式
    API 是用于匹配正则表达式的[解释器](https://en.wikipedia.org/wiki/Interpreter_(computing))。'
- en: 'As another example of the power of regular expressions, consider the problem
    of bulk-updating hundreds of files. When I started with Java, the syntax for declaring
    array references was `baseType arrayVariableName[]`. For example, a method with
    an array argument, such as every program’s main method, was commonly written like
    this:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个正则表达式强大之处的例子是考虑大规模更新数百个文件的问题。当我开始学习 Java 时，声明数组引用的语法是`baseType arrayVariableName[]`。例如，一个带有数组参数的方法，例如每个程序的主方法，通常是这样写的：
- en: '[PRE3]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'But as time went by, it became clear to the stewards of the Java language that
    it would be better to write it as `baseType[] arrayVariableName`, like this:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 但随着时间的推移，Java 语言的管理者们认识到将其写为`baseType[] arrayVariableName`会更好，就像这样：
- en: '[PRE4]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is better Java style because it associates the “array-ness” of the type
    with the type itself, rather than with the local argument name, and the compiler
    still accepts both modes. I wanted to change all occurrences of `main` written
    the old way to the new way. I used the pattern *`main(String [a-z]`* with the
    *grep* utility described earlier to find the names of all the files containing
    old-style main declarations (i.e., `main(String` followed by a space and a name
    character rather than an open square bracket). I then used another regex-based
    Unix tool, the stream editor *sed*, in a little shell script to change all occurrences
    in those files from *`main(String *([a-z][a-z]*)[]`* to *`main(String[] $1`* (the
    regex syntax used here is discussed later in this chapter). Again, the regex-based
    approach was orders of magnitude faster than doing it interactively, even using
    a reasonably powerful editor such as `vi` or `emacs`, let alone trying to use
    a graphical word processor.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这是更好的Java风格，因为它将类型的“数组性”与类型本身关联起来，而不是与局部参数名关联，并且编译器仍然接受这两种模式。我希望将所有以旧方式编写的`main`更改为新方式。我使用了模式*`main(String
    [a-z]`*，通过之前描述的*grep*实用程序查找所有包含旧式主体声明（即`main(String`后跟一个空格和一个名称字符而不是一个开方括号）的文件名。然后，我在一个小的shell脚本中使用另一个基于正则表达式的Unix工具流编辑器*sed*来更改这些文件中所有出现的内容，从*`main(String
    *([a-z][a-z]*)[]`*到*`main(String[] $1`*（此处使用的正则表达式语法在本章后面讨论）。同样，基于正则表达式的方法比交互式地进行操作快得多，即使使用像`vi`或`emacs`这样的强大编辑器，更不用说尝试使用图形化的文字处理器了。
- en: Historically, the syntax of regexes has changed as they get incorporated into
    more tools and more languages, so the exact syntax in the previous examples is
    not exactly what you’d use in Java, but it does convey the conciseness and power
    of the regex mechanism.^([1](ch04.html#idm45290687159592))
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 历史上，随着正则表达式被越来越多的工具和编程语言所采纳，其语法也发生了变化，因此先前示例中的确切语法并不完全适用于Java，但它确实传达了正则表达式机制的简洁性和强大性。^([1](ch04.html#idm45290687159592))
- en: As a third example, consider parsing an Apache web server logfile, where some
    fields are delimited with quotes, others with square brackets, and others with
    spaces. Writing ad hoc code to parse this is messy in any language, but a well-crafted
    regex can break the line into all its constituent fields in one operation (this
    example is developed in [Recipe 4.10](#javacook-regex-SECT-10)).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个例子是解析Apache Web服务器日志文件，其中一些字段用引号分隔，另一些用方括号分隔，还有些用空格分隔。在任何语言中编写解析代码都很混乱，但是一个精心设计的正则表达式可以在一次操作中将行分解为所有组成部分（此示例在[配方
    4.10](#javacook-regex-SECT-10)中开发）。
- en: These same time gains can be had by Java developers. Regular expression support
    has been in the standard Java runtime for ages and is well integrated (e.g., there
    are regex methods in the standard class `java.lang.String` and in the new I/O
    package). There are a few other regex packages for Java, and you may occasionally
    encounter code using them, but pretty well all code from this century can be expected
    to use the built-in package. The syntax of Java regexes themselves is discussed
    in [Recipe 4.1](#javacook-regex-SECT-1), and the syntax of the Java API for using
    regexes is described in [Recipe 4.2](#javacook-regex-SECT-2). The remaining recipes
    show some applications of regex technology in Java.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Java开发人员也可以获得同样的时间节省。正则表达式支持已经在标准Java运行时中存在多年，并且得到了很好的集成（例如，标准类`java.lang.String`和新I/O包中都有正则表达式方法）。Java还有一些其他正则表达式包，偶尔可能会遇到使用它们的代码，但几乎所有本世纪的代码都可以预期使用内置包。Java正则表达式的语法本身在[配方
    4.1](#javacook-regex-SECT-1)中讨论，使用正则表达式的Java API的语法在[配方 4.2](#javacook-regex-SECT-2)中描述。其余的配方展示了Java中正则表达式技术的一些应用。
- en: See Also
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*[Mastering Regular Expressions](http://shop.oreilly.com/product/9780596528126.do)*
    by Jeffrey Friedl (O’Reilly) is the definitive guide to all the details of regular
    expressions. Most introductory books on Unix and Perl include some discussion
    of regexes; *[Unix Power Tools](http://shop.oreilly.com/product/9780596003302.do)*
    by Mike Loukides, Tim O’Reilly, Jerry Peek, and Shelley Powers (O’Reilly) devotes
    a chapter to them.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*[精通正则表达式](http://shop.oreilly.com/product/9780596528126.do)* 由Jeffrey Friedl（O’Reilly）是正则表达式所有细节的权威指南。Unix和Perl的大多数入门书籍都包含对正则表达式的讨论；*[Unix权威指南](http://shop.oreilly.com/product/9780596003302.do)*
    由Mike Loukides、Tim O’Reilly、Jerry Peek和Shelley Powers（O’Reilly）专门有一章介绍正则表达式。'
- en: 4.1 Regular Expression Syntax
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.1 正则表达式语法
- en: Problem
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to learn the syntax of Java regular expressions.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要学习Java正则表达式的语法。
- en: Solution
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Consult [Table 4-1](#javacook-regex-TABLE-2) for a list of the regular expression
    characters.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 参考 [Table 4-1](#javacook-regex-TABLE-2) 获取正则表达式字符列表。
- en: Discussion
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: These pattern characters let you specify regexes of considerable power. In building
    patterns, you can use any combination of ordinary text and the *metacharacters*,
    or special characters, in [Table 4-1](#javacook-regex-TABLE-2). These can all
    be used in any combination that makes sense. For example, `a+` means any number
    of occurrences of the letter `a`, from one up to a million or a gazillion. The
    pattern `Mrs?`\. matches `Mr.` or `Mrs.` And `.*` indicates any character, any
    number of times, and is similar in meaning to most command-line interpreters’
    meaning of the `\*` alone. The pattern `\d+` means any number of numeric digits.
    `\d{2,3}` means a two- or three-digit number.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模式字符允许您指定具有相当强大的正则表达式。在构建模式时，您可以使用任何普通文本和元字符或特殊字符的组合，在 [Table 4-1](#javacook-regex-TABLE-2)
    中。这些可以以任何合理的组合方式使用。例如，`a+` 表示字母 `a` 的任意次数，从一次到百万次或无限多次。模式 `Mrs?`\. 匹配 `Mr.` 或
    `Mrs.` 而 `.*` 表示任意字符，任意次数，类似于大多数命令行解释器对单独的 `\*` 的含义。模式 `\d+` 表示任意数量的数字。`\d{2,3}`
    表示二位或三位数字。
- en: Table 4-1\. Regular expression metacharacter syntax
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Table 4-1\. 正则表达式元字符语法
- en: '| Subexpression | Matches | Notes |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| 子表达式 | 匹配 | 注释 |'
- en: '| --- | --- | --- |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| **General** |  |  |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| **通用** |  |  |'
- en: '| `\^` | Start of line/string |  |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `\^` | 行/字符串的起始位置 |  |'
- en: '| `$` | End of line/string |  |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `$` | 行/字符串的结束位置 |  |'
- en: '| `\b` | Word boundary |  |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `\b` | 单词边界 |  |'
- en: '| `\B` | Not a word boundary |  |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `\B` | 非单词边界 |  |'
- en: '| `\A` | Beginning of entire string |  |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `\A` | 整个字符串的开始 |  |'
- en: '| `\z` | End of entire string |  |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `\z` | 整个字符串的结束 |  |'
- en: '| `\Z` | End of entire string (except allowable final line terminator) | See
    [Recipe 4.9](#javacook-regex-SECT-9) |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `\Z` | 整个字符串的结束（除了允许的最终行终止符） | 参见 [Recipe 4.9](#javacook-regex-SECT-9) |'
- en: '| . | Any one character (except line terminator) |  |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| . | 任一字符（不包括行终止符） |  |'
- en: '| `[…]` | “Character class”; any one character from those listed |  |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `[…]` | “字符类”；包含列出的任一字符 |  |'
- en: '| `[\^…]` | Any one character not from those listed | See [Recipe 4.2](#javacook-regex-SECT-2)
    |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `[\^…]` | 不包含列出的任一字符 | 参见 [Recipe 4.2](#javacook-regex-SECT-2) |'
- en: '| **Alternation and grouping** |  |  |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| **替代和分组** |  |  |'
- en: '| `(…)` | Grouping (capture groups) | See [Recipe 4.3](#javacook-regex-SECT-3)
    |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `(…)` | 分组（捕获组） | 参见 [Recipe 4.3](#javacook-regex-SECT-3) |'
- en: '| `&#124;` | Alternation |  |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `&#124;` | 替代 |  |'
- en: '| `(?`:_`re`_ `)` | Noncapturing parenthesis |  |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `(?`:_`re`_ `)` | 非捕获括号 |  |'
- en: '| `\G` | End of the previous match |  |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `\G` | 前一次匹配的结束 |  |'
- en: '| +\+*`n`* | Back-reference to capture group number *`n`* |  |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| +\+*`n`* | 回溯引用到捕获组编号 *`n`* |  |'
- en: '| **Normal (greedy) quantifiers** |  |  |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| **普通（贪婪）量词** |  |  |'
- en: '| `{` *`m`*,*`n`* `}` | Quantifier for from *`m`* to *`n`* repetitions | See
    [Recipe 4.4](#javacook-regex-SECT-4) |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `{` *`m`*,*`n`* `}` | 从 *`m`* 到 *`n`* 次重复的量词 | 参见 [Recipe 4.4](#javacook-regex-SECT-4)
    |'
- en: '| `{` *`m`* `,}` | Quantifier for *`m`* or more repetitions |  |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `{` *`m`* `,}` | 至少 *`m`* 次重复的量词 |  |'
- en: '| `{` *`m`* `}` | Quantifier for exactly *`m`* repetitions | See [Recipe 4.10](#javacook-regex-SECT-10)
    |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `{` *`m`* `}` | 正好 *`m`* 次重复的量词 | 参见 [Recipe 4.10](#javacook-regex-SECT-10)
    |'
- en: '| `{`,*`n`* `}` | Quantifier for 0 up to *`n`* repetitions |  |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `{`,*`n`* `}` | 0 到 *`n`* 次重复的量词 |  |'
- en: '| `\*` | Quantifier for 0 or more repetitions | Short for `{0,}` |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `\*` | 0 或多次重复的量词 | 等同于 `{0,}` |'
- en: '| `+` | Quantifier for 1 or more repetitions | Short for `{1,}`; see [Recipe
    4.2](#javacook-regex-SECT-2) |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `+` | 1 次或更多次重复的量词 | 等同于 `{1,}`；参见 [Recipe 4.2](#javacook-regex-SECT-2) |'
- en: '| `?` | Quantifier for 0 or 1 repetitions (i.e., present exactly once, or not
    at all) | Short for `{0,1}` |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `?` | 0 或 1 次重复的量词（即，确切出现一次，或者根本不出现） | 等同于 `{0,1}` |'
- en: '| **Reluctant (nongreedy) quantifiers** |  |  |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| **懒惰（非贪婪）量词** |  |  |'
- en: '| `{` *`m`*,*`n`* `}?` | Reluctant quantifier for from *`m`* to *`n`* repetitions
    |  |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `{` *`m`*,*`n`* `}?` | 懒惰量词，从 *`m`* 到 *`n`* 次重复 |  |'
- en: '| `{` *`m`* `,}?` | Reluctant quantifier for *`m`* or more repetitions |  |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `{` *`m`*,}?` | 懒惰量词，至少 *`m`* 次重复 |  |'
- en: '| `{`,*`n`* `}?` | Reluctant quantifier for 0 up to *`n`* repetitions |  |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `{`,*`n`* `}?` | 懒惰量词，从 0 到 *`n`* 次重复 |  |'
- en: '| `\*?` | Reluctant quantifier: 0 or more |  |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `\*?` | 懒惰量词：0 或多次 |  |'
- en: '| `+?` | Reluctant quantifier: 1 or more | See [Recipe 4.10](#javacook-regex-SECT-10)
    |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `+?` | 懒惰量词：1 次或更多次 | 参见 [Recipe 4.10](#javacook-regex-SECT-10) |'
- en: '| `??` | Reluctant quantifier: 0 or 1 times |  |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `??` | 懒惰量词：0 或 1 次 |  |'
- en: '| **Possessive (very greedy) quantifiers** |  |  |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| **占有型（非常贪婪）量词** |  |  |'
- en: '| `{` *`m`*,*`n`* `}+` | Possessive quantifier for from *`m`* to *`n`* repetitions
    |  |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `{` *`m`*,*`n`* `}+` | 从*m*到*n*次重复的占有量词 |  |'
- en: '| `{` *`m`* `,}+` | Possessive quantifier for *`m`* or more repetitions |  |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `{` *`m`* `,}+` | 至少*m*次重复的占有量词 |  |'
- en: '| `{`,*`n`* `}+` | Possessive quantifier for 0 up to *`n`* repetitions |  |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `{`,*`n`* `}+` | 0到*n*次重复的占有量词 |  |'
- en: '| `\*+` | Possessive quantifier: 0 or more |  |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `\*+` | 占有量词：0或更多 |  |'
- en: '| `++` | Possessive quantifier: 1 or more |  |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `++` | 占有量词：1次或更多 |  |'
- en: '| `?+` | Possessive quantifier: 0 or 1 times |  |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `?+` | 占有量词：0或1次 |  |'
- en: '| **Escapes and shorthands** |  |  |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| **转义和速记** |  |  |'
- en: '| `\` | Escape (quote) character: turns most metacharacters off; turns subsequent
    alphabetic into metacharacters |  |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `\` | 转义（引号）字符：关闭大多数元字符；将后续字母转换为元字符 |  |'
- en: '| `\Q` | Escape (quote) all characters up to `\E` |  |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `\Q` | 转义（引用）直到`\E`的所有字符 |  |'
- en: '| `\E` | Ends quoting begun with `\Q` |  |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `\E` | 结束以`\Q`开始的引用 |  |'
- en: '| `\t` | Tab character |  |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `\t` | 制表符 |  |'
- en: '| `\r` | Return (carriage return) character |  |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `\r` | 回车（换行回车）字符 |  |'
- en: '| `\n` | Newline character | See [Recipe 4.9](#javacook-regex-SECT-9) |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `\n` | 换行符 | 参见[Recipe 4.9](#javacook-regex-SECT-9) |'
- en: '| `\f` | Form feed |  |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `\f` | 换页符 |  |'
- en: '| `\w` | Character in a word | Use `\w+` for a word; see [Recipe 4.10](#javacook-regex-SECT-10)
    |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `\w` | 单词中的字符 | 使用`\w+`表示一个单词；参见[Recipe 4.10](#javacook-regex-SECT-10) |'
- en: '| `\W` | A nonword character |  |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `\W` | 非单词字符 |  |'
- en: '| `\d` | Numeric digit | Use `\d+` for an integer; see [Recipe 4.2](#javacook-regex-SECT-2)
    |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `\d` | 数字字符 | 使用`\d+`表示整数；参见[Recipe 4.2](#javacook-regex-SECT-2) |'
- en: '| `\D` | A nondigit character |  |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `\D` | 非数字字符 |  |'
- en: '| `\s` | Whitespace | Space, tab, etc., as determined by `java.lang.Character.isWhitespace()`
    |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `\s` | 空白字符 | 空格、制表符等，由`java.lang.Character.isWhitespace()`确定 |'
- en: '| `\S` | A nonwhitespace character | See [Recipe 4.10](#javacook-regex-SECT-10)
    |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `\S` | 非空白字符 | 参见[Recipe 4.10](#javacook-regex-SECT-10) |'
- en: '| **Unicode blocks (representative samples)** |  |  |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| **Unicode区块（代表性样本）** |  |  |'
- en: '| `\p{InGreek}` | A character in the Greek block | (Simple block) |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `\p{InGreek}` | 希腊区块中的字符 | （简单区块） |'
- en: '| `\P{InGreek}` | Any character not in the Greek block |  |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `\P{InGreek}` | 不在希腊区块中的任何字符 |  |'
- en: '| `\p{Lu}` | An uppercase letter | (Simple category) |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `\p{Lu}` | 大写字母 | （简单类别） |'
- en: '| `\p{Sc}` | A currency symbol |  |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `\p{Sc}` | 货币符号 |  |'
- en: '| **POSIX-style character classes (defined only for US-ASCII)** |  |  |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| **POSIX风格的字符类（仅适用于US-ASCII）** |  |  |'
- en: '| `\p{Alnum}` | Alphanumeric characters | `[A-Za-z0-9]` |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `\p{Alnum}` | 字母数字字符 | `[A-Za-z0-9]` |'
- en: '| `\p{Alpha}` | Alphabetic characters | `[A-Za-z]` |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `\p{Alpha}` | 字母字符 | `[A-Za-z]` |'
- en: '| `\p{ASCII}` | Any ASCII character | `[\x00-\x7F]` |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `\p{ASCII}` | 任何ASCII字符 | `[\x00-\x7F]` |'
- en: '| `\p{Blank}` | Space and tab characters |  |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `\p{Blank}` | 空格和制表符字符 |  |'
- en: '| `\p{Space}` | Space characters | `[ \t\n\x0B\f\r]` |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `\p{Space}` | 空格字符 | `[ \t\n\x0B\f\r]` |'
- en: '| `\p{Cntrl}` | Control characters | `[\x00-\x1F\x7F]` |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `\p{Cntrl}` | 控制字符 | `[\x00-\x1F\x7F]` |'
- en: '| `\p{Digit}` | Numeric digit characters | `[0-9]` |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `\p{Digit}` | 数字字符 | `[0-9]` |'
- en: '| `\p{Graph}` | Printable and visible characters (not spaces or control characters)
    |  |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `\p{Graph}` | 可打印且可见字符（非空格或控制字符） |  |'
- en: '| `\p{Print}` | Printable characters | Same as `\p{Graph}` |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `\p{Print}` | 可打印字符 | 与`\p{Graph}`相同 |'
- en: '| `\p{Punct}` | Punctuation characters | One of `!"#$%&''()\*+,-./:;<=>?@[]\^_`{&#124;}\~`
    |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `\p{Punct}` | 标点字符 | `!"#$%&''()\*+,-./:;<=>?@[]\^_`{&#124;}\~` |'
- en: '| `\p{Lower}` | Lowercase characters | `[a-z]` |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `\p{Lower}` | 小写字符 | `[a-z]` |'
- en: '| `\p{Upper}` | Uppercase characters | `[A-Z]` |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `\p{Upper}` | 大写字符 | `[A-Z]` |'
- en: '| `\p{XDigit}` | Hexadecimal digit characters | `[0-9a-fA-F]` |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `\p{XDigit}` | 十六进制数字字符 | `[0-9a-fA-F]` |'
- en: Regexes match any place possible in the string. Patterns followed by greedy
    quantifiers (the only type that existed in traditional Unix regexes) consume (match)
    as much as possible without compromising any subexpressions that follow. Patterns
    followed by possessive quantifiers match as much as possible without regard to
    following subexpressions. Patterns followed by reluctant quantifiers consume as
    few characters as possible to still get a match.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式尽可能在字符串中匹配任何位置。紧随贪婪量词（在传统Unix正则表达式中唯一存在的类型）的模式尽可能多地消耗（匹配），而不会影响接下来的子表达式。紧随占有量词的模式尽可能多地匹配，而不考虑接下来的子表达式。紧随懒惰量词的模式尽可能少地消耗字符，以便仍然能够匹配。
- en: Also, unlike regex packages in some other languages, the Java regex package
    was designed to handle Unicode characters from the beginning. The standard Java
    escape sequence `\u+nnnn` is used to specify a Unicode character in the pattern.
    We use methods of `java.lang.Character` to determine Unicode character properties,
    such as whether a given character is a space. Again, note that the backslash must
    be doubled if this is in a Java string that is being compiled because the compiler
    would otherwise parse this as “backslash-u” followed by some numbers.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，与其他一些语言中的正则表达式包不同，Java 正则表达式包从一开始就被设计用来处理 Unicode 字符。标准的 Java 转义序列`\u+nnnn`用于在模式中指定
    Unicode 字符。我们使用`java.lang.Character`的方法来确定 Unicode 字符的属性，例如给定字符是否为空格。再次注意，如果这是在编译中的
    Java 字符串中，则必须加倍反斜杠，因为编译器否则会将其解析为“反斜杠-u”后跟一些数字。
- en: To help you learn how regexes work, I provide a little program called REDemo.^([2](ch04.html#idm45290686929656))
    The code for REDemo is too long to include in the book; in the online directory
    *regex* of the *darwinsys-api* repo, you will find *REDemo.java*, which you can
    run to explore how regexes work.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助您了解正则表达式的工作原理，我提供了一个名为 REDemo 的小程序。^([2](ch04.html#idm45290686929656)) REDemo
    的代码太长了，无法包含在本书中；您可以在 *darwinsys-api* 仓库的 *regex* 目录中找到 *REDemo.java*，您可以运行它来探索正则表达式的工作原理。
- en: In the uppermost text box (see [Figure 4-1](#javacook-regex-FIG-1)), type the
    regex pattern you want to test. Note that as you type each character, the regex
    is checked for syntax; if the syntax is OK, you see a checkmark beside it. You
    can then select Match, Find, or Find All. Match means that the entire string must
    match the regex, and Find means the regex must be found somewhere in the string
    (Find All counts the number of occurrences that are found). Below that, you type
    a string that the regex is to match against. Experiment to your heart’s content.
    When you have the regex the way you want it, you can paste it into your Java program.
    You’ll need to escape (backslash) any characters that are treated specially by
    both the Java compiler and the Java regex package, such as the backslash itself,
    double quotes, and others. Once you get a regex the way you want it, there is
    a Copy button (not shown in these screenshots) to export the regex to the clipboard,
    with or without backslash doubling, depending on how you want to use it.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在最上面的文本框中（参见 [Figure 4-1](#javacook-regex-FIG-1)），键入您要测试的正则表达式模式。请注意，当您键入每个字符时，都会检查正则表达式的语法；如果语法正确，您会看到其旁边有一个复选标记。然后，您可以选择匹配、查找或查找所有。匹配意味着整个字符串必须与正则表达式匹配，而查找意味着正则表达式必须在字符串中的某个位置找到（查找所有会计算找到的出现次数）。在下方，您键入要与正则表达式匹配的字符串。尽情实验。当您将正则表达式调整到想要的方式时，您可以将其粘贴到您的
    Java 程序中。您需要转义（反斜杠）任何由 Java 编译器和 Java 正则表达式包同时特殊处理的字符，例如反斜杠本身、双引号等。一旦您获得想要的正则表达式，就有一个复制按钮（在这些截图中未显示）可将正则表达式导出到剪贴板上，根据您希望如何使用它进行反斜杠加倍或不加倍。
- en: Tip
  id: totrans-106
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: 'Remember that because a regex is entered as a string that will be compiled
    by a Java compiler, you usually need two levels of escaping for any special characters,
    including backslash and double quotes. For example, the regex (which includes
    the double quotes):'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，因为正则表达式是作为将由 Java 编译器编译的字符串输入的，通常需要两个级别的转义以处理任何特殊字符，包括反斜杠和双引号。例如，正则表达式（其中包含双引号）：
- en: '[PRE5]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'has to be typed like this to be a valid compile-time Java language `String`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 必须像这样键入才能成为有效的编译时 Java 语言 `String`：
- en: '[PRE6]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In Java 14+ you could also use a text block to avoid escaping the quotes:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 14+ 中，您也可以使用文本块来避免转义引号：
- en: '[PRE7]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: I can’t tell you how many times I’ve made the mistake of forgetting the extra
    backslash in `\d+`, `\w+`, and their kin!
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我无法告诉你我有多少次犯了忘记在`\d+`、`\w+`及其类似形式中添加额外反斜杠的错误！
- en: 'In [Figure 4-1](#javacook-regex-FIG-1), I typed `qu` into the `REDemo` program’s
    Pattern box, which is a syntactically valid regex pattern: any ordinary characters
    stand as regexes for themselves, so this looks for the letter `q` followed by
    `u`. In the top version, I typed only a `q` into the string, which is not matched.
    In the second, I have typed `quack` and the `q` of a second `quack`. Because I
    have selected Find All, the count shows one match. As soon as I type the second
    `u`, the count is updated to two, as shown in the third version.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [Figure 4-1](#javacook-regex-FIG-1) 中，我在 `REDemo` 程序的 Pattern 框中键入了 `qu`，这是一个语法上有效的正则表达式模式：任何普通字符都是其自身的正则表达式，因此这将查找字母
    `q` 后跟 `u`。在顶部版本中，我只键入了一个 `q` 到字符串中，这是不匹配的。在第二个版本中，我键入了 `quack` 和第二个 `quack` 的
    `q`。因为我已经选择了查找所有，所以计数显示一个匹配项。当我键入第二个 `u` 时，计数将更新为两个，如第三个版本所示。
- en: Regexes can do far more than just character matching. For example, the two-character
    regex `^T` would match beginning of line (`^`) immediately followed by a capital
    T—that is, any line beginning with a capital T. It doesn’t matter whether the
    line begins with “Tiny trumpets,” “Titanic tubas,” or “Triumphant twisted trombones,”
    as long as the capital T is present in the first position.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式不仅可以进行字符匹配。例如，两个字符的正则表达式 `^T` 将匹配行的开头 (`^`) 立即跟随一个大写字母 T —— 也就是说，任何以大写字母
    T 开头的行都会匹配。无论行是否以“Tiny trumpets,” “Titanic tubas,” 或 “Triumphant twisted trombones”
    开头，只要第一个位置有大写字母 T 即可。
- en: But here we’re not very far ahead. Have we really invested all this effort in
    regex technology just to be able to do what we could already do with the `java.lang.String`
    method `startsWith()`? Hmmm, I can hear some of you getting a bit restless. Stay
    in your seats! What if you wanted to match not only a letter T in the first position,
    but also a vowel immediately after it, followed by any number of letters in a
    word, followed by an exclamation point? Surely you could do this in Java by checking
    `startsWith("T")` and `charAt(1) == 'a' || charAt(1) == 'e'`, and so on? Yes,
    but by the time you did that, you’d have written a lot of very highly specialized
    code that you couldn’t use in any other application. With regular expressions,
    you can just give the pattern `^T[aeiou]\w*!`. That is, `^` and `T` as before,
    followed by a character class listing the vowels, followed by any number of word
    characters (`\w*`), followed by the exclamation point.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们目前并没有取得很大进展。我们真的要投入所有这些精力来开发正则表达式技术，只是为了能够做到使用 `java.lang.String` 的 `startsWith()`
    方法已经可以做到的事情吗？嗯，我能听到一些人开始有点不耐烦了。请坐好！如果你想要匹配不仅在第一个位置有字母 T，而且紧随其后立即有元音字母，并且后面有任意数量的单词中的字母，最后是一个感叹号呢？在
    Java 中，你肯定可以通过检查 `startsWith("T")` 和 `charAt(1) == 'a' || charAt(1) == 'e'` 等来实现。是的，但是当你这样做的时候，你会写很多非常专门化的代码，这些代码在其他应用程序中无法使用。使用正则表达式，你只需给出模式
    `^T[aeiou]\w*!`。也就是说，与之前一样的 `^` 和 `T`，后跟列出元音字母的字符类，然后是任意数量的单词字符 (`\w*`)，最后是感叹号。
- en: '![jcb4 0401](assets/jcb4_0401.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![jcb4 0401](assets/jcb4_0401.png)'
- en: Figure 4-1\. REDemo with simple examples
  id: totrans-118
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-1\. REDemo with simple examples
- en: “But wait, there’s more!” as my late, great boss [Yuri Rubinsky](https://en.wikipedia.org/wiki/Yuri_Rubinsky)
    used to say. What if you want to be able to change the pattern you’re looking
    for *at runtime*? Remember all that Java code you just wrote to match `T` in column
    1, plus a vowel, some word characters, and an exclamation point? Well, it’s time
    to throw it out. Because this morning we need to match `Q`, followed by a letter
    other than `u`, followed by a number of digits, followed by a period. While some
    of you start writing a new function to do that, the rest of us will just saunter
    over to the RegEx Bar & Grille, order a `^Q[^u]\d+\.`. from the bartender, and
    be on our way.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: “但等等，还有更多！” 我已故的伟大老板 [Yuri Rubinsky](https://en.wikipedia.org/wiki/Yuri_Rubinsky)
    曾经说过。如果你想要能够在 *运行时* 更改你正在寻找的模式呢？还记得你刚刚编写的所有 Java 代码来匹配第一列的 `T`，加上一个元音字母，一些单词字符，以及一个感叹号吗？好吧，现在是时候将它们扔掉了。因为今天早上我们需要匹配
    `Q`，后跟一个不是 `u` 的字母，然后是一些数字，最后是一个句点。当一些人开始编写一个新的函数来实现这个目标时，我们其他人只需漫步到 RegEx 酒吧和餐厅，向酒保点一杯
    `^Q[^u]\d+\.` 就可以继续我们的工作了。
- en: 'OK, if you want an explanation: the `[^u]` means match any one character that
    is not the character `u`. The `\d+` means one or more numeric digits. The `+`
    is a quantifier meaning one or more occurrences of what it follows, and `\d` is
    any one numeric digit. So `\d+` means a number with one, two, or more digits.
    Finally, the `\.`? Well, . by itself is a metacharacter. Most single metacharacters
    are switched off by preceding them with an escape character. Not the Esc key on
    your keyboard, of course. The regex escape character is the backslash. Preceding
    a metacharacter like . with this escape turns off its special meaning, so we look
    for a literal period rather than any character. Preceding a few selected alphabetic
    characters (e.g., `n`, `r`, `t`, `s`, `w`) with escape turns them into metacharacters.
    [Figure 4-2](#javacook-regex-FIG-2) shows the `^Q[^u]\d+\..` regex in action.
    In the first frame, I have typed part of the regex as `^Q[^u`. Because there is
    an unclosed square bracket, the Syntax OK flag is turned off; when I complete
    the regex, it will be turned back on. In the second frame, I have finished typing
    the regex, and I’ve typed the data string as `QA577` (which you should expect
    to match the `$$^Q[^u]\d+$$` but not the period since I haven’t typed it). In
    the third frame, I’ve typed the period so the Matches flag is set to Yes.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，如果您需要解释：`[^u]` 表示匹配任何一个不是字符 `u` 的字符。`\d+` 表示一个或多个数字。`+` 是一个量词，表示它后面的内容出现一次或多次，而
    `\d` 表示任意一个数字。所以 `\d+` 表示一个、两个或更多位数的数字。最后，`\.`？嗯，`.` 本身是一个元字符。大多数单个元字符在前面加上转义字符就会被禁用。当然不是键盘上的Esc键。正则表达式的转义字符是反斜杠。在元字符（如`.`）前面加上这个转义字符会禁用它的特殊含义，因此我们寻找的是一个字面上的句点而不是任何字符。在前面加上几个选定的字母字符（例如
    `n`、`r`、`t`、`s`、`w`）的转义字符会将它们转换为元字符。[图 4-2](#javacook-regex-FIG-2) 展示了 `^Q[^u]\d+\..`
    正则表达式的应用。在第一帧中，我已经输入了正则表达式的一部分 `^Q[^u`。因为有一个未关闭的方括号，语法OK标志被关闭了；当我完成正则表达式时，它将被重新打开。在第二帧中，我已经完成了正则表达式的输入，并且我已经输入了数据字符串
    `QA577`（您应该期望它匹配 `$$^Q[^u]\d+$$`，但不包括句点，因为我还没有输入它）。在第三帧中，我输入了句点，因此匹配标志设置为是。
- en: '![jcb4 0402](assets/jcb4_0402.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![jcb4 0402](assets/jcb4_0402.png)'
- en: Figure 4-2\. REDemo with “Q not followed by u” example
  id: totrans-122
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-2\. REDemo示例：“不跟随u的Q”
- en: Because backslashes need to be escaped when pasting the regex into Java code,
    the current version of `REDemo` has both a `Copy Pattern` button, which copies
    the regex verbatim for use in documentation and in Unix commands, and a `Copy
    Pattern Backslashed` button, which copies the regex to the clipboard with backslashes
    doubled, for pasting into Java strings.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 因为在将正则表达式粘贴到Java代码中时需要转义反斜杠，所以当前版本的 `REDemo` 有一个 `复制模式` 按钮，它将正则表达式原样复制以供文档和Unix命令使用，并且有一个
    `复制模式（反斜杠）` 按钮，它将正则表达式复制到剪贴板上并将反斜杠加倍，以便粘贴到Java字符串中。
- en: By now you should have at least a basic grasp of how regexes work in practice.
    The rest of this chapter gives more examples and explains some of the more powerful
    topics, such as capture groups. As for how regexes work in theory—and there are
    a lot of theoretical details and differences among regex flavors—the interested
    reader is referred to *[Mastering Regular Expressions](http://shop.oreilly.com/product/9780596528126.do)*.
    Meanwhile, let’s start learning how to write Java programs that use regular expressions.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您至少应该基本掌握了正则表达式在实践中的工作原理。本章的其余部分将提供更多示例，并解释一些更强大的主题，例如捕获组。至于正则表达式在理论上的工作原理——不同的正则表达式风格之间有很多理论细节和差异——对于感兴趣的读者，建议参考
    *[Mastering Regular Expressions](http://shop.oreilly.com/product/9780596528126.do)*。同时，让我们开始学习如何编写使用正则表达式的Java程序的方法。
- en: '4.2 Using Regexes in Java: Test for a Pattern'
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.2 在Java中使用正则表达式：测试一个模式
- en: Problem
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You’re ready to get started using regular expression processing to beef up your
    Java code by testing to see if a given pattern can match in a given string.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以开始使用正则表达式处理来增强您的Java代码，测试给定模式是否可以在给定字符串中匹配。
- en: Solution
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the Java Regular Expressions Package, `java.util.regex`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Java正则表达式包，`java.util.regex`。
- en: Discussion
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'The good news is that the Java API for regexes is actually easy to use. If
    all you need is to find out whether a given regex matches a string, you can use
    the convenient `boolean matches()` method of the `String` class, which accepts
    a regex pattern in `String` form as its argument:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，Java的正则表达式API实际上非常易于使用。如果您只需要查找给定的正则表达式是否与字符串匹配，可以使用 `String` 类的便捷方法 `boolean
    matches()`，它接受一个以字符串形式表示的正则表达式模式作为其参数：
- en: '[PRE8]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This is, however, a convenience routine, and convenience always comes at a
    price. If the regex is going to be used more than once or twice in a program,
    it is more efficient to construct and use a `Pattern` and its `Matcher`(s). A
    complete program constructing a `Pattern` and using it to `match` is shown here:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这只是一个便利程序，而便利总是有代价的。如果正则表达式在程序中要使用一次或两次以上，构建并使用`Pattern`及其`Matcher`更有效率。一个完整的程序示例如下，构建`Pattern`并使用它进行`match`：
- en: '[PRE9]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `java.util.regex` package contains two classes, `Pattern` and `Matcher`,
    which provide the public API shown in [Example 4-1](#javacook-regex-EX-1).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util.regex`包含两个类，`Pattern`和`Matcher`，提供了示例[Example 4-1](https://wiki.example.org/javacook-regex-EX-1)中显示的公共API。'
- en: Example 4-1\. Regex public API
  id: totrans-136
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-1. 正则表达式公共API
- en: '[PRE10]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This API is large enough to require some explanation. These are the normal
    steps for regex matching in a production program:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 此API足够大，需要一些解释。这些是生产程序中正则表达式匹配的常规步骤：
- en: Create a `Pattern` by calling the static method `Pattern.compile()`.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用静态方法`Pattern.compile()`来创建`Pattern`。
- en: Request a `Matcher` from the pattern by calling `pattern.matcher(CharSequence)`
    for each `String` (or other `CharSequence`) you wish to look through.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对每个希望查找的`String`（或其他`CharSequence`），通过调用`pattern.matcher(CharSequence)`从模式中请求一个`Matcher`。
- en: Call (once or more) one of the finder methods (discussed later in this section)
    in the resulting `Matcher`.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用（一次或多次）结果`Matcher`中的一个查找方法（稍后在本节中讨论）。
- en: The `java.lang.CharSequence` interface provides simple read-only access to objects
    containing a collection of characters. The standard implementations are `String`
    and `StringBuffer`/`StringBuilder` (described in [Chapter 3](ch03.html#javacook-strings)),
    and the new I/O class `java.nio.CharBuffer`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.lang.CharSequence`接口提供对包含字符集合的对象的简单只读访问。标准实现包括`String`、`StringBuffer`/`StringBuilder`（在[Chapter
    3](https://wiki.example.org/ch03.html#javacook-strings)中描述）以及新的I/O类`java.nio.CharBuffer`。'
- en: 'Of course, you can perform regex matching in other ways, such as using the
    convenience methods in `Pattern` or even in `java.lang.String`, like this:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您可以以其他方式执行正则表达式匹配，例如使用`Pattern`中的便利方法或甚至在`java.lang.String`中，如下所示：
- en: '[PRE11]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: But the three-step list is the standard pattern for matching. You’d likely use
    the `String` convenience routine in a program that only used the regex once; if
    the regex were being used more than once, it is worth taking the time to compile
    it because the compiled version runs faster.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，三步列表是匹配的标准模式。如果正则表达式仅在程序中使用一次，可能会使用`String`便利程序；如果正则表达式使用超过一次，则值得花时间编译它，因为编译版本运行更快。
- en: 'In addition, the `Matcher` has several finder methods, which provide more flexibility
    than the `String` convenience routine `match()`. These are the `Matcher` methods:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`Matcher`具有多个查找方法，提供比`String`便利程序`match()`更灵活的功能。这些是`Matcher`的方法：
- en: '`match()`'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`match()`'
- en: Used to compare the entire string against the pattern; this is the same as the
    routine in `java.lang.String`. Because it matches the entire `String`, I had to
    put `.*` before and after the pattern.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 用于将整个字符串与模式进行比较；这与`java.lang.String`中的常规程序相同。因为它匹配整个`String`，所以我必须在模式之前和之后放置`.*`。
- en: '`lookingAt()`'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`lookingAt()`'
- en: Used to match the pattern only at the beginning of the string.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 仅用于匹配字符串的开头。
- en: '`find()`'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`find()`'
- en: Used to match the pattern in the string (not necessarily at the first character
    of the string), starting at the beginning of the string or, if the method was
    previously called and succeeded, at the first character not matched by the previous
    match.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 用于在字符串中匹配模式（不一定在字符串的第一个字符处），从字符串的开头开始，或者如果先前调用该方法并成功，则从未由上一个匹配项匹配的第一个字符开始。
- en: 'Each of these methods returns `boolean`, with `true` meaning a match and `false`
    meaning no match. To check whether a given string matches a given pattern, you
    need only type something like the following:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 每种方法都返回`boolean`，其中`true`表示匹配，`false`表示不匹配。要检查给定字符串是否与给定模式匹配，只需输入如下内容：
- en: '[PRE12]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: But you may also want to extract the text that matched, which is the subject
    of the next recipe.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 但您可能还想提取匹配的文本，这是下一个配方的主题。
- en: The following recipes cover uses of the Matcher API. Initially, the examples
    just use arguments of type `String` as the input source. Use of other `CharSequence`
    types is covered in [Recipe 4.5](#javacook-regex-SECT-5).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例涵盖了Matcher API的用法。最初，示例仅使用`String`类型的参数作为输入源。其他`CharSequence`类型的使用在[Recipe
    4.5](https://wiki.example.org/javacook-regex-SECT-5)中介绍。
- en: 4.3 Finding the Matching Text
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.3 寻找匹配的文本
- en: Problem
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to find the text that the regex matched.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要找到正则表达式匹配的文本。
- en: Solution
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Sometimes you need to know more than just whether a regex matched a string.
    In editors and many other tools, you want to know exactly what characters were
    matched. Remember that with quantifiers such as *, the length of the text that
    was matched may have no relationship to the length of the pattern that matched
    it. Do not underestimate the mighty `.*`, which happily matches thousands or millions
    of characters if allowed to. As you saw in the previous recipe, you can find out
    whether a given match succeeds just by using `find()` or `matches()`. But in other
    applications, you will want to get the characters that the pattern matched.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你不仅需要知道正则表达式是否匹配了字符串。在编辑器和许多其他工具中，您需要知道确切匹配了哪些字符。请记住，对于像*的量词，匹配的文本长度可能与匹配它的模式长度没有关系。不要低估强大的`.*`，如果允许的话，它可以轻松匹配成千上万个字符。正如您在前面的示例中看到的，您可以仅通过使用`find()`或`matches()`来确定给定匹配是否成功。但在其他应用程序中，您可能需要获取模式匹配的字符。
- en: 'After a successful call to one of the preceding methods, you can use these
    information methods on the `Matcher` to get information on the match:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述方法成功调用后，您可以使用`Matcher`上的这些信息方法获取有关匹配的信息：
- en: '`start(), end()`'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`start(), end()`'
- en: Returns the character position in the string of the starting and ending characters
    that matched.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 返回字符串中匹配的起始和结束字符的字符位置。
- en: '`groupCount()`'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`groupCount()`'
- en: Returns the number of parenthesized capture groups, if any; returns 0 if no
    groups were used.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 返回括号分组（如果有的话）的数量；如果未使用任何组，则返回0。
- en: '`group(int i)`'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`group(int i)`'
- en: Returns the characters matched by group *`i`* of the current match, if *`i`*
    is greater than or equal to zero and less than or equal to the return value of
    `groupCount()`. Group 0 is the entire match, so `group(0)` (or just `group()`)
    returns the entire portion of the input that matched.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 返回当前匹配的第*i*组匹配的字符，如果*i*大于等于零且小于等于`groupCount()`的返回值。组0是整个匹配，因此`group(0)`（或只是`group()`）返回匹配输入的整个部分。
- en: The notion of parentheses, or capture groups, is central to regex processing.
    Regexes may be nested to any level of complexity. The `group(int)` method lets
    you retrieve the characters that matched a given parenthesis group. If you haven’t
    used any explicit parens, you can just treat whatever matched as level zero. [Example 4-2](#part-of-rematch.java)
    shows part of *REMatch.java*.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 括号或捕获组的概念是正则表达式处理的核心。正则表达式可以嵌套到任意复杂的级别。`group(int)`方法允许您检索匹配给定括号组的字符。如果您没有使用任何显式的括号，则可以将匹配的任何内容视为零级。[Example 4-2](#part-of-rematch.java)展示了*REMatch.java*的部分内容。
- en: Example 4-2\. Part of main/src/main/java/regex/REMatch.java
  id: totrans-170
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-2\. main/src/main/java/regex/REMatch.java 的一部分
- en: '[PRE13]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'When run, this prints:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时，这将打印：
- en: '[PRE14]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: With the `Match` button checked, REDemo provides a display of all the capture
    groups in a given regex; one example is shown in [Figure 4-3](#javacook-regex-FIG-3).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 通过选中`Match`按钮，REDemo提供了给定正则表达式中所有捕获组的显示；其中一个示例显示在[Figure 4-3](#javacook-regex-FIG-3)中。
- en: '![jcb4 0403](assets/jcb4_0403.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![jcb4 0403](assets/jcb4_0403.png)'
- en: Figure 4-3\. REDemo in action
  id: totrans-176
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4-3\. REDemo的操作示例
- en: 'It is also possible to get the starting and ending indices and the length of
    the text that the pattern matched (remember that terms with quantifiers, such
    as the `\d+` in this example, can match an arbitrary number of characters in the
    string). You can use these in conjunction with the `String.substring()` methods
    as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以获取模式匹配的起始和结束索引以及文本的长度（请记住，例如此示例中的`\d+`等具有量词的术语可以匹配字符串中任意数量的字符）。可以与`String.substring()`方法结合使用，如下所示：
- en: '[PRE15]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Suppose you need to extract several items from a string. If the input is
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您需要从字符串中提取多个项目。如果输入为
- en: '[PRE16]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: and you want to get out
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 并且您希望退出
- en: '[PRE17]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'just use the following:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 只需使用以下内容：
- en: '[PRE18]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 4.4 Replacing the Matched Text
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.4 替换匹配的文本
- en: Problem
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: Having found some text using a Pattern, you want to replace the text with different
    text, without disturbing the rest of the string.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 找到某个文本使用模式后，您希望用不同的文本替换该文本，而不干扰字符串的其余部分。
- en: Solution
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: As we saw in the previous recipe, regex patterns involving quantifiers can match
    a lot of characters with very few metacharacters. We need a way to replace the
    text that the regex matched without changing other text before or after it. We
    could do this manually using the `String` method `substring()`. However, because
    it’s such a common requirement, the Java Regular Expression API provides some
    substitution methods.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的示例中看到的，涉及量词的正则表达式模式可以匹配大量字符，而只需很少的元字符。我们需要一种方法来替换正则表达式匹配的文本，而不更改其前后的其他文本。我们可以手动使用
    `String` 方法 `substring()` 来实现这一点。然而，由于这是一个如此常见的需求，Java 正则表达式 API 提供了一些替换方法。
- en: Discussion
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'The `Matcher` class provides several methods for replacing just the text that
    matched the pattern. In all these methods, you pass in the replacement text, or
    “righthand side,” of the substitution (this term is historical: in a command-line
    text editor’s substitute command, the lefthand side is the pattern and the righthand
    side is the replacement text). These are the replacement methods:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`Matcher` 类提供了几种方法来仅替换匹配模式的文本。在所有这些方法中，你需要传入替换文本或“右侧”替换的内容（这个术语来自历史上的命令行文本编辑器的替换命令，左侧是模式，右侧是替换文本）。这些是替换方法：'
- en: '`replaceAll(newString)`'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`replaceAll(newString)`'
- en: Replaces all occurrences that matched with the new string
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 替换了所有匹配的字符串
- en: '`replaceFirst(newString)`'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`replaceFirst(newString)`'
- en: As above but only the first occurence
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 与上例相同，但只替换第一个匹配项
- en: '`appendReplacement(StringBuffer, newString)`'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`appendReplacement(StringBuffer, newString)`'
- en: Copies up to before the first match, plus the given `newString`
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 复制直到第一个匹配项之前，再加上给定的 `newString`
- en: '`appendTail(StringBuffer)`'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`appendTail(StringBuffer)`'
- en: Appends text after the last match (normally used after `appendReplacement`)
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一个匹配项后添加文本（通常用于 `appendReplacement` 后）
- en: 'Despite their names, the `replace*` methods behave in accord with the immutability
    of `Strings` (see [“Timeless, Immutable, and Unchangeable”](ch03.html#strings-are-immutable)):
    they create a new `String` object with the replacement performed; they do not
    (indeed, could not) modify the string referred to in the `Matcher` object.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它们的名称如此，`replace*` 方法的行为符合 `Strings` 的不可变性（参见 [“Timeless, Immutable, and Unchangeable”](ch03.html#strings-are-immutable)）：它们创建一个执行替换的新
    `String` 对象；它们不会（事实上，也不能）修改 `Matcher` 对象中引用的字符串。
- en: '[Example 4-3](#javacook-regex-EX-2) shows use of these three methods.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '[Example 4-3](#javacook-regex-EX-2) 展示了这三种方法的使用。'
- en: Example 4-3\. main/src/main/java/regex/ReplaceDemo.java
  id: totrans-202
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-3\. main/src/main/java/regex/ReplaceDemo.java
- en: '[PRE19]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Sure enough, when you run it, it does what we expect:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行它时，它确实按我们的预期执行：
- en: '[PRE20]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `replaceAll()` method handles the case of making the same change all through
    a string. If you want to change each matching occurrence to a different value,
    you can use `replaceFirst()` in a loop, as in [Example 4-4](#javacook-regex-EX-2b).
    Here we make a pass through an entire string, turning each occurrence of either
    `cat` or `dog` into `feline` or `canine`. This is simplified from a real example
    that looked for *bit.ly* URLs and replaced them with the actual URL; the `computeReplacement`
    method there used the network client code from [Recipe 12.1](ch12.html#javacook-netclient-rest-1).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`replaceAll()` 方法处理了在整个字符串中进行相同更改的情况。如果你想要将每个匹配的出现更改为不同的值，可以在循环中使用 `replaceFirst()`，如在
    [Example 4-4](#javacook-regex-EX-2b) 中所示。在这里，我们遍历整个字符串，将每个 `cat` 或 `dog` 的出现转换为
    `feline` 或 `canine`。这是一个简化的实例，它查找了 *bit.ly* URL，并将其替换为实际的 URL；其中 `computeReplacement`
    方法使用了来自 [Recipe 12.1](ch12.html#javacook-netclient-rest-1) 的网络客户端代码。'
- en: Example 4-4\. main/src/main/java/regex/ReplaceMulti.java
  id: totrans-207
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-4\. main/src/main/java/regex/ReplaceMulti.java
- en: '[PRE21]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If you need to refer to portions of the occurrence that matched the regex, you
    can mark them with extra parentheses in the pattern and refer to the matching
    portion with `$1`, `$2`, and so on in the replacement string. [Example 4-5](#javacook-regex-EX-2c)
    uses this to interchange two fields, in this case, turn names in the form `Firstname
    Lastname` into `Lastname, FirstName`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要引用与正则表达式匹配的部分，可以在模式中用额外的括号标记它们，并在替换字符串中使用 `$1`、`$2` 等来引用匹配的部分。[Example 4-5](#javacook-regex-EX-2c)
    就是使用这种方法来交换两个字段，即将形如 `Firstname Lastname` 的姓名转换为 `Lastname, FirstName`。
- en: Example 4-5\. main/src/main/java/regex/ReplaceDemo2.java
  id: totrans-210
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-5\. main/src/main/java/regex/ReplaceDemo2.java
- en: '[PRE22]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 4.5 Printing All Occurrences of a Pattern
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.5 打印模式的所有出现
- en: Problem
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to find all the strings that match a given regex in one or more files
    or other sources.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在一个或多个文件或其他来源中查找所有匹配给定正则表达式的字符串。
- en: Solution
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: This example reads through a file one line at a time. Whenever a match is found,
    I extract it from the `line` and print it.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例逐行读取文件。每当找到匹配项时，我从`line`中提取并打印它。
- en: 'This code takes the `group()` methods from [Recipe 4.3](#javacook-regex-SECT-3),
    the `substring` method from the `CharacterIterator` interface, and the `match()`
    method from the regex and simply puts them all together. I coded it to extract
    all the names from a given file; in running the program through itself, it prints
    the words `import`, `java`, `until`, `regex`, and so on, each on its own line:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码从[Recipe 4.3](#javacook-regex-SECT-3)中获取了`group()`方法，从`CharacterIterator`接口中获取了`substring`方法，并从正则表达式中获取了`match()`方法，然后将它们组合在一起。我编写它来从给定文件中提取所有名称；在运行程序时，它会打印出`import`、`java`、`until`、`regex`等单词，每个单词独占一行：
- en: '[PRE23]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'I interrupted it here to save paper. This can be written two ways: a line-at-a-time
    pattern shown in [Example 4-6](#javacook-regex-EX-3) and a more compact form using
    new I/O shown in [Example 4-7](#javacook-regex-EX-4) (the new I/O package used
    in both examples is described in [Chapter 10](ch10.html#javacook-io)).'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里中断了以节省纸张。这可以有两种写法：一种是逐行模式，如[Example 4-6](#javacook-regex-EX-3)中所示，另一种是使用新I/O的更紧凑形式，如[Example 4-7](#javacook-regex-EX-4)中所示（两个示例中使用的新I/O包在[Chapter 10](ch10.html#javacook-io)中描述）。
- en: Example 4-6\. main/src/main/java/regex/ReaderIter.java
  id: totrans-220
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-6\. main/src/main/java/regex/ReaderIter.java
- en: '[PRE24]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Example 4-7\. main/src/main/java/regex/GrepNIO.java
  id: totrans-222
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-7\. main/src/main/java/regex/GrepNIO.java
- en: '[PRE25]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The non-blocking I/O (NIO) version shown in [Example 4-7](#javacook-regex-EX-4)
    relies on the fact that an NIO `Buffer` can be used as a `CharSequence`. This
    program is more general in that the pattern argument is taken from the command-line
    argument. It prints the same output as the previous example if invoked with the
    pattern argument from the previous program on the command line:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 非阻塞I/O（NIO）版本显示在[Example 4-7](#javacook-regex-EX-4)中，它依赖于NIO `Buffer`可以用作`CharSequence`的事实。这个程序更通用，因为它的模式参数来自命令行参数。如果以前一个程序的模式参数在命令行上调用，它将打印与前一个示例相同的输出：
- en: '[PRE26]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You might think of using `\w+` as the pattern; the only difference is that my
    pattern looks for well-formed capitalized words, whereas `\w+` would include Java-centric
    oddities like `theVariableName`, which have capitals in nonstandard positions.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会考虑使用`\w+`作为模式；唯一的区别是，我的模式寻找格式良好的大写单词，而`\w+`会包括Java中心的奇怪用法，如`theVariableName`，其中大写字母位于非标准位置。
- en: Also note that the NIO version will probably be more efficient because it doesn’t
    reset the `Matcher` to a new input source on each line of input as `ReaderIter`
    does.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 同样注意，NIO版本可能更有效，因为它不会像`ReaderIter`那样在每行输入时将`Matcher`重置为新的输入源。
- en: 4.6 Printing Lines Containing a Pattern
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.6 打印包含模式的行
- en: Problem
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to look for lines matching a given regex in one or more files.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要查找一个或多个文件中与给定正则表达式匹配的行。
- en: Solution
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Write a simple *grep*-like program.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个简单的类似于*grep*的程序。
- en: Discussion
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'As I’ve mentioned, once you have a regex package, you can write a *grep*-like
    program. I gave an example of the Unix *grep* program earlier. *grep* is called
    with some optional arguments, followed by one required regular expression pattern,
    followed by an arbitrary number of filenames. It prints any line that contains
    the pattern, differing from [Recipe 4.5](#javacook-regex-SECT-5), which prints
    only the matching text itself. Here’s an example:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前提到的，一旦你有了一个正则表达式包，你就可以编写类似于*grep*的程序。我之前给出了Unix的*grep*程序的示例。*grep*被调用时带有一些可选参数，后面跟着一个必需的正则表达式模式，然后是任意数量的文件名。它打印包含该模式的任何行，与[Recipe
    4.5](#javacook-regex-SECT-5)不同，后者只打印匹配的文本本身。这里是一个例子：
- en: '[PRE27]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The code searches for lines containing either `darwin` or `Darwin` in every
    line of every file whose name ends in *.txt*.^([3](ch04.html#idm45290684672008))
    [Example 4-8](#javacook-regex-EX-5) is the source for the first version of a program
    to do this, called *Grep0*. It reads lines from the standard input and doesn’t
    take any optional arguments, but it handles the full set of regular expressions
    that the `Pattern` class implements (it is, therefore, not identical to the Unix
    programs of the same name). We haven’t covered the `java.io` package for input
    and output yet (see [Chapter 10](ch10.html#javacook-io)), but our use of it here
    is simple enough that you can probably intuit it. The online source includes *Grep1*,
    which does the same thing but is better structured (and therefore longer). Later
    in this chapter, [Recipe 4.11](#javacook-regex-SECT-12) presents a *JGrep* program
    that parses a set of command-line options.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码搜索包含`darwin`或`Darwin`的行，它位于文件名以.txt结尾的每个文件的每一行中。[^3](ch04.html#idm45290684672008)
    第一个版本的执行此操作的程序的源是[Example 4-8](#javacook-regex-EX-5)，名为*Grep0*。它从标准输入读取行，并且不接受任何可选参数，但它处理`Pattern`类实现的完整一套正则表达式（因此与同名的Unix程序不完全相同）。我们尚未涵盖用于输入和输出的`java.io`包（请参见[Chapter
    10](ch10.html#javacook-io)），但我们在此处的使用足够简单，您可能可以直观理解它。在线源包括*Grep1*，它执行相同操作但结构更好（因此更长）。本章后面的[Recipe
    4.11](#javacook-regex-SECT-12)介绍了一个名为*JGrep*的程序，该程序解析一组命令行选项。
- en: Example 4-8\. main/src/main/java/regex/Grep0.java
  id: totrans-237
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-8\. main/src/main/java/regex/Grep0.java
- en: '[PRE28]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 4.7 Controlling Case in Regular Expressions
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.7 在正则表达式中控制大小写
- en: Problem
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to find text regardless of case.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望无视大小写地查找文本。
- en: Solution
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Compile the `Pattern` passing in the `flags` argument `Pattern.CASE_INSENSITIVE`
    to indicate that matching should be case-independent (i.e., that it should fold,
    ignore differences in case). If your code might run in different locales (see
    [Recipe 3.12](ch03.html#javacook-i18n-SECT-8)), then you should add `Pattern.UNICODE_CASE`.
    Without these flags, the default is normal, case-sensitive matching behavior.
    This flag (and others) are passed to the `Pattern.compile()` method, like this:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 编译`Pattern`时，传入`Pattern.CASE_INSENSITIVE`作为`flags`参数，指示匹配应该是不区分大小写的（即应该忽略大小写的差异）。如果您的代码可能在不同的地区运行（参见[Recipe
    3.12](ch03.html#javacook-i18n-SECT-8)），那么应添加`Pattern.UNICODE_CASE`。如果没有这些标志，默认行为是普通的大小写敏感匹配行为。像这样将这些标志（和其他标志）传递给`Pattern.compile()`方法：
- en: '[PRE29]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This flag must be passed when you create the `Pattern`; because `Pattern` objects
    are immutable, they cannot be changed once constructed.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建`Pattern`时必须传递此标志；因为`Pattern`对象是不可变的，一旦构建就无法更改。
- en: The full source code for this example is online as *CaseMatch.java*.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例的完整源代码在线查看，文件名为*CaseMatch.java*。
- en: 4.8 Matching Accented, or Composite, Characters
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.8 匹配重音或复合字符
- en: Problem
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want characters to match regardless of the form in which they are entered.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望字符匹配无论以何种形式输入。
- en: Solution
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Compile the `Pattern` with the `flags` argument `Pattern.CANON_EQ` for canonical
    equality.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Pattern.CANON_EQ`作为规范相等性的`flags`参数来编译`Pattern`。
- en: Discussion
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'Composite characters can be entered in various forms. Consider, as a single
    example, the letter `e` with an acute accent. This character may be found in various
    forms in Unicode text, such as the single character `é` (Unicode character `\u00e9`)
    or the two-character sequence `e´` (e followed by the Unicode combining acute
    accent, `\u0301`). To allow you to match such characters regardless of which of
    possibly multiple fully decomposed forms are used to enter them, the regex package
    has an option for *canonical matching*, which treats any of the forms as equivalent.
    This option is enabled by passing `CANON_EQ` as (one of) the flags in the second
    argument to `Pattern.compile()`. This program shows `CANON_EQ` being used to match
    several forms:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 复合字符可以以多种形式输入。例如，考虑带有重音符号的字母`e`。这个字符可能以多种形式出现在Unicode文本中，例如单个字符`é`（Unicode字符`\u00e9`）或两字符序列`e´`（e后跟Unicode组合的重音符号`\u0301`）。为了允许您匹配这些字符，无论使用哪种可能的完全分解形式，正则表达式包中有一个*规范匹配*选项，它将任何形式视为等效。通过在`Pattern.compile()`的第二个参数中传递`CANON_EQ`来启用此选项。此程序展示了使用`CANON_EQ`来匹配多种形式的示例：
- en: '[PRE30]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This program correctly matches the combining accent and rejects the other characters,
    some of which, unfortunately, look like the accent on a printer, but are not considered
    combining accent characters:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 此程序正确匹配组合重音符号并拒绝其他字符，其中一些不幸地看起来像打印机上的重音符号，但不被视为组合重音符号：
- en: '[PRE31]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: For more details, see the [character charts](http://www.unicode.org).
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 更多详情，请查看[字符图表](http://www.unicode.org)。
- en: 4.9 Matching Newlines in Text
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.9 匹配文本中的换行符
- en: Problem
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to match newlines in text.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在文本中匹配换行符。
- en: Solution
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use `\n` or `\r` in your regex pattern. See also the flags constant `Pattern.MULTILINE`,
    which makes newlines match as beginning-of-line and end-of-line (`\^` and `$`).
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的正则表达式模式中使用`\n`或`\r`。还可以参考标志常量`Pattern.MULTILINE`，它使换行符作为行首和行尾（`\^`和`$`）匹配。
- en: Discussion
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Though line-oriented tools from Unix such as *sed* and *grep* match regular
    expressions one line at a time, not all tools do. The *sam* text editor from Bell
    Laboratories was the first interactive tool I know of to allow multiline regular
    expressions; the Perl scripting language followed shortly after. In the Java API,
    the newline character by default has no special significance. The `BufferedReader`
    method `readLine()` normally strips out whichever newline characters it finds.
    If you read in gobs of characters using some method other than `readLine()`, you
    may have some number of `\n`, `\r`, or `\r\n` sequences in your text string.^([4](ch04.html#idm45290684143384))
    Normally all of these are treated as equivalent to `\n`. If you want only `\n`
    to match, use the `UNIX_LINES` flag to the `Pattern.compile()` method.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Unix中的面向行的工具（如*sed*和*grep*）一次只匹配一行的正则表达式，但并非所有工具都是如此。贝尔实验室的*sam*文本编辑器是我知道的第一个允许多行正则表达式的交互式工具；Perl脚本语言随后也跟进。在Java
    API中，默认情况下，换行符在正则表达式中没有特殊意义。`BufferedReader`方法`readLine()`通常会剥离掉它找到的任何换行符。如果您使用除`readLine()`之外的某些方法读取大量字符，可能会在文本字符串中有一些`\n`、`\r`或`\r\n`序列。通常情况下，这些都等同于`\n`。如果您只想匹配`\n`，请使用`Pattern.compile()`方法的`UNIX_LINES`标志。
- en: In Unix, `^` and `$` are commonly used to match the beginning or end of a line,
    respectively. In this API, the regex metacharacters `\^` and `$` ignore line terminators
    and only match at the beginning and the end, respectively, of the entire string.
    However, if you pass the `MULTILINE` flag into `Pattern.compile()`, these expressions
    match just after or just before, respectively, a line terminator; `$` also matches
    the very end of the string. Because the line ending is just an ordinary character,
    you can match it with . or similar expressions; and, if you want to know exactly
    where it is, `\n` or `\r` in the pattern match it as well. In other words, to
    this API, a newline character is just another character with no special significance.
    See the sidebar [“Pattern.compile() Flags”](#javacook-regex-SIDEBAR-2). An example
    of newline matching is shown in [Example 4-9](#javacook-regex-EX-6).
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unix中，`^`和`$`通常用于分别匹配行的开头和结尾。在此API中，正则表达式元字符`\^`和`$`会忽略换行符，并且只在整个字符串的开头和结尾匹配。然而，如果您向`Pattern.compile()`方法传递`MULTILINE`标志，这些表达式将在换行符的后面或前面匹配；`$`也会匹配字符串的最后。因为换行符只是普通字符，您可以用`.`或类似的表达式来匹配它；如果您想确切地知道它在哪里，模式中的`\n`或`\r`也可以匹配它。换句话说，对于此API，换行符只是没有特殊意义的另一个字符。请参见侧边栏[“Pattern.compile()
    Flags”](#javacook-regex-SIDEBAR-2)。换行符匹配的示例显示在[示例 4-9](#javacook-regex-EX-6)中。
- en: Example 4-9\. main/src/main/java/regex/NLMatch.java
  id: totrans-266
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-9\. main/src/main/java/regex/NLMatch.java
- en: '[PRE32]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If you run this code, the first pattern (with the wildcard character .) always
    matches, whereas the second pattern (with `$`) matches only when `MATCH_MULTILINE`
    is set:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行此代码，第一个模式（带有通配符字符`.`）总是匹配，而第二个模式（带有`$`）仅在设置了`MATCH_MULTILINE`时匹配：
- en: '[PRE33]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '4.10 Program: Apache Logfile Parsing'
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.10 程序：解析Apache日志文件
- en: The Apache web server is the world’s leading web server and has been for most
    of the web’s history. It is one of the world’s best-known open source projects,
    and it’s the first of many fostered by the Apache Foundation. The name Apache
    is often claimed to be a pun on the origins of the server; its developers began
    with the free NCSA server and kept hacking at it, or patching, it until it did
    what they wanted. When it was sufficiently different from the original, a new
    name was needed. Because it was now a patchy server, the name Apache was chosen.
    Officialdom denies the story, but it’s cute anyway. One place actual patchiness
    does show through is in the logfile format. Consider [Example 4-10](#apache-example).
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: Apache Web 服务器是世界上领先的 Web 服务器，几乎在 Web 的整个历史上都是如此。它是世界上最著名的开源项目之一，是 Apache 基金会孵化的第一个项目。Apache
    这个名字通常被认为是对服务器起源的一个双关语；其开发人员从自由的 NCSA 服务器开始，并不断地对其进行改进或修补，直到它符合他们的要求。当它与原始版本有了足够的不同之后，就需要一个新的名字。因为它现在是一个“补丁”（patchy）的服务器，所以选择了
    Apache 这个名字。官方对这个故事持否定态度，但这个故事非常有趣。实际上显示补丁性的一个地方是日志文件格式。请参考[Example 4-10](#apache-example)。
- en: Example 4-10\. Apache log file excerpt
  id: totrans-272
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 4-10\. Apache 日志文件摘录
- en: '[PRE34]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The file format was obviously designed for human inspection but not for easy
    parsing. The problem is that different delimiters are used: square brackets for
    the date, quotes for the request line, and spaces sprinkled all through. Consider
    trying to use a `StringTokenizer`; you might be able to get it working, but you’d
    spend a lot of time fiddling with it. Actually, no, you wouldn’t get it working.
    However, this somewhat contorted regular expression^([5](ch04.html#idm45290683942808))
    makes it easy to parse (this is one single Moby-sized regex; we had to break it
    over two lines to make it fit the book’s margins):'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，该文件格式设计用于人类检查，但不易于解析。问题在于使用了不同的分隔符：日期用方括号，请求行用引号，整个过程中还散布有空格。考虑尝试使用`StringTokenizer`；你可能能让它工作，但会花费大量时间摆弄它。实际上，不，你不会让它工作。然而，这个有些扭曲的正则表达式^([5](ch04.html#idm45290683942808))使得解析变得很容易（这是一个超大规模的单个正则表达式；我们不得不将其分成两行以适应书籍的边距）：
- en: '[PRE35]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: You may find it informative to refer back to [Table 4-1](#javacook-regex-TABLE-2)
    and review the full syntax used here. Note in particular the use of the nongreedy
    quantifier `+?` in `\"(.+?)\`" to match a quoted string; you can’t just use `.+`
    because that would match too much (up to the quote at the end of the line). Code
    to extract the various fields such as IP address, request, referrer URL, and browser
    version is shown in [Example 4-11](#javacook-regex-EX-7).
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你回顾一下[Table 4-1](#javacook-regex-TABLE-2)，并仔细查看这里使用的完整语法，你可能会觉得很有趣。特别注意在`\"(.+?)\`"中使用了非贪婪量词`+?`来匹配引号括起的字符串；你不能仅使用`.+`，因为那样会匹配太多（直到行尾的引号）。代码用于提取诸如
    IP 地址、请求、引用 URL 和浏览器版本等各种字段，在[Example 4-11](#javacook-regex-EX-7)中显示。
- en: Example 4-11\. main/src/main/java/regex/LogRegExp.java
  id: totrans-277
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 4-11\. main/src/main/java/regex/LogRegExp.java
- en: '[PRE36]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `implements` clause is for an interface that just defines the input string;
    it was used in a demonstration to compare the regular expression mode with the
    use of a `StringTokenizer`. The source for both versions is in the online source
    for this chapter. Running the program against the sample input from [Example 4-10](#apache-example)
    gives this output:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`implements` 子句用于仅定义输入字符串的接口；它在演示中被用来比较正则表达式模式与使用`StringTokenizer`。两个版本的源代码都在本章节的在线资源中。对[Example 4-10](#apache-example)中的示例输入运行程序将得到以下输出：'
- en: '[PRE37]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The program successfully parsed the entire logfile format entry with one call
    to `matcher.matches()`.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 程序成功地通过一次调用`matcher.matches()`成功解析了整个日志文件格式条目。
- en: '4.11 Program: Full Grep'
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.11 程序：完整的 Grep
- en: Now that we’ve seen how the regular expressions package works, it’s time to
    write JGrep, a full-blown version of the line-matching program with option parsing.
    [Table 4-2](#javacook-regex-TABLE-3) lists some typical command-line options that
    a Unix implementation of *grep* might include. For those not familiar with *grep*,
    it is a command-line tool that searches for regular expressions in text files.
    There are three or four programs in the standard *grep* family, and a newer replacement
    *ripgrep*, or *rg*. This program is my addition to this family of programs.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到正则表达式包如何工作，是时候编写 JGrep 了，这是一个完整的行匹配程序，并包含选项解析。[Table 4-2](#javacook-regex-TABLE-3)列出了
    Unix 实现中 *grep* 可能包含的一些典型命令行选项。对于不熟悉 *grep* 的人来说，它是一个在文本文件中搜索正则表达式的命令行工具。标准 *grep*
    家族中有三到四个程序，还有一个更新的替代 *ripgrep* 或 *rg*。这个程序是我对这类程序家族的补充。
- en: Table 4-2\. Grep command-line options
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: Table 4-2\. Grep 命令行选项
- en: '| Option | Meaning |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| Option | 意义 |'
- en: '| --- | --- |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| -c | Count only; don’t print lines, just count them |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| -c | 仅计数；不打印行，只计数 |'
- en: '| -C | Context; print some lines above and below each line that matches (not
    implemented in this version; left as an exercise for the reader) |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| -C | 上下文；打印与匹配行上下几行（在此版本中未实现；留给读者作为练习） |'
- en: '| -f pattern | Take pattern from file named after `-f` instead of from command
    line |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| -f pattern | 从名为`-f`的文件中获取模式，而不是从命令行获取 |'
- en: '| -h | Suppress printing filename ahead of lines |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| -h | 抑制在行前打印文件名 |'
- en: '| -i | Ignore case |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| -i | 忽略大小写 |'
- en: '| -l | List filenames only: don’t print lines, just the names they’re found
    in |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '| -l | 仅列出文件名：不打印行，只打印它们所在的文件名 |'
- en: '| -n | Print line numbers before matching lines |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '| -n | 在匹配行之前打印行号 |'
- en: '| -s | Suppress printing certain error messages |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '| -s | 抑制打印某些错误消息 |'
- en: '| -v | Invert: print only lines that do NOT match the pattern |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
  zh: '| -v | 反向：仅打印不匹配模式的行 |'
- en: The Unix world features several *getopt* library routines for parsing command-line
    arguments, so I have a reimplementation of this in Java. As usual, because `main()`
    runs in a static context but our application main line does not, we could wind
    up passing a lot of information into the constructor. To save space, this version
    just uses global variables to track the settings from the command line. Unlike
    the Unix *grep* tool, this one does not yet handle combined options, so `-l -r
    -i` is OK, but `-lri` will fail, due to a limitation in the `GetOpt` parser used.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: Unix世界提供了几个用于解析命令行参数的*getopt*库例程，因此我在Java中重新实现了这一过程。通常情况下，因为`main()`在静态上下文中运行而我们的应用程序主行没有运行，所以我们可能会传递大量信息到构造函数中。为了节省空间，此版本仅使用全局变量来跟踪从命令行获取的设置。与Unix的*grep*工具不同，这个工具尚不能处理组合选项，因此`-l
    -r -i`是可以的，但`-lri`将失败，这是由于使用的`GetOpt`解析器的限制。
- en: The program basically just reads lines, matches the pattern in them, and, if
    a match is found (or not found, with `-v`), prints the line (and optionally some
    other stuff, too). Having said all that, the code is shown in [Example 4-12](#javacook-regex-EX-9).
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序基本上只是读取行，匹配其中的模式，如果找到匹配（或者使用`-v`找不到），则打印该行（以及可选的其他一些东西）。话虽如此，代码显示在[Example 4-12](#javacook-regex-EX-9)中。
- en: Example 4-12\. darwinsys-api/src/main/java/regex/JGrep.java
  id: totrans-298
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 4-12\. darwinsys-api/src/main/java/regex/JGrep.java
- en: '[PRE38]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: ^([1](ch04.html#idm45290687159592-marker)) Non-Unix fans fear not, for you can
    use tools like *grep* on Windows systems using one of several packages. One is
    an open source package alternately called CygWin (after Cygnus Software) or [GnuWin32](http://sources.redhat.com/cygwin).
    Another is Microsoft’s *findstr* command for Windows. Or you can use my *Grep*
    program in [Recipe 4.6](#javacook-regex-SECT-6) if you don’t have *grep* on your
    system. Incidentally, the name *grep* comes from an ancient Unix line editor command
    *g/RE/p*, the command to find the regex globally in all lines in the edit buffer
    and print the lines that match—just what the *grep* program does to lines in files.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch04.html#idm45290687159592-marker)) 非Unix粉丝不必担心，在Windows系统上可以使用诸如*grep*之类的工具，使用几种不同的软件包。其中一个是开源软件包，交替称为CygWin（源自Cygnus
    Software）或[GnuWin32](http://sources.redhat.com/cygwin)。另一个是微软的*findstr*命令。或者，如果你的系统上没有*grep*，可以使用我在[Recipe
    4.6](#javacook-regex-SECT-6)中展示的*Grep*程序。顺便说一句，*grep*的名字来自于古老的Unix行编辑器命令*g/RE/p*，即在编辑缓冲区中全局查找正则表达式并打印匹配行的命令——这正是*grep*程序对文件中的行所做的事情。
- en: ^([2](ch04.html#idm45290686929656-marker)) REDemo was inspired by (but does
    not use any code from) a similar program provided with the now-retired Apache
    Jakarta Regular Expressions package.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch04.html#idm45290686929656-marker)) REDemo受到（但未使用任何代码）现已退役的Apache Jakarta正则表达式包中提供的类似程序的启发。
- en: ^([3](ch04.html#idm45290684672008-marker)) On Unix, the shell or command-line
    interpreter expands **.txt* to all the matching filenames before running the program,
    but the normal Java interpreter does this for you on systems where the shell isn’t
    energetic or bright enough to do it.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch04.html#idm45290684672008-marker)) 在Unix上，Shell或命令行解释器在运行程序之前会将**.txt*扩展到所有匹配的文件名，但在没有足够活跃或聪明的Shell系统上，正常的Java解释器会为你完成这些工作。
- en: ^([4](ch04.html#idm45290684143384-marker)) Or a few related Unicode characters,
    including the next-line (`\u0085`), line-separator (`\u2028`), and paragraph-separator
    (`\u2029`) characters.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch04.html#idm45290684143384-marker)) 或者一些相关的Unicode字符，包括下一行（`\u0085`）、行分隔符（`\u2028`）和段落分隔符（`\u2029`）字符。
- en: ^([5](ch04.html#idm45290683942808-marker)) You might think this would hold some
    kind of world record for complexity in regex competitions, but I’m sure it’s been
    outdone many times.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch04.html#idm45290683942808-marker)) 你可能会认为这在正则表达式比赛中是某种复杂性世界纪录，但我相信它已经被超越了许多次。
