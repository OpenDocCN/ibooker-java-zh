- en: Chapter 4\. Pattern Matching with Regular Expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 4.0 Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Suppose you have been on the internet for a few years and have been faithful
    about saving all your correspondence, just in case you (or your lawyers, or the
    prosecution) need a copy. The result is that you have a 5 GB disk partition dedicated
    to saved mail. Let’s further suppose that you remember that somewhere in there
    is an email message from someone named Angie or Anjie. Or was it Angy? But you
    don’t remember what you called it or where you stored it. Obviously, you have
    to look for it.
  prefs: []
  type: TYPE_NORMAL
- en: 'But while some of you go and try to open up all 15,000,000 documents in a word
    processor, I’ll just find it with one simple command. Any system that provides
    regular expression support allows me to search for the pattern in several ways.
    The simplest to understand is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'which you can probably guess means just to search for any of the variations.
    A more concise form (more thinking, less typing) is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The syntax will become clear as we go through this chapter. Briefly, the “A”
    and the “n” match themselves, in effect finding words that begin with “An”, while
    the cryptic `[^ dn]` requires the “An” to be followed by a character other than
    (*^* means *not* in this context) a space (to eliminate the very common English
    word “an” at the start of a sentence) or “d” (to eliminate the common word “and”)
    or “n” (to eliminate “Anne,” “Announcing,” etc.). Has your word processor gotten
    past its splash screen yet? Well, it doesn’t matter, because I’ve already found
    the missing file. To find the answer, I just typed this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '*Regular expressions*, or *regexes* for short, provide a concise and precise
    specification of patterns to be matched in text. One good way to think of regular
    expressions is as a little language for matching patterns of characters in text
    contained in strings. A regular expression API is an [interpreter](https://en.wikipedia.org/wiki/Interpreter_(computing))
    for matching regular expressions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As another example of the power of regular expressions, consider the problem
    of bulk-updating hundreds of files. When I started with Java, the syntax for declaring
    array references was `baseType arrayVariableName[]`. For example, a method with
    an array argument, such as every program’s main method, was commonly written like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'But as time went by, it became clear to the stewards of the Java language that
    it would be better to write it as `baseType[] arrayVariableName`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This is better Java style because it associates the “array-ness” of the type
    with the type itself, rather than with the local argument name, and the compiler
    still accepts both modes. I wanted to change all occurrences of `main` written
    the old way to the new way. I used the pattern *`main(String [a-z]`* with the
    *grep* utility described earlier to find the names of all the files containing
    old-style main declarations (i.e., `main(String` followed by a space and a name
    character rather than an open square bracket). I then used another regex-based
    Unix tool, the stream editor *sed*, in a little shell script to change all occurrences
    in those files from *`main(String *([a-z][a-z]*)[]`* to *`main(String[] $1`* (the
    regex syntax used here is discussed later in this chapter). Again, the regex-based
    approach was orders of magnitude faster than doing it interactively, even using
    a reasonably powerful editor such as `vi` or `emacs`, let alone trying to use
    a graphical word processor.
  prefs: []
  type: TYPE_NORMAL
- en: Historically, the syntax of regexes has changed as they get incorporated into
    more tools and more languages, so the exact syntax in the previous examples is
    not exactly what you’d use in Java, but it does convey the conciseness and power
    of the regex mechanism.^([1](ch04.html#idm45290687159592))
  prefs: []
  type: TYPE_NORMAL
- en: As a third example, consider parsing an Apache web server logfile, where some
    fields are delimited with quotes, others with square brackets, and others with
    spaces. Writing ad hoc code to parse this is messy in any language, but a well-crafted
    regex can break the line into all its constituent fields in one operation (this
    example is developed in [Recipe 4.10](#javacook-regex-SECT-10)).
  prefs: []
  type: TYPE_NORMAL
- en: These same time gains can be had by Java developers. Regular expression support
    has been in the standard Java runtime for ages and is well integrated (e.g., there
    are regex methods in the standard class `java.lang.String` and in the new I/O
    package). There are a few other regex packages for Java, and you may occasionally
    encounter code using them, but pretty well all code from this century can be expected
    to use the built-in package. The syntax of Java regexes themselves is discussed
    in [Recipe 4.1](#javacook-regex-SECT-1), and the syntax of the Java API for using
    regexes is described in [Recipe 4.2](#javacook-regex-SECT-2). The remaining recipes
    show some applications of regex technology in Java.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*[Mastering Regular Expressions](http://shop.oreilly.com/product/9780596528126.do)*
    by Jeffrey Friedl (O’Reilly) is the definitive guide to all the details of regular
    expressions. Most introductory books on Unix and Perl include some discussion
    of regexes; *[Unix Power Tools](http://shop.oreilly.com/product/9780596003302.do)*
    by Mike Loukides, Tim O’Reilly, Jerry Peek, and Shelley Powers (O’Reilly) devotes
    a chapter to them.'
  prefs: []
  type: TYPE_NORMAL
- en: 4.1 Regular Expression Syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to learn the syntax of Java regular expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Consult [Table 4-1](#javacook-regex-TABLE-2) for a list of the regular expression
    characters.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These pattern characters let you specify regexes of considerable power. In building
    patterns, you can use any combination of ordinary text and the *metacharacters*,
    or special characters, in [Table 4-1](#javacook-regex-TABLE-2). These can all
    be used in any combination that makes sense. For example, `a+` means any number
    of occurrences of the letter `a`, from one up to a million or a gazillion. The
    pattern `Mrs?`\. matches `Mr.` or `Mrs.` And `.*` indicates any character, any
    number of times, and is similar in meaning to most command-line interpreters’
    meaning of the `\*` alone. The pattern `\d+` means any number of numeric digits.
    `\d{2,3}` means a two- or three-digit number.
  prefs: []
  type: TYPE_NORMAL
- en: Table 4-1\. Regular expression metacharacter syntax
  prefs: []
  type: TYPE_NORMAL
- en: '| Subexpression | Matches | Notes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **General** |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| `\^` | Start of line/string |  |'
  prefs: []
  type: TYPE_TB
- en: '| `$` | End of line/string |  |'
  prefs: []
  type: TYPE_TB
- en: '| `\b` | Word boundary |  |'
  prefs: []
  type: TYPE_TB
- en: '| `\B` | Not a word boundary |  |'
  prefs: []
  type: TYPE_TB
- en: '| `\A` | Beginning of entire string |  |'
  prefs: []
  type: TYPE_TB
- en: '| `\z` | End of entire string |  |'
  prefs: []
  type: TYPE_TB
- en: '| `\Z` | End of entire string (except allowable final line terminator) | See
    [Recipe 4.9](#javacook-regex-SECT-9) |'
  prefs: []
  type: TYPE_TB
- en: '| . | Any one character (except line terminator) |  |'
  prefs: []
  type: TYPE_TB
- en: '| `[…]` | “Character class”; any one character from those listed |  |'
  prefs: []
  type: TYPE_TB
- en: '| `[\^…]` | Any one character not from those listed | See [Recipe 4.2](#javacook-regex-SECT-2)
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Alternation and grouping** |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| `(…)` | Grouping (capture groups) | See [Recipe 4.3](#javacook-regex-SECT-3)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `&#124;` | Alternation |  |'
  prefs: []
  type: TYPE_TB
- en: '| `(?`:_`re`_ `)` | Noncapturing parenthesis |  |'
  prefs: []
  type: TYPE_TB
- en: '| `\G` | End of the previous match |  |'
  prefs: []
  type: TYPE_TB
- en: '| +\+*`n`* | Back-reference to capture group number *`n`* |  |'
  prefs: []
  type: TYPE_TB
- en: '| **Normal (greedy) quantifiers** |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| `{` *`m`*,*`n`* `}` | Quantifier for from *`m`* to *`n`* repetitions | See
    [Recipe 4.4](#javacook-regex-SECT-4) |'
  prefs: []
  type: TYPE_TB
- en: '| `{` *`m`* `,}` | Quantifier for *`m`* or more repetitions |  |'
  prefs: []
  type: TYPE_TB
- en: '| `{` *`m`* `}` | Quantifier for exactly *`m`* repetitions | See [Recipe 4.10](#javacook-regex-SECT-10)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `{`,*`n`* `}` | Quantifier for 0 up to *`n`* repetitions |  |'
  prefs: []
  type: TYPE_TB
- en: '| `\*` | Quantifier for 0 or more repetitions | Short for `{0,}` |'
  prefs: []
  type: TYPE_TB
- en: '| `+` | Quantifier for 1 or more repetitions | Short for `{1,}`; see [Recipe
    4.2](#javacook-regex-SECT-2) |'
  prefs: []
  type: TYPE_TB
- en: '| `?` | Quantifier for 0 or 1 repetitions (i.e., present exactly once, or not
    at all) | Short for `{0,1}` |'
  prefs: []
  type: TYPE_TB
- en: '| **Reluctant (nongreedy) quantifiers** |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| `{` *`m`*,*`n`* `}?` | Reluctant quantifier for from *`m`* to *`n`* repetitions
    |  |'
  prefs: []
  type: TYPE_TB
- en: '| `{` *`m`* `,}?` | Reluctant quantifier for *`m`* or more repetitions |  |'
  prefs: []
  type: TYPE_TB
- en: '| `{`,*`n`* `}?` | Reluctant quantifier for 0 up to *`n`* repetitions |  |'
  prefs: []
  type: TYPE_TB
- en: '| `\*?` | Reluctant quantifier: 0 or more |  |'
  prefs: []
  type: TYPE_TB
- en: '| `+?` | Reluctant quantifier: 1 or more | See [Recipe 4.10](#javacook-regex-SECT-10)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `??` | Reluctant quantifier: 0 or 1 times |  |'
  prefs: []
  type: TYPE_TB
- en: '| **Possessive (very greedy) quantifiers** |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| `{` *`m`*,*`n`* `}+` | Possessive quantifier for from *`m`* to *`n`* repetitions
    |  |'
  prefs: []
  type: TYPE_TB
- en: '| `{` *`m`* `,}+` | Possessive quantifier for *`m`* or more repetitions |  |'
  prefs: []
  type: TYPE_TB
- en: '| `{`,*`n`* `}+` | Possessive quantifier for 0 up to *`n`* repetitions |  |'
  prefs: []
  type: TYPE_TB
- en: '| `\*+` | Possessive quantifier: 0 or more |  |'
  prefs: []
  type: TYPE_TB
- en: '| `++` | Possessive quantifier: 1 or more |  |'
  prefs: []
  type: TYPE_TB
- en: '| `?+` | Possessive quantifier: 0 or 1 times |  |'
  prefs: []
  type: TYPE_TB
- en: '| **Escapes and shorthands** |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| `\` | Escape (quote) character: turns most metacharacters off; turns subsequent
    alphabetic into metacharacters |  |'
  prefs: []
  type: TYPE_TB
- en: '| `\Q` | Escape (quote) all characters up to `\E` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `\E` | Ends quoting begun with `\Q` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `\t` | Tab character |  |'
  prefs: []
  type: TYPE_TB
- en: '| `\r` | Return (carriage return) character |  |'
  prefs: []
  type: TYPE_TB
- en: '| `\n` | Newline character | See [Recipe 4.9](#javacook-regex-SECT-9) |'
  prefs: []
  type: TYPE_TB
- en: '| `\f` | Form feed |  |'
  prefs: []
  type: TYPE_TB
- en: '| `\w` | Character in a word | Use `\w+` for a word; see [Recipe 4.10](#javacook-regex-SECT-10)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `\W` | A nonword character |  |'
  prefs: []
  type: TYPE_TB
- en: '| `\d` | Numeric digit | Use `\d+` for an integer; see [Recipe 4.2](#javacook-regex-SECT-2)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `\D` | A nondigit character |  |'
  prefs: []
  type: TYPE_TB
- en: '| `\s` | Whitespace | Space, tab, etc., as determined by `java.lang.Character.isWhitespace()`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `\S` | A nonwhitespace character | See [Recipe 4.10](#javacook-regex-SECT-10)
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Unicode blocks (representative samples)** |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| `\p{InGreek}` | A character in the Greek block | (Simple block) |'
  prefs: []
  type: TYPE_TB
- en: '| `\P{InGreek}` | Any character not in the Greek block |  |'
  prefs: []
  type: TYPE_TB
- en: '| `\p{Lu}` | An uppercase letter | (Simple category) |'
  prefs: []
  type: TYPE_TB
- en: '| `\p{Sc}` | A currency symbol |  |'
  prefs: []
  type: TYPE_TB
- en: '| **POSIX-style character classes (defined only for US-ASCII)** |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| `\p{Alnum}` | Alphanumeric characters | `[A-Za-z0-9]` |'
  prefs: []
  type: TYPE_TB
- en: '| `\p{Alpha}` | Alphabetic characters | `[A-Za-z]` |'
  prefs: []
  type: TYPE_TB
- en: '| `\p{ASCII}` | Any ASCII character | `[\x00-\x7F]` |'
  prefs: []
  type: TYPE_TB
- en: '| `\p{Blank}` | Space and tab characters |  |'
  prefs: []
  type: TYPE_TB
- en: '| `\p{Space}` | Space characters | `[ \t\n\x0B\f\r]` |'
  prefs: []
  type: TYPE_TB
- en: '| `\p{Cntrl}` | Control characters | `[\x00-\x1F\x7F]` |'
  prefs: []
  type: TYPE_TB
- en: '| `\p{Digit}` | Numeric digit characters | `[0-9]` |'
  prefs: []
  type: TYPE_TB
- en: '| `\p{Graph}` | Printable and visible characters (not spaces or control characters)
    |  |'
  prefs: []
  type: TYPE_TB
- en: '| `\p{Print}` | Printable characters | Same as `\p{Graph}` |'
  prefs: []
  type: TYPE_TB
- en: '| `\p{Punct}` | Punctuation characters | One of `!"#$%&''()\*+,-./:;<=>?@[]\^_`{&#124;}\~`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `\p{Lower}` | Lowercase characters | `[a-z]` |'
  prefs: []
  type: TYPE_TB
- en: '| `\p{Upper}` | Uppercase characters | `[A-Z]` |'
  prefs: []
  type: TYPE_TB
- en: '| `\p{XDigit}` | Hexadecimal digit characters | `[0-9a-fA-F]` |'
  prefs: []
  type: TYPE_TB
- en: Regexes match any place possible in the string. Patterns followed by greedy
    quantifiers (the only type that existed in traditional Unix regexes) consume (match)
    as much as possible without compromising any subexpressions that follow. Patterns
    followed by possessive quantifiers match as much as possible without regard to
    following subexpressions. Patterns followed by reluctant quantifiers consume as
    few characters as possible to still get a match.
  prefs: []
  type: TYPE_NORMAL
- en: Also, unlike regex packages in some other languages, the Java regex package
    was designed to handle Unicode characters from the beginning. The standard Java
    escape sequence `\u+nnnn` is used to specify a Unicode character in the pattern.
    We use methods of `java.lang.Character` to determine Unicode character properties,
    such as whether a given character is a space. Again, note that the backslash must
    be doubled if this is in a Java string that is being compiled because the compiler
    would otherwise parse this as “backslash-u” followed by some numbers.
  prefs: []
  type: TYPE_NORMAL
- en: To help you learn how regexes work, I provide a little program called REDemo.^([2](ch04.html#idm45290686929656))
    The code for REDemo is too long to include in the book; in the online directory
    *regex* of the *darwinsys-api* repo, you will find *REDemo.java*, which you can
    run to explore how regexes work.
  prefs: []
  type: TYPE_NORMAL
- en: In the uppermost text box (see [Figure 4-1](#javacook-regex-FIG-1)), type the
    regex pattern you want to test. Note that as you type each character, the regex
    is checked for syntax; if the syntax is OK, you see a checkmark beside it. You
    can then select Match, Find, or Find All. Match means that the entire string must
    match the regex, and Find means the regex must be found somewhere in the string
    (Find All counts the number of occurrences that are found). Below that, you type
    a string that the regex is to match against. Experiment to your heart’s content.
    When you have the regex the way you want it, you can paste it into your Java program.
    You’ll need to escape (backslash) any characters that are treated specially by
    both the Java compiler and the Java regex package, such as the backslash itself,
    double quotes, and others. Once you get a regex the way you want it, there is
    a Copy button (not shown in these screenshots) to export the regex to the clipboard,
    with or without backslash doubling, depending on how you want to use it.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Remember that because a regex is entered as a string that will be compiled
    by a Java compiler, you usually need two levels of escaping for any special characters,
    including backslash and double quotes. For example, the regex (which includes
    the double quotes):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'has to be typed like this to be a valid compile-time Java language `String`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In Java 14+ you could also use a text block to avoid escaping the quotes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: I can’t tell you how many times I’ve made the mistake of forgetting the extra
    backslash in `\d+`, `\w+`, and their kin!
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Figure 4-1](#javacook-regex-FIG-1), I typed `qu` into the `REDemo` program’s
    Pattern box, which is a syntactically valid regex pattern: any ordinary characters
    stand as regexes for themselves, so this looks for the letter `q` followed by
    `u`. In the top version, I typed only a `q` into the string, which is not matched.
    In the second, I have typed `quack` and the `q` of a second `quack`. Because I
    have selected Find All, the count shows one match. As soon as I type the second
    `u`, the count is updated to two, as shown in the third version.'
  prefs: []
  type: TYPE_NORMAL
- en: Regexes can do far more than just character matching. For example, the two-character
    regex `^T` would match beginning of line (`^`) immediately followed by a capital
    T—that is, any line beginning with a capital T. It doesn’t matter whether the
    line begins with “Tiny trumpets,” “Titanic tubas,” or “Triumphant twisted trombones,”
    as long as the capital T is present in the first position.
  prefs: []
  type: TYPE_NORMAL
- en: But here we’re not very far ahead. Have we really invested all this effort in
    regex technology just to be able to do what we could already do with the `java.lang.String`
    method `startsWith()`? Hmmm, I can hear some of you getting a bit restless. Stay
    in your seats! What if you wanted to match not only a letter T in the first position,
    but also a vowel immediately after it, followed by any number of letters in a
    word, followed by an exclamation point? Surely you could do this in Java by checking
    `startsWith("T")` and `charAt(1) == 'a' || charAt(1) == 'e'`, and so on? Yes,
    but by the time you did that, you’d have written a lot of very highly specialized
    code that you couldn’t use in any other application. With regular expressions,
    you can just give the pattern `^T[aeiou]\w*!`. That is, `^` and `T` as before,
    followed by a character class listing the vowels, followed by any number of word
    characters (`\w*`), followed by the exclamation point.
  prefs: []
  type: TYPE_NORMAL
- en: '![jcb4 0401](assets/jcb4_0401.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-1\. REDemo with simple examples
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: “But wait, there’s more!” as my late, great boss [Yuri Rubinsky](https://en.wikipedia.org/wiki/Yuri_Rubinsky)
    used to say. What if you want to be able to change the pattern you’re looking
    for *at runtime*? Remember all that Java code you just wrote to match `T` in column
    1, plus a vowel, some word characters, and an exclamation point? Well, it’s time
    to throw it out. Because this morning we need to match `Q`, followed by a letter
    other than `u`, followed by a number of digits, followed by a period. While some
    of you start writing a new function to do that, the rest of us will just saunter
    over to the RegEx Bar & Grille, order a `^Q[^u]\d+\.`. from the bartender, and
    be on our way.
  prefs: []
  type: TYPE_NORMAL
- en: 'OK, if you want an explanation: the `[^u]` means match any one character that
    is not the character `u`. The `\d+` means one or more numeric digits. The `+`
    is a quantifier meaning one or more occurrences of what it follows, and `\d` is
    any one numeric digit. So `\d+` means a number with one, two, or more digits.
    Finally, the `\.`? Well, . by itself is a metacharacter. Most single metacharacters
    are switched off by preceding them with an escape character. Not the Esc key on
    your keyboard, of course. The regex escape character is the backslash. Preceding
    a metacharacter like . with this escape turns off its special meaning, so we look
    for a literal period rather than any character. Preceding a few selected alphabetic
    characters (e.g., `n`, `r`, `t`, `s`, `w`) with escape turns them into metacharacters.
    [Figure 4-2](#javacook-regex-FIG-2) shows the `^Q[^u]\d+\..` regex in action.
    In the first frame, I have typed part of the regex as `^Q[^u`. Because there is
    an unclosed square bracket, the Syntax OK flag is turned off; when I complete
    the regex, it will be turned back on. In the second frame, I have finished typing
    the regex, and I’ve typed the data string as `QA577` (which you should expect
    to match the `$$^Q[^u]\d+$$` but not the period since I haven’t typed it). In
    the third frame, I’ve typed the period so the Matches flag is set to Yes.'
  prefs: []
  type: TYPE_NORMAL
- en: '![jcb4 0402](assets/jcb4_0402.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-2\. REDemo with “Q not followed by u” example
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Because backslashes need to be escaped when pasting the regex into Java code,
    the current version of `REDemo` has both a `Copy Pattern` button, which copies
    the regex verbatim for use in documentation and in Unix commands, and a `Copy
    Pattern Backslashed` button, which copies the regex to the clipboard with backslashes
    doubled, for pasting into Java strings.
  prefs: []
  type: TYPE_NORMAL
- en: By now you should have at least a basic grasp of how regexes work in practice.
    The rest of this chapter gives more examples and explains some of the more powerful
    topics, such as capture groups. As for how regexes work in theory—and there are
    a lot of theoretical details and differences among regex flavors—the interested
    reader is referred to *[Mastering Regular Expressions](http://shop.oreilly.com/product/9780596528126.do)*.
    Meanwhile, let’s start learning how to write Java programs that use regular expressions.
  prefs: []
  type: TYPE_NORMAL
- en: '4.2 Using Regexes in Java: Test for a Pattern'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You’re ready to get started using regular expression processing to beef up your
    Java code by testing to see if a given pattern can match in a given string.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the Java Regular Expressions Package, `java.util.regex`.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The good news is that the Java API for regexes is actually easy to use. If
    all you need is to find out whether a given regex matches a string, you can use
    the convenient `boolean matches()` method of the `String` class, which accepts
    a regex pattern in `String` form as its argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This is, however, a convenience routine, and convenience always comes at a
    price. If the regex is going to be used more than once or twice in a program,
    it is more efficient to construct and use a `Pattern` and its `Matcher`(s). A
    complete program constructing a `Pattern` and using it to `match` is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `java.util.regex` package contains two classes, `Pattern` and `Matcher`,
    which provide the public API shown in [Example 4-1](#javacook-regex-EX-1).
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-1\. Regex public API
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This API is large enough to require some explanation. These are the normal
    steps for regex matching in a production program:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `Pattern` by calling the static method `Pattern.compile()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Request a `Matcher` from the pattern by calling `pattern.matcher(CharSequence)`
    for each `String` (or other `CharSequence`) you wish to look through.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call (once or more) one of the finder methods (discussed later in this section)
    in the resulting `Matcher`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `java.lang.CharSequence` interface provides simple read-only access to objects
    containing a collection of characters. The standard implementations are `String`
    and `StringBuffer`/`StringBuilder` (described in [Chapter 3](ch03.html#javacook-strings)),
    and the new I/O class `java.nio.CharBuffer`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, you can perform regex matching in other ways, such as using the
    convenience methods in `Pattern` or even in `java.lang.String`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: But the three-step list is the standard pattern for matching. You’d likely use
    the `String` convenience routine in a program that only used the regex once; if
    the regex were being used more than once, it is worth taking the time to compile
    it because the compiled version runs faster.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, the `Matcher` has several finder methods, which provide more flexibility
    than the `String` convenience routine `match()`. These are the `Matcher` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`match()`'
  prefs: []
  type: TYPE_NORMAL
- en: Used to compare the entire string against the pattern; this is the same as the
    routine in `java.lang.String`. Because it matches the entire `String`, I had to
    put `.*` before and after the pattern.
  prefs: []
  type: TYPE_NORMAL
- en: '`lookingAt()`'
  prefs: []
  type: TYPE_NORMAL
- en: Used to match the pattern only at the beginning of the string.
  prefs: []
  type: TYPE_NORMAL
- en: '`find()`'
  prefs: []
  type: TYPE_NORMAL
- en: Used to match the pattern in the string (not necessarily at the first character
    of the string), starting at the beginning of the string or, if the method was
    previously called and succeeded, at the first character not matched by the previous
    match.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of these methods returns `boolean`, with `true` meaning a match and `false`
    meaning no match. To check whether a given string matches a given pattern, you
    need only type something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: But you may also want to extract the text that matched, which is the subject
    of the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: The following recipes cover uses of the Matcher API. Initially, the examples
    just use arguments of type `String` as the input source. Use of other `CharSequence`
    types is covered in [Recipe 4.5](#javacook-regex-SECT-5).
  prefs: []
  type: TYPE_NORMAL
- en: 4.3 Finding the Matching Text
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to find the text that the regex matched.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes you need to know more than just whether a regex matched a string.
    In editors and many other tools, you want to know exactly what characters were
    matched. Remember that with quantifiers such as *, the length of the text that
    was matched may have no relationship to the length of the pattern that matched
    it. Do not underestimate the mighty `.*`, which happily matches thousands or millions
    of characters if allowed to. As you saw in the previous recipe, you can find out
    whether a given match succeeds just by using `find()` or `matches()`. But in other
    applications, you will want to get the characters that the pattern matched.
  prefs: []
  type: TYPE_NORMAL
- en: 'After a successful call to one of the preceding methods, you can use these
    information methods on the `Matcher` to get information on the match:'
  prefs: []
  type: TYPE_NORMAL
- en: '`start(), end()`'
  prefs: []
  type: TYPE_NORMAL
- en: Returns the character position in the string of the starting and ending characters
    that matched.
  prefs: []
  type: TYPE_NORMAL
- en: '`groupCount()`'
  prefs: []
  type: TYPE_NORMAL
- en: Returns the number of parenthesized capture groups, if any; returns 0 if no
    groups were used.
  prefs: []
  type: TYPE_NORMAL
- en: '`group(int i)`'
  prefs: []
  type: TYPE_NORMAL
- en: Returns the characters matched by group *`i`* of the current match, if *`i`*
    is greater than or equal to zero and less than or equal to the return value of
    `groupCount()`. Group 0 is the entire match, so `group(0)` (or just `group()`)
    returns the entire portion of the input that matched.
  prefs: []
  type: TYPE_NORMAL
- en: The notion of parentheses, or capture groups, is central to regex processing.
    Regexes may be nested to any level of complexity. The `group(int)` method lets
    you retrieve the characters that matched a given parenthesis group. If you haven’t
    used any explicit parens, you can just treat whatever matched as level zero. [Example 4-2](#part-of-rematch.java)
    shows part of *REMatch.java*.
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-2\. Part of main/src/main/java/regex/REMatch.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'When run, this prints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: With the `Match` button checked, REDemo provides a display of all the capture
    groups in a given regex; one example is shown in [Figure 4-3](#javacook-regex-FIG-3).
  prefs: []
  type: TYPE_NORMAL
- en: '![jcb4 0403](assets/jcb4_0403.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-3\. REDemo in action
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'It is also possible to get the starting and ending indices and the length of
    the text that the pattern matched (remember that terms with quantifiers, such
    as the `\d+` in this example, can match an arbitrary number of characters in the
    string). You can use these in conjunction with the `String.substring()` methods
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Suppose you need to extract several items from a string. If the input is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: and you want to get out
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'just use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 4.4 Replacing the Matched Text
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Having found some text using a Pattern, you want to replace the text with different
    text, without disturbing the rest of the string.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we saw in the previous recipe, regex patterns involving quantifiers can match
    a lot of characters with very few metacharacters. We need a way to replace the
    text that the regex matched without changing other text before or after it. We
    could do this manually using the `String` method `substring()`. However, because
    it’s such a common requirement, the Java Regular Expression API provides some
    substitution methods.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Matcher` class provides several methods for replacing just the text that
    matched the pattern. In all these methods, you pass in the replacement text, or
    “righthand side,” of the substitution (this term is historical: in a command-line
    text editor’s substitute command, the lefthand side is the pattern and the righthand
    side is the replacement text). These are the replacement methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`replaceAll(newString)`'
  prefs: []
  type: TYPE_NORMAL
- en: Replaces all occurrences that matched with the new string
  prefs: []
  type: TYPE_NORMAL
- en: '`replaceFirst(newString)`'
  prefs: []
  type: TYPE_NORMAL
- en: As above but only the first occurence
  prefs: []
  type: TYPE_NORMAL
- en: '`appendReplacement(StringBuffer, newString)`'
  prefs: []
  type: TYPE_NORMAL
- en: Copies up to before the first match, plus the given `newString`
  prefs: []
  type: TYPE_NORMAL
- en: '`appendTail(StringBuffer)`'
  prefs: []
  type: TYPE_NORMAL
- en: Appends text after the last match (normally used after `appendReplacement`)
  prefs: []
  type: TYPE_NORMAL
- en: 'Despite their names, the `replace*` methods behave in accord with the immutability
    of `Strings` (see [“Timeless, Immutable, and Unchangeable”](ch03.html#strings-are-immutable)):
    they create a new `String` object with the replacement performed; they do not
    (indeed, could not) modify the string referred to in the `Matcher` object.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 4-3](#javacook-regex-EX-2) shows use of these three methods.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-3\. main/src/main/java/regex/ReplaceDemo.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Sure enough, when you run it, it does what we expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `replaceAll()` method handles the case of making the same change all through
    a string. If you want to change each matching occurrence to a different value,
    you can use `replaceFirst()` in a loop, as in [Example 4-4](#javacook-regex-EX-2b).
    Here we make a pass through an entire string, turning each occurrence of either
    `cat` or `dog` into `feline` or `canine`. This is simplified from a real example
    that looked for *bit.ly* URLs and replaced them with the actual URL; the `computeReplacement`
    method there used the network client code from [Recipe 12.1](ch12.html#javacook-netclient-rest-1).
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-4\. main/src/main/java/regex/ReplaceMulti.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: If you need to refer to portions of the occurrence that matched the regex, you
    can mark them with extra parentheses in the pattern and refer to the matching
    portion with `$1`, `$2`, and so on in the replacement string. [Example 4-5](#javacook-regex-EX-2c)
    uses this to interchange two fields, in this case, turn names in the form `Firstname
    Lastname` into `Lastname, FirstName`.
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-5\. main/src/main/java/regex/ReplaceDemo2.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 4.5 Printing All Occurrences of a Pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to find all the strings that match a given regex in one or more files
    or other sources.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This example reads through a file one line at a time. Whenever a match is found,
    I extract it from the `line` and print it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This code takes the `group()` methods from [Recipe 4.3](#javacook-regex-SECT-3),
    the `substring` method from the `CharacterIterator` interface, and the `match()`
    method from the regex and simply puts them all together. I coded it to extract
    all the names from a given file; in running the program through itself, it prints
    the words `import`, `java`, `until`, `regex`, and so on, each on its own line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'I interrupted it here to save paper. This can be written two ways: a line-at-a-time
    pattern shown in [Example 4-6](#javacook-regex-EX-3) and a more compact form using
    new I/O shown in [Example 4-7](#javacook-regex-EX-4) (the new I/O package used
    in both examples is described in [Chapter 10](ch10.html#javacook-io)).'
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-6\. main/src/main/java/regex/ReaderIter.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Example 4-7\. main/src/main/java/regex/GrepNIO.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The non-blocking I/O (NIO) version shown in [Example 4-7](#javacook-regex-EX-4)
    relies on the fact that an NIO `Buffer` can be used as a `CharSequence`. This
    program is more general in that the pattern argument is taken from the command-line
    argument. It prints the same output as the previous example if invoked with the
    pattern argument from the previous program on the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: You might think of using `\w+` as the pattern; the only difference is that my
    pattern looks for well-formed capitalized words, whereas `\w+` would include Java-centric
    oddities like `theVariableName`, which have capitals in nonstandard positions.
  prefs: []
  type: TYPE_NORMAL
- en: Also note that the NIO version will probably be more efficient because it doesn’t
    reset the `Matcher` to a new input source on each line of input as `ReaderIter`
    does.
  prefs: []
  type: TYPE_NORMAL
- en: 4.6 Printing Lines Containing a Pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to look for lines matching a given regex in one or more files.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Write a simple *grep*-like program.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As I’ve mentioned, once you have a regex package, you can write a *grep*-like
    program. I gave an example of the Unix *grep* program earlier. *grep* is called
    with some optional arguments, followed by one required regular expression pattern,
    followed by an arbitrary number of filenames. It prints any line that contains
    the pattern, differing from [Recipe 4.5](#javacook-regex-SECT-5), which prints
    only the matching text itself. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The code searches for lines containing either `darwin` or `Darwin` in every
    line of every file whose name ends in *.txt*.^([3](ch04.html#idm45290684672008))
    [Example 4-8](#javacook-regex-EX-5) is the source for the first version of a program
    to do this, called *Grep0*. It reads lines from the standard input and doesn’t
    take any optional arguments, but it handles the full set of regular expressions
    that the `Pattern` class implements (it is, therefore, not identical to the Unix
    programs of the same name). We haven’t covered the `java.io` package for input
    and output yet (see [Chapter 10](ch10.html#javacook-io)), but our use of it here
    is simple enough that you can probably intuit it. The online source includes *Grep1*,
    which does the same thing but is better structured (and therefore longer). Later
    in this chapter, [Recipe 4.11](#javacook-regex-SECT-12) presents a *JGrep* program
    that parses a set of command-line options.
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-8\. main/src/main/java/regex/Grep0.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 4.7 Controlling Case in Regular Expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to find text regardless of case.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Compile the `Pattern` passing in the `flags` argument `Pattern.CASE_INSENSITIVE`
    to indicate that matching should be case-independent (i.e., that it should fold,
    ignore differences in case). If your code might run in different locales (see
    [Recipe 3.12](ch03.html#javacook-i18n-SECT-8)), then you should add `Pattern.UNICODE_CASE`.
    Without these flags, the default is normal, case-sensitive matching behavior.
    This flag (and others) are passed to the `Pattern.compile()` method, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This flag must be passed when you create the `Pattern`; because `Pattern` objects
    are immutable, they cannot be changed once constructed.
  prefs: []
  type: TYPE_NORMAL
- en: The full source code for this example is online as *CaseMatch.java*.
  prefs: []
  type: TYPE_NORMAL
- en: 4.8 Matching Accented, or Composite, Characters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want characters to match regardless of the form in which they are entered.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Compile the `Pattern` with the `flags` argument `Pattern.CANON_EQ` for canonical
    equality.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Composite characters can be entered in various forms. Consider, as a single
    example, the letter `e` with an acute accent. This character may be found in various
    forms in Unicode text, such as the single character `é` (Unicode character `\u00e9`)
    or the two-character sequence `e´` (e followed by the Unicode combining acute
    accent, `\u0301`). To allow you to match such characters regardless of which of
    possibly multiple fully decomposed forms are used to enter them, the regex package
    has an option for *canonical matching*, which treats any of the forms as equivalent.
    This option is enabled by passing `CANON_EQ` as (one of) the flags in the second
    argument to `Pattern.compile()`. This program shows `CANON_EQ` being used to match
    several forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This program correctly matches the combining accent and rejects the other characters,
    some of which, unfortunately, look like the accent on a printer, but are not considered
    combining accent characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: For more details, see the [character charts](http://www.unicode.org).
  prefs: []
  type: TYPE_NORMAL
- en: 4.9 Matching Newlines in Text
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to match newlines in text.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use `\n` or `\r` in your regex pattern. See also the flags constant `Pattern.MULTILINE`,
    which makes newlines match as beginning-of-line and end-of-line (`\^` and `$`).
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Though line-oriented tools from Unix such as *sed* and *grep* match regular
    expressions one line at a time, not all tools do. The *sam* text editor from Bell
    Laboratories was the first interactive tool I know of to allow multiline regular
    expressions; the Perl scripting language followed shortly after. In the Java API,
    the newline character by default has no special significance. The `BufferedReader`
    method `readLine()` normally strips out whichever newline characters it finds.
    If you read in gobs of characters using some method other than `readLine()`, you
    may have some number of `\n`, `\r`, or `\r\n` sequences in your text string.^([4](ch04.html#idm45290684143384))
    Normally all of these are treated as equivalent to `\n`. If you want only `\n`
    to match, use the `UNIX_LINES` flag to the `Pattern.compile()` method.
  prefs: []
  type: TYPE_NORMAL
- en: In Unix, `^` and `$` are commonly used to match the beginning or end of a line,
    respectively. In this API, the regex metacharacters `\^` and `$` ignore line terminators
    and only match at the beginning and the end, respectively, of the entire string.
    However, if you pass the `MULTILINE` flag into `Pattern.compile()`, these expressions
    match just after or just before, respectively, a line terminator; `$` also matches
    the very end of the string. Because the line ending is just an ordinary character,
    you can match it with . or similar expressions; and, if you want to know exactly
    where it is, `\n` or `\r` in the pattern match it as well. In other words, to
    this API, a newline character is just another character with no special significance.
    See the sidebar [“Pattern.compile() Flags”](#javacook-regex-SIDEBAR-2). An example
    of newline matching is shown in [Example 4-9](#javacook-regex-EX-6).
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-9\. main/src/main/java/regex/NLMatch.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run this code, the first pattern (with the wildcard character .) always
    matches, whereas the second pattern (with `$`) matches only when `MATCH_MULTILINE`
    is set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '4.10 Program: Apache Logfile Parsing'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Apache web server is the world’s leading web server and has been for most
    of the web’s history. It is one of the world’s best-known open source projects,
    and it’s the first of many fostered by the Apache Foundation. The name Apache
    is often claimed to be a pun on the origins of the server; its developers began
    with the free NCSA server and kept hacking at it, or patching, it until it did
    what they wanted. When it was sufficiently different from the original, a new
    name was needed. Because it was now a patchy server, the name Apache was chosen.
    Officialdom denies the story, but it’s cute anyway. One place actual patchiness
    does show through is in the logfile format. Consider [Example 4-10](#apache-example).
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-10\. Apache log file excerpt
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The file format was obviously designed for human inspection but not for easy
    parsing. The problem is that different delimiters are used: square brackets for
    the date, quotes for the request line, and spaces sprinkled all through. Consider
    trying to use a `StringTokenizer`; you might be able to get it working, but you’d
    spend a lot of time fiddling with it. Actually, no, you wouldn’t get it working.
    However, this somewhat contorted regular expression^([5](ch04.html#idm45290683942808))
    makes it easy to parse (this is one single Moby-sized regex; we had to break it
    over two lines to make it fit the book’s margins):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: You may find it informative to refer back to [Table 4-1](#javacook-regex-TABLE-2)
    and review the full syntax used here. Note in particular the use of the nongreedy
    quantifier `+?` in `\"(.+?)\`" to match a quoted string; you can’t just use `.+`
    because that would match too much (up to the quote at the end of the line). Code
    to extract the various fields such as IP address, request, referrer URL, and browser
    version is shown in [Example 4-11](#javacook-regex-EX-7).
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-11\. main/src/main/java/regex/LogRegExp.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The `implements` clause is for an interface that just defines the input string;
    it was used in a demonstration to compare the regular expression mode with the
    use of a `StringTokenizer`. The source for both versions is in the online source
    for this chapter. Running the program against the sample input from [Example 4-10](#apache-example)
    gives this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The program successfully parsed the entire logfile format entry with one call
    to `matcher.matches()`.
  prefs: []
  type: TYPE_NORMAL
- en: '4.11 Program: Full Grep'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we’ve seen how the regular expressions package works, it’s time to
    write JGrep, a full-blown version of the line-matching program with option parsing.
    [Table 4-2](#javacook-regex-TABLE-3) lists some typical command-line options that
    a Unix implementation of *grep* might include. For those not familiar with *grep*,
    it is a command-line tool that searches for regular expressions in text files.
    There are three or four programs in the standard *grep* family, and a newer replacement
    *ripgrep*, or *rg*. This program is my addition to this family of programs.
  prefs: []
  type: TYPE_NORMAL
- en: Table 4-2\. Grep command-line options
  prefs: []
  type: TYPE_NORMAL
- en: '| Option | Meaning |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| -c | Count only; don’t print lines, just count them |'
  prefs: []
  type: TYPE_TB
- en: '| -C | Context; print some lines above and below each line that matches (not
    implemented in this version; left as an exercise for the reader) |'
  prefs: []
  type: TYPE_TB
- en: '| -f pattern | Take pattern from file named after `-f` instead of from command
    line |'
  prefs: []
  type: TYPE_TB
- en: '| -h | Suppress printing filename ahead of lines |'
  prefs: []
  type: TYPE_TB
- en: '| -i | Ignore case |'
  prefs: []
  type: TYPE_TB
- en: '| -l | List filenames only: don’t print lines, just the names they’re found
    in |'
  prefs: []
  type: TYPE_TB
- en: '| -n | Print line numbers before matching lines |'
  prefs: []
  type: TYPE_TB
- en: '| -s | Suppress printing certain error messages |'
  prefs: []
  type: TYPE_TB
- en: '| -v | Invert: print only lines that do NOT match the pattern |'
  prefs: []
  type: TYPE_TB
- en: The Unix world features several *getopt* library routines for parsing command-line
    arguments, so I have a reimplementation of this in Java. As usual, because `main()`
    runs in a static context but our application main line does not, we could wind
    up passing a lot of information into the constructor. To save space, this version
    just uses global variables to track the settings from the command line. Unlike
    the Unix *grep* tool, this one does not yet handle combined options, so `-l -r
    -i` is OK, but `-lri` will fail, due to a limitation in the `GetOpt` parser used.
  prefs: []
  type: TYPE_NORMAL
- en: The program basically just reads lines, matches the pattern in them, and, if
    a match is found (or not found, with `-v`), prints the line (and optionally some
    other stuff, too). Having said all that, the code is shown in [Example 4-12](#javacook-regex-EX-9).
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-12\. darwinsys-api/src/main/java/regex/JGrep.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: ^([1](ch04.html#idm45290687159592-marker)) Non-Unix fans fear not, for you can
    use tools like *grep* on Windows systems using one of several packages. One is
    an open source package alternately called CygWin (after Cygnus Software) or [GnuWin32](http://sources.redhat.com/cygwin).
    Another is Microsoft’s *findstr* command for Windows. Or you can use my *Grep*
    program in [Recipe 4.6](#javacook-regex-SECT-6) if you don’t have *grep* on your
    system. Incidentally, the name *grep* comes from an ancient Unix line editor command
    *g/RE/p*, the command to find the regex globally in all lines in the edit buffer
    and print the lines that match—just what the *grep* program does to lines in files.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch04.html#idm45290686929656-marker)) REDemo was inspired by (but does
    not use any code from) a similar program provided with the now-retired Apache
    Jakarta Regular Expressions package.
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch04.html#idm45290684672008-marker)) On Unix, the shell or command-line
    interpreter expands **.txt* to all the matching filenames before running the program,
    but the normal Java interpreter does this for you on systems where the shell isn’t
    energetic or bright enough to do it.
  prefs: []
  type: TYPE_NORMAL
- en: ^([4](ch04.html#idm45290684143384-marker)) Or a few related Unicode characters,
    including the next-line (`\u0085`), line-separator (`\u2028`), and paragraph-separator
    (`\u2029`) characters.
  prefs: []
  type: TYPE_NORMAL
- en: ^([5](ch04.html#idm45290683942808-marker)) You might think this would hold some
    kind of world record for complexity in regex competitions, but I’m sure it’s been
    outdone many times.
  prefs: []
  type: TYPE_NORMAL
