<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 2. The System of Truth"><div class="chapter" id="the_system_of_truth">
<h1><span class="label">Chapter 2. </span>The System of Truth</h1>


<p class="byline">Stephen Chin</p>
  <blockquote data-type="epigraph" epub:type="epigraph">
    <p>A complex system that works is invariably found to have evolved from a simple <span class="keep-together">system that worked.</span></p>
    <p data-type="attribution">John Gall (Gall’s law)</p>
  </blockquote>

<p>To have an effective DevOps pipeline, it is important to have a<a data-type="indexterm" data-primary="source code management (SCM)" data-secondary="about" id="idm45310224191008"/> single system of truth to understand what bits and bytes are being deployed into production.
Typically, this starts with a source code management system that contains all of the source code that gets compiled and built into the production deployment.
By tracing a production deployment back to a specific revision in source control, you can do root cause analysis of bugs, security holes, and performance issues.</p>

<p>Source code management solves several key roles in the software delivery lifecycle:</p>
<dl>
<dt>Collaboration</dt>
<dd>
<p>Large teams working on a single codebase<a data-type="indexterm" data-primary="collaboration" data-secondary="source code management" id="idm45310224187264"/> would constantly get blocked by one another without effective source code management, reducing productivity as the team size grows.</p>
</dd>
<dt>Versioning</dt>
<dd>
<p>Source code systems let you track versions<a data-type="indexterm" data-primary="version control systems" data-secondary="source code management" id="idm45310224184816"/> of the code to identify what is being deployed into production or released to a customer.</p>
</dd>
<dt>History</dt>
<dd>
<p>By keeping a chronological record of all versions<a data-type="indexterm" data-primary="history" data-secondary="source code management" id="idm45310224182256"/><a data-type="indexterm" data-primary="reverting to older version" id="idm45310224181280"/> of software as it is developed, it is possible to revert to an older version of the code or identify the specific change that caused a regression.</p>
</dd>
<dt>Attribution</dt>
<dd>
<p>Knowing who made the changes in a<a data-type="indexterm" data-primary="attribution in source code management" id="idm45310224179024"/> particular file allows you to identify ownership, assess domain expertise, and assess risk when making changes.</p>
</dd>
<dt>Dependencies</dt>
<dd>
<p>Source code has become the canonical source<a data-type="indexterm" data-primary="dependencies" data-secondary="source code management" id="idm45310224176656"/> for other key metadata about the project, like dependencies on other packages.</p>
</dd>
<dt>Quality</dt>
<dd>
<p>A source code management system allows for easy<a data-type="indexterm" data-primary="quality via source code management" id="idm45310224174112"/> peer review of changes before they are accepted, increasing the overall quality of the software.</p>
</dd>
</dl>

<p>Since source code management plays such a critical role in software development, it is important to understand how it works and select a system that best meets the needs of your organization and the desired DevOps workflow.</p>






<section data-type="sect1" data-pdf-bookmark="Three Generations of Source Code Management"><div class="sect1" id="idm45310224172384">
<h1>Three Generations of Source Code Management</h1>

<p>Collaboration is a big part of software development,<a data-type="indexterm" data-primary="source code management (SCM)" data-secondary="three generations of" id="ch02-3gen"/><a data-type="indexterm" data-primary="collaboration" data-secondary="source code management" id="ch02-3gen2"/><a data-type="indexterm" data-primary="version control systems" data-secondary="source code management" data-tertiary="three generations of" id="ch02-3gen3"/> and as you scale with larger teams, the ability to collaborate effectively on a shared codebase often becomes a bottleneck to developer productivity.
Also, the complexity of systems tends to increase, so rather than managing a dozen files or a handful of modules, it is common to see thousands of source files that need to be updated en masse to accomplish system-wide changes and refactorings.</p>

<p>To manage the need to collaborate on codebases, <em>source code management</em> <em>(SCM)</em> systems were created.
The first-generation SCM systems handled collaboration<a data-type="indexterm" data-primary="file locking" id="idm45310224218528"/> via file locking.
Examples of these are SCCS and RCS, which required that you lock files before editing, make your changes, and then release the lock for other folks to contribute.
This seemingly eliminated the possibility of two developers making conflicting changes, with two major drawbacks:</p>

<ul>
<li>
<p>Productivity was still impacted since you had to wait for other developers to finish their changes before editing.
In systems with large files, this could effectively limit the concurrency to only one developer at a time.</p>
</li>
<li>
<p>This did not solve the problem of conflicts across files.
It is still possible for two developers to modify different files with interdependencies and create a buggy or unstable system by introducing conflicting changes.</p>
</li>
</ul>

<p>A substantial improvement was made in the second-generation<a data-type="indexterm" data-primary="Concurrent Versions System (CVS)" id="idm45310224214464"/><a data-type="indexterm" data-primary="Grune, Dick" id="idm45310224213744"/> version control systems, starting with Concurrent Versions System (CVS) created by Dick Grune.
CVS was revolutionary in its approach to (or lack of) file locking.
Rather than preventing you from changing files, it would allow multiple developers to make their simultaneous (and possibly conflicting) changes to the same files.
This was later resolved via file merging: the conflicting files were analyzed via a difference (diff) algorithm, and any conflicting changes were presented to the user to resolve.</p>

<p>By delaying the resolution of conflicting changes to a check-in, CVS allowed multiple developers to freely modify and refactor a large codebase without becoming blocked on other changes to the same files.
This not only increases developer productivity, but also allows for the isolation and testing of large features separately, which can later be merged into an integrated codebase.</p>

<p>The most popular second-generation SCM is currently<a data-type="indexterm" data-primary="Apache Subversion" id="idm45310224212080"/><a data-type="indexterm" data-primary="Subversion (Apache)" id="idm45310224211376"/> Apache Subversion, which is designed as a drop-in replacement for CVS.
It offers several advantages over CVS, including tracking commits as a single revision, which avoids file-update collisions that can corrupt the CVS repository state.</p>

<p>The third generation of version control is<a data-type="indexterm" data-primary="distributed version control systems (DVCSs)" data-secondary="about" id="idm45310224210128"/><a data-type="indexterm" data-primary="version control systems" data-secondary="distributed version control systems" data-tertiary="about" id="idm45310224209056"/> distributed version control systems (DVCSs).
In a DVCS, every developer has a copy of the entire repository along with the full history stored locally.
Just as in a second-generation version control system, you check out a copy of the repository, make changes, and check it back in.
However, to integrate those changes with other developers, you sync your entire repository in a peer-to-peer fashion.</p>

<p>Several early DVCS systems existed, including GNU Arch, Monotone, and Darcs, but DVCS become popularized by Git and Mercurial.<a data-type="indexterm" data-primary="Mercurial" id="idm45310224207168"/><a data-type="indexterm" data-primary="Git" data-secondary="de facto standard DVCS" id="idm45310224206464"/><a data-type="indexterm" data-primary="version control systems" data-secondary="source code management" data-tertiary="Git as de facto standard" id="idm45310224205520"/><a data-type="indexterm" data-primary="version control systems" data-secondary="distributed version control systems" data-tertiary="Git as de facto standard" id="idm45310224204288"/><a data-type="indexterm" data-primary="source code management (SCM)" data-secondary="Git as de facto standard" id="idm45310224203040"/><a data-type="indexterm" data-primary="distributed version control systems (DVCSs)" data-secondary="Git as de facto standard" id="idm45310224202064"/>
Git was developed as a direct response to the Linux team’s need for a stable and reliable version control system that could support the scale and requirements for open source operating system development, and it has become the de facto standard for both open source and commercial version control system usage.</p>

<p>DVCSs offer several advantages over server-based version control:</p>
<dl>
<dt>Working entirely offline</dt>
<dd>
<p>Since you have a local copy of the repository, checking code in and out, merging, and managing branches can all be done without a network connection.</p>
</dd>
<dt>No single point of failure</dt>
<dd>
<p>Unlike a server-based SCM, where only one copy of the entire repository with full history exists, a DVCS creates a copy of the repository on every developer’s machine, increasing redundancy.</p>
</dd>
<dt>Faster local operations</dt>
<dd>
<p>Since most version control operations are local to the machine, they are much faster and not affected by network speed or server load.</p>
</dd>
</dl>
<dl class="pagebreak-before">
<dt>Decentralized control</dt>
<dd>
<p>Since syncing the code involves copying the entire repository, this makes it much easier to fork a codebase, and in the case of open source projects can make it much easier to start an independent effort when the main project has stalled or taken an undesirable direction.</p>
</dd>
<dt>Ease of migration</dt>
<dd>
<p>Converting from most SCM tools into Git is a relatively straightforward operation, and you can retain commit history.</p>
</dd>
</dl>

<p>And distributed version control has a few disadvantages, including these:</p>
<dl>
<dt>Slower initial repository sync</dt>
<dd>
<p>The initial sync includes copying the entire repository history, which can be much slower.</p>
</dd>
<dt>Larger storage requirements</dt>
<dd>
<p>Since everyone has a full copy of the repository and all history, very large and/or long-running projects may require a sizable disk requirement.</p>
</dd>
<dt>No ability to lock files</dt>
<dd>
<p>Server-based version control systems offer some support for locking files when a binary file that cannot be merged needs to be edited.
With DVCSs locking mechanics cannot<a data-type="indexterm" data-primary="file locking" data-secondary="distributed version control systems" id="idm45310224952608"/> be enforced, which means only files that can be merged (for example, text) are suitable for versioning.<a data-type="indexterm" data-startref="ch02-3gen" id="idm45310224951312"/><a data-type="indexterm" data-startref="ch02-3gen2" id="idm45310224950640"/><a data-type="indexterm" data-startref="ch02-3gen3" id="idm45310224949968"/></p>
</dd>
</dl>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Choosing Your Source Control"><div class="sect1" id="idm45310224948912">
<h1>Choosing Your Source Control</h1>

<p>Hopefully, by now you are convinced that using a modern DVCS is the way to go.<a data-type="indexterm" data-primary="source code management (SCM)" data-secondary="Git as de facto standard" id="ch02-which"/><a data-type="indexterm" data-primary="DVCS" data-see="distributed version control systems" id="idm45310224945696"/><a data-type="indexterm" data-primary="version control systems" data-secondary="distributed version control systems" data-tertiary="Git as de facto standard" data-seealso="Git" id="ch02-which2"/><a data-type="indexterm" data-primary="distributed version control systems (DVCSs)" data-secondary="Git as de facto standard" data-seealso="Git" id="ch02-which3"/><a data-type="indexterm" data-primary="version control systems" data-secondary="source code management" data-tertiary="Git as de facto standard" id="ch02-which4"/><a data-type="indexterm" data-primary="Git" data-secondary="de facto standard DVCS" id="ch02-which5"/>
It provides the best capabilities for local and remote development of any size team.</p>

<p>Also, of the commonly used version control systems, Git has become the clear winner in adoption.
This is shown clearly by looking at the Google Trends analysis of the most commonly used version control systems, as shown in <a data-type="xref" href="#version_control_adoption">Figure 2-1</a>.</p>

<figure><div id="version_control_adoption" class="figure">
<img src="Images/dtjd_0201.png" alt="Line graph comparing popularity of Git,Mercurial,Subversion,and CVS" width="600" height="159"/>
<h6><span class="label">Figure 2-1. </span>Popularity of version control systems from 2004 through 2022 (source: <a href="https://oreil.ly/qRxyG">Google Trends</a>)</h6>
</div></figure>

<p>Git has become the de facto standard in the open source community, which means a wide base of support exists for its usage along with a rich ecosystem.
However, sometimes convincing your boss or peers to adopt new technologies is difficult if they have a deep investment in a legacy source control technology.</p>

<p>Here are some reasons you can use to convince your boss to upgrade to Git:</p>
<dl>
<dt>Reliability</dt>
<dd>
<p>Git is written like a filesystem, including a proper filesystem check tool (<code>git fsck</code>) and checksums to ensure data reliability.
And given it is a DVCS, you probably have your data also pushed to multiple external repositories, creating several redundant backups of the data.</p>
</dd>
<dt>Performance</dt>
<dd>
<p>Git is not the first DVCS, but it is extremely performant.
It was built from the ground up to support Linux development with extremely large codebases and thousands of developers.
Git continues to be actively developed by a large open source community.</p>
</dd>
<dt>Tool support</dt>
<dd>
<p>There are over 40 frontends for Git and support in just about every major IDE (JetBrains IntelliJ IDEA, Microsoft Visual Studio Code, Eclipse, Apache NetBeans, etc.), so you are unlikely to find a development platform that does not fully support it.</p>
</dd>
<dt>Integrations</dt>
<dd>
<p>Git has first-class integrations with IDEs, issue trackers, messaging platforms, continuous integration servers, security scanners, code review tools, dependency management, and cloud platforms.</p>
</dd>
<dt>Upgrade tools</dt>
<dd>
<p>There are migration tools to ease the transition from other version-control systems to Git, such as <code>git-svn</code> that supports bidirectional changes from Subversion to Git, or the Team Foundation Version Control (TFVC) repository import tool for Git.</p>
</dd>
</dl>

<p>In summary, there is not much to lose by upgrading to Git, and a lot of additional capabilities and integrations to start to take advantage of.
Getting started with Git is<a data-type="indexterm" data-primary="Git" data-secondary="downloading" id="idm45310223335056"/><a data-type="indexterm" data-primary="resources for learning" data-secondary="Git" data-tertiary="download" id="idm45310223334080"/> as simple as <a href="https://oreil.ly/dxgt4">downloading a release</a> for your development machine and creating a local repository.</p>

<p>However, the real power comes in collaboration<a data-type="indexterm" data-primary="collaboration" data-secondary="Git distributed version control system" id="idm45310223331632"/><a data-type="indexterm" data-primary="Git" data-secondary="collaboration" id="idm45310223330688"/><a data-type="indexterm" data-primary="Git" data-secondary="commercial Git repositories" id="idm45310223329744"/> with the rest of your team, and this is most convenient if you have a central repository to push changes to and collaborate with. Several companies offer commercial Git repos that you can self-host or run on their cloud platform. These include AWS CodeCommit, Assembla, Azure DevOps, GitLab, SourceForge, GitHub, RhodeCode, Bitbucket, Gitcolony, and others. According to data from the JetBrains “State of the Developer Ecosystem 2020” report shown in <a data-type="xref" href="#version_control_service_chart">Figure 2-2</a>, these Git-based source control systems accounted for over 96% of the commercial source control market.</p>

<figure><div id="version_control_service_chart" class="figure">
<img src="Images/dtjd_0202.png" alt="Chart comparing the adoption of different CVS systems" width="600" height="326"/>
<h6><span class="label">Figure 2-2. </span>Data from the JetBrains <a href="https://oreil.ly/e9yJu">“State of the Developer Ecosystem 2020”</a> report on usage of version control services (source: JetBrains <a href="https://oreil.ly/W5qPM">CC BY 4.0</a>)</h6>
</div></figure>

<p>All of these version control services offer additional services on top of basic version control, including capabilities like these:</p>

<ul>
<li>
<p>Collaboration</p>
<dl>
<dt>Code reviews</dt>
<dd>
<p>Having an efficient system for code reviews is important to maintain code integrity, quality, and standards.</p>
</dd>
<dt>Advanced pull request/merge features</dt>
<dd>
<p>Many vendors implement advanced features on top of Git that help with multirepository and team workflows for more-efficient change request <span class="keep-together">management</span>.</p>
</dd>
<dt>Workflow automation</dt>
<dd>
<p>Approvals in a large organization<a data-type="indexterm" data-primary="workflows" data-secondary="workflow automation via version control services" id="idm45310223316784"/> can be both fluid and complicated, so having automation of team and corporate workflows improves efficiency.</p>
</dd>
<dt>Team comments/discussions</dt>
<dd>
<p>Effective team interaction and discussions that can be tied to specific pull requests and code changes help improve communication within and around the team.</p>
</dd>
<dt>Online editing</dt>
<dd>
<p>  In-browser IDEs allow for collaboration on source code from anywhere, on almost any device.
GitHub even recently released<a data-type="indexterm" data-primary="Git" data-secondary="collaboration" data-tertiary="Codespaces IDE" id="idm45310225119776"/><a data-type="indexterm" data-primary="GitHub" data-secondary="Codespaces IDE" id="idm45310225118528"/><a data-type="indexterm" data-primary="resources for learning" data-secondary="Git" data-tertiary="Codespaces IDE" id="idm45310225117584"/><a data-type="indexterm" data-primary="Git" data-secondary="downloading" data-tertiary="Codespaces IDE" id="idm45310225116368"/><a data-type="indexterm" data-primary="Git" data-secondary="IDE integration" data-tertiary="Codespaces IDE" id="idm45310225115152"/><a data-type="indexterm" data-primary="IDEs" data-secondary="Codespaces IDE" id="idm45310225113936"/><a data-type="indexterm" data-primary="Codespaces IDE" id="idm45310225112992"/> <a href="https://oreil.ly/1PKf4">Codespaces</a> to give you a fully functional development environment hosted by GitHub.</p>
</dd>
</dl>
</li>
<li>
<p>Compliance/security</p>
<dl>
<dt>Tracking</dt>
<dd>
<p>Being able to track the code history is a core feature of any version control system, but often additional compliance checks and reports are required.</p>
</dd>
<dt>Auditing changes</dt>
<dd>
<p>For control and regulatory purposes, auditing the changes to a codebase is often required, so having tools to automate this can be helpful.</p>
</dd>
<dt>Permissions management</dt>
<dd>
<p>Fine-grained roles and permissions allow for restricting access to sensitive files or codebases.</p>
</dd>
<dt>Bill of materials</dt>
<dd>
<p>For auditing purposes, a full list of all software modules and dependencies is often required, and can be generated off the source code.</p>
</dd>
<dt>Security vulnerability scanning</dt>
<dd>
<p>  Many common security vulnerabilities can be uncovered by scanning the codebase and looking for common patterns that are used to exploit deployed applications.
Using an automated vulnerability scanner on the source code can help identify vulnerabilities early in the development process.</p>
</dd>
</dl>
</li>
<li>
<p>Integration</p>
<dl>
<dt>Issue tracking</dt>
<dd>
<p>By having tight integration with an issue tracker, you can tie specific changesets to a software defect, making it easier to identify the version a bug is fixed in and trace any regressions.</p>
</dd>
<dt>CI/CD</dt>
<dd>
<p>Typically, a continuous integration server<a data-type="indexterm" data-primary="CI/CD (continuous integration and deployment)" data-secondary="version control services" id="idm45310225098864"/> will be used to build the code checked into source control. A tight integration makes it easier to kick off builds, report back on success and test results, and automate promotion and/or deployment of successful builds.</p>
</dd>
<dt>Binary package repository</dt>
<dd>
<p>Fetching dependencies from a binary repository and storing build results provides a central place to look for artifacts and to stage deployments.</p>
</dd>
<dt>Messaging integration</dt>
<dd>
<p>Team collaboration is important to a successful development effort, and making it easy to discuss source files, check-ins, and other source control events simplifies communication with platforms like Slack, Microsoft Teams, Element, etc.</p>
</dd>
<dt>Clients (desktop/IDE)</dt>
<dd>
<p>A lot of free clients and plug-ins for various IDEs allow you to access your source control system, including open source clients from GitHub, Bitbucket, and others.</p>
</dd>
</dl>
</li>
</ul>

<p>When selecting a version control service, it is important to make sure that it fits into the development workflow of your team, integrates with other tools that you already use, and fits into your corporate security policies.
Often companies have a version control system that is standardized across the organization, but there may be benefits to adopting a more modern version control system, especially if the corporate standard is not a DVCS like Git.<a data-type="indexterm" data-startref="ch02-which" id="idm45310225092752"/><a data-type="indexterm" data-startref="ch02-which2" id="idm45310225092048"/><a data-type="indexterm" data-startref="ch02-which3" id="idm45310225091376"/><a data-type="indexterm" data-startref="ch02-which4" id="idm45310225090704"/><a data-type="indexterm" data-startref="ch02-which5" id="idm45310225090032"/></p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Making Your First Pull Request"><div class="sect1" id="idm45310224948320">
<h1>Making Your First Pull Request</h1>

<p>To get a feel for how version control works, we are going<a data-type="indexterm" data-primary="book repository on GitHub" data-secondary="pull request" id="ch02-pull"/><a data-type="indexterm" data-primary="Git" data-secondary="pull request exercise" id="ch02-pull2"/><a data-type="indexterm" data-primary="pull (Git command)" data-secondary="book repository exercise" id="ch02-pull3"/><a data-type="indexterm" data-primary="collaboration" data-secondary="Git distributed version control system" data-tertiary="pull request exercise" id="ch02-pull4"/><a data-type="indexterm" data-primary="GitHub" data-secondary="UI for pull request" id="ch02-pull5"/><a data-type="indexterm" data-primary="tutorials" data-secondary="Git pull request" id="ch02-pull6"/><a data-type="indexterm" data-primary="repositories" data-secondary="book repository" data-tertiary="pull request exercise" id="ch02-pull7"/><a data-type="indexterm" data-primary="GUI interface for Git" data-secondary="GitHub UI for pull request" id="ch02-pull8"/> to run through a simple exercise to create your first pull request to the official book repository on GitHub.
A section of the readme file is dedicated to reader comments, so you can join the rest of the readers in showing your accomplishment in learning modern DevOps best practices!</p>

<p>This exercise doesn’t require installing any software or using the command line, so it should be easy and straightforward to accomplish.
Finishing this exercise is highly recommended so you understand the basic concepts of distributed version control that we go into more detail on later in the chapter.</p>

<p>To start, you need to navigate to the<a data-type="indexterm" data-primary="repositories" data-secondary="book repository" id="idm45310225064816"/><a data-type="indexterm" data-primary="resources for learning" data-secondary="book" data-tertiary="repository" id="idm45310225063840"/><a data-type="indexterm" data-primary="book repository on GitHub" id="idm45310225062624"/> <a href="https://oreil.ly/ApzqX">book repository</a>.
For this exercise, you need to be logged in so you can create a pull request from the web user interface.
If you don’t already have a GitHub account, signing up and getting started is easy and free.</p>

<p>The DevOps Tools for Java Developers repository GitHub page is shown in <a data-type="xref" href="#book_repository">Figure 2-3</a>.
The GitHub UI shows the root files and the contents of a special file called <em>README.md</em> by default.
We are going to make edits to the readme file,<a data-type="indexterm" data-primary="Markdown in README.md" id="ch02-readme"/> which is coded in a visual text language called Markdown.</p>

<p>Since we have only read access to this repository,<a data-type="indexterm" data-primary="fork (Git)" data-secondary="book repository exercise" id="idm45310225057952"/> we are going to create a personal clone of the repository, known as a <em>fork</em>, that we can freely edit to make and propose the changes.
Once you are logged in to GitHub, you can start this process by clicking the Fork button highlighted in the upper-right corner.</p>

<figure><div id="book_repository" class="figure">
<img src="Images/dtjd_0203.png" alt="Website page showing the GitHub book repository" width="600" height="542"/>
<h6><span class="label">Figure 2-3. </span>The GitHub repository containing this book’s samples</h6>
</div></figure>

<p>Your new fork will get created under your personal account at GitHub.
Once your fork is created, complete the following steps to open the web-based text editor:</p>
<ol>
<li>
<p>Click the <em>README.md</em> file that you want to edit to see the details page.</p>
</li>
<li>
<p>Click the pencil icon on the details page to edit the file.</p>
</li>

</ol>

<p>Once you click the pencil icon, you will see the web-based text editor shown in <a data-type="xref" href="#edit_readme">Figure 2-4</a>.
Scroll down to the section with the visitor log, and add your own personal comment to the end to let folks know you completed this exercise.</p>

<figure><div id="edit_readme" class="figure">
<img src="Images/dtjd_0204.png" alt="Website page showing the GitHub text file editor" width="600" height="431"/>
<h6><span class="label">Figure 2-4. </span>The GitHub web-based text editor for making quick changes to files</h6>
</div></figure>

<p>The recommended format for visitor log entries is as follows:</p>
<pre data-type="programlisting"><em>Name</em> (@<em>optional_twitter_handle</em>): <em>Visitor comment</em>
</pre>

<p>If you want to be fancy on the Twitter handle and link to your profile, the Markdown syntax for Twitter links is as follows:</p>
<pre data-type="programlisting">@<em>twitterhandle</em>
</pre>

<p>To check your changes, you can click the “Preview changes” tab, which will show the rendered output once it’s inserted into the original readme.</p>

<p>When you are satisfied with your changes, scroll down to the code commit section shown in <a data-type="xref" href="#commit_changes">Figure 2-5</a>.
Enter a helpful description for the change to explain your updates.
Then go ahead and click the “Commit changes” button.<a data-type="indexterm" data-startref="ch02-readme" id="idm45310223375360"/></p>

<p>For this example, we will simply commit to the main branch, which is the default.
However, if you were working in a shared repository, you would commit your pull request to a feature branch that can be integrated separately.</p>

<figure><div id="commit_changes" class="figure">
<img src="Images/dtjd_0205.png" alt="Website page showing the code commit form" width="600" height="223"/>
<h6><span class="label">Figure 2-5. </span>Using GitHub UI to commit changes to a repository you have write access to</h6>
</div></figure>

<p>After you have made a change to your forked repository, you can submit this as a pull request for the original project.
This will notify the project maintainers (in this case, the book authors) that a proposed change is waiting for review and let them choose whether to integrate it into the original project.</p>

<p>To do this, go to the “Pull requests” tab in the GitHub user interface.
This screen has a button to create a “New pull request” that will present you with a choice of the “base” and “head” repository to be merged, as shown in <a data-type="xref" href="#create_pull_request">Figure 2-6</a>.</p>

<p>In this case, since you have only one change, the default repositories should be selected correctly.
Simply click the “Create pull request” button, and a new pull request against the original repository will be submitted for review.</p>

<figure><div id="create_pull_request" class="figure">
<img src="Images/dtjd_0206.png" alt="Website page showing the GitHub pull request UI" width="600" height="261"/>
<h6><span class="label">Figure 2-6. </span>User interface for creating a pull request from a forked repository</h6>
</div></figure>

<p>This completes your submission of a pull request!
Now it is up to the original repository owners to review and comment on, or accept/reject the pull request.
While you don’t have write access to the original repository to see what this looks like, <a data-type="xref" href="#merge_pull_request">Figure 2-7</a> shows you what will be presented to the repository owners.</p>

<p>Once the repository owners accept your pull request, your custom visitor log greeting will be added to the official book repository.</p>

<figure><div id="merge_pull_request" class="figure">
<img src="Images/dtjd_0207.png" alt="Website page showing the GitHub merge resolution UI" width="600" height="390"/>
<h6><span class="label">Figure 2-7. </span>The repository owner user interface for merging in the resulting pull request</h6>
</div></figure>

<p>This workflow is an example of the fork and pull request collaboration model for handling project integration.
We will talk a bit more about collaboration patterns and the sort of projects and team structures they are most suitable for in <a data-type="xref" href="#git_collab_patterns">“Git Collaboration Patterns”</a>.<a data-type="indexterm" data-startref="ch02-pull" id="idm45310223362096"/><a data-type="indexterm" data-startref="ch02-pull2" id="idm45310223361392"/><a data-type="indexterm" data-startref="ch02-pull3" id="idm45310223360720"/><a data-type="indexterm" data-startref="ch02-pull4" id="idm45310223360048"/><a data-type="indexterm" data-startref="ch02-pull5" id="idm45310223359376"/><a data-type="indexterm" data-startref="ch02-pull6" id="idm45310223358704"/><a data-type="indexterm" data-startref="ch02-pull7" id="idm45310223358032"/><a data-type="indexterm" data-startref="ch02-pull8" id="idm45310223357360"/></p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Git Tools"><div class="sect1" id="idm45310225077584">
<h1>Git Tools</h1>

<p>In the previous section, we showed an entire web-based workflow for Git using the GitHub UI.<a data-type="indexterm" data-primary="Git" data-secondary="clients" data-tertiary="client-based tools" id="idm45310223355392"/>
However, other than code reviews and repository management, most developers spend the majority of their time in one of the client-based user interfaces to Git. The available client interfaces can be broadly split into the following categories:</p>
<dl>
<dt>Command line</dt>
<dd>
<p>An official Git command-line client may already be installed on your system or is easily added.</p>
</dd>
<dt>GUI clients</dt>
<dd>
<p>The official Git distribution comes with a couple of open source tools that can be used to more easily browse your revision history or to structure a commit.
Also, several third-party free and open source Git tools can make working with your repository easier.</p>
</dd>
<dt>Git IDE plug-ins</dt>
<dd>
<p>Often you need to go no further than your favorite IDE to work with your distributed source control system.
Many major IDEs have Git support packaged by default or offer a well-supported plug-in.</p>
</dd>
</dl>








<section data-type="sect2" data-pdf-bookmark="Git Command-Line Basics"><div class="sect2" id="idm45310223348496">
<h2>Git Command-Line Basics</h2>

<p>The Git command line is the most powerful interface<a data-type="indexterm" data-primary="Git" data-secondary="command-line basics" id="ch02-cmd"/> to your source control system, allowing for all local and remote options to manage your repository.
You can check whether you have the Git command line installed by typing the following on the console:</p>
<pre data-type="programlisting"><strong>git --version</strong>
</pre>

<p>If you have Git installed, the command will return the operating system and version that you are using, similar to this:</p>
<pre>git version 2.26.2.windows.1</pre>

<p>However, if you don’t have Git installed, here’s the easiest way to get it on various platforms:<a data-type="indexterm" data-primary="Git" data-secondary="installing" id="idm45310224640064"/></p>

<ul>
<li>
<p>Linux distributions:</p>

<ul>
<li>
<p><em>Debian-based:</em> <code>sudo apt install git-all</code></p>
</li>
<li>
<p><em>RPM-based:</em> <code>sudo dnf install git-all</code></p>
</li>
</ul>
</li>
<li>
<p>macOS</p>

<ul>
<li>
<p>Running <code>git</code> on macOS 10.9 or later will ask you to install it.</p>
</li>
<li>
<p>Another easy option is to<a data-type="indexterm" data-primary="resources for learning" data-secondary="Git" data-tertiary="GitHub Desktop" id="idm45310224631056"/><a data-type="indexterm" data-primary="GitHub Desktop" data-secondary="download link" id="idm45310224629808"/> install <a href="https://oreil.ly/0x2A3">GitHub Desktop</a>, which installs and configures the command-line tools.</p>
</li>
</ul>
</li>
<li>
<p>Windows</p>

<ul>
<li>
<p>The easiest way is to simply install GitHub Desktop, which installs the command-line tools as well.</p>
</li>
<li>
<p>Another option is <a href="https://oreil.ly/BioSg">Git for Windows</a>.</p>
</li>
</ul>
</li>
</ul>

<p>Regardless of which approach you use to install Git, you will end up with the same great command-line tools, which are well supported across all desktop platforms.</p>

<p>To start with, it is helpful to understand the basic Git commands.
<a data-type="xref" href="#git_repository_hierarchy">Figure 2-8</a> shows a typical<a data-type="indexterm" data-primary="distributed version control systems (DVCSs)" data-secondary="repository hierarchy" id="idm45310224621872"/><a data-type="indexterm" data-primary="version control systems" data-secondary="distributed version control systems" data-tertiary="repository hierarchy" id="idm45310224620800"/><a data-type="indexterm" data-primary="repositories" data-secondary="central server pattern" id="idm45310224619568"/><a data-type="indexterm" data-primary="Git" data-secondary="central repository model" id="idm45310224618624"/> repository hierarchy with one central repository and three clients who have cloned it locally.
Notice that every client has a full copy of the repository as well as a working copy where they can make changes.</p>

<figure><div id="git_repository_hierarchy" class="figure">
<img src="Images/dtjd_0208.png" alt="Diagram showing relationship of remote and local repositories, and the Git working copy" width="600" height="338"/>
<h6><span class="label">Figure 2-8. </span>A typical central server pattern for distributed version control collaboration</h6>
</div></figure>

<p>Some of the Git commands that allow you to move data between repositories as well as the working copy are shown.
Now let’s go through some of the most common commands that are used to manage your repository and collaborate in Git.</p>

<ul>
<li>
<p>Repository management:<a data-type="indexterm" data-primary="repositories" data-secondary="Git commands for management" data-seealso="Git" id="idm45310224613888"/></p>
<dl>
<dt><code>clone</code></dt>
<dd>
<p>Makes a connected copy of another local or remote repository on the local filesystem.
For those coming from a concurrent version control system like CVS or Subversion, this command serves a similar purpose to <code>checkout</code>, but is semantically different in that it creates a full copy of the remote repository. All of the clients in <a data-type="xref" href="#git_repository_hierarchy">Figure 2-8</a> would have cloned the central server to begin.<a data-type="indexterm" data-primary="clone (Git command)" id="idm45310224609408"/></p>
</dd>
<dt><code>init</code></dt>
<dd>
<p>Creates a new, empty repository. However, most of the time you will start by cloning an existing repository.<a data-type="indexterm" data-primary="init (Git command)" id="idm45310224607200"/></p>
</dd>
</dl>
</li>
<li>
<p>Changeset management:</p>
<dl>
<dt><code>add</code></dt>
<dd>
<p>Adds file revisions to version control, which can be either a new file or modifications to an existing file.
This is different from the <code>add</code> command in CVS or Subversion in that it does not <em>track</em> the file and needs to be called every time the file changes. Make sure to call <code>add</code> on all new and modified files before committing.<a data-type="indexterm" data-primary="add (Git command)" id="idm45310224275472"/></p>
</dd>
<dt><code>mv</code></dt>
<dd>
<p>Renames or moves a file/directory, while also updating the version control record for the next commit. It is similar in use to the <code>mv</code> command in Unix and should be used instead of filesystem commands to keep version control history intact.<a data-type="indexterm" data-primary="mv (Git command)" id="idm45310224272672"/></p>
</dd>
<dt><code>restore</code></dt>
<dd>
<p>Allows you to restore files from the Git index if they are deleted or erroneously modified.<a data-type="indexterm" data-primary="restore (Git command)" id="idm45310224270448"/></p>
</dd>
<dt><code>rm</code></dt>
<dd>
<p>Removes a file or directory, while also updating the version control record for the next commit. It is similar in use to the <code>rm</code> command in Unix and should be used instead of filesystem commands to keep version control history intact.<a data-type="indexterm" data-primary="rm (Git command)" id="idm45310224267648"/></p>
</dd>
</dl>
</li>
<li>
<p>History control:</p>
<dl>
<dt><code>branch</code></dt>
<dd>
<p>With no arguments, lists all branches in the local repository.
It can also be used to create a new branch or delete branches.<a data-type="indexterm" data-primary="branch (Git command)" id="idm45310224263792"/></p>
</dd>
<dt><code>commit</code></dt>
<dd>
<p>Saves changes in the working copy to the local repository.
Before running <code>commit</code>, make sure to register all your file changes by calling <code>add</code>, <code>mv</code>, and <code>rm</code> on files that have been added, modified, renamed, or moved. You also need to specify a commit message that can be done on the command line with the <code>-m</code> option; or if omitted, a text editor (such as <code>vi</code>) will be spawned to allow you to enter a message.<a data-type="indexterm" data-primary="commit (Git command)" id="idm45310224258608"/></p>
</dd>
<dt><code>merge</code></dt>
<dd>
<p>Joins changes from the named commits into the current branch.
If the merged history is already a descendant of the current branch, a “fast-forward” is used to combine the history sequentially.
Otherwise, a merge is created that combines the history; the user is prompted to resolve any conflicts. This command is also used by <code>git pull</code> to integrate changes from the remote repository.<a data-type="indexterm" data-primary="merge (Git command)" id="idm45310224256144"/></p>
</dd>
<dt><code>rebase</code></dt>
<dd>
<p>Replays the commits from your current branch on the upstream branch.
This is different from <code>merge</code> in that the result will be a linear history rather than a merge commit, which can make the revision history easier to follow. The disadvantage is that rebase creates entirely new commits when it moves the history, so if the current branch contains changes that have previously been pushed, you are rewriting history that other clients may depend upon.<a data-type="indexterm" data-primary="rebase (Git command)" id="idm45310224253504"/></p>
</dd>
<dt><code>reset</code></dt>
<dd>
<p>Reverts the <code>HEAD</code> to a previous state, and has several practical uses such as reverting an <code>add</code> or undoing a commit.
However, if those changes have been pushed remotely, this can cause problems with the upstream repository. Use with care!<a data-type="indexterm" data-primary="reset (Git command)" id="idm45310224250272"/></p>
</dd>
<dt><code>switch</code></dt>
<dd>
<p>Switches between branches for the working copy.
If you have changes in the working copy, this can result in a three-way merge, so it is often better to commit or stash your changes first.
With <code>-c</code>, this command will create a branch and immediately switch to it.<a data-type="indexterm" data-primary="switch (Git command)" id="idm45310224247536"/></p>
</dd>
<dt><code>tag</code></dt>
<dd>
<p>Allows you to create a tag on a specific commit that is signed by PGP. This uses the default email address’s PGP key. Since tags are cryptographically signed and unique, they should not be reused or changed once pushed. Additional options on this command allow for deleting, verifying, and listing tags.<a data-type="indexterm" data-primary="tag (Git command)" id="idm45310224245424"/></p>
</dd>
<dt><code>log</code></dt>
<dd>
<p>Shows the commit logs in a textual format. It can be used for a quick view of recent changes, and supports advanced options for the history subset shown and formatting of the output.<a data-type="indexterm" data-primary="log (Git command)" id="idm45310224243120"/> Later in this chapter, we also show how to visually browse the history by using tools like <code>gitk</code>.</p>
</dd>
</dl>
</li>
<li>
<p>Collaboration:<a data-type="indexterm" data-primary="collaboration" data-secondary="Git distributed version control system" data-tertiary="commands" id="idm45310224241056"/></p>
<dl>
<dt><code>fetch</code></dt>
<dd>
<p>Pulls the history from a remote repository into the local repository, but makes no attempt to merge it with local commits. This is a safe operation that can be performed at any time and repeatedly without causing merge conflicts or affecting the working copy.<a data-type="indexterm" data-primary="fetch (Git command)" id="idm45310224237712"/></p>
</dd>
<dt><code>pull</code></dt>
<dd>
<p>Equivalent to a <code>git fetch</code> followed by <code>git merge FETCH_HEAD</code>. It is convenient for the common workflow of grabbing the latest changes from a remote repository and integrating it with your working copy. However, if you have local changes, <code>pull</code> can cause merge conflicts that you will be forced to resolve. For this reason, it is often safer to <code>fetch</code> first and then decide if a simple merge will suffice.<a data-type="indexterm" data-primary="pull (Git command)" id="idm45310223652736"/></p>
</dd>
<dt><code>push</code></dt>
<dd>
<p>Sends changes to the upstream remote repository from the local repository.
Use this after a <code>commit</code> to push your changes to the upstream repository so other developers can see your changes.<a data-type="indexterm" data-primary="push (Git command)" id="idm45310223649984"/></p>
</dd>
</dl>
</li>
</ul>

<p>Now that you have a basic understanding of the Git commands, let’s put this knowledge into practice.<a data-type="indexterm" data-startref="ch02-cmd" id="idm45310223648400"/></p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Git Command-Line Tutorial"><div class="sect2" id="idm45310223347872">
<h2>Git Command-Line Tutorial</h2>

<p>To demonstrate how to use these commands, <a data-type="indexterm" data-primary="Git" data-secondary="command-line basics" data-tertiary="tutorial" id="idm45310223646032"/><a data-type="indexterm" data-primary="tutorials" data-secondary="Git command line" id="idm45310223644784"/><a data-type="indexterm" data-primary="exercises" data-see="tutorials" id="idm45310223643840"/><a data-type="indexterm" data-primary="repositories" data-secondary="Git commands for management" data-tertiary="tutorial" id="idm45310223642896"/>we will go through a simple example to create a new local repository from scratch.
For this exercise, we are assuming you are on a system with a Bash-like command shell.
This is the default on most Linux distributions as well as macOS.
If you are on Windows, you can do this via Windows PowerShell, which has sufficient aliases to emulate Bash for basic commands.</p>

<p>If this is your first time using Git, it is a good idea<a data-type="indexterm" data-primary="Git" data-secondary="name and email for version control" id="idm45310223640704"/> to put in your name and email, which will be associated with all of your version control operations.
You can do this with the following commands:</p>
<pre data-type="programlisting"><strong>git config --global user.name <em>"Put Your Name Here"</em></strong>
</pre>
<pre data-type="programlisting"><strong>git config --global user.email <em>"your@email.address"</em></strong>
</pre>

<p>After configuring your personal information, go to a suitable directory to create your working project.
First, create the project folder and initialize the repository:</p>
<pre data-type="programlisting"><strong>mkdir tutorial</strong>
</pre>
<pre data-type="programlisting"><strong>cd tutorial</strong>
</pre>
<pre data-type="programlisting"><strong>git init</strong>
</pre>

<p>This creates the repository and initializes it so you can start tracking revisions of files.
Let’s create a new file that we can add to revision control:</p>
<pre data-type="programlisting"><strong>echo "This is a sample file" &gt; sample.txt</strong>
</pre>

<p>To add this file to revision control, use the <code>git add</code> command as follows:</p>
<pre data-type="programlisting"><strong>git add sample.txt</strong>
</pre>

<p>And you can add this file to version control by using the <code>git commit</code> command:</p>
<pre data-type="programlisting"><strong>git commit sample.txt -m "First git commit!"</strong>
</pre>

<p>Congratulations on making your first command-line commit using Git!
You can double-check to make sure that your file is being tracked in revision control by using the <code>git log</code> command, which should return output similar to the following:</p>

<pre data-type="programlisting">commit 0da1bd4423503bba5ebf77db7675c1eb5def3960 (HEAD -&gt; master)
Author: Stephen Chin &lt;steveonjava@gmail.com&gt;
Date:   Sat Mar 12 04:19:08 2022 -0700

    First git commit!</pre>

<p>From this, you can see some of the details that Git stores in the repository, including branch information (the default branch is <code>master</code>), and revisions by globally unique identifiers (GUIDs).
Though you can do a lot more from the command line, it is often easier to use a Git client built for your workflow or IDE integration that is designed for a developer workflow.
The next couple of sections talk about these client options.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Git Clients"><div class="sect2" id="idm45310223647104">
<h2>Git Clients</h2>

<p>Several free and open source clients that you can use<a data-type="indexterm" data-primary="Git" data-secondary="clients" id="ch02-clients"/> to work with Git repos more easily are optimized for various different workflows.
Most clients do not try to do everything, but specialize in visualizations and functionality for specific workflows.</p>

<p>The default Git installation comes with a couple of handy visual tools that make committing and viewing history easier.
These tools are written in Tcl/Tk, are cross-platform, and are easily launched from the command line to supplement the Git command-line interface (CLI).</p>

<p>The first tool, <code>gitk</code>, provides an alternative<a data-type="indexterm" data-primary="gitk" id="idm45310223620624"/> to the command line for navigating, viewing, and searching the Git history of your local repository.
The <code>gitk</code> user interface displaying the history for the ScalaFX open source project is shown in <a data-type="xref" href="#gitk">Figure 2-9</a>.</p>

<figure><div id="gitk" class="figure">
<img src="Images/dtjd_0209.png" alt="User interface showing Git history visually via split panes with graphs and revision data" width="600" height="372"/>
<h6><span class="label">Figure 2-9. </span>The bundled Git history viewer application</h6>
</div></figure>

<p>The top pane of <code>gitk</code> displays the revision history with branching information drawn visually, which can be useful for deciphering complicated branch history.
Below this are search filters that can be used to find commits containing specific text.
Finally, for the selected changeset, you can see the changed files and a textual diff of the changes, which is also searchable.</p>

<p>The other tool that comes bundled<a data-type="indexterm" data-primary="git-gui" id="idm45310225352240"/> with Git is <code>git-gui</code>.
Unlike <code>gitk</code>, which only shows information about the repository history, <code>git-gui</code> allows you to modify the repository by executing many of the Git commands including <code>commit</code>, <code>push</code>, <code>branch</code>, <code>merge</code>, and others.</p>

<p><a data-type="xref" href="#git-gui">Figure 2-10</a> shows the <code>git-gui</code> user interface<a data-type="indexterm" data-primary="GUI interface for Git" data-secondary="git-gui client" id="idm45310225346912"/> for editing the source code repository for this book.
On the left side, all of the changes to the working copy are shown, with the unstaged changes on top and the files that will be included in the next commit on the bottom.
The details for the selected file are shown on the right side with the full file contents for new files, or a diff for modified files.
At the bottom right, buttons are provided for common operations like Rescan, Sign Off, Commit, and Push.
Further commands are available in the menu for advanced operations like branching, merging, and remote repository management.</p>

<figure><div id="git-gui" class="figure">
<img src="Images/dtjd_0210.png" alt="Screenshot of the bundled Git UI for reviewing and committing code" width="600" height="348"/>
<h6><span class="label">Figure 2-10. </span>The bundled Git collaboration application</h6>
</div></figure>

<p><code>git-gui</code> is an example of a workflow-driven user interface for Git.
It doesn’t expose the full set of functionality available on the command line, but is convenient for the commonly used Git workflows.</p>

<p>Another example of a workflow-driven user interface<a data-type="indexterm" data-primary="GitHub Desktop" id="idm45310225342416"/> is <em>GitHub Desktop</em>.
This is the most popular third-party GitHub user interface, and as mentioned earlier, also conveniently comes bundled with the command-line tools so you can use it as an installer for the Git CLI and aforementioned bundled GUIs.</p>

<p>GitHub Desktop is similar to <code>git-gui</code>, but is optimized for integration with GitHub’s service, and the user interface is designed to make it easy to follow workflows similar to GitHub Flow.
The GitHub Desktop user interface editing the source repository for another great book, <em>The Definitive Guide to Modern Java Clients with JavaFX</em>, is shown in <a data-type="xref" href="#github_desktop">Figure 2-11</a>.</p>

<figure><div id="github_desktop" class="figure">
<img src="Images/dtjd_0211.png" alt="Screenshot of the GitHub Desktop user interface" width="600" height="411"/>
<h6><span class="label">Figure 2-11. </span>GitHub’s open source desktop client</h6>
</div></figure>

<p>In addition to the same sort of capabilities as <code>git-gui</code> to view changes, commit revisions, and pull/push code, GitHub Desktop has a bunch of advanced features that make managing your code much easier:</p>

<ul>
<li>
<p>Commit attribution</p>
</li>
<li>
<p>Syntax highlighted diffs</p>
</li>
<li>
<p>Image diff support</p>
</li>
</ul>

<ul class="pagebreak-before">
<li>
<p>Editor and shell integration</p>
</li>
<li>
<p>CI status of pull requests</p>
</li>
</ul>

<p>GitHub Desktop can be used with any Git repo, but has features tailored specifically for use with GitHub-hosted repositories.
Here are some other popular Git tools:</p>
<dl>
<dt><a href="https://www.sourcetreeapp.com">Sourcetree</a></dt>
<dd>
<p>A free, but proprietary, Git client made by Atlassian.
It is a good alternative to GitHub Desktop and has only a slight bias toward Atlassian’s Git service, Bitbucket.<a data-type="indexterm" data-primary="Sourcetree Git client (Atlassian)" id="idm45310225326944"/><a data-type="indexterm" data-primary="Atlassian Sourcetree Git client" id="idm45310225326224"/></p>
</dd>
<dt><a href="https://www.gitkraken.com">GitKraken Client</a></dt>
<dd>
<p>A commercial and featureful Git client.
It is free for open source developers, but paid for commercial use.<a data-type="indexterm" data-primary="GitKraken Client" id="idm45310225323712"/></p>
</dd>
<dt><a href="https://tortoisegit.org">TortoiseGit</a></dt>
<dd>
<p>A free, GNU Public License (GPL), Git client based on TortoiseSVN.
The only downside is that it is Windows only.<a data-type="indexterm" data-primary="TortoiseGit" id="idm45310225321200"/></p>
</dd>
<dt>Others</dt>
<dd>
<p>A full list of Git GUI clients is maintained<a data-type="indexterm" data-primary="Git" data-secondary="clients" data-tertiary="list on website" id="idm45310225319152"/><a data-type="indexterm" data-primary="resources for learning" data-secondary="Git" data-tertiary="clients list" id="idm45310225317904"/> on the <a href="https://oreil.ly/JPi0J">Git website</a>.</p>
</dd>
</dl>

<p>Git desktop clients are a great addition to the arsenal of available source control management tools you have available.
However, the most useful Git interface may already be at your fingertips, right inside your IDE.<a data-type="indexterm" data-startref="ch02-clients" id="idm45310225314928"/></p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Git IDE Integration"><div class="sect2" id="idm45310223624560">
<h2>Git IDE Integration</h2>

<p>Many integrated development environments (IDEs) include<a data-type="indexterm" data-primary="Git" data-secondary="IDE integration" id="ch02-gitide"/><a data-type="indexterm" data-primary="IDEs" data-secondary="Git IDE integration" id="ch02-gitide2"/> Git support either as a standard feature, or as a well-supported plug-in.
Chances are that you need to go no further than your favorite IDE to do basic version control operations like adding, moving, and removing files, committing code, and pushing your changes to an upstream repository.</p>

<p>One of the most popular Java IDEs is JetBrains IntelliJ IDEA.<a data-type="indexterm" data-primary="IDEs" data-secondary="JetBrains IntelliJ IDEA" id="idm45310225037904"/><a data-type="indexterm" data-primary="JetBrains IntelliJ IDEA" id="idm45310225036928"/>
It has a Community Edition that is open source as well as a commercial version with additional features for enterprise developers.
The IntelliJ Git support is full featured, with the ability to sync changes from a remote repository, track and commit changes performed in the IDE, and integrate upstream changes.
The integrated Commit tab for a Git changeset is shown in <a data-type="xref" href="#intellij_git_commit">Figure 2-12</a>.</p>

<figure><div id="intellij_git_commit" class="figure">
<img src="Images/dtjd_0212.png" alt="Screenshot of the IntelliJ commit tab" width="600" height="351"/>
<h6><span class="label">Figure 2-12. </span>IntelliJ Commit tab for managing working copy changes</h6>
</div></figure>

<p>IntelliJ offers a rich set of features that you can use to customize the Git behavior to your team workflow.
For example, if your team prefers a git-flow or GitHub Flow workflow, you can choose to merge on update (more details on Git workflows in the next section).
However, if your team wants to keep a linear history as prescribed in OneFlow, you can choose to rebase on update instead.
IntelliJ also supports the native credential provider as well as the open source KeePass password manager.</p>

<p>Another IDE that offers great Git support<a data-type="indexterm" data-primary="IDEs" data-secondary="Eclipse IDE" id="idm45310225032000"/><a data-type="indexterm" data-primary="Eclipse" data-secondary="IDE with Git support" id="idm45310225031024"/> is Eclipse, a fully open source IDE that has strong community support and is run by the Eclipse Foundation.
The Eclipse Git support is provided<a data-type="indexterm" data-primary="EGit" id="idm45310225029792"/><a data-type="indexterm" data-primary="JGit" id="idm45310225029120"/> by the EGit project, which is based on JGit, a pure Java implementation of the Git version control system.</p>

<p>Because of the tight integration with the embedded Java implementation of Git, Eclipse has the most full-featured Git support.
From the Eclipse user interface, you can accomplish almost everything that you would normally have to do from the command line, including rebasing, cherry-picking, tagging, patching, and more.
The rich set of features is obvious from the Preferences dialog, shown in <a data-type="xref" href="#eclipse_git">Figure 2-13</a>. This dialog has 12 configuration pages detailing how the Git integration works and is supported by a user guide that is almost a book itself at 161 pages.</p>

<figure><div id="eclipse_git" class="figure">
<img src="Images/dtjd_0213.png" alt="Screenshot of the Eclipse settings dialog for Git configuration" width="600" height="388"/>
<h6><span class="label">Figure 2-13. </span>Eclipse Preferences dialog for Git configuration</h6>
</div></figure>

<p>Other Java IDEs that you can expect great Git support from include the following:</p>
<dl>
<dt>NetBeans</dt>
<dd>
<p>Offers a Git plug-in that fully supports workflow from the IDE.<a data-type="indexterm" data-primary="IDEs" data-secondary="NetBeans IDE" id="idm45310225022736"/><a data-type="indexterm" data-primary="NetBeans IDE" id="idm45310225021760"/></p>
</dd>
<dt>Visual Studio Code</dt>
<dd>
<p>Supports Git along with other version control systems out of the box.<a data-type="indexterm" data-primary="IDEs" data-secondary="Visual Studio Code" id="idm45310225019808"/><a data-type="indexterm" data-primary="Visual Studio (Microsoft)" data-secondary="Code support of Git" id="idm45310225018832"/><a data-type="indexterm" data-primary="Microsoft Visual Studio Code" id="idm45310225017872"/></p>
</dd>
<dt>BlueJ</dt>
<dd>
<p>A popular learning IDE built by King’s College London also supports Git in its team workflows.<a data-type="indexterm" data-primary="IDEs" data-secondary="BlueJ IDE" id="idm45310225015792"/><a data-type="indexterm" data-primary="BlueJ IDE" id="idm45310225014816"/></p>
</dd>
<dt>Oracle JDeveloper</dt>
<dd>
<p>While it doesn’t support complicated workflows, JDeveloper does have basic support for cloning, committing, and pushing to Git repos.<a data-type="indexterm" data-primary="IDEs" data-secondary="Oracle JDeveloper" id="idm45310225012720"/><a data-type="indexterm" data-primary="Oracle JDeveloper support of Git" id="idm45310225011744"/><a data-type="indexterm" data-primary="JDeveloper (Oracle) support of Git" id="idm45310225011056"/></p>
</dd>
</dl>

<p>So far in this chapter, you have added a whole set of new command-line, desktop, and integrated tools to your arsenal to work with Git repos.
This range of community- and industry-supported tools means that no matter your operating system, project workflow, or even team preference, you will find full tooling support to be successful with your source control management. The next section goes into more detail on collaboration patterns that are well supported by the full range of Git tools.<a data-type="indexterm" data-startref="ch02-gitide" id="idm45310225009728"/><a data-type="indexterm" data-startref="ch02-gitide2" id="idm45310225009024"/></p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Git Collaboration Patterns"><div class="sect1" id="git_collab_patterns">
<h1>Git Collaboration Patterns</h1>

<p>DVCSs have a proven track record of scaling to extremely large teams with hundreds of collaborators.<a data-type="indexterm" data-primary="Git" data-secondary="collaboration" data-tertiary="workflows" id="ch02-work"/><a data-type="indexterm" data-primary="collaboration" data-secondary="Git distributed version control system" data-tertiary="workflows" id="ch02-work2"/><a data-type="indexterm" data-primary="workflows" data-secondary="Git collaboration patterns" id="ch02-work3"/><a data-type="indexterm" data-primary="version control systems" data-secondary="distributed version control systems" data-tertiary="scaling well for large teams" id="idm45310225002048"/><a data-type="indexterm" data-primary="distributed version control systems (DVCSs)" data-secondary="scaling well for large teams" id="idm45310225000800"/>
At this scale, it is necessary to agree on uniform collaboration patterns that help the team avoid rework, avoid large and unwieldy merges, and reduce the amount of time blocked on administering the version control history.</p>

<p>Most projects follow a central repository model: <a data-type="indexterm" data-primary="Git" data-secondary="central repository model" id="idm45310224999056"/><a data-type="indexterm" data-primary="repositories" data-secondary="central server pattern" id="idm45310224998064"/>a single repository is designated as the official repository for integrations, builds, and releases.
Even though a DVCS allows for noncentralized peer-to-peer exchanges of revisions, these are best reserved for short-lived efforts among a small number of developers.
For any large project, having a single system of truth is important and requires one repository that everyone agrees is the official codeline.</p>

<p>For open source projects, it is common for a<a data-type="indexterm" data-primary="fork (Git)" data-secondary="central repository model" id="idm45310224996544"/><a data-type="indexterm" data-primary="pull (Git command)" data-secondary="pull requests in central repository model" id="idm45310224995552"/> limited set of developers to have write access to the central repository, while other committers <em>fork</em> the project and issue pull requests to have their changes included.
Best practices are to have small pull requests, and to have someone other than the pull request creator accept them.
This scales well to projects with thousands of contributors, and allows for review and oversight from a core team when the codebase is not well understood.</p>

<p>However, for most corporate projects, a shared repository with a single master branch is preferred.<a data-type="indexterm" data-primary="branch (Git command)" data-secondary="workflow practices" id="idm45310224915024"/>
The same workflow with pull requests can be used to keep a central or release branch clean, but this simplifies the contribution process and encourages more frequent integration, which reduces the size and difficulty of merging in changes.
For teams on tight deadlines or following an Agile process with short iterations, this also reduces the risk of last-minute integration failures.</p>

<p>The last best practice employed by most teams is to use branches to work on features, which then get integrated back into the main codeline.
Git makes it inexpensive to create short-lived branches, so it is common to create and merge back in a branch for work that takes only a couple of hours.
The risk with creating long-lived feature branches is that if they diverge too much from the main trunk of code development, they can become difficult to integrate back in.</p>

<p>Following these general best practices for distributed version control, several collaboration models have emerged.
They share a lot of commonalities and primarily diverge in their approach to branching, history management, and integration speed.</p>








<section data-type="sect2" data-pdf-bookmark="git-flow"><div class="sect2" id="idm45310224912736">
<h2>git-flow</h2>

<p><em>Git-flow</em> is one of the earliest Git workflows<a data-type="indexterm" data-primary="git-flow" id="ch02-gitflow"/> and was inspired by a <a href="https://oreil.ly/v6aI4">blog post</a> from Vincent Driessen.
It laid the groundwork for later Git collaboration workflows like GitHub Flow; however, git-flow is a more complicated workflow than most projects require and can add additional branch management and integration work.</p>

<p>Key attributes include the following:</p>
<dl>
<dt>Development branches</dt>
<dd>
<p>Branch per feature</p>
</dd>
<dt>Merge strategy</dt>
<dd>
<p>No fast-forward merges</p>
</dd>
<dt>Rebasing history</dt>
<dd>
<p>No rebasing</p>
</dd>
<dt>Release strategy</dt>
<dd>
<p>Separate release branch</p>
</dd>
</dl>

<p>In git-flow, there are two long-lived branches: one for development integration, called <em>develop</em>, and another for final releases, called <em>master</em>.
Developers are expected to do all of their coding in feature branches that are named according to the feature they are working on and integrate that with the develop branch once complete.
When the develop branch has the features necessary for a release, a new release branch is created that is used to stabilize the codebase with patches and bugfixes.</p>

<p>Once the release branch has stabilized and is ready for release, it is integrated into the master branch and given a release tag.
Once on the master, only hotfixes are applied, which are small changes managed on a dedicated branch.
These hotfixes also need to be applied back to the develop branch and any other concurrent releases that need the same fix.
<a data-type="xref" href="#git_flow_diagram">Figure 2-14</a> shows a sample diagram for git-flow.</p>

<p>Because of the design decisions on git-flow, it tends to create a complicated merge history.
By not taking advantage of fast-forward merges or rebasing, every integration becomes a commit, and the number of concurrent branches can be hard to follow even with visual tools.
Also, the complicated rules and branch strategy require team training and are difficult to enforce with tools, often requiring check-ins and integration to be done from the command-line interface.</p>
<div data-type="tip"><h6>Tip</h6>
<p>Git-flow is best applied to explicitly versioned projects that have multiple releases needing to be maintained in parallel.
Usually, this is not the case for web applications, which have only one <em>latest</em> version and can be managed with a single release branch.</p>
</div>

<figure><div id="git_flow_diagram" class="figure">
<img src="Images/dtjd_0214.png" alt="Diagram showing branches and integrations over time" width="600" height="770"/>
<h6><span class="label">Figure 2-14. </span>Managing branches and integration with git-flow <a href="https://oreil.ly/baH6Z">(source: Vincent Driessen, Creative Commons BY-SA)</a></h6>
</div></figure>

<p>If your project is in the sweet spot where git-flow excels, it is a very well-thought-out collaboration model. Otherwise, you may find that a simpler collaboration model will suffice.<a data-type="indexterm" data-startref="ch02-gitflow" id="idm45310224893968"/></p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="GitHub Flow"><div class="sect2" id="idm45310224912112">
<h2>GitHub Flow</h2>

<p><em>GitHub Flow</em> is a simplified Git workflow<a data-type="indexterm" data-primary="GitHub Flow" id="idm45310224891392"/><a data-type="indexterm" data-primary="Chacon, Scott" id="idm45310224890688"/> launched in response to the complexity of git-flow by Scott Chacon in another prominent <a href="https://oreil.ly/l7gTx">blog</a>.
GitHub Flow or a close variant has been adopted by most development teams, since it is easier to implement in practice, handles the common case for continuous released web development, and is well supported by tools.</p>

<p>Key attributes include the following:</p>
<dl>
<dt>Development branches</dt>
<dd>
<p>Branch per feature</p>
</dd>
<dt>Merge strategy</dt>
<dd>
<p>No fast-forward merges</p>
</dd>
<dt>Rebasing history</dt>
<dd>
<p>No rebasing</p>
</dd>
<dt>Release strategy</dt>
<dd>
<p>No separate release branches</p>
</dd>
</dl>

<p>GitHub Flow takes a simple approach to branch management, using <em>master</em> as the main codeline as well as the release branch.
Developers do all of their work on short-lived feature branches and integrate them back into the master as soon as their code passes tests and code reviews.</p>
<div data-type="tip"><h6>Tip</h6>
<p>In general, GitHub Flow makes good use of available tooling by having a straightforward workflow with a simple branching strategy and no use of complicated arguments to enable fast-forward merges or replace merges with rebasing. Developers who are not familiar with the team process or not as familiar with the command-line Git interface therefore find GitHub Flow easy to use.</p>
</div>

<p>The GitHub Flow collaboration model works well for server-side and cloud-deployed applications, where the only meaningful version is the latest release.
In fact, GitHub Flow recommends that teams continuously deploy to production to avoid feature stacking, in which a single release build has multiple features that increase complexity and make it harder to determine the breaking change.
However, for more complicated workflows with multiple concurrent releases, GitHub Flow needs to be modified to accommodate.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="GitLab Flow"><div class="sect2" id="idm45310224879392">
<h2>GitLab Flow</h2>

<p><em>GitLab Flow</em> is basically an extension<a data-type="indexterm" data-primary="GitLab Flow" id="idm45310224877696"/> of GitHub Flow, as documented on GitLab’s <a href="https://oreil.ly/P1LzH">website</a>.
It takes the same core design principles about using a master as a single long-lived branch and doing the majority of development on feature branches.
However, it adds a few extensions to support release branches and history cleanup that many teams have adopted as best practices.</p>

<p>Key attributes include the following:</p>
<dl>
<dt>Development branches</dt>
<dd>
<p>Branch per feature</p>
</dd>
<dt>Merge strategy</dt>
<dd>
<p>Open-ended</p>
</dd>
<dt>Rebasing history</dt>
<dd>
<p>Optional</p>
</dd>
<dt>Release strategy</dt>
<dd>
<p>Separate release branches</p>
</dd>
</dl>

<p>The key difference between GitHub Flow and GitLab Flow is the addition of release branches.
This is recognition that most teams are not practicing continuous deployment at the level GitHub does.
Having release branches allows stabilization of code before it gets pushed into production; however, GitLab Flow recommends making patches to the master and then cherry-picking them for release rather than having an extra hotfix branch like git-flow.</p>

<p>The other significant difference is the willingness to edit history using <code>rebase</code> and <code>squash</code>.
By cleaning up the history before committing to master, it is easier to retroactively go back and read the history to discover when key changes or bugs were introduced.
However, this involves rewriting the local history and can be dangerous when that history has already been pushed to the central repository.</p>
<div data-type="tip"><h6>Tip</h6>
<p>GitLab Flow is a modern take on the GitHub Flow philosophy to collaboration workflow, but ultimately your team has to decide on the features and branch strategy based on your project’s needs.</p>
</div>
</div></section>













<section data-type="sect2" class="less_space pagebreak-before" data-pdf-bookmark="OneFlow"><div class="sect2" id="idm45310224063328">
<h2>OneFlow</h2>

<p><em>OneFlow</em>, another collaboration workflow<a data-type="indexterm" data-primary="OneFlow" id="idm45310224061232"/><a data-type="indexterm" data-primary="Ruka, Adam" id="idm45310224060528"/> based on git-flow, was proposed by Adam Ruka and introduced in a detailed <a href="https://oreil.ly/euJ37">blog</a>.
OneFlow makes the same adaptation as GitHub/GitLab Flow in squashing the separate develop branch in favor of feature branches and direct integration on the main branch.
However, it keeps the release and hotfix branches that are used in git-flow.</p>

<p>Key attributes include the following:</p>
<dl>
<dt>Development branches</dt>
<dd>
<p>Branch per feature</p>
</dd>
<dt>Merge strategy</dt>
<dd>
<p>No fast-forward merges without rebase</p>
</dd>
<dt>Rebasing history</dt>
<dd>
<p>Rebasing recommended</p>
</dd>
<dt>Release strategy</dt>
<dd>
<p>Separate release branches</p>
</dd>
</dl>

<p>The other big deviation in OneFlow is that it heavily favors modifying history to keep the Git revision history readable.
It offers three merge strategies that have varying levels of revision cleanliness and rollback friendliness:</p>
<dl>
<dt>Rebase</dt>
<dd>
<p>This makes the merge history mostly linear and easy to follow.
It has the usual caveat that changesets pushed to the central server should not be rebased and makes it more difficult to roll back changes since they are not captured in a single commit.</p>
</dd>
<dt>merge -no-ff</dt>
<dd>
<p>This is the same strategy used in git-flow and has the disadvantage that the merge history is largely nonsequential and difficult to follow.</p>
</dd>
<dt>rebase + merge -no-ff</dt>
<dd>
<p>This is a rebase workaround that tacks on an extra merge integration at the end so it can be rolled back as a unit even though it is still mostly sequential.</p>
</dd>
</dl>
<div data-type="tip"><h6>Tip</h6>
<p>OneFlow is a thoughtful approach to a Git collaboration workflow that is created from the experience of developers on large enterprise projects.
It can be seen as a modern variant on git-flow that should serve the needs of projects of any size.</p>
</div>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Trunk-Based Development"><div class="sect2" id="idm45310224045232">
<h2>Trunk-Based Development</h2>

<p>All of the aforementioned approaches are variants<a data-type="indexterm" data-primary="branch (Git command)" data-secondary="workflow practices" data-tertiary="trunk-based development" id="idm45310224043760"/><a data-type="indexterm" data-primary="trunk-based development in Git" id="idm45310224042512"/> of the feature branch development model; all active development is done on branches that get merged into either the master or a dedicated development branch.
They take advantage of the great support Git has for branch management, but if features are not granular enough, they suffer from the typical integration problems that have plagued teams for decades.
The longer the feature branch is in active development, the higher the likelihood for merge conflicts with other features and maintenance going on in the master branch (or trunk).</p>

<p><em>Trunk-based development</em> solves this problem by recommending that all development happen on the main branch with very short integrations that occur anytime that tests are passing, but not necessarily waiting for a full feature to be completed.</p>

<p>Key attributes include the following:</p>
<dl>
<dt>Development branches</dt>
<dd>
<p>Optional, but no long-lived branches</p>
</dd>
<dt>Merge strategy</dt>
<dd>
<p>Only if using development branches</p>
</dd>
<dt>Rebasing history</dt>
<dd>
<p>Rebasing recommended</p>
</dd>
<dt>Release strategy</dt>
<dd>
<p>Separate release branches</p>
</dd>
</dl>

<p>Paul Hammant, a strong advocate for trunk-based development,<a data-type="indexterm" data-primary="Hammant, Paul" id="idm45310224034080"/><a data-type="indexterm" data-primary="resources for learning" data-secondary="Git" data-tertiary="trunk-based development" id="idm45310224033376"/> has set up a <a href="https://oreil.ly/HFo0J">full website</a> and written a book on the topic.
While this is not a new approach to collaboration on source control management systems, it is a proven approach to Agile development in large teams and works equally well on classic central SCMs like CVS and Subversion, and modern DVCSs like Git.<a data-type="indexterm" data-startref="ch02-work" id="idm45310224031040"/><a data-type="indexterm" data-startref="ch02-work2" id="idm45310224030336"/><a data-type="indexterm" data-startref="ch02-work3" id="idm45310224029664"/></p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Summary"><div class="sect1" id="idm45310225007760">
<h1>Summary</h1>

<p>Good source control systems and practices lay the foundation for a solid DevOps approach to building, releasing, and deploying code quickly.
In this chapter, we discussed the history of source control systems and explained why the world has moved to embrace distributed version control.</p>

<p>This consolidation has built a rich ecosystem of source control servers, developer tools, and commercial integrations.
Finally, through the adoption of distributed version control by DevOps thought leaders, best practices and collaboration workflows have been established that you can follow to help make your team successful with adopting a modern SCM.</p>

<p>In the next few chapters, we will drill into systems that connect to your source control management system, including continuous integration, package management, and security scanning, that allow you to rapidly deploy to traditional or cloud native environments.
You are on the way to building a comprehensive DevOps platform that will support whatever workflow you need to meet your quality and deployment objectives.</p>
</div></section>







</div></section></div></body></html>