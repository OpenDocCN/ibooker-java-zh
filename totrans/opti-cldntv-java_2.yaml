- en: Chapter 3\. Overview of the JVM
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。JVM概述
- en: There is no doubt that Java is one of the largest technology platforms on the
    planet—​the best available estimate is of over 10+ million developers working
    with Java.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，Java是全球最大的技术平台之一——目前最佳估计是有超过10百万的开发者在使用Java。
- en: The design of the Java system is *fully managed* --aspects such as garbage collection
    and execution optimization are controlled by the JVM on behalf of developers.
    The fact that Java is consciously aimed at mainstream developers, when combined
    with the fully-managed platform, leads to a situation in which many developers
    do not need to know about the low-level intricacies of the platform they work
    with on a daily basis. As a result, developers may not meet these internal aspects
    very frequently—​but only when an issue such as a customer complaining about a
    performance problem arises.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Java系统的设计是*完全管理*的——像垃圾收集和执行优化等方面是由JVM代表开发者控制的。Java专门面向主流开发者，加上完全管理的平台，导致许多开发者在日常工作中不需要了解平台的低级复杂性。因此，开发者可能并不经常接触到这些内部方面——只有在出现例如客户投诉性能问题的情况时才会涉及。
- en: For developers who are interested in performance, however, it is important to
    understand the basics of the JVM technology stack. Understanding JVM technology
    enables developers to write better software and provides the theoretical background
    required for investigating performance-related issues.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于对性能感兴趣的开发者来说，了解JVM技术栈的基础是非常重要的。理解JVM技术使开发者能够编写更好的软件，并提供了调查与性能相关问题所需的理论背景。
- en: This chapter introduces how the JVM executes Java in order to provide a basis
    for deeper exploration of these topics later in the book. In particular, Chapter
    6 has an in-depth treatment of bytecode, which is complementary to the discussion
    here.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了JVM如何执行Java，为后面更深入地探讨这些主题提供了基础。特别是第六章对字节码进行了深入讨论，这与此处的讨论互补。
- en: We suggest that you read through this chapter, but come back to it for a second
    pass after you have read Chapter 6.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议您先阅读本章，但在阅读完第六章后再回来复习一遍。
- en: Interpreting and Classloading
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释与类加载
- en: According to the specification that defines the Java Virtual Machine (usually
    called the VM Spec), the JVM is a stack-based interpreted machine. This means
    that rather than having registers (like a physical hardware CPU), it uses an execution
    stack of partial results and performs calculations by operating on the top value
    (or values) of that stack.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 根据定义Java虚拟机的规范（通常称为VM规范），JVM是一个基于堆栈的解释机器。这意味着它不像物理硬件CPU那样有寄存器，而是使用部分结果的执行堆栈，并通过对堆栈顶部值（或值）进行操作来执行计算。
- en: If you’re not familiar with how interpreters work, then you can think of the
    basic behavior of the JVM interpreter as essentially “a `switch` inside a `while`
    loop”. The interpreter processes each opcode of the program independently of the
    last, and uses the evaluation stack to hold the results of computations and as
    intermediate results.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对解释器的工作原理不熟悉，那么您可以将JVM解释器的基本行为想象为“`switch`在`while`循环内”。解释器独立处理程序的每个操作码，并使用评估堆栈来保存计算结果和中间结果。
- en: Note
  id: totrans-9
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: As we will see when we delve into the internals of the Oracle/OpenJDK VM (HotSpot),
    the situation for real production-grade Java interpreters is more complex, but
    *switch-inside-while* using a stack interpreter is an acceptable mental model
    for the moment.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们深入研究Oracle/OpenJDK VM（HotSpot）的内部时，我们将看到真实的生产级Java解释器的情况更加复杂，但在此时使用堆栈解释器内部的“switch-inside-while”作为一个可接受的心理模型。
- en: When we launch our application using the `java HelloWorld` command, the operating
    system starts the virtual machine process (the `java` binary). This sets up the
    Java virtual environment and initializes the interpreter that will actually execute
    the user code in the `HelloWorld.class` file.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`java HelloWorld`命令启动我们的应用程序时，操作系统会启动虚拟机进程（`java`二进制文件）。这设置了Java虚拟环境并初始化了实际执行`HelloWorld.class`文件中用户代码的解释器。
- en: The entry point into the application will be the `main()` method of `HelloWorld.class`.
    In order to hand over control to this class, it must be loaded by the virtual
    machine before execution can begin.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的入口点将是`HelloWorld.class`的`main()`方法。为了将控制权交给这个类，在执行之前必须由虚拟机加载它。
- en: To achieve this, the Java classloading mechanism is used. When a new Java process
    is initializing, a chain of classloaders is used. The initial loader is known
    as the Bootstrap classloader (historically also known as the “primordial classloader”)
    and it loads classes in the core Java runtime. The main point of the Bootstrap
    classloader is to get a minimal set of classes (which includes essentials such
    as `java.lang.Object`, `Class`, and `Classloader`) loaded to allow other classloaders
    to bring up the rest of the system.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: At this point it is also instructive to discuss a little bit of how the Java
    modules system (sometimes referred to as JPMS) has somewhat changed the picture
    of application startup. First of all, from Java 9 onwards, all JVMs are modular—​there
    is no “compatibility” or “classic” mode that restores the Java 8 monolithic JVM
    runtime.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: This means that during startup a module graph is always constructed—​even if
    the application itself is non-modular. This must be a Directed Acyclic Graph (DAG),
    and it is a fatal error if the application’s module metadata attempts to construct
    a module graph that contains a cycle.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'The module graph has various advantages, including:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Only required modules are loaded
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inter-module metadata can be confirmed to be good at startup time
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The module graph has a main module, which is where the entrypoint class lives.
    If the application has not yet been fully modularized, then it will have both
    a modulepath and a classpath, and the application code may be in the `UNNAMED`
    module.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-20
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Full details of the modules system are outside the scope of this book. An expanded
    treatment can be found in [*Java in a Nutshell (8th Edition)*](https://www.oreilly.com/library/view/java-in-a/9781098130992/)
    by Benjamin J. Evans, Jason Clark and David Flanagan (O’Reilly) or a more in-depth
    reference, such as [*Java 9 Modularity*](https://www.oreilly.com/library/view/java-9-modularity/9781491954157/)
    by Sander Mak and Paul Bakker (O’Reilly).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: In practice, the work of the Bootstrap classloader involves loading `java.base`
    and some other supporting modules (including some perhaps-surprising entries—​e.g.
    `java.security.sasl` and `java.datatransfer`)
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Java models classloaders as objects within its own runtime and type system,
    so there needs to be some way to bring an initial set of classes into existence.
    Otherwise, there would be a circularity problem in defining what a classloader
    is.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: The Bootstrap classloader does not verify the classes it loads (largely to improve
    startup performance), and it relies on the boot classpath being secure. Anything
    loaded by the bootstrap classloader is granted full security permissions and so
    this group of modules is kept as restricted as possible.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-25
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Legacy versions of Java up to and including 8 used a monolithic runtime, and
    the Bootstrap classloader loaded the contents of `rt.jar`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the base system (i.e. the equivalent of the rest of the old `rt.jar`
    used in version 8 and earlier) is loaded by the *platform classloader*, and is
    available via the method `ClassLoader::getPlatformClassLoader`. It has the Bootstrap
    classloader as its parent, as the old Extension classloader has been removed.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的基础系统（即在版本 8 及更早版本中使用的旧 `rt.jar` 的相当部分）由 *平台类加载器* 加载，并可通过方法 `ClassLoader::getPlatformClassLoader`
    访问。它的父加载器是引导类加载器，因为旧的扩展类加载器已被移除。
- en: In the new modular implementations of Java, far less code is required to bootstrap
    a Java process and accordingly, as much JDK code (now represented as modules)
    as possible has been moved out of the scope of the bootstrap loader and into the
    platform loader instead.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在新的 Java 模块化实现中，启动 Java 进程所需的代码大大减少，因此，尽可能多的 JDK 代码（现在表示为模块）已移出引导加载器的范围，并移到了平台加载器中。
- en: Finally, the Application classloader is created; it is responsible for loading
    user classes from the defined classpath. Some texts unfortunately refer to this
    as the “System” classloader. This term should be avoided, for the simple reason
    that it doesn’t load the system classes (the Bootstrap and Platform classloaders
    do). The Application classloader is encountered extremely frequently, and it has
    the Platform loader as its parent.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，创建了应用程序类加载器；它负责从定义的类路径中加载用户类。不幸的是，有些文本将其称为“系统”类加载器。出于简单的原因，应避免使用这个术语，因为它并不加载系统类（引导类加载器和平台类加载器会这么做）。应用程序类加载器非常常见，并且它的父加载器是平台加载器。
- en: Java loads in dependencies on new classes when they are first encountered during
    the execution of the program. If a classloader fails to find a class, the behavior
    is usually to delegate the lookup to the parent. If the chain of lookups reaches
    the Bootstrap classloader and it isn’t found, a `ClassNotFoundException` will
    be thrown. It is important that developers use a build process that effectively
    compiles with the exact same classpath that will be used in production, as this
    helps to mitigate this potential issue.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Java 在程序执行过程中首次遇到新类时会加载其依赖项。如果类加载器无法找到类，则通常会将查找委托给父加载器。如果查找链达到引导类加载器并且未找到，则会抛出
    `ClassNotFoundException`。开发人员使用与将在生产中使用的完全相同的类路径进行有效编译是非常重要的，因为这有助于减轻这种潜在问题。
- en: Normally, Java only loads a class once and a `Class` object is created to represent
    the class in the runtime environment. However, it is important to realize that
    under some circumstances the same class can be loaded twice by different classloaders.
    As a result, a class in the system is identified by the classloader used to load
    it as well as the fully qualified class name (which includes the package name).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，Java 只会加载一个类一次，并创建一个 `Class` 对象来代表运行时环境中的类。然而，重要的是要意识到，在某些情况下，同一个类可以被不同的类加载器加载两次。因此，系统中的类由加载它的类加载器以及完全限定的类名（包括包名）来标识。
- en: Note
  id: totrans-32
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Some execution contexts, such as application servers (e.g. Tomcat or JBoss EAP)
    display this behavior when multiple tenant applications are present in the server.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些执行环境中，比如应用服务器（例如 Tomcat 或 JBoss EAP），当服务器中存在多个租户应用时会显示此行为。
- en: It is also the case that some tools (e.g. Java agents) can potentially reload
    and retransform classes as part of bytecode weaving—​and such tools are often
    used in monitoring and Observability.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些工具（例如 Java 代理）可以作为字节码织入的一部分重新加载和重转换类——这些工具通常用于监控和可观察性。
- en: Executing Bytecode
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行字节码
- en: It is important to appreciate that Java source code goes through a significant
    number of transformations before execution. The first is the compilation step
    using the Java compiler `javac`, often invoked as part of a larger build process.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 很重要的是要理解，Java 源代码在执行之前经历了大量的转换过程。首先是使用 Java 编译器 `javac` 进行的编译步骤，通常作为更大构建过程的一部分而调用。
- en: The job of `javac` is to convert Java code into *.class* files that contain
    bytecode. It achieves this by doing a fairly straightforward translation of the
    Java source code, as shown in [Figure 3-1](#pracjavaperf-CHP-3-FIG-1). Very few
    optimizations are done during compilation by `javac`, and the resulting bytecode
    is still quite readable and recognizable as Java code when viewed in a disassembly
    tool, such as the standard `javap`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`javac` 的工作是将 Java 代码转换为包含字节码的 *.class* 文件。它通过对 Java 源代码进行相当直接的翻译来实现这一点，如 [图 3-1](#pracjavaperf-CHP-3-FIG-1)
    所示。`javac` 在编译过程中几乎没有进行任何优化，生成的字节码在使用反汇编工具（例如标准的 `javap`）查看时仍然非常清晰和可识别为 Java 代码。'
- en: '![ocnj2 0301](assets/ocnj2_0301.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![ocnj2 0301](assets/ocnj2_0301.png)'
- en: Figure 3-1\. Java class file compilation
  id: totrans-39
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-1\. Java 类文件编译
- en: Bytecode is an intermediate representation that is not tied to a specific machine
    architecture. Decoupling from the machine architecture provides portability, meaning
    already developed (or compiled) software can run on any platform supported by
    the JVM and provides an abstraction from the Java language. This provides our
    first important insight into the way the JVM executes code.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 字节码是一种中间表示，与特定的机器架构无关。与机器架构解耦提供了可移植性，意味着已经开发（或编译）的软件可以在 JVM 支持的任何平台上运行，并且提供了对
    Java 语言的抽象。这为我们对 JVM 执行代码的方式提供了第一个重要的见解。
- en: Note
  id: totrans-41
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The Java language and the Java Virtual Machine are now to a degree independent,
    and so the J in JVM is potentially a little misleading, as the JVM can execute
    any JVM language that can produce a valid class file. In fact, [Figure 3-1](#pracjavaperf-CHP-3-FIG-1)
    could just as easily show the Kotlin compiler `kotlinc` generating bytecode for
    execution on the JVM.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Java 语言和 Java 虚拟机现在在一定程度上是独立的，因此 JVM 中的 J 可能有点误导性，因为 JVM 可以执行任何可以生成有效类文件的 JVM
    语言。实际上，[图 3-1](#pracjavaperf-CHP-3-FIG-1) 可以很容易地展示 Kotlin 编译器 `kotlinc` 生成的字节码用于在
    JVM 上执行。
- en: Regardless of the source code compiler used, the resulting class file has a
    very well-defined structure specified by the VM spec ([Table 3-1](#anatomy-of-class-file)).
    Any class that is loaded by the JVM will be verified to conform to the expected
    format before being allowed to run.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 无论使用哪个源代码编译器，生成的类文件都具有由 VM 规范明确定义的非常清晰的结构。任何由 JVM 加载的类在允许运行之前都将被验证为符合预期格式。
- en: Table 3-1\. Anatomy of a class file
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3-1\. 类文件的解剖
- en: '| Component | Description |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 组件 | 描述 |'
- en: '| --- | --- |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Magic number | `0xCAFEBABE` |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 魔数 | `0xCAFEBABE` |'
- en: '| Version of class file format | The minor and major versions of the class
    file |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 类文件格式的版本 | 类文件的次要和主要版本 |'
- en: '| Constant pool | The pool of constants for the class |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 常量池 | 类的常量池 |'
- en: '| Access flags | Whether the class is abstract, static, and so on |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 访问标志 | 类是否为抽象的、静态的等等 |'
- en: '| This class | The name of the current class |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 这个类 | 当前类的名称 |'
- en: '| Superclass | The name of the superclass |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 超类 | 超类的名称 |'
- en: '| Interfaces | Any interfaces in the class |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 接口 | 类中的任何接口 |'
- en: '| Fields | Any fields in the class |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| 字段 | 类中的任何字段 |'
- en: '| Methods | Any methods in the class |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 类中的任何方法 |'
- en: '| Attributes | Any attributes of the class (e.g., name of the source file,
    etc.) |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 类的任何属性（例如，源文件的名称等） |'
- en: Every class file starts with the magic number `0xCAFEBABE`, the first 4 bytes
    in hexadecimal serving to denote conformance to the class file format. The following
    4 bytes represent the minor and major versions used to compile the class file,
    and these are checked to ensure that the version of the JVM is not of a lower
    version than the one used to compile the class file. The major and minor version
    are checked by the classloader to ensure compatibility; if these are not compatible
    an `UnsupportedClassVersionError` will be thrown at runtime, indicating the runtime
    is a lower version than the compiled class file.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 每个类文件以魔数 `0xCAFEBABE` 开头，这是16进制中的前4个字节，用于表示符合类文件格式。接下来的4个字节表示用于编译类文件的次要版本和主要版本，这些版本会被检查以确保
    JVM 的版本不低于用于编译类文件的版本。类加载器会检查次要和主要版本以确保兼容性；如果不兼容，则会在运行时抛出 `UnsupportedClassVersionError`，表示运行时低于编译的类文件版本。
- en: Note
  id: totrans-58
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Magic numbers provide a way for Unix environments to identify the type of a
    file (whereas Windows will typically use the file extension). For this reason,
    they are difficult to change once decided upon. Unfortunately, this means that
    Java is stuck using the rather embarrassing and sexist `0xCAFEBABE` for the foreseeable
    future, although Java 9 introduced the magic number `0xCAFEDADA` for module files.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 魔数为Unix环境提供了一种识别文件类型的方式（而Windows通常会使用文件扩展名）。因此，一旦确定，它们很难更改。不幸的是，这意味着Java在可预见的将来将继续使用相当尴尬和性别歧视的`0xCAFEBABE`，尽管Java
    9引入了魔数`0xCAFEDADA`用于模块文件。
- en: 'The constant pool holds constant values in code: for example, names of classes,
    interfaces, and fields. When the JVM executes code, the constant pool table is
    used to refer to values rather than having to rely on the precise layout of memory
    structures at runtime.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 常量池在代码中保存常量值：例如，类、接口和字段的名称。当JVM执行代码时，常量池表用于引用值，而不必依赖于运行时内存结构的精确布局。
- en: Access flags are used to determine the modifiers applied to the class. The first
    part of the flag block identifies general properties, such as whether a class
    is public, followed by whether it is final and thus cannot be subclassed. The
    flags also determine whether the class file represents an interface or an abstract
    class. The final part of the flag block indicates whether the class file represents
    a synthetic class (not present in source code), an annotation type, or an enum.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 访问标志用于确定应用于类的修饰符。标志块的第一部分标识一般属性，例如一个类是否为公共的，接着是是否为final，因此不能被子类化。标志还确定类文件是否表示一个接口或抽象类。标志块的最后部分指示类文件是否表示合成类（不在源代码中出现）、注解类型或枚举。
- en: The `this` class, superclass, and interface entries are indexes into the constant
    pool to identify the type hierarchy belonging to the class. Fields and methods
    define a signature-like structure, including the modifiers that apply to the field
    or method. A set of attributes is then used to represent structured items for
    more complicated and non-fixed-size structures. For example, methods make use
    of the `Code` attribute to represent the bytecode associated with that particular
    method.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`this`类、超类和接口条目是索引到常量池的，用于标识属于类的类型层次结构。字段和方法定义了类似签名的结构，包括应用于字段或方法的修饰符。然后使用一组属性来表示更复杂和非固定大小结构的结构化项目。例如，方法使用`Code`属性来表示与该特定方法相关的字节码。'
- en: '[Figure 3-2](#pracjavaperf-CHP-3-FIG-2) provides a mnemonic for remembering
    the structure.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3-2](#pracjavaperf-CHP-3-FIG-2)提供了一个记忆结构的助记符。'
- en: '![ocnj2 0302](assets/ocnj2_0302.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![ocnj2 0302](assets/ocnj2_0302.png)'
- en: Figure 3-2\. Mnemonic for class file structure
  id: totrans-65
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3-2\. 类文件结构的助记符
- en: 'In this very simple code example, it is possible to observe the effect of running
    `javac`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个非常简单的代码示例中，可以观察运行`javac`的效果：
- en: '[PRE0]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Java ships with a class file disassembler called `javap`, allowing inspection
    of *.class* files. Taking the *HelloWorld* class file and running `javap -c HelloWorld`
    gives the following output:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Java附带了一个名为`javap`的类文件反汇编器，允许检查*.class*文件。取出*HelloWorld*类文件并运行`javap -c HelloWorld`，将得到以下输出：
- en: '[PRE1]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This layout describes the bytecode for the file *HelloWorld.class*. For more
    detail `javap` also has a `-v` option that provides the full class file header
    information and constant pool details. The class file contains two methods, although
    only the single `main()` method was supplied in the source file; this is the result
    of `javac` automatically adding a default constructor to the class.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这个布局描述了文件*HelloWorld.class*的字节码。更详细的信息，`javap`还有一个`-v`选项，提供完整的类文件头信息和常量池详情。类文件包含两个方法，虽然源文件只提供了一个`main()`方法；这是`javac`自动向类中添加默认构造函数的结果。
- en: The first instruction executed in the constructor is `aload_0`, which places
    the `this` reference onto the first position in the stack. The `invokespecial`
    command is then called, which invokes an instance method that has specific handling
    for calling superconstructors and creating objects. In the default constructor,
    the invoke matches the default constructor for `Object`, as an override was not
    supplied.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数中执行的第一条指令是`aload_0`，它将`this`引用放置在堆栈的第一个位置上。然后调用`invokespecial`命令，它调用具有特定处理调用超级构造函数和创建对象的实例方法。在默认构造函数中，调用与`Object`的默认构造函数匹配，因为未提供重写。
- en: Note
  id: totrans-72
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '[Opcodes in the JVM](https://en.wikipedia.org/wiki/List_of_Java_bytecode_instructions)
    are concise and represent the type, the operation, and the interaction between
    local variables, the constant pool, and the stack.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '[JVM中的操作码](https://en.wikipedia.org/wiki/List_of_Java_bytecode_instructions)简洁且表示类型、操作以及本地变量、常量池和堆栈之间的交互。'
- en: Moving on to the `main()` method, `iconst_0` pushes the integer constant `0`
    onto the evaluation stack. `istore_1` stores this constant value into the local
    variable at offset 1 (represented as `i` in the loop). Local variable offsets
    start at 0, but for instance methods, the 0th entry is always `this`. The variable
    at offset 1 is then loaded back onto the stack and the constant `10` is pushed
    for comparison using `if_icmpge` (“if integer compare greater or equal”). The
    test only succeeds if the current integer is >= 10.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 继续到`main()`方法，`iconst_0`将整数常量`0`推送到评估堆栈。`istore_1`将此常量值存储到偏移量1处的本地变量（在循环中表示为`i`）。本地变量偏移从0开始，但对于实例方法，第0个条目始终是`this`。然后再次将偏移量1处的变量加载回堆栈，并且使用`if_icmpge`推送常量`10`进行比较（“如果整数比较大或等于”）。只有当前整数
    >= 10 时测试才会成功。
- en: For the first 10 iterations, this comparison test fails and so we continue to
    instruction 8\. Here the static method from `System.out` is resolved, followed
    by the loading of the “Hello World” string from the constant pool. The next invoke,
    `invokevirtual`, invokes an instance method based on the class. The integer is
    then incremented and `goto` is called to loop back to instruction 2.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在前10次迭代中，此比较测试失败，因此我们继续到指令8。在这里，来自`System.out`的静态方法被解析，随后从常量池加载“Hello World”字符串。接下来的`invokevirtual`调用基于类调用实例方法。然后对整数进行递增并且通过`goto`调用回到指令2继续循环。
- en: This process continues until the `if_icmpge` comparison eventually succeeds
    (when the loop variable is >= 10); on that iteration of the loop, control passes
    to instruction 22 and the method returns.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 此过程将持续直到`if_icmpge`比较最终成功（当循环变量 >= 10时）；在循环的这一次迭代中，控制传递到指令22并且方法返回。
- en: Introducing HotSpot
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入HotSpot
- en: In April 1999 Sun introduced one of the biggest-ever changes (in terms of performance)
    to the dominant Java implementation. The HotSpot virtual machine is a key feature
    that has evolved to enable performance that is comparable to (or better than)
    languages such as C and C++ (see [Figure 3-3](#pracjavaperf-CHP-3-FIG-3)). To
    explain how this is possible, let’s delve a little deeper into the design of languages
    intended for application development.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 1999年4月，Sun公司推出了对主导的Java实现最大的一次性性能改进。HotSpot虚拟机是一个关键功能，经过演变使得性能可以与诸如C和C++等语言相媲美（见[图 3-3](#pracjavaperf-CHP-3-FIG-3)）。要解释这种可能性，让我们深入探讨一下设计用于应用程序开发的语言。
- en: '![ocnj2 0303](assets/ocnj2_0303.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![ocnj2 0303](assets/ocnj2_0303.png)'
- en: Figure 3-3\. The HotSpot JVM
  id: totrans-80
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3-3\. HotSpot JVM
- en: Language and platform design frequently involves making decisions and tradeoffs
    between desired capabilities. In this case, the division is between languages
    that stay “close to the metal” and rely on ideas such as “zero-cost abstractions,”
    and languages that favor developer productivity and “getting things done” over
    strict low-level control.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 语言和平台设计通常涉及在所需功能之间进行决策和权衡。在这种情况下，分歧在于“接近底层”的语言和依赖于“零成本抽象”等思想，以及支持开发者生产力和“完成任务”的语言，而不是严格的低级控制。
- en: 'In general, C++ implementations obey the zero-overhead principle: What you
    don’t use, you don’t pay for. And further: What you do use, you couldn’t hand
    code any better.^([1](ch03.xhtml#id104))'
  id: totrans-82
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 总体而言，C++实现遵循零开销原则：你不用的部分不需要付出代价。而且进一步说，你使用的部分，你手工编码也不会更好。^([1](ch03.xhtml#id104))
- en: ''
  id: totrans-83
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Bjarne Stroustrup
  id: totrans-84
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Bjarne Stroustrup
- en: The zero-overhead principle sounds great in theory, but it requires all users
    of the language to deal with the low-level reality of how operating systems and
    computers actually work. This is a significant extra cognitive burden that is
    placed upon developers who may not care about raw performance as a primary goal.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 零开销原则在理论上听起来很棒，但它要求语言的所有用户处理操作系统和计算机实际工作的低级现实。这是一个额外的重大认知负担，可能不是开发者的主要目标关注的原始性能。
- en: Not only that, but it also requires the source code to be compiled to platform-specific
    machine code at build time—usually called *Ahead-of-Time* (AOT) compilation. This
    is because alternative execution models such as interpreters, virtual machines,
    and portability layers all are most definitely not zero-overhead.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: The phrase “what you do use, you couldn’t hand code any better” also has a sting
    in its tail. It implies a number of things, but most important for our purposes
    is that a developer is not able to produce better code than an automated system
    (such as a compiler).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Java has never subscribed to the zero-overhead abstraction philosophy. Instead,
    the approach taken by the HotSpot virtual machine is to analyze the runtime behavior
    of your program and intelligently apply optimizations where they will benefit
    performance the most. The goal of the HotSpot VM is to allow you to write idiomatic
    Java and follow good design principles rather then contort your program to fit
    the VM.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Just-in-Time Compilation
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Java programs begin their execution in the bytecode interpreter, where instructions
    are performed on a virtualized stack machine. This abstraction from the CPU gives
    the benefit of class file portability, but to get maximum performance your program
    must make optimal use of its native features.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: HotSpot achieves this by compiling units of your program from interpreted bytecode
    into native code, which then executes directly, without requiring the overhead
    of the abstractions of the interpreter. The units of compilation in the HotSpot
    VM are the method and the loop. This is known as *Just-in-Time* (JIT) compilation.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: JIT compilation works by monitoring the application while it is running in interpreted
    mode and observing the parts of code that are most frequently executed. During
    this analysis process, programmatic trace information is captured that allows
    for more sophisticated optimization. Once execution of a particular method passes
    a threshold, the profiler will look to compile and optimize that particular section
    of code.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: There are many advantages to the JIT approach to compilation, but one of the
    main ones is that it bases compiler optimization decisions on trace information
    that is collected while methods are being interpreted. This information enables
    HotSpot to make more informed optimizations if the method is eligible for compilation.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-94
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Some JIT compilers also have the capability to re-JIT if a better optimization
    becomes apparent later on during execution. This includes some of HotSpot’s compilers.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Not only that, but HotSpot has had hundreds of engineering years (or more) of
    development attributed to it and new optimizations and benefits are added with
    almost every new release. This means that all Java applications benefit from the
    latest HotSpot performance optimizations in the VM without even needing to be
    recompiled.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-97
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: After being translated from Java source to bytecode and now going through another
    step of (JIT) compilation, the code actually being executed has changed very significantly
    from the source code as written. This is a key insight, and it will drive our
    approach to dealing with performance-related investigations. JIT-compiled code
    executing on the JVM may well look nothing like the original Java source code.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Java 源代码转换为字节码后，经过（JIT）编译的代码实际上与原始编写的源代码有很大的变化。这是一个关键的见解，它将驱动我们处理与性能相关的调查方法。
- en: The general picture is that languages like C++ (and the up-and-coming Rust)
    tend to have more predictable performance, but at the cost of forcing a lot of
    low-level complexity onto the user.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 一般情况是，像 C++（以及崭露头角的 Rust）这样的语言倾向于具有更可预测的性能，但以迫使用户承担大量低级复杂性为代价。
- en: Note also that “more predictable” does not necessarily mean “better.” AOT compilers
    produce code that may have to run across a broad class of processors, and usually
    are not able to assume that specific processor features are available.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，“更可预测”并不一定意味着“更好”。AOT 编译器生成的代码可能需要在广泛的处理器类上运行，并且通常不能假定特定处理器功能可用。
- en: Environments that use profile-guided optimization (PGO), such as Java, have
    the potential to use runtime information in ways that are simply impossible to
    most AOT platforms. This can offer improvements to performance, such as dynamic
    inlining and optimizing away virtual calls. HotSpot can even detect the precise
    CPU type it is running on at VM startup, and can use this information to enable
    optimizations designed for specific processor features if available.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基于配置文件的优化（PGO）的环境，如 Java，有可能利用运行时信息，这对大多数 AOT 平台来说是不可能的。这可以提升性能，如动态内联和优化掉虚拟调用。HotSpot
    甚至可以在 VM 启动时检测正在运行的精确 CPU 类型，并且可以利用此信息启用针对特定处理器功能设计的优化。
- en: Tip
  id: totrans-102
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: The technique of detecting precise processor capabilities is known as *JVM intrinsics*,
    and is not to be confused with the intrinsic locks introduced by the `synchronized`
    keyword.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 检测精确处理器能力的技术称为*JVM内置功能*，不要与由`synchronized`关键字引入的内置锁混淆。
- en: A full discussion of PGO and JIT compilation can be found in Chapters 6 and
    10.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: PGO 和 JIT 编译的全面讨论可参见第 6 和第 10 章。
- en: The sophisticated approach that HotSpot takes is a great benefit to the majority
    of ordinary developers, but this tradeoff (to abandon zero-overhead abstractions)
    means that in the specific case of high-performance Java applications, the developer
    must be very careful to avoid “common sense” reasoning and overly simplistic mental
    models of how Java applications actually execute.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: HotSpot 采取的复杂方法对大多数普通开发者是一个巨大的好处，但这种权衡（放弃零开销抽象）意味着在高性能 Java 应用的特定情况下，开发者必须非常小心，避免“常识”推理和过于简单化的
    Java 应用实际执行模型。
- en: Note
  id: totrans-106
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Once again, analyzing the performance of small sections of Java code (*micro­benchmarks*)
    is usually much harder than analyzing entire applications, and is a very specialized
    task that the majority of developers should not undertake.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，分析小段 Java 代码的性能（*微基准测试*）通常比分析整个应用程序更加困难，这是大多数开发者不应该承担的非常专业化的任务。
- en: HotSpot’s compilation subsystem is one of the two most important subsystems
    that the virtual machine provides. The other is automatic memory management, which
    has been one of the major selling points of Java since the early years.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: HotSpot 的编译子系统是虚拟机提供的两个最重要的子系统之一。另一个是自动内存管理，自 Java 早期以来一直是其主要卖点之一。
- en: JVM Memory Management
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JVM 内存管理
- en: In languages such as C, C++, and Objective-C the programmer is responsible for
    managing the allocation and release of memory. The benefits of managing memory
    and lifetime of objects yourself are more deterministic performance and the ability
    to tie resource lifetime to the creation and deletion of objects. However, these
    benefits come at a huge cost—for correctness, developers must be able to accurately
    account for memory.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在像 C、C++ 和 Objective-C 这样的语言中，程序员负责管理内存的分配和释放。自行管理内存和对象生命周期的好处是更确定的性能和将资源生命周期与对象的创建和删除绑定的能力。然而，这些好处是以巨大的成本为代价的——为了正确性，开发者必须能够准确地考虑内存。
- en: Unfortunately, decades of practical experience showed that many developers have
    a poor understanding of idioms and patterns for memory management. Later versions
    of C++ and Objective-C have improved this using smart pointer idioms in the standard
    library. However, at the time Java was created poor memory management was a major
    cause of application errors. This led to concern among developers and managers
    about the amount of time spent dealing with language features rather than delivering
    value for the business.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，几十年的实际经验表明，许多开发人员对内存管理的习惯用法和模式理解不足。后来的C++和Objective-C版本通过在标准库中使用智能指针习惯改进了这一点。然而，在Java被创造时，糟糕的内存管理是应用程序错误的主要原因之一。这引起了开发人员和管理人员对处理语言特性而非为业务提供价值所花费的时间量的关注。
- en: Java looked to help resolve the problem by introducing automatically managed
    heap memory using a process known as *garbage collection* (GC). Simply put, garbage
    collection is a nondeterministic process that triggers to recover and reuse no-longer-needed
    memory when the JVM requires more memory for allocation.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Java通过引入自动管理堆内存的方式（称为*垃圾回收*（GC））来帮助解决这个问题。简而言之，垃圾回收是一种非确定性过程，当JVM需要更多内存进行分配时触发，以恢复和重用不再需要的内存。
- en: 'GC comes at a cost: when it runs, it traditionally *stopped the world*, which
    means while GC is in progress the application pauses. Usually these pause times
    are incredibly short, but as an application is put under pressure they can increase.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: GC是有代价的：当它运行时，传统上会*停止整个世界*，这意味着应用程序会暂停。通常这些暂停时间非常短暂，但当应用程序面临压力时，这些时间可能会增加。
- en: Having said that, the JVM’s garbage collection is best-in-class, and is far
    more sophisticated than the introductory algorithm that is often taught in Computer
    Science undergraduate courses. For example, stopping the world is much less necessary
    and intrusive in modern algorithms, as we will see later.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，JVM的垃圾回收是业界最佳的，远比计算机科学本科课程中常教授的初级算法要复杂得多。例如，在现代算法中，停止整个世界的必要性和侵入性大大降低，后面我们将会看到。
- en: Garbage collection is a major topic within Java performance optimization, so
    we will devote Chapters 4 and 5 to the details of Java GC.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 垃圾回收是Java性能优化中的一个重要主题，因此我们将在第四章和第五章详细讨论Java GC的细节。
- en: Threading and the Java Memory Model
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程和Java内存模型
- en: 'One of the major advances that Java brought in with its first version was built-in
    support for multithreaded programming. The Java platform allows the developer
    to create new threads of execution. For example, in Java 8 syntax:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Java的第一个版本带来的一项主要进步是对多线程编程的内置支持。Java平台允许开发人员创建新的执行线程。例如，在Java 8语法中：
- en: '[PRE2]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Not only that, but basically all production JVMs are multithreaded—​and this
    means that all Java programs are inherently multithreaded, as they execute as
    part of a JVM process.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅如此，基本上所有生产环境中的JVM都是多线程的—​这意味着所有Java程序本质上都是多线程的，因为它们作为JVM进程的一部分执行。
- en: This fact produces additional, irreducible complexity in the behavior of Java
    programs, and makes the work of the performance analyst harder. However, it allows
    the JVM to take advantage of all available cores, which provides all sorts of
    performance benefits to the Java developer.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这一事实增加了Java程序行为的额外、不可简化的复杂性，并使性能分析师的工作更加困难。然而，它允许JVM利用所有可用的核心，为Java开发人员提供各种性能优势。
- en: The relationship between Java’s conception of a thread (an “application thread”)
    and the operating system’s view of a thread (a “platform thread”) has a slightly
    interesting history. In the very earliest days of the platform, there was a sharp
    distinction made between the two concepts and application threads were *remapped*
    or *multiplexed* onto a pool of platform threads—​e.g. in the Solaris *M:N*, or
    the Linux *green threads* models.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Java对线程的概念（“应用程序线程”）与操作系统对线程的视图（“平台线程”）之间有着稍微有趣的历史。在平台的最早时期，对这两个概念有着明显的区分，并且应用程序线程会被*重新映射*或*多路复用*到一组平台线程中—​例如在Solaris的*M:N*或Linux的*green
    threads*模型中。
- en: However, this approach proved not to provide an acceptable performance profile
    and added needless complexity. As a result, in most mainstream JVM implementations,
    this model was replaced with a simpler one—​each Java application thread corresponding
    precisely to a dedicated platform thread.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法被证明无法提供可接受的性能特性，并增加了不必要的复杂性。因此，在大多数主流JVM实现中，这种模型被更简单的模型所取代—​每个Java应用程序线程精确对应于一个专用的平台线程。
- en: This is not the end of the story, however.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不是故事的终点。
- en: In the 20+ years since the “app thread == platform thread” transition, applications
    have grown and scaled massively—​and so has the number of threads (or, more generally,
    *execution contexts*) that an application might want to create. This has led to
    the “thread bottleneck” problem, and solving it has been the focus of a major
    research project within OpenJDK (Project Loom).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 自从“应用线程 == 平台线程”转变以来的20多年间，应用程序已经大规模增长和扩展 —— 线程（或者更普遍地说，*执行上下文*）的数量也随之增加。这导致了“线程瓶颈”问题的出现，解决这一问题已经成为
    OpenJDK 内的一个重要研究项目的焦点（项目 Loom）。
- en: The result is *virtual threads*, a new form of thread only available in Java
    21+, which can be used efficiently for certain types of task—​especially those
    performing network I/O.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 结果就是 *虚拟线程*，这是一种新形式的线程，只在 Java 21+ 中可用，可用于某些类型的任务 —— 特别是执行网络 I/O 的任务。
- en: Programmers must explicitly choose to create a thread as virtual—​otherwise
    they are platform threads and retain the same behavior as before (so the semantics
    of all existing Java programs are preserved when run on a JVM with virtual thread
    capability).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员必须明确选择将线程创建为虚拟线程 —— 否则它们就是平台线程，并保留与之前相同的行为（这样在具备虚拟线程功能的 JVM 上运行时，所有现有 Java
    程序的语义仍然得以保留）。
- en: Note
  id: totrans-127
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: It is safe to assume that every platform thread (or any thread, before Java
    21) is backed by a unique OS thread that is created when the `start()` method
    is called on the corresponding `Thread` object.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 可以安全地假设每个平台线程（或在 Java 21 之前的任何线程）都由一个唯一的操作系统线程支持，在对应的 `Thread` 对象上调用 `start()`
    方法时创建。
- en: Virtual threads are Java’s take on an idea that can be found in various other
    modern languages—​for example, Go programmers may regard a Java virtual thread
    as being broadly similar to a goroutine. We will discuss virtual threads in more
    detail in Chapter 14.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟线程是 Java 对各种现代语言中存在的一种思想的解决方案 —— 例如，Go 程序员可能会认为 Java 虚拟线程与 goroutine 在某种程度上相似。我们将在第14章中更详细地讨论虚拟线程。
- en: 'We should also briefly discuss Java’s approach to handling data in a multithreaded
    program. It dates from the late 1990s and has these fundamental design principles:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该简要讨论 Java 在处理多线程程序中的数据时的方法。这些方法可以追溯到20世纪90年代末，并具有以下基本设计原则：
- en: All threads in a Java process share a single, common garbage-collected heap.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 进程中的所有线程共享单一的垃圾收集堆。
- en: Any object created by one thread can be accessed by any other thread that has
    a reference to the object.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何一个线程创建的对象都可以被其他任何引用了该对象的线程访问。
- en: Objects are mutable by default; that is, the values held in object fields can
    be changed unless the programmer explicitly uses the `final` keyword to mark them
    as immutable.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象默认是可变的；也就是说，对象字段中保存的值可以被更改，除非程序员显式使用 `final` 关键字将它们标记为不可变。
- en: The Java Memory Model (JMM) is a formal model of memory that explains how different
    threads of execution see the changing values held in objects. That is, if threads
    A and B both have references to object `obj`, and thread A alters it, what happens
    to the value observed in thread B?
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Java 内存模型（JMM）是一个正式的内存模型，解释了不同执行线程如何看待对象中存储值的变化。也就是说，如果线程 A 和线程 B 都有对对象 `obj`
    的引用，并且线程 A 进行了修改，那么线程 B 中观察到的值会发生什么变化？
- en: This seemingly simple question is actually more complicated than it seems, because
    the operating system scheduler (which we will meet in Chapter 7) can forcibly
    evict platform threads from CPU cores. This can lead to another thread starting
    to execute and accessing an object before the original thread had finished processing
    it, and potentially seeing the object in a prior or even invalid state.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这个看似简单的问题实际上比看起来更为复杂，因为操作系统的调度器（我们将在第7章中介绍）可以强制从 CPU 核心中驱逐平台线程。这可能导致另一个线程开始执行并访问对象，而原始线程尚未完成对对象的处理，可能会看到对象处于先前或甚至是无效状态。
- en: The only defense the core of Java provides against this potential object damage
    during concurrent code execution is the mutual exclusion lock, and this can be
    very complex to use in real applications. Chapter 13 contains a detailed look
    at how the JMM works, and the practicalities of working with threads and locks.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Java 核心提供的唯一防御措施是互斥锁，以防止在并发代码执行期间造成对象损坏，但在实际应用中使用起来可能非常复杂。第13章详细讨论了 JMM 的工作原理以及处理线程和锁定的实际操作。
- en: Lifecycle of a traditional Java application
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传统 Java 应用程序的生命周期
- en: 'Earlier in the chapter we introduced Java program execution via classloading
    and bytecode interpretation—​but let’s dive a little deeper into what actually
    happens when you type: `java HelloWorld`.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的前面，我们通过类加载和字节码解释介绍了 Java 程序的执行方式—​但让我们更深入地了解当您键入`java HelloWorld`时实际发生了什么。
- en: At a low level, standard Unix-like process execution occurs in order to set
    up the JVM process. The shell locates the JVM binary (e.g. possibly in `$JAVA_HOME/bin/java`)
    and starts a process corresponding to that binary, passing the arguments (including
    the entrypoint class name).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在较低级别上，类似于标准 Unix 的进程执行顺序发生以设置 JVM 进程。Shell 定位 JVM 二进制文件（例如，可能在 `$JAVA_HOME/bin/java`
    中），并启动对应于该二进制文件的进程，传递参数（包括入口类名）。
- en: The newly started process analyzes the command line flags and prepares for VM
    initialization, which will be customized via the flags (for heap size, GC, etc).
    At this time the process probes the machine it is running on, and examines various
    system parameters, such as how many CPU cores the machine has; how much memory;
    what precise set of CPU instructions are available.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 新启动的进程分析命令行标志并准备进行 VM 初始化，这将通过标志（用于堆大小、GC 等）进行定制。此时，进程会探测其运行的机器，并检查各种系统参数，例如机器拥有多少
    CPU 核心；有多少内存；可用的 CPU 指令集是什么。
- en: This very detailed information is used to customize and optimize how the JVM
    configures itself. For example, the JVM will use the number of cores to determine
    how many threads to use when garbage collection runs, and to size the *common
    pool* of threads.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这些非常详细的信息用于定制和优化 JVM 如何配置自身。例如，JVM 将使用核心数确定垃圾收集运行时要使用多少线程，并且调整线程的*通用池*的大小。
- en: One key early step is to reserve an area of userspace memory (from the C heap)
    equal to `Xmx` (or the default value) for the Java heap. Another vital step is
    to initialize a repository to store Java classes and associated metadata in (known
    as *Metaspace* in HotSpot).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 一个关键的早期步骤是为 Java 堆保留一个用户空间内存区域（来自 C 堆），大小等于 `Xmx`（或默认值）。另一个至关重要的步骤是初始化存储 Java
    类和相关元数据的存储库（在 HotSpot 中称为 *Metaspace*）。
- en: Then the VM itself is created, usually via the function `JNI_CreateJavaVM`,
    on a new thread for HotSpot. The VM’s own threads—​such as the GC threads and
    the threads that perform JIT compilation—​also need to be started up.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，VM 本身将被创建，通常是通过 `JNI_CreateJavaVM` 函数，在 HotSpot 上为新线程。VM 的自身线程—​例如 GC 线程和执行
    JIT 编译的线程—​也需要启动起来。
- en: As discussed earlier, the bootstrapping classes are prepared and then initialized.
    The first bytecodes are run and first objects are created as soon as classes are
    loaded—​e.g. in the class initializer (`static {}` blocks aka `clinit` methods)
    for the bootstrapping classes.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 正如之前讨论的，引导类被准备并初始化。当类加载时（例如，在引导类的类初始化器（`static {}`块，也称为`clinit`方法）中），第一批字节码会被执行，第一个对象也会被创建。
- en: The significance of this is that the JVMs basic processes—​such as JIT compilation
    and GC—​are running from very early in the lifecycle of the application. As the
    VM starts up, there may be some GC and JIT activity even before control reaches
    the entrypoint class. Once it does, then further classloading will happen as the
    application begins to execute and needs to run code from classes that are not
    present in the class metadata cache.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这一点的重要性在于 JVM 的基本进程—​如 JIT 编译和 GC—​从应用程序的生命周期早期就开始运行。随着 VM 的启动，甚至在控制流达到入口类之前，可能会有一些
    GC 和 JIT 活动。一旦这样做了，随着应用程序开始执行并需要从类不存在于类元数据缓存中的类中运行代码时，将会发生进一步的类加载。
- en: 'For most typical production applications, therefore, the startup phase is characterized
    by a spike in classloading, JIT and GC activity while the application reaches
    a steady state. Once this has occurred, the amount of JIT and classloading usually
    drops sharply because:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于大多数典型的生产应用程序，启动阶段的特征是类加载、JIT 和 GC 活动的激增，而应用程序达到稳定状态。一旦发生这种情况，JIT 和类加载的量通常会急剧下降，因为：
- en: The entire “world” of classes that the application needs has been loaded
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序需要的类的“整个”世界已经加载完成
- en: The set of methods that are called often have already been converted to machine
    code by the JIT compiler
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 经常调用的一组方法已经被 JIT 编译器转换为机器码
- en: However, it is important to recognize that “steady state” does not mean “zero
    change”. It is perfectly normal for applications to experience further classloading
    and JIT activity—​such as *deoptimization* and *reoptimization*. This can be caused
    when a rarely-executed code path is encountered and causes a new class to be loaded.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，重要的是要认识到，“稳定状态”并不意味着“零变化”。应用程序经历进一步的类加载和JIT活动——例如*去优化*和*重新优化*是完全正常的。这可能是由于遇到了很少执行的代码路径并导致新类的加载。
- en: One other important special case of the startup-steady-state model is sometimes
    referred to as “2-phase classloading”. This occurs in applications that use Spring,
    and other similar dependency injection techniques.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的启动-稳定状态模型的特殊情况有时被称为“两阶段类加载”。这发生在使用Spring和其他类似依赖注入技术的应用程序中。
- en: In this case, the core framework classes are loaded first. After that, the framework
    examines the main application code and config to determine a graph of objects
    that need to be instantiated to activate the application. This triggers a second
    phase of classloading where the application code and its other dependencies are
    loaded.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，核心框架类首先被加载。之后，框架会检查主应用程序代码和配置，以确定需要实例化以激活应用程序的对象图。这触发了第二阶段的类加载，其中加载应用程序代码及其其他依赖项。
- en: The case of GC behavior is a little bit different. In an application which is
    not suffering any particular performance problem, the pattern of GC is also likely
    to change when the steady state is reached—​but GC events will still occur. This
    is because in any Java application, objects are created, live for some time and
    then are automatically collected—​this is the entire point of automatic memory
    management. However, the pattern of steady state GC may well look very different
    to that of the startup phase.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: GC行为的情况略有不同。在一个没有特定性能问题的应用程序中，当达到稳定状态时，GC模式也很可能发生变化——但GC事件仍会发生。这是因为在任何Java应用程序中，对象被创建，存在一段时间，然后被自动收集——这是自动内存管理的全部意义。然而，稳定状态的GC模式可能看起来与启动阶段的完全不同。
- en: The overall impression that you should be building up from this description
    is one of a highly dynamic runtime. Applications that are deployed on it display
    the runtime characteristics of a well-defined startup phase, followed by a steady
    state where minimal change occurs.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 从此描述中你应该得到的总体印象是一个高度动态的运行时环境。部署在其上的应用程序展示了明确定义的启动阶段的运行时特征，然后是稳定状态，在这个状态下发生的变化很少。
- en: This is the standard mental model for the behavior of Java applications, and
    has been for as long as Java has had JIT compilation, etc. However, it does have
    certain drawbacks—​the major one being that execution time can be slower while
    the application transitions into steady state (often called “JVM warmup”).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Java应用程序行为的标准心理模型，自Java具有JIT编译以来一直如此。然而，它确实有一些缺点——其中一个主要缺点是在应用程序过渡到稳定状态时执行时间可能会变慢（通常称为“JVM热身”）。
- en: This transition time can easily run into the 10s of seconds after application
    start. For long-running applications this is not usually a problem—​a process
    that is running continuously for hours (or days or weeks) receives far more benefit
    from the JIT compiled code than the one-off effort expended to create it at startup.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这种过渡时间在应用程序启动后很容易延长到几十秒。对于长时间运行的应用程序，这通常不是问题——一个连续运行数小时（或数天或数周）的进程比启动时为其创建JIT编译代码所投入的一次性努力获得了更大的好处。
- en: 'In the cloud native world, however, processes may be much shorter-lived. This
    raises the question: whether the amortized cost of Java startup and JIT is actually
    worth it, and if not, what could be done to make Java applications start up faster?'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在云原生世界中，进程可能存活时间较短。这引发了一个问题：Java启动和JIT的摊销成本是否真的值得，如果不值得，可以采取哪些措施来加快Java应用程序的启动速度？
- en: In turn, this has fueled interest in new operational and deployment modes for
    Java—​including AOT compilation (but not limited to it, as we will see). The community
    has adopted the term *dynamic VM mode* for the traditional lifecycle we have just
    discussed. We will have a good amount to say about the emerging alternatives to
    it throughout the rest of the book.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 反过来，这引发了对Java新的操作和部署模式的兴趣——包括AOT编译（但不限于此，我们将在本书的其余部分看到）。社区已经采用了“动态VM模式”的术语来描述我们刚讨论过的传统生命周期。在本书的其余部分，我们将详细探讨与其相对立的新兴替代方案。
- en: Monitoring and Tooling for the JVM
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JVM的监控和工具
- en: 'The JVM is a mature execution platform, and it provides a number of technology
    alternatives for instrumentation, monitoring, and Observability of running applications.
    The main technologies available for these types of tools for JVM applications
    are:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: JVM是一个成熟的执行平台，它为运行应用程序的仪表化、监视和可观测性提供了许多技术选择。针对JVM应用程序的这些类型的工具的主要技术有：
- en: Java Management Extensions (JMX)
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java管理扩展（JMX）
- en: Java agents
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java代理
- en: The JVM Tool Interface (JVMTI)
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JVM工具接口（JVMTI）
- en: The Serviceability Agent (SA)
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可服务性代理（SA）
- en: JMX is a general-purpose technology for controlling and monitoring JVMs and
    the applications running on them. It provides the ability to change parameters
    and call methods in a general way from a client application. A full treatment
    of how this is implemented is, unfortunately, outside the scope of this book.
    However, JMX (and its associated network transport, *remote method invocation*
    or RMI) is a fundamental aspect of the management capabilities of the JVM.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: JMX是一种用于控制和监视JVM及其上运行的应用程序的通用技术。它提供了从客户端应用程序通用方式更改参数和调用方法的能力。如何实现这一点的全面讨论，不幸的是，超出了本书的范围。然而，JMX（及其相关的网络传输，*远程方法调用*或RMI）是JVM管理能力的一个基本方面。
- en: A Java agent is a tooling component, written in Java (hence the name), that
    makes use of the interfaces in `java.lang.instrument` to modify the bytecode of
    methods as classes are loaded. The modification of bytecode allows instrumentation
    logic, such as method timing or distributed tracing (see Chapter 10 for more details),
    to be added to any application, even one that has not been written with any support
    for those concerns.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Java代理是一个工具组件，用Java编写（因此得名），利用`java.lang.instrument`中的接口在加载类时修改方法的字节码。字节码修改允许添加仪表逻辑，如方法计时或分布式跟踪（有关详细信息，请参见第10章），以添加到任何应用程序中，即使该应用程序没有为这些问题提供任何支持。
- en: 'This is an extremely powerful technique, and installing an agent changes the
    standard application lifecycle that we met in the last section. To install an
    agent, it must be packaged as a JAR and provided via a startup flag to the JVM:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种非常强大的技术，安装代理会改变我们在上一节中介绍的标准应用程序生命周期。要安装代理，它必须打包为JAR并通过启动标志提供给JVM：
- en: '[PRE3]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The agent JAR must contain a manifest file, `META-INF/MANIFEST.MF`, and it must
    include the attribute `Premain-Class`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 代理JAR必须包含一个清单文件，`META-INF/MANIFEST.MF`，并且必须包含属性`Premain-Class`。
- en: This attribute contains the name of the agent class, which must implement a
    public static `premain()` method that acts as the registration hook for the Java
    agent. This method will run on the main application thread *before* the `main()`
    method of the application (hence the name). Note that the premain method must
    exit, or the main application will not start.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 此属性包含代理类的名称，该类必须实现一个公共静态的`premain()`方法，作为Java代理的注册挂钩。此方法将在应用程序的主线程*之前*（因此得名）运行`main()`方法。请注意，premain方法必须退出，否则主应用程序将无法启动。
- en: Bytecode transformation is the usual intent of an agent, and this is done by
    creating and registering bytecode transformers—​objects that implement the `ClassFileTransformer`
    interface. However, a Java agent is just Java code, and so it can do anything
    that any other Java program can, i.e. it can contain arbitrary code to execute.
    This flexibility means that, for example, an agent can start additional threads
    that can persist for the entire life of the application, and collect data for
    sending out of the application and into an external monitoring system.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 字节码转换是代理的通常意图，通过创建和注册字节码转换器——实现`ClassFileTransformer`接口的对象来实现。然而，Java代理只是Java代码，因此它可以像任何其他Java程序一样做任何事情，即可以包含任意代码来执行。这种灵活性意味着，例如，代理可以启动额外的线程，这些线程可以持续整个应用程序的生命周期，并收集数据以发送到外部监控系统。
- en: Note
  id: totrans-171
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: We will have a little more to say about JMX and agents in Chapter 11 where we
    discuss their use in cloud Observability tools.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在第11章中，我们将进一步讨论JMX和代理的使用，特别是它们在云可观测性工具中的应用。
- en: 'If the Java instrumentation API is not sufficient, then the JVMTI may be used
    instead. This is a native interface of the JVM, so agents that make use of it
    must be written in a native compiled language—essentially, C or C++. It can be
    thought of as a communication interface that allows a native agent to monitor
    and be informed of events by the JVM. To install a native agent, provide a slightly
    different flag:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'or:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The requirement that JVMTI agents be written in native code means that these
    agents can be more difficult to write and debug. Programming errors in JVMTI agents
    can damage running applications and even crash the JVM.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, where possible, it is usually preferable to write a Java agent over
    JVMTI code. Agents are much easier to write, but some information is not available
    through the Java API, and to access that data JVMTI may be the only possibility
    available.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: The final approach is the Serviceability Agent. This is a set of APIs and tools
    that can expose both Java objects and HotSpot data structures.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: The SA does not require any code to be run in the target VM. Instead, the HotSpot
    SA uses primitives like symbol lookup and reading of process memory to implement
    debugging capability. The SA has the ability to debug live Java processes as well
    as core files (also called *crash dump files*).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: VisualVM
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The JDK ships with a number of useful additional tools along with the well-known
    binaries such as `javac` and `java`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: One tool that is often overlooked is VisualVM, which is a graphical tool based
    on the NetBeans platform. VisualVM used to ship as part of the JDK but has been
    moved out of the main distribution, so developers will have to download the binary
    separately from [the VisualVM website](https://visualvm.github.io/). After downloading,
    you will have to ensure that the `visualvm` binary is added to your path or you
    may get an obselete version from an old Java version.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-184
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`jvisualvm` is a replacement for the now obsolete `jconsole` tool from earlier
    Java versions. If you are still using `jconsole`, you should move to VisualVM
    (there is a compatibility plug-in to allow `jconsole` plug-ins to run inside VisualVM).'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: When VisualVM is started for the first time it will calibrate the machine it
    is running on, so there should be no other applications running that might affect
    the performance calibration. After calibration, VisualVM will finish starting
    up and show a splash screen. The most familiar view of VisualVM is the Monitor
    screen, which is similar to that shown in [Figure 3-4](#pracjavaperf-CHP-3-FIG-4).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '![ocnj2 0304](assets/ocnj2_0304.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
- en: Figure 3-4\. VisualVM Monitor screen
  id: totrans-188
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: VisualVM is used for live monitoring of a running process, and it uses the JVM’s
    *attach mechanism*. This works slightly differently depending on whether the process
    is local or remote.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Local processes are fairly straightforward. VisualVM lists them down the lefthand
    side of the screen. Double-clicking on one of them causes it to appear as a new
    tab in the righthand pane.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 本地进程相当简单。VisualVM将它们列在屏幕左侧。双击其中一个会在右侧窗格中显示为新选项卡。
- en: To connect to a remote process, the remote side must accept inbound connections
    (over JMX). For standard Java processes, this means `jstatd` must be running on
    the remote host (see the manual page for `jstatd` for more details).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 要连接到远程进程，远程端必须接受入站连接（通过JMX）。对于标准Java进程，这意味着远程主机上必须运行`jstatd`（有关更多详情，请参阅`jstatd`的手册页）。
- en: Note
  id: totrans-192
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Many application servers and execution containers provide an equivalent capability
    to `jstatd` directly in the server. Such processes do not need a separate `jstatd`
    process so long as they are capable of port-forwarding JMX and RMI traffic.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 许多应用服务器和执行容器直接在服务器中提供与`jstatd`等价的能力。这样的进程不需要单独的`jstatd`进程，只要能够进行JMX和RMI流量的端口转发即可。
- en: To connect to a remote process, enter the hostname and a display name that will
    be used on the tab. The default port to connect to is 1099, but this can be changed
    easily.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 要连接到远程进程，请输入主机名和将在选项卡上使用的显示名称。连接的默认端口是1099，但这可以轻松更改。
- en: 'Out of the box, VisualVM presents the user with five tabs:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: VisualVM默认呈现给用户五个选项卡：
- en: Overview
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: Provides a summary of information about your Java process. This includes the
    full flags that were passed in and all system properties. It also displays the
    exact Java version executing.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 提供有关您的Java进程的信息摘要。这包括传递的所有标志和所有系统属性。还显示正在执行的确切Java版本。
- en: Monitor
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 监视器
- en: This is the tab that is the most similar to the legacy `jconsole` view. It shows
    high-level telemetry for the JVM, including CPU and heap usage. It also shows
    the number of classes loaded and unloaded, and an overview of the numbers of threads
    running.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这是与传统`jconsole`视图最相似的选项卡。它显示了JVM的高级遥测信息，包括CPU和堆使用情况。还显示了加载和卸载的类数量，以及运行的线程数量的概述。
- en: Threads
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 线程
- en: Each thread in the running application is displayed with a timeline. This includes
    both application threads and VM threads. The state of each thread can be seen,
    with a small amount of history. Thread dumps can also be generated if needed.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序中的每个线程都显示在时间轴上。这包括应用程序线程和VM线程。可以看到每个线程的状态，还有一些历史记录。如果需要，还可以生成线程转储。
- en: Sampler and Profiler
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 采样器和分析器
- en: In these views, simplified sampling of CPU and memory utilization can be accessed.
    This will be discussed more fully in Chapter 11.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些视图中，可以访问对CPU和内存利用率的简化抽样。这将在第11章中更详细地讨论。
- en: The plug-in architecture of VisualVM allows additional tools to be easily added
    to the core platform to augment the core functionality. These include plug-ins
    that allow interaction with JMX consoles and bridging to legacy JConsole, and
    a very useful garbage collection plug-in, VisualGC.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: VisualVM的插件架构允许轻松添加额外的工具到核心平台以增强核心功能。这些包括允许与JMX控制台交互和桥接到传统JConsole的插件，以及非常有用的垃圾收集插件VisualGC。
- en: Java implementations, distributions and releases
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java的实现、分发和发布
- en: In this section we will briefly discuss the landscape of Java implementations
    and distributions, as well as the Java release cycle.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将简要讨论Java实现和分发的情况，以及Java发布周期。
- en: This is an area that changes a lot over time—​so this description is correct
    at time of writing only. Since then, for example, vendors may have entered (or
    exited) the business of making a Java distribution or the release cycle may have
    changed. Caveat lector!
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这个领域随时间变化很大，所以此描述仅在撰写时正确。例如，自那时以来，供应商可能已经进入（或退出）制作Java分发版的业务，或者发布周期可能已经改变。读者须注意！
- en: Many developers may only be familiar with the Java binaries produced by Oracle
    (Oracle JDK). However, as of 2023, we have quite a complex landscape, and it’s
    important to understand the basic components of what makes up “Java”.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发人员可能只熟悉由Oracle（Oracle JDK）生产的Java二进制文件。然而，截至2023年，我们有一个非常复杂的景观，了解构成“Java”基本组件非常重要。
- en: 'First, there’s the source code that will be built into a binary. The source
    code required to build a Java implementation comes in two parts:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，有将要构建成二进制文件的源代码。构建Java实现所需的源代码分为两部分：
- en: Virtual machine source code
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟机源代码
- en: Class library source code
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类库源代码
- en: The OpenJDK project, which can be found at [the OpenJDK website](https://openjdk.org/)
    is the project to develop the open source reference implementation of Java—​which
    is licensed under the GNU Public License version 2, with Classpath Exemption (GPLv2+CE).^([2](ch03.xhtml#id105))
    The project is led and supported by Oracle—​who provide a majority of the engineers
    who work on the OpenJDK codebase.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: OpenJDK项目位于[OpenJDK网站](https://openjdk.org/)，这个项目是开发Java开源参考实现的项目——其许可证为GNU公共许可证第二版，并带有类路径例外（GPLv2+CE）。^([2](ch03.xhtml#id105))
    该项目由Oracle领导并支持——他们为OpenJDK代码库提供了大多数工程师。
- en: The critical point to understand about OpenJDK is that it provides *source code
    only*. This is true both for the VM (HotSpot) and for the class libraries.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 关于OpenJDK的关键点是，它只提供*源代码*。这对于VM（HotSpot）和类库都是如此。
- en: The combination of HotSpot and the OpenJDK class libraries forms the basis of
    the vast majority of Java distributions used in today’s production environments
    (including Oracle’s). However, there are several other Java VMs that we will meet—​and
    discuss briefly in this book—​including Eclipse OpenJ9 and GraalVM. These VMs
    can also be combined with the OpenJDK class libraries to produce a complete Java
    implementation.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: HotSpot和OpenJDK类库的结合构成了今天生产环境中使用的绝大部分Java发行版的基础（包括Oracle的）。然而，还有几个其他的Java虚拟机我们将会遇到——并在本书中简要讨论——包括Eclipse
    OpenJ9和GraalVM。这些虚拟机也可以与OpenJDK类库结合，以产生完整的Java实现。
- en: However, source code, by itself, is not all that useful to developers—​it needs
    to be built into a binary distribution, tested and optionally certified.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，仅有源代码本身对开发人员来说并不十分有用——它需要构建成二进制发行版，经过测试并可选地进行认证。
- en: This is somewhat similar to the situation with Linux—​the source code exists
    and is freely available, but in practice virtually no-one except those folks developing
    the next version work directly with source. Instead, developers consume a binary
    Linux distribution.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这在某种程度上类似于Linux的情况——源代码存在并且可以自由获取，但实际上除了正在开发下一版本的人之外，几乎没有人直接使用源代码。开发人员使用的是二进制Linux发行版。
- en: In the Java world there are a number of vendors who make distributions available,
    just as there are for Linux. Let’s meet the vendors and take a quick look at their
    various offerings.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java世界中，有许多供应商提供发行版，就像Linux一样。让我们认识这些供应商，快速查看它们的各种产品。
- en: Choosing a distribution
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择一个发行版
- en: Developers and architects should consider carefully their choice of JVM vendor.
    Some large organizations—​notably Twitter (as of 2022) and Alibaba—​even choose
    to maintain their own private (or semi-public) builds of OpenJDK, although the
    engineering effort required for this is beyond the reach of many companies.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员和架构师应仔细考虑他们的JVM供应商选择。一些大型组织——特别是Twitter（截至2022年）和阿里巴巴——甚至选择维护自己的私有（或半公开）的OpenJDK版本，尽管这需要超出许多公司的工程能力。
- en: 'With this in mind, the main factors that organizations typically care about
    are:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在此基础上，组织通常关心的主要因素是：
- en: Do I have to pay money to use this in production?
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在生产环境中使用这个是否需要支付费用？
- en: How can I get any bugs I discover fixed?
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我如何让我发现的任何错误得到修复？
- en: How do I get security patches?
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何获取安全补丁？
- en: 'To take these in turn:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 依次处理这些问题：
- en: A binary that has been built from OpenJDK source (which is GPLv2+CE-licensed)
    is free to use in production. This includes all binaries from Eclipse Adoptium,
    Red Hat, Amazon, and Microsoft; as well as binaries from lesser-known suppliers
    such as BellSoft. Some, but not all, of Oracle’s binaries also fall into this
    category.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 从OpenJDK源代码构建的二进制文件（其使用GPLv2+CE许可证）可以在生产环境中免费使用。这包括来自Eclipse Adoptium、Red Hat、Amazon和Microsoft的所有二进制文件；以及来自BellSoft等较少知名供应商的二进制文件。Oracle的某些二进制文件也属于此类，但不是全部。
- en: 'Next up, to get a bug fixed in OpenJDK the discoverer may do one of two things:
    either buy a support contract and get the vendor to fix it; or ask an OpenJDK
    author to file a bug against the OpenJDK repo and then hope that (or ask nicely)
    someone fixes it for you. Or there’s always the inevitable third option that all
    open-source software provides—​fix it yourself and then submit a patch.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，要修复OpenJDK中的错误，发现者可以采取以下两种方式之一：购买支持合同并让供应商进行修复；或要求OpenJDK的作者提交一个错误报告到OpenJDK存储库，然后希望（或友好地要求）有人为您修复它。或者总是提供的第三种选择，即所有开源软件都提供的选择——自己修复然后提交补丁。
- en: The final point—​about security updates—​is slightly more subtle. First off,
    note that almost all changes to Java start off as commits to a public OpenJDK
    repository on GitHub. The exception to this is certain security fixes that have
    not yet been publicly disclosed.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一点——关于安全更新——稍微复杂一些。首先要注意的是，几乎所有Java的更改都起始于GitHub上公开的OpenJDK仓库的提交。唯一的例外是某些尚未公开披露的安全修复。
- en: When a fix is released and made public, there is a process by which the patch
    flows back into the various OpenJDK repos. The vendors will then be able to take
    that source code fix and build and release a binary which contains it. However,
    there are some subtleties to this process, which is one reason why most Java shops
    prefer to remain on a long-term support (or LTS) version—​we will have more to
    say about this in the section about Java versions.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个修复程序发布并公开时，有一个流程可以使补丁流回到各种OpenJDK仓库中。供应商随后将能够获取该源代码修复并构建和发布包含它的二进制文件。然而，这个过程有一些微妙之处，这也是为什么大多数Java商店更喜欢保持长期支持（或LTS）版本的原因——在关于Java版本的部分我们将会有更多讨论。
- en: 'Now that we’ve discussed the main criteria for choosing a distribution, let’s
    meet some of the main offerings that are available:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了选择发行版的主要标准，让我们来看看一些主要的可用选择：
- en: Oracle
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle
- en: Oracle’s Java (Oracle JDK) is perhaps the most widely known implementation.
    It is essentially the OpenJDK codebase, relicensed under Oracle’s proprietary
    licenses with a few extremely minor differences (such as the inclusion of some
    additional components that are not available under an open-source license). Oracle
    achieves this by having all contributors to OpenJDK sign a license agreement that
    permits dual licensing of their contribution to both the GPLv2+CE of OpenJDK and
    Oracle’s proprietary license.^([3](ch03.xhtml#id106))
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle的Java（Oracle JDK）可能是最广为人知的实现。它本质上是OpenJDK代码库，以Oracle专有许可证重新许可，只有一些极小的差异（例如包含一些在开源许可证下不可用的附加组件）。Oracle通过要求所有OpenJDK的贡献者签署许可协议来实现双重许可，允许其贡献同时采用OpenJDK的GPLv2+CE许可和Oracle的专有许可。^([3](ch03.xhtml#id106))
- en: Eclipse Adoptium
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: Eclipse Adoptium
- en: This community-led project started life as AdoptOpenJDK, changing name when
    it transitioned into the Eclipse Foundation. The Members of the Adoptium project
    (from companies such as Red Hat, Google, Microsoft, and Azul) consist mostly of
    build and test engineers, rather than development engineers (who implement new
    features and fix bugs). This is by design—​many of Adoptium’s member companies
    also make major contributions to upstream OpenJDK development, but do so under
    their own company names, rather than Adoptium. The Adoptium project takes the
    OpenJDK source and builds fully-tested binaries on multiple platforms. As a community
    project, Adoptium does not offer paid support, although member companies may choose
    to do so—​for example Red Hat does for some operating systems.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这个由社区领导的项目最初是AdoptOpenJDK，在转变为Eclipse基金会时更名为Adoptium。Adoptium项目的成员（来自Red Hat、Google、Microsoft和Azul等公司）主要是构建和测试工程师，而不是开发工程师（负责实现新功能和修复错误）。这是有意设计的——Adoptium的许多成员公司也为上游OpenJDK开发做出重大贡献，但是以各自公司的名义而不是Adoptium的名义进行。Adoptium项目获取OpenJDK源代码并在多个平台上构建完全经过测试的二进制文件。作为一个社区项目，Adoptium不提供付费支持，尽管成员公司可能选择这样做——例如Red
    Hat在某些操作系统上提供支持。
- en: Red Hat
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: Red Hat
- en: Red Hat is the longest-standing non-Oracle producer of Java binaries—​as well
    as the second-largest contributor to OpenJDK (behind Oracle). They produce builds
    and provide support for their operating systems—​RHEL and Fedora—​and Windows
    (for historical reasons). Red Hat also releases freely-available container images
    based on their Universal Base Image (UBI) Linux system.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: Red Hat是Java二进制文件中历史最悠久的非Oracle生产商，也是OpenJDK的第二大贡献者（仅次于Oracle）。他们为他们的操作系统（如RHEL和Fedora）以及Windows（出于历史原因）制作构建并提供支持。Red
    Hat还发布基于他们的Universal Base Image（UBI）Linux系统的免费容器映像。
- en: Amazon Corretto
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: Amazon Corretto
- en: Corretto is Amazon’s distribution of OpenJDK, and it is intended to run primarily
    on AWS cloud infrastructure. Amazon also provides builds for Mac, Windows and
    Linux in order to provide a consistent developer experience, and to encourage
    developers to use their builds across all environments.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: Corretto是亚马逊的OpenJDK发行版，主要用于AWS云基础设施。亚马逊还提供了Mac、Windows和Linux的构建，以提供一致的开发者体验，并鼓励开发者在所有环境中使用他们的构建。
- en: Microsoft OpenJDK
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: Microsoft OpenJDK
- en: Microsoft has been producing binaries since May 2021 (OpenJDK 11.0.11) for Mac,
    Windows and Linux. Just as for AWS, Microsoft’s distribution is largely intended
    to provide an easy on-ramp for developers who will be deploying on their Azure
    cloud infrastructure.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 自2021年5月起，Microsoft开始为Mac、Windows和Linux生产二进制文件（OpenJDK 11.0.11）。与AWS类似，Microsoft的发行版主要旨在为将在其Azure云基础设施上部署的开发人员提供便捷的入门途径。
- en: Azul Systems
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: Azul Systems
- en: Zulu is a free OpenJDK implementation provided by Azul Systems—​who also offer
    paid support for their OpenJDK binaries. Azul also offer a high-performance proprietary
    JVM called “Azul Platform Prime” (previously known as Zing). Prime is not an OpenJDK
    distribution.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: Zulu是Azul Systems提供的免费OpenJDK实现，同时他们也为其OpenJDK二进制文件提供付费支持。Azul还提供一款高性能的专有JVM，名为“Azul平台Prime”（以前称为Zing）。Prime并非一个OpenJDK发行版。
- en: GraalVM
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: GraalVM
- en: GraalVM is a relatively new addition to this list. Originally a research project
    at Oracle Labs, it has graduated to a fully productionized Java implementation
    (and much more besides). GraalVM can operate in dynamic VM mode and includes an
    OpenJDK-based runtime—​augmented with a JIT compiler that is written in Java.
    However, GraalVM is also capable of *native compilation* of Java—​essentially
    AOT compilation. We will have more to say on this subject later in the book.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: GraalVM是这个列表的一个相对较新的添加。最初是Oracle Labs的研究项目，现已发展为一个完全成熟的Java实现（以及更多其他功能）。GraalVM可以在动态VM模式下运行，并包括基于OpenJDK的运行时——增强了用Java编写的JIT编译器。然而，GraalVM也能够对Java进行本地编译，即AOT编译。关于这个主题，本书稍后将会详细介绍。
- en: OpenJ9
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: OpenJ9
- en: OpenJ9 started life as IBM’s proprietary JVM (when it was just called J9) but
    was open-sourced in 2017 partway through its life (just like HotSpot). It is now
    built on top of an Eclipse open runtime project (OMR). It is fully compliant with
    Java certification. IBM Semeru Runtimes are zero-cost runtimes built with the
    OpenJDK class libraries and the Eclipse OpenJ9 JVM (which is Eclipse-licensed).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: OpenJ9最初作为IBM的专有JVM（当时称为J9）而诞生，但在其寿命中段（就像HotSpot一样）于2017年开源。它现在建立在Eclipse开放运行时项目（OMR）之上，并且完全符合Java认证。IBM
    Semeru Runtimes是使用OpenJDK类库和Eclipse OpenJ9 JVM（受Eclipse许可证）构建的零成本运行时。
- en: Android
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: Android
- en: Google’s Android project is sometimes thought of as being “based on Java.” However,
    the picture is actually a little more complicated. Android uses a cross compiler
    to convert class files to a different (*.dex*) file format. These `.dex` files
    are then executed by the Android Runtime (ART), which is not a JVM. In fact, Google
    now recommends the Kotlin language over Java for developing Android apps. As this
    technology stack is so far from the other examples, we won’t consider Android
    any further in this book.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: Google的Android项目有时被认为是“基于Java”。但实际情况更为复杂。Android使用交叉编译器将类文件转换为不同的（*.dex*）文件格式。这些`.dex`文件然后由Android
    Runtime（ART）执行，ART并不是一个JVM。事实上，Google现在推荐使用Kotlin语言来开发Android应用程序。由于这一技术栈与其他示例有较大不同，本书不再深入讨论Android。
- en: Note that this list is not intended to be comprehensive—​there are other distributions
    available as well.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此列表并非全面之列——还有其他可用的发行版。
- en: The vast majority of the rest of this book focuses on the technology found in
    HotSpot. This means the material applies equally to Oracle’s Java and the distributions
    provided by Adoptium, Red Hat, Amazon, Microsoft, Azul Zulu, and all other OpenJDK-derived
    JVMs.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的绝大部分内容都集中在HotSpot技术上。这意味着这些材料同样适用于Oracle的Java以及Adoptium、Red Hat、Amazon、Microsoft、Azul
    Zulu等提供的发行版所使用的JVM。
- en: We also include some material related to Eclipse Open J9 . This is intended
    to provide an awareness of alternatives rather than a definitive guide. Some readers
    may wish to explore these technologies more deeply, and they are encouraged to
    proceed by setting performance goals, and then measuring and comparing, in the
    usual manner.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还包含了一些与Eclipse Open J9相关的内容。这旨在提供对替代选择的认识，而不是一个权威指南。一些读者可能希望深入了解这些技术，我们鼓励他们通过设定性能目标、进行测量和比较来进一步探索。
- en: Finally, before we discuss the Java release cycle, a word about the performance
    characteristics of the various OpenJDK distributions.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在讨论Java发布周期之前，我们来谈谈各种OpenJDK发行版的性能特性。
- en: Teams occasionally ask questions about performance—​sometimes because they mistakenly
    believe that certain distributions include different JIT or GC components that
    are not available in other OpenJDK-based distributions.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 团队偶尔会询问性能问题——有时是因为他们错误地认为某些发行版包含其他OpenJDK发行版中不可用的不同JIT或GC组件。
- en: 'So let’s clear that up right now: All the OpenJDK distributions build from
    the same source, and there should be *no* systematic performance-related differences
    between the various HotSpot-based implementations, when comparing like-for-like
    versions and build flag configurations.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 所以现在让我们澄清一下：所有OpenJDK发行版均来自同一源代码，并且在比较相同版本和构建标志配置时，不应存在*任何*系统性能相关差异。
- en: Note
  id: totrans-254
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Some vendors choose very specific build flag combinations that are highly specific
    to their cloud environments, and some research indicates that these combinations
    *may* help for some subset of workloads, but this is far from clear-cut.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 一些供应商选择非常特定的构建标志组合，这些组合非常适合它们的云环境，一些研究表明这些组合*可能*对某些工作负载有帮助，但情况并不明确。
- en: Once in a while, social media excitedly reports that significant performances
    differences have been found between some of the distributions. However, carrying
    out such tests in a sufficiently controlled environment is notoriously difficult—​so
    any results should be treated with healthy skepticism unless they can be independently
    verified as statistically rigorous.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 偶尔社交媒体激动地报道发现一些发行版之间存在显著的性能差异。然而，在足够受控的环境中进行这类测试是非常困难的——因此除非可以独立验证具有统计显著性，否则应对任何结果持健康的怀疑态度。
- en: The Java release cycle
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Java发布周期
- en: We can now complete the picture by briefly discussing the Java release cycle.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过简要讨论Java发布周期来完整地说明这个情况。
- en: New feature development happens in the open—​at a collection of GitHub repositories.
    Small to medium features and bug fixes are accepted as pull requests directly
    against the main branch in the main OpenJDK repository.^([4](ch03.xhtml#id107))
    Larger features and major projects are frequently developed in forked repos and
    then migrated into mainline when ready.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 新功能开发是公开的——在一组GitHub存储库中进行。小到中等的功能和错误修复以拉取请求直接提交到主OpenJDK存储库的主分支中。^([4](ch03.xhtml#id107))
- en: Every 6 months, a new release of Java is cut from whatever is in main. Features
    that “miss the train” must wait for the next release—​the 6-month cadence and
    strict timescale has been maintained since September 2017. These releases are
    known as “feature releases”, and they are run by Oracle, in their role as stewards
    of Java.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 每6个月，Java会从主要版本中切出一个新版本。错过“列车”的功能必须等待下一个发布——自2017年9月以来，这种6个月的节奏和严格的时间表一直得到维持。这些发布被称为“功能发布”，由Oracle作为Java的管理者运行。
- en: Oracle ceases to work on any given feature release as soon as the next feature
    release appears. However, an OpenJDK member of suitable standing and capability
    can offer to continue running the release after Oracle steps down. To date, this
    has only happened for certain releases—​in practice Java 8, 11, 17 and 21, which
    are known as *update releases*.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle在任何给定的功能版本发布后立即停止工作。然而，一个适当资格和能力的OpenJDK成员可以在Oracle退出后继续运行该版本。迄今为止，这仅发生在某些版本上——实际上是Java
    8、11、17和21，被称为*更新版本*。
- en: The significance of these releases is that they match Oracle’s Long-Term Support
    release concept. Technically, this is purely a construct of Oracle’s sales process—​whereby
    Oracle customers who do not want to upgrade Java every 6 months have certain stable
    versions that Oracle will support them on.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这些版本的重要性在于它们符合Oracle的长期支持版本概念。从技术上讲，这纯粹是Oracle销售流程的构建——即那些不想每6个月升级Java的Oracle客户有某些稳定版本可供Oracle支持。
- en: In practice, the Java ecosystem has overwhelmingly rejected the official Oracle
    dogma of “upgrade your JDK every 6 months"--project teams and engineering managers
    simply have no appetite for it. Instead, teams upgrade from one LTS version to
    the next, and the update release projects (8u, 11u, 17u and 21u) remain active,
    delivering security patches and a small number of bug fixes and backports. Oracle
    and the community work together to keep all these maintained code streams secure.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，Java生态系统已经明显拒绝了官方Oracle的“每6个月升级您的JDK”的教条——项目团队和工程经理根本不愿意这样做。相反，团队会从一个LTS版本升级到下一个，更新版本项目（如8u、11u、17u和21u）仍然活跃，提供安全补丁和少量错误修复和反向移植。Oracle和社区一起努力保持所有这些维护的代码流的安全性。
- en: 'This is the final piece we need to answer the question of how to pick a Java
    distribution. If you want a zero-cost Java distribution that receives security
    patches and has a non-zero chance of security (and possibly bug) fixes, select
    your choice of OpenJDK vendor and stick to the LTS versions. Any of: Adoptium,
    Red Hat, Amazon, Microsoft and Azul is a fine choice—​and so are some of the others.
    Depending on how and where you’re deploying your software (e.g. applications deployin
    in AWS may prefer Amazon’s Corretto distribution) you may have a reason to pick
    one of those over the others.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们回答如何选择Java发行版的最后一部分。如果您想要一个零成本的Java发行版，它能够接收安全补丁并且有可能进行安全（以及可能的错误）修复，请选择您喜欢的OpenJDK供应商并坚持使用LTS版本。包括：Adoptium、Red
    Hat、Amazon、Microsoft和Azul在内的任何一个都是一个不错的选择——其他一些也是如此。根据您部署软件的方式和位置（例如，在AWS上部署的应用程序可能更喜欢Amazon的Corretto发行版），您可能有理由选择其中之一。
- en: For a more in-depth guide to the various options and some of the licensing complexities,
    you can consult [Java Is Still Free](https://medium.com/@javachampions/java-is-still-free-3-0-0-ocrt-2021-bca75c88d23b)
    This document was written by the [Java Champions](https://dev.java/community/jcs/),
    an independent body of Java experts and leaders.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于各种选项和一些许可复杂性的详细指南，您可以查阅[Java仍然是免费的](https://medium.com/@javachampions/java-is-still-free-3-0-0-ocrt-2021-bca75c88d23b)。这份文件由[Java
    Champions](https://dev.java/community/jcs/)编写，他们是独立的Java专家和领导者。
- en: Summary
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter we have taken a quick tour through the overall anatomy of the
    JVM, including: compilation of byte code, interpretation, JIT compilation to native
    code, memory management, threading, the lifecycle of a Java process monitoring,
    and finally, how Java is built and distributed.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们快速浏览了JVM的整体解剖，包括：字节码编译、解释、JIT编译成本机代码、内存管理、线程、Java进程监控的生命周期，以及最后讨论了Java的构建和分发。
- en: It has only been possible to touch on some of the most important subjects, and
    virtually every topic mentioned here has a rich, full story behind it that will
    reward further investigation.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只能触及一些最重要的主题，几乎这里提到的每个主题都有一个丰富的、完整的故事背后，进一步的调查将会有所收获。
- en: In Chapter 4 we will begin our journey into garbage collection, starting with
    the basic concepts of mark-and-sweep and diving into the specifics, including
    some of the internal details of how HotSpot implements GC.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4章中，我们将开始探讨垃圾收集的旅程，从标记-清除的基本概念入手，深入到具体细节，包括HotSpot如何实现GC的一些内部细节。
- en: ^([1](ch03.xhtml#id104-marker)) B. Stroustrup, “Abstraction and the C++ Machine
    Model,” *Lecture Notes in Computer Science*, vol. 3605 (Springer 2005)
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch03.xhtml#id104-marker)) B. Stroustrup，“抽象和C++机器模型”，*计算机科学讲义*，第3605卷（Springer
    2005）
- en: ^([2](ch03.xhtml#id105-marker)) [*https://openjdk.org/legal/gplv2+ce.xhtml*](https://openjdk.org/legal/gplv2+ce.xhtml)
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch03.xhtml#id105-marker)) [*https://openjdk.org/legal/gplv2+ce.xhtml*](https://openjdk.org/legal/gplv2+ce.xhtml)
- en: ^([3](ch03.xhtml#id106-marker)) The latter has changed multiple times, so linking
    to the currently latest version might not be helpful—​it could be out-of-date
    by the time you read this.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch03.xhtml#id106-marker)) 后者已多次更改，因此链接到当前最新版本可能并不实用——到您阅读本文时可能已过时。
- en: ^([4](ch03.xhtml#id107-marker)) [*https://github.com/openjdk/jdk*](https://github.com/openjdk/jdk)
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch03.xhtml#id107-marker)) [*https://github.com/openjdk/jdk*](https://github.com/openjdk/jdk)
