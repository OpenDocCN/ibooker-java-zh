<html><head></head><body><section data-pdf-bookmark="Chapter 4. Design Principles of Reactive Systems" data-type="chapter" epub:type="chapter"><div class="chapter" id="reactive-systems">&#13;
<h1><span class="label">Chapter 4. </span>Design Principles of Reactive Systems</h1>&#13;
&#13;
&#13;
<p><a data-primary="design principles of reactive systems" data-type="indexterm" id="ix_reactive-systems-adoc0"/><a data-primary="reactive systems" data-type="indexterm" id="ix_reactive-systems-adoc1"/><a data-primary="reactive systems" data-secondary="design principles" data-type="indexterm" id="ix_reactive-systems-adoc2"/>In <a data-type="xref" href="ch03.html#distributed-system">Chapter 3</a>, we looked at the challenges behind distributed systems.&#13;
It’s now time to see what Reactive has to offer.&#13;
Reactive can be seen as a set of principles for building distributed systems, a kind of checklist to verify that no major known concern was overlooked while architecting and building a system.&#13;
These principles focus on the following:</p>&#13;
<dl>&#13;
<dt>Responsiveness</dt>&#13;
<dd>&#13;
<p>The ability to handle requests when facing failures or peaks of load</p>&#13;
</dd>&#13;
<dt>Efficiency</dt>&#13;
<dd>&#13;
<p>The ability to do more with fewer resources</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>In this chapter, we cover the principles promoted by reactive systems.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Reactive Systems 101" data-type="sect1"><div class="sect1" id="idm45358831739648">&#13;
<h1>Reactive Systems 101</h1>&#13;
&#13;
<p><a data-primary="design principles of reactive systems" data-secondary="characteristics of reactive systems" data-type="indexterm" id="ix_reactive-systems-adoc3"/><a data-primary="reactive systems" data-secondary="characteristics of" data-type="indexterm" id="ix_reactive-systems-adoc4"/>In 2013, a group of distributed systems experts gathered and wrote the first version of <a data-primary="&quot;The Reactive Manifesto&quot;" data-primary-sortas="Reactive Manifesto" data-type="indexterm" id="idm45358831735344"/>“The Reactive Manifesto.”&#13;
They assembled in this whitepaper their experience building distributed systems and cloud applications.&#13;
While in 2013 the cloud was not precisely what it is today, the dynamic creation of ephemeral resources was already a well-known mechanism.</p>&#13;
&#13;
<p>“The Reactive Manifesto” defines <em>reactive systems</em> as distributed systems having four characteristics:</p>&#13;
<dl>&#13;
<dt>Responsive</dt>&#13;
<dd>&#13;
<p>Able to handle requests in a timely fashion</p>&#13;
</dd>&#13;
<dt>Resilient</dt>&#13;
<dd>&#13;
<p>Able to manage failures gracefully</p>&#13;
</dd>&#13;
<dt>Elastic</dt>&#13;
<dd>&#13;
<p>Able to scale up and down according to the load and resources</p>&#13;
</dd>&#13;
<dt>Message driven</dt>&#13;
<dd>&#13;
<p>Using asynchronous message-based communication among the components forming the system</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>These four characteristics are represented in <a data-type="xref" href="#image:reactive-systems">Figure 4-1</a>.</p>&#13;
&#13;
<figure><div class="figure" id="image:reactive-systems">&#13;
<img alt="Reactive systems characteristics" src="assets/rsij_0401.png"/>&#13;
<h6><span class="label">Figure 4-1. </span>Reactive systems characteristics</h6>&#13;
</div></figure>&#13;
&#13;
<p>If you’re seeing this picture for the first time, you may be confused by all the arrows.&#13;
It can look like a well-tailored marketing campaign.&#13;
It’s not, and let’s explain why these pillars make a lot of sense when building cloud native and Kubernetes-native applications.&#13;
Let’s start with the bottom of the figure.</p>&#13;
&#13;
<p>Instead of trying to make distributed systems simpler than they are, reactive systems embrace their asynchronous nature.&#13;
<a data-primary="asynchronous message passing" data-secondary="reactive systems and" data-type="indexterm" id="idm45358831722640"/>They use <em>asynchronous message passing</em> to establish the connective tissue among the components.&#13;
Asynchronous message passing ensures loose coupling, isolation, and location transparency.&#13;
In a reactive system, interactions rely on messages sent to abstract destinations.&#13;
These messages carry everything—data as well as failures.&#13;
Asynchronous message passing also improves resource utilization.&#13;
Employing nonblocking communication (we cover that part later in this chapter) allows idle components to consume almost no CPU and memory.&#13;
Asynchronous message passing enables elasticity and resilience, as depicted by the two bottom arrows in <a data-type="xref" href="#image:reactive-systems">Figure 4-1</a>.</p>&#13;
&#13;
<p><a data-primary="elasticity" data-secondary="defined" data-type="indexterm" id="idm45358831719344"/><em>Elasticity</em> means that the system can adapt itself, or parts of itself, to handle the fluctuating load.&#13;
By looking at the messages flowing among the components, a system can determine which parts reach their limits and create more instances or route the messages elsewhere.&#13;
Cloud infrastructure enables creating these instances quickly at runtime.&#13;
But elasticity is not only about scaling up; it’s also about scaling down.&#13;
The system can decide to scale down underused parts to save resources.&#13;
At runtime, the system adjusts itself, always meeting the current demand, avoiding bottlenecks, overflows, and overcommitted resources.&#13;
As you can imagine, elasticity requires observability, replication, and routing features.&#13;
Observability is covered in <a data-type="xref" href="ch13.html#observability">Chapter 13</a>.&#13;
In general, the last two are provided by the infrastructure such as Kubernetes or cloud providers.</p>&#13;
&#13;
<p><a data-primary="resilience, in reactive systems" data-type="indexterm" id="idm45358831716032"/><em>Resilience</em> means handling failure gracefully.&#13;
As explained in <a data-type="xref" href="ch03.html#distributed-system">Chapter 3</a>, failures are inevitable in distributed systems.&#13;
Instead of hiding them, reactive systems consider failures first-class citizens.&#13;
The system should be able to handle them and react to them.&#13;
Failures are contained within each component, isolating components from one another.&#13;
This isolation ensures that parts of the system can fail and recover without jeopardizing the whole system.&#13;
For instance, by replicating components (elasticity), the system can continue to handle incoming messages even if some elements are failing.&#13;
The implementation of resilience is shared between the application (which needs to be aware of failures, contain them, and, if possible, handle them gracefully) and the infrastructure (which monitors the systems and restarts fallen components).</p>&#13;
&#13;
<p><a data-primary="responsiveness, in reactive systems" data-type="indexterm" id="idm45358831712944"/>The last characteristic is the whole purpose of reactive systems: being <em>responsive</em>.&#13;
Your system needs to stay responsive—to respond in a timely fashion—even under fluctuating load (elasticity) and when facing failure (resilience).&#13;
Relying on message passing enables these characteristics and much more, such as flow control by monitoring the messages in the system and applying backpressure when necessary.</p>&#13;
&#13;
<p>In a nutshell, reactive systems are exactly what we want to build: distributed systems able to handle the uncertainty, failures, and load efficiently.&#13;
Their characteristics meet the requirement for cloud native and Kubernetes-native applications perfectly.&#13;
But don’t be mistaken; building a reactive system is still making a distributed system.&#13;
It’s challenging.&#13;
However, by following these principles, the resulting system will be more responsive, more robust, and more efficient.&#13;
The rest of this book details how we can easily implement such systems with Quarkus and messaging technologies.<a data-startref="ix_reactive-systems-adoc4" data-type="indexterm" id="idm45358831710336"/><a data-startref="ix_reactive-systems-adoc3" data-type="indexterm" id="idm45358831709616"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Commands and Events" data-type="sect1"><div class="sect1" id="idm45358831739024">&#13;
<h1>Commands and Events</h1>&#13;
&#13;
<p>Now that we’ve covered many of the foundational principles, you might be confused.&#13;
In <a data-type="xref" href="ch01.html#introduction">Chapter 1</a>, we said that being reactive is related to being event driven, but in the previous section, we explicitly mentioned asynchronous message passing.&#13;
Does that mean the same thing? Not completely.</p>&#13;
&#13;
<p>But first, we need to discuss the differences between commands and events.&#13;
As complicated as a distributed system design can be, the concepts of commands and events are fundamental.&#13;
Nearly all interactions between individual components involve one or the other.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Commands" data-type="sect2"><div class="sect2" id="idm45358831705552">&#13;
<h2>Commands</h2>&#13;
&#13;
<p><a data-primary="commands" data-secondary="in reactive systems" data-type="indexterm" id="idm45358831704352"/><a data-primary="design principles of reactive systems" data-secondary="commands" data-type="indexterm" id="idm45358831703376"/><a data-primary="reactive systems" data-secondary="commands" data-type="indexterm" id="idm45358831702464"/>Every system issues commands.&#13;
<em>Commands</em> are actions that a user wishes to perform.&#13;
Most HTTP-based APIs pass commands: the client asks for an action to happen.&#13;
It’s important to understand that the action has not yet happened.&#13;
It may happen in the future, or not; it may complete successfully or fail.&#13;
In general, commands are sent to a specific recipient, and a result is sent back to the client.</p>&#13;
&#13;
<p>Take the simple HTTP application we used in <a data-type="xref" href="ch03.html#distributed-system">Chapter 3</a>.&#13;
You emitted a simple HTTP request.&#13;
As we’ve said, that was a command.&#13;
The application receives that command, handles it, and produces a result.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Events" data-type="sect2"><div class="sect2" id="idm45358831698896">&#13;
<h2>Events</h2>&#13;
&#13;
<p><a data-primary="design principles of reactive systems" data-secondary="events" data-type="indexterm" id="idm45358831697728"/><a data-primary="events" data-secondary="reactive systems and" data-type="indexterm" id="idm45358831696688"/><a data-primary="reactive systems" data-secondary="events" data-type="indexterm" id="idm45358831695744"/><em>Events</em> are actions that have successfully completed.&#13;
An event represents a <em>fact</em>, something that happened: a keystroke, a failure, an order, anything important to the organization or system at hand.&#13;
An event can be the result of work done by a command.</p>&#13;
&#13;
<p>Let’s go back to the preceding HTTP request example.&#13;
Once the response has been written, it becomes an event.&#13;
We have seen an HTTP request and its response.&#13;
That event can be written in a log or broadcast to interested parties so they can be aware of what happened.</p>&#13;
&#13;
<p>Events are immutable.&#13;
You cannot delete an event.&#13;
Admittedly, you can’t change the past.&#13;
If you want to refute a previously sent fact, you need to fire another event invalidating the fact.&#13;
The carried facts are made irrelevant only by another fact establishing the current knowledge.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Messages" data-type="sect2"><div class="sect2" id="idm45358831692128">&#13;
<h2>Messages</h2>&#13;
&#13;
<p><a data-primary="messages" data-secondary="reactive systems and" data-type="indexterm" id="idm45358831690752"/>But, how to publish these events?&#13;
There are many ways.&#13;
These days, solutions like Apache Kafka or Apache ActiveMQ (we cover both in <a data-type="xref" href="ch11.html#event-bus">Chapter 11</a>) are popular.&#13;
They act as brokers between the producers and consumers.&#13;
Essentially, our events are written into <em>topics</em> or <em>queues</em>.&#13;
To write these events, the application sends a message to the broker, targeting a specific destination (the queue or the topic).</p>&#13;
&#13;
<p><a data-primary="messages" data-secondary="defined" data-type="indexterm" id="idm45358831687312"/>A <em>message</em> is a self-contained data structure describing the event and any relevant details about the event, such as who emitted it, at what time it was emitted, and potentially its unique ID.&#13;
It’s generally better to keep the event itself business-centric and use additional metadata for the technical aspects.</p>&#13;
&#13;
<p>On the other side, to consume events, you subscribe to the queue or topic containing the events you are interested in and receive the messages.&#13;
You unwrap the event and can also get the associated metadata (for example, when the event happened, where it happened, and so forth).&#13;
The processing of an event can lead to the publication of other events (again, packaged in messages and sent to a known destination) or to the execution of commands.</p>&#13;
&#13;
<p>Brokers and messages can also convey commands.&#13;
In this case, the message contains the description of the action to execute, and another message (potentially multiple messages) would carry the outcome if needed.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Commands Versus Events: An Example" data-type="sect2"><div class="sect2" id="idm45358831683824">&#13;
<h2>Commands Versus Events: An Example</h2>&#13;
&#13;
<p><a data-primary="commands" data-secondary="events versus" data-type="indexterm" id="ix_reactive-systems-adoc5"/><a data-primary="design principles of reactive systems" data-secondary="commands versus events" data-type="indexterm" id="ix_reactive-systems-adoc6"/><a data-primary="events" data-secondary="commands versus" data-type="indexterm" id="ix_reactive-systems-adoc7"/><a data-primary="reactive systems" data-secondary="commands versus events" data-type="indexterm" id="ix_reactive-systems-adoc8"/>Let’s take a look at an example to highlight the differences between commands and events.&#13;
Imagine an ecommerce shop, like the one depicted in <a data-type="xref" href="#image:shop-order-services">Figure 4-2</a>.&#13;
The user picks a set of products and finalizes the order (process to payment, get the delivery date, etc.).</p>&#13;
&#13;
<figure><div class="figure" id="image:shop-order-services">&#13;
<img alt="Simplified architecture of an ecommerce shop" src="assets/rsij_0402.png"/>&#13;
<h6><span class="label">Figure 4-2. </span>Simplified architecture of an ecommerce shop</h6>&#13;
</div></figure>&#13;
&#13;
<p>The user sends a command (using an HTTP request, for example) to the shop service with the items the user wishes to receive. In a traditional application, once <code>ShopService</code> receives the command, it would call <code>OrderService</code> and invoke an <code>order</code> method with the username, the list of items (basket), and so on.&#13;
Calling the <code>order</code> method is a command.&#13;
That makes <code>ShopService</code> dependent on <code>OrderService</code> and reduces the component autonomy: <code>ShopService</code> cannot operate without <code>OrderService</code>.&#13;
We are creating a distributed monolith, a distributed application that would collapse as soon as one of its parts fails.<sup><a data-type="noteref" href="ch04.html#idm45358831669616" id="idm45358831669616-marker">1</a></sup></p>&#13;
&#13;
<p>Let’s see the difference if, instead of using a command between <code>ShopService</code> and <code>OrderService</code>, we publish an event.&#13;
Once the user finalizes the order, the application still sends a command to <code>ShopService</code>.&#13;
However, this time, <code>ShopService</code> <em>transforms</em> that command into an event: <em>a new order has been placed</em>.&#13;
The event contains the user, the basket, and so on.&#13;
The event is a fact written in a log, or wrapped into a message and sent to a broker.</p>&#13;
&#13;
<p>On the other side, <code>OrderService</code> observes the <em>a new order has been placed</em> event, by reading where these events are stored.&#13;
When <code>ShopService</code> emits the event, it receives it and can process it.</p>&#13;
&#13;
<p>With this architecture, <code>ShopService</code> does not depend on <code>OrderService</code>.&#13;
In addition, <code>OrderService</code> does not depend on <code>ShopService</code>, and it would process any observed event, regardless of the emitter.&#13;
For example, a mobile application can emit the same event when the user validates an order from a mobile phone.</p>&#13;
&#13;
<p>Multiple components can consume events (<a data-type="xref" href="#image:shop-messages">Figure 4-3</a>).&#13;
For example, in addition to <code>OrderService</code>, <code>StatisticsService</code> keeps track of the most ordered items.&#13;
It consumes the same event, without having to modify <code>ShopService</code> to receive them.</p>&#13;
&#13;
<p>A component observing events can derive new ones from them.&#13;
For instance, &#13;
<span class="keep-together"><code>StatisticsService</code></span> could analyze the order and compute recommendations.&#13;
These recommendations could be seen as another fact, and so communicate as an event.&#13;
<code>ShopService</code> could observe these events and process them to influence item selection.&#13;
However, <code>StatisticsService</code> and <code>ShopService</code> are independent of each other.&#13;
The knowledge is cumulative and occurs by receiving new events and deriving, as done by <code>StatisticsService</code>, new facts from the received events.</p>&#13;
&#13;
<p><a data-primary="message queues" data-type="indexterm" id="idm45358831654496"/>As depicted in <a data-type="xref" href="#image:shop-messages">Figure 4-3</a>, we can use <em>message queues</em> to transport our events.&#13;
These events are wrapped into messages, sent to known destinations (<code>orders</code> and &#13;
<span class="keep-together"><code>recommendations</code></span>).&#13;
<code>OrderService</code> and <code>StatisticsService</code> consume and process the messages independently.</p>&#13;
&#13;
<figure><div class="figure" id="image:shop-messages">&#13;
<img alt="Architecture of the ecommerce shop using events and message brokers" src="assets/rsij_0403.png"/>&#13;
<h6><span class="label">Figure 4-3. </span>Architecture of the ecommerce shop with events and message queues</h6>&#13;
</div></figure>&#13;
&#13;
<p>It’s important for these destinations to persist the events as an ordered sequence.&#13;
By keeping that sequence, the system can go back in time and reprocess the events.&#13;
<a data-primary="replay mechanism" data-type="indexterm" id="idm45358831647152"/>Such a <em>replay</em> mechanism, popular in the Kafka world, has multiple benefits.&#13;
You can restart with a clean state after a disaster by reprocessing all the stored events.&#13;
Then, if we change the recommendation algorithm from the statistic services, for example, it would be able to re-accumulate all the knowledge and derive new recommendations.</p>&#13;
&#13;
<p>While the event emission sounds explicit in this example, that’s not always the case.&#13;
For instance, events can be created from database writes.<sup><a data-type="noteref" href="ch04.html#idm45358831644992" id="idm45358831644992-marker">2</a></sup></p>&#13;
<aside class="pagebreak-before less_space" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45358831642624">&#13;
<h5>Independence</h5>&#13;
<p><a data-primary="messages" data-secondary="independence of system components and" data-type="indexterm" id="idm45358831641040"/>Using messages increases the independence of the components forming the system.&#13;
This independence is relative.&#13;
While the components don’t know one another, the emitted events and receivers need to share a common vocabulary.&#13;
This vocabulary is often business related but can be technical too.</p>&#13;
&#13;
<p>In the case of business events, they obviously arise from the analysis of the domain.&#13;
By looking at your system in terms of commands and events, you focus on the <em>behavior</em> instead of the <em>structure</em> (we focus on structure most of the time).&#13;
Focusing on behavior puts primary attention on the communications and the workflows, and allows determining who is responsible for what and the kind of interactions (commands or events) that are the most appropriate.&#13;
From this analysis, you can determine the type of interactions, the data they must encapsulate, and how they flow in your system.</p>&#13;
&#13;
<p>Workshops and techniques—such as <a href="https://oreil.ly/IutZ7">event storming</a> and the ones listed on the <a href="https://oreil.ly/jBh1r">Domain-Driven Design Crew page</a>—can ease that analysis.&#13;
These techniques will let you extract the events, the commands, the components, and, most importantly, highlight the communications.</p>&#13;
</div></aside>&#13;
&#13;
<p>Commands and events are the basis of most of the interactions.&#13;
While we use mostly commands, events come with significant benefits.&#13;
Events are facts.&#13;
Events tell a story, the story of your system, a narrative that describes your system’s evolution. In reactive systems, events are wrapped into messages, and these messages are sent to destinations, transported by message brokers such as AMQP or Kafka (<a data-type="xref" href="#image:reactive-architecture">Figure 4-4</a>).&#13;
Such an approach solves two important architectural issues arising from the distributed systems.&#13;
First, it naturally handles real-world asynchronicity.&#13;
Second, it binds together services without relying on strong coupling.&#13;
At the edge of the system, this approach uses commands most of the time, often relying on HTTP.</p>&#13;
&#13;
<figure><div class="figure" id="image:reactive-architecture">&#13;
<img alt="Overview of a reactive system" src="assets/rsij_0404.png"/>&#13;
<h6><span class="label">Figure 4-4. </span>Overview of a reactive system</h6>&#13;
</div></figure>&#13;
&#13;
<p>This asynchronous message-passing aspect of reactive systems forms the connective tissue.&#13;
It not only grants the applications forming the system more autonomy and independence, but also enables resilience and elasticity.&#13;
You may wonder how, and you will get the beginning of our response in the next section.<a data-startref="ix_reactive-systems-adoc8" data-type="indexterm" id="idm45358831631088"/><a data-startref="ix_reactive-systems-adoc7" data-type="indexterm" id="idm45358831630320"/><a data-startref="ix_reactive-systems-adoc6" data-type="indexterm" id="idm45358831629632"/><a data-startref="ix_reactive-systems-adoc5" data-type="indexterm" id="idm45358831628944"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Destinations and Space Decoupling" data-type="sect1"><div class="sect1" id="idm45358831683232">&#13;
<h1>Destinations and Space Decoupling</h1>&#13;
&#13;
<p><a data-primary="design principles of reactive systems" data-secondary="destinations and space decoupling" data-type="indexterm" id="ix_reactive-systems-adoc9"/><a data-primary="destinations, in reactive systems" data-type="indexterm" id="ix_reactive-systems-adoc10"/><a data-primary="reactive systems" data-secondary="destinations and space decoupling" data-type="indexterm" id="ix_reactive-systems-adoc11"/><a data-primary="space decoupling" data-type="indexterm" id="ix_reactive-systems-adoc12"/>The reactive applications, forming a reactive system, communicate using messages.&#13;
They subscribe to destinations and receive the messages sent by other components to these destinations.&#13;
These messages can carry commands or events, though as described in the previous section, events provide interesting benefits. These destinations are not bound to specific components or instances.&#13;
They are virtual.&#13;
Components must know only the name (generally business related, such as <code>orders</code>) of the destination, not who’s producing or consuming.&#13;
It enables location transparency.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45358831621376">&#13;
<h5>Location Transparency</h5>&#13;
<p><a data-primary="location transparency" data-type="indexterm" id="idm45358831620176"/><em>Location transparency</em> refers to the use of <em>names</em> to identify resources, rather than their actual location.&#13;
For example, you would use <a href="https://www.oreilly.com/"><em class="hyperlink">https://www.oreilly.com/</em></a> and not the <code>23.43.200.127</code> IP address.&#13;
The main benefit of location transparency is that it no longer matters where the resource is located. In reactive systems, <em>destinations</em> provide location transparency.&#13;
Reactive systems use these identifiable destinations instead of the exact location of the consumer.</p>&#13;
</div></aside>&#13;
&#13;
<p><a data-primary="Kubernetes" data-secondary="location transparency" data-type="indexterm" id="idm45358831615776"/>If you are using Kubernetes, you may consider location transparency as already managed for you.&#13;
Indeed, you can use Kubernetes <em>services</em> to implement location transparency.&#13;
You have a single endpoint delegating to a group of selected <em>pods</em>.&#13;
But this location transparency is somewhat limited and often tied to HTTP or request/reply protocols.&#13;
Other environments can use service discovery infrastructure such as <a href="https://consul.io">HashiCorp Consul</a> or <a href="https://oreil.ly/H9Ygn">Netflix Eureka</a>.</p>&#13;
&#13;
<p>Using messages sent to a destination allows you, as the sender, to ignore who precisely is going to receive the message.&#13;
You don’t know if someone is currently available or if multiple components or instances are waiting for your message.&#13;
This number of consumers can evolve at runtime; more instances can be created, moved, or destroyed, and new components deployed.&#13;
But for you, as a sender, you don’t need to know.&#13;
You just use a specified destination. Let’s illustrate the advantages of this <em>addressability</em> by using the example from the previous section.&#13;
<code>ShopService</code> emits <code>order placed</code> events carried inside messages sent to the <code>orders</code> destination (<a data-type="xref" href="#image:shop-messages">Figure 4-3</a>). It is likely possible that during a quiet period, only a single instance of <code>OrderService</code> runs.&#13;
If there are not many orders, why bother having more?&#13;
We could even imagine having no instance, and instantiating one when we receive an order.&#13;
Serverless platforms are offering this <em>scale-from-zero</em> ability. However, over time, your shop gets more customers, and a single instance may not be enough.&#13;
Thanks to &#13;
<span class="keep-together">location</span> transparency, we can start other instances of <code>OrderService</code> to share the load (<a data-type="xref" href="#image:shop-elasticity">Figure 4-5</a>).&#13;
<code>ShopService</code> is not modified and ignores this new topology.</p>&#13;
&#13;
<figure><div class="figure" id="image:shop-elasticity">&#13;
<img alt="Elasticity provided by the use of message passing" src="assets/rsij_0405.png"/>&#13;
<h6><span class="label">Figure 4-5. </span>Elasticity provided by the use of message passing</h6>&#13;
</div></figure>&#13;
&#13;
<p>The way the load is shared among the consumers is also irrelevant for the sender.&#13;
It can be a round-robin, a load-based selection, or something more clever.&#13;
When the load returns to normal, the system can reduce the number of instances and save resources.&#13;
Note that this kind of elasticity works perfectly for stateless services.&#13;
For stateful services, it may be harder, as the instances may have to share the state.&#13;
However, solutions exist (though not without caveats), like the <a href="https://oreil.ly/kVRID">Kubernetes <code>StatefulSet</code></a> or an <a href="https://oreil.ly/wNUIQ">in-memory data grid</a>, to coordinate state among instances of the same service. Message passing also enables replication.&#13;
Following the same principle, we can shadow the active <code>OrderService</code> instance and take over if the primary instance fails (<a data-type="xref" href="#image:shop-fail-over">Figure 4-6</a>).&#13;
This approach avoids service disruption.&#13;
That kind of failover may also require state sharing.</p>&#13;
&#13;
<figure><div class="figure" id="image:shop-fail-over">&#13;
<img alt="Resilience provided by the use of message passing" src="assets/rsij_0406.png"/>&#13;
<h6><span class="label">Figure 4-6. </span>Resilience provided by the use of message passing</h6>&#13;
</div></figure>&#13;
&#13;
<p>By using message passing, our system becomes not only asynchronous, but also elastic and resilient.&#13;
When you architect your system, you list the destinations that implement the communication pattern you want.&#13;
In general, you would use one destination per type of event, but that’s not necessarily the case.&#13;
However, avoid at all costs having a destination per component instance.&#13;
It introduces coupling between the sender and the receiver, discarding the benefits.&#13;
It also reduces the extensibility.&#13;
Finally, it’s important to keep the set of destinations stable.&#13;
Changing a destination would break the components using it or would force you to handle redirections.<a data-startref="ix_reactive-systems-adoc12" data-type="indexterm" id="idm45358831595120"/><a data-startref="ix_reactive-systems-adoc11" data-type="indexterm" id="idm45358831594448"/><a data-startref="ix_reactive-systems-adoc10" data-type="indexterm" id="idm45358831593760"/><a data-startref="ix_reactive-systems-adoc9" data-type="indexterm" id="idm45358831593072"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Time Decoupling" data-type="sect1"><div class="sect1" id="idm45358831592256">&#13;
<h1>Time Decoupling</h1>&#13;
&#13;
<p><a data-primary="asynchronous message passing" data-secondary="time decoupling and" data-type="indexterm" id="idm45358831590944"/><a data-primary="design principles of reactive systems" data-secondary="time decoupling" data-type="indexterm" id="idm45358831589952"/><a data-primary="reactive systems" data-secondary="time decoupling" data-type="indexterm" id="idm45358831588992"/><a data-primary="time decoupling, reactive systems and" data-type="indexterm" id="idm45358831588048"/>Location transparency is not the only benefit.&#13;
Asynchronous message passing also enables time decoupling.</p>&#13;
&#13;
<p>Modern message backbones, such as <a href="https://amqp.org">AMQP 1.0</a>, <a href="https://kafka.apache.org/">Apache Kafka</a>, and even Java Message Service (JMS), enable time decoupling.&#13;
With these event brokers, events are not lost if there are no consumers.&#13;
The events are stored and delivered later.&#13;
Each broker has its own way.&#13;
For instance, AMQP 1.0 uses persistent messages and durable subscribers to ensure message delivery.&#13;
Kafka stores records in a durable, fault-tolerant, ordered log.&#13;
The records can be retrieved so long as they remain stored within the topic.</p>&#13;
&#13;
<p>If our <code>ShopService</code> emits the finalized orders as events, it does not need to know whether <code>OrderService</code> is available.&#13;
It knows that it’s going to be processed eventually.&#13;
If, for example,  no instances of <code>OrderService</code> are available when <code>ShopService</code> emits the event, it’s not lost.&#13;
When an instance gets ready, it receives the pending orders and processes them.&#13;
The user is then notified asynchronously with an email.</p>&#13;
&#13;
<p>Of course, the message broker must be available and reachable.&#13;
Most message brokers have replication abilities preventing unavailability issues and message loss.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>It is becoming common to store events in an event log.&#13;
Such ordered and append-only structure represents the full history of your system.&#13;
Every time the state changes, the system appends the new state to the log.</p>&#13;
</div>&#13;
&#13;
<p>Time decoupling increases the independence of our components.&#13;
Time decoupling, combined with other features enabled by asynchronous message passing, achieves a high level of independence among our components and keeps coupling to a &#13;
<span class="keep-together">minimum</span>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The Role of Nonblocking Input/Output" data-type="sect1"><div class="sect1" id="reactive-system::non-blocking">&#13;
<h1>The Role of Nonblocking Input/Output</h1>&#13;
&#13;
<p><a data-primary="design principles of reactive systems" data-secondary="nonblocking I/O" data-type="indexterm" id="ix_reactive-systems-adoc13"/><a data-primary="nonblocking I/O" data-secondary="role in reactive systems" data-type="indexterm" id="ix_reactive-systems-adoc14"/><a data-primary="reactive systems" data-secondary="nonblocking I/O" data-type="indexterm" id="ix_reactive-systems-adoc15"/>At this point, you may wonder what the difference is between an application using Kafka or AMQP and a reactive system.&#13;
Message passing is the essence of reactive systems, and most of them rely on some sort of message broker.&#13;
Message passing enables resilience and elasticity, which lead to responsiveness.&#13;
It promotes space and time decoupling, making our system much more robust.</p>&#13;
&#13;
<p>But reactive systems are not only exchanging messages.&#13;
Sending and receiving messages must be done efficiently.&#13;
To achieve this, Reactive promotes the use of nonblocking I/Os.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Blocking Network I/O, Threads, and Concurrency" data-type="sect2"><div class="sect2" id="idm45358831572208">&#13;
<h2>Blocking Network I/O, Threads, and Concurrency</h2>&#13;
&#13;
<p><a data-primary="blocking I/Os" data-secondary="nonblocking I/O versus" data-type="indexterm" id="ix_reactive-systems-adoc16"/><a data-primary="nonblocking I/O" data-secondary="blocking I/Os versus" data-type="indexterm" id="ix_reactive-systems-adoc17"/>To understand the benefits of nonblocking I/O, we need to know how blocking I/Os work.&#13;
Let’s use a client/server interaction to illustrate.&#13;
When a client sends a request to a server, the server processes it and sends back a response.&#13;
HTTP, for instance, follows this principle.&#13;
For this to happen, both the client and the server need to establish a connection before the interaction starts.&#13;
We will not go into the depths of the <a href="https://oreil.ly/kcTBH">seven-layer model</a> and the protocol stack involved in this interaction; you can find plenty of articles online about that topic.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Examples from this section can be run directly from your IDE. Use <em>chapter-4/non-blocking-io/src/main/java/org/acme/client/EchoClient.java</em> to invoke the started server. Be sure to avoid running multiple servers concurrently as they all use the same port (9999).</p>&#13;
</div>&#13;
&#13;
<p><a data-primary="sockets" data-type="indexterm" id="idm45358831564576"/>To establish that connection between the client and the server, we use <code>sockets</code>, as shown in <a data-type="xref" href="#reactive-system::blocking-server">Example 4-1</a>.</p>&#13;
<div data-type="example" id="reactive-system::blocking-server">&#13;
<h5><span class="label">Example 4-1. </span>A single-threaded echo server using blocking I/O (<em>chapter-4/non-blocking-io/src/main/java/org/acme/blocking/BlockingEchoServer.java</em>)</h5>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kt">int</code> <code class="n">port</code> <code class="o">=</code> <code class="mi">9999</code><code class="o">;</code>&#13;
&#13;
<code class="c1">// Create a server socket</code>&#13;
<code class="k">try</code> <code class="o">(</code><code class="n">ServerSocket</code> <code class="n">server</code> <code class="o">=</code> <code class="k">new</code> <code class="n">ServerSocket</code><code class="o">(</code><code class="n">port</code><code class="o">))</code> <code class="o">{</code>&#13;
    <code class="k">while</code> <code class="o">(</code><code class="kc">true</code><code class="o">)</code> <code class="o">{</code>&#13;
&#13;
        <code class="c1">// Wait for the next connection from a client</code>&#13;
        <code class="n">Socket</code> <code class="n">client</code> <code class="o">=</code> <code class="n">server</code><code class="o">.</code><code class="na">accept</code><code class="o">();</code>&#13;
&#13;
        <code class="n">PrintWriter</code> <code class="n">response</code> <code class="o">=</code> <code class="k">new</code> <code class="n">PrintWriter</code><code class="o">(</code><code class="n">client</code><code class="o">.</code><code class="na">getOutputStream</code><code class="o">(),</code> <code class="kc">true</code><code class="o">);</code>&#13;
        <code class="n">BufferedReader</code> <code class="n">request</code> <code class="o">=</code> <code class="k">new</code> <code class="n">BufferedReader</code><code class="o">(</code>&#13;
                <code class="k">new</code> <code class="nf">InputStreamReader</code><code class="o">(</code><code class="n">client</code><code class="o">.</code><code class="na">getInputStream</code><code class="o">()));</code>&#13;
&#13;
        <code class="n">String</code> <code class="n">line</code><code class="o">;</code>&#13;
        <code class="k">while</code> <code class="o">((</code><code class="n">line</code> <code class="o">=</code> <code class="n">request</code><code class="o">.</code><code class="na">readLine</code><code class="o">())</code> <code class="o">!=</code> <code class="kc">null</code><code class="o">)</code> <code class="o">{</code>&#13;
            <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="s">"Server received message from client: "</code> <code class="o">+</code> <code class="n">line</code><code class="o">);</code>&#13;
            <code class="c1">// Echo the request</code>&#13;
            <code class="n">response</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="n">line</code><code class="o">);</code>&#13;
&#13;
            <code class="c1">// Add a way to stop the application.</code>&#13;
            <code class="k">if</code> <code class="o">(</code><code class="s">"done"</code><code class="o">.</code><code class="na">equalsIgnoreCase</code><code class="o">(</code><code class="n">line</code><code class="o">))</code> <code class="o">{</code>&#13;
                <code class="k">break</code><code class="o">;</code>&#13;
            <code class="o">}</code>&#13;
        <code class="o">}</code>&#13;
        <code class="n">client</code><code class="o">.</code><code class="na">close</code><code class="o">();</code>&#13;
    <code class="o">}</code>&#13;
<code class="o">}</code></pre></div>&#13;
&#13;
<p>The client and server have to bind themselves to a socket forming the connection.&#13;
The server listens to its socket for the client to connect.&#13;
Once established, the client and server can both write and read data from the socket bound to that connection.</p>&#13;
&#13;
<p>Traditionally, because it’s simpler, applications are developed using a synchronous development model.&#13;
Such a development model executes instructions sequentially, one after the other.&#13;
So when such applications interact across the network, they expect to continue using a synchronous development model even for I/O.&#13;
This model uses synchronous communication and blocks the execution until the operation completes.&#13;
In <a data-type="xref" href="#reactive-system::blocking-server">Example 4-1</a>, we wait for a connection and handle it synchronously.&#13;
We read and write using synchronous APIs.&#13;
It’s simpler, but it leads to the use of blocking I/O.</p>&#13;
&#13;
<p>With blocking I/O, when the client sends a request to the server, the socket processing that connection and the corresponding thread that reads from it is blocked until some read data appears.&#13;
The bytes are accumulated in the network buffer until everything is read and ready for processing.&#13;
Until the operation is complete, the server can do nothing more but wait.</p>&#13;
&#13;
<p><a data-primary="threads" data-secondary="blocking I/Os and" data-type="indexterm" id="idm45358831395696"/>The consequence of this model is that we cannot serve more than one connection within a single thread.&#13;
When the server receives a connection, it uses that thread to read the request, process it, and write the response.&#13;
That thread is blocked until the last byte of the response is written on the wire.&#13;
A single client connection blocks the server!&#13;
Not very efficient, right?</p>&#13;
&#13;
<p>To execute concurrent requests with this approach, the only way is to have multiple threads.&#13;
We need to allocate a new thread for each client connection.&#13;
To handle more clients, you need to use more threads and process each request on a different <em>worker</em> thread; see <a data-type="xref" href="#multi-threaded-server">Example 4-2</a>.</p>&#13;
<div data-type="example" id="multi-threaded-server">&#13;
<h5><span class="label">Example 4-2. </span>Principles behind multithreaded server using blocking I/O</h5>&#13;
&#13;
<pre data-type="programlisting">while (listening) {&#13;
    accept a connection;&#13;
    create a worker thread to process the client request;&#13;
}</pre></div>&#13;
&#13;
<p>To implement this principle, we need a thread pool (<em>worker pool</em>).&#13;
When the client connects, we accept the connection and offload the processing to a separate thread.&#13;
Thus, the server thread can still accept other connections, as shown in <a data-type="xref" href="#reactive-system::blocking-server-workers">Example 4-3</a>.</p>&#13;
<div data-type="example" id="reactive-system::blocking-server-workers">&#13;
<h5><span class="label">Example 4-3. </span>A multithreaded echo server using blocking I/O (<em>chapter-4/non-blocking-io/src/main/java/org/acme/blocking/BlockingWithWorkerEchoServer.java</em>)</h5>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kt">int</code><code> </code><code class="n">port</code><code> </code><code class="o">=</code><code> </code><code class="mi">9999</code><code class="o">;</code><code>&#13;
</code><code class="n">ExecutorService</code><code> </code><code class="n">executors</code><code> </code><code class="o">=</code><code> </code><code class="n">Executors</code><code class="o">.</code><code class="na">newFixedThreadPool</code><code class="o">(</code><code class="mi">10</code><code class="o">)</code><code class="o">;</code><code> </code><a class="co" href="#callout_design_principles_of_reactive_systems_CO1-1" id="co_design_principles_of_reactive_systems_CO1-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
</code><code>&#13;
</code><code class="c1">// Create a server socket&#13;
</code><code class="k">try</code><code> </code><code class="o">(</code><code class="n">ServerSocket</code><code> </code><code class="n">server</code><code> </code><code class="o">=</code><code> </code><code class="k">new</code><code> </code><code class="n">ServerSocket</code><code class="o">(</code><code class="n">port</code><code class="o">)</code><code class="o">)</code><code> </code><code class="o">{</code><code>&#13;
</code><code>    </code><code class="k">while</code><code> </code><code class="o">(</code><code class="kc">true</code><code class="o">)</code><code> </code><code class="o">{</code><code>&#13;
</code><code>&#13;
</code><code>        </code><code class="c1">// Wait for the next connection from a client&#13;
</code><code>        </code><code class="n">Socket</code><code> </code><code class="n">client</code><code> </code><code class="o">=</code><code> </code><code class="n">server</code><code class="o">.</code><code class="na">accept</code><code class="o">(</code><code class="o">)</code><code class="o">;</code><code>&#13;
</code><code>&#13;
</code><code>        </code><code class="n">executors</code><code class="o">.</code><code class="na">submit</code><code class="o">(</code><code class="o">(</code><code class="o">)</code><code> </code><code class="o">-</code><code class="o">&gt;</code><code> </code><code class="o">{</code><code>                                    </code><a class="co" href="#callout_design_principles_of_reactive_systems_CO1-2" id="co_design_principles_of_reactive_systems_CO1-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
</code><code>            </code><code class="k">try</code><code> </code><code class="o">{</code><code>&#13;
</code><code>                </code><code class="n">PrintWriter</code><code> </code><code class="n">response</code><code> </code><code class="o">=</code><code>&#13;
</code><code>                </code><code class="k">new</code><code> </code><code class="nf">PrintWriter</code><code class="o">(</code><code class="n">client</code><code class="o">.</code><code class="na">getOutputStream</code><code class="o">(</code><code class="o">)</code><code class="o">,</code><code> </code><code class="kc">true</code><code class="o">)</code><code class="o">;</code><code>&#13;
</code><code>                </code><code class="n">BufferedReader</code><code> </code><code class="n">request</code><code> </code><code class="o">=</code><code> </code><code class="k">new</code><code> </code><code class="n">BufferedReader</code><code class="o">(</code><code>&#13;
</code><code>                        </code><code class="k">new</code><code> </code><code class="nf">InputStreamReader</code><code class="o">(</code><code class="n">client</code><code class="o">.</code><code class="na">getInputStream</code><code class="o">(</code><code class="o">)</code><code class="o">)</code><code class="o">)</code><code class="o">;</code><code>&#13;
</code><code>&#13;
</code><code>                </code><code class="n">String</code><code> </code><code class="n">line</code><code class="o">;</code><code>&#13;
</code><code>                </code><code class="k">while</code><code> </code><code class="o">(</code><code class="o">(</code><code class="n">line</code><code> </code><code class="o">=</code><code> </code><code class="n">request</code><code class="o">.</code><code class="na">readLine</code><code class="o">(</code><code class="o">)</code><code class="o">)</code><code> </code><code class="o">!</code><code class="o">=</code><code> </code><code class="kc">null</code><code class="o">)</code><code> </code><code class="o">{</code><code>&#13;
</code><code>                    </code><code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="n">Thread</code><code class="o">.</code><code class="na">currentThread</code><code class="o">(</code><code class="o">)</code><code class="o">.</code><code class="na">getName</code><code class="o">(</code><code class="o">)</code><code> </code><code class="o">+</code><code>&#13;
</code><code>                            </code><code class="s">" - Server received message from client: "</code><code> </code><code class="o">+</code><code> </code><code class="n">line</code><code class="o">)</code><code class="o">;</code><code>&#13;
</code><code>                    </code><code class="c1">// Echo the request&#13;
</code><code>                    </code><code class="n">response</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="n">line</code><code class="o">)</code><code class="o">;</code><code>&#13;
</code><code>&#13;
</code><code>                    </code><code class="c1">// Add a way to stop the application.&#13;
</code><code>                    </code><code class="k">if</code><code> </code><code class="o">(</code><code class="s">"done"</code><code class="o">.</code><code class="na">equalsIgnoreCase</code><code class="o">(</code><code class="n">line</code><code class="o">)</code><code class="o">)</code><code> </code><code class="o">{</code><code>&#13;
</code><code>                        </code><code class="k">break</code><code class="o">;</code><code>&#13;
</code><code>                    </code><code class="o">}</code><code>&#13;
</code><code>                </code><code class="o">}</code><code>&#13;
</code><code>                </code><code class="n">client</code><code class="o">.</code><code class="na">close</code><code class="o">(</code><code class="o">)</code><code class="o">;</code><code>&#13;
</code><code>            </code><code class="o">}</code><code> </code><code class="k">catch</code><code> </code><code class="o">(</code><code class="n">Exception</code><code> </code><code class="n">e</code><code class="o">)</code><code> </code><code class="o">{</code><code>&#13;
</code><code>                </code><code class="n">System</code><code class="o">.</code><code class="na">err</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="s">"Couldn't serve I/O: "</code><code> </code><code class="o">+</code><code> </code><code class="n">e</code><code class="o">.</code><code class="na">toString</code><code class="o">(</code><code class="o">)</code><code class="o">)</code><code class="o">;</code><code>&#13;
</code><code>&#13;
</code><code>            </code><code class="o">}</code><code>&#13;
</code><code>        </code><code class="o">}</code><code class="o">)</code><code class="o">;</code><code>&#13;
</code><code>    </code><code class="o">}</code><code>&#13;
</code><code class="o">}</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_design_principles_of_reactive_systems_CO1-1" id="callout_design_principles_of_reactive_systems_CO1-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Create a worker thread pool to handle the request.</p></dd>&#13;
<dt><a class="co" href="#co_design_principles_of_reactive_systems_CO1-2" id="callout_design_principles_of_reactive_systems_CO1-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Offload the processing of the request to a thread from the thread pool. The rest of the code is unchanged.</p></dd>&#13;
</dl></div>&#13;
&#13;
<p>That’s the model used, by default, in traditional Java frameworks such as Jakarta EE or Spring.<sup><a data-type="noteref" href="ch04.html#idm45358831203712" id="idm45358831203712-marker">3</a></sup>&#13;
Even if these frameworks may use nonblocking I/O under the hood, they use <em>worker</em> threads to handle the requests.&#13;
But this approach has many drawbacks, including:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Each thread requires a stack of memory allocated to it.&#13;
With the increasing number of connections, spawning multiple threads and switching between them will consume not only memory but also CPU cycles.</p>&#13;
</li>&#13;
<li>&#13;
<p>At any given point in time, multiple threads could be waiting for the client requests.&#13;
That’s a massive waste of resources.</p>&#13;
</li>&#13;
<li>&#13;
<p>Your concurrency (the number of requests you can handle at a given time—10 in the previous example) is limited by the number of threads you can create.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>On public clouds, the blocking I/O approach inflates your monthly bill; on private clouds, it reduces the deployment density.&#13;
Therefore, this approach is not ideal if you have to handle many connections or implement applications dealing with a lot of I/O.&#13;
In the realm of distributed systems, that’s often the case. Luckily, there’s an alternative.<a data-startref="ix_reactive-systems-adoc17" data-type="indexterm" id="idm45358831238896"/><a data-startref="ix_reactive-systems-adoc16" data-type="indexterm" id="idm45358831238256"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="How Does Nonblocking I/O Work?" data-type="sect2"><div class="sect2" id="idm45358831571584">&#13;
<h2>How Does Nonblocking I/O Work?</h2>&#13;
&#13;
<p><a data-primary="nonblocking I/O" data-secondary="mechanism of operation" data-type="indexterm" id="ix_reactive-systems-adoc18"/>The alternative is <em>nonblocking I/O</em>.&#13;
The difference is evident from its name.&#13;
Instead of waiting for the completion of the transmission, the caller is not blocked and can continue its processing. The magic happens in the operating system.&#13;
With nonblocking I/O, the operating system queues the requests.&#13;
The system processes the actual I/O in the future.&#13;
When the I/O completes, and the response is ready, a <em>continuation</em>, often implemented as a callback, happens and the caller receives the result.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45358831373744">&#13;
<h5>Continuations</h5>&#13;
<p><a data-primary="continuations" data-type="indexterm" id="idm45358831372544"/>The term <em>continuation</em> comes from functional programming.&#13;
<a data-primary="CPS (continuation-passing style)" data-type="indexterm" id="idm45358831371296"/><em>Continuation-passing style</em> (<em>CPS</em>) is a style of programming in which control is passed explicitly in the form of a continuation.&#13;
It contrasts with the imperative style, which is the usual style of programming that executes each instruction in order.</p>&#13;
</div></aside>&#13;
&#13;
<p>To better understand the benefits and see how these continuations work, we need &#13;
<span class="keep-together">to look</span> under the hood: how is nonblocking I/O implemented?&#13;
We already mentioned a queue.&#13;
The system enqueues I/O operations and returns immediately, so the caller is not blocked while waiting for the I/O operations to complete.&#13;
When a response comes back, the system stores the result in a structure.&#13;
When the caller needs the result, it interrogates the system to see whether the operation completed (<a data-type="xref" href="#reactive-system::non-blocking-server-loop">Example 4-4</a>).</p>&#13;
<div data-type="example" id="reactive-system::non-blocking-server-loop">&#13;
<h5><span class="label">Example 4-4. </span>An echo server using nonblocking I/O (<em>chapter-4/non-blocking-io/src/main/java/org/acme/nio/NonBlockingServer.java</em>)</h5>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="n">InetSocketAddress</code> <code class="n">address</code> <code class="o">=</code> <code class="k">new</code> <code class="n">InetSocketAddress</code><code class="o">(</code><code class="s">"localhost"</code><code class="o">,</code> <code class="mi">9999</code><code class="o">);</code>&#13;
<code class="n">Selector</code> <code class="n">selector</code> <code class="o">=</code> <code class="n">Selector</code><code class="o">.</code><code class="na">open</code><code class="o">();</code>&#13;
<code class="n">ServerSocketChannel</code> <code class="n">channel</code> <code class="o">=</code> <code class="n">ServerSocketChannel</code><code class="o">.</code><code class="na">open</code><code class="o">();</code>&#13;
<code class="n">channel</code><code class="o">.</code><code class="na">configureBlocking</code><code class="o">(</code><code class="kc">false</code><code class="o">);</code>&#13;
&#13;
<code class="n">channel</code><code class="o">.</code><code class="na">socket</code><code class="o">().</code><code class="na">bind</code><code class="o">(</code><code class="n">address</code><code class="o">);</code>&#13;
<code class="c1">// Server socket supports only ACCEPT</code>&#13;
<code class="n">channel</code><code class="o">.</code><code class="na">register</code><code class="o">(</code><code class="n">selector</code><code class="o">,</code> <code class="n">SelectionKey</code><code class="o">.</code><code class="na">OP_ACCEPT</code><code class="o">);</code>&#13;
&#13;
<code class="k">while</code> <code class="o">(</code><code class="kc">true</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="kt">int</code> <code class="n">available</code> <code class="o">=</code> <code class="n">selector</code><code class="o">.</code><code class="na">select</code><code class="o">();</code> <code class="c1">// wait for events</code>&#13;
    <code class="k">if</code> <code class="o">(</code><code class="n">available</code> <code class="o">==</code> <code class="mi">0</code><code class="o">)</code> <code class="o">{</code>&#13;
        <code class="k">continue</code><code class="o">;</code>  <code class="c1">// Nothing ready yet.</code>&#13;
    <code class="o">}</code>&#13;
&#13;
    <code class="c1">// We have the request ready to be processed.</code>&#13;
    <code class="n">Set</code><code class="o">&lt;</code><code class="n">SelectionKey</code><code class="o">&gt;</code> <code class="n">keys</code> <code class="o">=</code> <code class="n">selector</code><code class="o">.</code><code class="na">selectedKeys</code><code class="o">();</code>&#13;
    <code class="n">Iterator</code><code class="o">&lt;</code><code class="n">SelectionKey</code><code class="o">&gt;</code> <code class="n">iterator</code> <code class="o">=</code> <code class="n">keys</code><code class="o">.</code><code class="na">iterator</code><code class="o">();</code>&#13;
    <code class="k">while</code> <code class="o">(</code><code class="n">iterator</code><code class="o">.</code><code class="na">hasNext</code><code class="o">())</code> <code class="o">{</code>&#13;
        <code class="n">SelectionKey</code> <code class="n">key</code> <code class="o">=</code> <code class="n">iterator</code><code class="o">.</code><code class="na">next</code><code class="o">();</code>&#13;
        <code class="k">if</code> <code class="o">(</code><code class="n">key</code><code class="o">.</code><code class="na">isAcceptable</code><code class="o">())</code> <code class="o">{</code>&#13;
            <code class="c1">// --  New connection --</code>&#13;
            <code class="n">SocketChannel</code> <code class="n">client</code> <code class="o">=</code> <code class="n">channel</code><code class="o">.</code><code class="na">accept</code><code class="o">();</code>&#13;
            <code class="n">client</code><code class="o">.</code><code class="na">configureBlocking</code><code class="o">(</code><code class="kc">false</code><code class="o">);</code>&#13;
            <code class="n">client</code><code class="o">.</code><code class="na">register</code><code class="o">(</code><code class="n">selector</code><code class="o">,</code> <code class="n">SelectionKey</code><code class="o">.</code><code class="na">OP_READ</code><code class="o">);</code>&#13;
            <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="s">"Client connection accepted: "</code>&#13;
                <code class="o">+</code> <code class="n">client</code><code class="o">.</code><code class="na">getLocalAddress</code><code class="o">());</code>&#13;
        <code class="o">}</code> <code class="k">else</code> <code class="k">if</code> <code class="o">(</code><code class="n">key</code><code class="o">.</code><code class="na">isReadable</code><code class="o">())</code> <code class="o">{</code>&#13;
            <code class="c1">// --  A client sent data ready to be read and we can write --</code>&#13;
            <code class="n">SocketChannel</code> <code class="n">client</code> <code class="o">=</code> <code class="o">(</code><code class="n">SocketChannel</code><code class="o">)</code> <code class="n">key</code><code class="o">.</code><code class="na">channel</code><code class="o">();</code>&#13;
            <code class="c1">// Read the data assuming the size is sufficient for reading.</code>&#13;
            <code class="n">ByteBuffer</code> <code class="n">payload</code> <code class="o">=</code> <code class="n">ByteBuffer</code><code class="o">.</code><code class="na">allocate</code><code class="o">(</code><code class="mi">256</code><code class="o">);</code>&#13;
            <code class="kt">int</code> <code class="n">size</code> <code class="o">=</code> <code class="n">client</code><code class="o">.</code><code class="na">read</code><code class="o">(</code><code class="n">payload</code><code class="o">);</code>&#13;
            <code class="k">if</code> <code class="o">(</code><code class="n">size</code> <code class="o">==</code> <code class="o">-</code><code class="mi">1</code> <code class="o">)</code> <code class="o">{</code> <code class="c1">// Handle disconnection</code>&#13;
                <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="s">"Disconnection from "</code>&#13;
                    <code class="o">+</code> <code class="n">client</code><code class="o">.</code><code class="na">getRemoteAddress</code><code class="o">());</code>&#13;
                <code class="n">channel</code><code class="o">.</code><code class="na">close</code><code class="o">();</code>&#13;
                <code class="n">key</code><code class="o">.</code><code class="na">cancel</code><code class="o">();</code>&#13;
            <code class="o">}</code> <code class="k">else</code> <code class="o">{</code>&#13;
                <code class="n">String</code> <code class="n">result</code> <code class="o">=</code> <code class="k">new</code> <code class="n">String</code><code class="o">(</code><code class="n">payload</code><code class="o">.</code><code class="na">array</code><code class="o">(),</code>&#13;
                    <code class="n">StandardCharsets</code><code class="o">.</code><code class="na">UTF_8</code><code class="o">).</code><code class="na">trim</code><code class="o">();</code>&#13;
                <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">println</code><code class="o">(</code><code class="s">"Received message: "</code> <code class="o">+</code> <code class="n">result</code><code class="o">);</code>&#13;
                <code class="k">if</code> <code class="o">(</code><code class="n">result</code><code class="o">.</code><code class="na">equals</code><code class="o">(</code><code class="s">"done"</code><code class="o">))</code> <code class="o">{</code>&#13;
                    <code class="n">client</code><code class="o">.</code><code class="na">close</code><code class="o">();</code>&#13;
                <code class="o">}</code>&#13;
                <code class="n">payload</code><code class="o">.</code><code class="na">rewind</code><code class="o">();</code> <code class="c1">// Echo</code>&#13;
                <code class="n">client</code><code class="o">.</code><code class="na">write</code><code class="o">(</code><code class="n">payload</code><code class="o">);</code>&#13;
            <code class="o">}</code>&#13;
        <code class="o">}</code>&#13;
        <code class="c1">// Be sure not to handle it twice.</code>&#13;
        <code class="n">iterator</code><code class="o">.</code><code class="na">remove</code><code class="o">();</code>&#13;
    <code class="o">}</code>&#13;
<code class="o">}</code></pre></div>&#13;
&#13;
<p>Nonblocking I/O introduces a few new concepts:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>We don’t use <code>InputStream</code> or <code>OutputStream</code> (which are blocking by nature), but <code>Buffer</code>, which is a temporary storage.</p>&#13;
</li>&#13;
<li>&#13;
<p><code>Channel</code> can be viewed as an endpoint for an open connection.</p>&#13;
</li>&#13;
<li>&#13;
<p><code>Selector</code> is the cornerstone of nonblocking I/O in Java.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p><a data-primary="Selector" data-type="indexterm" id="idm45358830675648"/><code>Selector</code> manages multiple channels, either server or client channels.&#13;
When you use nonblocking I/O, you create <code>Selector</code>.&#13;
Each time you deal with a new channel, you register this channel on the selector with the events you are interested in (accept, ready to read, ready to write).</p>&#13;
&#13;
<p><a data-primary="threads" data-secondary="nonblocking I/Os and" data-type="indexterm" id="idm45358830673744"/>Then your code polls <code>Selector</code> with only one thread to see if the channel is ready.&#13;
When the channel is ready to read or write, you can start to read and write.&#13;
We don’t need to have a thread for every channel at all, and a single thread can handle many channels.</p>&#13;
&#13;
<p>The selector is an abstraction of the nonblocking I/O implementation provided by the underlying operating system.&#13;
Various approaches, depending on the operating systems, are available.</p>&#13;
&#13;
<p>First, <code>select</code> was implemented in the 1980s.&#13;
It supports the registration of 1,024 sockets.&#13;
That was certainly enough in the ’80s, but not anymore.</p>&#13;
&#13;
<p><a data-primary="poll" data-type="indexterm" id="idm45358830670336"/><code>poll</code> is a replacement for <code>select</code> introduced in 1997.&#13;
The most significant difference is that <code>poll</code> no longer limits the number of sockets.&#13;
However, as with <code>select</code>, the system tells you only how many channels are ready, not which ones.&#13;
You need to iterate over the set of channels to check which ones are ready.&#13;
When there are few channels, it is not a big problem.&#13;
Once the number of channels is more than hundreds of thousands, the iteration time is considerable.</p>&#13;
&#13;
<p><a data-primary="epoll" data-type="indexterm" id="idm45358830667360"/>Then, <code>epoll</code> appeared in 2002 in the Linux Kernel 2.5.44.&#13;
<code>Kqueue</code> appeared in FreeBSD in 2000 and <code>/dev/poll</code> in Solaris around the same time.&#13;
These mechanisms return the set of channels that are ready to be processed—no more iteration over every channel!&#13;
Finally, Windows systems provide IOCP, an optimized implementation of <code>select</code>.</p>&#13;
&#13;
<p>What’s important to remember is that regardless of how the operating systems implement it, with nonblocking I/O, you need only a single thread to handle multiple requests.&#13;
This model is much more efficient than blocking I/O, as you don’t need to create threads to handle concurrent requests.&#13;
Eliminating these extra threads makes your application much more efficient in terms of memory consumption (about 1 MB per thread) and avoids wasting CPU cycles because of context switches (1–2 microseconds per switch).<sup><a data-type="noteref" href="ch04.html#idm45358830663584" id="idm45358830663584-marker">4</a></sup></p>&#13;
&#13;
<p>Reactive systems recommend the use of nonblocking I/O to receive and send messages.&#13;
Thus, your application can handle more messages with fewer resources.&#13;
Another advantage is that an idle application would consume almost no memory or CPUs.&#13;
You don’t have to reserve resources up front.<a data-startref="ix_reactive-systems-adoc18" data-type="indexterm" id="idm45358830661776"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Reactor Pattern and Event Loop" data-type="sect2"><div class="sect2" id="reactive-system::reactor-pattern-event-loop">&#13;
<h2>Reactor Pattern and Event Loop</h2>&#13;
&#13;
<p><a data-primary="nonblocking I/O" data-secondary="reactor pattern and event loop" data-type="indexterm" id="ix_reactive-systems-adoc19"/>Nonblocking I/O gives us the possibility to handle multiple concurrent requests or messages with a single thread.&#13;
How could we handle these concurrent requests?&#13;
How do we structure our code when using nonblocking I/O?&#13;
The examples given in the previous section are not scaling well; we can quickly see that implementing a REST API with such a model will be a nightmare.&#13;
Besides, we would like to avoid using worker threads, as it would discard the advantages of nonblocking I/O.&#13;
We need something different: the reactor pattern.</p>&#13;
&#13;
<p><a data-primary="reactor pattern" data-type="indexterm" id="idm45358830657200"/>The <em>reactor pattern</em>, illustrated in <a data-type="xref" href="#image:event-loop">Figure 4-7</a>, allows associating I/O events with <em>event handlers</em>.&#13;
The <em>reactor</em>, the cornerstone of this mechanism, invokes the event handlers when the expected event is received.</p>&#13;
&#13;
<p>The purpose of the reactor pattern is to avoid creating a thread for each message, request, and connection.&#13;
This pattern receives events from multiple channels and sequentially distributes them to the corresponding event handlers.</p>&#13;
&#13;
<figure><div class="figure" id="image:event-loop">&#13;
<img alt="The reactor pattern" src="assets/rsij_0407.png"/>&#13;
<h6><span class="label">Figure 4-7. </span>The reactor pattern</h6>&#13;
</div></figure>&#13;
&#13;
<p><a data-primary="event loop" data-type="indexterm" id="idm45358830651104"/>Implementation of the reactor pattern uses an <em>event loop</em> (<a data-type="xref" href="#image:event-loop">Figure 4-7</a>).&#13;
It’s a thread iterating over the set of channels, and when data is ready to be consumed, the event loop invokes the associated event handler sequentially, in a single-threaded manner.</p>&#13;
&#13;
<p>When you combine nonblocking I/O and the reactor pattern, you organize your code as a set of event handlers.&#13;
That approach works wonderfully with reactive code as it exposes the notion of events, the essence of Reactive.</p>&#13;
&#13;
<p>The reactor pattern has two variants:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><a data-primary="multireactor pattern" data-type="indexterm" id="idm45358830646704"/>The <em>multireactor</em> pattern uses multiple event loops (generally one or two per CPU core), which increase the concurrency of the application.&#13;
Multireactor pattern implementations, such as Eclipse Vert.x, call the event handlers in a single-threaded manner to avoid deadlock or state visibility issues.</p>&#13;
</li>&#13;
<li>&#13;
<p><a data-primary="proactor pattern" data-type="indexterm" id="idm45358830644320"/>The <em>proactor</em> pattern can be seen as an asynchronous version of the reactor pattern. Long-running event handlers invoke a continuation when they complete.&#13;
Such mechanisms allow mixing nonblocking and blocking I/O (<a data-type="xref" href="#image:proactor">Figure 4-8</a>).</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<figure><div class="figure" id="image:proactor">&#13;
<img alt="the proactor pattern" src="assets/rsij_0408.png"/>&#13;
<h6><span class="label">Figure 4-8. </span>The proactor pattern</h6>&#13;
</div></figure>&#13;
&#13;
<p>You can integrate nonblocking event handlers, as well as blocking ones, by offloading their execution to separate threads when it’s inevitable.&#13;
When their execution completes, the proactor pattern invokes the continuation.&#13;
As you will see in <a data-type="xref" href="ch06.html#quarkus-reactive">Chapter 6</a>, this is the pattern used by Quarkus<a data-startref="ix_reactive-systems-adoc19" data-type="indexterm" id="idm45358830638208"/>.<a data-startref="ix_reactive-systems-adoc15" data-type="indexterm" id="idm45358830637344"/><a data-startref="ix_reactive-systems-adoc14" data-type="indexterm" id="idm45358830636624"/><a data-startref="ix_reactive-systems-adoc13" data-type="indexterm" id="idm45358830635936"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Anatomy of Reactive Applications" data-type="sect1"><div class="sect1" id="idm45358830660544">&#13;
<h1>Anatomy of Reactive Applications</h1>&#13;
&#13;
<p><a data-primary="design principles of reactive systems" data-secondary="anatomy of reactive applications" data-type="indexterm" id="ix_reactive-systems-adoc20"/><a data-primary="reactive systems" data-secondary="anatomy of reactive applications" data-type="indexterm" id="ix_reactive-systems-adoc21"/>In the last few years, many frameworks have popped up, offering reactive application support.&#13;
Their goal is to simplify the implementation of reactive applications.&#13;
They achieve this by providing higher-level primitives and APIs to handle events and abstract nonblocking I/O.</p>&#13;
&#13;
<p>Indeed, and you may have recognized this already, using nonblocking I/O is not that simple.&#13;
Combining this with a reactor pattern (or a variant) can be convoluted.&#13;
Fortunately, alongside frameworks, libraries and toolkits are doing the heavy lifting.&#13;
<a data-primary="Netty" data-type="indexterm" id="idm45358830630256"/>Netty is an asynchronous event-driven network application framework leveraging nonblocking I/O to build highly concurrent applications.&#13;
It’s the most used library to handle nonblocking I/O in the Java world.&#13;
But Netty can be challenging.&#13;
<a data-type="xref" href="#reactive-system::netty-echo">Example 4-5</a> implements the <em>echo</em> TCP server using Netty.</p>&#13;
<div data-type="example" id="reactive-system::netty-echo">&#13;
<h5><span class="label">Example 4-5. </span>An echo server using Netty (<em>chapter-4/non-blocking-io/src/main/java/org/acme/netty/NettyEchoServer.java</em>)</h5>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">static</code> <code class="kt">void</code> <code class="nf">main</code><code class="o">(</code><code class="n">String</code><code class="o">[]</code> <code class="n">args</code><code class="o">)</code> <code class="kd">throws</code> <code class="n">Exception</code> <code class="o">{</code>&#13;
    <code class="k">new</code> <code class="nf">NettyServer</code><code class="o">(</code><code class="mi">9999</code><code class="o">).</code><code class="na">run</code><code class="o">();</code>&#13;
<code class="o">}</code>&#13;
&#13;
<code class="kd">private</code> <code class="kd">final</code> <code class="kt">int</code> <code class="n">port</code><code class="o">;</code>&#13;
&#13;
<code class="kd">public</code> <code class="nf">NettyServer</code><code class="o">(</code><code class="kt">int</code> <code class="n">port</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="k">this</code><code class="o">.</code><code class="na">port</code> <code class="o">=</code> <code class="n">port</code><code class="o">;</code>&#13;
<code class="o">}</code>&#13;
&#13;
<code class="kd">public</code> <code class="kt">void</code> <code class="nf">run</code><code class="o">()</code> <code class="kd">throws</code> <code class="n">Exception</code> <code class="o">{</code>&#13;
    <code class="c1">// NioEventLoopGroup is a multithreaded event loop that handles I/O operation.</code>&#13;
    <code class="c1">// The first one, often called 'boss', accepts an incoming connection.</code>&#13;
    <code class="c1">// The second one, often called 'worker', handles the traffic of the accepted</code>&#13;
    <code class="c1">// connection once the boss accepts the connection and registers the</code>&#13;
    <code class="c1">// accepted connection to the worker.</code>&#13;
    <code class="n">EventLoopGroup</code> <code class="n">bossGroup</code> <code class="o">=</code> <code class="k">new</code> <code class="n">NioEventLoopGroup</code><code class="o">();</code>&#13;
&#13;
    <code class="n">EventLoopGroup</code> <code class="n">workerGroup</code> <code class="o">=</code> <code class="k">new</code> <code class="n">NioEventLoopGroup</code><code class="o">();</code>&#13;
    <code class="k">try</code> <code class="o">{</code>&#13;
        <code class="c1">// ServerBootstrap is a helper class that sets up a server.</code>&#13;
        <code class="n">ServerBootstrap</code> <code class="n">b</code> <code class="o">=</code> <code class="k">new</code> <code class="n">ServerBootstrap</code><code class="o">();</code>&#13;
        <code class="n">b</code><code class="o">.</code><code class="na">group</code><code class="o">(</code><code class="n">bossGroup</code><code class="o">,</code> <code class="n">workerGroup</code><code class="o">)</code>&#13;
                <code class="c1">// the NioServerSocketChannel class is used to instantiate a</code>&#13;
                <code class="c1">// new Channel to accept incoming connections.</code>&#13;
                <code class="o">.</code><code class="na">channel</code><code class="o">(</code><code class="n">NioServerSocketChannel</code><code class="o">.</code><code class="na">class</code><code class="o">)</code>&#13;
                <code class="o">.</code><code class="na">childHandler</code><code class="o">(</code><code class="k">new</code> <code class="n">ChannelInitializer</code><code class="o">&lt;</code><code class="n">SocketChannel</code><code class="o">&gt;()</code> <code class="o">{</code>&#13;
                    <code class="c1">// This handler is called for each accepted channel and</code>&#13;
                    <code class="c1">// allows customizing the processing. In this case, we</code>&#13;
                    <code class="c1">// just append the echo handler.</code>&#13;
                    <code class="nd">@Override</code>&#13;
                    <code class="kd">public</code> <code class="kt">void</code> <code class="nf">initChannel</code><code class="o">(</code><code class="n">SocketChannel</code> <code class="n">ch</code><code class="o">)</code> <code class="o">{</code>&#13;
                        <code class="n">ch</code><code class="o">.</code><code class="na">pipeline</code><code class="o">().</code><code class="na">addLast</code><code class="o">(</code><code class="k">new</code> <code class="n">EchoServerHandler</code><code class="o">());</code>&#13;
                    <code class="o">}</code>&#13;
                <code class="o">});</code>&#13;
&#13;
        <code class="c1">// Bind and start to accept incoming connections.</code>&#13;
        <code class="n">ChannelFuture</code> <code class="n">f</code> <code class="o">=</code> <code class="n">b</code><code class="o">.</code><code class="na">bind</code><code class="o">(</code><code class="n">port</code><code class="o">).</code><code class="na">sync</code><code class="o">();</code>&#13;
&#13;
        <code class="c1">// Wait until the server socket is closed.</code>&#13;
        <code class="n">f</code><code class="o">.</code><code class="na">channel</code><code class="o">().</code><code class="na">closeFuture</code><code class="o">().</code><code class="na">sync</code><code class="o">();</code>&#13;
    <code class="o">}</code> <code class="k">finally</code> <code class="o">{</code>&#13;
        <code class="n">workerGroup</code><code class="o">.</code><code class="na">shutdownGracefully</code><code class="o">();</code>&#13;
        <code class="n">bossGroup</code><code class="o">.</code><code class="na">shutdownGracefully</code><code class="o">();</code>&#13;
    <code class="o">}</code>&#13;
<code class="o">}</code>&#13;
&#13;
<code class="kd">private</code> <code class="kd">static</code> <code class="kd">class</code> <code class="nc">EchoServerHandler</code> <code class="kd">extends</code> <code class="n">ChannelInboundHandlerAdapter</code> <code class="o">{</code>&#13;
&#13;
    <code class="nd">@Override</code>&#13;
    <code class="kd">public</code> <code class="kt">void</code> <code class="nf">channelRead</code><code class="o">(</code><code class="n">ChannelHandlerContext</code> <code class="n">ctx</code><code class="o">,</code> <code class="n">Object</code> <code class="n">msg</code><code class="o">)</code> <code class="o">{</code>&#13;
        <code class="c1">// Write the received object, and flush</code>&#13;
        <code class="n">ctx</code><code class="o">.</code><code class="na">writeAndFlush</code><code class="o">(</code><code class="n">msg</code><code class="o">);</code>&#13;
    <code class="o">}</code>&#13;
<code class="o">}</code></pre></div>&#13;
&#13;
<p><a data-primary="Vert.x" data-type="indexterm" id="idm45358830625472"/>The Vert.x toolkit, based on top of Netty, provides higher-level features to build reactive applications such as HTTP clients and servers, messaging clients, etc.&#13;
Typically, the same <em>echo</em> TCP server using Vert.x looks like <a data-type="xref" href="#reactive-system::vertx-echo">Example 4-6</a>.</p>&#13;
<div data-type="example" id="reactive-system::vertx-echo">&#13;
<h5><span class="label">Example 4-6. </span>An echo server using Vert.x (<em>chapter-4/non-blocking-io/src/main/java/org/acme/vertx/VertxEchoServer.java</em>)</h5>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="n">Vertx</code> <code class="n">vertx</code> <code class="o">=</code> <code class="n">Vertx</code><code class="o">.</code><code class="na">vertx</code><code class="o">();</code>&#13;
<code class="c1">// Create a TCP server</code>&#13;
<code class="n">vertx</code><code class="o">.</code><code class="na">createNetServer</code><code class="o">()</code>&#13;
        <code class="c1">// Invoke the given function for each connection</code>&#13;
        <code class="o">.</code><code class="na">connectHandler</code><code class="o">(</code><code class="n">socket</code> <code class="o">-&gt;</code> <code class="o">{</code>&#13;
            <code class="c1">// Just write the content back</code>&#13;
            <code class="n">socket</code><code class="o">.</code><code class="na">handler</code><code class="o">(</code><code class="n">buffer</code> <code class="o">-&gt;</code> <code class="n">socket</code><code class="o">.</code><code class="na">write</code><code class="o">(</code><code class="n">buffer</code><code class="o">));</code>&#13;
        <code class="o">})</code>&#13;
        <code class="o">.</code><code class="na">listen</code><code class="o">(</code><code class="mi">9999</code><code class="o">);</code></pre></div>&#13;
&#13;
<p>Most Java frameworks offering Reactive capabilities are based on Netty or Vert.x.&#13;
As shown in <a data-type="xref" href="#image:reactive-framework">Figure 4-9</a>, they all follow the same type of blueprint.</p>&#13;
&#13;
<figure><div class="figure" id="image:reactive-framework">&#13;
<img alt="The common architecture of reactive frameworks" src="assets/rsij_0409.png"/>&#13;
<h6><span class="label">Figure 4-9. </span>The common architecture of reactive frameworks</h6>&#13;
</div></figure>&#13;
&#13;
<p>At the bottom, you have the nonblocking I/O.&#13;
Generally, frameworks use Netty or Vert.x.&#13;
This layer handles client connections, outbound requests, and response writing. In other words, it manages the I/O part.&#13;
Most of the time, this layer implements the reactor pattern (or a variant), and so provides an event-loop-based model.</p>&#13;
&#13;
<p>Then, in the second layer, you have the <em>reactive framework</em> per se.&#13;
The role of this layer is to provide high-level APIs that are easy to use. You use these APIs to write your application code.&#13;
Instead of having to handle nonblocking I/O channels, this layer provides high-level objects such as HTTP requests, responses, Kafka messages, and so on.&#13;
Much easier!</p>&#13;
&#13;
<p>Finally, in the top layer, you have your application.&#13;
Your code does not need to touch nonblocking I/O concepts, thanks to the reactive framework.&#13;
It can focus on incoming events and handle them.&#13;
Your code is <em>just</em> a collection of event handlers.&#13;
It can use the features provided by the reactive framework to interact with other services or middleware.</p>&#13;
&#13;
<p>But there is a catch.&#13;
<a data-primary="event loop thread" data-type="indexterm" id="idm45358830281696"/><a data-primary="threads" data-secondary="event handlers and" data-type="indexterm" id="idm45358830280960"/>The event handler from your code is invoked using the <em>event loop</em> thread (an I/O thread).&#13;
If your code blocks this thread, no other concurrent events can be processed.&#13;
It would be a disaster in terms of responsiveness and concurrency.&#13;
The consequence of such an architecture is clear: your code must be nonblocking.&#13;
It must never block the I/O threads, as they are rare and are used to handle multiple concurrent requests.&#13;
To achieve this, you could offload the processing of some events to a worker thread (using the proactor pattern).&#13;
While it can discard some of the benefits of nonblocking I/O, it is sometimes the most rational choice (<a data-type="xref" href="#image:event-loop-worker">Figure 4-10</a>).&#13;
Nevertheless, we should not abuse this as it would discard the reactive benefits and make the application slow.&#13;
The multiple context switches required to handle an event on a worker thread penalizes the response time.</p>&#13;
&#13;
<figure><div class="figure" id="image:event-loop-worker">&#13;
<img alt="Running some event handlers on worker threads" src="assets/rsij_0410.png"/>&#13;
<h6><span class="label">Figure 4-10. </span>Running some event handlers on worker threads</h6>&#13;
</div></figure>&#13;
&#13;
<p>Typically, our applications from <a data-type="xref" href="ch02.html#quarkus">Chapter 2</a> and <a data-type="xref" href="ch03.html#distributed-system">Chapter 3</a> rely on such a mechanism.</p>&#13;
&#13;
<p>Another possibility is to rely only on nonblocking code, relying on asynchronous APIs provided by the reactive framework.&#13;
These APIs would be nonblocking, and if the business logic involved I/O, it uses nonblocking I/O.&#13;
Every time an <em>event handler</em> executes an asynchronous operation, another handler (the continuation) is registered, and when the expected event arrives, the event loop invokes it.&#13;
Thus, the processing is divided into smaller handlers running asynchronously.&#13;
That model is the most efficient and embraces the concepts entirely behind Reactive.<a data-startref="ix_reactive-systems-adoc21" data-type="indexterm" id="idm45358830272208"/><a data-startref="ix_reactive-systems-adoc20" data-type="indexterm" id="idm45358830271440"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="idm45358830634656">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>Reactive systems are about building better distributed systems.&#13;
They don’t aim to hide the nature of distributed systems but, on the contrary, embrace it.</p>&#13;
&#13;
<p>In this chapter, you learned the following:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>The four pillars of reactive systems (asynchronous message passing, elasticity, resilience, and responsiveness)</p>&#13;
</li>&#13;
<li>&#13;
<p>How asynchronous message passing enables elasticity and resilience, and increases the autonomy of each individual component</p>&#13;
</li>&#13;
<li>&#13;
<p>The role of commands and events in a distributed system</p>&#13;
</li>&#13;
<li>&#13;
<p>How nonblocking I/O improves resource utilization in reactive applications</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>But this last point has a significant drawback, as we need to write nonblocking code.&#13;
What a coincidence! The next chapter is precisely about that!<a data-startref="ix_reactive-systems-adoc2" data-type="indexterm" id="idm45358830263840"/><a data-startref="ix_reactive-systems-adoc1" data-type="indexterm" id="idm45358830263168"/><a data-startref="ix_reactive-systems-adoc0" data-type="indexterm" id="idm45358830262480"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<div data-type="footnotes"><p data-type="footnote" id="idm45358831669616"><sup><a href="ch04.html#idm45358831669616-marker">1</a></sup> <a href="https://oreil.ly/CtY3x">“Don’t Build a Distributed Monolith”</a> by Ben Christensen is an interesting talk about distributed monoliths and why you should avoid them.</p><p data-type="footnote" id="idm45358831644992"><sup><a href="ch04.html#idm45358831644992-marker">2</a></sup> This pattern is called <a href="https://oreil.ly/Umhs9">Change Data Capture</a>. Frameworks such as <a href="https://debezium.io">Debezium</a> are a key element of reactive systems when using databases, as the events are emitted without any impact on the application code.</p><p data-type="footnote" id="idm45358831203712"><sup><a href="ch04.html#idm45358831203712-marker">3</a></sup> We are referring to the traditional Spring Framework. Reactive Spring is based on nonblocking I/O.</p><p data-type="footnote" id="idm45358830663584"><sup><a href="ch04.html#idm45358830663584-marker">4</a></sup> <a href="https://oreil.ly/hv2Uy">“Measuring Context Switching and Memory Overheads for Linux Threads”</a> by Eli Bendersky provides interesting data about the cost of threads on Linux.</p></div></div></section></body></html>