- en: Chapter 15\. Encapsulated Collections to Type Aliases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Java, we encapsulate collections of objects in classes to control mutation
    and add operations. Controlling mutation is less of a concern in Kotlin, and we
    can use extension functions to add operations. How would our designs be better
    without the encapsulation, and how do we get there?
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In [Chapter 6](ch06.html#java-to-kotlin-collections) we looked at the differences
    between the grains of Java and Kotlin when it comes to collections. Java’s collection
    interfaces, in keeping with its object-oriented roots, are fundamentally mutable,
    whereas Kotlin treats collections as value types. As we saw, if we mutate shared
    collections, we can run into all sorts of trouble. We *could* avoid that trouble
    by not mutating shared collections ([“Don’t Mutate Shared Collections”](ch06.html#dont-mutate-shared-collections)),
    but in Java that’s hard to do when those `add` and `set` methods are just an autocomplete
    away. Instead of convention and discipline, most Java code sensibly opts for the
    safer approach of simply not sharing raw collections. Instead, collections are
    hidden inside another object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, for example, is a `Route` in Travelator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 15.1 [encapsulated-collections.0:src/main/java/travelator/itinerary/Route.java]](https://java-to-kotlin.dev/code.html?ref=15.1&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.1&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: '[![1](assets/1.png)](#co_introduction_CO23-1)'
  prefs: []
  type: TYPE_NORMAL
- en: A `Route` encapsulates a `List` of `Journey`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_introduction_CO23-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The raw data is passed in the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_introduction_CO23-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Access to the data, for example for displaying in the UI, is provided by `size`
    and `get` methods.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_introduction_CO23-5)'
  prefs: []
  type: TYPE_NORMAL
- en: The `Route` class implements application logic that uses the contents of the
    encapsulated list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have a `Route` class, it is a convenient namespace to host operations
    on routes, like `getDepartsFrom` and `getDuration`. In this case, all the methods
    shown only use other public methods, and there is no polymorphic behavior, so
    these operations *could* be defined as static methods taking a `Route` parameter.
    We can view `Route` as more of a namespace than a class: the operations don’t
    *have* to be methods; it’s just more convenient that they are, at least in Java,
    where static functions are so much less discoverable than methods. In Kotlin,
    as we saw in [Chapter 10](ch10.html#functions-to-extension-functions), making
    the operations into extension functions would let us find and call them as if
    they were methods. `Route` as a class would then be adding no value to `List`
    of `Journey`, just preventing people from changing it. And in an all-Kotlin codebase,
    that `List` would be effectively immutable anyway.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, `Route` is doing worse than adding no value to `List<Journey>`—it
    is removing value. If we had a `List<Journey>`, our frontend code could use its
    `Iterator` when rendering:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 15.2 [encapsulated-collections.0:src/main/java/travelator/UI.java]](https://java-to-kotlin.dev/code.html?ref=15.2&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.2&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'With a `Route`, we’re back to programming in the 1980s:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 15.3 [encapsulated-collections.0:src/main/java/travelator/UI.java]](https://java-to-kotlin.dev/code.html?ref=15.3&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.3&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: If we encapsulate a collection, we *reduce* the operations available for us
    to work with its contents to only those defined by the encapsulating class. When
    we want to process that data in a new way, the path of least resistance is to
    add new methods to the class. The more methods we add to the class, the more the
    class *increases* the coupling between different parts of our application. Before
    we know it, adding an operation to support a new UI function ends up recompiling
    our data-access layer.
  prefs: []
  type: TYPE_NORMAL
- en: Composing Domain Collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we don’t encapsulate the collection—if we make our domain model *be* the
    appropriate data structure, rather than hiding it inside another class boundary—we
    *extend* the operations available for us to work with the data. Then we have our
    application-specific operations *and* all the operations defined for the collection.
    Client code can define the operations it needs in terms of the rich Collections
    API without having to add them to the class.
  prefs: []
  type: TYPE_NORMAL
- en: Rather than a `Route` class accreting all the route functionality and in turn
    coupling all the parts of our application together, we can view functionality
    as operations to be composed by importing extension functions. The UI can define
    functions that render `List<Journey>`, which in turn import functions that transform
    `Iterable<Journey>`. The persistence layer can transform database responses into
    `List<Journey>` and have no particular concept of “routyness” at all.
  prefs: []
  type: TYPE_NORMAL
- en: We can program like this in Java, but the poor discoverability of static functions,
    combined with mutable collections, goes against the grain of the language. Kotlin
    has extension functions to make static functions more discoverable, and immutable
    collections, so that breaking our domain model into collection types and separate
    operations becomes the happy path.
  prefs: []
  type: TYPE_NORMAL
- en: If we don’t need to control access to a collection to prevent embarrassing mutation,
    and we don’t need to write a class to host operations on collections of a type,
    then is our `Route` class doing anything for us? Well, it is giving a name to
    `List<Journey>`, and it is also giving a type to this `List<Journey>` that might
    distinguish it from another `List<Journey>`—those in reports about all the journeys
    our travelers have booked this week, for example. Apart from that, though, in
    some ways it actually gets in our way, as we will see in [“Substitute a Type Alias”](#substitute-type-alias).
  prefs: []
  type: TYPE_NORMAL
- en: 'Where differentiating between different types of lists of journeys is *not*
    critical, Kotlin allows us to use type aliases to associate the name `Route` with
    `List<Journey>` rather than having to use a class to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In Kotlin, then, the obstacles to using collections as domain types have been
    removed. Encapsulating immutable collections should be the exception rather than
    the rule.
  prefs: []
  type: TYPE_NORMAL
- en: Collections with Other Properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Of course, we can’t always just substitute type aliases for classes. Take our
    `Itinerary` class, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 15.4 [encapsulated-collections.0:src/main/java/travelator/itinerary/Itinerary.kt]](https://java-to-kotlin.dev/code.html?ref=15.4&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.4&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the `Journey`s currently hidden in its `route`, `Itinerary` has
    an `Id` that allows us to address it as an entity. In these cases, we can’t just
    replace the class with its collection.
  prefs: []
  type: TYPE_NORMAL
- en: In these cases, we can gain many of the advantages of unencapsulated collections
    by making `Itinerary` implement `List<Journey>`. That’s hard to do right now,
    because `Route` doesn’t implement that interface itself, but this is a good strategy
    as more of our domain is expressed as complete collections. We’ll get to it in
    [“Refactoring Collections with Other Properties”](#collections-with-properties).
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring Encapsulated Collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the core services of our Travelator application is route planning.
  prefs: []
  type: TYPE_NORMAL
- en: The `Route` that we saw earlier is a sequence of journeys that can take the
    traveler from one location to another. We’d like to add some functionality that
    will allow us to sell accommodation where a `Route` is split over days, but as
    a key domain abstraction, `Route` is collapsing under the weight of all the operations
    that we have already added to it and coupling disparate parts of the codebase
    together. Let’s see if we can refactor `Route` to make some room before we start
    work on the new feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here again is the Java `Route` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 15.5 [encapsulated-collections.1:src/main/java/travelator/itinerary/Route.java]](https://java-to-kotlin.dev/code.html?ref=15.5&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.5&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: Convert Operations to Extensions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’re going to make `Route` less unwieldy (maybe even more wieldy) by moving
    its operations from methods to functions. Extension functions make this a reasonable
    strategy, but only from Kotlin, where they are much more discoverable. So we’re
    only going to attempt this stunt once the majority of our uses of `Route` are
    Kotlin. Luckily, our team really likes converting Java to Kotlin and has been
    beavering away as they work through the chapters of this book, so we’re ready
    to try this refactoring.
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, we want to unencapsulate the collection so that our clients work
    in terms of `List<Journey>` rather than using `Route`, and operations are provided
    by extension functions on that `List<Journey>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll start by converting `Route` to Kotlin, which after some tidying yields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 15.6 [encapsulated-collections.2:src/main/java/travelator/itinerary/Route.kt]](https://java-to-kotlin.dev/code.html?ref=15.6&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.6&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: As usual, you should assume that we are running our tests between refactors
    to make sure that we haven’t broken anything. All is fine at the moment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once a class is in Kotlin, IntelliJ can convert methods into extension methods.
    Let’s try out this refactoring on the `departsFrom` property: select it, press
    Alt-Enter, and choose “Convert member to extension”. The method disappears and
    reappears at the top level of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 15.7 [encapsulated-collections.3:src/main/java/travelator/itinerary/Route.kt]](https://java-to-kotlin.dev/code.html?ref=15.7&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.7&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Kotlin code will continue to be able to access `route.departsFrom` as a property,
    but Java code can’t. IntelliJ has helpfully fixed up the one Java usage to see
    the property as a static method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 15.8 [encapsulated-collections.3:src/main/java/travelator/UI.java]](https://java-to-kotlin.dev/code.html?ref=15.8&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.8&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: '[![1](assets/1.png)](#co_introduction_CO24-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Call of static method in `Route.kt`
  prefs: []
  type: TYPE_NORMAL
- en: '“Convert member to extension” works well for methods that only call `Route`’s
    public API. It will fail if we try it on, for example, `withJourneyAt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 15.9 [encapsulated-collections.3:src/main/java/travelator/itinerary/Route.kt]](https://java-to-kotlin.dev/code.html?ref=15.9&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.9&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'This references the `journeys` property, which is currently private and so
    not visible to an extension function. At this point we can make the property public
    (provided that we don’t abuse it by mutating the `List` from Java code). This
    fixes the extension function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 15.10 [encapsulated-collections.4:src/main/java/travelator/itinerary/Route.kt]](https://java-to-kotlin.dev/code.html?ref=15.10&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.10&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can continue the process of converting members to extensions until there
    are no members left; even `size` and `get` can be moved out, provided we are happy
    to use them statically in any remaining Java clients:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 15.11 [encapsulated-collections.5:src/main/java/travelator/UI.java]](https://java-to-kotlin.dev/code.html?ref=15.11&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.11&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: (Note that as we have converted the `size` method to a `size` extension property,
    Java sees a `getSize` function.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Here then is all that is left of the once-bloated `Route` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 15.12 [encapsulated-collections.5:src/main/java/travelator/itinerary/Route.kt]](https://java-to-kotlin.dev/code.html?ref=15.12&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.12&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: All its operations (bar accessing the `journeys`) are now extensions, albeit
    in the same file. But now that they *are* extensions, we can move them from this
    file to others, even in different modules, to better decouple our dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Substitute a Type Alias
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we’ve achieved our goal of decoupling the `Route` functionality from
    the class, is that class superfluous? Actually, wrapping the `List` is worse than
    superfluous: it prevents us from easily using all the useful extension functions
    in Kotlin’s standard library to construct, transform, and process routes. To quote
    one of Alan Perlis’s [Epigrams of Programming](https://oreil.ly/QDOJz): “It is
    better to have 100 functions operate on one data structure than 10 functions on
    10 data structures.” We don’t want a `Route` to *have* a `List` of `Journey`;
    we want it to *be* a `List` of `Journey`. This is very easy to achieve in Kotlin
    with delegation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 15.13 [encapsulated-collections.6:src/main/java/travelator/itinerary/Route.kt]](https://java-to-kotlin.dev/code.html?ref=15.13&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.13&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: In fact, though, we may want more than for a `Route` to be a `List` of `Journey`;
    we may want a `List` of `Journey` to be a `Route`. To see why, let’s look at that
    `withJourneyAt` function that we glossed over earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a traveler decides that they would rather not travel by camel, we can’t
    just replace a `Journey`, because `Route` is immutable. Instead, we return a new
    `Route` where `journeys` is a copy with the relevant `Journey` replaced:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 15.14 [encapsulated-collections.5:src/test/java/travelator/itinerary/RouteTests.kt]](https://java-to-kotlin.dev/code.html?ref=15.14&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.14&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: (In passing, note that this test was made more complicated by only having `get`
    to access the components of a `route`. We can fix that now that we can access
    the `journeys` property directly.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the implementation again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 15.15 [encapsulated-collections.4:src/main/java/travelator/itinerary/Route.kt]](https://java-to-kotlin.dev/code.html?ref=15.15&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.15&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Because `Route` wraps `journeys`, we can’t just operate on `journeys`; we have
    to unwrap, operate, and then wrap back up again. If a `List<Journey>` was a `Route`,
    then we could use a nice generic function like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 15.16 [encapsulated-collections.7:src/main/java/travelator/itinerary/Route.kt]](https://java-to-kotlin.dev/code.html?ref=15.16&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.16&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'As it is, even using `withItemAt`, we still have to deal with the wrapper:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 15.17 [encapsulated-collections.7:src/main/java/travelator/itinerary/Route.kt]](https://java-to-kotlin.dev/code.html?ref=15.17&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.17&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: Any operation that transforms `Route`s will have this problem—a problem that
    wouldn’t exist if we just used a type alias to say that a `Route` and `List<Journey>`
    are the same type.
  prefs: []
  type: TYPE_NORMAL
- en: To get there, we will have to remove all the calls to the `Route` constructor
    and the accesses of the `journeys` property, effectively unwrapping our carefully
    crafted encapsulation. There is a trick to do this automagically, but it relies
    on having converted all clients of `Route` to Kotlin. So does using a type alias
    though, so if we have any remaining Java clients, we have to resign ourselves
    to some manual editing.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we’re going to do is replace the class with a type alias and, at the same
    time, add temporary definitions that emulate the API of the class. That API is
    currently:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 15.18 [encapsulated-collections.6:src/main/java/travelator/itinerary/Route.kt]](https://java-to-kotlin.dev/code.html?ref=15.18&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.18&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'We emulate it with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 15.19 [encapsulated-collections.8:src/main/java/travelator/itinerary/Route.kt]](https://java-to-kotlin.dev/code.html?ref=15.19&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.19&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Because there is no `new` keyword in Kotlin, we can emulate the constructor
    call `Route(...)` with a function of the same name. Similarly, we replace the
    `journeys` property with an extension property that returns the receiver itself.
    The net result is that our Kotlin clients continue to compile against this new
    API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 15.20 [encapsulated-collections.8:src/test/java/travelator/itinerary/RouteTests.kt]](https://java-to-kotlin.dev/code.html?ref=15.20&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.20&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: '[![1](assets/1.png)](#co_introduction_CO25-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Our new function, not the constructor
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_introduction_CO25-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Extension property, not the class property
  prefs: []
  type: TYPE_NORMAL
- en: 'Inlining both function and property completes the refactor. The encapsulated
    collection is now just a collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 15.21 [encapsulated-collections.9:src/test/java/travelator/itinerary/RouteTests.kt]](https://java-to-kotlin.dev/code.html?ref=15.21&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.21&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: '[![1](assets/1.png)](#co_introduction_CO26-1)'
  prefs: []
  type: TYPE_NORMAL
- en: '`Route` was a no-op'
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_introduction_CO26-2)'
  prefs: []
  type: TYPE_NORMAL
- en: As was `journeys`
  prefs: []
  type: TYPE_NORMAL
- en: 'Any remaining Java clients will have been broken when we replaced the `Route`
    class with a type alias, because Java doesn’t understand type aliases. We fixed
    those by hand, replacing `Route` with `List<Journey>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 15.22 [encapsulated-collections.8:src/main/java/travelator/UI.java]](https://java-to-kotlin.dev/code.html?ref=15.22&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.22&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our transformation is almost complete. We still have `size` and `get` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 15.23 [encapsulated-collections.9:src/main/java/travelator/itinerary/Route.kt]](https://java-to-kotlin.dev/code.html?ref=15.23&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.23&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: Because these have the same signature as their method counterparts on `List`,
    the compiler warns us that they are shadowed; our Kotlin will be calling the methods,
    not the extensions. That means that if we didn’t have any Java client code invoking
    the extensions as statics, we could delete them.
  prefs: []
  type: TYPE_NORMAL
- en: 'We do have a Java client, though—that pesky rendering code, which is still
    calling the extensions as `getSize` and `get` in `RouteKt`. Those extensions are
    calling the methods that we want to use, but we can’t inline code from Kotlin
    to Java, so we’ll just delete the extensions anyway. Now the compiler will tell
    us where we need to fix the Java, and we can do that by hand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 15.24 [encapsulated-collections.10:src/main/java/travelator/UI.java]](https://java-to-kotlin.dev/code.html?ref=15.24&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.24&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'In reality, of course, we would replace this with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 15.25 [encapsulated-collections.10:src/main/java/travelator/UI.java]](https://java-to-kotlin.dev/code.html?ref=15.25&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.25&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Kotlin clients are unphased by deleting the extensions, because they were
    always calling the methods on `List`, so the transformation is almost complete.
    We can also now inline `withJourneyAt`, because it too is a no-op. This leaves
    us with `Route` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 15.26 [encapsulated-collections.10:src/main/java/travelator/itinerary/Route.kt]](https://java-to-kotlin.dev/code.html?ref=15.26&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.26&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our Kotlin usages are just `List` operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 15.27 [encapsulated-collections.10:src/test/java/travelator/itinerary/RouteTests.kt]](https://java-to-kotlin.dev/code.html?ref=15.27&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.27&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Any residual Java is readable, if a little ugly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 15.28 [encapsulated-collections.10:src/main/java/travelator/UI.java]](https://java-to-kotlin.dev/code.html?ref=15.28&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.28&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring Collections with Other Properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we saw previously, we can’t use type aliases when our types have collections
    with other attributes. We looked at `Itinerary`, which combines an `id` with a
    `Route`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 15.29 [encapsulated-collections.11:src/main/java/travelator/itinerary/Itinerary.kt]](https://java-to-kotlin.dev/code.html?ref=15.29&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.29&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can get the advantages of being able to query `Journey`s directly by implementing
    `Route` with delegation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 15.30 [encapsulated-collections.12:src/main/java/travelator/itinerary/Itinerary.kt]](https://java-to-kotlin.dev/code.html?ref=15.30&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.30&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: '[![1](assets/1.png)](#co_introduction_CO27-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The `by route` clause declares that the `Itinerary` object will delegate all
    methods on the `Route` interface to the `route` parameter passed to its constructor.
    A class can override this behavior by providing its own implementation of methods
    of the delegated interface, but we don’t want to do this for `Itinerary`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we can treat `Itinerary` as a `Route`, we can move `hasJourneyLongerThan`
    out as an extension and have it available to any `Route`, not just to `Itinerary`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 15.31 [encapsulated-collections.13:src/main/java/travelator/itinerary/Itinerary.kt]](https://java-to-kotlin.dev/code.html?ref=15.31&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.31&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'All those extensions to `Route` (aka `List<Journey>`) that we moved from methods
    to extensions are also now applicable to `Itinerary` as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 15.32 [encapsulated-collections.13:src/main/java/travelator/itinerary/itineraries.kt]](https://java-to-kotlin.dev/code.html?ref=15.32&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.32&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: '[![1](assets/1.png)](#co_introduction_CO28-1)'
  prefs: []
  type: TYPE_NORMAL
- en: This is `Route.duration`, aka `List<Journey>.duration`
  prefs: []
  type: TYPE_NORMAL
- en: 'What we can’t do as easily is create a new `Itinerary` from an existing one.
    This is now easy for `Route`, because standard API operations on `List<Journey>`
    (actually, usually `Iterable<Journey>`, as we saw in [Chapter 6](ch06.html#java-to-kotlin-collections))
    return `List<Journey>`, which is the other name for `Route`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 15.33 [encapsulated-collections.13:src/main/java/travelator/itinerary/itineraries.kt]](https://java-to-kotlin.dev/code.html?ref=15.33&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.33&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'For `Itinerary`, we have to create a new `Itinerary` to rewrap the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 15.34 [encapsulated-collections.13:src/main/java/travelator/itinerary/itineraries.kt]](https://java-to-kotlin.dev/code.html?ref=15.34&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.34&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is yet another place where data classes come to the rescue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 15.35 [encapsulated-collections.14:src/main/java/travelator/itinerary/Itinerary.kt]](https://java-to-kotlin.dev/code.html?ref=15.35&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.35&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Making `Itinerary` a data class means that we can make a copy with just a revised
    route, no matter how many other properties it has:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 15.36 [encapsulated-collections.14:src/main/java/travelator/itinerary/itineraries.kt]](https://java-to-kotlin.dev/code.html?ref=15.36&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.36&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Better still, we can add a method `withTransformedRoute`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 15.37 [encapsulated-collections.15:src/main/java/travelator/itinerary/Itinerary.kt]](https://java-to-kotlin.dev/code.html?ref=15.37&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.37&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'This allows us to create a transformed `Itinerary` almost as easily as we could
    create a transformed `Route`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 15.38 [encapsulated-collections.15:src/main/java/travelator/itinerary/itineraries.kt]](https://java-to-kotlin.dev/code.html?ref=15.38&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=15.38&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: Moving On
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We started this chapter with a Java class that encapsulated a mutable collection
    to guarantee value semantics. As we translated more of our code to Kotlin, we
    could rely on Kotlin’s type system to prevent the collection from being modified,
    and no longer needed to encapsulate it within the class. That allowed us to convert
    operations from methods to extensions, and move their definitions close to where
    they are used. Because our class encapsulated a single collection, we were able
    to eliminate the class altogether and replace it with a type alias.
  prefs: []
  type: TYPE_NORMAL
- en: Immutable collections and extensions allow us to organize our code in ways that
    are not available in Java. We can group all the logic required by a particular
    feature of the application in the same module, regardless of the domain classes
    the logic applies to. However, if we wanted methods of those domain classes to
    be polymorphic methods, we would have to define them on those classes and not
    in our feature module. In [Chapter 18, *Open to Sealed Classes*](ch18.html#open-to-sealed-classes),
    we look at sealed classes, an alternative to object-oriented polymorphism that
    is more convenient when we define type hierarchies in one part of the code and
    operations on those types in another.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, note that reusing built-in types like `List` rather than defining a
    specific type is not without cost. We might be storing items in a `List` as an
    implementation detail rather than a modeling choice. It’s also a lot easier to
    “Find usages” of a specific wrapper class than a generic specialization. Nevertheless,
    the standard collection types are pervasive because they are such good abstractions—so
    good that we generally shouldn’t hide them. [Chapter 22, *Classes to Functions*](ch22.html#classes-to-functions),
    looks at what happens if we take this idea and run with it.
  prefs: []
  type: TYPE_NORMAL
