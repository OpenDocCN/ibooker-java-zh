- en: 'Chapter 10\. Reactive Messaging: The Connective Tissue'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 10 章. 反应式消息传递：连接的纽带
- en: In [Part III](part03.html#quarkus-part), you saw many features to develop reactive
    applications with Quarkus. But, as you remember from [Part II](part02.html#reactive-part),
    we don’t want to limit ourselves to reactive applications; we want to build reactive
    systems. That’s what we are going to do now.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 III 部分](part03.html#quarkus-part) 中，您已经看到了许多使用 Quarkus 开发反应式应用程序的特性。但是，正如您从
    [第 II 部分](part02.html#reactive-part) 中记得的那样，我们不想局限于反应式应用程序；我们想要构建反应式系统。这就是我们现在要做的。
- en: Reactive systems use asynchronous message passing among their components. However,
    while middleware and frameworks can sometimes hide this message-passing aspect,
    we believe it’s far more efficient to make it apparent. It not only helps you
    write event-driven code (*on event x, do y*), but also helps decompose your application
    into a set of components receiving and producing messages. Thus, Quarkus offers
    a message-driven development model that is simple but powerful to consume, process,
    and create messages. This chapter focuses on this model, how it relates to Reactive
    Streams, and how it makes building message-driven and event-driven applications
    straightforward.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 反应式系统使用其组件之间的异步消息传递。然而，尽管中间件和框架有时可以隐藏这种消息传递的细节，但我们认为将其显露出来效果更好。这不仅有助于编写事件驱动的代码（*在事件
    x 上执行 y*），还有助于将您的应用程序分解为接收和生成消息的一组组件。因此，Quarkus 提供了一个简单而强大的消息驱动开发模型，用于消费、处理和创建消息。本章重点介绍这种模型，以及它与反应式流的关系，以及如何简化构建基于消息驱动和事件驱动的应用程序。
- en: From Reactive Applications to Reactive Systems
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从反应式应用程序到反应式系统
- en: When you talk to a Java developer about messaging, you can feel the frustration.
    For years, JMS has been the de facto standard for messaging. However, that API
    didn’t age well, and new messaging technologies such as Kafka and Pulsar use concepts
    that do not work well with JMS. In addition, JMS is a blocking API, which prevents
    us from implementing reactive principles.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 当您与 Java 开发人员讨论消息传递时，您会感受到他们的挫败感。多年来，JMS 一直是消息传递的事实标准。然而，该 API 的老化问题日益严重，而新的消息传递技术如
    Kafka 和 Pulsar 使用的概念与 JMS 不兼容。此外，JMS 是一个阻塞式 API，这阻碍了我们实现反应式原则。
- en: While Quarkus can use JMS, we are going to look at another approach called *Reactive
    Messaging*. This MicroProfile specification builds reactive and event-driven applications.
    Quarkus implements version 2*.x* of the specification but also provides many extensions.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Quarkus 可以使用 JMS，但我们将看看另一种称为 *反应式消息传递* 的方法。这个 MicroProfile 规范构建了反应式和事件驱动的应用程序。Quarkus
    实现了规范的 2*.x* 版本，同时还提供了许多扩展功能。
- en: Applications using Reactive Messaging can send, consume, and process messages
    in a protocol-agnostic way. For example, as you will see in [Chapter 11](ch11.html#event-bus),
    you will be able to use Apache Kafka or AMQP or even combine both. Reactive Messaging
    also provides a natural development model for developers used to Contexts and
    Dependency Injection (CDI), a standard dependency injection framework. Typically,
    you can summarize Reactive Messaging to a couple of annotations. But before seeing
    it in action, let’s describe a few concepts that it relies on.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 使用反应式消息传递的应用程序可以以与协议无关的方式发送、消费和处理消息。例如，正如您将在 [第 11 章](ch11.html#event-bus) 中看到的那样，您可以使用
    Apache Kafka 或 AMQP，甚至可以将两者结合使用。反应式消息传递还为习惯于上下文和依赖注入（CDI）的开发人员提供了一种自然的开发模型，这是一个标准的依赖注入框架。通常，您可以用几个注解来总结反应式消息传递。但在看它实际运作之前，让我们先描述一些它依赖的概念。
- en: Channels and Messages
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通道和消息
- en: When using Reactive Messaging, your applications and components forming them
    interact using *messages*, represented with the `o⁠r⁠g.e⁠c⁠l⁠i⁠p⁠s⁠e.m⁠i⁠c⁠r⁠o⁠p⁠r⁠o⁠f⁠i⁠l⁠e⁠.​r⁠e⁠a⁠c⁠t⁠i⁠v⁠e⁠.m⁠e⁠s⁠s⁠a⁠g⁠i⁠n⁠g⁠.M⁠e⁠s⁠s⁠a⁠g⁠e⁠<T>`
    class. A *message* is an envelope that has a payload of type `T`. In addition,
    a message can have metadata and provides acknowledgment methods to notify the
    framework of the successful or failed processing of a message.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用反应式消息传递时，您的应用程序和组件通过 *消息* 进行交互，这些消息由 `o⁠r⁠g.e⁠c⁠l⁠i⁠p⁠s⁠e.m⁠i⁠c⁠r⁠o⁠p⁠r⁠o⁠f⁠i⁠l⁠e⁠.​r⁠e⁠a⁠c⁠t⁠i⁠v⁠e⁠.m⁠e⁠s⁠s⁠a⁠g⁠i⁠n⁠g⁠.M⁠e⁠s⁠s⁠a⁠g⁠e⁠<T>`
    类来表示。*消息* 是一个信封，其负载类型为 `T`。此外，消息可以具有元数据，并提供确认方法来通知框架消息的成功或失败处理。
- en: Messages transit on *channels*. You can picture channels as pipes. A channel
    can be internal to an application or mapped, by a connector, to an external message
    queue or topic ([Figure 10-1](#image:channels)).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 消息在 *通道* 上传输。您可以将通道想象成管道。通道可以是应用程序内部的，也可以通过连接器映射到外部消息队列或主题（[图 10-1](#image:channels)）。
- en: '![Message-based Application Architecture](assets/rsij_1001.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![基于消息的应用架构](assets/rsij_1001.png)'
- en: Figure 10-1\. Message-based application architecture
  id: totrans-11
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10-1\. 基于消息的应用架构
- en: Your application reads from channels and writes to channels. You can split your
    application into a set of components, with all of them reading and writing to
    different channels. That’s it. Reactive Messaging binds everything all together,
    and so constructs streams in which messages flow.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你的应用程序从通道读取并写入通道。你可以将你的应用程序分割成一组组件，它们都从不同的通道读取和写入。就是这样。响应式消息传递将所有内容绑在一起，从而构建消息流。
- en: Producing Messages
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成消息
- en: 'Reactive Messaging provides multiple ways to produce messages, but let’s start
    with the simplest and probably more natural one for developers familiar with imperative
    programming: emitters. `Emitter` is an object that is attached to a channel and
    emits messages to that channel.^([1](ch10.html#idm45358821092016)) [Example 10-1](#messaging::emitter)
    illustrates the use of `MutinyEmitter`.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式消息传递提供了多种生成消息的方式，但让我们从最简单且可能更符合熟悉命令式编程的开发者的方式开始：发射器。`Emitter`是一个附加到通道并将消息发射到该通道的对象。^([1](ch10.html#idm45358821092016))
    [示例 10-1](#messaging::emitter) 说明了使用`MutinyEmitter`发送消息的方法。
- en: Example 10-1\. Use an emitter to send messages
  id: totrans-15
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-1\. 使用发射器发送消息
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: To access an emitter, you just inject it in your CDI bean. The target channel
    is indicated using the `@Channel` annotation.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问一个发射器，只需在你的CDI bean中注入它。目标通道使用`@Channel`注解指示。
- en: Tip
  id: totrans-18
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: There’s no need to use the `@Inject` annotation, as Quarkus detects the injection
    for you.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要使用`@Inject`注解，因为Quarkus会自动检测注入。
- en: In [Example 10-1](#messaging::emitter), we don’t produce a `Message` instance;
    we just send a payload (`Person`), automatically wrapped into a message. Note
    that the `send` method returns `Uni<Void>`. This `Uni` produces a `null` item
    when the message processing completes successfully. Otherwise, it produces a failure
    indicating why the processing failed.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [示例 10-1](#messaging::emitter) 中，我们不会生成一个`Message`实例；我们只发送一个被自动包装成消息的负载（`Person`）。请注意，`send`方法返回`Uni<Void>`。这个
    `Uni` 在消息处理成功完成时生成一个`null`项。否则，它会生成一个指示处理失败原因的故障。
- en: An emitter can also send an instance of `Message` directly, as shown in [Example 10-2](#messaging::emitter-message).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 发射器也可以直接发送`Message`的实例，就像 [示例 10-2](#messaging::emitter-message) 中展示的那样。
- en: Example 10-2\. Injection and use of an emitter
  id: totrans-22
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-2\. 注入和使用发射器
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When sending a `Message`, you can directly pass the acknowledgment callbacks.
    We cover acknowledgment in [“Acknowledgments”](#acknowledgements_aspect).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当发送`Message`时，你可以直接传递确认回调。我们在 [“确认”](#acknowledgements_aspect) 中讨论确认。
- en: Emitters are convenient when you want to decide when to send a message. They
    allow imperative code to emit messages that will be handled in a reactive manner.
    For example, you can use an emitter in an HTTP endpoint and send a message when
    you receive a request.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当你希望决定何时发送消息时，发射器就非常方便。它们允许命令式代码发射消息，这些消息将以反应式方式处理。例如，你可以在HTTP端点中使用发射器，在收到请求时发送消息。
- en: 'Another way to produce messages is with the `@Outgoing` annotation. It instructs
    Reactive Messaging to send the output of the method to the specified channel.
    Note that methods annotated with `@Outgoing` can’t be called from your code; Reactive
    Messaging calls them for you. You may wonder about the benefits. It looks a bit
    less flexible than emitters. But there is a trick: `@Outgoing` allows producing
    streams (`Multi`) directly ([Example 10-3](#messaging:outgoing)).'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种生成消息的方式是使用`@Outgoing`注解。它指示响应式消息传递将方法的输出发送到指定的通道。请注意，使用`@Outgoing`注解的方法不能从你的代码中调用；响应式消息传递会为你调用它们。也许你会对它的好处感到好奇。它看起来比发射器灵活性稍逊。但有一个技巧：`@Outgoing`允许直接生成流（`Multi`）（[示例 10-3](#messaging:outgoing)）。
- en: Example 10-3\. Usage of `@Outgoing`
  id: totrans-27
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-3\. 使用`@Outgoing`
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You can produce infinite streams every second, as demonstrated in [Example 10-4](#messaging:outgoing-infinite).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以每秒产生无限流，正如 [示例 10-4](#messaging:outgoing-infinite) 中演示的那样。
- en: Example 10-4\. Generate infinite streams by using `@Outgoing`
  id: totrans-30
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-4\. 使用`@Outgoing`生成无限流
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When the application starts, Reactive Messaging connects all the elements to
    the channels. Under the hood, it creates reactive streams (covered in [Chapter 5](ch05.html#reactive-programming)).
    So, your application is a set of reactive streams, enforcing the backpressure
    protocol. The consumption rate is controlled by the downstream subscribers. This
    is the reason we need `onOverflow.drop` in the preceding example. Otherwise, if
    the downstream subscriber does not consume fast enough, it would fail (you can’t
    apply backpressure in time).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序启动时，响应式消息连接所有元素到通道。在幕后，它创建了响应式流（在[第 5 章](ch05.html#reactive-programming)中讨论）。因此，您的应用程序是一组响应式流，强制执行背压协议。消费速率由下游订阅者控制。这就是为什么在前面的示例中我们需要`onOverflow.drop`。否则，如果下游订阅者不能及时消费，它将失败（您无法及时应用背压）。
- en: As for `Emitter`, you can produce a stream of messages ([Example 10-5](#messaging:outgoing-message)).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 至于`Emitter`，您可以生成消息流（[示例 10-5](#messaging:outgoing-message)）。
- en: Example 10-5\. Produce a stream of messages by using `@Outgoing`
  id: totrans-34
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-5\. 通过`@Outgoing`生成消息流
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, our messages are just wrapping the payload. As we have seen in the example,
    you can pass the acknowledgment callbacks.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们的消息只是包装了有效负载。正如我们在示例中看到的，您可以传递确认回调。
- en: Attentive readers may have observed a significant difference between the emitter
    and the `@Outgoing` approaches. Reactive Messaging handles the `@Outgoing` method
    completely (invoking it), so enforcing the backpressure protocol is no problem.
    But with the emitter, Reactive Messaging can’t. If your code uses an emitter to
    send messages faster than the consumption rate, you may be in trouble!
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 细心的读者可能已经观察到发射器和`@Outgoing`方法之间的显著差异。响应式消息完全处理`@Outgoing`方法（调用它），因此强制执行背压协议没有问题。但是对于发射器，响应式消息无法做到这一点。如果您的代码使用发射器发送消息速度快于消费率，您可能会遇到麻烦！
- en: Fortunately, to avoid this, you can configure an overflow strategy when using
    an emitter. This strategy describes what happens when the downstream does not
    consume fast enough. `@OnOverflow` offers six strategies. The most common, demonstrated
    in [Example 10-6](#messaging:onoverflow), consists of using a buffer.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，为了避免这种情况，在使用发射器时，您可以配置溢出策略。此策略描述了当下游消费不够快时会发生什么。`@OnOverflow`提供了六种策略。最常见的示例在[示例 10-6](#messaging:onoverflow)中演示了使用缓冲区。
- en: Example 10-6\. Usage of the `@OnOverflow` annotation
  id: totrans-39
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-6\. 使用`@OnOverflow`注解的用法
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `OnOverflow` strategies are similar to those in Mutiny:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnOverflow`策略与Mutiny中的策略类似：'
- en: '`BUFFER`, the default, uses a buffer to store the messages. The size can be
    configured; the default is 256.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BUFFER`是默认选项，使用缓冲区来存储消息。可以配置大小；默认大小为256。'
- en: '`UNBOUNDED_BUFFER` is like `BUFFER` but uses an unbounded buffer. Be cautious
    when using this strategy as it can lead to memory issues.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UNBOUNDED_BUFFER`与`BUFFER`类似，但使用无限缓冲区。使用此策略时要小心，因为可能会导致内存问题。'
- en: '`DROP` and `LATEST` drop the newest and oldest message, respectively.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DROP`和`LATEST`分别丢弃最新和最旧的消息。'
- en: '`FAIL` sends a failure downstream. Remember, failures are terminal for Reactive
    Streams. So, you can use the emitter after this.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FAIL`向下游发送失败。请记住，对于响应式流来说，失败是终端的。因此，在此之后您可以使用发射器。'
- en: '`THROW_EXCEPTION` throws an exception upstream to the caller of the `send`
    method. The caller can then react; for example, it can’t wait until the downstream
    subscriber catches up.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`THROW_EXCEPTION`向上游调用`send`方法时抛出异常。调用者可以对此作出反应；例如，它可能等不及下游订阅者赶上。'
- en: Consuming Messages
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消费消息
- en: Let’s have a look at the other side of the message pipe. To consume messages,
    you can inject the stream by using the `@Channel` annotation, as shown in [Example 10-7](#messaging:channel).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看消息管道的另一侧。要消耗消息，您可以通过使用`@Channel`注解来注入流，如[示例 10-7](#messaging:channel)所示。
- en: Example 10-7\. Inject a channel
  id: totrans-49
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-7\. 注入通道
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, you must subscribe to the injected stream. Remember, if you
    don’t subscribe, nothing will happen, and you won’t receive any messages. Note
    that your code can inject multiple streams and consume them.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，您必须订阅注入的流。请记住，如果您不订阅，什么都不会发生，您将不会收到任何消息。请注意，您的代码可以注入多个流并对其进行消费。
- en: You can also inject a stream of messages. In this case, you must acknowledge
    the messages manually ([Example 10-8](#messaging:channel-ack)).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以注入消息流。在这种情况下，您必须手动确认消息（[示例 10-8](#messaging:channel-ack)）。
- en: Example 10-8\. Inject a stream of messages
  id: totrans-53
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-8\. 注入消息流
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Acknowledgment is automatically done for you when injecting a stream of payloads.
    Messages give you more control on the acknowledgment, as well as the possibility
    to reject a message by using `nack`. In addition, you can access the message metadata.
    But, remember, with more power comes greater responsibility.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当你注入一组负载流时，确认会自动为你完成。消息让你在确认方面拥有更多控制权，同时还能通过使用`nack`拒绝消息。此外，你还可以访问消息的元数据。但是，请记住，更多的权力意味着更大的责任。
- en: The `@Channel` injection is convenient when you want to access the stream directly
    or when you want to control the subscription.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想直接访问流或者控制订阅时，注入`@Channel`非常方便。
- en: 'Reactive Messaging also offers a more declarative way to consume messages:
    the `@Incoming` annotation. This annotation is the opposite of `@Outgoing`. Reactive
    Messaging invokes the annotated method for each message transiting on the specified
    channel ([Example 10-9](#messaging:incoming)).'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式消息还提供了一种更声明式的消息消费方式：`@Incoming`注解。这个注解与`@Outgoing`相对应。响应式消息会调用在指定通道上每个消息通过的方法（[Example 10-9](#messaging:incoming)）。
- en: Example 10-9\. An example of a method using `@Incoming`
  id: totrans-58
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 10-9\. 使用`@Incoming`的方法示例
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[Example 10-9](#messaging:incoming) provides a convenient way to process every
    incoming `Person`. You don’t need to worry about acknowledgment; it’s done for
    you. You can also receive `Message`, as demonstrated in [Example 10-10](#messaging:incoming-message).'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '[Example 10-9](#messaging:incoming)提供了一种便捷的方式来处理每个传入的`Person`。你无需担心确认；这已经为你完成。你也可以接收`Message`，就像在[Example 10-10](#messaging:incoming-message)中展示的那样。'
- en: Example 10-10\. An example of a method using `@Incoming` and receiving messages
  id: totrans-61
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 10-10\. 使用`@Incoming`接收消息的方法示例
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In this case, as for `@Channel` injecting a stream of messages, you need to
    handle the acknowledgment yourself. Remember: more control, but more responsibility.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，就像对于注入消息流的`@Channel`一样，你需要自行处理确认。记住：更多的控制权，也意味着更大的责任。
- en: Processing Messages
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理消息
- en: 'Now that you have seen the two ends, let’s look at the middle of the pipeline:
    processing. To process messages, you combine `@Incoming` and `@Outgoing`, as shown
    in Example 10-11.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了两端，让我们来看看管道的中间部分：处理。为了处理消息，你需要结合`@Incoming`和`@Outgoing`，就像Example 10-11中展示的那样。
- en: Example 10-11\. Method using `@Incoming` and `@Outgoing`
  id: totrans-66
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 10-11\. 使用`@Incoming`和`@Outgoing`的方法
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this snippet, we read strings from the `from` channel. For each received
    string, we create a `Person` instance that is sent to the `to` channel. This method
    is synchronous and accepts an individual payload and returns an individual payload.
    That’s not the only supported signature. Reactive Messaging supports more than
    30 signatures, allowing asynchronous processing (such as returning `Uni`), or
    even stream processing (where you receive and return `Multi`s),^([2](ch10.html#idm45358820227664))
    see [Example 10-12](#messaging:stream).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，我们从`from`通道读取字符串。对于每个接收到的字符串，我们创建一个`Person`实例，然后将其发送到`to`通道。这种方法是同步的，接受一个个体负载并返回一个个体负载。这并不是唯一支持的签名方式。响应式消息支持超过30种签名，允许异步处理（例如返回`Uni`），甚至流处理（其中你接收并返回`Multi`），^([2](ch10.html#idm45358820227664))参见[Example 10-12](#messaging:stream)。
- en: Example 10-12\. Example of stream manipulation
  id: totrans-69
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 10-12\. 流操作示例
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In addition to payloads, you can process messages. But as for the consumption
    of messages, you need to be more attentive. Indeed, you often need to *chain*
    messages, or link the incoming message with the one you produce, as shown in [Example 10-13](#messaging:processing-messages).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 除了负载外，你还可以处理消息。但是对于消息的消费，你需要更加注意。确实，你经常需要*链式*消息，或者将传入的消息与你产生的消息链接起来，就像在[Example 10-13](#messaging:processing-messages)中展示的那样。
- en: Example 10-13\. Process messages
  id: totrans-72
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 10-13\. 处理消息
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this snippet, look at the `withPayload` method. The `Message` interface provides
    various `with` methods that link messages together. You may wonder why it’s so
    important to link them. It’s all about acknowledgment. You have seen this word
    a couple of times already, so it’s time to explain what it means.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，看看`withPayload`方法。`Message`接口提供了多个`with`方法来链接消息。你可能会想为什么将它们链接起来这么重要。这关乎确认。你已经多次见过这个词，现在是解释它的时候了。
- en: Acknowledgments
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确认
- en: '*Acknowledgment* is an essential aspect of any messaging system. When you use
    a message broker, the consumers, receiving and processing messages, must indicate
    to the broker when the message processing completes (successfully or not). Then
    the broker can decide to dispatch the next message, or to redeliver the same one
    if the processing failed. While the broker strategy is dependent on the broker
    itself, acknowledgment is a well-known concept that most messaging protocols use
    one way or another.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*确认* 是任何消息系统的重要组成部分。当您使用消息代理时，消费者接收并处理消息时必须向代理指示消息处理完成（成功或失败）。然后代理可以决定是否调度下一个消息，或者在处理失败时重新投递相同的消息。虽然代理策略依赖于代理本身，确认是一个众所周知的概念，大多数消息传递协议都以一种方式或另一种方式使用它。'
- en: In Reactive Messaging, each message must be *acked* (acknowledged successfully)
    or *nacked* (acknowledged negatively, or not acked). The `Message` interface offers
    the `ack` and `nack` methods to indicate the successful or failed processing of
    the message, respectively. Both methods are asynchronous and return `CompletionStage<Void>`.
    Indeed, when using a remote broker, acknowledging a message means telling the
    broker whether the message has been processed successfully. You will see in [Chapter 11](ch11.html#event-bus)
    how these acknowledgments are integrated with Apache Kafka and AMQP 1.0.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在响应式消息处理中，每条消息必须被 *ack*（成功确认）或 *nack*（否定确认或未确认）。`Message` 接口提供了 `ack` 和 `nack`
    方法来指示消息的成功或失败处理。这两个方法都是异步的，并返回 `CompletionStage<Void>`。实际上，当使用远程代理时，确认消息意味着告诉代理消息是否已成功处理。您将在
    [第 11 章](ch11.html#event-bus) 中看到这些确认如何与 Apache Kafka 和 AMQP 1.0 集成。
- en: When using individual payloads, Reactive Messaging handles the acknowledgment
    (positive or negative) for you. However, when you receive messages, you need to
    call these methods or produce a message that is *linked* to the incoming one.
    This link is essential. When the downstream consumer receives your message and
    acknowledges it, that consumer also acknowledges the linked message. These links
    form a chain of messages, and acknowledgments go up the chain until they reach
    the top (generally, a message produced by an emitter or from an external destination).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用单个有效载荷时，响应式消息处理确认（积极或消极）已为您处理。但是，当您接收消息时，您需要调用这些方法或生成一个*链接*到传入消息的消息。这种链接很重要。当下游消费者接收您的消息并对其进行确认时，该消费者还会确认链接的消息。这些链接形成一系列消息，并且确认沿着链条向上传递，直到达到顶部（通常是由发射器产生的消息或来自外部目的地）。
- en: As depicted on [Figure 10-2](#image:ack), the chain allows indicating the outcome
    of the processing, even when the processing is composed of several steps, potentially
    asynchronous ones.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如图 [10-2 图](#image:ack) 所示，即使处理包含多步骤（可能是异步的）时，链条也允许指示处理结果。
- en: '![Acknowledgement chain](assets/rsij_1002.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![确认链](assets/rsij_1002.png)'
- en: Figure 10-2\. Acknowledgment chain
  id: totrans-81
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10-2\. 确认链
- en: 'Let’s consider an example to illustrate the behavior. Imagine receiving a message
    from a broker, transforming the content, and then sending this message to a remote
    service. For each message from the broker, this process creates a chain:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们举个例子来说明行为。想象一下从代理接收消息，转换内容，然后将此消息发送到远程服务。对于每个来自代理的消息，此过程都会创建一个链：
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When everything is fine, the framework acknowledges the message `(b)`, which
    acknowledges the message `(a)`. The successful acknowledgment logic of the message
    is executed. However, if interacting with the remote service fails, it calls the
    `nack` method on the message `(b)`, which also calls `nack` on the message `(a)`.
    And so, it executes the negative acknowledgment logic attached to the message
    `(a)`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当一切正常时，框架会确认消息 `(b)`，从而确认消息 `(a)`。消息的成功确认逻辑得以执行。但是，如果与远程服务交互失败，则在消息 `(b)` 上调用
    `nack` 方法，这也会在消息 `(a)` 上调用 `nack` 方法。因此，执行与消息 `(a)` 关联的负面确认逻辑。
- en: In more advanced scenarios, this chain can be too rigid, and you’ll want more
    control. Typically, you may want to decide when to acknowledge a specific message,
    or decide to acknowledge before the processing instead of after. When using `Message`,
    you have full control and can decide to deliberately not chain messages or wait
    for a certain condition to acknowledge. For example, when producing multiple messages
    from a single one, you would acknowledge the message when all the produced messages
    have been acknowledged. Regardless of the use case, when using `Message`, don’t
    forget to call `ack` or `nack`. Alternatively, you can use the `@Acknowledgment`
    annotation to decide where to split the chain in a more declarative manner.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在更高级的场景中，这个链可能太死板，你会希望获得更多控制。通常情况下，你可能希望决定何时承认特定的消息，或者在处理之前而不是之后决定承认。当使用`Message`时，你有完全的控制权，可以决定故意不链接消息或等待某个条件承认。例如，当从单个消息产生多个消息时，你将在所有生成的消息都被确认后才确认该消息。无论使用情况如何，当使用`Message`时，不要忘记调用`ack`或`nack`。或者，你可以使用`@Acknowledgment`注解以更声明性的方式决定在哪里拆分链。
- en: Acknowledgment is essential, and with Reactive Messaging, all messages must
    be either *acked* or *nacked*. It’s vital to implement the elasticity and resilience
    patterns from reactive systems. But how do we connect the applications and message
    brokers? That’s what you are going to see in the next section.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 承认至关重要，而且在响应式消息传递中，所有消息必须被承认或未被承认。从响应式系统实施弹性和恢复模式至关重要。但是我们如何连接应用程序和消息代理？这就是你将在下一节中看到的内容。
- en: Connectors
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接器
- en: '*Connectors* are specific components that map a channel to something managed
    externally, such as a queue or a topic. They are specific to a particular protocol
    or technology. There are two kinds of connectors:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*连接器*是将通道映射到外部受控组件（如队列或主题）的特定组件。它们特定于特定的协议或技术。有两种类型的连接器：'
- en: Inbound connectors
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 入站连接器
- en: These receive messages and feed the channels. They must enforce the Reactive
    Streams backpressure protocol and create messages with the appropriate `ack` and
    `nack` logic.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这些接收消息并将其传送到通道。它们必须执行响应式流背压协议，并创建具有适当的`ack`和`nack`逻辑的消息。
- en: Outbound connectors
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 出站连接器
- en: These receive messages from within the application and send them to external
    destinations. So they map internal messages to the external format and track the
    outcome to call the `ack` or `nack` method on the incoming messages.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这些接收来自应用程序内部的消息并将它们发送到外部目的地。因此，它们将内部消息映射到外部格式，并跟踪结果以在传入消息上调用`ack`或`nack`方法。
- en: Quarkus offers multiple connectors. [Chapter 11](ch11.html#event-bus) covers
    the Kafka and AMQP connectors in detail. The HTTP connector allows binding HTTP
    and WebSockets with your message processing. The Camel connector allows integrating
    legacy systems. In your application configuration, you need to specify a connector
    used for each channel mapped to an external destination.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Quarkus提供了多个连接器。[第11章](ch11.html#event-bus)详细介绍了Kafka和AMQP连接器。HTTP连接器允许将HTTP和WebSockets与消息处理绑定在一起。Camel连接器允许集成遗留系统。在应用程序配置中，你需要指定用于每个映射到外部目的地的通道的连接器。
- en: Building Message-Based Applications
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建基于消息的应用程序
- en: Enough talking; it’s time to see Reactive Messaging in action. This example
    is located in the *chapter-10/hello-messaging* directory. To use Reactive Messaging,
    you need to have a dependency on `quarkus-smallrye-reactive-messaging` in your
    *pom.xml* file; see [Example 10-14](#dependency-reactive-messaging-10-14).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 足够说了；是时候看看响应式消息传递的实际效果了。此示例位于*chapter-10/hello-messaging*目录中。要使用响应式消息传递，你需要在*pom.xml*文件中具有对`quarkus-smallrye-reactive-messaging`的依赖；参见[Example 10-14](#dependency-reactive-messaging-10-14)。
- en: Example 10-14\. Dependency for the Reactive Messaging extension (*chapter-10/hello-messaging/pom.xml*)
  id: totrans-96
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 10-14\. Reactive Messaging扩展的依赖项(*chapter-10/hello-messaging/pom.xml*)
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you will see in the next chapter, you will also need to add dependencies
    for the connectors. However, in this chapter, we won’t use connectors.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你将在下一章中看到的，你还需要为连接器添加依赖项。然而，在本章中，我们不会使用连接器。
- en: A Reactive Messaging application includes beans containing methods annotated
    with `@Incoming` and `@Outgoing`. [Example 10-15](#hellomessage-10-15) contains
    a single bean with three methods.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式消息传递应用程序包含带有`@Incoming`和`@Outgoing`注解的方法的bean。[Example 10-15](#hellomessage-10-15)包含一个具有三个方法的单个bean。
- en: Example 10-15\. Hello messaging application (*chapter-10/hello-messaging/src/main/java/org/acme/HelloMessaging.java*)
  id: totrans-100
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 10-15\. Hello messaging application (*chapter-10/hello-messaging/src/main/java/org/acme/HelloMessaging.java*)
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The methods form a processing pipeline. The first method, `ticks`, generates
    messages on the `ticks` channel. The method returns a `Multi` emitting a number
    every second. This number is wrapped into a simple message automatically. Then,
    the method `hello` consumes these ticks and produces a `String`, sent to the `hello`
    channel. Finally, the `print` method receives these messages and displays them
    on the console. We get the pipeline in Example 10-16.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法形成一个处理管道。第一个方法`ticks`在`ticks`通道上生成消息。该方法返回一个`Multi`，每秒发出一个数字。这个数字被自动包装成一个简单的消息。然后，`hello`方法消费这些ticks并产生一个`String`，发送到`hello`通道。最后，`print`方法接收这些消息并在控制台上显示它们。我们在示例10-16中得到了这个管道。
- en: Example 10-16\. The processing pipeline
  id: totrans-103
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-16\. 处理管道
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If you go into the *chapter-10/hello-messaging* directory and run `mvn quarkus:dev`,
    you will see [Example 10-17](#hello-messages-10-17).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你进入*chapter-10/hello-messaging*目录并运行`mvn quarkus:dev`，你会看到[示例 10-17](#hello-messages-10-17)。
- en: Example 10-17\. Hello messages
  id: totrans-106
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-17\. Hello 消息
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As you can see, building a message-processing pipeline is pretty straightforward.
    Beneath the hood, Reactive Messaging creates a reactive stream and creates the
    acknowledgment chain. That’s what we are going to illustrate in the next section.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，构建消息处理管道非常简单。在幕后，响应式消息创建了一个响应式流并创建了确认链。这将在下一节中进行详细说明。
- en: Message and Acknowledgment
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消息和确认
- en: To better understand the message chain, let’s look at the chapter-10/messages-example
    directory. In this module, we create a specific implementation of `Message` (`MyMessage`),
    which displays on the console when a message is *acked* or *nacked* (Example 10-18).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解消息链，让我们看一下chapter-10/messages-example目录。在这个模块中，我们创建了`Message`的特定实现(`MyMessage`)，当消息被*acked*或*nacked*时在控制台上显示（示例
    10-18）。
- en: Example 10-18\. An implementation of `Message` (*chapter-10/messages-example/src/main/java/org/acme/MyMessage.java*)
  id: totrans-111
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-18\. `Message`的一个实现 (*chapter-10/messages-example/src/main/java/org/acme/MyMessage.java*)
- en: '[PRE18]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The application itself, shown in [Example 10-19](#rm::using-messages), is similar
    to the one from the previous section. We generate a message every second, but
    this time, it’s an instance of `MyMessage` instead of a payload automatically
    wrapped into a message. The `hello` method receives these messages and creates
    a new one with a different payload. The `print` method is unchanged.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序本身，如[示例 10-19](#rm::using-messages)所示，类似于上一节中的一个应用程序。我们每秒生成一条消息，但这次是`MyMessage`的实例，而不是自动包装成消息的有效载荷。`hello`方法接收这些消息并创建一个带有不同有效载荷的新消息。`print`方法保持不变。
- en: Example 10-19\. Usage of messages (*chapter-10/messages-example/src/main/java/org/acme/MessageExample.java*)
  id: totrans-114
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-19\. 消息使用 (*chapter-10/messages-example/src/main/java/org/acme/MessageExample.java*)
- en: '[PRE19]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Look at the `hello` method. It returns a new message built from the receiving
    one. The `with` methods link the two messages to form the chain. When the returned
    message is acknowledged, the received message is also acknowledged.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 查看`hello`方法。它返回从接收到的消息构建的新消息。`with`方法将这两条消息链接起来形成链条。当返回的消息被确认时，接收到的消息也被确认。
- en: 'If you run `mvn quarkus:dev` from the *chapter-10/messages-example* directory,
    you should see this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从*chapter-10/messages-example*目录运行`mvn quarkus:dev`，你应该看到这个：
- en: '[PRE20]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: When the `print` method invocation completes for a specific message, it acknowledges
    this message (created in the `hello` method), which also acknowledges the one
    emitted by the `tick` method. That’s why you can see “Acknowledgment for …” on
    the console.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当`print`方法调用完成特定消息时，它确认这条消息（在`hello`方法中创建），这也确认了由`tick`方法发出的消息。这就是为什么你会在控制台上看到“Acknowledgment
    for…”。
- en: Failures and Negative Acknowledgment
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 失败和负面确认
- en: Message processing may fail, and in this case, we expect the failing message
    to be *nacked*. To illustrate this, let’s update the code to throw an exception
    when it processes the third message, as shown in [Example 10-20](#messaging:auto-nack).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 消息处理可能会失败，在这种情况下，我们期望失败的消息会*nacked*。为了说明这一点，让我们更新代码，当处理第三条消息时抛出异常，如[示例 10-20](#messaging:auto-nack)所示。
- en: Example 10-20\. Throwing an exception acknowledges the message negatively
  id: totrans-122
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-20\. 抛出异常会否定确认消息
- en: '[PRE21]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Restart the application. Now the third message is nacked:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 重新启动应用程序。现在第三条消息被nacked了：
- en: '[PRE22]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Throwing an exception calls the `nack` method on the message and goes up the
    chain to call `nack` on the `MyMessage` instance.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 抛出异常在消息上调用`nack`方法，并沿着链条调用`MyMessage`实例上的`nack`方法。
- en: In this example, our `ack` and `nack` implementations are simplistic. But they
    demonstrate how `ack` and `nack` can notify a message broker about the processing
    outcome.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们的 `ack` 和 `nack` 实现是简单的。但它们展示了 `ack` 和 `nack` 如何通知消息代理有关处理结果。
- en: Stream Manipulation
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 流操作
- en: Manipulating messages one by one is straightforward, but sometimes we need to
    do more complicated processing. To achieve this, Reactive Messaging allows manipulating
    the stream of messages directly. Instead of an individual message or payload,
    the method receives a `Multi` and produces another `Multi` ([Example 10-21](#stream-10-21)).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 逐个操纵消息很简单，但有时我们需要进行更复杂的处理。为了实现这一点，Reactive Messaging 允许直接操纵消息流。方法不再接收单个消息或负载，而是接收
    `Multi` 并产生另一个 `Multi`（见 [示例 10-21](#stream-10-21)）。
- en: Example 10-21\. Stream manipulation with Reactive Messaging (*chapter-10/stream-example/src/main/java/org/acme/StreamingExample.java*)
  id: totrans-130
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-21\. 使用 Reactive Messaging 进行流操作 (*chapter-10/stream-example/src/main/java/org/acme/StreamingExample.java*)
- en: '[PRE23]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You can find the complete code in the *chapter-10/stream-example* directory.
    The method `group` takes the stream of ticks as input and groups the items into
    lists of five elements. The `processGroup` method takes each group and processes
    them:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 *chapter-10/stream-example* 目录中找到完整的代码。`group` 方法接收滴答声流作为输入，并将项目分组成五个元素的列表。`processGroup`
    方法接收每个组并处理它们：
- en: '[PRE24]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Although this example uses just the `group` operator, you can use the whole
    Mutiny API to orchestrate asynchronous calls, skip messages, handle failure recovery,
    or apply complex manipulations.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管此示例仅使用了 `group` 操作符，但你可以使用整个 Mutiny API 来编排异步调用、跳过消息、处理故障恢复或应用复杂的操作。
- en: Blocking Processing
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 阻塞处理
- en: Reactive Messaging implements the reactive principles. It avoids blocking the
    caller thread, but sometimes it’s not possible to do otherwise. Imagine lengthy
    processing or using a blocking API.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Reactive Messaging 实现了反应式原则。它避免阻塞调用者线程，但有时无法做到这一点。想象一下冗长的处理或使用阻塞式 API。
- en: When facing such a situation, you can use the `@Blocking` annotation, which
    automatically switches the processing to a worker thread and then switches back
    to the I/O thread (see [Example 10-22](#annotate-10-22)).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 面对这种情况时，你可以使用 `@Blocking` 注解，它会自动将处理切换到工作线程，然后再切换回 I/O 线程（见 [示例 10-22](#annotate-10-22)）。
- en: Example 10-22\. Annotate methods with `@Blocking` (*chapter-10/blocking-example/src/main/java/org/acme/BlockingExample.java*)
  id: totrans-138
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-22\. 使用 `@Blocking` 注解方法 (*chapter-10/blocking-example/src/main/java/org/acme/BlockingExample.java*)
- en: '[PRE25]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the *blocking-example* directory, you can find a modified version of our
    simple pipeline simulating a long operation in the `hello` method. Using `Thread.sleep`
    is blocking, so it cannot be executed on the I/O thread. Fortunately, thanks to
    the `@Blocking` annotation, that method is invoked on a worker thread. The `@Blocking`
    annotation is particularly interesting when integrating with blocking APIs. However,
    please don’t abuse it, as it reduces the concurrency of your application.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *blocking-example* 目录中，你可以找到我们简单管道的修改版本，模拟在 `hello` 方法中进行长时间操作。使用 `Thread.sleep`
    是阻塞的，所以不能在 I/O 线程上执行。幸运的是，由于 `@Blocking` 注解，该方法在工作线程上被调用。当与阻塞式 API 集成时，`@Blocking`
    注解特别有趣。但请不要滥用它，因为它会降低应用程序的并发性。
- en: Retrying Processing
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重试处理
- en: Intermittent failures happen. Network disruptions or temporary unavailability
    are part of the life of any distributed system.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 偶发性失败是常有的事。网络中断或临时不可用是任何分布式系统生活的一部分。
- en: To handle this case, you can use the Mutiny API and use `onFailure.retry`, but
    you can also use the SmallRye Fault-Tolerance and its `@Retry` annotation. First,
    you need to declare a dependency on Fault-Tolerance, as shown in [Example 10-23](#dependency-10-23).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理这种情况，你可以使用 Mutiny API 并使用 `onFailure.retry`，但也可以使用 SmallRye Fault-Tolerance
    及其 `@Retry` 注解。首先，你需要声明对 Fault-Tolerance 的依赖，如 [示例 10-23](#dependency-10-23) 所示。
- en: Example 10-23\. Dependency for the fault-tolerance support (*chapter-10/fault-tolerance-example/pom.xml*)
  id: totrans-144
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-23\. 容错支持的依赖 (*chapter-10/fault-tolerance-example/pom.xml*)
- en: '[PRE26]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Then, you can use the `@Retry` annotation that automatically catches exceptions
    and retries the invocation. In *chapter-10/fault-tolerance-example*, you can see
    the code in [Example 10-24](#retry-10-24).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以使用 `@Retry` 注解，它会自动捕获异常并重试调用。在 *chapter-10/fault-tolerance-example* 中，你可以在
    [示例 10-24](#retry-10-24) 中看到代码。
- en: Example 10-24\. Retry the processing of messages (*chapter-10/fault-tolerance-example/src/main/java/org/acme/FaultToleranceExample.java*)
  id: totrans-147
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-24\. 重试消息处理 (*chapter-10/fault-tolerance-example/src/main/java/org/acme/FaultToleranceExample.java*)
- en: '[PRE27]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `maybeFaulty` method throws exceptions randomly. So the `@Retry` annotation
    is used to retry the processing of the message, hoping for a better outcome. Remember,
    don’t retry if your processing is not idempotent! It can have terrible consequences.
    It might be better to store the faulty messages on a dead-letter queue (this is
    covered in the next chapter).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`maybeFaulty` 方法会随机抛出异常。因此，使用 `@Retry` 注解重试消息的处理，希望能获得更好的结果。请记住，如果您的处理不是幂等的，请不要重试！这可能会产生可怕的后果。最好将有故障的消息存储在死信队列中（这将在下一章中讨论）。'
- en: Putting Everything Together
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将所有内容整合在一起
- en: The last few sections have demonstrated some features offered by Reactive Messaging.
    These examples are simplistic on purpose. Let’s now work on a more realistic pipeline
    where we receive HTTP requests, manipulate the body, and write it into a database.
    We will use RESTEasy Reactive and Hibernate Reactive, which we have seen in Chapters
    [8](ch08.html#http) and [9](ch09.html#data). While the application could be perfectly
    implemented without Reactive Messaging, we use it to illustrate how to build more
    complex pipelines.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 最近的几节演示了反应式消息传递提供的一些特性。这些示例是故意简化的。现在让我们来处理一个更加现实的流水线，我们将接收 HTTP 请求，操作请求体，并将其写入数据库。我们将使用
    RESTEasy Reactive 和 Hibernate Reactive，这些内容我们在第 [8](ch08.html#http) 和第 [9](ch09.html#data)
    章节已经看到。尽管可以完全不使用反应式消息传递来实现应用程序，但我们使用它来演示如何构建更复杂的流水线。
- en: 'The code of this application is in the *chapter-10/database-example* directory.
    Four classes compose the application. First, the `Person` class is a Hibernate
    Reactive Panache entity. This entity contains two fields: the name (unique) and
    the age. In this application, the user posts `Person` instances (sent as JSON),
    which are sent to the Reactive Messaging pipeline (as illustrated in [Example 10-25](#person-10-25)).'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序的代码位于 *chapter-10/database-example* 目录中。该应用程序由四个类组成。首先是 `Person` 类，它是一个
    Hibernate Reactive Panache 实体。此实体包含两个字段：名称（唯一）和年龄。在此应用程序中，用户以 JSON 形式发布 `Person`
    实例，这些实例将发送到反应式消息传递流水线（如 [示例 10-25](#person-10-25) 所示）。
- en: Example 10-25\. The `Person` structure (*chapter-10/database-example/src/main/java/org/acme/Person.java*)
  id: totrans-153
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-25\. `Person` 结构 (*chapter-10/database-example/src/main/java/org/acme/Person.java*)
- en: '[PRE28]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `HTTPEndpoint` class uses an emitter to send the received `Person` instances
    to the `upload` channel. In addition, this class has two methods. The `upload`
    method receives the `Person` sent by the user and emits it. The `getAll` method
    returns the list of the stored `Person` instances from the database. In [Example 10-26](#http-endpoint-10-26),
    we use this method to verify that everything works as expected. The `upload` method
    returns `Uni<Response>`. It creates the HTTP response asynchronously when the
    emitted message is acknowledged positively (then it returns a `202 - Accepted`
    response), or negatively (then it returns a `400 - Bad Request` response with
    the error message). So, when the processing is successful, the user receives its
    response after the insertion in the database completes.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`HTTPEndpoint` 类使用发射器将接收到的 `Person` 实例发送到 `upload` 通道。此外，此类还有两个方法。`upload`
    方法接收用户发送的 `Person` 并发出它。`getAll` 方法从数据库返回存储的 `Person` 实例列表。在 [示例 10-26](#http-endpoint-10-26)
    中，我们使用此方法来验证一切是否按预期工作。`upload` 方法返回 `Uni<Response>`。在正面确认消息被积极接受后，它异步创建 HTTP 响应（然后返回
    `202 - Accepted` 响应），或者在否定确认消息时（然后返回带有错误消息的 `400 - Bad Request` 响应）。因此，当处理成功时，用户在完成数据库插入后收到其响应。'
- en: Example 10-26\. The HTTP endpoint (*chapter-10/database-example/src/main/java/org/acme/HttpEndpoint.java*)
  id: totrans-156
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-26\. HTTP 端点 (*chapter-10/database-example/src/main/java/org/acme/HttpEndpoint.java*)
- en: '[PRE29]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `Processing` bean receives the uploaded `Person` instances and validates
    and formats the input ([Example 10-27](#process-10-27)).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`Processing` Bean 接收上传的 `Person` 实例，并验证和格式化输入（参见 [示例 10-27](#process-10-27)）。'
- en: Example 10-27\. Process `Person` instances (*chapter-10/database-example/src/main/java/org/acme/Processing.java*)
  id: totrans-159
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-27\. 处理 `Person` 实例 (*chapter-10/database-example/src/main/java/org/acme/Processing.java*)
- en: '[PRE30]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: It forwards the result to the `database` channel. The `Database` class reads
    this channel and writes the received `Person` to the database. To achieve this,
    we use the `withTransaction` and `persist` methods offered by Panache, as shown
    in [Example 10-28](#persist-10-28).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 它将结果转发到 `database` 通道。`Database` 类读取此通道，并将接收到的 `Person` 写入数据库。为实现此目的，我们使用 Panache
    提供的 `withTransaction` 和 `persist` 方法，正如 [示例 10-28](#persist-10-28) 中所示。
- en: Example 10-28\. Persist the entities in the database (*chapter-10/database-example/src/main/java/org/acme/Database.java*)
  id: totrans-162
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-28\. 将实体持久化到数据库 (*chapter-10/database-example/src/main/java/org/acme/Database.java*)
- en: '[PRE31]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This pipeline only passes payloads. So, when the last step completes, it acknowledges
    the message, which, going through the chain of messages, notifies the emitter.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 此流水线仅传递有效负载。因此，当最后一步完成时，它确认消息，这通过消息链通知了发射器。
- en: Run the application with `mvn quarkus:dev` from the *chapter-10/database-example*
    directory. No need to provision a database; Quarkus starts a test database for
    you. Then, in a terminal, send a `Person` instance by using [Example 10-29](#upload-new-10-29).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *chapter-10/database-example* 目录中使用 `mvn quarkus:dev` 运行应用程序。无需准备数据库；Quarkus
    为您启动了一个测试数据库。然后，在终端中，通过使用 [示例 10-29](#upload-new-10-29) 发送一个 `Person` 实例。
- en: Example 10-29\. Upload a new person
  id: totrans-166
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-29\. 上传一个新的人员
- en: '[PRE32]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: You should get a `202 - Accepted` response. If you try to send an invalid payload,
    as shown in [Example 10-30](#upload-invalid-10-30), you will get a `400` response.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该收到`202 - Accepted`的响应。如果尝试发送无效负载，就像 [示例 10-30](#upload-invalid-10-30) 中显示的那样，您将收到`400`的响应。
- en: Example 10-30\. Upload an invalid person
  id: totrans-169
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-30\. 上传一个无效的人员
- en: '[PRE33]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: You can use `curl` to check the stored instances.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`curl`来检查存储的实例。
- en: Summary
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In addition to having a reactive engine and providing asynchronous and nonblocking
    ways to deal with HTTP and databases, Quarkus comes with a message-based model
    called Reactive Messaging.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 除了具有响应式引擎并提供与 HTTP 和数据库交互的异步非阻塞方式外，Quarkus 还提供了基于消息的模型称为响应式消息。
- en: 'Remember:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住：
- en: Reactive Messaging allows receiving, processing, and consuming messages transiting
    on channels.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应式消息允许接收、处理和消耗通过通道传输的消息。
- en: The channel can be internal to the application, as you have seen in this chapter,
    or mapped to external destinations, as you will see in the next chapter.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通道可以是应用程序内部的，正如您在本章中看到的那样，也可以映射到外部目标，正如您将在下一章中看到的那样。
- en: Reactive Messaging supports positive and negative acknowledgment. You can decide
    the amount of control you need.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应式消息支持肯定和否定确认。您可以决定需要的控制量。
- en: Reactive Messaging allows handling messages individually or supports the Mutiny
    API to implement more complex transformations.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应式消息允许单独处理消息，或支持 Mutiny API 来实现更复杂的转换。
- en: In the next chapter, we will look at two connectors that will allow interacting
    with Apache Kafka and AMQP to build reactive systems.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨两个连接器，它们允许与 Apache Kafka 和 AMQP 交互，以构建响应式系统。
- en: ^([1](ch10.html#idm45358821092016-marker)) In this book, we use `MutinyEmitter`,
    but you can use plain `Emitter` instead, providing a slightly different API.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch10.html#idm45358821092016-marker)) 在本书中，我们使用 `MutinyEmitter`，但您可以使用普通的
    `Emitter`，提供略有不同的 API。
- en: ^([2](ch10.html#idm45358820227664-marker)) [You can find the list of supported
    signatures on GitHub](https://oreil.ly/hewBO).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch10.html#idm45358820227664-marker)) [您可以在 GitHub 上找到支持的签名列表](https://oreil.ly/hewBO)。
