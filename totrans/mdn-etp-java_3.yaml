- en: Chapter 3\. Travel Light on Your Pathway
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: He who would travel happily must travel light.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Antoine de Saint-Exupéry
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In the last chapter, you built a microservices-based system, and we also showed
    you some migration steps from an existing application. But the challenge with
    all examples is that they remove complexity for the sake of easier understandability.
    What might seem clear for smaller examples becomes challenging with real business
    systems. In particular, think about complex legacy systems. As outlined in the
    first chapter, technologies and methodologies developed over the years have led
    to today’s best practices and tools to develop modern enterprise systems. Just
    because our industry now has a more extensive toolbox with shiny new things to
    work with doesn’t mean you should always use them. If you think about this and
    our growing number of frameworks, methodologies, and technologies, one question
    becomes more pressing: What tools and architecture should you use for your next
    system, and how and where will you run them? Before you can decide, you need to
    think a bit about the most prominent architectural styles that have emerged for
    enterprise applications in the last couple of years (Three-tier, Enterprise Integration,
    service-oriented architecture, microservices, and event-driven architecture).'
  prefs: []
  type: TYPE_NORMAL
- en: Three-Tier or Distributed System
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Enterprise Java world is dominated by monolithic applications. They often
    are designed as single execution units that scale with server instances and clustering
    functionality. They are also often referred to as “Three-tier systems” to reflect
    the three main parts they are composed of: a client-side user interface, a server-side
    business logic implementation, and server-side data Persistence or Integration
    layer. The server-side parts are called a “monolith” since they are packaged as
    a single large executable. Any changes to the system typically involve building
    and deploying a new version.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Learn more about building microservices in [Sam Newman’s excellent book *Building
    Microservices* (O’Reilly)](https://oreil.ly/JZqsr), now in its second edition.
  prefs: []
  type: TYPE_NORMAL
- en: A microservices-based architecture is an approach to developing a single application
    as a suite of small services, each of them running in its own process and communicating
    with lightweight mechanisms, often an HTTP resource API or as part of an event-driven
    architecture (EDA). These services are built around business capabilities and
    are independently deployable by fully automated deployment machinery. There is
    a bare minimum of centralized management of these services, which may be written
    in different programming languages and use different data storage technologies.
  prefs: []
  type: TYPE_NORMAL
- en: The difference between the monolithic and microservice styles can’t be more
    fundamental. And so are the nonfunctional requirements leading to the choice of
    one. The most critical requirements result from extremely flexible scaling scenarios.
    As an experienced developer and architect, you know how to evaluate functional
    and nonfunctional requirements to conclude your specific project. In this chapter,
    we will help you navigate your migration approach and target platform. Your journey
    starts by looking at the motivation for modernization. Let’s take a deeper look
    at what makes us think about modernization in general and where to start looking
    for opportunities.
  prefs: []
  type: TYPE_NORMAL
- en: Technology Updates, Modernization, and Transformation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Enterprise software is developed to put business value into code that can be
    executed within nonfunctional and functional requirements. Creating value depends
    on our ability to deliver applications quickly. Not only with better quality but
    also ready to be changed quickly, enabling businesses to respond to new challenges
    or regulatory changes in the market. And these challenges are multifaceted. First,
    you address scaling challenges with cloud native applications to handle bigger
    transaction volumes. New business cases will also require you to analyze data
    further and might be solved by artificial intelligence (AI) and machine learning
    (ML). And last but not least, our interconnected world generates more data from
    the Internet of Things (IoT). What might read like it is a natural progression
    of architectures isn’t. In fact, the evolving business requirements drive modernization
    and architectural evolution by changing functional and nonfunctional requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Aditionally, you will find operational concerns influencing modernization needs.
    For example, expiring maintenance contracts or outdated technologies can drive
    technology updates. The continuously evolving Java language with the shortened
    release cycles can also influence modernization decisions. Modernization can happen
    at any level of your project, ranging from the execution environment (e.g., virtual
    machines to container) to the Java Virtual Machine (JVM version or vendor), individual
    dependencies, external interfaces, and services.
  prefs: []
  type: TYPE_NORMAL
- en: It is essential to distinguish between three different angles to modernization
    here. While the *technology updates* within existing processes and boundaries
    are a familiar and well-established challenge for software projects, modernization
    refers to something else. Often paired with the word “digital,” the term *modernization*
    refers to adopting new technology. It involves upgrading systems, platforms, and
    software with new functionality. It can be as simple as taking an existing paper-based
    process and turning it digital using new software and hardware, or more complex,
    such as phasing out existing infrastructure and moving to the cloud. Sometimes
    you’ll also hear *transformation* when someone talks about modern systems. Digital
    transformation means taking advantage of modern technology to reimagine an organization’s
    processes, culture, people, and customer experiences. It can result in new business
    models, revenue streams, policies, and values. Transformation is somewhat of a
    holistic lens into an organization with a clear focus to fundamentally change
    business performance. Modernization is embedded and becomes the centerpiece that
    software developers and architects need to navigate.
  prefs: []
  type: TYPE_NORMAL
- en: Despite your project-specific reasons to take the first step in modernizing
    your application, it is essential to remember that modernization itself does not
    carry any particular mandates for specific target environments or technologies.
    It is an ever-changing and growing set of candidate technologies that enable companies
    to compete and grow in their industry. You can find some of them in technology
    trend reports (e.g., the [ThoughtWorks Technology Radar](https://oreil.ly/SWvEH))
    or on hype cycles ([Gartner Hype Cycle](https://oreil.ly/JT4jE)). But as you’ve
    seen in the first chapter, two of the strongest motivations to constantly innovate
    are speed and cost pressure. Both are addressed by a modern, cloud native, microservices-based
    architecture.
  prefs: []
  type: TYPE_NORMAL
- en: The 6 Rs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you’ve learned the motivation behind application modernization, you
    want to identify general approaches to modernization and define a categorization
    for existing applications. Doing this helps you manage a variety of different
    applications, especially in a platform modernization project. Rather than looking
    at the details of a single application, consider the complete runtime architecture
    of traditional Enterprise Java applications. In that case, you’ll commonly identify
    on-premise hardware, which is usually virtualized and made available to projects
    via an individual set of instances. Given that individual projects are rarely
    treated as islands without any integrated systems, you get to a situation where
    a coordinated approach for more than just one project needs to be found.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s first have a look at what the 6 Rs are and where the concept comes from.
    Essentially, you can think of each “R” as an available migration strategy for
    your applications. Each strategy indicates a clear outcome for a transformed application,
    but not necessarily the actual migration steps to take. The concept was first
    [mentioned by the Gartner analyst Richard Watson](https://oreil.ly/tk08O) in 2011\.
    The five original strategies—namely Rehost, Refactor, Revise, Rebuild, and Replace—were
    revived and adapted in a [popular blog post](https://oreil.ly/CAalp) by Stephen
    Orban of AWS in 2016\. Orban kept some of Gartner’s strategies and added a new
    one. Thus, the 5 Rs became the 6 Rs. Today, the 6 Rs are used as a fundamental
    guideline for almost any cloud transformation. Although there are still disputes
    about whether further strategies should be added, and you can even find 7 Rs,
    we stick to the 6 Rs in this book as shown in [Figure 3-1](#fig3-2).
  prefs: []
  type: TYPE_NORMAL
- en: '![Six ways to classify your existing applications](Images/moej_0301.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-1\. Six modernization approaches, an overview of the 6 Rs
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Retain—Modernize later or not at all
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Everyone has heard the stereotypical story of a mainframe in the basement of
    some very well-known company, where all of its business secrets are stored. Oftentimes,
    these mainframes are programmed in CICS (Customer Information Control System,
    a family of mixed-language application servers that provide online transaction
    management and connectivity for applications on IBM mainframe systems) and the
    data is stored in IMS (IBM Information Management System, an early database).
    And this isn’t necessarily a bad thing. Maybe the existing system is a perfect
    fit for the business and does not need to participate in a modernization project.
    In order to correctly scope your transformation and modernization efforts, you
    need to identify those systems and omit them from the modernization process. Systems
    with this classification need a particular integration approach that needs to
    be explicitly designed. Imagine a highly scalable mobile application backend that
    connects directly to a mainframe. In this scenario, the requests from the potentially
    many mobile devices would overload the costly mainframe. Retain, in this case,
    does not mean “untouched” but rather “not moved.”
  prefs: []
  type: TYPE_NORMAL
- en: Retire—Turn system off
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some candidates may clearly have reached end-of-life and are already migrated
    and replaced or just a relic that isn’t needed going forward. Travel light and
    make sure to flag these systems. Subsequent housekeeping is as equally essential
    as building new things. Investing time to validate and decide on retiring a system
    is as valuable as a redesign would be.
  prefs: []
  type: TYPE_NORMAL
- en: Repurchase—Buy new version
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In some cases, you can repurchase off-the-shelf software and get it ready made
    for a new execution environment. That sounds straightforward but will most likely
    include a migration project and reevaluation of feature lists, mostly because
    it is unlikely that you can update without changing the product version or its
    APIs. In some rare cases, you might even find missing integration documentation
    to be a blocker. This is why it is essential to treat this as a modernization
    project and not as a simple software update.
  prefs: []
  type: TYPE_NORMAL
- en: Rehost—Put into containers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Often referred to as “lift and shift,” one option for containerizing an application
    is to simply port the existing architecture as-is to run inside of a container.
    While this can be as simple as it sounds, there are some challenges on the way.
    In particular, there can be difficulties when it comes to optimizing the JVM for
    constrained container runtimes. Some existing middleware application servers come
    with their vendor-supported base images and make it convenient to switch runtimes.
    Particular focus should be placed on storage for stateful application runtimes.
    Java application servers require some data to survive container restarts and require
    persistent volume mappings. Transactions, load balancing, and in-memory session
    replication need extended configurations to ensure correct shutdown behavior and
    node communication. Plan for sufficient research and testing and make sure to
    adhere to the vendor recommendations. This step is addressing infrastructure modernization
    and not concerned with application code directly. Existing applications that qualify
    for such an approach are those that need to move to a container runtime before
    a refactoring can occur or as an interim step toward switching data center concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Martin Fowler coined the term [“strangler pattern”](https://oreil.ly/0otPb)
    as a way to extract functionality out of a monolithic application. It is named
    after the Australian strangler figs that grow roots from seeds in the upper branches
    until they touch the ground.
  prefs: []
  type: TYPE_NORMAL
- en: Replatform—Make some slight adjustments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As an extension to rehosting, replatforming categorizes applications that undergo
    a conceptual or functional change while switching runtimes. It can also be referred
    to by its own “lift” name variation, “lift and adjust.” It can be related to a
    strangled functionality, which might be implemented on top of a new technology
    stack or a change in data storage or integration systems. We recommend using this
    approach as an initial step toward refactoring and decoupling a monolithic application.
    Prepending this step leads to smoother operations executing on subsequent extensions
    and decoupling stages. By choosing to replatform, you are allowing a gentle start
    to modernizing your applications and pragmatically evolving them.
  prefs: []
  type: TYPE_NORMAL
- en: Refactor—Build new
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Refactoring](https://refactoring.com) is a disciplined technique for restructuring
    an existing body of code, altering its internal structure without changing its
    external behavior. Refactoring is the most time-consuming and costly way to move
    existing applications onto a new runtime or platform. It may or may not include
    a switch to different architecture styles or on-premise or cloud hosting.'
  prefs: []
  type: TYPE_NORMAL
- en: Divide and Containerize
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have looked at different modernization strategies for existing applications,
    and we know how and when to apply them. It is time to think about other prerequisites
    for our target platform.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes as the New Application Server?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The word “platform” in the Enterprise Java world normally refers to the application
    server. Application servers follow a guardrailed software development approach
    with standardized APIs. The vertical layers are defined by what is commonly refered
    to as technical layers of a three-tier system. Presentation on top of business
    on top of data access and/or integration. Horizontally to this we usually find
    business components or domains. While the vertical layers are usually well separated
    and decoupled, it is common to find shared classess and violated access rules
    between the horizontal components. If this happens frequently across the code
    base, we talk about entangled designs that turn into unmaintainable monoliths
    over time. But no matter how entangled the application code is, it still profits
    from the standard application server functionalities addressing nonfunctional
    and functional requirements like security, isolation, fault tolerance, transaction
    management, configuration management, etc.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we fast-forward to distributed architectures of today, where applications
    consist of many small services, we observe two things: there is no longer a shortcut
    to a good component design, and the standard application server features are no
    longer available to our components.'
  prefs: []
  type: TYPE_NORMAL
- en: The first observation leads to a mandatory requirement. Distributed services
    have to be well designed, loosely coupled, and strongly encapsulated components.
    We will talk more about design principles and approaches for modernizing monoliths
    in [Chapter 5](ch05.xhtml#beyond_lift_and_shift). The second observation holds
    a list of missing funcionalities in cloud native runtimes. If an application server
    isn’t providing support for commonly used functionalities like we mentioned, there
    are only two places left. One can be the microservices framework of choice (e.g.,
    Quarkus), and another one could be additional frameworks or products on top of
    Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a detailed look at some of the most critical functionalities needed
    in the following chapters. We call them *microservicilities*. The term refers
    to a list of cross-cutting concerns that a service must implement apart from the
    business logic to resolve these concerns as summarized in [Figure 3-2](#fig3-3).
  prefs: []
  type: TYPE_NORMAL
- en: '![Microservicilities for distributed applications](Images/moej_0302.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-2\. Microservicilities for distributed applications
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Discovery and configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Container images are immutable. Storing configuration options inside them for
    different environments or stages is discouraged. Instead, the configuration has
    to be externalized and configured by instance. An externalized configuration is
    also one of the critical principles of cloud native applications. Service discovery
    is one way to get configuration information from the runtime environment instead
    of being hardcoded in the application. Other approaches include using ConfigMaps
    and Secrets. Kubernetes provides service discovery out of the box, but this might
    not be sufficient for your application needs. While you can manage the environment
    settings for each runtime environment through YAML files, additional UIs or CLIs
    can make it easier for DevOps teams to share responsibility.
  prefs: []
  type: TYPE_NORMAL
- en: Basic invocation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Applications running inside containers are accessed through Ingress controllers.
    Ingress exposes HTTP and HTTPS routes from outside the cluster to services within
    the cluster. Traffic routing is controlled by rules defined on the Ingress resource.
    Traditionally, this can be compared with Apache HTTP-based load balancers. Other
    alternatives include projects like [HAProxy](http://www.haproxy.org) or Nginx.
    You can use the routing capabilities to do rolling deployments as the basis for
    a sophisticated CI/CD strategy. For one-time jobs, such as batch processes, Kubernetes
    provides job and cron-job functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Elasticity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Kubernetes’s ReplicaSets control scaling of pods. It is a way to reconcile
    a desired state: you tell Kubernetes what state the system should be in so it
    can figure out how to reach the outcome. A ReplicaSet controls the number of replicas,
    or exact copies, of a container that should be running at any time. What sounds
    like a largely static operation can be automated. The Horizontal Pod Autoscaler
    scales the number of pods based on observed CPU utilization. It is possible to
    use a custom metric or almost any other application-provided metric as input.'
  prefs: []
  type: TYPE_NORMAL
- en: Logging
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the more challenging aspects of a distributed application is the correlation
    of logs from each active part. This is an area where the difference from traditional
    application servers becomes very visible because it used to be so simple and isn’t
    in the new world. Storing them individually, per container, is not recommended
    because you lose sight of the bigger picture and have a hard time debugging side
    effects and root causes for issues. There are various approaches to this, with
    most of them extensively using the [ELK](https://oreil.ly/XflXI) ([Elasticsearch](https://oreil.ly/FKoKx),
    [Logstash](https://oreil.ly/YLtNc), [Kibana](https://oreil.ly/h2nIX)) stack or
    a variant. In those stacks, Elasticsearch is the object store, where all logs
    are stored. Logstash gathers logs from nodes and feeds them to Elasticsearch.
    Kibana is the web UI for Elasticsearch, which is used to search the aggregated
    log files from various sources.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Monitoring in a distributed application is an essential ingredient to make sure
    all of the bits and pieces continue working. In contrast to logging, monitoring
    is an active observation often paired with alerting rather than simply recording
    events. [Prometheus](https://prometheus.io) is the de facto standard for storing
    the generated information. Essentially, it is a complete open source monitoring
    system that includes a time-series database. Prometheus’s web UI gives you access
    to metric querying, alerting, and visualizations and helps you gain insights into
    your systems.
  prefs: []
  type: TYPE_NORMAL
- en: Build and deployment pipelines
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: CI/CD (Continuous Integration/Continuous Delivery) isn’t anything new to Enterprise
    Java applications or distributed applications. As a good software development
    practice, every production code should follow a strict and automated release cycle.
    With a potentially large number of services that compose an application, the automation
    should at least aim for 100% coverage. Traditionally a job for the open source
    tool [Jenkins](https://www.jenkins.io), modern container platforms have moved
    away from a centralized build system and embrace a distributed approach to CI/CD.
    One example is [Tekton](https://tekton.dev). The goal is to create reliable software
    releases through build, test, and deployment. We dig deeper into this in [Chapter 4](ch04.xhtml#kubernetes_based_softw_dev_platform).
  prefs: []
  type: TYPE_NORMAL
- en: Resilience and fault tolerance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Psychologists define “resilience” as the process of adapting well in the face
    of adversity, trauma, tragedy, threats, or significant sources of stress. In distributed
    applications, it is the concept of recovering from failure or load scenarios without
    human interaction. Kubernetes provides resilience options for the cluster itself,
    but only sparsely supports application resiliency and fault tolerance. For example,
    application-level resiliency can be facilitated through PersistentVolumes that
    support replicated volumes or with ReplicaSets ensuring a consistent number of
    pod replicas across the cluster. On an application level, there is resilience
    and fault-tolerance support through Istio or various frameworks like [Cloudstate](https://cloudstate.io).
    You want to use features such as retry rules, circuit breaker, and pool ejection.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '[Istio](https://istio.io) is an open source service mesh that layers transparently
    onto existing distributed applications. It is also a platform, including APIs
    that integrate into any logging platform, telemetry, or policy system.'
  prefs: []
  type: TYPE_NORMAL
- en: Security
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Authentication or Authorization between services is not part of Kubernetes itself.
    There are two ways to implement it. Using Istio, each service is provided with
    a strong identity that represents its role and enables interoperability across
    clusters and clouds. It secures service-to-service communication, as well as providing
    a key management to automate key and certificate generation, distribution, rotation,
    and revocation. A more application-centric alternative can be to use a single-sign-on
    component like [Keycloak](https://www.keycloak.org) or relying on [Eclipse MicroProfile
    JSON Web Token](https://oreil.ly/bVETR) (JWT).
  prefs: []
  type: TYPE_NORMAL
- en: Tracing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Tracing gives you a way to follow request paths and events throughout the system
    across individual application parts by still allowing you to trace back to an
    origin. You can find different approaches across the community today. Independent
    of languages, frameworks, or technologies you intend to use, Istio can enable
    distributed tracing. There are other commercial and open source projects available
    helping with distributed tracing across your application components. [Zipkin](https://zipkin.io)
    and [Jaeger](https://www.jaegertracing.io) are two possible solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Define Your Target Platform
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It’s important to note that the nine elements mentioned previously are focused
    on application development and do not capture all the necessities of a modern
    container platform. Just looking at this narrow focus leaves important areas unaddressed.
    A container platform needs to provide features and capabilities for the complete
    team from Dev to Ops. Depending on specific needs, there is no one-size-fits-all
    solution. A comprehensive way to define your target platform is to start with
    the three main layers: Core, Customer Experience, and Integration, then build
    your application landscape on an optimized technology stack. What sounds like
    a ready-to-use checklist is anything but. Companies are different in culture,
    technologies, and requirements, and the following lists are a recommended starting
    point without any claim to comprehensiveness. We recommend using the bullet points
    as evaluation categories and defining the individual functional and nonfunctional
    requirements underneath with a fulfillment score from zero (not available) to
    three (fully supported) with a middle score of two (can make it work) as a medium
    evaluation. Finally, add weighting logic to it to reach a complete evaluation
    based on a product comparison. It can be the core framework for a direct product
    versus do-it-yourself (DIY) comparison and also the starting point for the platform
    documentation.'
  prefs: []
  type: TYPE_NORMAL
- en: Define the core
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Start with evaluating the core part of the platform. This category includes
    basic capabilities like container orchestration, storage mapping, rolling upgrades,
    site reliability engineering (SRE) requirements, out-of-the-box support for the
    desired deployment models, and might even include further support for virtual
    machines. This category represents the technical foundation for your target platform:'
  prefs: []
  type: TYPE_NORMAL
- en: Existing core capabilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional gap assessment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hybrid-cloud support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security integration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managed services support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operators/marketplace available (e.g., [OperatorHub](https://operatorhub.io),
    [Red Hat Marketplace](https://oreil.ly/sFuDg))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Available support levels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Target deployment model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Core modernization approach
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define the customer experience layer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When thinking about platforms, one part gets too little attention: the customer
    experience layer, which contains a technical definition for the customer channels
    to the platform. A channel can be one of the B2X (business to something) portals
    or various other specific frontends. A cohesive platform that can host various
    applications also needs to include a clear definition for the technical composition
    of the individual services:'
  prefs: []
  type: TYPE_NORMAL
- en: Define customer-centric requirements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assess existing cx framework versus build
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Micro frontends (e.g., [Entando](https://dev.entando.org))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration requirements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data gap analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mobile support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define the integration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In a containerized world, integration becomes a new challenge. Coming from
    a traditional enterprise landscape, it has either been a centralized solution
    (Enterprise Service Bus or similar) or been part of the individual applications
    using some common integration framework like Apache Camel. Neither approach fits
    perfectly into a stateless container-oriented platform. What you are looking for
    in a target platform is the smooth integration between messaging components, data
    transformation logic, and service integration. All the relevant parts need to
    scale well in a stateless environment for distributed systems, and it should be
    easy to extend a composed application with new capabilities:'
  prefs: []
  type: TYPE_NORMAL
- en: Existing integration capabilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Evaluate partner solution ecosystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define integration requirements (data sources, service integration, messaging,
    APIs)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define standards and frameworks (e.g., [Camel K](https://oreil.ly/kfXw1))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Evaluate serverless/knative integration (e.g., Camel K)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define the technology stack
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The remaining category focuses on individual technologies and frameworks. Think
    of it as a blueprint repository defining the relevant technologies, services,
    and methodologies for a productive environment. An underestimated influence on
    the requirements in this category is the available development skill in an organization.
    With a traditional Enterprise Java background, it is not easy to completely switch
    to a reactive development approach and a stateless application design. Also, familiarity
    with existing APIs and time to productivity on a new platform play a crucial role
    in picking the most suitable technology stack:'
  prefs: []
  type: TYPE_NORMAL
- en: Technology stack assessment across core, CX, and external services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microservices framework (e.g, Quarkus, Spring Boot)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementation recommendation (reactive, imperative, message-driven, etc.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deployment model (IaaS, PaaS, hybrid)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define target development platform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Development skills gap analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After completing this assessment, you are well prepared for a journey to a containerized
    application platform. Next, you will need to map out and plan your containerization
    strategy.
  prefs: []
  type: TYPE_NORMAL
- en: Mandatory Migration Steps and Tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Following the basic assumption that you have an existing application landscape
    in place and cannot start everything as a green-field project, we emphasize moving
    existing applications into containers. Coming back to the 6 Rs from earlier, the
    first application you are taking a look at should fall into one of the following
    Rs: Rehost, Replatform, and Refactor ([Figure 3-3](#fig1-3)). While they look
    similar in their description, the most significant difference between the three
    approaches is business value versus migration time and cost.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Business value assesment](Images/moej_0303.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-3\. Workload migration pattern
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Which action to take and where to start modernizing depends on the application.
    While the concrete steps may vary, the first thing to identify is the correct
    candidates. Therefore, we need to analyze the existing applications, catalog them,
    and group them to assign them to the final migration pattern. The last step is
    to execute the individual migration projects.
  prefs: []
  type: TYPE_NORMAL
- en: Create an Application Portfolio
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many ways to create such an application catalog or portfolio. And
    you most likely already have a way to select applications relevant for a certain
    business domain. If not, feel free to fast-forward to [Chapter 5](ch05.xhtml#beyond_lift_and_shift),
    where we talk about the [Konveyor project](https://oreil.ly/1wPUF).
  prefs: []
  type: TYPE_NORMAL
- en: Prepare for Big Things
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most prestigious process in modernization is refactoring existing applications.
    For coverage of a proven method of transitioning an existing monolithic system
    to a microservice architecture, we recommend [*Monolith to Microservices*](https://oreil.ly/0x6oq)
    by Sam Newman (O’Reilly). While he walks you through a lot of different approaches
    and creates a detailed process for various situations, there are also simpler
    approaches, such as the one outlined by Brent Frye from the Software Engineering
    Institute at Carnegie Mellon University. His [approach to modularization](https://oreil.ly/YKYUY)
    of existing applications is a lot more generic. He recommends eight simple steps
    to break down the monolith. He focuses on components and component groups. *Components*
    are logical sets of data objects and the actions that the system performs on those
    objects. Component groups become what he calls *macroservices*. A macroservice
    is similar to a microservice with two primary differences. First, a macroservice
    may share the datastore with the legacy monolithic system or other macroservices.
    Second, unlike a microservice, a macroservice may provide access to multiple data
    objects. In the last step, the macroservices are decomposed further.
  prefs: []
  type: TYPE_NORMAL
- en: 'The logical steps to breaking down your monolith according to Frye are:'
  prefs: []
  type: TYPE_NORMAL
- en: Identify logical components.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Flatten and refactor components.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Identify component dependencies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Identify component groups.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an API for a remote user interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Migrate component groups to macroservices:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move component groups to separate projects.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Make separate deployments.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Migrate macroservices to microservices.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat steps 6–7 until complete.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is also the more general recommendation from Chris Richardson. As he outlined
    in his [O’Reilly SACON London keynote](https://oreil.ly/CZn61) and many times
    after, he is looking for an incremental approach starting with the most promising
    functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Do it incrementally and repeat the extraction steps until the monolith is finally
    eliminated or the initial software delivery problems are solved as illustrated
    in [Figure 3-4](#fig3-4).
  prefs: []
  type: TYPE_NORMAL
- en: '![Move functionality as long as necessary.](Images/moej_0304.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-4\. Moving monoliths to services over time by incrementally extracting
    them
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The three approaches differ in depth, angle, and details. While Richardson
    talks about the most valuable functionality and focuses on extracting it first,
    Frye created a simple methodology that can be applied in all situations. Finally,
    Newman developed the most detailed handbook for various situations in a modernization
    journey. All three will be helpful on your personal journey. We are convinced,
    though, that the approach Richardson takes is the best starting point. What Thomas
    Huijskens said for data scientists is something we also strongly believe in: “The
    code you write is only useful if it is production code.”'
  prefs: []
  type: TYPE_NORMAL
- en: Every modernization effort has to follow business requirements and support production
    functionality. Following this thought, the entire modernization project can only
    be successful if you identify the correct candidates.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter walked you through some basic definitions for migration strategies
    and showed you an evaluation path for the target development platform. We’ve looked
    at technical recommendations, and you now know how to assess existing applications
    for rehosting, replatforming, and refactoring.
  prefs: []
  type: TYPE_NORMAL
