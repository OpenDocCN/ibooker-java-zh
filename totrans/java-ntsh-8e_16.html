<html><head></head><body>
<div id="sbo-rt-content"><section data-pdf-bookmark="Appendix. Beyond Java 17" data-type="appendix" epub:type="appendix"><div class="appendix" id="javanut8-APP-A">
<h1><span class="label">Appendix. </span>Beyond Java 17</h1>
<p><a data-primary="Java 17" data-secondary="versions beyond" data-type="indexterm" id="ix_appendixA-asciidoc0"/>This appendix discusses versions of Java beyond Java 17.
In previous editions of <em>Java in a Nutshell</em>, we have resisted adding forward-looking material, but recent changes in the Java release model (which we discussed in <a data-type="xref" href="ch01.xhtml#javanut8-CHP-1">Chapter 1</a>), as well as ongoing and forthcoming Java developments, have prompted a change of tack in this new edition.</p>
<p><a data-primary="long-term support (LTS) releases" data-type="indexterm" id="idm45927697246672"/><a data-primary="LTS (long-term support) releases" data-type="indexterm" id="idm45927697246000"/><a data-primary="Oracle Corporation" data-secondary="LTS releases" data-type="indexterm" id="idm45927697245360"/>In the current model, a new version of Java is released every six months, but only certain releases are LTS.
As it stands, Java 11 and 17 are regarded as LTS (with 8 retrospectively added).
Note that LTS has a dual meaning: for Oracle customers it means that paid support is available for a multiyear period, while other JDK providers (including Red Hat, Microsoft, Amazon, etc.) have de facto adopted the same versions as those for which backported security and other fixes will be made publicly available—free of charge—as certified OpenJDK binaries.</p>
<p>The industry, as a whole, has not chosen to adopt a six-month Java upgrade cycle for various reasons, and so in practice, the LTS versions are the only ones that are likely to be deployed into production.
However, most of the OpenJDK providers do diligently publish binaries for all Java releases, even those that will not be supported beyond the six-month window.</p>
<p>This creates a dichotomy: new features arrive every six months but are not widely deployed by teams until the next LTS, which complicates writing about specific Java versions.
This is further complicated by the concept of <em>Incubating</em> and <em>Preview</em> features, which are used to experiment with new APIs and new language features, respectively, before they are finalized and become a standard part of the language.</p>
<p>The solution we have chosen is to target new editions of this book at LTS versions and include an appendix that covers any new features that have arrived (or are expected to arrive) since the last LTS.
We have also chosen to cover only final features in the main part of the book; all discussion of Incubating and Preview features will be confined to appendices.</p>
<p>Let’s start by covering how major development efforts are arranged within OpenJDK, then discuss Java 18 and 19, and then conclude with a look at the future beyond that release.</p>
<section data-pdf-bookmark="Long-Term JDK Projects" data-type="sect1"><div class="sect1" id="javanut8-APP-A-SECT-1">
<h1>Long-Term JDK Projects</h1>
<p><a data-primary="JDK (Java Development Kit)" data-secondary="long-term projects" data-type="indexterm" id="ix_appendixA-asciidoc1"/>OpenJDK is organized into projects that cover specific major areas of ongoing work.
This includes projects that are centered on the development of future language or JVM features that can take multiyear efforts to deliver.</p>
<p>Four projects currently focus on the delivery of major future aspects of Java.
They are usually known by their project codenames:</p>
<ul>
<li>
<p>Panama</p>
</li>
<li>
<p>Loom</p>
</li>
<li>
<p>Valhalla</p>
</li>
<li>
<p>Amber</p>
</li>
</ul>
<p>Of these, Project Panama provides two major improvements: a modern foreign-function interface for Java and support for vector CPU instructions.</p>
<p>It has been incubating for some time now, but Java 18 contains an interesting milestone iteration of the functionality, and so we will cover the project in the Java 18 section.</p>
<p><a data-primary="Loom" data-type="indexterm" id="idm45927697232880"/><a data-primary="Project Loom" data-type="indexterm" id="idm45927697232176"/>Project Loom is a new concurrency model for Java.
A first preview of some of Loom’s functionality will be available for the first time in Java 19, so we will discuss Loom in that section.</p>
<p><a data-primary="Project Valhalla" data-type="indexterm" id="idm45927697231120"/><a data-primary="Valhalla" data-type="indexterm" id="idm45927697230416"/>Project Valhalla is the most ambitious, wide-ranging, and highest-impact of all of the projects.
It is also the most complex and the farthest from delivery as a shipping product.
We discuss it toward the end of the appendix.</p>
<p>Project Amber’s remit is incremental language improvements.
It is probably the most familiar and easiest-to-understand of the four projects, so we’ll discuss it here as our next topic.</p>
<section data-pdf-bookmark="Amber" data-type="sect2"><div class="sect2" id="javanut8-APP-A-SECT-1.1">
<h2>Amber</h2>
<p><a data-primary="Amber" data-type="indexterm" id="idm45927697227280"/><a data-primary="Project Amber" data-type="indexterm" id="idm45927697226576"/>Amber has been running since Java 9 was delivered.
It aims to deliver small chunks of useful language functionality, an approach that fits well with the new delivery schedule for Java releases.
The features that have formed part of Amber and delivered so far include:</p>
<ul>
<li>
<p>Local Variable Type Inference (<code>var</code>)</p>
</li>
<li>
<p>Switch Expressions</p>
</li>
<li>
<p>Enhanced <code>instanceof</code></p>
</li>
<li>
<p>Text Blocks</p>
</li>
<li>
<p>Records</p>
</li>
<li>
<p>Sealed Types</p>
</li>
<li>
<p>Pattern Matching</p>
</li>
</ul>
<p>Most of these features have already been completed, but the last of these, Pattern Matching, has not been fully delivered as of Java 17.
Only the simplest case, the <code>instanceof</code> pattern, has arrived as a final feature so far.
Java 17 does have a Preview version of a more advanced form (as we mentioned in <a data-type="xref" href="ch05.xhtml#javanut8-CHP-5">Chapter 5</a>) that can be used as part of a switch expression, like this:</p>
<pre data-type="programlisting">sealed interface Pet permits Cat, Dog {}
record Cat(String name) implements Pet {}
record Dog(String name) implements Pet {}

boolean isDog(Pet p) {
    return switch (p) {
        case Cat c -&gt; false;
        case Dog d -&gt; true;
    };
}</pre>
<p>Note the lack of need for a <code>default</code> case. All <code>Pet</code> objects are either a <code>Cat</code> or a <code>Dog</code>, because the <code>Pet</code> interface is declared as sealed.</p>
<p>Pattern matching will truly come into its full power when further future cases arrive and are standardized as final features.
In particular, the combination of pattern matching and <em>algebraic data types</em> (one of the names given to the combination of records and sealed types) is especially powerful.</p>
<p>We can see how Amber’s approach fits with the model of biannual releases of Java; switch expressions and enhanced <code>instanceof</code> are extended and combined into the basics of pattern matching, which is then further enhanced by algebraic data types and further cases of patterns tailored to them.<a data-startref="ix_appendixA-asciidoc1" data-type="indexterm" id="idm45927697211216"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Java 18" data-type="sect1"><div class="sect1" id="javanut8-APP-A-SECT-2">
<h1>Java 18</h1>
<p><a data-primary="Java 18" data-type="indexterm" id="idm45927697208800"/><a data-primary="Java Enhancement Proposals (JEPs)" data-type="indexterm" id="idm45927697208096"/><a data-primary="JEPs (Java Enhancement Proposals)" data-type="indexterm" id="idm45927697207456"/>New Java releases are made up of Java Enhancement Proposals (JEPs): a complete list of current, past, and future JEPs can be found at <a class="bare" href="https://oreil.ly/BE1r1"><em class="hyperlink">https://oreil.ly/BE1r1</em></a>.</p>
<p>Java 18 was released in March 2022 and includes the following JEPs:</p>
<ul>
<li>
<p>400: UTF-8 by Default</p>
</li>
<li>
<p>408: Simple Web Server</p>
</li>
<li>
<p>413: Code Snippets in Java API Documentation</p>
</li>
<li>
<p>416: Reimplement Core Reflection with Method Handles</p>
</li>
<li>
<p>417: Vector API (Third Incubator)</p>
</li>
<li>
<p>418: Internet-Address Resolution SPI</p>
</li>
<li>
<p>419: Foreign Function &amp; Memory API (Second Incubator)</p>
</li>
<li>
<p>420: Pattern Matching for switch (Second Preview)</p>
</li>
</ul>
<p>Most of these are very minor or internal implementation changes.
The two JEPs related to Panama (417 and 419) are significant steps forward for the project, which we’ll discuss in detail here.</p>
<section data-pdf-bookmark="Panama" data-type="sect2"><div class="sect2" id="javanut8-APP-A-SECT-2.1">
<h2>Panama</h2>
<p><a data-primary="Panama" data-type="indexterm" id="idm45927697194912"/><a data-primary="Project Panama" data-type="indexterm" id="idm45927697194208"/>Project Panama aims to provide a modern Foreign (i.e., non-Java) interface for connecting to native code.
The codename comes from the isthmus of Panama, a narrow strip connecting two larger “landmasses,” understood to be the JVM and native memory (aka “off-heap”).</p>
<p><a data-primary="Java Native Interface (JNI)" data-type="indexterm" id="idm45927697193152"/><a data-primary="JNI (Java Native Interface)" data-type="indexterm" id="idm45927697192480"/>The overall aim is to replace Java Native Interface (JNI), which is well-known to have major problems such as an excess of ceremony, extra artifacts, and a lack of interoperability with libraries written in anything other than C / C++.
In fact, even for the C case, JNI does not do anything automatic to map type systems and the portions of Java and C code have to be mapped semimanually.</p>
<p>Panama provides two main components to assist in the interoperation of Java and native code:</p>
<ul>
<li>
<p>Foreign Memory and Functions API</p>
</li>
<li>
<p>Vector API</p>
</li>
</ul>
<p><a data-primary="Foreign Memory API" data-type="indexterm" id="idm45927697188720"/>The Foreign Memory API is concerned with the allocation, manipulation, and freeing of structured foreign memory, and the lifecycle management of foreign resources.
This goes beyond the existing capabilities of the <code>ByteBuffer</code> class, and for example can address more than 2 GB of memory as a single segment.
The issue of how foreign memory is managed is complex, as it is outside the scope of the JVM’s garbage collector, and existing mechanisms such as finalization are known to be fatally flawed.</p>
<p>Calling foreign functions is also possible using Panama.
<a data-primary="jextract tool" data-type="indexterm" id="idm45927697187088"/>A new command-line tool, called <code>jextract</code>, creates a Java bridge from a C header file.
This bridge is built using method and var handles to provide a set of (static) Java methods that look as close as possible to the original C API.</p>
<p>The runtime support for this is contained in the module <code>jdk.incubator.foreign</code>, which is, unsurprisingly, an Incubating API and may well change in future versions before it ships as final.
As it stands, C and C++ are the initially supported foreign languages, but other possibilities (notably Rust) are expected to be added as the project develops.</p>
<p>In addition to the Foreign API, Panama also provides support for vector computations by shipping an API that has these main goals:</p>
<ul>
<li>
<p>Clear and concise API</p>
</li>
<li>
<p>Platform agnostic</p>
</li>
<li>
<p>Reliable JIT compilation and performance</p>
</li>
<li>
<p>Graceful degradation of vector mode back to linear instructions</p>
</li>
</ul>
<p>Panama is initially shipping an implementation for the x64 and AArch64 CPU architectures.
However, as expressed in the goals, the API does not—and must not—rule out possible implementations for other CPUs.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="Java 19" data-type="sect1"><div class="sect1" id="javanut8-APP-A-SECT-3">
<h1>Java 19</h1>
<p><a data-primary="Java 19" data-type="indexterm" id="idm45927697178624"/>Java 19 was released in September 2022 and includes a preview of a new major feature (Loom) as well as the following selection of JEPs:</p>
<ul>
<li>
<p>405:  Record Patterns (Preview)</p>
</li>
<li>
<p>422:  Linux/RISC-V Port</p>
</li>
<li>
<p>424:  Foreign Function and Memory API (Preview)</p>
</li>
<li>
<p>426:  Vector API (Fourth Incubator)</p>
</li>
<li>
<p>427:  Pattern Matching for switch (Third Preview)</p>
</li>
</ul>
<p>These JEPs are mostly continuations of the development of existing preview and incubating features, so rather than spend more time on them, we’ll focus on:</p>
<ul>
<li>
<p>425:  Virtual Threads (Preview)</p>
</li>
<li>
<p>428:  Structured Concurrency (Incubator)</p>
</li>
</ul>
<p>These two JEPs provide the basis of the first preview delivery of Project Loom.</p>
<section data-pdf-bookmark="Loom" data-type="sect2"><div class="sect2" id="javanut8-APP-A-SECT-3.1">
<h2>Loom</h2>
<p><a data-primary="Loom" data-type="indexterm" id="idm45927697167728"/><a data-primary="Project Loom" data-type="indexterm" id="idm45927697167024"/><a data-primary="threads" data-secondary="Project Loom and" data-type="indexterm" id="idm45927697166352"/>In Java 17, every executing Java language thread is an OS thread because calling <code>Thread.start()</code> triggers a system call that creates an OS thread.
This therefore creates a constraint between the number of available Java execution contexts and the limits of the operating system.
As programming languages have evolved, this constraint has become more problematic.
The OS has data structures (e.g., stack) that it creates for each thread, and it individually schedules execution of each thread.</p>
<p>This naturally leads to the question: how many OS threads can an application start? 1,000? Perhaps 10,000?
Regardless of the exact number, there is definitely a hard limit in this approach.
Project Loom is a reimagining of Java’s concurrency model that is designed to transcend this limitation.</p>
<p><a data-primary="virtual threads" data-type="indexterm" id="idm45927697164096"/>The key is <em>virtual threads</em>, a new construct that is not 1-1 with OS threads.
From a Java programming perspective, virtual threads look like instances of <code>Thread</code>, but they are managed by the JVM, not the OS.
This means that no OS-level data structures (e.g., for the thread’s stack frames) are created, and all the management metadata is handled by the JVM.
This includes the scheduling behavior; rather than the OS scheduler, a Java execution scheduler (a threadpool) is used.</p>
<p><a data-primary="carrier threads" data-type="indexterm" id="idm45927697162144"/>When a virtual thread wants to execute, it does so on an OS <em>carrier thread</em> and runs until a blocking call (e.g., I/O) is made.
The carrier thread is <em>yielded</em> to another virtual thread, and so a virtual thread may execute on several different carriers over its lifetime.
The connection to blocking calls means that virtual threads are not suitable for pure CPU-bound tasks, and in general, the use of Loom is very different from approaches such as <code>async</code> / <code>await</code> that developers may have used in other languages.</p>
<p>It remains to be seen how much Loom will impact end-user devs, although there is a lot of interest from framework and library authors.
An initial version is arriving as a preview in JDK 19, but it is still unclear when it’ll arrive as a standard feature.
Overall, the expectation in the community is that it will be finalized in the next LTS, which is expected to be Java 21.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="Future Java" data-type="sect1"><div class="sect1" id="javanut8-APP-A-SECT-4">
<h1>Future Java</h1>
<p>Along with the completion of the projects already mentioned, longer-term efforts to evolve Java are underway: Project Valhalla and the rise of Cloud-Native Java.</p>
<p>Let’s look at each in turn.</p>
<section data-pdf-bookmark="Valhalla" data-type="sect2"><div class="sect2" id="javanut8-APP-A-SECT-4.1">
<h2>Valhalla</h2>
<p><a data-primary="Project Valhalla" data-type="indexterm" id="idm45927697154480"/><a data-primary="Valhalla" data-type="indexterm" id="idm45927697153776"/>Project Valhalla is a very ambitious OpenJDK project that has been running since 2014.
The goal, “To align JVM memory layout behavior with the cost model of modern hardware,” seems simple and innocuous enough.</p>
<p>However, this is deeply deceptive.</p>
<p>For starters, this divides the existing Java objects into two cases: the identity objects we’re used to using and a new kind of value object whose main difference is that it doesn’t have a unique identity.
From these value objects, a further step is taken to allow the reference-ness, or indirection, to be removed and for the value to be directly represented by its bit patterns.</p>
<p>The intended use case for this new data value is small, immutable, final, identity-less types.
This allows these new identity-less values to fit with both the existing object reference and primitive worlds, getting the best of each world, and it also alludes to one possible use case as “user-defined primitives.”</p>
<p>Users should think of values as objects without identity, and then they will get guaranteed performance benefits from the JIT (such as enhanced <em>escape analysis</em>).</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Valhalla also provides a mechanism for low-level libraries (such as complex numbers, half-floats for machine learning, etc.) to use the primitive value type directly, but most developers should not need to use this aspect.</p>
</div>
<p>The fact that these new data values lack object identity implies that they disrupt the traditional inheritance hierarchy—without identity there is no object monitor, so <code>wait()</code>, <code>notify()</code>, and <code>synchronized</code> are not possible for these types.</p>
<p>In turn, this creates a potentially surprising connection to Java generics because only reference types are permissible as the value for a type parameter.
Valhalla therefore proposes to extend generics to allow abstraction over all types including these new data values and even the existing primitives.</p>
<p>In addition to the extensive work to plumb these new forms of data through the JVM, it is also necessary to create a usage model in the Java language that seems natural to Java programmers.
Valhalla must also enable existing libraries (including, but not limited to, the JDK) to compatibly evolve as these changes are delivered.</p>
<p>Some new bytecode instructions will be needed, as Valhalla’s new types are immutable, so the <code>putfield</code> instruction (which modifies object fields) will not work.</p>
<p>Valhalla’s new types have been known by several names during the project’s history, including <em>value types</em>, <em>inline types</em>, and <em>primitive classes</em>.
The JEPs that cover the implementation of Valhalla are not, at the time of writing, targeted at any specific Java version, and it may be some time before most Java programmers encounter them in day-to-day work.</p>
</div></section>
<section data-pdf-bookmark="Cloud-Native Java" data-type="sect2"><div class="sect2" id="javanut8-APP-A-SECT-4.2">
<h2>Cloud-Native Java</h2>
<p><a data-primary="cloud-native Java" data-type="indexterm" id="ix_appendixA-asciidoc2"/>One of the ongoing mega trends in the software industry is the transition to workloads that run “in the cloud,” which means on time-leased servers owned by infrastructure providers such as Amazon, Microsoft, and Google.</p>
<p>Modern programming environments increasingly need to ensure that they are economic and easy to use in cloud deployments, and Java is no exception.
However, Java’s design does have certain aspects that are potentially less friendly to cloud applications than we would like.
These largely stem from the classloading and JIT compilation aspects of the runtime, which are designed for flexibility and high performance over the lifetime of a single JVM process.</p>
<p>In the cloud, this can have side effects such as:</p>
<ul>
<li>
<p>Slow application startup time</p>
</li>
<li>
<p>Long time to peak performance</p>
</li>
<li>
<p>Potentially high memory overhead</p>
</li>
</ul>
<p>In particular, the lifetime of cloud processes (especially for “Serverless” and <em>Function-as-a-Service</em> deployments) may be too short for the performance benefits of Java to pay off. This can be seen as the costs required to get the gains not being fully amortized by the time the process exits.</p>
<p>There are ongoing attempts to solve these long-term pain points and ensure that Java remains a competitive and attractive programming environment as Cloud-First becomes the dominant mode of delivery for serverside applications.</p>
<p><a data-primary="native compilation" data-type="indexterm" id="idm45927697135520"/>One of the major approaches is <em>native compilation</em>: the conversion of a Java program from bytecode into compiled machine code.
<a data-primary="ahead-of-time (AOT) compilation" data-type="indexterm" id="idm45927697134256"/><a data-primary="AOT (ahead-of-time) compilation" data-type="indexterm" id="idm45927697133488"/>As this compilation occurs before program execution starts (as for languages like Rust and C++), it is known as <em>ahead-of-time compilation</em>, or just AOT.
This technique is unusual in the Java space, but it aims to provide a faster startup time as programs do not need to be classloaded or JIT compiled.
However, it does not generally give better peak performance than the same application would have when running in dynamic VM mode.
This is because peak performance isn’t the point here. AOT and JIT represent different strategies and different tradeoffs.</p>
<p><a data-primary="GraalVM" data-type="indexterm" id="idm45927697131808"/>The current main effort to support native compiled Java is <a href="https://oreil.ly/o9jNp">Oracle’s GraalVM</a>.
This was developed as a separate research project in Oracle Labs, but as of late 2022, Oracle has announced plans to contribute parts of it to OpenJDK. It is available in two editions, an open-source edition and a proprietary Enterprise Edition, which has a licensing and support cost.</p>
<p>GraalVM contains a compiler called Graal that can operate in either JIT or AOT mode.
The AOT mode of Graal is the basis of GraalVM’s Native Image technology that can produce a standalone, compiled machine code binary from a Java application.
One interesting aspect of the Graal compiler is that it is written in Java, unlike the JIT compilers in OpenJDK, which are implemented in native code.</p>
<p><a data-primary="Truffle" data-type="indexterm" id="idm45927697129616"/>GraalVM also includes Truffle, an interpreter generating framework for languages on the JVM.
Interpreters for supported languages, written on top of Truffle, are themselves Java programs that run on the JVM.
Many non-Java languages are already available such as JavaScript, Python, Ruby, and R.</p>
<p>Another of the projects working on improving cloud-native support is <a href="https://quarkus.io">Quarkus</a>, a Java microservices framework designed for the Kubernetes cloud orchestration and deployment stack.1411.200
<a data-primary="Quarkus" data-type="indexterm" id="idm45927697127504"/>Quarkus attempts to reduce the impact of the cloud-native pain points by extensively using build-time processing.
Expensive computations and startup that would normally be handled reflectively during startup are instead performed ahead of time wherever possible.</p>
<p>Quarkus also emphasizes developer experience and provides both reactive and imperative styles of programming microservices.</p>
<p>The framework is open source and production ready, and it has support available from Red Hat, which is the primary maintainer of the project.
It also includes support for native compilation, based on the open-source edition of GraalVM.
However, Quarkus can also be run in dynamic VM mode on top of an OpenJDK runtime.</p>
<p><a data-primary="Leyden" data-type="indexterm" id="idm45927697125440"/><a data-primary="Project Leyden" data-type="indexterm" id="idm45927697124736"/>Finally, we should also mention Project Leyden.
This is a new (May 2022) OpenJDK project that seeks to introduce <em>static runtime images</em> to the Java platform.
The project name comes from a “Leyden jar,” a device from the 1700s used for storing static electrical charge.
A key aspect of this is known as the <em>closed world</em> assumption that removes dynamic runtime behavior such as reflection.</p>
<p>The project is still in its early stages but is adopting a different (and more cautious) approach than GraalVM; a key goal of Leyden is to be able to selectively and flexibly constrain and shift dynamism.
The intent is to evolve toward similar targets as the AOT-compiled native image binaries created by GraalVM, but as yet there are no indications when these techniques might appear in a production form of Java<a data-startref="ix_appendixA-asciidoc2" data-type="indexterm" id="idm45927697122320"/>.<a data-startref="ix_appendixA-asciidoc0" data-type="indexterm" id="idm45927697121488"/></p>
</div></section>
</div></section>
</div></section></div></body></html>