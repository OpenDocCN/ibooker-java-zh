["```java\nint port = 9999;\n\n// Create a server socket\ntry (ServerSocket server = new ServerSocket(port)) {\n    while (true) {\n\n        // Wait for the next connection from a client\n        Socket client = server.accept();\n\n        PrintWriter response = new PrintWriter(client.getOutputStream(), true);\n        BufferedReader request = new BufferedReader(\n                new InputStreamReader(client.getInputStream()));\n\n        String line;\n        while ((line = request.readLine()) != null) {\n            System.out.println(\"Server received message from client: \" + line);\n            // Echo the request\n            response.println(line);\n\n            // Add a way to stop the application.\n            if (\"done\".equalsIgnoreCase(line)) {\n                break;\n            }\n        }\n        client.close();\n    }\n}\n```", "```java\nwhile (listening) {\n    accept a connection;\n    create a worker thread to process the client request;\n}\n```", "```java\nint port = 9999;\nExecutorService executors = Executors.newFixedThreadPool(10); ![1](assets/1.png)\n\n// Create a server socket try (ServerSocket server = new ServerSocket(port)) {\n    while (true) {\n\n        // Wait for the next connection from a client\n        Socket client = server.accept();\n\n        executors.submit(() -> {                                    ![2](assets/2.png)\n            try {\n                PrintWriter response =\n                new PrintWriter(client.getOutputStream(), true);\n                BufferedReader request = new BufferedReader(\n                        new InputStreamReader(client.getInputStream()));\n\n                String line;\n                while ((line = request.readLine()) != null) {\n                    System.out.println(Thread.currentThread().getName() +\n                            \" - Server received message from client: \" + line);\n                    // Echo the request\n                    response.println(line);\n\n                    // Add a way to stop the application.\n                    if (\"done\".equalsIgnoreCase(line)) {\n                        break;\n                    }\n                }\n                client.close();\n            } catch (Exception e) {\n                System.err.println(\"Couldn't serve I/O: \" + e.toString());\n\n            }\n        });\n    }\n}\n```", "```java\nInetSocketAddress address = new InetSocketAddress(\"localhost\", 9999);\nSelector selector = Selector.open();\nServerSocketChannel channel = ServerSocketChannel.open();\nchannel.configureBlocking(false);\n\nchannel.socket().bind(address);\n// Server socket supports only ACCEPT\nchannel.register(selector, SelectionKey.OP_ACCEPT);\n\nwhile (true) {\n    int available = selector.select(); // wait for events\n    if (available == 0) {\n        continue;  // Nothing ready yet.\n    }\n\n    // We have the request ready to be processed.\n    Set<SelectionKey> keys = selector.selectedKeys();\n    Iterator<SelectionKey> iterator = keys.iterator();\n    while (iterator.hasNext()) {\n        SelectionKey key = iterator.next();\n        if (key.isAcceptable()) {\n            // --  New connection --\n            SocketChannel client = channel.accept();\n            client.configureBlocking(false);\n            client.register(selector, SelectionKey.OP_READ);\n            System.out.println(\"Client connection accepted: \"\n                + client.getLocalAddress());\n        } else if (key.isReadable()) {\n            // --  A client sent data ready to be read and we can write --\n            SocketChannel client = (SocketChannel) key.channel();\n            // Read the data assuming the size is sufficient for reading.\n            ByteBuffer payload = ByteBuffer.allocate(256);\n            int size = client.read(payload);\n            if (size == -1 ) { // Handle disconnection\n                System.out.println(\"Disconnection from \"\n                    + client.getRemoteAddress());\n                channel.close();\n                key.cancel();\n            } else {\n                String result = new String(payload.array(),\n                    StandardCharsets.UTF_8).trim();\n                System.out.println(\"Received message: \" + result);\n                if (result.equals(\"done\")) {\n                    client.close();\n                }\n                payload.rewind(); // Echo\n                client.write(payload);\n            }\n        }\n        // Be sure not to handle it twice.\n        iterator.remove();\n    }\n}\n```", "```java\npublic static void main(String[] args) throws Exception {\n    new NettyServer(9999).run();\n}\n\nprivate final int port;\n\npublic NettyServer(int port) {\n    this.port = port;\n}\n\npublic void run() throws Exception {\n    // NioEventLoopGroup is a multithreaded event loop that handles I/O operation.\n    // The first one, often called 'boss', accepts an incoming connection.\n    // The second one, often called 'worker', handles the traffic of the accepted\n    // connection once the boss accepts the connection and registers the\n    // accepted connection to the worker.\n    EventLoopGroup bossGroup = new NioEventLoopGroup();\n\n    EventLoopGroup workerGroup = new NioEventLoopGroup();\n    try {\n        // ServerBootstrap is a helper class that sets up a server.\n        ServerBootstrap b = new ServerBootstrap();\n        b.group(bossGroup, workerGroup)\n                // the NioServerSocketChannel class is used to instantiate a\n                // new Channel to accept incoming connections.\n                .channel(NioServerSocketChannel.class)\n                .childHandler(new ChannelInitializer<SocketChannel>() {\n                    // This handler is called for each accepted channel and\n                    // allows customizing the processing. In this case, we\n                    // just append the echo handler.\n                    @Override\n                    public void initChannel(SocketChannel ch) {\n                        ch.pipeline().addLast(new EchoServerHandler());\n                    }\n                });\n\n        // Bind and start to accept incoming connections.\n        ChannelFuture f = b.bind(port).sync();\n\n        // Wait until the server socket is closed.\n        f.channel().closeFuture().sync();\n    } finally {\n        workerGroup.shutdownGracefully();\n        bossGroup.shutdownGracefully();\n    }\n}\n\nprivate static class EchoServerHandler extends ChannelInboundHandlerAdapter {\n\n    @Override\n    public void channelRead(ChannelHandlerContext ctx, Object msg) {\n        // Write the received object, and flush\n        ctx.writeAndFlush(msg);\n    }\n}\n```", "```java\nVertx vertx = Vertx.vertx();\n// Create a TCP server\nvertx.createNetServer()\n        // Invoke the given function for each connection\n        .connectHandler(socket -> {\n            // Just write the content back\n            socket.handler(buffer -> socket.write(buffer));\n        })\n        .listen(9999);\n```"]