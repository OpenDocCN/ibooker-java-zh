- en: Chapter 18\. Open to Sealed Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our systems are composed of types and operations, nouns and verbs. In Java,
    nouns are expressed as classes and interfaces, verbs as methods; but Kotlin adds
    sealed class hierarchies and freestanding functions. What do they bring to the
    party?
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Change is a constant challenge in designing software. The more people use our
    software, the more they think of things they want it to do. To support new use
    cases, we need to add new functions that work with existing data types, and new
    data types that work with existing functions. If our design is well aligned with
    the way the software has to evolve, we can add new features by adding new code
    and making few, localized changes to our existing code. If it isn’t well aligned,
    we will have to change many functions when we add a new data type, or change many
    data types when we need to add a function.
  prefs: []
  type: TYPE_NORMAL
- en: 'We feel this tension between the variability of data types and of functions
    most keenly in the core entities of our domain model. For example, the traveler’s
    itinerary is a core entity of our Travelator application. Many features of the
    application present views of, alter the contents of, or calculate information
    about itineraries. It’s no surprise then that many of the feature requests from
    our users affect our `Itinerary` type. Our travelers want to include more kinds
    of things in their itineraries: not just journeys and accommodation, as we saw
    in [Chapter 10](ch10.html#functions-to-extension-functions), but now restaurant
    bookings and attractions along the route. They also want to do more things with
    their itineraries. In [Chapter 14](ch14.html#accumulating-objects-to-transformations),
    we saw how we estimate their cost, but our customers also want to compare them
    by cost, time, or comfort, view them on a map, import them into their calendar,
    share them with their friends…their imagination is endless.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When we last looked at the `Itinerary` class in [Chapter 14](ch14.html#accumulating-objects-to-transformations),
    we were modeling an itinerary as a data class, with a property for the route and
    another for the accommodation required along the route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 18.1 [accumulator.17:src/main/java/travelator/itinerary/Itinerary.kt]](https://java-to-kotlin.dev/code.html?ref=18.1&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=18.1&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since then, we have added more features to the application and, hence, more
    types of items to the itinerary. We found it increasingly cumbersome to hold each
    type of itinerary item in a separate collection, because too much of our code
    involved combining those collections or applying the same filters and transforms
    to separate collections. So we decided that an `Itinerary` would maintain a single
    collection of `ItineraryItem` rather than keep each type of item in a separate
    collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 18.2 [open-to-sealed.0:src/main/java/travelator/itinerary/Itinerary.kt]](https://java-to-kotlin.dev/code.html?ref=18.2&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=18.2&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: '`ItineraryItem` is an interface, implemented by the concrete item types we
    saw before: `Journey` and `Accommodation` and new types `RestaurantBooking` and
    `Attraction`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 18.3 [open-to-sealed.0:src/main/java/travelator/itinerary/ItineraryItem.kt]](https://java-to-kotlin.dev/code.html?ref=18.3&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=18.3&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: Operations on `Itinerary` don’t depend on the concrete type of its items. For
    example, to display the itinerary on a map, we create a `MapOverlay` that will
    be rendered on top of map tiles on the frontend. The overlay for an `Itinerary`
    is the group of the overlays for all the items it contains. The `Itinerary` class
    and its clients don’t know, or need to know, how each item represents itself as
    a map overlay.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 18.4 [open-to-sealed.0:src/main/java/travelator/itinerary/Itinerary.kt]](https://java-to-kotlin.dev/code.html?ref=18.4&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=18.4&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: This polymorphism makes it very easy to add new types of `ItineraryItem` to
    the system without having to change the parts of the application that use the
    `Itinerary` type.
  prefs: []
  type: TYPE_NORMAL
- en: For a while now, though, we haven’t had to do that. Recently, we find that most
    of the new functionality we add to Travelator involves adding new operations to
    `Itinerary` and `ItineraryItem` rather than new types of `ItineraryItem`. Changes
    to the `Itinerary​I⁠tem` interface and its implementations are a common source
    of merge conflicts between team members who are working on different features.
    With every new feature, the `ItineraryItem` gets larger. It seems to attract behavior
    to support distantly related parts of the application, with properties to support
    rendering, cost estimation, ranking by comfort, maps drawing, and more hidden
    beyond that `…and other methods`. Paradoxically, in the core of our application,
    object-oriented polymorphism is *increasing* coupling!
  prefs: []
  type: TYPE_NORMAL
- en: 'Object-oriented polymorphism enables variability of data types with an infrequently
    changing set of operations. For a while, that was what our codebase needed, but
    now that it has stabilized, we need the opposite: variability of operations applied
    to an infrequently changing set of data types.'
  prefs: []
  type: TYPE_NORMAL
- en: If we were writing in Java (at least up to Java 16), there is no language feature
    to help us cope with variability in this dimension. Java’s principal feature to
    support variability is object-oriented polymorphism, and that doesn’t help when
    operations change more frequently than the set of data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could use the [double dispatch](https://oreil.ly/8m2HL) pattern, but it
    involves a lot of boilerplate code and, because it does not play well with checked
    exceptions, is not widely used in Java. Instead, Java programmers often resort
    to runtime type checks, using the `instanceof` and downcast operators to run different
    code for different classes of object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 18.5 [open-to-sealed.0:src/main/java/travelator/itinerary/ItineraryItems.java]](https://java-to-kotlin.dev/code.html?ref=18.5&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=18.5&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'That `IllegalStateException` shows that this approach is risky. Whereas the
    compiler can type check our calls to polymorphic methods, our hand-coded runtime
    type checks and casts are explicitly circumventing compile-time checks. The type
    checker cannot tell whether our casts are correct or our conditional statement
    is *exhaustive*: whether it applies to all possible subclasses. If returning a
    value from the method, we have to write an `else` clause to return a dummy value
    or throw an exception, even if we have branches for every subclass of `ItineraryItem`,
    and the else clause “cannot possibly be executed™.”'
  prefs: []
  type: TYPE_NORMAL
- en: Even if we cover all the subtypes of `ItineraryItem` when we write the code,
    if we later add new types, we have to find all such code and update it. It turns
    out that we didn’t do that here, so if we add an `Attraction` to an `Itinerary`,
    this code will fail with an `IllegalArgumentException`. OO solves this problem,
    but we circumvented the solution because we were tired of having to update lots
    of classes when we add an operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Type checking and downcasting are possible in Kotlin, too, and carry the same
    overheads and risks. However, Kotlin has another mechanism for organizing classes
    and behavior that makes runtime type checks safe and convenient: *sealed classes*.
    A sealed class is an abstract class with a fixed set of direct subclasses. We
    must define the sealed class and its subclasses in the same compilation unit and
    package; the compiler prevents us from extending the sealed class elsewhere. Thanks
    to this restriction, runtime type checks on sealed class hierarchies do not have
    the same problem as runtime type checks in Java. The static type checker can guarantee
    that `when` expressions that perform runtime type checks for a subtype of a sealed
    class cover all possible cases and only the possible cases.'
  prefs: []
  type: TYPE_NORMAL
- en: When Statements Are Not Checked for Exhaustiveness
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The compiler checks `when` expressions for exhaustiveness but does not check
    `when` *statements*; `when` becomes a statement if the value of the entire `when`
    expression is not used. You can force the compiler to check for exhaustiveness
    by using the result of the `when`, even though it is of type `Unit`.
  prefs: []
  type: TYPE_NORMAL
- en: If the `when` is the only statement in the body of a function, you can refactor
    the function to single-expression form. If `when` is the last statement in a multistatement
    function, you can explicitly use its value with the `return` keyword. When the
    `when` is in the middle of the function body, extracting it to its own function
    might make sense.
  prefs: []
  type: TYPE_NORMAL
- en: 'When none of those options apply, you can use the following utility function
    to force an exhaustiveness check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'When used like this, it will prevent compilation when `when` is not exhaustive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Compared to polymorphic methods, sealed classes and `when` expressions make
    it easy to add new operations that apply to a fixed type hierarchy, although we
    still have to change all those operations if we add a new type to that hierarchy.
    At this point the compiler will help us by checking that all those operations
    cover all possible types in the hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism or Sealed Classes?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some languages have mechanisms that let us vary types *and* operations without
    modifying existing code. Haskell has type classes, Scala has implicit parameters,
    Rust has traits, Swift has protocols, and Clojure and Common Lisp have polymorphic
    functions that dispatch on the classes of multiple arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Kotlin doesn’t have any equivalent. When we’re designing in Kotlin, we have
    to choose between object-oriented polymorphism or sealed classes based on the
    dimension—types or operations—we expect to vary most frequently as the program
    evolves. Object-oriented polymorphism is preferable when the set of data types
    varies more frequently than the set of operations on those data types, and sealed
    class hierarchies when the set of operations varies more frequently than the set
    of data types they apply to.
  prefs: []
  type: TYPE_NORMAL
- en: Only Typecast Down a Sealed Class Hierarchy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Only use typecasts to cast from the root of a sealed class hierarchy to one
    of the children in an exhaustive `when` expression. Otherwise, it is risky to
    cast away from the static type. The actual class used to implement a value may
    have operations that violate the constraints expressed by its static type.
  prefs: []
  type: TYPE_NORMAL
- en: For example, as we saw in [Chapter 6](ch06.html#java-to-kotlin-collections),
    the static type `List` prevents mutation, but Kotlin’s higher-order functions
    return lists that can be mutated if you downcast from `List` to `MutableList`.
    A function that downcasts a list argument from `List` to `MutableList` and mutates
    it is likely to introduce bugs in code, because it violates the expectations of
    its callers. It could introduce aliasing errors that are very hard to find, because
    the possibility of spooky action at a distance is not explicit in the type declarations
    of the function’s signature. If a future version of the Kotlin standard library
    returned immutable lists from its higher-order functions, the function would continue
    to compile successfully but crash at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Just because you *can* cast from a super type to a subtype doesn’t mean you
    are intended to. The possibility is likely to be a mere implementation detail.
    A sealed class hierarchy signals that downcasting is intended, supported, and
    made safe by the compiler’s exhaustiveness checks.
  prefs: []
  type: TYPE_NORMAL
- en: Converting an Interface to a Sealed Class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We’re about to add another feature that involves itineraries and itinerary
    items: making the `Itinerary` appear in the traveler’s calendar app. We don’t
    want to add more methods to the already bloated `ItineraryItem` interface and
    couple the core classes of our application’s domain to the needs of another peripheral
    module. It’s time to bite the bullet and convert `ItineraryItem` from an interface
    of polymorphic methods to a sealed class hierarchy and freestanding functions,
    and move those freestanding functions into the modules that use them.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Kotlin 1.4 was current when we wrote this, so we have to define a sealed class
    and its direct subclasses in the same file. Our first step, then, is to use the
    IDE’s “Move Class” refactoring to move the implementations of `ItineraryItem`
    into the same file as the interface. Once we’ve done that, we can turn the interface
    and its implementations into a sealed class hierarchy. IntelliJ does not have
    an automated refactoring for this, so we have to do it by manually editing the
    class definitions. At least moving all the classes into the same file has made
    the task easier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 18.6 [open-to-sealed.2:src/main/java/travelator/itinerary/ItineraryItem.kt]](https://java-to-kotlin.dev/code.html?ref=18.6&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=18.6&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: '[![1](assets/1.png)](#co_introduction_CO40-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We declare `ItineraryItem` as a `sealed class` instead of an `interface`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_introduction_CO40-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Because it is now a class, we have to explicitly mark its methods as `abstract`.
    If the interface had any methods with a default implementation, we would have
    had to declare them as `open` so that subclasses could still override them.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_introduction_CO40-3)'
  prefs: []
  type: TYPE_NORMAL
- en: We replace the declaration of the interface in the concrete item classes with
    a call to the superclass constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Kotlin 1.5 (released as we completed this book) supports sealed *interfaces*,
    which make this refactoring easier. It’s unnecessary to move the subclasses into
    the same file or to call the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: '`ItineraryItem` is now a sealed class. Its operations are still polymorphic
    methods, but we can add *new* operations without changing the `ItineraryItem`
    classes, by writing extension functions that use a `when` expression to safely
    dispatch on the concrete item type.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First we’ll write the extension functions that we need to translate an `Itinerary`
    to a calendar. When we’re done, we’ll continue refactoring to make the other operations
    on `ItineraryItem` work the same way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 18.7 [open-to-sealed.3:src/main/java/travelator/calendar/ItineraryToCalendar.kt]](https://java-to-kotlin.dev/code.html?ref=18.7&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=18.7&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s refactor the rest of the `ItineraryItem` methods from being polymorphic
    methods defined on the (now sealed) class, to extension functions that use `when`
    expressions to switch on the type of item. We’ll walk through the process with
    the `mapOverlay` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we Alt-Enter on the definition of `mapOverlay` in `ItineraryItem`, the
    context menu includes the action “Convert member to extension”. Can it really
    be that easy? Unfortunately, no. At the time of writing, the IDE action only gets
    us part of the way there and leaves us with code that does not compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 18.8 [open-to-sealed.4:src/main/java/travelator/itinerary/ItineraryItem.kt]](https://java-to-kotlin.dev/code.html?ref=18.8&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=18.8&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: '[![1](assets/1.png)](#co_introduction_CO41-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The IDE removed the `mapOverlay` method from the `ItineraryItem` class…
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_introduction_CO41-2)'
  prefs: []
  type: TYPE_NORMAL
- en: …and replaced it with an extension function. Unfortunately, the extension function
    only contains a `TODO` that throws `UnsupportedOperationException`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_introduction_CO41-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The IDE left `override` modifiers on the `mapOverlay` properties in the subclasses,
    which no longer have a method in the superclass to override.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can get the code compiling again by removing the `override` modifiers in
    the subclasses. Then we’ll make the code actually work by implementing the body
    of an extension function as a `when` expression that switches on the type of `ItineraryItem`
    and calls the now monomorphic `mapOverlay` getter on each concrete class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 18.9 [open-to-sealed.5:src/main/java/travelator/itinerary/ItineraryItem.kt]](https://java-to-kotlin.dev/code.html?ref=18.9&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=18.9&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: The `when` expression will not compile until we have covered all the subclasses
    of `ItineraryItem`. IntelliJ also highlights each read of the subclass `mapOverlay`
    properties to show that the compiler’s flow-sensitive typing is smart casting
    the implicit `this` reference from `ItineraryItem` to the correct subclass.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now the point of this refactor was to prevent every implementation of `ItineraryItem`
    from having to know about map overlays. At present each still does, because each
    has its own `mapOverlay` property—the one that was originally overriding the property
    in the interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 18.10 [open-to-sealed.5:src/main/java/travelator/itinerary/ItineraryItem.kt]](https://java-to-kotlin.dev/code.html?ref=18.10&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=18.10&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can solve this problem by converting the `mapOverlay` properties with “Convert
    member to extension”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 18.11 [open-to-sealed.6:src/main/java/travelator/itinerary/ItineraryItem.kt]](https://java-to-kotlin.dev/code.html?ref=18.11&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=18.11&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now `ItineraryItem.mapOverlay` doesn’t appear to have changed at all:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 18.12 [open-to-sealed.6:src/main/java/travelator/itinerary/ItineraryItem.kt]](https://java-to-kotlin.dev/code.html?ref=18.12&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=18.12&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Look closer, though (well, hover in IntelliJ), and we can see that those property
    accesses are now extension properties, not method calls—`Accommodation` and so
    on no longer depend on `MapOverlay`. And now that `ItineraryItem.mapOverlay` and
    all the subclass properties are extensions, they don’t need to be defined in the
    same file as the sealed classes. We can move them to the module or package where
    they are used, and they won’t clutter our core domain abstraction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 18.13 [open-to-sealed.7:src/main/java/travelator/geo/ItineraryToMapOverlay.kt]](https://java-to-kotlin.dev/code.html?ref=18.13&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=18.13&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do the same with the other members of `ItineraryItem`, until the sealed
    class declares only the fundamental properties of the type. For `ItineraryItem`
    at the moment, only the `id` property is truly fundamental: declaring `id` as
    an abstract property on the sealed class forces every subclass to have an identifier.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Of the other properties, some are clearly there just to support specific features
    of the application, like `mapOverlay` and `toCalendar`. Others, like `description`,
    are in a gray area: they support many features of the application, but are not
    a fundamental property of an `ItineraryItem`. For example, each subtype derives
    its description from its fundamental properties. Nat prefers to define properties
    like these as extensions, while Duncan prefers to define them as members of the
    class. Nat is writing this example, so we’ll make `description` an extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 18.14 [open-to-sealed.8:src/main/java/travelator/itinerary/ItineraryDescription.kt]](https://java-to-kotlin.dev/code.html?ref=18.14&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=18.14&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll have to make your own judgment call in your own code. That leaves the
    sealed `ItineraryItem` class declaring only the `id` property and its subclasses
    declaring their fundamental properties. The whole hierarchy looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 18.15 [open-to-sealed.8:src/main/java/travelator/itinerary/ItineraryItem.kt]](https://java-to-kotlin.dev/code.html?ref=18.15&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=18.15&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: Our `ItineraryItem` model is now a sealed class hierarchy of pure data classes.
    The operations needed by the features of our application are all extension functions
    in the modules for those features. Only the `id` property remains as a polymorphic
    `val`, because it is a fundamental property of the type that is not specific to
    any one feature of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Moving On
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As our software evolves, we have to add new data types and new operations to
    our system. In Kotlin, as in Java, object-oriented polymorphism lets us easily
    add new data types without changing the code of existing functions. We can also
    use sealed classes and safe runtime type checks to easily add new functions over
    existing data types without changing the code that defines those types. Which
    we choose depends on what we expect to vary most frequently as the code evolves:
    data types or operations. Managing variability in Kotlin involves mastering when
    to apply these two mechanisms to our domain models.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If our bet turns out to have been wrong, we must refactor from one to the other.
    When all the code is in a single codebase, Kotlin and IntelliJ make refactoring
    between the two forms straightforward. This chapter described going from the kind
    of object-oriented polymorphism we’d write in Java to Kotlin’s sealed classes.
    Going the other way involves refactoring steps described in Martin Fowler’s [*Refactoring:
    Improving the Design of Existing Code*](bibliography01.html#F_RITDOEC_1999), such
    as “Replace Conditional with Polymorphism,” so we won’t cover it in this book.'
  prefs: []
  type: TYPE_NORMAL
