- en: Chapter 7\. Creating Applications Using Spring MVC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter demonstrates how to create Spring Boot applications using Spring
    MVC with REST interactions, messaging platforms, and other communications mechanisms
    and provides an introduction to templating language support. Although I introduced
    interservice interactions as part of last chapter’s dive into Spring Boot’s many
    options for handling data, this chapter shifts the primary focus from the application
    itself to the outside world: its interactions with other applications and/or services
    and with end users.'
  prefs: []
  type: TYPE_NORMAL
- en: Code Checkout Checkup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Please check out branch *chapter7begin* from the code repository to begin.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring MVC: What Does It Mean?'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Like many other things in technology, the term *Spring MVC* is somewhat overloaded.
    When someone refers to Spring MVC, they could mean any of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing (in some manner) the Model-View-Controller pattern in a Spring
    application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an application specifically using Spring MVC component concepts like
    the `Model` interface, `@Controller` classes, and view technologies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing blocking/nonreactive applications using Spring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Depending on context, Spring MVC can be considered both an approach and an implementation.
    It can also be used within or without Spring Boot. Generic application of the
    MVC pattern using Spring and Spring MVC use outside of Spring Boot both fall outside
    the scope of this book. I’ll focus specifically on the final two concepts previously
    listed using Spring Boot to implement them.
  prefs: []
  type: TYPE_NORMAL
- en: End User Interactions Using Template Engines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While Spring Boot applications handle a lot of heavy-lifting chores on the backend,
    Boot also supports direct end-user interactions as well. Although long-established
    standards like Java Server Pages (JSP) are still supported by Boot for legacy
    applications, most current applications either leverage more powerful view technologies
    supported by still-evolving and -maintained template engines or shift frontend
    development to a combination of HTML and JavaScript. It’s even possible to mix
    the two options successfully and play to each one’s strengths.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Boot works well with HTML and JavaScript frontends, as I demonstrate
    later in this chapter. For now, let’s take a closer look at template engines.
  prefs: []
  type: TYPE_NORMAL
- en: 'Template engines provide a way for a so-called server-side application to generate
    the final pages that will be displayed and executed in the end user’s browser.
    These view technologies differ in approaches but generally provide the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A template language and/or collection of tags that define inputs used by the
    template engine to produce the expected outcome
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A view resolver that determines the view/template to use to fulfill a requested
    resource
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Among other lesser-used options, Spring Boot supports view technologies such
    as [Thymeleaf](https://www.thymeleaf.org), [FreeMarker](https://freemarker.apache.org),
    [Groovy Markup](http://groovy-lang.org/templating.html), and [Mustache](https://mustache.github.io).
    Thymeleaf is perhaps the most widely used of these for several reasons and provides
    excellent support for both Spring MVC and Spring WebFlux applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thymeleaf uses natural templates: files that incorporate code elements but
    that can be opened and viewed directly (and correctly) in any standard web browser.
    Being able to view the template files as HTML enables developers or designers
    to create and evolve Thymeleaf templates without any running server processes.
    Any code integrations that expect corresponding server-side elements are tagged
    as Thymeleaf-specific and simply don’t display what isn’t present.'
  prefs: []
  type: TYPE_NORMAL
- en: Building on previous efforts, let’s build a simple web application using Spring
    Boot, Spring MVC, and Thymeleaf to present to the end user an interface for querying
    PlaneFinder for current aircraft positions and displaying the results. Initially
    this will be a rudimentary proof of concept to be evolved in subsequent chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing the Project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To begin, we return to the Spring Initializr. From there, I choose the following
    options:'
  prefs: []
  type: TYPE_NORMAL
- en: Maven project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Current production version of Spring Boot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Packaging: Jar'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Java: 11'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And for dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: Spring Web (`spring-boot-starter-web`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Reactive Web (`spring-boot-starter-webflux`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thymeleaf (`spring-boot-starter-thymeleaf`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Data JPA (`spring-boot-starter-data-jpa`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: H2 Database (`h2`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lombok (`lombok`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next step is to generate the project and save it locally, unzip it, and
    open it in the IDE.
  prefs: []
  type: TYPE_NORMAL
- en: Developing the Aircraft Positions Application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since this application is concerned only with the current state—aircraft positions
    at the moment the request is made, not historically—an in-memory database seems
    a reasonable choice. One could instead use an `Iterable` of some kind, of course,
    but Spring Boot’s support for Spring Data repositories and the H2 database fulfill
    the current use case and position the application well for planned future expansion.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the domain class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As with other projects interacting with `PlaneFinder`, I create an `Aircraft`
    domain class to serve as the primary (data) focus. Here is the `Aircraft` domain
    class structure for the `Aircraft Positions` application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This domain class is defined using JPA with H2 as the underlying JPA-compliant
    database and leveraging Lombok to create a data class with constructors having
    zero arguments and all arguments, one for every member variable.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the repository interface
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, I define the required repository interface, extending Spring Data’s `CrudRepository`
    and providing the type of object to store and its key: `Aircraft` and `Long`,
    in this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Working with Model and Controller
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I’ve defined the data behind the model with the `Aircraft` domain class; now
    it’s time to incorporate it into the `Model` and expose it via a `Controller`.
  prefs: []
  type: TYPE_NORMAL
- en: As discussed in [Chapter 3](ch03.xhtml#sbur-03), `@RestController` is a convenience
    notation that combines `@Controller` with `@ResponseBody` into a single descriptive
    annotation, returning a formatted response as JavaScript Object Notation (JSON)
    or as other data-oriented format. This results in the Object/Iterable return value
    of a method being the *entire body* of the response to a web request, instead
    of being returned as a part of the `Model`. An `@RestController` enables the creation
    of an API, a specialized, but very common, use case.
  prefs: []
  type: TYPE_NORMAL
- en: The goal now is to create an application that also includes a user interface,
    and `@Controller` enables that. Within an `@Controller` class, each method annotated
    with `@RequestMapping` or one of its specialized aliases like `@GetMapping` will
    return a `String` value that corresponds to the name of a template file minus
    its extension. For example, Thymeleaf files have the *.html* file extension, so
    if an `@Controller` class’s `@GetMapping` method returns the `String` “myfavoritepage”,
    the Thymeleaf template engine will use the *myfavoritepage.html* template to create
    and return the generated page to the user’s browser.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: View technology templates are placed under the project’s *src/main/resources/templates*
    directory by default; the template engine will look here for them unless overridden
    via application properties or programmatic means.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returning to the controller, I create a class `PositionController` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This controller looks very similar to previous iterations but with a few key
    differences. First, of course, is the `@Controller` annotation previously discussed
    instead of `@RestController`. Second is that the `getCurrentAircraftPositions()`
    method has an automatically autowired parameter: `Model model`. This parameter
    is the `Model` bean that is leveraged by the template engine to provide access
    to the application’s components—their data and operations—once we add those components
    to the `Model` as an attribute. And third is the method’s return type of `String`
    instead of a class type and the actual return statement with the name of a template
    (sans *.html* extension).'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In a complex domain/application, I prefer to separate concerns a bit more by
    creating distinct `@Service` and `@Controller` classes. In this example, there
    is a single method making a single repository access, so I’ve placed all functionality
    to populate the underlying data, populate the `Model`, and hand it off to the
    appropriate `View` within the `Controller`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the requisite View files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As a basic foundation for this and future chapters, I create one plain HTML
    file and one template file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since I want to display a plain HTML page to all visitors, and since this page
    requires no template support, I place *index.html* directly in the project’s *src/main/resources/static*
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'For the dynamic content, I create a template file, adding an XML namespace
    for Thymeleaf tags to the otherwise plain HTML file and then using those tags
    as content injection guidance for the Thymeleaf template engine, as shown in the
    following *positions.html* file. To designate this as a template file for processing
    by the engine, I place it in the *src/main/resources/templates* project directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'For the aircraft position report page, I reduce the information displayed to
    a select few elements of particular importance and interest. There are a few items
    of note in the *positions.html* Thymeleaf template:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, as mentioned earlier, I add the Thymeleaf tags to the XML namespace
    with the *th* prefix with the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'When defining the `division` that will display the current aircraft positions,
    I direct that the positionList division should be shown only if data is present;
    if the `currentPositions` element within the `Model` is empty, simply omit the
    entire division:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Finally, I define a table using standard HTML table tags for the table itself
    and the header row and its contents. For the table body, I use Thymeleaf’s `each`
    to iterate through all `currentPositions` and populate each row’s columns using
    the Thymeleaf’s `text` tag and referencing each position object’s properties via
    the “${object.property}” variable expression syntax. With that, the application
    is ready for testing.
  prefs: []
  type: TYPE_NORMAL
- en: The results
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With the `PlaneFinder` service running, I execute the `Aircraft Positions` application
    from the IDE. Once it has successfully started, I open a browser tab and enter
    `localhost:8080` in the address bar and hit enter. [Figure 7-1](#the_aircraft_positions_application_very_simple_landing_page)
    shows the resultant page.
  prefs: []
  type: TYPE_NORMAL
- en: '![sbur 0701](Images/sbur_0701.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-1\. The Aircraft Positions application (very simple) landing page
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: From here, I click the *Click here* link to proceed to the Aircraft Position
    Report page, as shown in [Figure 7-1](#the_aircraft_positions_application_very_simple_landing_page).
  prefs: []
  type: TYPE_NORMAL
- en: '![sbur 0702](Images/sbur_0702.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-2\. The Aircraft Position Report Page
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Refreshing the page will requery `PlaneFinder` and update the report with current
    data on demand.
  prefs: []
  type: TYPE_NORMAL
- en: A refreshing flourish
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Being able to request a listing of aircraft currently in the area along with
    their exact positions is a useful thing. But having to manually refresh the page
    could also become quite tedious and result in missing data of great interest,
    if one is so disposed. To add a timed refresh function to the Aircraft Position
    Report template, simply add a JavaScript function to the page `body` similar to
    the following, specifying the page refresh rate in milliseconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The Thymeleaf template engine passes this code into the generated page untouched,
    and the user’s browser executes the script at the designated refresh rate. It
    isn’t the most elegant solution, but for simple use cases, it does the job.
  prefs: []
  type: TYPE_NORMAL
- en: Passing Messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When use cases are a bit more demanding, more sophisticated solutions may be
    required. The preceding code does provide dynamic updates reflecting the latest
    available position data, but among other potential concerns are that periodic
    requests for updated data can be somewhat chatty. If several clients are requesting
    and receiving updates constantly, network traffic can be substantial.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to fulfill more complex use cases while simultaneously addressing
    network demands, it’s helpful to shift perspectives: from a pull model to a push
    model, or some combination of the two.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This section and the next explore two different and incremental steps toward
    a push model, culminating in an *entirely* push-based model from the `PlaneFinder`
    service outward. Use cases will indicate (or dictate) conditions that may favor
    one of these approaches or something else entirely. I continue to explore and
    demonstrate additional alternatives in subsequent chapters, so stay tuned.
  prefs: []
  type: TYPE_NORMAL
- en: Messaging platforms were made to efficiently accept, route, and deliver messages
    between applications. Examples include [RabbitMQ](https://www.rabbitmq.com) and
    [Apache Kafka](https://kafka.apache.org) and numerous other offerings, both open
    source and commercial. Spring Boot and the Spring ecosystem provide a few different
    options for leveraging message pipelines, but my hands-down favorite is Spring
    Cloud Stream.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Cloud Stream elevates the level of abstraction for developers while still
    providing access to supported platforms’ unique attributes via application properties,
    beans, and direct configuration. Binders form the connection between streaming
    platform drivers and Spring Cloud Stream (SCSt), allowing developers to maintain
    focus on the key tasks—sending, routing, and receiving messages—which don’t differ
    in concept regardless of the underlying plumbing.
  prefs: []
  type: TYPE_NORMAL
- en: Powering Up PlaneFinder
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first order of business is to refactor the `PlaneFinder` service to use
    Spring Cloud Stream to publish messages for consumption by the `Aircraft Positions`
    (and any other applicable) application.
  prefs: []
  type: TYPE_NORMAL
- en: Required dependencies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'I add the following dependencies to `PlaneFinder` ’s *pom.xml* Maven build
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing to note is actually the second dependency listed: `spring-cloud-stream`.
    This is the code dependency for Spring Cloud Stream, but it can’t do the job alone.
    As mentioned, SCSt uses binders to enable its powerful abstraction to work with
    various streaming platforms’ drivers seamlessly. There is even a helpful reminder
    on the Spring Cloud Stream entry accessible from the Spring Initializr to that
    effect:'
  prefs: []
  type: TYPE_NORMAL
- en: Framework for building highly scalable event-driven microservices connected
    with shared messaging systems (requires a binder, e.g., Apache Kafka, RabbitMQ,
    or Solace PubSub+)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: For Spring Cloud Stream to work with a messaging platform, it requires a messaging
    platform driver and the binder that works with it. In the preceding example, I
    include a binder+driver combination for RabbitMQ *and* for Apache Kafka.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If only one binder+driver combination is included—for RabbitMQ, for example—Spring
    Boot’s autoconfiguration can unambiguously determine that your application should
    support communication with RabbitMQ instance(s) and associated `exchanges` and
    `queues` and create the appropriate supporting beans with no additional effort
    required on the developer’s part. Including more than one set of binders+drivers
    requires us to specify which one to use, but it also allows us to dynamically
    switch among all included platforms at runtime, with no change to the tested and
    deployed application. This is an extremely powerful and useful capability.
  prefs: []
  type: TYPE_NORMAL
- en: 'Two more additions to the *pom.xml* file are necessary. First is to indicate
    the project-level version of Spring Cloud to use by adding this line to the `<properties></properties>`
    section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Second is to provide guidance on the Spring Cloud Bill of Materials (BOM),
    from which the build system can determine versions for any Spring Cloud components—in
    this case, Spring Cloud Stream—that are used in this project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Versions of Spring component projects are updated frequently. An easy way to
    determine correct, synchronized versions tested with the current version of Spring
    Boot is to use the Spring Initializr. Selecting the desired dependencies and clicking
    the button to "*Explore CTRL+SPACE*" displays the build file with the appropriate
    elements and versions.
  prefs: []
  type: TYPE_NORMAL
- en: After refreshing the project’s dependencies, it’s on to the code.
  prefs: []
  type: TYPE_NORMAL
- en: Supplying aircraft positions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Due to `PlaneFinder` ’s existing structure and Spring Cloud Stream’s clean,
    functional approach, only one small class is required to publish current aircraft
    positions to RabbitMQ for consumption by other applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Since each poll by `PlaneFinder` of the upstream radio device produces a listing
    of positions of aircraft currently within range, the `PlaneFinder` service creates
    a message consisting of 1+ aircraft in an `Iterable<Aircraft>` by calling the
    `PlaneFinderService` `getAircraft()` method. An opinion—that a `Supplier` is called
    once per second by default (overridable via application property)—and some required/optional
    application properties inform Spring Boot’s autoconfiguration and set things in
    motion.
  prefs: []
  type: TYPE_NORMAL
- en: Application properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Only one property is required, although others are helpful. Here are the contents
    of the updated `PlaneFinder` ’s *application.properties* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `server.port` remains from the first version and indicates the application
    should listen on port 7634.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Cloud Stream’s functional API relies on minimal property configuration
    when necessary (as a baseline) to enable its functionality. A `Supplier` has only
    output channels, as it produces only messages. A `Consumer` has only input channels,
    as it consumes only messages. A `Function` has both input and output channels,
    which are necessary due to its use in transforming one thing to another.
  prefs: []
  type: TYPE_NORMAL
- en: Each binding uses the interface (`Supplier`, `Function`, or `Consumer`) bean
    method’s name for the channel name, along with `in` or `out` and a channel number
    from `0` to `7`. Once concatenated in the form `<method>-<in|out>-n`, binding
    properties can be defined for the channel.
  prefs: []
  type: TYPE_NORMAL
- en: The only property required for this use case is `destination`, and even that
    is for convenience. Specifying the `destination` name results in RabbitMQ creating
    an exchange named `aircraftpositions` (in this example).
  prefs: []
  type: TYPE_NORMAL
- en: Since I included binders and drivers for both RabbitMQ and Kafka in the project
    dependencies, I must specify which binder the application should use. For this
    example, I choose `rabbit`.
  prefs: []
  type: TYPE_NORMAL
- en: With all required and desired application properties defined, `PlaneFinder`
    is ready to publish current aircraft positions each second to RabbitMQ for consumption
    by any applications desiring to do so.
  prefs: []
  type: TYPE_NORMAL
- en: Extending the Aircraft Positions Application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Converting `Aircraft Positions` to consume messages from a RabbitMQ pipeline
    using Spring Cloud Stream is similarly straightforward. Only a few changes to
    the workings behind the scenes are necessary to replace frequent HTTP requests
    with a message-driven architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Required dependencies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Just as with `PlaneFinder`, I add the following dependencies to the `Aircraft
    Positions` application’s *pom.xml*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As previously mentioned, I include binders and drivers for both RabbitMQ and
    Kafka for planned future use, but only the RabbitMQ set—`spring-boot-starter-amqp`
    and `spring-cloud-stream-binder-rabbit`—are required for the current use case
    in order for Spring Cloud Stream (`spring-cloud-stream`) to use RabbitMQ.
  prefs: []
  type: TYPE_NORMAL
- en: 'I also add the two additional required entries to *pom.xml*. First, this goes
    into the `<properties></properties>` section, with the `java.version`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Second is the Spring Cloud BOM information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: A quick refresh of the project’s dependencies and we’re on to the next step.
  prefs: []
  type: TYPE_NORMAL
- en: Consuming aircraft positions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to retrieve and store messages listing current aircraft positions,
    only one small additional class is required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Like its `PositionReporter` counterpart in `PlaneFinder`, the `PositionRetriever`
    class is an `@Configuration` class in which I define a bean for use with Spring
    Cloud Stream: in this case, a `Consumer` of messages, each consisting of a `List`
    of one or more `Aircraft`. With each incoming message, the `Consumer` bean deletes
    all positions in the (in-memory) datastore, saves all incoming positions, and
    then prints all stored positions to the console for verification. Note that the
    last statement printing all positions to the console is optional; it’s included
    only for confirmation as I develop the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Application properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to provide the application the few remaining bits of information necessary
    to connect to the incoming stream of messages, I add the following entries to
    the *application.properties* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'As with `PlaneFinder`, the channel is defined by concatenating the following,
    separated by a hyphen (-):'
  prefs: []
  type: TYPE_NORMAL
- en: The bean name, in this case, a `Consumer<T>` bean
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`in`, since consumers only consume and thus have only input(s)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A number between `0` and `7` inclusive, supporting up to eight inputs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `destination` and `binder` properties match those of `PlaneFinder` because
    the `Aircraft Positions` application must point to the same destination as input
    that `PlaneFinder` used as output and because to do so, both must be using the
    same messaging platform—in this case, RabbitMQ. The `group` property is new, though.
  prefs: []
  type: TYPE_NORMAL
- en: For any kind of `Consumer` (including the receiving portion of a `Function<T,
    R>`), one can specify a `group`, but it isn’t required; in fact, including or
    omitting `group` forms a starting point for a particular routing pattern.
  prefs: []
  type: TYPE_NORMAL
- en: If a message-consuming application doesn’t specify a group, the RabbitMQ binder
    creates a randomized unique name and assigns it, and the consumer, to an auto-delete
    queue within the RabbitMQ instance or cluster. This results in each generated
    queue being serviced by one—and only one—consumer. Why is this important?
  prefs: []
  type: TYPE_NORMAL
- en: Whenever a message arrives at a RabbitMQ exchange, a copy is routed automatically
    to all queues assigned to that exchange by default. If an exchange has multiple
    queues, the same message is sent to every queue in what’s referred to as a *fan-out
    pattern*, a useful capability when each message must be delivered to numerous
    destinations to satisfy various requirements.
  prefs: []
  type: TYPE_NORMAL
- en: If an application specifies a consumer group to which it belongs, that group
    name is used to name the underlying queue within RabbitMQ. When multiple applications
    specify the same `group` property and thus connect to the same queue, together
    those applications fulfill the competing consumer pattern in which each message
    arriving in the designated queue is processed by only one of the consumers. This
    allows the number of consumers to scale to accommodate varying volumes of messages.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: It is also possible to employ partitioning and routing keys for even finer-grained
    and flexible routing options, if needed.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying the `group` property for this application enables scaling, should
    multiple instances be needed to keep pace with the flow of arriving messages.
  prefs: []
  type: TYPE_NORMAL
- en: Contacting the Controller
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since the `Consumer` bean automatically checks for and processes messages automatically,
    the `PositionController` class and its `getCurrentAircraftPositions()` method
    become dramatically leaner.
  prefs: []
  type: TYPE_NORMAL
- en: 'All references to `WebClient` can be removed, since getting a list of current
    positions is now only a matter of retrieving the current contents of the repository.
    The streamlined class now looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: With that, all changes to both message-producer (the `PlaneFinder` app) and
    message-consumer (the `Aircraft Positions` app) are now complete.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In order to use any external messaging platform, said platform must be running
    and accessible to the applications. I run a local instance of RabbitMQ using Docker;
    scripts for quick creation and startup/shutdown are provided in this book’s associated
    repositories.
  prefs: []
  type: TYPE_NORMAL
- en: The results
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After verifying that RabbitMQ is accessible, it’s time to start the applications
    and verify everything works as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Although it isn’t a requirement to do so, I prefer to start the message-consuming
    application first so it’s ready and waiting for messages to arrive. In this case,
    that means executing `Aircraft Positions` from my IDE.
  prefs: []
  type: TYPE_NORMAL
- en: Next, I start up the new and improved `PlaneFinder` application. This initiates
    the flow of messages to the `Aircraft Positions` application, as shown in the
    `Aircraft Positions` app’s console. That’s gratifying, but we can follow this
    path of success all the way to the end user as well.
  prefs: []
  type: TYPE_NORMAL
- en: Returning to the browser and accessing *localhost:8080*, we’re presented with
    the landing page once again, and opting to *Click here*, are taken to the Positions
    Report. As before, the Positions Report is refreshed automatically and displays
    current aircraft positions; now however, those positions are pushed independently
    from `PlaneFinder` behind the scenes to the `Aircraft Positions` application,
    without first receiving an HTTP request for them, which brings the architecture
    one step closer to a fully event-driven system.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Conversations with WebSocket
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In its first iteration, the distributed system we created to query and display
    current aircraft positions was entirely pull-based. A user requested (or re-requested
    with a refresh) the latest positions from the browser, which passed the request
    to the `Aircraft Positions` application, which in turn relayed the request to
    the `PlaneFinder` application. Responses then were returned from one to the next,
    to the next. The last chapter segment replaced the midsection of our distributed
    system with an event-driven architecture. Now whenever `PlaneFinder` retrieves
    positions from the upstream radio device, it pushes those positions to a streaming
    platform pipeline and the `Aircraft Positions` app consumes them. The last mile
    (or kilometer, if you prefer) is still pull-based, however; updates must be requested
    via browser refresh, either manually or automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Standard request-response semantics work brilliantly for numerous use cases,
    but they largely lack the ability for the responding “server” side to, independent
    of any request, initiate a transmission to the requestor. There are various workarounds
    and clever ways to satisfy this use case—each of which has its own pros and cons,
    and some of the best of which I discuss in subsequent chapters—but one of the
    more versatile options is WebSocket.
  prefs: []
  type: TYPE_NORMAL
- en: What Is WebSocket?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a nutshell, WebSocket is a full-duplex communications protocol that connects
    two systems over a single TCP connection. Once a WebSocket connection is established,
    either party can initiate a transmission to the other, and the designated server
    application can maintain numerous client connections, enabling low-overhead broadcast
    and chat types of systems. WebSocket connections are forged from standard HTTP
    connections using the HTTP upgrade header, and once the handshake is complete,
    the protocol used for the connection shifts from HTTP to WebSocket.
  prefs: []
  type: TYPE_NORMAL
- en: WebSocket was standardized by the IETF in 2011, and by now every major browser
    and programming language supports it. Compared to HTTP requests and responses,
    WebSocket is extremely low overhead; transmissions don’t have to identify themselves
    and the terms of their communication with each transmission, thus reducing WebSocket
    framing to a few bytes. With its full-duplex capabilities, the ability of a server
    to handle a multiple of the number of open connections other options can support,
    and its low overhead, WebSocket is a useful tool for developers to have in their
    toolbox.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring the Aircraft Positions Application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Although I refer to the `Aircraft Positions` application as a single unit,
    the *aircraft-positions* project comprises both the backend Spring Boot+Java application
    and the frontend HTML+JavaScript functionality. During development, both portions
    execute in a single environment, usually the developer’s machine. While they are
    built, tested, and deployed as a single unit to production settings as well, execution
    in production settings is divided as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Backend Spring+Java code is run in the cloud, including the template engine
    (if applicable) that generates final webpages to deliver to the end user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Frontend HTML+JavaScript—static and/or generated content—is displayed and run
    in the end user’s browser, wherever that browser may be located.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, I leave existing functionality intact and add the ability to
    the system to automatically display aircraft positions as they are reported via
    a live feed. With a WebSocket connection in place between frontend and backend
    applications, the backend app is free to push updates to the end user’s browser
    and update the display automatically, with no need to trigger a page refresh.
  prefs: []
  type: TYPE_NORMAL
- en: Additional dependencies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To add WebSocket capabilities to the `Aircraft Positions` application, I need
    add only a single dependency to its *pom.xml*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: A quick refresh of the project’s dependencies and we’re on to the next step.
  prefs: []
  type: TYPE_NORMAL
- en: Handling WebSocket connections and messages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Spring offers a couple of different approaches for configuring and using WebSocket,
    but I recommend following the clean lines of a direct implementation based on
    the `WebSocketHandler` interface. Owing to the frequency of requirements for exchanging
    text-based, i.e., nonbinary, information, there is even a `TextWebSocketHandler`
    class. I build on that here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code implements two of the `WebSocketHandler` interface’s methods,
    `afterConnectionEstablished` and `afterConnectionClosed`, to maintain a `List`
    of active `WebSocketSession` and `log connections` and `disconnections`. I also
    implement `handleTextMessage`, broadcasting any incoming message to all other
    active sessions. This single class provides the WebSocket capability for the backend,
    ready to be activated when aircraft positions are received from `PlaneFinder`
    via RabbitMQ.
  prefs: []
  type: TYPE_NORMAL
- en: Broadcasting aircraft positions to WebSocket connections
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In its previous iteration, the `PositionRetriever` class consumed aircraft
    position lists received via RabbitMQ messages and stored them in the in-memory
    H2 database. I build on that now by replacing the logging confirmation `System.out::println`
    call with a call to a new `sendPositions()` method, whose purpose is to use the
    newly added `@Autowired` `WebSocketHandler` bean to send the latest list of aircraft
    positions to all WebSocket-connected clients:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have WebSocket configured properly and have a way for the backend
    to broadcast aircraft positions to connected WebSocket clients as soon as a new
    position list is received, the next step is to provide a way for the backend application
    to listen for and accept connection requests. This is accomplished by registering
    the `WebSocketHandler` created earlier via the `WebSocketConfigurer` interface
    and annotating the new `@Configuration` class with `@EnableWebSocket` to direct
    the application to process WebSocket requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In the `registerWebSocketHandlers(WebSocketHandlerRegistry registry)` method,
    I tie the `WebSocketHandler` bean created earlier to the endpoint *ws://<hostname:hostport>/ws*.
    The application will listen on this endpoint for HTTP requests with WebSocket
    upgrade headers and act accordingly when one is received.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If HTTPS is enabled for your application, *wss://* (WebSocket Secure) would
    be used in place of *ws://*.
  prefs: []
  type: TYPE_NORMAL
- en: WebSocket in back, WebSocket in front
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With the backend work done, it’s time to collect the payoff in the frontend
    functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a simple example of how WebSocket enables the backend app to push
    updates unprompted by the user and their browser, I create the following file
    with a single HTML division and label and a few lines of JavaScript and place
    it in the project’s *src/main/resources/static* directory along with the existing
    *index.html*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'As short as this page is, it could be shorter. The `socket.onopen` and `socket.onclose`
    function definitions are logging functions that could be omitted, and `socket.onmessage`
    could almost certainly be refactored by someone with actual JavaScript chops and
    the desire to do so. These are the key bits:'
  prefs: []
  type: TYPE_NORMAL
- en: The defined division and label in the HTML at bottom
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `socket` variable that establishes and references a WebSocket connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `socket.onmessage` function that parses the aircraft position list and assigns
    the reformatted output to the HTML “positions” label’s `innerText`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once we rebuild and execute the project, it is of course possible to simply
    access the *wspositions.html* page directly from the browser. This is a poor way
    to create an application for actual users, though—providing no way to access a
    page and its functionality unless they know its location and enter it manually
    into the address bar—and it does nothing to set the table for upcoming chapters’
    expansions to this example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Keeping it simple for the time being, I add another line to the existing *index.html*
    to allow the user to navigate to the *wspositions.html* WebSocket-driven page
    in addition to the existing one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: With frontend work now complete, it’s time to test the WebSocket waters.
  prefs: []
  type: TYPE_NORMAL
- en: The results
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: From the IDE, I launch the `Aircraft Positions` application and `PlaneFinder`.
    Opening a browser window, I access the frontend application at *localhost:8080*,
    as shown in [Figure 7-3](#aircraft_positions_landing_page_now_with_two_options).
  prefs: []
  type: TYPE_NORMAL
- en: '![sbur 0703](Images/sbur_0703.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-3\. Aircraft Positions landing page, now with two options
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: From the still rather rudimentary landing page, choosing the second option—*Click
    here* to retrieve a livestream of current aircraft positions in range of receiver—produces
    the *wspositions.html* page and results similar to those shown in [Figure 7-4](#aircraft_position_report_with_live_updates_via_websocket).
  prefs: []
  type: TYPE_NORMAL
- en: '![sbur 0704](Images/sbur_0704.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-4\. Aircraft Position report with live updates via WebSocket
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: It’s a trivial exercise to convert the database record format shown with JSON,
    and just a bit more involved to dynamically populate a table with results received
    live from the backend application via WebSocket. Please refer to this book’s code
    repositories for examples.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: It’s perfectly fine to build and run both the `PlaneFinder` and `Aircraft Positions`
    applications from the command line; while I do so on occasion, for most build/run
    cycles, I find it much faster to run (and debug) directly from within the IDE.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nearly every application must interact with end users or other applications
    in some manner to provide real utility, and that requires useful and efficient
    means of interaction.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter introduced view technologies—template languages/tags like Thymeleaf
    and engines that process them—and how Spring Boot uses them to create and deliver
    functionality to an end user’s browser. Also introduced was how Spring Boot handles
    static content like standard HTML along with JavaScript that can be delivered
    directly without processing by template engines. The chapter’s first project iteration
    showed examples of both with a Thymeleaf-driven application that retrieved and
    displayed aircraft positions within range at the time of the request, an entirely
    pull-based model.
  prefs: []
  type: TYPE_NORMAL
- en: The chapter next showed how to harness the power of messaging platforms from
    Spring Boot using Spring Cloud Stream and RabbitMQ. The `PlaneFinder` application
    was refactored to push a list of current aircraft positions, each time retrieved
    from the upstream device, and the `Aircraft Positions` app was modified to accept
    new aircraft position listings as they arrived via the RabbitMQ pipeline. This
    replaced the pull-based model between the two applications with a push-based one,
    making the backend functionality of the `Aircraft Positions` app event-driven.
    The front end functionality still required a refresh (either manual or hard-coded)
    to update results shown to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, implementing a WebSocket connection and handler code within backend
    and frontend components of the `Aircraft Positions` application enabled the Spring+Java
    backend app to push aircraft position updates *as they are received* via a RabbitMQ
    pipeline from `PlaneFinder`. Position updates are shown live in a simple HTML+JavaScript
    page and require no update requests be issued by the end user or their browser,
    showcasing WebSocket’s bidirectional nature, lack of required request-response
    pattern (or workaround), and low communication overhead.
  prefs: []
  type: TYPE_NORMAL
- en: Code Checkout Checkup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For complete chapter code, please check out branch *chapter7end* from the code
    repository.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter introduces reactive programming and describes how Spring is
    leading the development and advancement of numerous tools and technologies that
    make it one of the best possible solutions for numerous use cases. More specifically,
    I’ll demonstrate how to use Spring Boot and Project Reactor to drive database
    access, integrate reactive types with view technologies like Thymeleaf, and take
    interprocess communication to unexpected new levels.
  prefs: []
  type: TYPE_NORMAL
