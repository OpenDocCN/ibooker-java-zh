- en: Chapter 7\. Creating Applications Using Spring MVC
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter demonstrates how to create Spring Boot applications using Spring
    MVC with REST interactions, messaging platforms, and other communications mechanisms
    and provides an introduction to templating language support. Although I introduced
    interservice interactions as part of last chapter’s dive into Spring Boot’s many
    options for handling data, this chapter shifts the primary focus from the application
    itself to the outside world: its interactions with other applications and/or services
    and with end users.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Code Checkout Checkup
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Please check out branch *chapter7begin* from the code repository to begin.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring MVC: What Does It Mean?'
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Like many other things in technology, the term *Spring MVC* is somewhat overloaded.
    When someone refers to Spring MVC, they could mean any of the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Implementing (in some manner) the Model-View-Controller pattern in a Spring
    application
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an application specifically using Spring MVC component concepts like
    the `Model` interface, `@Controller` classes, and view technologies
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing blocking/nonreactive applications using Spring
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Depending on context, Spring MVC can be considered both an approach and an implementation.
    It can also be used within or without Spring Boot. Generic application of the
    MVC pattern using Spring and Spring MVC use outside of Spring Boot both fall outside
    the scope of this book. I’ll focus specifically on the final two concepts previously
    listed using Spring Boot to implement them.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: End User Interactions Using Template Engines
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While Spring Boot applications handle a lot of heavy-lifting chores on the backend,
    Boot also supports direct end-user interactions as well. Although long-established
    standards like Java Server Pages (JSP) are still supported by Boot for legacy
    applications, most current applications either leverage more powerful view technologies
    supported by still-evolving and -maintained template engines or shift frontend
    development to a combination of HTML and JavaScript. It’s even possible to mix
    the two options successfully and play to each one’s strengths.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Spring Boot works well with HTML and JavaScript frontends, as I demonstrate
    later in this chapter. For now, let’s take a closer look at template engines.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 'Template engines provide a way for a so-called server-side application to generate
    the final pages that will be displayed and executed in the end user’s browser.
    These view technologies differ in approaches but generally provide the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: A template language and/or collection of tags that define inputs used by the
    template engine to produce the expected outcome
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A view resolver that determines the view/template to use to fulfill a requested
    resource
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Among other lesser-used options, Spring Boot supports view technologies such
    as [Thymeleaf](https://www.thymeleaf.org), [FreeMarker](https://freemarker.apache.org),
    [Groovy Markup](http://groovy-lang.org/templating.html), and [Mustache](https://mustache.github.io).
    Thymeleaf is perhaps the most widely used of these for several reasons and provides
    excellent support for both Spring MVC and Spring WebFlux applications.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 除了其他不常用的选项外，Spring Boot还支持视图技术，如[Thymeleaf](https://www.thymeleaf.org)，[FreeMarker](https://freemarker.apache.org)，[Groovy
    Markup](http://groovy-lang.org/templating.html)和[Mustache](https://mustache.github.io)。Thymeleaf可能是其中使用最广泛的，有几个原因，并为Spring
    MVC和Spring WebFlux应用程序提供了出色的支持。
- en: 'Thymeleaf uses natural templates: files that incorporate code elements but
    that can be opened and viewed directly (and correctly) in any standard web browser.
    Being able to view the template files as HTML enables developers or designers
    to create and evolve Thymeleaf templates without any running server processes.
    Any code integrations that expect corresponding server-side elements are tagged
    as Thymeleaf-specific and simply don’t display what isn’t present.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Thymeleaf使用自然模板：这些文件包含代码元素，但可以直接（并且正确地）在任何标准Web浏览器中打开和查看。能够将模板文件视为HTML文件使得开发人员或设计人员可以在没有运行服务器进程的情况下创建和演变Thymeleaf模板。任何期望对应的服务器端元素的代码集成都被标记为Thymeleaf特定的，并且只显示存在的内容。
- en: Building on previous efforts, let’s build a simple web application using Spring
    Boot, Spring MVC, and Thymeleaf to present to the end user an interface for querying
    PlaneFinder for current aircraft positions and displaying the results. Initially
    this will be a rudimentary proof of concept to be evolved in subsequent chapters.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的努力基础上，让我们使用Spring Boot、Spring MVC和Thymeleaf构建一个简单的Web应用程序，向最终用户展示一个界面，用于查询PlaneFinder的当前飞机位置并显示结果。最初，这将是一个基础的概念验证，后续章节将进一步完善。
- en: Initializing the Project
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化项目
- en: 'To begin, we return to the Spring Initializr. From there, I choose the following
    options:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们回到Spring Initializr。从那里，我选择以下选项：
- en: Maven project
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Maven项目
- en: Java
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java
- en: Current production version of Spring Boot
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前生产版本的Spring Boot
- en: 'Packaging: Jar'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打包方式：Jar
- en: 'Java: 11'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java：11
- en: 'And for dependencies:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖项如下：
- en: Spring Web (`spring-boot-starter-web`)
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Web (`spring-boot-starter-web`)
- en: Spring Reactive Web (`spring-boot-starter-webflux`)
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Reactive Web (`spring-boot-starter-webflux`)
- en: Thymeleaf (`spring-boot-starter-thymeleaf`)
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Thymeleaf (`spring-boot-starter-thymeleaf`)
- en: Spring Data JPA (`spring-boot-starter-data-jpa`)
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Data JPA (`spring-boot-starter-data-jpa`)
- en: H2 Database (`h2`)
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: H2数据库 (`h2`)
- en: Lombok (`lombok`)
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lombok (`lombok`)
- en: The next step is to generate the project and save it locally, unzip it, and
    open it in the IDE.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是生成项目并将其保存到本地，解压缩并在IDE中打开它。
- en: Developing the Aircraft Positions Application
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发飞机位置应用程序
- en: Since this application is concerned only with the current state—aircraft positions
    at the moment the request is made, not historically—an in-memory database seems
    a reasonable choice. One could instead use an `Iterable` of some kind, of course,
    but Spring Boot’s support for Spring Data repositories and the H2 database fulfill
    the current use case and position the application well for planned future expansion.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此应用程序仅涉及当前状态——即在发出请求时的飞机位置，而非历史记录，因此选择使用内存数据库似乎是一个合理的选择。当然，也可以使用某种`Iterable`，但是Spring
    Boot对Spring Data存储库和H2数据库的支持可以满足当前的使用案例，并为计划中的未来扩展奠定基础。
- en: Defining the domain class
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义领域类
- en: 'As with other projects interacting with `PlaneFinder`, I create an `Aircraft`
    domain class to serve as the primary (data) focus. Here is the `Aircraft` domain
    class structure for the `Aircraft Positions` application:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他与`PlaneFinder`交互的项目一样，我创建了一个`Aircraft`领域类作为主要的（数据）焦点。以下是`Aircraft Positions`应用程序的`Aircraft`领域类结构：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This domain class is defined using JPA with H2 as the underlying JPA-compliant
    database and leveraging Lombok to create a data class with constructors having
    zero arguments and all arguments, one for every member variable.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 此领域类使用JPA定义，以H2作为底层符合JPA标准的数据库，并利用Lombok创建数据类，其中构造函数具有零参数和所有参数，每个成员变量都有一个。
- en: Creating the repository interface
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建存储库接口
- en: 'Next, I define the required repository interface, extending Spring Data’s `CrudRepository`
    and providing the type of object to store and its key: `Aircraft` and `Long`,
    in this case:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我定义所需的存储库接口，扩展Spring Data的`CrudRepository`，并提供要存储的对象类型及其键：在这种情况下是`Aircraft`和`Long`：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Working with Model and Controller
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用模型和控制器处理工作
- en: I’ve defined the data behind the model with the `Aircraft` domain class; now
    it’s time to incorporate it into the `Model` and expose it via a `Controller`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: As discussed in [Chapter 3](ch03.xhtml#sbur-03), `@RestController` is a convenience
    notation that combines `@Controller` with `@ResponseBody` into a single descriptive
    annotation, returning a formatted response as JavaScript Object Notation (JSON)
    or as other data-oriented format. This results in the Object/Iterable return value
    of a method being the *entire body* of the response to a web request, instead
    of being returned as a part of the `Model`. An `@RestController` enables the creation
    of an API, a specialized, but very common, use case.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: The goal now is to create an application that also includes a user interface,
    and `@Controller` enables that. Within an `@Controller` class, each method annotated
    with `@RequestMapping` or one of its specialized aliases like `@GetMapping` will
    return a `String` value that corresponds to the name of a template file minus
    its extension. For example, Thymeleaf files have the *.html* file extension, so
    if an `@Controller` class’s `@GetMapping` method returns the `String` “myfavoritepage”,
    the Thymeleaf template engine will use the *myfavoritepage.html* template to create
    and return the generated page to the user’s browser.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-47
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: View technology templates are placed under the project’s *src/main/resources/templates*
    directory by default; the template engine will look here for them unless overridden
    via application properties or programmatic means.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 'Returning to the controller, I create a class `PositionController` as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This controller looks very similar to previous iterations but with a few key
    differences. First, of course, is the `@Controller` annotation previously discussed
    instead of `@RestController`. Second is that the `getCurrentAircraftPositions()`
    method has an automatically autowired parameter: `Model model`. This parameter
    is the `Model` bean that is leveraged by the template engine to provide access
    to the application’s components—their data and operations—once we add those components
    to the `Model` as an attribute. And third is the method’s return type of `String`
    instead of a class type and the actual return statement with the name of a template
    (sans *.html* extension).'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-52
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In a complex domain/application, I prefer to separate concerns a bit more by
    creating distinct `@Service` and `@Controller` classes. In this example, there
    is a single method making a single repository access, so I’ve placed all functionality
    to populate the underlying data, populate the `Model`, and hand it off to the
    appropriate `View` within the `Controller`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Creating the requisite View files
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As a basic foundation for this and future chapters, I create one plain HTML
    file and one template file.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: 'Since I want to display a plain HTML page to all visitors, and since this page
    requires no template support, I place *index.html* directly in the project’s *src/main/resources/static*
    directory:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'For the dynamic content, I create a template file, adding an XML namespace
    for Thymeleaf tags to the otherwise plain HTML file and then using those tags
    as content injection guidance for the Thymeleaf template engine, as shown in the
    following *positions.html* file. To designate this as a template file for processing
    by the engine, I place it in the *src/main/resources/templates* project directory:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'For the aircraft position report page, I reduce the information displayed to
    a select few elements of particular importance and interest. There are a few items
    of note in the *positions.html* Thymeleaf template:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'First, as mentioned earlier, I add the Thymeleaf tags to the XML namespace
    with the *th* prefix with the following line:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When defining the `division` that will display the current aircraft positions,
    I direct that the positionList division should be shown only if data is present;
    if the `currentPositions` element within the `Model` is empty, simply omit the
    entire division:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Finally, I define a table using standard HTML table tags for the table itself
    and the header row and its contents. For the table body, I use Thymeleaf’s `each`
    to iterate through all `currentPositions` and populate each row’s columns using
    the Thymeleaf’s `text` tag and referencing each position object’s properties via
    the “${object.property}” variable expression syntax. With that, the application
    is ready for testing.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: The results
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With the `PlaneFinder` service running, I execute the `Aircraft Positions` application
    from the IDE. Once it has successfully started, I open a browser tab and enter
    `localhost:8080` in the address bar and hit enter. [Figure 7-1](#the_aircraft_positions_application_very_simple_landing_page)
    shows the resultant page.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '![sbur 0701](Images/sbur_0701.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
- en: Figure 7-1\. The Aircraft Positions application (very simple) landing page
  id: totrans-69
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: From here, I click the *Click here* link to proceed to the Aircraft Position
    Report page, as shown in [Figure 7-1](#the_aircraft_positions_application_very_simple_landing_page).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '![sbur 0702](Images/sbur_0702.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
- en: Figure 7-2\. The Aircraft Position Report Page
  id: totrans-72
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Refreshing the page will requery `PlaneFinder` and update the report with current
    data on demand.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: A refreshing flourish
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Being able to request a listing of aircraft currently in the area along with
    their exact positions is a useful thing. But having to manually refresh the page
    could also become quite tedious and result in missing data of great interest,
    if one is so disposed. To add a timed refresh function to the Aircraft Position
    Report template, simply add a JavaScript function to the page `body` similar to
    the following, specifying the page refresh rate in milliseconds:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The Thymeleaf template engine passes this code into the generated page untouched,
    and the user’s browser executes the script at the designated refresh rate. It
    isn’t the most elegant solution, but for simple use cases, it does the job.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Thymeleaf模板引擎将此代码不加修改地传递到生成的页面，并且用户的浏览器以指定的刷新率执行脚本。这并不是最优雅的解决方案，但对于简单的用例，它能够胜任。
- en: Passing Messages
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传递消息
- en: When use cases are a bit more demanding, more sophisticated solutions may be
    required. The preceding code does provide dynamic updates reflecting the latest
    available position data, but among other potential concerns are that periodic
    requests for updated data can be somewhat chatty. If several clients are requesting
    and receiving updates constantly, network traffic can be substantial.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当用例要求更加严格时，可能需要更复杂的解决方案。前面的代码确实提供了反映最新可用位置数据的动态更新，但其中可能存在的其他问题包括定期请求更新数据可能会有些啰嗦。如果几个客户端不断地请求和接收更新，网络流量可能会相当大。
- en: 'In order to fulfill more complex use cases while simultaneously addressing
    network demands, it’s helpful to shift perspectives: from a pull model to a push
    model, or some combination of the two.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了同时满足更复杂的用例并解决网络需求，有助于改变视角：从拉模型转换为推模型，或两者的某种组合。
- en: Note
  id: totrans-81
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: This section and the next explore two different and incremental steps toward
    a push model, culminating in an *entirely* push-based model from the `PlaneFinder`
    service outward. Use cases will indicate (or dictate) conditions that may favor
    one of these approaches or something else entirely. I continue to explore and
    demonstrate additional alternatives in subsequent chapters, so stay tuned.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 本节和接下来的内容探讨了向推送模型迈出的两个不同而逐步的步骤，最终从`PlaneFinder`服务向外推进到一个*完全*的基于推送的模型。用例将指出（或规定）可能支持其中一种方法或完全不同的其他方法的条件。我将继续在随后的章节中探索和展示额外的替代方案，敬请关注。
- en: Messaging platforms were made to efficiently accept, route, and deliver messages
    between applications. Examples include [RabbitMQ](https://www.rabbitmq.com) and
    [Apache Kafka](https://kafka.apache.org) and numerous other offerings, both open
    source and commercial. Spring Boot and the Spring ecosystem provide a few different
    options for leveraging message pipelines, but my hands-down favorite is Spring
    Cloud Stream.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 消息平台旨在有效地接受、路由和传递应用程序之间的消息。示例包括[RabbitMQ](https://www.rabbitmq.com)和[Apache
    Kafka](https://kafka.apache.org)以及许多其他提供的产品，无论是开源的还是商业的。Spring Boot和Spring生态系统提供了几种不同的选项来利用消息管道，但我最喜欢的是Spring
    Cloud Stream。
- en: Spring Cloud Stream elevates the level of abstraction for developers while still
    providing access to supported platforms’ unique attributes via application properties,
    beans, and direct configuration. Binders form the connection between streaming
    platform drivers and Spring Cloud Stream (SCSt), allowing developers to maintain
    focus on the key tasks—sending, routing, and receiving messages—which don’t differ
    in concept regardless of the underlying plumbing.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Stream提升了开发者的抽象级别，同时通过应用程序属性、bean和直接配置提供对支持的平台独特属性的访问。绑定器形成了流平台驱动程序与Spring
    Cloud Stream（SCSt）之间的连接，使开发人员能够专注于关键任务——发送、路由和接收消息——这些任务的概念不管底层管道如何都不会有所不同。
- en: Powering Up PlaneFinder
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提升PlaneFinder的能力
- en: The first order of business is to refactor the `PlaneFinder` service to use
    Spring Cloud Stream to publish messages for consumption by the `Aircraft Positions`
    (and any other applicable) application.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 首要任务是重构`PlaneFinder`服务，使用Spring Cloud Stream发布消息，供`Aircraft Positions`（以及任何其他适用的）应用程序使用。
- en: Required dependencies
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 必需的依赖项
- en: 'I add the following dependencies to `PlaneFinder` ’s *pom.xml* Maven build
    file:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我将以下依赖项添加到`PlaneFinder`的*pom.xml* Maven构建文件中：
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The first thing to note is actually the second dependency listed: `spring-cloud-stream`.
    This is the code dependency for Spring Cloud Stream, but it can’t do the job alone.
    As mentioned, SCSt uses binders to enable its powerful abstraction to work with
    various streaming platforms’ drivers seamlessly. There is even a helpful reminder
    on the Spring Cloud Stream entry accessible from the Spring Initializr to that
    effect:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的第二个依赖项实际上是第二个列出的依赖项：`spring-cloud-stream`。这是Spring Cloud Stream的代码依赖，但它不能单独完成任务。如前所述，SCSt使用绑定器无缝地启用其强大的抽象与各种流平台驱动程序的工作。甚至从Spring
    Initializr访问的Spring Cloud Stream入口处也有一个有用的提醒，以此作为提示：
- en: Framework for building highly scalable event-driven microservices connected
    with shared messaging systems (requires a binder, e.g., Apache Kafka, RabbitMQ,
    or Solace PubSub+)
  id: totrans-91
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 用于构建与共享消息系统连接的高度可伸缩的事件驱动微服务框架（需要绑定器，例如 Apache Kafka、RabbitMQ 或 Solace PubSub+）
- en: For Spring Cloud Stream to work with a messaging platform, it requires a messaging
    platform driver and the binder that works with it. In the preceding example, I
    include a binder+driver combination for RabbitMQ *and* for Apache Kafka.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要使 Spring Cloud Stream 与消息平台配合工作，它需要一个消息平台驱动程序和与之配套的 binder。在前面的示例中，我包含了一个 RabbitMQ
    的 binder+driver 组合 *和* 一个 Apache Kafka 的 binder+driver 组合。
- en: Tip
  id: totrans-93
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: If only one binder+driver combination is included—for RabbitMQ, for example—Spring
    Boot’s autoconfiguration can unambiguously determine that your application should
    support communication with RabbitMQ instance(s) and associated `exchanges` and
    `queues` and create the appropriate supporting beans with no additional effort
    required on the developer’s part. Including more than one set of binders+drivers
    requires us to specify which one to use, but it also allows us to dynamically
    switch among all included platforms at runtime, with no change to the tested and
    deployed application. This is an extremely powerful and useful capability.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果只包含一个 binder+driver 组合—例如 RabbitMQ—Spring Boot 的自动配置可以明确确定您的应用程序应支持与 RabbitMQ
    实例及相关的 `exchanges` 和 `queues` 进行通信，并创建适当的支持 bean，而无需开发人员额外的工作。包含多组 binder+driver
    需要我们指定要使用哪一个，但它也允许我们在运行时动态在所有包含的平台之间切换，而不需要更改经过测试和部署的应用程序。这是一种非常强大和有用的功能。
- en: 'Two more additions to the *pom.xml* file are necessary. First is to indicate
    the project-level version of Spring Cloud to use by adding this line to the `<properties></properties>`
    section:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*pom.xml* 文件需要两个更改。首先是通过将以下行添加到 `<properties></properties>` 部分来指示要使用的 Spring
    Cloud 项目级版本：'
- en: '[PRE9]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Second is to provide guidance on the Spring Cloud Bill of Materials (BOM),
    from which the build system can determine versions for any Spring Cloud components—in
    this case, Spring Cloud Stream—that are used in this project:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 其次是提供有关 Spring Cloud BOM（Bill of Materials）的指导，从中构建系统可以确定任何在此项目中使用的 Spring Cloud
    组件（在本例中为 Spring Cloud Stream）的版本：
- en: '[PRE10]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-99
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Versions of Spring component projects are updated frequently. An easy way to
    determine correct, synchronized versions tested with the current version of Spring
    Boot is to use the Spring Initializr. Selecting the desired dependencies and clicking
    the button to "*Explore CTRL+SPACE*" displays the build file with the appropriate
    elements and versions.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 组件项目的版本经常更新。确定与当前版本的 Spring Boot 经过测试的正确同步版本的简单方法是使用 Spring Initializr。选择所需的依赖项并单击“*Explore
    CTRL+SPACE*”按钮将显示具有相应元素和版本的构建文件。
- en: After refreshing the project’s dependencies, it’s on to the code.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 刷新项目的依赖项后，转到代码。
- en: Supplying aircraft positions
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提供飞机位置
- en: 'Due to `PlaneFinder` ’s existing structure and Spring Cloud Stream’s clean,
    functional approach, only one small class is required to publish current aircraft
    positions to RabbitMQ for consumption by other applications:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `PlaneFinder` 的现有结构和 Spring Cloud Stream 的简洁、功能性方法，只需要一个小的类来将当前飞机位置发布到 RabbitMQ
    以供其他应用程序使用：
- en: '[PRE11]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Since each poll by `PlaneFinder` of the upstream radio device produces a listing
    of positions of aircraft currently within range, the `PlaneFinder` service creates
    a message consisting of 1+ aircraft in an `Iterable<Aircraft>` by calling the
    `PlaneFinderService` `getAircraft()` method. An opinion—that a `Supplier` is called
    once per second by default (overridable via application property)—and some required/optional
    application properties inform Spring Boot’s autoconfiguration and set things in
    motion.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `PlaneFinder` 对上游无线电设备的每次轮询会产生当前范围内的飞机位置列表，因此 `PlaneFinder` 服务通过调用 `PlaneFinderService`
    的 `getAircraft()` 方法创建由 `Iterable<Aircraft>` 中的 1+ 架飞机组成的消息。 一种观点是，`Supplier`
    每秒钟默认调用一次（可通过应用程序属性重写），以及一些必需/可选的应用程序属性会通知 Spring Boot 的自动配置并启动工作。
- en: Application properties
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用程序属性
- en: 'Only one property is required, although others are helpful. Here are the contents
    of the updated `PlaneFinder` ’s *application.properties* file:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 只需要一个属性，尽管其他属性也很有帮助。以下是更新后的 `PlaneFinder` 的 *application.properties* 文件的内容：
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `server.port` remains from the first version and indicates the application
    should listen on port 7634.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`server.port` 仍然来自第一个版本，并指示应用程序应在端口 7634 上监听。'
- en: Spring Cloud Stream’s functional API relies on minimal property configuration
    when necessary (as a baseline) to enable its functionality. A `Supplier` has only
    output channels, as it produces only messages. A `Consumer` has only input channels,
    as it consumes only messages. A `Function` has both input and output channels,
    which are necessary due to its use in transforming one thing to another.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Stream 的功能 API 依赖于最小的属性配置（作为基线），以启用其功能。`Supplier` 只有输出通道，因为它只产生消息。`Consumer`
    只有输入通道，因为它只消费消息。`Function` 既有输入通道也有输出通道，这是因为它用于将一种东西转换为另一种东西。
- en: Each binding uses the interface (`Supplier`, `Function`, or `Consumer`) bean
    method’s name for the channel name, along with `in` or `out` and a channel number
    from `0` to `7`. Once concatenated in the form `<method>-<in|out>-n`, binding
    properties can be defined for the channel.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 每个绑定使用接口（`Supplier`、`Function` 或 `Consumer`）的 bean 方法名称作为通道名称，以及 `in` 或 `out`
    和从 `0` 到 `7` 的通道编号。一旦以 `<method>-<in|out>-n` 的形式连接，绑定属性就可以为通道定义。
- en: The only property required for this use case is `destination`, and even that
    is for convenience. Specifying the `destination` name results in RabbitMQ creating
    an exchange named `aircraftpositions` (in this example).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此用例唯一需要的属性是 `destination`，即使如此也是为了方便。指定 `destination` 名称会导致 RabbitMQ 创建一个名为
    `aircraftpositions` 的交换。
- en: Since I included binders and drivers for both RabbitMQ and Kafka in the project
    dependencies, I must specify which binder the application should use. For this
    example, I choose `rabbit`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我在项目依赖项中包含了 RabbitMQ 和 Kafka 的绑定器和驱动程序，我必须指定应用程序应该使用哪个绑定器。对于这个示例，我选择 `rabbit`。
- en: With all required and desired application properties defined, `PlaneFinder`
    is ready to publish current aircraft positions each second to RabbitMQ for consumption
    by any applications desiring to do so.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了所有必需和期望的应用程序属性后，`PlaneFinder` 准备每秒向 RabbitMQ 发布当前飞机位置，以供希望这样做的任何应用程序消费。
- en: Extending the Aircraft Positions Application
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展飞机位置应用程序
- en: Converting `Aircraft Positions` to consume messages from a RabbitMQ pipeline
    using Spring Cloud Stream is similarly straightforward. Only a few changes to
    the workings behind the scenes are necessary to replace frequent HTTP requests
    with a message-driven architecture.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Spring Cloud Stream 将 `飞机位置` 转换为消费 RabbitMQ 管道消息同样简单。只需对幕后的工作进行少量更改，即可将频繁的
    HTTP 请求替换为消息驱动架构。
- en: Required dependencies
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 所需依赖项
- en: 'Just as with `PlaneFinder`, I add the following dependencies to the `Aircraft
    Positions` application’s *pom.xml*:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 `PlaneFinder` 一样，我将以下依赖项添加到 `飞机位置` 应用程序的 *pom.xml*：
- en: '[PRE13]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note
  id: totrans-120
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: As previously mentioned, I include binders and drivers for both RabbitMQ and
    Kafka for planned future use, but only the RabbitMQ set—`spring-boot-starter-amqp`
    and `spring-cloud-stream-binder-rabbit`—are required for the current use case
    in order for Spring Cloud Stream (`spring-cloud-stream`) to use RabbitMQ.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 正如之前提到的，我为计划中的未来使用包括 RabbitMQ 和 Kafka 的绑定器和驱动程序，但是目前使用案例中只需要 RabbitMQ 集合 — `spring-boot-starter-amqp`
    和 `spring-cloud-stream-binder-rabbit` — 让 Spring Cloud Stream (`spring-cloud-stream`)
    使用 RabbitMQ。
- en: 'I also add the two additional required entries to *pom.xml*. First, this goes
    into the `<properties></properties>` section, with the `java.version`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我还向 *pom.xml* 添加了两个额外所需的条目。首先，这些内容放在 `<properties></properties>` 部分，使用 `java.version`：
- en: '[PRE14]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Second is the Spring Cloud BOM information:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个是 Spring Cloud BOM 信息：
- en: '[PRE15]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: A quick refresh of the project’s dependencies and we’re on to the next step.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 快速刷新项目的依赖项，然后我们就可以进行下一步了。
- en: Consuming aircraft positions
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 消费飞机位置
- en: 'In order to retrieve and store messages listing current aircraft positions,
    only one small additional class is required:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检索和存储列出当前飞机位置的消息，只需要一个额外的小类：
- en: '[PRE16]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Like its `PositionReporter` counterpart in `PlaneFinder`, the `PositionRetriever`
    class is an `@Configuration` class in which I define a bean for use with Spring
    Cloud Stream: in this case, a `Consumer` of messages, each consisting of a `List`
    of one or more `Aircraft`. With each incoming message, the `Consumer` bean deletes
    all positions in the (in-memory) datastore, saves all incoming positions, and
    then prints all stored positions to the console for verification. Note that the
    last statement printing all positions to the console is optional; it’s included
    only for confirmation as I develop the app.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Application properties
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to provide the application the few remaining bits of information necessary
    to connect to the incoming stream of messages, I add the following entries to
    the *application.properties* file:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As with `PlaneFinder`, the channel is defined by concatenating the following,
    separated by a hyphen (-):'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: The bean name, in this case, a `Consumer<T>` bean
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`in`, since consumers only consume and thus have only input(s)'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A number between `0` and `7` inclusive, supporting up to eight inputs
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `destination` and `binder` properties match those of `PlaneFinder` because
    the `Aircraft Positions` application must point to the same destination as input
    that `PlaneFinder` used as output and because to do so, both must be using the
    same messaging platform—in this case, RabbitMQ. The `group` property is new, though.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: For any kind of `Consumer` (including the receiving portion of a `Function<T,
    R>`), one can specify a `group`, but it isn’t required; in fact, including or
    omitting `group` forms a starting point for a particular routing pattern.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: If a message-consuming application doesn’t specify a group, the RabbitMQ binder
    creates a randomized unique name and assigns it, and the consumer, to an auto-delete
    queue within the RabbitMQ instance or cluster. This results in each generated
    queue being serviced by one—and only one—consumer. Why is this important?
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Whenever a message arrives at a RabbitMQ exchange, a copy is routed automatically
    to all queues assigned to that exchange by default. If an exchange has multiple
    queues, the same message is sent to every queue in what’s referred to as a *fan-out
    pattern*, a useful capability when each message must be delivered to numerous
    destinations to satisfy various requirements.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: If an application specifies a consumer group to which it belongs, that group
    name is used to name the underlying queue within RabbitMQ. When multiple applications
    specify the same `group` property and thus connect to the same queue, together
    those applications fulfill the competing consumer pattern in which each message
    arriving in the designated queue is processed by only one of the consumers. This
    allows the number of consumers to scale to accommodate varying volumes of messages.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-143
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: It is also possible to employ partitioning and routing keys for even finer-grained
    and flexible routing options, if needed.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Specifying the `group` property for this application enables scaling, should
    multiple instances be needed to keep pace with the flow of arriving messages.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Contacting the Controller
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since the `Consumer` bean automatically checks for and processes messages automatically,
    the `PositionController` class and its `getCurrentAircraftPositions()` method
    become dramatically leaner.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'All references to `WebClient` can be removed, since getting a list of current
    positions is now only a matter of retrieving the current contents of the repository.
    The streamlined class now looks like this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: With that, all changes to both message-producer (the `PlaneFinder` app) and
    message-consumer (the `Aircraft Positions` app) are now complete.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-151
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In order to use any external messaging platform, said platform must be running
    and accessible to the applications. I run a local instance of RabbitMQ using Docker;
    scripts for quick creation and startup/shutdown are provided in this book’s associated
    repositories.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: The results
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After verifying that RabbitMQ is accessible, it’s time to start the applications
    and verify everything works as expected.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Although it isn’t a requirement to do so, I prefer to start the message-consuming
    application first so it’s ready and waiting for messages to arrive. In this case,
    that means executing `Aircraft Positions` from my IDE.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Next, I start up the new and improved `PlaneFinder` application. This initiates
    the flow of messages to the `Aircraft Positions` application, as shown in the
    `Aircraft Positions` app’s console. That’s gratifying, but we can follow this
    path of success all the way to the end user as well.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Returning to the browser and accessing *localhost:8080*, we’re presented with
    the landing page once again, and opting to *Click here*, are taken to the Positions
    Report. As before, the Positions Report is refreshed automatically and displays
    current aircraft positions; now however, those positions are pushed independently
    from `PlaneFinder` behind the scenes to the `Aircraft Positions` application,
    without first receiving an HTTP request for them, which brings the architecture
    one step closer to a fully event-driven system.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Creating Conversations with WebSocket
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In its first iteration, the distributed system we created to query and display
    current aircraft positions was entirely pull-based. A user requested (or re-requested
    with a refresh) the latest positions from the browser, which passed the request
    to the `Aircraft Positions` application, which in turn relayed the request to
    the `PlaneFinder` application. Responses then were returned from one to the next,
    to the next. The last chapter segment replaced the midsection of our distributed
    system with an event-driven architecture. Now whenever `PlaneFinder` retrieves
    positions from the upstream radio device, it pushes those positions to a streaming
    platform pipeline and the `Aircraft Positions` app consumes them. The last mile
    (or kilometer, if you prefer) is still pull-based, however; updates must be requested
    via browser refresh, either manually or automatically.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们创建的分布式系统的第一次迭代中，用于查询和显示当前飞行器位置的分布式系统完全是基于拉取的。用户从浏览器请求（或使用刷新重新请求）最新的位置，浏览器将请求传递给`飞行器位置`应用程序，后者又将请求中继给`PlaneFinder`应用程序。然后依次从一个应用程序返回到下一个应用程序。最后一章将我们的分布式系统的中段替换为事件驱动架构。现在，每当`PlaneFinder`从上游无线设备检索位置时，它将这些位置推送到流式平台管道，而`飞行器位置`应用程序则消耗这些位置。然而，最后一英里（或者说最后一公里，如果你愿意）仍然是基于拉取的；更新必须通过浏览器刷新手动或自动请求。
- en: Standard request-response semantics work brilliantly for numerous use cases,
    but they largely lack the ability for the responding “server” side to, independent
    of any request, initiate a transmission to the requestor. There are various workarounds
    and clever ways to satisfy this use case—each of which has its own pros and cons,
    and some of the best of which I discuss in subsequent chapters—but one of the
    more versatile options is WebSocket.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的请求-响应语义对许多用例非常有效，但它们在很大程度上缺乏响应端"服务器"独立于任何请求启动传输的能力。有各种解决方法和聪明的方式来满足这个用例——每种方式都有其优缺点，其中一些我在接下来的章节中讨论——但其中一种更多才多艺的选择是WebSocket。
- en: What Is WebSocket?
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是WebSocket？
- en: In a nutshell, WebSocket is a full-duplex communications protocol that connects
    two systems over a single TCP connection. Once a WebSocket connection is established,
    either party can initiate a transmission to the other, and the designated server
    application can maintain numerous client connections, enabling low-overhead broadcast
    and chat types of systems. WebSocket connections are forged from standard HTTP
    connections using the HTTP upgrade header, and once the handshake is complete,
    the protocol used for the connection shifts from HTTP to WebSocket.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket简而言之，是一种全双工通信协议，通过单个TCP连接连接两个系统。一旦建立WebSocket连接，任何一方都可以向另一方发起传输，指定的服务器应用程序可以维护多个客户端连接，实现低开销的广播和聊天类型的系统。WebSocket连接是通过使用HTTP升级标头从标准HTTP连接中形成的，一旦握手完成，用于连接的协议从HTTP转变为WebSocket。
- en: WebSocket was standardized by the IETF in 2011, and by now every major browser
    and programming language supports it. Compared to HTTP requests and responses,
    WebSocket is extremely low overhead; transmissions don’t have to identify themselves
    and the terms of their communication with each transmission, thus reducing WebSocket
    framing to a few bytes. With its full-duplex capabilities, the ability of a server
    to handle a multiple of the number of open connections other options can support,
    and its low overhead, WebSocket is a useful tool for developers to have in their
    toolbox.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket在2011年由IETF标准化，到目前为止，每个主要浏览器和编程语言都支持它。与HTTP请求和响应相比，WebSocket的开销极低；传输不必在每个传输中识别自己和它们的通信条款，从而将WebSocket帧格式化为几个字节。借助其全双工能力，服务器处理多个开放连接的能力比其他选项多，以及低开销，WebSocket是开发人员工具箱中有用的工具。
- en: Refactoring the Aircraft Positions Application
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重构飞行器位置应用程序
- en: 'Although I refer to the `Aircraft Positions` application as a single unit,
    the *aircraft-positions* project comprises both the backend Spring Boot+Java application
    and the frontend HTML+JavaScript functionality. During development, both portions
    execute in a single environment, usually the developer’s machine. While they are
    built, tested, and deployed as a single unit to production settings as well, execution
    in production settings is divided as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我将`飞行器位置`应用程序称为单一单元，*飞行器位置*项目包括后端Spring Boot+Java应用程序和前端HTML+JavaScript功能。在开发过程中，这两部分通常在单一环境中执行，通常是开发者的计算机。尽管它们作为单个单元构建、测试并部署到生产环境中，但在生产环境中的执行分为以下几个部分：
- en: Backend Spring+Java code is run in the cloud, including the template engine
    (if applicable) that generates final webpages to deliver to the end user.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后端 Spring+Java 代码在云中运行，包括（如果适用）生成最终网页以交付给最终用户的模板引擎。
- en: Frontend HTML+JavaScript—static and/or generated content—is displayed and run
    in the end user’s browser, wherever that browser may be located.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前端 HTML+JavaScript——静态和/或生成的内容——在最终用户的浏览器中显示和运行，无论该浏览器位于何处。
- en: In this section, I leave existing functionality intact and add the ability to
    the system to automatically display aircraft positions as they are reported via
    a live feed. With a WebSocket connection in place between frontend and backend
    applications, the backend app is free to push updates to the end user’s browser
    and update the display automatically, with no need to trigger a page refresh.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分中，我保留了现有功能，并添加了系统自动显示飞机位置的能力，这些位置是通过实时数据流报告的。通过前端和后端应用程序之间建立的 WebSocket
    连接，后端应用程序可以自由地将更新推送到最终用户的浏览器，并自动更新显示，无需触发页面刷新。
- en: Additional dependencies
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 附加依赖项
- en: 'To add WebSocket capabilities to the `Aircraft Positions` application, I need
    add only a single dependency to its *pom.xml*:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 要向 `Aircraft Positions` 应用程序添加 WebSocket 能力，我只需要在其 *pom.xml* 中添加一个依赖项：
- en: '[PRE19]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: A quick refresh of the project’s dependencies and we’re on to the next step.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 快速刷新项目的依赖项，我们就可以进行下一步了。
- en: Handling WebSocket connections and messages
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理 WebSocket 连接和消息
- en: 'Spring offers a couple of different approaches for configuring and using WebSocket,
    but I recommend following the clean lines of a direct implementation based on
    the `WebSocketHandler` interface. Owing to the frequency of requirements for exchanging
    text-based, i.e., nonbinary, information, there is even a `TextWebSocketHandler`
    class. I build on that here:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 提供了几种不同的方法来配置和使用 WebSocket，但我建议遵循基于 `WebSocketHandler` 接口的直接实现的清晰路线。由于需要频繁交换基于文本的、即非二进制信息，因此甚至有一个
    `TextWebSocketHandler` 类。我在这里基于此进行构建：
- en: '[PRE20]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The preceding code implements two of the `WebSocketHandler` interface’s methods,
    `afterConnectionEstablished` and `afterConnectionClosed`, to maintain a `List`
    of active `WebSocketSession` and `log connections` and `disconnections`. I also
    implement `handleTextMessage`, broadcasting any incoming message to all other
    active sessions. This single class provides the WebSocket capability for the backend,
    ready to be activated when aircraft positions are received from `PlaneFinder`
    via RabbitMQ.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码实现了 `WebSocketHandler` 接口的两个方法，即 `afterConnectionEstablished` 和 `afterConnectionClosed`，以维护活动
    `WebSocketSession` 的 `List` 和记录连接和断开连接。我还实现了 `handleTextMessage`，将任何传入的消息广播给所有其他活动会话。这个单一类为后端提供了
    WebSocket 能力，一旦从 `PlaneFinder` 通过 RabbitMQ 接收到飞机位置，就可以激活它。
- en: Broadcasting aircraft positions to WebSocket connections
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将飞机位置广播到 WebSocket 连接
- en: 'In its previous iteration, the `PositionRetriever` class consumed aircraft
    position lists received via RabbitMQ messages and stored them in the in-memory
    H2 database. I build on that now by replacing the logging confirmation `System.out::println`
    call with a call to a new `sendPositions()` method, whose purpose is to use the
    newly added `@Autowired` `WebSocketHandler` bean to send the latest list of aircraft
    positions to all WebSocket-connected clients:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在其先前版本中，`PositionRetriever` 类通过 RabbitMQ 消息接收飞机位置列表，并将它们存储在内存中的 H2 数据库中。现在我通过调用一个新的
    `sendPositions()` 方法来构建它，该方法的目的是使用新添加的 `@Autowired` `WebSocketHandler` bean 将最新的飞机位置列表发送给所有连接的
    WebSocket 客户端，以取代记录确认的 `System.out::println` 调用：
- en: '[PRE21]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now that we have WebSocket configured properly and have a way for the backend
    to broadcast aircraft positions to connected WebSocket clients as soon as a new
    position list is received, the next step is to provide a way for the backend application
    to listen for and accept connection requests. This is accomplished by registering
    the `WebSocketHandler` created earlier via the `WebSocketConfigurer` interface
    and annotating the new `@Configuration` class with `@EnableWebSocket` to direct
    the application to process WebSocket requests:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经正确配置了 WebSocket，并且有了一种让后端向连接的 WebSocket 客户端广播飞机位置的方法，即一旦收到新的位置列表，下一步就是提供一种让后端应用程序监听并接受连接请求的方法。通过注册先前创建的
    `WebSocketHandler`，使用 `WebSocketConfigurer` 接口，并在新的 `@Configuration` 类上加上 `@EnableWebSocket`
    注解来指示应用程序处理 WebSocket 请求来实现这一点：
- en: '[PRE22]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the `registerWebSocketHandlers(WebSocketHandlerRegistry registry)` method,
    I tie the `WebSocketHandler` bean created earlier to the endpoint *ws://<hostname:hostport>/ws*.
    The application will listen on this endpoint for HTTP requests with WebSocket
    upgrade headers and act accordingly when one is received.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在`registerWebSocketHandlers(WebSocketHandlerRegistry registry)`方法中，我将之前创建的`WebSocketHandler`
    bean绑定到端点*ws://<hostname:hostport>/ws*。 应用程序将在此端点上侦听带有WebSocket升级标头的HTTP请求，并在收到请求时采取相应措施。
- en: Note
  id: totrans-183
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If HTTPS is enabled for your application, *wss://* (WebSocket Secure) would
    be used in place of *ws://*.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的应用程序启用了HTTPS，则会使用*wss://*（WebSocket Secure）代替*ws://*。
- en: WebSocket in back, WebSocket in front
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 后端WebSocket，前端WebSocket
- en: With the backend work done, it’s time to collect the payoff in the frontend
    functionality.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 后端工作完成后，是时候在前端功能中收集回报了。
- en: 'To create a simple example of how WebSocket enables the backend app to push
    updates unprompted by the user and their browser, I create the following file
    with a single HTML division and label and a few lines of JavaScript and place
    it in the project’s *src/main/resources/static* directory along with the existing
    *index.html*:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个简单的示例，演示WebSocket如何使后端应用程序能够无需用户及其浏览器提示即可推送更新，我创建了以下文件，其中包含一个HTML部分和标签以及几行JavaScript，并将其放置在项目的*src/main/resources/static*目录中，与现有的*index.html*一起：
- en: '[PRE23]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As short as this page is, it could be shorter. The `socket.onopen` and `socket.onclose`
    function definitions are logging functions that could be omitted, and `socket.onmessage`
    could almost certainly be refactored by someone with actual JavaScript chops and
    the desire to do so. These are the key bits:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管此页面很短，但它可以更短。`socket.onopen`和`socket.onclose`函数定义是可以省略的日志函数，而`socket.onmessage`几乎肯定可以由具有实际JavaScript技能和愿望的人进行重构。
    这些是关键位：
- en: The defined division and label in the HTML at bottom
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在HTML底部定义的部门和标签
- en: The `socket` variable that establishes and references a WebSocket connection
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建立和引用WebSocket连接的`socket`变量
- en: The `socket.onmessage` function that parses the aircraft position list and assigns
    the reformatted output to the HTML “positions” label’s `innerText`
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析飞机位置列表并将重新格式化的输出分配给HTML“positions”标签的`innerText`的`socket.onmessage`函数
- en: Once we rebuild and execute the project, it is of course possible to simply
    access the *wspositions.html* page directly from the browser. This is a poor way
    to create an application for actual users, though—providing no way to access a
    page and its functionality unless they know its location and enter it manually
    into the address bar—and it does nothing to set the table for upcoming chapters’
    expansions to this example.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们重建并执行项目，当然可以直接从浏览器访问*wspositions.html*页面。 但这是为实际用户创建应用程序的不良方式——除非他们知道其位置并将其手动输入到地址栏中，否则无法访问页面及其功能——并且它对于设置为本示例的扩展来说毫无作用。
- en: 'Keeping it simple for the time being, I add another line to the existing *index.html*
    to allow the user to navigate to the *wspositions.html* WebSocket-driven page
    in addition to the existing one:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 暂时保持简单，我在现有的*index.html*中添加另一行，允许用户导航到*wspositions.html* WebSocket驱动的页面，除了现有的页面：
- en: '[PRE24]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: With frontend work now complete, it’s time to test the WebSocket waters.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 前端工作现在已经完成，是时候测试WebSocket了。
- en: The results
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结果
- en: From the IDE, I launch the `Aircraft Positions` application and `PlaneFinder`.
    Opening a browser window, I access the frontend application at *localhost:8080*,
    as shown in [Figure 7-3](#aircraft_positions_landing_page_now_with_two_options).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 从IDE中，我启动`Aircraft Positions`应用程序和`PlaneFinder`。 打开浏览器窗口，我访问*localhost:8080*的前端应用程序，如[图7-3](#aircraft_positions_landing_page_now_with_two_options)所示。
- en: '![sbur 0703](Images/sbur_0703.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![sbur 0703](Images/sbur_0703.png)'
- en: Figure 7-3\. Aircraft Positions landing page, now with two options
  id: totrans-200
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7-3\. 飞机位置着陆页面，现在有两个选项
- en: From the still rather rudimentary landing page, choosing the second option—*Click
    here* to retrieve a livestream of current aircraft positions in range of receiver—produces
    the *wspositions.html* page and results similar to those shown in [Figure 7-4](#aircraft_position_report_with_live_updates_via_websocket).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 从仍然相当简陋的着陆页面中，选择第二个选项——*点击这里*以检索接收器范围内当前飞机位置的实时流产生了*wspositions.html*页面和类似于[图7-4](#aircraft_position_report_with_live_updates_via_websocket)中所示的结果。
- en: '![sbur 0704](Images/sbur_0704.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![sbur 0704](Images/sbur_0704.png)'
- en: Figure 7-4\. Aircraft Position report with live updates via WebSocket
  id: totrans-203
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7-4\. 通过WebSocket进行实时更新的飞机位置报告
- en: It’s a trivial exercise to convert the database record format shown with JSON,
    and just a bit more involved to dynamically populate a table with results received
    live from the backend application via WebSocket. Please refer to this book’s code
    repositories for examples.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 将显示的数据库记录格式转换为JSON格式是一个微不足道的练习，而动态填充表格以显示从后端应用通过WebSocket实时接收到的结果则稍微复杂一些。请参考本书的代码仓库获取示例。
- en: Tip
  id: totrans-205
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: It’s perfectly fine to build and run both the `PlaneFinder` and `Aircraft Positions`
    applications from the command line; while I do so on occasion, for most build/run
    cycles, I find it much faster to run (and debug) directly from within the IDE.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 完全可以通过命令行构建和运行`PlaneFinder`和`Aircraft Positions`应用；虽然我偶尔这样做，但对于大多数构建/运行周期，我发现直接在IDE中运行（和调试）要快得多。
- en: Summary
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Nearly every application must interact with end users or other applications
    in some manner to provide real utility, and that requires useful and efficient
    means of interaction.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每个应用程序都必须以某种方式与最终用户或其他应用程序进行交互，这需要有效和高效的交互手段。
- en: This chapter introduced view technologies—template languages/tags like Thymeleaf
    and engines that process them—and how Spring Boot uses them to create and deliver
    functionality to an end user’s browser. Also introduced was how Spring Boot handles
    static content like standard HTML along with JavaScript that can be delivered
    directly without processing by template engines. The chapter’s first project iteration
    showed examples of both with a Thymeleaf-driven application that retrieved and
    displayed aircraft positions within range at the time of the request, an entirely
    pull-based model.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了视图技术——如Thymeleaf等模板语言/标签以及处理它们的引擎——以及Spring Boot如何使用它们创建和传递功能给最终用户的浏览器。还介绍了Spring
    Boot如何处理静态内容，如标准HTML及无需模板引擎处理即可直接交付的JavaScript。章节的第一个项目迭代展示了一个完全基于拉取模型的Thymeleaf驱动应用，该应用在请求时检索并显示范围内的飞机位置示例。
- en: The chapter next showed how to harness the power of messaging platforms from
    Spring Boot using Spring Cloud Stream and RabbitMQ. The `PlaneFinder` application
    was refactored to push a list of current aircraft positions, each time retrieved
    from the upstream device, and the `Aircraft Positions` app was modified to accept
    new aircraft position listings as they arrived via the RabbitMQ pipeline. This
    replaced the pull-based model between the two applications with a push-based one,
    making the backend functionality of the `Aircraft Positions` app event-driven.
    The front end functionality still required a refresh (either manual or hard-coded)
    to update results shown to the user.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的章节展示了如何利用Spring Boot中的Spring Cloud Stream和RabbitMQ平台的消息传递功能。`PlaneFinder`应用程序进行了重构，以便每次从上游设备检索到当前飞机位置列表时都推送一次，并且`Aircraft
    Positions`应用程序已修改以接受通过RabbitMQ管道实时到达的新飞机位置列表。这将两个应用程序之间基于拉取的模型替换为推送模型，使得`Aircraft
    Positions`应用程序的后端功能变成了事件驱动。前端功能仍然需要刷新（手动或硬编码）才能更新显示给用户的结果。
- en: Finally, implementing a WebSocket connection and handler code within backend
    and frontend components of the `Aircraft Positions` application enabled the Spring+Java
    backend app to push aircraft position updates *as they are received* via a RabbitMQ
    pipeline from `PlaneFinder`. Position updates are shown live in a simple HTML+JavaScript
    page and require no update requests be issued by the end user or their browser,
    showcasing WebSocket’s bidirectional nature, lack of required request-response
    pattern (or workaround), and low communication overhead.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`Aircraft Positions`应用的后端和前端组件中实现WebSocket连接和处理程序代码，使得Spring+Java后端应用能够通过RabbitMQ管道从`PlaneFinder`接收到的飞机位置更新
    *即时推送*。这些位置更新会在简单的HTML+JavaScript页面中实时显示，并且无需用户或其浏览器发出更新请求，展示了WebSocket双向通信的特性，以及其低通信开销和无需请求-响应模式（或其变通方式）。
- en: Code Checkout Checkup
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码检出检查
- en: For complete chapter code, please check out branch *chapter7end* from the code
    repository.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 想要完整的章节代码，请查看代码仓库中的*chapter7end*分支。
- en: The next chapter introduces reactive programming and describes how Spring is
    leading the development and advancement of numerous tools and technologies that
    make it one of the best possible solutions for numerous use cases. More specifically,
    I’ll demonstrate how to use Spring Boot and Project Reactor to drive database
    access, integrate reactive types with view technologies like Thymeleaf, and take
    interprocess communication to unexpected new levels.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章介绍了响应式编程，并描述了Spring如何引领开发和推动多种工具和技术的进展，使其成为多种用例中最佳解决方案之一。具体而言，我将演示如何使用Spring
    Boot和Project Reactor来驱动数据库访问，将响应式类型集成到像Thymeleaf这样的视图技术中，并将进程间通信提升到意想不到的新水平。
