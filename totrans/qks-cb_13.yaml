- en: Chapter 13\. Quarkus REST Clients
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 3](ch03.xhtml#developing_restful_services_chapter), you learned
    about developing RESTful services, but in this chapter, you’ll learn about communication
    between RESTful web services.
  prefs: []
  type: TYPE_NORMAL
- en: Using any service-based architecture inevitably means that you need to communicate
    with external services. These services might be internal services (you control
    the life cycle of the service and they are usually deployed in the same cluster)
    or external services (third-party services).
  prefs: []
  type: TYPE_NORMAL
- en: 'If these services are implemented as RESTful web services, then you need a
    client to interact with these services. Quarkus offers two ways to do that: JAX-RS
    Web Client, which is the standard Java EE way of communicating with RESTful service;
    and MicroProfile REST Client, which is the new way of communicating with RESTful
    services.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will include recipes for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Communicate to other RESTful services using the JAX-RS client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Communicate to other RESTful services using the MicroProfile Rest Client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secure the communication between RESTful services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 13.1 Using the JAX-RS Web Client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to communicate with another RESTful web service.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use JAX-RS web client to communicate with other RESTful web services.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at how to communicate with other RESTful services using the JAX-RS
    spec.
  prefs: []
  type: TYPE_NORMAL
- en: The external service we are going to connect with, the [World Clock API](https://oreil.ly/wl2IE),
    returns the current date/time by time zone. You’ll need to get the current date/time
    exposed by the [API](https://oreil.ly/7M0tf).
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to add extensions for using a REST client and the JAX-B/Jackson for
    marshalling/unmarshalling JSON and Java objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, if you are creating from empty directory, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You can start using the JAX-RS REST Client for communicating with an external
    Rest API. Let’s see what the interaction with the world clock service looks like.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `org.acme.quickstart.WorldClockResource.java` and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_quarkus_rest_clients_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Makes service host configurable
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_quarkus_rest_clients_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Creates a new REST Client
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_quarkus_rest_clients_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets the host
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_quarkus_rest_clients_CO1-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets the path to the service
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](Images/5.png)](#co_quarkus_rest_clients_CO1-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Resolves the `timezone` placeholder to the one provided
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](Images/6.png)](#co_quarkus_rest_clients_CO1-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Executes a `GET` HTTP method
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](Images/7.png)](#co_quarkus_rest_clients_CO1-7)'
  prefs: []
  type: TYPE_NORMAL
- en: Transforms the JSON output to the provided POJO
  prefs: []
  type: TYPE_NORMAL
- en: 'Try it by opening a new terminal window, starting the Quarkus application,
    and sending a request to the `GET` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In similar way, you can make requests to other HTTP methods. For example, to
    do a POST request, you call the `post` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use the `javax.ws.rs.core.Response` to get all the response details
    instead of just the body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can further explore the JAX-RS REST Client at the following pages on Oracle’s
    website:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Accessing REST Resources with the JAX-RS Client API](https://oreil.ly/7neQm)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Using the Client API in the JAX-RS Example Applications](https://oreil.ly/QA8lA)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 13.2 Using the MicroProfile REST Client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to communicate with another RESTful web service without going into
    low-level details.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use MicroProfile REST Client to communicate with other RESTful web services.
  prefs: []
  type: TYPE_NORMAL
- en: So far, you’ve seen how to use the JAX-RS `Web Client` to communicate with other
    REST APIs, but it is not type-safe, and you need to deal with low-level parameters
    instead of focusing on message communication.
  prefs: []
  type: TYPE_NORMAL
- en: The MicroProfile REST Client provides a type-safe approach to invoke RESTful
    services over HTTP using as much of the JAX-RS 2.0 spec as possible. The REST
    client is defined as a Java interface, making it type-safe and providing the network
    configuration using JAX-RS annotations.
  prefs: []
  type: TYPE_NORMAL
- en: We will use the same World Clock API that was used in the previous section here,
    too. Remember to get the [current date/time](https://oreil.ly/7M0tf).
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `org.acme.quickstart.WorldClockService` interface that is responsible
    for interacting with the external service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_quarkus_rest_clients_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The global path
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_quarkus_rest_clients_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets the interface as REST client
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_quarkus_rest_clients_CO2-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The request uses the `GET` HTTP method
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_quarkus_rest_clients_CO2-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The subpath with a path parameter
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](Images/5.png)](#co_quarkus_rest_clients_CO2-5)'
  prefs: []
  type: TYPE_NORMAL
- en: The media type requested
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](Images/6.png)](#co_quarkus_rest_clients_CO2-6)'
  prefs: []
  type: TYPE_NORMAL
- en: The path parameter is resolved with the passed argument
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `org.acme.quickstart.WorldClockResource.java` and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_quarkus_rest_clients_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Injects the REST client
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_quarkus_rest_clients_CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Calls the external service
  prefs: []
  type: TYPE_NORMAL
- en: You still need to set the host of the external service. MicroProfile REST Client
    has a configuration property to set it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open *application.properties*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The attribute name uses the following format: `*fully_qualified_name_rest_client*/mp-rest/url`,
    and the value is the hostname (or the root of the URL):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can also convert a response with a status code equal to or greater than
    400 into an exception by implementing the `org.eclipse.microprofile.rest.client.ex.ResponseExceptionMapper`
    interface. If multiple mappers are registered, then you need to set a priority
    with `javax.annotation.Priority` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the following `ResponseExecptionMapper` class to have it registered,
    and have the application throw `IOExecptions` for status codes in the 400s:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_quarkus_rest_clients_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Implements the mapper interface
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_quarkus_rest_clients_CO4-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Does the conversion to an exception
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_quarkus_rest_clients_CO4-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Default is to transform any response with status code ≥ 400, but you can override
    the method to provide a smaller range
  prefs: []
  type: TYPE_NORMAL
- en: '`ResponseExceptionMapper` is an extension point specifically from the MicroProfile
    REST Client specification, but you can also use the extension model provided by
    the JAX-RS specification:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ClientRequestFilter`'
  prefs: []
  type: TYPE_NORMAL
- en: The filter invoked when the request is made to the external service.
  prefs: []
  type: TYPE_NORMAL
- en: '`ClientResponseFilter`'
  prefs: []
  type: TYPE_NORMAL
- en: The filter invoked when the response is received from the external service.
  prefs: []
  type: TYPE_NORMAL
- en: '`MessageBodyReader`'
  prefs: []
  type: TYPE_NORMAL
- en: Reads the entity after invocation.
  prefs: []
  type: TYPE_NORMAL
- en: '`MessageBodyWriter`'
  prefs: []
  type: TYPE_NORMAL
- en: Writes a request body in the operations that support bodies.
  prefs: []
  type: TYPE_NORMAL
- en: '`ParamConverter`'
  prefs: []
  type: TYPE_NORMAL
- en: Converts a parameter in the resource to a format to be used in a request or
    response.
  prefs: []
  type: TYPE_NORMAL
- en: '`ReadInterceptor`'
  prefs: []
  type: TYPE_NORMAL
- en: The listener fired when the response is received from the external service.
  prefs: []
  type: TYPE_NORMAL
- en: '`WriteInterceptor`'
  prefs: []
  type: TYPE_NORMAL
- en: The listener fired when the request is sent on the external service.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also mock the `WorldClockService` interface by using the `@InjectMock`
    together with `@RestClient`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The MicroProfile Rest Client specification can be found at the following website:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Eclipse REST Client for MicroProfile](https://oreil.ly/7D0Zv)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 13.3 Implementing a CRUD Client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to communicate with another RESTful web service with CRUD operations
    exposed.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use MicroProfile REST Client and JAX-RS annotations to implement a CRUD client.
  prefs: []
  type: TYPE_NORMAL
- en: So far, you’ve seen how to use MicroProfile REST Client to get information from
    external services. When the service is an internal service, more often than not
    you need to implement more operations like insert, delete, or update.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement these operations, you can use JAX-RS annotations on a MicroProfile
    REST Client. Let’s see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_quarkus_rest_clients_CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Requests and responses are in JSON format
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_quarkus_rest_clients_CO5-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Uses the `HEAD` HTTP method
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_quarkus_rest_clients_CO5-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Uses the `POST` HTTP method
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_quarkus_rest_clients_CO5-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets `Authorization` header
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](Images/5.png)](#co_quarkus_rest_clients_CO5-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Developer content is sent as the body
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](Images/6.png)](#co_quarkus_rest_clients_CO5-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Uses the `DELETE` HTTP method
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](Images/7.png)](#co_quarkus_rest_clients_CO5-7)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets `AuthToken` cookie
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Notice how the JAX-RS annotations are used to configure how the requests are
    sent to the other services. You never need to do anything programmatically.
  prefs: []
  type: TYPE_NORMAL
- en: This approach is developer-friendly and helps to reduce the boilerplate code
    that you might end up using with the JAX-RS Web Client.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, it also has some drawbacks. For example, methods can contain a huge
    number of parameters because of the number of path parameters, headers to set,
    and cookies. To fix this, pass a POJO with all of the required fields (instead
    of setting them in the method).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a Java class for the `PUT` requirements (i.e., an authorization
    header and a path parameter):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_quarkus_rest_clients_CO6-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets the `Authorization` header
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_quarkus_rest_clients_CO6-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets the `path` parameter to resolve
  prefs: []
  type: TYPE_NORMAL
- en: 'The `interface` method using the previous class is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_quarkus_rest_clients_CO7-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The `BeanParam` is used to indicate that this class is a *parameter aggregator*
  prefs: []
  type: TYPE_NORMAL
- en: 13.4 Manipulating Headers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to manipulate and propagate headers from the incoming request to the
    outgoing service (service-to-service authentication).
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the MicroProfile REST Client feature that manipulates headers.
  prefs: []
  type: TYPE_NORMAL
- en: When you need to communicate to other RESTful web services, you might want to
    pass through some headers from the incoming request to the outgoing/downstream
    service. One of these typical cases is the `Authorization` header to do service-to-service
    authentication. Authentication and authorization in services architecture are
    usually solved by propagating a token, often a JWT token, through all services
    that compose the application. You can see the idea in [Figure 13-1](#s2sauth).
  prefs: []
  type: TYPE_NORMAL
- en: '![qucb 1301](Images/qucb_1301.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13-1\. Service-to-service authentication
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The MicroProfile REST Client simplifies all these operations by allowing you
    to propagate and manipulate headers either at a static level by using annotations
    or at a programmatic level by implementing `ClientHeadersFactory` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set a header on a method or on all the methods defined in an interface,
    you can use the `org.eclipse.microprofile.rest.client.annotation.ClientHeaderParam`
    annotation at method level or class level to set a header with a static value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_quarkus_rest_clients_CO8-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets `user-agent` to the request
  prefs: []
  type: TYPE_NORMAL
- en: 'The `value` can be a method invocation where the return value would be the
    header’s value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_quarkus_rest_clients_CO9-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets the method to invoke
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_quarkus_rest_clients_CO9-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The header name is the first argument of the method
  prefs: []
  type: TYPE_NORMAL
- en: These approaches offer a basic manipulation of headers but don’t help in propagating
    headers from the incoming request to the outgoing service. It is also possible
    to add or propagate headers by implementing the `ClientHeadersFactory` interface
    and registering it with the `RegisterClientHeaders` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that your service receives the authentication token from your upstream
    service in a header named `x-auth`, and your downstream service requires that
    this value is set to the `Authorization` header. Let’s implement this rename of
    headers in a MicroProfile REST Client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_quarkus_rest_clients_CO10-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The headers from the inbound JAX-RS request
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_quarkus_rest_clients_CO10-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The headers parameters specified on the client interface
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_quarkus_rest_clients_CO10-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Adds all headers
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_quarkus_rest_clients_CO10-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Renames the header value
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you need to register this factory in the client by using the `R⁠e⁠g⁠i⁠s⁠t⁠e⁠r⁠C⁠l⁠i⁠e⁠n⁠t​H⁠e⁠a⁠d⁠e⁠r⁠s`
    annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_quarkus_rest_clients_CO11-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Registers the headers factory for this client
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you want to propagate the headers only as is, without any modification, you
    can do it by just annotating the REST client with `@RegisterClientHeaders` without
    specifying any factory. Then the default headers factory is used.
  prefs: []
  type: TYPE_NORMAL
- en: 'This default factory will propagate specified headers from the inbound JAX-RS
    request to the outbound request. To configure which headers are propagated, you
    need to set them as comma-separated values under the `org.eclipse.microprofile.rest.client.propagateHeaders`
    property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 13.5 Using REST Client for Multipart Messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to send multipart content to interact with the REST APIs requiring
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use RESTEasy multipart support to deal with multipart messages.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes the service you need to connect with requires that you send multiple
    content bodies embedded into one message, usually using the `multipart/form-data`
    MIME-type. The easiest way to work with multipart mime-types is using the RESTEasy
    multipart provider, which integrates with the MicroProfile REST client.
  prefs: []
  type: TYPE_NORMAL
- en: Important
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This feature is specific of RESTEasy/Quarkus and is not under MicroProfile REST
    client spec.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you start developing, you need to add the `resteasy-multipart-provider`
    dependency in your build tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Then you need to create the model object that defines the payload of the message.
    Let’s define a multipart message with two parts, one as a binary content and another
    one as a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_quarkus_rest_clients_CO12-1)'
  prefs: []
  type: TYPE_NORMAL
- en: JAX-RS annotation to define the form parameter contained inside the request
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_quarkus_rest_clients_CO12-2)'
  prefs: []
  type: TYPE_NORMAL
- en: RESTEasy annotation to define the content type of the part
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you need to declare a new method using the `MultipartDeveloperModel`
    object as a parameter annotated with `org.jboss.resteasy.annotations.providers.multipart.MultipartForm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_quarkus_rest_clients_CO13-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets the output mime-type as multipart
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_quarkus_rest_clients_CO13-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Defines the parameter as a `multipart/form-type` mime-type
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_quarkus_rest_clients_CO13-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Multipart data
  prefs: []
  type: TYPE_NORMAL
- en: 13.6 Using REST Client to Configure SSL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to configure REST client to use SSL.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The MicroProfile REST Client provides a way to configure SSL for communication
    with other services.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the MicroProfile REST Client uses the JVM trust store to verify
    the certificates when HTTPS connections are used. But sometimes, especially in
    cases of internal services, the certificates cannot be validated using the JVM
    trust store and you need to provide your custom trust store.
  prefs: []
  type: TYPE_NORMAL
- en: 'The MicroProfile REST Client accepts setting custom trust stores by using the
    `trustStore` configuration property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_quarkus_rest_clients_CO14-1)'
  prefs: []
  type: TYPE_NORMAL
- en: '`trustStore` sets the trust store location; this can be a class path resource
    (`classpath:`) or a file (`file:`)'
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_quarkus_rest_clients_CO14-2)'
  prefs: []
  type: TYPE_NORMAL
- en: '`trustStorePassword` sets the password for the trust store'
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_quarkus_rest_clients_CO14-3)'
  prefs: []
  type: TYPE_NORMAL
- en: '`trustStoreType` sets the type of trust store'
  prefs: []
  type: TYPE_NORMAL
- en: Keystores are also provided, which are really useful in two-way SSL connections.
  prefs: []
  type: TYPE_NORMAL
- en: MicroProfile REST Client accepts setting custom key stores by using the `keyStore`
    configuration property.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_quarkus_rest_clients_CO15-1)'
  prefs: []
  type: TYPE_NORMAL
- en: '`keyStore` sets the key store location; this can be a class path resource (`classpath:`)
    or a file (`file:`)'
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_quarkus_rest_clients_CO15-2)'
  prefs: []
  type: TYPE_NORMAL
- en: '`keyStorePassword` sets the password for the trust store'
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_quarkus_rest_clients_CO15-3)'
  prefs: []
  type: TYPE_NORMAL
- en: '`keyStoreType` sets the type of key store'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you can implement `javax.net.ssl.HostnameVerifier` to override the
    behavior when the URL’s hostname and the server’s identification hostname mismatch.
    Then the implementation of this interface can determine whether this connection
    should be allowed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of hostname verifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'You need to enable it in the configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most of the time, when you are running tests locally, you might not have installed
    all the trust stores or key stores required to connect to an external service.
    In these cases, you might run tests against the HTTP version of the service. This
    is not always possible, however, and in some third-party services, only the HTTPS
    protocol is enabled.
  prefs: []
  type: TYPE_NORMAL
- en: 'One possible solution to this problem is to configure the MicroProfile REST
    Client to trust any certificate. To do this, you need to configure the client
    and provide a custom trust manager:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_quarkus_rest_clients_CO16-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Creates a CDI bean; you need to use `@Inject` instead of `@RestClient` to make
    use of it
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_quarkus_rest_clients_CO16-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Disable host verification
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_quarkus_rest_clients_CO16-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Trust all certificates without doing any verification
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_quarkus_rest_clients_CO16-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Customize `SSLContext` with an empty trust manager, effectively negating all
    SSL checks
  prefs: []
  type: TYPE_NORMAL
- en: Then if you inject this instance instead of the production one, every HTTPS
    request is valid independently of the certificate used by the external service.
  prefs: []
  type: TYPE_NORMAL
