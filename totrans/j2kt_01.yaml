- en: Chapter 1\. Introduction
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Grain of a Programming Language
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like wood, a programming language has a grain. In both carpentry and programming,
    when you work *with* the grain, things go smoothly. When you work *against* the
    grain, things are more difficult. When you work against the grain of a programming
    language, you have to write more code than necessary, performance suffers, you
    are more likely to introduce defects, you usually have to override convenient
    defaults, and you have to fight against the tooling every step of the way.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Going against the grain involves constant effort with an uncertain payoff.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: For example, it has always been possible to write Java code in a functional
    style, but few programmers did before Java 8—for good reasons.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s Kotlin code that calculates the sum of a list of numbers by folding
    the list with the addition operator:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Let’s compare that to what was required in Java 1.0 to do the same.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: The mists of time will pass over you while transporting you to 1995…
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: 'Java 1.0 does not have first-class functions, so we have to implement functions
    as objects and define our own interfaces for different types of function. For
    example, the addition function takes two arguments, so we have to define the type
    of two-argument functions:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Then we have to write the `fold` higher-order function, hiding the iteration
    and mutation required by the `Vector` class. (The 1995 Java standard library doesn’t
    yet include the Collections Framework.)
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We have to define a separate class for every function we want to pass to our
    `fold` function. The addition operator can’t be passed around as a value, and
    the language has no method references, lambdas, or closures at this time, not
    even inner classes. Nor does Java 1.0 have generics or autoboxing—we have to cast
    the arguments to the expected type and write the boxing between reference types
    and primitives:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'And, finally, we can use all that to calculate the sum:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: That’s a lot of effort for what is a single expression in a mainstream language
    in 2020.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'But that’s not the end of it. Because Java doesn’t have standard function types,
    we can’t easily combine different libraries written in a functional style. We
    have to write adapter classes to map between the function types defined in different
    libraries. And, because the virtual machine has no JIT and a simple garbage collector,
    our functional code has worse performance than the imperative alternative:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In 1995, there is just not enough benefit to justify the effort of writing Java
    in a functional style. Java programmers found it easier to write imperative code
    that iterated over collections and mutated state.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Writing functional code *goes against the grain* of Java 1.0.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: A language’s grain forms over time as its designers and users build a common
    understanding of how language features interact and encode their understanding
    and preferences in libraries that others build upon. The grain influences the
    way that programmers write code in the language, which influences the evolution
    of the language and its libraries and programming tools, changing the grain, altering
    the way that programmers write code in the language, on and on in a continual
    cycle of mutual feedback and evolution.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，语言的粒度逐渐形成，设计者和用户在构建语言特性互动方面建立了共同的理解，并在库中编码他们的理解和偏好，供其他人基于此构建。这种粒度影响程序员在语言中编写代码的方式，进而影响语言及其库和编程工具的演变，改变粒度，改变程序员在语言中编写代码的方式，如此循环互动和演变不断进行。
- en: 'For example, as we move forward through time, Java 1.1 adds anonymous inner
    classes to the language, and Java 2 adds the Collections Framework to the standard
    library. Anonymous inner classes mean that we don’t need to write a named class
    for each function we want to pass to our `fold` function, but the resulting code
    is arguably harder to read:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，随着时间的推移，Java 1.1向语言添加了匿名内部类，Java 2向标准库添加了集合框架。匿名内部类意味着我们不需要为要传递给我们的`fold`函数的每个函数编写命名类，但由此产生的代码可能更难阅读：
- en: '[PRE6]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Functional idioms still go against the grain of Java 2.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 功能性习惯仍然不符合Java 2的粒度。
- en: 'Fast-forward to 2004, and Java 5 is the next release that significantly changes
    the language. It adds generics and autoboxing, which improve type safety and reduce
    boilerplate code:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 快进到2004年，Java 5是显著改变语言的下一个版本。它添加了泛型和自动装箱功能，增强了类型安全性并减少了样板代码：
- en: '[PRE7]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Java developers often use [Google’s Guava library](https://oreil.ly/dMX73) to
    add some common higher-order functions over collections (although `fold` is not
    among them), but even the authors of Guava recommend writing imperative code by
    default, because it has better performance and is usually easier to read.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Java开发者通常使用[Google的Guava库](https://oreil.ly/dMX73)来为集合添加一些常见的高阶函数（尽管`fold`不在其中），但即使是Guava的作者也建议默认情况下编写命令式代码，因为它具有更好的性能并且通常更易读。
- en: Functional programming still goes largely against the grain of Java 5, but we
    can see the start of a trend.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 功能性编程仍然大多不符合Java 5的粒度，但我们可以看到一种趋势的开始。
- en: 'Java 8 adds anonymous functions (aka lambda expressions) and method references
    to the language, and the Streams API to the standard library. The compiler and
    virtual machine optimize lambdas to avoid the performance overhead of anonymous
    inner classes. The Streams API fully embraces functional idioms, finally allowing:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8向语言添加了匿名函数（又称lambda表达式）和方法引用，并向标准库添加了Streams API。编译器和虚拟机优化lambda以避免匿名内部类的性能开销。Streams
    API充分支持功能性习惯，最终允许：
- en: '[PRE9]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: However, it isn’t entirely plain sailing. We still can’t pass the addition operator
    as a parameter to the Streams `reduce` function, but we have the standard library
    function `Integer::sum` that does the same thing. Java’s type system still creates
    awkward edge cases because of its distinction between reference and primitive
    types. The Streams API is missing some common higher-order functions that we would
    expect to find if coming from a functional language (or even Ruby). Checked exceptions
    don’t play well with the Streams API and functional programming in general. And
    making immutable classes with value semantics still involves a lot of boilerplate
    code. But with Java 8, Java has fundamentally changed to make a functional style
    work, if not completely with the grain of the language, at least not against it.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，事情并非一帆风顺。我们仍然无法将加法运算符作为参数传递给Streams的`reduce`函数，但我们有标准库函数`Integer::sum`可以实现同样的功能。Java的类型系统仍然因引用类型和原始类型之间的区别而产生一些尴尬的边缘情况。如果来自功能性语言（甚至是Ruby），Streams
    API缺少一些常见的高阶函数。检查异常与Streams API及功能性编程一般不兼容。而使用具有值语义的不可变类仍然涉及大量样板代码。但是，通过Java 8，Java在根本上已经改变，使功能风格运行起来，即使不完全符合语言的粒度，至少也不再与之相悖。
- en: The releases after Java 8 add a variety of smaller language and library features
    that support more functional programming idioms, but nothing that changes our
    sum calculation. And that brings us back to the present day.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8之后的发布增加了多种较小的语言和库特性，支持更多功能性编程习惯，但并未改变我们的求和计算方式。这将我们带回到现代。
- en: In the case of Java, the grain of the language, and the way programmers adapted
    to it, evolved through several distinct programming styles.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: An Opinionated History of Java Programming Style
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Like ancient poets, we divide the development of Java programming style into
    four distinct ages: Primeval, Beans, Enterprise, and Modern.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Primeval Style
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Originally intended for use in domestic appliances and interactive TV, Java
    only took off when Netscape adopted Java applets in its hugely popular Navigator
    browser. Sun released the Java development kit 1.0, Microsoft included Java in
    Internet Explorer, and suddenly everyone with a web browser had a Java runtime
    environment. Interest in Java as a programming language exploded.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'The fundamentals of Java were in place by this time:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: The Java virtual machine and its bytecode and class file format
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Primitive and reference types, null references, garbage collection
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes and interfaces, methods and control flow statements
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checked exceptions for error handling, the abstract windowing toolkit
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes for networking with internet and web protocols
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The loading and linking of code at runtime, sandboxed by a security manager
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, Java wasn’t yet ready for general-purpose programming: the JVM was
    slow and the standard library sparse.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Java looked like a cross between C++ and Smalltalk, and those two languages
    influenced the Java programming style of the time. The “getFoo/setFoo” and “AbstractSingletonProxyFactoryBean”
    conventions that programmers of other languages poke fun at were not yet widespread.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: One of Java’s unsung innovations was an official coding convention that spelled
    out how programmers should name packages, classes, methods, and variables. C and
    C++ programmers followed a seemingly infinite variety of coding conventions, and
    code that combined multiple libraries ended up looking like a right dog’s dinner
    somewhat inconsistent. Java’s one true coding convention meant that Java programmers
    could seamlessly integrate strangers’ libraries into their programs, and encouraged
    the growth of a vibrant open source community that continues to this day.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Bean Style
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After Java’s initial success, Sun set out to make it a practical tool for building
    applications. Java 1.1 (1996) added language features (most notably inner classes),
    improved the runtime (most notably just-in-time compilation and reflection), and
    extended the standard library. Java 1.2 (1998) added a standard collections API
    and the Swing cross-platform GUI framework, which ensured Java applications looked
    and felt equally awkward on every desktop operating system.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: 'At this time, Sun was eying Microsoft’s and Borland’s domination of corporate
    software development. Java had the potential to be a strong competitor to Visual
    Basic and Delphi. Sun added a slew of APIs that were heavily inspired by Microsoft
    APIs: JDBC for data base access (equivalent to Microsoft’s ODBC), Swing for desktop
    GUI programming (equivalent to Microsoft’s MFC), and the framework that had the
    greatest influence on Java programming style, JavaBeans.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当时，Sun 公司正密切关注微软和 Borland 在企业软件开发领域的主导地位。Java 有潜力成为 Visual Basic 和 Delphi 的强有力竞争对手。Sun
    添加了一系列 API，这些 API 在很大程度上受到了微软 API 的启发：JDBC 用于数据库访问（相当于微软的 ODBC），Swing 用于桌面 GUI
    编程（相当于微软的 MFC），以及对 Java 编程风格影响最大的框架，JavaBeans。
- en: The JavaBeans API was Sun’s answer to Microsoft’s ActiveX component model for
    low-code, graphical, drag-and-drop programming. Windows programmers could use
    ActiveX components in their Visual Basic programs or embed them in office documents
    or web pages on their corporate intranet. Despite how easy it was to use ActiveX
    components, they were notoriously difficult to write. JavaBeans were much easier;
    you merely had to follow some additional coding conventions for your Java class
    to be considered a “bean” that could be instantiated and configured in a graphical
    designer. The promise of “Write once, run anywhere” meant you would also be able
    to use—or sell—JavaBean components on any operating system, not just Windows.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: JavaBeans API 是 Sun 公司对微软 ActiveX 组件模型的回应，用于低代码、图形化、拖放式编程。Windows 程序员可以在其 Visual
    Basic 程序中使用 ActiveX 组件，或将其嵌入公司内部网的办公文档或网页中。尽管使用 ActiveX 组件非常容易，但编写它们却非常困难。JavaBeans
    则简单得多；你只需遵循一些额外的编码约定，你的 Java 类就可以被视为一个“bean”，可以在图形化设计师中实例化和配置。“一次编写，到处运行”的承诺意味着你也可以在任何操作系统上使用或销售
    JavaBean 组件，而不仅仅是在 Windows 上。
- en: For a class to be a JavaBean, it needed to have a constructor that took no arguments,
    be serializable, and declare an API made up of public properties that could be
    read and optionally written, methods that could be invoked, and events that objects
    of the class would emit. The idea was that programmers would instantiate beans
    in a graphical application designer, configure them by setting their properties,
    and connect events emitted by beans to the methods of other beans. By default,
    the Beans API defined properties by pairs of methods whose names started with
    *get* and *set*. This default could be overridden, but doing so required the programmer
    to write more classes of boilerplate code. Programmers usually went to the effort
    only when retrofitting existing classes to act as JavaBeans. In new code, it was
    much easier to go with the grain.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要使一个类成为 JavaBean，它需要有一个不带参数的构造函数，可以序列化，并声明由公共属性组成的 API，这些属性可以被读取和（可选地）写入，可以调用的方法，以及对象在类中发出的事件。这个理念是程序员可以在图形应用程序设计师中实例化
    beans，通过设置它们的属性来配置它们，并将 beans 发出的事件连接到其他 beans 的方法。默认情况下，Beans API 通过以 *get* 和
    *set* 开头的方法对来定义属性。虽然可以重写这个默认设置，但这样做需要程序员编写更多的样板代码。程序员通常只在将现有类改造为 JavaBeans 时才会这样做。在新代码中，沿着这个方向进行更容易。
- en: The drawback of Beans style is that it relies heavily on mutable state and requires
    more of that state to be public than plain old Java objects do, because visual
    builder tools could not pass parameters to an object’s constructor, but instead
    had to set properties. User interface components work well as beans, because they
    can safely be initialized with default content and styling and adjusted after
    construction. When we have classes that have no reasonable defaults, treating
    them in the same way is error-prone, because the type checker can’t tell us when
    we have provided all the required values. The Beans conventions make writing correct
    code harder, and changes in dependencies can silently break client code.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Beans 风格的缺点在于它严重依赖可变状态，并且需要更多的状态是公共的，而不是像普通的 Java 对象那样，因为视觉构建工具不能将参数传递给对象的构造函数，而是必须设置属性。用户界面组件作为
    beans 工作得很好，因为它们可以安全地用默认内容和样式初始化，并在构造后进行调整。当我们有没有合理默认值的类时，将它们视为相同的方式是容易出错的，因为类型检查器不能告诉我们何时提供了所有必需的值。Beans
    约定使得编写正确的代码更加困难，并且依赖关系的变化可能会悄无声息地破坏客户端代码。
- en: In the end, graphical composition of JavaBeans did not become mainstream, but
    the coding conventions stuck. Java programmers followed the JavaBean conventions
    even when they had no intention of their class being used as a JavaBean. Beans
    had an enormous, lasting, and not entirely positive influence on Java programming
    style.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，JavaBeans的图形组合并未成为主流，但其编码约定却深入人心。即使程序员并不打算将其类用作JavaBean，Java程序员仍然遵循JavaBean的约定。Beans对Java编程风格产生了巨大而持久的影响，尽管并非完全正面。
- en: Enterprise Style
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 企业风格
- en: Java did eventually spread through the enterprise. It didn’t replace Visual
    Basic on the corporate desktop as expected, but rather unseated C++ as the server-side
    language of choice. In 1998, Sun released Java 2 Enterprise Edition (then known
    as J2EE, now JakartaEE), a suite of standard APIs for programming server-side,
    transaction processing systems.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Java最终在企业中获得了普及。它没有如预期般取代企业桌面上的Visual Basic，而是取代了C++成为服务器端首选语言。1998年，Sun发布了Java
    2企业版（当时称为J2EE，现在是JakartaEE），这是用于编程服务器端事务处理系统的一套标准API。
- en: The J2EE APIs suffer from *abstraction inversion*. The JavaBeans and applets
    APIs also suffer from abstraction inversion—they both disallow passing parameters
    to constructors, for example—but it is far more severe in J2EE. J2EE applications
    don’t have a single entry point. They are composed of many small components whose
    lifetime is managed by an application container, and are exposed to one another
    through a JNDI name service. Applications need a lot of boilerplate code and mutable
    state to look up the resources they depend on. Programmers responded by inventing
    *dependency injection* (DI) frameworks that did all the resource lookup and binding,
    and managed lifetimes. The most successful of these is Spring. It builds upon
    the JavaBeans coding conventions and uses reflection to compose applications from
    Bean-like objects.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: J2EE API存在*抽象反转*问题。JavaBeans和小程序API也有抽象反转问题——例如，它们都不允许向构造函数传递参数，但在J2EE中问题更为严重。J2EE应用程序没有单一的入口点。它们由许多由应用容器管理生命周期的小组件组成，并通过JNDI名称服务相互暴露。应用程序需要大量样板代码和可变状态来查找其依赖的资源。程序员们通过发明*依赖注入*（DI）框架来应对这些问题，这些框架负责资源查找、绑定和管理生命周期。其中最成功的是Spring。它建立在JavaBeans编码约定的基础上，利用反射从类似Bean的对象组合应用程序。
- en: In terms of programming style, DI frameworks encourage programmers to eschew
    direct use of the `new` keyword and instead rely on the framework to instantiate
    objects. The Android APIs also exhibit abstraction inversion, and Android programmers
    also turn to DI frameworks to help them write to the APIs. DI frameworks’ focus
    on mechanism over domain modeling leads to enterprisey class names such as Spring’s
    infamous `AbstractSingletonProxyFactoryBean`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 就编程风格而言，依赖注入（DI）框架鼓励程序员避免直接使用`new`关键字，而是依赖框架来实例化对象。Android API也表现出抽象反转，Android程序员也倾向于使用DI框架来帮助他们编写API。DI框架更专注于机制而非领域建模，导致出现了像Spring那种臭名昭著的`AbstractSingletonProxyFactoryBean`这样的企业级类名。
- en: On the plus side, though, the Enterprise Era saw the release of Java 5, which
    added generics and autoboxing to the language, the most significant change to
    date. This era also saw a massive uptake of open source libraries in the Java
    community, powered by the Maven packaging conventions and central package repository.
    The availability of top-notch open source libraries fueled the adoption of Java
    for business-critical application development, and led to more open source libraries,
    in a virtuous circle. This was followed by best-in-class development tools, including
    the IntelliJ IDE, which we use in this book.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，企业时代也见证了Java 5的发布，该版本为语言添加了泛型和自动装箱，这是迄今为止最重大的变化。该时代还看到Java社区对开源库的大规模采用，这得益于Maven打包约定和中央仓库。顶级开源库的可用性推动了Java在关键业务应用开发中的采纳，并导致更多的开源库出现，形成良性循环。此后还出现了一流的开发工具，包括我们在本书中使用的IntelliJ
    IDE。
- en: Modern Style
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 现代风格
- en: Java 8 brought the next big change to the language—lambdas—and significant additions
    to the standard library to take advantage of them. The Streams API encouraged
    a functional programming style, in which processing is performed by transforming
    streams of immutable values rather than changing the state of mutable objects.
    A new date/time API ignored JavaBeans coding conventions for property accessors
    and followed coding conventions common to the Primeval Age.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8为语言带来了下一个重大变化——lambda表达式——以及对标准库的重大增强以利用它们。流API鼓励一种函数式编程风格，其中处理是通过转换不可变值流而不是改变可变对象的状态来完成的。一个新的日期/时间API忽略了JavaBeans编码约定，而是遵循了原始时代的编码约定。
- en: The growth of the cloud platforms meant that programmers didn’t need to deploy
    their servers into JavaEE application containers. Lightweight web application
    frameworks let programmers write a `main` function to compose their applications.
    Many server-side programmers stopped using DI frameworks—function and object composition
    were good enough—so DI frameworks released greatly simplified APIs to stay relevant.
    With no DI framework or mutable state, there’s less need to follow JavaBean coding
    conventions. Within a single codebase, exposing fields of immutable values works
    fine, because the IDE can encapsulate a field behind accessors in an instant if
    they’re needed.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 云平台的增长意味着程序员不再需要将服务器部署到JavaEE应用容器中。轻量级的Web应用框架允许程序员编写一个`main`函数来组合他们的应用程序。许多服务器端程序员停止使用DI框架——函数和对象组合已经足够好了——因此DI框架发布了大大简化的API以保持相关性。没有DI框架或可变状态，就不需要遵循JavaBean编码约定。在单一代码库中，暴露不可变值字段也没问题，因为如果需要，IDE可以在瞬间将字段封装在访问器后面。
- en: Java 9 introduced modules, but so far they have not seen widespread adoption
    outside the JDK itself. The most exciting thing about recent Java releases has
    been the modularization of the JDK and removal of seldom-used modules, such as
    CORBA, from the JDK into optional extensions.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9引入了模块，但到目前为止，除了JDK本身外，它们还没有被广泛采用。最令人兴奋的是最近Java版本的模块化和将鲜为人知的模块（如CORBA）从JDK移入可选扩展中。
- en: The Future
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 未来
- en: 'The future of Java promises more features to make Modern Style easier to apply:
    records, pattern matching, user-defined value types, and eventually the unification
    of primitive and reference types into a uniform type system.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Java的未来承诺提供更多功能，使现代风格更易于应用：记录、模式匹配、用户定义的值类型，最终将原始类型和引用类型统一为一致的类型系统。
- en: However, this is a challenging effort that will take many years to complete.
    Java started off with some deep-seated inconsistencies and edge cases that are
    hard to unify into clean abstractions while staying backward compatible. Kotlin
    has the benefit of 25 years of hindsight, and a clean slate from which to start
    afresh.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这是一个具有挑战性的工作，需要花费多年时间才能完成。Java最初存在一些根深蒂固的不一致性和边界情况，很难统一为干净的抽象并保持向后兼容性。Kotlin有着25年的远见和从头开始的干净板，这是一个巨大的优势。
- en: The Grain of Kotlin
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kotlin的风格
- en: Kotlin is a young language, but it clearly has a different grain than Java.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin是一种年轻的语言，但它显然有着与Java不同的风格。
- en: 'When we wrote this, the [“Why Kotlin”](https://oreil.ly/pqZbu) section of the
    Kotlin home page gave four design goals: concise, safe, interoperable, and tool-friendly.
    The designers of the language and its standard library also encoded implicit preferences
    that contribute to these design goals. These preferences include:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们写这篇文章时，Kotlin首页的[“为什么选择Kotlin”](https://oreil.ly/pqZbu)部分列出了四个设计目标：简洁、安全、可互操作性和工具友好性。语言和其标准库的设计者还编码了有助于实现这些设计目标的隐含偏好。这些偏好包括：
- en: Kotlin prefers the transformation of immutable data to mutation of state.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin更喜欢转换不可变数据而不是变异状态。
- en: Data classes make it easy to define new types with value semantics. The standard
    library makes it easier and more concise to transform collections of immutable
    data than to iterate and mutate data in place.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类使定义具有值语义的新类型变得容易。标准库使得转换不可变数据集合比就地迭代和变异数据更容易且更简洁。
- en: Kotlin prefers behavior to be explicit.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin更喜欢行为明确。
- en: For example, there is no implicit coercion between types, even from smaller
    to larger range. Java implicitly converts `int` values to `long` values, because
    there is no loss of precision. In Kotlin, you have to call `Int.toLong()` explicitly.
    The preference for explicitness is especially strong when it comes to control
    flow. Although you can overload arithmetic and comparison operators for your own
    types, you cannot overload the shortcut logical operators (`&&` and `||`), because
    that would allow you to define different control flow.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，类型之间没有隐式强制转换，即使是从较小范围到较大范围也是如此。Java会将`int`值隐式转换为`long`值，因为没有精度损失。在Kotlin中，你必须显式调用`Int.toLong()`。在控制流方面，对显式性的偏好尤为强烈。虽然你可以为自己的类型重载算术和比较运算符，但不能重载快捷逻辑运算符（`&&`和`||`），因为这样会允许你定义不同的控制流。
- en: Kotlin prefers static over dynamic binding.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin更青睐静态绑定而非动态绑定。
- en: Kotlin encourages a type-safe, compositional coding style. Extension functions
    are bound statically. By default, classes are not extensible and methods are not
    polymorphic. You must explicitly opt in to polymorphism and inheritance. If you
    want to use reflection, you have to add a platform-specific library dependency.
    Kotlin is designed from the outset to be used with a language-aware IDE that statically
    analyzes the code to guide the programmer, automate navigation, and automate program
    transformation.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin鼓励一种类型安全的、组合式的编码风格。扩展函数在静态绑定时绑定。默认情况下，类不可扩展，方法不具有多态性。你必须显式地选择多态性和继承。如果要使用反射，你必须添加一个特定于平台的库依赖。Kotlin从一开始就被设计用于与语言感知的IDE一起使用，该IDE静态分析代码以指导程序员、自动化导航和自动化程序转换。
- en: Kotlin doesn’t like special cases.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin不喜欢特殊情况。
- en: Compared to Java, Kotlin has fewer special cases that interact in unpredictable
    ways. There is no distinction between primitive and reference types. There is
    no `void` type for functions that return but do not return a value; functions
    in Kotlin either return a value or never return at all. Extension functions allow
    you to add new operations to existing types that look the same at the call point.
    You can write new control structures as inline functions, and the `break`, `continue`,
    and `return` statements act the same as they do in built-in control structures.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 与Java相比，Kotlin的特殊情况较少，并且交互方式不可预测。没有基本类型和引用类型之分。没有`void`类型用于返回但不返回值的函数；Kotlin中的函数要么返回一个值，要么根本不返回。扩展函数允许你为现有类型添加新操作，而在调用点看起来相同。你可以将新的控制结构编写为内联函数，`break`、`continue`和`return`语句的行为与内置控制结构中的行为相同。
- en: Kotlin breaks its own rules to make migration easier.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin为了简化迁移而打破了自己的规则。
- en: The Kotlin language has features to allow idiomatic Java and Kotlin code to
    coexist in the same codebase. Some of those features remove guarantees provided
    by the type checker and should *only* be used to interoperate with legacy Java.
    For example, `lateinit` opens a hole in the type system so that Java dependency
    injection frameworks that initialize objects by reflection can inject values through
    the encapsulation boundaries that are normally enforced by the compiler. If you
    declare a property as `lateinit var`, it’s up to you to ensure the code initializes
    the property before reading it. The compiler will not catch your mistakes.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin语言具有允许在同一代码库中存在惯用Java和Kotlin代码的功能。其中一些功能会移除类型检查器提供的保证，**仅应**用于与旧版Java进行交互。例如，`lateinit`打开了类型系统的漏洞，以便Java依赖注入框架可以通过反射初始化对象并通过编译器通常强制执行的封装边界注入值。如果将属性声明为`lateinit
    var`，则由你来确保代码在读取属性之前初始化它。编译器不会捕获你的错误。
- en: When we, Nat and Duncan, revisit the earliest code we wrote in Kotlin, it tends
    to look like Java dressed in Kotlin syntax. We came to Kotlin after years writing
    a lot of Java and had ingrained habits that affected how we wrote Kotlin code.
    We wrote unnecessary boilerplate, didn’t make good use of the standard library,
    and avoided using null because we weren’t yet used to the type checker enforcing
    null safety. The Scala programmers on our team went too far the other way—their
    code looked like Kotlin trying to be Scala, cosplaying as Haskell. None of us
    had yet found the sweet spot that comes from working with the grain of Kotlin.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们，Nat 和 Duncan，重新审视我们最早用 Kotlin 编写的代码时，它往往看起来像是用 Kotlin 语法打扮成的 Java。我们在写了很多年的
    Java 后转向 Kotlin，养成了影响我们编写 Kotlin 代码的习惯。我们写了不必要的样板文件，没有充分利用标准库，并且避免使用 null，因为我们还不习惯类型检查器强制执行空安全。我们团队中的
    Scala 程序员走得太远了——他们的代码看起来像是 Kotlin 试图成为 Scala，扮演 Haskell。我们当中没有人找到与 Kotlin 的纹理相匹配的甜蜜点。
- en: The path to idiomatic Kotlin is complicated by the Java code we have to keep
    working along the way. In practice, it is not enough just to learn Kotlin. We
    have to work with the different grains of Java *and* Kotlin, being sympathetic
    to both as we gradually transition from one to the other.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 通往惯用 Kotlin 的道路受到我们必须保持工作的 Java 代码的影响。实际上，仅仅学习 Kotlin 是不够的。我们必须同时处理 Java *和*
    Kotlin 的不同特点，对两者都持有同情心，逐渐从一个转向另一个。
- en: Refactoring to Kotlin
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kotlin 重构
- en: When we started our journey to Kotlin, we were responsible for maintaining and
    enhancing business-critical systems. We were never able to focus *only* on converting
    our Java codebase to Kotlin. We always had to migrate code to Kotlin at the same
    time as changing the system to meet new business needs, maintaining a mixed Java/Kotlin
    codebase as we did so. We managed the risk by working in small changes, making
    each easy to understand and cheap to discard if we found out it broke something.
    Our process was first to convert Java code to Kotlin, giving us a Java-esque design
    in Kotlin syntax. We then incrementally applied Kotlin language features to make
    the code increasingly easy to understand, more type safe, more concise, and with
    a more compositional structure that is easier to change without unpleasant surprises.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始向 Kotlin 进发时，我们负责维护和增强业务关键系统。我们从未能只专注于将我们的 Java 代码库转换为 Kotlin。我们总是不得不在同时将代码迁移到
    Kotlin，同时改变系统以满足新的业务需求，我们在此过程中保持了一个混合的 Java/Kotlin 代码库。我们通过进行小的更改来管理风险，使每个更改易于理解，并且如果我们发现它破坏了某些东西，就廉价丢弃。我们的流程首先将
    Java 代码转换为 Kotlin，给我们带来了 Kotlin 语法中的 Java 式设计。然后我们逐步应用 Kotlin 语言特性，使代码变得越来越易于理解，更加类型安全，更加简洁，并且具有更具组合结构的结构，更易于改变而不会有不愉快的惊喜。
- en: 'Small, safe, reversible changes that improved the design: we *refactored* from
    idiomatic Java to idiomatic Kotlin.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 从惯用的 Java 到惯用的 Kotlin，进行了一系列小的、安全的、可逆的改变，以改善设计。
- en: Refactoring *between* languages is usually harder than refactoring *within*
    a single language because refactoring tools do not work well across the boundaries
    between the languages, if they work at all. Porting logic from one language to
    another must be done manually, which takes longer and introduces more risk. Once
    multiple languages are in use, the language boundary impedes refactoring because
    when you refactor code in one language, the IDE does not update dependent code
    written in other languages to be compatible.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在语言之间进行重构通常比在单一语言中进行重构更难，因为重构工具在语言之间的边界上效果不佳，如果有的话。从一种语言迁移到另一种语言必须手动完成，这需要更长的时间，并引入了更多的风险。一旦使用了多种语言，语言边界会妨碍重构，因为当您重构一种语言中的代码时，IDE
    不会更新其他语言中编写的依赖代码以使其兼容。
- en: What makes the combination of Java and Kotlin unique is the (relatively) seamless
    boundary between the two languages. Thanks to the design of the Kotlin language,
    the way it is mapped to the JVM platform, and JetBrains’ investment in developer
    tooling, refactoring Java to Kotlin and refactoring a combined Java/Kotlin codebase
    is almost as easy as refactoring in a single codebase.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 使 Java 和 Kotlin 的组合独特的是两种语言之间（相对）无缝的边界。由于 Kotlin 语言的设计、它被映射到 JVM 平台的方式，以及 JetBrains
    对开发工具的投资，将 Java 重构为 Kotlin 和重构合并的 Java/Kotlin 代码库几乎和在单一代码库中进行重构一样容易。
- en: Our experience has been that we can refactor Java to Kotlin without affecting
    productivity, and that productivity then accelerates as we convert more of the
    codebase to Kotlin.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的经验表明，我们可以将 Java 重构为 Kotlin 而不影响生产力，并且随着我们将更多的代码库转换为 Kotlin，生产力会加速提升。
- en: Refactoring Principles
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重构原则
- en: 'The practice of refactoring has come a long way since its initial popularization
    in Martin Fowler’s book, [*Refactoring: Improving the Design of Existing Code*](bibliography01.html#F_RITDOEC_1999)
    (Addison-Wesley), published in 1999. This book had to detail manual steps for
    even simple refactorings like renaming identifiers but notes that some state-of-the-art
    development environments were beginning to provide automated support to reduce
    such drudgery. Nowadays we expect our tools to automate even complicated scenarios
    such as extracting an interface or changing function signatures.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 自从马丁·福勒在1999年出版的书籍[*《重构：改善既有代码的设计》*](bibliography01.html#F_RITDOEC_1999)（Addison-Wesley）中首次流行以来，重构的实践已经走了很长一段路。该书甚至详细说明了像重命名标识符这样简单的重构的手动步骤，但指出一些先进的开发环境已经开始提供自动化支持来减少这种单调乏味的工作。如今，我们期望我们的工具甚至能自动化复杂的情况，比如提取接口或改变函数签名。
- en: These individual refactorings rarely stand alone though. Now that the building-block
    refactorings can be performed automatically, we have the time and energy to combine
    them to make larger-scale changes to our codebase. When the IDE does not have
    distinct user-interface actions for a large-scale transformation we wish to do,
    we have to perform it as a sequence of more granular refactorings. We use the
    IDE’s automatic refactoring whenever we can, and fall back on text editing when
    the IDE does not automate a transformation we need.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这些单独的重构很少是孤立的。现在建筑块重构可以自动执行，我们有时间和精力将它们结合起来，对代码库进行更大规模的改变。当IDE没有为我们希望执行的大规模转换提供明确的用户界面操作时，我们必须将其作为一系列更细粒度的重构操作序列来执行。我们尽可能使用IDE的自动重构，当IDE不能自动化我们需要的转换时，我们则退而使用文本编辑。
- en: It’s tedious and error-prone to refactor by editing text. To reduce the risk,
    and our boredom, we minimize the amount of text editing we have to do. If we *must*
    edit text, we prefer that edit to affect a single expression. So we use automatic
    refactorings to transform the code so that is possible, edit one expression, and
    then use automatic refactorings to tidy back up to the final state we’re aiming
    for.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 通过编辑文本来进行重构是单调且容易出错的。为了减少风险和无聊感，我们尽量减少需要编辑文本的次数。如果我们*必须*编辑文本，我们更希望编辑影响单个表达式。因此，我们使用自动重构来转换代码，使这种操作成为可能，然后编辑一个表达式，再利用自动重构将其整理回我们的最终目标状态。
- en: The first time we describe a large-scale refactoring, we’ll go through it step
    by step and show how the code changes at each step. This takes quite a lot of
    space on the page and will take a bit of reading time to follow. In practice,
    however, these large refactorings are quick to apply. They typically take a few
    seconds, a few minutes at most.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们第一次描述大规模重构时，我们将逐步展示每个步骤的代码变化。这在页面上占据了相当多的空间，并需要一些阅读时间来跟进。然而，在实践中，这些大规模重构是快速应用的。通常只需几秒钟，最多几分钟。
- en: We expect the refactorings published here to date quite quickly as tools improve.
    The individual IDE steps may be renamed, and some combinations might be implemented
    as single refactorings in their own right. Experiment in your context to find
    ways of gradually and safely transforming your code that are better than those
    we present, and then share them with the world too.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 随着工具的改进，我们预计这里发布的重构技术会迅速更新。各个IDE的步骤可能会更名，一些组合可能会作为独立的重构技术实现。在您的环境中进行实验，找到逐步和安全地转换代码的方法，比我们提供的更好，并与世界分享。
- en: We Assume Good Test Coverage
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们假设测试覆盖率良好。
- en: 'As Martin Fowler says in [*Refactoring: Improving the Design of Existing Code*](bibliography01.html#F_RITDOEC_1999):
    “[I]f you want to refactor, the essential precondition is having solid tests.”
    Good test coverage ensures that the code transformations we want to only improve
    design have not inadvertently changed our system’s behavior. In this book, we
    assume that you have good test coverage. We do not cover how to write automated
    tests. Other authors have addressed these topics in more detail than we could
    in this book, for example: [*Test-Driven Development By Example*](bibliography01.html#B_TDDBE_2002)
    by Kent Beck (Addison-Wesley) and [*Growing Object-Oriented Software Guided By
    Tests*](bibliography01.html#FP_GOOSGBT_2009) by Steve Freeman and Nat Pryce (Addison-Wesley).
    We do, however, show how to apply Kotlin features to improve our tests.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 正如马丁·福勒在[*重构：改善现有代码的设计*](bibliography01.html#F_RITDOEC_1999)中所说：“[如果你想要重构，重要的前提是拥有可靠的测试。]”良好的测试覆盖率确保了我们只想要改进设计的代码转换没有无意间改变系统行为。在本书中，我们假设您有良好的测试覆盖率。我们不讨论如何编写自动化测试。其他作者已经更详细地讨论了这些主题，例如：[*通过示例驱动开发*](bibliography01.html#B_TDDBE_2002)肯特·贝克（Addison-Wesley）和[*由测试指导的面向对象软件开发*](bibliography01.html#FP_GOOSGBT_2009）由史蒂夫·弗里曼和纳特·普莱斯（Addison-Wesley）。但是，我们确实展示了如何应用
    Kotlin 特性来改进我们的测试。
- en: As we walk through multistep code transformations, we won’t always say when
    we run the tests. Assume that we run our tests after every change that we show
    that compiles, no matter how small.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们进行多步代码转换时，我们不会总是说明何时运行测试。假设我们在每次编译后运行我们展示的每一项更改的测试，无论多么小。
- en: 'If your system does not already have good test coverage, it can be difficult
    (and expensive) to retrofit tests to the code because the logic you want to test
    is entangled with other aspects of the system. You’re in a chicken and egg situation:
    you have to refactor to be able to add tests so that you can safely refactor.
    Again, other authors have addressed these topics in more detail than we could,
    for example: [*Working Effectively with Legacy Code*](bibliography01.html#F_WEWLC_2004)
    by Michael Feathers (Pearson).'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的系统尚未具有良好的测试覆盖率，则向代码添加测试可能会很困难（和昂贵），因为您要测试的逻辑与系统的其他方面纠缠在一起。您陷入了一个鸡生蛋和蛋生鸡的困境：您必须重构才能添加测试，以便您可以安全地重构。同样，其他作者已经更详细地讨论了这些主题，例如：[*与遗留代码有效地合作*](bibliography01.html#F_WEWLC_2004)迈克尔·费瑟斯（Pearson）。
- en: We’ve listed more books about these topics in the [Bibliography](bibliography01.html#bibliography).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[参考文献](bibliography01.html#bibliography)中列出了更多关于这些主题的书籍。
- en: We Commit for Git Bisect
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们为 Git Bisect 提交
- en: Just as we don’t explicitly state when we run our tests, nor do we explicitly
    state when we commit our changes. Assume we commit our changes whenever they have
    added value to the code, no matter how small.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们不明确说明何时运行测试，也不明确说明何时提交更改。假设我们在代码增加了价值时提交更改，无论多么小。
- en: We know our test suite isn’t perfect. If we accidentally break something that
    is not caught by our tests, we want to find the commit that introduced the fault
    and fix it as quickly as we can.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道我们的测试套件并不完美。如果我们意外破坏了某些未被测试捕获的内容，我们希望尽快找到引入错误的提交并修复它。
- en: The `git bisect` command automates that search. We write a new test that demonstrates
    the error, and `git bisect` does a binary search of the history to find the first
    commit that makes that test fail.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`git bisect` 命令自动化了该搜索。我们编写一个新的测试来演示错误，`git bisect` 对历史进行二进制搜索，找到使该测试失败的第一个提交。'
- en: If the commits in our history are large, and contain a mishmash of unrelated
    changes, `git bisect` won’t help as much as it could. It cannot tell which of
    the source changes within a commit introduced the error. If commits mix refactoring
    *and* changes to behavior, reverting a bad refactoring step is likely to break
    *other* behavior in the system.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们历史中的提交很大，并且包含杂乱无章的不相关更改，`git bisect` 的帮助就不那么大了。它无法告诉哪个提交的源更改引入了错误。如果提交混合了重构*和*行为更改，那么恢复错误的重构步骤可能会破坏系统中的*其他*行为。
- en: Therefore, we commit small, focused changes that separate refactorings from
    each other, and from changes to behavior, to make it easy to understand what changed
    and fix any erroneous change. For the same reason, we very rarely squash commits.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们提交小而专注的更改，将重构与行为更改分开，以便轻松理解发生了什么变化并修复任何错误的更改。出于同样的原因，我们很少压缩提交。
- en: Note
  id: totrans-107
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: We prefer to commit changes straight onto the mainline branch—“trunk-based development”—but
    changing code in a sequence of small, independent commits is just as beneficial
    when working in branches and merging less frequently.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们更喜欢直接将更改提交到主线分支——“基于主干的开发”——但在分支上工作并较少频繁合并时，通过一系列小的独立提交进行代码更改同样有益。
- en: What Are We Working On?
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们正在做什么？
- en: In the chapters that follow, we take examples from the codebase of *Travelator*,
    a fictional application for planning and booking international surface travel.
    Our (still fictional) users plan routes by sea, rail, and road; search for places
    to stay and sights to see; compare their options by price, time, and spectacle;
    and finally book their trips, all from web and mobile frontends that invoke backend
    services via HTTP.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将从*Travelator*代码库中获取示例，这是一个虚构的用于规划和预订国际陆面旅行的应用程序。我们（仍然是虚构的）用户通过海上、铁路和公路规划路线；搜索住宿和景点；通过价格、时间和景观比较选项；最后通过Web和移动前端预订他们的旅行，这些前端通过HTTP调用后端服务。
- en: 'Each chapter pulls an informative example from a different part of the Travelator
    system, but they share common domain concepts: money, currency conversion, journeys,
    itineraries, bookings, and so on.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 每一章节从Travelator系统的不同部分提取一个信息丰富的例子，但它们共享共同的领域概念：货币、货币转换、旅程、行程安排、预订等等。
- en: Our aim is that, like our Travelator application, this book will help you plan
    your journey from Java to Kotlin.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是，就像我们的Travelator应用程序一样，这本书将帮助您从Java过渡到Kotlin规划您的旅程。
- en: Let’s Get Started!
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Enough chitchat. You’re probably itching to convert all that Java to Kotlin.
    We’ll start in the next chapter by adding Kotlin support to our project’s build
    file.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 足够的闲聊。 您可能急于将所有Java代码转换为Kotlin。 我们将在下一章开始，通过向项目的构建文件添加Kotlin支持。
