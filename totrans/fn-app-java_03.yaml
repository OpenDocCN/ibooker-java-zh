- en: Chapter 2\. Functional Java
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unsurprisingly, *lambda expressions* are the key to having a functional approach
    in Java.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to use lambdas in Java, why they are so
    important, how to use them efficiently, and how they work internally.
  prefs: []
  type: TYPE_NORMAL
- en: What Are Java Lambdas?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A lambda expression is a single line or block of Java code that zero or more
    parameters and might return a value. From a simplified point of view, a lambda
    is like an *anonymous method* that doesn’t belong to any object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Let’s look at the details of the syntax and how lambdas are implemented in Java.
  prefs: []
  type: TYPE_NORMAL
- en: Lambda Syntax
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Java syntax for lambdas is quite similar to the mathematical notation you
    saw in [Chapter 1](ch01.xhtml#_01-an-introduction) for lambda calculus:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The syntax consists of three distinct parts:'
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: A comma-separated list of parameters, just like a method argument list. Unlike
    method arguments, though, you can omit the argument types if the compiler can
    infer them. Mixing implicitly and explicitly typed parameters is not allowed.
    You don’t need parentheses for a single parameter, but they are required if none
    or more than one parameter is present.
  prefs: []
  type: TYPE_NORMAL
- en: Arrow
  prefs: []
  type: TYPE_NORMAL
- en: The `->` (arrow) separates the parameters from the lambda body. It’s the equivalent
    to <math alttext="lamda"><mi>λ</mi></math> in lambda calculus.
  prefs: []
  type: TYPE_NORMAL
- en: Body
  prefs: []
  type: TYPE_NORMAL
- en: Either a single expression or a code block. Single-line expressions don’t require
    curly braces, and their evaluated result returns implicitly without a `return`
    statement. A typical Java code block is used if the body is represented by more
    than a single expression. It must be wrapped in curly braces and explicitly use
    a `return` statement if a value is supposed to be returned.
  prefs: []
  type: TYPE_NORMAL
- en: That is all the syntax definition there is for lambdas in Java. With its multiple
    ways of declaring a lambda, you can write the same lambda with different levels
    of verbosity, as seen in [Example 2-1](#_01-functions_java-lambdas_syntax-compare).
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-1\. Different ways of writing the same lambda
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_functional_java_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The most verbose variant: an explicitly typed parameter in parenthesis and
    a body block.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_functional_java_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first mixed variant: type inference for parameters allows removing the
    explicit type, and a single parameter doesn’t need parenthesis. That shortens
    the lambda declaration slightly without removing information due to the surrounding
    context.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_functional_java_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The second mixed variant: an explicitly typed parameter in parenthesis but
    a single expression body instead of a block, no curly braces or `return` statement
    are needed.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_functional_java_CO1-4)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The most concise variant: As the body is reducible to a single expression.'
  prefs: []
  type: TYPE_NORMAL
- en: Which variant to choose depends highly on the context and personal preference.
    Usually, the compiler can infer the types, but that doesn’t mean a human reader
    is as good at understanding the shortest code possible as a compiler does.
  prefs: []
  type: TYPE_NORMAL
- en: Even though you should always strive for clean and more concise code, that doesn’t
    mean it has to be as minimal as possible. A certain amount of verbosity might
    help any reader — you included — to understand the reasoning behind the code better
    and make the mental model of your code more graspable.
  prefs: []
  type: TYPE_NORMAL
- en: Functional Interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we’ve only looked at the general concept of lambdas in isolation. However,
    they still have to exist inside Java and its concepts and language rules as well.
  prefs: []
  type: TYPE_NORMAL
- en: Java is known for its backward compatibility. That’s why even though the lambda
    syntax is a breaking change to the Java syntax itself, they’re still based on
    ordinary interfaces to be backward compatible and feel quite familiar to any Java
    developer.
  prefs: []
  type: TYPE_NORMAL
- en: To achieve their *first-class citizenship*, lambdas in Java require a representation
    comparable to the existing types, like objects and primitives, as discussed in
    [“First-Class and Higher-Order Functions”](ch01.xhtml#_01-an-introduction_concepts_first-class).
    Therefore, lambdas are represented by a specialized subtype of interfaces, so-called
    *functional interfaces*.
  prefs: []
  type: TYPE_NORMAL
- en: There isn’t any explicit syntax or language keyword for *functional interfaces*.
    They look and feel like any other interface, can extend or be extended by other
    interfaces, and classes can implement them. If they are just like “normal” interfaces,
    what makes them a “functional” interface then? It’s their enforced requirement
    that they may only define a *single abstract method* (SAM).
  prefs: []
  type: TYPE_NORMAL
- en: As the name signifies, the SAM count only applies to `abstract` methods. There’s
    no limit to any additional, non-`abstract` methods. Neither `default` nor `static`
    methods are abstract, hence not relevant for the SAM count. That’s why they are
    often used to complement the capabilities of the lambda type.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Most functional interfaces of the JDK give you additional `default` and `static`
    methods related to the type. Checking out the interface declarations of any functional
    interface might reveal many hidden gems of functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Consider [Example 2-2](#_01-functions-functional-interfaces_predicate), which
    shows a simplified version^([1](ch02.xhtml#idm45115256766512)) of the functional
    interface `java.util.function.Predicate<T>`. A `Predicate` is a functional interface
    for testing conditions, which will be explained in more detail in [“The Big Four
    Functional Interface Categories”](ch03.xhtml#_01-functions_the-big-four). Besides
    having a single abstract method, `boolean test(T t)`, it provides five additional
    methods (three `default`, two `static`).
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-2\. Simplified `java.util.functional.Predicate<T>`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_functional_java_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The type has a `@FunctionalInterface` annotation, which isn’t explicitly required.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_functional_java_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The single abstract method of the type `Predicate<T>`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_functional_java_CO2-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Several `default` methods provide support for functional composition.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_functional_java_CO2-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Convenience `static` methods are used to simplify creation or to wrap existing
    lambdas.
  prefs: []
  type: TYPE_NORMAL
- en: Any interface with a single abstract method is automatically a functional interface.
    Therefore, any of their implementations is representable by a lambda, too.
  prefs: []
  type: TYPE_NORMAL
- en: Java 8 added the marker annotation `@FunctionalInterface` to enforce the SAM
    requirement at the compiler level. It isn’t mandatory, but it tells the compiler
    and possibly other annotation-based tooling that an interface should be a functional
    interface and, therefore, that the single abstract method requirement must be
    enforced. If you add another `abstract` method, the Java compiler will refuse
    to compile your code. That’s why adding the annotation to any functional interface
    makes a lot of sense, even if you don’t explicitly need it. It clarifies the reasoning
    behind your code and the intention of such an interface and fortifies your code
    against unintentional changes that might break it in the future.
  prefs: []
  type: TYPE_NORMAL
- en: The optional nature of the `@FunctionalInterface` annotation also enables the
    backward compatibility of existing interfaces. As long as an interface fulfills
    the SAM requirements, it’s representable as a lambda. I’ll talk about the functional
    interfaces of the JDK later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Lambdas and Outside Variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[“Pure Functions and Referential Transparency”](ch01.xhtml#_01-an-introduction_pure-functions)
    introduced the concept of *pure* — self-contained and side-effect-free — functions
    that won’t affect any outside state and only rely on their arguments. Even though
    lambdas follow the same gist, they also allow a certain degree of impurity to
    be more flexible. They can “capture” constants and variables from their creation
    scope in which the lambda is defined, which makes such variables available to
    them even if the original scope no longer exists, as shown in [Example 2-3](#_01-functions_pure-lambas_capture).'
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-3\. Lambda variable capture
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_functional_java_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The variable `theAnswer` is declared in the scope of `capture()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_functional_java_CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The lambda `printAnswer` captures the variable in its body.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_functional_java_CO3-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The lambda can be run in another method and scope but still has access to `theAnswer`.
  prefs: []
  type: TYPE_NORMAL
- en: The big difference between *capture* and *non-capture* lambdas is the optimization
    strategies of the JVM. The JVM optimizes lambdas with different strategies based
    on their actual usage pattern. If no variables get captured, a lambda might end
    up being a simple `static` method behind the scenes, beating out the performance
    of alternative approaches like anonymous classes. The implications of capturing
    variables on performance are not as clear-cut, though.
  prefs: []
  type: TYPE_NORMAL
- en: There are multiple ways the JVM might translate your code if it captures variables,
    leading to additional object allocation, affecting performance, and garbage collector
    times. That doesn’t mean that capturing variables is inherently a bad design choice.
    The main goal of a more functional approach should be improved productivity, more
    straightforward reasoning, and more concise code. Still, you should avoid unnecessary
    capturing, especially if you require the least amount of allocations or the best
    performance possible.
  prefs: []
  type: TYPE_NORMAL
- en: Another reason to avoid capturing variables is their necessity of being *effectively*
    `final`.
  prefs: []
  type: TYPE_NORMAL
- en: Effectively final
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The JVM has to make special considerations to use captured variables safely
    and achieve the best performance possible. That’s why there’s an essential requirement:
    only *effectively* `final` variables are allowed to be captured.'
  prefs: []
  type: TYPE_NORMAL
- en: In simple terms, any captured variable must be an immutable reference that isn’t
    allowed to change after its initialization. They *must* be `final`, either by
    explicitly using the `final` keyword or by *never* changing after their initialization,
    making them *effectively* `final`.
  prefs: []
  type: TYPE_NORMAL
- en: Be aware that this requirement is actually for the *reference* to a variable
    and *not* the underlying data structure itself. A reference to a `List<String>`
    might be `final`, and therefore usable in a lambda, but you can still add new
    items, as seen in [Example 2-4](#_01-functions-effecitvely-final_mutable). Only
    reassigning the variable is prohibited.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-4\. Change data behind a `final` variable
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_functional_java_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The variable `list` is explicitly `final`, making the reference immutable.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_functional_java_CO4-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Capturing and using the variable in a lambda works without problems. However,
    the `final keyword does not affect the +List` itself, allowing you to add additional
    items.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_functional_java_CO4-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Reassigning the variable is prohibited due to the `final` keyword and won’t
    compile.
  prefs: []
  type: TYPE_NORMAL
- en: The simplest way to test whether a variable is *effectively* `final` or not
    is by making it explicitly `final`. If your code still compiles with the additional
    `final` keyword, it will compile without it. So why not make every variable `final`?
    Because the compiler ensures that “out-of-body” references are *effectively* `final`,
    the keyword won’t help with actual immutability anyways. Making every variable
    `final` would only create more visual noise in your code without much benefit.
    Adding a modifier like `final` should always be a conscious decision with intent.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you run any of the shown *effectively* `final`-related examples in `jshell`,
    they might not behave as expected. That’s because `jshell` has special semantics
    regarding top-level expressions and declarations, which affects `final` or effectively
    `final` values at top-level^([2](ch02.xhtml#idm45115252733520)). Even though you
    can reassign any reference, making it non-effectively `final`, you can still use
    them in lambdas, as long as you’re not in the top-level scope.
  prefs: []
  type: TYPE_NORMAL
- en: Re-finalizing a Reference
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes a reference might not be *effectively* `final`, but you still need
    them to be available in a lambda. If refactoring your code isn’t an option, there’s
    a simple trick to *re-finalize* them. Remember, the requirement is just for the
    reference and not the underlying data structure itself.
  prefs: []
  type: TYPE_NORMAL
- en: You can create a new *effectively* `final` reference to the non-*effectively*
    `final` variable by simply referencing the original one and not changing it further,
    as shown in [Example 2-5](#_01-functions-effecitvely-final_refinalize).
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-5\. Re-finalize a variable
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_functional_java_CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: At this point, `nonEffectivelyFinal` is still *effectively* `final`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_functional_java_CO5-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Changing the variable after its initialization makes it unusable in lambda.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_functional_java_CO5-3)'
  prefs: []
  type: TYPE_NORMAL
- en: By creating a new variable and not changing it after its initialization, you
    “re-finalized” the reference to the underlying data structure.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that re-finalizing a reference is just a “band-aid”, and needing
    a band-aid means you scraped your knees first. So the best approach is trying
    not to need it at all. Refactoring or redesigning your code should always be the
    preferred option instead of bending the code to your will with tricks like re-finalizing
    a reference.
  prefs: []
  type: TYPE_NORMAL
- en: Such safeguards for using variables in lambdas like the effectively `final`
    requirement might feel like an additional burden at first. However, instead of
    capturing “out-of-body” variables, your lambdas should strive to be self-sufficient
    and require all necessary data as arguments. That automatically leads to more
    reasonable code, increased reusability, and allows for easier refactoring and
    testing.
  prefs: []
  type: TYPE_NORMAL
- en: What about Anonymous Classes?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After learning about lambdas and functional interfaces, you’re most likely
    reminded of their similarities to *anonymous inner classes*: the combined declaration
    and instantiation of types. An interface or extended class can be implemented
    “on-the-fly” without needing a separate Java class, so what differs between a
    lambda expression and an anonymous class if they both have to implement a concrete
    interface?'
  prefs: []
  type: TYPE_NORMAL
- en: On the surface, a functional interface implemented by an anonymous class looks
    quite similar to its lambda representation, except for the additional boilerplate,
    as seen in [Example 2-6](#_01-functions_java-lambdas_anonymous-classes).
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-6\. Anonymous class vs. lambda expression
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Does that mean that lambda expressions are just *syntactic sugar* for implementing
    a functional interface as an anonymous class then?
  prefs: []
  type: TYPE_NORMAL
- en: Lambda expressions might look like syntactic sugar, but they’re so much more
    in reality. The *real* difference — besides verbosity — lies in the generated
    bytecode, as seen in [Example 2-7](#_01-functions_java-lambdas_syntax-lambda-as-anonymous_bytecode),
    and how the runtime handles it.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-7\. Bytecode differences between anonymous classes and lambdas
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_functional_java_CO6-1)'
  prefs: []
  type: TYPE_NORMAL
- en: A new object of the anonymous inner class `HelloWorldAnonymous$1` is created
    in the surrounding class `HelloWorldAnonymous`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_functional_java_CO6-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The constructor of the anonymous class is called. Object creation is a two-step
    process in the JVM.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_functional_java_CO6-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The `invokedynamic` opcode hides the whole logic behind creating the lambda.
  prefs: []
  type: TYPE_NORMAL
- en: Both variants have the `astore_1` call in common, which stores a reference into
    a local variable, and the `return` call, so both won’t be part of analyzing the
    bytecode.
  prefs: []
  type: TYPE_NORMAL
- en: 'The anonymous class version creates a new object of the anonymous type `Anonymous$1`,
    resulting in three opcodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`new`'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new uninitialized instance of a type.
  prefs: []
  type: TYPE_NORMAL
- en: '`dup`'
  prefs: []
  type: TYPE_NORMAL
- en: Put the value on top of the stack by duplicating it.
  prefs: []
  type: TYPE_NORMAL
- en: '`invokespecial`'
  prefs: []
  type: TYPE_NORMAL
- en: Call the constructor method of the newly created object to finalize its initialization.
  prefs: []
  type: TYPE_NORMAL
- en: 'The lambda version, on the other hand, doesn’t need to create an instance that
    needs to be put on the stack. Instead, it delegates the whole task of creating
    the lambda to the JVM with a single opcode: `invokedynamic`.'
  prefs: []
  type: TYPE_NORMAL
- en: Another big difference between lambdas and anonymous inner classes is their
    respective scope. An inner class creates its own scope, hiding its local variables
    from the enclosing one. That’s why the keyword `this` references the instance
    of the inner class itself, not the surrounding scope. Lambdas, on the other hand,
    live fully in their surrounding scope. Variables can’t be re-declared with the
    same name, and `this` refers to the instance the lambda was created in, if not
    `static`.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, lambda expressions are *not* syntactic sugar at all.
  prefs: []
  type: TYPE_NORMAL
- en: Lambdas In Action
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you saw in the previous section, lambdas are an extraordinary addition to
    Java to improve its functional programming abilities that’s much more than just
    syntactic sugar for previously available approaches. Their first-class citizenship
    allows them to be statically typed, concise, and anonymous functions that are
    just like any other variable. Although the arrow syntax might be new, the overall
    use pattern should feel familiar to any programmer. In this section, we’ll jump
    right into actually using lambdas and seeing them in action.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Lambdas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To create a lambda expression, it needs to represent a singular functional interface.
    The actual type might not be evident because a receiving method argument dictates
    the required type, or the compiler will infer it if possible.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a look at `Predicate<T>` again to better illustrate that point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a new instance requires the type to be defined on the left-hand side:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Even if you use explicit types for the arguments, the functional interface
    type is still required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The method signature of `Predicate<String>` SAM might be inferable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Still, the Java compiler requires a concrete type for the reference, not just
    a method signature. This requirement stems from Java’s propensity for backward
    compatibility, as I previously mentioned. By using the pre-existing statically-typed
    system, lambdas fit perfectly into Java, granting lambdas the same compile-time
    safety as any other type or approach before them.
  prefs: []
  type: TYPE_NORMAL
- en: However, obeying the type system makes Java lambdas less dynamic than their
    counterparts in other languages. Just because two lambdas share the same SAM signature
    doesn’t mean they are interchangeable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take the following functional interface for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Even though it’s SAM is identical to `Predicate<T>`, the types can’t be used
    interchangeably, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_functional_java_CO7-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The lambda is created as before.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_functional_java_CO7-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Trying to assign it to a functional interface with an identical SAM won’t compile.
  prefs: []
  type: TYPE_NORMAL
- en: Due to this incompatibility, you should try to rely on the available interfaces
    in the `java.util.function` package that will be discussed in [Chapter 3](ch03.xhtml#_01-functional-jdk)
    to maximize interoperability. You’re still going to encounter pre-Java 8 interfaces
    like `java.util.concurrent.Callable<V>` that are identical to a Java 8+ one, in
    this case, `java.util.function.Supplier<T>`, though. If that happens, there’s
    a neat shortcut for switching a lambda to another identical type. You’ll learn
    about this in [“Bridging Functional Interfaces”](ch03.xhtml#_01-functional-jdk_bridging-functional-interfaces).
  prefs: []
  type: TYPE_NORMAL
- en: 'Ad-hoc created lambdas as method arguments and return types don’t suffer from
    any type incompatibility, as demonstrated by the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The compiler infers the type of ad-hoc lambdas directly from the method signature,
    so you can concentrate on *what* you want to achieve with the lambda. The same
    is true for return types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Now that you know how to create lambdas, you then need to call them.
  prefs: []
  type: TYPE_NORMAL
- en: Calling Lambdas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As discussed, lambdas are effectively concrete implementations of their respective
    functional interfaces. Other, more functionally inclined languages are usually
    treating lambdas more dynamically. That’s why Java’s usage patterns can differ
    from such languages.
  prefs: []
  type: TYPE_NORMAL
- en: 'In JavaScript, for example, you can call a lambda and pass an argument directly,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In Java, however, lambdas behave like any other instances of an interface,
    so you need to explicitly call its SAM, as demonstrated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Calling the *single abstract method* might not be as concise as in other languages,
    but the benefit is Java’s continued backward compatibility.
  prefs: []
  type: TYPE_NORMAL
- en: Method References
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Besides lambdas, Java 8 introduced another new feature with a language syntax
    change as a new way to create lambda expressions: *method references*. It’s shorthand
    syntactic sugar, using the new `::` (double-colon) operator to reference an existing
    method in place of creating a lambda expression from an existing method, and therefore
    streamlining your functional code.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 2-8](#_01-functions-method-references_stream) shows how a Stream pipeline’s
    readability is improved by converting the lambdas to method references. Don’t
    worry about the details! You will learn about Streams in [Chapter 6](ch06.xhtml#_02-data-processing),
    just think of it as a fluent call with lambda accepting methods.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-8\. Method references and Streams
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Replacing lambdas with method references removes a lot of *noise* without compromising
    the readability or understandability of your code too much. There is no need for
    the input arguments to have actual names or types, or to call the reference method
    explicitly. Also, modern IDEs usually provide you with automatic refactoring to
    convert lambdas to method references, if applicable.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are four types of method references you can use, depending on the lambda
    expression you want to replace and what kind of method you need to reference:'
  prefs: []
  type: TYPE_NORMAL
- en: Static method references
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bound non-`static` method references
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unbound non-`static` method references
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constructor references
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s take a look at the different kinds and how and when to use them.
  prefs: []
  type: TYPE_NORMAL
- en: Static Method References
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A *static method reference* refers to a `static` method of a specific type,
    like the `toHexString` method available on `Integer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The general syntax for static method references is `ClassName::staticMethodName`.
  prefs: []
  type: TYPE_NORMAL
- en: Bound non-static Method References
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you want to refer to a non-`static` method of an already existing object,
    you need a *bound non-static method reference*. The lambda arguments are passed
    as the method arguments to the reference method of that specific object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'You don’t even need an intermediate variable; you can combine the return value
    of another method call or field access directly with `::` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also reference methods from the current instance with `this::` or the
    `super` implementation with `super::`, as shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Bound method references are a great way to use already existing methods on variables,
    the current instance, or `super`. It also allows you to refactor non-trivial or
    more complex lambdas to methods and use method references instead. Especially
    fluent pipelines, like Streams in [Chapter 6](ch06.xhtml#_02-data-processing)
    or Optionals in [Chapter 9](ch09.xhtml#_02-optionals), profit immensely from the
    improved readability of short method references.
  prefs: []
  type: TYPE_NORMAL
- en: The general syntax for bound non-static method references is `objectName::instanceMethodName`.
  prefs: []
  type: TYPE_NORMAL
- en: Unbound non-static Method References
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Unbound non-static method references* are, as their name suggests, not bound
    to a specific object. Instead, they refer to an instance method of a type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The general syntax for unbound non-static method references is `ClassName::instanceMethodName`.
  prefs: []
  type: TYPE_NORMAL
- en: This type of method reference can be confused with a *static method reference*.
    For *Unbound non-static method references*, however, the `ClassName` signifies
    the instance type in which the referenced instance method is defined. It’s also
    the first argument of the lambda expression. This way, the reference method is
    called on the incoming instance and not on an explicitly referenced instance of
    that type.
  prefs: []
  type: TYPE_NORMAL
- en: Constructor References
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The last type of method reference refers to a type’s constructor. A constructor
    method reference looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: At first glance, constructor method references look like static or unbound non-static
    method references. The referenced method isn’t an actual method but a reference
    to a constructor via the `new` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: The general syntax for constructor method references is `ClassName::new`.
  prefs: []
  type: TYPE_NORMAL
- en: Functional Programming Concepts in Java
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Chapter 1](ch01.xhtml#_01-an-introduction) tackled the core concepts that
    make a programming language functional from a mostly theoretical viewpoint. So
    let’s take another look at them from a Java developer’s point of view.'
  prefs: []
  type: TYPE_NORMAL
- en: Pure Functions and Referential Transparency
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The concept of pure functions is based on two guarantees that aren’t necessarily
    bound to functional programming:'
  prefs: []
  type: TYPE_NORMAL
- en: Function logic is self-contained without any kind of side effect.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *same* input will *always* create the same output. Therefore, repeated calls
    can be replaced by the initial result, making the call referentially transparent.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These two principles make sense even in your imperative code. Making your code
    self-contained makes it predictable and more straightforward. From a Java perspective,
    how can you achieve these beneficial properties?
  prefs: []
  type: TYPE_NORMAL
- en: First, check for uncertainty. Is there non-predictive logic that doesn’t depend
    on the input arguments? Prime examples are random number generators or the current
    date. Using such data in a function removes a function’s predictability, making
    it *impure*.
  prefs: []
  type: TYPE_NORMAL
- en: Next, look for side effects and mutable state.
  prefs: []
  type: TYPE_NORMAL
- en: Does your function affect any state outside of the function itself, like an
    instance or global variable?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does it change the inner data of its arguments, like adding new elements to
    a collection or changing an object property?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does it do any other *impure* work, like I/O?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, side effects aren’t restricted to mutable state. A simple `System.out.println(…​)`
    call is a side-effect, even if it might look harmless. Any kind of I/O, like accessing
    the file system, making network requests, or printing to `System.out` is a side-effect.
    The reasoning is simple: repeated calls with the same arguments can’t be replaced
    with the result of the first evaluation. A good indicator for an *impure* method
    is a `void` return type. If a method doesn’t return anything, all it does are
    side effects, or it does nothing at all.'
  prefs: []
  type: TYPE_NORMAL
- en: Pure functions are inherently *referentially transparent*. Hence, you can replace
    any subsequent calls with the same arguments with the previously calculated result.
    This interchangeability allows for an optimization technique called *memoization*.
    Originating from the Latin word “memorandum" — *to be remembered* --⁠, this technique
    describes “remembering” previously evaluated expressions. It trades memory *space*
    for saving computational *time*.
  prefs: []
  type: TYPE_NORMAL
- en: You’re most likely already using the general idea behind referential transparency
    in your code in the form of *caching*. From dedicated cache libraries, like Ehcache^([6](ch02.xhtml#idm45115250887264))
    to simple `HashMap`-based lookup tables, it’s all about “remembering” a value
    against a set of input arguments.
  prefs: []
  type: TYPE_NORMAL
- en: The Java compiler doesn’t support automatic memoization of lambda expressions
    or methods calls. Some frameworks provide annotations, like `@Cacheable` in Spring^([7](ch02.xhtml#idm45115250884688))
    or `@Cached` in Apache Tapestry^([8](ch02.xhtml#idm45115250882416)), and generate
    the required code automatically behind the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: Creating your own lambda expression caching isn’t too hard either, thanks to
    some of the newer additions to Java 8+. So let’s do that right now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Building your own *memoization* by creating an “on-demand” lookup table requires
    the answer to two questions:'
  prefs: []
  type: TYPE_NORMAL
- en: How do you identify the function and its input arguments uniquely?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can you store the evaluated result?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If your function or method call has only a single argument with a constant `hashCode`
    or other deterministic value, you can create a simple `Map`-based lookup table.
    For multi-argument calls, you must first define how to create a lookup key.
  prefs: []
  type: TYPE_NORMAL
- en: Java 8 introduced multiple functional additions to the `Map<K, V>` type. One
    of these additions, the `computeIfAbsent` method, is a great aid to easily implement
    memoization, as shown in [Example 2-9](#_01-functions_memoization_computeIfAbsent).
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-9\. Memoization with `Map#computeIfAbsent`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_functional_java_CO8-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The results are cached in a simple `HashMap<String, Object>` so it can cache
    any kind of call based on an identifier. Depending on your requirements, there
    might be special considerations, like caching results per request in a web application
    or requiring a “time-to-live” concept. This example is supposed to show the simplest
    form of a lookup table.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_functional_java_CO8-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The `memoize` method accepts an identifier and a `Supplier<T>` in case the cache
    doesn’t have a result yet.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_functional_java_CO8-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The `expensiveCall` is the method that gets memoized.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_functional_java_CO8-5)'
  prefs: []
  type: TYPE_NORMAL
- en: For convenience, a specialized memoized call method exists, so you don’t have
    to build an identifier manually each time you call `memoize`. It has the same
    arguments as the calculation method and delegates the actual memoization process.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_functional_java_CO8-6)'
  prefs: []
  type: TYPE_NORMAL
- en: The convenience method allows you to replace the method name of the call to
    use the memoized version instead of the original one.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_functional_java_CO8-7)'
  prefs: []
  type: TYPE_NORMAL
- en: The second call returns the cached result immediately without any additional
    evaluation.
  prefs: []
  type: TYPE_NORMAL
- en: This implementation is quite simplistic and is not a one-size-fits-all solution.
    Still, it confers the general concept of storing a call result via an intermediate
    method doing the actual memoization.
  prefs: []
  type: TYPE_NORMAL
- en: The functional additions to `Map<K, V>` don’t stop there. It provides the tools
    to create associations “on the fly,” and more tools giving you more fine-grained
    control if a value is already present or not. You will learn more about it in
    [Chapter 11](ch11.xhtml#_02-lazy-evaluation).
  prefs: []
  type: TYPE_NORMAL
- en: Immutability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The classical approach to Java with OOP is based on mutable program state, most
    prominently represented by JavaBeans and POJOs. There’s no clear definition of
    how program state should be handled in OOP, and immutability is no pre-requisite
    or unique feature of FP. Still, mutable state is a thorn in the side of many functional
    programming concepts because they expect *immutable* data structures to ensure
    data integrity and safe overall use.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: POJOs are “plain old Java Objects” that aren’t bound by special restrictions,
    other than those imposed by the Java language. JavaBeans are a special type of
    POJOs. You will learn more about them in [“Mutability and Data Structures in OOP”](ch04.xhtml#_02-data-sructures_mutability).
  prefs: []
  type: TYPE_NORMAL
- en: Java’s support for immutability is quite limited compared to other languages.
    That’s why it has to enforce constructs like *effectively* `final` as discussed
    in [“Lambdas and Outside Variables”](#_01-introduction_pure-lambas-effectively-final).
    To support “full” immutability, you need to design your data structures from the
    ground up as immutable, which can be cumbersome and error-prone. Third-party libraries
    are an often chosen approach to minimize the required boilerplate code and rely
    on battle-tested implementations. Finally, with Java 14+, immutable data classes — *Records* — were
    introduced to bridge the gap, which I will discuss in [Chapter 5](ch05.xhtml#_02-records).
  prefs: []
  type: TYPE_NORMAL
- en: Immutability is a complex subject that you’ll learn more about and its importance
    and how to utilize it properly — either with built-in tools or with a do-it-yourself
    approach — in [Chapter 4](ch04.xhtml#_02-data-structures).
  prefs: []
  type: TYPE_NORMAL
- en: First-Class and Higher-Order
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With Java *lambas* being concrete implementations of functional interfaces,
    they gain *first-class* citizenship and are usable as variables, arguments, and
    return values, as seen in [Example 2-10](#_01-functions_first-class).
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-10\. First-class Java Lambdas
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_functional_java_CO9-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Assigning a Java lambda to the variable `quadraticFn`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_functional_java_CO9-2)'
  prefs: []
  type: TYPE_NORMAL
- en: It can be used like any other “normal” Java variable, calling the `apply` method
    of its interface.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_functional_java_CO9-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Lambdas are usable like any other type for arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_functional_java_CO9-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Returning a lambda is like returning any other Java variable.
  prefs: []
  type: TYPE_NORMAL
- en: Accepting lambdas as arguments and returning lambdas is essential for the next
    concept, *functional composition*.
  prefs: []
  type: TYPE_NORMAL
- en: Functional Composition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The idea of creating complex systems by composing smaller components is a cornerstone
    of programming, regardless of the chosen paradigm to follow. In OOP, objects can
    be composed of smaller ones, building a more complex API. In FP, two functions
    are combined to build a new function, which then can be combined further.
  prefs: []
  type: TYPE_NORMAL
- en: Functional composition is arguably one of the essential aspects of a functional
    programming mindset. It allows you to build complex systems by composing smaller,
    reusable functions into a larger chain, fulfilling a more complex task, as illustrated
    in [Figure 2-1](#_01-functional-java_functional-composition).
  prefs: []
  type: TYPE_NORMAL
- en: '![Composing complex tasks from multiple functions](assets/afaj_0201.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-1\. Composing complex tasks from multiple functions
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Java’s functional composition capabilities depend highly on the involved concrete
    types. In [“Functional Composition”](ch03.xhtml#_01-functional-jdk_functional-composition),
    I will discuss how to combine the different functional interfaces provided by
    the JDK.
  prefs: []
  type: TYPE_NORMAL
- en: Lazy Evaluation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Even though Java, at least in principle, is a non-lazy — *strict* or *eager* — language,
    it supports multiple lazy constructs:'
  prefs: []
  type: TYPE_NORMAL
- en: Logical short-circuit operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`if`-`else` and the `:?` (ternary) operator'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`for` and `while` loops'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Logical short-circuit operators are a simple example of laziness:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The evaluation `complex()` depends on the outcome of `simple()` and the logical
    operator used in the overall expression. That’s why the JVM can discard expressions
    that don’t need evaluation, as will be explained in more detail in [Chapter 11](ch11.xhtml#_02-lazy-evaluation).
  prefs: []
  type: TYPE_NORMAL
- en: Takeaways
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functional interfaces are concrete types and representations of Java lambdas.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java’s lambda syntax is close to the underlying mathematical notation of lambda
    calculus.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lambdas can be expressed with multiple levels of verbosity, depending on the
    surrounding context and your requirements. Shorter isn’t always as expressive
    as it should be, especially if others are reading your code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lamba expressions are not *syntactic sugar* thanks to the JVM using the opcode
    `invokedynamic`. This allows for multiple optimization techniques to get better
    performance as alternatives like anonymous classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Outside variables need to be *effectively* `final` to be used in lambdas, but
    this makes only the references immutable, not the underlying data structure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Method references are a concise alternative for matching method signatures and
    lambda definitions. They even provide a simple way to use “identical but incompatible”
    functional interface types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '^([1](ch02.xhtml#idm45115256766512-marker)) The simplified version of `java.util.function.Predicate`
    is based on the source code for the latest Git tag of the LTS version at the time
    of writing: 17+35\. You can check out the [official source code repository](https://github.com/openjdk/jdk/blob/dfacda488bfbe2e11e8d607a6d08527710286982/src/java.base/share/classes/java/util/function/Predicate.java)
    to see the original file.'
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch02.xhtml#idm45115252733520-marker)) The [official documentation](https://docs.oracle.com/en/java/javase/17/docs/api/jdk.jshell/jdk/jshell/JShell.xhtml#eval(java.lang.String))
    sheds some light on the special semantics and requirements for top-level expressions
    and declarations.
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch02.xhtml#idm45115252515552-marker)) Landin, Peter J. (1964). “The mechanical
    evaluation of expressions.” [The Computer Journal. Computer Journal. 6 (4)](https://doi.org/10.1093/comjnl/6.4.308).
  prefs: []
  type: TYPE_NORMAL
- en: ^([4](ch02.xhtml#idm45115252465520-marker)) The Java Magazine has [an article](https://blogs.oracle.com/javamagazine/post/understanding-java-method-invocation-with-invokedynamic)
    by Java Champion Ben Evans that explains method invocation with `invokedynamic`
    in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: ^([5](ch02.xhtml#idm45115252462144-marker)) The class [`java.lang.invoke.LambdaMetaFactory`](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/invoke/LambdaMetafactory.xhtml)
    is responsible for creating “bootstrap methods.”
  prefs: []
  type: TYPE_NORMAL
- en: ^([6](ch02.xhtml#idm45115250887264-marker)) [Ehcache](https://www.ehcache.org/)
    is a widely-used Java cache library.
  prefs: []
  type: TYPE_NORMAL
- en: ^([7](ch02.xhtml#idm45115250884688-marker)) The official documentation of [like
    `@Cacheable`](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/cache/annotation/Cacheable.xhtml)
    explains the inner workings including key mechanics.
  prefs: []
  type: TYPE_NORMAL
- en: ^([8](ch02.xhtml#idm45115250882416-marker)) The [Tapestry annotation](https://tapestry.apache.org/5.8.2/apidocs/org/apache/tapestry5/annotations/Cached.xhtml)
    doesn’t support key-based caching, but can be bound to a field instead.
  prefs: []
  type: TYPE_NORMAL
