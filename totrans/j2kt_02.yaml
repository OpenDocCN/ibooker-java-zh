- en: Chapter 2\. Java to Kotlin Projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the first step of the journey from pure Java to a mixed and then increasingly
    Kotlin codebase?
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Strategy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first time we, Nat and Duncan, introduced Kotlin to a Java codebase, we
    were members of a small team that included six developers, building a relatively
    greenfield project. We had already deployed some web applications with Kotlin,
    but our enterprise architects insisted that we write the new system in Java 8.
    This was shortly after Kotlin 1.0 had been released, but before Google announced
    that Kotlin was an official language for Android, so the architects were understandably
    wary about committing to a language with an uncertain future for a strategic system
    that they expected to be around for decades.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java, we leaned toward a functional approach, designing the core application
    domain model as immutable data types transformed by pipelines. However, we kept
    bumping into Java’s limitations: the verbosity required to implement immutable
    value types, the distinction between primitive and reference types, null references,
    and Streams lacking common higher-order functions. Meanwhile, we could see Kotlin
    being adopted at an ever-increasing rate across the industry and even within the
    company. When we saw Google’s announcement, we decided to start converting our
    Java to Kotlin.'
  prefs: []
  type: TYPE_NORMAL
- en: Our judgment was that starting in the core domain model would give us the biggest
    bang for our buck. Kotlin’s data classes shrank the code significantly, in some
    cases replacing hundreds of lines of code with a single declaration. We started
    carefully, using IntelliJ to convert a small value class that had no dependencies
    on other classes beyond those in the standard library, and examined how that affected
    the rest of our Java codebase. It had no effect at all! Emboldened by this success,
    we picked up the pace. Whenever a new feature needed changes to a Java domain
    model class, we would first convert it to a Kotlin data class, commit the conversion,
    and then implement the feature.
  prefs: []
  type: TYPE_NORMAL
- en: As more of the domain model logic became pure Kotlin, we were able to make better
    use of Kotlin features. For example, we replaced calls to the Stream API with
    Kotlin’s standard functions on collections and sequences. The biggest improvement
    though, was replacing our use of Java’s Optional type with nullable references.
    This simplified our code and gave us greater confidence in its null safety.
  prefs: []
  type: TYPE_NORMAL
- en: Another project in the company adopted Kotlin for a different reason. They had
    a mature Java system that was built on a dependency injection framework. The developers
    found that the framework’s use of reflection and annotations made the code difficult
    to understand and navigate in the IDE. Kotlin’s lightweight syntax for closures
    offered a way to define the structure of their application and distinguish between
    object graphs instantiated for the whole application, for each HTTP request, or
    for each database transaction. They gradually refactored the underpinnings of
    their system from a framework that obscured the architecture to a style that composed
    functions and made the architecture visible in the code. This work became the
    [http4k](https://http4k.org) web programming toolkit.
  prefs: []
  type: TYPE_NORMAL
- en: As these two examples show, your choice of starting point should depend on a
    number of factors, including why your team is adopting Kotlin, how large the codebase
    is, and how frequently it changes. You know your project and can decide what is
    most important to change.
  prefs: []
  type: TYPE_NORMAL
- en: If you are choosing Kotlin for its language features, it makes sense to convert
    the classes you are working in most frequently, as we did in our first project.
    If you are choosing Kotlin to use a specific library, then it makes sense to start
    writing Kotlin against the API, annotate it to make your Kotlin code convenient
    to the Java code in the rest of the app, and continue from there.
  prefs: []
  type: TYPE_NORMAL
- en: In a small team it’s easy to establish the Kotlin coding style for your system
    (beyond the standard style guide), for instance, error handling conventions, how
    code is to be organized into files, what should be a top-level declaration and
    what should be in an object, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Above a certain size, you run the risk of Kotlin code becoming inconsistent
    as people establish their own conventions in different parts of the system. So
    it may be worth starting with a small subteam working in one area of the system,
    who establish conventions and build up a body of example code. Once there are
    some established conventions, you can expand the effort to the rest of the team
    and other parts of the system.
  prefs: []
  type: TYPE_NORMAL
- en: In the rest of this book, we will examine in detail how to progress, how to
    keep your Java code maintainable while you are introducing Kotlin that it depends
    upon, and how to take advantage of Kotlin’s features to simplify the code further
    after IntelliJ has performed its conversion magic. But all that follows the first
    small step.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Kotlin Support to a Java Build
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we want to refactor our Java to Kotlin, the first change we must make is
    to give ourselves the ability to write Kotlin code in our codebase. Happily, the
    Kotlin build tools and IDE make this very straightforward. It takes a few additional
    lines in our Gradle build configuration for it to compile Kotlin as well as Java.
    IntelliJ will pick up that configuration when we resync the build file, allowing
    us to navigate, autocomplete, and refactor across both languages almost seamlessly.
  prefs: []
  type: TYPE_NORMAL
- en: To add Kotlin to our Gradle build, we need to add the Kotlin plug-in. There
    is a different plug-in for each target that Kotlin supports (JVM, JavaScript,
    and native code), and a plug-in for building multiplatform projects. Because we
    have a Java project, we can ignore other platforms and use the Kotlin JVM plug-in.
  prefs: []
  type: TYPE_NORMAL
- en: We also need to add the Kotlin standard library to our dependencies and specify
    the minimum JVM version that the output bytecode will support. Our project targets
    JDK 11 (the latest LTS at the time of writing). At the time of writing, the Kotlin
    compiler can generate bytecode compatible with JDK 1.6 or JDK 1.8\. JDK 1.8 bytecode
    is more efficient and runs fine on JDK 11, so we will pick that.
  prefs: []
  type: TYPE_NORMAL
- en: Kotlin Versions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Kotlin language and standard library are still maturing, but JetBrains policy
    is to provide a clear migration path. The current version of Kotlin was 1.3 when
    we started writing this book. As we finish it, 1.5 has just been released, deprecating
    some standard APIs used in our code examples! We have chosen not to migrate to
    their replacements, so that the code is able to run on Kotlin 1.4 and 1.5.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the relevant parts of our `build.gradle` before the changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 2.1 [projects.0:build.gradle]](https://java-to-kotlin.dev/code.html?ref=2.1&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=2.1&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'After we have added the Kotlin plug-in, our build file looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 2.2 [projects.1:build.gradle]](https://java-to-kotlin.dev/code.html?ref=2.2&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=2.2&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: Given those changes, we can rerun our build, and see that…
  prefs: []
  type: TYPE_NORMAL
- en: …the build still works!
  prefs: []
  type: TYPE_NORMAL
- en: If we resync the Gradle project in IntelliJ (this may happen automatically on
    saving), we can run our tests and programs within the IDE.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our tests still pass, so we haven’t broken anything, but neither have we proved
    that we can use Kotlin in our project. Let’s test that by writing a “hello world”
    program. We create a file, *HelloWorld.kt*, in the root package of our Java source
    tree, *src/main/java*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 2.3 [projects.2:src/main/java/HelloWorld.kt]](https://java-to-kotlin.dev/code.html?ref=2.3&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=2.3&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: Where to Put Kotlin Source
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Kotlin build plug-in adds additional source roots, *src/main/kotlin* and
    *src/test/kotlin*, and compiles Kotlin source files found in any of their subdirectories.
  prefs: []
  type: TYPE_NORMAL
- en: It will also compile Kotlin source found in Java source trees, in particular
    *src/main/java* and *src/test/java*. Although you can separate your source files
    by language, putting Java files in the *java* directories and Kotlin into *kotlin*,
    in practice your authors don’t bother. It’s nice to be able to look into a directory
    and see all the source for the corresponding package rather than casting around
    the filesystem. To make this work, though, we keep Kotlin source in directories
    mirroring the package structure rather than taking advantage of Kotlin’s ability
    to have files in a single directory but multiple packages.
  prefs: []
  type: TYPE_NORMAL
- en: In a similar vein, while Kotlin does allow multiple public classes to be defined
    in a single class, when we are mixing Java and Kotlin in a project, we tend to
    stick to one class per file for consistency.
  prefs: []
  type: TYPE_NORMAL
- en: We can run that within the IDE by clicking the little green arrow in the lefthand
    margin next to `fun main()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can run our build and then run it from the command line with the `java`
    command. Compiling the source file named *HelloWorld.kt* creates a Java class
    file named `HelloWorldKt`. We’ll look into how Kotlin source gets translated into
    Java class files in more detail later, but for now, we can run our program with
    the `java` command, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: It lives!
  prefs: []
  type: TYPE_NORMAL
- en: Let’s delete *HelloWorld.kt*—it’s done its job—commit and push.
  prefs: []
  type: TYPE_NORMAL
- en: We now have the *option* to use Kotlin in our project; the first part of this
    chapter gives some pointers to *where* to start using it.
  prefs: []
  type: TYPE_NORMAL
- en: Moving On
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We expect the technical information in this chapter to date very quickly, as
    neither Gradle nor its plug-ins have a very stable interface. Your current Java
    build file is also almost certainly incompatible with our example in some crucial
    way. Despite this, though, adding Kotlin to a Java build is generally straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: Devising a strategy for moving code from Java to Kotlin is more complicated
    and context specific. Or at least differently complicated and context specific.
    Individual projects should examine where Java is and isn’t working for them, and
    where using Kotlin would alleviate problems and improve the code. You might choose
    to dive in and write some Kotlin from scratch, or to convert an existing Java
    class to Kotlin. In the spirit of this book, the latter is the approach we’ll
    take in [Chapter 3, *Java to Kotlin Classes*](ch03.html#java-to-kotlin-classes).
  prefs: []
  type: TYPE_NORMAL
