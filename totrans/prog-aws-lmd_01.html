<html><head></head><body><section class="pagenumrestart" data-pdf-bookmark="Chapter 1. Introduction to Serverless, Amazon Web Services, and AWS Lambda" data-type="chapter" epub:type="chapter"><div class="chapter" id="ch01">&#13;
<h1><span class="label">Chapter 1. </span>Introduction to Serverless, Amazon Web Services, and AWS Lambda</h1>&#13;
&#13;
&#13;
<p>To<a data-primary="applications" data-startref="globally distributed applications; Lambda applications; serverless applications" data-type="indexterm" id="idm46222431712168"/> start off your serverless journey, we’re going to take you on a brief tour of the cloud and then define serverless. After that, we dive into Amazon Web Services (AWS)—this will be new to some of you and a refresher to others.</p>&#13;
&#13;
<p>With those foundations set, we introduce Lambda—what it is, why you might use it, what you can build with Lambda, and how Java and Lambda work together.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="A Quick History Lesson" data-type="sect1"><div class="sect1" id="idm46222431710136">&#13;
<h1>A Quick History Lesson</h1>&#13;
&#13;
<p>Let’s<a data-primary="cloud computing" data-secondary="brief history of" data-type="indexterm" id="idm46222431708568"/> travel back in time to 2006. No one has an iPhone yet, Ruby on Rails is a hot new programming&#13;
environment, and Twitter is being launched. More germane to us, however, is that at this point in&#13;
time many people are hosting their server-side applications on physical servers that they own and&#13;
have racked in a data center.</p>&#13;
&#13;
<p>In<a data-primary="Elastic Compute Cloud (EC2)" data-type="indexterm" id="idm46222431706712"/> August 2006 something happened that would fundamentally change this model. Amazon’s new IT&#13;
division, AWS, announced the launch of <a href="https://aws.amazon.com/ec2">Elastic&#13;
Compute Cloud (EC2)</a>.</p>&#13;
&#13;
<p>EC2<a data-primary="infrastructure-as-a-service (IaaS)" data-type="indexterm" id="idm46222432097960"/> was one of the first infrastructure-as-a-service (IaaS) products. IaaS allows companies&#13;
to rent compute capacity—that is, a host to run their internet-facing server applications—rather&#13;
than buying their own machines. It also allows them to provision hosts just in time, with the delay&#13;
from requesting a machine to its availability being on the order of minutes.&#13;
In 2006 this was all possible because of the advances in <em>virtualization</em> technology—all EC2 hosts at that time were <em>virtual machines</em>.</p>&#13;
&#13;
<p>EC2’s five key advantages are:</p>&#13;
<dl>&#13;
<dt>Reduced labor cost</dt>&#13;
<dd>&#13;
<p>Before IaaS, companies needed to hire specific technical&#13;
operations staff who would work in data centers and manage their physical servers. This meant&#13;
everything from power and networking to racking and installing to fixing physical problems with&#13;
machines like bad RAM to setting up the operating system (OS). With IaaS all of this goes away and&#13;
instead becomes the responsibility of the IaaS service provider (AWS in the case of EC2).</p>&#13;
</dd>&#13;
<dt>Reduced risk</dt>&#13;
<dd>&#13;
<p>When managing their own physical servers, companies are exposed to problems caused by&#13;
unplanned incidents like failing hardware. This introduces downtime periods of highly volatile&#13;
length since hardware problems are usually infrequent and can take a long time to fix. With IaaS,&#13;
the customer, while still having some work to do in the event of a hardware failure, no longer needs&#13;
know what to do to fix the hardware. Instead the customer can simply request a new machine instance,&#13;
available within a few minutes, and reinstall the application, limiting exposure to such issues.</p>&#13;
</dd>&#13;
<dt>Reduced infrastructure cost</dt>&#13;
<dd>&#13;
<p>In many scenarios the cost of a connected EC2 instance is cheaper than&#13;
running your own hardware when you take into account power, networking, etc. This is especially&#13;
valid when you want to run hosts for a only few days or weeks, rather than many months or years at a&#13;
stretch. Similarly, renting hosts by the hour rather than buying them outright allows different&#13;
accounting: EC2 machines are an operating expense (Opex) rather than the capital expense (Capex) of&#13;
physical machines, typically allowing much more favorable accounting flexibility.</p>&#13;
</dd>&#13;
<dt>Scaling</dt>&#13;
<dd>&#13;
<p>Infrastructure costs drop significantly when considering the scaling benefits IaaS brings.&#13;
With IaaS, companies have far more flexibility in scaling the numbers and types of servers they run.&#13;
There is no longer a need to buy 10 high-end servers up front because you think you might need them&#13;
in a few months’ time. Instead, you can start with one or two low-powered, inexpensive virtual&#13;
machines (VMs) and then scale your number and types of VMs up and down over time without any&#13;
negative cost impact.</p>&#13;
</dd>&#13;
<dt>Lead time</dt>&#13;
<dd>&#13;
<p>In the bad old days of self-hosted servers, it could take months to procure and&#13;
provision a server for a new application. If you came up with an idea you wanted to try within a few&#13;
weeks, then that was just too bad. With IaaS, lead time goes from months to minutes. This has&#13;
ushered in the age of rapid product experimentation, as encouraged by the ideas in <a href="http://theleanstartup.com">Lean Startup</a>.</p>&#13;
</dd>&#13;
</dl>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The Cloud Grows" data-type="sect1"><div class="sect1" id="the-cloud-grows">&#13;
<h1>The Cloud Grows</h1>&#13;
&#13;
<p>IaaS<a data-primary="Simple Storage Service (S3)" data-secondary="as key element of Cloud growth" data-type="indexterm" id="idm46222432083112"/><a data-primary="cloud computing" data-secondary="technologies spurring growth of" data-type="indexterm" id="idm46222432082120"/> was one of the first key elements of the cloud, along with storage (e.g., AWS <a href="https://aws.amazon.com/s3">Simple Storage Service (S3)</a>). AWS was an early mover in cloud services, and is still a&#13;
leading provider, but there are many other cloud vendors such as Microsoft and <span class="keep-together">Google</span>.</p>&#13;
&#13;
<p>The<a data-primary="platform as a service (PaaS)" data-type="indexterm" id="idm46222432079096"/><a data-primary="Heroku" data-type="indexterm" id="idm46222432078296"/> next evolution of the cloud was platform as a service (PaaS). One of the most popular&#13;
PaaS providers is Heroku. PaaS layers on top of IaaS, abstracting the management of the host’s operating system.&#13;
With PaaS you deploy just applications, and the platform is&#13;
responsible for OS installation, patch upgrades, system-level monitoring, service discovery, etc.</p>&#13;
&#13;
<p>An<a data-primary="containers" data-type="indexterm" id="idm46222432076520"/><a data-primary="Docker" data-type="indexterm" id="idm46222432075784"/><a data-primary="containers-as-a-service (CaaS)" data-type="indexterm" id="idm46222432075112"/> alternative to using a PaaS is to use containers.&#13;
<a href="https://www.docker.com">Docker</a> has become incredibly popular over the last few years as a way to&#13;
more clearly delineate an application’s system requirements from the nitty-gritty of the operating&#13;
system itself. There are cloud-based services to host and manage/orchestrate containers on a team’s&#13;
behalf, and these are often referred to as containers-as-a-service (CaaS) products.&#13;
Amazon, Google, and Microsoft all offer CaaS platforms.&#13;
Managing<a data-primary="Kubernetes" data-type="indexterm" id="idm46222432073256"/> fleets of Docker containers has been made easier by use of tools like&#13;
<a href="https://kubernetes.io">Kubernetes</a>, either in a self-managed form or as part of a CaaS&#13;
(e.g., GKE from Google, EKS from Amazon, or AKS from <span class="keep-together">Microsoft</span>).</p>&#13;
&#13;
<p>All<a data-primary="compute as a service" data-type="indexterm" id="idm46222432070632"/> three of these ideas—IaaS, PaaS, and CaaS—can be grouped as <em>compute as a service</em>; in other words, they are different types of generic environments that we can run our own&#13;
specialized software in. PaaS and CasS differ from IaaS by raising the level of abstraction further, allowing us to hand off&#13;
more of our “heavy lifting” to others.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Enter Serverless" data-type="sect1"><div class="sect1" id="idm46222432068904">&#13;
<h1>Enter Serverless</h1>&#13;
&#13;
<p>Serverless<a data-primary="cloud computing" data-secondary="serverless" data-type="indexterm" id="CCserverless01"/> is the next evolution of cloud computing and can be divided into two ideas: backend as a service and functions as a service.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Backend as a Service" data-type="sect2"><div class="sect2" id="idm46222432065656">&#13;
<h2>Backend as a Service</h2>&#13;
&#13;
<p>Backend<a data-primary="serverless cloud computing" data-secondary="backend as a service (BaaS)" data-type="indexterm" id="idm46222432064120"/><a data-primary="backend as a service (BaaS)" data-type="indexterm" id="idm46222432063176"/> as a service (BaaS) allows us to replace server-side components that we code and/or&#13;
manage ourselves with off-the-shelf services. It’s closer in concept to software as a service (SaaS)&#13;
than it is to things like virtual instances and containers. SaaS is typically about outsourcing&#13;
business processes, though—think HR or sales tools or, on the technical side, products like GitHub—whereas with BaaS, we’re breaking up our applications into smaller pieces and implementing some of&#13;
those pieces entirely with externally hosted products.</p>&#13;
&#13;
<p>BaaS services are domain-generic remote components (i.e., not in-process libraries) that we can&#13;
incorporate into our products, with an application programming interface (API) being a typical integration paradigm.</p>&#13;
&#13;
<p>BaaS has become especially popular with teams developing mobile apps or single-page web apps. Many&#13;
such teams are able to rely significantly on third-party services to perform tasks that they would&#13;
otherwise have needed to do themselves. Let’s look at a couple of examples.</p>&#13;
&#13;
<p>First<a data-primary="Firebase" data-type="indexterm" id="idm46222432060072"/> up we have services like Google’s <a href="https://firebase.google.com">Firebase</a>.&#13;
Firebase is a database product that is fully managed by a vendor (Google in this&#13;
case) that can be accessed directly from a mobile or web application without the need for our own&#13;
intermediary application server. This represents one aspect of BaaS: services that manage data&#13;
components on our behalf.</p>&#13;
&#13;
<p>BaaS services also allow us to rely on application logic that someone else has implemented. A good&#13;
example here is authentication—many applications implement their own code to perform sign-up, login,&#13;
password management, etc., but more often than not this code is similar across many apps. Such&#13;
repetition across teams and businesses is ripe for extraction into an external service, and that’s&#13;
precisely the aim of products<a data-primary="Auth0" data-type="indexterm" id="idm46222432057304"/><a data-primary="Cognito" data-type="indexterm" id="idm46222432056600"/> like <a href="https://auth0.com">Auth0</a> and Amazon’s&#13;
<a href="https://aws.amazon.com/cognito">Cognito</a>. Both of these products allow mobile apps and web apps to&#13;
have fully featured authentication and user management, but without a development team having to&#13;
write or manage any of the code to implement those features.</p>&#13;
&#13;
<p>The<a data-primary="mobile backend as a service (MBaaS)" data-type="indexterm" id="idm46222431649320"/> term <em>BaaS</em> came to prominence with the rise in mobile application development; in fact, the&#13;
term is sometimes referred to as <em>mobile backend as a service</em> (MBaaS). However, the key idea of using&#13;
fully externally managed products as part of our application development is not unique to mobile&#13;
development, or even frontend development in general.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Functions as a Service" data-type="sect2"><div class="sect2" id="idm46222431647144">&#13;
<h2>Functions as a Service</h2>&#13;
&#13;
<p>The<a data-primary="serverless cloud computing" data-secondary="functions as a service (FaaS)" data-type="indexterm" id="idm46222431645768"/><a data-primary="functions as a service (FaaS)" data-secondary="basics of" data-type="indexterm" id="idm46222431644680"/> other half of serverless is functions as a service (FaaS). FaaS, like IaaS, PaaS, and CaaS, is&#13;
another form of compute as a service—a generic environment within which we can run our own&#13;
software. Some<a data-primary="serverless compute" data-seealso="functions as a service (FaaS)" data-type="indexterm" id="idm46222431643368"/> people like to use the term <em>serverless compute</em> instead of FaaS.</p>&#13;
&#13;
<p>With FaaS we deploy our code as independent functions or operations, and we configure those&#13;
functions to be called, or triggered, when a specific event or request occurs within the FaaS&#13;
platform. The platform itself calls our functions by instantiating a dedicated environment <em>for each&#13;
event</em>—this environment consists of an ephemeral, fully managed lightweight virtual machine, or&#13;
container; the FaaS runtime; and our code.</p>&#13;
&#13;
<p>The<a data-primary="functions as a service (FaaS)" data-secondary="benefits of" data-type="indexterm" id="idm46222431640184"/> result of this type of environment is that we have no concern for the runtime management of our&#13;
code, unlike any other style of compute platform.</p>&#13;
&#13;
<p>Furthermore, because of several factors of serverless in general that we describe in a moment,&#13;
with FaaS we have no concern for hosts or processes, and scaling and resource management are handled on&#13;
our behalf.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Differentiating Serverless" data-type="sect2"><div class="sect2" id="idm46222431638088">&#13;
<h2>Differentiating Serverless</h2>&#13;
&#13;
<p>The<a data-primary="serverless cloud computing" data-secondary="differentiating" data-type="indexterm" id="idm46222431636792"/> idea of using externally hosted application components, as we do with BaaS, is not new—people&#13;
have been using hosted SQL databases for a decade or more—so what makes some of these services&#13;
qualify as backends as a service?&#13;
And what aspects do BaaS and FaaS have in common that cause us to group them into the idea of serverless computing?</p>&#13;
&#13;
<p>There are five key criteria that differentiate serverless services—both BaaS and FaaS—that allow us to approach&#13;
architecting applications in a new way. These criteria are as follows:</p>&#13;
<dl>&#13;
<dt>Does not require managing a long-lived host or application instance</dt>&#13;
<dd>&#13;
<p>This is the core of serverless. Most other ways of operating server-side software require us to&#13;
deploy, run, and monitor an instance of an application (whether programmed by us or others), and&#13;
that application’s lifetime spans more than one request. Serverless implies the opposite of this:&#13;
there is no long-lived server process, or server host, that we need to manage. That’s not to say&#13;
those servers don’t exist—they absolutely do—but they are not our concern or responsibility.</p>&#13;
</dd>&#13;
<dt>Self auto-scales and auto-provisions, dependent on load</dt>&#13;
<dd>&#13;
<p>Auto-scaling<a data-primary="auto-scaling" data-secondary="defined" data-type="indexterm" id="idm46222431630952"/><a data-primary="scaling" data-secondary="auto-scaling feature" data-type="indexterm" id="idm46222431629944"/> is the ability of a system to adjust capacity requirements dynamically based upon load.&#13;
Most existing auto-scaling solutions require some amount of work by the utilizing team. Serverless&#13;
services self auto-scale from the first time you use them with no effort at all.</p>&#13;
&#13;
<p>Serverless<a data-primary="auto-provisioning" data-type="indexterm" id="idm46222431628200"/> services also auto-provision when they perform auto-scaling. They remove all the effort&#13;
of allocating capacity, both in terms of number and size of underlying resources. This is a huge&#13;
operational burden lifted.</p>&#13;
</dd>&#13;
<dt>Has<a data-primary="costs" data-secondary="based on precise usage" data-type="indexterm" id="idm46222431626600"/> costs that are based on precise usage, up from and down to zero usage</dt>&#13;
<dd>&#13;
<p>This is closely tied to the previous point—serverless costs are precisely correlated with usage.&#13;
The cost of using a BaaS database, for instance, should be closely tied to usage, not predefined&#13;
capacity. This cost should be largely derived from actual amount of storage used and/or requests&#13;
made.</p>&#13;
&#13;
<p>Note that we’re not saying costs should be solely based on usage—there may be some overhead&#13;
cost for using the service in general—but the lion’s share of the costs should be proportional to&#13;
fine-grained usage.</p>&#13;
</dd>&#13;
<dt>Has performance capabilities defined in terms other than host size/count</dt>&#13;
<dd>&#13;
<p>It’s reasonable and useful for a serverless platform to expose some performance configuration.&#13;
However, this configuration should be completely abstracted from whatever underlying instance or&#13;
host types are being used.</p>&#13;
</dd>&#13;
<dt>Has implicit high availability</dt>&#13;
<dd>&#13;
<p>When<a data-primary="high availability (HA)" data-type="indexterm" id="idm46222431620808"/> operating applications, we typically use the term high availability (HA) to mean that a service&#13;
will continue to process requests even when an underlying component fails. With a serverless service&#13;
we expect the vendor to provide HA transparently for us.</p>&#13;
&#13;
<p>As an example, if we’re using a BaaS database, we assume that the provider is doing whatever is&#13;
necessary to handle the failure of individual hosts or internal components.<a data-primary="" data-startref="CCserverless01" data-type="indexterm" id="idm46222431619096"/></p>&#13;
</dd>&#13;
</dl>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="What Is AWS?" data-type="sect1"><div class="sect1" id="idm46222431617864">&#13;
<h1>What Is AWS?</h1>&#13;
&#13;
<p>We’ve<a data-primary="cloud computing" data-secondary="Amazon Web Services (AWS)" data-type="indexterm" id="idm46222431616328"/><a data-primary="Amazon Web Services (AWS)" data-secondary="types of service" data-type="indexterm" id="idm46222431615352"/> talked about AWS a few times already in this chapter, and now it’s time to look at this behemoth of cloud providers in a little more detail.</p>&#13;
&#13;
<p>Since its launch in 2006, AWS has grown at a mind-boggling rate, in terms of the number and type of&#13;
service offered, the capacity that the AWS cloud provides, and the number of companies using it.&#13;
Let’s look at all of those aspects.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Types of Service" data-type="sect2"><div class="sect2" id="idm46222431613336">&#13;
<h2>Types of Service</h2>&#13;
&#13;
<p>AWS has more than a hundred different services. Some of these are fairly low level—networking,&#13;
virtual machines, basic block storage. Above these services, in abstraction, come the component&#13;
services—databases, platforms as a service, message buses. Then on top of all of these come&#13;
true application components—user management, machine learning, data analysis.</p>&#13;
&#13;
<p>Sideways of this stack are the management services necessary to work with AWS at scale—security,&#13;
cost reporting, deployment, monitoring, etc.</p>&#13;
&#13;
<p class="pagebreak-before">This combination of services is shown in <a data-type="xref" href="#aws-service-layers">Figure 1-1</a>.</p>&#13;
&#13;
<figure><div class="figure" id="aws-service-layers">&#13;
<img alt="images/ch01_image01.png" src="assets/awsl_0101.png"/>&#13;
<h6><span class="label">Figure 1-1. </span>AWS service layers</h6>&#13;
</div></figure>&#13;
&#13;
<p>AWS likes to pitch itself as the ultimate IT “Lego brick” provider—it provides a vast number&#13;
of pluggable types of resources that can be joined together to create huge, massively scalable,&#13;
enterprise-grade applications.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Capacity" data-type="sect2"><div class="sect2" id="idm46222431884360">&#13;
<h2>Capacity</h2>&#13;
&#13;
<p>AWS<a data-primary="Amazon Web Services (AWS)" data-secondary="capacity" data-type="indexterm" id="idm46222431882952"/> houses its computers in more than 60 data centers spread around the world as shown in&#13;
<a data-type="xref" href="#aws-regions">Figure 1-2</a>. In AWS terminology, each data center corresponds to an <em>Availability Zone (AZ)</em>, and&#13;
clusters of data centers in close proximity to each other are grouped into <em>regions</em>. AWS has more&#13;
than 20 different regions, across 5 continents.</p>&#13;
&#13;
<p>That’s a lot of computers.</p>&#13;
&#13;
<p>While<a data-primary="Amazon Web Services (AWS)" data-secondary="global infrastructure" data-type="indexterm" id="idm46222431879192"/> the total number of regions continues to grow, so does the capacity within each region. A vast&#13;
number of US-based internet companies run their systems in the us-east-1 region in Northern&#13;
Virginia (just outside Washington DC)—and the more companies that run their systems there, the&#13;
more confident AWS is in increasing the number of servers available. This is a virtuous cycle&#13;
between Amazon and its <span class="keep-together">customers</span>.</p>&#13;
&#13;
<figure><div class="figure" id="aws-regions">&#13;
<img alt="images/ch01_image02.png" src="assets/awsl_0102.png"/>&#13;
<h6><span class="label">Figure 1-2. </span>AWS regions (source: <a href="https://oreil.ly/61Ztd">AWS</a>)</h6>&#13;
</div></figure>&#13;
&#13;
<p>When<a data-primary="Elastic Compute Cloud (EC2)" data-type="indexterm" id="idm46222431873656"/> you use some of Amazon’s lower-level services, like EC2, you’ll typically specify an&#13;
Availability Zone to use. With the higher-level services, though, you’ll usually specify only a region, and Amazon will handle any problems for you on an individual data center level.</p>&#13;
&#13;
<p>A compelling aspect of Amazon’s region model is that each region is largely independent,&#13;
logistically and from a software management point of view. That means that if a physical problem&#13;
like a power outage, or a software problem like a deployment bug, happens in one region, the others&#13;
will almost certainly be unaffected. The region model does make for some extra work from our point&#13;
of view as users, but overall it works well.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="pagebreak-before lesss_space" data-pdf-bookmark="Who Uses AWS?" data-type="sect2"><div class="sect2" id="idm46222431871528">&#13;
<h2>Who Uses AWS?</h2>&#13;
&#13;
<p>AWS<a data-primary="Amazon Web Services (AWS)" data-secondary="uses for" data-type="indexterm" id="idm46222431869784"/> has a vast number of customers, spread all around the planet. Massive enterprises, governments,&#13;
startups, individuals, and everyone in between use AWS. Many of the internet services you use are&#13;
probably hosted on AWS.</p>&#13;
&#13;
<p>AWS is not just for websites. Many companies have moved a lot of their “backend” IT infrastructure&#13;
to AWS, finding it a more compelling option than running their own physical infrastructure.</p>&#13;
&#13;
<p>AWS, of course, doesn’t have a monopoly. Google and Microsoft are their biggest competitors, at least in&#13;
the English-speaking world, while Alibaba Cloud competes with them in the growing Chinese market.&#13;
And there are plenty of other cloud providers offering services suited to specific types of&#13;
customer.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="How Do You Use AWS?" data-type="sect2"><div class="sect2" id="idm46222431866936">&#13;
<h2>How Do You Use AWS?</h2>&#13;
&#13;
<p>Your<a data-primary="Amazon Web Services (AWS)" data-secondary="account set up and use" data-type="indexterm" id="idm46222431865144"/><a data-primary="AWS Web Console" data-secondary="account set up" data-type="indexterm" id="idm46222431864168"/><a data-primary="accounts, set up and use" data-type="indexterm" id="idm46222431863224"/><a data-primary="credentials" data-secondary="acquiring for AWS account set up" data-type="indexterm" id="idm46222431862584"/> first interaction with AWS will likely be via the <a href="https://console.aws.amazon.com">AWS Web Console</a>. To do this, you will need some kind of access credential, which&#13;
will give you permissions within an <em>account</em>. An account is a construct that maps to billing&#13;
(i.e., paying AWS for the services you use), but it is also a grouping of defined service configurations&#13;
within AWS. Companies tend to run a number of production applications in one account. (Accounts&#13;
can also have <em>subaccounts</em>, but we won’t be talking about them too much in this book—just know&#13;
that if you’re using credentials supplied by a company, they might be for a specific subaccount.)</p>&#13;
&#13;
<p>If<a data-primary="exercises" data-secondary="AWS account set up" data-type="indexterm" id="idm46222431859112"/><a data-primary="Amazon Web Services (AWS)" data-secondary="free tier" data-type="indexterm" id="idm46222431858104"/> you haven’t been given credentials by your company, you’ll need to create an account. You can do&#13;
this by supplying AWS with your credit card details, but know that AWS supplies a generous <em>free&#13;
tier</em>, and if you just stick to the basic exercises in this book, you shouldn’t end up needing to pay&#13;
AWS anything.</p>&#13;
&#13;
<p>Your credentials may be in the form of a typical username and password or may be via a single sign-on (SSO) workflow (e.g., via Google Apps or Microsoft Active Directory). Either way, eventually you’ll&#13;
successfully log in to the web console. Using<a data-primary="AWS Web Console" data-secondary="navigating the home page" data-type="indexterm" id="idm46222431855656"/> the web console for the first time can be a daunting&#13;
experience, with all 100+ AWS services craving your attention—Amazon Polly shouting “PICK ME!!!” in&#13;
equal measure to a strange thing called Macie. And then of course what about all of those services known only&#13;
by an acronym—what <em>are</em> they?</p>&#13;
&#13;
<p>Part of the reason for the overwhelming nature of the home page of the AWS Console is because it&#13;
really isn’t developed as one product—it’s developed as a hundred different products, all given a&#13;
link on the home page. Also, drilling into one product may look quite different from another because&#13;
each product is given a good amount of autonomy within the AWS universe. Sometimes using AWS might&#13;
feel like a <span class="keep-together">spelunking</span> exercise in navigating the AWS corporate organization—don’t worry, we all&#13;
feel that way.</p>&#13;
&#13;
<p>Apart<a data-primary="Amazon Web Services (AWS)" data-secondary="interacting through API" data-type="indexterm" id="idm46222431851752"/> from the web console, the other way of interacting with AWS is via its extensive API. One&#13;
great aspect that Amazon has had from very early in its history, even before the times of AWS, is&#13;
that each service must be fully usable via a public API, and this means that for all intents and&#13;
purposes anything that is possible to configure in AWS can be done via the API.</p>&#13;
&#13;
<p>Layered<a data-primary="Amazon Web Services (AWS)" data-secondary="command line interface (CLI)" data-type="indexterm" id="idm46222431849832"/> on top of the API is the CLI—the command line interface—which we use&#13;
in this book. The CLI is most simply described as a thin client application that communicates with&#13;
the AWS API. We talk about configuring the CLI in the next chapter (<a data-type="xref" href="ch02.html#aws-cli">“AWS Command Line Interface”</a>).</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="What Is AWS Lambda?" data-type="sect1"><div class="sect1" id="idm46222431847480">&#13;
<h1>What Is AWS Lambda?</h1>&#13;
&#13;
<p>Lambda<a data-primary="cloud computing" data-secondary="AWS Lambda" data-type="indexterm" id="CClambda01"/> is Amazon’s FaaS platform. We briefly mentioned FaaS earlier, but&#13;
now it’s time to dig into it in some more detail.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Functions as a Service" data-type="sect2"><div class="sect2" id="idm46222431844232">&#13;
<h2>Functions as a Service</h2>&#13;
&#13;
<p>As<a data-primary="AWS Lambda" data-secondary="FaaS versus server-side software deployment" data-type="indexterm" id="idm46222431842696"/><a data-primary="functions as a service (FaaS)" data-secondary="versus server-side software deployment" data-secondary-sortas="server-side software deployment" data-type="indexterm" id="idm46222431841720"/> we introduced before, FaaS is a new way of building and deploying server-side software, oriented&#13;
around deploying individual functions or operations. FaaS is where a lot of the buzz about&#13;
serverless comes from; in fact, many people think that serverless <em>is</em> FaaS, but they’re missing out&#13;
on the complete picture. While this book focuses on FaaS, we encourage you to consider BaaS too as&#13;
you build out bigger applications.</p>&#13;
&#13;
<p>When we deploy traditional server-side software, we start with a host instance, typically a&#13;
VM instance or a container (see <a data-type="xref" href="#server-side-software-deployment">Figure 1-3</a>). We then&#13;
deploy our application, which usually runs as an operating system process, within the host. Usually&#13;
our application contains code for several different but related operations; for instance, a web&#13;
service may allow both retrieval and updating resources.</p>&#13;
&#13;
<figure class="no-frame"><div class="figure" id="server-side-software-deployment">&#13;
<img alt="images/ch01_image03.png" src="assets/awsl_0103.png"/>&#13;
<h6><span class="label">Figure 1-3. </span>Traditional server-side software deployment</h6>&#13;
</div></figure>&#13;
&#13;
<p>From an ownership point of view, we as users are responsible for all three aspects of this configuration—host instance, application process, and of course program <span class="keep-together">operations</span>.</p>&#13;
&#13;
<p>FaaS changes this model of deployment and ownership (see <a data-type="xref" href="#faas-software-deployment">Figure 1-4</a>). We strip away both the&#13;
host instance and the application process from our model. Instead, we focus on just the individual&#13;
operations or functions that express our application’s logic. We upload those functions individually&#13;
to a FaaS platform, which itself is the responsibility of the cloud vendor and not us.</p>&#13;
&#13;
<figure class="no-frame"><div class="figure" id="faas-software-deployment">&#13;
<img alt="images/ch01_image04.png" src="assets/awsl_0104.png"/>&#13;
<h6><span class="label">Figure 1-4. </span>FaaS software deployment</h6>&#13;
</div></figure>&#13;
&#13;
<p>The functions are not constantly active in an application process, though, sitting idle until they&#13;
need to be run as they would in a traditional system. Instead, the FaaS platform is configured to&#13;
listen for a specific event for each operation. When that event occurs, the platform instantiates&#13;
the FaaS function and then calls it, passing the triggering event.</p>&#13;
&#13;
<p>Once the function has finished executing, the FaaS platform is free to tear it down. Alternatively,&#13;
as an optimization, it may keep the function around for a little while until there’s another event&#13;
to be processed.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="FaaS as Implemented by Lambda" data-type="sect2"><div class="sect2" id="lambda-as-faas">&#13;
<h2>FaaS as Implemented by Lambda</h2>&#13;
&#13;
<p>AWS <a data-primary="AWS Lambda" data-secondary="FaaS implementation by" data-type="indexterm" id="idm46222431690984"/><a data-primary="functions as a service (FaaS)" data-secondary="implementation by AWS Lambda" data-type="indexterm" id="idm46222431689976"/>Lambda was launched in 2014, and it continues to grow in scope, maturity, and usage. Some Lambda&#13;
functions might be very low throughput—perhaps just executing once per day, or even less&#13;
frequently than that. But others may be executed billions of times per day.</p>&#13;
&#13;
<p>Lambda implements the FaaS pattern by instantiating ephemeral, managed, Linux environments to host&#13;
each of our function instances. Lambda guarantees that only one event is processed per environment&#13;
at a time. At the time of writing, Lambda also requires that the function completes processing of&#13;
the event within 15 minutes; otherwise, the execution is aborted.</p>&#13;
&#13;
<p>Lambda<a data-primary="AWS Lambda" data-secondary="benefits of" data-type="indexterm" id="idm46222431687368"/> provides an exceptionally lightweight programming and deployment model—we just provide a&#13;
function, and associated dependencies, in a ZIP or JAR file, and Lambda fully manages the runtime&#13;
environment.</p>&#13;
&#13;
<p>Lambda is tightly integrated with many other AWS services. This corresponds to many different types&#13;
of event source that can trigger Lambda functions, and this leads to the ability to build many&#13;
different types of applications using Lambda.</p>&#13;
&#13;
<p>Lambda is a fully serverless service, as defined by our differentiating criteria from earlier,&#13;
specifically:</p>&#13;
<dl>&#13;
<dt>Does not require managing a long-lived host or application instance</dt>&#13;
<dd>&#13;
<p>With Lambda we are fully abstracted from the underlying host running our code. Furthermore, we do not&#13;
manage a long-lived application—once our code has finished processing a particular event, AWS is&#13;
free to terminate the runtime <span class="keep-together">environment</span>.</p>&#13;
</dd>&#13;
<dt>Self auto-scales and auto-provisions, dependent on load</dt>&#13;
<dd>&#13;
<p>This<a data-primary="auto-provisioning" data-type="indexterm" id="idm46222431680648"/><a data-primary="auto-scaling" data-secondary="transparency of" data-type="indexterm" id="idm46222431679912"/><a data-primary="scaling" data-secondary="auto-scaling feature" data-type="indexterm" id="idm46222431678968"/> is one of the key benefits of Lambda—resource management and scaling is completely&#13;
transparent. Once we upload our function code, the Lambda platform will create just enough environments&#13;
to handle the load at any particular time. If one environment is enough then Lambda will create the&#13;
environment when it is needed. If on the other hand hundreds of separate instances are required, then&#13;
Lambda will scale out quickly and without any effort on our part.</p>&#13;
</dd>&#13;
<dt>Has<a data-primary="costs" data-secondary="based on precise usage" data-type="indexterm" id="idm46222431676904"/> costs that are based on precise usage, up from and down to zero usage</dt>&#13;
<dd>&#13;
<p>AWS charges for Lambda only for the time that our code is executing per environment, down to a 100 ms&#13;
precision. If our function is active for 200 ms every 5 minutes, then we’ll be charged only for 2.4&#13;
seconds of usage per hour. This precise usage cost structure is the same whether one instance of our&#13;
function is required or a thousand.</p>&#13;
</dd>&#13;
<dt>Has performance capabilities defined in terms other than host size/count</dt>&#13;
<dd>&#13;
<p>Since we are fully abstracted from the underlying host with Lambda, we can’t specify a number or&#13;
type of underlying EC2 instances to use. Instead, we specify how much RAM our function requires (up to&#13;
a maximum of 3GB), and other aspects of performance are tied to this too. We explore this in more&#13;
detail later in the book—see <a data-type="xref" href="ch03.html#memory-and-cpu">“Memory and CPU”</a>.</p>&#13;
</dd>&#13;
<dt>Has implicit high availability</dt>&#13;
<dd>&#13;
<p>If<a data-primary="high availability (HA)" data-type="indexterm" id="idm46222431670664"/><a data-primary="Availability Zones (AZs)" data-type="indexterm" id="idm46222431669928"/> a particular underlying host fails, then Lambda will automatically start environments on a different&#13;
host. Similarly, if a particular data center/<em>Availability Zone</em> fails, then Lambda will&#13;
automatically start environments in a different AZ in the same <em>region</em>. Note that it’s on us as AWS&#13;
customers to handle a <em>region-wide</em> failure, and we talk about this toward the end of the book—see <a data-type="xref" href="ch09.html#globally-distributed-applications">“Globally Distributed Applications”</a>.</p>&#13;
</dd>&#13;
</dl>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Why Lambda?" data-type="sect2"><div class="sect2" id="idm46222431684072">&#13;
<h2>Why Lambda?</h2>&#13;
&#13;
<p>The<a data-primary="AWS Lambda" data-secondary="key benefit of" data-type="indexterm" id="idm46222431665384"/> basic benefits of the cloud, as we described earlier, apply to Lambda—it’s often cheaper to&#13;
run in comparison to other types of host platform; it requires less effort and time to operate a&#13;
Lambda application; and the scaling flexibility of Lambda surpasses any other compute option within&#13;
AWS.</p>&#13;
&#13;
<p>However, the key benefit from our perspective is how quickly you can build applications with Lambda&#13;
when combined with other AWS services. We often hear of companies building brand new applications,&#13;
deployed to production, in just a day or two. Being able to remove ourselves from so much of the&#13;
infrastructure-related code we often write in regular applications is a huge time-saver.</p>&#13;
&#13;
<p>Lambda also has more capacity, more maturity, and more integration points than any other FaaS&#13;
platform. It’s not perfect, and some other products in our opinion offer better “developer UX” than&#13;
Lambda. But absent any strong tie to an existing cloud vendor, we would recommend AWS Lambda for&#13;
all of the reasons listed earlier.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="What Does a Lambda Application Look Like?" data-type="sect2"><div class="sect2" id="what_does_a_lambda_application_look_like">&#13;
<h2>What Does a Lambda Application Look Like?</h2>&#13;
&#13;
<p>Traditional<a data-primary="AWS Lambda" data-secondary="application overview" data-type="indexterm" id="AWSbuild01"/> long-running server applications often have at least one of two ways of starting work&#13;
for a particular stimulus—they either open up a TCP/IP socket and wait for inbound connections or have an internal scheduling mechanism that will cause them to reach out to a remote resource to&#13;
check for new work. Since Lambda is fundamentally an event-oriented platform and since Lambda&#13;
enforces a timeout, neither of these patterns is applicable to a Lambda application. So&#13;
how <em>do</em> we build a Lambda application?</p>&#13;
&#13;
<p>The<a data-primary="Lambda applications" data-secondary="invocation models" data-type="indexterm" id="idm46222431657592"/><a data-primary="invocation models" data-type="indexterm" id="idm46222431656584"/> first point to consider is that at the lowest level Lambda functions can be invoked (called) in&#13;
one of two ways:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Lambda<a data-primary="Lambda functions" data-secondary="invocation models" data-type="indexterm" id="idm46222431654632"/> functions can be called <em>synchronously</em>—named <code>RequestResponse</code> by AWS.&#13;
In this scenario, an upstream component calls the Lambda function and waits for whatever response the Lambda function generates.</p>&#13;
</li>&#13;
<li>&#13;
<p>Alternatively, a Lambda function may be invoked <em>asynchronously</em>—named <code>Event</code> by AWS.&#13;
This time the request from the upstream caller is responded to immediately by the Lambda <em>platform</em>, while the Lambda <em>function</em> proceeds with processing the request.&#13;
No further response is returned to the caller in this scenario.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>These two invocation models have various other behaviors, which we get into later, starting with&#13;
<a data-type="xref" href="ch03.html#invocation_types_explanation">“Invocation Types”</a>. For now let’s see how they are used in some example&#13;
applications.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Web API" data-type="sect3"><div class="sect3" id="idm46222427974696">&#13;
<h3>Web API</h3>&#13;
&#13;
<p>An<a data-primary="API Gateway" data-secondary="purpose of" data-type="indexterm" id="idm46222427972856"/><a data-primary="web API" data-type="indexterm" id="idm46222427971848"/><a data-primary="Lambda functions" data-secondary="HTTP protocols with API Gateway" data-type="indexterm" id="idm46222427971176"/><a data-primary="Lambda applications" data-secondary="HTTP protocols with API Gateway" data-type="indexterm" id="idm46222427970264"/> obvious question to ask is whether Lambda can be used in the implementation of an HTTP API, and&#13;
fortunately the answer is yes! While Lambda functions aren’t HTTP servers themselves, we can use&#13;
another AWS component, <em>API Gateway</em>, to provide the HTTP protocol and routing logic that we&#13;
typically have within a web <span class="keep-together">service</span> (see <a data-type="xref" href="#web-api">Figure 1-5</a>).</p>&#13;
&#13;
<figure><div class="figure" id="web-api">&#13;
<img alt="images/ch01_image05.png" src="assets/awsl_0105.png"/>&#13;
<h6><span class="label">Figure 1-5. </span>Web API using AWS Lambda</h6>&#13;
</div></figure>&#13;
&#13;
<p>The above diagram shows a typical API as used by a single-page web app or by a mobile application.&#13;
The user’s client makes various calls, via HTTP, to the backend to retrieve data and/or initiate&#13;
requests. In our case, the component that handles the HTTP aspects of the request is Amazon API&#13;
Gateway—it is an HTTP server.</p>&#13;
&#13;
<p>We configure API Gateway with a mapping from request to handler (e.g., if a client makes a request to&#13;
<code>GET /restaurants/123</code>, then we can set up API Gateway to call a Lambda function named&#13;
<code>RestaurantsFunction</code>, passing the details of the request). API Gateway will invoke the Lambda&#13;
function <em>synchronously</em> and will wait for the function to evaluate the request and return a&#13;
response.</p>&#13;
&#13;
<p>Since the Lambda function instance isn’t itself a remotely callable API, the API Gateway actually&#13;
makes a call to the Lambda platform, specifying the Lambda function to invoke, the type of&#13;
invocation (<code>RequestResponse</code>), and the request parameters. The Lambda platform then instantiates an&#13;
instance of <code>RestaurantsFunction</code> and invokes that with the request parameters.</p>&#13;
&#13;
<p>The Lambda platform does have a few limitations, like the maximum timeout we’ve already mentioned,&#13;
but apart from that, it’s pretty much a standard Linux environment. In <code>RestaurantsFunction</code> we can,&#13;
for example, make a call to a database—Amazon’s DynamoDB<a data-primary="DynamoDB" data-secondary="scaling capabilities" data-type="indexterm" id="idm46222427959864"/> is a popular database to use with Lambda,&#13;
partly due to the similar scaling capabilities of the two services.</p>&#13;
&#13;
<p>Once the function has finished its work, it returns a response, since it was called in a synchronous&#13;
fashion. This response is passed by the Lambda platform back to API Gateway, which transforms the&#13;
response into an HTTP response message, which is itself passed back to the client.</p>&#13;
&#13;
<p>Typically a web API will satisfy multiple types of requests, mapped to different HTTP <em>paths</em> and&#13;
<em>verbs</em> (like GET, PUT, POST, etc.). When developing a Lambda-backed web API, you will usually&#13;
implement different types of requests as different Lambda functions, although you are not forced to&#13;
use such a design—you can handle all requests as one function if you’d like and switch logic&#13;
inside the function based on the original HTTP request path and verb.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="File processing" data-type="sect3"><div class="sect3" id="file-processing-example">&#13;
<h3>File processing</h3>&#13;
&#13;
<p>A<a data-primary="Lambda applications" data-secondary="file processing using" data-type="indexterm" id="idm46222427954152"/><a data-primary="photo resizer" data-type="indexterm" id="idm46222427953144"/><a data-primary="file processing" data-type="indexterm" id="idm46222427952472"/> common use case for Lambda is file processing. Let’s imagine a mobile application that can&#13;
upload photos to a remote server, which we then want to make available to other parts of our product&#13;
suite, but at different image sizes, as shown in <a data-type="xref" href="#file-processing">Figure 1-6</a>.</p>&#13;
&#13;
<figure><div class="figure" id="file-processing">&#13;
<img alt="images/ch01_image06.png" src="assets/awsl_0106.png"/>&#13;
<h6><span class="label">Figure 1-6. </span>File processing using AWS Lambda</h6>&#13;
</div></figure>&#13;
&#13;
<p>S3<a data-primary="Simple Storage Service (S3)" data-secondary="uploading files to" data-type="indexterm" id="idm46222427948232"/> is Amazon’s Simple Storage Service—the very same that was launched in 2006. Mobile applications&#13;
can upload files to S3 via the AWS API, in a secure fashion.</p>&#13;
&#13;
<p>S3 can be configured to invoke the Lambda platform when the file is uploaded, specifying the&#13;
function to be called, and passing a path to the file. As with the previous example, the Lambda&#13;
platform then instantiates the Lambda function and calls it with the request details passed this&#13;
time by S3. The difference now, though, is that this is an <em>asynchronous</em> invocation (S3 specified the&#13;
<code>Event</code> invocation type)—no value is returned to S3 nor does S3 wait for a return value.</p>&#13;
&#13;
<p>This<a data-primary="side effects" data-secondary="Lambda functions and" data-type="indexterm" id="idm46222427944904"/> time our Lambda function exists solely for the purpose of a <em>side effect</em>—it loads the file&#13;
specified by the request parameter and then creates new, resized versions of the file in a&#13;
different S3 bucket. With the side effects complete, the Lambda function’s work is done. Since it&#13;
created files in an S3 bucket, we may choose to add a Lambda trigger to that bucket also,&#13;
invoking further Lambda functions that process these generated files, creating a processing pipeline.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Other examples of Lambda applications" data-type="sect3"><div class="sect3" id="idm46222427942664">&#13;
<h3>Other examples of Lambda applications</h3>&#13;
&#13;
<p>The<a data-primary="Lambda applications" data-secondary="examples of" data-type="indexterm" id="idm46222427941240"/> previous two examples show two scenarios, with two different Lambda event sources. There are many&#13;
other event sources that enable us to build many other types of applications. Just some of these are&#13;
as follows:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>We can build<a data-primary="message-processing applications" data-type="indexterm" id="idm46222427938760"/> message-processing applications, using message buses like Simple Notification Service (SNS), Simple Queue Service (SQS), EventBridge, or Kinesis as the event source.</p>&#13;
</li>&#13;
<li>&#13;
<p>We can build<a data-primary="email-processing applications" data-type="indexterm" id="idm46222427936648"/> email-processing applications, using Simple Email Service (SES) as the event source.</p>&#13;
</li>&#13;
<li>&#13;
<p>We<a data-primary="scheduled-task applications" data-type="indexterm" id="idm46222427934936"/> can build scheduled-task applications, similar to cron programs, using<a data-primary="CloudWatch Scheduled Events" data-type="indexterm" id="idm46222427934056"/> CloudWatch Scheduled&#13;
Events as the trigger.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Note<a data-primary="serverless architecture" data-secondary="benefits of" data-type="indexterm" id="idm46222427932456"/> that many of these services other than Lambda are <em>BaaS</em> services and therefore also serverless.&#13;
Combining FaaS and BaaS to produce <em>serverless architectures</em> is an extraordinarily powerful technique due to their similar scaling, security, and cost characteristics.&#13;
In fact, it’s such combinations of service that are driving the popularity of serverless computing.</p>&#13;
&#13;
<p>We talk in depth about building applications in this way in <a data-type="xref" href="ch05.html#ch05">Chapter 5</a>.<a data-primary="" data-startref="AWSbuild01" data-type="indexterm" id="idm46222427928936"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="AWS Lambda in the Java World" data-type="sect2"><div class="sect2" id="idm46222427927832">&#13;
<h2>AWS Lambda in the Java World</h2>&#13;
&#13;
<p>AWS<a data-primary="AWS Lambda" data-secondary="language support" data-type="indexterm" id="idm46222427926328"/><a data-primary="language support" data-type="indexterm" id="idm46222427925320"/> Lambda natively supports a large number of languages.&#13;
JavaScript and Python are very popular “getting started” languages for Lambda (as well as for significant production applications) partly because of their dynamically typed, noncompiled nature allowing for very fast development cycles.</p>&#13;
&#13;
<p>We<a data-primary="AWS Lambda" data-secondary="language selection" data-type="indexterm" id="idm46222427923832"/> both got our start, however, using Lambda with Java.&#13;
Java occasionally has a bad reputation in the Lambda world—some of which is fair, and some not.&#13;
If what you need in a Lambda function can be expressed in 10 lines or so, it’s typically quicker to put something together in JavaScript or Python.&#13;
However, for larger applications, there are many excellent reasons to implement<a data-primary="Lambda functions" data-secondary="implementing in Java" data-type="indexterm" id="idm46222427922296"/><a data-primary="Java" data-secondary="benefits of" data-type="indexterm" id="idm46222427921352"/> Lambda functions in Java, a couple of which are as follows:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>If you or your team is more familiar with Java than the other Lambda-supported languages, then you’ll have the ability to reuse these skills and libraries in a new runtime platform.&#13;
Java is as much a “first-class language” in the Lambda ecosystem as JavaScript, Python, Go, etc., are—Lambda is not limiting you if you use Java.&#13;
Further, if you already have a lot of code implemented in Java, then porting some of this to Lambda can be a significant time-to-market advantage, in comparison to reimplementing in a different language.</p>&#13;
</li>&#13;
<li>&#13;
<p>In high throughput messaging systems, the typical runtime performance benefit of Java over JavaScript or Python can be significant.&#13;
Not only is “faster” normally “better” in any system, with Lambda “faster” can also result in tangible cost benefits due to Lambda’s pricing model.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>For JVM workloads, Lambda natively supports, at the time of writing, the Java 8 and Java 11 runtimes. The Lambda platform will instantiate a&#13;
version of the Java Runtime Environment within its Linux environment and then run our code within that&#13;
Java VM. Our code, therefore, must be compatible with that runtime environment, but we’re not restricted&#13;
to just using the Java language. Scala, Clojure, Kotlin, and more, can all be run on Lambda (see more at <a data-type="xref" href="ch08.html#other-jvm-languages">“Other JVM Languages and Lambda”</a>).</p>&#13;
&#13;
<p>There’s also an advanced option with Lambda to define your own runtime if neither of these Java versions is sufficient—we discuss this further in <a data-type="xref" href="ch08.html#custom-runtimes">“Custom Runtimes”</a>.</p>&#13;
&#13;
<p>The&#13;
Lambda platform supplies a few basic libraries with the runtime (e.g., a small subset of the AWS&#13;
Java library) but any other libraries that your code needs must be supplied with your code itself.&#13;
You will learn how to do that in <a data-type="xref" href="ch04.html#build-and-package">“Build and Package”</a>.</p>&#13;
&#13;
<p>Finally, while Java has the programming construct of&#13;
<a href="https://oreil.ly/nnjwh"><em>Lambda expressions</em></a>,&#13;
these are unrelated to AWS Lambda functions. You are free to use Java Lambda expressions within your&#13;
AWS Lambda function if you’d like (since AWS Lambda supports Java 8 and later) or not.<a data-primary="" data-startref="CClambda01" data-type="indexterm" id="idm46222427910984"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="idm46222427909912">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>In<a data-primary="AWS" data-see="Amazon Web Services (AWS)" data-type="indexterm" id="idm46222427908376"/><a data-primary="Lambda" data-see="AWS Lambda" data-type="indexterm" id="idm46222427907400"/><a data-primary="AWS Lambda" data-see="also Lambda applications; Lambda functions" data-type="indexterm" id="idm46222427906456"/><a data-primary="S3" data-see="Simple Storage Service (S3)" data-type="indexterm" id="idm46222427905480"/><a data-primary="CaaS" data-see="containers-as-a-service (CaaS)" data-type="indexterm" id="idm46222427904568"/><a data-primary="EC2" data-see="Elastic Compute Cloud (EC2)" data-type="indexterm" id="idm46222427903608"/><a data-primary="HA" data-see="high availability (HA)" data-type="indexterm" id="idm46222427902648"/><a data-primary="FaaS" data-see="functions as a service (FaaS)" data-type="indexterm" id="idm46222427901704"/> this chapter, you learned how serverless computing is the next evolution of the cloud—a way of&#13;
building applications by relying on services that handle resource management, scaling, and more,&#13;
transparently and without configuration.</p>&#13;
&#13;
<p>Further, you now understand that functions as a service (FaaS) and backend as a service (BaaS) are the two halves of serverless, with FaaS being the general-purpose computing paradigm within serverless.&#13;
For more information on serverless in general, we refer you to&#13;
our free O’Reilly ebook <a href="https://oreil.ly/5YbLa"><em>What Is&#13;
Serverless?</em></a></p>&#13;
&#13;
<p>You also have at least a basic knowledge of Amazon Web Services—one of the world’s most popular cloud platforms.&#13;
You’ve learned about the vast capacity that AWS has to host our applications and how you access AWS both via the web console and the API/CLI.</p>&#13;
&#13;
<p>You’ve been introduced to AWS Lambda—Amazon’s FaaS product. We compared “thinking in Lambda”&#13;
to a traditionally built application, talked about why you may want to use Lambda versus other FaaS&#13;
implementations, and then gave some examples of applications built using Lambda.</p>&#13;
&#13;
<p>Finally, you saw a quick overview of Java as a Lambda language option.</p>&#13;
&#13;
<p>In <a data-type="xref" href="ch02.html#ch02">Chapter 2</a> we implement our first Lambda function—get ready for a brave new world!</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Exercises" data-type="sect1"><div class="sect1" id="idm46222431338216">&#13;
<h1>Exercises</h1>&#13;
<ol>&#13;
<li>&#13;
<p>Acquire<a data-primary="exercises" data-secondary="AWS account set up" data-type="indexterm" id="idm46222431336088"/> credentials for an <a href="https://aws.amazon.com">AWS account</a>. The easiest way to do this is by creating a new account. As we mentioned earlier, if you do this, you’ll need to supply a credit card&#13;
number, but everything we do in this book should be covered by the free tier, unless you&#13;
get very enthusiastic with tests!</p>&#13;
&#13;
<p>Alternatively you can use an existing AWS account, but if so, we recommend using a “development”&#13;
account so as not to interfere with any “production” <span class="keep-together">systems</span>.</p>&#13;
&#13;
<p>We also strongly recommend that whatever access you use grants you full administrative permissions&#13;
within the account; otherwise, you’ll be bogged down by distracting security issues.</p>&#13;
</li>&#13;
<li>&#13;
<p>Log in to the <a href="https://console.aws.amazon.com">AWS Console</a>. Find the Lambda section—are there&#13;
any functions there yet?</p>&#13;
</li>&#13;
<li>&#13;
<p><em>Extended task</em>: Look at <a href="https://aws.amazon.com/serverless">Amazon’s serverless marketing page</a>, specifically where it describes the various services in its “serverless platform.” Which of&#13;
these services fully satisfy the differentiating criteria of a serverless service we described&#13;
earlier? Which don’t, and in what ways are they “mostly” serverless?</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section></body></html>