<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" class="pagenumrestart" data-pdf-bookmark="Chapter 1. Quarkus Overview"><div class="chapter" id="quarkus_overview_chapter">
<h1><span class="label">Chapter 1. </span>Quarkus Overview</h1>


<p><a data-type="indexterm" data-primary="Kafka" data-see="Apache Kafka" id="idm45128543840728"/><a data-type="indexterm" data-primary="authorization" data-see="authentication and authorization" id="idm45128543839752"/><a data-type="indexterm" data-primary="MicroProfile Fault Tolerance" data-see="fault tolerance" id="idm45128543838792"/><a data-type="indexterm" data-primary="Quarkus projects" data-see="projects" id="idm45128543837832"/><a data-type="indexterm" data-primary="Quarkus Vault" data-see="Vault" id="idm45128543836888"/><a data-type="indexterm" data-primary="Kubernetes secrets" data-see="secrets" id="idm45128543835944"/><a data-type="indexterm" data-primary="Kubernetes" data-secondary="about" id="idm45128543835000"/><a data-type="indexterm" data-primary="Containers in Pods" id="idm45128543834056"/>Kubernetes is becoming the de facto platform to deploy our enterprise applications nowadays.
The movement to containers and Kubernetes has led to changes in the way we code, deploy, and maintain our Java-based applications.
You can easily get yourself in trouble if you containerize and run a Java application without taking proper measures.
Containers in Pods (a Kubernetes term) are the basic units in Kubernetes, so it is very important to have a good understanding of how to containerize a Java-based application correctly to avoid pitfalls, wasted work, and extra hours of frustration.</p>

<p><a data-type="indexterm" data-primary="Quarkus" data-secondary="about" id="idm45128543786424"/>Quarkus is a cloud-native framework with built-in Kubernetes integration.
It is an open source stack, released under the Apache License 2.0, that helps you create Kubernetes-native applications tailored for GraalVM and OpenJDK HotSpot.
It is built on top of popular libraries and technologies such as Hibernate, Eclipse MicroProfile, Kubernetes, Apache Camel, and Eclipse Vert.x.</p>

<p><a data-type="indexterm" data-primary="Quarkus" data-secondary="benefits of" id="idm45128543784664"/>The benefits of Quarkus include easy integration with Docker and Kubernetes, quick startup time, low resident set size (RSS) memory, and increased developer productivity.
In this introductory chapter, we’ll take a quick look Quarkus—what it is, the problems it solves, how it integrates with Kubernetes, why developers enjoy working with it, and some of its most noteworthy features.</p>






<section data-type="sect1" class="orm:non-recipe" data-pdf-bookmark="Developer-Friendly"><div class="sect1" id="idm45128543783032">
<h1>Developer-Friendly</h1>

<p><a data-type="indexterm" data-primary="developer-friendliness, of Quarkus" id="idm45128543781352"/>Quarkus allows you, the Java developer, to be more productive, and it helps you stay relevant in the fast-paced area of microservices and cloud-based applications.</p>

<p>Quarkus will enable your applications to scale better, to more tightly fill up a Kubernetes cluster utilizing fewer resources overall, and to make use of decades of community work in open source Java.</p>

<p>To start developing with Quarkus, you won’t need to learn a new technology.
If you’re already familiar with dependency injection, JAX-RS, Hibernate, and Eclipse MicroProfile concepts, there’s nothing new here.
All the knowledge you have built up over the course of your career will map directly into Quarkus.
Whereas it might take weeks to learn other frameworks, you can get started with Quarkus and be productive in a matter of days or even hours.</p>

<p>Quarkus is designed to be an optimized choice for the next generation of application development and deployment. It supports you through the entire application life cycle from application scaffolding and live reloading in dev mode (a save-and-refresh workflow), all the way through to deployment in a cloud-based Kubernetes cluster. 
<span class="keep-together">As a developer,</span> Quarkus will keep you productive and solving problems, instead of 
<span class="keep-together">shaving</span> yaks.</p>
</div></section>













<section data-type="sect1" class="orm:non-recipe" data-pdf-bookmark="Integration with Kubernetes"><div class="sect1" id="idm45128543776568">
<h1>Integration with Kubernetes</h1>

<p><a data-type="indexterm" data-primary="Kubernetes" data-secondary="integration with" id="idm45128543775032"/>We said that Quarkus is meant to run within Kubernetes.
That sounds great, but we know lots of things can run within Kubernetes.
Throw your application in a Docker container, and it will run on Kubernetes.
While this is true, there are a number of things that traditionally have to be done to properly tune, size, and configure your application to run efficiently within Kubernetes.
You also have to pull out your text editor of choice and craft multiple YAML files—and let’s be honest, no one really enjoys doing all that.</p>

<p><a data-type="indexterm" data-primary="Dockerfiles" id="idm45128543773128"/>Quarkus eliminates that work by having a number of enhancements for deploying to and using Kubernetes with your application.
When you bootstrap a Quarkus application, it comes with some Dockerfile files used to generate the Docker containers for your application.
That is a great first step.
These files are optimized for running with the OpenJDK JVM or running as native executables with GraalVM.
They contain what is necessary to run the application, thereby eliminating as much duplication and unnecessary bloat from the container image as possible.</p>

<p><a data-type="indexterm" data-primary="YAML files" id="idm45128543771464"/>Next, when you use the Kubernetes extensions, Quarkus can generate the resources (YAML files) for a vanilla Kubernetes or OpenShift deployment!
No more having to wade through YAML files and make sure you have the right indentation.
After all, you’d prefer to be writing code than looking for that one line of YAML that isn’t formatted correctly.
Quarkus can also push your image to a registry before deploying to the Kubernetes cluster.
All of these application images can be further enhanced and customized via the Quarkus application configuration, which you’ll learn about in <a data-type="xref" href="ch04.xhtml#configuration_chapter">Chapter 4</a>.
For example, in Quarkus 1.4 and later, <code>ConfigMap</code> and <code>Secret</code>s can be read from the API server—you don’t need to mount any of the files in the Pod!</p>
</div></section>













<section data-type="sect1" class="orm:non-recipe" data-pdf-bookmark="Memory and First Response Time"><div class="sect1" id="idm45128543768152">
<h1>Memory and First Response Time</h1>

<p><a data-type="indexterm" data-primary="memory" id="idm45128543766536"/><a data-type="indexterm" data-primary="response time" id="idm45128543765832"/>Quarkus is known as the “supersonic, subatomic” Java framework.
That may set off marketing alarms with developers, but when you break it down and understand what Quarkus is doing, you’ll see that you really are getting a very small, quick, and productive execution.
With Quarkus, you can deploy a native application optimized to be run on Kubernetes.
For example, let’s say you want to deploy a native application, optimized to be run on Kubernetes, where the container image is around 200 MB or smaller.
In Quarkus, this application will start up and be ready to accept requests within a fraction of a second, and it will use less than 50 MB of memory.</p>

<p>When deploying to a Kubernetes cluster, you want to pack in as many instances of your application as possible so you are able to scale to meet unexpected load yet still utilize as many of the resources as possible.
When scaling up you want your new application instances up and running quickly—this is where a native executable shines.
Quarkus does as much pre-boot of your application and the frameworks it uses as possible during the native executable build process.
This helps your application start quickly and be ready to service requests without having to do additional class loading, runtime scanning, or other warm-up the the JVM typically does.</p>

<p>Naturally, available memory is a finite resource.
Understanding exactly how much memory is being used by your application, and not starving the JVM while trying to keep that number low, is key to deployment density.
Quarkus succeeds in helping you achieve that with the native executable, which is small and memory efficient.</p>
</div></section>













<section data-type="sect1" class="orm:non-recipe" data-pdf-bookmark="A Basic Quarkus Workflow"><div class="sect1" id="idm45128543762424">
<h1>A Basic Quarkus Workflow</h1>

<p><a data-type="indexterm" data-primary="Quarkus" data-secondary="basic workflow" id="idm45128543760808"/>While reading this book and going through the recipes, you’ll be introduced to the Quarkus ecosystem.
You’ll learn about extensions, integrations, and design decisions.
You will also see the basic workflow used throughout to help you be productive.
<a data-type="indexterm" data-primary="scaffolding" data-secondary="in basic workflow" id="idm45128543759432"/><a data-type="indexterm" data-primary="launch dev mode, in basic workflow" id="idm45128543758488"/><a data-type="indexterm" data-primary="test, in basic workflow" id="idm45128543757752"/><a data-type="indexterm" data-primary="package, in basic workflow" id="idm45128543757080"/><a data-type="indexterm" data-primary="deploying" data-secondary="in basic workflow" id="idm45128543756392"/>In a nutshell, this workflow is as follows:</p>
<ol>
<li>
<p>Scaffold</p>
</li>
<li>
<p>Launch dev mode</p>
</li>
<li>
<p>Code</p>
</li>
<li>
<p>Test</p>
</li>
<li>
<p>Package</p>
</li>
<li>
<p>Deploy</p>
</li>

</ol>

<p>Scaffolding your application, or adding an extension to an existing start, gives you a solid foundation to build upon.
You’ll become familiar with this in <a data-type="xref" href="ch02.xhtml#scaffolding_chapter">Chapter 2</a>.
Following scaffolding, you will be asked to run your application in dev mode, which is also introduced in <a data-type="xref" href="ch02.xhtml#scaffolding_chapter">Chapter 2</a>.
You will then learn about typical tasks for an application: creating RESTful services, completing the basic programming model, and performing application configuration.
Dev mode will give you near instant feedback without the bothersome dance of compile, package, and deploy that you’ve become familiar with.
In <a data-type="xref" href="ch05.xhtml#programming_model">Chapter 5</a> you’ll see how to test a Quarkus application that targets both the JVM and native executable, giving you reassurance that your application runs correctly and meets your standards.
Creating the final deliverable is covered in <a data-type="xref" href="ch06.xhtml#packaging_quark_applications_chapter">Chapter 6</a>, as is learning how to package your application for your particular deployment strategy.
The last piece of that workflow, deployment, is covered in <a data-type="xref" href="ch10.xhtml#integrating_with_kubernetes_chapter">Chapter 10</a>.
Exploring further, you’ll learn how to make your application more fault resistant, how to interact with various persistence engines, and how to communicate with external services.

<span class="keep-together">We will</span> also explain additional integrations to aid you in leveraging existing knowledge from other libraries and programming paradigms.
We’ll walk you through setting 
<span class="keep-together">up the</span> Kubernetes optimizations that are necessary for your application, building 
<span class="keep-together">Kubernetes</span> resources, and pushing it all live.</p>
</div></section>







</div></section></div>



  </body></html>