<html><head></head><body>
<div id="sbo-rt-content"><section data-nutshell-tab="OO Programming" data-pdf-bookmark="Chapter 3. Object-Oriented Programming in Java" data-type="chapter" epub:type="chapter"><div class="chapter" id="javanut8-CHP-3">
<h1><span class="label">Chapter 3. </span>Object-Oriented Programming <span class="keep-together">in Java</span></h1>
<p><a data-primary="object-oriented programming" data-type="indexterm" id="ix_ch03-asciidoc0"/>Now that we’ve covered fundamental Java syntax, we are ready to begin object-oriented programming in Java. All Java programs use objects, and the type of an object is defined by its <em>class</em> or <em>interface</em>. Every Java program is defined as a class, and nontrivial programs include a number of classes and interface definitions.</p>
<p>This chapter explains how to define new classes (and records) and how to do object-oriented programming with them.
We also introduce the concept of an interface, but a full discussion of interfaces and Java’s type system is deferred until <a data-type="xref" href="ch04.xhtml#javanut8-CHP-4">Chapter 4</a>.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>If you have experience with OO programming, however, be careful. The term “object-oriented” has different meanings in different languages. Don’t assume that Java works the same way as your favorite OO language. (This is particularly true for JavaScript or Python programmers.)</p>
</div>
<p>This is a fairly lengthy chapter, so let’s begin with an overview and some definitions.</p>
<section data-pdf-bookmark="Overview of Classes and Records" data-type="sect1"><div class="sect1" id="javanut8-CHP-3-SECT-1">
<h1>Overview of Classes and Records</h1>
<p><a data-primary="class(es)" data-secondary="in object-oriented programming" data-secondary-sortas="object-oriented programming" data-type="indexterm" id="ix_ch03-asciidoc1"/><a data-primary="object-oriented programming" data-secondary="classes" data-type="indexterm" id="ix_ch03-asciidoc2"/>Classes are the most fundamental structural element of all Java programs. You cannot write Java code without defining a class. All Java statements appear within classes, and all methods are implemented within classes.</p>
<section class="pagebreak-before" data-pdf-bookmark="Basic OO Definitions" data-type="sect2"><div class="sect2" id="idm45927749364096">
<h2>Basic OO Definitions</h2>
<p><a data-primary="class(es)" data-secondary="basic object-oriented definitions" data-type="indexterm" id="ix_ch03-asciidoc3"/>Here are some important definitions:</p>
<dl>
<dt>Class</dt>
<dd>
<p><a data-primary="class(es)" data-secondary="defined" data-type="indexterm" id="idm45927749359856"/>A <em>class</em> is a collection of data fields that hold values, along with methods that operate on those values. <a data-primary="Account class" data-type="indexterm" id="idm45927749358224"/>A class defines a new reference type, such as the <code>Account</code> type defined in <a data-type="xref" href="ch02.xhtml#javanut8-CHP-2">Chapter 2</a>.</p>
<p>The <code>Account</code> class defines a type that represents customer accounts within a banking system.</p>
</dd>
</dl>
<p>From Java 17 onwards, the language also includes support for records—which are a special kind of class that have additional semantics.</p>
<dl>
<dt>Object</dt>
<dd>
<p><a data-primary="objects" data-secondary="defined" data-type="indexterm" id="idm45927749353072"/>An <em>object</em> is an <em>instance</em> of a class.</p>
<p>An <code>Account</code> object is a value of that type: it represents a specific customer bank account.</p>
</dd>
</dl>
<p>Objects are often created by <em>instantiating</em> a class with the <code>new</code> keyword and a constructor invocation, as shown here:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">Account</code><code class="w"> </code><code class="n">a</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">Account</code><code class="p">(</code><code class="s">"John Smith"</code><code class="p">,</code><code class="w"> </code><code class="mi">100</code><code class="p">,</code><code class="w"> </code><code class="mi">1144789</code><code class="p">);</code><code class="w"/></pre>
<p>Constructors are covered in detail later in this chapter in <a data-type="xref" href="#javanut8-CHP-3-SECT-3">“Creating and Initializing Objects”</a>.</p>
<p><a data-primary="signature" data-secondary="in class definition" data-secondary-sortas="class definition" data-type="indexterm" id="idm45927749328864"/>A class definition consists of a <em>signature</em> and a <em>body</em>. The class signature defines the name of the class and may also specify other
important information. <a data-primary="{ } (curly braces)" data-secondary="members of a class in" data-type="indexterm" id="idm45927749326352"/><a data-primary="body" data-secondary="in class definition" data-secondary-sortas="in class definition" data-type="indexterm" id="idm45927749322480"/><a data-primary="members of a class" data-type="indexterm" id="idm45927749321264"/>The body of a class is a set of <em>members</em> enclosed in curly braces. The members of a class usually include fields  and methods, and may also include constructors, initializers, and nested types.</p>
<p><a data-primary="nonstatic members" data-type="indexterm" id="idm45927749319792"/><a data-primary="static members" data-type="indexterm" id="idm45927749319088"/>Members can be <em>static</em> or nonstatic. A static member belongs to the class itself, while a nonstatic member is associated with the instances of a class (see <a data-type="xref" href="#javanut8-CHP-3-SECT-2">“Fields and Methods”</a>).</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>There are four very common kinds of members—class fields, class
methods, instance fields, and instance methods. The majority of work
done with Java involves interacting with these kinds of members.</p>
</div>
<p>The signature of a class may declare that the class <em>extends</em> another
class. <a data-primary="superclasses" data-secondary="defined" data-type="indexterm" id="idm45927749314848"/>The extended class is known as the <em>superclass</em> and the extension
is known as the <em>subclass</em>. <a data-primary="subclasses" data-secondary="defined" data-type="indexterm" id="idm45927749312912"/>A subclass <em>inherits</em> the members of its
superclass and may declare new members or <em>override</em> inherited methods
with new implementations.</p>
<p><a data-primary="access modifiers" data-type="indexterm" id="idm45927749310784"/>The members of a class may have <em>access modifiers</em> <code>public</code>,
<code>protected</code>, or <code>private</code>.<sup><a data-type="noteref" href="ch03.xhtml#idm45927749308000" id="idm45927749308000-marker">1</a></sup> These modifiers specify their
visibility and accessibility to clients and to subclasses. This allows
classes to control access to members that are not part of their public
API. <a data-primary="encapsulation" data-type="indexterm" id="idm45927749307280"/>This ability to hide members enables an object-oriented design
technique known as <em>data encapsulation</em>, which we discuss in
<a data-type="xref" href="#javanut8-CHP-3-SECT-5">“Data Hiding and Encapsulation”</a>.<a data-startref="ix_ch03-asciidoc3" data-type="indexterm" id="idm45927749284480"/></p>
</div></section>
<section data-pdf-bookmark="Records" data-type="sect2"><div class="sect2" id="idm45927749363504">
<h2>Records</h2>
<p><a data-primary="records" data-type="indexterm" id="idm45927749282496"/>A <em>record</em> (or <em>record class</em>) is a special form of class that provides additional semantic guarantees that general classes do not.</p>
<p>Specifically, a record guarantees that the instance fields precisely define the only meaningful state of an object of that type. This can be expressed as the principle (or <em>pattern</em>) that the record class is a <em>data carrier</em> or “just holds fields.” Agreeing to this principle imposes constraints on programmers, but it also frees them from needing to be explicit about some design details.</p>
<p>A record class is defined like this:</p>
<pre data-code-language="java" data-type="programlisting"><code class="cm">/** Represents a point in 2-dimensional space */</code><code class="w"/>
<code class="kd">public</code><code class="w"> </code><code class="kd">record</code> <code class="nc">Point</code><code class="p">(</code><code class="kt">double</code><code class="w"> </code><code class="n">x</code><code class="p">,</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="n">y</code><code class="p">)</code><code class="w"> </code><code class="p">{}</code><code class="w"/></pre>
<p>There is no need to explicitly declare a constructor, or accessor methods for the fields—for a record class the compiler automatically generates these members and adds them to the class definition.
The accessor methods are named exactly the same as the underlying fields they provide access to.
It is possible to add additional methods to a record, but it is not necessary to do so if all that is needed is the basic data carrier form.</p>
<p>Instances of record classes (or just records) are created and instantiated in the same way as for regular classes, and we can call the accessors on the objects we create:</p>
<pre data-code-language="java" data-type="programlisting"><code class="c1">// Create a Point object representing (2,-3.5).</code><code class="w"/>
<code class="c1">// Declare a variable p and store a reference to the new Point object</code><code class="w"/>
<code class="n">Point</code><code class="w"> </code><code class="n">p</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">Point</code><code class="p">(</code><code class="mf">2.0</code><code class="p">,</code><code class="w"> </code><code class="o">-</code><code class="mf">3.5</code><code class="p">);</code><code class="w"/>
<code class="kt">double</code><code class="w"> </code><code class="n">x</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">p</code><code class="p">.</code><code class="na">x</code><code class="p">();</code><code class="w">                    </code><code class="c1">// Read a field of the object</code><code class="w"/></pre>
<p>One other aspect of records is that they are always immutable. Once created, the value of a record’s fields cannot be altered. This means that there is no need for setter methods for the fields, as they cannot be modified.</p>
<p>The contract that Java records have is that the parameter name (as specified in the record declaration), the field name, and the method name are all identical: if there’s a record parameter <code>x</code> of type <code>double</code> then the class has a field called <code>x</code> of type <code>double</code> and an instance method called <code>x()</code> that returns <code>double</code>.</p>
<p>Records have certain other methods that are also automatically generated by the compiler. We will have more to say about them in <a data-type="xref" href="ch05.xhtml#javanut8-CHP-5">Chapter 5</a> when we discuss how to use records as part of object-oriented design.</p>
</div></section>
<section data-pdf-bookmark="Other Reference Types" data-type="sect2"><div class="sect2" id="idm45927749283408">
<h2>Other Reference Types</h2>
<p>The signature of a class may also declare that the class <em>implements</em>
one or more interfaces. <a data-primary="interfaces" data-secondary="definition of term" data-type="indexterm" id="idm45927749205360"/>An <em>interface</em> is a reference type similar to
a class that defines method signatures but does not usually include
method bodies to implement the methods.</p>
<p><a data-primary="default keyword" data-type="indexterm" id="idm45927749203152"/>However, from Java 8 onward, interfaces may use the keyword <code>default</code> to
indicate that a method specified in the interface is optional. If a
method is optional, the interface file must include a default
implementation (hence the choice of keyword), which will be used by all
implementing classes that do not provide an implementation of the
optional method.</p>
<p>A class that implements an interface is required to provide bodies for
the interface’s nondefault methods. Instances of a class that implement
an interface are also instances of the interface type.</p>
<p>Classes and interfaces are the most important of the five fundamental
reference types defined by Java. Arrays, enumerated types (or
“enums”), and annotation types (usually just called “annotations”) are
the other three. Arrays are covered in <a data-type="xref" href="ch02.xhtml#javanut8-CHP-2">Chapter 2</a>.
Enums are a specialized kind of class, and annotations are a specialized
kind of interface—both are discussed later in
<a data-type="xref" href="ch04.xhtml#javanut8-CHP-4">Chapter 4</a>, along with a full discussion of
interfaces.</p>
</div></section>
<section data-pdf-bookmark="Class Definition Syntax" data-type="sect2"><div class="sect2" id="idm45927749199344">
<h2>Class Definition Syntax</h2>
<p><a data-primary="class keyword" data-type="indexterm" id="idm45927749198096"/><a data-primary="class(es)" data-secondary="definition syntax" data-type="indexterm" id="idm45927749197200"/>At its simplest level, a class definition consists of the keyword
<code>class</code> followed by the name of the class and a set of class members
within curly braces. The <code>class</code> keyword may be preceded by modifier
keywords and annotations. If the class extends another class, the class
name is followed by the <code>extends</code> keyword and the name of the class
being extended. If the class implements one or more interfaces, then the
class name or the <code>extends</code> clause is followed by the <code>implements</code>
keyword and a comma-separated list of interface names. For example, for the <code>Integer</code> class in <code>java.lang</code></p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code><code class="w"> </code><code class="kd">class</code> <code class="nc">Integer</code><code class="w"> </code><code class="kd">extends</code><code class="w"> </code><code class="n">Number</code><code class="w"/>
<code class="w">                     </code><code class="kd">implements</code><code class="w"> </code><code class="n">Serializable</code><code class="p">,</code><code class="w"> </code><code class="n">Comparable</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="c1">// class members go here</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>Java also includes the ability to declare <em>generic classes</em> that allow an entire family of types to be created from a single class declaration.
We will meet this feature, along with its supporting mechanisms (such as <em>type parameters</em> and <em>wildcards</em>), in <a data-type="xref" href="ch04.xhtml#javanut8-CHP-4">Chapter 4</a>.</p>
<p class="pagebreak-before">Class declarations may include modifier keywords. In addition to the access control modifiers (<code>public</code>, <code>protected</code>, etc.), these include:</p>
<dl>
<dt><code>abstract</code></dt>
<dd>
<p><a data-primary="abstract classes" data-secondary="defined" data-type="indexterm" id="idm45927749125952"/>An <code>abstract</code> class is one whose implementation is incomplete and cannot be instantiated. Any class with one or more <code>abstract</code> methods must be declared <code>abstract</code>. Abstract classes are discussed in <a data-type="xref" href="#javanut8-CHP-3-SECT-6">“Abstract Classes and Methods”</a>.</p>
</dd>
<dt><code>final</code></dt>
<dd>
<p><a data-primary="final classes" data-type="indexterm" id="idm45927749121328"/>The <code>final</code> modifier specifies that the class may not be extended. A class cannot be declared to be both <code>abstract</code> and <code>final</code>.</p>
</dd>
<dt><code>sealed</code></dt>
<dd>
<p><a data-primary="sealed classes" data-type="indexterm" id="idm45927749096448"/>Sealed classes are those that may be extended only by a known set of subclasses. Sealed classes provide a halfway house between <code>final</code> classes and the default, open for extension classes. The use of sealed classes is discussed in more detail in <a data-type="xref" href="ch05.xhtml#javanut8-CHP-5">Chapter 5</a>. Sealed classes are available only in Java 17 and above.</p>
</dd>
<dt><code>strictfp</code></dt>
<dd>
<p><a data-primary="strictfp modifier" data-type="indexterm" id="idm45927749092992"/>A class can be declared <code>strictfp</code>; all its methods behave as if they were declared <code>strictfp</code>, and thus exactly follow the formal semantics of the floating-point standard. This modifier is <em>extremely</em> rarely used, and is in fact a no-op in Java 17, for the reasons discussed in <a data-type="xref" href="ch02.xhtml#javanut8-CHP-2">Chapter 2</a>.<a data-startref="ix_ch03-asciidoc2" data-type="indexterm" id="idm45927749089776"/><a data-startref="ix_ch03-asciidoc1" data-type="indexterm" id="idm45927749089072"/></p>
</dd>
</dl>
</div></section>
</div></section>
<section data-pdf-bookmark="Fields and Methods" data-type="sect1"><div class="sect1" id="javanut8-CHP-3-SECT-2">
<h1>Fields and Methods</h1>
<p><a data-primary="class(es)" data-secondary="fields and methods" data-type="indexterm" id="ix_ch03-asciidoc4"/><a data-primary="fields" data-type="indexterm" id="ix_ch03-asciidoc5"/><a data-primary="object-oriented programming" data-secondary="fields and methods" data-type="indexterm" id="ix_ch03-asciidoc6"/>A class can be viewed as a collection of data (also referred to as <em>state</em>) and code to operate on that state. The data is stored in fields, and the code is organized into methods.</p>
<p>This section covers fields and methods, the two most important kinds of
class members. Fields and methods come in two distinct types: class
members (also known as static members) are associated with the class
itself, while instance members are associated with individual instances
of the class (i.e., with objects). This gives us four kinds of members:</p>
<ul>
<li>
<p>Class fields</p>
</li>
<li>
<p>Class methods</p>
</li>
<li>
<p>Instance fields</p>
</li>
<li>
<p>Instance methods</p>
</li>
</ul>
<p>The simple class definition for the class <code>Circle</code>, shown in
<a data-type="xref" href="#javanut8-CHP-3-EX-1">Example 3-1</a>, contains all four types of
members.</p>
<div data-type="example" id="javanut8-CHP-3-EX-1">
<h5><span class="label">Example 3-1. </span>A simple class and its members</h5>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code><code class="w"> </code><code class="kd">class</code> <code class="nc">Circle</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="c1">// A class field</code><code class="w"/>
<code class="w">  </code><code class="kd">public</code><code class="w"> </code><code class="kd">static</code><code class="w"> </code><code class="kd">final</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="n">PI</code><code class="o">=</code><code class="w"> </code><code class="mf">3.14159</code><code class="p">;</code><code class="w">     </code><code class="c1">// A useful constant</code><code class="w"/>

<code class="w">  </code><code class="c1">// A class method: just compute a value based on the arguments</code><code class="w"/>
<code class="w">  </code><code class="kd">public</code><code class="w"> </code><code class="kd">static</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="nf">radiansToDegrees</code><code class="p">(</code><code class="kt">double</code><code class="w"> </code><code class="n">radians</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="n">radians</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="mi">180</code><code class="w"> </code><code class="o">/</code><code class="w"> </code><code class="n">PI</code><code class="p">;</code><code class="w"/>
<code class="w">  </code><code class="p">}</code><code class="w"/>

<code class="w">  </code><code class="c1">// An instance field</code><code class="w"/>
<code class="w">  </code><code class="kd">public</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="n">r</code><code class="p">;</code><code class="w">                  </code><code class="c1">// The radius of the circle</code><code class="w"/>

<code class="w">  </code><code class="c1">// Two instance methods: operate on an object's instance fields</code><code class="w"/>

<code class="w">  </code><code class="c1">// Compute the area of the circle</code><code class="w"/>
<code class="w">  </code><code class="kd">public</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="nf">area</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="n">PI</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="n">r</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="n">r</code><code class="p">;</code><code class="w"/>
<code class="w">  </code><code class="p">}</code><code class="w"/>

<code class="w">  </code><code class="c1">// Compute the circumference of the circle</code><code class="w"/>
<code class="w">  </code><code class="kd">public</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="nf">circumference</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="mi">2</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="n">PI</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="n">r</code><code class="p">;</code><code class="w"/>
<code class="w">  </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre></div>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>It is not good practice to have a public instance field such as <code>r</code> in our example.
It would be much better to have a private field <code>r</code> and a method <code>radius()</code> (or <code>r()</code>) to provide access to it.
The reason for this will be explained later, in <a data-type="xref" href="#javanut8-CHP-3-SECT-5">“Data Hiding and Encapsulation”</a>.
For now, we use a public field simply to give examples of how to work with instance fields.</p>
</div>
<p>The following sections explain all four common kinds of members. First,
we cover the declaration syntax for fields. (The syntax for declaring
methods is covered later in this chapter in
<a data-type="xref" href="#javanut8-CHP-3-SECT-5">“Data Hiding and Encapsulation”</a>.)</p>
<section data-pdf-bookmark="Field Declaration Syntax" data-type="sect2"><div class="sect2" id="javanut8-CHP-3-SECT-2.1">
<h2>Field Declaration Syntax</h2>
<p><a data-primary="fields" data-secondary="declaration syntax" data-type="indexterm" id="idm45927748986752"/><a data-primary="syntax, Java" data-secondary="field declaration syntax" data-type="indexterm" id="idm45927748985776"/>Field declaration syntax is much like the syntax for declaring local
variables (see <a data-type="xref" href="ch02.xhtml#javanut8-CHP-2">Chapter 2</a>) except that field
definitions may also include modifiers. The simplest field declaration
consists of the field type followed by the field name.</p>
<p>The type may be
preceded by zero or more modifier keywords or annotations, 
<span class="keep-together">and the</span> name
may be followed by an equals sign and initializer expression that
provides the initial value of the field. If two or more fields share the
same type and modifiers, the type may be followed by a comma-separated
list of field names and initializers. Here are some valid field
declarations:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kt">int</code><code class="w"> </code><code class="n">x</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">1</code><code class="p">;</code><code class="w"/>
<code class="kd">private</code><code class="w"> </code><code class="n">String</code><code class="w"> </code><code class="n">name</code><code class="p">;</code><code class="w"/>
<code class="kd">public</code><code class="w"> </code><code class="kd">static</code><code class="w"> </code><code class="kd">final</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="n">DAYS_PER_WEEK</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">7</code><code class="p">;</code><code class="w"/>
<code class="n">String</code><code class="o">[]</code><code class="w"> </code><code class="n">daynames</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">String</code><code class="o">[</code><code class="n">DAYS_PER_WEEK</code><code class="o">]</code><code class="p">;</code><code class="w"/>
<code class="kd">private</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="n">a</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">17</code><code class="p">,</code><code class="w"> </code><code class="n">b</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">37</code><code class="p">,</code><code class="w"> </code><code class="n">c</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">53</code><code class="p">;</code><code class="w"/></pre>
<p><a data-primary="fields" data-secondary="modifiers" data-type="indexterm" id="idm45927748864992"/>Field modifier keywords comprise zero or more of the following
keywords:</p>
<dl>
<dt><code>public</code>, <code>protected</code>, <code>private</code></dt>
<dd>
<p><a data-primary="private modifier" data-type="indexterm" id="idm45927748834512"/><a data-primary="protected modifier" data-type="indexterm" id="idm45927748833808"/><a data-primary="public modifier" data-type="indexterm" id="idm45927748833136"/>These access modifiers specify whether and where a field can be used outside of the class that defines it.</p>
</dd>
<dt><code>static</code></dt>
<dd>
<p><a data-primary="static modifier" data-type="indexterm" id="idm45927748830928"/>If present, this modifier specifies that the field is associated with the defining class itself rather than with each instance of the class.</p>
</dd>
<dt><code>final</code></dt>
<dd>
<p><a data-primary="final modifier" data-type="indexterm" id="idm45927748828656"/>This modifier specifies that once the field has been initialized, its value may never be changed. Fields that are both <code>static</code> and <code>final</code> are compile-time constants that <code>javac</code> may inline. <code>final</code> fields can also be used to create classes whose instances are immutable.</p>
</dd>
<dt><code>transient</code></dt>
<dd>
<p><a data-primary="transient modifier" data-type="indexterm" id="idm45927748763344"/>This modifier specifies that a field is not part of the persistent state of an object and that it need not be serialized along with the rest of the object. This modifier is very rarely seen.</p>
</dd>
<dt><code>volatile</code></dt>
<dd>
<p><a data-primary="volatile keyword" data-type="indexterm" id="idm45927748761328"/>This modifier indicates that the field has extra semantics for concurrent use by two or more threads. The <code>volatile</code> modifier says that the value of a field must always be read from and flushed to main memory, and that it may not be cached by a thread (in a register or CPU cache). See <a data-type="xref" href="ch06.xhtml#javanut8-CHP-6">Chapter 6</a> for more details.</p>
</dd>
</dl>
</div></section>
<section data-pdf-bookmark="Class Fields" data-type="sect2"><div class="sect2" id="idm45927748836512">
<h2>Class Fields</h2>
<p><a data-primary="class field" data-type="indexterm" id="idm45927748757712"/><a data-primary="fields" data-secondary="class" data-type="indexterm" id="idm45927748757008"/>A <em>class field</em> is associated with the class in which it is defined
rather than with an instance of the class. The following line declares a class field:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code><code class="w"> </code><code class="kd">static</code><code class="w"> </code><code class="kd">final</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="n">PI</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mf">3.14159</code><code class="p">;</code><code class="w"/></pre>
<p>This line declares a field of type <code>double</code> named <code>PI</code> and assigns it a value of <code>3.14159</code>.</p>
<p>The <code>static</code> modifier says that the field is a class field. Class
fields are sometimes called static fields because of this <code>static</code>
modifier. The <code>final</code> modifier says that the value of the field cannot be reassigned directly. Because the field <code>PI</code> represents a constant, we declare it <code>final</code> so that it cannot be changed.</p>
<p>It is a convention in Java (and many other languages) that constants are named with capital letters, which is why our field is named <code>PI</code>, not <code>pi</code>. Defining constants like this is a common use for class fields, meaning that the <code>static</code> and <code>final</code> modifiers are often used together. Not all class fields are constants, however. In other words, a field can be declared <code>static</code> without being declared <code>final</code>.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The use of public fields that are not <code>final</code> is a code smell—as multiple threads could update the field and cause behavior that is extremely hard to debug. Beginning Java programmers should not use public fields that are not final.</p>
</div>
<p>A public static field is essentially a global variable. The names of
class fields are qualified by the unique names of the classes that
contain them, however. Thus, Java does not suffer from the name
collisions that can affect other languages when different modules of
code define global variables with the same name.</p>
<p>The key point to understand about a static field is that there is only a
single copy of it. This field is associated with the class itself, not
with instances of the class. If you look at the various methods of the
<code>Circle</code> class, you’ll see that they use this field. From inside the
<code>Circle</code> class, the field can be referred to simply as <code>PI</code>. Outside the
class, however, both class and field names are required to uniquely
specify the field. Methods that are not part of <code>Circle</code> access this
field as <code>Circle.PI</code>.</p>
</div></section>
<section data-pdf-bookmark="Class Methods" data-type="sect2"><div class="sect2" id="idm45927748706736">
<h2>Class Methods</h2>
<p><a data-primary="class methods" data-type="indexterm" id="idm45927748705168"/><a data-primary="methods" data-secondary="class" data-type="indexterm" id="idm45927748704528"/>As with class fields, <em>class methods</em> are declared with the <code>static</code> modifier. They are also known as <em>static methods</em>:</p>
<pre class="pre" data-code-language="java" data-type="programlisting"><code class="kd">public</code><code class="w"> </code><code class="kd">static</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="nf">radiansToDegrees</code><code class="p">(</code><code class="kt">double</code><code class="w"> </code><code class="n">rads</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="n">rads</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="mi">180</code><code class="w"> </code><code class="o">/</code><code class="w"> </code><code class="n">PI</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>This line declares a class method named <code>radiansToDegrees()</code>. It has a single parameter of type <code>double</code> and returns a <code>double</code> value.</p>
<p>Like class fields, class methods are associated with a class, rather
than with an object. When invoking a class method from code that exists
outside the class, you must specify both the name of the class and the
method. For example:</p>
<pre data-code-language="java" data-type="programlisting"><code class="c1">// How many degrees is 2.0 radians?</code><code class="w"/>
<code class="kt">double</code><code class="w"> </code><code class="n">d</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Circle</code><code class="p">.</code><code class="na">radiansToDegrees</code><code class="p">(</code><code class="mf">2.0</code><code class="p">);</code><code class="w"/></pre>
<p>If you want to invoke a class method from inside the class in which it
is defined, you don’t have to specify the class name. You can also
shorten the amount of typing required via the use of a static import (as
discussed in <a data-type="xref" href="ch02.xhtml#javanut8-CHP-2">Chapter 2</a>).</p>
<p>Note that the body of our <code>Circle.radiansToDegrees()</code> method uses the
class field <code>PI</code>. A class method can use any class fields and class
methods of its own class (or of any other class that is visible to it).</p>
<p>A class method cannot use any instance fields or instance methods
because class methods are not associated with an instance of the class.
In other words, although the <code>radiansToDegrees()</code> method is defined in
the <code>Circle</code> class, it cannot use the instance part of any <code>Circle</code>
objects.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>One way to think about this is that in any instance, we always have a reference—<code>this</code>—to the current object. The <code>this</code> reference is passed as an implicit parameter to any instance method. However, class methods are not associated with a specific instance, so they have no <code>this</code> reference and no access to instance fields.</p>
</div>
<p>As we discussed earlier, a class field is essentially a global variable.
In a similar way, a class method is a global method, or global
function. Although <code>radiansToDegrees()</code> does not operate on <code>Circle</code>
objects, it is defined within the <code>Circle</code> class because it is a utility
method that is sometimes useful when you’re working with circles, and so it
makes sense to package it along with the other functionality of the
<code>Circle</code> class.</p>
</div></section>
<section data-pdf-bookmark="Instance Fields" data-type="sect2"><div class="sect2" id="idm45927748706112">
<h2>Instance Fields</h2>
<p><a data-primary="fields" data-secondary="instance" data-type="indexterm" id="idm45927748614656"/><a data-primary="instance fields" data-type="indexterm" id="idm45927748613680"/>Any field declared without the <code>static</code> modifier is an <em>instance
field</em>:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="n">r</code><code class="p">;</code><code class="w">    </code><code class="c1">// The radius of the circle</code><code class="w"/></pre>
<p>Instance fields are associated with instances of the class, so every
<code>Circle</code> object we create has its own copy of the <code>double</code> field <code>r</code>. In
our example, <code>r</code> represents the radius of a specific circle. Each
<code>Circle</code> object can have a radius independent of all other <code>Circle</code>
objects.</p>
<p>Inside a class definition, instance fields are referred to by name
alone. You can see an example of this if you look at the method body of
the <code>circumference()</code> instance method. In code outside the class, the
name of an instance method must be prefixed with a reference to the
object that contains it. For example, if the variable <code>c</code> holds a
reference to a <code>Circle</code> object, we use the expression <code>c.r</code> to refer to
the radius of that circle:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">Circle</code><code class="w"> </code><code class="n">c</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">Circle</code><code class="p">();</code><code class="w"> </code><code class="c1">// Create a Circle object; store a ref in c</code><code class="w"/>
<code class="n">c</code><code class="p">.</code><code class="na">r</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mf">2.0</code><code class="p">;</code><code class="w">               </code><code class="c1">// Assign a value to its instance field r</code><code class="w"/>
<code class="n">Circle</code><code class="w"> </code><code class="n">d</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">Circle</code><code class="p">();</code><code class="w"> </code><code class="c1">// Create a different Circle object</code><code class="w"/>
<code class="n">d</code><code class="p">.</code><code class="na">r</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">c</code><code class="p">.</code><code class="na">r</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="mi">2</code><code class="p">;</code><code class="w">           </code><code class="c1">// Make this one twice as big</code><code class="w"/></pre>
<p>Instance fields are key to object-oriented programming. Instance fields
hold the state of an object; the values of those fields make one object
distinct from another.</p>
</div></section>
<section data-pdf-bookmark="Instance Methods" data-type="sect2"><div class="sect2" id="idm45927748472608">
<h2>Instance Methods</h2>
<p><a data-primary="instance methods" data-type="indexterm" id="idm45927748481088"/><a data-primary="methods" data-secondary="instance" data-type="indexterm" id="idm45927748480384"/>An <em>instance</em> <em>method</em> operates on a specific instance of a class (an
object), and any method not declared with the <code>static</code> keyword is
automatically an instance method.</p>
<p>Instance methods are the feature that makes object-oriented programming
start to get interesting. The <code>Circle</code> class defined in
<a data-type="xref" href="#javanut8-CHP-3-EX-1">Example 3-1</a> contains two instance methods,
<code>area()</code> and <code>circumference()</code>, that compute and return the area and
circumference of the circle represented by a given <code>Circle</code> object.</p>
<p>To use an instance method from outside the class in which it is defined,
we must prefix it with a reference to the instance that is to be
operated on. For example:</p>
<pre data-code-language="java" data-type="programlisting"><code class="c1">// Create a Circle object; store in variable c</code><code class="w"/>
<code class="n">Circle</code><code class="w"> </code><code class="n">c</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">Circle</code><code class="p">();</code><code class="w"/>
<code class="n">c</code><code class="p">.</code><code class="na">r</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mf">2.0</code><code class="p">;</code><code class="w">                 </code><code class="c1">// Set an instance field of the object</code><code class="w"/>
<code class="kt">double</code><code class="w"> </code><code class="n">a</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">c</code><code class="p">.</code><code class="na">area</code><code class="p">();</code><code class="w">       </code><code class="c1">// Invoke an instance method of the object</code><code class="w"/></pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>This is why it is called object-oriented programming; the object is the focus here, not the method call.</p>
</div>
<p>From within an instance method, we naturally have access to all the
instance fields that belong to the object the method was called on.
Recall that an object is often best considered to be a bundle containing
state (represented as the fields of the object), and behavior (the
methods to act on that state).</p>
<p>All instance methods are implemented by using an implicit parameter not shown in the method signature.
<a data-primary="methods" data-secondary="this reference" data-type="indexterm" id="idm45927748400192"/><a data-primary="this keyword" data-type="indexterm" id="idm45927748399216"/>The implicit argument is named <code>this</code>; it holds a reference to the object through which the method is invoked.
In our example, that object is a <code>Circle</code>.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The bodies of the <code>area()</code> and <code>circumference()</code> methods both use the
class field <code>PI</code>. We saw earlier that class methods can use only class
fields and class methods, not instance fields or methods. Instance
methods are not restricted in this way: they can use any member of a
class, whether it is declared <code>static</code> or not.</p>
</div>
</div></section>
<section data-pdf-bookmark="How the this Reference Works" data-type="sect2"><div class="sect2" id="idm45927748437488">
<h2>How the this Reference Works</h2>
<p>The implicit <code>this</code> parameter is not shown in method signatures
because it is usually not needed; whenever a Java method accesses the
instance fields in its class, it is implicit that it is accessing fields
in the object referred to by the <code>this</code> parameter. The same is true when
an instance method invokes another instance method in the same
class—it’s taken that this means “call the instance method on the
current object.”</p>
<p>However, you can use the <code>this</code> keyword explicitly when you want to make
it clear that a method is accessing its own fields and/or methods. For
example, we can rewrite the <code>area()</code> method to use <code>this</code> explicitly to
refer to instance fields:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="nf">area</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="n">Circle</code><code class="p">.</code><code class="na">PI</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="k">this</code><code class="p">.</code><code class="na">r</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="k">this</code><code class="p">.</code><code class="na">r</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w"/></pre>
<p>This code also uses the class name explicitly to refer to class field
<code>PI</code>. In a method this simple, it is not normally necessary to be quite
so explicit. In more complicated cases, however, you may sometimes find
that it increases the clarity of your code to use an explicit <code>this</code>
even when it is not strictly required.</p>
<p>In some cases, the <code>this</code> keyword <em>is</em> required, however.
For example, when a method parameter or local variable in a method has the same name as one of the fields of the class, you must use <code>this</code> to refer to the field.
This is because the field name used alone refers to the method parameter or local variable, as discussed in <a data-type="xref" href="ch04.xhtml#javanut8-CHP-4-SECT-4.4">“Lexical Scoping and Local Variables”</a>.</p>
<p>For example, we can add the following method to the <code>Circle</code> class:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">setRadius</code><code class="p">(</code><code class="kt">double</code><code class="w"> </code><code class="n">r</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="k">this</code><code class="p">.</code><code class="na">r</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">r</code><code class="p">;</code><code class="w">      </code><code class="c1">// Assign the argument (r) to the field (this.r)</code><code class="w"/>
<code class="w">                   </code><code class="c1">// Note that writing r = r is a bug</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>Some developers will deliberately choose the names of their method arguments in such a way that they don’t clash with field names, so the use of <code>this</code> can largely be avoided.
However, accessor methods (setter) generated by any of the major Java IDEs will use the <code>this.x = x</code> style shown here.</p>
<p>Finally, note that while instance methods can use the <code>this</code> keyword,
class methods cannot because class methods are not associated
with individual objects.<a data-startref="ix_ch03-asciidoc6" data-type="indexterm" id="idm45927748306240"/><a data-startref="ix_ch03-asciidoc5" data-type="indexterm" id="idm45927748305536"/><a data-startref="ix_ch03-asciidoc4" data-type="indexterm" id="idm45927748304864"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Creating and Initializing Objects" data-type="sect1"><div class="sect1" id="javanut8-CHP-3-SECT-3">
<h1>Creating and Initializing Objects</h1>
<p><a data-primary="object-oriented programming" data-secondary="creating/initializing objects" data-type="indexterm" id="ix_ch03-asciidoc7"/><a data-primary="objects" data-secondary="creating" data-type="indexterm" id="ix_ch03-asciidoc8"/><a data-primary="objects" data-secondary="initializing" data-type="indexterm" id="ix_ch03-asciidoc9"/>Now that we’ve covered fields and methods, let’s move on to other
important members of a class. In particular, <a data-primary="constructors" data-secondary="purpose of" data-type="indexterm" id="idm45927748298624"/>we’ll look at
constructors—these are class members whose job is to initialize the
fields of a class as new instances of the class are created.</p>
<p>Take another look at how we’ve been creating <code>Circle</code> objects:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">Circle</code><code class="w"> </code><code class="n">c</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">Circle</code><code class="p">();</code><code class="w"/></pre>
<p>This can easily be read as creating a new instance of <code>Circle</code>,
by calling something that looks a bit like a method. In fact, <code>Circle()</code>
is an example of a <em>constructor</em>. This is a member of a class that has
the same name as the class, and it has a body, like a method.</p>
<p>Here’s how a constructor works. The <code>new</code> operator indicates that we
need to create a new instance of the class. First of all, memory is
allocated (in the Java heap) to hold the new object instance. Then, the constructor body is
called, with any arguments that have been specified. The constructor
uses these arguments to do whatever initialization of the new object is
necessary.</p>
<p>Every class in Java has at least one <em>constructor</em>, and their purpose is to perform any necessary initialization for a new object.
If the programmer does not explicitly define a constructor for a class, the <code>javac</code> compiler automatically creates a constructor (called the default constructor) that takes no arguments and performs no special initialization.
The <code>Circle</code> class seen in <a data-type="xref" href="#javanut8-CHP-3-EX-1">Example 3-1</a> used this mechanism to automatically declare a constructor.</p>
<section data-pdf-bookmark="Defining a Constructor" data-type="sect2"><div class="sect2" id="javanut8-CHP-3-SECT-3.1">
<h2>Defining a Constructor</h2>
<p><a data-primary="constructors" data-secondary="defining a single constructor" data-type="indexterm" id="idm45927748254416"/><a data-primary="initializing objects" data-secondary="defining a constructor" data-type="indexterm" id="idm45927748253248"/>There is some obvious initialization we could do for our <code>Circle</code>
objects, so let’s define a constructor.
<a data-type="xref" href="#javanut8-CHP-3-EX-2">Example 3-2</a> shows a new definition for
<code>Circle</code> that contains a constructor that lets us specify the radius of
a new <code>Circle</code> object. We’ve also taken the opportunity to make the
field <code>r</code> protected (to prevent access to it from arbitary objects).</p>
<div data-type="example" id="javanut8-CHP-3-EX-2">
<h5><span class="label">Example 3-2. </span>A constructor for the Circle class</h5>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code><code class="w"> </code><code class="kd">class</code> <code class="nc">Circle</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">public</code><code class="w"> </code><code class="kd">static</code><code class="w"> </code><code class="kd">final</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="n">PI</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mf">3.14159</code><code class="p">;</code><code class="w">  </code><code class="c1">// A constant</code><code class="w"/>
<code class="w">    </code><code class="c1">// An instance field that holds the radius of the circle</code><code class="w"/>
<code class="w">    </code><code class="kd">protected</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="n">r</code><code class="p">;</code><code class="w"/>

<code class="w">    </code><code class="c1">// The constructor: initialize the radius field</code><code class="w"/>
<code class="w">    </code><code class="kd">public</code><code class="w"> </code><code class="nf">Circle</code><code class="p">(</code><code class="kt">double</code><code class="w"> </code><code class="n">r</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="k">this</code><code class="p">.</code><code class="na">r</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">r</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w"/>

<code class="w">    </code><code class="c1">// The instance methods: compute values based on the radius</code><code class="w"/>
<code class="w">    </code><code class="kd">public</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="nf">circumference</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="mi">2</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="n">PI</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="n">r</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="kd">public</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="nf">area</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="n">PI</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="n">r</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="n">r</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="kd">public</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="nf">radius</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="n">r</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre></div>
<p>When we relied on the default constructor supplied by the compiler, we
had to write code like this to initialize the radius explicitly:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">Circle</code><code class="w"> </code><code class="n">c</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">Circle</code><code class="p">();</code><code class="w"/>
<code class="n">c</code><code class="p">.</code><code class="na">r</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mf">0.25</code><code class="p">;</code><code class="w"/></pre>
<p>With the new constructor, the initialization becomes part of the object
creation step:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">Circle</code><code class="w"> </code><code class="n">c</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">Circle</code><code class="p">(</code><code class="mf">0.25</code><code class="p">);</code><code class="w"/></pre>
<p>Here are some basics regarding naming, declaring, and writing
constructors:</p>
<ul>
<li>
<p>The constructor name is always the same as the class name.</p>
</li>
<li>
<p>A constructor is declared without a return type (not even the <code>void</code> placeholder).</p>
</li>
<li>
<p>The body of a constructor is the code that initializes the object. You can think of this as setting up the contents of the <code>this</code> reference.</p>
</li>
<li>
<p>A constructor does not return <code>this</code> (or any other value).</p>
</li>
</ul>
</div></section>
<section data-pdf-bookmark="Defining Multiple Constructors" data-type="sect2"><div class="sect2" id="javanut8-CHP-3-SECT-3.2">
<h2>Defining Multiple Constructors</h2>
<p><a data-primary="constructors" data-secondary="defining multiple constructors" data-type="indexterm" id="idm45927748008592"/><a data-primary="initializing objects" data-secondary="defining multiple constructors" data-type="indexterm" id="idm45927748007648"/>Sometimes you want to initialize an object in a number of different
ways, depending on what is most convenient in a particular circumstance.
For example, we might want to initialize the radius of a circle to a
specified value or a reasonable default value. Here’s how we can define
two constructors for <code>Circle</code>:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code><code class="w"> </code><code class="nf">Circle</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">r</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mf">1.0</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="kd">public</code><code class="w"> </code><code class="nf">Circle</code><code class="p">(</code><code class="kt">double</code><code class="w"> </code><code class="n">r</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="k">this</code><code class="p">.</code><code class="na">r</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">r</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w"/></pre>
<p>Because our <code>Circle</code> class has only a single instance field, we can’t
initialize it in too many ways, of course. But in more complex classes, it
is often convenient to define a variety of constructors.</p>
<p>It is perfectly legal to define multiple constructors for a class, as
long as each constructor has a different parameter list. The compiler
determines which constructor you wish to use based on the number and
type of arguments you supply. This ability to define multiple
constructors is analogous to method overloading.</p>
</div></section>
<section data-pdf-bookmark="Invoking One Constructor from Another" data-type="sect2"><div class="sect2" id="javanut8-CHP-3-SECT-3.3">
<h2>Invoking One Constructor from Another</h2>
<p><a data-primary="constructors" data-secondary="invoking one constructor from another" data-type="indexterm" id="idm45927747897632"/><a data-primary="initializing objects" data-secondary="invoking one constructor from another" data-type="indexterm" id="idm45927747896688"/><a data-primary="this keyword" data-type="indexterm" id="idm45927747895776"/>A specialized use of the <code>this</code> keyword arises when a class has
multiple constructors; it can be used from a constructor to invoke one
of the other constructors of the same class. In other words, we can
rewrite the two previous <code>Circle</code> constructors as follows:</p>
<pre data-code-language="java" data-type="programlisting"><code class="c1">// This is the basic constructor: initialize the radius</code><code class="w"/>
<code class="kd">public</code><code class="w"> </code><code class="nf">Circle</code><code class="p">(</code><code class="kt">double</code><code class="w"> </code><code class="n">r</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="k">this</code><code class="p">.</code><code class="na">r</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">r</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="c1">// This constructor uses this() to invoke the constructor above</code><code class="w"/>
<code class="kd">public</code><code class="w"> </code><code class="nf">Circle</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="k">this</code><code class="p">(</code><code class="mf">1.0</code><code class="p">);</code><code class="w"> </code><code class="p">}</code><code class="w"/></pre>
<p>This is a useful technique when a number of constructors share a
significant amount of initialization code, as it avoids repetition of
that code. In more complex cases, where the constructors do a lot more
initialization, this can be a very useful technique.</p>
<p>There is an important restriction on using <code>this()</code>: it can appear only
as the first statement in a constructor, but the call may be followed by
any additional initialization a particular constructor needs to perform.
The reason for this restriction involves the automatic invocation of
superclass constructors, which we’ll explore later in this chapter.</p>
</div></section>
<section data-pdf-bookmark="Field Defaults and Initializers" data-type="sect2"><div class="sect2" id="javanut8-CHP-3-SECT-3.4">
<h2>Field Defaults and Initializers</h2>
<p><a data-primary="fields" data-secondary="defaults and initializers" data-type="indexterm" id="ix_ch03-asciidoc10"/><a data-primary="initializing objects" data-secondary="field defaults and initializers" data-type="indexterm" id="ix_ch03-asciidoc11"/>The fields of a class do not necessarily require initialization. If their initial values are not specified, the fields are automatically initialized to the default value <code>false</code>, <code>\u0000</code>, <code>0</code>, <code>0.0</code>, or <code>null</code>, depending on their type (see <a data-type="xref" href="ch02.xhtml#javanut8-CHP-2-TABLE-1">Table 2-1</a> for more details).
These default values are specified by the Java language specification and apply to both instance fields and class fields.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The default values are essentially the “natural” interpretation of the zero bit pattern for each type.</p>
</div>
<p>If the default field value is not appropriate for your field, you can instead explicitly provide a different initial value.
For example:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code><code class="w"> </code><code class="kd">static</code><code class="w"> </code><code class="kd">final</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="n">PI</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mf">3.14159</code><code class="p">;</code><code class="w"/>
<code class="kd">public</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="n">r</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mf">1.0</code><code class="p">;</code><code class="w"/></pre>
<p>Field declarations are not part of any method. Instead, the Java compiler generates initialization code for the field automatically and puts it into all the constructors for the class. The initialization code is inserted into a constructor in the order in which it appears in the source code, which means that a field initializer can use the initial values of any fields declared before it.</p>
<p>Consider the following code excerpt, which shows a constructor and two instance fields of a hypothetical class:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code><code class="w"> </code><code class="kd">class</code> <code class="nc">SampleClass</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="kd">public</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="n">len</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">10</code><code class="p">;</code><code class="w"/>
<code class="w">  </code><code class="kd">public</code><code class="w"> </code><code class="kt">int</code><code class="o">[]</code><code class="w"> </code><code class="n">table</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="kt">int</code><code class="o">[</code><code class="n">len</code><code class="o">]</code><code class="p">;</code><code class="w"/>

<code class="w">  </code><code class="kd">public</code><code class="w"> </code><code class="nf">SampleClass</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">for</code><code class="p">(</code><code class="kt">int</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="o">&lt;</code><code class="w"> </code><code class="n">len</code><code class="p">;</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="mi">1</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="n">table</code><code class="o">[</code><code class="n">i</code><code class="o">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">i</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">  </code><code class="p">}</code><code class="w"/>

<code class="w">  </code><code class="c1">// The rest of the class is omitted...</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>In this case, the code generated by <code>javac</code> for the constructor is actually equivalent to:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code><code class="w"> </code><code class="nf">SampleClass</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="n">len</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">10</code><code class="p">;</code><code class="w"/>
<code class="w">  </code><code class="n">table</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="kt">int</code><code class="o">[</code><code class="n">len</code><code class="o">]</code><code class="p">;</code><code class="w"/>
<code class="w">  </code><code class="k">for</code><code class="p">(</code><code class="kt">int</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="o">&lt;</code><code class="w"> </code><code class="n">len</code><code class="p">;</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="mi">1</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">      </code><code class="n">table</code><code class="o">[</code><code class="n">i</code><code class="o">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">i</code><code class="p">;</code><code class="w"/>
<code class="w">  </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p><a data-primary="this()" data-type="indexterm" id="idm45927747609664"/>If a constructor begins with a <code>this()</code> call to another constructor, the
field initialization code does not appear in the first constructor.
Instead, the initialization is handled in the constructor invoked by the
<code>this()</code> call.</p>
<p>So, if instance fields are initialized in the constructor, where are class fields initialized?
These fields are associated with the class, even if no instances of the class are ever created.
Logically, this means they need to be initialized even before a constructor is called.</p>
<p><a data-primary="javac" data-secondary="class initialization method generation" data-type="indexterm" id="idm45927747579072"/>To support this, <code>javac</code> generates a class initialization method automatically for every class. Class fields are initialized in the body of this method, which is invoked exactly once before the class is first used (often when the class is first loaded by the Java VM).</p>
<p>As with instance field initialization, class field initialization expressions are inserted into the class initialization method in the order in which they appear in the source code.
This means that the initialization expression for a class field can use the class fields declared before it.</p>
<p>The class initialization method is an internal method that is hidden from Java programmers.
In the class file, it bears the name <code>&lt;clinit&gt;</code> (and you could see this method by, for example, examining the class file with <code>javap</code>—see <a data-type="xref" href="ch13.xhtml#javanut8-CHP-13">Chapter 13</a> for more details on how to use <code>javap</code> to do this).</p>
<section data-pdf-bookmark="Initializer blocks" data-type="sect3"><div class="sect3" id="idm45927747574544">
<h3>Initializer blocks</h3>
<p><a data-primary="class(es)" data-secondary="initializer blocks" data-type="indexterm" id="idm45927747573072"/><a data-primary="fields" data-secondary="initializer blocks" data-type="indexterm" id="idm45927747572096"/>So far, we’ve seen that objects can be initialized through the initialization expressions for their fields and by arbitrary code in their constructors.
A class has a class initialization method (which is like a constructor), but we cannot explicitly define the body of this method in Java, although it is perfectly legal to do so in bytecode.</p>
<p><a data-primary="static initializer" data-type="indexterm" id="idm45927747570768"/>Java does however allow us to express class initialization with a construct known as a <em>static initializer</em>.
A static initializer is simply the keyword <code>static</code> followed by a block of code in curly braces.
A static initializer can appear in a class definition <span class="keep-together">anywhere</span> a field or method definition can appear.
For example, consider the following code that performs some nontrivial initialization for two class fields:</p>
<pre data-code-language="java" data-type="programlisting"><code class="c1">// We can draw the outline of a circle using trigonometric functions</code><code class="w"/>
<code class="c1">// Trigonometry is slow, though, so we precompute a bunch of values</code><code class="w"/>
<code class="kd">public</code><code class="w"> </code><code class="kd">class</code> <code class="nc">TrigCircle</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="c1">// Here are our static lookup tables and their own initializers</code><code class="w"/>
<code class="w">  </code><code class="kd">private</code><code class="w"> </code><code class="kd">static</code><code class="w"> </code><code class="kd">final</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="n">NUMPTS</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">500</code><code class="p">;</code><code class="w"/>
<code class="w">  </code><code class="kd">private</code><code class="w"> </code><code class="kd">static</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="n">sines</code><code class="o">[]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="kt">double</code><code class="o">[</code><code class="n">NUMPTS</code><code class="o">]</code><code class="p">;</code><code class="w"/>
<code class="w">  </code><code class="kd">private</code><code class="w"> </code><code class="kd">static</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="n">cosines</code><code class="o">[]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="kt">double</code><code class="o">[</code><code class="n">NUMPTS</code><code class="o">]</code><code class="p">;</code><code class="w"/>

<code class="w">  </code><code class="c1">// Here's a static initializer that fills in the arrays</code><code class="w"/>
<code class="w">  </code><code class="kd">static</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kt">double</code><code class="w"> </code><code class="n">x</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mf">0.0</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="kt">double</code><code class="w"> </code><code class="n">delta_x</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">(</code><code class="n">Circle</code><code class="p">.</code><code class="na">PI</code><code class="o">/</code><code class="mi">2</code><code class="p">)</code><code class="o">/</code><code class="p">(</code><code class="n">NUMPTS</code><code class="w"> </code><code class="o">-</code><code class="w"> </code><code class="mi">1</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="k">for</code><code class="p">(</code><code class="kt">int</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="n">x</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mf">0.0</code><code class="p">;</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="o">&lt;</code><code class="w"> </code><code class="n">NUMPTS</code><code class="p">;</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="n">x</code><code class="w"> </code><code class="o">+=</code><code class="w"> </code><code class="n">delta_x</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">      </code><code class="n">sines</code><code class="o">[</code><code class="n">i</code><code class="o">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Math</code><code class="p">.</code><code class="na">sin</code><code class="p">(</code><code class="n">x</code><code class="p">);</code><code class="w"/>
<code class="w">      </code><code class="n">cosines</code><code class="o">[</code><code class="n">i</code><code class="o">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Math</code><code class="p">.</code><code class="na">cos</code><code class="p">(</code><code class="n">x</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">  </code><code class="p">}</code><code class="w"/>
<code class="w">  </code><code class="c1">// The rest of the class is omitted...</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>A class can have any number of static initializers. The body of each
initializer block is incorporated into the class initialization method,
along with any static field initialization expressions. A static
initializer is like a class method in that it cannot use the <code>this</code>
keyword or any instance fields or instance methods of the class.<a data-startref="ix_ch03-asciidoc11" data-type="indexterm" id="idm45927747508352"/><a data-startref="ix_ch03-asciidoc10" data-type="indexterm" id="idm45927747507744"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Record Constructors" data-type="sect2"><div class="sect2" id="javanut8-CHP-3-SECT-3.5">
<h2>Record Constructors</h2>
<p><a data-primary="constructors" data-secondary="record constructors" data-type="indexterm" id="idm45927747286944"/><a data-primary="record constructors" data-type="indexterm" id="idm45927747285968"/><a data-primary="records" data-secondary="constructors" data-type="indexterm" id="idm45927747285296"/>Record classes, introduced as a standard feature in Java 16, implicitly define one constructor: the canonical constructor defined by the parameter list. There may be circumstances, however, when developers need to provide additional (aka auxiliary) constructors for record classes. For example, to provide default values for some of the record parameters, as in:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code><code class="w"> </code><code class="kd">record</code> <code class="nc">Point</code><code class="p">(</code><code class="kt">double</code><code class="w"> </code><code class="n">x</code><code class="p">,</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="n">y</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="cm">/** Constructor simulates default parameters */</code><code class="w"/>
<code class="w">    </code><code class="kd">public</code><code class="w"> </code><code class="nf">Point</code><code class="p">(</code><code class="kt">double</code><code class="w"> </code><code class="n">x</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">this</code><code class="p">(</code><code class="n">x</code><code class="p">,</code><code class="w"> </code><code class="mf">0.0</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p><a data-primary="compact constructor" data-type="indexterm" id="idm45927747224656"/>Records also provide for another refinement to class constructors: the <em>compact constructor</em>. This is used when some sort of validation or other checking code is helpful for creating valid record objects. For example:</p>
<pre data-code-language="java" data-type="programlisting"><code class="cm">/** Represents a point in 2-dimensional space */</code><code class="w"/>
<code class="kd">public</code><code class="w"> </code><code class="kd">record</code> <code class="nc">Point</code><code class="p">(</code><code class="kt">double</code><code class="w"> </code><code class="n">x</code><code class="p">,</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="n">y</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="cm">/** Compact constructor provides validation */</code><code class="w"/>
<code class="w">    </code><code class="kd">public</code><code class="w"> </code><code class="n">Point</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="n">Double</code><code class="p">.</code><code class="na">isNaN</code><code class="p">(</code><code class="n">x</code><code class="p">)</code><code class="w"> </code><code class="o">||</code><code class="w"> </code><code class="n">Double</code><code class="p">.</code><code class="na">isNaN</code><code class="p">(</code><code class="n">y</code><code class="p">))</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="k">throw</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">IllegalArgumentException</code><code class="p">(</code><code class="s">"Illegal NaN"</code><code class="p">);</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>Note that in the compact constructor syntax, the parameter list does not need to be repeated (as it is inferred from the record declaration) and the parameters (in our example, <code>x</code> and <code>y</code>) are already in scope.
Compact constructors, like the canonical constructor, also implicitly initialize the fields from the parameter values.<a data-startref="ix_ch03-asciidoc9" data-type="indexterm" id="idm45927747078352"/><a data-startref="ix_ch03-asciidoc8" data-type="indexterm" id="idm45927747077712"/><a data-startref="ix_ch03-asciidoc7" data-type="indexterm" id="idm45927747077040"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Subclasses and Inheritance" data-type="sect1"><div class="sect1" id="javanut8-CHP-3-SECT-4">
<h1>Subclasses and Inheritance</h1>
<p><a data-primary="class(es)" data-secondary="subclasses and inheritance" data-type="indexterm" id="ix_ch03-asciidoc12"/><a data-primary="object-oriented programming" data-secondary="subclasses and inheritance" data-type="indexterm" id="ix_ch03-asciidoc13"/><a data-primary="subclasses" data-secondary="inheritance and" data-type="indexterm" id="ix_ch03-asciidoc14"/>The <code>Circle</code> defined earlier is a simple class that distinguishes
circle objects only by their radii. Suppose, instead, that we want to
represent circles that have both a size and a position. For example, a
circle of radius 1.0 centered at point 0,0 in the Cartesian plane is
different from the circle of radius 1.0 centered at point 1,2. To do
this, we need a new class, which we’ll call <code>PlaneCircle</code>.</p>
<p>We’d like to add the ability to represent the position of a circle
without losing any of the existing functionality of the <code>Circle</code> class.
We do this by defining <code>PlaneCircle</code> as a subclass of <code>Circle</code> so that
<code>PlaneCircle</code> inherits the fields and methods of its superclass,
<code>Circle</code>. The ability to add functionality to a class by subclassing, or
extending, is central to the object-oriented programming paradigm.</p>
<section data-pdf-bookmark="Extending a Class" data-type="sect2"><div class="sect2" id="javanut8-CHP-3-SECT-4.1">
<h2>Extending a Class</h2>
<p><a data-primary="class(es)" data-secondary="extending" data-type="indexterm" id="ix_ch03-asciidoc15"/><a data-primary="subclasses" data-secondary="extending a class" data-type="indexterm" id="ix_ch03-asciidoc16"/>In <a data-type="xref" href="#javanut8-CHP-3-EX-3">Example 3-3</a>, we show how we can implement
<code>PlaneCircle</code> as a subclass of the <code>Circle</code> class.</p>
<div data-type="example" id="javanut8-CHP-3-EX-3">
<h5><span class="label">Example 3-3. </span>Extending the Circle class</h5>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code><code class="w"> </code><code class="kd">class</code> <code class="nc">PlaneCircle</code><code class="w"> </code><code class="kd">extends</code><code class="w"> </code><code class="n">Circle</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="c1">// We automatically inherit the fields and methods of Circle,</code><code class="w"/>
<code class="w">  </code><code class="c1">// so we only have to put the new stuff here.</code><code class="w"/>
<code class="w">  </code><code class="c1">// New instance fields that store the center point of the circle</code><code class="w"/>
<code class="w">  </code><code class="kd">private</code><code class="w"> </code><code class="kd">final</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="n">cx</code><code class="p">,</code><code class="w"> </code><code class="n">cy</code><code class="p">;</code><code class="w"/>

<code class="w">  </code><code class="c1">// A new constructor to initialize the new fields</code><code class="w"/>
<code class="w">  </code><code class="c1">// It uses a special syntax to invoke the Circle() constructor</code><code class="w"/>
<code class="w">  </code><code class="kd">public</code><code class="w"> </code><code class="nf">PlaneCircle</code><code class="p">(</code><code class="kt">double</code><code class="w"> </code><code class="n">r</code><code class="p">,</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="n">x</code><code class="p">,</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="n">y</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">super</code><code class="p">(</code><code class="n">r</code><code class="p">);</code><code class="w">       </code><code class="c1">// Invoke the constructor of the superclass, Circle()</code><code class="w"/>
<code class="w">    </code><code class="k">this</code><code class="p">.</code><code class="na">cx</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">x</code><code class="p">;</code><code class="w">    </code><code class="c1">// Initialize the instance field cx</code><code class="w"/>
<code class="w">    </code><code class="k">this</code><code class="p">.</code><code class="na">cy</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">y</code><code class="p">;</code><code class="w">    </code><code class="c1">// Initialize the instance field cy</code><code class="w"/>
<code class="w">  </code><code class="p">}</code><code class="w"/>

<code class="w">  </code><code class="kd">public</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="nf">getCenterX</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="n">cx</code><code class="p">;</code><code class="w"/>
<code class="w">  </code><code class="p">}</code><code class="w"/>

<code class="w">  </code><code class="kd">public</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="nf">getCenterY</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="n">cy</code><code class="p">;</code><code class="w"/>
<code class="w">  </code><code class="p">}</code><code class="w"/>

<code class="w">  </code><code class="c1">// The area() and circumference() methods are inherited from Circle</code><code class="w"/>
<code class="w">  </code><code class="c1">// A new instance method checks whether a point is inside the circle</code><code class="w"/>
<code class="w">  </code><code class="c1">// Note that it uses the inherited instance field r</code><code class="w"/>
<code class="w">  </code><code class="kd">public</code><code class="w"> </code><code class="kt">boolean</code><code class="w"> </code><code class="nf">isInside</code><code class="p">(</code><code class="kt">double</code><code class="w"> </code><code class="n">x</code><code class="p">,</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="n">y</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kt">double</code><code class="w"> </code><code class="n">dx</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">x</code><code class="w"> </code><code class="o">-</code><code class="w"> </code><code class="n">cx</code><code class="p">,</code><code class="w"> </code><code class="n">dy</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">y</code><code class="w"> </code><code class="o">-</code><code class="w"> </code><code class="n">cy</code><code class="p">;</code><code class="w">             </code><code class="c1">// Distance from center</code><code class="w"/>
<code class="w">    </code><code class="kt">double</code><code class="w"> </code><code class="n">distance</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Math</code><code class="p">.</code><code class="na">sqrt</code><code class="p">(</code><code class="n">dx</code><code class="o">*</code><code class="n">dx</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">dy</code><code class="o">*</code><code class="n">dy</code><code class="p">);</code><code class="w">  </code><code class="c1">// Pythagorean theorem</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="p">(</code><code class="n">distance</code><code class="w"> </code><code class="o">&lt;</code><code class="w"> </code><code class="n">r</code><code class="p">);</code><code class="w">                       </code><code class="c1">// Returns true or false</code><code class="w"/>
<code class="w">  </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre></div>
<p>Note the use of the keyword <code>extends</code> in the first line of
<a data-type="xref" href="#javanut8-CHP-3-EX-3">Example 3-3</a>. This keyword tells Java that
<code>PlaneCircle</code> extends, or subclasses, <code>Circle</code>, meaning that it inherits
the fields and methods of that class.</p>
<p>The definition of the <code>isInside()</code> method shows field inheritance;
this method uses the field <code>r</code> (defined by the <code>Circle</code> class) as if it
were defined right in <code>PlaneCircle</code> itself. <code>PlaneCircle</code> also inherits
the methods of <code>Circle</code>. Therefore, if we have a <span class="keep-together"><code>PlaneCircle</code></span> object
referenced by variable <code>pc</code>, we can say:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kt">double</code><code class="w"> </code><code class="n">ratio</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">pc</code><code class="p">.</code><code class="na">circumference</code><code class="p">()</code><code class="w"> </code><code class="o">/</code><code class="w"> </code><code class="n">pc</code><code class="p">.</code><code class="na">area</code><code class="p">();</code><code class="w"/></pre>
<p>This works just as if the <code>area()</code> and <code>circumference()</code> methods were
defined in <span class="keep-together"><code>PlaneCircle</code></span> itself.</p>
<p>Another feature of subclassing is that every <code>PlaneCircle</code> object is
also a perfectly legal <code>Circle</code> object. If <code>pc</code> refers to a
<code>PlaneCircle</code> object, we can assign it to a <code>Circle</code> variable and forget
all about its extra positioning capabilities:</p>
<pre data-code-language="java" data-type="programlisting"><code class="c1">// Unit circle at the origin</code><code class="w"/>
<code class="n">PlaneCircle</code><code class="w"> </code><code class="n">pc</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">PlaneCircle</code><code class="p">(</code><code class="mf">1.0</code><code class="p">,</code><code class="w"> </code><code class="mf">0.0</code><code class="p">,</code><code class="w"> </code><code class="mf">0.0</code><code class="p">);</code><code class="w"/>
<code class="n">Circle</code><code class="w"> </code><code class="n">c</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">pc</code><code class="p">;</code><code class="w">     </code><code class="c1">// Assigned to a Circle variable without casting</code><code class="w"/></pre>
<p>This assignment of a <code>PlaneCircle</code> object to a <code>Circle</code> variable can be
done without a cast. As we discussed in <a data-type="xref" href="ch02.xhtml#javanut8-CHP-2">Chapter 2</a>,
a conversion like this is always legal. The value held in the <code>Circle</code>
variable <code>c</code> is still a valid <code>PlaneCircle</code> object, but the compiler
cannot know this for sure, so it doesn’t allow us to do the opposite
(narrowing) conversion without a cast:</p>
<pre data-code-language="java" data-type="programlisting"><code class="c1">// Narrowing conversions require a cast (and a runtime check by the VM)</code><code class="w"/>
<code class="n">PlaneCircle</code><code class="w"> </code><code class="n">pc2</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">(</code><code class="n">PlaneCircle</code><code class="p">)</code><code class="w"> </code><code class="n">c</code><code class="p">;</code><code class="w"/>
<code class="kt">boolean</code><code class="w"> </code><code class="n">inside</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">((</code><code class="n">PlaneCircle</code><code class="p">)</code><code class="w"> </code><code class="n">c</code><code class="p">).</code><code class="na">isInside</code><code class="p">(</code><code class="mf">0.0</code><code class="p">,</code><code class="w"> </code><code class="mf">0.0</code><code class="p">);</code><code class="w"/></pre>
<p>This distinction is covered in more detail in
<a data-type="xref" href="ch04.xhtml#javanut8-CHP-4-SECT-5">“Nested Types”</a>, where we talk about the
distinction between the compile and runtime type of an object.</p>
<section data-pdf-bookmark="Final classes" data-type="sect3"><div class="sect3" id="idm45927746642448">
<h3>Final classes</h3>
<p><a data-primary="class(es)" data-secondary="final" data-type="indexterm" id="idm45927746641344"/><a data-primary="final classes" data-type="indexterm" id="idm45927746639968"/><a data-primary="java.lang.String" data-type="indexterm" id="idm45927746639296"/><a data-primary="subclasses" data-secondary="final classes and" data-type="indexterm" id="idm45927746638624"/>When a class is declared with the <code>final</code> modifier, it means that it cannot be extended or subclassed. <code>java.lang.String</code> is an example of a <code>final</code> class.
<a data-primary="String class" data-type="indexterm" id="idm45927746636304"/>Declaring a class <code>final</code> prevents unwanted extensions to the class: if you invoke a method on a <code>String</code> object, you know that the method is the one defined by the <code>String</code> class itself, even if the <code>String</code> is passed to you from some unknown outside source.</p>
<p>In general, many of the classes that Java developers create should be <code>final</code>.
Think carefully about whether it will make sense to allow other (possibly unknown) code to extend your classes—if it doesn’t, then disallow the mechanism by declaring your classes <code>final</code>.<a data-startref="ix_ch03-asciidoc16" data-type="indexterm" id="idm45927746587408"/><a data-startref="ix_ch03-asciidoc15" data-type="indexterm" id="idm45927746586912"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Superclasses, Object, and the Class Hierarchy" data-type="sect2"><div class="sect2" id="idm45927747066288">
<h2>Superclasses, Object, and the Class Hierarchy</h2>
<p><a data-primary="class hierarchy" data-type="indexterm" id="idm45927746584736"/><a data-primary="class(es)" data-secondary="class hierarchy" data-type="indexterm" id="idm45927746583904"/><a data-primary="class(es)" data-secondary="hierarchy" data-type="indexterm" id="idm45927746582992"/><a data-primary="class(es)" data-secondary="superclasses" data-type="indexterm" id="idm45927746582048"/><a data-primary="object-oriented programming" data-secondary="superclasses and class hierarchy" data-type="indexterm" id="idm45927746581104"/><a data-primary="subclasses" data-secondary="superclasses and" data-type="indexterm" id="idm45927746580224"/><a data-primary="superclasses" data-type="indexterm" id="idm45927746579280"/>In our example, <code>PlaneCircle</code> is a subclass of <code>Circle</code>.
We can also say that <code>Circle</code> is the superclass of <code>PlaneCircle</code>.
The superclass of a class is specified in its <code>extends</code> clause, and a class may have only a single direct superclass:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code><code class="w"> </code><code class="kd">class</code> <code class="nc">PlaneCircle</code><code class="w"> </code><code class="kd">extends</code><code class="w"> </code><code class="n">Circle</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="p">...</code><code class="w"> </code><code class="p">}</code><code class="w"/></pre>
<p>Every class the programmer defines has a superclass. If the superclass is not specified with an <code>extends</code> clause, then the superclass is taken to be the class <code>java.lang.Object</code>.</p>
<p>As a result, the <code>Object</code> class is special for a couple of reasons:</p>
<ul>
<li>
<p>It is the only class in Java that does not have a superclass.</p>
</li>
<li>
<p>All Java classes inherit (directly or indirectly) the methods of <code>Object</code>.</p>
</li>
</ul>
<p>Because every class (except <code>Object</code>) has a superclass, classes in Java form a class hierarchy, which can be represented as a tree with <code>Object</code> at its root.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><code>Object</code> has no superclass, but every other class has exactly one
superclass. A subclass cannot extend more than one superclass; see
<a data-type="xref" href="ch04.xhtml#javanut8-CHP-4">Chapter 4</a> for more information on how to achieve a similar result using interfaces.</p>
</div>
<p><a data-type="xref" href="#javanut8-CHP-3-FIG-1">Figure 3-1</a> shows a partial class hierarchy
diagram that includes our <code>Circle</code> and <span class="keep-together"><code>PlaneCircle</code></span> classes, as well as
some of the standard classes from the Java API.</p>
<figure><div class="figure" id="javanut8-CHP-3-FIG-1">
<img alt="JN7 0301" height="349" src="assets/jns8_0301.png" width="600"/>
<h6><span class="label">Figure 3-1. </span>A class hierarchy diagram</h6>
</div></figure>
</div></section>
<section data-pdf-bookmark="Subclass Constructors" data-type="sect2"><div class="sect2" id="idm45927746585584">
<h2>Subclass Constructors</h2>
<p><a data-primary="constructors" data-secondary="subclass" data-type="indexterm" id="idm45927746542688"/><a data-primary="subclasses" data-secondary="constructors" data-type="indexterm" id="idm45927746541712"/>Look again at the <code>PlaneCircle()</code> constructor from
<a data-type="xref" href="#javanut8-CHP-3-EX-3">Example 3-3</a>:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code><code class="w"> </code><code class="nf">PlaneCircle</code><code class="p">(</code><code class="kt">double</code><code class="w"> </code><code class="n">r</code><code class="p">,</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="n">x</code><code class="p">,</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="n">y</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="kd">super</code><code class="p">(</code><code class="n">r</code><code class="p">);</code><code class="w">       </code><code class="c1">// Invoke the constructor of the superclass, Circle()</code><code class="w"/>
<code class="w">  </code><code class="k">this</code><code class="p">.</code><code class="na">cx</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">x</code><code class="p">;</code><code class="w">    </code><code class="c1">// Initialize the instance field cx</code><code class="w"/>
<code class="w">  </code><code class="k">this</code><code class="p">.</code><code class="na">cy</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">y</code><code class="p">;</code><code class="w">    </code><code class="c1">// Initialize the instance field cy</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>Although this constructor explicitly initializes the <code>cx</code> and <code>cy</code>
fields newly defined by <code>PlaneCircle</code>, it relies on the superclass
<code>Circle()</code> constructor to initialize the inherited fields of the class.
To invoke the superclass constructor, our constructor calls <code>super()</code>.</p>
<p><code>super</code> is a reserved word in Java.
One of its main uses is to invoke the constructor of a superclass from within a subclass constructor.
This use is analogous to the use of <code>this()</code> to invoke one constructor of a class from within another constructor of the same class.
<a data-primary="super keyword" data-secondary="as reserved word" data-secondary-sortas="reserved word" data-type="indexterm" id="idm45927746491632"/><a data-primary="super()" data-type="indexterm" id="idm45927746490384"/>Invoking a constructor using <code>super()</code> is subject to the same restrictions as is using <code>this()</code>:</p>
<ul>
<li>
<p><code>super()</code> can be used in this way only within a constructor.</p>
</li>
<li>
<p>The call to the superclass constructor must appear as the first
statement within the constructor, even before local variable
declarations.</p>
</li>
</ul>
<p>The arguments passed to <code>super()</code> must match the parameters of the superclass constructor.
If the superclass defines more than one constructor, <code>super()</code> can be used to invoke any one of them, depending on the arguments passed.</p>
</div></section>
<section data-pdf-bookmark="Constructor Chaining and the Default Constructor" data-type="sect2"><div class="sect2" id="idm45927746428016">
<h2>Constructor Chaining and the Default Constructor</h2>
<p><a data-primary="constructors" data-secondary="chaining" data-type="indexterm" id="idm45927746426768"/><a data-primary="subclasses" data-secondary="constructor chaining" data-type="indexterm" id="idm45927746425824"/>Java guarantees that the constructor of a class is called whenever an
instance of that class is created. It also guarantees that the
constructor is called whenever an instance of any subclass is created.
In order to guarantee this second point, Java must ensure that every
constructor calls its superclass constructor.</p>
<p>Thus, if the first statement in a constructor does not explicitly invoke
another constructor with <code>this()</code> or <code>super()</code>, the <code>javac</code> compiler
inserts the call <code>super()</code> (i.e., it calls the superclass constructor
with no arguments). If the superclass does not have a visible
constructor that takes no arguments, this implicit invocation causes a
compilation error.</p>
<p>Consider what happens when we create a new instance of the <code>PlaneCircle</code>
class:</p>
<ol>
<li>
<p>First, the <code>PlaneCircle</code> constructor is invoked.</p>
</li>
<li>
<p>This constructor explicitly calls <code>super(r)</code> to invoke a <code>Circle</code>
constructor.</p>
</li>
<li>
<p>That <code>Circle()</code> constructor implicitly calls <code>super()</code> to invoke the
constructor of its superclass, <code>Object</code> (<code>Object</code> only has one
constructor).</p>
</li>
<li>
<p>At this point, we’ve reached the top of the hierarchy and constructors
start to run.</p>
</li>
<li>
<p>The body of the <code>Object</code> constructor runs first.</p>
</li>
<li>
<p>When it returns, the body of the <code>Circle()</code> constructor runs.</p>
</li>
<li>
<p>Finally, when the call to <code>super(r)</code> returns, the remaining statements
of the <code>PlaneCircle()</code> constructor are executed.</p>
</li>
</ol>
<p>What all this means is that constructor calls are chained; any time an
object is created, a sequence of constructors is invoked, from subclass
to superclass on up to <code>Object</code> at the root of the class hierarchy.</p>
<p>Because a superclass constructor is always invoked as the first
statement of its subclass constructor, the body of the <code>Object</code>
constructor always runs first, followed by the constructor of its
subclass and on down the class hierarchy to the class that is being
instantiated.</p>
<p>Whenever a constructor is invoked, it can count on the fields of its
superclass to be initialized by the time the constructor starts to run.</p>
<section data-pdf-bookmark="The default constructor" data-type="sect3"><div class="sect3" id="idm45927746407296">
<h3>The default constructor</h3>
<p><a data-primary="constructors" data-secondary="default" data-type="indexterm" id="idm45927746405744"/><a data-primary="default constructor" data-type="indexterm" id="idm45927746404768"/><a data-primary="subclasses" data-secondary="default constructor" data-type="indexterm" id="idm45927746404096"/><a data-primary="superclasses" data-secondary="default constructor" data-type="indexterm" id="idm45927746403152"/>There is one missing piece in the previous description of constructor
chaining. If a constructor does not invoke a superclass constructor,
Java does so implicitly.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>If a class is declared without a constructor, Java implicitly adds a constructor to the class. This default constructor does nothing but invoke the superclass constructor.</p>
</div>
<p>For example, if we don’t declare a constructor for the <code>PlaneCircle</code> class, Java implicitly inserts this constructor:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code><code class="w"> </code><code class="nf">PlaneCircle</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="kd">super</code><code class="p">();</code><code class="w"> </code><code class="p">}</code><code class="w"/></pre>
<p>Classes declared <code>public</code> are given <code>public</code> constructors.
All other classes are given a default constructor that is declared without any visibility modifier; such a constructor has default visibility.</p>
<p>One very important point is that if a class declares constructors that take parameters but does not define a no-argument constructor, then all its subclasses must define constructors that explicitly invoke a constructor with the necessary arguments.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>If you are creating a <code>public</code> class that should not be publicly instantiated, declare at least one non-<code>public</code> constructor to prevent the insertion of a default <code>public</code> constructor.</p>
</div>
<p><a data-primary="private constructor" data-type="indexterm" id="idm45927746379168"/>Classes that should never be instantiated (such as <code>java.lang.Math</code> or <code>java.lang.System</code>) should define only a <code>private</code> constructor.
Such a constructor can never be invoked from outside of the class, and it prevents the automatic insertion of the default constructor.
The overall effect is that the class will never be instantiated, as it is not instantiated by the class itself and no other class has the correct access.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="Hiding Superclass Fields" data-type="sect2"><div class="sect2" id="idm45927746376800">
<h2>Hiding Superclass Fields</h2>
<p><a data-primary="fields" data-secondary="hiding superclass fields" data-type="indexterm" id="ix_ch03-asciidoc17"/><a data-primary="superclasses" data-secondary="hiding superclass fields" data-type="indexterm" id="ix_ch03-asciidoc18"/>For the sake of example, imagine that our <code>PlaneCircle</code> class needs
to know the distance between the center of the circle and the origin
(0,0). We can add another instance field to hold this value:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="n">r</code><code class="p">;</code><code class="w"/></pre>
<p>Adding the following line to the constructor computes the value of the field:</p>
<pre data-code-language="java" data-type="programlisting"><code class="k">this</code><code class="p">.</code><code class="na">r</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Math</code><code class="p">.</code><code class="na">sqrt</code><code class="p">(</code><code class="n">cx</code><code class="o">*</code><code class="n">cx</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">cy</code><code class="o">*</code><code class="n">cy</code><code class="p">);</code><code class="w">  </code><code class="c1">// Pythagorean theorem</code><code class="w"/></pre>
<p>But wait; this new field <code>r</code> has the same name as the radius field <code>r</code>
in the <code>Circle</code> superclass. When this happens, we say that the field <code>r</code>
of <code>PlaneCircle</code> <em>hides</em> the field <code>r</code> of <code>Circle</code>. (This is a contrived
example, of course: the new field really should be called
<code>distanceFromOrigin</code>.)</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>In code that you write, you should avoid declaring fields with names
that hide superclass fields. It is almost always a sign of bad code.</p>
</div>
<p>With this new definition of <code>PlaneCircle</code>, the expressions <code>r</code> and
<code>this.r</code> both refer to the field of <code>PlaneCircle</code>. How, then, can we
refer to the field <code>r</code> of <code>Circle</code> that holds the radius of the circle?
A special syntax for this uses the <code>super</code> keyword:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">r</code><code class="w">        </code><code class="c1">// Refers to the PlaneCircle field</code><code class="w"/>
<code class="k">this</code><code class="p">.</code><code class="na">r</code><code class="w">   </code><code class="c1">// Refers to the PlaneCircle field</code><code class="w"/>
<code class="kd">super</code><code class="p">.</code><code class="na">r</code><code class="w">  </code><code class="c1">// Refers to the Circle field</code><code class="w"/></pre>
<p>Another way to refer to a hidden field is to cast <code>this</code> (or any
instance of the class) to the appropriate superclass and then access the
field:</p>
<pre data-code-language="java" data-type="programlisting"><code class="p">((</code><code class="n">Circle</code><code class="p">)</code><code class="w"> </code><code class="k">this</code><code class="p">).</code><code class="na">r</code><code class="w">   </code><code class="c1">// Refers to field r of the Circle class</code><code class="w"/></pre>
<p>This casting technique is particularly useful when you need to refer to
a hidden field defined in a class that is not the immediate superclass.
Suppose, for example, that classes <code>A</code>, <code>B</code>, and <code>C</code> all define a field
named <code>x</code> and that <code>C</code> is a subclass of <code>B</code>, which is a subclass of <code>A</code>.
Then, in the methods of class <code>C</code>, you can refer to these different
fields as follows:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">x</code><code class="w">                </code><code class="c1">// Field x in class C</code><code class="w"/>
<code class="k">this</code><code class="p">.</code><code class="na">x</code><code class="w">           </code><code class="c1">// Field x in class C</code><code class="w"/>
<code class="kd">super</code><code class="p">.</code><code class="na">x</code><code class="w">          </code><code class="c1">// Field x in class B</code><code class="w"/>
<code class="p">((</code><code class="n">B</code><code class="p">)</code><code class="k">this</code><code class="p">).</code><code class="na">x</code><code class="w">      </code><code class="c1">// Field x in class B</code><code class="w"/>
<code class="p">((</code><code class="n">A</code><code class="p">)</code><code class="k">this</code><code class="p">).</code><code class="na">x</code><code class="w">      </code><code class="c1">// Field x in class A</code><code class="w"/>
<code class="kd">super</code><code class="p">.</code><code class="na">super</code><code class="p">.</code><code class="na">x</code><code class="w">    </code><code class="c1">// Illegal; does not refer to x in class A</code><code class="w"/></pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>You cannot refer to a hidden field <code>x</code> in the superclass of a superclass
with <code>super.super.x</code>. This is not legal syntax.</p>
</div>
<p>Similarly, if you have an instance <code>c</code> of class <code>C</code>, you can refer to
the three fields named <code>x</code> like this:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">c</code><code class="p">.</code><code class="na">x</code><code class="w">              </code><code class="c1">// Field x of class C</code><code class="w"/>
<code class="p">((</code><code class="n">B</code><code class="p">)</code><code class="n">c</code><code class="p">).</code><code class="na">x</code><code class="w">         </code><code class="c1">// Field x of class B</code><code class="w"/>
<code class="p">((</code><code class="n">A</code><code class="p">)</code><code class="n">c</code><code class="p">).</code><code class="na">x</code><code class="w">         </code><code class="c1">// Field x of class A</code><code class="w"/></pre>
<p>So far, we’ve been discussing instance fields. Class fields can also be
hidden. You can use the same <code>super</code> syntax to refer to the hidden value
of the field, but this is never necessary, as you can always refer to a
class field by prepending the name of the desired class. Suppose, for
example, that the implementer of <code>PlaneCircle</code> decides that the
<code>Circle.PI</code> field does not declare to enough decimal places. She can
define her own class field <code>PI</code>:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code><code class="w"> </code><code class="kd">static</code><code class="w"> </code><code class="kd">final</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="n">PI</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mf">3.14159265358979323846</code><code class="p">;</code><code class="w"/></pre>
<p>Now code in <code>PlaneCircle</code> can use this more accurate value with the
expressions <code>PI</code> or <code>PlaneCircle.PI</code>. It can also refer to the old, less
accurate value with the expressions <code>super.PI</code> and <code>Circle.PI</code>. However,
the <code>area()</code> and <code>circumference()</code> methods inherited by <code>PlaneCircle</code>
are defined in the <code>Circle</code> class, so they use the value <code>Circle.PI</code>,
even though that value is hidden now by <code>PlaneCircle.PI</code>.<a data-startref="ix_ch03-asciidoc18" data-type="indexterm" id="idm45927746062096"/><a data-startref="ix_ch03-asciidoc17" data-type="indexterm" id="idm45927746058368"/></p>
</div></section>
<section data-pdf-bookmark="Overriding Superclass Methods" data-type="sect2"><div class="sect2" id="idm45927746073808">
<h2>Overriding Superclass Methods</h2>
<p><a data-primary="methods" data-secondary="overriding superclass methods" data-type="indexterm" id="ix_ch03-asciidoc19"/><a data-primary="superclasses" data-secondary="overriding superclass methods" data-type="indexterm" id="ix_ch03-asciidoc20"/>When a class defines an instance method using the same name, return
type, and parameters as a method in its superclass, that method
<em>overrides</em> the method of the superclass. When the method is invoked for
an object of the class, it is the new definition of the method that is
called, not the old definition from the superclass.</p>
<div data-type="tip"><h6>Tip</h6>
<p><a data-primary="covariant return" data-type="indexterm" id="idm45927746052832"/>The return type of the overriding method may be a subclass of the
return type of the original method (instead of being exactly the same
type). This is known as a <em>covariant return</em>.</p>
</div>
<p>Method overriding is an important and useful technique in object-oriented programming.
<code>PlaneCircle</code> does not override either of the methods defined by <code>Circle</code>, and in fact it is difficult to think of a good example where any of the methods defined by <code>Circle</code> could have a well-defined override.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>Don’t be tempted to consider subclassing <code>Circle</code> with a class like <code>Ellipse</code>—this would actually violate a core principle of object-oriented development (the Liskov principle, which we will meet later in this chapter).</p>
</div>
<p>Instead, let’s look at a different example that does work with method overriding:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code><code class="w"> </code><code class="kd">class</code> <code class="nc">Car</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">public</code><code class="w"> </code><code class="kd">static</code><code class="w"> </code><code class="kd">final</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="n">LITRE_PER_100KM</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mf">8.9</code><code class="p">;</code><code class="w"/>

<code class="w">    </code><code class="kd">protected</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="n">topSpeed</code><code class="p">;</code><code class="w"/>

<code class="w">    </code><code class="kd">protected</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="n">fuelTankCapacity</code><code class="p">;</code><code class="w"/>

<code class="w">    </code><code class="kd">private</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="n">doors</code><code class="p">;</code><code class="w"/>

<code class="w">    </code><code class="kd">public</code><code class="w"> </code><code class="nf">Car</code><code class="p">(</code><code class="kt">double</code><code class="w"> </code><code class="n">topSpeed</code><code class="p">,</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="n">fuelTankCapacity</code><code class="p">,</code><code class="w"> </code>
<code class="w">               </code><code class="kt">int</code><code class="w"> </code><code class="n">doors</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">this</code><code class="p">.</code><code class="na">topSpeed</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">topSpeed</code><code class="p">;</code><code class="w"/>
<code class="w">        </code><code class="k">this</code><code class="p">.</code><code class="na">fuelTankCapacity</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">fuelTankCapacity</code><code class="p">;</code><code class="w"/>
<code class="w">        </code><code class="k">this</code><code class="p">.</code><code class="na">doors</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">doors</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>

<code class="w">    </code><code class="kd">public</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="nf">getTopSpeed</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="n">topSpeed</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>

<code class="w">    </code><code class="kd">public</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="nf">getDoors</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="n">doors</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>

<code class="w">    </code><code class="kd">public</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="nf">getFuelTankCapacity</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="n">fuelTankCapacity</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>

<code class="w">    </code><code class="kd">public</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="nf">range</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="mi">100</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="n">fuelTankCapacity</code><code class="w"> </code><code class="o">/</code><code class="w"> </code><code class="n">LITRE_PER_100KM</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>This is a bit more complex, but it will illustrate the concepts behind overriding.
Along with the <code>Car</code> class, we also have a specialized class, <code>SportsCar</code>.
This has several differences: it has a fixed-size fuel tank and comes only in a two-door version.
It may also have a much higher top speed than the regular form, but if the top speed rises above 200 km/h then the fuel efficiency of the car suffers, and as a result the overall range of the car starts to decrease:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code><code class="w"> </code><code class="kd">class</code> <code class="nc">SportsCar</code><code class="w"> </code><code class="kd">extends</code><code class="w"> </code><code class="n">Car</code><code class="w"> </code><code class="p">{</code><code class="w"/>

<code class="w">    </code><code class="kd">private</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="n">efficiency</code><code class="p">;</code><code class="w"/>

<code class="w">    </code><code class="kd">public</code><code class="w"> </code><code class="nf">SportsCar</code><code class="p">(</code><code class="kt">double</code><code class="w"> </code><code class="n">topSpeed</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="kd">super</code><code class="p">(</code><code class="n">topSpeed</code><code class="p">,</code><code class="w"> </code><code class="mf">50.0</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="p">);</code><code class="w"/>
<code class="w">        </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="n">topSpeed</code><code class="w"> </code><code class="o">&gt;</code><code class="w"> </code><code class="mf">200.0</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="n">efficiency</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mf">200.0</code><code class="w"> </code><code class="o">/</code><code class="w"> </code><code class="n">topSpeed</code><code class="p">;</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"> </code><code class="k">else</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="n">efficiency</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mf">1.0</code><code class="p">;</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>

<code class="w">    </code><code class="kd">public</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="nf">getEfficiency</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="n">efficiency</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>

<code class="w">    </code><code class="nd">@Override</code><code class="w"/>
<code class="w">    </code><code class="kd">public</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="nf">range</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="mi">100</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="n">fuelTankCapacity</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="n">efficiency</code><code class="w"> </code><code class="o">/</code><code class="w"> </code><code class="n">LITRE_PER_100KM</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>

<code class="p">}</code><code class="w"/></pre>
<p>The upcoming discussion of method overriding considers only instance
methods. Class (aka static) methods behave quite differently, and they cannot be
overridden. Just like fields, class methods can be hidden by a subclass
but not overridden. As noted earlier in this chapter, it is good
programming style to always prefix a class method invocation with the
name of the class in which it is defined. If you consider the class name
part of the class method name, the two methods have different names, so
nothing is actually hidden at all.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The code example for the <code>SportsCar</code> includes the syntax construct <code>@Override</code>. This is known as an <em>annotation</em>, and we shall meet this piece of Java syntax properly in <a data-type="xref" href="ch04.xhtml#javanut8-CHP-4">Chapter 4</a>.</p>
</div>
<p>Before we go any further with the discussion of method overriding, you
should understand the difference between method overriding and method
overloading. As we discussed in <a data-type="xref" href="ch02.xhtml#javanut8-CHP-2">Chapter 2</a>, method
overloading refers to the practice of defining multiple methods (in the
same class) that have the same name but different parameter lists.</p>
<p>On the other hand, a method overrides a method in its superclass when the instance method uses the same name, return type, and
parameter list as a method in its superclass.
These two features are very different from each other, so don’t get them confused.</p>
<section data-pdf-bookmark="Overriding is not hiding" data-type="sect3"><div class="sect3" id="idm45927745654128">
<h3>Overriding is not hiding</h3>
<p><a data-primary="field hiding, overriding vs." data-type="indexterm" id="idm45927745652720"/><a data-primary="hidden fields, overriding vs. field hiding" data-type="indexterm" id="idm45927745592128"/><a data-primary="javac" data-secondary="virtual method lookup" data-type="indexterm" id="idm45927745591520"/><a data-primary="methods" data-secondary="overriding vs. field hiding" data-type="indexterm" id="idm45927745590672"/><a data-primary="methods" data-secondary="virtual lookup" data-type="indexterm" id="idm45927745589824"/><a data-primary="overriding" data-secondary="field hiding vs." data-type="indexterm" id="idm45927745588944"/><a data-primary="virtual method lookup" data-type="indexterm" id="idm45927745588000"/>Although Java treats the fields and methods of a class analogously in
many ways, method overriding is not at all like field hiding. You can
refer to hidden fields simply by casting an object to an instance of the
appropriate superclass, but you cannot invoke overridden instance
methods with this technique. The following code illustrates this crucial
difference:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">class</code> <code class="nc">A</code><code class="w"> </code><code class="p">{</code><code class="w">                          </code><code class="c1">// Define a class named A</code><code class="w"/>
<code class="w">  </code><code class="kt">int</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">1</code><code class="p">;</code><code class="w">                       </code><code class="c1">// An instance field</code><code class="w"/>
<code class="w">  </code><code class="kt">int</code><code class="w"> </code><code class="nf">f</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="n">i</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w">            </code><code class="c1">// An instance method</code><code class="w"/>
<code class="w">  </code><code class="kd">static</code><code class="w"> </code><code class="kt">char</code><code class="w"> </code><code class="nf">g</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="sc">'A'</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w">  </code><code class="c1">// A class method</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">class</code> <code class="nc">B</code><code class="w"> </code><code class="kd">extends</code><code class="w"> </code><code class="n">A</code><code class="w"> </code><code class="p">{</code><code class="w">                </code><code class="c1">// Define a subclass of A</code><code class="w"/>
<code class="w">  </code><code class="kt">int</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">2</code><code class="p">;</code><code class="w">                       </code><code class="c1">// Hides field i in class A</code><code class="w"/>
<code class="w">  </code><code class="kt">int</code><code class="w"> </code><code class="nf">f</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="o">-</code><code class="n">i</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w">           </code><code class="c1">// Overrides method f in class A</code><code class="w"/>
<code class="w">  </code><code class="kd">static</code><code class="w"> </code><code class="kt">char</code><code class="w"> </code><code class="nf">g</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="sc">'B'</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w">  </code><code class="c1">// Hides class method g() in class A</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">public</code><code class="w"> </code><code class="kd">class</code> <code class="nc">OverrideTest</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="kd">public</code><code class="w"> </code><code class="kd">static</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">main</code><code class="p">(</code><code class="n">String</code><code class="w"> </code><code class="n">args</code><code class="o">[]</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">B</code><code class="w"> </code><code class="n">b</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">B</code><code class="p">();</code><code class="w">               </code><code class="c1">// Creates a new object of type B</code><code class="w"/>
<code class="w">    </code><code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="n">b</code><code class="p">.</code><code class="na">i</code><code class="p">);</code><code class="w">     </code><code class="c1">// Refers to B.i; prints 2</code><code class="w"/>
<code class="w">    </code><code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="n">b</code><code class="p">.</code><code class="na">f</code><code class="p">());</code><code class="w">   </code><code class="c1">// Refers to B.f(); prints -2</code><code class="w"/>
<code class="w">    </code><code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="n">b</code><code class="p">.</code><code class="na">g</code><code class="p">());</code><code class="w">   </code><code class="c1">// Refers to B.g(); prints B</code><code class="w"/>
<code class="w">    </code><code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="n">B</code><code class="p">.</code><code class="na">g</code><code class="p">());</code><code class="w">   </code><code class="c1">// A better way to invoke B.g()</code><code class="w"/>

<code class="w">    </code><code class="n">A</code><code class="w"> </code><code class="n">a</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">(</code><code class="n">A</code><code class="p">)</code><code class="w"> </code><code class="n">b</code><code class="p">;</code><code class="w">                 </code><code class="c1">// Casts b to an instance of class A</code><code class="w"/>
<code class="w">    </code><code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="n">a</code><code class="p">.</code><code class="na">i</code><code class="p">);</code><code class="w">     </code><code class="c1">// Now refers to A.i; prints 1</code><code class="w"/>
<code class="w">    </code><code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="n">a</code><code class="p">.</code><code class="na">f</code><code class="p">());</code><code class="w">   </code><code class="c1">// Still refers to B.f(); prints -2</code><code class="w"/>
<code class="w">    </code><code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="n">a</code><code class="p">.</code><code class="na">g</code><code class="p">());</code><code class="w">   </code><code class="c1">// Refers to A.g(); prints A</code><code class="w"/>
<code class="w">    </code><code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="n">A</code><code class="p">.</code><code class="na">g</code><code class="p">());</code><code class="w">   </code><code class="c1">// A better way to invoke A.g()</code><code class="w"/>
<code class="w">  </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>While this difference between method overriding and field hiding may
seem surprising at first, a little thought makes the purpose clear.</p>
<p>Suppose we are manipulating a bunch of <code>Car</code> and <code>SportsCar</code> objects and store them in an array of type <code>Car[]</code>. We can do this because <code>SportsCar</code> is a subclass of <code>Car</code>, so all <code>SportsCar</code> objects are legal <code>Car</code> objects.</p>
<p>When we loop through the elements of this array, we don’t have to know or care whether the element is actually a <code>Car</code> or a <code>SportsCar</code>.
What we do care about very much, however, is that the correct value is computed when we invoke the <code>range()</code> method of any element of the array.
In other words, we don’t want to use the formula for the range of a car when the object is actually a sports car!</p>
<p>All we really want is for the objects we’re computing the ranges of to “do the right thing”—the <code>Car</code> objects to use their definition of how to compute their own range, and the <code>SportsCar</code> objects to use the definition that is correct for them.</p>
<p>Seen in this context, it is not surprising that Java handles method overriding differently than field hiding.</p>
</div></section>
<section data-pdf-bookmark="Virtual method lookup" data-type="sect3"><div class="sect3" id="idm45927745238848">
<h3>Virtual method lookup</h3>
<p>If we have a <code>Car[]</code> array that holds <code>Car</code> and <code>SportsCar</code> objects, how does <code>javac</code> know whether to call the <code>range()</code> method of the <code>Car</code> class or the <code>SportsCar</code> class for any given item in the array?
In fact, the source code compiler cannot know this at compilation time.</p>
<p>Instead, <code>javac</code> creates bytecode that uses <em>virtual</em> method lookup at runtime. When the interpreter runs the code, it looks up the appropriate <code>range()</code> method to call for each of the objects in the array.
That is, when the interpreter interprets the expression <code>o.range()</code>, it checks the actual runtime type of the object referred to by the variable <code>o</code> and then finds the <code>range()</code> method that is appropriate for that type.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><a data-primary="C/C++" data-secondary="virtual keyword" data-type="indexterm" id="idm45927745229760"/>Some other languages (such as C# or C++) do not do virtual lookup by default and instead have a <code>virtual</code> keyword that programmers must explicitly use if they want subclasses to be able to override a method.</p>
</div>
<p>This is another way of approaching the concept of method overriding, which we discussed earlier. If the version of the <code>range()</code> method associated with the static type of <code>o</code> was used, without the runtime (aka virtual) lookup, then overriding would not work properly.</p>
<p>Virtual method lookup is the default for Java instance methods.
See <a data-type="xref" href="ch04.xhtml#javanut8-CHP-4">Chapter 4</a> for more details about compile-time and runtime types and how they affect virtual method lookup.</p>
</div></section>
<section data-pdf-bookmark="Invoking an overridden method" data-type="sect3"><div class="sect3" id="idm45927745224944">
<h3>Invoking an overridden method</h3>
<p><a data-primary="methods" data-secondary="invoking an overridden method" data-type="indexterm" id="ix_ch03-asciidoc21"/><a data-primary="overriding" data-secondary="invoking an overridden method" data-type="indexterm" id="ix_ch03-asciidoc22"/><a data-primary="super keyword" data-secondary="invoking an overridden method" data-type="indexterm" id="ix_ch03-asciidoc23"/>We’ve seen the important differences between method overriding and
field hiding. Nevertheless, the Java syntax for invoking an overridden
method is quite similar to the syntax for accessing a hidden field: both
use the <code>super</code> keyword. The following code illustrates:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">class</code> <code class="nc">A</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="kt">int</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">1</code><code class="p">;</code><code class="w">            </code><code class="c1">// An instance field hidden by subclass B</code><code class="w"/>
<code class="w">  </code><code class="kt">int</code><code class="w"> </code><code class="nf">f</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="n">i</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w"> </code><code class="c1">// An instance method overridden by subclass B</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">class</code> <code class="nc">B</code><code class="w"> </code><code class="kd">extends</code><code class="w"> </code><code class="n">A</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="kt">int</code><code class="w"> </code><code class="n">i</code><code class="p">;</code><code class="w">                    </code><code class="c1">// This field hides i in A</code><code class="w"/>
<code class="w">  </code><code class="kt">int</code><code class="w"> </code><code class="nf">f</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w">                 </code><code class="c1">// This method overrides f() in A</code><code class="w"/>
<code class="w">    </code><code class="n">i</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="kd">super</code><code class="p">.</code><code class="na">i</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="mi">1</code><code class="p">;</code><code class="w">        </code><code class="c1">// It can retrieve A.i like this</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="kd">super</code><code class="p">.</code><code class="na">f</code><code class="p">()</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">i</code><code class="p">;</code><code class="w">   </code><code class="c1">// It can invoke A.f() like this</code><code class="w"/>
<code class="w">  </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>Recall that when you use <code>super</code> to refer to a hidden field, it is the
same as casting <code>this</code> to the superclass type and accessing the field
through it. Using <code>super</code> to invoke an overridden method, however, is
not the same as casting the <code>this</code> reference. In other words, in the
previous code, the expression <code>super.f()</code> is not the same as
<code>((A)this).f()</code>.</p>
<p>When the interpreter invokes an instance method with the <code>super</code> syntax,
a modified form of virtual method lookup is performed. The first step,
as in regular virtual method lookup, is to determine the actual class of
the object through which the method is invoked. Normally, the runtime
search for an appropriate method definition would begin with this class.
When a method is invoked with the <code>super</code> syntax, however, the search
begins at the superclass of the class. If the superclass implements the
method directly, that version of the method is invoked. If the
superclass inherits the method, the inherited version of the method is
invoked.</p>
<p>Note that the <code>super</code> keyword invokes the most immediately overridden
version of a method. Suppose class <code>A</code> has a subclass <code>B</code> that has a
subclass <code>C</code> and that all three classes define the same method <code>f()</code>.
The method <code>C.f()</code> can invoke the method <code>B.f()</code>, which it overrides
directly, with <code>super.f()</code>. But there is no way for <code>C.f()</code> to invoke
<code>A.f()</code> directly: <code>super.super.f()</code> is not legal Java syntax. Of
course, if <code>C.f()</code> invokes <code>B.f()</code>, it is reasonable to suppose that
<code>B.f()</code> might also invoke <code>A.f()</code>.</p>
<p>This kind of chaining is relatively common with overridden
methods: it is a way of augmenting the behavior of a method without
replacing the method entirely.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><a data-primary="super keyword" data-secondary="super() vs." data-type="indexterm" id="idm45927745132208"/><a data-primary="super()" data-type="indexterm" id="idm45927745131232"/>Don’t confuse the use of <code>super</code> to invoke an overridden method with the
<code>super()</code> method call used in a constructor to invoke a superclass
constructor. Although they both use the same keyword, these are two
entirely different syntaxes. In particular, you can use <code>super</code> to
invoke an overridden method anywhere in the overriding class, while you
can use <code>super()</code> only to invoke a superclass constructor as the very
first statement of a constructor.</p>
</div>
<p>It is also important to remember that <code>super</code> can be used only to invoke an overridden method from within the class that overrides it.
Given a reference to a <code>SportsCar</code> object <code>e</code>, there is no way for a program that uses <code>e</code> to invoke the <code>range()</code> method defined by the <code>Car</code> class on <code>e</code><a data-startref="ix_ch03-asciidoc23" data-type="indexterm" id="idm45927745044096"/><a data-startref="ix_ch03-asciidoc22" data-type="indexterm" id="idm45927745043392"/><a data-startref="ix_ch03-asciidoc21" data-type="indexterm" id="idm45927745042720"/>.<a data-startref="ix_ch03-asciidoc20" data-type="indexterm" id="idm45927745041920"/><a data-startref="ix_ch03-asciidoc19" data-type="indexterm" id="idm45927745041216"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Sealed Classes" data-type="sect2"><div class="sect2" id="idm45927746057568">
<h2>Sealed Classes</h2>
<p><a data-primary="class(es)" data-secondary="sealed" data-type="indexterm" id="idm45927745039232"/><a data-primary="sealed classes" data-type="indexterm" id="idm45927745038224"/>Until this point, we have only encountered two possibilities for class inheritance:</p>
<ul>
<li>
<p>Unrestricted ability to subclass (which is the default and has no keyword associated with it)</p>
</li>
<li>
<p>Complete prevention of subclassing with the <code>final</code> keyword applied to a class</p>
</li>
</ul>
<p><a data-primary="Java 17" data-secondary="sealed classes" data-type="indexterm" id="idm45927745034080"/><a data-primary="sealed keyword" data-type="indexterm" id="idm45927745032880"/>As of Java 17, there is a third possibility, which is controlled by the <code>sealed</code> keyword.
A <em>sealed class</em> is one that can be subclassed but only by a specific list of known classes.
<a data-primary="permits keyword" data-type="indexterm" id="idm45927745031248"/>This is done by using the <code>permits</code> keyword to enumerate the list of possible subclasses (which must all be in the same package as the base class) upfront, when the sealed class is declared. Like this:</p>
<pre data-code-language="java" data-type="programlisting"><code class="c1">// In Shape.java</code><code class="w"/>
<code class="kd">public</code><code class="w"> </code><code class="kd">abstract</code><code class="w"> </code><code class="kd">sealed</code><code class="w"> </code><code class="kd">class</code> <code class="nc">Shape</code><code class="w"> </code><code class="n">permits</code><code class="w"> </code><code class="n">Circle</code><code class="p">,</code><code class="w"> </code><code class="n">Triangle</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="c1">// ...</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="c1">// In Circle.java</code><code class="w"/>
<code class="kd">public</code><code class="w"> </code><code class="kd">final</code><code class="w"> </code><code class="kd">class</code> <code class="nc">Circle</code><code class="w"> </code><code class="kd">extends</code><code class="w"> </code><code class="n">Shape</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="c1">// ...</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="c1">// In Triangle.java</code><code class="w"/>
<code class="kd">public</code><code class="w"> </code><code class="kd">final</code><code class="w"> </code><code class="kd">class</code> <code class="nc">Triangle</code><code class="w"> </code><code class="kd">extends</code><code class="w"> </code><code class="n">Shape</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="c1">// ...</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>In this example, we have declared both  <code>Circle</code> and <code>Triangle</code> as <code>final</code>, so they cannot be further subclassed. This is the usual approach, but it is also possible to declare a subtype of a sealed class as either <code>sealed</code> (with a further set of permitted subclasses), or as <code>non-sealed</code>, which restores the default Java behavior of unrestricted subclassing.</p>
<p>This last option (<code>non-sealed</code>) should not be used without a very good reason, as it undermines much of the semantic point of using class sealing in the first place. For this reason, it is a compile-time error to try to subclass a sealed class without providing one of the three sealing modifiers: there is no default behavior here.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The introduction of <code>non-sealed</code> is the first example of a <em>hyphenated keyword</em> that’s been seen in Java.</p>
</div>
<p>In this example we’ve used an abstract sealed base class (<code>Shape</code>). This is not always necessary but it is often a good practice, as it means that any instances of the type that we encounter are known to be one of the “leaf types,” such as <code>Circle</code> or <code>Triangle</code>. We will meet abstract classes properly later in the chapter.</p>
<p>Although sealed classes are new with Java 17, we expect that many developers will adopt them quickly—along with records, they represent a “missing concept” that fits very naturally into Java’s view of OO. We will have more to say about this in <a data-type="xref" href="ch05.xhtml#javanut8-CHP-5">Chapter 5</a> when we discuss aspects of object-oriented design related to sealed types.<a data-startref="ix_ch03-asciidoc14" data-type="indexterm" id="idm45927744963040"/><a data-startref="ix_ch03-asciidoc13" data-type="indexterm" id="idm45927744962368"/><a data-startref="ix_ch03-asciidoc12" data-type="indexterm" id="idm45927744922880"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Data Hiding and Encapsulation" data-type="sect1"><div class="sect1" id="javanut8-CHP-3-SECT-5">
<h1>Data Hiding and Encapsulation</h1>
<p><a data-primary="encapsulation" data-type="indexterm" id="ix_ch03-asciidoc24"/><a data-primary="object-oriented programming" data-secondary="data hiding and encapsulation" data-type="indexterm" id="ix_ch03-asciidoc25"/>We started this chapter by describing a class as a collection of data and methods. One of the most important object-oriented techniques we haven’t discussed so far is hiding the data within the class and making it available only through the methods.</p>
<p>This technique is known as <em>encapsulation</em> because it contains the data (and internal methods) safely inside the “capsule” of the class, where it can be accessed only by trusted users (i.e., the methods of the class).</p>
<p>Why would you want to do this? The most important reason is to hide the
internal implementation details of your class. If you prevent
programmers from relying on those details, you can safely modify the
implementation without worrying that you will break existing code that
uses the class.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>You should always encapsulate your code. It is almost always impossible
to reason through and ensure the correctness of code that hasn’t been
well-encapsulated, especially in multithreaded environments (and
essentially all Java programs are multithreaded).</p>
</div>
<p>Another reason for encapsulation is to protect your class against
accidental or willful stupidity. A class often contains a number of
interdependent fields that must be in a consistent state. If you allow programmers (including yourself) to manipulate those fields directly, they
may change one field without changing important related fields, leaving
the class in an inconsistent state. If instead the programmer has to call a method
to change the field, that method can be sure to do everything necessary
to keep the state consistent. Similarly, if a class defines certain
methods for internal use only, hiding these methods prevents users of
the class from calling them.</p>
<p>Here’s another way to think about encapsulation: when all the data for a
class is hidden, the methods define the only possible operations that
can be performed on objects of that class.</p>
<p>Once you have carefully tested and debugged your methods, you can be
confident that the class will work as expected. On the other hand, if
all the fields of the class can be directly manipulated, the number of
possibilities you have to test becomes unmanageable.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>This idea can be carried to a very powerful conclusion, as we will see
in <a data-type="xref" href="ch05.xhtml#javanut8-CHP-5-SECT-safe-programming">“Safe Java Programming”</a> when we discuss the <em>safety</em>
of Java programs (which differs from the concept of <em>type safety</em> of the
Java programming language).</p>
</div>
<p>Other, secondary, reasons to hide fields and methods of a class include:</p>
<ul>
<li>
<p>Internal fields and methods that are visible outside the class just
clutter up the API. Keeping visible fields to a minimum keeps your class
tidy and therefore easier to use and understand.</p>
</li>
<li>
<p>If a method is visible to the users of your class, you have to
document it. Save yourself time and effort by hiding it instead.</p>
</li>
</ul>
<section data-pdf-bookmark="Access Control" data-type="sect2"><div class="sect2" id="idm45927744909712">
<h2>Access Control</h2>
<p><a data-primary="access control" data-type="indexterm" id="ix_ch03-asciidoc26"/><a data-primary="encapsulation" data-secondary="access control" data-type="indexterm" id="ix_ch03-asciidoc27"/>Java defines access control rules that can restrict members of a class
from being used outside the class. In a number of examples in this
chapter, you’ve seen the <code>public</code> modifier used in field and method
declarations. This <code>public</code> keyword, along with <code>protected</code> and
<code>private</code> (and one other, special one) are <em>access</em> <em>control</em>
<em>modifiers</em>; they specify the access rules for the field or method.</p>
<section data-pdf-bookmark="Access to modules" data-type="sect3"><div class="sect3" id="idm45927744902656">
<h3>Access to modules</h3>
<p><a data-primary="access control" data-secondary="for modules" data-secondary-sortas="modules" data-type="indexterm" id="idm45927744901456"/><a data-primary="Java 9" data-primary-sortas="Java 09" data-secondary="platform modules" data-type="indexterm" id="idm45927744900208"/><a data-primary="modules" data-secondary="access control" data-type="indexterm" id="idm45927744898992"/>One of the biggest changes in Java 9 was the arrival of Java platform modules.
These are a grouping of code that is larger than a single package and intended as the future way to deploy code for reuse.
As Java is often used in large applications and environments, the arrival of modules should make it easier to build and manage enterprise codebases.</p>
<p>The modules technology is an advanced topic, and if Java is one of the first programming languages you have encountered, you should not try to learn it until you have gained some language proficiency.
An introductory treatment of modules is provided in <a data-type="xref" href="ch12.xhtml#javanut8-CHP-12">Chapter 12</a>, and we defer discussing the access control impact of modules until then.</p>
</div></section>
<section data-pdf-bookmark="Access to packages" data-type="sect3"><div class="sect3" id="idm45927744896448">
<h3>Access to packages</h3>
<p><a data-primary="access control" data-secondary="for packages" data-secondary-sortas="packages" data-type="indexterm" id="idm45927744895280"/><a data-primary="package access" data-type="indexterm" id="idm45927744894032"/><a data-primary="packages" data-secondary="access control" data-type="indexterm" id="idm45927744893360"/>Access control on a per-package basis is not directly part of the core Java language and instead is provided by the modules mechanism. In the normal course of programming, access control is usually done at the level of classes and members of classes.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>A package that has been loaded is always accessible to code defined
within the same package. Whether it is accessible to code from other
packages depends on the way the package is deployed on the host system.
When the class files that comprise a package are stored in a directory,
for example, a user must have read access to the directory and the files
within it to have access to the package.</p>
</div>
</div></section>
<section data-pdf-bookmark="Access to classes" data-type="sect3"><div class="sect3" id="idm45927744890928">
<h3>Access to classes</h3>
<p><a data-primary="access control" data-secondary="for classes" data-secondary-sortas="classes" data-type="indexterm" id="idm45927744889728"/><a data-primary="class(es)" data-secondary="access control" data-type="indexterm" id="idm45927744888480"/>By default, top-level classes are accessible within the package in
which they are defined. However, if a top-level class is declared
<code>public</code>, it is accessible everywhere.</p>
<div data-type="tip"><h6>Tip</h6>
<p>In <a data-type="xref" href="ch04.xhtml#javanut8-CHP-4">Chapter 4</a>, we’ll meet nested classes.
These are classes that can be defined as members of other classes.
Because these inner classes are members of a class, they obey the
member access-control rules.</p>
</div>
</div></section>
<section data-pdf-bookmark="Access to members" data-type="sect3"><div class="sect3" id="idm45927744884768">
<h3>Access to members</h3>
<p><a data-primary="access control" data-secondary="for members of a class" data-secondary-sortas="members of a class" data-type="indexterm" id="idm45927744883264"/><a data-primary="members of a class" data-type="indexterm" id="idm45927744882016"/>The members of a class are always accessible within the body of the
class. By default, members are also accessible throughout the package in
which the class is defined. This default level of access is often
called <em>package access</em>.</p>
<p>It is one of four possible levels of
access. The other three levels are defined by the <code>public</code>, <span class="keep-together"><code>protected</code></span>,
and <code>private</code> modifiers. Here is some example code that uses these
modifiers:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code><code class="w"> </code><code class="kd">class</code> <code class="nc">Laundromat</code><code class="w"> </code><code class="p">{</code><code class="w">    </code><code class="c1">// People can use this class.</code><code class="w"/>
<code class="w">  </code><code class="kd">private</code><code class="w"> </code><code class="n">Laundry</code><code class="o">[]</code><code class="w"> </code><code class="n">dirty</code><code class="p">;</code><code class="w">   </code><code class="c1">// They cannot use this internal field,</code><code class="w"/>
<code class="w">  </code><code class="kd">public</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">wash</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="p">...</code><code class="w"> </code><code class="p">}</code><code class="w"> </code><code class="c1">// but they can use these public methods</code><code class="w"/>
<code class="w">  </code><code class="kd">public</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">dry</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="p">...</code><code class="w"> </code><code class="p">}</code><code class="w">  </code><code class="c1">// to manipulate the internal field.</code><code class="w"/>
<code class="w">  </code><code class="c1">// A subclass might want to tweak this field</code><code class="w"/>
<code class="w">  </code><code class="kd">protected</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="n">temperature</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>These access rules apply to members of a class:</p>
<ul>
<li>
<p>All the fields and methods of a class can always be used within the
body of the class itself.</p>
</li>
<li>
<p><a data-primary="public modifier" data-type="indexterm" id="idm45927744822736"/>If a member of a class is declared with the <code>public</code> modifier, it
means that the member is accessible anywhere the containing class is
accessible. This is the least restrictive type of access control.</p>
</li>
<li>
<p><a data-primary="private modifier" data-type="indexterm" id="idm45927744786528"/>If a member of a class is declared <code>private</code>, the member is never
accessible, except within the class itself. This is the most restrictive
type of access control.</p>
</li>
<li>
<p><a data-primary="protected access" data-type="indexterm" id="idm45927744784448"/>If a member of a class is declared <code>protected</code>, it is accessible to
all classes within the package (the same as the default package
accessibility) and also accessible within the body of any subclass of
the class, regardless of the package in which that subclass is defined.</p>
</li>
<li>
<p><a data-primary="default access" data-type="indexterm" id="idm45927744782496"/>If a member of a class is not declared with any of these modifiers, it
has <em>default</em> access (sometimes called <em>package</em> access), and it is
accessible to code within all classes that are defined in the same
package but inaccessible outside of the package.</p>
</li>
</ul>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>Default access is <em>more</em> restrictive than <code>protected</code>—as default access
does not allow access by subclasses outside the package.</p>
</div>
<p><code>protected</code> access requires more elaboration. Suppose class <code>A</code> declares
a <code>protected</code> field <code>x</code> and is extended by a class <code>B</code>, which is defined
in a different package (this last point is important). Class <code>B</code>
inherits the <code>protected</code> field <code>x</code>, and its code can access that field
in the current instance of <code>B</code> or in any other instances of <code>B</code> that the
code can refer to. This does not mean, however, that the code of class
<code>B</code> can start reading the protected fields of arbitrary instances of
<code>A</code>.</p>
<p>Let’s look at this language detail in code. Here’s the definition for
<code>A</code>:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kn">package</code><code class="w"> </code><code class="nn">javanut8.ch03</code><code class="p">;</code><code class="w"/>

<code class="kd">public</code><code class="w"> </code><code class="kd">class</code> <code class="nc">A</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">protected</code><code class="w"> </code><code class="kd">final</code><code class="w"> </code><code class="n">String</code><code class="w"> </code><code class="n">name</code><code class="p">;</code><code class="w"/>

<code class="w">    </code><code class="kd">public</code><code class="w"> </code><code class="nf">A</code><code class="p">(</code><code class="n">String</code><code class="w"> </code><code class="n">named</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="n">name</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">named</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>

<code class="w">    </code><code class="kd">public</code><code class="w"> </code><code class="n">String</code><code class="w"> </code><code class="nf">getName</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="n">name</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>Here’s the definition for <code>B</code>:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kn">package</code><code class="w"> </code><code class="nn">javanut8.ch03.different</code><code class="p">;</code><code class="w"/>

<code class="kn">import</code><code class="w"> </code><code class="nn">javanut8.ch03.A</code><code class="p">;</code><code class="w"/>

<code class="kd">public</code><code class="w"> </code><code class="kd">class</code> <code class="nc">B</code><code class="w"> </code><code class="kd">extends</code><code class="w"> </code><code class="n">A</code><code class="w"> </code><code class="p">{</code><code class="w"/>

<code class="w">    </code><code class="kd">public</code><code class="w"> </code><code class="nf">B</code><code class="p">(</code><code class="n">String</code><code class="w"> </code><code class="n">named</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="kd">super</code><code class="p">(</code><code class="n">named</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>

<code class="w">    </code><code class="nd">@Override</code><code class="w"/>
<code class="w">    </code><code class="kd">public</code><code class="w"> </code><code class="n">String</code><code class="w"> </code><code class="nf">getName</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="s">"B: "</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">name</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Java packages do not “nest,” so <code>javanut8.ch03.different</code> is just a
different package than <code>javanut8.ch03</code>; it is not contained inside it or
related to it in any way.</p>
</div>
<p>However, if we try to add this new method to <code>B</code>, we will get a
compilation error, because instances of <code>B</code> do not have access to
arbitary instances of <code>A</code>:</p>
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="kd">public</code><code class="w"> </code><code class="n">String</code><code class="w"> </code><code class="nf">examine</code><code class="p">(</code><code class="n">A</code><code class="w"> </code><code class="n">a</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="s">"B sees: "</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">a</code><code class="p">.</code><code class="na">name</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/></pre>
<p>If we change the method to this:</p>
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="kd">public</code><code class="w"> </code><code class="n">String</code><code class="w"> </code><code class="nf">examine</code><code class="p">(</code><code class="n">B</code><code class="w"> </code><code class="n">b</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="s">"B sees another B: "</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">b</code><code class="p">.</code><code class="na">name</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/></pre>
<p>then the compiler is happy, because instances of the same exact type can
always see each other’s <code>protected</code> fields. Of course, if <code>B</code> was in the
same package as <code>A,</code> then any instance of <code>B</code> could read any protected
field of any instance of <code>A</code> because <code>protected</code> fields are visible to
every class in the same package.</p>
</div></section>
<section data-pdf-bookmark="Access control and inheritance" data-type="sect3"><div class="sect3" id="idm45927744884176">
<h3>Access control and inheritance</h3>
<p><a data-primary="access control" data-secondary="inheritance and" data-type="indexterm" id="idm45927744452400"/><a data-primary="inheritance" data-secondary="access control and" data-type="indexterm" id="idm45927744451424"/>The Java specification states that:</p>
<ul>
<li>
<p>A subclass inherits all the instance fields and instance methods of
its superclass accessible to it.</p>
</li>
<li>
<p>If the subclass is defined in the same package as the superclass, it
inherits all non-<code>private</code> instance fields and methods.</p>
</li>
<li>
<p>If the subclass is defined in a different package, it inherits all
<code>protected</code> and <code>public</code> instance fields and methods.</p>
</li>
<li>
<p><code>private</code> fields and methods are never inherited; neither are class
fields or class methods.</p>
</li>
<li>
<p>Constructors are not inherited (instead, they are chained, as
described earlier in this chapter).</p>
</li>
</ul>
<p><a data-primary="subclasses" data-secondary="access control" data-type="indexterm" id="idm45927744440032"/>However, some programmers are confused by the statement that a subclass
does not inherit the inaccessible fields and methods of its superclass. Let us be explicit: Every instance
of a subclass includes a complete instance of the superclass within it, including all private fields and
methods. When you create an instance of a subclass, memory is allocated for all <code>private</code> fields defined by the
superclass; however, the subclass does not have access to these fields directly.</p>
<p>This existence of potentially inaccessible members seems to be in
conflict with the statement that the members of a class are always
accessible within the body of the class. To clear up this confusion, we
define “inherited members” to mean those superclass members that are
accessible.</p>
<p>Then the correct statement about member accessibility is: “All inherited
members and all members defined in this class are accessible.” An
alternative way of saying this is:</p>
<ul>
<li>
<p>A class inherits <em>all</em> instance fields and instance methods (but not
constructors) of its superclass.</p>
</li>
<li>
<p>The body of a class can always access all the fields and methods it
declares itself. It can also access the <em>accessible</em> fields and members
it inherits from its superclass.</p>
</li>
</ul>
</div></section>
<section data-pdf-bookmark="Member access summary" data-type="sect3"><div class="sect3" id="idm45927744434272">
<h3>Member access summary</h3>
<p>We summarize the member access rules in
<a data-type="xref" href="#javanut8-CHP-3-TABLE-1">Table 3-1</a>.</p>
<table id="javanut8-CHP-3-TABLE-1">
<caption><span class="label">Table 3-1. </span>Class member accessibility</caption>
<thead>
<tr>
<th> </th>
<th>Member visibility</th>
<th> </th>
<th> </th>
<th> </th>
</tr>
<tr>
<th>Accessible to</th>
<th>Public</th>
<th>Protected</th>
<th>Default</th>
<th>Private</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<p>Defining class</p>
</td>
<td>
<p>Yes</p>
</td>
<td>
<p>Yes</p>
</td>
<td>
<p>Yes</p>
</td>
<td>
<p>Yes</p>
</td>
</tr>
<tr>
<td>
<p>Class in same package</p>
</td>
<td>
<p>Yes</p>
</td>
<td>
<p>Yes</p>
</td>
<td>
<p>Yes</p>
</td>
<td>
<p>No</p>
</td>
</tr>
<tr>
<td>
<p>Subclass in different package</p>
</td>
<td>
<p>Yes</p>
</td>
<td>
<p>Yes</p>
</td>
<td>
<p>No</p>
</td>
<td>
<p>No</p>
</td>
</tr>
<tr>
<td>
<p>Nonsubclass different package</p>
</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td>No</td>
</tr>
</tbody>
</table>
<p>There are a few generally observed rules about what parts of a Java program should use each visibility modifier. It is important that even beginning Java programmers follow these rules:</p>
<ul>
<li>
<p><a data-primary="public modifier" data-secondary="rules governing" data-type="indexterm" id="idm45927744404784"/>Use <code>public</code> only for methods and constants that form part of the
public API of the class. The only acceptable usage of <code>public</code> fields is
for constants or immutable objects, and they must be also declared
<code>final</code>.</p>
</li>
<li>
<p><a data-primary="protected modifier" data-secondary="rules governing" data-type="indexterm" id="idm45927744401440"/>Use <code>protected</code> for fields and methods that aren’t required by most
programmers using the class but that may be of interest to anyone
creating a subclass as part of a different package.</p>
</li>
</ul>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><code>protected</code> members are technically part of the exported API of a class.
They must be documented and cannot be changed without potentially
breaking code that relies on them.</p>
</div>
<ul>
<li>
<p>Use the default package visibility for fields and methods that are
internal implementation details but are used by cooperating classes in
the same package.</p>
</li>
<li>
<p><a data-primary="private modifier" data-secondary="rules governing" data-type="indexterm" id="idm45927744396256"/>Use <code>private</code> for fields and methods that are used only inside the
class and should be hidden everywhere else.</p>
</li>
</ul>
<p>If you are not sure whether to use <code>protected</code>, package, or <code>private</code>
accessibility, start with <code>private</code>. If this is overly restrictive, you
can always relax the access restrictions slightly (or provide accessor
methods, in the case of fields).</p>
<p>This is especially important for designing APIs because increasing
access restrictions is not a backward-compatible change and can break
code that relies on access to those members.<a data-startref="ix_ch03-asciidoc27" data-type="indexterm" id="idm45927744391904"/><a data-startref="ix_ch03-asciidoc26" data-type="indexterm" id="idm45927744391200"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Data Accessor Methods" data-type="sect2"><div class="sect2" id="idm45927744390144">
<h2>Data Accessor Methods</h2>
<p><a data-primary="access control" data-secondary="data accessor methods" data-type="indexterm" id="ix_ch03-asciidoc28"/><a data-primary="encapsulation" data-secondary="data accessor methods" data-type="indexterm" id="ix_ch03-asciidoc29"/><a data-primary="methods" data-secondary="data accessor methods" data-type="indexterm" id="ix_ch03-asciidoc30"/>In the <code>Circle</code> example, we declared the circle radius to be a <code>public</code>
field. The <span class="keep-together"><code>Circle</code></span> class is one in which it may be reasonable to
keep that field publicly accessible; it is a simple enough class, with
no dependencies between its fields. On the other hand, our current
implementation of the class allows a <code>Circle</code> object to have a negative
radius, and circles with negative radii simply should not exist. As long
as the radius is stored in a <code>public</code> field, however, any programmer can
set the field to any value they want, no matter how unreasonable. The
only solution is to restrict the programmer’s direct access to the field
and define <code>public</code> methods that provide indirect access to the field.
Providing <code>public</code> methods to read and write a field is not the same as
making the field itself <code>public</code>. The crucial difference is that methods
can perform error checking.</p>
<p>We might, for example, want to prevent <code>Circle</code> objects with negative
radii—these are obviously not sensible, but our current implementation
does not prohibit this. In <a data-type="xref" href="#javanut8-CHP-3-EX-4">Example 3-4</a>, we
show how we might change the definition of <code>Circle</code> to prevent this.</p>
<p>This version of <code>Circle</code> declares the <code>r</code> field to be <code>protected</code> and
defines accessor methods named <code>getRadius()</code> and <code>setRadius()</code> to read
and write the field value while enforcing the restriction on negative
radius values. Because the <code>r</code> field is <span class="keep-together"><code>protected</code></span>, it is directly (and
more efficiently) accessible to subclasses.</p>
<div data-type="example" id="javanut8-CHP-3-EX-4">
<h5><span class="label">Example 3-4. </span>The Circle class using data hiding and encapsulation</h5>
<pre data-code-language="java" data-type="programlisting"><code class="kn">package</code><code class="w"> </code><code class="nn">javanut8.ch03.shapes</code><code class="p">;</code><code class="w"> </code><code class="c1">// Specify a package for the class</code><code class="w"/>

<code class="kd">public</code><code class="w"> </code><code class="kd">class</code> <code class="nc">Circle</code><code class="w"> </code><code class="p">{</code><code class="w">     </code><code class="c1">// The class is still public</code><code class="w"/>
<code class="w">    </code><code class="c1">// This is a generally useful constant, so we keep it public</code><code class="w"/>
<code class="w">    </code><code class="kd">public</code><code class="w"> </code><code class="kd">static</code><code class="w"> </code><code class="kd">final</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="n">PI</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mf">3.14159</code><code class="p">;</code><code class="w"/>

<code class="w">    </code><code class="kd">protected</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="n">r</code><code class="p">;</code><code class="w">     </code><code class="c1">// Radius is hidden but visible to subclasses</code><code class="w"/>

<code class="w">    </code><code class="c1">// A method to enforce the restriction on the radius</code><code class="w"/>
<code class="w">    </code><code class="c1">// Subclasses may be interested in this implementation detail</code><code class="w"/>
<code class="w">    </code><code class="kd">protected</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">checkRadius</code><code class="p">(</code><code class="kt">double</code><code class="w"> </code><code class="n">radius</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="n">radius</code><code class="w"> </code><code class="o">&lt;</code><code class="w"> </code><code class="mf">0.0</code><code class="p">)</code><code class="w"/>
<code class="w">            </code><code class="k">throw</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">IllegalArgumentException</code><code class="p">(</code><code class="s">"illegal negative radius"</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>

<code class="w">    </code><code class="c1">// The non-default constructor</code><code class="w"/>
<code class="w">    </code><code class="kd">public</code><code class="w"> </code><code class="nf">Circle</code><code class="p">(</code><code class="kt">double</code><code class="w"> </code><code class="n">r</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="n">checkRadius</code><code class="p">(</code><code class="n">r</code><code class="p">);</code><code class="w"/>
<code class="w">        </code><code class="k">this</code><code class="p">.</code><code class="na">r</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">r</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>

<code class="w">    </code><code class="c1">// Public data accessor methods</code><code class="w"/>
<code class="w">    </code><code class="kd">public</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="nf">getRadius</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="n">r</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="kd">public</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">setRadius</code><code class="p">(</code><code class="kt">double</code><code class="w"> </code><code class="n">r</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="n">checkRadius</code><code class="p">(</code><code class="n">r</code><code class="p">);</code><code class="w"/>
<code class="w">        </code><code class="k">this</code><code class="p">.</code><code class="na">r</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">r</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>

<code class="w">    </code><code class="c1">// Methods to operate on the instance field</code><code class="w"/>
<code class="w">    </code><code class="kd">public</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="nf">area</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="n">PI</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="n">r</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="n">r</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="kd">public</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="nf">circumference</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="mi">2</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="n">PI</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="n">r</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre></div>
<p>We have defined the <code>Circle</code> class within a package named <code>javanut8.ch03.shapes</code>; <code>r</code> is <code>protected</code> so any other classes in the <code>javanut8.ch03.shapes</code> package
have direct access to that field and can set it however they like. The
assumption here is that all classes within the <code>javanut8.ch03.shapes</code> package were
written by the same author or a closely cooperating group of authors, and
that the classes all trust each other not to abuse their privileged
level of access to each other’s implementation details.</p>
<p>Finally, the code that enforces the restriction against negative radius
values is itself placed within a <code>protected</code> method, <code>checkRadius()</code>.
Although users of the <code>Circle</code> class cannot call this method, subclasses
of the class can call it and even override it if they want to change the
restrictions on the radius.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>One set of common (but older) conventions in Java—known as Java Beans conventions—is that data accessor methods begin with
the prefixes “get” and “set.” But if the field being accessed is of type <code>boolean</code>, the <code>get()</code> method may be replaced with an equivalent method
that begins with “is”—the accessor method for a <code>boolean</code>
field named <code>readable</code> is typically called <code>isReadable()</code> instead of
<code>getReadable()</code><a data-startref="ix_ch03-asciidoc30" data-type="indexterm" id="idm45927744124992"/><a data-startref="ix_ch03-asciidoc29" data-type="indexterm" id="idm45927744124288"/><a data-startref="ix_ch03-asciidoc28" data-type="indexterm" id="idm45927744123616"/>.<a data-startref="ix_ch03-asciidoc25" data-type="indexterm" id="idm45927744122816"/><a data-startref="ix_ch03-asciidoc24" data-type="indexterm" id="idm45927744122112"/></p>
</div>
</div></section>
</div></section>
<section data-pdf-bookmark="Abstract Classes and Methods" data-type="sect1"><div class="sect1" id="javanut8-CHP-3-SECT-6">
<h1>Abstract Classes and Methods</h1>
<p><a data-primary="abstract classes" data-type="indexterm" id="ix_ch03-asciidoc31"/><a data-primary="abstract methods" data-type="indexterm" id="ix_ch03-asciidoc32"/><a data-primary="class(es)" data-secondary="abstract" data-type="indexterm" id="ix_ch03-asciidoc33"/><a data-primary="methods" data-secondary="abstract" data-type="indexterm" id="ix_ch03-asciidoc34"/><a data-primary="object-oriented programming" data-secondary="abstract classes and methods" data-type="indexterm" id="ix_ch03-asciidoc35"/>In <a data-type="xref" href="#javanut8-CHP-3-EX-4">Example 3-4</a>, we declared our <code>Circle</code>
class to be part of a package named <code>shapes</code>. Suppose we plan to
implement a number of shape classes: <code>Rectangle</code>, <code>Square</code>, <code>Hexagon</code>,
<code>Triangle</code>, and so on. We can give these shape classes our two basic
<code>area()</code> and <code>circumference()</code> methods. Now, to make it easy to work
with an array of shapes, it would be helpful if all our shape classes
had a common superclass, <code>Shape</code>. If we structure our class hierarchy
this way, every shape object, regardless of the actual type of shape it
represents, can be assigned to variables, fields, or array elements of
type <code>Shape</code>. We want the <code>Shape</code> class to encapsulate whatever features
all our shapes have in common (e.g., the <code>area()</code> and <code>circumference()</code>
methods). But our generic <code>Shape</code> class doesn’t represent any real kind
of shape, so it cannot define useful implementations of the methods.
Java handles this situation with <em>abstract methods</em>.</p>
<p>Java lets us define a method without implementing it by declaring the
method with the <code>abstract</code> modifier. An <code>abstract</code> method has no body;
it simply has a signature definition followed by a semicolon.<sup><a data-type="noteref" href="ch03.xhtml#idm45927744054480" id="idm45927744054480-marker">2</a></sup> Here are the rules about <code>abstract</code> methods and the
<code>abstract</code> classes that contain them:</p>
<ul>
<li>
<p>Any class with an <code>abstract</code> method is automatically <code>abstract</code> itself
and must be declared as such. To fail to do so is a compilation error.</p>
</li>
<li>
<p>An <code>abstract</code> class cannot be instantiated.</p>
</li>
<li>
<p>A subclass of an <code>abstract</code> class can be instantiated only if it
overrides each of the <code>abstract</code> methods of its superclass and provides
an implementation (i.e., a method body) for all of them. Such a class is
often called a <em>concrete</em> subclass, to emphasize the fact that it is not
<code>abstract</code>.</p>
</li>
<li>
<p>If a subclass of an <code>abstract</code> class does not implement all the
<code>abstract</code> methods it inherits, that subclass is itself <code>abstract</code> and
must be declared as such.</p>
</li>
<li>
<p><code>static</code>, <code>private</code>, and <code>final</code> methods cannot be <code>abstract</code>, because
these types of methods cannot be overridden by a subclass. Similarly, a
<code>final</code> class cannot contain any <code>abstract</code> methods.</p>
</li>
<li>
<p>A class can be declared <code>abstract</code> even if it does not actually have
any <code>abstract</code> methods. Declaring such a class <code>abstract</code> indicates that
the implementation is somehow incomplete and is meant to serve as a
superclass for one or more subclasses that complete the implementation.
Such a class cannot be <span class="keep-together">instantiated</span>.</p>
</li>
</ul>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The <code>ClassLoader</code> class that we will meet in
<a data-type="xref" href="ch11.xhtml#javanut8-CHP-11">Chapter 11</a> is a good example of an abstract class
that does not have any abstract methods.</p>
</div>
<p>Let’s look at an example of how these rules work. If we define the
<code>Shape</code> class to have <code>abstract</code> <code>area()</code> and <code>circumference()</code> methods,
any subclass of <code>Shape</code> is required to provide implementations of these
methods so that it can be instantiated. In other words, every <code>Shape</code>
object is guaranteed to have implementations of these methods defined.
<a data-type="xref" href="#javanut8-CHP-3-EX-5">Example 3-5</a> shows how this might work. It
defines an <code>abstract</code> <code>Shape</code> class and a concrete subclass of it. You should also imagine that the <code>Circle</code> class from <a data-type="xref" href="#javanut8-CHP-3-EX-4">Example 3-4</a> has been modified so that it <code>extends Shape</code>.</p>
<div data-type="example" id="javanut8-CHP-3-EX-5">
<h5><span class="label">Example 3-5. </span>An abstract class and concrete subclass</h5>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code><code class="w"> </code><code class="kd">abstract</code><code class="w"> </code><code class="kd">class</code> <code class="nc">Shape</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">public</code><code class="w"> </code><code class="kd">abstract</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="nf">area</code><code class="p">();</code><code class="w">            </code><code class="c1">// Abstract methods: note</code><code class="w"/>
<code class="w">    </code><code class="kd">public</code><code class="w"> </code><code class="kd">abstract</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="nf">circumference</code><code class="p">();</code><code class="w">   </code><code class="c1">// semicolon instead of body.</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">public</code><code class="w"> </code><code class="kd">class</code> <code class="nc">Rectangle</code><code class="w"> </code><code class="kd">extends</code><code class="w"> </code><code class="n">Shape</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="c1">// Instance data</code><code class="w"/>
<code class="w">    </code><code class="kd">protected</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="n">w</code><code class="p">,</code><code class="w"> </code><code class="n">h</code><code class="p">;</code><code class="w"/>

<code class="w">    </code><code class="c1">// Constructor                               </code><code class="w"/>
<code class="w">    </code><code class="kd">public</code><code class="w"> </code><code class="nf">Rectangle</code><code class="p">(</code><code class="kt">double</code><code class="w"> </code><code class="n">w</code><code class="p">,</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="n">h</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w">               </code>
<code class="w">        </code><code class="k">this</code><code class="p">.</code><code class="na">w</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">w</code><code class="p">;</code><code class="w">  </code><code class="k">this</code><code class="p">.</code><code class="na">h</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">h</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>

<code class="w">    </code><code class="c1">// Accessor methods</code><code class="w"/>
<code class="w">    </code><code class="kd">public</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="nf">getWidth</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="n">w</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w">               </code>
<code class="w">    </code><code class="kd">public</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="nf">getHeight</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="n">h</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w"/>

<code class="w">    </code><code class="c1">// Implementation of abstract methods             </code><code class="w"/>
<code class="w">    </code><code class="kd">public</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="nf">area</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="n">w</code><code class="o">*</code><code class="n">h</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w">                 </code>
<code class="w">    </code><code class="kd">public</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="nf">circumference</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="mi">2</code><code class="o">*</code><code class="p">(</code><code class="n">w</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">h</code><code class="p">);</code><code class="w"> </code><code class="p">}</code><code class="w">   </code>
<code class="p">}</code><code class="w"/></pre></div>
<p>Each <code>abstract</code> method in <code>Shape</code> has a semicolon right after its parentheses. Method declarations of this sort have no curly braces, and no method body is defined.</p>
<p>Note that we could have declared the class <code>Shape</code> as a sealed class, but we have deliberately chosen not to. This is so other programmers can define their own shape classes as new subclasses of <code>Shape</code>, should they wish to.</p>
<p>Using the classes defined in <a data-type="xref" href="#javanut8-CHP-3-EX-5">Example 3-5</a>, we
can now write code such as:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">Shape</code><code class="o">[]</code><code class="w"> </code><code class="n">shapes</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">Shape</code><code class="o">[</code><code class="mi">3</code><code class="o">]</code><code class="p">;</code><code class="w">        </code><code class="c1">// Create an array to hold shapes</code><code class="w"/>
<code class="n">shapes</code><code class="o">[</code><code class="mi">0</code><code class="o">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">Circle</code><code class="p">(</code><code class="mf">2.0</code><code class="p">);</code><code class="w">          </code><code class="c1">// Fill in the array</code><code class="w"/>
<code class="n">shapes</code><code class="o">[</code><code class="mi">1</code><code class="o">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">Rectangle</code><code class="p">(</code><code class="mf">1.0</code><code class="p">,</code><code class="w"> </code><code class="mf">3.0</code><code class="p">);</code><code class="w"/>
<code class="n">shapes</code><code class="o">[</code><code class="mi">2</code><code class="o">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">Rectangle</code><code class="p">(</code><code class="mf">4.0</code><code class="p">,</code><code class="w"> </code><code class="mf">2.0</code><code class="p">);</code><code class="w"/>

<code class="kt">double</code><code class="w"> </code><code class="n">totalArea</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"/>
<code class="k">for</code><code class="p">(</code><code class="kt">int</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="o">&lt;</code><code class="w"> </code><code class="n">shapes</code><code class="p">.</code><code class="na">length</code><code class="p">;</code><code class="w"> </code><code class="n">i</code><code class="o">++</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">totalArea</code><code class="w"> </code><code class="o">+=</code><code class="w"> </code><code class="n">shapes</code><code class="o">[</code><code class="n">i</code><code class="o">]</code><code class="p">.</code><code class="na">area</code><code class="p">();</code><code class="w">   </code><code class="c1">// Compute the area of the shapes</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>Notice two important points here:</p>
<ul>
<li>
<p>Subclasses of <code>Shape</code> can be assigned to elements of an array of
<code>Shape</code>. No cast is necessary. This is another example of a widening
reference type conversion (discussed in <a data-type="xref" href="ch02.xhtml#javanut8-CHP-2">Chapter 2</a>).</p>
</li>
<li>
<p>You can invoke the <code>area()</code> and <code>circumference()</code> methods for any
<code>Shape</code> object, even though the <code>Shape</code> class does not define a body for
these methods. When you do this, the method to be invoked is found using
virtual lookup, which we met earlier.
In our case, this means that the area of a circle is computed using the method defined by <code>Circle</code>, and the area of a rectangle is computed using the method defined by <code>Rectangle</code>.</p>
</li>
</ul>
<section data-pdf-bookmark="Reference Type Conversions" data-type="sect2"><div class="sect2" id="javanut8-CHP-3-SECT-6.1">
<h2>Reference Type Conversions</h2>
<p><a data-primary="conversions" data-secondary="reference types" data-type="indexterm" id="ix_ch03-asciidoc36"/><a data-primary="object references" data-type="indexterm" id="ix_ch03-asciidoc37"/><a data-primary="reference types" data-secondary="conversions" data-type="indexterm" id="ix_ch03-asciidoc38"/>Object references can be converted between different reference types. As with primitive types, reference type conversions can be widening conversions
(allowed automatically by the compiler) or narrowing conversions that
require a cast (and possibly a runtime check). <a data-primary="class hierarchy" data-type="indexterm" id="idm45927743610080"/>In order to understand
reference type conversions, you need to understand that reference types
form a hierarchy, usually called the <em>class hierarchy</em>.</p>
<p><a data-primary="superclasses" data-secondary="reference type conversions" data-type="indexterm" id="idm45927743608704"/>Every Java reference type <em>extends</em> some other type, known as its
<em>superclass</em>. A type inherits the fields and methods of its superclass
and then defines its own additional fields and methods. <a data-primary="Object class" data-type="indexterm" id="idm45927743606496"/>A special class named <code>Object</code> serves as the root of the class hierarchy in Java. All
Java classes extend <code>Object</code> directly or indirectly. The <code>Object</code> class
defines a number of special methods that are inherited (or overridden)
by all objects.</p>
<p><a data-primary="Account class" data-type="indexterm" id="idm45927743604128"/><a data-primary="String class" data-secondary="reference type conversions and" data-type="indexterm" id="idm45927743603056"/>The predefined <code>String</code> class and the <code>Account</code> class we discussed earlier
in this chapter both extend <code>Object</code>. Thus, we can say that all <code>String</code>
objects are also <code>Object</code> objects. We can also say that all <code>Account</code>
objects are <code>Object</code> objects. The opposite is not true, however. We
cannot say that every <code>Object</code> is a <code>String</code> because, as we’ve just
seen, some <code>Object</code> objects are <code>Account</code> objects.</p>
<p><a data-primary="casts" data-secondary="conversion rules and" data-type="indexterm" id="idm45927743597136"/>With this simple understanding of the class hierarchy, we can define the
rules of reference type conversion:</p>
<ul>
<li>
<p>An object reference cannot be converted to an unrelated type. The Java compiler does not allow you to convert a <code>String</code> to a <code>Account</code>, for example, even if you use a cast operator.</p>
</li>
<li>
<p>An object reference can be converted to the type of its superclass or of any ancestor class. This is a widening conversion, so no cast is required.
For example, a <code>String</code> value can be assigned to a variable of type
<code>Object</code> or passed to a method where an <code>Object</code> parameter is expected.</p>
</li>
</ul>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>No conversion is actually performed; the object is simply treated as if
it were an instance of the superclass. This is a simple form of
the Liskov substitution principle, after Barbara Liskov, the computer
scientist who first explicitly formulated it.</p>
</div>
<ul>
<li>
<p>An object reference can be converted to the type of a subclass, but this is a narrowing conversion and requires a cast. The Java compiler
provisionally allows this kind of conversion, but the Java interpreter
checks at runtime to make sure it is valid. Only cast a reference to the
type of a subclass if you are sure, based on the logic of your program,
that the object is actually an instance of the subclass. If it is not,
the interpreter throws a <code>ClassCastException</code>. For example, if we assign
a <code>String</code> reference to a variable of type <code>Object</code>, we can later cast the
value of that variable back to type <code>String</code>:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">Object</code><code class="w"> </code><code class="n">o</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">"string"</code><code class="p">;</code><code class="w">    </code><code class="c1">// Widening conversion from String</code><code class="w"/>
<code class="w">                        </code><code class="c1">// to Object later in the program...</code><code class="w"/>
<code class="n">String</code><code class="w"> </code><code class="n">s</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">(</code><code class="n">String</code><code class="p">)</code><code class="w"> </code><code class="n">o</code><code class="p">;</code><code class="w">  </code><code class="c1">// Narrowing conversion from Object</code><code class="w"/>
<code class="w">                        </code><code class="c1">// to String</code><code class="w"/></pre>
</li>
</ul>
<p><a data-primary="arrays" data-secondary="conversion rules" data-type="indexterm" id="idm45927743540224"/>Arrays are objects and follow some conversion rules of their own.
First, any array can be converted to an <code>Object</code> value through a
widening conversion. A narrowing conversion with a cast can convert such
an object value back to an array. Here’s an example:</p>
<pre data-code-language="java" data-type="programlisting"><code class="c1">// Widening conversion from array to Object</code><code class="w"/>
<code class="n">Object</code><code class="w"> </code><code class="n">o</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="kt">int</code><code class="o">[]</code><code class="w"> </code><code class="p">{</code><code class="mi">1</code><code class="p">,</code><code class="mi">2</code><code class="p">,</code><code class="mi">3</code><code class="p">};</code><code class="w"/>
<code class="c1">// Later in the program...</code><code class="w"/>

<code class="kt">int</code><code class="o">[]</code><code class="w"> </code><code class="n">a</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">(</code><code class="kt">int</code><code class="o">[]</code><code class="p">)</code><code class="w"> </code><code class="n">o</code><code class="p">;</code><code class="w">      </code><code class="c1">// Narrowing conversion back to array type</code><code class="w"/></pre>
<p>In addition to converting an array to an object, we can convert an array to another type of array if the “base types” of the two arrays
are reference types that can themselves be converted. For example:</p>
<pre data-code-language="java" data-type="programlisting"><code class="c1">// Here is an array of strings.</code><code class="w"/>
<code class="n">String</code><code class="o">[]</code><code class="w"> </code><code class="n">strings</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">String</code><code class="o">[]</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="s">"hi"</code><code class="p">,</code><code class="w"> </code><code class="s">"there"</code><code class="w"> </code><code class="p">};</code><code class="w"/>
<code class="c1">// A widening conversion to CharSequence[] is allowed because String</code><code class="w"/>
<code class="c1">// can be widened to CharSequence</code><code class="w"/>
<code class="n">CharSequence</code><code class="o">[]</code><code class="w"> </code><code class="n">sequences</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">strings</code><code class="p">;</code><code class="w"/>
<code class="c1">// The narrowing conversion back to String[] requires a cast.</code><code class="w"/>
<code class="n">strings</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">(</code><code class="n">String</code><code class="o">[]</code><code class="p">)</code><code class="w"> </code><code class="n">sequences</code><code class="p">;</code><code class="w"/>

<code class="c1">// This is an array of arrays of strings</code><code class="w"/>
<code class="n">String</code><code class="o">[][]</code><code class="w"> </code><code class="n">s</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">String</code><code class="o">[][]</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">strings</code><code class="w"> </code><code class="p">};</code><code class="w"/>
<code class="c1">// It cannot be converted to CharSequence[] because String[] cannot be</code><code class="w"/>
<code class="c1">// converted to CharSequence: the number of dimensions don't match</code><code class="w"/>

<code class="n">sequences</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">s</code><code class="p">;</code><code class="w">  </code><code class="c1">// This line will not compile</code><code class="w"/>
<code class="c1">// s can be converted to Object or Object[], because all array types</code><code class="w"/>
<code class="c1">// (including String[] and String[][]) can be converted to Object.</code><code class="w"/>
<code class="n">Object</code><code class="o">[]</code><code class="w"> </code><code class="n">objects</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">s</code><code class="p">;</code><code class="w"/></pre>
<p class="pagebreak-before">Note that these array conversion rules apply only to arrays of objects
and arrays of arrays. An array of primitive type cannot be converted to
any other array type, even if the primitive base types can be converted<a data-startref="ix_ch03-asciidoc38" data-type="indexterm" id="idm45927743411872"/><a data-startref="ix_ch03-asciidoc37" data-type="indexterm" id="idm45927743354336"/><a data-startref="ix_ch03-asciidoc36" data-type="indexterm" id="idm45927743353696"/>:<a data-startref="ix_ch03-asciidoc35" data-type="indexterm" id="idm45927743352896"/><a data-startref="ix_ch03-asciidoc34" data-type="indexterm" id="idm45927743352192"/><a data-startref="ix_ch03-asciidoc33" data-type="indexterm" id="idm45927743351520"/><a data-startref="ix_ch03-asciidoc32" data-type="indexterm" id="idm45927743350848"/><a data-startref="ix_ch03-asciidoc31" data-type="indexterm" id="idm45927743350176"/></p>
<pre data-code-language="java" data-type="programlisting"><code class="c1">// Can't convert int[] to double[] even though</code><code class="w"/>
<code class="c1">// int can be widened to double</code><code class="w"/>
<code class="c1">// This line causes a compilation error</code><code class="w"/>
<code class="kt">double</code><code class="o">[]</code><code class="w"> </code><code class="n">data</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="kt">int</code><code class="o">[]</code><code class="w"> </code><code class="p">{</code><code class="mi">1</code><code class="p">,</code><code class="mi">2</code><code class="p">,</code><code class="mi">3</code><code class="p">};</code><code class="w"/>
<code class="c1">// This line is legal, however,</code><code class="w"/>
<code class="c1">// because int[] can be converted to Object</code><code class="w"/>
<code class="n">Object</code><code class="o">[]</code><code class="w"> </code><code class="n">objects</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="kt">int</code><code class="o">[][]</code><code class="w"> </code><code class="p">{{</code><code class="mi">1</code><code class="p">,</code><code class="mi">2</code><code class="p">},{</code><code class="mi">3</code><code class="p">,</code><code class="mi">4</code><code class="p">}};</code><code class="w"/></pre>
</div></section>
</div></section>
<section data-pdf-bookmark="Modifier Summary" data-type="sect1"><div class="sect1" id="idm45927744120976">
<h1>Modifier Summary</h1>
<p><a data-primary="object-oriented programming" data-secondary="modifier summary" data-type="indexterm" id="idm45927743278192"/>As we’ve seen, classes, interfaces, and their members can be
declared with one or more <em>modifiers</em>—keywords such as <code>public</code>,
<code>static</code>, and <code>final</code>. Let’s conclude this chapter by listing the Java
modifiers, explaining what types of Java constructs they can modify,
and explaining what they do. <a data-type="xref" href="#javanut8-CHP-3-TABLE-2">Table 3-2</a>
has the details; you can also refer to
<a data-type="xref" href="#javanut8-CHP-3-SECT-1">“Overview of Classes and Records”</a>, <a data-type="xref" href="#javanut8-CHP-3-SECT-2.1">“Field Declaration Syntax”</a>, and <a data-type="xref" href="ch02.xhtml#javanut8-CHP-2-SECT-6.2">“Method Modifiers”</a>.</p>
<table id="javanut8-CHP-3-TABLE-2">
<caption><span class="label">Table 3-2. </span>Java modifiers</caption>
<thead>
<tr>
<th>Modifier</th>
<th>Used on</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td><p><code>abstract</code></p></td>
<td><p>Class</p></td>
<td><p>The class cannot be instantiated and may contain
unimplemented methods.</p></td>
</tr>
<tr>
<td/>
<td><p>Interface</p></td>
<td><p>All interfaces are <code>abstract</code>. The modifier is optional
in interface declarations.</p></td>
</tr>
<tr>
<td/>
<td><p>Method</p></td>
<td><p>No body is provided for the method; it is provided by a
subclass. The signature is followed by a semicolon. The enclosing class
must also be <code>abstract</code>.</p></td>
</tr>
<tr>
<td><p><code>default</code></p></td>
<td><p>Method</p></td>
<td><p>Implementation of this interface method is optional.
The interface provides a default implementation for classes that elect
not to implement it. See <a data-type="xref" href="ch04.xhtml#javanut8-CHP-4">Chapter 4</a> for more
details.</p></td>
</tr>
<tr>
<td><p><code>final</code></p></td>
<td><p>Class</p></td>
<td><p>The class cannot be subclassed.</p></td>
</tr>
<tr>
<td/>
<td><p>Method</p></td>
<td><p>The method cannot be overridden.</p></td>
</tr>
<tr>
<td/>
<td><p>Field</p></td>
<td><p>The field cannot have its value changed. <code>static final</code>
fields are compile-time constants.</p></td>
</tr>
<tr>
<td/>
<td><p>Variable</p></td>
<td><p>A local variable, method parameter, or exception parameter
cannot have its value changed.</p></td>
</tr>
<tr>
<td><p><code>native</code></p></td>
<td><p>Method</p></td>
<td><p>The method is implemented in some platform-dependent
way (often in C). No body is provided; the signature is followed by a
semicolon.</p></td>
</tr>
<tr>
<td><p><code>non-sealed</code></p></td>
<td><p>Class</p></td>
<td><p>The class inherits from a sealed type but itself has unrestricted open inheritance.</p></td>
</tr>
<tr>
<td><p>&lt;None&gt; (package)</p></td>
<td><p>Class</p></td>
<td><p>A non-<code>public</code> class is accessible only in its
package.</p></td>
</tr>
<tr>
<td/>
<td><p>Interface</p></td>
<td><p>A non-<code>public</code> interface is accessible only in its
package.</p></td>
</tr>
<tr>
<td/>
<td><p>Member</p></td>
<td><p>A member that is not <code>private</code>, <code>protected</code>, or <code>public</code> has
package visibility and is accessible only within its package.</p></td>
</tr>
<tr>
<td><p><code>private</code></p></td>
<td><p>Member</p></td>
<td><p>The member is accessible only within the class
that defines it.</p></td>
</tr>
<tr>
<td><p><code>protected</code></p></td>
<td><p>Member</p></td>
<td><p>The member is accessible only within the package
in which it is defined and within subclasses.</p></td>
</tr>
<tr>
<td><p><code>public</code></p></td>
<td><p>Class</p></td>
<td><p>The class is accessible anywhere its package is.</p></td>
</tr>
<tr>
<td/>
<td><p>Interface</p></td>
<td><p>The interface is accessible anywhere its package is.</p></td>
</tr>
<tr>
<td/>
<td><p>Member</p></td>
<td><p>The member is accessible anywhere its class is.</p></td>
</tr>
<tr>
<td><p><code>sealed</code></p></td>
<td><p>Class</p></td>
<td><p>The class can be subclassed only by a known list of subclasses, as given by the <code>permits</code> clause.
If the permits clause is missing, the class can be subclassed only by classes within the same compilation unit.
</p></td>
</tr>
<tr>
<td><p><code>static</code></p></td>
<td><p>Class</p></td>
<td><p>An inner class declared <code>static</code> is a top-level
class not associated with a member of the containing class. See
<a data-type="xref" href="ch04.xhtml#javanut8-CHP-4">Chapter 4</a> for more details.</p></td>
</tr>
<tr>
<td/>
<td><p>Method</p></td>
<td><p>A <code>static</code> method is a class method. It is not passed an
implicit <code>this</code> object reference. It can be invoked through the class
name.</p></td>
</tr>
<tr>
<td/>
<td><p>Field</p></td>
<td><p>A <code>static</code> field is a class field. There is only one instance
of the field, regardless of the number of class instances created. It
can be accessed through the class name.</p></td>
</tr>
<tr>
<td/>
<td><p>Initializer</p></td>
<td><p>The initializer is run when the class is loaded rather
than when an instance is created.</p></td>
</tr>
<tr>
<td><p><code>strictfp</code></p></td>
<td><p>Class</p></td>
<td><p>All methods of the class are implicitly <code>strictfp</code>.</p></td>
</tr>
<tr>
<td/>
<td><p>Method</p></td>
<td><p>All floating-point computation done by the method must be
performed in a way that strictly conforms to the IEEE 754 standard. In
particular, all values, including intermediate results, must be
expressed as IEEE <code>float</code> or <code>double</code> values and cannot take advantage
of any extra precision or range offered by native platform
floating-point formats or hardware. This modifier is extremely rarely
used, and is a no-op in Java 17, as the language now always uses strict conformance to the standard.</p></td>
</tr>
<tr>
<td><p><span class="keep-together"><code>synchronized</code></span></p></td>
<td><p>Method</p></td>
<td><p>The method makes nonatomic modifications to the
class or instance, so care must be taken to ensure that two threads
cannot modify the class or instance at the same time. For a <code>static</code>
method, a lock for the class is acquired before executing the method.
For a non-<code>static</code> method, a lock for the specific object instance is
acquired. See <a data-type="xref" href="ch05.xhtml#javanut8-CHP-5">Chapter 5</a> for more details.</p></td>
</tr>
<tr>
<td><p><span class="keep-together"><code>transient</code></span></p></td>
<td><p>Field</p></td>
<td><p>The field is not part of the persistent state of
the object and should not be serialized with the object. Used with
object serialization; see <code>java.io.ObjectOutputStream</code>.</p></td>
</tr>
<tr>
<td><p><code>volatile</code></p></td>
<td><p>Field</p></td>
<td><p>The field can be accessed by unsynchronized threads,
so certain optimizations must not be performed on it. This modifier can
sometimes be used as an alternative to <code>synchronized</code>. See
<a data-type="xref" href="ch05.xhtml#javanut8-CHP-5">Chapter 5</a> for more details.</p></td>
</tr>
</tbody>
</table>
</div></section>
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="idm45927743267248">
<h1>Summary</h1>
<p>Java, like all object-oriented languages, has its own model of how OO should work.
In this chapter we have met the basic concepts of this model: static typing, fields, methods, inheritance, access control, encapsulation, overloading, overriding, and sealing.
To become a proficient Java programmer, you will need to gain proficiency in handling all of these concepts and understand the relationship between them and how they interact.</p>
<p>The next two chapters are devoted to exploring these features further and understanding how the basic aspects of object-oriented design in Java arise directly from this relatively small set of basic concepts.<a data-startref="ix_ch03-asciidoc0" data-type="indexterm" id="idm45927743154976"/></p>
</div></section>
<div data-type="footnotes"><p data-type="footnote" id="idm45927749308000"><sup><a href="ch03.xhtml#idm45927749308000-marker">1</a></sup> There is also the default, aka package, visibility that we will meet later.</p><p data-type="footnote" id="idm45927744054480"><sup><a href="ch03.xhtml#idm45927744054480-marker">2</a></sup> An <code>abstract</code> method in Java is something like a pure virtual function in C++ (i.e., a virtual function that is declared <code>= 0</code>). In C++, a class that contains a pure virtual function is called an abstract class and cannot be instantiated. The same is true of Java classes that contain <code>abstract</code> methods.</p></div></div></section></div></body></html>