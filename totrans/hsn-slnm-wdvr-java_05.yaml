- en: Chapter 3\. WebDriver Fundamentals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter presents the elementary aspects of the Selenium WebDriver API.
    To that aim, we review first the different ways to create instances of the `WebDriver`
    hierarchy (e.g., `ChromeDriver`, `EdgeDriver`, `FirefoxDriver`, etc.). Also, we
    explore the main methods available in these objects. Among them, locating the
    different elements in a web page is essential. Thus, you will discover the possible
    locators, i.e., strategies to find the elements within a web page (called `WebElement`
    in the Selenium WebDriver API), such as by tag name, link text, HTML attribute
    (identifier, name, or class), CSS selector, or XPath. Another critical aspect
    of the Selenium WebDriver API covered in this chapter is the impersonation of
    user actions (i.e., automated interactions with web pages using the keyboard and
    mouse). The last part of this chapter presents the ability to wait for web elements.
    This feature is critical due to the dynamic and asynchronous nature of web applications.
  prefs: []
  type: TYPE_NORMAL
- en: Basic WebDriver Usage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section covers three fundamental aspects related to `WebDriver` objects.
    First, we review the different ways to create them. Second, we study their basic
    operations. Finally, we analyze the different ways to dispose of these objects
    (typically at the end of a test, for closing the browser).
  prefs: []
  type: TYPE_NORMAL
- en: WebDriver Creation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As introduced in [Chapter 2](ch02.html#ch02), to control browsers with Selenium
    WebDriver in Java, the first step is to create `WebDriver` instances. Thus, we
    need to create a `ChromeDriver` object when using Chrome, `EdgeDriver` for Edge,
    `FirefoxDriver` for Firefox, and so on. The basic way to create instances of these
    types is to use the `new` operator in Java. For example, we create a `ChromeDriver`
    object as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The use of the operator `new` for creating `WebDriver` instances is perfectly
    correct, and you can use it in your tests. Nevertheless, it is worth reviewing
    other possibilities that can provide additional benefits depending on specific
    use cases for creating these objects. These alternatives are the WebDriver and
    the WebDriverManager builders.
  prefs: []
  type: TYPE_NORMAL
- en: WebDriver builder
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Selenium WebDriver API provides a built-in method following the *builder
    pattern* to create `WebDriver` instances. This feature is accessible through the
    static method `builder()` of the `RemoteWebDriver` class and provides a fluent
    API for creating `WebDriver` objects. [Table 3-1](#webdriver-builder-methods)
    presents the available methods for this builder. [Example 3-1](#webdriver_builder_skeleton)
    shows a test skeleton using the WebDriver builder.
  prefs: []
  type: TYPE_NORMAL
- en: Table 3-1\. WebDriver builder methods
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '| Browser-specific capabilities |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '| Alternative browser-specific capabilities (see [Chapter 5](ch05.html#ch05))
    |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '| Add custom metadata, typically used for requesting additional features in
    cloud providers (see [Chapter 6](ch06.html#ch06)) |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '| Individual browser-specific capabilities (see [Chapter 5](ch05.html#ch05))
    |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '| Set the address of the remote server (see [Chapter 6](ch06.html#ch06)) |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '| Specific configuration when using a remote server, such as the connection
    timeout or proxy settings |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '| Specific configuration for the local driver (e.g., chromedriver), such as
    its file location, used port, timeout, or arguments |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '| Last method in the builder pattern, devoted to creating a `WebDriver` instance
    |'
  prefs: []
  type: TYPE_TB
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '[Chapter 5](ch05.html#ch05) explains the details about *browser-specific capabilities*
    (such as `ChromeOptions`). At this point, we use these classes just to select
    a browser type (e.g., `ChromeOptions` for Chrome, `Edge​Op⁠tions` for Edge, or
    `FirefoxOptions` for Firefox).'
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-1\. Test skeleton using the WebDriver builder
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_webdriver_fundamentals_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: As usual, before the actual `WebDriver` instantiation, we resolve the required
    driver (chromedriver in this example) using WebDriverManager.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_webdriver_fundamentals_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: We create the `WebDriver` instance using the WebDriver builder. Since we want
    to use Chrome in this test, we use a `ChromeOptions` object as the capabilities
    argument (using the method `oneOf()`).
  prefs: []
  type: TYPE_NORMAL
- en: From a functional point of view, this example works in the same way as the regular
    *hello world* tests presented in [Chapter 2](ch02.html#ch02). Nevertheless, the
    WebDriver builder API easily allows specifying a different behavior. Consider
    the following snippet as an example. This code changes the setup method and creates
    a `SafariDriver` instance. Suppose the instantiation of this object is not possible
    (typically, when the test is not executed on macOS, and therefore, Safari is not
    available in the system). In that case, we use Chrome as an alternative browser.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: WebDriverManager builder
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another possibility to create `WebDriver` objects is using WebDriverManager.
    In addition to resolving drivers, as of version 5, WebDriverManager provides a
    `WebDriver` builder utility. [Example 3-2](#wdm_builder_skeleton) shows a test
    skeleton using this builder.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-2\. Test skeleton using the WebDriverManager builder
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_webdriver_fundamentals_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: WebDriverManager resolves the required driver (chromedriver in this case) and
    creates an instance of the proper `WebDriver` type (`ChromeDriver` in this case)
    in a single line.
  prefs: []
  type: TYPE_NORMAL
- en: This approach has different benefits. First, it enables less verbose tests since
    the driver resolution and `WebDriver` instantiation are simultaneous. Second,
    it allows specifying the browser type (i.e., Chrome, Firefox, etc.) simply by
    selecting a specific manager (i.e., `chromedriver()`, `firefoxdriver()`, etc.).
    Moreover, we can easily parameterize the selection of a manager to create cross-browser
    tests (see [Chapter 8](ch08.html#ch08)). Finally, the WebDriverManager allows
    you to specify browser-specific capabilities (see [Chapter 5](ch05.html#ch05))
    and effortlessly use browsers in a Docker container (see [Chapter 6](ch06.html#ch06)).
  prefs: []
  type: TYPE_NORMAL
- en: WebDriverManager keeps a reference to `WebDriver` objects created using this
    approach. In addition, it launches a shutdown hook to watch the correct disposal
    of `WebDriver` instances. If `WebDriver` sessions are live when the JVM is shutting
    down, WebDriverManager quits these browser(s). You can play with this feature
    by removing the `teardown()` method of the example before.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Although WebDriverManager quits the `WebDriver` objects automatically, I recommend
    you do it explicitly in each test. Otherwise, in the typical case of executing
    a test suite, all browsers remain open until the end of the test suite execution.
  prefs: []
  type: TYPE_NORMAL
- en: WebDriver Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `WebDriver` interface provides a group of methods that are the basis of
    the Selenium WebDriver API. [Table 3-2](#webdriver-methods) presents a summary
    of these methods. [Example 3-3](#basic_webdriver_methods) shows a basic test using
    several of these methods.
  prefs: []
  type: TYPE_NORMAL
- en: Table 3-2\. WebDriver methods
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Return | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '| Load a web page in the current browser. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '| Get the URL currently loaded in the browser. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '| Get the title (`<title>` HTML tag) of the current web page. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '| Find the first `WebElement` using a given locator in the current web page.
    In other words, if several elements match the locator, the first one (in the Document
    Object Model [DOM]) is returned (see [“Locating WebElements”](#location) for further
    details). |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '| Find every `WebElement` using a given locator in the current web page (see
    also [“Locating WebElements”](#location)). |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '| Get the HTML source code of the current web page. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '| Access the browser history and navigate to a given URL (see [Chapter 4](ch04.html#ch04)).
    |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '| Get the *window handle*, i.e., a unique identifier for the open window in
    the current browser (see [Chapter 4](ch04.html#ch04)). |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '| Get the set of window handles currently open in the current browser (see
    also [Chapter 4](ch04.html#ch04)). |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '| Select a frame or window in the current browser (see [Chapter 4](ch04.html#ch04)).
    |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '| Generic utility for managing different aspects of the browser (e.g., browser
    size and position, cookies, timeouts, or logs). |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '| Close the current window, quitting the browser if there are no more windows
    opened. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '| Close all windows and quit the browser. |'
  prefs: []
  type: TYPE_TB
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: From now on, I illustrate the examples showing only the test logic. These tests
    use a `WebDriver` object created before the test (in the setup method) and closed
    after the test (in the teardown method). As a convention, I show the JUnit 5 tests
    in the book (although you can find them also for JUnit 4, Selenium-Jupiter, and
    TestNG in the examples repository).
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-3\. Test using several basic methods of the Selenium WebDriver API
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_webdriver_fundamentals_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We open the practice website.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_webdriver_fundamentals_CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: We verify the page title is as expected.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_webdriver_fundamentals_CO3-3)'
  prefs: []
  type: TYPE_NORMAL
- en: We confirm the current URL is still the same.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_webdriver_fundamentals_CO3-4)'
  prefs: []
  type: TYPE_NORMAL
- en: We check that the source HTML of the page contains a given tag.
  prefs: []
  type: TYPE_NORMAL
- en: Session Identifier
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each time we instantiate a `WebDriver` object, the underlying driver (e.g.,
    chromedriver, geckodriver, etc.) creates a unique identifier called *sessionId*
    to track the browser session. We can use this value in our test to univocally
    identify a browser session. For that, we need to invoke the method `getSessionId()`
    in our driver object. Notice this method is not available in [Table 3-2](#webdriver-methods),
    because it belongs to the `RemoteWebDriver` class. In practice, the types we use
    to control browsers (e.g., `ChromeDriver`, `FirefoxDriver`, etc.) inherit from
    that class. Therefore, we simply need to cast the `WebDriver` object to `RemoteWebDriver`
    to invoke the `getSessionId()` method. [Example 3-4](#sessionid) shows a basic
    test using it.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-4\. Test reading the sessionId
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_webdriver_fundamentals_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We cast the driver object to `RemoteWebDriver` and read its sessionId.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_webdriver_fundamentals_CO4-2)'
  prefs: []
  type: TYPE_NORMAL
- en: We verify the sessionId has some value.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_webdriver_fundamentals_CO4-3)'
  prefs: []
  type: TYPE_NORMAL
- en: We log the sessionId on the standard output.
  prefs: []
  type: TYPE_NORMAL
- en: WebDriver Disposal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you can see in [Table 3-2](#webdriver-methods), there are two methods to
    dispose of the `WebDriver` objects, called `close()` and `quit().` As a general
    rule, I use `quit()` in the examples since this method closes the browser and
    every associated window. On the other hand, the method `close()` terminates only
    the current window. Therefore, I only use `close()` in the case of handling different
    windows (or tabs) in the same browser, and I want to finish some of the windows
    (or tabs) and still use the rest.
  prefs: []
  type: TYPE_NORMAL
- en: Locating WebElements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most relevant aspects of the Selenium WebDriver API is the ability
    to interact with the different elements of a web page. These elements are handled
    by Selenium WebDriver using the interface `WebElement`, an abstraction for HTML
    elements. As introduced in [Table 3-2](#webdriver-methods), there are two methods
    to locate `WebElement` in a given web page. First, the method `findElement()`
    returns the first occurrence (if any) of a given node in the Document Object Model
    (DOM). Second, the method `find​Ele⁠ments()` returns a list of DOM nodes. Both
    methods accept a parameter `By`, which specifies the location strategy.
  prefs: []
  type: TYPE_NORMAL
- en: The Document Object Model (DOM)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The DOM is a cross-platform interface that allows representing XML-like documents
    (e.g., web pages, based on HTML) in a tree structure. [Example 3-5](#basic_html)
    shows an small web page; the associated DOM tree structure in memory is represented
    in [Figure 3-1](#dom-example). As you can see, each HTML tag (e.g., `<html>`,
    `<head>`, `<body>`, `<a>`, etc.) produces a node (or element) in the tree. Then,
    each standard HTML attribute (e.g., `charset`, `href`, etc.) produces an equivalent
    DOM *property*. Also, the text content of the HTML tags is available in the resulting
    tree. Languages like JavaScript use DOM methods to access and modify the tree
    structure. Thanks to this, web pages are dynamic and can change their layout and
    content in response to user events.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-5\. Basic web page
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '![hosw 0301](assets/hosw_0301.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-1\. DOM structure generated from [Example 3-5](#basic_html)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: WebElement Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Table 3-3](#webelement-methods) contains a summary of the available methods
    in the `WebElement` class. You will find examples of each method in the following
    parts of this section.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 3-3\. WebElement methods
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Return | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '| Perform a mouse click (i.e., a left-click) in the current element. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '| Send a web form (when the current element is a form). |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '| Simulate typing with the keyboard (e.g., in input text elements). |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '| Reset the value of an input text element. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '| Get the tag name of the element. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '| Get the value of a DOM property. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '| Get the value of the element attribute as declared in its HTML markup. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '| Get the value of the given HTML attribute (e.g., `class`) as a `String`.
    More precisely, this method attempts to get a meaningful value of the DOM property
    with the given name if it exists. For instance, for boolean attributes (e.g.,
    `readonly`), it returns `true` if it exists or `null` if not. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '| Get element role as defined on the [W3C WAI-ARIA](https://www.w3.org/TR/wai-aria)
    specification. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '| Get element accessible name as defined by WAI-ARIA. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '| Determine if a checkbox, option in a select, or radio button is selected.
    |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '| Determine if an element is enabled or not (e.g., a form field). |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '| Determine if an element is visible or not. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '| Get the visible text of the element, including its sub-elements (if any).
    |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '| Get the position (*x* and *y* coordinates) from the top-left corner of the
    rendered element. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '| Get the width and height of the rendered element. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '| Get the location and size of the rendered element. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '| Get the value of a CSS property of the element. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '| Get the shadow root to search in a shadow tree (see [“The Shadow DOM”](ch04.html#shadow-dom)).
    |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '| Find all subelements that match the locator within the current element. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '| Find the first subelement that matches the locator within the current element.
    |'
  prefs: []
  type: TYPE_TB
- en: Location Strategies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Selenium WebDriver provides eight basic location strategies, summarized in [Table 3-4](#location-strategies).
    In addition, as explained in the next subsections, there are other advanced location
    strategies, namely, compound and relative locators.
  prefs: []
  type: TYPE_NORMAL
- en: We specify the basic locators using the class `By` in the Selenium WebDriver
    API. The following subsections show examples of all these strategies. We use the
    [practice web form](https://bonigarcia.dev/selenium-webdriver-java/web-form.html)
    to that aim. [Figure 3-2](#practice-site-web-form) shows a screenshot of this
    form.
  prefs: []
  type: TYPE_NORMAL
- en: Table 3-4\. Summary of the location strategies in Selenium WebDriver
  prefs: []
  type: TYPE_NORMAL
- en: '| Locator | Finds elements based on |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Tag name | The name of HTML tag (e.g., `a`, `p`, `div`, `img`, etc.). |'
  prefs: []
  type: TYPE_TB
- en: '| Link text | The exact text value displayed by a link (i.e., `a` HTML tag).
    |'
  prefs: []
  type: TYPE_TB
- en: '| Partial link text | The text contained in a link (i.e., `a` HTML tag). |'
  prefs: []
  type: TYPE_TB
- en: '| Name | The value of the attribute `name`. |'
  prefs: []
  type: TYPE_TB
- en: '| Id | The value of the attribute `id`. |'
  prefs: []
  type: TYPE_TB
- en: '| Class name | The value of the attribute `class`. |'
  prefs: []
  type: TYPE_TB
- en: '| CSS selector | Patterns that follow the [W3C Selectors](https://www.w3.org/TR/selectors)
    recommendation. The original aim of CSS patterns is to select element(s) in a
    web page to apply CSS styles. Selenium WebDriver allows reusing these CSS selectors
    to find web elements and interact with them. |'
  prefs: []
  type: TYPE_TB
- en: '| XPath | Queries that follow the [XPath](https://www.w3.org/TR/xpath) (XML
    Path Language) language. XPath is a W3C standard query language for selecting
    nodes from an XML-like document (e.g., web pages). |'
  prefs: []
  type: TYPE_TB
- en: '![hosw 0302](assets/hosw_0302.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-2\. Practice web form used in the locator examples
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Locating by HTML tag name
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One of the most basic strategies for finding web elements is by tag name. [Example 3-6](#by-tagname)
    shows a test using this strategy. This test locates the text area available in
    the practice web form, whose HTML markup is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Example 3-6\. Test using a locator strategy by tag name
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_webdriver_fundamentals_CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We use the locator `By.tagName("textarea")` to find this element. In this case,
    since this is the only text area declared on the web page, we can be sure that
    the method `findElement()` will locate this element.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_webdriver_fundamentals_CO5-2)'
  prefs: []
  type: TYPE_NORMAL
- en: We ensure the attribute `rows` value is the same as defined in the HTML markup.
  prefs: []
  type: TYPE_NORMAL
- en: Locating by HTML attributes (name, id, class)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another straightforward location strategy is to find web elements by an HTML
    attribute, i.e., name, id, or class. Consider the following input text available
    in the practice web form. Notice that it includes the standard attributes `class`,
    `name`, `id`, and the nonstandard attribute `myprop` (included to illustrate the
    difference between several `WebDriver` methods). [Example 3-7](#by-html-attr)
    shows a test using this strategy.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Example 3-7\. Test using locators by HTML attributes (name, id, and class)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_webdriver_fundamentals_CO6-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We locate the text input by name.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_webdriver_fundamentals_CO6-2)'
  prefs: []
  type: TYPE_NORMAL
- en: We assert that the element is enabled (i.e., the user can type in it).
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_webdriver_fundamentals_CO6-3)'
  prefs: []
  type: TYPE_NORMAL
- en: We find the same text input element by id.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_webdriver_fundamentals_CO6-4)'
  prefs: []
  type: TYPE_NORMAL
- en: This assertion (and the next two) returns the same value since the attribute
    `type` is standard, and as previously explained, it becomes a *property* in the
    DOM.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_webdriver_fundamentals_CO6-5)'
  prefs: []
  type: TYPE_NORMAL
- en: This assertion (and the next two) return different values since the attribute
    `myprop` is not standard, and for this reason, it is not available as a DOM property.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_webdriver_fundamentals_CO6-6)'
  prefs: []
  type: TYPE_NORMAL
- en: We locate a list of elements by class.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](assets/7.png)](#co_webdriver_fundamentals_CO6-7)'
  prefs: []
  type: TYPE_NORMAL
- en: We verify the list has more than one element.
  prefs: []
  type: TYPE_NORMAL
- en: '[![8](assets/8.png)](#co_webdriver_fundamentals_CO6-8)'
  prefs: []
  type: TYPE_NORMAL
- en: We check that the first element found by class is the same as the input text
    located before.
  prefs: []
  type: TYPE_NORMAL
- en: Locating by link text
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The last basic locator is by link text. This strategy is twofold: locate by
    exact and by partial text occurrence. We use a link in the practice web form to
    illustrate this locator in the following HTML markup. Then, [Example 3-8](#by-link)
    shows a test using these locators.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Example 3-8\. Test using locators by text link
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_webdriver_fundamentals_CO7-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We locate an element by its full link text.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_webdriver_fundamentals_CO7-2)'
  prefs: []
  type: TYPE_NORMAL
- en: We check its tag name is `a`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_webdriver_fundamentals_CO7-3)'
  prefs: []
  type: TYPE_NORMAL
- en: We check its CSS property `cursor` is `pointer` (i.e., the style typically used
    for clickable elements).
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_webdriver_fundamentals_CO7-4)'
  prefs: []
  type: TYPE_NORMAL
- en: We find an element by partial link text. This link will be the same as in step
    1.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_webdriver_fundamentals_CO7-5)'
  prefs: []
  type: TYPE_NORMAL
- en: We verify both elements share the same position and size.
  prefs: []
  type: TYPE_NORMAL
- en: Locating by CSS selectors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The strategies we have seen so far are easy to apply but also have some limitations.
    First, locating by tag name can be tricky since it is likely that the same tag
    will occur many times on a web page. Next, finding elements by HTML attributes
    (name, id, or class) is a limited approach since these attributes are not always
    available. In addition, ids can be autogenerated and volatile between different
    sessions. Lastly, the location by link text is limited only to links. To overcome
    these limitations, Selenium WebDriver provides two powerful location strategies:
    CSS selector and XPath.'
  prefs: []
  type: TYPE_NORMAL
- en: There are many possibilities for creating CSS selectors. [Table 3-5](#basic-css-selectors)
    shows a comprehensive summary with the basic CSS selectors.
  prefs: []
  type: TYPE_NORMAL
- en: Table 3-5\. Basic CSS selectors
  prefs: []
  type: TYPE_NORMAL
- en: '| Category | Syntax | Description | Example | Example explanation |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Universal | `*` | Select all elements | `*` | Match all elements |'
  prefs: []
  type: TYPE_TB
- en: '| Type | `elementName` | Select all elements with a given tag name | `input`
    | Match all `<input>` elements |'
  prefs: []
  type: TYPE_TB
- en: '| Class | `.classname` | Select elements with a given `class` attribute | `.form-control`
    | Match all elements with class of `form-control` |'
  prefs: []
  type: TYPE_TB
- en: '| Id | `#id` | Select elements with a given `id` attribute | `#my-text-id`
    | Match all elements with id `my-text-id` |'
  prefs: []
  type: TYPE_TB
- en: '| Attribute | `[attr]` | Select elements with a given attribute | `[target]`
    | Match all elements with a `target` attribute |'
  prefs: []
  type: TYPE_TB
- en: '|  | `[attr=value]` | Select elements with a given attribute and value | `[target=_blank]`
    | Match all elements with a `target="_blank"` attribute |'
  prefs: []
  type: TYPE_TB
- en: '|  | `[attr~=value]` | Select elements with a given attribute containing some
    text value | `[title~=hands]` | Match all elements with a title attribute containing
    the word `hands` |'
  prefs: []
  type: TYPE_TB
- en: '|  | `[attr&#124;=value]` | Select elements with a given attribute equal to
    or starting by some value | `[lang&#124;=en]` | Match all elements equal to or
    starting with `en` |'
  prefs: []
  type: TYPE_TB
- en: '|  | `[attr^=value]` | Select elements with a given attribute starting by some
    value | `a[href^="https"]` | Match all links whose `href` attribute starts with
    `https` |'
  prefs: []
  type: TYPE_TB
- en: '|  | `[attr$=value]` | Select elements with a given attribute ending by some
    value | `a[href$=".pdf"]` | Match all links whose `href` attribute ends with `.pdf`
    |'
  prefs: []
  type: TYPE_TB
- en: '|  | `[attr*=value]` | Select elements with a given attribute value containing
    some string | `a[href*="github"]` | Match all links whose `href` attribute contains
    `github` |'
  prefs: []
  type: TYPE_TB
- en: The following HTML excerpt shows the hidden input text available in the practice
    web form. Then, [Example 3-9](#by-css-basic) illustrates a possible way to locate
    this element using a CSS selector. One advantage of this locator is that the selector
    will still work even when changing the attribute `name` in HTML markup.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Example 3-9\. Test using a basic locator with CSS selector
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_webdriver_fundamentals_CO8-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We use a CSS selector to locate the hidden input.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_webdriver_fundamentals_CO8-2)'
  prefs: []
  type: TYPE_NORMAL
- en: We check the hidden field is not visible.
  prefs: []
  type: TYPE_NORMAL
- en: There are plenty of possibilities to create advanced CSS selectors. [Table 3-6](#advanced-css-selectors)
    shows a summary with some of them. The complete reference of CSS selectors is
    available in the official [W3C recommendation](https://www.w3.org/TR/selectors).
  prefs: []
  type: TYPE_NORMAL
- en: Table 3-6\. Advanced CSS selectors
  prefs: []
  type: TYPE_NORMAL
- en: '| Category | Syntax | Description | Example | Example explanation |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Grouping | `,` | Group two (or more) selectors | `div, span` | Match both
    `<span>` and `<div>` elements |'
  prefs: []
  type: TYPE_TB
- en: '| Combinators | `(space)` | Select elements that are descendants | `div span`
    | Match all `<span>` that are inside a `<div>` |'
  prefs: []
  type: TYPE_TB
- en: '|  | `A > B` | Select elements that are direct children of another element
    | `ul > li` | Match all `<li>` elements nested directly inside to `<ul>` |'
  prefs: []
  type: TYPE_TB
- en: '|  | `A ~ B` | Select elements sharing the same parent (i.e., *siblings*),
    and the second element follows the first (not necessarily immediately) | `p ~
    span` | Match all <span> that follow a <p> (immediately or not) |'
  prefs: []
  type: TYPE_TB
- en: '|  | `A + B` | Sibling elements, and the second element immediately follows
    the first | `h2 + p` | Match all `<p>` that immediately follows <h2> |'
  prefs: []
  type: TYPE_TB
- en: '| Pseudo | `:` | Select a CSS *pseudoclass* (i.e., a special state of the selected
    element) | `a:visited` | Match all already visited links |'
  prefs: []
  type: TYPE_TB
- en: '|  | `:nth-child(n)` | Select elements based on their position in a group (starting
    from the beginning) | `p:nth-child(2)` | Match every second `<p>` child |'
  prefs: []
  type: TYPE_TB
- en: '|  | `:not(selector)` | Select elements not matching a given selector | `:not(p)`
    | Match every element different from `<p>` |'
  prefs: []
  type: TYPE_TB
- en: '|  | `:nth-last-child(n)` | Select elements based on their position in a group
    (starting from the end) | `p:nth-last-child(2)` | Match every second `<p>` child
    (counting from the last child) |'
  prefs: []
  type: TYPE_TB
- en: '|  | `::` | Select a CSS *pseudoelement* (i.e., a specific part of the selected
    element) | `p::first-line` | Match the first line of all `<p>` elements |'
  prefs: []
  type: TYPE_TB
- en: 'Consider the following piece of HTML (as usual, contained in the practice web
    form). As you can see, there are a couple of checkboxes: one of them is checked,
    and the other is not. We can determine which element is checked using the Selenium
    WebDriver API and CSS selectors. To that aim, [Example 3-10](#by-css-advanced)
    uses CSS pseudoclass.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Example 3-10\. Test using advanced locators with CSS selectors
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_webdriver_fundamentals_CO9-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We use the pseudoclass *checked* to locate clicked checkboxes.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_webdriver_fundamentals_CO9-2)'
  prefs: []
  type: TYPE_NORMAL
- en: We check the element id is as expected.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_webdriver_fundamentals_CO9-3)'
  prefs: []
  type: TYPE_NORMAL
- en: We confirm the selected is checked.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_webdriver_fundamentals_CO9-4)'
  prefs: []
  type: TYPE_NORMAL
- en: We use the pseudoclass *checked* and the operator *not* to locate default checkboxes.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_webdriver_fundamentals_CO9-5)'
  prefs: []
  type: TYPE_NORMAL
- en: We check the element id is as expected.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_webdriver_fundamentals_CO9-6)'
  prefs: []
  type: TYPE_NORMAL
- en: We confirm the selected is unchecked.
  prefs: []
  type: TYPE_NORMAL
- en: Locating by XPath
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'XPath (XML Path Language) is a powerful way of navigating to the DOM of XML-like
    documents, such as HTML pages. It includes over two hundred built-in functions
    to create advanced queries to select nodes. There are two types of XPath queries.
    First, *absolute* queries use the symbol slash (`/`) to traverse the DOM from
    the root node. For example, considering the basic HTML page in [Example 3-5](#basic_html),
    to select the link element present in this page using this approach, we need the
    following XPath query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Absolute XPath queries are easy to create, but they have a relevant inconvenience:
    any minimal change in the page layout would make a locator built with this strategy
    fail. For this reason, as a general rule, the usage of absolute XPaths is discouraged.
    Instead, *relative* queries are more convenient.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The general syntax for relative XPath queries is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 3-11](#by-xpath-basic) shows a test with an XPath locator to select
    the hidden field in the practice web.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-11\. Test using a basic locator with XPath
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_webdriver_fundamentals_CO10-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We locate the hidden field in the practice web.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_webdriver_fundamentals_CO10-2)'
  prefs: []
  type: TYPE_NORMAL
- en: We verify this element is not visible to the user.
  prefs: []
  type: TYPE_NORMAL
- en: The real power of XPath comes from its built-in functions. [Table 3-7](#xpath-functions)
    contains some of the most relevant XPath functions. You can find the complete
    XPath reference in the [W3C XPath Recommendations](https://www.w3.org/TR/xpath).
  prefs: []
  type: TYPE_NORMAL
- en: Table 3-7\. Summary of relevant XPath built-in functions
  prefs: []
  type: TYPE_NORMAL
- en: '| Category | Syntax | Description | Example | Example explanation |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Attributes | `contains(@attr, ''string'')` | Check if an attribute contains
    a string | `//a[contains(@href, ''github'')]` | Match links with `href` containing
    `github` |'
  prefs: []
  type: TYPE_TB
- en: '| `starts-with(@attr, ''string'')` | Check if an attribute starts with a string
    | `//a[starts-with(@href, ''https'')]` | Match all links using HTTPS |'
  prefs: []
  type: TYPE_TB
- en: '| `ends-with(@attr, ''string'')` | Check if an attribute end with a string
    | `//a[ends-with(@href, *https*)]` | Match all links to PDF documents |'
  prefs: []
  type: TYPE_TB
- en: '| Text | `text()=''string''` | Locate elements based on text content | `//*[text()=*click*]`
    | Match all elements with the text `click` |'
  prefs: []
  type: TYPE_TB
- en: '| Child nodes | `[index]` | Locate children elements | `//div/*[0]` | First
    child of a `<div>` |'
  prefs: []
  type: TYPE_TB
- en: '| Boolean | `or` | Logic operator *or* | `//@type=''submit'' or @type=''reset'']`
    | Match buttons to submit and clear forms |'
  prefs: []
  type: TYPE_TB
- en: '|  | `and` | Logic operator *and* | `//@type=''submit'' and @id =''my-button'']`
    | Match submit buttons with a given id |'
  prefs: []
  type: TYPE_TB
- en: '|  | `not()` | Logic operator *not* | `//@type=''submit'' and not(@id =''my-button'')]`
    | Match submit buttons different to a given id |'
  prefs: []
  type: TYPE_TB
- en: '| Axes (used to locate relative nodes) | `following::item` | Nodes that come
    after the current one | `//*[@type=''text'']//following::input` | Match all input
    fields after the first text input |'
  prefs: []
  type: TYPE_TB
- en: '|  | `descendant::item` | Select descendant elements (child, etc.) of current
    node | `//*[@id=''my-id'']//descendant::a` | Match all descendant links from a
    given parent node |'
  prefs: []
  type: TYPE_TB
- en: '|  | `ancestor::item` | Select ancestor elements (parent, etc.) of current
    node | `//input[@id=''my-id'']//ancestor::label` | Match all antecedent labels
    from a given input text |'
  prefs: []
  type: TYPE_TB
- en: '|  | `child::item` | Select children elements of current node | `//*[@id=''my-id'']//child::li`
    | Match all list element under a given node |'
  prefs: []
  type: TYPE_TB
- en: '|  | `preceding::item` | Select all nodes that come before the current one
    | `//*[@id=''my-id'']//preceding::input` | Match all `input` before a given node
    |'
  prefs: []
  type: TYPE_TB
- en: '|  | `following-sibling::item` | Select following nodes that come before the
    current one | `//*[@id=''my-id'']//following-sibling::input` | Match the next
    input before a given node |'
  prefs: []
  type: TYPE_TB
- en: '|  | `parent::item` | Select parent of the current node | `//*[@id=''my-id'']//parent::div`
    | Match the parent `div` element of a given node |'
  prefs: []
  type: TYPE_TB
- en: '[Example 3-12](#by-xpath-advanced) shows how to use XPath locators for the
    radio buttons available in the practice web form. The HTML markup for these radio
    buttons is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Example 3-12\. Test using advanced locators with XPath
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_webdriver_fundamentals_CO11-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We use XPath to locate the checked radio buttons.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_webdriver_fundamentals_CO11-2)'
  prefs: []
  type: TYPE_NORMAL
- en: We check the element id is as expected.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_webdriver_fundamentals_CO11-3)'
  prefs: []
  type: TYPE_NORMAL
- en: We confirm the selected is checked.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_webdriver_fundamentals_CO11-4)'
  prefs: []
  type: TYPE_NORMAL
- en: We use XPath to locate the unchecked radio buttons.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_webdriver_fundamentals_CO11-5)'
  prefs: []
  type: TYPE_NORMAL
- en: We check the element id is as expected.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_webdriver_fundamentals_CO11-6)'
  prefs: []
  type: TYPE_NORMAL
- en: We confirm the selected is unchecked.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '[“What Strategy Should You Use?”](#what-strategy) provides a comparison between
    CSS selectors and XPath and gives some hints for selecting one or another locator
    strategies.'
  prefs: []
  type: TYPE_NORMAL
- en: Finding Locators on a Web Page
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As introduced in [Table 1-4](ch01.html#locators) in [Chapter 1](ch01.html#ch01),
    there are different tools we can use to help generate locators for our WebDriver
    tests. This section shows how to use the main features of the built-in developer
    tools in major browsers, i.e., [Chrome DevTools](https://developer.chrome.com/docs/devtools)
    for Chromium-based browsers (e.g., Chrome and Edge) and [Firefox Developer Tools](https://developer.mozilla.org/en-US/docs/Tools)
    (for Firefox).
  prefs: []
  type: TYPE_NORMAL
- en: You can open both of these developer tools by right-clicking on the portion
    of the web page UI that you want to test and then selecting the option menu *Inspect*.
    [Figure 3-3](#chrome-devtools) shows a screenshot of Chrome DevTools placed at
    the bottom of the browser (you can move it if you want).
  prefs: []
  type: TYPE_NORMAL
- en: Developer tools provide different ways to locate elements in a web page. First,
    we use the element selector by clicking on the icon (an arrow over a box) in the
    upper left corner of the developer tools pane. Then, we can move the mouse over
    the page to highlight each web element and inspect the elements panel to check
    their markup, attributes, etc.
  prefs: []
  type: TYPE_NORMAL
- en: '![hosw 0303](assets/hosw_0303.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-3\. Use of Chrome DevTools while navigating the practice site
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the same view, we can use the tool to copy its CSS or XPath selector by right-clicking
    on the element and then selecting the menu option “Copy.” This mechanism allows
    getting the full CSS or XPath selector. It can be the first approach to generate
    a locator quickly, although I do not recommend using these locators directly since
    they tend to be brittle (i.e., linked to the current page layout) and are hard
    to read.
  prefs: []
  type: TYPE_NORMAL
- en: To create robust CSS or XPath locators, we need to think about the specific
    characteristics of the web pages we are working with and create a custom selector
    based on that knowledge. Again, the developer tools can help us in this task.
    We can press the key combination Ctrl + F to search by string, CSS selector, or
    XPath in Chrome DevTools. [Figure 3-4](#chrome-devtools-search-selector) shows
    an example of this feature in action.
  prefs: []
  type: TYPE_NORMAL
- en: Notice we are using the practice web form, and we type the string `#my-text-id`,
    which corresponds to the element with a given id using a CSS selector. DevTools
    found the web element on the page and highlighted it.
  prefs: []
  type: TYPE_NORMAL
- en: '![hosw 0304](assets/hosw_0304.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-4\. Searching CSS selector in Chrome DevTools
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We can use a similar approach in Firefox. We need to use the console panel and
    type `$$("css-selector")` for searching by CSS selector or `$x("xpath-query")`
    for XPath queries. [Figure 3-5](#firefox-devtools-search-selector) shows how to
    locate the first input text element of the practice web form by id, using a CSS
    selector and an XPath query.
  prefs: []
  type: TYPE_NORMAL
- en: '![hosw 0305](assets/hosw_0305.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-5\. Searching CSS selector and XPath in Firefox Developer Tools
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Compound Locators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Selenium WebDriver API has several support classes that enable the composition
    of the different locator types we have seen. These classes are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ByIdOrName(String idOrName)`'
  prefs: []
  type: TYPE_NORMAL
- en: It seeks by id, and if that is not available, it seeks by name.
  prefs: []
  type: TYPE_NORMAL
- en: '`ByChained(By... bys)`'
  prefs: []
  type: TYPE_NORMAL
- en: It seeks elements in a sequence (i.e., the second one should appear inside the
    first one, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: '`ByAll(By... bys)`'
  prefs: []
  type: TYPE_NORMAL
- en: It seeks elements that match a number of location strategies (following an *and*
    logic condition for these locators).
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 3-13](#by-id-or-name) shows a test using `ByIdOrName`. This test looks
    for the following file-select field available in the practice web form. Notice
    that this field specifies the attribute `name` (but not `id`).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Example 3-13\. Test using by id or name compound locator
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_webdriver_fundamentals_CO12-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We use a locator by id or name.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_webdriver_fundamentals_CO12-2)'
  prefs: []
  type: TYPE_NORMAL
- en: We check the element has the attribute `name`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_webdriver_fundamentals_CO12-3)'
  prefs: []
  type: TYPE_NORMAL
- en: We verify the absence of the attribute `name` in the same element.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 3-14](#by-chained-all) shows two tests illustrating the difference
    between `ByChained` and `ByAll`. Both locators use the practice web form again.
    If you inspect its source code, you will notice that there are three single `<div
    class="row">` inside the `<form>`.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-14\. Test using by chained and by all compound locators
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_webdriver_fundamentals_CO13-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We use the locator using `ByChained`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_webdriver_fundamentals_CO13-2)'
  prefs: []
  type: TYPE_NORMAL
- en: We find one element since only one `row` element is within the form.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_webdriver_fundamentals_CO13-3)'
  prefs: []
  type: TYPE_NORMAL
- en: We use the locator using `ByAll`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_webdriver_fundamentals_CO13-4)'
  prefs: []
  type: TYPE_NORMAL
- en: We find five elements, since the locator matches a `<form>` element plus four
    `<div class="row">` available on the page.
  prefs: []
  type: TYPE_NORMAL
- en: Relative Locators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Selenium WebDriver version 4 incorporates a new way to find elements in a web
    page: *relative locators*. These new locators aim to find web elements relative
    to another known element. This feature is based on the CSS *box model*. The model
    determines that each element of a web document is rendered using a rectangular
    box. [Figure 3-6](#box-model) shows an example of this box model for a given web
    element in the practice form.'
  prefs: []
  type: TYPE_NORMAL
- en: '![hosw 0306](assets/hosw_0306.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-6\. Practice form showing the box model of a web element
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Using this box model, the relative locators available in the Selenium WebDriver
    API allow finding elements in relation to the position of another web element.
    To this aim, first, we need to locate that web element using the standard location
    strategies (e.g., by id, name, attribute, etc.). Then, we need to specify the
    locator type obtained by proximity to the original web element using the static
    method `with` of the class `RelativeLocator`. As a result, we get a `RelativeBy`
    object, which extends the abstract class `By`, used in the standard locator strategies.
    A `RelativeBy` object provides the following methods to carry out relative location:'
  prefs: []
  type: TYPE_NORMAL
- en: '`above()`'
  prefs: []
  type: TYPE_NORMAL
- en: Finds element(s) located on the top of the original element.
  prefs: []
  type: TYPE_NORMAL
- en: '`below()`'
  prefs: []
  type: TYPE_NORMAL
- en: Finds element(s) located under the original element.
  prefs: []
  type: TYPE_NORMAL
- en: '`near()`'
  prefs: []
  type: TYPE_NORMAL
- en: Finds element(s) located close to the original element. The default distance
    to consider an element near to some other is one hundred pixels. This locator
    is overloaded to specify another distance.
  prefs: []
  type: TYPE_NORMAL
- en: '`toLeftOf()`'
  prefs: []
  type: TYPE_NORMAL
- en: Finds element(s) located at the left side of the original element.
  prefs: []
  type: TYPE_NORMAL
- en: '`toRightOf()`'
  prefs: []
  type: TYPE_NORMAL
- en: Finds element(s) located at the right side of the original element.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 3-15](#relative_locators_examples) shows a basic test using relative
    locators. Once again, we use the practice web form to illustrate this feature.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-15\. Test using relative locators
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_webdriver_fundamentals_CO14-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We locate the link whose text is `Return to index`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_webdriver_fundamentals_CO14-2)'
  prefs: []
  type: TYPE_NORMAL
- en: We specify the relative locator type, which will be by tag name the `input`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_webdriver_fundamentals_CO14-3)'
  prefs: []
  type: TYPE_NORMAL
- en: We use a relative locator to find a web element (which should be an `input`
    filed) above the original web element (i.e., a link).
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_webdriver_fundamentals_CO14-4)'
  prefs: []
  type: TYPE_NORMAL
- en: We verify the element above the reference link is a read-only field (see [Figure 3-2](#practice-site-web-form)
    to double-check it).
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Relative locators can be helpful for finding elements based on the relative
    position of other elements. On the other hand, this strategy can be very sensitive
    to page layout. For example, you need to be careful when using relative locators
    in responsive pages since the layout can vary depending on the viewport.
  prefs: []
  type: TYPE_NORMAL
- en: A challenging example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The examples we have seen so far are reasonably simple. Let’s now look at a
    more complex use case. A nondefault element in the practice web is the *date picker*.
    As its name suggests, this element provides a handy way to select dates using
    a web GUI. Since the CSS framework used in the practice site is [Bootstrap](https://getbootstrap.com),
    I implemented the date picker using [bootstrap-datepicker](https://github.com/uxsolutions/bootstrap-datepicker).
    This date picker is attached to an input field. When the user clicks on this field,
    a calendar appears on the web page (see [Figure 3-7](#date-picker-gui)). The user
    can select a given date by clicking the preferred date by navigating to the different
    days, months, and years.
  prefs: []
  type: TYPE_NORMAL
- en: '![hosw 0307](assets/hosw_0307.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-7\. Date picker in the practice web form
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We want to implement an automated test using Selenium WebDriver that selects
    the current day and month but the previous year by interacting with the date picker
    GUI. [Example 3-16](#datepiker_example) shows the resulting implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: To follow this example, I recommend you open the practice web form (see URL
    in the code example) in your browser and use the developer tools to inspect the
    internal elements of the date picker selector, paying attention to the different
    selector strategies used.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-16\. Test interacting with a date picker
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_webdriver_fundamentals_CO15-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Get the current date from the system clock. We use the standard `java.time`
    API for this.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_webdriver_fundamentals_CO15-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the date picker to open the calendar. We use a locator by name (`By.name("my-date")`).
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_webdriver_fundamentals_CO15-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the current month by searching by text. We use an XPath query for this
    locator. After this step, the rest of the months of the year appear in the date
    picker GUI.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_webdriver_fundamentals_CO15-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the left arrow using relative locators (i.e., right of the month element).
    After this step, the calendar moves to the previous year.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_webdriver_fundamentals_CO15-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the current month of that year. We use a CSS selector here.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_webdriver_fundamentals_CO15-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the present day in that month. We use an XPath query in this step.
    After the click, the date is selected, and the value appears in the input text.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](assets/7.png)](#co_webdriver_fundamentals_CO15-7)'
  prefs: []
  type: TYPE_NORMAL
- en: Get the final date on the input text. We use a basic locator by attribute here.
  prefs: []
  type: TYPE_NORMAL
- en: '[![8](assets/8.png)](#co_webdriver_fundamentals_CO15-8)'
  prefs: []
  type: TYPE_NORMAL
- en: Assert that the expected date is equal to the one selected in the date picker.
    We calculate the expected date using standard Java, and as usual, AssertJ for
    the assertion.
  prefs: []
  type: TYPE_NORMAL
- en: What Strategy Should You Use?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we review the different alternatives the Selenium WebDriver
    API allows for locating elements in a web page. This topic is one of the most
    fundamental routines for browser automation with Selenium WebDriver. Maybe you
    are asking yourself: *What is the best strategy I should use?* As Dr. Alfred Lanning
    (character in the novel and movie *I, Robot*) would say: “That, detective, is
    the right question.” In my opinion, that is a difficult question, and it has no
    simple answer. In other words, the answer to this question could be “it depends.”
    This section presents several hints for identifying a suitable locator strategy
    for common use cases. First, [Table 3-8](#locator-comparison) compares the different
    locating strategies.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 3-8\. Pros, cons, and typical use cases of the different locating strategies
  prefs: []
  type: TYPE_NORMAL
- en: '| Locator | Pros | Cons | Typical use case |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| By attribute (id, name, class) | Easy to use | These attributes are not always
    available | Elements that define these attributes immutably (i.e., it does not
    change dynamically) |'
  prefs: []
  type: TYPE_TB
- en: '| By link text (total or partial) | Easy to use | Only available for links
    | For text links |'
  prefs: []
  type: TYPE_TB
- en: '| By tag name | Easy to use | Hard to select one specific element when the
    tag repeatedly appears on the page | When the tag is unique, or the resulting
    DOM node has a fixed position |'
  prefs: []
  type: TYPE_TB
- en: '| By CSS selector or by XPath | Very powerful | It is not easy to write robust
    selectors | For complex locators |'
  prefs: []
  type: TYPE_TB
- en: '| Compound locators | Easy way to compose existing locators | Limited to specific
    situations | When looking for id or name (`ByIdOrName`), when looking for nested
    elements (`ByChained`), and when using several strategies at the same time (`ByAll`)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Relative locators | Human language approach | It needs to be combined with
    other locators | Find element based on the relative position (above, below, near,
    etc.) of a known element |'
  prefs: []
  type: TYPE_TB
- en: As you can see in this table, CSS selectors and XPath share the same pros, cons,
    and use cases. Does it mean these strategies are the same? The answer is no. Both
    are very powerful and allow the creation of complex locators. Nevertheless, there
    are relevant distinctions between them. [Table 3-9](#css-xpath-comparison) summarizes
    these differences.
  prefs: []
  type: TYPE_NORMAL
- en: Table 3-9\. Some differences between XPath and CSS selector
  prefs: []
  type: TYPE_NORMAL
- en: '| XPath | CSS selector |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| XPath allows bidirectional location, i.e., the traversal can be from parent
    to child and vice versa | CSS allows one-directional locations, i.e., the traversal
    is from parent to child only |'
  prefs: []
  type: TYPE_TB
- en: '| XPath is slower in terms of performance | CSS has faster performance than
    XPath |'
  prefs: []
  type: TYPE_TB
- en: '| XPath allows the identification of visible text on the screen using the `text()`
    function | CSS does not allow locating elements by its text content |'
  prefs: []
  type: TYPE_TB
- en: To better illustrate the difference between XPath and CSS selectors, [Table 3-10](#css-xpath-comparison-examples)
    compares specific locators using both strategies.
  prefs: []
  type: TYPE_NORMAL
- en: Table 3-10\. Examples comparing XPath and CSS selector
  prefs: []
  type: TYPE_NORMAL
- en: '| Locator | XPath | CSS selector |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| All elements | `//*` | `*` |'
  prefs: []
  type: TYPE_TB
- en: '| All `<div>` elements | `//div` | `div` |'
  prefs: []
  type: TYPE_TB
- en: '| Element by id | `//*[@id=''my-id'']` | `#my-id` |'
  prefs: []
  type: TYPE_TB
- en: '| Element by class | `//*[contains(@class=''my-class'')]` | `.my-class` |'
  prefs: []
  type: TYPE_TB
- en: '| Element with attribute | `//*[@attr]` | `*[attr]` |'
  prefs: []
  type: TYPE_TB
- en: '| Find by text in a `<div>` | `//div[text()=''search-string'']` | Not possible
    |'
  prefs: []
  type: TYPE_TB
- en: '| First child of a `<div>` | `//div/*[1]` | `div>*:first-child` |'
  prefs: []
  type: TYPE_TB
- en: '| All `<div>` with a link child | `//div[a]` | Not possible |'
  prefs: []
  type: TYPE_TB
- en: '| Next element in a `<div>` | `//div/following-sibling::*[1]` | `div + *` |'
  prefs: []
  type: TYPE_TB
- en: '| Previous element of a `<div>` | `//div/preceding-sibling::*[1]` | Not possible
    |'
  prefs: []
  type: TYPE_TB
- en: In conclusion, we can see that XPath provides the most general strategy. Nevertheless,
    there are some cases in which the CSS selectors offer a friendlier syntax (e.g.,
    locating by id or class) and better general performance.
  prefs: []
  type: TYPE_NORMAL
- en: Keyboard Actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As introduced in [Table 3-3](#webelement-methods), two main methods in `WebDriver`
    objects allow impersonating keyboard user actions: `sendKeys()` and `clear()`.
    [Example 3-17](#keyboard_basic) shows a test using these methods.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-17\. Test impersonating keyboard events
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_webdriver_fundamentals_CO16-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We use the practice web form to locate the input text named `my-text`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_webdriver_fundamentals_CO16-2)'
  prefs: []
  type: TYPE_NORMAL
- en: We simulate a keyboard typing on it using the method `sendKeys()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_webdriver_fundamentals_CO16-3)'
  prefs: []
  type: TYPE_NORMAL
- en: We assess the input value is as expected.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_webdriver_fundamentals_CO16-4)'
  prefs: []
  type: TYPE_NORMAL
- en: We reset its content using `clear()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_webdriver_fundamentals_CO16-5)'
  prefs: []
  type: TYPE_NORMAL
- en: We assess the input value is empty.
  prefs: []
  type: TYPE_NORMAL
- en: File Uploading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are several use cases in which we will need to impersonate keyboard actions
    when interacting with web pages through Selenium WebDriver. The first one is file
    uploading. The standard mechanism to upload files for web applications is using
    `<input>` elements with `type="file"`. For instance, the practice web form contains
    one of these elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: The Selenium WebDriver API does not provide a mechanism to handle file inputs.
    Instead, we should treat input elements for uploading files as regular text inputs,
    so we need to simulate the user typing them. In particular, we need to type the
    absolute file path to be uploaded. [Example 3-18](#upload_file) illustrates how.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-18\. Test uploading a file
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_webdriver_fundamentals_CO17-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We locate the input field using a by-name strategy.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_webdriver_fundamentals_CO17-2)'
  prefs: []
  type: TYPE_NORMAL
- en: We create a temporal file using standard Java.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_webdriver_fundamentals_CO17-3)'
  prefs: []
  type: TYPE_NORMAL
- en: We type its absolute path to the input field.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_webdriver_fundamentals_CO17-4)'
  prefs: []
  type: TYPE_NORMAL
- en: We submit the form.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_webdriver_fundamentals_CO17-5)'
  prefs: []
  type: TYPE_NORMAL
- en: We verify that the resulting page (defined in `action` form attribute) is different
    from the initial web page.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The file path sent to the input file should correspond to an existing archive
    in the machine running the test. Otherwise, the test fails with an `InvalidArgumentException`
    exception. See [“WebDriver Exceptions”](ch04.html#exceptions) in [Chapter 5](ch05.html#ch05)
    for further details about exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: When uploading a file to a remote browser (as explained in [Chapter 6](ch06.html#ch06)),
    we need to load the file from the local file system explicitly. The following
    line shows how to specify a local file detector.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: Range Sliders
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A similar situation happens with `<input type="range">` form fields. These
    elements allow users to select a number in a range using a graphical slider. You
    can find an example in the practice web form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: Again, the Selenium WebDriver API does not provide any particular utility to
    handle these fields. We can interact with them by impersonating keyboard actions
    with Selenium WebDriver. [Example 3-19](#slider) shows a test interaction with
    these fields.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-19\. Test selecting a number with a form slider
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_webdriver_fundamentals_CO18-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We send a keyboard key to the range field available in the practice web form.
    We use the class `Keys` available in the Selenium WebDriver API to handle special
    keyboard characters. In particular, we send the right arrow key to the slider,
    and as a result, it moves to the right (i.e., it increases the selected number
    within the range).
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_webdriver_fundamentals_CO18-2)'
  prefs: []
  type: TYPE_NORMAL
- en: We assert the resulting selected value is different from the one in the original
    position.
  prefs: []
  type: TYPE_NORMAL
- en: Mouse Actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In addition to the keyboard, the other primary input device for interacting
    with web applications is the computer mouse. First of all, the single-click (also
    known as left-click or simply *click*) is impersonated by the Selenium WebDriver
    API using the method `click()`, which is one of the methods available per `WebElement`
    in Selenium WebDriver. This section shows examples of two typical use cases using
    this feature: web navigation and interaction with checkboxes and radio buttons
    in web forms.'
  prefs: []
  type: TYPE_NORMAL
- en: Other common mouse actions are right-clicking (also known as *context-click*),
    double-clicking, cursor movement, drag and drop, or mouseover. Selenium WebDriver
    allows impersonating these actions using a helper class called `Actions`. See
    the next section for further details. Finally, scrolling is possible in WebDriver
    by executing JavaScript. I explain this feature in [“Executing JavaScript”](ch04.html#js).
  prefs: []
  type: TYPE_NORMAL
- en: Web Navigation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Example 3-20](#basic-navigation) shows a test implementing automated web navigation
    with Selenium WebDriver. This test locates links using XPath and clicks on them,
    invoking the method `click()`. In the end, it reads the text content of the web
    page `body` and verifies it contains an expected string.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-20\. Test navigating by clicking on links
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: Checkboxes and Radio Buttons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Example 3-21](#checkbox-radio) shows another basic use of the `click()` method
    for manipulating checkboxes and radio buttons. To verify the expected state of
    these elements after the click action, we use an assertion based on the result
    of the `isSelected()` method.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-21\. Test interacting with checkboxes and radio buttons
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: User Gestures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Selenium WebDriver provides the class `Actions`, a powerful asset to automate
    different user actions, both for keyboard and mouse. This class follows the *builder*
    pattern. This way, you can chain several methods (i.e., different actions) and
    perform all of them at the end by calling `build()`. [Table 3-11](#actions-methods)
    summarizes the public methods available in this class. We review these methods
    through examples in the following subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Table 3-11\. Actions methods
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '| Send a single key (it could be a special character using the class `Keys`)
    in the current position (or a given element). The key remains pressed until calling
    to `keyUp()`. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '| Release a key previously pressed with `keyDown()`. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '| Send a key sequence in the current position (or a given element). This method
    is different from `WebElement#sendKeys(CharSequence...)` in two ways: 1) Modifier
    keys (e.g., `Keys.CONTROL`, `Keys.SHIFT`) are not released explicitly. 2) There
    is no refocus on the element, so `Keys.TAB` should work. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '| Click without releasing the current position (or the middle of a given element).
    |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '| Release the left-click mouse button previously pressed with `clickAndHold()`.
    |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '| Click on the current position (or a given element). |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '| Double-click on the current position (or element). |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '| Right-click on the current position (or element). |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '| Move mouse cursor to the middle (or shifted to a given offset) of a given
    element. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '| Move the mouse from its current position (`0,0` by default) by the given
    offset. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '| This action consists of three steps: 1) Click and hold at the middle (or
    shifted by a given offset) of the source element location. 2) Move the mouse to
    the target element location. 3) Release the mouse click. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '| Perform a pause in the actions chain (in milliseconds or using a Java `Duration`).
    |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '| Generate a composite action containing all previous actions. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '| Execute the composite action. |'
  prefs: []
  type: TYPE_TB
- en: Right-Click and Double-Click
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can find a demo page using three dropdown menus on the practice site (see
    [Figure 3-8](#dropdown-menus)). On this page, the first dropdown menu appears
    when clicking on its button, the second one uses the right-click, and the third
    one requires a double-click. [Example 3-22](#right_double_click) shows a test
    using this page to impersonate user gestures through the WebDriver class `Actions`.
  prefs: []
  type: TYPE_NORMAL
- en: '![hosw 0308](assets/hosw_0308.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-8\. Practice web page with dropdown menus
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Example 3-22\. Test using context and double-click
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_webdriver_fundamentals_CO19-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We use `contextClick()` in the middle dropdown menu.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_webdriver_fundamentals_CO19-2)'
  prefs: []
  type: TYPE_NORMAL
- en: We verify the middle menu is correctly displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_webdriver_fundamentals_CO19-3)'
  prefs: []
  type: TYPE_NORMAL
- en: We use `doubleClick()` in the right dropdown menu.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_webdriver_fundamentals_CO19-4)'
  prefs: []
  type: TYPE_NORMAL
- en: We verify the right menu is correctly displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Mouseover
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The second example handling `Actions` uses a sample web page implementing a
    mouseover. This page displays four images. Each one shows a text label below the
    image when the mouse pointer is over. [Example 3-23](#mouse-over-java) contains
    a test that uses this page. [Figure 3-9](#mouse-over) shows this page when the
    mouse is over the first picture.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-23\. Test using mouseover
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_webdriver_fundamentals_CO20-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We iterate a string list to locate the four images of the page.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_webdriver_fundamentals_CO20-2)'
  prefs: []
  type: TYPE_NORMAL
- en: We use XPath to find each `<img>` web element.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_webdriver_fundamentals_CO20-3)'
  prefs: []
  type: TYPE_NORMAL
- en: We use `moveToElement()` to move the mouse pointer to the middle of each image.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_webdriver_fundamentals_CO20-4)'
  prefs: []
  type: TYPE_NORMAL
- en: We use relative locators to find the displayed label.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_webdriver_fundamentals_CO20-5)'
  prefs: []
  type: TYPE_NORMAL
- en: We use assertions to verify that the text is as expected.
  prefs: []
  type: TYPE_NORMAL
- en: '![hosw 0309](assets/hosw_0309.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-9\. Practice web page with mouse-over images
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Drag and Drop
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Example 3-24](#drag-and-drop-java) illustrates the use of drag and drop. This
    test uses the practice web shown in [Figure 3-10](#drag-and-drop).'
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-24\. Test using drag and drop
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_webdriver_fundamentals_CO21-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We locate the *draggable* element.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_webdriver_fundamentals_CO21-2)'
  prefs: []
  type: TYPE_NORMAL
- en: We use `dragAndDropBy()` to move this element a fixed number of pixels (`100`)
    four times (right, bottom, left, and up).
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_webdriver_fundamentals_CO21-3)'
  prefs: []
  type: TYPE_NORMAL
- en: We assert the element position is the same as the beginning.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_webdriver_fundamentals_CO21-4)'
  prefs: []
  type: TYPE_NORMAL
- en: We find a second element (not draggable this time).
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_webdriver_fundamentals_CO21-5)'
  prefs: []
  type: TYPE_NORMAL
- en: We use `dragAndDrop()` to move the draggable element to the second one.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_webdriver_fundamentals_CO21-6)'
  prefs: []
  type: TYPE_NORMAL
- en: We assert the position of both elements is the same.
  prefs: []
  type: TYPE_NORMAL
- en: '![hosw 0310](assets/hosw_0310.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-10\. Practice web page with a draggable element
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Click and Hold
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following example shows complex user gestures, including click and hold.
    To that aim, we practice with the web page in [Figure 3-11](#draw-in-canvas).
  prefs: []
  type: TYPE_NORMAL
- en: '![hosw 0311](assets/hosw_0311.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-11\. Practice web page with a drawable canvas
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This page uses an open source JavaScript library called [Signature Pad](https://github.com/szimek/signature_pad)
    to draw signatures in HTML canvas using the mouse. [Example 3-25](#draw-in-canvas-java)
    shows a test using it.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-25\. Test drawing a circumference on a canvas
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_webdriver_fundamentals_CO22-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We locate the canvas by tag name.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_webdriver_fundamentals_CO22-2)'
  prefs: []
  type: TYPE_NORMAL
- en: We move the mouse to this element with `moveToElement()` and then add the action
    `clickAndHold()` (for drawing into the canvas) to the actions pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_webdriver_fundamentals_CO22-3)'
  prefs: []
  type: TYPE_NORMAL
- en: We iterate using a fixed number of points, using the equation to find the points
    in a circumference.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_webdriver_fundamentals_CO22-4)'
  prefs: []
  type: TYPE_NORMAL
- en: We use the circumference points (`x` and `y`) to move the mouse by offset (`moveByOffset()`).
    Since the click is held from the previous step, the resulting compound action
    will move the mouse while the click button is pressed.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_webdriver_fundamentals_CO22-5)'
  prefs: []
  type: TYPE_NORMAL
- en: We release the click, build the action, and carry out the whole chain. As a
    result, a circumference should appear on the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: Copy and Paste
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This last example for user gestures automates a pervasive user action: copy
    and paste using the keyboard. Here, we use the web form available on the practice
    website. [Example 3-26](#copy_paste) shows a test impersonating copy and paste.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-26\. Test impersonating copy and paste
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_webdriver_fundamentals_CO23-1)'
  prefs: []
  type: TYPE_NORMAL
- en: 'We locate two web elements: an input text and a text area.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_webdriver_fundamentals_CO23-2)'
  prefs: []
  type: TYPE_NORMAL
- en: We use a modifier key for sending the combination Ctrl + C for copying (in Windows
    and Linux) or Cmd + C for copying (in macOS). To this aim, we use the class `SystemUtils`,
    available in the open source library [Apache Commons IO](https://commons.apache.org/proper/commons-io)
    (this dependency is used transitively in the Maven/Gradle project).
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_webdriver_fundamentals_CO23-3)'
  prefs: []
  type: TYPE_NORMAL
- en: 'We implement the actions chain composed of the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Send the char sequence `hello world` to the input text.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press the key modifier (Ctrl or Cmd, depending on the operating system). Remember
    that this key remains pressed until we explicitly release it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We send the key `a` to the input text. Since the modifier is active, the resulting
    combination is Ctrl + A (or Cmd + A), and as a result, all the text present in
    the input text is selected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We send the key `c` to the input text. Again, since the modifier is active,
    the combination is Ctrl + C (or Cmd + C), and the input text is copied to the
    clipboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We send the key `v` to the text area. This means sending Ctrl + V (or Cmd +
    V), and the clipboard content is pasted to the text area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_webdriver_fundamentals_CO23-4)'
  prefs: []
  type: TYPE_NORMAL
- en: We assert the content of both elements (input text and text area) is the same
    at the end of the text.
  prefs: []
  type: TYPE_NORMAL
- en: Waiting Strategies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Web applications are client-server distributed services in which the clients
    are the web browsers and the web servers are usually remote hosts. The intermediate
    network latency could affect the reliability of a WebDriver test. For instance,
    in the case of high-latency networks or overloaded servers, a slow response might
    negatively affect the expected conditions of WebDriver tests. In addition, modern
    web applications tend to be dynamic and asynchronous. Nowadays, JavaScript allows
    executing nonblocking (i.e., asynchronous) operations using different mechanisms,
    such as callbacks, promises, or async/await. In addition, we can retrieve data
    from other servers asynchronously, for example, using AJAX (Asynchronous JavaScript
    and XML) or REST (REpresentational State Transfer) services.
  prefs: []
  type: TYPE_NORMAL
- en: All in all, it is of paramount importance to have mechanisms pause and wait
    for certain conditions in our WebDriver tests. For this reason, the Selenium WebDriver
    API provides different waiting assets. The three principal waiting strategies
    are *implicit*, *explicit*, and *fluent* waits. The following subsections explain
    and show examples.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: For waiting in Java, you might think about including `Thread.sleep()` commands
    in your code. On the one hand, it is a simple solution, but on the other hand,
    it is considered a *bad smell* (i.e., a weak sign) that could lead to unreliable
    tests (since the delay conditions can change). As a general rule, I strongly discourage
    you from using it. Instead, consider using the aforementioned wait strategies.
  prefs: []
  type: TYPE_NORMAL
- en: Implicit Wait
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first waiting strategy provided by Selenium WebDriver is called *implicit*.
    This mechanism allows specifying an amount of time before throwing an exception
    when finding an element. By default, this wait has a value of zero seconds (i.e.,
    it does not wait at all). But when we define an implicit wait value, Selenium
    WebDriver polls the DOM during the implicit wait value when trying to find an
    element. The poll time is specific to the driver implementation and is frequently
    less than five hundred ms. If the element is present in the elapsed time, the
    script continues. Otherwise, it throws an exception.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 3-27](#implicit_wait_test) illustrates this strategy. This test uses
    a practice page (see [Figure 3-12](#loading-page)) that dynamically loads several
    images into the DOM. Since these images are not available just before the page
    is loaded, we need to wait for these images to be available.'
  prefs: []
  type: TYPE_NORMAL
- en: '![hosw 0312](assets/hosw_0312.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-12\. Practice web page loading images
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Example 3-27\. Test using an implicit wait in the “loading images” page
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_webdriver_fundamentals_CO24-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Before interacting with the elements, we specify an implicit wait strategy.
    In this case, we set up a timeout of 10 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_webdriver_fundamentals_CO24-2)'
  prefs: []
  type: TYPE_NORMAL
- en: In the following calls, we use the Selenium WebDriver API as usual.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can play with this feature by dropping the implicit wait from the test (step
    1). If you do that, you will notice that the test fails in step 2 due to a `NoSuchElementException`.
  prefs: []
  type: TYPE_NORMAL
- en: Although supported by the Selenium WebDriver API, implicit waits have different
    inconveniences you need to know. First, an implicit wait only works on finding
    elements. Second, we cannot customize its behavior since its implementation is
    driver-specific. Finally, and since implicit waits are applied globally, checking
    for the absence of web elements usually increases the execution time for the entire
    script. For these reasons, implicit waits are typically considered bad practice
    in most cases, and explicit and fluent waits are preferred instead.
  prefs: []
  type: TYPE_NORMAL
- en: Explicit Wait
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The second waiting strategy, called *explicit*, allows pausing the test execution
    a maximum amount of time until a specific condition happens. To use this strategy,
    we need to create an instance of `WebDriverWait`, using the `WebDriver` object
    as the first constructor argument, and an instance of `Duration` as the second
    argument (to specify the timeout).
  prefs: []
  type: TYPE_NORMAL
- en: Selenium WebDriver provides a comprehensive set of expected conditions using
    the `ExpectedConditions` class. These conditions are very readable, and it does
    not require further explanation to understand their purpose. I recommend you use
    an autocomplete feature in your favorite IDE to discover all the possibilities.
    For example, [Figure 3-13](#expected-conditions-eclipse) shows this list in Eclipse.
  prefs: []
  type: TYPE_NORMAL
- en: '![hosw 0313](assets/hosw_0313.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-13\. Autocomplete in Eclipse for the ExpectedConditions class
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '[Example 3-28](#explicit_wait) shows a test using an explicit wait. In the
    example, we use the `presenceofElementLocated` condition to wait until one of
    the images is available on the practice web page.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-28\. Test using an explicit wait in the “loading images” page
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_webdriver_fundamentals_CO25-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We create the `wait` instance. In this case, the selected timeout is 10 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_webdriver_fundamentals_CO25-2)'
  prefs: []
  type: TYPE_NORMAL
- en: We explicitly wait for a given condition (in this case, the presence of a given
    element) by invoking the `until()` method in the `WebDriverWait` object. To achieve
    a more readable statement, you can also statically import this expected condition
    (`presenceOfElementLocated`). In this book, I decided to keep the class name (`ExpectedConditions`)
    in these conditions to ease the autocomplete feature in IDEs as described before.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 3-29](#explicit_wait_2) shows another test using explicit waits. This
    test uses another practice web page called “slow calculator,” which contains a
    GUI of a basic calculator, tuned to wait a configurable time to get the result
    of basic arithmetic operations (by default, five seconds). [Figure 3-14](#slow-calculator)
    shows a screenshot of this page.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-29\. Test using an explicit wait in the “slow calculator” page
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_webdriver_fundamentals_CO26-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We use XPath locators to click the buttons corresponding to operation 1 + 3.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_webdriver_fundamentals_CO26-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Since the test should wait until the result is ready, we explicitly wait for
    that. In this case, the condition is the text of the element with a class name
    `screen` is equal to 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![hosw 0314](assets/hosw_0314.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-14\. Practice web page with the “slow calculator” demo
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Fluent Wait
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last strategy is a *fluent* wait. This mechanism is a generalization of
    explicit waits. In other words, we use fluent waits for pausing the test until
    certain conditions, but in addition, fluent waits provide fine-grained configuration
    capabilities. [Table 3-12](#fluentwait-methods) summarizes the methods available
    in `FluentWait`. As its name suggests, this class provides a fluent API, and therefore,
    we can chain several invocations in the same line. [Example 3-30](#fluent_wait)
    shows a test using fluent wait.
  prefs: []
  type: TYPE_NORMAL
- en: Table 3-12\. Fluent wait methods
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: '| Timeout using Java `Duration` |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '| How often the condition is evaluated (five hundred ms by default) |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: '| Custom error message |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: '| Ignore specific exceptions while waiting for a condition |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: '| Expected condition |'
  prefs: []
  type: TYPE_TB
- en: Example 3-30\. Test using a fluent wait
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_webdriver_fundamentals_CO27-1)'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, this test is very similar to [Example 3-28](#explicit_wait),
    although using a `FluentWait` instance, we can specify additional characteristics.
    In this case, we change the poll time to one second.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The class `WebDriverWait` (presented in the previous subsection) extends the
    generic class `FluentWait`. Thus, you can use all the methods shown in [Table 3-12](#fluentwait-methods)
    for explicit waits too.
  prefs: []
  type: TYPE_NORMAL
- en: Summary and Outlook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter presented the foundations of the Selenium WebDriver API. First,
    you learned how to create and shut down `WebDriver` instances. These objects represent
    a browser controlled with Selenium WebDriver. This way, we use an instance of
    `ChromeDriver` for Chrome, `FirefoxDriver` for Firefox, etc. Second, you looked
    at `Web​Ele⁠ment`, a class representing different web page elements (e.g., links,
    images, form fields, etc.). Selenium WebDriver provides several strategies to
    locate web elements: by HTML attribute (id, name, or class), tag name, link text
    (complete or partial), CSS selector, and XPath. We also looked at a brand-new
    strategy of Selenium WebDriver 4 called relative locators. Then, we covered user
    actions’ impersonation, using the keyboard and the mouse. You can use these actions
    from simple actions (e.g., clicking a link, filling a text input, etc.) to complex
    user gestures (e.g., drag and drop, click and hover, etc.). Finally, we examined
    the ability to wait in Selenium WebDriver tests. This feature is critical due
    to the current distributed, dynamic, and asynchronous nature of web applications.
    There are three main wait strategies in Selenium WebDriver: implicit (specify
    a general timeout to wait for elements), explicit (pause test execution until
    a given condition), and fluent (extension of an explicit wait with some fine-grained
    setup).'
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter continues digging into the Selenium WebDriver API. In particular,
    [Chapter 4](ch04.html#ch04) reviews those interoperable features in different
    browsers (Chrome, Edge, Firefox, etc.). Among these features, you will discover
    how to execute JavaScript, specify event listeners, configure timeouts for page
    and script loading, manage the browser history, make screenshots, manipulate cookies,
    manipulate dropdown lists (i.e., selects and data lists), handle window targets
    (i.e., tabs, frames, and iframes) and dialog boxes (i.e., alerts, prompts, confirmation,
    and modal pop-ups), use web storage, and understand the WebDriver exceptions.
  prefs: []
  type: TYPE_NORMAL
