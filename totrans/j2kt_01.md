# 第一章。介绍

# 编程语言的纹理

像木头一样，编程语言也有纹理。在木工和编程中，当你顺着纹理工作时，事情会顺利进行。当你逆着纹理工作时，事情就更加困难。当你逆着编程语言的纹理工作时，你必须写比必要多的代码，性能下降，容易引入缺陷，通常必须覆盖便捷的默认设置，并且在每一步都必须与工具抗争。

逆流而上涉及不断努力，而收益却不确定。

例如，在 Java 8 之前，将 Java 代码编写成函数式风格是可能的，但很少有程序员这样做，原因很充分。

这里是 Kotlin 代码，通过使用加法运算符对列表中的数字进行折叠来计算它们的总和：

```java
val sum = numbers.fold(0, Int::plus)
```

让我们将其与 Java 1.0 中执行相同操作所需进行比较。

时光的雾气会在将您运送到 1995 年的过程中流逝…

Java 1.0 没有一等函数，所以我们必须将函数实现为对象，并为不同类型的函数定义自己的接口。例如，加法函数接受两个参数，因此我们必须定义两个参数函数的类型：

```java
public interface Function2 {
    Object apply(Object arg1, Object arg2);
}
```

然后我们必须编写 `fold` 高阶函数，隐藏 `Vector` 类所需的迭代和变异。（1995 年的 Java 标准库还不包括 Collections 框架。）

```java
public class Vectors {
    public static Object fold(Vector l, Object initial, Function2 f) {
        Object result = initial;
        for (int i = 0; i < l.size(); i++) {
            result = f.apply(result, l.get(i));
        }
        return result;
    }

    ... and other operations on vectors
}
```

我们必须为想要传递给我们的 `fold` 函数的每个函数定义单独的类。加法运算符不能作为值传递，并且该语言此时既没有方法引用，也没有 lambda 表达式或闭包，甚至没有内部类。Java 1.0 也没有泛型或自动装箱——我们必须将参数转换为预期类型，并在引用类型和基本类型之间进行装箱：

```java
public class AddIntegers implements Function2 {
    public Object apply(Object arg1, Object arg2) {
        int i1 = ((Integer) arg1).intValue();
        int i2 = ((Integer) arg2).intValue();
        return new Integer(i1 + i2);
    }
}
```

最后，我们可以使用所有这些来计算总和：

```java
int sum = ((Integer) Vectors.fold(counts, new Integer(0), new AddIntegers()))
    .intValue();
```

对于 2020 年主流语言中的单个表达式来说，这需要大量的努力。

但这还不是全部。因为 Java 没有标准的函数类型，我们无法轻松地组合以函数式风格编写的不同库。我们必须编写适配器类来映射不同库中定义的函数类型。而且，由于虚拟机没有 JIT 和简单的垃圾收集器，我们的函数式代码比命令式的替代方案性能更差：

```java
int sum = 0;
for (int i = 0; i < counts.size(); i++) {
    sum += ((Integer)counts.get(i)).intValue();
}
```

1995 年，写 Java 的函数式风格的付出，并不能带来足够的好处来证明其价值。Java 程序员发现编写迭代集合并改变状态的命令式代码更容易。

编写函数式代码 *违背了* Java 1.0 的纹理。

随着时间的推移，语言的粒度逐渐形成，设计者和用户在构建语言特性互动方面建立了共同的理解，并在库中编码他们的理解和偏好，供其他人基于此构建。这种粒度影响程序员在语言中编写代码的方式，进而影响语言及其库和编程工具的演变，改变粒度，改变程序员在语言中编写代码的方式，如此循环互动和演变不断进行。

例如，随着时间的推移，Java 1.1 向语言添加了匿名内部类，Java 2 向标准库添加了集合框架。匿名内部类意味着我们不需要为要传递给我们的`fold`函数的每个函数编写命名类，但由此产生的代码可能更难阅读：

```java
int sum = ((Integer) Lists.fold(counts, new Integer(0),
    new Function2() {
        public Object apply(Object arg1, Object arg2) {
            int i1 = ((Integer) arg1).intValue();
            int i2 = ((Integer) arg2).intValue();
            return new Integer(i1 + i2);
        }
    })).intValue();
```

功能性习惯仍然不符合 Java 2 的粒度。

快进到 2004 年，Java 5 是显著改变语言的下一个版本。它添加了泛型和自动装箱功能，增强了类型安全性并减少了样板代码：

```java
public interface Function2<A, B, R> {
    R apply(A arg1, B arg2);
}
```

```java
int sum = Lists.fold(counts, 0,
    new Function2<Integer, Integer, Integer>() {
        @Override
        public Integer apply(Integer arg1, Integer arg2) {
            return arg1 + arg2;
        }
    });
```

Java 开发者通常使用[Google 的 Guava 库](https://oreil.ly/dMX73)来为集合添加一些常见的高阶函数（尽管`fold`不在其中），但即使是 Guava 的作者也建议默认情况下编写命令式代码，因为它具有更好的性能并且通常更易读。

功能性编程仍然大多不符合 Java 5 的粒度，但我们可以看到一种趋势的开始。

Java 8 向语言添加了匿名函数（又称 lambda 表达式）和方法引用，并向标准库添加了 Streams API。编译器和虚拟机优化 lambda 以避免匿名内部类的性能开销。Streams API 充分支持功能性习惯，最终允许：

```java
int sum = counts.stream().reduce(0, Integer::sum);
```

然而，事情并非一帆风顺。我们仍然无法将加法运算符作为参数传递给 Streams 的`reduce`函数，但我们有标准库函数`Integer::sum`可以实现同样的功能。Java 的类型系统仍然因引用类型和原始类型之间的区别而产生一些尴尬的边缘情况。如果来自功能性语言（甚至是 Ruby），Streams API 缺少一些常见的高阶函数。检查异常与 Streams API 及功能性编程一般不兼容。而使用具有值语义的不可变类仍然涉及大量样板代码。但是，通过 Java 8，Java 在根本上已经改变，使功能风格运行起来，即使不完全符合语言的粒度，至少也不再与之相悖。

Java 8 之后的发布增加了多种较小的语言和库特性，支持更多功能性编程习惯，但并未改变我们的求和计算方式。这将我们带回到现代。

在 Java 的情况下，语言的粒度以及程序员对其的适应方式，通过几种不同的编程风格演变而来。

# Java 编程风格的一个有趣历史

像古代诗人一样，我们将 Java 编程风格的发展分为四个明显的时代：原始时代、豆子时代、企业时代和现代时代。

## 原始时代风格

最初设计用于家用电器和交互式电视，直到 Netscape 在其极其流行的 Navigator 浏览器中采用了 Java 小程序，Java 才真正起飞。Sun 发布了 Java 开发工具包 1.0，Microsoft 将 Java 包含在 Internet Explorer 中，突然之间，每个拥有 Web 浏览器的人都有了 Java 运行时环境。对 Java 作为一种编程语言的兴趣激增。

到那个时候，Java 的基本原理已经奠定了基础：

+   Java 虚拟机及其字节码和类文件格式

+   原始类型和引用类型，空引用，垃圾收集

+   类和接口，方法和控制流语句

+   用于错误处理的检查异常，抽象窗口工具包

+   用于与互联网和 Web 协议进行网络编程的类

+   在运行时加载和链接代码，由安全管理器沙箱化

但是，Java 还没有准备好进行通用编程：JVM 速度慢，标准库稀少。

Java 看起来像 C++ 和 Smalltalk 的混合体，这两种语言影响了当时的 Java 编程风格。其他语言的程序员取笑的 “getFoo/setFoo” 和 “AbstractSingletonProxyFactoryBean” 约定还没有普及。

Java 的一个未被赞扬的创新是官方的编码约定，明确了程序员应该如何命名包、类、方法和变量。C 和 C++ 程序员遵循了看似无穷无尽的编码约定，而结合了多个库的代码最终看起来像一顿狗的晚餐，显得有些不一致。Java 的唯一真正的编码约定意味着 Java 程序员可以将陌生的库无缝地集成到他们的程序中，并鼓励了一个持续发展的充满活力的开源社区。

## 豆子时代风格

在 Java 初始成功后，Sun 开始使其成为构建应用程序的实用工具。Java 1.1（1996 年）增加了语言特性（尤其是内部类），改进了运行时（尤其是即时编译和反射），并扩展了标准库。Java 1.2（1998 年）添加了标准集合 API 和 Swing 跨平台 GUI 框架，确保 Java 应用程序在每个桌面操作系统上看起来和感觉都一样笨拙。

当时，Sun 公司正密切关注微软和 Borland 在企业软件开发领域的主导地位。Java 有潜力成为 Visual Basic 和 Delphi 的强有力竞争对手。Sun 添加了一系列 API，这些 API 在很大程度上受到了微软 API 的启发：JDBC 用于数据库访问（相当于微软的 ODBC），Swing 用于桌面 GUI 编程（相当于微软的 MFC），以及对 Java 编程风格影响最大的框架，JavaBeans。

JavaBeans API 是 Sun 公司对微软 ActiveX 组件模型的回应，用于低代码、图形化、拖放式编程。Windows 程序员可以在其 Visual Basic 程序中使用 ActiveX 组件，或将其嵌入公司内部网的办公文档或网页中。尽管使用 ActiveX 组件非常容易，但编写它们却非常困难。JavaBeans 则简单得多；你只需遵循一些额外的编码约定，你的 Java 类就可以被视为一个“bean”，可以在图形化设计师中实例化和配置。“一次编写，到处运行”的承诺意味着你也可以在任何操作系统上使用或销售 JavaBean 组件，而不仅仅是在 Windows 上。

要使一个类成为 JavaBean，它需要有一个不带参数的构造函数，可以序列化，并声明由公共属性组成的 API，这些属性可以被读取和（可选地）写入，可以调用的方法，以及对象在类中发出的事件。这个理念是程序员可以在图形应用程序设计师中实例化 beans，通过设置它们的属性来配置它们，并将 beans 发出的事件连接到其他 beans 的方法。默认情况下，Beans API 通过以 *get* 和 *set* 开头的方法对来定义属性。虽然可以重写这个默认设置，但这样做需要程序员编写更多的样板代码。程序员通常只在将现有类改造为 JavaBeans 时才会这样做。在新代码中，沿着这个方向进行更容易。

Beans 风格的缺点在于它严重依赖可变状态，并且需要更多的状态是公共的，而不是像普通的 Java 对象那样，因为视觉构建工具不能将参数传递给对象的构造函数，而是必须设置属性。用户界面组件作为 beans 工作得很好，因为它们可以安全地用默认内容和样式初始化，并在构造后进行调整。当我们有没有合理默认值的类时，将它们视为相同的方式是容易出错的，因为类型检查器不能告诉我们何时提供了所有必需的值。Beans 约定使得编写正确的代码更加困难，并且依赖关系的变化可能会悄无声息地破坏客户端代码。

最终，JavaBeans 的图形组合并未成为主流，但其编码约定却深入人心。即使程序员并不打算将其类用作 JavaBean，Java 程序员仍然遵循 JavaBean 的约定。Beans 对 Java 编程风格产生了巨大而持久的影响，尽管并非完全正面。

## 企业风格

Java 最终在企业中获得了普及。它没有如预期般取代企业桌面上的 Visual Basic，而是取代了 C++成为服务器端首选语言。1998 年，Sun 发布了 Java 2 企业版（当时称为 J2EE，现在是 JakartaEE），这是用于编程服务器端事务处理系统的一套标准 API。

J2EE API 存在*抽象反转*问题。JavaBeans 和小程序 API 也有抽象反转问题——例如，它们都不允许向构造函数传递参数，但在 J2EE 中问题更为严重。J2EE 应用程序没有单一的入口点。它们由许多由应用容器管理生命周期的小组件组成，并通过 JNDI 名称服务相互暴露。应用程序需要大量样板代码和可变状态来查找其依赖的资源。程序员们通过发明*依赖注入*（DI）框架来应对这些问题，这些框架负责资源查找、绑定和管理生命周期。其中最成功的是 Spring。它建立在 JavaBeans 编码约定的基础上，利用反射从类似 Bean 的对象组合应用程序。

就编程风格而言，依赖注入（DI）框架鼓励程序员避免直接使用`new`关键字，而是依赖框架来实例化对象。Android API 也表现出抽象反转，Android 程序员也倾向于使用 DI 框架来帮助他们编写 API。DI 框架更专注于机制而非领域建模，导致出现了像 Spring 那种臭名昭著的`AbstractSingletonProxyFactoryBean`这样的企业级类名。

不过，企业时代也见证了 Java 5 的发布，该版本为语言添加了泛型和自动装箱，这是迄今为止最重大的变化。该时代还看到 Java 社区对开源库的大规模采用，这得益于 Maven 打包约定和中央仓库。顶级开源库的可用性推动了 Java 在关键业务应用开发中的采纳，并导致更多的开源库出现，形成良性循环。此后还出现了一流的开发工具，包括我们在本书中使用的 IntelliJ IDE。

## 现代风格

Java 8 为语言带来了下一个重大变化——lambda 表达式——以及对标准库的重大增强以利用它们。流 API 鼓励一种函数式编程风格，其中处理是通过转换不可变值流而不是改变可变对象的状态来完成的。一个新的日期/时间 API 忽略了 JavaBeans 编码约定，而是遵循了原始时代的编码约定。

云平台的增长意味着程序员不再需要将服务器部署到 JavaEE 应用容器中。轻量级的 Web 应用框架允许程序员编写一个`main`函数来组合他们的应用程序。许多服务器端程序员停止使用 DI 框架——函数和对象组合已经足够好了——因此 DI 框架发布了大大简化的 API 以保持相关性。没有 DI 框架或可变状态，就不需要遵循 JavaBean 编码约定。在单一代码库中，暴露不可变值字段也没问题，因为如果需要，IDE 可以在瞬间将字段封装在访问器后面。

Java 9 引入了模块，但到目前为止，除了 JDK 本身外，它们还没有被广泛采用。最令人兴奋的是最近 Java 版本的模块化和将鲜为人知的模块（如 CORBA）从 JDK 移入可选扩展中。

## 未来

Java 的未来承诺提供更多功能，使现代风格更易于应用：记录、模式匹配、用户定义的值类型，最终将原始类型和引用类型统一为一致的类型系统。

然而，这是一个具有挑战性的工作，需要花费多年时间才能完成。Java 最初存在一些根深蒂固的不一致性和边界情况，很难统一为干净的抽象并保持向后兼容性。Kotlin 有着 25 年的远见和从头开始的干净板，这是一个巨大的优势。

# Kotlin 的风格

Kotlin 是一种年轻的语言，但它显然有着与 Java 不同的风格。

当我们写这篇文章时，Kotlin 首页的[“为什么选择 Kotlin”](https://oreil.ly/pqZbu)部分列出了四个设计目标：简洁、安全、可互操作性和工具友好性。语言和其标准库的设计者还编码了有助于实现这些设计目标的隐含偏好。这些偏好包括：

Kotlin 更喜欢转换不可变数据而不是变异状态。

数据类使定义具有值语义的新类型变得容易。标准库使得转换不可变数据集合比就地迭代和变异数据更容易且更简洁。

Kotlin 更喜欢行为明确。

例如，类型之间没有隐式强制转换，即使是从较小范围到较大范围也是如此。Java 会将`int`值隐式转换为`long`值，因为没有精度损失。在 Kotlin 中，你必须显式调用`Int.toLong()`。在控制流方面，对显式性的偏好尤为强烈。虽然你可以为自己的类型重载算术和比较运算符，但不能重载快捷逻辑运算符（`&&`和`||`），因为这样会允许你定义不同的控制流。

Kotlin 更青睐静态绑定而非动态绑定。

Kotlin 鼓励一种类型安全的、组合式的编码风格。扩展函数在静态绑定时绑定。默认情况下，类不可扩展，方法不具有多态性。你必须显式地选择多态性和继承。如果要使用反射，你必须添加一个特定于平台的库依赖。Kotlin 从一开始就被设计用于与语言感知的 IDE 一起使用，该 IDE 静态分析代码以指导程序员、自动化导航和自动化程序转换。

Kotlin 不喜欢特殊情况。

与 Java 相比，Kotlin 的特殊情况较少，并且交互方式不可预测。没有基本类型和引用类型之分。没有`void`类型用于返回但不返回值的函数；Kotlin 中的函数要么返回一个值，要么根本不返回。扩展函数允许你为现有类型添加新操作，而在调用点看起来相同。你可以将新的控制结构编写为内联函数，`break`、`continue`和`return`语句的行为与内置控制结构中的行为相同。

Kotlin 为了简化迁移而打破了自己的规则。

Kotlin 语言具有允许在同一代码库中存在惯用 Java 和 Kotlin 代码的功能。其中一些功能会移除类型检查器提供的保证，**仅应**用于与旧版 Java 进行交互。例如，`lateinit`打开了类型系统的漏洞，以便 Java 依赖注入框架可以通过反射初始化对象并通过编译器通常强制执行的封装边界注入值。如果将属性声明为`lateinit var`，则由你来确保代码在读取属性之前初始化它。编译器不会捕获你的错误。

当我们，Nat 和 Duncan，重新审视我们最早用 Kotlin 编写的代码时，它往往看起来像是用 Kotlin 语法打扮成的 Java。我们在写了很多年的 Java 后转向 Kotlin，养成了影响我们编写 Kotlin 代码的习惯。我们写了不必要的样板文件，没有充分利用标准库，并且避免使用 null，因为我们还不习惯类型检查器强制执行空安全。我们团队中的 Scala 程序员走得太远了——他们的代码看起来像是 Kotlin 试图成为 Scala，扮演 Haskell。我们当中没有人找到与 Kotlin 的纹理相匹配的甜蜜点。

通往惯用 Kotlin 的道路受到我们必须保持工作的 Java 代码的影响。实际上，仅仅学习 Kotlin 是不够的。我们必须同时处理 Java *和* Kotlin 的不同特点，对两者都持有同情心，逐渐从一个转向另一个。

# Kotlin 重构

当我们开始向 Kotlin 进发时，我们负责维护和增强业务关键系统。我们从未能只专注于将我们的 Java 代码库转换为 Kotlin。我们总是不得不在同时将代码迁移到 Kotlin，同时改变系统以满足新的业务需求，我们在此过程中保持了一个混合的 Java/Kotlin 代码库。我们通过进行小的更改来管理风险，使每个更改易于理解，并且如果我们发现它破坏了某些东西，就廉价丢弃。我们的流程首先将 Java 代码转换为 Kotlin，给我们带来了 Kotlin 语法中的 Java 式设计。然后我们逐步应用 Kotlin 语言特性，使代码变得越来越易于理解，更加类型安全，更加简洁，并且具有更具组合结构的结构，更易于改变而不会有不愉快的惊喜。

从惯用的 Java 到惯用的 Kotlin，进行了一系列小的、安全的、可逆的改变，以改善设计。

在语言之间进行重构通常比在单一语言中进行重构更难，因为重构工具在语言之间的边界上效果不佳，如果有的话。从一种语言迁移到另一种语言必须手动完成，这需要更长的时间，并引入了更多的风险。一旦使用了多种语言，语言边界会妨碍重构，因为当您重构一种语言中的代码时，IDE 不会更新其他语言中编写的依赖代码以使其兼容。

使 Java 和 Kotlin 的组合独特的是两种语言之间（相对）无缝的边界。由于 Kotlin 语言的设计、它被映射到 JVM 平台的方式，以及 JetBrains 对开发工具的投资，将 Java 重构为 Kotlin 和重构合并的 Java/Kotlin 代码库几乎和在单一代码库中进行重构一样容易。

我们的经验表明，我们可以将 Java 重构为 Kotlin 而不影响生产力，并且随着我们将更多的代码库转换为 Kotlin，生产力会加速提升。

## 重构原则

自从马丁·福勒在 1999 年出版的书籍*《重构：改善既有代码的设计》*（Addison-Wesley）中首次流行以来，重构的实践已经走了很长一段路。该书甚至详细说明了像重命名标识符这样简单的重构的手动步骤，但指出一些先进的开发环境已经开始提供自动化支持来减少这种单调乏味的工作。如今，我们期望我们的工具甚至能自动化复杂的情况，比如提取接口或改变函数签名。

尽管这些单独的重构很少是孤立的。现在建筑块重构可以自动执行，我们有时间和精力将它们结合起来，对代码库进行更大规模的改变。当 IDE 没有为我们希望执行的大规模转换提供明确的用户界面操作时，我们必须将其作为一系列更细粒度的重构操作序列来执行。我们尽可能使用 IDE 的自动重构，当 IDE 不能自动化我们需要的转换时，我们则退而使用文本编辑。

通过编辑文本来进行重构是单调且容易出错的。为了减少风险和无聊感，我们尽量减少需要编辑文本的次数。如果我们*必须*编辑文本，我们更希望编辑影响单个表达式。因此，我们使用自动重构来转换代码，使这种操作成为可能，然后编辑一个表达式，再利用自动重构将其整理回我们的最终目标状态。

当我们第一次描述大规模重构时，我们将逐步展示每个步骤的代码变化。这在页面上占据了相当多的空间，并需要一些阅读时间来跟进。然而，在实践中，这些大规模重构是快速应用的。通常只需几秒钟，最多几分钟。

随着工具的改进，我们预计这里发布的重构技术会迅速更新。各个 IDE 的步骤可能会更名，一些组合可能会作为独立的重构技术实现。在您的环境中进行实验，找到逐步和安全地转换代码的方法，比我们提供的更好，并与世界分享。

## 我们假设测试覆盖率良好。

正如马丁·福勒在*重构：改善现有代码的设计*中所说：“[如果你想要重构，重要的前提是拥有可靠的测试。]”良好的测试覆盖率确保了我们只想要改进设计的代码转换没有无意间改变系统行为。在本书中，我们假设您有良好的测试覆盖率。我们不讨论如何编写自动化测试。其他作者已经更详细地讨论了这些主题，例如：*通过示例驱动开发*肯特·贝克（Addison-Wesley）和*由测试指导的面向对象软件开发*迈克尔·费瑟斯（Pearson）。

我们在参考文献中列出了更多关于这些主题的书籍。

## 我们为 Git Bisect 提交

正如我们不明确说明何时运行测试，也不明确说明何时提交更改。假设我们在代码增加了价值时提交更改，无论多么小。

我们知道我们的测试套件并不完美。如果我们意外破坏了某些未被测试捕获的内容，我们希望尽快找到引入错误的提交并修复它。

`git bisect` 命令自动化了该搜索。我们编写一个新的测试来演示错误，`git bisect` 对历史进行二进制搜索，找到使该测试失败的第一个提交。

如果我们历史中的提交很大，并且包含杂乱无章的不相关更改，`git bisect` 的帮助就不那么大了。它无法告诉哪个提交的源更改引入了错误。如果提交混合了重构*和*行为更改，那么恢复错误的重构步骤可能会破坏系统中的*其他*行为。

因此，我们提交小而专注的更改，将重构与行为更改分开，以便轻松理解发生了什么变化并修复任何错误的更改。出于同样的原因，我们很少压缩提交。

###### 注意

我们更喜欢直接将更改提交到主线分支——“基于主干的开发”——但在分支上工作并较少频繁合并时，通过一系列小的独立提交进行代码更改同样有益。

# 我们正在做什么？

在接下来的章节中，我们将从*Travelator*代码库中获取示例，这是一个虚构的用于规划和预订国际陆面旅行的应用程序。我们（仍然是虚构的）用户通过海上、铁路和公路规划路线；搜索住宿和景点；通过价格、时间和景观比较选项；最后通过 Web 和移动前端预订他们的旅行，这些前端通过 HTTP 调用后端服务。

每一章节从 Travelator 系统的不同部分提取一个信息丰富的例子，但它们共享共同的领域概念：货币、货币转换、旅程、行程安排、预订等等。

我们的目标是，就像我们的 Travelator 应用程序一样，这本书将帮助您从 Java 过渡到 Kotlin 规划您的旅程。

# 让我们开始吧！

足够的闲聊。 您可能急于将所有 Java 代码转换为 Kotlin。 我们将在下一章开始，通过向项目的构建文件添加 Kotlin 支持。
