<html><head></head><body>
<div id="sbo-rt-content"><section data-nutshell-tab="OO Design" data-pdf-bookmark="Chapter 5. Introduction to Object-Oriented Design in Java" data-type="chapter" epub:type="chapter"><div class="chapter" id="javanut8-CHP-5">
<h1><span class="label">Chapter 5. </span>Introduction to Object-Oriented Design in Java</h1>
<p><a data-primary="object-oriented design (OOD)" data-type="indexterm" id="ix_ch05-asciidoc0"/>In this chapter, we will consider several techniques relevant to object-oriented design (OOD) in Java.</p>
<p>We’ll look at how to work with Java’s objects, covering the key methods of <code>Object</code>, aspects of object-oriented design, and implementing exception handling schemes.
Throughout the chapter, we will be introducing some <em>design patterns</em>—essentially best practices for solving some very common situations that arise in software design.
Toward the end of the chapter, we’ll also consider <em>safe</em> programs—those that are designed so as not to become inconsistent over  time.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>This chapter is intended to showcase some examples of a complex topic and a few underlying principles. We encourage you to consult additional resources, such as <em>Effective Java</em> by Josh Bloch.</p>
</div>
<p>We’ll get started by considering the subject of Java’s calling and passing conventions and the nature of Java values.</p>
<section data-pdf-bookmark="Java Values" data-type="sect1"><div class="sect1" id="idm45927735984560">
<h1>Java Values</h1>
<p><a data-primary="object-oriented design (OOD)" data-secondary="Java values" data-type="indexterm" id="ix_ch05-asciidoc1"/>Java’s values, and their relationship to the type system, are quite straightforward. Java has two types of values: primitives and object references.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>There are only eight different primitive types in Java, and new primitive types cannot be defined by the programmer.</p>
</div>
<p>The key difference between primitive values and references is that
primitive values cannot be altered; the value <code>2</code> is always the same value.
By contrast, the contents of object references can usually be
changed—often referred to as <em>mutation</em> of object contents.</p>
<p>Also note that variables can contain values only of the appropriate type.
In particular, variables of reference type always contain a reference to the memory location holding the object—they do not contain the object contents directly.
This means that in Java there is no equivalent of a dereference operator or a <code>struct</code>.</p>
<p>Java tries to simplify a concept that often confused C++
programmers: the difference between “contents of an object” and
“reference to an object.” Unfortunately, it’s not possible to completely
hide the difference, and so it is necessary for the programmer to
understand how reference values work in the platform.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45927735977472">
<h5>Is Java “Pass by Reference”?</h5>
<p><a data-primary="object-oriented design (OOD)" data-secondary="by reference vs. pass by reference" data-type="indexterm" id="idm45927735976304"/><a data-primary="pass-by-reference language" data-type="indexterm" id="idm45927735975392"/><a data-primary="pass-by-value language" data-type="indexterm" id="idm45927735974752"/>Java handles objects “by reference,” but we must not confuse this with
the phrase “pass by reference,” a term used to
describe the method-calling conventions of various programming languages.
In a pass-by-reference language, values—even primitive values—are not
passed directly to methods. Instead, methods are always passed
by references to values. Thus, if the method modifies its parameters, those
modifications are visible when the method returns, even for primitive
types.</p>
<p>Java does <em>not</em> do this; it is a “pass by value” language. However,
when a reference type is involved, the value that is passed is a copy of
the reference (as a value). But this is not the same as pass by
reference. If Java were a pass-by-reference language, when a reference
type is passed to a method, it would be passed as a reference to the
reference.</p>
</div></aside>
<p>The fact that Java is pass by value can be demonstrated very simply, e.g., by running the
following code:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">manipulate</code><code class="p">(</code><code class="n">Circle</code><code class="w"> </code><code class="n">circle</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">circle</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">Circle</code><code class="p">(</code><code class="mi">3</code><code class="p">);</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="n">Circle</code><code class="w"> </code><code class="n">c</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">Circle</code><code class="p">(</code><code class="mi">2</code><code class="p">);</code><code class="w"/>
<code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="s">"Radius: "</code><code class="o">+</code><code class="w"> </code><code class="n">c</code><code class="p">.</code><code class="na">getRadius</code><code class="p">());</code><code class="w"/>
<code class="n">manipulate</code><code class="p">(</code><code class="n">c</code><code class="p">);</code><code class="w"/>
<code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="s">"Radius: "</code><code class="o">+</code><code class="w"> </code><code class="n">c</code><code class="p">.</code><code class="na">getRadius</code><code class="p">());</code><code class="w"/></pre>
<p>This outputs <code>Radius: 2</code> twice and thus shows that even after the call to 
<span class="keep-together"><code>manipulate()</code></span>, the
value contained in variable <code>c</code> is unaltered—it is still holding a reference to a <code>Circle</code> object of radius 2.
If Java was a pass-by-reference language, it would instead be holding a reference to a radius 3 <code>Circle</code>:</p>
<p>If we’re scrupulously careful about the distinction, and about referring
to object references as one of Java’s possible kinds of values, then
some otherwise surprising features of Java become obvious. Be
careful! Some older texts are ambiguous on this point. We will meet this
concept of Java’s values again when we discuss memory and garbage
collection in <a data-type="xref" href="ch06.xhtml#javanut8-CHP-6">Chapter 6</a>.<a data-startref="ix_ch05-asciidoc1" data-type="indexterm" id="idm45927735926352"/></p>
</div></section>
<section data-pdf-bookmark="Important Common Methods" data-type="sect1"><div class="sect1" id="idm45927735925392">
<h1>Important Common Methods</h1>
<p><a data-primary="java.lang.Object" data-secondary="important methods of" data-type="indexterm" id="ix_ch05-asciidoc2"/><a data-primary="methods" data-secondary="of java.lang.Object" data-secondary-sortas="java.lang.Object" data-type="indexterm" id="ix_ch05-asciidoc3"/><a data-primary="object-oriented design (OOD)" data-secondary="important methods of java.lang.Object" data-type="indexterm" id="ix_ch05-asciidoc4"/>As we’ve noted, all classes extend, directly or indirectly,
<code>java.lang.Object</code>.
This class defines a number of useful methods, some of which were designed to be overridden by classes you write.
<a data-type="xref" href="#javanut8-CHP-5-EX-1">Example 5-1</a> shows a class that overrides these methods.
The sections that follow this example document the default implementation of each method and explain why you might want to override it.</p>
<p>Note that this example is for demonstration purposes only; in reality, we would represent classes like <code>Circle</code> as records and get a lot of these methods implemented automatically by the compiler.</p>
<div data-type="example" id="javanut8-CHP-5-EX-1">
<h5><span class="label">Example 5-1. </span>A class that overrides important Object methods</h5>
<pre data-code-language="java" data-type="programlisting"><code class="c1">// This class represents a circle with immutable position and radius.</code><code class="w"/>
<code class="kd">public</code><code class="w"> </code><code class="kd">class</code> <code class="nc">Circle</code><code class="w"> </code><code class="kd">implements</code><code class="w"> </code><code class="n">Comparable</code><code class="o">&lt;</code><code class="n">Circle</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="c1">// These fields hold the coordinates of the center and the radius.</code><code class="w"/>
<code class="w">    </code><code class="c1">// They are private for data encapsulation and final for immutability</code><code class="w"/>
<code class="w">    </code><code class="kd">private</code><code class="w"> </code><code class="kd">final</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="n">x</code><code class="p">,</code><code class="w"> </code><code class="n">y</code><code class="p">,</code><code class="w"> </code><code class="n">r</code><code class="p">;</code><code class="w"/>

<code class="w">    </code><code class="c1">// The basic constructor: initialize the fields to specified values</code><code class="w"/>
<code class="w">    </code><code class="kd">public</code><code class="w"> </code><code class="nf">Circle</code><code class="p">(</code><code class="kt">int</code><code class="w"> </code><code class="n">x</code><code class="p">,</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="n">y</code><code class="p">,</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="n">r</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="n">r</code><code class="w"> </code><code class="o">&lt;</code><code class="w"> </code><code class="mi">0</code><code class="p">)</code><code class="w"> </code><code class="k">throw</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">IllegalArgumentException</code><code class="p">(</code><code class="s">"negative radius"</code><code class="p">);</code><code class="w"/>
<code class="w">        </code><code class="k">this</code><code class="p">.</code><code class="na">x</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">x</code><code class="p">;</code><code class="w"> </code><code class="k">this</code><code class="p">.</code><code class="na">y</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">y</code><code class="p">;</code><code class="w"> </code><code class="k">this</code><code class="p">.</code><code class="na">r</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">r</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>

<code class="w">    </code><code class="c1">// This is a "copy constructor"--a useful alternative to clone()</code><code class="w"/>
<code class="w">    </code><code class="kd">public</code><code class="w"> </code><code class="nf">Circle</code><code class="p">(</code><code class="n">Circle</code><code class="w"> </code><code class="n">original</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="n">x</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">original</code><code class="p">.</code><code class="na">x</code><code class="p">;</code><code class="w">   </code><code class="c1">// Just copy the fields from the original</code><code class="w"/>
<code class="w">        </code><code class="n">y</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">original</code><code class="p">.</code><code class="na">y</code><code class="p">;</code><code class="w"/>
<code class="w">        </code><code class="n">r</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">original</code><code class="p">.</code><code class="na">r</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>

<code class="w">    </code><code class="c1">// Public accessor methods for the private fields.</code><code class="w"/>
<code class="w">    </code><code class="c1">// These are part of data encapsulation.</code><code class="w"/>
<code class="w">    </code><code class="kd">public</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="nf">getX</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="n">x</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="kd">public</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="nf">getY</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="n">y</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="kd">public</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="nf">getR</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="n">r</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w"/>

<code class="w">    </code><code class="c1">// Return a string representation</code><code class="w"/>
<code class="w">    </code><code class="nd">@Override</code><code class="w"> </code><code class="kd">public</code><code class="w"> </code><code class="n">String</code><code class="w"> </code><code class="nf">toString</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="n">String</code><code class="p">.</code><code class="na">format</code><code class="p">(</code><code class="s">"center=(%d,%d); radius=%d"</code><code class="p">,</code><code class="w"> </code><code class="n">x</code><code class="p">,</code><code class="w"> </code><code class="n">y</code><code class="p">,</code><code class="w"> </code><code class="n">r</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>

<code class="w">    </code><code class="c1">// Test for equality with another object</code><code class="w"/>
<code class="w">    </code><code class="nd">@Override</code><code class="w"> </code><code class="kd">public</code><code class="w"> </code><code class="kt">boolean</code><code class="w"> </code><code class="nf">equals</code><code class="p">(</code><code class="n">Object</code><code class="w"> </code><code class="n">o</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="c1">// Identical references?</code><code class="w"/>
<code class="w">        </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="n">o</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="k">this</code><code class="p">)</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="kc">true</code><code class="p">;</code><code class="w"/>
<code class="w">        </code><code class="c1">// Correct type and non-null?</code><code class="w"/>
<code class="w">        </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="o">!</code><code class="p">(</code><code class="n">o</code><code class="w"> </code><code class="k">instanceof</code><code class="w"> </code><code class="n">Circle</code><code class="p">))</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="kc">false</code><code class="p">;</code><code class="w"/>
<code class="w">        </code><code class="n">Circle</code><code class="w"> </code><code class="n">that</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">(</code><code class="n">Circle</code><code class="p">)</code><code class="w"> </code><code class="n">o</code><code class="p">;</code><code class="w">                 </code><code class="c1">// Cast to our type</code><code class="w"/>
<code class="w">        </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="na">x</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="n">that</code><code class="p">.</code><code class="na">x</code><code class="w"> </code><code class="o">&amp;&amp;</code><code class="w"> </code><code class="k">this</code><code class="p">.</code><code class="na">y</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="n">that</code><code class="p">.</code><code class="na">y</code><code class="w"> </code><code class="o">&amp;&amp;</code><code class="w"> </code><code class="k">this</code><code class="p">.</code><code class="na">r</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="n">that</code><code class="p">.</code><code class="na">r</code><code class="p">)</code><code class="w"/>
<code class="w">            </code><code class="k">return</code><code class="w"> </code><code class="kc">true</code><code class="p">;</code><code class="w">                          </code><code class="c1">// If all fields match</code><code class="w"/>
<code class="w">        </code><code class="k">else</code><code class="w"/>
<code class="w">            </code><code class="k">return</code><code class="w"> </code><code class="kc">false</code><code class="p">;</code><code class="w">                         </code><code class="c1">// If fields differ</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>

<code class="w">    </code><code class="c1">// A hash code allows an object to be used in a hash table.</code><code class="w"/>
<code class="w">    </code><code class="c1">// Equal objects must have equal hash codes.  Unequal objects are</code><code class="w"/>
<code class="w">    </code><code class="c1">// allowed to have equal hash codes, but we try to avoid that.</code><code class="w"/>
<code class="w">    </code><code class="c1">// We must override this method because we also override equals().</code><code class="w"/>
<code class="w">    </code><code class="nd">@Override</code><code class="w"> </code><code class="kd">public</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="nf">hashCode</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="kt">int</code><code class="w"> </code><code class="n">result</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">17</code><code class="p">;</code><code class="w">          </code><code class="c1">// This hash code algorithm from</code><code class="w"/>
<code class="w">        </code><code class="n">result</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">37</code><code class="o">*</code><code class="n">result</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">x</code><code class="p">;</code><code class="w">   </code><code class="c1">// Effective Java, by Joshua Bloch</code><code class="w"/>
<code class="w">        </code><code class="n">result</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">37</code><code class="o">*</code><code class="n">result</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">y</code><code class="p">;</code><code class="w"/>
<code class="w">        </code><code class="n">result</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">37</code><code class="o">*</code><code class="n">result</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">r</code><code class="p">;</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="n">result</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>

<code class="w">    </code><code class="c1">// This method is defined by the Comparable interface. Compare</code><code class="w"/>
<code class="w">    </code><code class="c1">// this Circle to that Circle.  Return a value &lt; 0 if this &lt; that</code><code class="w"/>
<code class="w">    </code><code class="c1">// Return 0 if this == that. Return a value &gt; 0 if this &gt; that.</code><code class="w"/>
<code class="w">    </code><code class="c1">// Circles are ordered top to bottom, left to right, then by radius</code><code class="w"/>
<code class="w">    </code><code class="kd">public</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="nf">compareTo</code><code class="p">(</code><code class="n">Circle</code><code class="w"> </code><code class="n">that</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="c1">// Smaller circles have bigger y</code><code class="w"/>
<code class="w">        </code><code class="kt">long</code><code class="w"> </code><code class="n">result</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">(</code><code class="kt">long</code><code class="p">)</code><code class="n">that</code><code class="p">.</code><code class="na">y</code><code class="w"> </code><code class="o">-</code><code class="w"> </code><code class="k">this</code><code class="p">.</code><code class="na">y</code><code class="p">;</code><code class="w"/>
<code class="w">        </code><code class="c1">// If same compare l-to-r</code><code class="w"/>
<code class="w">        </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="n">result</code><code class="o">==</code><code class="mi">0</code><code class="p">)</code><code class="w"> </code><code class="n">result</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">(</code><code class="kt">long</code><code class="p">)</code><code class="k">this</code><code class="p">.</code><code class="na">x</code><code class="w"> </code><code class="o">-</code><code class="w"> </code><code class="n">that</code><code class="p">.</code><code class="na">x</code><code class="p">;</code><code class="w"/>
<code class="w">        </code><code class="c1">// If same compare radius</code><code class="w"/>
<code class="w">        </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="n">result</code><code class="o">==</code><code class="mi">0</code><code class="p">)</code><code class="w"> </code><code class="n">result</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">(</code><code class="kt">long</code><code class="p">)</code><code class="k">this</code><code class="p">.</code><code class="na">r</code><code class="w"> </code><code class="o">-</code><code class="w"> </code><code class="n">that</code><code class="p">.</code><code class="na">r</code><code class="p">;</code><code class="w"/>

<code class="w">        </code><code class="c1">// We have to use a long value for subtraction because the</code><code class="w"/>
<code class="w">        </code><code class="c1">// differences between a large positive and large negative</code><code class="w"/>
<code class="w">        </code><code class="c1">// value could overflow an int. But we can't return the long,</code><code class="w"/>
<code class="w">        </code><code class="c1">// so return its sign as an int.</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="n">Long</code><code class="p">.</code><code class="na">signum</code><code class="p">(</code><code class="n">result</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre></div>
<p><a data-type="xref" href="#javanut8-CHP-5-EX-1">Example 5-1</a> uses a lot of the extended features of the type system that we introduced in <a data-type="xref" href="ch04.xhtml#javanut8-CHP-4">Chapter 4</a>.
First, this example implements a parameterized, or generic, version of the <code>Comparable</code> interface.
Second, it uses the <code>@Override</code> annotation to emphasize (and have the compiler verify) that certain methods override <code>Object</code>.</p>
<section data-pdf-bookmark="toString()" data-type="sect2"><div class="sect2" id="idm45927735600384">
<h2>toString()</h2>
<p><a data-primary="java.lang.Object" data-secondary="toString() method" data-type="indexterm" id="idm45927735599152"/><a data-primary="toString()" data-type="indexterm" id="idm45927735598176"/>The purpose of the <code>toString()</code> method is to return a textual
representation of an object. The method is invoked automatically on
objects during string concatenation and by methods such as
<code>System.out.println()</code>. Giving objects a textual representation can be
quite helpful for debugging or logging output, and a well-crafted
<code>toString()</code> method can even help with tasks such as report generation.</p>
<p>The version of <code>toString()</code> inherited from <code>Object</code> returns a string
that includes the name of the class of the object as well as a
hexadecimal representation of the <code>hashCode()</code> value of the object
(discussed later in this chapter). This default implementation provides
basic type and identity information for an object but is not very useful. The <code>toString()</code> method in
<a data-type="xref" href="#javanut8-CHP-5-EX-1">Example 5-1</a> instead returns a human-readable
string that includes the value of each of the fields of the <code>Circle</code>
class.</p>
</div></section>
<section data-pdf-bookmark="equals()" data-type="sect2"><div class="sect2" id="javanut8-CHP-5-SECT-2-2">
<h2>equals()</h2>
<p><a data-primary="equals()" data-type="indexterm" id="idm45927735276224"/><a data-primary="java.lang.Object" data-secondary="equals() method" data-type="indexterm" id="idm45927735275296"/>The <code>==</code> operator tests two references to see if they refer to the
same object. If you want to test whether two distinct objects are equal
to one another, you must use the <code>equals()</code> method instead. Any class
can define its own notion of equality by overriding <code>equals()</code>. The
<code>Object.equals()</code> method simply uses the <code>==</code> operator: this default
method considers two objects equal only if they are actually the very
same object.</p>
<p>The <code>equals()</code> method in <a data-type="xref" href="#javanut8-CHP-5-EX-1">Example 5-1</a>
considers two distinct <code>Circle</code> objects to be equal if their fields are
all equal. Note that it first does a quick identity test with <code>==</code> as an
optimization and then checks the type of the other object with
<code>instanceof</code>: a <code>Circle</code> can be equal only to another <code>Circle</code>, and it
is not acceptable for an <code>equals()</code> method to throw a
<code>ClassCastException</code>. Note that the <code>instanceof</code> test also rules out
<code>null</code> arguments: <code>instanceof</code> always evaluates to <code>false</code> if its
lefthand operand is <code>null</code>.</p>
</div></section>
<section data-pdf-bookmark="hashCode()" data-type="sect2"><div class="sect2" id="idm45927735264512">
<h2>hashCode()</h2>
<p><a data-primary="hashCode()" data-type="indexterm" id="idm45927735263040"/><a data-primary="java.lang.Object" data-secondary="hashCode() method" data-type="indexterm" id="idm45927735262336"/>Whenever you override <code>equals()</code>, you also must override <code>hashCode()</code>.
This method returns an integer for use by hash table data structures.
It is critical that two objects have the same hash code if they are
equal according to the <code>equals()</code> method.</p>
<p>It is important (for efficient
operation of hash tables) but not required that unequal objects have
unequal hash codes, or at least that unequal objects are unlikely to
share a hash code. This second criterion can lead to <code>hashCode()</code>
methods that involve mildly tricky arithmetic or bit manipulation.</p>
<p>The <code>Object.hashCode()</code> method works with the <code>Object.equals()</code> method
and returns a hash code based on object identity rather than object
equality. (If you ever need an identity-based hash code, you can access
the functionality of <code>Object.hashCode()</code> through the static method
<code>System.identityHashCode()</code>.)</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>When you override <code>equals()</code>, you must always override <code>hashCode()</code> to
guarantee that equal objects have equal hash codes. Failing to do this
can cause subtle bugs in your programs.</p>
</div>
<p>Because the <code>equals()</code> method in <a data-type="xref" href="#javanut8-CHP-5-EX-1">Example 5-1</a>
bases object equality on the values of the three fields, the
<code>hashCode()</code> method computes its hash code based on these three fields
as well. It is clear from the code that if two <code>Circle</code> objects have the
same field values, they will have the same hash code.</p>
<p>Note that the <code>hashCode()</code> method in <a data-type="xref" href="#javanut8-CHP-5-EX-1">Example 5-1</a> does not simply add the three fields and return their sum. Such an
implementation would be legal but not efficient because two circles with
the same radius but whose <em>x</em> and <em>y</em> coordinates were reversed would
then have the same hash code. The repeated multiplication and addition
steps “spread out” the range of hash codes and dramatically reduce the
likelihood that two unequal <code>Circle</code> objects have the same code.</p>
<p>In practice, modern Java programmers will either autogenerate <code>hashCode()</code>, <code>equals()</code>, and <code>toString()</code> from within their IDE (for classes), or use records where the source code compiler produces a standard form of these methods.
For the extremely rare cases where the programmer chooses not to use either of these approaches, <em>Effective Java</em> by Joshua Bloch (Addison Wesley) includes a helpful recipe for constructing efficient <code>hashCode()</code> methods.</p>
</div></section>
<section data-pdf-bookmark="Comparable::compareTo()" data-type="sect2"><div class="sect2" id="idm45927735245680">
<h2>Comparable::compareTo()</h2>
<p><a data-primary="compareTo()" data-type="indexterm" id="idm45927735244368"/><a data-primary="java.lang.Object" data-secondary="compareTo() method" data-type="indexterm" id="idm45927735243264"/><a data-type="xref" href="#javanut8-CHP-5-EX-1">Example 5-1</a> includes a <code>compareTo()</code>
method. This method is defined by the <code>java.lang.Comparable</code> interface
rather than by <code>Object</code>, but it is such a common method to implement
that we include it in this section. The purpose of <code>Comparable</code> and its
<code>compareTo()</code> method is to allow instances of a class to be compared to
each other in a similar way to how the <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, and <code>&gt;=</code> operators
compare numbers.
If a class implements <code>Comparable</code>, we can call methods to allow us to say that one instance is less than, greater than, or equal to another instance.
This also means that instances of a <code>Comparable</code> class can be sorted.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><a data-primary="natural comparison method" data-type="indexterm" id="idm45927735235904"/>The method <code>compareTo()</code> sets up a <em>total ordering</em> of the objects of the type. This is referred to as the <em>natural order</em> of the type, and the method is called the <em>natural comparison method</em>.</p>
</div>
<p>Because <code>compareTo()</code> is not declared by the <code>Object</code> class, it is up to
each individual class to determine whether and how its instances should
be ordered and to include a <code>compareTo()</code> method that implements that
ordering.</p>
<p>The ordering defined by <a data-type="xref" href="#javanut8-CHP-5-EX-1">Example 5-1</a>
compares <code>Circle</code> objects as if they were words on a page. Circles are
first ordered from top to bottom: circles with larger <em>y</em> coordinates
are less than circles with smaller <em>y</em> coordinates. If two circles have
the same <em>y</em> coordinate, they are ordered from left to right. A circle
with a smaller <em>x</em> coordinate is less than a circle with a larger <em>x</em>
coordinate. Finally, if two circles have the same <em>x</em> and <em>y</em>
coordinates, they are compared by radius. The circle with the smaller
radius is smaller.</p>
<p>Note that under this ordering, two circles are equal only if all three of their fields are equal. This means that the
ordering defined by <code>compareTo()</code> is consistent with the equality
defined by <code>equals()</code>.
This is not strictly required but is very desirable, and you should aim for it wherever possible.</p>
<p>The <code>compareTo()</code> method returns an <code>int</code> value that requires further
explanation. <code>compareTo()</code> should return a negative number if the <code>this</code>
object is less than the object passed to it. It should return 0 if the
two objects are equal. And <code>compareTo()</code> should return a positive number
if <code>this</code> is greater than the method argument.</p>
</div></section>
<section data-pdf-bookmark="clone()" data-type="sect2"><div class="sect2" id="idm45927735220992">
<h2>clone()</h2>
<p><a data-primary="clone() method" data-type="indexterm" id="idm45927735219552"/><a data-primary="java.lang.Object" data-secondary="clone() method" data-type="indexterm" id="idm45927735218848"/><code>Object</code> defines a method named <code>clone()</code> whose purpose is to return an object with fields set identically to those of the current object.
This is an unusual method for several reasons.</p>
<p>First, <code>clone()</code> is declared as <code>protected</code>.
Therefore, if you want your object to be cloneable by other classes, you must override the <code>clone()</code> method, making it <code>public</code>.
Next, the default implementation of <code>clone()</code> in <code>Object</code> throws a checked exception, <code>CloneNotSupportedException</code>, unless the class implements the <code>java.lang.Cloneable</code> interface.
Note that this interface does not define any methods (it is a marker interface), so implementing it is simply a matter of listing it in the <code>implements</code> clause of the class signature.</p>
<p>The original intent of <code>clone()</code> was to provide a mechanism to produce “deep copies” of objects, but it is fundamentally flawed and its use is not recommended.
<a data-primary="copy constructor" data-type="indexterm" id="idm45927735026832"/>Instead, developers should prefer declaring a <em>copy constructor</em> for making copies of their objects, for example:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">Circle</code><code class="w"> </code><code class="n">original</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">Circle</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="mi">3</code><code class="p">);</code><code class="w">  </code><code class="c1">// regular constructor</code><code class="w"/>
<code class="n">Circle</code><code class="w"> </code><code class="n">copy</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">Circle</code><code class="p">(</code><code class="n">original</code><code class="p">);</code><code class="w">     </code><code class="c1">// copy constructor</code><code class="w"/></pre>
<p>We will meet copy constructors again when we consider factory methods, later in this chapter.<a data-startref="ix_ch05-asciidoc4" data-type="indexterm" id="idm45927734997248"/><a data-startref="ix_ch05-asciidoc3" data-type="indexterm" id="idm45927734996640"/><a data-startref="ix_ch05-asciidoc2" data-type="indexterm" id="idm45927734996032"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Constants" data-type="sect1"><div class="sect1" id="idm45927735924800">
<h1>Constants</h1>
<p><a data-primary="constants" data-secondary="object-oriented design and" data-type="indexterm" id="idm45927734993952"/><a data-primary="object-oriented design (OOD)" data-secondary="constants" data-type="indexterm" id="idm45927734966912"/>In Java a constant is a <code>static final</code> field.
This combination of modifiers gives a single value (per class) with the given name, and it is initialized as soon as the class is loaded and then cannot be changed.</p>
<p><a data-primary="snake case" data-type="indexterm" id="idm45927734965008"/>By convention, Java’s constants are named in all-capitals, using <em>snake case</em>, for example <span class="keep-together"><code>NETWORK_SERVER_SOCKET</code></span><sup><a data-type="noteref" href="ch05.xhtml#idm45927734963040" id="idm45927734963040-marker">1</a></sup> as opposed to the “camel case” (or “camelCase”) convention <code>networkServerSocket</code> for a regular field.</p>
<p>There are essentially three different subcases of constants that can appear:</p>
<ul>
<li>
<p><code>public</code> constants: <a data-primary="public constants" data-type="indexterm" id="idm45927734959920"/>these form part of the public API of the class</p>
</li>
<li>
<p><code>private</code> constants: <a data-primary="private constants" data-type="indexterm" id="idm45927734947888"/>these are used when the constant is an internal implementation detail for this class only</p>
</li>
<li>
<p>Package-level constants: <a data-primary="package-level constants" data-type="indexterm" id="idm45927734946272"/>these have no additional access keyword and are used when the constant is an internal implementation detail that needs to be seen by different classes within the same package</p>
</li>
</ul>
<p>The final case might arise, for example, when client and server classes implement a network protocol whose details (such as the port number to connect to and listen on) are captured in a set of symbolic constants.</p>
<p>As discussed earlier, an alternative approach is for constants to appear in an interface definition.
Any class that implements an interface inherits the constants it defines and can use them as if they were defined directly in the class itself.
This has the advantage that there is no need to prefix the constants with the name of the interface or provide any kind of implementation of the constants.</p>
<p>However, this is rather overcomplicated and so the preferred approach is to define constants (as either public or package-level) in a class and use them by importing the constants from their defining class with the <code>import static</code> declaration.
See <a data-type="xref" href="ch02.xhtml#javanut8-CHP-2-SECT-10">“Packages and the Java Namespace”</a> for details.</p>
</div></section>
<section data-pdf-bookmark="Working with Fields" data-type="sect1"><div class="sect1" id="idm45927734942528">
<h1>Working with Fields</h1>
<p class="fix_tracking"><a data-primary="fields" data-secondary="working with" data-type="indexterm" id="idm45927734940880"/>Java provides a variety of access control keywords that can be used to define how fields can be accessed.
It is perfectly legal to use any of these possibilities, but in practice there are three primary choices for field access that Java developers typically use:</p>
<ul>
<li>
<p><a data-primary="constants" data-secondary="field access and" data-type="indexterm" id="idm45927734938880"/>Constants (<code>static final</code>): the case that we just met, which may have an additional access control keyword as well</p>
</li>
<li>
<p><a data-primary="immutable fields" data-type="indexterm" id="idm45927734936512"/>Immutable fields (<code>private final</code>): fields with this combination cannot be altered after object creation</p>
</li>
<li>
<p><a data-primary="mutable fields" data-type="indexterm" id="idm45927734934528"/>Mutable fields (<code>private</code>): this combination should only be used if the programmer is sure that the field’s value will change during the object’s lifetime</p>
</li>
</ul>
<p>In recent years, many developers have adopted the practice of using immutable data wherever possible.
There are several benefits to this approach, but the main one is that if objects can be designed so that they cannot be modified after creation, then they can be freely shared between threads.</p>
<p>When writing classes, we recommend using the above three choices for field modifiers, depending on the circumstances.
Instance fields should always be initially written as <code>final</code> and made mutable only if necessary.</p>
<p>In addition, direct field access should not be used, except for constants.
Instead, getter methods (and setters, for the case of mutable state) should be preferred.
The primary reason for this is that direct field access is a very tight coupling between the defining class and any client code.
If accessor methods are used, then the implementation code for those methods can later be modified without changing the client code—this is impossible with field access.</p>
<p><a data-primary="C/C++" data-secondary="access modifiers for fields" data-type="indexterm" id="idm45927734930880"/>We should also call out one common mistake in field handling: Developers coming from C++ frequently make the mistake of omitting any access modifiers for fields.
This is a serious defect, because C++ has a default visibility of private, whereas Java’s default access is considerably more open.
This represents a failure of encapsulation in Java, and developers should take care to avoid it.</p>
</div></section>
<section data-pdf-bookmark="Field Inheritance and Accessors" data-type="sect1"><div class="sect1" id="idm45927734929680">
<h1>Field Inheritance and Accessors</h1>
<p><a data-primary="accessor methods, field inheritance and" data-type="indexterm" id="ix_ch05-asciidoc5"/><a data-primary="fields" data-secondary="inheritance" data-type="indexterm" id="ix_ch05-asciidoc6"/><a data-primary="object-oriented design (OOD)" data-secondary="field inheritance and accessors" data-type="indexterm" id="ix_ch05-asciidoc7"/>As well as the above considerations, Java offers multiple potential approaches to the design issue of the inheritance of state.
The programmer could choose to mark fields as <code>protected</code> and allow them to be accessed directly by subclasses (including writing to them).
Alternatively, we can provide <em>accessor methods</em> to read (and write, if desired) the actual object fields, while retaining encapsulation and leaving the fields as <code>private</code>.</p>
<p>Let’s revisit our earlier <code>PlaneCircle</code> example from the end of
<a data-type="xref" href="ch03.xhtml#javanut8-CHP-3">Chapter 3</a> and explicitly show the field
inheritance:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code><code class="w"> </code><code class="kd">class</code> <code class="nc">Circle</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="c1">// This is a generally useful constant, so we keep it public</code><code class="w"/>
<code class="w">  </code><code class="kd">public</code><code class="w"> </code><code class="kd">static</code><code class="w"> </code><code class="kd">final</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="n">PI</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mf">3.14159</code><code class="p">;</code><code class="w"/>

<code class="w">  </code><code class="kd">protected</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="n">r</code><code class="p">;</code><code class="w">     </code><code class="c1">// State inheritance via a protected field</code><code class="w"/>

<code class="w">  </code><code class="c1">// A method to enforce the restriction on the radius</code><code class="w"/>
<code class="w">  </code><code class="kd">protected</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">checkRadius</code><code class="p">(</code><code class="kt">double</code><code class="w"> </code><code class="n">radius</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="n">radius</code><code class="w"> </code><code class="o">&lt;</code><code class="w"> </code><code class="mf">0.0</code><code class="p">)</code><code class="w"/>
<code class="w">      </code><code class="k">throw</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">IllegalArgumentException</code><code class="p">(</code><code class="s">"radius may not &lt; 0"</code><code class="p">);</code><code class="w"/>
<code class="w">  </code><code class="p">}</code><code class="w"/>

<code class="w">  </code><code class="c1">// The non-default constructor</code><code class="w"/>
<code class="w">  </code><code class="kd">public</code><code class="w"> </code><code class="nf">Circle</code><code class="p">(</code><code class="kt">double</code><code class="w"> </code><code class="n">r</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">checkRadius</code><code class="p">(</code><code class="n">r</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="k">this</code><code class="p">.</code><code class="na">r</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">r</code><code class="p">;</code><code class="w"/>
<code class="w">  </code><code class="p">}</code><code class="w"/>

<code class="w">  </code><code class="c1">// Public data accessor methods</code><code class="w"/>
<code class="w">  </code><code class="kd">public</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="nf">getRadius</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="n">r</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="w">  </code><code class="kd">public</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">setRadius</code><code class="p">(</code><code class="kt">double</code><code class="w"> </code><code class="n">r</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">checkRadius</code><code class="p">(</code><code class="n">r</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="k">this</code><code class="p">.</code><code class="na">r</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">r</code><code class="p">;</code><code class="w"/>
<code class="w">  </code><code class="p">}</code><code class="w"/>

<code class="w">  </code><code class="c1">// Methods to operate on the instance field</code><code class="w"/>
<code class="w">  </code><code class="kd">public</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="nf">area</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="n">PI</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="n">r</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="n">r</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="w">  </code><code class="kd">public</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="nf">circumference</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="mi">2</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="n">PI</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="n">r</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">public</code><code class="w"> </code><code class="kd">class</code> <code class="nc">PlaneCircle</code><code class="w"> </code><code class="kd">extends</code><code class="w"> </code><code class="n">Circle</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="c1">// We automatically inherit the fields and methods of Circle,</code><code class="w"/>
<code class="w">  </code><code class="c1">// so we only have to put the new stuff here.</code><code class="w"/>
<code class="w">  </code><code class="c1">// New instance fields that store the center point of the circle</code><code class="w"/>
<code class="w">  </code><code class="kd">private</code><code class="w"> </code><code class="kd">final</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="n">cx</code><code class="p">,</code><code class="w"> </code><code class="n">cy</code><code class="p">;</code><code class="w"/>

<code class="w">  </code><code class="c1">// A new constructor to initialize the new fields</code><code class="w"/>
<code class="w">  </code><code class="c1">// It uses a special syntax to invoke the Circle() constructor</code><code class="w"/>
<code class="w">  </code><code class="kd">public</code><code class="w"> </code><code class="nf">PlaneCircle</code><code class="p">(</code><code class="kt">double</code><code class="w"> </code><code class="n">r</code><code class="p">,</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="n">x</code><code class="p">,</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="n">y</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">super</code><code class="p">(</code><code class="n">r</code><code class="p">);</code><code class="w">       </code><code class="c1">// Invoke the constructor of the superclass</code><code class="w"/>
<code class="w">    </code><code class="k">this</code><code class="p">.</code><code class="na">cx</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">x</code><code class="p">;</code><code class="w">    </code><code class="c1">// Initialize the instance field cx</code><code class="w"/>
<code class="w">    </code><code class="k">this</code><code class="p">.</code><code class="na">cy</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">y</code><code class="p">;</code><code class="w">    </code><code class="c1">// Initialize the instance field cy</code><code class="w"/>
<code class="w">  </code><code class="p">}</code><code class="w"/>

<code class="w">  </code><code class="kd">public</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="nf">getCenterX</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="n">cx</code><code class="p">;</code><code class="w"/>
<code class="w">  </code><code class="p">}</code><code class="w"/>

<code class="w">  </code><code class="kd">public</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="nf">getCenterY</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="n">cy</code><code class="p">;</code><code class="w"/>
<code class="w">  </code><code class="p">}</code><code class="w"/>

<code class="w">  </code><code class="c1">// The area() and circumference() methods are inherited from Circle</code><code class="w"/>
<code class="w">  </code><code class="c1">// A new instance method that checks whether a point is inside the</code><code class="w"/>
<code class="w">  </code><code class="c1">// circle; note that it uses the inherited instance field r</code><code class="w"/>
<code class="w">  </code><code class="kd">public</code><code class="w"> </code><code class="kt">boolean</code><code class="w"> </code><code class="nf">isInside</code><code class="p">(</code><code class="kt">double</code><code class="w"> </code><code class="n">x</code><code class="p">,</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="n">y</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kt">double</code><code class="w"> </code><code class="n">dx</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">x</code><code class="w"> </code><code class="o">-</code><code class="w"> </code><code class="n">cx</code><code class="p">,</code><code class="w"> </code><code class="n">dy</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">y</code><code class="w"> </code><code class="o">-</code><code class="w"> </code><code class="n">cy</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="c1">// Pythagorean theorem</code><code class="w"/>
<code class="w">    </code><code class="kt">double</code><code class="w"> </code><code class="n">distance</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Math</code><code class="p">.</code><code class="na">sqrt</code><code class="p">(</code><code class="n">dx</code><code class="o">*</code><code class="n">dx</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">dy</code><code class="o">*</code><code class="n">dy</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="p">(</code><code class="n">distance</code><code class="w"> </code><code class="o">&lt;</code><code class="w"> </code><code class="n">r</code><code class="p">);</code><code class="w">                   </code><code class="c1">// Returns true or false</code><code class="w"/>
<code class="w">  </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>Instead of the preceding code, we can rewrite <code>PlaneCircle</code> using
accessor methods, like this:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code><code class="w"> </code><code class="kd">class</code> <code class="nc">PlaneCircle</code><code class="w"> </code><code class="kd">extends</code><code class="w"> </code><code class="n">Circle</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="c1">// Rest of class is the same as above; the field r in</code><code class="w"/>
<code class="w">  </code><code class="c1">// the superclass Circle can be made private because</code><code class="w"/>
<code class="w">  </code><code class="c1">// we no longer access it directly here</code><code class="w"/>

<code class="w">  </code><code class="c1">// Note that we now use the accessor method getRadius()</code><code class="w"/>
<code class="w">  </code><code class="kd">public</code><code class="w"> </code><code class="kt">boolean</code><code class="w"> </code><code class="nf">isInside</code><code class="p">(</code><code class="kt">double</code><code class="w"> </code><code class="n">x</code><code class="p">,</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="n">y</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kt">double</code><code class="w"> </code><code class="n">dx</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">x</code><code class="w"> </code><code class="o">-</code><code class="w"> </code><code class="n">cx</code><code class="p">,</code><code class="w"> </code><code class="n">dy</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">y</code><code class="w"> </code><code class="o">-</code><code class="w"> </code><code class="n">cy</code><code class="p">;</code><code class="w">            </code><code class="c1">// Distance to center</code><code class="w"/>
<code class="w">    </code><code class="kt">double</code><code class="w"> </code><code class="n">distance</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Math</code><code class="p">.</code><code class="na">sqrt</code><code class="p">(</code><code class="n">dx</code><code class="o">*</code><code class="n">dx</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">dy</code><code class="o">*</code><code class="n">dy</code><code class="p">);</code><code class="w"> </code><code class="c1">// Pythagorean theorem</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="p">(</code><code class="n">distance</code><code class="w"> </code><code class="o">&lt;</code><code class="w"> </code><code class="n">getRadius</code><code class="p">());</code><code class="w"/>
<code class="w">  </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>Both approaches are legal Java, but they have some differences.
As we discussed in <a data-type="xref" href="ch03.xhtml#javanut8-CHP-3-SECT-5">“Data Hiding and Encapsulation”</a>, fields that are writable outside of the class are usually not a correct way to model
object state.
In fact, as we will see later in this chapter and again in <a data-type="xref" href="ch06.xhtml#javanut8-CHP-6-SECT-5">“Java’s Support for Concurrency”</a>, they can damage the running state of a program irreparably.</p>
<p><a data-primary="protected access" data-type="indexterm" id="idm45927734260656"/>It is therefore unfortunate that the <code>protected</code> keyword in Java allows
access to fields (and methods) from both subclasses <em>and</em> classes in the
same packages as the declaring class. This, combined with the ability
for anyone to write a class that belongs to any given package (except
system packages), means that protected inheritance of state is
potentially flawed in Java.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>Java does not provide a mechanism for a member to be visible only in the
declaring class and its subclasses.</p>
</div>
<p>For all of these reasons, it is almost always better to use accessor methods (either public or protected) to provide access to state for subclasses—unless the inherited state is declared <code>final</code>, in which case protected inheritance of state is perfectly permissible.<a data-startref="ix_ch05-asciidoc7" data-type="indexterm" id="idm45927734256928"/><a data-startref="ix_ch05-asciidoc6" data-type="indexterm" id="idm45927734256224"/><a data-startref="ix_ch05-asciidoc5" data-type="indexterm" id="idm45927734255552"/></p>
</div></section>
<section data-pdf-bookmark="Singleton" data-type="sect1"><div class="sect1" id="idm45927734929088">
<h1>Singleton</h1>
<p><a data-primary="object-oriented design (OOD)" data-secondary="singleton pattern" data-type="indexterm" id="ix_ch05-asciidoc8"/><a data-primary="singleton pattern" data-secondary="about" data-type="indexterm" id="ix_ch05-asciidoc9"/>The <em>singleton pattern</em> is a very well-known design pattern. It is
intended to solve the design issue where only a single instance of a
class is required or desired. Java provides a number of different
possible ways to implement the singleton pattern. In our discussion, we
will use a slightly more verbose form, which has the benefit of being
very explicit in what needs to happen for a safe singleton:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code><code class="w"> </code><code class="kd">class</code> <code class="nc">Singleton</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="kd">private</code><code class="w"> </code><code class="kd">final</code><code class="w"> </code><code class="kd">static</code><code class="w"> </code><code class="n">Singleton</code><code class="w"> </code><code class="n">instance</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">Singleton</code><code class="p">();</code><code class="w"/>
<code class="w">  </code><code class="kd">private</code><code class="w"> </code><code class="kd">static</code><code class="w"> </code><code class="kt">boolean</code><code class="w"> </code><code class="n">initialized</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="kc">false</code><code class="p">;</code><code class="w"/>

<code class="w">  </code><code class="c1">// Constructor</code><code class="w"/>
<code class="w">  </code><code class="kd">private</code><code class="w"> </code><code class="nf">Singleton</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">super</code><code class="p">();</code><code class="w"/>
<code class="w">  </code><code class="p">}</code><code class="w"/>

<code class="w">  </code><code class="kd">private</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">init</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="cm">/* Do initialization */</code><code class="w"/>
<code class="w">  </code><code class="p">}</code><code class="w"/>

<code class="w">  </code><code class="c1">// This method should be the only way to get a reference</code><code class="w"/>
<code class="w">  </code><code class="c1">// to the instance</code><code class="w"/>
<code class="w">  </code><code class="kd">public</code><code class="w"> </code><code class="kd">static</code><code class="w"> </code><code class="kd">synchronized</code><code class="w"> </code><code class="n">Singleton</code><code class="w"> </code><code class="nf">getInstance</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="n">initialized</code><code class="p">)</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="n">instance</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="n">instance</code><code class="p">.</code><code class="na">init</code><code class="p">();</code><code class="w"/>
<code class="w">    </code><code class="n">initialized</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="kc">true</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="n">instance</code><code class="p">;</code><code class="w"/>
<code class="w">  </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>The crucial point is that for the singleton pattern to be effective, it must be impossible to create more than one of them, and it must be impossible to get a reference to the object in an uninitialized state (see later in this chapter for more on this important point).</p>
<p>To achieve this, we require a <code>private</code> constructor, which is called only once, ever.
In our version of <code>Singleton</code>, we only call the constructor when we initialize the private static variable <code>instance</code>. We also separate the creation of the only <code>Singleton</code> object from its initialization—which occurs in the private method <code>init()</code>.</p>
<p><a data-primary="getInstance()" data-type="indexterm" id="idm45927734091904"/>With this mechanism in place, the only way to get a reference to the
lone instance of <code>Singleton</code> is via the static helper method,
<code>getInstance()</code>. This method checks the flag <code>initialized</code> to see if the
object is already in an active state. If it is, then a reference to the
singleton object is returned. If not, then <code>getInstance()</code> calls
<code>init()</code> to activate the object and flicks the flag to <code>true</code>, so that
next time a reference to the <code>Singleton</code> is requested, further
initialization will not occur.</p>
<p>Finally, we also note that <code>getInstance()</code> is a <code>synchronized</code> method.
See <a data-type="xref" href="ch06.xhtml#javanut8-CHP-6">Chapter 6</a> for full details of what this means
and why it is necessary, but for now, know that it is present to guard
against unintended consequences if <code>Singleton</code> is used in a
<span class="keep-together">multithreaded</span> program.</p>
<div data-type="tip"><h6>Tip</h6>
<p>Singleton, being one of the simplest patterns, is often overused. When
used correctly, it can be a useful technique, but too many singleton
classes in a program is a classic sign of badly engineered code.</p>
</div>
<p class="pagebreak-before">The singleton pattern has some drawbacks—in particular, it can be hard
to test and to separate from other classes. It also requires care
when used in mulithreaded code. Nevertheless, it is important that
developers are familiar with it and do not accidentally reinvent it. The
singleton pattern is often used in configuration management, but modern
code will typically use a framework (often a <em>dependency injection</em> framework) to
provide the programmer with singletons automatically, rather than via an
explicit <code>Singleton</code> (or equivalent) class.<a data-startref="ix_ch05-asciidoc9" data-type="indexterm" id="idm45927734081760"/><a data-startref="ix_ch05-asciidoc8" data-type="indexterm" id="idm45927734081024"/></p>
</div></section>
<section data-pdf-bookmark="Factory Methods" data-type="sect1"><div class="sect1" id="idm45927734080224">
<h1>Factory Methods</h1>
<p><a data-primary="factory methods" data-type="indexterm" id="ix_ch05-asciidoc10"/><a data-primary="object-oriented design (OOD)" data-secondary="factory methods" data-type="indexterm" id="ix_ch05-asciidoc11"/>An alternative to using constructors directly is the <em>Factory Method</em> pattern.
The basic form of this technique is to make the constructor private (or other nonpublic modifier, in some variants) and to provide a static method that returns the desired type.
This static method is then used by client code that wants an instance of the type.</p>
<p>There are various reasons why, as a code author, we may not want to expose our constructors directly and may choose to use factories instead.
For example, caching factories that do not necessarily create a new object, or because there are several valid ways of constructing an object.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The static factory approach is not the same as the <em>Abstract Factory</em> pattern from the classic book <a href="https://oreil.ly/1CbpU"><em>Design Patterns</em></a>.</p>
</div>
<p>Let’s rewrite the constructor from <a data-type="xref" href="#javanut8-CHP-5-EX-1">Example 5-1</a> and introduce some factory 
<span class="keep-together">methods:</span></p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code><code class="w"> </code><code class="kd">final</code><code class="w"> </code><code class="kd">class</code> <code class="nc">Circle</code><code class="w"> </code><code class="kd">implements</code><code class="w"> </code><code class="n">Comparable</code><code class="o">&lt;</code><code class="n">Circle</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">private</code><code class="w"> </code><code class="kd">final</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="n">x</code><code class="p">,</code><code class="w"> </code><code class="n">y</code><code class="p">,</code><code class="w"> </code><code class="n">r</code><code class="p">;</code><code class="w"/>

<code class="w">    </code><code class="c1">// Main constructor</code><code class="w"/>
<code class="w">    </code><code class="kd">private</code><code class="w"> </code><code class="nf">Circle</code><code class="p">(</code><code class="kt">int</code><code class="w"> </code><code class="n">x</code><code class="p">,</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="n">y</code><code class="p">,</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="n">r</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="n">r</code><code class="w"> </code><code class="o">&lt;</code><code class="w"> </code><code class="mi">0</code><code class="p">)</code><code class="w"> </code><code class="k">throw</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">IllegalArgumentException</code><code class="p">(</code><code class="s">"radius &lt; 0"</code><code class="p">);</code><code class="w"/>
<code class="w">        </code><code class="k">this</code><code class="p">.</code><code class="na">x</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">x</code><code class="p">;</code><code class="w"> </code><code class="k">this</code><code class="p">.</code><code class="na">y</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">y</code><code class="p">;</code><code class="w"> </code><code class="k">this</code><code class="p">.</code><code class="na">r</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">r</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>

<code class="w">    </code><code class="c1">// Usual factory method</code><code class="w"/>
<code class="w">    </code><code class="kd">public</code><code class="w"> </code><code class="kd">static</code><code class="w"> </code><code class="n">Circle</code><code class="w"> </code><code class="nf">of</code><code class="p">(</code><code class="kt">int</code><code class="w"> </code><code class="n">x</code><code class="p">,</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="n">y</code><code class="p">,</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="n">r</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">Circle</code><code class="p">(</code><code class="n">x</code><code class="p">,</code><code class="w"> </code><code class="n">y</code><code class="p">,</code><code class="w"> </code><code class="n">r</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>

<code class="w">    </code><code class="c1">// Factory method playing the role of the copy constructor</code><code class="w"/>
<code class="w">    </code><code class="kd">public</code><code class="w"> </code><code class="kd">static</code><code class="w"> </code><code class="n">Circle</code><code class="w"> </code><code class="nf">of</code><code class="p">(</code><code class="n">Circle</code><code class="w"> </code><code class="n">original</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">Circle</code><code class="p">(</code><code class="n">original</code><code class="p">.</code><code class="na">x</code><code class="p">,</code><code class="w"> </code><code class="n">original</code><code class="p">.</code><code class="na">y</code><code class="p">,</code><code class="w"> </code><code class="n">original</code><code class="p">.</code><code class="na">r</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>

<code class="w">    </code><code class="c1">// Third factory with intent given by name</code><code class="w"/>
<code class="w">    </code><code class="kd">public</code><code class="w"> </code><code class="kd">static</code><code class="w"> </code><code class="n">Circle</code><code class="w"> </code><code class="nf">ofOrigin</code><code class="p">(</code><code class="kt">int</code><code class="w"> </code><code class="n">r</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">Circle</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="n">r</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>

<code class="w">    </code><code class="c1">// other methods elided</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>This class contains a private constructor and three separate factory methods: a “usual” one with the same signature as the constructor, and two additional.
<a data-primary="copy constructor" data-type="indexterm" id="idm45927733782624"/>One of these additional factories is effectively a copy constructor, and the other is used to handle a special case: circles at the origin.</p>
<p>One advantage of using factory methods is that, unlike constructors, the method has a name and so can indicate its intent using part of the name.
In our example, the factory methods are <code>of()</code>, which is one very common choice, and we distinguish the case of the origin circles by using a name <code>ofOrigin()</code> that expresses it.<a data-startref="ix_ch05-asciidoc11" data-type="indexterm" id="idm45927733780464"/><a data-startref="ix_ch05-asciidoc10" data-type="indexterm" id="idm45927733815872"/></p>
</div></section>
<section data-pdf-bookmark="Builders" data-type="sect1"><div class="sect1" id="idm45927733814944">
<h1>Builders</h1>
<p><a data-primary="builder pattern" data-type="indexterm" id="ix_ch05-asciidoc12"/><a data-primary="object-oriented design (OOD)" data-secondary="builder pattern" data-type="indexterm" id="ix_ch05-asciidoc13"/>Factory methods are a useful technique for when you don’t want to expose a constructor to client code.
However, there are limitations to factories.
They work well when only a few parameters, all of which are required, need to be passed.
But in some circumstances, we need to model data where much of it is optional, or when there are many valid, different possible constructions for our domain objects.
In this case, the number of factory methods can quickly multiply to represent all possible combinations and overwhelm us, cluttering the API.</p>
<p>An alternative approach is the <em>Builder</em> pattern.
This pattern uses a secondary builder object that exactly parallels the state of the real domain object (which is assumed to be immutable).
For every field that the domain object has, the builder has the same field—the same name, and the same type.
However, while the domain object is immutable, the builder object is explicitly mutable.
In fact, the builder has a setter method, named in the same way as the field (i.e. in “record convention”) that the developer will use to set up a piece of state.</p>
<p>The overall intent of the Builder pattern is to start from a “blank” builder object and add state to it, until the builder is ready to be converted into an actual domain object, usually by calling the <code>build()</code> method on the builder.</p>
<p>Let’s take a look at a simple example:</p>
<pre data-code-language="java" data-type="programlisting"><code class="c1">// Generic builder interface</code><code class="w"/>
<code class="kd">public</code><code class="w"> </code><code class="kd">interface</code> <code class="nc">Builder</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">T</code><code class="w"> </code><code class="nf">build</code><code class="p">();</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">public</code><code class="w"> </code><code class="kd">class</code> <code class="nc">BCircle</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">private</code><code class="w"> </code><code class="kd">final</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="n">x</code><code class="p">,</code><code class="w"> </code><code class="n">y</code><code class="p">,</code><code class="w"> </code><code class="n">r</code><code class="p">;</code><code class="w"/>

<code class="w">    </code><code class="c1">// The main constructor is now private</code><code class="w"/>
<code class="w">    </code><code class="kd">private</code><code class="w"> </code><code class="nf">BCircle</code><code class="p">(</code><code class="n">CircleBuilder</code><code class="w"> </code><code class="n">cb</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="n">cb</code><code class="p">.</code><code class="na">r</code><code class="w"> </code><code class="o">&lt;</code><code class="w"> </code><code class="mi">0</code><code class="p">)</code><code class="w"/>
<code class="w">        </code><code class="k">throw</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">IllegalArgumentException</code><code class="p">(</code><code class="s">"negative radius"</code><code class="p">);</code><code class="w"/>
<code class="w">        </code><code class="k">this</code><code class="p">.</code><code class="na">x</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">cb</code><code class="p">.</code><code class="na">x</code><code class="p">;</code><code class="w"> </code><code class="k">this</code><code class="p">.</code><code class="na">y</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">cb</code><code class="p">.</code><code class="na">y</code><code class="p">;</code><code class="w"> </code><code class="k">this</code><code class="p">.</code><code class="na">r</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">cb</code><code class="p">.</code><code class="na">r</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>

<code class="w">    </code><code class="kd">public</code><code class="w"> </code><code class="kd">static</code><code class="w"> </code><code class="kd">class</code> <code class="nc">CircleBuilder</code><code class="w"> </code><code class="kd">implements</code><code class="w"> </code><code class="n">Builder</code><code class="o">&lt;</code><code class="n">BCircle</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="kd">private</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="n">x</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="n">y</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="n">r</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"/>

<code class="w">        </code><code class="kd">public</code><code class="w"> </code><code class="n">CircleBuilder</code><code class="w"> </code><code class="nf">x</code><code class="p">(</code><code class="kt">int</code><code class="w"> </code><code class="n">x</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="k">this</code><code class="p">.</code><code class="na">x</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">x</code><code class="p">;</code><code class="w"/>
<code class="w">            </code><code class="k">return</code><code class="w"> </code><code class="k">this</code><code class="p">;</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>

<code class="w">        </code><code class="kd">public</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="nf">x</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="k">return</code><code class="w"> </code><code class="n">x</code><code class="p">;</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>

<code class="w">        </code><code class="c1">// Similarly for y and r</code><code class="w"/>

<code class="w">        </code><code class="nd">@Override</code><code class="w"/>
<code class="w">        </code><code class="kd">public</code><code class="w"> </code><code class="n">BCircle</code><code class="w"> </code><code class="nf">build</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="k">return</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">BCircle</code><code class="p">(</code><code class="k">this</code><code class="p">);</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>

<code class="w">    </code><code class="c1">// Other methods elided</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>Notice that the builder interface is typically generic. This is because in practice we may well have a large number of domain classes, all of which will require builders, so the use of a generic builder interface removes duplication.
The <code>Builder</code> interface contains only one method, so it technically is a candidate for lambda target typing. But in practice this is almost never the intent, and so it is not tagged with <code>@FunctionalInterface</code>.
The implementation of the <code>build()</code> method also contains a nonoptional use of the <code>this</code> reference.</p>
<p>The builder can be driven by a simple bit of code like this:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">var</code><code class="w"> </code><code class="n">cb</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">BCircle</code><code class="p">.</code><code class="na">CircleBuilder</code><code class="p">();</code><code class="w"/>
<code class="n">cb</code><code class="p">.</code><code class="na">x</code><code class="p">(</code><code class="mi">1</code><code class="p">).</code><code class="na">y</code><code class="p">(</code><code class="mi">2</code><code class="p">).</code><code class="na">r</code><code class="p">(</code><code class="mi">3</code><code class="p">);</code><code class="w"/>
<code class="kd">var</code><code class="w"> </code><code class="n">circle</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">cb</code><code class="p">.</code><code class="na">build</code><code class="p">();</code><code class="w"/></pre>
<p>Note that first we instantiate the builder.
Then, we call the methods to set the various parameters on the builder.
Finally, we create an immutable object from the builder, by calling <code>build()</code>.</p>
<p>You may notice that the methods on the builder that accrete state all return <code>this</code>.
The point of this interface design is so that the calls can be <em>chained</em>—so that methods can be called one after another on the same mutable object—for example as <code>cb.x(1).y(2).r(3)</code>.
<a data-primary="fluent interface" data-type="indexterm" id="idm45927733346176"/>Another way of describing this style of interface design is as a <em>fluent interface</em>.
As each method returns <code>this</code>, we know that all of these calls are safe: there can’t be a <code>NullPointerException</code>.</p>
<p>Our example is very simple and is somewhat contrived; it only has three parameters and all of them are required.
In practice, builders are more useful with a larger number of object parameters and when there are multiple possibilities for “spanning sets” of valid object states.
There exists an overlap between the cases where one should use a factory versus a builder; determining exactly where that boundary is for your own code is part of the development of OO design skills.<a data-startref="ix_ch05-asciidoc13" data-type="indexterm" id="idm45927733343776"/><a data-startref="ix_ch05-asciidoc12" data-type="indexterm" id="idm45927733343072"/></p>
</div></section>
<section data-pdf-bookmark="Interfaces Versus Abstract Classes" data-type="sect1"><div class="sect1" id="idm45927733814352">
<h1>Interfaces Versus Abstract Classes</h1>
<p><a data-primary="abstract classes" data-secondary="interfaces vs." data-type="indexterm" id="ix_ch05-asciidoc14"/><a data-primary="interfaces" data-secondary="abstract classes vs." data-type="indexterm" id="ix_ch05-asciidoc15"/><a data-primary="Java 8" data-primary-sortas="Java 08" data-secondary="interfaces in" data-type="indexterm" id="ix_ch05-asciidoc16"/><a data-primary="object-oriented design (OOD)" data-secondary="interfaces vs. abstract classes" data-type="indexterm" id="ix_ch05-asciidoc17"/>Java 8 fundamentally changed Java’s object-oriented programming model.
Before Java 8, interfaces were pure API specification and contained no implementation.
This could (and often did) lead to duplication of code when the interface had multiple implementations.</p>
<p>To prevent this wasted effort, a simple coding pattern developed that takes advantage of the fact that an abstract class can contain a partial implementation that subclasses can build upon.
Numerous subclasses can rely on method implementations provided by an abstract superclass (also called an <em>abstract base</em>).</p>
<p>The pattern consists of an interface that contains the API spec for the basic methods, paired with a primary partial implementation as an abstract class.
<a data-primary="java.util.AbstractList" data-type="indexterm" id="idm45927733310448"/>A good example would be <code>java.util.List</code>, which is paired with <code>java.util.AbstractList</code>.
Two of the main implementations of <code>List</code> that ship with the JDK (<code>ArrayList</code> and <span class="keep-together"><code>LinkedList</code></span>) are subclasses of <code>AbstractList</code>.</p>
<p>As another example:</p>
<pre data-code-language="java" data-type="programlisting"><code class="c1">// Here is a basic interface. It represents a shape that fits inside</code><code class="w"/>
<code class="c1">// of a rectangular bounding box. Any class that wants to serve as a</code><code class="w"/>
<code class="c1">// RectangularShape can implement these methods from scratch.</code><code class="w"/>
<code class="kd">public</code><code class="w"> </code><code class="kd">interface</code> <code class="nc">RectangularShape</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kt">void</code><code class="w"> </code><code class="nf">setSize</code><code class="p">(</code><code class="kt">double</code><code class="w"> </code><code class="n">width</code><code class="p">,</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="n">height</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="kt">void</code><code class="w"> </code><code class="nf">setPosition</code><code class="p">(</code><code class="kt">double</code><code class="w"> </code><code class="n">x</code><code class="p">,</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="n">y</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="kt">void</code><code class="w"> </code><code class="nf">translate</code><code class="p">(</code><code class="kt">double</code><code class="w"> </code><code class="n">dx</code><code class="p">,</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="n">dy</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="kt">double</code><code class="w"> </code><code class="nf">area</code><code class="p">();</code><code class="w"/>
<code class="w">    </code><code class="kt">boolean</code><code class="w"> </code><code class="nf">isInside</code><code class="p">();</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="c1">// Here is a partial implementation of that interface. Many</code><code class="w"/>
<code class="c1">// implementations may find this a useful starting point.</code><code class="w"/>
<code class="kd">public</code><code class="w"> </code><code class="kd">abstract</code><code class="w"> </code><code class="kd">class</code> <code class="nc">AbstractRectangularShape</code><code class="w"/>
<code class="w">                        </code><code class="kd">implements</code><code class="w"> </code><code class="n">RectangularShape</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="c1">// The position and size of the shape</code><code class="w"/>
<code class="w">    </code><code class="kd">protected</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="n">x</code><code class="p">,</code><code class="w"> </code><code class="n">y</code><code class="p">,</code><code class="w"> </code><code class="n">w</code><code class="p">,</code><code class="w"> </code><code class="n">h</code><code class="p">;</code><code class="w"/>

<code class="w">    </code><code class="c1">// Default implementations of some of the interface methods</code><code class="w"/>
<code class="w">    </code><code class="kd">public</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">setSize</code><code class="p">(</code><code class="kt">double</code><code class="w"> </code><code class="n">width</code><code class="p">,</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="n">height</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">     </code><code class="n">w</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">width</code><code class="p">;</code><code class="w"> </code><code class="n">h</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">height</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="kd">public</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">setPosition</code><code class="p">(</code><code class="kt">double</code><code class="w"> </code><code class="n">x</code><code class="p">,</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="n">y</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">     </code><code class="k">this</code><code class="p">.</code><code class="na">x</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">x</code><code class="p">;</code><code class="w"> </code><code class="k">this</code><code class="p">.</code><code class="na">y</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">y</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="kd">public</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">translate</code><code class="w"> </code><code class="p">(</code><code class="kt">double</code><code class="w"> </code><code class="n">dx</code><code class="p">,</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="n">dy</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">x</code><code class="w"> </code><code class="o">+=</code><code class="w"> </code><code class="n">dx</code><code class="p">;</code><code class="w"> </code><code class="n">y</code><code class="w"> </code><code class="o">+=</code><code class="w"> </code><code class="n">dy</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>The arrival of default methods in Java 8 changed this landscape considerably.
Interfaces can now contain implementation code, as we saw in <a data-type="xref" href="ch04.xhtml#javanut8-CHP-4-SECT-1.7">“Default Methods”</a>.</p>
<p>This means that when defining an abstract type (e.g., <code>Shape</code>) that you expect to have many subtypes (e.g., <code>Circle</code>, <code>Rectangle</code>, <code>Square</code>), you are faced with a choice between interfaces and abstract classes.
As they now have potentially similar features, it is not always clear which to use.</p>
<p>Remember that a class that extends an abstract class cannot extend any other class, and that interfaces still cannot contain any nonconstant fields.
This means there are still some restrictions on how we can use inheritance in our Java programs.</p>
<p>Another important difference between interfaces and abstract classes has
to do with compatibility. If you define an interface as part of a public
API and then later add a new mandatory method to the interface, you
break any classes that implemented the previous version of the
interface—in other words, any new interface methods must be declared as
default and an implementation provided.</p>
<p>If you use an abstract class, however, you can safely add nonabstract methods to that class without requiring modifications to existing classes that extend the abstract class.</p>
<p>In both cases, adding new methods can cause a clash with subclass methods of the same name and signature—with the subclass methods always winning.
For this reason, think carefully when adding new methods, especially when the method names are “obvious” for this type or where the method could have several possible meanings.</p>
<p>In general, the suggested approach is to prefer interfaces when an API
specification is needed. The mandatory methods of the interface are
nondefault, as they represent the part of the API that must be present
for an implementation to be considered valid. Default methods should be
used only if a method is truly optional, or if they are really only
intended to have a single possible implementation.</p>
<p>Finally, the older (pre-Java 8) technique of declaring in documentation which methods of an interface are considered “optional” and directing to implementations to throw a <code>java.lang.UnsupportedOperationException</code> if the programmer does not want to implement them is fraught with problems and should not be used in new code.<a data-startref="ix_ch05-asciidoc17" data-type="indexterm" id="idm45927733119984"/><a data-startref="ix_ch05-asciidoc16" data-type="indexterm" id="idm45927733119424"/><a data-startref="ix_ch05-asciidoc15" data-type="indexterm" id="idm45927733118752"/><a data-startref="ix_ch05-asciidoc14" data-type="indexterm" id="idm45927733118080"/></p>
</div></section>
<section data-pdf-bookmark="Do Default Methods Change Java’s Inheritance Model?" data-type="sect1"><div class="sect1" id="idm45927733341808">
<h1>Do Default Methods Change Java’s Inheritance Model?</h1>
<p><a data-primary="default methods" data-secondary="traits and" data-type="indexterm" id="ix_ch05-asciidoc18"/><a data-primary="object-oriented design (OOD)" data-secondary="default methods and traits" data-type="indexterm" id="ix_ch05-asciidoc19"/><a data-primary="traits, default methods and" data-type="indexterm" id="ix_ch05-asciidoc20"/>Before Java 8, the strict single inheritance model of the language was clear.
Every class (except <code>Object</code>) had exactly one direct superclass, and method implementations could only either be defined in a class, or be inherited from the superclass hierarchy.</p>
<p>Default methods change this picture, because they allow method implementations to be inherited from multiple places—either from the superclass hierarchy or from default implementation provided in interfaces.
Any potential conflicts between different default methods from separate interfaces will result in a compile-time error.</p>
<p>This means there is no possibility of conflicting multiple inheritance of implementation, as in any clash the programmer is required to manually disambiguate the methods.</p>
<p>There is also no multiple inheritance of state: interfaces still do not have non-constant fields.</p>
<p>This means that Java’s multiple inheritance is different from the general multiple inheritance found in, e.g., C++.
In fact, default methods are effectively the <em>Mixin</em> pattern from C++ (for readers who are familiar with that language).
Some developers also view default members as a form of the <em>trait</em> language feature that appears in some OO languages (e.g., Scala).</p>
<p>However, the official position from Java’s language designers is that default methods fall short of being full traits.
<a data-primary="java.util.function" data-type="indexterm" id="idm45927733108656"/>This view is somewhat undermined by the code that ships within the JDK—even the interfaces within <code>java.util.function</code> (such as <code>Function</code> itself) behave as simple traits.</p>
<p>For example, consider this example:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code><code class="w"> </code><code class="kd">interface</code> <code class="nc">IntFunc</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kt">int</code><code class="w"> </code><code class="nf">apply</code><code class="p">(</code><code class="kt">int</code><code class="w"> </code><code class="n">x</code><code class="p">);</code><code class="w"/>

<code class="w">    </code><code class="k">default</code><code class="w"> </code><code class="n">IntFunc</code><code class="w"> </code><code class="nf">compose</code><code class="p">(</code><code class="n">IntFunc</code><code class="w"> </code><code class="n">before</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="p">(</code><code class="kt">int</code><code class="w"> </code><code class="n">y</code><code class="p">)</code><code class="w"> </code><code class="o">-&gt;</code><code class="w"> </code><code class="n">apply</code><code class="p">(</code><code class="n">before</code><code class="p">.</code><code class="na">apply</code><code class="p">(</code><code class="n">y</code><code class="p">));</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>

<code class="w">    </code><code class="k">default</code><code class="w"> </code><code class="n">IntFunc</code><code class="w"> </code><code class="nf">andThen</code><code class="p">(</code><code class="n">IntFunc</code><code class="w"> </code><code class="n">after</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="p">(</code><code class="kt">int</code><code class="w"> </code><code class="n">z</code><code class="p">)</code><code class="w"> </code><code class="o">-&gt;</code><code class="w"> </code><code class="n">after</code><code class="p">.</code><code class="na">apply</code><code class="p">(</code><code class="n">apply</code><code class="p">(</code><code class="n">z</code><code class="p">));</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>

<code class="w">    </code><code class="kd">static</code><code class="w"> </code><code class="n">IntFunc</code><code class="w"> </code><code class="nf">id</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="n">x</code><code class="w"> </code><code class="o">-&gt;</code><code class="w"> </code><code class="n">x</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>It is a simplified version of the <code>Function</code> interface in <code>java.util.function</code> that removes the generics and deals with <code>int</code> only as a data type.</p>
<p>This case shows an important point for the functional composition methods (
<span class="keep-together"><code>compose()</code></span> and <code>andThen()</code>) present: these functions will only be composed in the standard way, and it is highly implausible that any sane override of the default <code>compose()</code> method could exist.</p>
<p>This is, of course, also true for the function types present in <code>java.util.function</code>, and it shows that within the limited domain provided, default methods can indeed be treated as a form of stateless trait.<a data-startref="ix_ch05-asciidoc20" data-type="indexterm" id="idm45927732836288"/><a data-startref="ix_ch05-asciidoc19" data-type="indexterm" id="idm45927732835584"/><a data-startref="ix_ch05-asciidoc18" data-type="indexterm" id="idm45927732834912"/></p>
</div></section>
<section data-pdf-bookmark="OOD Using Lambdas" data-type="sect1"><div class="sect1" id="idm45927733116816">
<h1>OOD Using Lambdas</h1>
<p><a data-primary="lambda expressions" data-secondary="object-oriented design and" data-type="indexterm" id="ix_ch05-asciidoc21"/><a data-primary="object-oriented design (OOD)" data-secondary="lambdas and" data-type="indexterm" id="ix_ch05-asciidoc22"/>Consider this simple lambda expression:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">Runnable</code><code class="w"> </code><code class="n">r</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">()</code><code class="w"> </code><code class="o">-&gt;</code><code class="w"> </code><code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="s">"Hello World"</code><code class="p">);</code><code class="w"/></pre>
<p>The type of the <em>lvalue</em> (lefthand side of the assignment) is <code>Runnable</code>, which is an interface type.
For this statement to make sense, the <em>rvalue</em> (right-hand side of the assignment) must contain an instance of some class type (because interfaces cannot be instantiated) that implements <code>Runnable</code>.
The minimal implementation that satisfies these constraints is a class type (of inconsequential name) that directly extends <code>Object</code> and implements <code>Runnable</code>.</p>
<p>Recall that the intention of lambda expressions is to allow Java programmers to express a concept that is as close as possible to the anonymous or inline methods seen in other languages.</p>
<p>Furthermore, given that Java is a statically typed language, this leads directly to the design of lambdas as implemented.</p>
<div data-type="tip"><h6>Tip</h6>
<p>Lambdas are a shorthand for the construction of a new instance of a class type that is essentially <code>Object</code> enhanced by a single method.</p>
</div>
<p>A lambda’s single extra method has a signature provided by the interface type, and the compiler will check that the <code>rvalue</code> is consistent with this type signature.</p>
<section data-pdf-bookmark="Lambdas Versus Nested Classes" data-type="sect2"><div class="sect2" id="idm45927732801472">
<h2>Lambdas Versus Nested Classes</h2>
<p><a data-primary="lambda expressions" data-secondary="nested classes vs." data-type="indexterm" id="idm45927732800064"/><a data-primary="nested classes, lambdas vs." data-type="indexterm" id="idm45927732799088"/>The addition of lambdas to the language in Java 8 was relatively late, as compared to other programming languages.
As a consequence, the Java community had established patterns to work around the absence of lambdas.
This manifests in a heavy use of very simple nested (aka inner) classes to fill the niche that lambdas usually occupy.</p>
<p>In modern Java projects developed from scratch, developers will typically use lambdas wherever possible.
We also strongly suggest that, when refactoring old code, you take some time to convert inner classes to lambdas wherever possible.
Some IDEs even provide an automatic conversion facility.</p>
<p>However, this still leaves the design question of when to use lambdas and when nested classes are still the correct solution.</p>
<p>Some cases are obvious; for example, when extending a default implementation for some functionality, a nested class approach is appropriate, for two reasons:</p>
<ol>
<li>
<p>The custom implementation may have to override multiple methods</p>
</li>
<li>
<p>The base implementation is a class, not an interface</p>
</li>
</ol>
<p>Another major use case to consider is that of stateful lambdas.
As there is nowhere to declare any fields, it would appear at first glance that lambdas cannot directly be used for anything that involves state—the syntax only gives the opportunity to declare a method body.</p>
<p>However, a lambda can refer to a variable defined in the scope that the lambda is created in, so we can create a closure, as discussed in <a data-type="xref" href="ch04.xhtml#javanut8-CHP-4">Chapter 4</a>, to fill the role of a stateful lambda.</p>
</div></section>
<section data-pdf-bookmark="Lambdas Versus Method References" data-type="sect2"><div class="sect2" id="idm45927732792848">
<h2>Lambdas Versus Method References</h2>
<p><a data-primary="lambda expressions" data-secondary="method references vs." data-type="indexterm" id="idm45927732791472"/><a data-primary="method references" data-secondary="lambdas vs." data-type="indexterm" id="idm45927732790496"/>The question of when to use a lambda and when to use a method reference is largely a matter of personal taste and style.
There are, of course, some circumstances where it is essential to create a lambda.
However, in many simple cases, a lambda can be replaced by a method reference.</p>
<p>One possible approach is to consider whether the lambda notation adds anything to the readability of the code.
For example, in the streams API, there is a potential benefit in using the lambda form, as it uses the <code>-&gt;</code> operator.
This provides a form of visual metaphor—the stream API is a lazy abstraction that can be visualized as data items “flowing through a functional pipeline.”</p>
<p>For example, let’s consider a <code>Person</code> object, which has standard characteristics, such as name, age, etc.
We can compute the average using a pipeline, like this:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">List</code><code class="o">&lt;</code><code class="n">Person</code><code class="o">&gt;</code><code class="w"> </code><code class="n">persons</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">...</code><code class="w"> </code><code class="c1">// derived from somewhere</code><code class="w"/>
<code class="kt">double</code><code class="w"> </code><code class="n">aveAge</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">persons</code><code class="p">.</code><code class="na">stream</code><code class="p">()</code><code class="w"/>
<code class="w">        </code><code class="p">.</code><code class="na">mapToDouble</code><code class="p">(</code><code class="n">o</code><code class="w"> </code><code class="o">-&gt;</code><code class="w"> </code><code class="n">o</code><code class="p">.</code><code class="na">getAge</code><code class="p">())</code><code class="w"/>
<code class="w">        </code><code class="p">.</code><code class="na">reduce</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="p">(</code><code class="n">x</code><code class="p">,</code><code class="w"> </code><code class="n">y</code><code class="p">)</code><code class="w"> </code><code class="o">-&gt;</code><code class="w"> </code><code class="n">x</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">y</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="o">/</code><code class="w"> </code><code class="n">persons</code><code class="p">.</code><code class="na">size</code><code class="p">();</code><code class="w"/></pre>
<p>The idea that the <code>mapToDouble()</code> method has an aspect of motion, or transformation, is strongly implied by the usage of an explicit lambda.
For less experienced programmers, it also draws attention to the use of a functional API.</p>
<p>For other use cases (e.g., <em>dispatch tables</em>), method references may well be more appropriate.
For example:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code><code class="w"> </code><code class="kd">class</code> <code class="nc">IntOps</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">private</code><code class="w"> </code><code class="n">Map</code><code class="o">&lt;</code><code class="n">String</code><code class="p">,</code><code class="w"> </code><code class="n">BinaryOperator</code><code class="o">&gt;</code><code class="w"> </code><code class="n">table</code><code class="w"> </code><code class="o">=</code><code class="w"/>
<code class="w">        </code><code class="n">Map</code><code class="p">.</code><code class="na">of</code><code class="p">(</code><code class="s">"add"</code><code class="p">,</code><code class="w"> </code><code class="n">IntOps</code><code class="p">::</code><code class="n">add</code><code class="p">,</code><code class="w"> </code><code class="s">"subtract"</code><code class="p">,</code><code class="w"> </code><code class="n">IntOps</code><code class="p">::</code><code class="n">sub</code><code class="p">);</code><code class="w"/>

<code class="w">    </code><code class="kd">private</code><code class="w"> </code><code class="kd">static</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="nf">add</code><code class="p">(</code><code class="kt">int</code><code class="w"> </code><code class="n">x</code><code class="p">,</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="n">y</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="n">x</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">y</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>

<code class="w">    </code><code class="kd">private</code><code class="w"> </code><code class="kd">static</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="nf">sub</code><code class="p">(</code><code class="kt">int</code><code class="w"> </code><code class="n">x</code><code class="p">,</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="n">y</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="n">x</code><code class="w"> </code><code class="o">-</code><code class="w"> </code><code class="n">y</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>

<code class="w">    </code><code class="kd">public</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="nf">eval</code><code class="p">(</code><code class="n">String</code><code class="w"> </code><code class="n">op</code><code class="p">,</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="n">x</code><code class="p">,</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="n">y</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="n">table</code><code class="p">.</code><code class="na">get</code><code class="p">(</code><code class="n">op</code><code class="p">).</code><code class="na">apply</code><code class="p">(</code><code class="n">x</code><code class="p">,</code><code class="w"> </code><code class="n">y</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>In situations where either notation could be used, you will come to develop a preference that fits your individual style over time.
The key consideration is whether, when returning to reread code written several months (or years) ago, the choice of notation still makes sense and the code is easy to read.<a data-startref="ix_ch05-asciidoc22" data-type="indexterm" id="idm45927732549152"/><a data-startref="ix_ch05-asciidoc21" data-type="indexterm" id="idm45927732548544"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="OOD Using Sealed Types" data-type="sect1"><div class="sect1" id="idm45927732833648">
<h1>OOD Using Sealed Types</h1>
<p><a data-primary="object-oriented design (OOD)" data-secondary="sealed types" data-type="indexterm" id="ix_ch05-asciidoc23"/><a data-primary="sealed types" data-type="indexterm" id="ix_ch05-asciidoc24"/>We met sealed classes for the first time in <a data-type="xref" href="ch03.xhtml#javanut8-CHP-3">Chapter 3</a> and introduced sealed interfaces in <a data-type="xref" href="ch04.xhtml#javanut8-CHP-4">Chapter 4</a>.
As well as the cases we’ve already met, there is also a simpler possibility, in which a sealed type can be extended only by classes that are defined inside the same compilation unit (i.e., Java source file), like this:</p>
<pre data-code-language="java" data-type="programlisting"><code class="c1">// Note the absence of a permits clause</code><code class="w"/>
<code class="kd">public</code><code class="w"> </code><code class="kd">abstract</code><code class="w"> </code><code class="kd">sealed</code><code class="w"> </code><code class="kd">class</code> <code class="nc">Shape</code><code class="w"> </code><code class="p">{</code><code class="w"/>

<code class="w">    </code><code class="kd">public</code><code class="w"> </code><code class="kd">static</code><code class="w"> </code><code class="kd">final</code><code class="w"> </code><code class="kd">class</code> <code class="nc">Circle</code><code class="w"> </code><code class="kd">extends</code><code class="w"> </code><code class="n">Shape</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="c1">// ...</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>

<code class="w">    </code><code class="kd">public</code><code class="w"> </code><code class="kd">static</code><code class="w"> </code><code class="kd">final</code><code class="w"> </code><code class="kd">class</code> <code class="nc">Rectangle</code><code class="w"> </code><code class="kd">extends</code><code class="w"> </code><code class="n">Shape</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="c1">// ...</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>The classes <code>Shape.Circle</code> and <code>Shape.Rectangle</code> are the only permitted subclasses of <code>Shape</code>: any other attempt to extend <code>Shape</code> will result in a compilation error.
This is really just additional detail, as the general concept remains the same; <code>sealed</code> indicates a type that has only a finite number of possible types that are compatible with it.</p>
<p>There is an interesting duality here:</p>
<ul>
<li>
<p>Enums are classes that have only a finite number of instances—any enum object is one of those instances</p>
</li>
<li>
<p>Sealed types have only a finite number of compatible classes—any sealed object belongs to one of those classes</p>
</li>
</ul>
<p>Now consider a switch expression that accepts an enum, for example:</p>
<pre data-type="programlisting">var temp = switch(season) {
    case WINTER -&gt; 2.0;
    case SPRING -&gt; 10.5;
    case SUMMER -&gt; 24.5;
    case AUTUMN -&gt; 16.0;
};
System.out.println("Average temp: "+ temp);</pre>
<p>All the possible enum constants for seasons are present in this switch expression, and so the match is said to be <em>total</em>.
In this case, it is not necessary to include a <code>default</code>, as the compiler can use the <em>exhaustiveness</em> of the enum constants to infer that the default case would never be activated.</p>
<p>It isn’t hard to see that we could do something similar with sealed types. Some code like this:</p>
<pre data-type="programlisting">Shape shape = ...

if (shape instanceof Shape.Circle c) {
    System.out.println("Circle: "+ c.circumference());
} else if (shape instanceof Shape.Rectangle r) {
    System.out.println("Rectangle: "+ r.circumference());
}</pre>
<p>is obviously exhaustive to a human but is not currently (as of Java 17) directly recognized by the compiler.</p>
<p>This is because, as of Java 17, sealed types are essentially an incomplete feature.
<a data-primary="pattern matching" data-type="indexterm" id="idm45927732356448"/>In a future version of Java, the intent is to extend the switch expressions feature and combine it with the new form of <code>instanceof</code> (and other new language features) to deliver a capability called <em>pattern matching</em>.</p>
<p>This new feature will enable developers to write code that, for example, “switches over a variable’s type,” and this will unlock new design patterns inspired by functional programming, which have not been easy to achieve in Java.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><a data-type="xref" href="app01.xhtml#javanut8-APP-A">Appendix</a> has more information about pattern matching and other future features.</p>
</div>
<p>Despite not being entirely complete as of Java 17, sealed types are still very useful in their current form and can also be combined with records to produce some compelling designs.<a data-startref="ix_ch05-asciidoc24" data-type="indexterm" id="idm45927732352112"/><a data-startref="ix_ch05-asciidoc23" data-type="indexterm" id="idm45927732351408"/></p>
</div></section>
<section data-pdf-bookmark="OOD Using Records" data-type="sect1"><div class="sect1" id="idm45927732547344">
<h1>OOD Using Records</h1>
<p><a data-primary="object-oriented design (OOD)" data-secondary="records" data-type="indexterm" id="ix_ch05-asciidoc25"/><a data-primary="records" data-secondary="OOD and" data-type="indexterm" id="ix_ch05-asciidoc26"/>Records were introduced in <a data-type="xref" href="ch03.xhtml#javanut8-CHP-3">Chapter 3</a>, and in their simplest form they represent a data entity that is “just fields” or a “bag of data.”
<a data-primary="tuples, Java records versus" data-type="indexterm" id="idm45927732345776"/>In some other programming languages, this is represented by a <em>tuple</em>, but Java’s records are different from tuples in two important ways:</p>
<ol>
<li>
<p>Java records are named types, whereas tuples are anonymous</p>
</li>
<li>
<p>Java records can have methods, auxiliary constructors and almost everything a class can</p>
</li>
</ol>
<p>Both of these stem from the fact that records are a special type of class.
This allows the programmer to start their design by using a record as a basic collection of fields, and then to evolve from there.</p>
<p>For example, let’s rewrite <a data-type="xref" href="#javanut8-CHP-5-EX-1">Example 5-1</a> as a record (eliding the <code>Comparable</code> interface for simplicity):</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code><code class="w"> </code><code class="kd">record</code> <code class="nc">Circle</code><code class="p">(</code><code class="kt">int</code><code class="w"> </code><code class="n">x</code><code class="p">,</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="n">y</code><code class="p">,</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="n">r</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="c1">// Primary (compact) constructor</code><code class="w"/>
<code class="w">    </code><code class="kd">public</code><code class="w"> </code><code class="n">Circle</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="c1">// Validation code in the constructor</code><code class="w"/>
<code class="w">        </code><code class="c1">// This would be impossible in a tuple</code><code class="w"/>
<code class="w">        </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="n">r</code><code class="w"> </code><code class="o">&lt;</code><code class="w"> </code><code class="mi">0</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="k">throw</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">IllegalArgumentException</code><code class="p">(</code><code class="s">"negative radius"</code><code class="p">);</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>

<code class="w">    </code><code class="c1">// Factory method playing the role of the copy constructor</code><code class="w"/>
<code class="w">    </code><code class="kd">public</code><code class="w"> </code><code class="kd">static</code><code class="w"> </code><code class="n">Circle</code><code class="w"> </code><code class="nf">of</code><code class="p">(</code><code class="n">Circle</code><code class="w"> </code><code class="n">original</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">Circle</code><code class="p">(</code><code class="n">original</code><code class="p">.</code><code class="na">x</code><code class="p">,</code><code class="w"> </code><code class="n">original</code><code class="p">.</code><code class="na">y</code><code class="p">,</code><code class="w"> </code><code class="n">original</code><code class="p">.</code><code class="na">r</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p><a data-primary="compact constructor" data-type="indexterm" id="idm45927732337440"/>Note that we have introduced a new type of constructor, called a <em>compact constructor</em>.
It is available only for records and is used in the case where we want to do a bit of extra work in the constructor as well as initialize the fields.
Compact constructors don’t have (or need) a parameter list, as they always have the same parameter list as the declaration of the record.</p>
<p>This code is much shorter than <a data-type="xref" href="#javanut8-CHP-5-EX-1">Example 5-1</a> and clearly distinguishes the case of the primary constructor (the “true form”) of the record from the copy constructor and any other factories that may be present.</p>
<p>The design of Java’s records means that they are a very flexible choice for the programmer.
An entity can be initially modeled as just fields, and over time, can acquire more methods, implement interfaces, and so on.</p>
<p>One other important aspect is that records also can be used very effectively in combination with sealed interfaces.
Let’s take a look at an example: a delivery company that has different types of orders: basic orders (delivered free), and express orders (arrive quicker but for an additional charge).</p>
<p>The basic interface for the orders looks like this:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">sealed</code><code class="w"> </code><code class="kd">interface</code> <code class="nc">Order</code><code class="w"> </code><code class="n">permits</code><code class="w"> </code><code class="n">BasicOrder</code><code class="p">,</code><code class="w"> </code><code class="n">ExpressOrder</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kt">double</code><code class="w"> </code><code class="nf">price</code><code class="p">();</code><code class="w"/>
<code class="w">    </code><code class="n">String</code><code class="w"> </code><code class="nf">address</code><code class="p">();</code><code class="w"/>
<code class="w">    </code><code class="n">LocalDate</code><code class="w"> </code><code class="nf">delivery</code><code class="p">();</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>and has two implementations:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code><code class="w"> </code><code class="kd">record</code> <code class="nc">BasicOrder</code><code class="p">(</code><code class="kt">double</code><code class="w"> </code><code class="n">price</code><code class="p">,</code><code class="w"/>
<code class="w">                         </code><code class="n">String</code><code class="w"> </code><code class="n">address</code><code class="p">,</code><code class="w"/>
<code class="w">                         </code><code class="n">LocalDate</code><code class="w"> </code><code class="n">delivery</code><code class="p">)</code><code class="w"> </code><code class="kd">implements</code><code class="w"> </code><code class="n">Order</code><code class="w"> </code><code class="p">{}</code><code class="w"/>

<code class="kd">public</code><code class="w"> </code><code class="kd">record</code> <code class="nc">ExpressOrder</code><code class="p">(</code><code class="kt">double</code><code class="w"> </code><code class="n">price</code><code class="p">,</code><code class="w"/>
<code class="w">                           </code><code class="n">String</code><code class="w"> </code><code class="n">address</code><code class="p">,</code><code class="w"/>
<code class="w">                           </code><code class="n">LocalDate</code><code class="w"> </code><code class="n">delivery</code><code class="p">,</code><code class="w"/>
<code class="w">                           </code><code class="kt">double</code><code class="w"> </code><code class="n">deliveryCharge</code><code class="p">)</code><code class="w"> </code><code class="kd">implements</code><code class="w"> </code><code class="n">Order</code><code class="w"> </code><code class="p">{}</code><code class="w"/></pre>
<p>Remember that the supertype of all record types is <code>java.lang.Record</code>, so for this type of use case we have to use interfaces; it would not be possible to have the different order types extend an abstract base.
Our choices are:</p>
<ul>
<li>
<p>Model the entities as classes and use a <code>sealed abstract</code> base class</p>
</li>
<li>
<p>Model the entities as records and use a sealed interface</p>
</li>
</ul>
<p>In the second case, any common record components need to be hoisted up into the interface, just as we saw for the <code>Order</code> example.<a data-startref="ix_ch05-asciidoc26" data-type="indexterm" id="idm45927732062032"/><a data-startref="ix_ch05-asciidoc25" data-type="indexterm" id="idm45927732061296"/></p>
</div></section>
<section data-pdf-bookmark="Instance Methods or Class Methods?" data-type="sect1"><div class="sect1" id="idm45927732350144">
<h1>Instance Methods or Class Methods?</h1>
<p><a data-primary="class methods" data-secondary="instance methods vs." data-type="indexterm" id="ix_ch05-asciidoc27"/><a data-primary="instance methods" data-type="indexterm" id="ix_ch05-asciidoc28"/><a data-primary="methods" data-secondary="instance methods vs. class methods" data-type="indexterm" id="ix_ch05-asciidoc29"/><a data-primary="object-oriented design (OOD)" data-secondary="instance methods vs. class methods" data-type="indexterm" id="ix_ch05-asciidoc30"/>Instance methods are one of the key features of object-oriented
programming. That doesn’t mean, however, that you should shun class
methods. In many cases, it is perfectly reasonable to define class
methods.</p>
<div data-type="tip"><h6>Tip</h6>
<p><a data-primary="static keyword" data-type="indexterm" id="idm45927732020880"/>Remember that in Java, class methods are declared with the <code>static</code>
keyword, and the terms <em>static method</em> and <em>class method</em> are used
interchangeably.</p>
</div>
<p>For example, when working with the <code>Circle</code> class you might find that
you often want to compute the area of a circle with a given radius but
don’t want to bother creating a <code>Circle</code> object to represent that
circle. In this case, a class method is more convenient:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code><code class="w"> </code><code class="kd">static</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="nf">area</code><code class="p">(</code><code class="kt">double</code><code class="w"> </code><code class="n">r</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="n">PI</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="n">r</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="n">r</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w"/></pre>
<p>It is perfectly legal for a class to define more than one method with
the same name, as long as the methods have different parameter lists. This
version of the <code>area()</code> method is a class method, so it does not have an
implicit <code>this</code> parameter and must have a parameter that specifies the
radius of the circle. This parameter keeps it distinct from the instance
method of the same name.</p>
<p>As another example of the choice between instance methods and class
methods, consider defining a method named <code>bigger()</code> that examines two
<code>Circle</code> objects and returns whichever has the larger radius. We can
write <code>bigger()</code> as an instance method as follows:</p>
<pre data-code-language="java" data-type="programlisting"><code class="c1">// Compare the implicit "this" circle to the "that" circle passed</code><code class="w"/>
<code class="c1">// explicitly as an argument and return the bigger one.</code><code class="w"/>
<code class="kd">public</code><code class="w"> </code><code class="n">Circle</code><code class="w"> </code><code class="nf">bigger</code><code class="p">(</code><code class="n">Circle</code><code class="w"> </code><code class="n">that</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="na">r</code><code class="w"> </code><code class="o">&gt;</code><code class="w"> </code><code class="n">that</code><code class="p">.</code><code class="na">r</code><code class="p">)</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="k">this</code><code class="p">;</code><code class="w"/>
<code class="w">  </code><code class="k">else</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="n">that</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>We can also implement <code>bigger()</code> as a class method as follows:</p>
<pre data-code-language="java" data-type="programlisting"><code class="c1">// Compare circles a and b and return the one with the larger radius</code><code class="w"/>
<code class="kd">public</code><code class="w"> </code><code class="kd">static</code><code class="w"> </code><code class="n">Circle</code><code class="w"> </code><code class="nf">bigger</code><code class="p">(</code><code class="n">Circle</code><code class="w"> </code><code class="n">a</code><code class="p">,</code><code class="w"> </code><code class="n">Circle</code><code class="w"> </code><code class="n">b</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="n">a</code><code class="p">.</code><code class="na">r</code><code class="w"> </code><code class="o">&gt;</code><code class="w"> </code><code class="n">b</code><code class="p">.</code><code class="na">r</code><code class="p">)</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="n">a</code><code class="p">;</code><code class="w"/>
<code class="w">  </code><code class="k">else</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="n">b</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>Given two <code>Circle</code> objects, <code>x</code> and <code>y</code>, we can use either the instance
method or the class method to determine which is bigger. The invocation
syntax differs significantly for the two methods, however:</p>
<pre data-code-language="java" data-type="programlisting"><code class="c1">// Instance method: also y.bigger(x)</code><code class="w"/>
<code class="n">Circle</code><code class="w"> </code><code class="n">biggest</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">x</code><code class="p">.</code><code class="na">bigger</code><code class="p">(</code><code class="n">y</code><code class="p">);</code><code class="w"/>
<code class="n">Circle</code><code class="w"> </code><code class="n">biggest</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Circle</code><code class="p">.</code><code class="na">bigger</code><code class="p">(</code><code class="n">x</code><code class="p">,</code><code class="w"> </code><code class="n">y</code><code class="p">);</code><code class="w">  </code><code class="c1">// Static method</code><code class="w"/></pre>
<p>Both methods work well, and, from an object-oriented design standpoint,
neither of these methods is “more correct” than the other. The instance
method is more formally object-oriented, but its invocation syntax
suffers from a kind of asymmetry. In a case like this, the choice
between an instance method and a class method is simply a design
decision. Depending on the circumstances, one or the other will likely
be the more natural choice.</p>
<section data-pdf-bookmark="A word about System.out.println()" data-type="sect2"><div class="sect2" id="idm45927731770080">
<h2>A word about System.out.println()</h2>
<p><a data-primary="object-oriented design (OOD)" data-secondary="System.out.println() and" data-type="indexterm" id="idm45927731769072"/><a data-primary="println()" data-secondary="System.out.println() and" data-type="indexterm" id="idm45927731767968"/><a data-primary="System.out.println()" data-type="indexterm" id="idm45927731767024"/>We’ve frequently encountered the method <code>System.out.println()</code>—it’s
used to display output to the terminal window or console. We’ve never
explained why this method has such a long, awkward name or what those
two periods are doing in it. Now that you understand class and instance
fields and class and instance methods, it is easier to understand what
is going on: <code>System</code> is a class. It has a public class field named
<code>out</code>. <a data-primary="java.io.PrintStream" data-type="indexterm" id="idm45927731765008"/>This field is an object of type <code>java.io.PrintStream</code>, and it
has an instance method named <code>println()</code>.</p>
<p><a data-primary="java.lang.System.out" data-type="indexterm" id="idm45927731763152"/>We can use static imports to make this a bit shorter with
<code>import static java.lang.System.out;</code>—this will enable us to refer to
the printing method as <code>out.println()</code> but as this is an instance
method, we cannot shorten it further.<a data-startref="ix_ch05-asciidoc30" data-type="indexterm" id="idm45927731761552"/><a data-startref="ix_ch05-asciidoc29" data-type="indexterm" id="idm45927731760848"/><a data-startref="ix_ch05-asciidoc28" data-type="indexterm" id="idm45927731760176"/><a data-startref="ix_ch05-asciidoc27" data-type="indexterm" id="idm45927731759504"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Composition Versus Inheritance" data-type="sect1"><div class="sect1" id="idm45927732060032">
<h1>Composition Versus Inheritance</h1>
<p><a data-primary="composition, inheritance vs." data-type="indexterm" id="ix_ch05-asciidoc31"/><a data-primary="inheritance" data-secondary="composition vs." data-type="indexterm" id="ix_ch05-asciidoc32"/><a data-primary="object-oriented design (OOD)" data-secondary="composition vs. inheritance" data-type="indexterm" id="ix_ch05-asciidoc33"/>Inheritance is not the only technique at our disposal in
object-oriented design. Objects can contain references to other objects,
so a larger conceptual unit can be aggregated out of smaller component
parts; this is known as <em>composition</em>.</p>
<p>An important related technique is <em>delegation</em>, where an object of a particular type holds a reference
to a secondary object of a compatible type and forwards all operations
to the secondary object. This is frequently done using interface types,
as shown in this example where we model the employment structure of
software companies:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code><code class="w"> </code><code class="kd">interface</code> <code class="nc">Employee</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="kt">void</code><code class="w"> </code><code class="nf">work</code><code class="p">();</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">public</code><code class="w"> </code><code class="kd">class</code> <code class="nc">Programmer</code><code class="w"> </code><code class="kd">implements</code><code class="w"> </code><code class="n">Employee</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="kd">public</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">work</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="cm">/* program computer */</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">public</code><code class="w"> </code><code class="kd">class</code> <code class="nc">Manager</code><code class="w"> </code><code class="kd">implements</code><code class="w"> </code><code class="n">Employee</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="kd">private</code><code class="w"> </code><code class="n">Employee</code><code class="w"> </code><code class="n">report</code><code class="p">;</code><code class="w"/>

<code class="w">  </code><code class="kd">public</code><code class="w"> </code><code class="nf">Manager</code><code class="p">(</code><code class="n">Employee</code><code class="w"> </code><code class="n">staff</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">report</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">staff</code><code class="p">;</code><code class="w"/>
<code class="w">  </code><code class="p">}</code><code class="w"/>

<code class="w">  </code><code class="kd">public</code><code class="w"> </code><code class="n">Employee</code><code class="w"> </code><code class="nf">setReport</code><code class="p">(</code><code class="n">Employee</code><code class="w"> </code><code class="n">staff</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">report</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">staff</code><code class="p">;</code><code class="w"/>
<code class="w">  </code><code class="p">}</code><code class="w"/>

<code class="w">  </code><code class="kd">public</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">work</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">report</code><code class="p">.</code><code class="na">work</code><code class="p">();</code><code class="w"/>
<code class="w">  </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>The <code>Manager</code> class is said to <em>delegate</em> the <code>work()</code> operation to
their direct report, and no actual work is performed by the <code>Manager</code>
object. Variations of this pattern involve some work being done in the
delegating class, with only some calls being forwarded to the delegate
object.</p>
<p><a data-primary="decorator pattern" data-type="indexterm" id="idm45927731578000"/>Another useful, related technique is called the <em>decorator
pattern</em>. This provides the capability to extend objects with new
functionality, including at runtime. The slight overhead is some extra
work needed at design time. Let’s look at an example of the decorator
pattern as applied to modeling burritos for sale at a taqueria. To keep
things simple, we’ve modeled only a single aspect to be decorated—the
price of the burrito:</p>
<pre data-code-language="java" data-type="programlisting"><code class="c1">// The basic interface for our burritos</code><code class="w"/>
<code class="kd">interface</code> <code class="nc">Burrito</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="kt">double</code><code class="w"> </code><code class="nf">getPrice</code><code class="p">();</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="c1">// Concrete implementation-standard size burrito</code><code class="w"/>
<code class="kd">public</code><code class="w"> </code><code class="kd">class</code> <code class="nc">StandardBurrito</code><code class="w"> </code><code class="kd">implements</code><code class="w"> </code><code class="n">Burrito</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="kd">private</code><code class="w"> </code><code class="kd">static</code><code class="w"> </code><code class="kd">final</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="n">BASE_PRICE</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mf">5.99</code><code class="p">;</code><code class="w"/>

<code class="w">  </code><code class="kd">public</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="nf">getPrice</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="n">BASE_PRICE</code><code class="p">;</code><code class="w"/>
<code class="w">  </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="c1">// Larger, super-size burrito</code><code class="w"/>
<code class="kd">public</code><code class="w"> </code><code class="kd">class</code> <code class="nc">SuperBurrito</code><code class="w"> </code><code class="kd">implements</code><code class="w"> </code><code class="n">Burrito</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="kd">private</code><code class="w"> </code><code class="kd">static</code><code class="w"> </code><code class="kd">final</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="n">BASE_PRICE</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mf">6.99</code><code class="p">;</code><code class="w"/>

<code class="w">  </code><code class="kd">public</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="nf">getPrice</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="n">BASE_PRICE</code><code class="p">;</code><code class="w"/>
<code class="w">  </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>These cover the basic burritos that can be offered—two different sizes,
at different prices. Let’s enhance this by adding some optional
extras—jalapeño chilies and guacamole. The key design point here is to
use an abstract base class that all of the optional decorating
components will subclass:</p>
<pre data-code-language="java" data-type="programlisting"><code class="cm">/*</code>
<code class="cm"> * This class is the Decorator for Burrito. It represents optional</code>
<code class="cm"> * extras that the burrito may or may not have.</code>
<code class="cm"> */</code><code class="w"/>
<code class="kd">public</code><code class="w"> </code><code class="kd">abstract</code><code class="w"> </code><code class="kd">class</code> <code class="nc">BurritoOptionalExtra</code><code class="w"> </code><code class="kd">implements</code><code class="w"> </code><code class="n">Burrito</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">private</code><code class="w"> </code><code class="kd">final</code><code class="w"> </code><code class="n">Burrito</code><code class="w"> </code><code class="n">burrito</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="kd">private</code><code class="w"> </code><code class="kd">final</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="n">price</code><code class="p">;</code><code class="w"/>

<code class="w">    </code><code class="kd">protected</code><code class="w"> </code><code class="nf">BurritoOptionalExtra</code><code class="p">(</code><code class="n">Burrito</code><code class="w"> </code><code class="n">toDecorate</code><code class="p">,</code><code class="w"/>
<code class="w">          </code><code class="kt">double</code><code class="w"> </code><code class="n">myPrice</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="n">burrito</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">toDecorate</code><code class="p">;</code><code class="w"/>
<code class="w">        </code><code class="n">price</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">myPrice</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>

<code class="w">    </code><code class="kd">public</code><code class="w"> </code><code class="kd">final</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="nf">getPrice</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="p">(</code><code class="n">burrito</code><code class="p">.</code><code class="na">getPrice</code><code class="p">()</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">price</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>Combining an <code>abstract</code> base, <code>BurritoOptionalExtra</code>, with a <code>protected</code> constructor means that the only valid way to get a <code>BurritoOptionalExtra</code> is to construct an instance of one of the subclasses, as they have public constructors.
This approach also hides the setup of the price of the component from client code.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Decorators can, of course, also be combined with sealed types to allow only a known, finite list of possible decorators.</p>
</div>
<p>Let’s test the implementation:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">Burrito</code><code class="w"> </code><code class="n">lunch</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">Jalapeno</code><code class="p">(</code><code class="k">new</code><code class="w"> </code><code class="n">Guacamole</code><code class="p">(</code><code class="k">new</code><code class="w"> </code><code class="n">SuperBurrito</code><code class="p">()));</code><code class="w"/>
<code class="c1">// The overall cost of the burrito is the expected $8.09.</code><code class="w"/>
<code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="s">"Lunch cost: "</code><code class="o">+</code><code class="w"> </code><code class="n">lunch</code><code class="p">.</code><code class="na">getPrice</code><code class="p">());</code><code class="w"/></pre>
<p>The decorator pattern is very widely used, not least in the JDK utility
classes. When we discuss Java I/O in <a data-type="xref" href="ch10.xhtml#javanut8-CHP-10">Chapter 10</a>,
we will see more examples of decorators in the wild.<a data-startref="ix_ch05-asciidoc33" data-type="indexterm" id="idm45927731184672"/><a data-startref="ix_ch05-asciidoc32" data-type="indexterm" id="idm45927731184064"/><a data-startref="ix_ch05-asciidoc31" data-type="indexterm" id="idm45927731183392"/></p>
</div></section>
<section data-pdf-bookmark="Exceptions and Exception Handling" data-type="sect1"><div class="sect1" id="idm45927731758112">
<h1>Exceptions and Exception Handling</h1>
<p><a data-primary="exception handling" data-type="indexterm" id="ix_ch05-asciidoc34"/><a data-primary="exceptions" data-secondary="object-oriented design and" data-type="indexterm" id="ix_ch05-asciidoc35"/><a data-primary="object-oriented design (OOD)" data-secondary="exception handling" data-type="indexterm" id="ix_ch05-asciidoc36"/>We met checked and unchecked exceptions in
<a data-type="xref" href="ch02.xhtml#javanut8-CHP-2-SECT-6.3">“Checked and Unchecked Exceptions”</a>. In this section, we
discuss some additional aspects of the design of exceptions and how to
use them in your own code.</p>
<p><a data-primary="java.lang.Throwable" data-type="indexterm" id="idm45927731216192"/><a data-primary="Throwable class" data-type="indexterm" id="idm45927731215264"/>Recall that an exception in Java is an object. The type of this object
is <code>java.lang.Throwable</code>, or more commonly, some subclass of
<code>Throwable</code> that more specifically describes the type of exception that
occurred. <a data-primary="java.lang.Error" data-type="indexterm" id="idm45927731213664"/><a data-primary="java.lang.Exception" data-type="indexterm" id="idm45927731212960"/><code>Throwable</code> has two standard subclasses: <code>java.lang.Error</code> and
<code>java.lang.Exception</code>. Exceptions that are subclasses of <code>Error</code>
generally indicate unrecoverable problems: the virtual machine has run
out of memory, or a class file is corrupted and cannot be read, for
example. Exceptions of this sort can be caught and handled, but it is
rare to do so—these are the unchecked exceptions previously mentioned.</p>
<p>Exceptions that are subclasses of <code>Exception</code>, on the other hand,
indicate less severe conditions. These exceptions can be reasonably
caught and handled. They include such exceptions as
<code>java.io.EOFException</code>, which signals the end of a file, and
<code>java.lang.ArrayIndexOutOfBoundsException</code>, which indicates that a
program has tried to read past the end of an array. These are the
checked exceptions from <a data-type="xref" href="ch02.xhtml#javanut8-CHP-2">Chapter 2</a> (except for
subclasses of <code>RuntimeException</code>, which are also a form of unchecked
exception). In this book, we use the term “exception” to refer to any
exception object, regardless of whether the type of that exception is
<code>Exception</code> or <code>Error</code>.</p>
<p>Because an exception is an object, it can contain data, and its class
can define methods that operate on that data. The <code>Throwable</code> class and
all its subclasses include a <code>String</code> field that stores a human-readable
error message that describes the exceptional condition. It’s set when
the exception object is created and can be read from the exception with
the <code>getMessage()</code> method. Most exceptions contain only this single
message, but a few add other data. The <code>java.io.InterruptedIOException</code>,
for example, adds a field named <code>bytesTransferred</code> that specifies how
much input or output was completed before the exceptional condition
interrupted it.</p>
<p>When designing your own exceptions, you should consider what other
additional modeling information is relevant to the exception object.
This is usually situation-specific information about the aborted
operation, and the exceptional circumstance that was encountered (as we
saw with <code>java.io.InterruptedIOException</code>).</p>
<p>There are some trade-offs in the use of exceptions in application
design. Using checked exceptions means that the compiler can enforce the
handling (or propagation up the call stack) of known conditions that
have the potential of recovery or retry. It also means that it’s more
difficult to forget to actually handle errors—thus reducing the risk
that a forgotten error condition causes a system to fail in <span class="keep-together">production</span>.</p>
<p>On the other hand, some applications will not be able to recover from
certain conditions, even conditions that are theoretically modeled by
checked exceptions. For example, if an application requires a config
file to be placed at a specific place in the filesystem and can’t
locate it at startup, it may have no option but to print an
error message and exit—despite the fact that
<code>java.io.FileNotFoundException</code> is a checked exception.
Forcing exceptions that cannot be recovered from to be either handled or propagated is, in these circumstances, bordering on perverse; in this situation, printing the error and exiting is the only really sensible action.</p>
<p>When designing exception schemes, here are some good practices you should follow:</p>
<ul>
<li>
<p>Consider what additional state needs to be placed on the exception—remember that it’s also an object like any other.</p>
</li>
<li>
<p><code>Exception</code> has four public constructors—under normal circumstances,
custom exception classes should implement all of them—to initialize the
additional state or to customize messages.</p>
</li>
<li>
<p>Don’t create many fine-grained custom exception classes in your
APIs—the Java I/O and reflection APIs both suffer from this, and it
needlessly complicates working with those packages.</p>
</li>
<li>
<p>Don’t overburden a single exception type with describing too many
conditions.</p>
</li>
<li>
<p>Never create an exception until you’re sure you need to throw it. Exception creation can be a costly operation.</p>
</li>
</ul>
<p>Finally, two exception-handling antipatterns you should avoid:</p>
<pre data-code-language="java" data-type="programlisting"><code class="c1">// Never just swallow an exception</code><code class="w"/>
<code class="k">try</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="n">someMethodThatMightThrow</code><code class="p">();</code><code class="w"/>
<code class="p">}</code><code class="w"> </code><code class="k">catch</code><code class="p">(</code><code class="n">Exception</code><code class="w"> </code><code class="n">e</code><code class="p">){</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="c1">// Never catch, log, and rethrow an exception</code><code class="w"/>
<code class="k">try</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="n">someMethodThatMightThrow</code><code class="p">();</code><code class="w"/>
<code class="p">}</code><code class="w"> </code><code class="k">catch</code><code class="p">(</code><code class="n">SpecificException</code><code class="w"> </code><code class="n">e</code><code class="p">){</code><code class="w"/>
<code class="w">  </code><code class="n">log</code><code class="p">(</code><code class="n">e</code><code class="p">);</code><code class="w"/>
<code class="w">  </code><code class="k">throw</code><code class="w"> </code><code class="n">e</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>The former just ignores a condition that almost certainly
required some action (even if just a notification in a log). This
increases the likelihood of failure elsewhere in the system—potentially
far from the original, real source.</p>
<p>The second just creates noise. We’re logging a message but not
actually doing anything about the issue; we still require some other code
higher up in the system to actually deal with the problem.<a data-startref="ix_ch05-asciidoc36" data-type="indexterm" id="idm45927731077712"/><a data-startref="ix_ch05-asciidoc35" data-type="indexterm" id="idm45927731077104"/><a data-startref="ix_ch05-asciidoc34" data-type="indexterm" id="idm45927731076464"/></p>
</div></section>
<section data-pdf-bookmark="Safe Java Programming" data-type="sect1"><div class="sect1" id="javanut8-CHP-5-SECT-safe-programming">
<h1>Safe Java Programming</h1>
<p><a data-primary="object-oriented design (OOD)" data-secondary="safe programming" data-type="indexterm" id="ix_ch05-asciidoc37"/><a data-primary="safety" data-secondary="object-oriented design and" data-type="indexterm" id="ix_ch05-asciidoc38"/>Programming languages are sometimes described as being <em>type
safe</em>; however, this term is used rather loosely by working
programmers. There are a number of different viewpoints on and definitions
for type safety, not all of which are mutually compatible.
<a data-primary="type safety" data-type="indexterm" id="idm45927731071072"/>The most useful view for our purposes is that <em>type safety</em> is the
property of a programming language that prevents the type of data being
incorrectly identified at runtime. This should be thought of as a
sliding scale—it is more helpful to think of languages as being more (or
less) type safe than each other, rather than a simple binary property of
safe/unsafe.</p>
<p>In Java, the static nature of the type system helps prevent a large
class of possible errors by producing compilation errors if, for
example, the programmer attempts to assign an incompatible value to a
variable. However, Java is not perfectly type safe, as we can perform a
cast between any two reference types—this will fail at runtime with a
<code>ClassCastException</code> if the value is not compatible.</p>
<p>In this book, we prefer to think of safety as inseparable from the
broader topic of correctness. This means that we should think in terms
of programs, rather than languages. This emphasizes the point that safe
code is not guaranteed by any widely used language, and instead
considerable programmer effort (and adherence to rigorous coding
discipline) must be employed if the end result is to be truly safe and
correct.</p>
<p>We approach our view of safe programs by working with the state model
abstraction as shown in <a data-type="xref" href="#javanut8-CHP-5-FIG-1">Figure 5-1</a>. A <em>safe</em>
program is one in which:</p>
<ul>
<li>
<p>All objects start off in a legal state after creation</p>
</li>
<li>
<p>Externally accessible methods transition objects between legal states</p>
</li>
</ul>
<ul class="pagebreak-before">
<li>
<p>Externally accessible methods must not return with objects in an
inconsistent state</p>
</li>
<li>
<p>Externally accessible methods must reset objects to a legal state
before <span class="keep-together">throwing</span></p>
</li>
</ul>
<p>In this context, “externally accessible” means <code>public</code>,
package-private, or <span class="keep-together"><code>protected</code></span>. This defines a reasonable model for
safety of programs, and as it is bound up with defining our abstract
types in such a way that their methods ensure consistency of state, it’s
reasonable to refer to a program satisfying these requirements as a
“safe program,” regardless of the language in which such a program is
implemented.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>Private methods do not have to start or end with objects in a legal
state, as they cannot be called by an external piece of code.</p>
</div>
<p>As you might imagine, actually engineering a substantial piece of code
so that we can be sure that the state model and methods respect these
properties can be quite an undertaking. In languages such as Java, in
which programmers have direct control over the creation of preemptively
multitasked execution threads, this problem is a great deal more complex.</p>
<figure><div class="figure" id="javanut8-CHP-5-FIG-1">
<img alt="JN7 0501" height="333" src="assets/jns8_0501.png" width="600"/>
<h6><span class="label">Figure 5-1. </span>Program state transitions</h6>
</div></figure>
<p>Moving on from our introduction of object-oriented design, one
final aspect of the Java language and platform needs to be
understood for a sound grounding. That is the nature of memory and
concurrency—one of the most complex of the platform, but also one that
rewards careful study with large dividends. It is the subject of our
next chapter and concludes <a data-type="xref" href="part01.xhtml#javanut-PART-1">Part I</a><a data-startref="ix_ch05-asciidoc38" data-type="indexterm" id="idm45927731053296"/><a data-startref="ix_ch05-asciidoc37" data-type="indexterm" id="idm45927731052624"/>.<a data-startref="ix_ch05-asciidoc0" data-type="indexterm" id="idm45927731051824"/></p>
</div></section>
<div data-type="footnotes"><p data-type="footnote" id="idm45927734963040"><sup><a href="ch05.xhtml#idm45927734963040-marker">1</a></sup> Technically, this should probably be called <code>SCREAMING_SNAKE_CASE</code></p></div></div></section></div></body></html>