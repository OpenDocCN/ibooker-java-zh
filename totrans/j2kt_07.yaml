- en: Chapter 7\. Actions to Calculations
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 7 章。从动作到计算
- en: Neither Java nor Kotlin makes any formal distinction between imperative and
    functional code, although Kotlin’s emphasis on immutability and expressions generally
    leads to more functional programs. Can we improve our code by making more of it
    functional?
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Java 和 Kotlin 都没有明确区分命令式代码和函数式代码，尽管 Kotlin 强调不可变性和表达式通常导致更多的函数式程序。通过增加函数式编程的比例，我们能改善我们的代码吗？
- en: Functions
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数
- en: As an industry, we have invented a lot of phrases to describe callable subprograms
    within a larger program. We have the very generic *subroutine*. Some languages
    (notably Pascal) distinguish between *functions* that return a result, and *procedures*,
    which don’t; but most developers use the terms interchangeably. Then there are
    *methods*, which are subroutines associated with an object (or a class, in the
    case of static methods).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个行业，我们发明了很多短语来描述大型程序中的可调用子程序。我们有非常通用的 *子程序*。一些语言（尤其是 Pascal）区分 *返回结果的函数*
    和 *不返回结果的过程*；但大多数开发人员将这些术语互换使用。然后有 *方法*，这是与对象相关联的子程序（或者在静态方法的情况下是与类相关联的）。
- en: The C language calls them all functions but has a special `void` type to represent
    the absence of a return value. This was carried forward into Java. Kotlin uses
    `Unit` in almost the same way, except that `Unit` is not the absence of a return
    value, but rather a singleton value that is returned instead.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: C 语言将它们都称为函数，但有一个特殊的 `void` 类型表示没有返回值。这一点在 Java 中也保留了下来。Kotlin 几乎以相同的方式使用 `Unit`，不过
    `Unit` 并不表示没有返回值，而是返回的是一个单例值。
- en: In this book we use the term *function* to refer to both result-returning and
    non-result-returning subroutines, whether freestanding or associated with an object.
    Where it’s significant that they are associated with an object, we’ll call them
    as methods.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们使用术语 *函数* 来指代既返回结果又不返回结果的子程序，无论是独立存在还是与对象相关联。在需要强调与对象关联的情况下，我们将其称为方法。
- en: Whatever we call them, functions are one of the fundamental building blocks
    of our software. We define them with some sort of notation, generally the programming
    language we are using. They are also generally fixed during a run of the program;
    in static languages, at least, we don’t usually redefine functions on the fly.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们称其为什么，函数都是我们软件的基本构建块之一。我们通过某种标记（通常是我们正在使用的编程语言）来定义它们。它们在程序运行期间通常是固定的；至少在静态语言中，我们通常不会在运行时重新定义函数。
- en: 'This is in contrast to the other fundamental building block: data. We expect
    data to vary as we run our program, and different data is bound to variables.
    Variables are called variables because they are, wait for it, variable. Even when
    they are `final`, or `val`, they are usually bound to different data in different
    invocations of a function.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这与另一个基本构建块不同：数据。我们期望数据随着程序运行而变化，不同的数据绑定到变量上。变量被称为变量，因为它们是，等待它，可变的。即使它们是 `final`
    或 `val`，它们在函数的不同调用中通常绑定到不同的数据上。
- en: 'We hinted earlier at a subdivision of functions into those that return a result
    and those that do not. This might seem like a fundamental difference, but in practice
    there is a more useful way to divide functions: into *calculations* and *actions*.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前暗示过将函数划分为返回结果和不返回结果的类型。这似乎是一个基本差异，但实际上有一种更有用的方法来划分函数：*计算* 和 *动作*。
- en: Actions are functions that depend on when or how many times they are run; calculations
    are functions that don’t—they are timeless. Most functions that we write are actions,
    because we have to take special care to write code that doesn’t depend on when
    it is run. How would we go about doing that?
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 动作是依赖于何时或多少次运行的函数；而计算是不依赖于运行时间的函数，它们是永恒的。我们编写的大多数函数都是动作，因为我们必须特别小心编写不依赖于运行时间的代码。我们该如何做到这一点？
- en: Calculations
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算
- en: To be a calculation, a function must always return the same result given the
    same inputs. The inputs to a function are its parameters, which are bound to arguments
    when the function is called. So a calculation always returns the same result when
    called with the same arguments.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要成为计算，函数在给定相同输入时必须始终返回相同结果。函数的输入是其参数，在调用函数时与参数绑定。因此，使用相同参数调用计算函数时，总是返回相同结果。
- en: 'Take a `fullName` function:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 以 `fullName` 函数为例：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`fullName` is a calculation: it will always return the same value when supplied
    the same `Customer`. This is true only if `Customer` is immutable, or at least
    `givenName` and `familyName` cannot change. To keep things simple, we’ll say that
    calculations can only have parameters that are values, as defined in [Chapter 5](ch05.html#beans-to-values).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`fullName`是一个计算：当提供相同的`Customer`时，它将始终返回相同的值。这仅在`Customer`是不可变的情况下成立，或者至少`givenName`和`familyName`不能改变。为了保持简单，我们将说计算只能有作为值定义的参数，如[第五章](ch05.html#beans-to-values)所定义。'
- en: 'Methods, and the disguised methods that are member properties, can also be
    calculations:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 方法和伪装成成员属性的方法也可以是计算：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: For a method or extension, the receiver `this`, and any property accessed via
    `this`, is also an input. So both `upperCaseGivenName` and `fullName` are calculations
    because `givenName` and `familyName` are both values.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对于方法或扩展，接收器`this`和通过`this`访问的任何属性也是输入。因此，`upperCaseGivenName`和`fullName`都是计算，因为`givenName`和`familyName`都是值。
- en: 'An extension function or property can also be a calculation if the data it
    depends on is a value:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它所依赖的数据是值，扩展函数或属性也可以是计算：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The result of a calculation may depend on data that is not passed as parameters,
    but only if that data does not change. Otherwise, the function’s result would
    be different before and after the change, which would make it an action. Even
    if a function always returns the same result for the same parameters, it may still
    be an action if it mutates something (either a parameter or an external resource
    such as a global variable or a database). For example:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 计算结果可能依赖于未作为参数传递的数据，但仅当该数据不改变时。否则，函数在更改前后的结果会不同，这使它成为一个行动。即使函数对于相同的参数总是返回相同的结果，如果它改变了某些东西（参数或外部资源，如全局变量或数据库），它仍然可能是一个行动。例如：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`println` always returns the same `Unit` result given the same `hello` input,
    but it is not a calculation. It is an action.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`println`给定相同的`hello`输入始终返回相同的`Unit`结果，但它不是计算。它是一个行动。'
- en: Actions
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动
- en: '`println` is an action because it *does* depend on when and how many times
    it is run. If we don’t call it, nothing is output, which is different from calling
    it once, which is different from calling it twice. The order that we call `println`
    with different arguments also matters to the results we see on the console.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`println`是一个行动，因为它*确实*依赖于它何时以及多少次被运行。如果我们不调用它，就不会输出任何内容，这与调用一次是不同的，这与调用两次也是不同的。调用`println`以不同参数的顺序对我们在控制台上看到的结果也是有影响的。'
- en: We call `println` for its *side effect*—the effect it has on its environment.
    Side effect is a bit of a misleading term because, unlike drug side effects, they
    are often exactly the thing that we want to happen. Maybe *outside effect* would
    be a better name, to emphasize that they are external to a function’s parameters,
    local variables, and return value. In any case, functions with observable side
    effects are actions not calculations. Functions returning `void` or `Unit` are
    almost always actions, because if they do anything, they have to do it by side
    effect.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用`println`是为了它的*副作用*——它对环境的影响。副作用是一个有点误导的术语，因为与药物副作用不同，它们通常确实是我们想要发生的事情。也许“外部效应”会是一个更好的名称，以强调它们是函数参数、局部变量和返回值外部的影响。无论如何，具有可观察副作用的函数都是行动而不是计算。返回`void`或`Unit`的函数几乎总是行动，因为如果它们做任何事情，它们必须通过副作用来做。
- en: As we saw previously, code that reads from external mutable state must also
    be an action (provided that anything does actually mutate the state).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所见，从外部可变状态读取的代码也必须是一个行动（只要确实有任何东西实际上改变了状态）。
- en: 'Let’s look at a `Customers` service:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下`Customers`服务：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Both `save` and `find` are actions; `save` creates a new customer record in
    our database and returns it. This is an action because the state of our database
    depends on when we call it. The result of `find` is also time sensitive, because
    it depends on previous calls to `save`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`save`和`find`都是行动；`save`在我们的数据库中创建一个新的客户记录并返回它。这是一个行动，因为我们调用它时数据库的状态会发生变化。`find`的结果也是时间敏感的，因为它依赖于对`save`的先前调用。'
- en: 'Functions that have no parameters (this doesn’t include methods or extension
    functions, which can have implicit parameters accessed via `this`) must either
    be returning a constant or be reading from some other source and so be categorized
    as actions. Without looking at its source, we can deduce that a top-level function
    `requestRate` is almost certainly an action, reading from some global mutable
    state:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 没有参数的函数（这不包括方法或扩展函数，它们可以通过 `this` 访问隐式参数）必须要么返回一个常量，要么从其他源读取数据，因此被归类为动作。在没有查看其源代码的情况下，我们可以推断顶层函数
    `requestRate` 几乎肯定是一个动作，从某个全局可变状态读取数据：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If a function with the same apparent signature is defined as a method, it is
    probably a calculation that depends on properties of `Metrics` (provided `Metrics`
    is immutable):'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个具有相同表面签名的函数被定义为一个方法，那么它可能是依赖于`Metrics`属性的计算（假设`Metrics`是不可变的）：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We say *probably* because in languages like Java or Kotlin that allow input,
    output, or accessing global mutable data from any code, there is no way to be
    sure whether a function represents a calculation or action short of examining
    it and all the functions that it calls. We’ll return to that problem soon.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们说 *可能* 是因为在像 Java 或 Kotlin 这样允许从任何代码中进行输入、输出或访问全局可变数据的语言中，除了检查它及其调用的所有函数之外，没有其他方法确保一个函数代表一个计算或动作。我们很快会回到这个问题。
- en: Why Should We Care?
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么我们应该关心呢？
- en: We should obviously pay special attention to some actions in our software. Sending
    the same email to every user twice is a bug, as is not sending it at all. We care
    exactly how many times it is sent. We may even care that it is sent at exactly
    8:07 a.m., so that our offer for a free first-class upgrade is at the top of our
    customer’s inbox when they read their email over breakfast.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们显然应特别关注软件中的某些操作。将相同的电子邮件发送两次给每个用户是一个 bug，就像完全不发送一样。我们确切地关心它被发送的次数。我们甚至可能关心它是否在早餐时段准确地在上午8:07发送，这样我们为免费头等舱升级的优惠就能出现在顾客的收件箱顶部。
- en: Other seemingly innocuous actions may be more nocuous than we think. Changing
    the order of read and write actions causes concurrency bugs. Error handling is
    much more complicated if the second of two sequential actions fails after the
    first succeeded. Actions prevent us from having free rein to refactor our code,
    because doing so may change when or whether they are invoked.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 其他看似无害的行为可能比我们想象的更有害。更改读取和写入操作的顺序会导致并发 bug。如果两个顺序操作中的第二个失败，而第一个已成功，错误处理会变得更加复杂。这些操作阻止我们随意重构代码，因为这样做可能会改变它们何时或是否被调用。
- en: 'Calculations, on the other hand, can be invoked at any time, with no consequences
    for calling them again and again with the same arguments except a waste of time
    and energy. If we are refactoring code and find that we don’t need the result
    of a calculation, we can safely not invoke it. If it is an expensive calculation,
    we can safely cache its result; if it is inexpensive, we can safely recalculate
    it on demand if that simplifies things. It is this feeling of safety that puts
    the smug smile on the faces of functional programmers (well, that and knowing
    that a monad is just a monoid in the category of endofunctors). Those functional
    programmers also have a term for the property of a function that makes it a calculation:
    *referential transparency*. If a function is referentially transparent, we can
    replace its call with its result, and we can only do that if it doesn’t matter
    when or if we call it.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，计算可以随时调用，多次调用它们不会有什么后果，除了浪费时间和精力。如果我们正在重构代码并发现我们不需要计算的结果，我们可以安全地不调用它。如果这是一个昂贵的计算，我们可以安全地缓存其结果；如果它很廉价，我们可以根据需要安全地再次计算它，以简化事务。正是这种安全感让函数式编程人员在脸上挂上了得意的笑容（这也包括知道一个单子仅仅是一种自函子范畴中的单子）。那些函数式编程人员还为使函数成为计算的属性创造了一个术语：*引用透明性*。如果一个函数具有引用透明性，我们可以用其结果替换其调用，而只有在不管何时或是否调用它都没有影响时才能这样做。
- en: Why Prefer Calculations?
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么更喜欢计算呢？
- en: We like calculations because they are so much easier to work with, but ultimately
    our software needs to have an effect on the world, which is an action. There is
    no overlap though; code can’t be an action and a calculation, both timeless and
    time-dependent. If we take some code that is a calculation and have it invoke
    an action, then it becomes an action, because it will now depend on when or whether
    it is called. We can think of calculations as the purer code, where code inherits
    the most tainted level of all of its dependencies. We see the same thing with
    susceptibility to errors in [Chapter 19](ch19.html#throwing-to-returning). If
    we value purity (which in all these cases brings ease of reasoning and refactoring),
    we must strive to pull the boundary between impure and pure code to the outer
    layers of our system—those closest to the entry points. If we succeed, then a
    significant proportion of our code can be calculations and, hence, easily tested,
    reasoned with, and refactored.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们喜欢计算，因为它们更容易处理，但最终我们的软件需要对世界产生影响，这就是一个操作。然而没有重叠；代码不能同时是操作和计算，既是无时间概念又是有时间概念的。如果我们拿一些计算代码并让它调用一个操作，那么它就会变成一个操作，因为它现在将取决于何时或是否被调用。我们可以将计算视为更纯净的代码，其中代码继承了其所有依赖关系中最受污染的层次。在[第19章](ch19.html#throwing-to-returning)中，我们看到了在错误易感性方面的相同情况。如果我们重视纯度（在所有这些情况下都带来了推理和重构的便利性），我们必须努力将不纯净代码与纯净代码之间的边界拉到系统的外层—靠近入口点的那些部分。如果我们成功了，那么我们的代码中的一个重要部分可以是计算，因此可以轻松测试、推理和重构。
- en: What if we don’t succeed in keeping actions at the bottom of our call stack?
    Then we can fix things with refactoring!
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们无法保持操作在调用堆栈的底部，那么我们可以通过重构来解决问题！
- en: Refactoring Actions to Calculations
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将操作重构为计算
- en: Let’s have a look at recognizing and refactoring actions in existing code.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看如何识别和重构现有代码中的操作。
- en: Existing Code
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 现有代码
- en: 'There is an HTTP endpoint in Travelator that allows the client app to fetch
    information about the customer’s current trip:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Travelator 中有一个 HTTP 端点，允许客户端应用获取关于客户当前行程的信息：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[Example 7.1 [actions.0:src/main/java/travelator/handlers/CurrentTripsHandler.java]](https://java-to-kotlin.dev/code.html?ref=7.1&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=7.1&show=diff)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 7.1 [actions.0:src/main/java/travelator/handlers/CurrentTripsHandler.java]](https://java-to-kotlin.dev/code.html?ref=7.1&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=7.1&show=diff)'
- en: 'Actions are code that is sensitive to time, so words like *current* in `CurrentTripsHandler`
    are a dead giveaway. The `handle` method is an action, and that’s OK: things on
    the edge of our systems often are.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 操作是对时间敏感的代码，因此像`CurrentTripsHandler`中的*current*这样的词就是一个明显的线索。`handle`方法是一个操作，这没问题：我们系统的边缘经常会有这种情况。
- en: 'The handler delegates to some business logic, implemented in `Tracking`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 处理程序委托给一些业务逻辑，由`Tracking`实现：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[Example 7.2 [actions.0:src/main/java/travelator/Tracking.java]](https://java-to-kotlin.dev/code.html?ref=7.2&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=7.2&show=diff)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 7.2 [actions.0:src/main/java/travelator/Tracking.java]](https://java-to-kotlin.dev/code.html?ref=7.2&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=7.2&show=diff)'
- en: 'Using the *current* rule, `Tracking.currentTripFor` is evidently an action
    too, as is `Trips.currentTripsFor`. Here is its implementation in `InMemoryTrips`,
    which is used for testing in place of a version implemented with database queries:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*current*规则，`Tracking.currentTripFor`显然也是一个操作，`Trips.currentTripsFor`也是。这是它在`InMemoryTrips`中的实现，用于测试而不是使用数据库查询实现的版本：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[Example 7.3 [actions.0:src/test/java/travelator/InMemoryTrips.java]](https://java-to-kotlin.dev/code.html?ref=7.3&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=7.3&show=diff)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 7.3 [actions.0:src/test/java/travelator/InMemoryTrips.java]](https://java-to-kotlin.dev/code.html?ref=7.3&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=7.3&show=diff)'
- en: The conversions from `Set<Trip>` (the result of `Trips.currentTripsFor`) and
    to `Optional<Trip>` (returned from `Tracking.currentTripFor`) seem to be because
    there is some business rule around there being only one active trip at any time—a
    rule that is not enforced in the persistence layer.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 从`Set<Trip>`（`Trips.currentTripsFor`的结果）到`Optional<Trip>`（`Tracking.currentTripFor`返回的结果）的转换似乎是因为有一个业务规则，即任何时候只能有一次活动行程—这个规则在持久层中没有被强制执行。
- en: Until we got here, we were relying on our knowledge of the meanings of words
    (in particular *current*) to deduce that Java methods represent actions rather
    than calculations. Here, though, there is a smoking gun. Can you spot it?
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 直到我们到达这里，我们一直依赖于我们对单词含义（特别是*current*）的知识，来推断 Java 方法表示的是操作而不是计算。然而，这里确实有一个罪证。你能发现它吗？
- en: 'Yes: `clock.instant()`. That definitely depends on when we call it. (If you
    found another action, well done, but keep it to yourself for now. We’ll come back
    to it.)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 是的：`clock.instant()`。这确实取决于我们何时调用它。（如果你找到了另一个动作，干得漂亮，但现在还是先留着。我们以后会回来处理。）
- en: 'Even if we chose not go on with the rest of this refactoring, there is one
    change that we should make now. We have discussed calculations and actions as
    applying to named blocks of code, but they also apply at the expression level.
    Once you start to differentiate actions from calculations, it makes sense not
    to throw a random action into an otherwise pure calculation. Let’s pull the action
    out so that the remainder of the expression is pure: select `clock.instant()`
    and “Introduce Variable”, calling it `now`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们选择不继续进行此重构的其他部分，现在我们应该做出一项改变。我们已经讨论过计算和动作适用于命名的代码块，但它们也适用于表达式级别。一旦开始区分动作和计算，将随机动作插入纯计算是不合理的。让我们将动作分离出来，以便表达式的其余部分是纯的：选择
    `clock.instant()` 并“引入变量”，将其命名为 `now`：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[Example 7.4 [actions.1:src/test/java/travelator/InMemoryTrips.java]](https://java-to-kotlin.dev/code.html?ref=7.4&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=7.4&show=diff)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 7.4 [actions.1:src/test/java/travelator/InMemoryTrips.java]](https://java-to-kotlin.dev/code.html?ref=7.4&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=7.4&show=diff)'
- en: 'That’s still in the middle of the expression, so let’s move it up (and convert
    to a `var` on the way):'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这仍然处于表达式中间位置，让我们将其移到上面（并在移动过程中转换为 `var`）：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[Example 7.5 [actions.2:src/test/java/travelator/InMemoryTrips.java]](https://java-to-kotlin.dev/code.html?ref=7.5&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=7.5&show=diff)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 7.5 [actions.2:src/test/java/travelator/InMemoryTrips.java]](https://java-to-kotlin.dev/code.html?ref=7.5&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=7.5&show=diff)'
- en: This simple act has allowed us to realize that we were previously comparing
    every trip against a slightly different time! Was that a problem? Probably not
    here, but you may have worked on systems where it would be. Duncan, for one, has
    recently finished diagnosing an issue where half of a banking transaction could
    be accounted for in one day, and the other half in the next.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的举动让我们意识到，之前我们每次都是与稍有不同的时间比较每一次旅行！这是个问题吗？可能在这里不是，但你可能会在其他系统中工作过，那里可能会是个问题。例如，Duncan
    最近完成了一个问题的诊断，其中一半银行交易在一天内完成，而另一半在第二天完成。
- en: 'As well as making it harder to refactor our code, actions make it harder to
    test too. Let’s see how that is manifested:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使我们的代码更难重构外，动作还使测试更加困难。让我们看看这是如何表现出来的：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[Example 7.6 [actions.0:src/test/java/travelator/TrackingTests.java]](https://java-to-kotlin.dev/code.html?ref=7.6&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=7.6&show=diff)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 7.6 [actions.0:src/test/java/travelator/TrackingTests.java]](https://java-to-kotlin.dev/code.html?ref=7.6&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=7.6&show=diff)'
- en: To give predictable results, we have had to use a fake clock, injected into
    `InMemoryTrips`. Having previously said that `clock.instant()` depends on when
    we call it; in our tests it doesn’t (at least, not in the same way). We could
    instead have set up trips relative to the time that the tests are being run, but
    this would make our tests harder to understand, and subject to failure if you
    run them around midnight.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保证可预测的结果，我们不得不在 `InMemoryTrips` 中使用一个假时钟。之前说过 `clock.instant()` 的调用取决于我们何时调用它；但在我们的测试中，它并不是这样（至少不完全是）。我们本可以根据测试运行时的时间设置行程，但这样会使我们的测试更难理解，并且在午夜附近运行时容易失败。
- en: Is having to inject a clock [test-induced design damage](https://oreil.ly/YZx1T)?
    In this case it is. The fake clock has allowed us to solve a testing problem,
    but at the expense of making the code more complicated. It has also allowed us
    to avoid a rethink that might lead to…
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 是否需要注入时钟来解决 [测试引起的设计损害](https://oreil.ly/YZx1T)？在这种情况下是需要的。这个假时钟让我们能够解决一个测试问题，但代价是使代码变得更加复杂。它也让我们避免了重新考虑的可能性，这可能会导致……
- en: A Better Design
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更好的设计
- en: What would a better design look like here?
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，一个更好的设计会是什么样子呢？
- en: To make this code less time dependant, we can supply the time as an argument
    to the method. Although this forces the *caller* to know the time, it is as easy
    for our caller to ask the time as it is for this method. This is a special case
    of the way that we refactor to avoid dependencies on other global state; instead
    of reading a value within a function, we pass the value into it.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这段代码不那么依赖时间，我们可以将时间作为方法的参数提供。虽然这会强迫 *调用者* 知道时间，但对于调用者来说，询问时间与询问这个方法一样容易。这是我们重构以避免依赖其他全局状态的特殊案例；我们不是在函数内部读取值，而是将值传递给它。
- en: 'The function we want to pass the time into overrides `Trips.currentTripsFor`,
    so we start by adding an `Instant` parameter to that. Before, this was:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望将时间传递到 `Trips.currentTripsFor` 的函数中，因此我们首先添加了一个 `Instant` 参数。在此之前，代码如下：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[Example 7.7 [actions.0:src/main/java/travelator/Trips.java]](https://java-to-kotlin.dev/code.html?ref=7.7&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=7.7&show=diff)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 7.7 [actions.0:src/main/java/travelator/Trips.java]](https://java-to-kotlin.dev/code.html?ref=7.7&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=7.7&show=diff)'
- en: We use IntelliJ’s “Change Signature” refactoring to add the parameter, calling
    it `at`. When we add a parameter, we need to tell IntelliJ what value it should
    use when updating the callers of our function. Because we aren’t using the value
    in the method yet (and this is Java), we should be able to use `null` without
    breaking anything. Running the tests shows that we are right—they still pass.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 IntelliJ 的“更改签名”重构来添加参数，称为 `at`。当我们添加参数时，我们需要告诉 IntelliJ 在更新我们函数的调用者时应使用什么值。因为我们尚未在方法中使用该值（这是
    Java），我们应该能够在不破坏任何东西的情况下使用 `null`。运行测试显示我们是正确的，它们仍然通过。
- en: '`Trips` now looks like this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`Trips` 现在如下所示：'
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[Example 7.8 [actions.3:src/main/java/travelator/Trips.java]](https://java-to-kotlin.dev/code.html?ref=7.8&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=7.8&show=diff)'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 7.8 [actions.3:src/main/java/travelator/Trips.java]](https://java-to-kotlin.dev/code.html?ref=7.8&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=7.8&show=diff)'
- en: 'Here is the method being called:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是被调用的方法：
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[Example 7.9 [actions.3:src/main/java/travelator/Tracking.java]](https://java-to-kotlin.dev/code.html?ref=7.9&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=7.9&show=diff)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 7.9 [actions.3:src/main/java/travelator/Tracking.java]](https://java-to-kotlin.dev/code.html?ref=7.9&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=7.9&show=diff)'
- en: '[![1](assets/1.png)](#co_introduction_CO9-1)'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_introduction_CO9-1)'
- en: IntelliJ introduced `null` as the argument value
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: IntelliJ 将 `null` 作为参数值引入
- en: 'Remember that we aren’t using the value of the time in our implementations
    of `Trips` yet; we’re just trying to supply it on the outside of our system to
    convert as much code as possible to calculations. `Tracking` isn’t the outside
    of our interaction, so we select the `null` `Instant` and “Introduce Parameter”
    to add it to the signature of `Tracking.​cur⁠rentTripFor`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在我们的 `Trips` 实现中，我们尚未使用时间的值；我们只是尝试在系统外部提供它，以便尽可能多地将代码转换为计算。`Tracking` 并非我们互动的外部，因此我们选择了
    `null` 的 `Instant` 并“引入参数”将其添加到 `Tracking.currentTripFor` 的签名中：
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[Example 7.10 [actions.4:src/main/java/travelator/Tracking.java]](https://java-to-kotlin.dev/code.html?ref=7.10&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=7.10&show=diff)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 7.10 [actions.4:src/main/java/travelator/Tracking.java]](https://java-to-kotlin.dev/code.html?ref=7.10&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=7.10&show=diff)'
- en: '[![1](assets/1.png)](#co_introduction_CO10-1)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_introduction_CO10-1)'
- en: Our new `Instant` parameter
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们新的 `Instant` 参数
- en: 'When we “Introduce Parameter”, IntelliJ moves the expression (`null` in this
    case) from the body of the method to the callers, so `CurrentTripsHandler` still
    compiles:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们“引入参数”时，IntelliJ 将表达式（在本例中为 `null`）从方法体移动到调用者，因此 `CurrentTripsHandler` 仍然可以编译：
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[Example 7.11 [actions.4:src/main/java/travelator/handlers/CurrentTripsHandler.java]](https://java-to-kotlin.dev/code.html?ref=7.11&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=7.11&show=diff)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 7.11 [actions.4:src/main/java/travelator/handlers/CurrentTripsHandler.java]](https://java-to-kotlin.dev/code.html?ref=7.11&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=7.11&show=diff)'
- en: '[![1](assets/1.png)](#co_introduction_CO11-1)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_introduction_CO11-1)'
- en: '`null` argument value'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`null` 参数值'
- en: '`TrackingTests` is similarly fixed up:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`TrackingTests` 同样被修复：'
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[Example 7.12 [actions.4:src/test/java/travelator/TrackingTests.java]](https://java-to-kotlin.dev/code.html?ref=7.12&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=7.12&show=diff)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 7.12 [actions.4:src/test/java/travelator/TrackingTests.java]](https://java-to-kotlin.dev/code.html?ref=7.12&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=7.12&show=diff)'
- en: '[![1](assets/1.png)](#co_introduction_CO12-1)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_introduction_CO12-1)'
- en: '`null` argument value'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`null` 参数值'
- en: 'At this point everything compiles and passes the tests, but we aren’t actually
    using the (`null`) time that we are passing down from our handler. Let’s fix that
    in `InMemoryTrips`, where we started. We did have:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 此时一切编译通过并通过测试，但我们实际上并未使用从处理程序传递下来的 (`null`) 时间。让我们在我们开始的 `InMemoryTrips` 中解决这个问题。我们之前的代码如下：
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[Example 7.13 [actions.4:src/test/java/travelator/InMemoryTrips.java]](https://java-to-kotlin.dev/code.html?ref=7.13&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=7.13&show=diff)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 7.13 [actions.4:src/test/java/travelator/InMemoryTrips.java]](https://java-to-kotlin.dev/code.html?ref=7.13&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=7.13&show=diff)'
- en: 'Now that we have the time as a parameter, we can use that rather than asking
    the `clock`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了时间作为参数，我们可以使用它，而不是询问 `clock`：
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[Example 7.14 [actions.5:src/test/java/travelator/InMemoryTrips.java]](https://java-to-kotlin.dev/code.html?ref=7.14&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=7.14&show=diff)'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 7.14 [actions.5:src/test/java/travelator/InMemoryTrips.java]](https://java-to-kotlin.dev/code.html?ref=7.14&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=7.14&show=diff)'
- en: 'This causes the tests that use `InMemoryTrips` to fail with a `NullPointerException`,
    because the method is now using the value of the parameter, and the tests are
    passing in `null`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致使用 `InMemoryTrips` 的测试失败，并出现 `NullPointerException`，因为该方法现在使用参数的值，而测试传递 `null`：
- en: '[PRE21]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[Example 7.15 [actions.5:src/test/java/travelator/TrackingTests.java]](https://java-to-kotlin.dev/code.html?ref=7.15&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=7.15&show=diff)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 7.15 [actions.5:src/test/java/travelator/TrackingTests.java]](https://java-to-kotlin.dev/code.html?ref=7.15&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=7.15&show=diff)'
- en: '[![1](assets/1.png)](#co_introduction_CO13-1)'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_introduction_CO13-1)'
- en: These `nulls` are now being dereferenced inside `InMemoryTrips`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 `null` 现在在 `InMemoryTrips` 中被解引用。
- en: 'Instead of `null`, we need to pass the value that the tests were setting into
    the `clock`. A cunning refactor is to replace the `null`s with `clock.now`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要传递测试设置到 `clock` 中的值，而不是 `null`。一个巧妙的重构是将 `null` 替换为 `clock.now`：
- en: '[PRE22]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[Example 7.16 [actions.6:src/test/java/travelator/TrackingTests.java]](https://java-to-kotlin.dev/code.html?ref=7.16&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=7.16&show=diff)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 7.16 [actions.6:src/test/java/travelator/TrackingTests.java]](https://java-to-kotlin.dev/code.html?ref=7.16&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=7.16&show=diff)'
- en: 'This gets our tests to pass, because we are now passing the correct time as
    the argument, albeit via setting and immediately reading a field in the `StoppedClock`.
    To fix that, we replace the `clock.now` reads with the values from the `clock.now`
    writes. Then the `clock` is unused, and we can delete it:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得我们的测试通过了，因为我们现在传递了正确的时间作为参数，尽管是通过设置并立即读取 `StoppedClock` 中的字段。为了修复这个问题，我们将
    `clock.now` 读取替换为 `clock.now` 写入的值。然后 `clock` 就没用了，我们可以删除它：
- en: '[PRE23]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[Example 7.17 [actions.8:src/test/java/travelator/TrackingTests.java]](https://java-to-kotlin.dev/code.html?ref=7.17&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=7.17&show=diff)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 7.17 [actions.8:src/test/java/travelator/TrackingTests.java]](https://java-to-kotlin.dev/code.html?ref=7.17&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=7.17&show=diff)'
- en: This is a pattern we often see as we refactor toward more functional code. As
    we reduce the scope of actions, our tests become simpler, because they can express
    more of their variation in parameters rather than preparing test state. We’ll
    see this again in [Chapter 17](ch17.html#mocks-to-maps).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在向更加函数化的代码重构时经常看到的模式。随着我们减少操作的范围，我们的测试变得更简单，因为它们可以通过参数表达更多的变化，而不是准备测试状态。我们将在[第17章](ch17.html#mocks-to-maps)再次看到这一点。
- en: End Game
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 终局
- en: We’re almost done now. (Refactoring is never completely done.)
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在几乎完成了。（重构永远不完全完成。）
- en: 'With all this focus on the tests, we were about to check in before we realized
    that we haven’t completed our refactor in `CurrentTripsHandler`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有对测试的关注中，我们准备在检查之前登记，然后才意识到我们还没有完成对 `CurrentTripsHandler` 的重构：
- en: '[PRE24]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[Example 7.18 [actions.8:src/main/java/travelator/handlers/CurrentTripsHandler.java]](https://java-to-kotlin.dev/code.html?ref=7.18&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=7.18&show=diff)'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 7.18 [actions.8:src/main/java/travelator/handlers/CurrentTripsHandler.java]](https://java-to-kotlin.dev/code.html?ref=7.18&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=7.18&show=diff)'
- en: '[![1](assets/1.png)](#co_introduction_CO14-1)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_introduction_CO14-1)'
- en: We’re still passing `null`
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然传递 `null`
- en: 'Now that neither of our `currentTripFor` methods fetch the time, `CurrentTripHandler`
    is the only action—the place that we need to call `Instant.now()`. We can fix
    things by inserting the call, leaving us with:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的 `currentTripFor` 方法都不再获取时间，`CurrentTripHandler` 是唯一的操作——我们需要调用 `Instant.now()`
    的地方。我们可以通过插入调用来修复问题，最终得到：
- en: '[PRE25]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[Example 7.19 [actions.9:src/main/java/travelator/handlers/CurrentTripsHandler.java]](https://java-to-kotlin.dev/code.html?ref=7.19&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=7.19&show=diff)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 7.19 [actions.9:src/main/java/travelator/handlers/CurrentTripsHandler.java]](https://java-to-kotlin.dev/code.html?ref=7.19&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=7.19&show=diff)'
- en: '[![1](assets/1.png)](#co_introduction_CO15-1)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_introduction_CO15-1)'
- en: Now our action is at the application entry point.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的操作位于应用程序的入口点。
- en: Looking through our code, we find (scream) that we don’t have any unit tests
    for the handler. If we want to add them, this is the level at which we would now
    inject a `Clock`, rather than into the individual services. Mocks or stubs allow
    us to test actions, but are rarely required to test calculations.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 查看我们的代码，我们发现（尖叫声）处理程序没有任何单元测试。如果我们想要添加它们，这是我们现在注入`Clock`的层次，而不是单独的服务。模拟或存根允许我们测试操作，但很少需要测试计算。
- en: We won’t show it, but we also have to consider the production implementation
    of `Trips`, the one that reads from our database. We are lucky and find that this
    passes the current time into its SQL query, so now we can just use the value of
    the `at` parameter in `Trips.currentTripsFor(String customerId, Instant at)` instead.
    It would have been more complicated if the SQL query was using the current time
    of the database server from a database-specific expression such as `CURRENT_TIMESTAMP`
    or `NOW`. As with non-SQL code, actions are so pervasive that this is a common
    practice even though it makes testing more complicated and the code itself less
    versatile. If our query had used the database time, we would have to rewrite it
    to receive the time from our function as a parameter, and make a mental note not
    to make the same mistake again.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会展示它，但我们也必须考虑`Trips`的生产实现，即从我们的数据库中读取的实现。我们很幸运地发现，它将当前时间传递到其SQL查询中，因此现在我们可以直接使用`Trips.currentTripsFor(String
    customerId, Instant at)`中`at`参数的值。如果SQL查询使用数据库服务器的当前时间，例如`CURRENT_TIMESTAMP`或`NOW`等特定于数据库的表达式，那么情况将更加复杂。与非SQL代码一样，操作如此普遍，即使这使得测试更加复杂，代码本身也不太灵活。如果我们的查询使用了数据库时间，我们将不得不重写它，以从我们的函数中接收时间参数，并心理记录不要再犯同样的错误。
- en: With that done, we review our changes and find that we haven’t converted any
    code to Kotlin!
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: With that done, we review our changes and find that we haven’t converted any
    code to Kotlin!
- en: This is significant. This way of thinking about calculations and actions doesn’t
    depend on our implementation language, and the grain of Java is becoming more
    functional with time. We find, though, that Kotlin’s more natural support for
    immutable data and other functional constructs means that the costs of making
    the distinction are lower, and so the cost/benefit ratio looks more favorable.
    Note also that a lot of the refactoring steps taken in this chapter (and others)
    are safe only because we are moving around the invocation of calculations and
    not actions.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这很重要。这种对计算和操作的思考方式并不依赖于我们的实现语言，而Java的粒度随着时间的推移变得更加功能化。尽管如此，我们发现Kotlin对于不可变数据和其他函数构造的自然支持意味着区分的成本更低，因此成本/收益比看起来更有利。还要注意，本章（以及其他章节）中采取的许多重构步骤之所以安全，仅因为我们在计算和操作的调用之间移动。
- en: 'Before we finish this chapter, what about the other action we hinted at? Here
    is the implementation of `InMemoryTrips`, now converted to Kotlin:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成本章之前，我们暗示的另一个操作呢？这里是`InMemoryTrips`的实现，现在已转换为Kotlin：
- en: '[PRE26]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[Example 7.20 [actions.10:src/test/java/travelator/InMemoryTrips.kt]](https://java-to-kotlin.dev/code.html?ref=7.20&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=7.20&show=diff)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 7.20 [actions.10:src/test/java/travelator/InMemoryTrips.kt]](https://java-to-kotlin.dev/code.html?ref=7.20&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=7.20&show=diff)'
- en: That `MutableMap` of `MutableSet`s is a sign that something can change over
    time. If they have the same customer, the result of `tripsFor` will be different
    after we have called `addTrip`. So `tripsFor` is an action, not a calculation.
    If `tripsFor` is an action, then anything that calls it is an action, including
    our `currentTripsFor`. The same will obviously be true of the production version
    of `Trips` that reads and writes to the database. After all this work, we haven’t
    actually promoted our action to a calculation after all!
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`MutableMap`中的`MutableSet`是某些东西随时间变化的迹象。如果它们有相同的客户端，那么在我们调用`addTrip`之后，`tripsFor`的结果将不同。因此，`tripsFor`是一个操作，而不是一个计算。如果`tripsFor`是一个操作，那么调用它的任何东西也是一个操作，包括我们的`currentTripsFor`。同样的情况显然也适用于读写数据库的生产版本的`Trips`。在所有这些工作之后，我们实际上并没有将我们的操作提升为一个计算！'
- en: Should we be downhearted? No. Despite our previous assertion that functions
    are either calculations *or* actions, the truth is that in practice actionness
    is graduated, and actions can be more or less susceptible to time. In this case,
    unless other code *in this interaction* is also going to fetch the trips for a
    customer and find an inconsistency, we can treat `Trips` as effectively immutable.
    So `tripsFor`, and by extension `currentTripsFor`, are effectively calculations.
    In this respect our `InMemoryTrips` is less safe than our database implementation
    because, if accessed on multiple threads, it can mutate the collection returned
    by `tripsFor`, leading to potential `ConcurrentModification​Excep⁠tions` in the
    `filter` implementation. Categorizing our code into calculations and actions has
    helped us see these issues and given us a framework for deciding whether they
    are important in context.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该沮丧吗？不。尽管我们先前断言函数要么是计算，要么是操作，但实际上操作性是分级的，操作可能更或少易受时间影响。在这种情况下，除非其他代码*在此互动中*也要获取客户的行程并找到不一致，否则我们可以将`Trips`视为实际上不可变。因此，`tripsFor`，以及由此推广出的`currentTripsFor`，实际上是计算。在这方面，我们的`InMemoryTrips`比我们的数据库实现不太安全，因为如果在多个线程中访问，它可能会突变由`tripsFor`返回的集合，在`filter`实现中可能导致`ConcurrentModification​Excep⁠tions`。将我们的代码分类为计算和操作有助于我们看到这些问题，并为在特定上下文中它们是否重要提供了一个框架。
- en: Lastly, note that Kotlin’s preference for immutable data makes this categorization
    easier. For example, when you see `List` in Java, you have to find the places
    in which it is created or referenced to establish its mutability and, hence, the
    likelihood that code accessing it can be an action. In Kotlin, when you see `MutableList`
    you can infer an action, although as we have seen with `InMemoryTrips`, exposing
    a mutable collection with a read-only alias can lead to actions pretending to
    be calculations.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请注意，Kotlin 更倾向于使用不可变数据，这使得这种分类变得更加容易。例如，在 Java 中当你看到`List`时，你必须找到创建或引用它的地方来确定它的可变性，从而推断访问它的代码是否可能是一个操作。在
    Kotlin 中，当你看到`MutableList`时，你可以推断这是一个操作，尽管正如我们在`InMemoryTrips`中看到的，暴露一个带有只读别名的可变集合可能会导致操作假装成计算。
- en: Moving On
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继续前进
- en: 'Categorizing code into calculations and actions (along with data) is a formalism
    introduced by Eric Normand in his book, [*Grokking Simplicity: Taming Complex
    Software with Functional Thinking*](bibliography01.html#N_GSTCSWFT_2021) (Manning
    Publications). As developers, we intuit the difference and soon learn to rely
    on our intuition, but often without realizing how or why. Giving names to the
    categories, and studying their qualities, allows us to reason at a more conscious
    and effective level.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码分类为计算和操作（以及数据）是埃里克·诺曼德在他的书籍[*《通晓简易：用功能性思维驾驭复杂软件》*](bibliography01.html#N_GSTCSWFT_2021)（Manning
    出版社）中引入的一种形式化方法。作为开发者，我们可以直觉地区分它们，并很快学会依赖我们的直觉，但通常并不意识到如何或为什么。给这些类别命名，并研究它们的特性，使我们能够在更有意识和有效的水平上推理。
- en: 'In [Chapter 5, *Beans to Values*](ch05.html#beans-to-values), we refactored
    from a mutable bean to an immutable value. Similarly, in [Chapter 6, *Java to
    Kotlin Collections*](ch06.html#java-to-kotlin-collections), we refactored from
    mutable to immutable collections. In both cases, we trade mutating an object for
    returning an amended copy, converting an action into a calculation. In doing so,
    we gain the advantages we’ve seen in this chapter: better comprehension, easier
    testing, and predictable refactoring. The more of our code that is calculations,
    the better off we are.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 5 章，*从 Bean 到值*](ch05.html#beans-to-values)中，我们从可变的 bean 重构为不可变的值。类似地，在[第
    6 章，*Java 到 Kotlin 集合*](ch06.html#java-to-kotlin-collections)中，我们从可变集合重构为不可变集合。在这两种情况下，我们通过返回一个修改后的副本来代替对对象的突变，将一个操作转换为计算。通过这样做，我们获得了本章中看到的优势：更好的理解、更容易的测试和可预测的重构。我们的代码中计算的部分越多，我们就越好。
- en: We will return to the topic of moving from actions to calculations in [Chapter 14,
    *Accumulating Objects to Transformations*](ch14.html#accumulating-objects-to-transformations).
    In [Chapter 15, *Encapsulated Collections to Type Aliases*](ch15.html#encapsulated-collections-to-typealiases),
    we’ll see how immutable data combines with Kotlin’s extension functions and type
    aliases and lets us organize our code in ways not possible in Java.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第 14 章，*从累积对象到转换*](ch14.html#accumulating-objects-to-transformations)中回到从操作到计算的主题。在[第
    15 章，*封装集合到类型别名*](ch15.html#encapsulated-collections-to-typealiases)中，我们将看到不可变数据如何与
    Kotlin 的扩展函数和类型别名结合，让我们以 Java 不可能的方式组织我们的代码。
