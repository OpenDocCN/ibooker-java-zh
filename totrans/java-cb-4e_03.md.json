["```java\nSystem.out.println(\"The answer is \" + result);\n```", "```java\nint result = ...;\nSystem.out.println(result + '=' + \" the answer.\");\n```", "```java\n103 the answer.\n```", "```java\nString long = \"\"\"\nThis is a long\ntext String.\"\"\"\n```", "```java\npublic class SubStringDemo {\n    public static void main(String[] av) {\n        String a = \"Java is great.\";\n        System.out.println(a);\n        String b = a.substring(5);    // b is the String \"is great.\"\n        System.out.println(b);\n        String c = a.substring(5,7);// c is the String \"is\"\n        System.out.println(c);\n        String d = a.substring(5,a.length());// d is \"is great.\"\n        System.out.println(d);\n    }\n}\n```", "```java\nC:> java strings.SubStringDemo\nJava is great.\nis great.\nis\nis great.\nC:>\n```", "```java\nfor (String word : some_input_string.split(\" \")) {\n    System.out.println(word);\n}\n```", "```java\nStringTokenizer st = new StringTokenizer(\"Hello World of Java\");\n\nwhile (st.hasMoreTokens( ))\n    System.out.println(\"Token: \" + st.nextToken( ));\n```", "```java\nStringTokenizer st = new StringTokenizer(\"Hello, World|of|Java\", \", |\");\n\nwhile (st.hasMoreElements( ))\n    System.out.println(\"Token: \" + st.nextElement( ));\n```", "```java\nFirstName|LastName|Company|PhoneNumber\n```", "```java\nStringTokenizer st =\n    new StringTokenizer(\"Hello, World|of|Java\", \", |\", true);\n\nwhile (st.hasMoreElements( ))\n    System.out.println(\"Token: \" + st.nextElement( ));\n```", "```java\nC:\\>java strings.StrTokDemo3\nToken: Hello\nToken: ,\nToken:\nToken: World\nToken: |\nToken: of\nToken: |\nToken: Java\nC:\\>\n```", "```java\npublic class StrTokDemo4 {\n    public final static int MAXFIELDS = 5;\n    public final static String DELIM = \"|\";\n\n    /** Processes one String, returns it as an array of Strings */\n    public static String[] process(String line) {\n        String[] results = new String[MAXFIELDS];\n\n        // Unless you ask StringTokenizer to give you the tokens,\n        // it silently discards multiple null tokens.\n        StringTokenizer st = new StringTokenizer(line, DELIM, true);\n\n        int i = 0;\n        // Stuff each token into the current slot in the array.\n        while (st.hasMoreTokens()) {\n            String s = st.nextToken();\n            if (s.equals(DELIM)) {\n                if (i++>=MAXFIELDS)\n                    // This is messy: See StrTokDemo4b which uses\n                    // a List to allow any number of fields.\n                    throw new IllegalArgumentException(\"Input line \" +\n                        line + \" has too many fields\");\n                continue;\n            }\n            results[i] = s;\n        }\n        return results;\n    }\n\n    public static void printResults(String input, String[] outputs) {\n        System.out.println(\"Input: \" + input);\n        for (String s : outputs)\n            System.out.println(\"Output \" + s + \" was: \" + s);\n    }\n\n    public static void main(String[] a) {\n        printResults(\"A|B|C|D\", process(\"A|B|C|D\"));\n        printResults(\"A||C|D\", process(\"A||C|D\"));\n        printResults(\"A|||D|E\", process(\"A|||D|E\"));\n    }\n}\n```", "```java\nInput: A|B|C|D\nOutput 0 was: A\nOutput 1 was: B\nOutput 2 was: C\nOutput 3 was: D\nOutput 4 was: null\nInput: A||C|D\nOutput 0 was: A\nOutput 1 was: null\nOutput 2 was: C\nOutput 3 was: D\nOutput 4 was: null\nInput: A|||D|E\nOutput 0 was: A\nOutput 1 was: null\nOutput 2 was: null\nOutput 3 was: D\nOutput 4 was: E\n```", "```java\nMatcher tokenizer = Pattern.compile(\"\\\\d+\").matcher(inputString);\nwhile (tokenizer.find( )) {\n        String courseString = tokenizer.group(0);\n        int courseNumber = Integer.parseInt(courseString);\n        ...\n```", "```java\npublic class StringBuilderDemo {\n\n    public static void main(String[] argv) {\n\n        String s1 = \"Hello\" + \", \" + \"World\";\n        System.out.println(s1);\n\n        // Build a StringBuilder, and append some things to it.\n        StringBuilder sb2 = new StringBuilder();\n        sb2.append(\"Hello\");\n        sb2.append(',');\n        sb2.append(' ');\n        sb2.append(\"World\");\n\n        // Get the StringBuilder's value as a String, and print it.\n        String s2 = sb2.toString();\n        System.out.println(s2);\n\n        // Now do the above all over again, but in a more\n        // concise (and typical \"real-world\" Java) fashion.\n\n        System.out.println(\n          new StringBuilder()\n            .append(\"Hello\")\n            .append(',')\n            .append(' ')\n            .append(\"World\"));\n    }\n}\n```", "```java\n        System.out.println(\n            \"Split using String.split; joined using 1.8 String join\");\n        System.out.println(String.join(\", \", SAMPLE_STRING.split(\" \")));\n\n        System.out.println(\n            \"Split using String.split; joined using StringBuilder\");\n        StringBuilder sb1 = new StringBuilder();\n        for (String word : SAMPLE_STRING.split(\" \")) {\n            if (sb1.length() > 0) {\n                sb1.append(\", \");\n            }\n            sb1.append(word);\n        }\n        System.out.println(sb1);\n\n        System.out.println(\n            \"Split using StringTokenizer; joined using StringBuilder\");\n        StringTokenizer st = new StringTokenizer(SAMPLE_STRING);\n        StringBuilder sb2 = new StringBuilder();\n        while (st.hasMoreElements()) {\n            sb2.append(st.nextToken());\n            if (st.hasMoreElements()) {\n                sb2.append(\", \");\n            }\n        }\n        System.out.println(sb2);\n```", "```java\npublic class StrCharAt {\n    public static void main(String[] av) {\n        String a = \"A quick bronze fox\";\n        for (int i=0; i < a.length(); i++) { // no forEach, need the index\n            String message = String.format(\n                \"charAt is '%c', codePointAt is %3d, casted it's '%c'\",\n                     a.charAt(i),\n                     a.codePointAt(i),\n                     (char)a.codePointAt(i));\n            System.out.println(message);\n        }\n    }\n}\n```", "```java\npublic class ForEachChar {\n    public static void main(String[] args) {\n        String mesg = \"Hello world\";\n\n        // Does not compile, Strings are not iterable\n        // for (char ch : mesg) {\n        //        System.out.println(ch);\n        // }\n\n        System.out.println(\"Using toCharArray:\");\n        for (char ch : mesg.toCharArray()) {\n            System.out.println(ch);\n        }\n\n        System.out.println(\"Using Streams:\");\n        mesg.chars().forEach(c -> System.out.println((char)c));\n    }\n}\n```", "```java\n    /** CheckSum one text file, given an open BufferedReader.\n * Checksum does not include line endings, so will give the\n * same value for given text on any platform. Do not use\n * on binary files!\n */\n    public static int process(BufferedReader is) {\n        int sum = 0;\n        try {\n            String inputLine;\n\n            while ((inputLine = is.readLine()) != null) {\n                for (char c : inputLine.toCharArray()) {\n                    sum += c;\n                }\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(\"IOException: \" + e);\n        }\n        return sum;\n    }\n```", "```java\npublic class StringAlignSimple {\n\n    public static void main(String[] args) {\n        // Construct a \"formatter\" to center strings.\n        StringAlign formatter = new StringAlign(70, StringAlign.Justify.CENTER);\n        // Try it out, for page \"i\"\n        System.out.println(formatter.format(\"- i -\"));\n        // Try it out, for page 4\\. Since this formatter is\n        // optimized for Strings, not specifically for page numbers,\n        // we have to convert the number to a String\n        System.out.println(formatter.format(Integer.toString(4)));\n    }\n}\n```", "```java\n> javac -d . StringAlignSimple.java\n> java strings.StringAlignSimple\n                                - i -\n                                  4\n>\n```", "```java\npublic class StringAlign extends Format {\n\n    private static final long serialVersionUID = 1L;\n\n    public enum Justify {\n        /* Constant for left justification. */\n        LEFT,\n        /* Constant for centering. */\n        CENTER,\n        /** Constant for right-justified Strings. */\n        RIGHT,\n    }\n\n    /** Current justification */\n    private Justify just;\n    /** Current max length */\n    private int maxChars;\n\n    /** Construct a StringAlign formatter; length and alignment are\n * passed to the Constructor instead of each format() call as the\n * expected common use is in repetitive formatting e.g., page numbers.\n * @param maxChars - the maximum length of the output\n * @param just - one of the enum values LEFT, CENTER or RIGHT\n */\n    public StringAlign(int maxChars, Justify just) {\n        switch(just) {\n        case LEFT:\n        case CENTER:\n        case RIGHT:\n            this.just = just;\n            break;\n        default:\n            throw new IllegalArgumentException(\"invalid justification arg.\");\n        }\n        if (maxChars < 0) {\n            throw new IllegalArgumentException(\"maxChars must be positive.\");\n        }\n        this.maxChars = maxChars;\n    }\n\n    /** Format a String.\n * @param input - the string to be aligned.\n * @parm where - the StringBuilder to append it to.\n * @param ignore - a FieldPosition (may be null, not used but\n * specified by the general contract of Format).\n */\n    @Override\n    public StringBuffer format(\n        Object input, StringBuffer where, FieldPosition ignore)  {\n\n        String s = input.toString();\n        String wanted = s.substring(0, Math.min(s.length(), maxChars));\n\n        // Get the spaces in the right place.\n        switch (just) {\n            case RIGHT:\n                pad(where, maxChars - wanted.length());\n                where.append(wanted);\n                break;\n            case CENTER:\n                int toAdd = maxChars - wanted.length();\n                pad(where, toAdd/2);\n                where.append(wanted);\n                pad(where, toAdd - toAdd/2);\n                break;\n            case LEFT:\n                where.append(wanted);\n                pad(where, maxChars - wanted.length());\n                break;\n            }\n        return where;\n    }\n\n    protected final void pad(StringBuffer to, int howMany) {\n        for (int i=0; i<howMany; i++)\n            to.append(' ');\n    }\n\n    /** Convenience Routine */\n    String format(String s) {\n        return format(s, new StringBuffer(), null).toString();\n    }\n\n    /** ParseObject is required, but not useful here. */\n    public Object parseObject (String source, ParsePosition pos)  {\n        return source;\n    }\n}\n```", "```java\njshell> \"abc\\ndef\".indent(30).lines().forEach(System.out::println);\n                              abc\n                              def\n\njshell> \"abc\\ndef\".indent(30).indent(-10).lines().forEach(System.out::println);\n                    abc\n                    def\n\njshell>\n```", "```java\n        // UnicodeChars.java\n        StringBuilder b = new StringBuilder();\n        for (char c = 'a'; c<'d'; c++) {\n            b.append(c);\n        }\n        b.append('\\u00a5');    // Japanese Yen symbol\n        b.append('\\u01FC');    // Roman AE with acute accent\n        b.append('\\u0391');    // GREEK Capital Alpha\n        b.append('\\u03A9');    // GREEK Capital Omega\n\n        for (int i=0; i<b.length(); i++) {\n            System.out.printf(\n                \"Character #%d (%04x) is %c%n\",\n                i, (int)b.charAt(i), b.charAt(i));\n        }\n        System.out.println(\"Accumulated characters are \" + b);\n```", "```java\n$ java -cp target/classes strings.UnicodeChars\nCharacter #0 (0061) is a\nCharacter #1 (0062) is b\nCharacter #2 (0063) is c\nCharacter #3 (00a5) is ¥\nCharacter #4 (01fc) is Ǽ\nCharacter #5 (0391) is Α\nCharacter #6 (03a9) is Ω\nAccumulated characters are abc¥ǼΑΩ\n$\n```", "```java\nCharacter #0 is a\nCharacter #1 is b\nCharacter #2 is c\nCharacter #3 is ¥\nCharacter #4 is ?\nCharacter #5 is ?\nCharacter #6 is ?\nAccumulated characters are abc¥___\n```", "```java\nString sh = \"FCGDAEB\";\nSystem.out.println(sh + \" -> \" + new StringBuilder(sh).reverse());\n```", "```java\n        String s = \"Father Charles Goes Down And Ends Battle\";\n\n        // Put it in the stack frontwards\n        Stack<String> myStack = new Stack<>();\n        StringTokenizer st = new StringTokenizer(s);\n        while (st.hasMoreTokens()) {\n            myStack.push(st.nextToken());\n        }\n\n        // Print the stack backwards\n        System.out.print('\"' + s + '\"' + \" backwards by word is:\\n\\t\\\"\");\n        while (!myStack.empty()) {\n            System.out.print(myStack.pop());\n            System.out.print(' ');    // inter-word spacing\n        }\n        System.out.println('\"');\n```", "```java\npublic class EnTab {\n\n    private static Logger logger = Logger.getLogger(EnTab.class.getSimpleName());\n\n    /** The Tabs (tab logic handler) */\n    protected Tabs tabs;\n\n    /**\n * Delegate tab spacing information to tabs.\n */\n    public int getTabSpacing() {\n        return tabs.getTabSpacing();\n    }\n\n    /**\n * Main program: just create an EnTab object, and pass the standard input\n * or the named file(s) through it.\n */\n    public static void main(String[] argv) throws IOException {\n        EnTab et = new EnTab(8);\n        if (argv.length == 0) // do standard input\n            et.entab(\n                new BufferedReader(new InputStreamReader(System.in)),\n                System.out);\n        else\n            for (String fileName : argv) { // do each file\n                et.entab(\n                    new BufferedReader(new FileReader(fileName)),\n                    System.out);\n            }\n    }\n\n    /**\n * Constructor: just save the tab values.\n * @param n The number of spaces each tab is to replace.\n */\n    public EnTab(int n) {\n        tabs = new Tabs(n);\n    }\n\n    public EnTab() {\n        tabs = new Tabs();\n    }\n\n    /**\n * entab: process one file, replacing blanks with tabs.\n * @param is A BufferedReader opened to the file to be read.\n * @param out a PrintWriter to send the output to.\n */\n    public void entab(BufferedReader is, PrintWriter out) throws IOException {\n\n        // main loop: process entire file one line at a time.\n        is.lines().forEach(line -> {\n            out.println(entabLine(line));\n        });\n    }\n\n    /**\n * entab: process one file, replacing blanks with tabs.\n *\n * @param is A BufferedReader opened to the file to be read.\n * @param out A PrintStream to write the output to.\n */\n    public void entab(BufferedReader is, PrintStream out) throws IOException {\n        entab(is, new PrintWriter(out));\n    }\n\n    /**\n * entabLine: process one line, replacing blanks with tabs.\n * @param line the string to be processed\n */\n    public String entabLine(String line) {\n        int N = line.length(), outCol = 0;\n        StringBuilder sb = new StringBuilder();\n        char ch;\n        int consumedSpaces = 0;\n\n        for (int inCol = 0; inCol < N; inCol++) { // Cannot use foreach here\n            ch = line.charAt(inCol);\n            // If we get a space, consume it, don't output it.\n            // If this takes us to a tab stop, output a tab character.\n            if (ch == ' ') {\n                logger.info(\"Got space at \" + inCol);\n                if (tabs.isTabStop(inCol)) {\n                    logger.info(\"Got a Tab Stop \" + inCol);\n                    sb.append('\\t');\n                    outCol += consumedSpaces;\n                    consumedSpaces = 0;\n                } else {\n                    consumedSpaces++;\n                }\n                continue;\n            }\n\n            // We're at a non-space; if we're just past a tab stop, we need\n            // to put the \"leftover\" spaces back out, since we consumed\n            // them above.\n            while (inCol-1 > outCol) {\n                logger.info(\"Padding space at \" + inCol);\n                sb.append(' ');\n                outCol++;\n            }\n\n            // Now we have a plain character to output.\n            sb.append(ch);\n            outCol++;\n\n        }\n        // If line ended with trailing (or only!) spaces, preserve them.\n        for (int i = 0; i < consumedSpaces; i++) {\n            logger.info(\"Padding space at end # \" + i);\n            sb.append(' ');\n        }\n        return sb.toString();\n    }\n}\n```", "```java\npublic class DeTab {\n    Tabs ts;\n\n    public static void main(String[] argv) throws IOException {\n        DeTab dt = new DeTab(8);\n        dt.detab(new BufferedReader(new InputStreamReader(System.in)),\n                new PrintWriter(System.out));\n    }\n\n    public DeTab(int n) {\n        ts = new Tabs(n);\n    }\n    public DeTab() {\n        ts = new Tabs();\n    }\n\n    /** detab one file (replace tabs with spaces)\n * @param is - the file to be processed\n * @param out - the updated file\n */\n    public void detab(BufferedReader is, PrintWriter out) throws IOException {\n        is.lines().forEach(line -> {\n            out.println(detabLine(line));\n        });\n    }\n\n    /** detab one line (replace tabs with spaces)\n * @param line - the line to be processed\n * @return the updated line\n */\n    public String detabLine(String line) {\n        char c;\n        int col;\n        StringBuilder sb = new StringBuilder();\n        col = 0;\n        for (int i = 0; i < line.length(); i++) {\n            // Either ordinary character or tab.\n            if ((c = line.charAt(i)) != '\\t') {\n                sb.append(c); // Ordinary\n                ++col;\n                continue;\n            }\n            do { // Tab, expand it, must put >=1 space\n                sb.append(' ');\n            } while (!ts.isTabStop(++col));\n        }\n        return sb.toString();\n    }\n}\n```", "```java\npublic class Tabs {\n    /** tabs every so often */\n    public final static int DEFTABSPACE =   8;\n    /** the current tab stop setting. */\n    protected int tabSpace = DEFTABSPACE;\n    /** the longest line that we initially set tabs for */\n    public final static int MAXLINE  = 255;\n\n    /** Construct a Tabs object with a given tab stop settings */\n    public Tabs(int n) {\n        if (n <= 0) {\n            n = 1;\n        }\n        tabSpace = n;\n    }\n\n    /** Construct a Tabs object with a default tab stop settings */\n    public Tabs() {\n        this(DEFTABSPACE);\n    }\n\n    /**\n * @return Returns the tabSpace.\n */\n    public int getTabSpacing() {\n        return tabSpace;\n    }\n\n    /** isTabStop - returns true if given column is a tab stop.\n * @param col - the current column number\n */\n    public boolean isTabStop(int col) {\n        if (col <= 0)\n            return false;\n        return (col+1) % tabSpace == 0;\n    }\n}\n```", "```java\n        String name = \"Java Cookbook\";\n        System.out.println(\"Normal:\\t\" + name);\n        System.out.println(\"Upper:\\t\" + name.toUpperCase());\n        System.out.println(\"Lower:\\t\" + name.toLowerCase());\n        String javaName = \"java cookBook\"; // If it were Java identifiers :-)\n        if (!name.equals(javaName))\n            System.err.println(\"equals() correctly reports false\");\n        else\n            System.err.println(\"equals() incorrectly reports true\");\n        if (name.equalsIgnoreCase(javaName))\n            System.err.println(\"equalsIgnoreCase() correctly reports true\");\n        else\n            System.err.println(\"equalsIgnoreCase() incorrectly reports false\");\n```", "```java\nC:\\javasrc\\strings>java strings.Case\nNormal: Java Cookbook\nUpper:  JAVA COOKBOOK\nLower:  java cookbook\nequals( ) correctly reports false\nequalsIgnoreCase( ) correctly reports true\n```", "```java\npublic class StringEscapes {\n    public static void main(String[] argv) {\n        System.out.println(\"Java Strings in action:\");\n        // System.out.println(\"An alarm or alert: \\a\");    // not supported\n        System.out.println(\"An alarm entered in Octal: \\007\");\n        System.out.println(\"A tab key: \\t(what comes after)\");\n        System.out.println(\"A newline: \\n(what comes after)\");\n        System.out.println(\"A UniCode character: \\u0207\");\n        System.out.println(\"A backslash character: \\\\\");\n    }\n}\n```", "```java\npublic class GetMark {\n    /** the default starting mark */\n    public final String START_MARK = \"//+\";\n    /** the default ending mark */\n    public final String END_MARK = \"//-\";\n    /** Set this to TRUE for running in \"exclude\" mode (e.g., for\n * building exercises from solutions) and to FALSE for running\n * in \"extract\" mode (e.g., writing a book and omitting the\n * imports and \"public class\" stuff).\n */\n    public final static boolean START = true;\n    /** True if we are currently inside marks */\n    protected boolean printing = START;\n    /** True if you want line numbers */\n    protected final boolean number = false;\n\n    /** Get Marked parts of one file, given an open LineNumberReader.\n * This is the main operation of this class, and can be used\n * inside other programs or from the main() wrapper.\n */\n    public void process(String fileName,\n        LineNumberReader is,\n        PrintStream out) {\n        int nLines = 0;\n        try {\n            String inputLine;\n\n            while ((inputLine = is.readLine()) != null) {\n                if (inputLine.trim().equals(START_MARK)) {\n                    if (printing)\n                        // These go to stderr, so you can redirect the output\n                        System.err.println(\"ERROR: START INSIDE START, \" +\n                            fileName + ':' + is.getLineNumber());\n                    printing = true;\n                } else if (inputLine.trim().equals(END_MARK)) {\n                    if (!printing)\n                        System.err.println(\"ERROR: STOP WHILE STOPPED, \" +\n                            fileName + ':' + is.getLineNumber());\n                    printing = false;\n                } else if (printing) {\n                    if (number) {\n                        out.print(nLines);\n                        out.print(\": \");\n                    }\n                    out.println(inputLine);\n                    ++nLines;\n                }\n            }\n            is.close();\n            out.flush(); // Must not close - caller may still need it.\n            if (nLines == 0)\n                System.err.println(\"ERROR: No marks in \" + fileName +\n                    \"; no output generated!\");\n        } catch (IOException e) {\n            System.out.println(\"IOException: \" + e);\n        }\n    }\n```", "```java\n    ResourceBundle rb = ResourceBundle.getBundle(\"Menus\");\n    ```", "```java\n    String label = \"Exit\";\n    // Create the control, e.g., new JButton(label);\n    ```", "```java\n    try { label = rb.getString(\"exit.label\"); }\n    catch (MissingResourceException e) { label=\"Exit\"; } // fallback\n    // Create the control, e.g., new JButton(label);\n    ```", "```java\nJButton exitButton = I18NUtil.getButton(\"exit.label\", \"Exit\");\n```", "```java\n  <application>\n    <locale-config>\n        <default-locale>en</default-locale>\n        <supported-locale>en</supported-locale>\n        <supported-locale>es</supported-locale>\n        <supported-locale>fr</supported-locale>\n    </locale-config>\n    <resource-bundle>\n        <base-name>resources</base-name>\n        <var>msg</var>\n    </resource-bundle>\n  </application>\n```", "```java\n// In signup.xhtml:\n<h:outputText value=\"#{msg.prompt_firstname}\"/>\n<h:inputText required=\"true\" id=\"firstName\" value=\"#{person.firstName}\" />\n```", "```java\nexport LANG=es_MX\n```", "```java\njava -Duser.language=es i18n.Browser\n```", "```java\nLocale locale1 = Locale.FRANCE;    // predefined\nLocale locale2 = new Locale(\"en\", \"UK\");    // English, UK version\n```", "```java\nDateFormat frDateFormatter = DateFormat.getDateInstance(\n\t\tDateFormat.MEDIUM, frLocale);\nDateFormat ukDateFormatter = DateFormat.getDateInstance(\n\t\tDateFormat.MEDIUM, ukLocale);\n```", "```java\npackage i18n;\n\nimport java.time.LocalDateTime;\nimport java.time.format.DateTimeFormatter;\nimport java.time.format.FormatStyle;\nimport java.util.Locale;\n\n/** Use some locales; based on user's OS \"settings\"\n * choices or -Duser.lang= or -Duser.region=.\n */\npublic class UseLocales {\n    public static void main(String[] args) {\n\n        Locale frLocale = Locale.FRANCE;    // predefined\n        Locale ukLocale = new Locale(\"en\", \"UK\");    // English, UK version\n\n        DateTimeFormatter defaultDateFormatter =\n            DateTimeFormatter.ofLocalizedDateTime(\n                FormatStyle.MEDIUM);\n        DateTimeFormatter frDateFormatter =\n            DateTimeFormatter.ofLocalizedDateTime(\n                FormatStyle.MEDIUM).localizedBy(frLocale);\n        DateTimeFormatter ukDateFormatter =\n            DateTimeFormatter.ofLocalizedDateTime(\n                FormatStyle.MEDIUM).localizedBy(ukLocale);\n\n        LocalDateTime now = LocalDateTime.now();\n        System.out.println(\"Default: \" + ' ' +\n            now.format(defaultDateFormatter));\n        System.out.println(frLocale.getDisplayName() + ' ' +\n            now.format(frDateFormatter));\n        System.out.println(ukLocale.getDisplayName() + ' ' +\n            now.format(ukDateFormatter));\n    }\n}\n```", "```java\n$ java i18n.UseLocales\nDefault:  Oct 16, 2019, 4:41:45 PM\nFrench (France) 16 oct. 2019 à 16:41:45\nEnglish (UK) Oct 16, 2019, 4:41:45 PM$\n\n```", "```java\n# Default Menu properties\n# The File Menu\nfile.label=File Menu\nfile.new.label=New File\nfile.new.key=N\nfile.save.label=Save\nfile.new.key=S\n```", "```java\nIt's a nice\nday, isn't it, Mr. Mxyzzptllxy?\nI think we should\ngo for a walk.\n```", "```java\nIt's a nice day, isn't it, Mr. Mxyzzptllxy? I think we should go for a\nwalk.\n```", "```java\npublic class Fmt {\n    /** The maximum column width */\n    public static final int COLWIDTH=72;\n    /** The file that we read and format */\n    final BufferedReader in;\n    /** Where the output goes */\n    PrintWriter out;\n\n    /** If files present, format each one, else format the standard input. */\n    public static void main(String[] av) throws IOException {\n        if (av.length == 0)\n            new Fmt(System.in).format();\n        else for (String name : av) {\n            new Fmt(name).format();\n        }\n    }\n\n    public Fmt(BufferedReader inFile, PrintWriter outFile) {\n        this.in = inFile;\n        this.out = outFile;\n    }\n\n    public Fmt(PrintWriter out) {\n        this(new BufferedReader(new InputStreamReader(System.in)), out);\n    }\n\n    /** Construct a Formatter given an open Reader */\n    public Fmt(BufferedReader file) throws IOException {\n        this(file, new PrintWriter(System.out));\n    }\n\n    /** Construct a Formatter given a filename */\n    public Fmt(String fname) throws IOException {\n        this(new BufferedReader(new FileReader(fname)));\n    }\n\n    /** Construct a Formatter given an open Stream */\n    public Fmt(InputStream file) throws IOException {\n        this(new BufferedReader(new InputStreamReader(file)));\n    }\n\n    /** Format the File contained in a constructed Fmt object */\n    public void format() throws IOException {\n        format(in.lines(), out);\n    }\n\n    /** Format a Stream of lines, e.g., bufReader.lines() */\n    public static void format(Stream<String> s, PrintWriter out) {\n        StringBuilder outBuf = new StringBuilder();\n        s.forEachOrdered((line -> {\n            if (line.length() == 0) {    // null line\n                out.println(outBuf);    // end current line\n                out.println();    // output blank line\n                outBuf.setLength(0);\n            } else {\n                // otherwise it's text, so format it.\n                StringTokenizer st = new StringTokenizer(line);\n                while (st.hasMoreTokens()) {\n                    String word = st.nextToken();\n\n                    // If this word would go past the margin,\n                    // first dump out anything previous.\n                    if (outBuf.length() + word.length() > COLWIDTH) {\n                        out.println(outBuf);\n                        outBuf.setLength(0);\n                    }\n                    outBuf.append(word).append(' ');\n                }\n            }\n        }));\n        if (outBuf.length() > 0) {\n            out.println(outBuf);\n        } else {\n            out.println();\n        }\n    }\n\n}\n```", "```java\npublic class SoundexSimple {\n\n    /** main */\n    public static void main(String[] args) {\n        String[] names = {\n            \"Darwin, Ian\",\n            \"Davidson, Greg\",\n            \"Darwent, William\",\n            \"Derwin, Daemon\"\n        };\n        for (String name : names) {\n            System.out.println(Soundex.soundex(name) + ' ' + name);\n        }\n    }\n}\n```", "```java\n> javac -d . SoundexSimple.java\n> java strings.SoundexSimple | sort\nD132 Davidson, Greg\nD650 Darwin, Ian\nD650 Derwin, Daemon\nD653 Darwent, William\n>\n```", "```java\npublic class Soundex {\n\n    static boolean debug = false;\n\n    /* Implements the mapping\n * from: AEHIOUWYBFPVCGJKQSXZDTLMNR\n * to:   00000000111122222222334556\n */\n    public static final char[] MAP = {\n        //A  B   C   D   E   F   G   H   I   J   K   L   M\n        '0','1','2','3','0','1','2','0','0','2','2','4','5',\n        //N  O   P   W   R   S   T   U   V   W   X   Y   Z\n        '5','0','1','2','6','2','3','0','1','0','2','0','2'\n    };\n\n    /** Convert the given String to its Soundex code.\n * @return null If the given string can't be mapped to Soundex.\n */\n    public static String soundex(String s) {\n\n        // Algorithm works on uppercase (mainframe era).\n        String t = s.toUpperCase();\n\n        StringBuilder res = new StringBuilder();\n        char c, prev = '?', prevOutput = '?';\n\n        // Main loop: find up to 4 chars that map.\n        for (int i=0; i<t.length() && res.length() < 4 &&\n            (c = t.charAt(i)) != ','; i++) {\n\n            // Check to see if the given character is alphabetic.\n            // Text is already converted to uppercase. Algorithm\n            // only handles ASCII letters, do NOT use Character.isLetter()!\n            // Also, skip double letters.\n            if (c>='A' && c<='Z' && c != prev) {\n                prev = c;\n\n                // First char is installed unchanged, for sorting.\n                if (i==0) {\n                    res.append(c);\n                } else {\n                    char m = MAP[c-'A'];\n                    if (debug) {\n                        System.out.println(c + \" --> \" + m);\n                    }\n                    if (m != '0' && m != prevOutput) {\n                        res.append(m);\n                        prevOutput = m;\n                    }\n                }\n            }\n        }\n        if (res.length() == 0)\n            return null;\n        for (int i=res.length(); i<4; i++)\n            res.append('0');\n        return res.toString();\n    }\n```"]