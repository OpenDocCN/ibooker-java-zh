<html><head></head><body><section data-pdf-bookmark="Chapter 23. Continuing the Journey" data-type="chapter" epub:type="chapter"><div class="chapter" id="continuing-the-journey">&#13;
<h1><span class="label">Chapter 23. </span>Continuing the Journey</h1>&#13;
&#13;
<blockquote data-type="epigraph" epub:type="epigraph">&#13;
<p>We’ve arrived at the end of the book.&#13;
Thank you for coming on the journey.&#13;
Your authors are privileged to have worked with, and learned from, many great developers, and now you are on that list.&#13;
Even if you skipped a couple of chapters, or zoned out in the middle of the odd refactoring, it’s been good to have someone to talk to.&#13;
We can’t pair on improving Travelator anymore, but what have we learned from our travels?</p>&#13;
</blockquote>&#13;
&#13;
<p>When O’Reilly asked us if we would like to write a book on Kotlin, we had to think about what we wanted to write and about what enough people might want to read.&#13;
We knew that we had been on a journey adopting the language and that we are comfortable at the destination, but we also knew that our starting point was not that of the typical Java developer.&#13;
We saw that most existing books taught Kotlin as if it were just another syntax for Java, one that could achieve more with less typing but didn’t require a change in approach.&#13;
That<a data-primary="Kotlin" data-secondary="sweet spot for" data-type="indexterm" id="idm46393342519832"/> wasn’t our experience; we found that Kotlin’s sweet spot required more functional thinking than Java.&#13;
Books on functional programming in Kotlin, though, seem to ask the reader to leave behind all that they know about programming with objects and join a new cult.&#13;
We weren’t comfortable with this either.&#13;
Classes and objects are a humane way of expressing behavior, especially compared to many functional idioms.&#13;
Why remove tools from our box when there is plenty of room?&#13;
Can’t we just have more tools and pick the right one for the job?</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Grain" data-type="sect1"><div class="sect1" id="idm46393342518040">&#13;
<h1>Grain</h1>&#13;
&#13;
<p>This<a data-primary="Kotlin" data-secondary="versus Java" data-secondary-sortas="Java" data-type="indexterm" id="idm46393342516744"/><a data-primary="Java" data-secondary="versus Kotlin" data-secondary-sortas="Kotlin" data-type="indexterm" id="idm46393342515464"/> thinking led Nat to come up with the metaphor that programming languages have a grain that influences the design of the programs we write in them.&#13;
The grain makes certain design styles easy to apply and makes others arduous or risky.</p>&#13;
&#13;
<p>The grain of Kotlin is different from that of Java.&#13;
Java’s grain favors mutable objects and reflection at the cost of composability and type safety.&#13;
Compared to Java, Kotlin favors the transformation of immutable values and freestanding functions, and has a type system that is unobtrusive and helpful.&#13;
Although it is easy to convert Java to Kotlin with IntelliJ, we end up with Java in Kotlin syntax rather than taking advantage of all that the new language could offer if we changed our thinking, too.</p>&#13;
&#13;
<p>Java and Kotlin can coexist in the same codebase, and the interop boundary is almost seamless, but there are some risks when you pass information from the strictly typed world of Kotlin to the more loosely typed world of Java.&#13;
With care, we find that we can transform code from idiomatic Java to idiomatic Kotlin in small, safe steps, using automated refactoring tools where possible and editing text as a last resort.&#13;
We can also support the conventions of both languages at the same time when we must maintain Java code while we are converting code it depends on to Kotlin.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Functional Thinking" data-type="sect1"><div class="sect1" id="idm46393342511688">&#13;
<h1>Functional Thinking</h1>&#13;
&#13;
<p>As<a data-primary="functional thinking" data-type="indexterm" id="fthink23"/> we’ve seen in some of our history lessons, the grain of Java was formed in the 1990s, when we believed that<a data-primary="object-oriented programming" data-type="indexterm" id="idm46393342508696"/> object-oriented programming was the mythical silver bullet.&#13;
When OO turned out not to solve all our problems, mainstream programming languages, and even Java itself, began to adopt ideas from functional programming.&#13;
Kotlin was born from Java in this age, and, like our children are better equipped for the future than we are, Kotlin is more suited to modern programming than Java is.</p>&#13;
&#13;
<p>What do we mean by functional thinking?</p>&#13;
&#13;
<p>Our software is ultimately limited by our ability to understand it.&#13;
Our understanding is in turn ultimately limited by the complexity of the software we have created, and a lot of that complexity arises over confusion about <em>when</em> things happen.&#13;
Functional programmers have learned that the easiest way to tame that complexity is simply to have things <em>happen</em> a lot less.&#13;
They<a data-primary="effects" data-type="indexterm" id="idm46393342505464"/> call things happening an <em>effect</em>: a change that is observable in some scope.</p>&#13;
&#13;
<p>Mutating a variable or a collection <em>inside</em> a function is an effect, but unless that variable is shared <em>outside</em> the function, it doesn’t <em>affect</em> any other code.&#13;
When the scope of an effect is local to a function, we don’t have to consider it when reasoning about what our system does.&#13;
As<a data-primary="complexity" data-type="indexterm" id="comp23"/> soon as we mutate shared state (a parameter to the function, perhaps, or a global variable, or a file or network socket), our local effect becomes an effect in whatever scope can see the shared thing, and that quickly increases complexity and makes understanding more difficult.</p>&#13;
&#13;
<p>It isn’t enough that a function doesn’t <em>actually</em> mutate shared state.&#13;
If there is a possibility that a function <em>could</em> mutate shared state, we have to examine the source of the function and, recursively, every function that it calls, to understand what our system does.&#13;
Every piece of global mutable state makes every function suspect.&#13;
Similarly, if we program in an environment in which every function can write to the database, we lose the ability to predict when such writes can occur and plan accordingly.</p>&#13;
&#13;
<p>So functional programmers tame complexity by reducing mutation.&#13;
Sometimes they program in languages (like Clojure and Haskell) that enforce controls on mutation.&#13;
Otherwise, they work by convention.&#13;
If we adopt these conventions in more general languages, we gain more ability to reason with our code.&#13;
Kotlin chooses not to enforce the control of effects, but the language and its runtime come with some built-in conventions to nudge us in the right direction.&#13;
Compared to Java, we have, for example, an immutable <code>val</code> declaration rather than an optional <code>final</code> modifier, read-only views of collections, and concise data classes to encourage copy-on-write rather than mutation.&#13;
Many of this book’s chapters describe more subtle conventions with the same aim:&#13;
<a data-type="xref" data-xrefstyle="chap-num-title" href="ch05.html#beans-to-values">Chapter 5, <em>Beans to Values</em></a>, <a data-type="xref" data-xrefstyle="chap-num-title" href="ch06.html#java-to-kotlin-collections">Chapter 6, <em>Java to Kotlin Collections</em></a>, <a data-type="xref" data-xrefstyle="chap-num-title" href="ch07.html#actions-to-calculations">Chapter 7, <em>Actions to Calculations</em></a>, <a data-type="xref" data-xrefstyle="chap-num-title" href="ch14.html#accumulating-objects-to-transformations">Chapter 14, <em>Accumulating Objects to Transformations</em></a>, and <a data-type="xref" data-xrefstyle="chap-num-title" href="ch20.html#performing-io-to-passing-data">Chapter 20, <em>Performing I/O to Passing Data</em></a>.</p>&#13;
&#13;
<p>There is, of course, much more to functional programming than simply not mutating shared state.&#13;
But if we just focus on solving problems without mutation (or where mutation is the point, we minimize its scope), our systems become easier to understand and change.&#13;
Like <a href="https://oreil.ly/HSaLs">“Don’t repeat yourself”</a> (aka <a href="https://oreil.ly/5HKxy">“Once and only once”</a>), assiduous application of a simple rule has profound effects.&#13;
Both “Don’t mutate shared state” and “Once and only once” share another property though—if we aren’t careful, applying the rules can increase complexity faster than they reduce it.&#13;
We need to learn techniques that allow us to manage mutation (and remove duplication, facilitate testing, and so on) without making our code even harder to understand, and to recognize these techniques for what they are when we see them.&#13;
These techniques will tend to be different in different languages, environments, and domains, and are the craft of our profession.</p>&#13;
&#13;
<p>If you research functional techniques, you will come across a lot of anti-object sentiment.&#13;
This seems to be rooted in a perception that OO is all about mutable objects, but we shouldn’t throw the message-passing baby out with the mutable bathwater.&#13;
Although we can use OO to manage shared mutable state, in practice, these days we generally use objects to encapsulate immutable state, or to represent services and their dependencies.&#13;
We saw in <a data-type="xref" data-xrefstyle="chap-num-title" href="ch16.html#interfaces-to-functions">Chapter 16, <em>Interfaces to Functions</em></a>, that we can use both functions with closure, and classes with properties, to encapsulate data.&#13;
Both can also hide code details and allow a client to work with different implementations.&#13;
We need these points of inflection to build flexible, robust, and testable systems.&#13;
Where in Java we traditionally reach for subclassing as a tool, Kotlin, with its default-closed classes, encourages a more compositional style.&#13;
Instead of overriding a protected method, we have a function-typed property representing a strategy or a collaborator.&#13;
We should favor this style but not be embarrassed to define class and subclass hierarchies where they simplify our implementation.&#13;
Similarly, extension functions in <a data-type="xref" data-xrefstyle="chap-num-title" href="ch10.html#functions-to-extension-functions">Chapter 10, <em>Functions to Extension Functions</em></a>, are all very well, and they can work wonders to reduce coupling between disparate concerns in our codebases, but they are no substitute for polymorphic methods when that is what we need.</p>&#13;
&#13;
<p>In the end, one of the attractions of programming is its combination of the human and the mathematical.&#13;
Objects and classes are, to your authors at least, a more human way of modeling the world, and that is often a fine starting point.&#13;
When we need rigor (which is often, but not as often as muggles might think), functional programming is there for us.&#13;
We see no reason to have to choose one camp or the other when we can have two tents and move between them both, and Kotlin allows us to do that better than any other language we have found.<a data-primary="" data-startref="fthink23" data-type="indexterm" id="idm46393342482600"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Simple Design" data-type="sect1"><div class="sect1" id="idm46393342511064">&#13;
<h1>Simple Design</h1>&#13;
&#13;
<p>If<a data-primary="Rules of Simple Design" data-type="indexterm" id="idm46393342480088"/> complexity is the limiting factor in our software, and functional thinking is a tool for reducing complexity, how does that fit with other maxims—in particular, Kent Beck’s Rules of Simple Design (<a href="bibliography01.html#B_EPEEC_1999"><em>Extreme Programming Explained: Embrace Change</em></a>)?&#13;
These have served us well for two decades, and say that a simple design:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Passes the tests</p>&#13;
</li>&#13;
<li>&#13;
<p>Reveals intention</p>&#13;
</li>&#13;
<li>&#13;
<p>Has no duplication</p>&#13;
</li>&#13;
<li>&#13;
<p>Has fewest elements</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Of these, “reveals intention” is the most open to interpretation, so let’s pull on that thread.</p>&#13;
&#13;
<p>An intention is “an aim or plan”: it implies change.&#13;
It implies action.&#13;
By<a data-primary="calculations" data-secondary="differentiating from actions" data-type="indexterm" id="idm46393342473176"/><a data-primary="actions" data-secondary="differentiating from calculations" data-type="indexterm" id="idm46393342472136"/> differentiating between actions and calculations in our code, we show where we expect things to happen and where we don’t: which things may be affected by other things and which things won’t.&#13;
When the majority of our code is in the form of calculations, we can be explicit about which functions are actions, better revealing our intent.</p>&#13;
&#13;
<p>As we saw in <a data-type="xref" data-xrefstyle="chap-num-title" href="ch07.html#actions-to-calculations">Chapter 7, <em>Actions to Calculations</em></a>, and <a data-type="xref" data-xrefstyle="chap-num-title" href="ch20.html#performing-io-to-passing-data">Chapter 20, <em>Performing I/O to Passing Data</em></a>, our main technique to disentangle calculations from actions is moving the actions out to the entry points of our interactions, so that they contaminate the least code.&#13;
This is neither easy nor a panacea, but we find that it does produce designs that are simpler and code that is less complex.<a data-primary="" data-startref="comp23" data-type="indexterm" id="idm46393342467432"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="pagebreak-before less_space" data-pdf-bookmark="Functional Programming and Textual Reasoning" data-type="sect1"><div class="sect1" id="idm46393342466360">&#13;
<h1>Functional Programming and Textual Reasoning</h1>&#13;
&#13;
<p>When<a data-primary="functional programming" data-type="indexterm" id="idm46393342464568"/><a data-primary="textual reasoning" data-type="indexterm" id="idm46393342463832"/> we finished this book, we realized—to our surprise—that we had not included any software design diagrams.</p>&#13;
&#13;
<p>Partly, frankly, this was laziness.&#13;
It’s hard enough to manage the multiple versions of the example code as it passes through refactorings without having to worry about other views.&#13;
But we also make it a habit to try to express ourselves in just the &#13;
<span class="keep-together">programming</span> language that we have.&#13;
If we can achieve enough comprehension in just the raw text, then in our day jobs, we won’t be forced to switch contexts to view a diagram that may or may not be in sync with the code.</p>&#13;
&#13;
<p>When we’ve written about object-oriented design, we’ve relied on diagrams to show the dynamic structure and behavior of the software and how changes to the source affect its dynamic behavior.&#13;
In object-oriented software, that dynamic structure—the graph of objects and how messages flow between them—is largely implicit.&#13;
This makes it hard to relate what you see in the source to what will happen at runtime, so visualization is a vital part of<a data-primary="object-oriented programming" data-type="indexterm" id="idm46393342460456"/> object-oriented programming.&#13;
Through the 1980s and 1990s, software design luminaries created a variety of diagram notations to visualize object-oriented software.&#13;
In the mid 1990s, the designers of the most popular notations, Grady Booch, Ivar Jacobson, and James Rumbaugh, combined their efforts into the<a data-primary="Unified Modeling Language (UML)" data-type="indexterm" id="idm46393342459288"/> <em>Unified Modeling Language</em> (UML).</p>&#13;
&#13;
<p>The functional programming community doesn’t have such a focus on diagrams and visualization.&#13;
The goal of functional programming is<a data-primary="algebraic reasoning" data-type="indexterm" id="idm46393342457496"/> <em>algebraic reasoning</em>: reasoning about the behavior of a program by manipulating its textual expressions.&#13;
Referential transparency and static types allow us to reason about our programs solely by using the syntax of the source code.&#13;
This results in a much closer correspondence between source code and runtime.&#13;
As our code becomes more functional, we find that we can <em>read</em> our system’s behavior without having to think hard about mechanisms that are not immediately apparent in the source and have to be visualized to be understood.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Refactoring" data-type="sect1"><div class="sect1" id="idm46393342455160">&#13;
<h1>Refactoring</h1>&#13;
&#13;
<p>Along<a data-primary="refactoring" data-secondary="role in real-life programming" data-type="indexterm" id="idm46393342453592"/> with the pragmatic functional programming, refactoring is the other key tenet of this book.&#13;
Refactoring plays an important part in our professional lives because, if we don’t know enough about the eventual form of our system to get its design right the first time, we will have to transform what we have into what we need.&#13;
Your authors, at least, have never known enough about the eventual form of a system to get its design right the first time.&#13;
Even those applications where we started with detailed requirements ended up very different from those specifications by the time they were delivered.</p>&#13;
&#13;
<p>Late in a project and against schedule pressure is no time to learn how to refactor your code.&#13;
Instead, we take every opportunity to practice refactoring.&#13;
As we saw in <a data-type="xref" data-xrefstyle="chap-num-title" href="ch22.html#classes-to-functions">Chapter 22, <em>Classes to Functions</em></a>, even when writing code from scratch we will often hard-code values to get a test to pass and then refactor to remove duplication between the tests and production code.&#13;
We are always looking for new ways to get tests passing quickly and then refactor our way into code that looks like we planned it that way.&#13;
Sometimes we discover a new automated refactoring built into IntelliJ; other times, we find a way to combine existing refactorings to achieve our aims.</p>&#13;
&#13;
<p>When the scope of a change is small, we can get away with hand-editing a definition and then its uses to match, or sometimes, more usefully, the other way around.&#13;
This becomes tedious and error prone when a change affects many files though, so practicing using the tools to achieve even small changes will equip us when faced with larger refactoring challenges.&#13;
Where we do have a multistage refactor, or where we have to manually apply changes in multiple places, <a data-type="xref" href="ch04.html#expand-contract">“Expand-and-Contract Refactoring”</a> allows us to keep the system building and working throughout the process.&#13;
This is vital when a change may take multiple days or even weeks, because it allows us to continually merge our work with other changes in the system.&#13;
Once you’ve thrown away a month of work because a big-bang merge at the end proved impossible, you come to appreciate the value of this technique and want to practice it even when it isn’t strictly necessary.</p>&#13;
&#13;
<p>We hope that the refactorings in this book expand your ambition.&#13;
Your authors have been lucky enough to work with some world-class practitioners, the sort of people who tut if you cause a compile error during a refactoring.&#13;
The transformations we have shown may not be optimal (and even if they were, the state of the art will change with tooling and language changes), but they are genuine, and they do reflect how we write and refactor code.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Refactoring and Functional Thinking" data-type="sect1"><div class="sect1" id="idm46393342446376">&#13;
<h1>Refactoring and Functional Thinking</h1>&#13;
&#13;
<p>As<a data-primary="refactoring" data-secondary="and functional thinking" data-secondary-sortas="functional thinking" data-type="indexterm" id="idm46393342445000"/> we’ve seen on our tour, there is a relationship between functional thinking and refactoring.&#13;
Refactoring is a rearrangement of our code, and where that code represents actions (<a data-type="xref" href="ch07.html#actions">“Actions”</a>)—code that depends on when you run it—the rearrangement may change when actions run, and so the functioning of the software.&#13;
In contrast, calculations<a data-primary="calculations" data-secondary="refactoring and functional thinking" data-type="indexterm" id="idm46393342442424"/><a data-primary="actions" data-secondary="refactoring and functional thinking" data-type="indexterm" id="idm46393342441416"/> (<a data-type="xref" href="ch07.html#calculations">“Calculations”</a>) are safe to rearrange but are ultimately impotent.&#13;
(Without reading and writing, our code is simply generating heat.)&#13;
Functional thinking encourages us to recognize and control actions and, by doing so, makes refactoring much safer.</p>&#13;
&#13;
<p>Your authors learned this the hard way.&#13;
We learned to refactor in the days of mutable objects, and introduced bugs when we failed to predict the consequences.&#13;
This could have led us to abandon refactoring, but we still weren’t clever enough to design our systems right in the first place.&#13;
Instead, we discovered that a certain style of &#13;
<span class="keep-together">programming</span>—object orientation but with immutable objects—was expressive and understandable, refactorable and safe.&#13;
When we adopted that style in our Java code, it was often working against the grain, but despite this, it was much more productive than the alternatives.&#13;
Discovering Kotlin, we realized that this is the sweet spot for us.&#13;
Now we can use a modern language where functional thinking is part of the design, objects are still well-supported, and refactoring tooling is not an afterthought.<a data-primary="checked exceptions" data-see="also throwing to returning" data-type="indexterm" id="idm46393342436760"/><a data-primary="collections" data-see="also encapsulated collections to type aliases" data-type="indexterm" id="idm46393342435768"/><a data-primary="data classes" data-see="also open to sealed classes; performing I/O to passing data" data-type="indexterm" id="idm46393342434728"/><a data-primary="error handling" data-see="also exceptions to values; throwing to returning" data-type="indexterm" id="idm46393342433816"/><a data-primary="exceptions" data-see="also exceptions to values; throwing to returning" data-type="indexterm" id="idm46393342432840"/><a data-primary="exceptions to values" data-see="also exceptions" data-type="indexterm" id="idm46393342431864"/><a data-primary="functions" data-see="also functions to extension functions; functions to operators; interfaces to functions; multi- to single-expression functions" data-type="indexterm" id="idm46393342430920"/><a data-primary="functions to extension functions" data-see="also functions; functions to operators" data-type="indexterm" id="idm46393342430248"/><a data-primary="functions to operators" data-see="also functions; functions to extension functions" data-type="indexterm" id="idm46393342428984"/><a data-primary="I/O errors" data-see="also performing I/O to passing data" data-type="indexterm" id="idm46393342428008"/><a data-primary="iterables" data-see="streams to iterables to sequences" data-type="indexterm" id="idm46393342427048"/><a data-primary="mutability" data-see="also accumulating objects to transformations" data-type="indexterm" id="idm46393342426088"/><a data-primary="sequences" data-see="also streams to iterables to sequences" data-type="indexterm" id="idm46393342425112"/><a data-primary="top-level functions" data-see="also static methods to top level functions" data-type="indexterm" id="idm46393342424152"/><a data-primary="transformations" data-see="also accumulating objects to transformations" data-type="indexterm" id="idm46393342423176"/><a data-primary="type aliases" data-see="also encapsulated collections to type aliases" data-type="indexterm" id="idm46393342422200"/><a data-primary="performing I/O to passing data" data-see="also data classes" data-type="indexterm" id="idm46393342421224"/><a data-primary="data" data-see="values" data-type="indexterm" id="idm46393342420264"/></p>&#13;
&#13;
<p>As Kent Beck put it: “Make the change easy, then make the easy change.”&#13;
Continually refactor so that every change you need to make is an easy change.&#13;
Refactoring is the fundamental practice for tackling the inherent complexity of our software.</p>&#13;
&#13;
<p>Safe travels.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section></body></html>