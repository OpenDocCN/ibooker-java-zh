["```java\npublic class EmailAddress {\n    private final String localPart; ![1](assets/1.png)\n    private final String domain;\n\n    public static EmailAddress parse(String value) { ![2](assets/2.png)\n        var atIndex = value.lastIndexOf('@');\n        if (atIndex < 1 || atIndex == value.length() - 1)\n            throw new IllegalArgumentException(\n                \"EmailAddress must be two parts separated by @\"\n            );\n        return new EmailAddress(\n            value.substring(0, atIndex),\n            value.substring(atIndex + 1)\n        );\n    }\n\n    public EmailAddress(String localPart, String domain) { ![3](assets/3.png)\n        this.localPart = localPart;\n        this.domain = domain;\n    }\n\n    public String getLocalPart() { ![4](assets/4.png)\n        return localPart;\n    }\n\n    public String getDomain() { ![4](assets/4.png)\n        return domain;\n    }\n\n    @Override\n    public boolean equals(Object o) { ![5](assets/5.png)\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        EmailAddress that = (EmailAddress) o;\n        return localPart.equals(that.localPart) &&\n            domain.equals(that.domain);\n    }\n\n    @Override\n    public int hashCode() { ![5](assets/5.png)\n        return Objects.hash(localPart, domain);\n    }\n\n    @Override\n    public String toString() { ![6](assets/6.png)\n        return localPart + \"@\" + domain;\n    }\n}\n```", "```java\nclass EmailAddress(val localPart: String, val domain: String) {\n    override fun equals(o: Any?): Boolean {\n        if (this === o) return true\n        if (o == null || javaClass != o.javaClass) return false\n        val that = o as EmailAddress\n        return localPart == that.localPart && domain == that.domain\n    }\n\n    override fun hashCode(): Int {\n        return Objects.hash(localPart, domain)\n    }\n\n    override fun toString(): String {\n        return \"$localPart@$domain\"\n    }\n\n    companion object {\n        @JvmStatic\n        fun parse(value: String): EmailAddress {\n            val atIndex = value.lastIndexOf('@')\n            require(!(atIndex < 1 || atIndex == value.length - 1)) {\n                \"EmailAddress must be two parts separated by @\"\n            }\n            return EmailAddress(\n                value.substring(0, atIndex),\n                value.substring(atIndex + 1)\n            )\n        }\n    }\n}\n```", "```java\nprivate final String localPart;\nprivate final String domain;\n\npublic EmailAddress(String localPart, String domain) {\n    this.localPart = localPart;\n    this.domain = domain;\n}\n\npublic String getLocalPart() {\n    return localPart;\n}\n\npublic String getDomain() {\n    return domain;\n}\n```", "```java\nclass EmailAddress(\n    val localPart: String,\n    val domain: String\n) {\n\n    override fun equals(o: Any?): Boolean {\n        if (this === o) return true\n        if (o == null || javaClass != o.javaClass) return false\n        val that = o as EmailAddress\n        return localPart == that.localPart && domain == that.domain\n    }\n\n    override fun hashCode(): Int {\n        return Objects.hash(localPart, domain)\n    }\n\n    override fun toString(): String {\n        return \"$localPart@$domain\"\n    }\n\n    companion object {\n        @JvmStatic\n        fun parse(value: String): EmailAddress {\n            val atIndex = value.lastIndexOf('@')\n            require(!(atIndex < 1 || atIndex == value.length - 1)) {\n                \"EmailAddress must be two parts separated by @\"\n            }\n            return EmailAddress(\n                value.substring(0, atIndex),\n                value.substring(atIndex + 1)\n            )\n        }\n    }\n}\n```", "```java\npublic class EmailAddressTests {\n\n    @Test\n    public void parsing() {\n        assertEquals(\n            new EmailAddress(\"fred\", \"example.com\"),\n            EmailAddress.parse(\"fred@example.com\")\n        );\n    }\n\n    @Test\n    public void parsingFailures() {\n        assertThrows(\n            IllegalArgumentException.class,\n            () -> EmailAddress.parse(\"@\")\n        );\n        ...\n    }\n\n    ...\n}\n```", "```java\npublic class Marketing {\n\n    public static boolean isHotmailAddress(EmailAddress address) {\n        return address.getDomain().equalsIgnoreCase(\"hotmail.com\");\n    }\n}\n```", "```java\ndata class EmailAddress(\n    val localPart: String,\n    val domain: String\n) {\n\n    override fun toString(): String { ![1](assets/1.png)\n        return \"$localPart@$domain\"\n    }\n\n    companion object {\n        @JvmStatic\n        fun parse(value: String): EmailAddress {\n            val atIndex = value.lastIndexOf('@')\n            require(!(atIndex < 1 || atIndex == value.length - 1)) {\n                \"EmailAddress must be two parts separated by @\"\n            }\n            return EmailAddress(\n                value.substring(0, atIndex),\n                value.substring(atIndex + 1)\n            )\n        }\n    }\n}\n```", "```java\nval postmasterEmail = customerEmail.copy(localPart = \"postmaster\")\n```", "```java\npublic class Money {\n    private final BigDecimal amount;\n    private final Currency currency;\n\n    private Money(BigDecimal amount, Currency currency) { ![1](assets/1.png)\n        this.amount = amount;\n        this.currency = currency;\n    }\n\n    public static Money of(BigDecimal amount, Currency currency) { ![1](assets/1.png)\n        return new Money(\n            amount.setScale(currency.getDefaultFractionDigits()),\n            currency);\n    }\n\n    ... and convenience overloads\n\n    public BigDecimal getAmount() { ![2](assets/2.png)\n        return amount;\n    }\n\n    public Currency getCurrency() { ![3](assets/3.png)\n        return currency;\n    }\n\n    @Override\n    public boolean equals(Object o) { ![3](assets/3.png)\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Money money = (Money) o;\n        return amount.equals(money.amount) &&\n            currency.equals(money.currency);\n    }\n\n    @Override\n    public int hashCode() { ![3](assets/3.png)\n        return Objects.hash(amount, currency);\n    }\n\n    @Override\n    public String toString() { ![4](assets/4.png)\n        return amount.toString() + \" \" + currency.getCurrencyCode();\n    }\n\n    public Money add(Money that) { ![5](assets/5.png)\n        if (!this.currency.equals(that.currency)) {\n            throw new IllegalArgumentException(\n                \"cannot add Money values of different currencies\");\n        }\n\n        return new Money(this.amount.add(that.amount), this.currency);\n    }\n}\n```", "```java\n amount.withScale(currency.getDefaultFractionDigits())\n```", "```java\nfun BigDecimal.withScale(int scale, RoundingMode mode) =\n    setScale(scale, mode)\n```", "```java\nclass Money\nprivate constructor(\n    val amount: BigDecimal,\n    val currency: Currency\n) {\n    override fun equals(o: Any?): Boolean {\n        if (this === o) return true\n        if (o == null || javaClass != o.javaClass) return false\n        val money = o as Money\n        return amount == money.amount && currency == money.currency\n    }\n\n    override fun hashCode(): Int {\n        return Objects.hash(amount, currency)\n    }\n\n    override fun toString(): String {\n        return amount.toString() + \" \" + currency.currencyCode\n    }\n\n    fun add(that: Money): Money {\n        require(currency == that.currency) {\n            \"cannot add Money values of different currencies\"\n        }\n        return Money(amount.add(that.amount), currency)\n    }\n\n    companion object {\n        @JvmStatic\n        fun of(amount: BigDecimal, currency: Currency): Money {\n            return Money(\n                amount.setScale(currency.defaultFractionDigits),\n                currency\n            )\n        }\n\n        ... and convenience overloads\n    }\n}\n```", "```java\nPrivate data class constructor is exposed via the generated 'copy' method.\"\n```"]