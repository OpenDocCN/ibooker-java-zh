- en: 'Chapter 9\. Functional Programming Techniques: Functional Interfaces, Streams,
    and Parallel Collections'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 9.0 Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Java is an Object-Oriented (OO) language. You know what that is. Functional
    Programming (FP) has been attracting attention lately. There may not be quite
    as many definitions of FP as there are FP languages, but it’s close. Wikipedia’s
    definition of functional programming is as follows (from [*https://en.wikipedia.org/wiki/Functional_programming*](https://en.wikipedia.org/wiki/Functional_programming),
    viewed December 2013):'
  prefs: []
  type: TYPE_NORMAL
- en: a programming paradigm, a style of building the structure and elements of computer
    programs, that treats computation as the evaluation of mathematical functions
    and avoids state and mutable data. Functional programming emphasizes functions
    that produce results that depend only on their inputs and not on the program state—i.e.
    pure mathematical functions. It is a declarative programming paradigm, which means
    programming is done with expressions. In functional code, the output value of
    a function depends only on the arguments that are input to the function, so calling
    a function f twice with the same value for an argument x will produce the same
    result f(x) both times. Eliminating side effects, i.e. changes in state that don’t
    depend on the function inputs, can make it much easier to understand and predict
    the behavior of a program, which is one of the key motivations for the development
    of functional programming.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How can we benefit from the FP paradigm? One way would be to switch to using
    an FP language; some of the leading ones are Haskell,^([1](ch09.html#idm45290660939720))
    Idris, Ocaml, Erlang, Julia, and the LISP family. But most of those would require
    walking away from the Java ecosystem. You could consider using [Scala](http://www.scala-lang.org)
    or [Clojure](http://clojure.org), JVM-based languages that provide functional
    programming support in the context of an OO language. And there is [Kotlin](https://kotlinlang.org),
    the latest Java-like language for the JVM.
  prefs: []
  type: TYPE_NORMAL
- en: 'But this is the *Java Cookbook*, so you can imagine we’re going to try to get
    as many benefits of functional programming as we can while remaining in the Java
    language. Some features of FP include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Pure functions having no side effects and whose results depend only on their
    inputs and not on mutable state elsewhere in the program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First-class functions (e.g., functions as data)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Immutable data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extensive use of recursion and lazy evaluation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Pure functions* are completely self-contained; their operation depends only
    on the input parameters and internal logic, not on any variable state in other
    parts of the program—indeed, there are no global variables, only global *constants*.
    Although this can be hard to accept for those schooled in imperative languages
    like Java, it does make it much easier to test and ensure program correctness!
    It means that, no matter what else is going on in the program (even with multiple
    threads), a method call like `computeValue(27)` will always, unconditionally,
    return the same value every time (with exceptions, of course, for things like
    the current time, random seeds, etc., which are global state).'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use the terms *function* and *method* interchangeably in this chapter,
    although it’s not strictly correct. FP people use the term *function* in the mathematical
    function sense, whereas in Java *methods* just means some code you can call (a
    Java method call is also referred to as a *message* being *sent* to an object,
    in the OO view of things).
  prefs: []
  type: TYPE_NORMAL
- en: '*Functions as data* means that you can create *an object that is a function*,
    pass it into another function, write a function that returns another function,
    and so on—with no special syntax, because, well, functions *are* data.'
  prefs: []
  type: TYPE_NORMAL
- en: One of Java’s approaches to FP is the definition of functional interfaces. A
    *functional interface* in Java is one that has only one abstract method, such
    as the widely used `Runnable`, whose only method is `run()`, or the common Swing
    action handler `ActionListener`, whose only method is `actionPerformed(ActionEvent)`.
    Actually, also new in Java 8, interfaces can have methods annotated with the new-in-this-context
    `default` keyword. A `default` method in an interface becomes available for use
    in any class that `implements` the interface. Such methods cannot depend on instance
    state in a particular class because they would have no way of referring to it
    at compile time.
  prefs: []
  type: TYPE_NORMAL
- en: So a functional interface is more precisely defined as one that has a single
    nondefault method. You can do functional-style programming in Java if you use
    functional interfaces and if you restrict code in your methods to not depending
    on any nonfinal instance or class fields; using default methods is one way of
    achieving this. The first few recipes in this chapter discuss functional interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another Java approach to functional-ness is lambda expressions. A lambda is
    an expression of a functional interface, and it can be used as data (i.e., assigned,
    returned, etc.). Just to give a couple of short examples for now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Immutable data is easy in theory: just have a class with only read accessors
    (“get” methods). The standard `String` class, for example, is immutable: methods
    like `substring()` or `toUpperCase()` don’t change the original string, but make
    up new string objects with the requested change. Yet strings are universally used,
    and useful. Enums are also implicitly immutable. There is a proposal to add a
    new kind of class-like object called a `record` in Java 14 or 15. `record`s are
    implicitly immutable; the compiler generates “get” methods for the fields (along
    with a constructor and the three common `Object` methods), but not “set” methods.'
  prefs: []
  type: TYPE_NORMAL
- en: Also new in Java 8 is the notion of `Stream` classes. A `Stream` is like a pipeline
    that you can feed into, fan out, collect down—like a cross between the Unix notion
    of pipelines and Google’s distributed programming concept of MapReduce, as exemplified
    in [Hadoop](http://hadoop.apache.org), but running in a single VM, a single program.
    `Stream`s can be sequential or parallel; the latter are designed to take advantage
    of the massive parallelism that is happening in hardware design (particularly
    servers, where 12- and 16-core processors are popular). We discuss `Stream`s in
    several recipes in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re familiar with Unix pipes and filters, this equivalence will make
    sense to you; if not, you can skip it for now. The Unix command is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The Java `Stream`s equivalent is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: These commands are written out in more idiomatic Java in [Example 9-1](#javacook-fp-unixpipes).
    Both approaches give the same answer. For small inputs, the Unix pipeline is faster;
    but for larger volumes, the Java one should be faster, especially when parallelized.
  prefs: []
  type: TYPE_NORMAL
- en: Example 9-1\. main/src/main/java/functional/UnixPipesFiltersReplacement.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Tied in with `Stream`s is the notion of a `Spliterator`, a derivative (logically,
    not by inheritance) of the familiar `Iterator` but designed for use in parallel
    processing. Most users will not be expected to develop their own `Spliterator`
    and will likely not even call its methods directly very often, so we do not discuss
    them in detail.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For general information on functional programming, see the book *[Functional
    Thinking](http://shop.oreilly.com/product/0636920029687.do)* by Neal Ford (O’Reilly).
  prefs: []
  type: TYPE_NORMAL
- en: There is an entire book dedicated to lambda expressions and related tools, Richard
    Warburton’s *[Java 8 Lambdas](http://shop.oreilly.com/product/0636920030713.do)*
    (O’Reilly).
  prefs: []
  type: TYPE_NORMAL
- en: 9.1 Using Lambdas/Closures Instead of Inner Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to avoid all the typing that even the anonymous style of inner class
    requires.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use Java’s lambda expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The symbol lambda (λ) is the 11th letter of the Greek alphabet and thus as
    old as Western society. The [Lambda calculus](http://en.wikipedia.org/wiki/Lambda_calculus)
    is about as old as our notions of computing. In this context, Lambda expressions
    are small units of calculation that can be referred to. They are functions as
    data. In that sense, they are a lot like anonymous inner classes, though it’s
    probably better to think of them as *anonymous methods*. They are essentially
    used to replace inner classes for a *functional interface*—that is, an interface
    with one abstract method (function) in it. A very common example is the AWT `ActionListener`
    interface, widely used in GUI code, whose only method is this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Using lambdas is now the preferred method of writing for GUI action listeners.
    Here’s a single example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Because not everybody writes Swing GUI applications these days, let’s start
    with an example that doesn’t require GUI programming. Suppose we have a collection
    of camera model descriptor objects that has already been loaded from a database
    into memory, and we want to write a general-purpose API for searching them, for
    use by other parts of our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thought might be along the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Perhaps you can already see the problem. You will also need to write `findByPrice()`,
    `findByMakeAndModel()`, `findByYearIntroduced()`, and so on as your application
    grows in complexity.
  prefs: []
  type: TYPE_NORMAL
- en: You could consider implementing a query by example method, where you pass in
    a `Camera` object and all its nonnull fields are used in the comparison. But then
    how would you implement finding cameras with interchangeable lenses *under $500*?^([2](ch09.html#idm45290660596184))
  prefs: []
  type: TYPE_NORMAL
- en: 'So a better approach is probably to use a callback function to do the comparison.
    Then you can provide an anonymous inner class to do any kind of searching you
    need. You’d want to be able to write callback methods like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Accordingly, we’ll build that into an interface:^([3](ch09.html#idm45290660542184))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the search application provides a method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'which we can call with code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, if you were not comfortable with anonymous inner classes, you might have
    to type this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s really a great deal of typing just to get one method packaged up for
    sending into the search engine. Java’s support for lambda expressions or closures
    was argued about for many years (literally) before the experts agreed on how to
    do it. And the result is staggeringly simple. One way to think of Java lambda
    expressions is that each one is just a method that implements a functional interface.
    With lambda expressions, you can rewrite the preceding code as just:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The arrow notation -> indicates the code to execute. If it’s a simple expression
    as here, you can just write it as shown. If there is conditional logic or other
    statements, you have to use a block, as is usual in Java.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here I just rewrite the search example to show it as a block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The first `c` inside the parenthesis corresponds to `Camera c` in the explicitly
    implemented `choose()` method: you can omit the type because the compiler knows
    it! If there is more than one argument to the method, you must parenthesize them.
    Suppose we had a compare method that takes two cameras and returns a quantitative
    value (oh, and good luck trying to get two photographers to agree on *that* algorithm!):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This notion of *lambdas* seems pretty potent, and it is! You will see much more
    of this in Java as Java 8 moves into the mainstream of computing.
  prefs: []
  type: TYPE_NORMAL
- en: Up to here, we still have to write an interface for each type of method that
    we want to be able to lambda-ize. The next recipe shows some predefined interfaces
    that you can use to further simplify (or at least shorten) your code.
  prefs: []
  type: TYPE_NORMAL
- en: And, of course, there are many existing interfaces that are functional, such
    as the `ActionListener` interface from GUI applications. Interestingly, the IntelliJ
    IDE (see [Recipe 1.3](ch01.html#javacook-getstarted-SECT-3)) automatically recognizes
    inner class definitions that are replaceable by lambdas and, when using *code
    folding* (the IDE feature of representing an entire method definition with a single
    line), replaces the inner class with the corresponding lambda! Figures [9-1](#javacook-lambda-intellij-f1)
    and [9-2](#javacook-lambda-intellij-f2) show a before-and-after picture of this
    code folding.
  prefs: []
  type: TYPE_NORMAL
- en: '![jcb4 0901](assets/jcb4_0901.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-1\. IntelliJ code unfolded
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '![jcb4 0902](assets/jcb4_0902.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-2\. IntelliJ code folded
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 9.2 Using Lambda Predefined Interfaces Instead of Your Own
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to use existing interfaces, instead of defining your own, for use with
    Lambdas.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the Java 8 lambda functional interfaces from `java.util.function`.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In [Recipe 9.1](#javacook-lambda-interfaces), we used the interface method
    `acceptCamera()` defined in the interface `CameraAcceptor`. Acceptor-type methods
    are quite common, so the package `java.util.function` includes the `Predicate<T>`
    interface, which we can use instead of `CameraAcceptor`. This interface has only
    one method—`boolean test(T t)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This package includes about 50 of the most commonly needed functional interfaces,
    such as `IntUnaryOperator`, which takes one `int` argument and returns an `int`
    value; `LongPredicate`, which takes one `long` and returns `boolean`; and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the `Predicate` interface, as with any generic type, we provide an actual
    type for the parameter `Camera`, giving us (in this case) the parameterized type
    `Predicate<Camera>`, which is the following (although we don’t have to write this
    out):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'So now our search application will be changed to offer us the following search
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Conveniently, this has the same signature as our own `CameraAcceptor` from
    the point of view of the anonymous methods that lambdas implement, so the rest
    of our code doesn’t have to change! This is still a valid call to the `search()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the implementation of the `search` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*main/src/main/java/functional/CameraSearchPredicate.java*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Suppose we only need the list to do one operation on each element, and then
    we’ll discard it. Upon reflection, we don’t actually need to get the list back;
    we merely need to get our hooks on each element that matches our `Predicate` in
    turn.
  prefs: []
  type: TYPE_NORMAL
- en: Roll Your Own Functional Interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While the JDK provides a good set of functional interfaces, there may be cases
    where you’d want to create your own. This is a simple example of a functional
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `@FunctionalInterface` annotation tells the compiler to ensure that a given
    interface is and remains functional. Its use is analogous to `@Override` (both
    annotations are in `java.lang`). It is always optional.
  prefs: []
  type: TYPE_NORMAL
- en: '`MyFunctionalInterface` could be used to process an array of integers, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: If `compute` were a nonfunctional interface—having multiple abstract methods—you
    would not be able to use it in this fashion.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, of course, you really do need an interface to have more than one
    method. In that case, the illusion (or the effect) of functionality can sometimes
    be preserved by denoting all but one of the methods with the default keyword—the
    nondefault method will still be usable in lambdas. A default method has a method
    body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Only default methods may contain executable statements, and there may only be
    one nondefault method per functional interface.
  prefs: []
  type: TYPE_NORMAL
- en: By the way, the `MyFunctionalInterface` given earlier can be totally replaced
    by `java.util.function.IntUnaryOperator`, changing the method name `apply()` to
    `applyAsInt()`. There is a version of the `ProcessInts` program under the name
    `ProcessIntsIntUnaryOperator` in the *javasrc* repository.
  prefs: []
  type: TYPE_NORMAL
- en: Default methods in interfaces can be used to produce *mixins*, as described
    in [Recipe 9.7](#fp-mixins-sect1).
  prefs: []
  type: TYPE_NORMAL
- en: 9.3 Simplifying Processing with Streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to process some data through a pipeline-like mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use a `Stream` class and its operations.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Streams* are a new mechanism introduced with Java 8 to allow a collection
    to send its values out one at a time through a pipeline-like mechanism where they
    can be processed in various ways, with varying degrees of parallelism. There are
    three types of methods involved with `Stream`s:'
  prefs: []
  type: TYPE_NORMAL
- en: Stream-producing methods (see [Recipe 7.3](ch07.html#javacook-structure-collections)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stream-passing methods, which operate on a Stream and return a reference to
    it, in order to allow for *fluent programming* (chained methods calls); examples
    include `distinct()`, `filter()`, `limit()`, `map()`, `peek()`, `sorted()`, and
    `unsorted()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stream-terminating methods, which conclude a streaming operation; examples include
    `collect()`, `count()`, `findFirst()`, `max()`, `min()`, `reduce()`, and `sum()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In [Example 9-2](#javacook-fp-streams-ex), we have a list of `Hero` objects
    representing superheroes through the ages. We use the `Stream` mechanism to filter
    just the adult heroes and then sum their ages. We use it again to sort the heroes’
    names alphabetically.
  prefs: []
  type: TYPE_NORMAL
- en: In both operations we start with a stream generator (`Arrays.stream()`); we
    run it through several steps, one of which involves a mapping operation (don’t
    confuse with `java.util.Map`!) that causes a different value to be sent along
    the pipeline. The stream is wrapped up by a terminal operation. The map and filter
    operations almost invariably are controlled by a lambda expression (inner classes
    would be too tedious to use in this style of programming!).
  prefs: []
  type: TYPE_NORMAL
- en: Example 9-2\. main/src/main/java/functional/SimpleStreamDemo.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'And let’s run it to be sure it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: See the javadoc for the `java.util.stream.Stream` interface for a complete list
    of the operations.
  prefs: []
  type: TYPE_NORMAL
- en: 9.4 Simplifying Streams with Collectors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You construct Streams but they are complicated or inefficient.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use `Collector`s.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Example 9-2](#javacook-fp-streams-ex) ended the first half with a call to
    `collect()`. The argument to `collect()` is of type `Collector`, which this recipe
    considers in more detail. `Collector`s are a form of what classical FP languages
    call [*folds*](https://en.wikipedia.org/wiki/Fold_(higher-order_function)). Folds
    are also called reduce, accumulate, aggregate, compress, or inject operations.
    A *fold* in functional programming is a terminal operation, analogous to collapsing
    a whole string of tickets into a flat pile (see [Figure 9-3](#javacook-fp-FIG-folds)).
    The string of tickets represents the `Stream`, the folding operation is represented
    by a function, and the final result is, well, the final result, all folded up.
    It will often include a combining operation, analogous to counting the tickets
    as they are folded.'
  prefs: []
  type: TYPE_NORMAL
- en: '![folds](assets/folds.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-3\. Stream of tickets before folding, during folding, and after folding:
    a terminal operation'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note that in the first panel of [Figure 9-3](#javacook-fp-FIG-folds) we don’t
    know how long the `Stream` is, but we expect that it will terminate eventually.
  prefs: []
  type: TYPE_NORMAL
- en: '*Collector* as used in Java refers to a terminal function that analyses/summarizes
    the content of a `Stream`. Technically, `Collector` is an interface whose implementation
    is specified by three (or four) functions that work together to accumulate entries
    into a Collection or Map or other mutable result container, and optionally a final
    transform on the result. The functions are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new result container (the `supplier()`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a new data element into the result container (the `accumulator()`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combining two result *containers* into one (the `combiner()`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing a final transform on the container (the `finisher()`, which is optional)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'While you can easily compose your own `Collector` implementation, it is often
    expedient to use one of the many useful ones predefined in the `Collectors` class.
    Here are a couple of simple examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In [Example 9-3](#javacook-functional-EX-wordfreq) I implement the classic
    *word frequency count* algorithm: take a text file, break it into individual words,
    count the occurrence of each word, and list the *n* most-used words, sorted by
    frequency in descending order.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Unix terms this could be implemented (assuming *n* = 20) as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: where `prep` is a script that uses the Unix tool `tr` to break lines into words
    and turn the words into lowercase.
  prefs: []
  type: TYPE_NORMAL
- en: Example 9-3\. main/src/main/java/functional/WordFreq.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: There are two steps. First, create a map of the words and their frequencies.
    Second, sort these in reverse order, stop at number 20, and format them neatly
    and print.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part uses `Files.lines()` from [Chapter 10](ch10.html#javacook-io)
    to get a `Stream` of `Strings`, which is broken into individual words using the
    `Stream` method `flatMap()` combined with the `String` method `split()` to break
    on one or more spaces. The result of that is collected into a map using a `Collector`.
    I had initially used a homemade collector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This form of `collect()` takes three arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: A `Supplier<R>` or factory method to create an empty container; here I’m just
    using the `HashMap` constructor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An accumulator of type `BiConsumer<R,? super T>` to add each element into the
    map, adding one each time the same word is found.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Combiner of type `BiConsumer<R,R> combiner)` to combine all the collections
    used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the case of parallel streams (see [Recipe 9.5](#javacook-functional-parallel_collections)),
    the `Supplier` may be called multiple times to create multiple containers, and
    each part of the Stream’s content will be handled by one Accumulator into one
    of the containers. The `Combiner` will merge all the containers into one at the
    end of processing.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, Sander Mak pointed out that it’s easier to use the existing `Collectors`
    class’s predefined Collector `groupingBy`, combining the `toLowerCase()` call
    and the `collect()` call with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'To further simplify the code, you could combine the two statements into one,
    by doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Removing the return value and assignment `Map<String,Long> =`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing the semicolon from the end of the `collect` call
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing the `.map()` from the `entrySet()` call
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then you can say you’ve implemented something useful in a single Java statement!
  prefs: []
  type: TYPE_NORMAL
- en: 9.5 Improving Throughput with Parallel Streams and Collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to combine `Stream`s with parallelism and still be able to use the
    non-thread-safe Collections API.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use a parallel stream.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The standard Collections classes, such as most `List`, `Set`, and `Map` implementations,
    are not thread-safe for update; if you add or remove objects from one in one thread
    while another thread is accessing the objects stored in the collection, failure
    will result. Multiple threads reading from the same collection with no modification
    is OK. We discuss multithreading in [Chapter 16](ch16.html#javacook-threads).
  prefs: []
  type: TYPE_NORMAL
- en: The Collections Framework does provide *synchronized wrappers*, which provide
    automatic synchronization but at the cost of adding thread contention, which reduces
    parallelism. To enable efficient operations, *parallel streams* let you use the
    non-thread-safe collections safely, as long as you do not modify the collection
    while you are operating on it.
  prefs: []
  type: TYPE_NORMAL
- en: To use a parallel stream, you just ask the collection for it, using `parallelStream()`
    instead of the `stream()` method we used in [Recipe 9.3](#javacook-fp-streams1-1).
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, suppose that our camera business takes off, and we need to find
    cameras by type and price range *quickly* (and with less code than we used before):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_functional_programming_techniques__functional_interfaces__streams___span_class__keep_together__and_parallel_collections__span__CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Create a parallel stream from the `List` of `Camera` objects. The end result
    of the stream will be iterated over by the foreach loop.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_functional_programming_techniques__functional_interfaces__streams___span_class__keep_together__and_parallel_collections__span__CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Filter the cameras on price, using the same `Predicate` lambda that we used
    in [Recipe 9.1](#javacook-lambda-interfaces).
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_functional_programming_techniques__functional_interfaces__streams___span_class__keep_together__and_parallel_collections__span__CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Terminate the `Stream` by converting it to an array.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_functional_programming_techniques__functional_interfaces__streams___span_class__keep_together__and_parallel_collections__span__CO1-4)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The body of the foreach loop: print one `Camera` from the `Stream`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_functional_programming_techniques__functional_interfaces__streams___span_class__keep_together__and_parallel_collections__span__CO1-5)'
  prefs: []
  type: TYPE_NORMAL
- en: A more concise way of writing the search.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This is reliable as long as no thread is modifying the data at the same time
    as the searching is going on. See the thread interlocking mechanisms in [Chapter 16](ch16.html#javacook-threads)
    to see how to ensure this.
  prefs: []
  type: TYPE_NORMAL
- en: 9.6 Using Existing Code as Functional with Method References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have existing code that matches a functional interface and want to use it
    without renaming methods to match the interface name.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use function references such as `MyClass::myFunc` or `someObj::someFunc`.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The word *reference* is almost as overloaded in Java as the word *Session*.
    Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Ordinary objects are usually accessed with references.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reference types such as `WeakReference` have defined semantics for garbage collection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And now, for something completely different, Java 8 lets you reference an individual
    method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can even reference what Oracle documentation calls “an Instance Method of
    an Arbitrary Object of a Particular Type.”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The new syntax consists of an object or class name, two colons, and the name
    of a method that can be invoked in the context of the object or class name (as
    per the usual rules of Java, a class name can refer to static methods and an instance
    can refer to an instance method). To refer to a constructor as the method, you
    can use `new`—for example, `MyClass::new`. The reference creates a lambda that
    can be invoked, stored in a variable of a functional interface type, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: In [Example 9-4](#javacook-fp-refs-ex1), we create a `Runnable` reference that
    holds, not the usual `run` method, but a method with the same type and arguments
    but with the name `walk`. Note the use of `this` as the object part of the method
    reference. We then pass this `Runnable` into a `Thread` constructor and start
    the thread, with the result that `walk` is invoked where `run` would normally
    be.
  prefs: []
  type: TYPE_NORMAL
- en: Example 9-4\. main/src/main/java/functional/ReferencesDemo.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 9-5](#javacook-fp-refs-ex2) creates an `AutoCloseable` for use in
    a try-with-resource. The normal `AutoCloseable` method is `close()`, but ours
    is named `cloz()`. The `AutoCloseable` reference variable `autoCloseable` is created
    inside the `try` statement, so its close-like method will be called when the body
    completes. In this example, we are in a static `main` method wherein we have a
    reference `rnd2` to an instance of the class, so we use this in referring to the
    `AutoCloseable`-compatible method.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 9-5\. main/src/main/java/functional/ReferencesDemo2.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: It is, of course, possible to use this with your own functional interfaces,
    defined as in [“Roll Your Own Functional Interface”](#javacook-lambda-interfacesb-4).
    You’re also probably at least vaguely aware that any normal Java object reference
    can be passed to `System.out.println()` and you’ll get some description of the
    referenced object. [Example 9-6](#javacook-fp-refs-ex3) explores these two themes.
    We define a functional interface imaginatively known as `FunInterface` with a
    method with a bunch of arguments (merely to avoid it being mistaken for any existing
    functional interface). The method name is `process`, but as you now know the name
    is not important; our implementation method goes by the name `work`. The `work`
    method is static, so we could not state that the class `implements FunInterface`
    (even if the method names were the same; a static method may not hide an inherited
    instance method), but we can nonetheless create a lambda reference to the `work`
    method. We then print this out to show that it has a valid structure as a Java
    object.
  prefs: []
  type: TYPE_NORMAL
- en: Example 9-6\. main/src/main/java/functional/ReferencesDemo3.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This generates the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The `Lambda$1` in the name is structurally similar to the “$1” used in anonymous
    inner classes.
  prefs: []
  type: TYPE_NORMAL
- en: The fourth way, “an Instance Method of an Arbitrary Object of a Particular Type,”
    may be the most esoteric thing in all of Java 8\. It allows you to declare a reference
    to an instance method but without specifying which instance. Because there is
    no particular instance in mind, you again use the class name. This means you can
    use it with any instance of the given class! In [Example 9-7](#javacook-fp-refs-ex4),
    we have an array of `String`s to sort. Because the names in this array can begin
    with a lowercase letter, we want to sort them using the `String` method `compareToIgnoreCase()`,
    which nicely ignores case differences for us.
  prefs: []
  type: TYPE_NORMAL
- en: Because I want to show the sorting several different ways, I set up two array
    referencess, the original, unsorted one, and a working one that is re-created,
    sorted, and printed using a simple dump routine, which isn’t shown (it’s just
    a `for` loop printing the strings from the passed array).
  prefs: []
  type: TYPE_NORMAL
- en: Example 9-7\. main/src/main/java/functional/ReferencesDemo4.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_functional_programming_techniques__functional_interfaces__streams___span_class__keep_together__and_parallel_collections__span__CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Using “an Instance Method of an Arbitrary Object of a Particular Type,” declares
    a reference to the `compareToIgnoreCase` method of any `String` used in the invocation.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_functional_programming_techniques__functional_interfaces__streams___span_class__keep_together__and_parallel_collections__span__CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Shows the equivalent lambda expression.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_functional_programming_techniques__functional_interfaces__streams___span_class__keep_together__and_parallel_collections__span__CO2-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Shows “Your grandparents’ Java” way of doing things.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_functional_programming_techniques__functional_interfaces__streams___span_class__keep_together__and_parallel_collections__span__CO2-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Using the exported `Comparator` directly, just to show that there is always
    more than one way to do things.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just to be safe, I ran the demo, and got the expected output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '9.7 Java Mixins: Mixing in Methods'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You’ve heard about mixins and want to apply them in Java.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use static imports. Or, declare one or more functional interfaces with a default
    method containing the code to execute, and simply implement it.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Developers from other languages sometimes deride Java for its inability to handle
    mixins, the ability to mix in bits of code from other classes.
  prefs: []
  type: TYPE_NORMAL
- en: One way to implement mixins is with the *static import* feature, which has been
    in the language for a decade. This is often done in unit testing (see [Recipe
    1.10](ch01.html#javacook-getstarted-junit)). A limitation of this approach is
    that, as the name implies, the methods must be static methods, not instance methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'A newer mechanism depends on an interesting bit of fallout from the Java 8
    language changes in support of lambdas: you can now mix in code from unrelated
    places into one class. Has Java finally abandoned its staunch opposition to multiple
    inheritance? It may seem that way when you first hear it, but relax: you can only
    pull methods from multiple interfaces, not from multiple classes. If you didn’t
    know that you could have methods defined (rather than merely declared) in interfaces,
    see [“Subclass, Abstract Class, or Interface?”](ch08.html#javacook-oo-SIDEBAR-1).
    Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '*main/src/main/java/lang/MixinsDemo.java*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run this, we see the expected results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Presto—Java now supports mixins!
  prefs: []
  type: TYPE_NORMAL
- en: 'Does this mean you should go crazy trying to build interfaces with code in
    them? No. Remember this mechanism was designed to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Provide the notion of functional interfaces for use in lambda calculations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Give the ability to retrofit interfaces with new methods, without having to
    change *old* implementations. As with many changes made in Java over the years,
    backward compatibility was a huge driver.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Used sparingly, functional interfaces can provide the ability to mix in code
    to build up applications in another way than direct inheritance, aggregation,
    or AOP. Overused, it can make your code heavy, drive pre–Java 8 developers crazy,
    and lead to chaos.
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch09.html#idm45290660939720-marker)) Haskell was used to write a fairly
    complete Twitter clone in a few hundred lines; see [*https://github.com/Gabriel439/simple-twitter*](https://github.com/Gabriel439/simple-twitter).
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch09.html#idm45290660596184-marker)) If you ever have to do this kind
    of thing where the data is stored in a relational database using the Java Persistence
    API (JPA), you should check out the [Spring Data](https://spring.io/projects/spring-data)
    or [Apache DeltaSpike](http://deltaspike.apache.org) frameworks. These allow you
    to define an `interface` with method names like `findCameraByInterchangeableTrueAndPriceLessThan(double
    price)` and have the framework implement these methods for you.
  prefs: []
  type: TYPE_NORMAL
- en: '^([3](ch09.html#idm45290660542184-marker)) If you’re just not that into cameras,
    the description “Interchangeable Lens Camera (ILC)” includes two categories of
    what you might find in a camera store: traditional DSLR (Digital Single Lens Reflex)
    cameras, and the newer category of “Compact System Cameras” like the Nikon 1 and
    Z series, Sony ILCE (formerly known as NEX), and the Canon EOS-M, all of which
    are smaller and lighter than the older DSLRs.'
  prefs: []
  type: TYPE_NORMAL
