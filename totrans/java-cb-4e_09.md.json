["```java\nActionListener x = e -> System.out.println(\"You activated \" + e.getSource());\n```", "```java\npublic class RunnableLambda {\n\n    public static void main(String[] args) {\n        threadPool.submit(() -> System.out.println(\"Hello from a thread\"));\n```", "```java\ncat lines.txt | sort | uniq | wc -l\n```", "```java\njshell> long numberLines =\n    new BufferedReader(\n    new FileReader(\"lines.txt\")).lines().sorted().distinct().count();\nnumberLines ==> 5\n```", "```java\n        long numberLines = Files.lines(Path.of((\"lines.txt\")))\n            .sorted()\n            .distinct()\n            .count();\n        System.out.printf(\"lines.txt contains \" + numberLines + \" unique lines.\");\n```", "```java\npublic void actionPerformed(ActionEvent);\n```", "```java\nquitButton.addActionListener(e -> shutDownApplication(0));\n```", "```java\npublic interface CameraInfo {\n    public List<Camera> findByMake();\n    public List<Camera> findByModel();\n    ...\n}\n```", "```java\npublic boolean choose(Camera c) {\n    return c.isIlc() && c.getPrice() < 500;\n}\n```", "```java\n/** An Acceptor accepts some elements from a Collection */\npublic interface CameraAcceptor {\n    boolean choose(Camera c);\n}\n```", "```java\npublic List<Camera> search(CameraAcceptor acc);\n```", "```java\nresults = searchApp.search(new CameraAcceptor() {\n    public boolean choose(Camera c) {\n        return c.isIlc() && c.getPrice() < 500;\n    }\n}\n```", "```java\nclass MyIlcPriceAcceptor implements CameraAcceptor {\n    public boolean choose(Camera c) {\n        return c.isIlc() && c.getPrice() < 500;\n    }\n}\nCameraAcceptor myIlcPriceAcceptor = nwq MyIlcPriceAcceptor();\nresults = searchApp.search(myIlcPriceAcceptor);\n```", "```java\nresults = searchApp.search(c -> c.isIlc() && c.getPrice() < 500);\n```", "```java\nresults = searchApp.search(c -> {\n    if (c.isIlc() && c.getPrice() < 500)\n        return true;\n    else\n        return false;\n});\n```", "```java\ndouble goodness = searchApp.compare((c1, c2) -> {\n    // write some amazing code here\n});\n```", "```java\ninterface Predicate<T> {\n    boolean test(T t);\n}\n```", "```java\ninterface Predicate<Camera> {\n    boolean test(Camera c);\n}\n```", "```java\npublic List<Camera> search(Predicate p);\n```", "```java\nresults = searchApp.search(c -> c.isIlc() && c.getPrice() < 500);\n```", "```java\n    public List<Camera> search(Predicate<Camera> tester) {\n        List<Camera> results = new ArrayList<>();\n        privateListOfCameras.forEach(c -> {\n            if (tester.test(c))\n                results.add(c);\n        });\n        return results;\n    }\n```", "```java\ninterface MyFunctionalInterface {\n    int compute(int x);\n}\n```", "```java\npublic class ProcessIntsUsingFunctional {\n    static int[] integers = {1, 2, 3};\n\n    public static void main(String[] args) {\n        int total = 0;\n        for (int i : integers)\n            total += process(i, x ->  x * x + 1);\n        System.out.println(\"The total is \" + total);\n    }\n\n    private static int process(int i, MyFunctionalInterface o) {\n        return o.compute(i);\n    }\n}\n```", "```java\npublic interface ThisIsStillFunctional {\n    default int compute(int ix) { return ix * ix + 1 };\n    int anotherMethod(int y);\n}\n```", "```java\n    static Hero[] heroes = {\n        new Hero(\"Grelber\", 21),\n        new Hero(\"Roderick\", 12),\n        new Hero(\"Francisco\", 35),\n        new Hero(\"Superman\", 65),\n        new Hero(\"Jumbletron\", 22),\n        new Hero(\"Mavericks\", 1),\n        new Hero(\"Palladin\", 50),\n        new Hero(\"Athena\", 50) };\n\n    public static void main(String[] args) {\n\n        long adultYearsExperience = Arrays.stream(heroes)\n                .filter(b -> b.age >= 18)\n                .mapToInt(b -> b.age).sum();\n        System.out.println(\"We're in good hands! The adult superheros have \" +\n                adultYearsExperience + \" years of experience\");\n\n        List<Object> sorted = Arrays.stream(heroes)\n                .sorted((h1, h2) -> h1.name.compareTo(h2.name))\n                .map(h -> h.name)\n                .collect(Collectors.toList());\n        System.out.println(\"Heroes by name: \" + sorted);\n    }\n```", "```java\nWe're in good hands! The adult superheroes have 243 years of experience\nHeroes by name: [Athena, Francisco, Grelber, Jumbletron, Mavericks, Palladin,\n                 Roderick, Superman]\n```", "```java\nint howMany = cameraList.stream().collect(Collectors.counting());\ndouble howMuch = cameraList.filter(desiredFilter).\n\tcollect(Collectors.summingDouble(Camera::getPrice);\n```", "```java\nprep $file | sort | uniq -c | sort -nr | head -20\n```", "```java\npackage functional;\n\nimport java.io.*;\nimport java.nio.file.*;\nimport java.util.*;\nimport java.util.stream.*;\n\n/**\n * Implement word frequency count, in two statements\n */\npublic class WordFreq {\n    public static void main(String[] args) throws IOException {\n\n        // 1) Collect words with a mutable reduction into Map<String,Long>.\n        Map<String,Long> map = Files.lines(Path.of(args[0]))\n            .flatMap(s -> Stream.of(s.split(\" +\")))\n            .collect(Collectors.groupingBy(\n                String::toLowerCase, Collectors.counting()));\n\n        // 2) Print results sorted numerically descending, limit 20\n        map.entrySet().stream()\n            .sorted(Map.Entry.<String,Long>comparingByValue() .reversed())\n            .limit(20)\n            .map(entry -> String.format(\"%4d %s\", entry.getValue(), entry.getKey()))\n            .forEach(System.out::println);\n    }\n}\n```", "```java\n.collect(HashMap::new, (m,s)->m.put(s, m.getOrDefault(s,0)+1), HashMap::putAll);\n```", "```java\n.collect(Collectors.groupingBy(String::toLowerCase, Collectors.counting()));\n```", "```java\n    public static void main(String[] args) {\n        System.out.println(\"Search Results using For Loop\");\n        for (Object camera : privateListOfCameras.parallelStream(). ![1](assets/1.png)\n                filter(c -> c.isIlc() && c.getPrice() < 500).       ![2](assets/2.png)\n                toArray()) {                                        ![3](assets/3.png)\n            System.out.println(camera);                             ![4](assets/4.png)\n        }\n\n        System.out.println(\n            \"Search Results from shorter, more functional approach\");\n        privateListOfCameras.parallelStream().                      ![5](assets/5.png)\n                filter(c -> c.isIlc() && c.getPrice() < 500).\n                forEach(System.out::println);\n    }\n```", "```java\n/** \"Walk, don't run\" */\npublic class ReferencesDemo {\n\n    // Assume this is an existing method we don't want to rename\n    public void walk() {\n        System.out.println(\"ReferencesDemo.walk(): Stand-in run method called\");\n    }\n\n    // This is our main processing method; it runs \"walk\" in a Thread\n    public void doIt() {\n        Runnable r = this::walk;\n        new Thread(r).start();\n    }\n\n    // The usual simple main method to start things off\n    public static void main(String[] args) {\n        new ReferencesDemo().doIt();\n    }\n}\n```", "```java\nReferencesDemo.walk(): Stand-in run method called\n```", "```java\npublic class ReferencesDemo2 {\n    void cloz() {\n        System.out.println(\"Stand-in close() method called\");\n    }\n\n    public static void main(String[] args) throws Exception {\n        ReferencesDemo2 rd2 = new ReferencesDemo2();\n\n        // Use a method reference to assign the AutoCloseable interface\n        // variable \"ac\" to the matching method signature \"c\" (obviously\n        // short for close, but just to show the method name isn't what matters).\n        try (AutoCloseable autoCloseable = rd2::cloz) {\n            System.out.println(\"Some action happening here.\");\n        }\n    }\n}\n```", "```java\nSome action happening here.\nStand-in close() method called\n```", "```java\npublic class ReferencesDemo3 {\n\n    interface FunInterface {\n        void process(int i, String j, char c, double d);\n    }\n\n    public static void work(int i, String j, char c, double d){\n        System.out.println(\"Moo\");\n    }\n\n    public static void main(String[] args) {\n        FunInterface sample = ReferencesDemo3::work;\n        System.out.println(\"My process method is \" + sample);\n    }\n}\n```", "```java\nMy process method is functional.ReferencesDemo3$$Lambda$1/713338599@4a574795\n```", "```java\nimport java.util.Arrays;\nimport java.util.Comparator;\n\npublic class ReferencesDemo4 {\n\n    static final String[] unsortedNames = {\n        \"Gosling\", \"de Raadt\", \"Torvalds\", \"Ritchie\", \"Hopper\"\n    };\n\n    public static void main(String[] args) {\n        String[] names;\n\n        // Sort using\n        // \"an Instance Method of an Arbitrary Object of a Particular Type\"\n        names = unsortedNames.clone();\n        Arrays.sort(names, String::compareToIgnoreCase);                    ![1](assets/1.png)\n        dump(names);\n\n        // Equivalent Lambda:\n        names = unsortedNames.clone();\n        Arrays.sort(names, (str1, str2) -> str1.compareToIgnoreCase(str2)); ![2](assets/2.png)\n        dump(names);\n\n        // Equivalent old way:\n        names = unsortedNames.clone();\n        Arrays.sort(names, new Comparator<String>() {                       ![3](assets/3.png)\n            @Override\n            public int compare(String str1, String str2) {\n                return str1.compareToIgnoreCase(str2);\n            }\n        });\n        dump(names);\n\n        // Simpest way, using existing comparator\n        names = unsortedNames.clone();\n        Arrays.sort(names, String.CASE_INSENSITIVE_ORDER);                  ![4](assets/4.png)\n        dump(names);\n    }\n```", "```java\nAmdahl, de Raadt, Gosling, Hopper, Ritchie, Turing\nAmdahl, de Raadt, Gosling, Hopper, Ritchie, Turing\nAmdahl, de Raadt, Gosling, Hopper, Ritchie, Turing\nAmdahl, de Raadt, Gosling, Hopper, Ritchie, Turing\n```", "```java\ninterface Bar {\n    default String filter(String s) {\n        return \"Filtered \" + s;\n    }\n}\n\ninterface Foo {\n    default String convolve(String s) {\n        return \"Convolved \" + s;\n    }\n}\n\npublic class MixinsDemo implements Foo, Bar{\n\n    public static void main(String[] args) {\n        String input = args.length > 0 ? args[0] : \"Hello\";\n        String output = new MixinsDemo().process(input);\n        System.out.println(output);\n    }\n\n    private String process(String s) {\n        return filter(convolve(s)); // methods mixed in!\n    }\n}\n```", "```java\nC:\\javasrc>javac -d build lang/MixinsDemo.java\nC:\\javasrc>java -cp build lang.MixinsDemo\nFiltered Convolved Hello\n\nC:\\javasrc>\n```"]