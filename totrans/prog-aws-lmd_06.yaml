- en: Chapter 6\. Testing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。测试
- en: A good test suite, like the solid foundation of a house, provides a known baseline
    of system behavior on top of which we can build confidently. That baseline gives
    us confidence to add features, fix bugs, and refactor without worrying that we’ll
    break other parts of the system. When integrated into a development workflow,
    that same test suite also encourages good practices by making it easier to maintain
    existing tests and add new ones.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 一个良好的测试套件，就像房子的坚实基础一样，为我们提供了一个已知的系统行为基准，我们可以在其上放心地构建。这个基准给了我们信心，可以添加功能，修复错误，并进行重构，而不用担心会破坏系统的其他部分。当集成到开发工作流程中时，同样的测试套件还通过更容易维护现有测试和添加新测试来鼓励良好的实践。
- en: Of course, foundations aren’t free. The effort of maintaining tests must be
    balanced with the value that the tests provide. If we spend all of our effort
    on testing, we’ll have none left to work on the rest of the system.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，基础并非免费。维护测试的努力必须与测试提供的价值相平衡。如果我们把所有精力都花在测试上，就没有剩余精力来处理系统的其他部分了。
- en: For serverless applications, drawing the line between valuable tests and brittle
    technical debt is harder than ever. Fortunately, we can use a familiar model to
    help consider the trade-offs.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 对于无服务器应用程序来说，划分有价值测试和脆弱技术债务之间的界限比以往任何时候都更加困难。幸运的是，我们可以使用一个熟悉的模型来帮助考虑这些权衡。
- en: The Test Pyramid
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试金字塔
- en: The classic “Test Pyramid” (from the 2009 book *Succeeding with Agile* by Mike
    Cohn, shown in [Figure 6-1](#test-pyramid)) is a useful guide in helping us decide
    which kinds of tests to write. The pyramid metaphor illustrates the trade-offs
    between the number of tests in a given slice, the value of those tests, and the
    costs to write, run, and maintain them.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 经典的“测试金字塔”（来自2009年迈克·科恩的书《成功的敏捷》中，图6-1显示的[图6-1](#test-pyramid)）对我们帮助决定写哪种测试是一个有用的指南。金字塔的比喻说明了在给定切片中测试的数量、这些测试的价值以及编写、运行和维护它们的成本之间的权衡。
- en: '![images/ch06_image01.png](assets/awsl_0601.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![images/ch06_image01.png](assets/awsl_0601.png)'
- en: Figure 6-1\. The Test Pyramid
  id: totrans-7
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-1。测试金字塔
- en: Testing in a serverless world isn’t substantively different than in a traditional
    application, especially nearer the base of the pyramid. However, as with any distributed
    system made up of different components and services, higher-level “end-to-end”
    testing is more challenging. In this chapter, we’ll address testing from the bottom
    of the pyramid to the top, with plenty of examples along the way.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在无服务器世界中进行测试与传统应用程序并没有实质性的区别，特别是在金字塔的基础部分。然而，与由不同组件和服务组成的任何分布式系统一样，更高级别的“端到端”测试更具挑战性。在本章中，我们将从金字塔底部到顶部讨论测试，并且会沿途提供大量示例。
- en: Unit Tests
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试
- en: At the base of the pyramid are unit tests—these tests should exercise specific
    pieces of our components of our application, without relying on any external dependencies
    (like databases). Unit tests should execute quickly, and we should be able to
    run them regularly (or even automatically) during the course of development, with
    a minimum of configuration and no network access. We should have as many unit
    tests as necessary to give us confidence that our code is working correctly. Unit
    tests not only cover the “happy paths,” but thoroughly address edge cases and
    error handling. Even a small application might have dozens or hundreds of unit
    tests.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 金字塔的基础是单元测试 —— 这些测试应该针对我们应用程序的特定组件进行测试，而不依赖于任何外部依赖项（如数据库）。单元测试应该快速执行，并且在开发过程中我们应该能够定期（甚至自动化地）运行它们，配置最小化且无需网络访问。我们应该有足够多的单元测试来确保我们的代码正常工作。单元测试不仅覆盖“正常路径”，还要彻底处理边缘情况和错误处理。即使是一个小应用程序也可能有数十甚至数百个单元测试。
- en: Functional Tests
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 功能测试
- en: In the middle of the pyramid are the functional tests. Like unit tests, these
    tests should execute quickly, and shouldn’t rely on external dependencies. Unlike
    unit tests, we might have to mock or stub those external dependencies to meet
    the runtime requirements of the component under test.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 金字塔的中间是功能测试。像单元测试一样，这些测试应该快速执行，并且不应依赖外部依赖项。与单元测试不同的是，我们可能需要模拟或存根这些外部依赖项，以满足测试组件的运行时要求。
- en: Rather than attempting to exhaustively exercise every logical branch of our
    code, our functional tests address the major code paths for a component, paying
    particular attention to failure modes.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是试图详尽地执行我们代码的每个逻辑分支，我们的功能测试解决组件的主要代码路径，特别关注失败模式。
- en: End-to-End Tests
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 端到端测试
- en: At the top of the pyramid are the end-to-end tests. An end-to-end test submits
    input to the application (often via the normal user interface or API) and then
    makes assertions on the output or side effects. Unlike a functional test, an end-to-end
    test runs against the complete application and all of its external dependencies,
    in a production-like environment (although often isolated from production).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 位于金字塔顶端的是端到端测试。端到端测试向应用程序提交输入（通常通过正常的用户界面或 API），然后对输出或副作用进行断言。与功能测试不同，端到端测试针对完整的应用程序及其所有外部依赖项在类似生产的环境中运行（尽管通常与生产隔离）。
- en: Because end-to-end tests are more expensive to run than functional and unit
    tests (in terms of runtime and infrastructure cost), you typically should only
    test a few important scenarios. A good rule of thumb is to have at least one end-to-end
    test that covers the most important path through an application (e.g., the purchase
    path in an online shopping application).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 因为端到端测试比功能和单元测试更昂贵（就运行时间和基础设施成本而言），通常您只应测试一些重要的情况。一个很好的经验法则是至少有一个端到端测试覆盖应用程序中最重要的路径（例如，在在线购物应用程序中的购买路径）。
- en: Refactoring for Testing
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构以进行测试
- en: We’re going to use the serverless data pipeline we built in [Chapter 5](ch05.html#ch05)
    as the basis to build out a suite of unit, functional, and end-to-end tests. Before
    we jump in, let’s do a little refactoring to make our data pipeline Lambdas easier
    to test.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用我们在[第五章](ch05.html#ch05)中构建的无服务器数据流水线作为基础，构建一套单元测试、功能测试和端到端测试。在我们开始之前，让我们做一点重构，使我们的数据流水线
    Lambdas 更容易测试。
- en: Recall from the previous section that unit tests exercise specific pieces of
    components of our application. In our case, we’re referring to methods within
    the Java classes that make up our Lambda functions. We want to write tests that
    provide input to certain methods, and assert that the output (or side effects)
    of those methods are what we expect.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 从前一节中回顾，单元测试会测试我们应用程序的特定组件的具体部分。在我们的情况下，我们指的是构成我们 Lambda 函数的 Java 类中的方法。我们希望编写测试，为某些方法提供输入，并断言这些方法的输出（或副作用）是否符合我们的预期。
- en: To start, let’s review `BulkEventsLambda`, keeping in mind the unit and functional
    slices of the Test Pyramid. This relatively simple Lambda function is interacting
    with two external AWS services (S3 and SNS), as well as serializing and deserializing
    JSON data.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们回顾一下`BulkEventsLambda`，牢记测试金字塔的单元和功能切片。这个相对简单的 Lambda 函数与两个外部 AWS 服务（S3
    和 SNS）以及序列化和反序列化 JSON 数据进行交互。
- en: Revisiting BulkEventsLambda
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重访 BulkEventsLambda
- en: '`BulkEventsLambda` is triggered whenever a file is uploaded to a specific S3
    bucket. The handler method is invoked with an `S3Event` object. For each `S3EventNotificationRecord`
    within that event, the Lambda retrieves a JSON file from an S3 bucket. That JSON
    file contains zero or more JSON objects. The Lambda deserializes the JSON file
    into a collection of `WeatherEvent` Java objects. Each of those Java objects is
    then serialized into a `String` and published to an SNS topic. Finally, the Lambda
    function writes a log entry to STDOUT (and hence to CloudWatch Logs) stating the
    number of weather events that were sent to SNS.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 每当文件上传到特定的 S3 存储桶时，就会触发`BulkEventsLambda`。处理程序方法会使用一个`S3Event`对象调用。对于该事件中的每个`S3EventNotificationRecord`，Lambda
    会从 S3 存储桶中检索一个 JSON 文件。该 JSON 文件包含零个或多个 JSON 对象。Lambda 将 JSON 文件反序列化为一组`WeatherEvent`
    Java 对象。然后，每个 Java 对象都序列化为一个`String`并发布到一个 SNS 主题。最后，Lambda 函数会向 STDOUT（因此也会向
    CloudWatch Logs）写入一个日志条目，指出发送到 SNS 的天气事件的数量。
- en: The code you saw in [Chapter 5](ch05.html#ch05) was written and organized for
    clarity, but not necessarily for ease of testing. Let’s take a look at the four
    methods in the `BulkEvents Lambda` class.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 您在[第五章](ch05.html#ch05)看到的代码是为了清晰而编写和组织的，但不一定是为了便于测试。让我们来看一下`BulkEvents Lambda`类中的四个方法。
- en: 'First, the `handler` method, which receives an `S3Event` object:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`handler`方法，接收一个`S3Event`对象：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is the only method accessible from outside the class—without refactoring,
    it means that any tests for this class *must* invoke this method with an `S3Event`
    object. Furthermore, the method has a `void` return type, so asserting success
    or failure is difficult.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这是类外唯一可访问的方法——没有重构的话，这意味着对这个类的任何测试*必须*使用一个`S3Event`对象调用此方法。此外，该方法具有`void`返回类型，因此很难断言成功或失败。
- en: 'Moving on, we see that this method calls `processS3EventRecord` for each incoming
    event record:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们看到这个方法为每个传入的事件记录调用了`processS3EventRecord`：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This method is private, so it can’t be tested at all without changing the visibility
    to “package-private” (by removing the `private` keyword). Like the `handler` function,
    it has a void return type, so any assertions we make will be on the side effects
    rather than the return value of the method. This method has two explicit side
    effects:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: The `System.out.println` call.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `sns.publish` call, which sends an SNS message to the topic named by the
    `snsTopic` field. Because this is an AWS SDK call, a number of other environment
    and system attributes must be accounted for:'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The appropriate AWS configuration must be in place and correct.
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The AWS API endpoint for the configured region must be accessible over the network.
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The named SNS topic must exist.
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The AWS credentials we’re using must have access to write to that SNS topic.
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: To invoke `processS3EventRecord` as written, we have to address all of those
    items ahead of time. For a unit test, this is unacceptable overhead.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, if we also want to assert that `processS3EventRecord` has run correctly,
    we need a way of knowing that the SNS message was sent to the correct topic. One
    way to do that would be to subscribe to the SNS topic within our test process
    and wait for the expected message to show up. As before, this is unacceptable
    overhead for a unit test.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: A common way to test these side effects in Java is to mock or stub the classes
    responsible for those side effects using tools like [Mockito](https://site.mockito.org).
    This allows us to test our own application classes that produce side effects,
    by replacing things like the AWS SDK with a mock that looks and acts similarly
    but allows us to avoid actually setting up a real SNS topic. Using techniques
    like [argument capture](https://oreil.ly/GPdlH), mocks can also save the parameters
    used to call them, which allows us to make assertions about how they are called—in
    this case we could assert that the `sns.publish` method was called with the correct
    topic name and message.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: To use a mock AWS SDK object like this, we need a way to inject it into the
    class under test—typically this is done via a constructor that accepts the appropriate
    parameters. `BulkEventsLambda` doesn’t have such a constructor, so we’ll need
    to add one to be able to use mock objects.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: The `readWeatherEventsFromS3` method is another example of a method with a side
    effect, in this case a remote API call. In this case, it uses the AWS S3 SDK client’s
    `getObject` call to download data from the S3.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'That data is then deserialized into a collection of `WeatherEvent` objects
    and returned to the caller:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This method does two distinctly different things—it downloads data from S3 *and*
    deserializes that data. That combination of actions makes it harder for us to
    test each piece of functionality in isolation. If we want to test how errors are
    handled during JSON deserialization, we still have to make sure that the input
    to the method has the correct S3 bucket and key even though that information isn’t
    relevant to the JSON processing.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法做了两件完全不同的事情——它从 S3 下载数据，并对该数据进行反序列化。这种行为组合使我们难以测试每个功能片段是否独立。如果我们想测试 JSON
    反序列化过程中如何处理错误，我们仍然需要确保方法的输入具有正确的 S3 存储桶和密钥，尽管这些信息与 JSON 处理无关。
- en: Finally, `weatherEventToSnsMessage` is an example of a method that should be
    easy to test (if made visible outside of the `BulkEventsLambda` class). It takes
    a single `Weather Event` object and returns a `String`, and it doesn’t cause any
    side effects.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`weatherEventToSnsMessage`是一个应该很容易测试的方法示例（如果在`BulkEventsLambda`类外部可见的话）。它接受一个`Weather
    Event`对象并返回一个`String`，并且不会造成任何副作用。
- en: Refactoring BulkEventsLambda
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构 BulkEventsLambda
- en: 'Having reviewed the four methods in `BulkEventsLambda`, here are some things
    we can do to better enable unit and functional testing:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在审查了`BulkEventsLambda`中的四种方法之后，以下是一些可以更好地实现单元测试和功能测试的方法：
- en: Enable injection of mock AWS SDK classes via constructor arguments.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过构造函数参数启用模拟 AWS SDK 类的注入。
- en: Isolate side effects, so most methods can be tested without using mocks.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隔离副作用，因此大多数方法可以在不使用模拟的情况下进行测试。
- en: Split methods up so most methods just do one thing.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将方法拆分开来，使大多数方法只做一件事情。
- en: Add Constructors
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加构造函数
- en: 'With those things in mind, let’s start by adding some constructors:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在牢记这些事情的情况下，让我们从添加一些构造函数开始：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We now have two constructors. As we learned in [Chapter 3](ch03.html#ch03),
    the no-arguments default constructor will be invoked by the Lambda runtime when
    our function is run for the first time. That default constructor creates an AWS
    SDK SNS client and an S3 client and passes those two objects to the second constructor
    (this technique is called *constructor chaining*).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了两个构造函数。正如我们在[第 3 章](ch03.html#ch03)中学到的那样，默认的无参数构造函数将在第一次运行我们的函数时由 Lambda
    运行时调用。该默认构造函数创建了一个 AWS SDK SNS 客户端和一个 S3 客户端，并将这两个对象传递给第二个构造函数（这种技术称为*构造函数链*）。
- en: The second constructor takes those client objects as parameters. In tests we
    can use this constructor to instantiate the `BulkEventsLambda` class with mock
    AWS SDK clients. That second constructor also reads the `FAN_OUT_TOPIC` environment
    variable, and throws an exception if it isn’t set.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个构造函数以这些客户端对象为参数。在测试中，我们可以使用这个构造函数来实例化具有模拟 AWS SDK 客户端的`BulkEventsLambda`类。该第二个构造函数还读取`FAN_OUT_TOPIC`环境变量，如果没有设置，则抛出异常。
- en: Isolate Side Effects
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隔离副作用
- en: 'We noted three side effects from the `BulkEventsLambda` review:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`BulkEventsLambda`审查中注意到了三个副作用：
- en: Download a JSON file from S3.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 S3 下载 JSON 文件。
- en: Publish messages to an SNS topic.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向 SNS 主题发布消息。
- en: Write a log entry to STDOUT.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写入一条日志到 STDOUT。
- en: The first two impose a number of prerequisites on the test environment, slow
    down test execution, and make tests more complex to write. While we definitely
    want to test those side effects (using both mocks *and* the actual AWS services),
    isolating them to as few methods as possible will help make our unit tests simple
    and fast.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个对测试环境有一些先决条件，减慢了测试执行速度，并使编写测试变得更加复杂。虽然我们肯定要测试这些副作用（同时使用模拟和实际的 AWS 服务），但将它们隔离到尽可能少的方法中将有助于使我们的单元测试简单而快速。
- en: 'With that in mind, let’s look at two new methods that isolate AWS side effects:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个基础上，让我们看一下两种新方法，以隔离 AWS 的副作用：
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The first method, `publishToSns`, takes a `String` parameter and publishes a
    message to an SNS topic. The second, `getObjectFromS3`, takes an `S3EventNotification​Record`
    and downloads the corresponding file from S3.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个方法`publishToSns`接受一个`String`参数并向 SNS 主题发布消息。第二个`getObjectFromS3`接受一个`S3EventNotification​Record`并从
    S3 下载相应的文件。
- en: 'These two methods are now called from a refactored `handler` method, which
    is where the actual isolation of side effects is realized:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在从重构的`handler`方法中调用这两种方法，这是实现副作用隔离的实际位置：
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: There’s more going on in this new `handler` method, but for now just note that
    `get​ObjectFromS3` and `publishToSns` are called from here (and nowhere else).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个新的`handler`方法中还有更多的工作，但现在只需注意`get​ObjectFromS3`和`publishToSns`是从这里调用的（其他地方没有）。
- en: Split Methods
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分割方法
- en: In addition to isolating our side effects, the new `handler` method now also
    contains much of our processing logic. This might seem contrary to our goal, but
    this “glue” logic orchestrates a number of simpler, single-purpose methods that
    are easier to unit test. In this case, the `readWeatherEvents` method no longer
    requires access to S3 (or to a mock S3 client). Its only purpose is to deserialize
    an `InputStream` into a collection of `WeatherEvent` objects and handle errors
    (by rethrowing a `RuntimeException`, which will halt the Lambda function).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 除了隔离我们的副作用外，新的`handler`方法现在也包含了我们大部分的处理逻辑。这看起来可能与我们的目标相反，但这种“粘合”逻辑协调了许多更简单、单一用途的方法，这些方法更容易进行单元测试。在这种情况下，`readWeatherEvents`方法不再需要访问S3（或模拟的S3客户端）。它的唯一目的是将`InputStream`反序列化为一组`WeatherEvent`对象，并处理错误（通过重新抛出`RuntimeException`来停止Lambda函数）。
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note that we’re now using Java’s [`try-with-resources` feature](https://oreil.ly/LxRNY)
    to automatically close the input stream. We also removed the `private` keyword
    from this and the `weather​EventToSnsMessage` method, so those can both be accessed
    from our test classes as necessary.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们现在使用了Java的[`try-with-resources`特性](https://oreil.ly/LxRNY)来自动关闭输入流。我们还从`weatherEventToSnsMessage`方法中移除了`private`关键字，这样我们的测试类可以根据需要访问它们两者。
- en: Testing BulkEventsLambda
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试BulkEventsLambda
- en: Now that we’ve refactored, let’s add some unit tests for `BulkEventsLambda`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经重构了代码，让我们为`BulkEventsLambda`添加一些单元测试。
- en: Unit Testing
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试
- en: These tests are completely isolated from side effects—we don’t have to configure
    or connect to any AWS services or any other external dependencies. That isolation
    also means that these tests execute quickly, in just a few milliseconds. We have
    only a few, because `BulkEventsLambda` is fairly simple, but even hundreds of
    unit tests written in this style could be run in a few seconds.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试完全隔离了副作用 —— 我们无需配置或连接到任何AWS服务或其他外部依赖项。这种隔离也意味着这些测试执行速度快，仅需几毫秒。尽管`BulkEventsLambda`相当简单，我们只有几个测试，但是即使以这种风格编写数百个单元测试，也可以在几秒钟内运行。
- en: 'Here’s a unit test for the `readWeatherEvents` method of `BulkEventsLambda`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`BulkEventsLambda`的`readWeatherEvents`方法的一个单元测试：
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: For convenience, we’re reading the input data from a JSON file on disk. We then
    create an instance of `BulkEventsLambda`—notice that we’re simply passing in `null`
    for the SNS and S3 clients, because they’re not needed by this test at all. The
    `readWeatherEvents` method is called, and we assert that it produced the right
    objects.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，我们从磁盘上的JSON文件中读取输入数据。然后我们创建了一个`BulkEventsLambda`的实例 —— 请注意，我们只是简单地传入`null`作为SNS和S3客户端，因为在这个测试中它们根本不需要。调用了`readWeatherEvents`方法，并断言它产生了正确的对象。
- en: 'We can test the failure case with even less code:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以用更少的代码来测试失败的情况：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here we use a [JUnit Rule](https://oreil.ly/YeLiW) to assert that an exception
    of the expected type is thrown by our method.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们使用了一个[Junit规则](https://oreil.ly/YeLiW)，来断言我们的方法是否抛出了预期类型的异常。
- en: As unit tests go, these are simple and effective. For a more complex Lambda
    function, we might have dozens of tests like these to test as many logical paths
    and edge cases as necessary.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 就单元测试而言，这些都是简单有效的。对于更复杂的Lambda函数，我们可能会有数十个这样的测试，以测试尽可能多的逻辑路径和边缘情况。
- en: Functional Testing
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 功能测试
- en: Like the unit tests, we want our functional tests to run without having to connect
    to AWS. However, unlike the unit tests, we want to test our Lambda function as
    a single component, and doing so means that we have to convince our code that
    it’s talking to the cloud! To accomplish this feat of trickery and deceit, we’ll
    use Mockito to build “mock” instances of the AWS SDK clients configured to return
    prearranged responses to method calls. For example, if our code calls the `getObject`
    method on the S3 client, our mock will return an `S3Object` complete with fixtured
    test data.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 与单元测试类似，我们希望我们的功能测试在不连接到AWS的情况下运行。然而，与单元测试不同的是，我们希望将Lambda函数作为单个组件进行测试，这意味着我们必须让我们的代码认为它正在与云端通信！为了完成这种欺骗和欺骗的壮举，我们将使用Mockito来构建AWS
    SDK客户端的“模拟”实例，配置为返回预先安排的响应以响应方法调用。例如，如果我们的代码调用S3客户端的`getObject`方法，我们的模拟将返回一个包含固定测试数据的`S3Object`。
- en: 'Here’s a functional test for the “happy path”:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个“正常路径”的功能测试：
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The first thing you should note is that this test is *much* longer than our
    unit tests. Most of that additional code is setting up the mock objects and configuring
    the environment so that our Lambda function’s `handler` method thinks it’s running
    in the cloud.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是，这个测试比我们的单元测试*长得多*。大部分额外的代码用于设置模拟对象并配置环境，使得我们的Lambda函数的`handler`方法认为自己在云中运行。
- en: 'The second thing to note is that we’re reading the input data from a file on
    disk. *s3_event.json* is a file that was generated using this `sam` command:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 第二点需要注意的是，我们正在从磁盘上的文件中读取输入数据。*s3_event.json*是使用此`sam`命令生成的文件：
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We then changed the `key` field to reference another local file, *bulk_data.json*,
    which represents the weather data that would be stored on S3:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将`key`字段更改为引用另一个本地文件，*bulk_data.json*，它表示将存储在S3上的天气数据：
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Our mock S3 client returns the contents of the *bulk_data.json* file when the
    `s3.getObject` method is called, and our Lambda function is none the wiser.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`s3.getObject`方法时，我们的模拟S3客户端返回*bulk_data.json*文件的内容，而我们的Lambda函数对此一无所知。
- en: Lastly, we want to assert that `BulkEventsLambda` publishes messages to SNS,
    but without actually sending messages to AWS. Here we use our mock SNS client
    and capture the parameters that are passed to the `sns.publish` method. If that
    method is called the expected number of times with the right parameters, our test
    passes.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们想要断言`BulkEventsLambda`向SNS发布消息，但实际上并不向AWS发送消息。在这里，我们使用我们的模拟SNS客户端，并捕获传递给`sns.publish`方法的参数。如果该方法以正确的参数调用了预期次数，我们的测试就会通过。
- en: Another functional test asserts that the Lambda function throws an exception
    if it receives bad input data. The last test asserts that an exception is thrown
    if the `FAN_OUT_TOPIC` environment variable isn’t set.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个功能测试断言，如果Lambda函数接收到不良输入数据，则会引发异常。最后一个测试断言，如果未设置`FAN_OUT_TOPIC`环境变量，则会引发异常。
- en: These functional tests are more complex to write and take somewhat longer to
    run, but they give us confidence that `BulkEventsLambda` will behave as we expect
    it to when the Lambda runtime calls the `handler` function with an `S3Event` object.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这些功能测试编写起来更复杂，运行时间稍长，但它们确保了`BulkEventsLambda`在Lambda运行时调用`handler`函数并传递`S3Event`对象时的行为符合我们的预期。
- en: End-to-End Testing
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 端到端测试
- en: With the confidence gained from our suite of unit and functional tests, we can
    focus our most complex and costly testing methodology on the critical path for
    our application. We can also take advantage of our infrastructure-as-code approach
    to deploy a complete version of our serverless application and infrastructure
    to AWS, for the sole purpose of running an end-to-end test. When the test has
    completed successfully, we’ll clean up and tear it all down.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 通过我们的一系列单元测试和功能测试所获得的信心，我们可以将最复杂和成本最高的测试方法集中在应用程序的关键路径上。我们还可以利用基础设施即代码的方法部署我们的无服务器应用程序及其基础设施的完整版本到AWS，专门用于运行端到端测试。当测试成功完成时，我们将进行清理和拆除。
- en: To run the end-to-end test, we simply need to execute the `mvn verify` command.
    This uses the Maven Failsafe plug-in, which finds test classes that end in **IT*
    and runs them using JUnit. In this case, IT stands for integration test, but that’s
    just Maven nomenclature—we could configure the Failsafe plug-in to use a different
    suffix.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行端到端测试，我们只需执行`mvn verify`命令。这使用了Maven Failsafe插件，它会查找以**IT*结尾的测试类，并使用JUnit运行它们。在这种情况下，IT代表集成测试，但这只是Maven的命名惯例，我们可以配置Failsafe插件使用不同的后缀。
- en: For our end-to-end test, we exercise our application exactly as it would be
    used in production. We upload a JSON file to an S3 bucket and then assert that
    the `Single EventLambda` produces the correct CloudWatch Logs output. From the
    perspective of the test, our serverless application is a black box.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的端到端测试，我们确切地按照其在生产中的使用方式来运行我们的应用程序。我们将一个JSON文件上传到S3存储桶，然后断言`Single EventLambda`生成了正确的CloudWatch
    Logs输出。从测试的角度来看，我们的无服务器应用程序就是一个黑盒子。
- en: 'Here’s the main body of the test method:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这是测试方法的主体：
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here are a few points worth noting from this example:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个例子中有几个值得注意的点：
- en: The test resolves the actual name (in AWS parlance, the “Physical ID”) of the
    S3 bucket from our CloudFormation stack. This technique for resource discovery
    is useful because it allows us to deploy named stacks that don’t explicitly specify
    names for resources (or that use the stack name as part of the resource name).
    This means that we can deploy the same application multiple times in the same
    account and even the same region, using different names each time for the CloudFormation
    stack.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试解析了S3存储桶的实际名称（在AWS术语中称为“物理ID”），该技术用于资源发现非常有用，因为它允许我们部署命名堆栈而不明确指定资源的名称（或者将堆栈名称用作资源名称的一部分）。这意味着我们可以在同一账户和区域中多次部署同一应用，并使用不同的堆栈名称进行CloudFormation堆栈部署。
- en: For simplicity’s sake, our test simply sleeps for 30 seconds before checking
    if the `SingleEventLambda` has executed. Another approach would be to poll CloudWatch
    Logs proactively, which would be more reliable, but obviously more complex.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了简单起见，我们的测试在检查`SingleEventLambda`是否执行之前简单地休眠30秒。另一种方法是主动轮询CloudWatch日志，这种方法更可靠，但显然更复杂。
- en: We clean up some resources at the end of the test method. We do this so if the
    test fails, those resources remain available for our investigation into the test
    failure. If we had used JUnit’s `@After` functionality, that cleanup would happen
    even if the test failed, thus hampering an investigation.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在测试方法结束时清理一些资源。我们这样做是为了在测试失败时，这些资源仍然可用于我们对测试失败的调查。如果我们使用了JUnit的`@After`功能，即使测试失败，也会进行清理，从而阻碍调查工作。
- en: Now that you’ve seen the test method itself, let’s look at how we set up and
    tear down the test infrastructure. We need to make sure that the S3 bucket, SNS
    topic, and Lambda functions are in place for our test to run, but we don’t want
    to create those resources individually. Instead, we want to use the same SAM *template.yaml*
    file as we use for production.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了测试方法本身，让我们看看如何设置和拆除测试基础设施。我们需要确保S3存储桶、SNS主题和Lambda函数已经准备好以便我们的测试运行，但我们不希望单独创建这些资源。相反，我们想使用与生产环境相同的SAM
    *template.yaml*文件。
- en: For this example, we’re using the Maven “exec” plug-in to hook into the build
    lifecycle’s “pre-integration” phase, which will execute before the end-to-end
    test. Don’t be put off by the fact that we’re using Maven here. You could just
    as easily do this with a simple shell script or Makefile. What’s important is
    that we use the same *template.yaml* file as we would use for production, and
    if possible, the same AWS CLI commands to deploy our application.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们使用Maven的“exec”插件来连接到构建生命周期的“pre-integration”阶段，这将在端到端测试之前执行。在这里使用Maven并不可怕。你可以很容易地使用简单的Shell脚本或Makefile来做同样的事情。重要的是我们使用与生产环境相同的*template.yaml*文件，如果可能的话，使用相同的AWS
    CLI命令来部署我们的应用。
- en: '[PRE13]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: It takes several lines of XML to describe, but in this example we’re calling
    the SAM CLI binary with the same arguments that we used in [Chapter 5](ch05.html#ch05).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 需要多行XML来描述，但在此示例中，我们使用与我们在[第5章](ch05.html#ch05)中使用的相同参数调用SAM CLI二进制文件。
- en: 'The `${integration.test.code.bucket}` and `${integration.test.stack.name}`
    properties come from the top-level *pom.xml* file and are defined like this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`${integration.test.code.bucket}`和`${integration.test.stack.name}`属性来自顶层*pom.xml*文件，并且定义如下：'
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Our Maven process populates the value of `${integration.test.code.bucket}` with
    the value of the `$CF_BUCKET` environment variable, which we’ve used in previous
    chapters. The `${maven.build.timestamp.format}` [*pom.xml* documentation](https://oreil.ly/FIl7J)
    tells Maven to construct a human-readable numeric timestamp, which we then use
    as part of the `${integration.test.stack.name}`. This gives us a (nearly) unique
    CloudFormation stack name, so multiple end-to-end tests could be run simultaneously
    using the same AWS account and region (as long as they’re not started in the same
    second!).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Maven过程使用`${integration.test.code.bucket}`的值来填充`$CF_BUCKET`环境变量的值，我们在前几章中已经使用过它。`${maven.build.timestamp.format}`
    [*pom.xml* 文档](https://oreil.ly/FIl7J)告诉Maven构建一个人类可读的数值时间戳，然后我们将其用作`${integration.test.stack.name}`的一部分。这为我们提供了一个（几乎）唯一的CloudFormation堆栈名称，因此可以在同一AWS账户和区域中同时运行多个端到端测试（只要它们不是在同一秒钟开始！）。
- en: What we don’t see in this Maven configuration are any AWS credentials. Processes
    started by the Maven “exec” plug-in will pick up environment variables automatically,
    so this will use the AWS environment variables that we’ve been using for the last
    several chapters without any additional configuration on our part.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个 Maven 配置中看不到任何 AWS 凭据。由 Maven 的“exec”插件启动的进程将自动获取环境变量，因此这将使用我们在过去几章中一直在使用的
    AWS 环境变量，而无需我们进一步配置。
- en: In most cases you should use separate AWS accounts for your test environments
    to isolate test infrastructure and data. To achieve that here, simply supply a
    different set of AWS credentials via environment variables.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，您应该为您的测试环境使用单独的 AWS 帐户，以隔离测试基础设施和数据。要在这里实现这一点，只需通过环境变量提供不同的 AWS 凭据集。
- en: 'After our end-to-end test runs, teardown of the CloudFormation stack works
    in the same way, as part of Maven’s “post-integration-test” lifecycle phase:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的端到端测试运行后，CloudFormation 栈的拆除工作以相同的方式进行，作为 Maven 的“post-integration-test”生命周期阶段的一部分：
- en: '[PRE15]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We’ve now reached the very top of the Test Pyramid. The end-to-end test brings
    a lot of value: it deploys and runs the entire application. It tests the critical
    path just as it would be executed in production. However, with that value comes
    a fairly high cost—we need a lot of extra configuration and setup and teardown
    code to make sure the test can be run repeatedly and without any affinity to a
    particular AWS account or region. Despite those efforts, this test is still vulnerable
    to vendor outages, environment changes, and the indeterminate behavior inherent
    in operating over a global network.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经达到了测试金字塔的顶端。端到端测试带来了很多价值：它部署并运行整个应用程序。它测试了关键路径，就像在生产环境中执行的那样。然而，随着这个价值而来的是相当高的成本——我们需要大量额外的配置和设置以及拆除代码，以确保测试可以重复运行，并且不倾向于特定的
    AWS 帐户或区域。尽管有这些努力，这个测试仍然容易受到供应商故障、环境变化以及在全球网络上操作固有的不确定行为的影响。
- en: In other words, our end-to-end test is brittle and costly to maintain compared
    to the unit and functional tests. For this reason, you should try to write as
    few end-to-end tests as possible and instead rely on more, lower-cost tests to
    fully exercise your application.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，与单元测试和功能测试相比，我们的端到端测试更加脆弱且维护成本高昂。因此，您应尽量少写端到端测试，并且更多地依赖成本较低的测试来全面测试您的应用程序。
- en: Local Cloud Testing
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本地云测试
- en: For years, an inherent and unassailable property of a good development workflow
    was the ability to run the entire application or system locally, without touching
    any external resources. For a traditional desktop or server application, this
    might mean just running the application itself, or perhaps the application and
    a database. For a web application, the list of requirements might include a reverse
    proxy, a web server, and a job queue.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，一个良好的开发工作流的固有和不可动摇的特性是能够在不触及任何外部资源的情况下在本地运行整个应用程序或系统。对于传统的桌面或服务器应用程序，这可能意味着只运行应用程序本身，或者可能包括应用程序和数据库。对于
    web 应用程序，需求列表可能包括反向代理、Web 服务器和作业队列。
- en: But what happens when we start using vendor-managed cloud services? Our initial
    reaction might be to try to achieve the same fully local development workflow
    we were used to before, using tools like [localstack](https://oreil.ly/TbcEo)
    and `sam local` ([“sam local invoke”](#sam-local)). This approach might seem tenable
    at first, but it quickly puts us at odds with a cloud-first architecture in which
    we want to take full advantage of scalable, reliable, fully managed services provided
    by a cloud vendor. Most importantly, we don’t want to limit our service choices
    to only those that enable our development workflow. This is the tail wagging the
    dog!
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，当我们开始使用供应商管理的云服务时会发生什么呢？我们最初的反应可能是尝试实现与以前相同的完全本地开发工作流程，使用像 [localstack](https://oreil.ly/TbcEo)
    和 `sam local`（[“sam local invoke”](#sam-local)）这样的工具。这种方法起初可能看似可行，但很快就会与云优先架构相冲突，在这种架构中，我们希望充分利用由云供应商提供的可扩展、可靠、完全托管的服务。最重要的是，我们不希望将服务选择限制为仅允许我们的开发工作流程。这是本末倒置的问题！
- en: 'What are the difficulties with fully local development in a world of vendor-managed
    cloud services? The fundamental issue is fidelity: it is simply impossible for
    a local version of a service (like S3 or DynamoDB or Lambda) to have the same
    properties as the cloud version. Even if the local analogue is provided by the
    vendor (in this case AWS), it will have at least some of the following issues:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个由供应商管理的云服务的世界里，完全本地开发存在哪些困难？根本问题是保真度：一个服务的本地版本（比如 S3 或 DynamoDB 或 Lambda）要具有与云版本相同的属性是完全不可能的。即使供应商（在这种情况下是
    AWS）提供了本地模拟，它仍然会存在以下至少一些问题：
- en: Missing features
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺少功能
- en: Different (or absent) control plane behavior (e.g., creating DynamoDB tables)
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同的（或者不存在的）控制平面行为（例如，创建 DynamoDB 表）
- en: Different scaling behavior
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同的扩展行为
- en: Different latency (e.g., extremely low latency for the local analogue compared
    to the cloud service)
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同的延迟（例如，与云服务相比，本地模拟的延迟非常低）
- en: Different failure modes
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同的故障模式
- en: Different (or no) security controls
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同的（或者没有）安全控制
- en: Having run into these issues time after time, we advocate for the pragmatic
    testing approach taken in this chapter. We rely extensively on unit tests to verify
    the behavior of specific pieces of functionality, and we use those tests to rapidly
    iterate during development of individual Lambda functions. Functional tests exercise
    the capability of a Lambda function using mocks or stubs in place of AWS SDK clients
    and other external dependencies. Finally, a few full-fledged end-to-end tests
    let us execute the entire application in the cloud, using the same SAM infrastructure
    template and CLI commands that we would use in production.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 一次又一次地遇到这些问题后，我们倡导本章中采用的务实测试方法。我们广泛依赖单元测试来验证特定功能片段的行为，并且在开发各个 Lambda 函数时使用这些测试来快速迭代。功能测试使用模拟或存根来代替
    AWS SDK 客户端和其他外部依赖项来执行 Lambda 函数的功能。最后，几个完整的端到端测试让我们在云中执行整个应用程序，使用相同的 SAM 基础设施模板和
    CLI 命令，就像我们在生产环境中使用的那样。
- en: Cloud Test Environments
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 云测试环境
- en: For the unit and functional testing we’ve described in this chapter, a local
    environment with Java, Maven, and your favorite IDE will suffice nicely. For the
    end-to-end tests, you need access to an AWS account. This is all straightforward
    for a single developer working in isolation, but when working as part of a larger
    team, it can get more complex.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们在本章中描述的单元测试和功能测试，具有 Java、Maven 和您喜欢的 IDE 的本地环境将非常满足要求。对于端到端测试，您需要访问一个 AWS
    账户。这对于单个开发人员在隔离环境中工作是非常简单的，但是当作为较大团队的一部分工作时，情况可能会变得更加复杂。
- en: When you’re working as a part of a larger team, what’s the best way to work
    with cloud resources? We have found that a good place to start is for each developer
    to have an isolated development account and for the team as a whole to have one
    account per shared integration environment (e.g., dev, test, staging). Things
    can get tricky when relying on truly shared resources (such as databases or S3
    buckets), but in general maintaining isolation during rapid development prevents
    an entire class of issues ranging from accidental deletion to resource contention.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当您作为较大团队的一部分工作时，最佳的云资源工作方式是什么？我们发现一个好的起点是让每个开发人员拥有一个隔离的开发账户，并且整个团队为每个共享集成环境（例如，开发，测试，暂存）拥有一个账户。当依赖于真正共享的资源（如数据库或
    S3 存储桶）时，情况可能会变得棘手，但总的来说，在快速开发过程中保持隔离可以防止从意外删除到资源争用等一系列问题。
- en: A rigorous infrastructure-as-code approach makes managing resources in multiple
    accounts much easier. Taking it a step further, an infrastructure-as-code approach
    to setting up build pipelines means that standing up and deploying a serverless
    application in a new account might be as simple as deploying a single CloudFormation
    stack representing the build pipeline, which will then pull the latest source
    code and deploy the application.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 严格的基础设施即代码方法使得在多个账户中管理资源变得更加容易。更进一步，基础设施即代码方法设置构建流水线意味着在新账户中部署无服务器应用可能就像部署一个代表构建流水线的单个
    CloudFormation 栈那样简单，然后该栈将获取最新的源代码并部署应用程序。
- en: Summary
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概要
- en: Testing serverless applications is not substantively different than testing
    traditional applications—it’s all about finding the right balance of coverage,
    complexity, cost, and value, and scaling our testing approach to work for a team.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 测试无服务器应用与测试传统应用没有本质区别——关键是找到覆盖范围、复杂性、成本和价值的平衡，并将我们的测试方法扩展到团队中使用。
- en: In this chapter, you learned that the Test Pyramid can guide your testing strategy
    for a serverless application. We refactored our Lambda code to ease unit testing
    and to enable functional testing without a network connection. The end-to-end
    test demonstrated the efficacy of an infrastructure-as-code approach as well as
    the high degree of complexity inherent in testing a distributed application.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习到了测试金字塔如何指导您在无服务器应用程序中的测试策略。我们重构了我们的Lambda代码，以便轻松进行单元测试，并且能够在没有网络连接的情况下进行功能测试。端到端测试展示了基础设施即代码方法的有效性，以及测试分布式应用程序固有的高复杂度。
- en: You saw that trying to run cloud services for local testing is subject to a
    host of issues, especially the lack of fidelity that can be achieved locally.
    If you want to test a cloud-based application, at some point you have to actually
    run it in the cloud! Finally, for a team to work effectively in this way, developers
    should have isolated cloud accounts, and teams should have shared integration
    environments.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 您看到了试图在本地运行云服务面临各种问题，特别是在本地无法达到的准确性。如果您想测试基于云的应用程序，最终您必须在云中实际运行它！最后，为了团队有效地工作，开发人员应该拥有隔离的云账户，团队应该有共享的集成环境。
- en: Through testing, we now have confidence that our application will behave as
    expected. In the next chapter, we’ll explore how to gain insight into the behavior
    of our deployed applications through logging, metrics, and tracing.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 通过测试，我们现在有信心我们的应用程序会按预期行事。在下一章中，我们将探讨如何通过日志记录、度量和跟踪来了解我们部署的应用程序的行为。
- en: Exercise
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: The code and tests in this chapter exercise S3 and SNS. Write an integration
    test for the [Chapter 5](ch05.html#ch05) application that makes HTTP calls from
    Java to the deployed API Gateway and then asserts on the responses (and side effects).
    For extra credit, use [Java 11’s new native HTTP client](https://oreil.ly/ctKPo)!
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码和测试涉及S3和SNS。为[第五章](ch05.html#ch05)的应用编写一个集成测试，该测试使用Java从部署的API Gateway发出HTTP调用，然后断言其响应（及副作用）。如果有余力，可以使用[Java
    11的新原生HTTP客户端](https://oreil.ly/ctKPo)！
