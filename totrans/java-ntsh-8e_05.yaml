- en: Chapter 4\. The Java Type System
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we move beyond basic object-oriented programming with classes
    and into the additional concepts required to work effectively with Java’s type
    system.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: A *statically typed* language is one in which variables have definite types,
    and where it is a compile-time error to assign a value of an incompatible type
    to a variable. Languages that only check type compatibility at runtime are called
    *dynamically typed*.
  prefs: []
  type: TYPE_NORMAL
- en: Java is a fairly classic example of a statically typed language. JavaScript
    is an example of a dynamically typed language that allows any variable to store
    any type of value.
  prefs: []
  type: TYPE_NORMAL
- en: The Java type system involves not only classes and primitive types but also
    other kinds of reference type that are related to the basic concept of a class,
    but which differ in some way and are usually treated in a special way by `javac`
    or the JVM.
  prefs: []
  type: TYPE_NORMAL
- en: We have already met arrays and classes, two of Java’s most widely used kinds
    of reference type. This chapter starts by discussing another very important kind
    of reference type—*interfaces*. We then move on to discuss Java’s *generics*,
    which have a major role to play in Java’s type system. With these topics under
    our belts, we can discuss the differences between compile-time and runtime types
    in Java.
  prefs: []
  type: TYPE_NORMAL
- en: To complete the full picture of Java’s reference types, we look at specialized
    kinds of classes and interfaces—known as *enums* and *annotations*. We conclude
    the chapter by looking at *lambda expressions* and *nested types* and then reviewing
    how enhanced type inference has allowed Java’s *nondenotable types* to become
    usable by programmers.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s get started by taking a look at interfaces—probably the most important
    of Java’s reference types after classes and a key building block for the rest
    of Java’s type system.
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 3](ch03.xhtml#javanut8-CHP-3), we met the idea of inheritance. We
    also saw that a Java class can inherit only from a single class. This is quite
    a big restriction on the kinds of object-oriented programs that we want to build.
    The designers of Java knew this, but they also wanted to ensure that Java’s approach
    to object-oriented programming was less complex and error-prone than, for example,
    that of C++.
  prefs: []
  type: TYPE_NORMAL
- en: The solution that they chose was to introduce the concept of an interface to
    Java. Like a class, an *interface* defines a new reference type. As its name implies,
    an interface is intended to represent only an API—so it provides a description
    of a type and the methods (and signatures) that classes that *implement* that
    API must provide.
  prefs: []
  type: TYPE_NORMAL
- en: In general, a Java interface does not provide any implementation code for the
    methods that it describes. These methods are considered *mandatory*—any class
    that wishes to implement the interface must provide an implementation of these
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: However, an interface may wish to mark that some API methods are optional and
    that implementing classes do not need to implement them if they choose not to.
    This is done with the `default` keyword—and the interface must provide an implementation
    of these optional methods, which will be used by any implementing class that elects
    not to implement them.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The ability to have optional methods in interfaces was new in Java 8. It is
    not available in any earlier version. See [“Records and Interfaces”](#javanut8-CHP-4-SECT-1.5)
    for a full description of how optional (also called default) methods work.
  prefs: []
  type: TYPE_NORMAL
- en: It is not possible to directly instantiate an interface and create a member
    of the interface type. Instead, a class must *implement* the interface to provide
    the necessary method bodies.
  prefs: []
  type: TYPE_NORMAL
- en: Any instances of the implementing class are *compatible with* both the type
    defined by the class and the type defined by the interface. This means that the
    instances may be substituted at any point in the code that requires an instance
    of either the class type or the interface type. This extends the Liskov principle
    as seen in [“Reference Type Conversions”](ch03.xhtml#javanut8-CHP-3-SECT-6.1).
  prefs: []
  type: TYPE_NORMAL
- en: Another way of saying this is that two objects that do not share the same class
    or superclass may still both be compatible with the same interface type if both
    objects are instances of classes that implement the interface.
  prefs: []
  type: TYPE_NORMAL
- en: Defining an Interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An interface definition is somewhat like a class definition in which all the
    (mandatory) methods are abstract and the keyword `class` has been replaced with
    `interface`. For example, this code shows the definition of an interface named
    `Centered` (a `Shape` class, such as those defined in [Chapter 3](ch03.xhtml#javanut8-CHP-3),
    might implement this interface if it wants to allow the coordinates of its center
    to be set and queried):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'A number of restrictions apply to the members of an interface:'
  prefs: []
  type: TYPE_NORMAL
- en: All mandatory methods of an interface are implicitly `abstract` and must have
    a semicolon in place of a method body. The `abstract` modifier is allowed but
    by convention is usually omitted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An interface defines a public API. By convention, members of an interface are
    implicitly `public`, and it is conventional to omit the unnecessary `public` modifier.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An interface may not define any instance fields. Fields are an implementation
    detail, and an interface is a specification, not an implementation. The only fields
    allowed in an interface definition are constants that are declared both `static`
    and `final`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An interface cannot be instantiated, so it does not define a constructor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interfaces may contain nested types. Any such types are implicitly `public`
    and `static`. See [“Nested Types”](#javanut8-CHP-4-SECT-5) for a full description
    of nested types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As of Java 8, an interface may contain static methods. Previous versions of
    Java did not allow this, which is widely believed to have been a flaw in the design
    of the Java language.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As of Java 9, an interface may contain `private` methods. These have limited
    use cases, but with the other changes to the interface construct, it seems arbitrary
    to disallow them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is a compile-time error to try to define a `protected` method in an interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending Interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Interfaces may extend other interfaces, and, like a class definition, an interface
    definition indicates this by including an `extends` clause. When one interface
    extends another, it inherits all the methods and constants of its superinterface
    and can define new methods and constants. Unlike classes, however, the `extends`
    clause of an interface definition may include more than one superinterface. For
    example, here are some interfaces that extend other interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: An interface that extends more than one interface inherits all the methods and
    constants from each of those interfaces and can define its own additional methods
    and constants. A class that implements such an interface must implement the abstract
    methods defined directly by the interface, as well as all the abstract methods
    inherited from all the superinterfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing an Interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just as a class uses `extends` to specify its superclass, it can use `implements`
    to name one or more interfaces it supports. The `implements` keyword can appear
    in a class declaration following the `extends` clause. It should be followed by
    a comma-separated list of interfaces that the class implements.
  prefs: []
  type: TYPE_NORMAL
- en: When a class declares an interface in its `implements` clause, it is saying
    that it provides an implementation (i.e., a body) for each mandatory method of
    that interface. If a class implements an interface but does not provide an implementation
    for every mandatory interface method, it inherits those unimplemented `abstract`
    methods from the interface and must itself be declared `abstract`. If a class
    implements more than one interface, it must implement every mandatory method of
    each interface it implements (or be declared `abstract`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows how to define a `CenteredRectangle` class that extends
    the `Rectangle` class from [Chapter 3](ch03.xhtml#javanut8-CHP-3) and implements
    our `Centered` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose we implement `CenteredCircle` and `CenteredSquare` just as we have
    implemented this `CenteredRectangle` class. Each class extends `Shape`, so instances
    of the classes can be treated as instances of the `Shape` class, as we saw earlier.
    Because each class implements the `Centered` interface, instances can also be
    treated as instances of that type. The following code demonstrates how objects
    can be members of both a class type and an interface type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Interfaces are data types in Java, just like classes. When a class implements
    an interface, instances of that class can be assigned to variables of the interface
    type.
  prefs: []
  type: TYPE_NORMAL
- en: Don’t interpret this example to imply that you must assign a `CenteredRectangle`
    object to a `Centered` variable before you can invoke the `setCenter()` method
    or to a `Shape` variable before invoking the `area()` method. Instead, because
    the `CenteredRectangle` class defines `setCenter()` and inherits `area()` from
    its `Rectangle` superclass, you can always invoke these methods.
  prefs: []
  type: TYPE_NORMAL
- en: As we could see by examining the bytecode (e.g., by using the `javap` tool we
    will meet in [Chapter 13](ch13.xhtml#javanut8-CHP-13)), the JVM calls the `setCenter()`
    method slightly differently depending on whether the local variable holding the
    shape is of the type `CenteredRectangle` or `Centered`, but this is not a distinction
    that matters most of the time when you’re writing Java code.
  prefs: []
  type: TYPE_NORMAL
- en: Records and Interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Records, being a special case of classes, can implement interfaces, just like
    any other class. The body of the record must contain implementation code for all
    of the mandatory methods of the interface, and it may contain overriding implementations
    for any of the default methods of the interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example as applied to the `Point` record we met in the last
    chapter. Given an interface defined like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'then we can update the `Point` type like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note that because records are immutable, it is not possible to mutate instances
    in-place and so, if we need a modified object, we have to create one and return
    it explicitly. This implies that not every interface will be suitable for implementation
    by a record type.
  prefs: []
  type: TYPE_NORMAL
- en: Sealed Interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We met the `sealed` keyword in the last chapter, as applied to classes. It
    can also be applied to interfaces, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This sealed interface represents the capability for a shape to be rotated by
    90 degrees. Note that the declaration also contains a `permits` clause that specifies
    the only classes that are allowed to implement this interface—in this case just
    the `Circle` and `Rectangle` for simplicity. The `Circle` is modified like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'whereas the `Rectangle` has been modified like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As it stands, we don’t want to deal with the complexity of allowing other shapes
    to have rotational behavior, so we restrict the interface so that it can only
    be implemented by the two simplest cases: circles and rectangles.'
  prefs: []
  type: TYPE_NORMAL
- en: There is also an interesting interplay between sealed interfaces and records,
    which we will discuss in [Chapter 5](ch05.xhtml#javanut8-CHP-5).
  prefs: []
  type: TYPE_NORMAL
- en: Default Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From Java 8 onward, it is possible to declare methods in interfaces that include
    an implementation. In this section, we’ll discuss these methods, which should
    be understood as optional methods in the API the interfaces represent—they’re
    usually called *default methods*. Let’s start by looking at the reasons why we
    need the default mechanism in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: Backward compatibility
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Java platform has always been very concerned with backward compatibility.
    This means that code that was written (or even compiled) for an earlier version
    of the platform must continue to work with later releases of the platform. This
    principle allows development groups to have a high degree of confidence that an
    upgrade of their JDK or Java Runtime Environment (JRE) will not break currently
    working applications.
  prefs: []
  type: TYPE_NORMAL
- en: Backward compatibility is a great strength of the Java platform, but in order
    to achieve it, some constraints are placed on the platform. One of them is that
    interfaces may not have new mandatory methods added to them in a new release of
    the interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let’s suppose that we want to update the `Positionable` interface
    with the ability to add a bottom-left bounding point as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: With this new definition, if we try to use this new interface with code developed
    for the old, it just won’t work, as the existing code is missing the mandatory
    methods `setLowerLeftCorner()`, `getLowerLeftX()`, and `getLowerLeftY()`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can see this effect quite easily in your own code. Compile a class file
    that depends on an interface. Then add a new mandatory method to the interface
    and try to run the program with the new version of the interface, together with
    your old class file. You should see the program crash with a `NoClassDefError`.
  prefs: []
  type: TYPE_NORMAL
- en: This limitation was a concern for the designers of Java 8—as one of their goals
    was to be able to upgrade the core Java Collections libraries and introduce methods
    that used lambda expressions.
  prefs: []
  type: TYPE_NORMAL
- en: To solve this problem, a new mechanism was needed, essentially to allow interfaces
    to evolve by allowing new methods to be added without breaking backward compatibility.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation of default methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Adding new methods to an interface without breaking backward compatibility requires
    providing some implementation for the older implementations of the interface so
    that they can continue to work. This mechanism is a `default` method, and it was
    first added to the platform in JDK 8.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: A default method (sometimes called an optional method) can be added to any interface.
    This must include an implementation, called the *default implementation*, which
    is written inline in the interface definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic behavior of a default method is:'
  prefs: []
  type: TYPE_NORMAL
- en: An implementing class may (but is not required to) implement the default method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If an implementing class implements the default method, then the implementation
    in the class is used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If no other implementation can be found, then the default implementation is
    used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An example default method is the `sort()` method. It’s been added to the interface
    `java.util.List` in JDK 8, and is defined as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Thus, from Java 8 upward, any object that implements `List` has an instance
    method `sort()` that can be used to sort the list using a suitable `Comparator`.
    As the return type is `void`, we might expect that this is an in-place sort, and
    this is indeed the case.
  prefs: []
  type: TYPE_NORMAL
- en: One consequence of default methods is that when implementing multiple interfaces,
    it’s possible that two or more interfaces may contain a default method with a
    completely identical name and signature.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: These two interfaces have very different default semantics for `call()` and
    could cause a potential implementation clash—a *colliding default method*. In
    versions of Java prior to 8, this could not occur, as the language permitted only
    single inheritance of implementation. The introduction of default methods means
    that Java now permits a limited form of *multiple inheritance* (but only of method
    implementations). Java still does not permit (and has no plans to add) multiple
    inheritance of object state.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In some other languages, notably C++, this problem is known as *diamond inheritance*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Default methods have a simple set of rules to help resolve any potential ambiguities:'
  prefs: []
  type: TYPE_NORMAL
- en: If a class implements multiple interfaces in such a way as to cause a potential
    clash of default method implementations, the implementing class must override
    the clashing method and provide a definition of what is to be done.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Syntax is provided to allow the implementing class to simply call one of the
    interface default methods if that is what is required:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As a side effect of the design of default methods, there is a slight, unavoidable
    usage issue that may arise in the case of evolving interfaces with colliding methods.
    Consider the case where a bytecode version 51.0 (Java 7) class implements two
    interfaces `A` and `B` with version numbers `a.0` and `b.0`, respectively. As
    defaults are not available in Java 7, this class will work correctly. However,
    if at a later time either or both interfaces adopt a default implementation of
    a colliding method, then compile-time breakage can occur.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if version `a.1` introduces a default method in `A`, then the
    implementing class will pick up the implementation when run with the new version
    of the dependency. If version `b.1` now introduces the same method, it causes
    a collision:'
  prefs: []
  type: TYPE_NORMAL
- en: If `B` introduces the method as a mandatory (i.e., abstract) method, then the
    implementing class continues to work—both at compile time and at runtime.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `B` introduces the method as a default method, then this is not safe and
    the implementing class will fail both at compile and at runtime.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This minor issue is very much a corner case and in practice is a very small
    price to pay in order to have usable default methods in the language.
  prefs: []
  type: TYPE_NORMAL
- en: 'When working with default methods, we should be aware that there is a slightly
    restricted set of operations we can perform from within a default method:'
  prefs: []
  type: TYPE_NORMAL
- en: Call another method present in the interface’s public API (whether mandatory
    or optional); some implementation for such methods is guaranteed to be available.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Call a private method on the interface (Java 9 and up).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Call a static method, whether on the interface or defined elsewhere.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the `this` reference (e.g., as an argument to method calls).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The biggest takeaway from these restrictions is that even with default methods,
    Java interfaces still lack meaningful state; we cannot alter or store state within
    the interface.
  prefs: []
  type: TYPE_NORMAL
- en: Default methods have had a profound impact on the way that Java practitioners
    approach object-oriented programming. When combined with the rise of lambda expressions,
    they have upended many previous conventions of Java coding; we will discuss this
    in detail in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Marker Interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Occasionally it is useful to define an interface that is entirely empty. A class
    can implement this interface simply by naming it in its `implements` clause without
    having to implement any methods. In this case, any instances of the class become
    valid instances of the interface as well and can be cast to the type. Java code
    can check whether an object is an instance of the interface using the `instanceof`
    operator, so this technique is a useful way to provide additional information
    about an object. It can be thought of as providing additional, auxiliary type
    information about a class.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Marker interfaces are much less widely used than they once were. Java’s *annotations*
    (which we shall meet presently) have largely replaced them due to their much greater
    flexibility at conveying extended type information.
  prefs: []
  type: TYPE_NORMAL
- en: 'The interface `java.util.RandomAccess` is an example of a marker interface:
    `java.util.List` implementations use this interface to advertise that they provide
    fast random access to the elements of the list. For example, `ArrayList` implements
    `RandomAccess`, while `LinkedList` does not. Algorithms that care about the performance
    of random-access operations can test for `RandomAccess` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'As we will see later, Java’s type system is very tightly coupled to the names
    that types have—an approach called *nominal typing*. A marker interface is a great
    example of this: it has nothing at all *except* a name.'
  prefs: []
  type: TYPE_NORMAL
- en: Java Generics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the great strengths of the Java platform is the standard library it ships.
    It provides a great deal of useful functionality—and in particular robust implementations
    of common data structures. These implementations are relatively simple to develop
    with and are well documented. The libraries are known as the Java Collections,
    and we will spend a big chunk of [Chapter 8](ch08.xhtml#javanut8-CHP-8) discussing
    them. For a far more complete treatment, see the book [*Java Generics and Collections*](http://shop.oreilly.com/product/9780596527754.do)
    by Maurice Naftalin and Philip Wadler (O’Reilly).
  prefs: []
  type: TYPE_NORMAL
- en: 'Although they were still very useful, the earliest versions of the collections
    had a fairly major limitation: the data structure (sometimes called the *container*)
    essentially obscured the type of the data being stored in it.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Data hiding and encapsulation is a great principle of object-oriented programming,
    but in this case, the opaque nature of the container caused a lot of problems
    for the developer.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s kick off the section by demonstrating the problem and showing how the
    introduction of *generic types* solved it and made life much easier for Java developers.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Generics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we want to build a collection of `Shape` instances, we can use a `List`
    to hold them, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: A problem with this code stems from the requirement to perform a cast to get
    the shape objects back out in a usable form—the `List` doesn’t know what type
    of objects it contains. Not only that, but it’s actually possible to put different
    types of objects into the same container, and everything will work fine until
    an illegal cast is used and the program crashes.
  prefs: []
  type: TYPE_NORMAL
- en: What we really want is a form of `List` that understands what type it contains.
    Then, `javac` could detect when an illegal argument was passed to the methods
    of `List` and cause a compilation error, rather than deferring the issue to runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Collections that have all elements of the same type are called *homogeneous*,
    while the collections that can have elements of potentially different types are
    called *heterogeneous* (sometimes called “mystery meat collections”).
  prefs: []
  type: TYPE_NORMAL
- en: 'Java provides a simple syntax to cater to homogeneous collections. To indicate
    that a type is a container that holds instances of another reference type, we
    enclose the *payload* type that the container holds within angle brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This syntax ensures that a large class of unsafe code is caught by the compiler,
    before it gets anywhere near runtime. This is, of course, the whole point of static
    type systems—to use compile-time knowledge to help eliminate runtime problems
    wherever possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'The resulting types, which combine an enclosing container type and a payload
    type, are usually called *generic types*, and they are declared like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This indicates that the `Box` interface is a general construct, which can hold
    any type of payload. It isn’t really a complete interface by itself—it’s more
    like a general description of a whole family of interfaces, one for each type
    that can be used in place of `T`.
  prefs: []
  type: TYPE_NORMAL
- en: Generic Types and Type Parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ve seen how to use a generic type to provide enhanced program safety by using
    compile-time knowledge to prevent simple type errors. In this section, let’s dig
    deeper into the properties of generic types.
  prefs: []
  type: TYPE_NORMAL
- en: The syntax `<T>` has a special name, *type parameter*, and another name for
    a generic type is a *parameterized type*. This should convey the sense that the
    container type (e.g., `List`) is parameterized by another type (the payload type).
    When we write a type like `Map<String, Integer>`, we are assigning concrete values
    to the type parameters.
  prefs: []
  type: TYPE_NORMAL
- en: When we define a type that has parameters, we need to do so in a way that does
    not make assumptions about the type parameters. So the `List` type is declared
    in a generic way as `List<E>`, and the type parameter `E` is used all the way
    through to stand as a placeholder for the actual type that programmers will use
    for the payload when they use the `List` data structure.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Type parameters always stand in for reference types. It is not possible to use
    a primitive type as a value for a type parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The type parameter can be used in the signatures and bodies of methods as though
    it is a real type, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note how the type parameter `E` can be used as a parameter for both return types
    and method arguments. We don’t assume that the payload type has any specific properties
    and only make the basic assumption of consistency—that the type we put in is the
    same type that we will later get back out.
  prefs: []
  type: TYPE_NORMAL
- en: This enhancement has effectively introduced a new kind of type to Java’s type
    system. By combining the container type with the value of the type parameter,
    we are making new types.
  prefs: []
  type: TYPE_NORMAL
- en: Diamond Syntax
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we create an instance of a generic type, the righthand side of the assignment
    statement repeats the value of the type parameter. This is usually unnecessary,
    as the compiler can infer the values of the type parameters. In modern versions
    of Java, we can leave out the repeated type values in what is called *diamond
    syntax*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how to use diamond syntax, by rewriting one of
    our earlier examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This is a small improvement in the verbosity of the assignment statement—we’ve
    managed to save a few characters of typing. We’ll return to the topic of type
    inference when we discuss lambda expressions later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Type Erasure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [“Default Methods”](#javanut8-CHP-4-SECT-1.7), we discussed the Java platform’s
    strong preference for backward compatibility. The addition of generics in Java
    5 was another example of where backward compatibility was an issue for a new language
    feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'The central question was how to make a type system that allowed older, nongeneric
    collection classes to be used alongside with newer, generic collections. The design
    decision was to achieve this by the use of casts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This means that `List` and `List<String>` are compatible as types, at least
    at some level. Java achieves this compatibility by *type erasure*. This means
    that generic type parameters are only visible at compile time—they are stripped
    out by `javac` and are not reflected in the bytecode.^([1](ch04.xhtml#idm45927740773536))
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The nongeneric type `List` is usually called a *raw type*. It is still perfectly
    legal Java to work with the raw form of types, even for types that are now generic.
    This is almost always a sign of poor-quality code, however.
  prefs: []
  type: TYPE_NORMAL
- en: The mechanism of type erasure gives rise to a difference in the type system
    seen by `javac` and that seen by the JVM—we will discuss this fully in [“Compile
    and Runtime Typing”](#javanut8-CHP-4-SECT-2.10).
  prefs: []
  type: TYPE_NORMAL
- en: 'Type erasure also prohibits some other definitions, which would otherwise seem
    legal. In this code, we want to count the orders as represented in two slightly
    different data structures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This seems like perfectly legal Java code, but it will not compile. The issue
    is that although the two methods seem like normal overloads, after type erasure,
    the signature of both methods becomes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: All that is left after type erasure is the raw type of the container—in this
    case, `Map`. The runtime would be unable to distinguish between the methods by
    signature, and so the language specification makes this syntax illegal.
  prefs: []
  type: TYPE_NORMAL
- en: Bounded Type Parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider a simple generic box:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a useful abstraction, but suppose we want to have a restricted form
    of box that holds only numbers. Java allows us to achieve this by using a *bound*
    on the type parameter. This is the ability to restrict the types that can be used
    as the value of a type parameter, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The type bound `T extends Number` ensures that `T` can only be substituted with
    a type that is compatible with the type `Number`. As a result of this, the compiler
    knows that `value` will definitely have a method `intValue()` available on it.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Notice that because the `value` field has protected access, it can be accessed
    directly in the subclass.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we attempt to instantiate `NumberBox` with an invalid value for the type
    parameter, the result will be a compilation error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Beginning Java programmers should avoid using raw types altogether. Even experienced
    Java programmers can run into problems when using them. For example, when using
    raw types when working with a type bound, then the type bound can be evaded, but
    in doing so, the code is left vulnerable to a runtime exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The call to `intValue()` fails with a `java.lang.ClassCastException`—as `javac`
    has inserted an unconditional cast of `value` to `Number` before calling the method.
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, type bounds can be used to write better generic code and libraries.
    With practice, some fairly complex constructions can be built, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The definition might seem daunting, but the `ComparingBox` is really just a
    `Box` that contains a `Comparable` value. The type also extends the comparison
    operation to the `ComparingBox` type itself, just by comparing the contents of
    the two boxes.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Covariance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The design of Java’s generics contains the solution to an old problem. In the
    earliest versions of Java, before the collections libraries were even introduced,
    the language had been forced to confront a deep-seated type system design issue.
  prefs: []
  type: TYPE_NORMAL
- en: 'Put simply, the question is this:'
  prefs: []
  type: TYPE_NORMAL
- en: Should an array of strings be compatible with a variable of type array-of-object?
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In other words, should this code be legal?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Without this, then even simple methods like `Arrays::sort` would have been
    very difficult to write in a useful way, as this would not work as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The method declaration would work only for the type `Object[]` and not for
    any other array type. As a result of these complications, the very first version
    of the Java Language Standard determined that:'
  prefs: []
  type: TYPE_NORMAL
- en: If a value of type `C` can be assigned to a variable of type `P`, then a value
    of type `C[]` can be assigned to a variable of type `P[]`.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: That is, arrays’ assignment syntax *varies with* the base type that they hold,
    or arrays are *covariant*.
  prefs: []
  type: TYPE_NORMAL
- en: 'This design decision is rather unfortunate, as it leads to immediate negative
    consequences:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The assignment to `objects[0]` attempts to store an `Integer` into a piece of
    storage that is expecting to hold a `String`. This obviously will not work and
    will throw an `ArrayStoreException`.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The usefulness of covariant arrays led to them being seen as a necessary evil
    in the very early days of the platform, despite the hole in the static type system
    that the feature exposes.
  prefs: []
  type: TYPE_NORMAL
- en: However, more recent research on modern open-source codebases indicates that
    array covariance is extremely rarely used and is a language misfeature.^([2](ch04.xhtml#idm45927740053936))
    You should avoid it when writing new code.
  prefs: []
  type: TYPE_NORMAL
- en: 'When considering the behavior of generics in the Java platform, a very similar
    question can be asked: “Is `List<String>` a subtype of `List<Object>`?” That is,
    can we write this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: At first glance, this seems entirely reasonable—`String` is a subclass of `Object`,
    so we know that any `String` element in our collection is also a valid `Object`.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, consider the following code (which is just the array covariance code
    translated to use `List`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: As the type of `objects` was declared to be `List<Object>`, then it should be
    legal to add an `Object` instance to it. However, as the actual instance holds
    strings, then trying to add an `Object` would not be compatible, and so this would
    fail at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'This would have changed nothing from the case of arrays, and so the resolution
    is to realize that although this is legal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'that does not mean that the corresponding statement for generic container types
    is also true, and as a result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Another way of saying this is that `List<String>` is *not* a subtype of `List<Object>`
    or that generic types are *invariant*, not *covariant*. We will have more to say
    about this when we discuss bounded wildcards.
  prefs: []
  type: TYPE_NORMAL
- en: Wildcards
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A parameterized type, such as `ArrayList<T>`, is not *instantiable*; we cannot
    create instances of them. This is because `<T>` is just a type parameter, merely
    a placeholder for a genuine type. It is only when we provide a concrete value
    for the type parameter (e.g., `ArrayList<String>`) that the type becomes fully
    formed and we can create objects of that type.
  prefs: []
  type: TYPE_NORMAL
- en: This poses a problem if the type that we want to work with is unknown at compile
    time. Fortunately, the Java type system is able to accommodate this concept. It
    does so by having an explicit concept of the *unknown type*, which is represented
    as `<?>`. This is the simplest example of Java’s *wildcard types*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can write expressions that involve the unknown type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This is perfectly valid Java: `ArrayList<?>` is a complete type that a variable
    can have, unlike `ArrayList<T>`. We don’t know anything about `mysteryList`’s
    payload type, but that may not be a problem for our code.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, when we get an item out of `mysteryList`, it has a completely unknown
    type. However, we can be sure that the object is assignable to `Object`—because
    all valid values of a generic type parameter are reference types and all reference
    values can be assigned to a variable of type `Object`.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, when we’re working with the unknown type, there are some
    limitations on its use in user code. For example, this code will not compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The reason for this is simple: we don’t know what the payload type of `mysteryList`
    is! For example, if `mysteryList` was really a instance of `ArrayList<String>`,
    then we wouldn’t expect to be able to put an `Object` into it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The only value that we know we can always insert into a container is `null`,
    as we know that `null` is a possible value for any reference type. This isn’t
    that useful, and for this reason, the Java language spec also rules out instantiating
    a container object with the unknown type as payload, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The unknown type may seem to be of limited utility, but one very important
    use for it is as a starting point for resolving the covariance question. We can
    use the unknown type if we want to have a subtyping relationship for containers,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This means that `List<String>` *is* a subtype of `List<?>`—although when we
    use an assignment like the preceding one, we have lost some type information.
    For example, the return type of `objects.get()` is now effectively `Object`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: For any value of the type parameter `T`, `List<?>` is not a subtype of the type
    `List<T>`.
  prefs: []
  type: TYPE_NORMAL
- en: The unknown type sometimes confuses developers—provoking questions like, “Why
    wouldn’t you just use `Object` instead of the unknown type?” However, as we’ve
    seen, the need to have subtyping relationships between generic types essentially
    requires us to have a notion of the unknown type.
  prefs: []
  type: TYPE_NORMAL
- en: Bounded wildcards
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In fact, Java’s wildcard types extend beyond just the unknown type, with the
    concept of *bounded wildcards*.
  prefs: []
  type: TYPE_NORMAL
- en: These are used to describe the inheritance hierarchy of a mostly unknown type—effectively
    making statements like, for example, “I don’t know anything about this type, except
    that it must implement `List`.”
  prefs: []
  type: TYPE_NORMAL
- en: This would be written as `? extends List` in the type parameter. This provides
    a useful lifeline to programmers. Instead of being restricted to the totally unknown
    type, they know that at least the capabilities of the type bound are available.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `extends` keyword is always used, regardless of whether the constraining
    type is a class or interface type.
  prefs: []
  type: TYPE_NORMAL
- en: This is an example of a concept called *type variance*, which is the general
    theory of how inheritance between container types relates to the inheritance of
    their payload types.
  prefs: []
  type: TYPE_NORMAL
- en: Type covariance
  prefs: []
  type: TYPE_NORMAL
- en: This means that the container types have the same relationship to each other
    as the payload types do. This is expressed using the `extends` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: Type contravariance
  prefs: []
  type: TYPE_NORMAL
- en: This means that the container types have the inverse relationship to each other
    as the payload types. This is expressed using the `super` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'These ideas tend to appear when discussing container types. For example, if
    `Cat` extends `Pet`, then `List<Cat>` is a subtype of `List<? extends Pet>`, and
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this differs from the array case, because type safety is maintained
    in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The compiler cannot prove that the storage pointed at by `pets` is capable of
    storing a `Cat` and so it rejects the call to `add()`. However, as `cats` definitely
    points at a list of `Cat` objects, then it must be acceptable to add a new one
    to the list.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, it is very commonplace to see these types of generic constructions
    with types that act as producers or consumers of payload types.
  prefs: []
  type: TYPE_NORMAL
- en: For example, when the `List` is acting as a *producer* of `Pet` objects, then
    the appropriate keyword is `extends`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Note that for the producer case, the payload type appears as the return type
    of the producer method.
  prefs: []
  type: TYPE_NORMAL
- en: For a container type that is acting purely as a *consumer* of instances of a
    type, we would use the `super` keyword, and we would expect to see the payload
    type as the type of a method argument.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This is codified in the *Producer Extends, Consumer Super* (PECS) principle
    coined by Joshua Bloch.
  prefs: []
  type: TYPE_NORMAL
- en: As we will discuss in [Chapter 8](ch08.xhtml#javanut8-CHP-8), both covariance
    and contravariance appear throughout the Java Collections. They largely exist
    to ensure that the generics just “do the right thing” and behave in a manner that
    should not surprise the developer.
  prefs: []
  type: TYPE_NORMAL
- en: Generic Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *generic method* is a method that is able to take instances of any reference
    type.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at an example. In Java, the comma is used to allow multiple declarations
    in a single line (usually referred to as a *compound declaration*). Other languages,
    such as Javascript or C, have a comma operator that is much more general. The
    JS comma operator `(,)` evaluates both expressions provided to it (from left to
    right) and returns the value of the last expression. The aim is to create a compound
    expression in which multiple expressions are evaluated, with the compound expression’s
    value being the value of the rightmost of its member expressions. Note that any
    side effects from evaluating the expressions to the comma are always triggered,
    unlike in a short-circuiting logic operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Java’s comma is much more restrictive than this, by design. This is because
    the comma in other languages can lead to some very hard-to-understand code and
    can be a fantastic source of bugs. However, if we did want to emulate the behavior
    of the comma operator from other language, we could do so by creating a generic
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Calling the method `Utils.comma()` will cause the values of the expressions
    `a` and `b` to be computed, and any side effects to be triggered, before the method
    call, which is the behavior we want.
  prefs: []
  type: TYPE_NORMAL
- en: However, notice that even though a type parameter is used in the definition
    of the method, the class it is defined in (`Utils`) is not generic. Instead, we
    see that a new syntax is used to indicate that the method can be used freely,
    and that the return type is the same as the argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at another example, from the Java Collections library. In the `ArrayList`
    class we can find a method to create a new array object from an arraylist instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This method uses the low-level `arraycopy()` method to do the actual work.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If we look at the class definition for `ArrayList` we can see that it is a generic
    class—but the type parameter is `<E>`, not `<T>`, and the type parameter `<E>`
    does not appear at all in the definition of `toArray()`.
  prefs: []
  type: TYPE_NORMAL
- en: The `toArray()` method provides one half of a bridge API between the collections
    and Java’s original arrays. The other half of the API—moving from arrays to collections—involves
    a few additional subtleties, as we will discuss in [Chapter 8](ch08.xhtml#javanut8-CHP-8).
  prefs: []
  type: TYPE_NORMAL
- en: Compile and Runtime Typing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider an example piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We can ask the following question: what is the type of `l`? The answer to that
    question depends on whether we consider `l` at compile time (i.e., the type seen
    by `javac`) or at runtime (as seen by the JVM).'
  prefs: []
  type: TYPE_NORMAL
- en: '`javac` will see the type of `l` as `List-of-String` and will use that type
    information to carefully check for syntax errors, such as an attempted `add()`
    of an illegal type.'
  prefs: []
  type: TYPE_NORMAL
- en: Conversely, the JVM will see `l` as an object of type `ArrayList`, as we can
    see from the `println()` statement. The runtime type of `l` is a raw type due
    to type erasure.
  prefs: []
  type: TYPE_NORMAL
- en: The compile-time and runtime types are therefore slightly different from each
    other. The slightly strange thing is that in some ways, the runtime type is both
    more *and* less specific than the compile-time type.
  prefs: []
  type: TYPE_NORMAL
- en: The runtime type is less specific than the compile-time type, because the type
    information about the payload type is gone—it has been erased, and the resulting
    runtime type is just a raw type.
  prefs: []
  type: TYPE_NORMAL
- en: The compile-time type is less specific than the runtime type, because we don’t
    know exactly what concrete type `l` will be; all we know is that it will be of
    a type compatible with `List`.
  prefs: []
  type: TYPE_NORMAL
- en: The differences between compile-time and runtime typing sometimes confuse new
    Java programmers, but the distinction quickly comes to be seen as a normal part
    of working in the language.
  prefs: []
  type: TYPE_NORMAL
- en: Using and Designing Generic Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When working with Java’s generics, it can be helpful to think in terms of two
    different levels of understanding:'
  prefs: []
  type: TYPE_NORMAL
- en: Practitioner
  prefs: []
  type: TYPE_NORMAL
- en: A practitioner needs to use existing generic libraries and to build some fairly
    simple generic classes. At this level, the developer should also understand the
    basics of type erasure, as several Java syntax features are confusing without
    at least an awareness of the runtime handling of generics.
  prefs: []
  type: TYPE_NORMAL
- en: Designer
  prefs: []
  type: TYPE_NORMAL
- en: The designer of new libraries that use generics needs to understand much more
    of the capabilities of generics. There are some nastier parts of the spec, including
    a full understanding of wildcards, and advanced topics such as “capture-of” error
    messages.
  prefs: []
  type: TYPE_NORMAL
- en: Java generics are one of the most complex parts of the language specification
    with a lot of potential corner cases. Not every developer needs to fully understand
    this part of the language, at least not on their first encounter with this part
    of Java’s type system.
  prefs: []
  type: TYPE_NORMAL
- en: Enums and Annotations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already met records, but Java has additional specialized forms of classes
    and interfaces used to fulfill specific roles in the type system. They are known
    as *enumerated types* and *annotation types*, or normally just *enums* and *annotations*.
  prefs: []
  type: TYPE_NORMAL
- en: Enums
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Enums are a variation of classes that have limited functionality and the specific
    semantic meaning that the type has only a small number of possible permitted values.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, suppose we want to define a type to represent the primary colors
    of red, green, and blue, and we want these to be the only possible values of the
    type. We can do this by using the `enum` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The only available instances of the type `PrimaryColor` can then be referenced
    as static fields: `PrimaryColor.RED`, `PrimaryColor.GREEN`, and `PrimaryColor.BLUE`.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In other languages, such as C++, the role of enum types is fulfilled by using
    constant integers, but Java’s approach provides better type safety and more flexiblity.
  prefs: []
  type: TYPE_NORMAL
- en: As enums are specialized classes, enums can have member fields and methods.
    If they do have a body (consisting of fields or methods), then the semicolon at
    the end of the list of instances is required, and the list of enum constants must
    precede the methods and fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, suppose that we want to have an enum that encompasses the suits
    of standard playing cards. We can achieve this by using an enum that takes a value
    as a parameter, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The parameters (only one of them in this example) are passed to the constructor
    to create the individual enum instances. As the enum instances are created by
    the Java runtime, and can’t be instantiated from outside, the constructor is declared
    as private.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enums have some special properties:'
  prefs: []
  type: TYPE_NORMAL
- en: All (implicitly) extend `java.lang.Enum`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: May not be generic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: May implement interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cannot be extended
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: May have only abstract methods if all enum values provide an implementation
    body
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: May not be directly instantiated by `new`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Annotations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Annotations are a specialized kind of interface that, as the name suggests,
    annotate some part of a Java program.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider the `@Override` annotation. You may have seen it on some
    methods in some of the earlier examples and may have asked the following question:
    what does it do?'
  prefs: []
  type: TYPE_NORMAL
- en: The short, and perhaps surprising, answer is that it does nothing at all.
  prefs: []
  type: TYPE_NORMAL
- en: The less short (and flippant) answer is that, like all annotations, it has no
    direct effect but instead acts as additional information about the method that
    it annotates; in this case, it denotes that a method overrides a superclass method.
  prefs: []
  type: TYPE_NORMAL
- en: This acts as a useful hint to compilers and integrated development environments
    (IDEs)—if a developer has misspelled the name of a method intended to be an override
    of a superclass method, then the presence of the `@Override` annotation on the
    misspelled method (which does not override anything) alerts the compiler to the
    fact that something is not right.
  prefs: []
  type: TYPE_NORMAL
- en: Annotations, as originally conceived, were not supposed to alter program semantics;
    instead, they were to provide optional metadata. In its strictest sense, this
    means that they should not affect program execution and instead should only provide
    information for compilers and other pre-execution phases.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, modern Java applications make heavy use of annotations, and this
    now includes many use cases that essentially render the annotated classes useless
    without additional runtime support.
  prefs: []
  type: TYPE_NORMAL
- en: For example, classes bearing annotations such as `@Inject`, `@Test`, or `@Autowired`
    cannot realistically be used outside of a suitable container. As a result, it
    is difficult to argue that such annotations do not violate the “no semantic meaning”
    rule.
  prefs: []
  type: TYPE_NORMAL
- en: The platform defines a small number of basic annotations in `java.lang`. The
    original set were `@Override`, `@Deprecated`, and `@SuppressWarnings`, which were
    used to indicate that a method was overriden, deprecated, or that it generated
    some compiler warnings that should be suppressed.
  prefs: []
  type: TYPE_NORMAL
- en: These were augmented by `@SafeVarargs` in Java 7 (which provides extended warning
    suppression for varargs methods) and `@FunctionalInterface` in Java 8.
  prefs: []
  type: TYPE_NORMAL
- en: This last annotation indicates an interface can be used as a target for a lambda
    expression—it is a useful marker annotation although not mandatory, as we will
    see.
  prefs: []
  type: TYPE_NORMAL
- en: 'Annotations have some special properties, compared to regular interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: All (implicitly) extend `java.lang.annotation.Annotation`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: May not be generic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: May not extend any other interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: May only define zero-arg methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: May not define methods that throw exceptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Have restrictions on the return types of methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can have a default return value for methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In practice, annotations do not typically have a great deal of functionality
    and instead are a fairly simple language concept.
  prefs: []
  type: TYPE_NORMAL
- en: Defining Custom Annotations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Defining custom annotation types for use in your own code is not that hard.
    The `@interface` keyword allows the developer to define a new annotation type,
    in much the same way that `class` or `interface` is used.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The key to writing custom annotations is the use of “meta-annotations.” These
    are special annotations that appear on the definition of new (custom) annotation
    types.
  prefs: []
  type: TYPE_NORMAL
- en: The meta-annotations are defined in `java.lang.annotation` and allow the developer
    to specify policy for where the new annotation type is to be used and how it will
    be treated by the compiler and runtime.
  prefs: []
  type: TYPE_NORMAL
- en: There are two primary meta-annotations that are both required when creating
    a new annotation type—`@Target` and `@Retention`. These both take values that
    are represented as enums.
  prefs: []
  type: TYPE_NORMAL
- en: The `@Target` meta-annotation indicates where the new custom annotation can
    be legally placed within Java source code. The enum `ElementType` has the possible
    values `TYPE`, `FIELD`, `METHOD`, `PARAMETER`, `CONSTRUCTOR`, `LOCAL_VARIABLE`,
    `ANNOTATION_TYPE`, `PACKAGE`, `TYPE_PARAMETER`, and `TYPE_USE`, and annotations
    can indicate that they intend to be used at one or more of these locations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other meta-annotation is `@Retention`, which indicates how `javac` and
    the Java runtime should process the custom annotation type. It can have one of
    three values, which are represented by the enum `RetentionPolicy`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SOURCE`'
  prefs: []
  type: TYPE_NORMAL
- en: Annotations with this retention policy are discarded by `javac` during compilation.
  prefs: []
  type: TYPE_NORMAL
- en: '`CLASS`'
  prefs: []
  type: TYPE_NORMAL
- en: This means that the annotation will be present in the class file but will not
    necessarily be accessible at runtime by the JVM. This is rarely used but is sometimes
    seen in tools that do offline analysis of JVM bytecode.
  prefs: []
  type: TYPE_NORMAL
- en: '`RUNTIME`'
  prefs: []
  type: TYPE_NORMAL
- en: This indicates that the annotation will be available for user code to access
    at runtime (by using reflection).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at an example, a simple annotation called `@Nickname`, which
    allows the developer to define a nickname for a method, which can then be used
    to find the method reflectively at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This is all that’s required to define the annotation—a syntax element where
    the annotation can appear, a retention policy, and the name of the element. As
    we need to be able to supply the nickname we’re assigning to the method, we also
    need to define a method on the annotation. Despite this, defining new custom annotations
    is a remarkably compact undertaking.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the two primary meta-annotations, there are also the `@Inherited`
    and `@Documented` meta-annotations. These are much less frequently encountered
    in practice, and details on them can be found in the platform documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Type Annotations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the release of Java 8, two new values for `ElementType` were added: `TYPE_PARAMETER`
    and `TYPE_USE`. These new values allow the use of annotations in places where
    they were previously not legal, such as at any site where a type is used. This
    enables the developer to write code such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The extra type information conveyed by the `@NotNull` can then be used by a
    special type checker to detect problems (a possible `NullPointerException`, in
    this example) and to perform additional static analysis. The basic Java 8 distribution
    ships with some basic pluggable type checkers, but it also provides a framework
    for allowing developers and library authors to create their own.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we’ve met Java’s enum and annotation types. Let’s move on
    to consider the next important part of Java’s type system: lambda expressions.'
  prefs: []
  type: TYPE_NORMAL
- en: Lambda Expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most eagerly anticipated features of Java 8 was the introduction
    of lambda expressions (frequently referred to as just lambdas).
  prefs: []
  type: TYPE_NORMAL
- en: 'This major upgrade to the Java platform was driven by five goals, in roughly
    descending order of priority:'
  prefs: []
  type: TYPE_NORMAL
- en: More expressive programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Better libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concise code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improved programming safety
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Potentially increased data parallelism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Lambdas have three key aspects that help define the essential nature of the
    feature:'
  prefs: []
  type: TYPE_NORMAL
- en: They allow small bits of code to be written inline as literals in a program.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They relax the strict grammar of Java code by using type inference.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They facilitate a more functional style of programming Java.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As we saw in [Chapter 2](ch02.xhtml#javanut8-CHP-2), the syntax for a lambda
    expression is to take a list of parameters (the types of which are typically inferred),
    and to attach that to a method body, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This can provide a very compact way to represent what is effectively a single
    method. It is also a major departure from earlier versions of Java—until now,
    we always required a class declaration and then a complete method declaration,
    all of which add to the verboseness of the code.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, before the arrival of lambdas, the only way to approximate this coding
    style was to use *anonymous classes*, which we will discuss later in this chapter.
    However, since Java 8, lambdas have proved to be very popular with Java programmers
    and now have mostly taken over the role of anonymous classes.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Despite the similarities between lambda expressions and anonymous classes, lambdas
    are *not* simply syntactic sugar over anonymous classes. In fact, lambdas are
    implemented using method handles (which we will meet in [Chapter 11](ch11.xhtml#javanut8-CHP-11))
    and a special JVM bytecode called `invokedynamic`.
  prefs: []
  type: TYPE_NORMAL
- en: Lambda expressions represent the creation of an object of a specific type. The
    type of the instance that is created is known as the *target type* of the lambda.
  prefs: []
  type: TYPE_NORMAL
- en: Only certain types are eligible to be the target of a lambda.
  prefs: []
  type: TYPE_NORMAL
- en: 'Target types are also called *functional interfaces* and they must:'
  prefs: []
  type: TYPE_NORMAL
- en: Be interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Have only one nondefault method (but may have other methods that are default)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some developers also like to use the *single abstract method* (or SAM) type
    to refer to the interface type that the lambda is converted into. This draws attention
    to the fact that to be usable by the lambda expression mechanism, an interface
    must have only a single nondefault method.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: A lambda expression has almost all of the component parts of a method, with
    the obvious exception that a lambda doesn’t have a name. In fact, many developers
    like to think of lambdas as “anonymous methods.”
  prefs: []
  type: TYPE_NORMAL
- en: 'As a result, this means that the single line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: does not result in the execution of the `println()` but instead creates an object,
    which is assigned to a variable `r`, of type `Runnable`. This object, `r`, will
    execute the `println()` statement, but only when `r.run()` is called, and not
    until then.
  prefs: []
  type: TYPE_NORMAL
- en: Lambda Expression Conversion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When `javac` encounters a lambda expression, it interprets it as the body of
    a method with a specific signature—but which method?
  prefs: []
  type: TYPE_NORMAL
- en: 'To resolve this question, `javac` looks at the surrounding code. To be legal
    Java code, the lambda expression must satisfy the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: The lambda must appear where an instance of an interface type is expected.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The expected interface type should have exactly one mandatory method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The expected interface method should have a signature that exactly matches that
    of the lambda expression.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If this is the case, then an instance is created of a type that implements the
    expected interface and uses the lambda body as the implementation for the mandatory
    method.
  prefs: []
  type: TYPE_NORMAL
- en: This slightly complex conversion approach comes from the desire to keep Java’s
    type system as purely *nominative* (based on names). The lambda expression is
    said to be *converted* to an instance of the correct interface type.
  prefs: []
  type: TYPE_NORMAL
- en: From this discussion, we can see that although Java 8 has added lambda expressions,
    they have been specifically designed to fit into Java’s existing type system—which
    has a very strong emphasis on nominal types (rather than the other possible sorts
    of types that exist in some other programming languages).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider an example of lambda conversion—the `list()` method of the `java.io.File`
    class. This method lists the files in a directory. Before it returns the list,
    though, it passes the name of each file to a `FilenameFilter` object that the
    programmer must supply. This `FilenameFilter` object accepts or rejects each file
    and is a SAM type defined in the `java.io` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The type `FilenameFilter` carries the `@FunctionalInterface` to indicate that
    it is a suitable type to be used as the target type for a lambda. However, this
    annotation is not required, and any type that meets the requirements (by being
    an interface and a SAM type) can be used as a target type.
  prefs: []
  type: TYPE_NORMAL
- en: This is because the JDK and the existing corpus of Java code already had a huge
    number of SAM types available before Java 8 was released. To require potential
    target types to carry the annotation would have prevented lambdas from being retrofitted
    to existing code for no real benefit.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In code that you write, you should always try to indicate when your types are
    usable as target types, which you can do by adding the `@FunctionalInterface`
    to them. This aids readability and can help some automated tools as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how we can define a `FilenameFilter` class to list only those files
    whose names end with *.java*, using a lambda:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: For each file in the list, the block of code in the lambda expression is evaluated.
    If the method returns `true` (which happens if the filename ends in *.java*),
    then the file is included in the output—which ends up in the array `filelist`.
  prefs: []
  type: TYPE_NORMAL
- en: This pattern, where a block of code is used to test if an element of a container
    matches a condition, and to return only the elements that pass the condition,
    is called a *filter idiom*. It is one of the standard techniques of functional
    programming, which we will discuss in more depth presently.
  prefs: []
  type: TYPE_NORMAL
- en: Method References
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Recall that we can think of lambda expressions as objects representing methods
    that don’t have names. Now, consider this lambda expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'This will be autoconverted to an implementation of a `@FunctionalInterface`
    type that has a single nondefault method that takes a single `MyObject` and returns
    a `String`—specifically, the string obtained by calling `toString()` on the instance
    of `MyObject`. However, this seems like excessive boilerplate, and so Java 8 provides
    a syntax for making this easier to read and write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: This shorthand, known as a *method reference*, uses an existing method as a
    lambda expression. The method reference syntax is completely equivalent to the
    previous form expressed as a lambda. It can be thought of as using an existing
    method but ignoring the name of the method, so it can be used as a lambda and
    then autoconverted in the usual way. Java defines four types of method reference,
    which are equivalent to four slightly different lambda expression forms (see [Table 4-1](#javanut8-CHP-4-TABLE-1)).
  prefs: []
  type: TYPE_NORMAL
- en: Table 4-1\. Method references
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Method reference | Equivalent lambda |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Unbound | `Trade::getPrice` | `trade -> trade.getPrice()` |'
  prefs: []
  type: TYPE_TB
- en: '| Bound | `System.out::println` | `s -> System.out.println(s)` |'
  prefs: []
  type: TYPE_TB
- en: '| Static | `System::getProperty` | `key -> System.getProperty(key)` |'
  prefs: []
  type: TYPE_TB
- en: '| Constructor | `Trade::new` | `price -> new Trade(price)` |'
  prefs: []
  type: TYPE_TB
- en: The form we originally introduced can be seen to be an *unbound method reference*.
    When we use an unbound method reference, it is equivalent to a lambda that is
    expecting an instance of the type that contains the method reference—​in [Table 4-1](#javanut8-CHP-4-TABLE-1)
    that is a `Trade` object.
  prefs: []
  type: TYPE_NORMAL
- en: It is called an unbound method reference because the receiver object needs to
    be supplied (as the first argument to the lambda) when the method reference is
    used. That is, we are going to call `getPrice()` on some `Trade` object, but the
    supplier of the method reference has not defined which one. That is left up to
    the user of the reference.
  prefs: []
  type: TYPE_NORMAL
- en: By contrast, a *bound method reference* always includes the receiver as part
    of the instantiation of the method reference. In [Table 4-1](#javanut8-CHP-4-TABLE-1),
    the receiver is `System.out` so, when the reference is used, the `println()` method
    will always be called on `System.out`, and all the parameters of the lambda will
    be used as method parameters to `println()`.
  prefs: []
  type: TYPE_NORMAL
- en: We will discuss use cases for method references versus lambda expressions in
    more detail in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Functional Programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Java is fundamentally an object-oriented language. However, with the arrival
    of lambda expressions, it becomes much easier to write code that is closer to
    the functional approach.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: There’s no single definition of exactly what constitutes a *functional language*—but
    there is at least consensus that it should at a minimum contain the ability to
    represent a function as a value that can be put into a variable.
  prefs: []
  type: TYPE_NORMAL
- en: Java has always (since version 1.1) been able to represent functions via inner
    classes (see next section), but the syntax was complex and lacking in clarity.
    Lambda expressions greatly simplify that syntax, and so it is only natural that
    more developers will be seeking to use aspects of functional programming in their
    Java code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first taste of functional programming that Java developers are likely to
    encounter are three basic idioms that are remarkably useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '`map()`'
  prefs: []
  type: TYPE_NORMAL
- en: The map idiom is used with lists and list-like containers. The idea is that
    a function is passed in that is applied to each element in the collection, and
    a new collection is created that consists of the results of applying the function
    to each element in turn. This means that a map idiom converts a collection of
    one type to a collection of potentially a different type.
  prefs: []
  type: TYPE_NORMAL
- en: '`filter()`'
  prefs: []
  type: TYPE_NORMAL
- en: We have already met an example of the filter idiom, when we discussed how to
    replace an anonymous implementation of `FilenameFilter` with a lambda. The filter
    idiom is used for producing a new subset of a collection, based on some selection
    criteria. Note that in functional programming, it is normal to produce a new collection
    rather than modifying an existing one in place.
  prefs: []
  type: TYPE_NORMAL
- en: '`reduce()`'
  prefs: []
  type: TYPE_NORMAL
- en: The reduce idiom has several different guises. It is an aggregation operation,
    which can be called *fold*, *accumulate*, or *aggregate* as well as reduce. The
    basic idea is to take an initial value and an aggregation (or reduction) function,
    and apply the reduction function to each element in turn, building up a final
    result for the whole collection by making a series of intermediate results—similar
    to a “running total”—as the reduce operation traverses the collection.
  prefs: []
  type: TYPE_NORMAL
- en: Java has full support for these key functional idioms (and several others).
    The implementation is explained in some depth in [Chapter 8](ch08.xhtml#javanut8-CHP-8),
    where we discuss Java’s data structures and collections, and in particular the
    *stream* abstraction, which makes all of this possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s conclude this introduction with some words of caution. It’s worth noting
    that Java is best regarded as having support for “slightly functional programming.”
    It is not an especially functional language, nor does it try to be. Some particular
    aspects of Java that militate against any claims to being a functional language
    include:'
  prefs: []
  type: TYPE_NORMAL
- en: Java has no structural types, which means no “true” function types. Every lambda
    is automatically converted to the appropriate target type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type erasure causes problems for functional programming—type safety can be lost
    for higher-order functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java is inherently mutable (as we’ll discuss in [Chapter 6](ch06.xhtml#javanut8-CHP-6))—mutability
    is often regarded as highly undesirable for functional languages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Java collections are imperative, not functional. Collections must be converted
    to streams to use functional style.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Despite this, easy access to the basics of functional programing—and especially
    idioms such as map, filter, and reduce—is a huge step forward for the Java community.
    These idioms are so useful that a large majority of Java developers will never
    need or miss the more advanced capabilities provided by languages with a more
    thoroughbred functional pedigree.
  prefs: []
  type: TYPE_NORMAL
- en: In truth, many of these techniques were possible using nested types (see next
    section for details), via patterns like callbacks and handlers, but the syntax
    was always quite cumbersome, especially given that you had to explicitly define
    a completely new type even when you needed to express only a single line of code
    in the callback.
  prefs: []
  type: TYPE_NORMAL
- en: Lexical Scoping and Local Variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A local variable is defined within a block of code that defines its *scope*
    and, outside of that scope, a local variable cannot be accessed and ceases to
    exist. Only code within the curly braces that define the boundaries of a block
    can use local variables defined in that block. This type of scoping is known as
    *lexical scoping*, and it just defines a section of source code within which a
    variable can be used.
  prefs: []
  type: TYPE_NORMAL
- en: It is common for programmers to think of such a scope as *temporal* instead—that
    is, to think of a local variable as existing from the time the JVM begins executing
    the block until the time control exits the block. This is usually a reasonable
    way to think about local variables and their scope. However, lambda expressions
    (and anonymous and local classes, which we will meet later) have the ability to
    bend or break this intuition.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can cause effects that some developers initially find surprising. Because
    lambdas can use local variables, they can contain copies of values from lexical
    scopes that no longer exist. This can been seen in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Each instance of a lambda has an automatically created private copy of each
    of the final local variables it uses, so, in effect, it has its own private copy
    of the scope that existed when it was created. This is sometimes referred to as
    a *captured* variable.
  prefs: []
  type: TYPE_NORMAL
- en: Lambdas that capture variables like this are referred to as *closures*, and
    the variables are said to have been *closed over*.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Other programming languages may have a slightly different definition of a closure.
    In fact, some theorists would dispute that Java’s mechanism counts as a closure
    because, technically, it is the contents of the variable (a value) and not the
    variable itself that is captured.
  prefs: []
  type: TYPE_NORMAL
- en: 'In practice, the preceding closure example is more verbose than it needs to
    be in two separate ways:'
  prefs: []
  type: TYPE_NORMAL
- en: The lambda has an explicit scope `{}` and `return` statement.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The variable `fi` is explicitly declared `final`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The compiler `javac` helps with both of these.
  prefs: []
  type: TYPE_NORMAL
- en: Lambdas that return the value of only a single expression need not include a
    scope or `return`; instead, the body of the lambda is just the expression without
    the need for curly braces. In our example, we have explicitly included the braces
    and `return` statement to spell out that the lambda is defining its own scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'In early versions of Java, there were two hard requirements when closing over
    a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: The captures must not be modified after they have been captured (e.g., after
    the lambda)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The captured variables must be declared `final`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, in recent Java versions, `javac` can analyze the code and detect whether
    the programmer attempts to modify the captured variable after the scope of the
    lambda. If not, then the `final` qualifier on the captured variable can be omitted
    (such a variable is said to be *effectively final*). If the `final` qualifier
    is omitted, then it is a compile-time error to attempt to modify a captured variable
    after the lambda’s scope.
  prefs: []
  type: TYPE_NORMAL
- en: The reason for this is that Java implements closures by copying the bit pattern
    of the contents of the variable into the scope created by the closure. Further
    changes to the contents of the closed-over variable would not be reflected in
    the copy contained in closure scope, so the design decision was made to make such
    changes illegal and a compile-time error.
  prefs: []
  type: TYPE_NORMAL
- en: 'These assists from `javac` mean that we can rewrite the inner loop of the preceding
    example to the very compact form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Closures are very useful in some styles of programming, and different programming
    languages define and implement closures in different ways. Java implements closures
    as lambda expressions, but local classes and anonymous classes can also capture
    state—and in fact this is how Java implemented closures before lambdas were available.
  prefs: []
  type: TYPE_NORMAL
- en: Nested Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The classes, interfaces, and enum types we have seen so far in this book have
    all been defined as *top-level types*. This means that they are direct members
    of packages, defined independently of other types. However, type definitions can
    also be nested within other type definitions. These *nested types*, commonly known
    as “inner classes,” are a powerful feature of the Java language.
  prefs: []
  type: TYPE_NORMAL
- en: In general, nested types are used for two separate purposes, both related to
    encapsulation. First, a type may be nested because it needs especially intimate
    access to the internals of another type. By being a nested type, it has access
    in the same way that member variables and methods do. This means that nested types
    have privileged access and can be thought of as “slightly bending the rules of
    encapsulation.”
  prefs: []
  type: TYPE_NORMAL
- en: Another way of thinking about this use case of nested types is that they are
    types that are somehow tied together with another type. This means that they don’t
    really have a completely independent existence as an entity and only coexist.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, a type may be only required for a very specific reason and in
    a very small section of code. This means that it should be tightly localized,
    as it is really part of the implementation detail.
  prefs: []
  type: TYPE_NORMAL
- en: In older versions of Java, the only way to do this was with a nested type, such
    as an anonymous implementation of an interface. In practice, with the advent of
    Java 8, this use case has substantially been taken over by lambda expressions.
    The use of anonymous types as closely localized types has dramatically declined
    as a result, although it still persists for some cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Types can be nested within another type in four different ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Static member types
  prefs: []
  type: TYPE_NORMAL
- en: A static member type is any type defined as a `static` member of another type.
    Nested interfaces, enums, and annotations are always static (even if you don’t
    use the keyword).
  prefs: []
  type: TYPE_NORMAL
- en: Nonstatic member classes
  prefs: []
  type: TYPE_NORMAL
- en: A “nonstatic member type” is simply a member type that is not declared `static`.
    Only classes can be nonstatic member types.
  prefs: []
  type: TYPE_NORMAL
- en: Local classes
  prefs: []
  type: TYPE_NORMAL
- en: A local class is a class that is defined and only visible within a block of
    Java code. Interfaces, enums, and annotations may not be defined locally.
  prefs: []
  type: TYPE_NORMAL
- en: Anonymous classes
  prefs: []
  type: TYPE_NORMAL
- en: An anonymous class is a kind of local class that has no meaningful name that
    is useful to humans; it is merely an arbitrary name assigned by the compiler,
    which programmers should not use directly. Interfaces, enums, and annotations
    cannot be defined anonymously.
  prefs: []
  type: TYPE_NORMAL
- en: The term “nested types,” while correct and precise, is not widely used by developers.
    Instead, most Java programmers use the much vaguer term “inner class.” Depending
    on the situation, this can refer to a nonstatic member class, local class, or
    anonymous class, but not a static member type, with no real way to distinguish
    between them.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, although the terminology for describing nested types is not always
    clear, the syntax for working with them is, and it is usually apparent from context
    which kind of nested type is being discussed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Until Java 11, nested types were implemented using a compiler trick and were
    mostly syntactic sugar. Experienced Java programmers should note that this detail
    changed in Java 11, and it is no longer done in quite the same way as it used
    to be.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s move on to describe each of the four kinds of nested types in greater
    detail. Each section describes the features of the nested type, the restrictions
    on its use, and any special Java syntax used with the type.
  prefs: []
  type: TYPE_NORMAL
- en: Static Member Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A *static member type* is much like a regular top-level type. For convenience,
    however, it is nested within the namespace of another type. Static member types
    have the following basic properties:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A static member type is like the other static members of a class: static fields
    and static methods.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A static member type is not associated with any instance of the containing class
    (i.e., there is no `this` object).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A static member type can access (only) the `static` members of the class that
    contains it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A static member type has access to all the `static` members (including any other
    static member types) of its containing type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nested interfaces, enums, and annotations are implicitly static, whether or
    not the `static` keyword appears.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any type nested within an interface or annotation is also implicitly `static`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static member types may be defined within top-level types or nested to any depth
    within other static member types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A static member type may not be defined within any other kind of nested type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s look at a quick example of the syntax for static member types. [Example 4-1](#javanut8-CHP-4-EX-1)
    shows a helper interface defined as a static member of a containing interface,
    in this case Java’s `Map`.
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-1\. Defining and using a static member interface
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: When used by an external class, `Entry` will be referred to by its hierarchical
    name `Map.Entry`.
  prefs: []
  type: TYPE_NORMAL
- en: Features of static member types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A static member type has access to all static members of its containing type,
    including `private` members. The reverse is true as well: the methods of the containing
    type have access to all members of a static member type, including the `private`
    members. A static member type even has access to all the members of any other
    static member types, including the `private` members of those types. A static
    member type can use any other static member without qualifying its name with the
    name of the containing type.'
  prefs: []
  type: TYPE_NORMAL
- en: Top-level types can be declared as either `public` or package-private (if they’re
    declared without the `public` keyword). But declaring top-level types as `private`
    and `protected` wouldn’t make a great deal of sense—`protected` would just mean
    the same as package-private, and a `private` top-level class would be unable to
    be accessed by any other type.
  prefs: []
  type: TYPE_NORMAL
- en: Static member types, on the other hand, are members and so can use any access
    control modifiers that other members of the containing type can. These modifiers
    have the same meanings for static member types as they do for other members of
    a type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Under most circumstances, the `Outer.Inner` syntax for class names provides
    a helpful reminder that the inner class is interconnected with its containing
    type. However, the Java language does permit you to use the `import` directive
    to directly import a static member type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: You can then reference the nested type without including the name of its enclosing
    type (e.g., just as `Entry`).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can also use the `import static` directive to import a static member type.
    See [“Packages and the Java Namespace”](ch02.xhtml#javanut8-CHP-2-SECT-10) in
    [Chapter 2](ch02.xhtml#javanut8-CHP-2) for details on `import` and `import static`.
  prefs: []
  type: TYPE_NORMAL
- en: However, importing a nested type obscures the fact that that type is closely
    associated with its containing type—which is usually important information—and
    as a result it is not commonly done.
  prefs: []
  type: TYPE_NORMAL
- en: Nonstatic Member Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A *nonstatic member class* is a class that is declared as a member of a containing
    class or enumerated type without the `static` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: If a static member type is analogous to a class field or class method, a nonstatic
    member class is analogous to an instance field or instance method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only classes can be nonstatic member types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An instance of a nonstatic member class is always associated with an instance
    of the enclosing type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code of a nonstatic member class has access to all the fields and methods
    (both `static` and non-`static`) of its enclosing type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Several Java syntax features exist specifically to work with the enclosing instance
    of a nonstatic member class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example 4-2](#javanut8-CHP-4-EX-2) shows how a member class can be defined
    and used. This example shows a `LinkedStack` example: it defines a nested interface
    that describes the nodes of the linked list underlying the stack and a nested
    class to allow enumeration of the elements on the stack. The member class defines
    an implementation of the `java.util.Iterator` interface.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-2\. An iterator implemented as a member class
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the `LinkedIterator` class is nested within the `LinkedStack` class.
    `LinkedIterator` is a helper class used only within `LinkedStack`, so having it
    defined close to where it is used by the containing class makes for a clean design.
  prefs: []
  type: TYPE_NORMAL
- en: Features of member classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Like instance fields and instance methods, every instance of a nonstatic member
    class is associated with an instance of the class in which it is defined. This
    means that the code of a member class has access to all the instance fields and
    instance methods (as well as the `static` members) of the containing instance,
    including any that are declared `private`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This crucial feature was already illustrated in [Example 4-2](#javanut8-CHP-4-EX-2).
    Here is the `LinkedStack.LinkedIterator()` constructor again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: This single line of code sets the `current` field of the inner class to the
    value of the `head` field of the containing class. The code works as shown, even
    though `head` is declared as a `private` field in the containing class.
  prefs: []
  type: TYPE_NORMAL
- en: A nonstatic member class, like any member of a class, can be assigned one of
    the standard access control modifiers. In [Example 4-2](#javanut8-CHP-4-EX-2),
    the `LinkedIterator` class is declared `protected`, so it is inaccessible to code
    (in a different package) that uses the `LinkedStack` class but is accessible to
    any class that subclasses `LinkedStack`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Member classes have two important restrictions:'
  prefs: []
  type: TYPE_NORMAL
- en: A nonstatic member class cannot have the same name as any containing class or
    package. This is an important rule, one that is *not* shared by fields and methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nonstatic member classes cannot contain any `static` fields, methods, or types,
    except for constant fields declared both `static` and `final`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Syntax for member classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The most important feature of a member class is that it can access the instance
    fields and methods in its containing object.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to use explicit references, and make use of `this`, then we have
    to use a special syntax for explicitly referring to the containing instance of
    the `this` object. For example, if we want to be explicit in our constructor,
    we can use the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The general syntax is *`classname.this`*, where *`classname`* is the name of
    a containing class. Note that member classes can themselves contain member classes,
    nested to any depth.
  prefs: []
  type: TYPE_NORMAL
- en: However, no member class can have the same name as any containing class, so
    the use of the enclosing class name prepended to `this` is a perfectly general
    way to refer to any containing instance. Another way of saying this is that the
    syntax construction `EnclosingClass.this` is an unambiguous way of referring to
    the containing instance as an *uplevel reference*.
  prefs: []
  type: TYPE_NORMAL
- en: Local Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A *local class* is declared locally within a block of Java code rather than
    as a member of a class. Only classes may be defined locally: interfaces, enumerated
    types, and annotation types must be top-level or static member types. Typically,
    a local class is defined within a method, but it can also be defined within a
    static initializer or instance initializer of a class.'
  prefs: []
  type: TYPE_NORMAL
- en: Just as all blocks of Java code appear within class definitions, all local classes
    are nested within containing blocks. For this reason, although local classes share
    many of the features of member classes, it is usually more appropriate to think
    of them as an entirely separate kind of nested type.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: See [Chapter 5](ch05.xhtml#javanut8-CHP-5) for details as to when it’s appropriate
    to choose a local class versus a lambda expression.
  prefs: []
  type: TYPE_NORMAL
- en: The defining characteristic of a local class is that it is local to a block
    of code. Like a local variable, a local class is valid only within the scope defined
    by its enclosing block. [Example 4-3](#javanut8-CHP-4-EX-3) illustrates how we
    can modify the `iterator()` method of the `LinkedStack` class so it defines `LinkedIterator`
    as a local class instead of a member class.
  prefs: []
  type: TYPE_NORMAL
- en: By doing this, we move the definition of the class even closer to where it is
    used and hopefully improve the clarity of the code even further. For brevity,
    [Example 4-3](#javanut8-CHP-4-EX-3) shows only the `iterator()` method, not the
    entire `LinkedStack` class that contains it.
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-3\. Defining and using a local class
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Features of local classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Local classes have the following interesting features:'
  prefs: []
  type: TYPE_NORMAL
- en: Like member classes, local classes are associated with a containing instance
    and can access any members, including `private` members, of the containing class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition to accessing fields defined by the containing class, local classes
    can access any local variables, method parameters, or exception parameters that
    are in the scope of the local method definition and are declared `final`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Local classes are subject to the following restrictions:'
  prefs: []
  type: TYPE_NORMAL
- en: The name of a local class is defined only within the block that defines it;
    it can never be used outside that block. (Note, however, that instances of a local
    class created within the scope of the class can continue to exist outside of that
    scope. This situation is described in more detail later in this section.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Local classes cannot be declared `public`, `protected`, `private`, or `static`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Like member classes, and for the same reasons, local classes cannot contain
    `static` fields, methods, or classes. The only exception is for constants that
    are declared both `static` and `final`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interfaces, enumerated types, and annotation types cannot be defined locally.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A local class, like a member class, cannot have the same name as any of its
    enclosing classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As noted earlier, a local class can close over the local variables, method parameters,
    and even exception parameters that are in its scope but only if those variables
    or parameters are effectively `final`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scope of a local class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In discussing nonstatic member classes, we saw that a member class can access
    any members inherited from superclasses and any members defined by their containing
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: The same is true for local classes, but local classes can also behave like lambdas
    and access effectively `final` local variables and parameters. [Example 4-4](#javanut8-CHP-4-EX-4)
    illustrates the different kinds of fields and variables that may be accessible
    to a local class (or a lambda, for that matter).
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-4\. Fields and variables available to a local class
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Local classes have quite a complex scoping structure, therefore. To see why,
    notice that instances of a local class can have a lifetime that extends past the
    time that the JVM exits the block where the local class is defined.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In other words, if you create an instance of a local class, that instance does
    not automatically go away when the JVM finishes executing the block that defines
    the class. So, even though the definition of the class was local, instances of
    that class can escape the place they were defined.
  prefs: []
  type: TYPE_NORMAL
- en: Local classes, therefore, behave like lambdas in many regards, although the
    use case of local classes is more general than that of lambdas. However, in practice,
    the extra generality is rarely required, and lambdas are preferred wherever possible.
  prefs: []
  type: TYPE_NORMAL
- en: Anonymous Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An *anonymous class* is a local class without a name. It is defined and instantiated
    in a single expression using the `new` operator. While a local class definition
    is a statement in a block of Java code, an anonymous class definition is an expression,
    which means that it can be included as part of a larger expression, such as a
    method call.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: For the sake of completeness, we cover anonymous classes here, but for most
    use cases, lambda expressions (see [“Lambda Expressions”](#javanut8-CHP-4-SECT-4))
    have replaced anonymous classes.
  prefs: []
  type: TYPE_NORMAL
- en: Consider [Example 4-5](#javanut8-CHP-4-EX-5), which shows the `LinkedIterator`
    class implemented as an anonymous class within the `iterator()` method of the
    `LinkedStack` class. Compare it with [Example 4-4](#javanut8-CHP-4-EX-4), which
    shows the same class implemented as a local class.
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-5\. An enumeration implemented with an anonymous class
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the syntax for defining an anonymous class and creating an instance
    of that class uses the `new` keyword, followed by the name of a type and a class
    body definition in curly braces. If the name following the `new` keyword is the
    name of a class, the anonymous class is a subclass of the named class. If the
    name following `new` specifies an interface, as in the two previous examples,
    the anonymous class implements that interface and extends `Object`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The syntax for anonymous classes deliberately does not include any way to specify
    an `extends` clause, an `implements` clause, or a name for the class.
  prefs: []
  type: TYPE_NORMAL
- en: Because an anonymous class has no name, it is not possible to define a constructor
    for it within the class body. This is one of the basic restrictions on anonymous
    classes. Any arguments you specify between the parentheses following the superclass
    name in an anonymous class definition are implicitly passed to the superclass
    constructor. Anonymous classes are commonly used to subclass simple classes that
    do not take any constructor arguments, so the parentheses in the anonymous class
    definition syntax are often empty.
  prefs: []
  type: TYPE_NORMAL
- en: Because an anonymous class is just a type of local class, anonymous classes
    and local classes share the same restrictions. An anonymous class cannot define
    any `static` fields, methods, or classes, except for `static` `final` constants.
    Interfaces, enumerated types, and annotation types cannot be defined anonymously.
    Also, like local classes, anonymous classes cannot be `public`, `private`, `protected`,
    or `static`.
  prefs: []
  type: TYPE_NORMAL
- en: The syntax for defining an anonymous class combines definition with instantiation,
    similar to a lambda expression. Using an anonymous class instead of a local class
    is not appropriate if you need to create more than a single instance of the class
    each time the containing block is executed.
  prefs: []
  type: TYPE_NORMAL
- en: Describing the Java Type System
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, we have met all of the major aspects of the Java type system,
    and so it is possible for us to describe and characterize it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most important and obvious characteristics of Java’s type system are that
    it is:'
  prefs: []
  type: TYPE_NORMAL
- en: Static
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not single-rooted
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nominal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static typing, which is the most widely recognized of the three aspects, means
    that in Java, every piece of data storage (such as variables, fields, etc.) has
    a type, and that type is declared when the storage is first introduced. It is
    a compile-time error to try to put an incompatible value into storage that does
    not support it.
  prefs: []
  type: TYPE_NORMAL
- en: That Java’s type system is not single-rooted is also immediately apparent. Java
    has both primitive types and reference types. Every object in Java belongs to
    a class, and every class, except `Object`, has a single parent. This means that
    the set of classes in any Java program forms a tree structure with `Object` at
    the root.
  prefs: []
  type: TYPE_NORMAL
- en: However, there is no inheritance relationship between any of the primitive types
    and `Object`. As a result, the overall graph of Java classes consists of a large
    tree of reference types and eight disjoint, isolated points that correspond to
    the primitives. This leads to the need to use wrapper types, such as `Integer`,
    to represent primitive values as objects where necessary (such as in the Java
    Collections).
  prefs: []
  type: TYPE_NORMAL
- en: The final aspect, though, requires a bit more of a detailed discussion.
  prefs: []
  type: TYPE_NORMAL
- en: Nominal Typing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Java, each type has a name. In the normal course of Java programming, this
    will be a simple string of letters (and sometimes numbers) that has some semantic
    meaning that reflects the purpose of the type. This approach is known as *nominal
    typing*.
  prefs: []
  type: TYPE_NORMAL
- en: Not all languages have purely nominal typing; for example, some languages can
    express the idea that “this type has a method with a certain signature” without
    needing to explicitly refer to the name of the type, sometimes known as a *structural
    type*.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in Python, you can call `len()` on any object that defines a `__len__()`
    method. Of course, Python is a dynamically typed language and so will throw a
    runtime exception if the call to `len()` cannot be made. However, it is also possible
    to express a similar idea in statically typed languages, such as Scala.
  prefs: []
  type: TYPE_NORMAL
- en: 'Java, on the other hand, has no way to express this idea without using an interface,
    which, of course, has a name. Java also maintains type compatibility based strictly
    on inheritance and implementation. Let’s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The interface `MyRunnable` has a single method that exactly matches that of
    `Runnable`. However, the two interfaces have no inheritance or other relationship
    to each other and so code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'will compile cleanly but will fail with a `ClassCastException` at runtime.
    The fact that a `run()` method with an identical signature exists on both interfaces
    is not considered, and in fact the program never even makes it to the point where
    `run()` would be called: it fails on the previous line where the cast is attempted.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another important point is that the entire construction of Java’s lambda expressions,
    and especially the use of target typing to a functional interface, is to ensure
    that lambdas fit into the nominal typing approach. For example, consider an interface
    such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'then a lambda expression that yields a constant, e.g., `() -> 42`, can be used
    in a number of different ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: From this, we can see that the expression `() -> 42` is, by itself, incomplete.
    Java lambdas rely upon type inference, and so we need to see the expression in
    context with its target type for it to be meaningful. When combined with a target
    type, the lambda’s class type is “an unknown-at-compile-time implementation of
    the target interface,” and the programmer must use the interface type as the type
    of the lambda.
  prefs: []
  type: TYPE_NORMAL
- en: Beyond lambdas, there are some corner cases of nominal typing in Java. One example
    is anonymous classes, but even here the types still have names. However, the type
    names of anonymous types are automatically generated by the compiler and are specially
    chosen so as to be usable by the JVM but not accepted by the Java source code
    compiler.
  prefs: []
  type: TYPE_NORMAL
- en: There is one other corner case that we should consider, and it relates to the
    enhanced type inference introduced in recent Java versions.
  prefs: []
  type: TYPE_NORMAL
- en: Nondenotable Types and var
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'From Java 11 onwards (actually introduced in the Java 10 non-LTS release),
    Java developers can make use of a new language feature *Local Variable Type Inference*
    (LVTI), otherwise known as `var`. This is an enhancement to Java’s type inference
    capabilities that may prove to be more significant than it first appears. In the
    simplest case, it allows code such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: which moves the inference from the type of values to the type of variables.
  prefs: []
  type: TYPE_NORMAL
- en: The implementation achieves this by making `var` a reserved type name rather
    than a keyword. This means that code can still use `var` as a variable, method,
    or package name without being affected by the new syntax. However, code that has
    previously used `var` as the name of a type will have to be recompiled.
  prefs: []
  type: TYPE_NORMAL
- en: This simple case is designed to reduce verbosity and to make programmers coming
    to Java from other languages (especially Scala, .NET, and JavaScript) feel more
    comfortable. However, it does carry the risk that overuse will potentially obscure
    the intent of the code being written, so it should be used sparingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'As well as the simple cases, `var` actually permits programming constructs
    that were not possible before. To see the differences, let’s consider that `javac`
    has always permitted a very limited form of type inference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The code will compile and run, printing out `bar!`. This slightly counterintuitive
    result occurs because `javac` preserves enough type information about the anonymous
    class (i.e., that it has a `bar()` method) for just long enough that the compiler
    can conclude that the call to `bar()` is valid.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, this edge case has been [known in the Java community](https://oreil.ly/RVqng)
    since at least 2009, long before the arrival of Java 7.
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem with this form of type inference is that it has no real practical
    applications: the type of “Object-with-a-bar-method” exists within the compiler,
    but the type is impossible to express as the type of a variable—it is not a *denotable
    type*. This means that before Java 10, the existence of this type is restricted
    to a single expression and cannot be used in a larger scope.'
  prefs: []
  type: TYPE_NORMAL
- en: With the arrival of LVTI, however, the type of variables does not always need
    to be made explicit. Instead, we can use `var` to allow us to preserve the static
    type information by avoiding denoting the type.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means we can now modify our example and write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: This has allowed us to preserve the true type of `o` beyond a single expression.
    The type of `o` cannot be denoted, and so it cannot appear as the type of either
    a method parameter or return type. This means the type is still limited to only
    a single method, but it is still useful to express some constructions that would
    be awkward or impossible otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: This use of `var` as a “magic type” allows the programmer to preserve type information
    for each distinct usage of `var`, in a way that is somewhat reminiscent of bounded
    wildcards from Java’s generics.
  prefs: []
  type: TYPE_NORMAL
- en: More advanced usages of `var` with nondenotable types [are possible](https://oreil.ly/p0w-a).
    While the feature is not able to satisfy every criticism of Java’s type system,
    it does represent a definite (if cautious) step forward.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By examining Java’s type system, we have been able to build up a clear picture
    of the worldview that the Java platform has about data types. Java’s type system
    can be characterized as:'
  prefs: []
  type: TYPE_NORMAL
- en: Static
  prefs: []
  type: TYPE_NORMAL
- en: All Java variables have types that are known at compile time.
  prefs: []
  type: TYPE_NORMAL
- en: Nominal
  prefs: []
  type: TYPE_NORMAL
- en: The name of a Java type is of paramount importance. Java does not permit structural
    types and has only limited support for nondenotable types.
  prefs: []
  type: TYPE_NORMAL
- en: Object/imperative
  prefs: []
  type: TYPE_NORMAL
- en: Java code is object-oriented, and all code must live inside methods, which must
    live inside classes. However, Java’s primitive types prevent full adoption of
    the “everything is an object” worldview.
  prefs: []
  type: TYPE_NORMAL
- en: Slightly functional
  prefs: []
  type: TYPE_NORMAL
- en: Java provides support for some of the more common functional idioms but more
    as a convenience to programmers than anything else.
  prefs: []
  type: TYPE_NORMAL
- en: Type-inferred
  prefs: []
  type: TYPE_NORMAL
- en: Java is optimized for readability (even by novice progammers) and prefers to
    be explicit but uses type inference to reduce boilerplate where it does not impact
    the legibility of the code.
  prefs: []
  type: TYPE_NORMAL
- en: Strongly backward compatible
  prefs: []
  type: TYPE_NORMAL
- en: Java is primarily a business-focused language, and backward compatibility and
    protection of existing codebases are very high priorities.
  prefs: []
  type: TYPE_NORMAL
- en: Type erased
  prefs: []
  type: TYPE_NORMAL
- en: Java permits parameterized types, but this information is not available at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Java’s type system has evolved (albeit slowly and cautiously) over the years—and
    is now on par with the type systems of other mainstream programming languages.
    Lambda expressions, along with default methods, represent the greatest transformation
    since the advent of Java 5 and the introduction of generics, annotations, and
    related innovations.
  prefs: []
  type: TYPE_NORMAL
- en: Default methods represent a major shift in Java’s approach to object-oriented
    programming—perhaps the biggest since the language’s inception. From Java 8 onward,
    interfaces can contain implementation code. This fundamentally changes Java’s
    nature. Previously a single-inherited language, Java is now multiply inherited
    (but only for behavior—there is still no multiple inheritance of state).
  prefs: []
  type: TYPE_NORMAL
- en: Despite all of these innovations, Java’s type system is not (and is not intended
    to be) equipped with the power of the type systems of languages such as Scala
    or Haskell. Instead, Java’s type system is strongly biased in favor of simplicity,
    readability, and a simple learning curve for newcomers.
  prefs: []
  type: TYPE_NORMAL
- en: Java has also benefited enormously from the approaches to types developed in
    other languages over the last 10 years. Scala’s example of a statically typed
    language that nevertheless achieves much of the feel of a dynamically typed language
    through the use of type inference has been a good source of ideas for features
    to add to Java, even though the languages have quite different design philosophies.
  prefs: []
  type: TYPE_NORMAL
- en: One remaining question is whether the modest support for functional idioms that
    lambda expressions provide in Java is sufficient for the majority of Java programmers.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The long-term direction of Java’s type system is being explored in research
    projects such as Valhalla, where concepts such as data classes, pattern matching,
    and sealed classes are being explored.
  prefs: []
  type: TYPE_NORMAL
- en: It remains to be seen whether the majority of ordinary Java programmers require
    the added power—and attendant complexity—that comes from an advanced (and much
    less nominal) type system such as Scala’s, or whether the “slightly functional
    programming” introduced in Java 8 (e.g., *map*, *filter*, *reduce*, and their
    peers) will suffice for most developers’ needs.
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch04.xhtml#idm45927740773536-marker)) Some small traces of generics remain,
    which can be seen at runtime via reflection.
  prefs: []
  type: TYPE_NORMAL
- en: '^([2](ch04.xhtml#idm45927740053936-marker)) Raoul-Gabriel Urma and Janina Voigt,
    “Using the OpenJDK to Investigate Covariance in Java,” *Java Magazine* (May/June
    2012): 44–47.'
  prefs: []
  type: TYPE_NORMAL
