<html><head></head><body>
<div id="sbo-rt-content"><section data-pdf-bookmark="Chapter 12. Recursion" data-type="chapter" epub:type="chapter"><div class="chapter" id="_02-recursion">
<h1><span class="label">Chapter 12. </span>Recursion</h1>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45115220646752">
<h1>A Note for Early Release Readers</h1>
<p>With Early Release ebooks, you get books in their earliest form—the author’s raw and unedited content as they write—so you can take advantage of these technologies long before the official release of these titles.</p>
<p>This will be the 12th chapter of the final book. Please note that the GitHub repo will be made active later on.</p>
<p>If you have comments about how we might improve the content and/or examples in this book, or if you notice missing material within this chapter, please reach out to the editor at <em>rfernando@oreilly.com</em>.</p>
</div></aside>
<p>Recursion is an approach to solving a problem that can be broken down into smaller versions of itself.
Many developers see <em>recursion</em> as another — often complicated — approach to iteration-based problem-solving.
Still, it’s good to know different techniques for particular groups of problems in a functional way.</p>
<p>This chapter shows the general idea behind recursion, how you implement recursive methods, and their place in your Java code compared to other forms of iteration.</p>
<section data-pdf-bookmark="What is Recursion?" data-type="sect1"><div class="sect1" id="_02-recursion_mathematical-explanation">
<h1>What is Recursion?</h1>
<p>In <a data-type="xref" href="ch01.xhtml#_01-an-introduction_recursion">“Recursion”</a>, you’ve seen an illustration of calculating factorials — the product of all positive integers less than or equal to the input parameter.
Many books, guides, and tutorials use factorials to demonstrate recursion because it’s a perfect problem to solve partially, and it’ll be the first example of this chapter, too.</p>
<p>Every step of calculating factorials breaks down into the product of the input parameter and the result of the next factorial operation.
When the calculation reaches <code>fac(1)</code> — defined as “1" — the chain terminates and provides the value to the previous step.
The complete steps can be seen in <a data-type="xref" href="#_02-recursion_factorial_steps">Equation 12-1</a>.</p>
<div data-type="equation" id="_02-recursion_factorial_steps">
<h5><span class="label">Equation 12-1. </span>Formal representation of a factorial calculation</h5>
<math alttext="StartLayout 1st Row 1st Column Blank 2nd Column f a c left-parenthesis n right-parenthesis 2nd Row 1st Column right-arrow 2nd Column n asterisk f a c left-parenthesis n minus 1 right-parenthesis 3rd Row 1st Column right-arrow 2nd Column n asterisk left-parenthesis n minus 1 right-parenthesis asterisk f a c left-parenthesis n minus 2 right-parenthesis 4th Row 1st Column right-arrow 2nd Column 4 asterisk left-parenthesis n minus 1 right-parenthesis asterisk left-parenthesis n minus 2 right-parenthesis asterisk ellipsis asterisk f a c left-parenthesis 1 right-parenthesis 5th Row 1st Column right-arrow 2nd Column 4 asterisk left-parenthesis n minus 1 right-parenthesis asterisk left-parenthesis n minus 2 right-parenthesis asterisk ellipsis asterisk 1 EndLayout" display="block">
<mtable displaystyle="true">
<mtr>
<mtd/>
<mtd columnalign="left">
<mrow>
<mi>f</mi>
<mi>a</mi>
<mi>c</mi>
<mo>(</mo>
<mi>n</mi>
<mo>)</mo>
</mrow>
</mtd>
</mtr>
<mtr>
<mtd columnalign="right">
<mo>→</mo>
</mtd>
<mtd columnalign="left">
<mrow>
<mi>n</mi>
<mo>*</mo>
<mi>f</mi>
<mi>a</mi>
<mi>c</mi>
<mo>(</mo>
<mi>n</mi>
<mo>-</mo>
<mn>1</mn>
<mo>)</mo>
</mrow>
</mtd>
</mtr>
<mtr>
<mtd columnalign="right">
<mo>→</mo>
</mtd>
<mtd columnalign="left">
<mrow>
<mi>n</mi>
<mo>*</mo>
<mo>(</mo>
<mi>n</mi>
<mo>-</mo>
<mn>1</mn>
<mo>)</mo>
<mo>*</mo>
<mi>f</mi>
<mi>a</mi>
<mi>c</mi>
<mo>(</mo>
<mi>n</mi>
<mo>-</mo>
<mn>2</mn>
<mo>)</mo>
</mrow>
</mtd>
</mtr>
<mtr>
<mtd columnalign="right">
<mo>→</mo>
</mtd>
<mtd columnalign="left">
<mrow>
<mn>4</mn>
<mo>*</mo>
<mo>(</mo>
<mi>n</mi>
<mo>-</mo>
<mn>1</mn>
<mo>)</mo>
<mo>*</mo>
<mo>(</mo>
<mi>n</mi>
<mo>-</mo>
<mn>2</mn>
<mo>)</mo>
<mo>*</mo>
<mo>⋯</mo>
<mo>*</mo>
<mi>f</mi>
<mi>a</mi>
<mi>c</mi>
<mo>(</mo>
<mn>1</mn>
<mo>)</mo>
</mrow>
</mtd>
</mtr>
<mtr>
<mtd columnalign="right">
<mo>→</mo>
</mtd>
<mtd columnalign="left">
<mrow>
<mn>4</mn>
<mo>*</mo>
<mo>(</mo>
<mi>n</mi>
<mo>-</mo>
<mn>1</mn>
<mo>)</mo>
<mo>*</mo>
<mo>(</mo>
<mi>n</mi>
<mo>-</mo>
<mn>2</mn>
<mo>)</mo>
<mo>*</mo>
<mo>⋯</mo>
<mo>*</mo>
<mn>1</mn>
</mrow>
</mtd>
</mtr>
</mtable>
</math>
</div>
<p>This generalization of the calculation steps visualizes the underlying concept of recursion:
solving a problem by combining smaller instances of the same problem.
This is done using methods that call themselves with modified arguments until a base condition is reached.</p>
<p>Recursion consists of two distinct operation types:</p>
<dl>
<dt>Base conditions</dt>
<dd>
<p>A base condition is a predefined case — a <em>solution</em> to the problem — which will return an actual value and unwind the recursive call chain.
It provides its value to the previous step, which can now calculate a result and return it to its predecessor, and so forth.</p>
</dd>
<dt>Recursive call</dt>
<dd>
<p>Until the call chain reaches its <em>base condition</em>, every step will create another one by calling itself with modified input parameters.</p>
</dd>
</dl>
<p><a data-type="xref" href="#_02-recursion_smalller_problems">Figure 12-1</a> shows the general flow of a recursive call chain.</p>
<figure><div class="figure" id="_02-recursion_smalller_problems">
<img alt="Solving problems with smaller problems" height="500" src="assets/afaj_1201.png" width="600"/>
<h6><span class="label">Figure 12-1. </span>Solving problems with smaller problems</h6>
</div></figure>
<p>The problem becomes smaller until a solution is found for the smallest part.
This solution will then become an input for the next bigger problem, and so on until the sum of all parts builds the solution to the original problem.</p>
<section data-pdf-bookmark="Head Versus Tail Recursion" data-type="sect2"><div class="sect2" id="idm45115220580784">
<h2>Head Versus Tail Recursion</h2>
<p>Recursive calls fall into two categories, <em>head</em> and <em>tail</em> recursion, depending on the location of the recursive call in the method body:</p>
<dl>
<dt>Head recursion</dt>
<dd>
<p>Other statements/expressions are executed/evaluated after the recursive method call, making it not the last statement.</p>
</dd>
<dt>Tail recursion</dt>
<dd>
<p>The recursive call is the last statement of the method without any further calculations linking its result to the current call.</p>
</dd>
</dl>
<p>Let’s look at calculating a factorial with both types to illustrate their differences better.
<a data-type="xref" href="#_02-recursion_factorial_head">Example 12-1</a> shows how to use head recursion.</p>
<div data-type="example" id="_02-recursion_factorial_head">
<h5><span class="label">Example 12-1. </span>Calculating factorials with head recursion</h5>
<pre data-code-language="java" data-type="programlisting"><code class="kt">long</code> <code class="nf">factorialHead</code><code class="p">(</code><code class="kt">long</code> <code class="n">n</code><code class="p">)</code> <code class="p">{</code> <a class="co" href="#callout_recursion_CO1-1" id="co_recursion_CO1-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a>

  <code class="k">if</code> <code class="p">(</code><code class="n">n</code> <code class="o">=</code><code class="o">=</code> <code class="mi">1L</code><code class="p">)</code> <code class="p">{</code> <a class="co" href="#callout_recursion_CO1-2" id="co_recursion_CO1-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a>
    <code class="k">return</code> <code class="mi">1L</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="kd">var</code> <code class="n">nextN</code> <code class="o">=</code> <code class="n">n</code> <code class="o">-</code> <code class="mi">1L</code><code class="p">;</code>

  <code class="k">return</code> <code class="n">n</code> <code class="o">*</code> <code class="n">factorialHead</code><code class="p">(</code><code class="n">nextN</code><code class="p">)</code><code class="p">;</code> <a class="co" href="#callout_recursion_CO1-3" id="co_recursion_CO1-3"><img alt="3" height="12" src="assets/3.png" width="12"/></a>
<code class="p">}</code>

<code class="kd">var</code> <code class="n">result</code> <code class="o">=</code> <code class="n">factorialHead</code><code class="p">(</code><code class="mi">4L</code><code class="p">)</code><code class="p">;</code>
<code class="c1">// =&gt; 24</code></pre></div>
<dl class="calloutlist">
<dt><a class="co" href="#co_recursion_CO1-1" id="callout_recursion_CO1-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p>The method signature only contains the input parameter of the current recursive step.
No intermediate state moves between the recursive calls.</p></dd>
<dt><a class="co" href="#co_recursion_CO1-2" id="callout_recursion_CO1-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a></dt>
<dd><p>The base condition must come before the recursive call.</p></dd>
<dt><a class="co" href="#co_recursion_CO1-3" id="callout_recursion_CO1-3"><img alt="3" height="12" src="assets/3.png" width="12"/></a></dt>
<dd><p>The return value is an expression depending on the result of the recursive call, making it not the sole last statement in the method.</p></dd>
</dl>
<p>Now it’s time to look at tail recursion, as shown in <a data-type="xref" href="#_02-recursion_factorial_tail">Example 12-2</a>.</p>
<div data-type="example" id="_02-recursion_factorial_tail">
<h5><span class="label">Example 12-2. </span>Calculating factorials with tail recursion</h5>
<pre data-code-language="java" data-type="programlisting"><code class="kt">long</code> <code class="nf">factorialTail</code><code class="p">(</code><code class="kt">long</code> <code class="n">n</code><code class="p">,</code> <code class="kt">long</code> <code class="n">accumulator</code><code class="p">)</code> <code class="p">{</code> <a class="co" href="#callout_recursion_CO2-1" id="co_recursion_CO2-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a>

  <code class="k">if</code> <code class="p">(</code><code class="n">n</code> <code class="o">=</code><code class="o">=</code> <code class="mi">1L</code><code class="p">)</code> <code class="p">{</code> <a class="co" href="#callout_recursion_CO2-2" id="co_recursion_CO2-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a>
    <code class="k">return</code> <code class="n">accumulator</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="kd">var</code> <code class="n">nextN</code> <code class="o">=</code> <code class="n">n</code> <code class="o">-</code> <code class="mi">1L</code><code class="p">;</code>
  <code class="kd">var</code> <code class="n">nextAccumulator</code> <code class="o">=</code> <code class="n">n</code> <code class="o">*</code> <code class="n">accumulator</code><code class="p">;</code>

  <code class="k">return</code> <code class="n">factorialTail</code><code class="p">(</code><code class="n">nextN</code><code class="p">,</code> <code class="n">nextAccumulator</code><code class="p">)</code><code class="p">;</code> <a class="co" href="#callout_recursion_CO2-3" id="co_recursion_CO2-3"><img alt="3" height="12" src="assets/3.png" width="12"/></a>
<code class="p">}</code>

<code class="kd">var</code> <code class="n">result</code> <code class="o">=</code> <code class="n">factorialTail</code><code class="p">(</code><code class="mi">4L</code><code class="p">,</code> <code class="mi">1L</code><code class="p">)</code><code class="p">;</code> <a class="co" href="#callout_recursion_CO2-4" id="co_recursion_CO2-4"><img alt="4" height="12" src="assets/4.png" width="12"/></a>
<code class="c1">// =&gt; 24</code></pre></div>
<dl class="calloutlist">
<dt><a class="co" href="#co_recursion_CO2-1" id="callout_recursion_CO2-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p>The method signature contains an accumulator.</p></dd>
<dt><a class="co" href="#co_recursion_CO2-2" id="callout_recursion_CO2-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a></dt>
<dd><p>The base condition hasn’t changed compared to head recursion.</p></dd>
<dt><a class="co" href="#co_recursion_CO2-3" id="callout_recursion_CO2-3"><img alt="3" height="12" src="assets/3.png" width="12"/></a></dt>
<dd><p>Instead of returning an expression dependent on the next recursive call, both <code>factorialTail</code> parameters are evaluated beforehand.
The method only returns the recursive call itself.</p></dd>
<dt><a class="co" href="#co_recursion_CO2-4" id="callout_recursion_CO2-4"><img alt="4" height="12" src="assets/4.png" width="12"/></a></dt>
<dd><p>The accumulator requires an initial value.
It reflects the base condition.</p></dd>
</dl>
<p>The main difference between head and tail recursion is how the call stack is constructed.</p>
<p>With <em>head recursion</em>, the recursive call is performed before returning a value.
Therefore, the final result won’t be available until the runtime has returned from each recursive call.</p>
<p>With <em>tail recursion</em>, the broken-down problem is solved first before the result is passed on to the next recursive call.
Essentially, the return value of any given recursive step is the same as the result of the next recursive call.
This allows for optimizing the call stack if the runtime supports it, as you will see in the next section.</p>
</div></section>
<section data-pdf-bookmark="Recursion and the Call Stack" data-type="sect2"><div class="sect2" id="idm45115220284304">
<h2>Recursion and the Call Stack</h2>
<p>If you look at <a data-type="xref" href="#_02-recursion_smalller_problems">Figure 12-1</a> again, you can think of every box as a separate method call and, therefore, a new stack frame on the call stack.
That is a necessity because every box must be isolated from previous calculations so that their arguments won’t affect each other.
The total recursive call count is only constrained by how long it takes to reach a base condition.
The problem is, though, that the available stack size is finite.
Too many calls will fill up the available stack space and eventually throw a <code>StackOverflowError</code>.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>A stack frame contains the state of a single method invocation.
Each time your code calls a method, the JVM creates and pushes a new frame on the thread’s stack.
After returning from a method, its stack frame gets popped and discarded.</p>
<p>The actual maximum stack depth depends on the available stack size<sup><a data-type="noteref" href="ch12.xhtml#idm45115220279984" id="idm45115220279984-marker">1</a></sup>, and what’s stored in the individual frames.</p>
</div>
<p>To prevent the stack from overflowing, many modern compilers use <em>tail-call optimization/elimination</em> to remove no longer required frames in recursive call chains.
If no additional calculations take place after a recursive call, the stack frame is no longer needed and can be removed.
That reduces the stack frame space complexity of the recursive call from <code>O(N)</code> to <code>O(1)</code>, resulting in faster and more memory-friendly machine code without an overflowing stack.</p>
<p>Sadly, the Java compiler and runtime lack that particular ability yet, as of early 2023.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45115220275280">
<h1>Project Loom</h1>
<p><a href="https://openjdk.java.net/projects/loom/">Project Loom</a>, an effort to support easy-to-use, high-throughput lightweight concurrency and new programming models, will add support for stack frame manipulation.
The JVM gains support for unwinding the stack to some point and invoking a method with given arguments, a feature called <em>unwind-and-inkove</em>.</p>
<p>That allows for efficient tail-calls, even though automatic tail-call optimization is not an explicitly stated project goal.
Nevertheless, these pleasant changes to the runtime might lower the barriers to using recursion more often and more efficiently.</p>
</div></aside>
<p>Nevertheless, recursion is still a valuable tool for a subset of particular problems, even without optimization of the call stack.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="A More Complex Example" data-type="sect1"><div class="sect1" id="idm45115220641888">
<h1>A More Complex Example</h1>
<p>As good as calculating a factorial is for explaining recursion, it isn’t a typical “real-world” problem.
That’s why it’s time to look at a more realistic example: traversing a tree-like data structure, as seen in <a data-type="xref" href="#_02-recursion_tree">Figure 12-2</a>.</p>
<figure><div class="figure" id="_02-recursion_tree">
<img alt="Tree-like data structure traversal" height="250" src="assets/afaj_1202.png" width="390"/>
<h6><span class="label">Figure 12-2. </span>Tree-like data structure traversal</h6>
</div></figure>
<p>The data structure has a single root node, and every node has an optional left and right child node.
Their numbers are for identification, not the order of any traversal.</p>
<p>The nodes are represented by a generic Record <code>Node&lt;T&gt;</code>, as shown in <a data-type="xref" href="#_02-recursion_tree-node">Example 12-3</a>.</p>
<div data-type="example" id="_02-recursion_tree-node">
<h5><span class="label">Example 12-3. </span>Tree node structure</h5>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">record</code> <code class="nc">Node</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="p">(</code><code class="n">T</code> <code class="n">value</code><code class="p">,</code> <code class="n">Node</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code> <code class="n">left</code><code class="p">,</code> <code class="n">Node</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code> <code class="n">right</code><code class="p">)</code> <code class="p">{</code>

  <code class="kd">public</code> <code class="kd">static</code> <code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code> <code class="n">Node</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code> <code class="nf">of</code><code class="p">(</code><code class="n">T</code> <code class="n">value</code><code class="p">,</code> <code class="n">Node</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code> <code class="n">left</code><code class="p">,</code> <code class="n">Node</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code> <code class="n">right</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">new</code> <code class="n">Node</code><code class="o">&lt;&gt;</code><code class="p">(</code><code class="n">value</code><code class="p">,</code> <code class="n">left</code><code class="p">,</code> <code class="n">right</code><code class="p">);</code>
  <code class="p">}</code>

  <code class="kd">public</code> <code class="kd">static</code> <code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code> <code class="n">Node</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code> <code class="nf">of</code><code class="p">(</code><code class="n">T</code> <code class="n">value</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">new</code> <code class="n">Node</code><code class="o">&lt;&gt;</code><code class="p">(</code><code class="n">value</code><code class="p">,</code> <code class="kc">null</code><code class="p">,</code> <code class="kc">null</code><code class="p">);</code>
  <code class="p">}</code>

  <code class="kd">public</code> <code class="kd">static</code> <code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code> <code class="n">Node</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code> <code class="nf">left</code><code class="p">(</code><code class="n">T</code> <code class="n">value</code><code class="p">,</code> <code class="n">Node</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code> <code class="n">left</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">new</code> <code class="n">Node</code><code class="o">&lt;&gt;</code><code class="p">(</code><code class="n">value</code><code class="p">,</code> <code class="n">left</code><code class="p">,</code> <code class="kc">null</code><code class="p">);</code>
  <code class="p">}</code>

  <code class="kd">public</code> <code class="kd">static</code> <code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code> <code class="n">Node</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code> <code class="nf">right</code><code class="p">(</code><code class="n">T</code> <code class="n">value</code><code class="p">,</code> <code class="n">Node</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code> <code class="n">right</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">new</code> <code class="n">Node</code><code class="o">&lt;&gt;</code><code class="p">(</code><code class="n">value</code><code class="p">,</code> <code class="kc">null</code><code class="p">,</code> <code class="n">right</code><code class="p">);</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="kd">var</code> <code class="n">root</code> <code class="o">=</code> <code class="n">Node</code><code class="p">.</code><code class="na">of</code><code class="p">(</code><code class="s">"1"</code><code class="p">,</code>
                   <code class="n">Node</code><code class="p">.</code><code class="na">of</code><code class="p">(</code><code class="s">"2"</code><code class="p">,</code>
                           <code class="n">Node</code><code class="p">.</code><code class="na">of</code><code class="p">(</code><code class="s">"4"</code><code class="p">,</code>
                                   <code class="n">Node</code><code class="p">.</code><code class="na">of</code><code class="p">(</code><code class="s">"7"</code><code class="p">),</code>
                                   <code class="n">Node</code><code class="p">.</code><code class="na">of</code><code class="p">(</code><code class="s">"8"</code><code class="p">)),</code>
                           <code class="n">Node</code><code class="p">.</code><code class="na">of</code><code class="p">(</code><code class="s">"5"</code><code class="p">)),</code>
                   <code class="n">Node</code><code class="p">.</code><code class="na">right</code><code class="p">(</code><code class="s">"3"</code><code class="p">,</code>
                              <code class="n">Node</code><code class="p">.</code><code class="na">left</code><code class="p">(</code><code class="s">"6"</code><code class="p">,</code>
                                        <code class="n">Node</code><code class="p">.</code><code class="na">of</code><code class="p">(</code><code class="s">"9"</code><code class="p">))));</code></pre></div>
<p>The goal is to traverse the tree “in order.”
That means every node’s left child node is traversed first until no other left node is found.
Then it will continue traversing down its right child’s left nodes before going up again.</p>
<p>First, we will implement the tree-traversal with an iterative approach and then compare it to a recursive one.</p>
<section data-pdf-bookmark="Iterative Tree-Traversal" data-type="sect2"><div class="sect2" id="idm45115219963888">
<h2>Iterative Tree-Traversal</h2>
<p>With the help of a <code>while</code> loop, traversing the tree is as you would expect.
It requires temporary variables and coordination boilerplate for traversal, as seen in <a data-type="xref" href="#_02-recursion_tree-iterative">Example 12-4</a>.</p>
<div data-type="example" id="_02-recursion_tree-iterative">
<h5><span class="label">Example 12-4. </span>Iterative tree traversal</h5>
<pre data-code-language="java" data-type="programlisting"><code class="kt">void</code> <code class="nf">traverseIterative</code><code class="p">(</code><code class="n">Node</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code> <code class="n">root</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">var</code> <code class="n">tmpNodes</code> <code class="o">=</code> <code class="k">new</code> <code class="n">Stack</code><code class="o">&lt;</code><code class="n">Node</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code><code class="o">&gt;</code><code class="p">(</code><code class="p">)</code><code class="p">;</code> <a class="co" href="#callout_recursion_CO3-1" id="co_recursion_CO3-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a>
  <code class="kd">var</code> <code class="n">current</code> <code class="o">=</code> <code class="n">root</code><code class="p">;</code>

  <code class="k">while</code><code class="p">(</code><code class="o">!</code><code class="n">tmpNodes</code><code class="p">.</code><code class="na">isEmpty</code><code class="p">(</code><code class="p">)</code> <code class="o">|</code><code class="o">|</code> <code class="n">current</code> <code class="o">!</code><code class="o">=</code> <code class="kc">null</code><code class="p">)</code> <code class="p">{</code> <a class="co" href="#callout_recursion_CO3-2" id="co_recursion_CO3-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a>

    <code class="k">if</code> <code class="p">(</code><code class="n">current</code> <code class="o">!</code><code class="o">=</code> <code class="kc">null</code><code class="p">)</code> <code class="p">{</code> <a class="co" href="#callout_recursion_CO3-3" id="co_recursion_CO3-3"><img alt="3" height="12" src="assets/3.png" width="12"/></a>
      <code class="n">tmpNodes</code><code class="p">.</code><code class="na">push</code><code class="p">(</code><code class="n">current</code><code class="p">)</code><code class="p">;</code>
      <code class="n">current</code> <code class="o">=</code> <code class="n">current</code><code class="p">.</code><code class="na">left</code><code class="p">(</code><code class="p">)</code><code class="p">;</code>
      <code class="k">continue</code><code class="p">;</code>
    <code class="p">}</code>

    <code class="n">current</code> <code class="o">=</code> <code class="n">tmpNodes</code><code class="p">.</code><code class="na">pop</code><code class="p">(</code><code class="p">)</code><code class="p">;</code> <a class="co" href="#callout_recursion_CO3-4" id="co_recursion_CO3-4"><img alt="4" height="12" src="assets/4.png" width="12"/></a>

    <code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">print</code><code class="p">(</code><code class="n">current</code><code class="p">.</code><code class="na">value</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code class="p">;</code> <a class="co" href="#callout_recursion_CO3-5" id="co_recursion_CO3-5"><img alt="5" height="12" src="assets/5.png" width="12"/></a>

    <code class="n">current</code> <code class="o">=</code> <code class="n">current</code><code class="p">.</code><code class="na">right</code><code class="p">(</code><code class="p">)</code><code class="p">;</code> <a class="co" href="#callout_recursion_CO3-6" id="co_recursion_CO3-6"><img alt="6" height="12" src="assets/6.png" width="12"/></a>
  <code class="p">}</code>
<code class="p">}</code></pre></div>
<dl class="calloutlist">
<dt><a class="co" href="#co_recursion_CO3-1" id="callout_recursion_CO3-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p>Auxiliary variables are required to save the current state of the iteration.</p></dd>
<dt><a class="co" href="#co_recursion_CO3-2" id="callout_recursion_CO3-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a></dt>
<dd><p>Iterate until no node is present, or <code>nodeStack</code> isn’t empty.</p></dd>
<dt><a class="co" href="#co_recursion_CO3-3" id="callout_recursion_CO3-3"><img alt="3" height="12" src="assets/3.png" width="12"/></a></dt>
<dd><p>A <code>java.util.Stack</code> saves all nodes until the bottom is reached.</p></dd>
<dt><a class="co" href="#co_recursion_CO3-4" id="callout_recursion_CO3-4"><img alt="4" height="12" src="assets/4.png" width="12"/></a></dt>
<dd><p>At this point, the loop can’t go deeper because it encountered <code>current == null</code>, so it sets <code>current</code> to the last node saved in <code>tmpNodes</code>.</p></dd>
<dt><a class="co" href="#co_recursion_CO3-5" id="callout_recursion_CO3-5"><img alt="5" height="12" src="assets/5.png" width="12"/></a></dt>
<dd><p>Output the node value.</p></dd>
<dt><a class="co" href="#co_recursion_CO3-6" id="callout_recursion_CO3-6"><img alt="6" height="12" src="assets/6.png" width="12"/></a></dt>
<dd><p>Rinse and repeat with the right child node.</p></dd>
</dl>
<p>The output is as expected: <em>748251396</em>.</p>
<p>Although it works as intended, the code isn’t very concise and requires mutable auxiliary variables to work properly.</p>
<p>Let’s take a look at the recursive approach to see if it’s an improvement over iteration.</p>
</div></section>
<section data-pdf-bookmark="Recursive Tree-Traversal" data-type="sect2"><div class="sect2" id="idm45115219637744">
<h2>Recursive Tree-Traversal</h2>
<p>To create a recursive solution to traverse the tree, you must first clearly define the different steps needed, including the base condition.</p>
<p>Traversing the tree requires two recursive calls, an action, and a base condition:</p>
<ul>
<li>
<p>Traverse the left node</p>
</li>
<li>
<p>Traverse the right node</p>
</li>
<li>
<p>Print a node’s value</p>
</li>
<li>
<p>Stop if no further nodes are found</p>
</li>
</ul>
<p>The Java implementation of these different steps in their correct order is shown in <a data-type="xref" href="#_02-recursion_tree-iterative-simple">Example 12-5</a>.</p>
<div data-type="example" id="_02-recursion_tree-iterative-simple">
<h5><span class="label">Example 12-5. </span>Recursive tree traversal</h5>
<pre data-code-language="java" data-type="programlisting"><code class="kt">void</code> <code class="nf">traverseRecursion</code><code class="p">(</code><code class="n">Node</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code> <code class="n">node</code><code class="p">)</code> <code class="p">{</code>
  <code class="k">if</code> <code class="p">(</code><code class="n">node</code> <code class="o">=</code><code class="o">=</code> <code class="kc">null</code><code class="p">)</code> <code class="p">{</code> <a class="co" href="#callout_recursion_CO4-1" id="co_recursion_CO4-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a>
    <code class="k">return</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="n">traverseRecursion</code><code class="p">(</code><code class="n">node</code><code class="p">.</code><code class="na">left</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code class="p">;</code> <a class="co" href="#callout_recursion_CO4-2" id="co_recursion_CO4-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a>

  <code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">print</code><code class="p">(</code><code class="n">node</code><code class="p">.</code><code class="na">value</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code class="p">;</code> <a class="co" href="#callout_recursion_CO4-3" id="co_recursion_CO4-3"><img alt="3" height="12" src="assets/3.png" width="12"/></a>

  <code class="n">traverseRecursion</code><code class="p">(</code><code class="n">node</code><code class="p">.</code><code class="na">right</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code class="p">;</code> <a class="co" href="#callout_recursion_CO4-4" id="co_recursion_CO4-4"><img alt="4" height="12" src="assets/4.png" width="12"/></a>
<code class="p">}</code></pre></div>
<dl class="calloutlist">
<dt><a class="co" href="#co_recursion_CO4-1" id="callout_recursion_CO4-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p>The base condition to stop the traversal if no nodes remain.</p></dd>
<dt><a class="co" href="#co_recursion_CO4-2" id="callout_recursion_CO4-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a></dt>
<dd><p>First, recursively traverse the left child node.
This will call <code>traverse</code> again as long as a left node exists.</p></dd>
<dt><a class="co" href="#co_recursion_CO4-3" id="callout_recursion_CO4-3"><img alt="3" height="12" src="assets/3.png" width="12"/></a></dt>
<dd><p>Second, because no more left child nodes exist, the current value needs to be printed.</p></dd>
<dt><a class="co" href="#co_recursion_CO4-4" id="callout_recursion_CO4-4"><img alt="4" height="12" src="assets/4.png" width="12"/></a></dt>
<dd><p>Third, traverse the possible right child node with the same logic as before.</p></dd>
</dl>
<p>The output is the same as before: <em>748251396</em>.</p>
<p>The code no longer requires an external iterator or auxiliary variables to hold the state, and the actual processing logic is reduced to a minimum.
The traversal is no longer in the imperative mindset of <em>what to do</em>.
Instead, it reflects the functional approach of <em>how to achieve</em> a goal in a more declarative way.</p>
<p>Let’s make the tree traversal even more functional by moving the traversal process into the type itself and accepting a <code>Consumer&lt;Node&lt;T&gt;&gt;</code> for its action, as shown in <a data-type="xref" href="#_02-recursion_tree-node-recursive">Example 12-6</a>.</p>
<div data-type="example" id="_02-recursion_tree-node-recursive">
<h5><span class="label">Example 12-6. </span>Extend <code>Node&lt;T&gt;</code> with traversal method</h5>
<pre data-code-language="java" data-type="programlisting"><code class="kd">record</code> <code class="nc">Node</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="p">(</code><code class="n">T</code> <code class="n">value</code><code class="p">,</code> <code class="n">Node</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code> <code class="n">left</code><code class="p">,</code> <code class="n">Node</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code> <code class="n">right</code><code class="p">)</code> <code class="p">{</code>

  <code class="c1">// ...</code>

  <code class="kd">private</code> <code class="kd">static</code> <code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code> <code class="kt">void</code> <code class="nf">traverse</code><code class="p">(</code><code class="n">Node</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code> <code class="n">node</code><code class="p">,</code> <a class="co" href="#callout_recursion_CO5-1" id="co_recursion_CO5-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a>
                                   <code class="n">Consumer</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code> <code class="n">fn</code><code class="p">)</code> <code class="p">{</code> <a class="co" href="#callout_recursion_CO5-2" id="co_recursion_CO5-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a>
    <code class="k">if</code> <code class="p">(</code><code class="n">node</code> <code class="o">=</code><code class="o">=</code> <code class="kc">null</code><code class="p">)</code> <code class="p">{</code>
      <code class="k">return</code><code class="p">;</code>
    <code class="p">}</code>

    <code class="n">traverse</code><code class="p">(</code><code class="n">node</code><code class="p">.</code><code class="na">left</code><code class="p">(</code><code class="p">)</code><code class="p">,</code> <code class="n">fn</code><code class="p">)</code><code class="p">;</code>

    <code class="n">fn</code><code class="p">.</code><code class="na">accept</code><code class="p">(</code><code class="n">node</code><code class="p">.</code><code class="na">value</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code class="p">;</code>

    <code class="n">traverse</code><code class="p">(</code><code class="n">node</code><code class="p">.</code><code class="na">right</code><code class="p">(</code><code class="p">)</code><code class="p">,</code> <code class="n">fn</code><code class="p">)</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="kd">public</code> <code class="kt">void</code> <code class="nf">traverse</code><code class="p">(</code><code class="n">Consumer</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code> <code class="n">fn</code><code class="p">)</code> <code class="p">{</code> <a class="co" href="#callout_recursion_CO5-3" id="co_recursion_CO5-3"><img alt="3" height="12" src="assets/3.png" width="12"/></a>
    <code class="n">Node</code><code class="p">.</code><code class="na">traverse</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="n">fn</code><code class="p">)</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="n">root</code><code class="p">.</code><code class="na">traverse</code><code class="p">(</code><code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">:</code><code class="p">:</code><code class="n">print</code><code class="p">)</code><code class="p">;</code></pre></div>
<dl class="calloutlist">
<dt><a class="co" href="#co_recursion_CO5-1" id="callout_recursion_CO5-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p>The previous <code>traverse</code> method can easily be refactored into a <code>private static</code> method on the original type.</p></dd>
<dt><a class="co" href="#co_recursion_CO5-2" id="callout_recursion_CO5-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a></dt>
<dd><p>The new <code>traverse</code> method accepts a <code>Consumer&lt;Node&lt;T&gt;&gt;</code> to support any kind of action.</p></dd>
<dt><a class="co" href="#co_recursion_CO5-3" id="callout_recursion_CO5-3"><img alt="3" height="12" src="assets/3.png" width="12"/></a></dt>
<dd><p>A <code>public</code> method for traversal simplifies the call be omitting <code>this</code> as its first argument.</p></dd>
</dl>
<p>Traversing the type became even easier.
The type itself is now responsible for the best way to traverse itself and provides a flexible solution for anyone using it.</p>
<p>It’s concise, functional, and easier to understand compared to the iterative approach.
Still, there are advantages to using a loop.
The biggest one is the performance discrepancy, trading the needed stack space for available heap space.
Instead of creating a new stack frame for every recursive traversal operation, the nodes accumulate on the heap in <code>tmpNodes</code>.
That makes the code more robust for larger graphs that might otherwise lead to a stack overflow.</p>
<p>As you can see, there’s no easy answer to which approach is best.
It always depends highly on the kind of data structure and how much data you need to process.
Even then, your personal preference and familiarity with a particular approach might be more important than the “best” solution to a problem to write straightforward and bug-free processing code.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="Recursion-like Streams" data-type="sect1"><div class="sect1" id="_02-recursion_streams-to-the-rescue">
<h1>Recursion-like Streams</h1>
<p>Java’s runtime might not support tail-call optimization, however, you can still implement a recursive-like experience with lambda expressions and Streams that don’t suffer from overflowing stack issues.</p>
<p>Thanks to the lazy nature of Streams, you can build a pipeline that runs infinitely until the recursive problem is solved.
But instead of calling a lambda expression recursively, it returns a new expression instead.
This way, the stack depth will remain constant, regardless of the number of performed recursive steps.</p>
<p>This approach is quite convoluted compared to recursion or even using loops.
It’s not commonly used, but it illustrates how to combine various new functional components of Java to solve recursive problems.
Take a look at the book’s <a href="https://github.com/benweidig/a-functional-approach-to-java">code repository</a> if you’d like to learn more.</p>
</div></section>
<section data-pdf-bookmark="Final Thoughts on Recursion" data-type="sect1"><div class="sect1" id="idm45115219251472">
<h1>Final Thoughts on Recursion</h1>
<p>Recursion is an often overlooked technique because it’s so easy to get it wrong.
For example, a faulty base condition may be impossible to fulfill, which inevitably leads to a stack overflow.
The recursive flow, in general, is harder to follow and more difficult to understand if you’re not used to it.
Because Java does not have <em>tail-call optimization</em>, you will have to factor in the unavoidable overhead, which results in slower execution times than iterative structures, in addition to the possibility of a <code>StackOverflowError</code> if your call stack is too deep.</p>
<p>You should always consider the additional overhead and stack-overflow problems when choosing between recursion and its alternatives.
If you’re running in a JVM with ample available memory and a big enough stack size, even bigger recursive call chains won’t be an issue.
But if your problem size is unknown or not fixed, an alternative approach might be more sensible to prevent a <code>StackOverflowError</code> in the long run.</p>
<p>Some scenarios are better suited for a recursive approach, even in Java with its lack of tail-call optimization.
Recursion will feel like a more natural way to solve particular problems with self-referencing data structures like linked lists or trees.
Traversing tree-like structures can also be done iteratively but will most likely result in more complex code that’s harder to reason with.</p>
<p>But remember, choosing the best solution for a problem solely from a technical viewpoint might undermine the readability and reasonability of your code, which will affect long-time maintainability.</p>
<p><a data-type="xref" href="#_02-recursion_vs-iteration">Table 12-1</a> gives you an overview of the differences between recursion and iteration, so you can use them to choose more effectively.</p>
<table id="_02-recursion_vs-iteration">
<caption><span class="label">Table 12-1. </span>Recursion versus iteration</caption>
<thead>
<tr>
<th/>
<th>Recursion</th>
<th>Iteration</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>Approach</p></td>
<td><p>Self-calling function</p></td>
<td><p>Loop construct</p></td>
</tr>
<tr>
<td><p>State</p></td>
<td><p>Stored on Stack</p></td>
<td><p>Stored in control variables (e.g., a loop index)</p></td>
</tr>
<tr>
<td><p>Progression</p></td>
<td><p>Towards base condition</p></td>
<td><p>Towards control value condition</p></td>
</tr>
<tr>
<td><p>Termination</p></td>
<td><p>Base condition reached</p></td>
<td><p>Control variable condition reached</p></td>
</tr>
<tr>
<td><p>Verbosity</p></td>
<td><p>Lower verbosity<br/>
Minimal boilerplate and coordination code required</p></td>
<td><p>Higher verbosity<br/>
Explicit coordination of control variables and state.</p></td>
</tr>
<tr>
<td><p>If not terminated</p></td>
<td><p><code>StackOverflowError</code></p></td>
<td><p>Endless loop</p></td>
</tr>
<tr>
<td><p>Overhead</p></td>
<td><p>Higher overhead of repeated method calls.</p></td>
<td><p>Lower overhead with constant stack depth.</p></td>
</tr>
<tr>
<td><p>Performance</p></td>
<td><p>Lower performance due to overhead and missing tail-call optimization.</p></td>
<td><p>Better performance thanks to constant call stack depth.</p></td>
</tr>
<tr>
<td><p>Memory Usage</p></td>
<td><p>Each call requires stack space.</p></td>
<td><p>No additional memory besides control variables.</p></td>
</tr>
<tr>
<td><p>Execution speed</p></td>
<td><p>Slower</p></td>
<td><p>Faster</p></td>
</tr>
</tbody>
</table>
<p>Which to choose — recursion or iteration — depends highly on the problem you want to solve and in which environment your code runs.
Recursion is often the preferred tool for solving more abstract problems, and iteration is a better match for more low-level code.
Iteration might provide better runtime performance, but recursion can improve your productivity as a programmer.</p>
<p>Don’t forget that you can always start with a familiar iterative approach and convert it to use recursion later.</p>
</div></section>
<section data-pdf-bookmark="Takeaways" data-type="sect1"><div class="sect1" id="idm45115219219936">
<h1>Takeaways</h1>
<ul>
<li>
<p>Recursion is the functional alternative to “traditional” iteration.</p>
</li>
<li>
<p>Recursion is best used for partially solvable problems.</p>
</li>
<li>
<p>Java lacks tail-call-optimization, which can lead to <code>StackOverflowExceptions</code>.</p>
</li>
<li>
<p>Don’t force recursion for functional’s sake.
You can always start with an iterative approach and convert it to a recursive approach later.</p>
</li>
</ul>
</div></section>
<div data-type="footnotes"><p data-type="footnote" id="idm45115220279984"><sup><a href="ch12.xhtml#idm45115220279984-marker">1</a></sup> The default stack size of most JVM implementations is one megabyte. You can set a bigger stack size with the flag <code>-Xss</code>. See the <a href="https://docs.oracle.com/en/java/javase/11/tools/java.xhtml#GUID-3B1CE181-CD30-4178-9602-230B800D4FAE__GUID-72BC3B70-49FF-4588-979F-7F8A32FEE6DA">Oracle Java Tools Documentation</a> for more information.</p></div></div></section></div></body></html>