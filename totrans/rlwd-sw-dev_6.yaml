- en: Chapter 6\. Twootr
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 6 章 Twootr
- en: The Challenge
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 挑战
- en: Joe was an excited young chap, keen to tell me all about his new startup idea.
    He was on a mission to help people communicate better and faster. He enjoyed blogging
    but wondered about how to get people to blog more frequently in smaller amounts.
    He was calling it micro-blogging. The big idea was that if you restricted the
    size of the messages to 140 characters that people would post little and often
    rather than in big messages.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Joe 是一个兴奋的年轻小伙子，热衷于向我讲述他的新创业想法。他的使命是帮助人们更好更快地沟通。他喜欢博客，但他在思考如何让人们更频繁地以更少量的内容进行博客。他称之为微博客。大胆的想法是，如果你将消息大小限制在
    140 个字符，人们会频繁地发布少量的消息，而不是大段的消息。
- en: We asked Joe if he felt that this restriction would encourage people to just
    post short, pithy statements that didn’t really mean anything. He said “Yolo!”
    We asked Joe how he was going to make money. He said “Yolo!” We asked Joe what
    he planned to call the product. He said “Twootr!” We thought it sounded like a
    cool and original idea, so we decided to help him build his product.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们问 Joe，他觉得这种限制是否会鼓励人们发表毫无意义的简短言论。他说：“Yolo！”我们问 Joe 如何赚钱。他说：“Yolo！”我们问 Joe 打算给产品取什么名字。他说：“Twootr！”我们觉得这听起来是一个很酷和原创的想法，所以我们决定帮助他建立他的产品。
- en: The Goal
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 目标
- en: In this chapter you will learn about the big picture of putting a software application
    together. A lot of the previous apps in this book were smaller examples—batch
    jobs that would run on the command line. Twootr is a server-side Java application,
    similar to the kind of application that most Java developers write.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解如何将软件应用程序整合成一个大局。本书中以往的应用程序示例大多是小型示例——在命令行上运行的批处理作业。Twootr 是一个服务器端的
    Java 应用程序，类似于大多数 Java 开发人员编写的应用程序类型。
- en: 'In this chapter you’ll have the opportunity to learn about a number of different
    skills:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将有机会学习到许多不同的技能：
- en: How to take a big picture description and break it down into different architectural
    concerns
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将一个大局描述拆分成不同的架构关注点
- en: How to use test doubles to isolate and test interactions from different components
    within your codebase
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用测试替身（test doubles）来隔离和测试代码库中不同组件之间的交互。
- en: How to think outside-in—to go from requirements through to the core of your
    application domain
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何从需求出发，思考到应用程序领域的核心。
- en: At several places in this chapter we will also talk not only about the final
    design of the software, but how we got there. There are a few places where we
    show how certain methods iteratively evolved over the development of the project
    in response to an expanding list of implemented features. This will give you a
    feel for how software projects can evolve in reality, rather than simply presenting
    an idealized final design abstract of its thought process.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的几个地方，我们不仅会谈论软件的最终设计，还会谈论我们如何达到这一设计的过程。有一些地方我们展示了某些方法是如何随着项目的开发和功能列表的扩展而迭代演变的。这将让你了解到软件项目在现实中如何演变，而不只是呈现一个理想化的最终设计抽象的思考过程。
- en: Twootr Requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Twootr 需求
- en: The previous applications that you’ve seen in this book are all line-of-business
    applications that process data and documents. Twootr, on the other hand, is a
    user-facing application. When we talked to Joe about the requirements for his
    system, it became apparent that he had refined his ideas a bit. Each micro-blog
    from a user would be called a *twoot* and users would have a constant stream of
    twoots. In order to see what other users were twooting about, you would *follow*
    those users.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中你看到的以前的应用程序都是处理数据和文档的业务应用程序。而 Twootr 是一个面向用户的应用程序。当我们和 Joe 谈论他系统需求的时候，显而易见地，他已经对自己的想法进行了一些精炼。每个用户的微博称为
    *twoot*，用户会有一个持续的 twoot 流。为了看到其他用户的 twoot，你可以 *follow* 这些用户。
- en: 'Joe had brainstormed some different use cases—scenarios in which his users
    use the service. This is the functionality that we need to get working in order
    to help Joe achieve his goal of helping people communicate better:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Joe 想出了一些不同的使用案例——他的用户使用服务的场景。这些是我们需要使之正常工作以帮助 Joe 实现帮助人们更好更快地沟通的目标的功能：
- en: Users log in to Twootr with a unique user ID and password.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户使用唯一的用户 ID 和密码登录到 Twootr。
- en: Each user has a set of other users that they follow.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个用户都有一组其他用户，他们在系统中关注这些用户。
- en: Users can send a twoot, and any followers who are logged in should immediately
    see the twoot.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户可以发送一个 twoot，任何已登录的跟随者都应该立即看到这个 twoot。
- en: When users log in they should see all the twoots from their followers since
    they last logged in.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户登录时应该看到自上次登录以来关注者的所有Twoots。
- en: Users should be able to delete twoots. Deleted twoots should no longer be visible
    to followers.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户应该能够删除Twoots。已删除的Twoots不应再对关注者可见。
- en: Users should be able to log in from a mobile phone or a website.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户应该能够从手机或网站登录。
- en: The first step in explaining how we go about implementing a solution fit for
    Joe’s needs is to overview and outline the big-picture design choices that we
    face.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 解释如何实现适合Joe需求的解决方案的第一步是概述并概述我们面临的宏观设计选择。
- en: Design Overview
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计概述
- en: Note
  id: totrans-22
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If at any point you want to look at the source code for this chapter, you can
    look at the package `com.iteratrlearning.shu_book.chapter_06` in the book’s code
    repository.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要查看本章的源代码，您可以查看书籍代码存储库中的`com.iteratrlearning.shu_book.chapter_06`包。
- en: If you want to see the project in action, you should run the `TwootrServer`
    class from your IDE and then browser to *http://localhost:8000*.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想看到项目的实际操作，您应该从您的IDE中运行`TwootrServer`类，然后浏览到*http://localhost:8000*。
- en: If we pick out the last requirement and consider it first then it strikes us
    that, in contrast to many of the other systems in this book, we need to build
    a system that has many computers communicating together in some way. This is because
    our users may be running the software on different computers—for example, one
    user may load the Twootr website on their desktop at home and another may run
    Twootr on a mobile phone. How will these different user interfaces talk to each
    other?
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们先挑出最后一个需求并首先考虑它，那么与本书中许多其他系统相比，我们需要构建一个以某种方式多台计算机进行通信的系统。这是因为我们的用户可能在不同的计算机上运行软件——例如，一个用户可能在家里的桌面电脑上加载Twootr网站，另一个用户可能在手机上运行Twootr。这些不同的用户界面将如何相互通信？
- en: The most common approach taken by software developers trying to approach this
    kind of problem is to use the *client-server* model. In this approach to developing
    distributed applications we group our computers into two main groups. We have
    *clients* who request the use of some kind of service and *servers* who provide
    the service in question. So in our case our clients would be something like a
    website or a mobile phone application that provides a UI through which we can
    communicate with the Twootr server. The server would process the majority of the
    business logic and send and receive twoots to different clients. This is shown
    in [Figure 6-1](#ch06_client_server_img).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发人员尝试解决这类问题时采取的最常见方法是使用*客户端-服务器*模型。在开发分布式应用程序的这种方法中，我们将计算机分为两个主要组。我们有*客户端*请求某种服务的使用和*服务器*提供所需的服务。所以在我们的情况下，我们的客户端可能是像网站或移动电话应用程序这样的东西，通过它们，我们可以与Twootr服务器通信。服务器将处理大部分业务逻辑并将Twoots发送和接收到不同的客户端。这在[图 6-1](#ch06_client_server_img)中显示。
- en: '![Client-server model](Images/rwsd_0601.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![客户端-服务器模型](Images/rwsd_0601.png)'
- en: Figure 6-1\. Client-server model
  id: totrans-28
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-1\. 客户端-服务器模型
- en: 'It was clear from the requirements and talking to Joe that a key part of this
    system working was the ability to immediately view twoots from users you follow.
    This means that the user interface would have to have the ability to receive twoots
    from the server as well as send them. There are, in big-picture terms, two different
    styles of communication that can be used to achieve this goal: pull-based or push-based.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 从需求和与Joe的交谈中明显地可以看出，使该系统正常运行的关键部分之一是能够立即查看您关注的用户的Twoots的能力。这意味着用户界面必须具有从服务器接收Twoots以及发送它们的能力。从宏观上来说，有两种不同的通信风格可以实现这个目标：拉取式或推送式。
- en: Pull-Based
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 拉取式
- en: In a *pull-based communication* style the client makes a request to the server
    and queries it for information. This style of communication is often called a
    point-to-point style or a request-response style of communication. This is a particularly
    common communication style, used by most of the web. When you load a website it
    will make an HTTP request to some server, pulling the page’s data. Pull-based
    communication styles are useful when the client controls what content to load.
    For example, if you’re browsing wikipedia you control which pages you’re interested
    in reading about or seeing next and the content responses are sent back to you.
    This is shown in [Figure 6-2](#ch06_pull_comms_img).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在*拉取式通信*风格中，客户端向服务器发出请求并查询信息。这种通信风格通常被称为点对点风格或请求-响应风格的通信。这是一种特别常见的通信方式，被大多数网站使用。当你加载一个网页时，它会向某个服务器发出
    HTTP 请求，以获取页面的数据。拉取式通信风格在客户端控制要加载的内容时非常有用。例如，当你浏览维基百科时，你可以控制你有兴趣阅读或查看的页面，内容响应将被发送回给你。这在[图 6-2](#ch06_pull_comms_img)中有所体现。
- en: '![Pull communications](Images/rwsd_0602.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![拉取通信](Images/rwsd_0602.png)'
- en: Figure 6-2\. Pull communications
  id: totrans-33
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-2\. 拉取通信
- en: Push-Based
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 推送式
- en: Another approach is a *push-based communication* style. This could be referred
    to as a reactive or event-driven communication approach. In this model, streams
    of events are emitted by a publisher and many subscribers listen to them. So instead
    of each communication being 1 to 1, they are 1 to many. This is a really useful
    model for systems where different components need to talk in terms of ongoing
    communication patterns of multiple events. For example, if you’re designing a
    stock market exchange then different companies want to see updated prices, or
    ticks, constantly rather than having to make a new request every time they want
    to see a new tick. This is shown in [Figure 6-3](#ch06_push_comms_img).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是*推送式通信*风格。这可以称为一种反应式或事件驱动的通信方法。在这种模型中，由发布者发出一系列事件，许多订阅者监听这些事件。因此，每次通信不再是一对一的，而是一对多的。这是一个对于需要在多个事件的持续通信模式中进行不同组件交流的系统非常有用的模型。例如，如果你正在设计一个股票市场交易所，不同的公司希望看到不断更新的价格或交易信息，而不是每次想看新的信息时都需要发出新的请求。这在[图 6-3](#ch06_push_comms_img)中有所体现。
- en: '![Push communications](Images/rwsd_0603.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![推送通信](Images/rwsd_0603.png)'
- en: Figure 6-3\. Push communications
  id: totrans-37
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-3\. 推送通信
- en: In the case of Twootr, an event-driven communication style seems most suitable
    for the application as it mainly consists of ongoing streams of twoots. The events
    in this model would be the twoots themselves. We could definitely still design
    the application in terms of a request-response communication style. If we went
    down this route, however, the client would have to be regularly polling the server
    and asking with a request saying, “Hey, has anyone twooted since my last request?”
    In an event-driven style you simply subscribe to your events—i.e., follow another
    user—and the server pushes the twoots that you’re interested in to the client.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Twootr来说，事件驱动的通信风格似乎最适合该应用，因为它主要由持续的“twoots”流组成。在这种模型中，事件将是“twoots”本身。我们当然仍然可以设计应用程序，采用请求-响应通信风格。然而，如果我们选择这条路线，客户端将不得不定期轮询服务器，并使用请求询问：“自从上次请求以来有人发了‘twoot’吗？”在事件驱动风格中，你只需订阅你感兴趣的事件——即关注另一个用户——服务器就会将你感兴趣的“twoots”推送给客户端。
- en: This choice of an event-driven communication style influences the rest of the
    application design from here on in. When we write code that implements the main
    class of our application, we’ll be receiving events and sending them. How to receive
    and send events determines the patterns within our code and also how we write
    tests for our code.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这种选择的事件驱动通信风格将从现在开始影响应用程序的其余设计。当我们编写实现应用程序主类的代码时，我们将接收并发送事件。如何接收和发送事件决定了我们代码中的模式，也决定了我们如何为代码编写测试。
- en: From Events to Design
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从事件到设计
- en: 'Having said that, we’re building a client-server application—this chapter will
    focus on the server-side component rather than the client component. In [“User
    Interface”](ch07.xhtml#ch06_User_Interfaces) you will see how a client can be
    developed for this codebase, and an example client is implemented in the code
    samples that go with this book. There are two reasons why we focus on the server-side
    component. First, this is a book on how to write software in Java, which is extensively
    used on the server side but not so widely on the client side. Second, the server
    side is where the business logic lies: the brains of the application. The client
    side is a very simple codebase that just needs to bind a UI to publishing and
    subscribing events.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Communication
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Having established that we want to send and receive events, a common next step
    in our design would be to pick some kind of technology to send those messages
    to or from our client to our server. There are lots of choices in this area, and
    here are a few routes that we could go down:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: WebSockets are a modern, lightweight communications protocol to provide duplex
    (two-way) communication of events over a TCP stream. They are often used for event-driven
    communication between a web browser and a web server and is supported by recent
    browser releases.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hosted cloud-based message queues such as Amazon Simple Queue Service are an
    increasingly popular choice for broadcasting and receiving events. A message queue
    is a way of performing inter-process communication by sending messages that can
    either be received by a single process of a group of processes. The benefit of
    being a hosted service is that your company doesn’t have to expend effort on ensuring
    that they are reliably hosted.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many good open source message transports or message queues, such as
    Aeron, ZeroMQ, and AMPQ implementations. Many of these open source projects avoid
    vendor lock-in, though they may limit your choice of client to something that
    can interact with a message queue. For example, they wouldn’t be appropriate if
    your client is a web browser.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That’s far from an exhaustive list, and as you can see different technologies
    have different trade-offs and use cases. It might be the case that, for your own
    program, you pick one of these technologies. At a later date you decide that it’s
    not the right choice and want to pick another. It might be that you wish to choose
    different types of communications technologies for different types of connecting
    clients. Either way, making that decision at the beginning of your project and
    being forced to live with it forever isn’t a great architectural decision. Later
    in this chapter we will see how it’s possible to abstract away this architectural
    choice to avoid a big-mistake-up-front architectural decision.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: It’s even possibly the case that you may want to combine different communications
    approaches; for example, by using different communications approaches for different
    types of client. [Figure 6-4](#ch06_comms_styles) visualizes using WebSockets
    to communicate with a website and Android push notifications for your Android
    mobile app.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至可能出现这样的情况，您可能希望结合不同的通信方法；例如，通过使用不同的通信方法为不同类型的客户端使用不同的通信方法。[图 6-4](#ch06_comms_styles)
    可视化使用WebSockets与网站通信以及为Android移动应用程序推送Android推送通知。
- en: '![Different communications approaches](Images/rwsd_0604.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![不同的通信方法](Images/rwsd_0604.png)'
- en: Figure 6-4\. Different communications approaches
  id: totrans-50
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-4. 不同的通信方法
- en: GUI
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GUI
- en: 'Coupling the choice of UI communications technology or your UI to your core
    server-side business logic also has several other disadvantages:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 将UI通信技术或您的UI与核心服务器端业务逻辑耦合也具有其他几个缺点：
- en: It is difficult and slow to test. Every test would have to test the system by
    publishing and subscribing to events running in parallel with the main server.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是测试困难且缓慢的。每个测试都必须通过与主服务器并行运行的发布和订阅事件来测试系统。
- en: It breaks the Single Responsibility Principle that we talked about in [Chapter 2](ch02.xhtml#chapter_02).
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它违反了我们在[第二章](ch02.xhtml#chapter_02)讨论的单一责任原则。
- en: It assumes that we’re going to have a UI as our client. At first this might
    be a solid assumption for Twootr, but in the glorious future we might wish to
    have interactive artificially intelligent chat bots helping solve user problems.
    Or twooting cat GIFs at least!
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它假设我们的客户端将有一个UI。起初，这对Twootr可能是一个坚实的假设，但在辉煌的未来，我们可能希望有交互式的人工智能聊天机器人帮助解决用户问题。或者至少发送twooting猫的GIF！
- en: The takeaway from this is that we would be prudent to introduce some kind of
    abstraction to decouple the messaging for our UI from the core business logic.
    We need an interface through which we can send messages to the client and an interface
    through which we can receive messages from the client.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 从中得出的结论是，我们应该明智地引入某种抽象来解耦UI的消息传递与核心业务逻辑。我们需要一个接口，通过它可以向客户端发送消息，并且需要一个接口，通过它可以从客户端接收消息。
- en: Persistence
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 持久性
- en: 'There are similar concerns at the other side of the application. How should
    we store the data for Twootr? We have many choices to pick from:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序的另一侧也存在类似的问题。我们应该如何存储Twootr的数据？我们可以从以下多种选择中进行选择：
- en: Plain-text files that we can index and search ourselves. It’s easy to see what
    has been logged and avoids a dependency on another application.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以自己索引和搜索的纯文本文件。很容易看出已经记录了什么，并避免依赖于另一个应用程序。
- en: A traditional SQL database. It’s well tested and understood, with strong querying
    support.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传统的SQL数据库。它经过充分测试和理解，具有强大的查询支持。
- en: A NoSQL database. There are a variety of different databases here with differing
    use cases, query languages, and data storage models.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个NoSQL数据库。这里有多种不同的数据库，具有不同的用例、查询语言和数据存储模型。
- en: We don’t really know which to pick at the beginning of our software project
    and our needs may evolve over time. We really want to decouple our choice of storage
    backend from the rest of our application. There’s a similarity between these different
    issues—both are about wanting to avoid coupling yourself to a specific technology.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件项目开始时，我们真的不知道该选择什么，而且随着时间的推移，我们的需求可能会发生变化。我们确实希望将存储后端的选择与应用程序的其余部分解耦。这些不同问题之间存在相似之处——都是关于希望避免与特定技术耦合。
- en: The Hexagonal Architecture
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 六边形架构
- en: In fact, there’s a name for a more general architectural style here that helps
    us solve this problem. It’s called the *Ports and Adapters* or *Hexagonal* architecture
    and was [originally introduced by Alister Cockburn](https://oreil.ly/wJO17). The
    idea, shown in [Figure 6-5](#ch06_hexagonal), is that the core of your application
    is the business logic that you’re writing, and you want to keep different implementation
    choices separate from this core logic.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这里有一个更一般的架构风格的名称，帮助我们解决这个问题。它被称为*端口和适配器*或*六边形*架构，并由[Alister Cockburn最初介绍](https://oreil.ly/wJO17)。这个想法如[图 6-5](#ch06_hexagonal)所示，您的应用程序的核心是您正在编写的业务逻辑，您希望将不同的实现选择与此核心逻辑分开。
- en: Whenever you have a technology-specific concern that you want to decouple from
    the core of your business logic, you introduce a *port*. Events from the outside
    world arrive at and depart from your business logic core through a port. An *adapter*
    is the technology-specific implementation code that plugs into the port. For example,
    we may have a port for publishing and subscribing to UI events and a WebSocket
    adapter that talks to a web browser.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你有一个想要与业务逻辑核心解耦的技术特定关注点时，你引入一个*端口*。来自外部世界的事件通过端口到达和离开你的业务逻辑核心。*适配器*是插入端口的技术特定实现代码。例如，我们可能会有一个用于发布和订阅
    UI 事件的端口，以及一个与 Web 浏览器通信的 WebSocket 适配器。
- en: '![Hexagonal architecture](Images/rwsd_0605.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![六边形架构](Images/rwsd_0605.png)'
- en: Figure 6-5\. Hexagonal architecture
  id: totrans-67
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-5\. 六边形架构
- en: There are other components within a system for which you might want to create
    a port and adapter abstraction. One thing that might be relevant to an expanded
    Twootr implementation is a notification system. Informing users that they have
    a lot of twoots they might be interested in logging in and seeing would be a port.
    You may wish to implement this with an adapter for email or text messages.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 系统中可能有其他组件，你可能希望为其创建端口和适配器抽象。一个可能与扩展的 Twootr 实现相关的组件是通知系统。通知用户有很多可能感兴趣的 Twoots
    可以登录查看，这就是一个端口。你可能希望使用电子邮件或短信的适配器来实现这一功能。
- en: Another example port that comes to mind is authentication services. You may
    wish to start off with an adapter that just stores the usernames and passwords,
    later replacing it with an OAuth backend or tying it to some other system. In
    the Twootr implementation that this chapter describes we don’t go so far as to
    abstract out authentication. This is because our requirements and initial brainstorming
    session haven’t come up with a good reason why we might want different authentication
    adapters as of yet.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是身份验证服务端口。你可能希望先用一个仅存储用户名和密码的适配器开始，稍后将其替换为 OAuth 后端或将其绑定到其他系统。在本章描述的 Twootr
    实现中，我们并没有像这样抽象出身份验证。这是因为我们的需求和最初的头脑风暴会议尚未提出我们可能需要不同身份验证适配器的充分理由。
- en: 'You might be wondering how you separate what should be a port and what should
    be part of the core domain. At one extreme you could have hundreds or even thousands
    of ports in your application and nearly everything could be abstracted out of
    the core domain. At the other extreme you could have none at all. Where you decide
    your application should live on this sliding scale is a matter of personal judgment
    and circumstance: there are no rules.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 或许你会想知道如何区分什么应该是端口，什么应该是核心域的一部分。在一个极端情况下，你的应用程序中可能会有数百甚至数千个端口，几乎所有内容都可以从核心域中抽象出来。在另一个极端情况下，可能根本不需要端口。在这个滑动尺度上决定应用程序应该处于的位置，是个人判断和具体情况的问题：没有硬性规定。
- en: A good principle to help you decide might be to think of anything that is critical
    to the business problem that you’re solving as living inside the core of the application
    and anything that is technology specific or involves communicating with the outside
    world as living outside the core application. That is the principle that we’ve
    used in this application. So business logic is part of our core domain, but responsibility
    for persistence and event-driven communication with the UI are hidden behind ports.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的决策原则可能是，把解决业务问题中至关重要的内容视为应用核心的一部分，把技术特定的或涉及与外部世界通信的内容视为应用核心外的内容。这就是我们在这个应用程序中使用的原则。因此，业务逻辑是我们核心域的一部分，但负责持久化和与
    UI 的事件驱动通信的部分隐藏在端口后面。
- en: Where to Begin
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何入门
- en: We could proceed with outlining the design in more and more detail at this stage,
    designing more elaborate diagrams and deciding what functionality should live
    in what class. We’ve never found that to be a terribly productive approach to
    writing software. It tends to result in lots of assumptions and design decisions
    being pushed down into little boxes in an architecture diagram that turn out to
    be not so little. Diving straight into coding with no thought to overall design
    is unlikely to result in the best software, either. Software development needs
    *just enough upfront design* to avoid it collapsing into chaos, but architecture
    without coding enough bits to make it real can quickly become sterile and unrealistic.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在这个阶段继续以更详细的方式概述设计，设计更复杂的图表，并决定哪个功能应该存在于哪个类中。我们从未发现这是一种非常有效的编写软件的方法。它往往会导致大量的假设和设计决策被推送到架构图中的小框中，结果证明这些小框并不那么小。毫无关于整体设计的思考直接潜入编码中，也不太可能产生最好的软件。软件开发需要*足够的前期设计*来避免其陷入混乱，但没有对代码进行足够的编写部分的架构很快就会变得枯燥和不切实际。
- en: Note
  id: totrans-74
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The approach of pushing all your design work before you start writing your code
    is called *Big Design Up Front*, or *BDUF*. BDUF is often contrasted with the
    Agile, or iterative, development methodologies that have become more popular over
    the last 10–20 years. Since we find iterative approaches to be more effective,
    we’ve described the design process over the next couple of sections in an iterative
    manner.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始编写代码之前推动所有设计工作的方法被称为*大设计上前*，或*BDUF*。 BDUF通常与过去10-20年变得更受欢迎的敏捷或迭代式开发方法相对比。由于我们发现迭代方法更有效，我们将在接下来的几节中以迭代方式描述设计过程。
- en: 'In the previous chapter you saw an introduction to TDD—test-driven development—so
    by now you should be familiar with the fact that it’s a good idea to start writing
    our project with a test class, `TwootrTest`. So let’s start with a test that our
    user can log in: `shouldBeAbleToAuthenticateUser()`. In this test a user will
    log in and be correctly authenticated. A skeleton for this method can be seen
    in [Example 6-1](#shouldBeAbleToAuthenticateUser_skeleton).'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章节中，您已经看到了TDD——测试驱动开发——的介绍，所以现在您应该熟悉了这样的事实，即从一个名为`TwootrTest`的测试类开始编写项目是个好主意。因此，让我们从一个测试开始，我们的用户可以登录：`shouldBeAbleToAuthenticateUser()`。在这个测试中，用户将登录并正确认证。此方法的骨架可以在[示例
    6-1](#shouldBeAbleToAuthenticateUser_skeleton)中看到。
- en: Example 6-1\. Skeleton for shouldBeAbleToAuthenticateUser()
  id: totrans-77
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-1\. shouldBeAbleToAuthenticateUser() 的骨架
- en: '[PRE0]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In order to implement the test we need to create a `Twootr` class and have a
    way of modeling the login event. As a matter of convention in this module any
    method that corresponds to an event happening will have the prefix `on`. So, for
    example, we’re going to create a method here called `onLogon`. But what is the
    signature of this method—what information does it need to take as parameters and
    what should it reply with?
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这个测试，我们需要创建一个`Twootr`类，并有一种对登录事件进行建模的方式。作为惯例，在本模块中，任何与事件发生相对应的方法都将具有前缀`on`。因此，例如，在这里我们将创建一个名为`onLogon`的方法。但是这个方法的签名是什么——它需要以什么参数，以及应该回复什么？
- en: We’ve already made the architectural decision to separate our UI communications
    layer with a port. So here we need to make a decision as to how to define the
    API. We need a way of emitting events to a user—for example, that another user
    who the user is following has twooted. We also need a way of receiving events
    from a given user. In Java we can just use a method call to represent the events.
    So whenever a UI adapter wants to publish an event to `Twootr`, it will call a
    method on some object owned by the core of the system. Whenever `Twootr` wants
    to publish an event, it will call a method on some object owned by the adapter.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经作出了将UI通信层与端口分离的架构决策。因此，我们需要决定如何定义API。我们需要一种向用户发出事件的方式——例如，用户正在关注的另一个用户已经发了两推。我们还需要一种接收来自特定用户的事件的方式。在Java中，我们可以使用方法调用来代表事件。因此，每当UI适配器想向`Twootr`发布事件时，它将在系统核心拥有的对象上调用一个方法。每当`Twootr`想要发布事件时，它将在适配器拥有的对象上调用一个方法。
- en: But the goal of ports and adapters is that we decouple the core from a specific
    adapter implementation. This means we need some way of abstracting over different
    adapters—an interface. We could have chosen to use an abstract class at this point
    in time. It would have worked, but interfaces are more flexible because adapter
    classes can implement more than one interface. Also by using an interface we’re
    discouraging our future selves from the devilish temptation to add some state
    into the API. Introducing state in an API is bad because different adapter implementations
    may want to represent their internal state in a different way, so putting state
    into the API could result in coupling.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 但是端口和适配器的目标是将核心与特定适配器实现解耦。这意味着我们需要某种方式来抽象不同的适配器——一个接口。在这一点上，我们本可以选择使用抽象类。虽然这样也可以运行，但接口更加灵活，因为适配器类可以实现多个接口。而且通过使用接口，我们在一定程度上避免了未来添加一些状态到
    API 的邪恶诱惑。在 API 中引入状态是不好的，因为不同的适配器实现可能希望以不同的方式表示其内部状态，因此将状态放入 API 可能导致耦合。
- en: We don’t need to use an interface for the object where user events are published
    as there will only be a single implementation in the core—we can just use a regular
    class. You can see what our approach looks like visually in [Figure 6-6](#ch06_events_out_in).
    Of course we need a name, or indeed a pair of names, in order to represent this
    API for sending and receiving events. There are lots of choices here; in practice,
    anything that made it clear that these were APIs for sending and receiving events
    would do well.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 对于发布用户事件的对象，我们不需要使用接口，因为核心中只会有一个实现——我们可以只使用常规类。您可以在[图 6-6](#ch06_events_out_in)中直观地看到我们的方法。当然，为了表示发送和接收事件的
    API，我们需要一个名称，或者实际上是一对名称。在这里有很多选择；实际上，任何能清楚表明这些是用于发送和接收事件的 API 的东西都会做得很好。
- en: We’ve gone with `SenderEndPoint` for the class that sends events to the core
    and `ReceiverEndPoint` for the interface that receives events from the core. We
    could in fact flip the sender and receiver designations around to work from the
    perspective of the user or the adapter. This ordering has the advantage that we’re
    thinking core first, adapters second.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择了`SenderEndPoint`作为发送事件到核心的类，以及`ReceiverEndPoint`作为从核心接收事件的接口。实际上，我们可以反转发送和接收的设计，以从用户或适配器的角度工作。这种排序的优势在于我们首先考虑核心，其次考虑适配器。
- en: '![Events to code](Images/rwsd_0606.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![事件到代码](Images/rwsd_0606.png)'
- en: Figure 6-6\. Events to code
  id: totrans-85
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-6\. 事件到代码
- en: Now that we know the route we’re going down we can write the `shouldBeAbleToAuthenticateUser()`
    test. This just needs to test that when we log on to the system with a valid username
    that the user logs on. What does logging on mean here? Well, we want to return
    a valid `SenderEndPoint` object, as that is the object returned to the UI in order
    to represent the user who has just logged on. We then need to add a method to
    our `Twootr` class in order to represent the logon event happening and allow the
    test to compile. The signature of our implementation is shown in [Example 6-2](#onLogon_1_definition).
    Since TDD encourages us to do the minimal implementation work in order to get
    a test to pass and then evolve the implementation, we’ll just instantiate the
    `SenderEndPoint` object and return it from our method.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道我们要走的路线，我们可以编写`shouldBeAbleToAuthenticateUser()`测试。这个测试只需测试当我们使用有效的用户名登录系统时，用户是否成功登录即可。这里的登录意味着什么？我们希望返回一个有效的`SenderEndPoint`对象，因为这是返回给
    UI 以表示刚刚登录的用户的对象。然后，我们需要在我们的`Twootr`类中添加一个方法来表示登录事件的发生，并允许测试通过。我们的实现签名显示在[示例 6-2](#onLogon_1_definition)中。由于
    TDD 鼓励我们进行最小实现工作以使测试通过，然后演化实现，我们将仅实例化`SenderEndPoint`对象并从我们的方法中返回它。
- en: Example 6-2\. First onLogon signature
  id: totrans-87
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-2\. 第一个 onLogon 签名
- en: '[PRE1]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now that we’ve got a nice green bar we need to write another test—`shouldNotAuthenticateUnknownUser()`.
    This will ensure that we don’t allow a user who we don’t know about to log on
    to the system. When writing this test, an interesting issue crops up. How do we
    model the failure scenario here? We don’t want to return a `SenderEndPoint` here,
    but we do need a way of indicating to our UI that the logon has failed. One approach
    would be to use exceptions, which we described in [Chapter 3](ch03.xhtml#chapter_03).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了一个漂亮的绿色条，我们需要编写另一个测试——`shouldNotAuthenticateUnknownUser()`。这将确保我们不允许一个我们不了解的用户登录系统。在编写此测试时，会出现一个有趣的问题。我们如何在这里建模失败情景？我们不希望在这里返回`SenderEndPoint`，但我们确实需要一种方式来指示我们的UI登录失败了。一种方法是使用异常，我们在[第三章](ch03.xhtml#chapter_03)中描述了这种方法。
- en: 'Exceptions could work here, but arguably it’s a bit of an abuse of the concept.
    Failing to logon isn’t really an exceptional scenario—it’s a thing that happens
    all the time. People typo their username, they typo their passwords, and they
    can sometimes even go to the wrong website! An alternative, and common, approach
    would be to return the `SenderEndPoint` if the logon succeeds, and return `null`
    if it fails. This is a flawed approach for several reasons:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 异常在这里可能有用，但可以说这有点滥用概念。登录失败并不是一个异常情况——这是经常发生的事情。人们可能会拼错用户名，拼错密码，有时甚至会进入错误的网站！另一种替代且常见的方法是，如果登录成功，则返回`SenderEndPoint`，如果失败，则返回`null`。这种方法有几个缺点：
- en: If another developer uses the value without checking that it isn’t `null`, they
    get a `NullPointerException`. These kinds of bugs are incredibly common mistakes
    for Java developers to make.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果另一个开发人员在不检查它是否为`null`的情况下使用该值，则会获得`NullPointerException`。这种错误是Java开发人员非常常见的错误。
- en: There is no compile-time support in order to help avoid these kind of issues.
    They crop up at runtime.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有编译时支持可以帮助避免这种类型的问题。它们会在运行时出现。
- en: There is no way to tell from looking at the signature of a method whether it
    is deliberately returning a `null` value to model failure or whether there’s just
    a bug in the code.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从方法的签名中无法判断它是故意返回`null`值来模拟失败，还是代码中有bug。
- en: A better approach that can help here is to use the `Optional` data type. This
    was introduced in Java 8 and models values that may be present or absent. It’s
    a generic type and can be thought of a box where a value may or may not lurk inside—a
    collection with only one or no values inside. Using `Optional` as a return type
    makes it explicit what happens when the method fails to return its value—it returns
    the empty `Optional`. We’ll talk about how to create and use the `Optional` type
    throughout this chapter. So we now refactor our `onLogon` method to have the signature
    in [Example 6-3](#onLogon_2_definition).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这里可以帮助的更好的方法是使用`Optional`数据类型。这是在Java 8中引入的，用于建模可能存在或不存在的值。它是一个通用类型，可以将其视为一个箱子，里面可能有值也可能没有值——一个只有一个或没有值的集合。使用`Optional`作为返回类型使得当方法无法返回其值时发生什么变得明确——它返回空的`Optional`。我们将在本章中讨论如何创建和使用`Optional`类型。因此，我们现在重构我们的`onLogon`方法，使其签名为[示例 6-3](#onLogon_2_definition)中的签名。
- en: Example 6-3\. Second onLogon signature
  id: totrans-95
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-3\. 第二个onLogon签名
- en: '[PRE2]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We also need to modify the `shouldBeAbleToAuthenticateUser()` test in order
    to ensure that it checks that the `Optional` value is present. Our next test is
    `shouldNotAuthenticateUserWithWrongPassword()` and is shown in [Example 6-4](#shouldNotAuthenticateUserWithWrongPassword_definition).
    This test ensures that the user who is logging in has the correct password for
    their logon to work. That means our `onLogon()` method needs to not only store
    the names of our users, but also their passwords in a `Map`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要修改`shouldBeAbleToAuthenticateUser()`测试，以确保它检查`Optional`值是否存在。我们接下来的测试是`shouldNotAuthenticateUserWithWrongPassword()`，如[示例 6-4](#shouldNotAuthenticateUserWithWrongPassword_definition)所示。这个测试确保正在登录的用户拥有正确的密码，以使其登录工作。这意味着我们的`onLogon()`方法不仅需要存储用户的名称，还需要存储他们的密码在一个`Map`中。
- en: Example 6-4\. shouldNotAuthenticateUserWithWrongPassword
  id: totrans-98
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-4\. 应该不会因为密码错误而认证用户
- en: '[PRE3]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: A simple approach for storing the data in this case would have been to use a
    `Map<String, String>`, where the key is the user ID and the value is the password.
    In reality, though, the concept of a user is important to our domain. We’ve got
    stories that refer to users and a lot of the system’s functionality is related
    to users talking to each other. It’s time for a `User` domain class to be added
    to our implementation. Our data structure will be modified to a `Map<String, User>`,
    where the key is the user’s ID and the value is the `User` object for the user
    in question.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，存储数据的简单方法是使用一个`Map<String, String>`，其中键是用户ID，值是密码。然而，实际上，用户的概念对我们的领域很重要。我们有涉及用户的故事，并且系统的许多功能与用户之间的交流相关。现在是向我们的实现中添加一个`User`领域类的时候了。我们的数据结构将被修改为一个`Map<String,
    User>`，其中键是用户的ID，值是所讨论用户的`User`对象。
- en: A common criticism about TDD is that it discourages the design of software.
    That it just leads you to write tests and you end up with an anaemic domain model
    and have to just rewrite your implementation at some point. By an *anaemic domain
    model* we mean a model where the domain objects don’t have much business logic
    and it’s all scattered across different methods in a procedural style. That’s
    certainly a fair critique of the way that TDD can sometimes be practiced. Spotting
    the right point in time to add a domain class or make some concept real in code
    is a subtle thing. If the concept is something that your user stories are always
    referring to, though, you should really have something in your problem domain
    representing it.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: TDD的一个常见批评是它抑制了软件设计。它只会让你编写测试，最终导致贫血的领域模型，你最终不得不在某个时候重写你的实现。所谓*贫血的领域模型*指的是领域对象没有太多的业务逻辑，而是散布在不同的方法中，以过程化的方式。这确实是对TDD有时候可能被实践的一种公平批评。然而，识别在何时添加一个领域类或在代码中实现某个概念是一个微妙的事情。如果这个概念是你的用户故事经常提到的内容，那么你的问题域中确实应该有代表它的东西。
- en: There are some clear anti-patterns that you can spot, however. For example,
    if you’ve built different lookup structures with the same key, that you add to
    at the same time but relate to different values, then you’re missing a domain
    class. So if we track the set of followers and the password for our user and we
    have two `Map` objects from the user ID, one onto followers and one onto a password,
    then there’s a concept in the problem domain missing. We actually introduced our
    `User` class here with only a single value that we cared about—the password—but
    an understanding of the problem domain tells us that users are important so we
    weren’t being overly premature.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可以看到一些明显的反模式。例如，如果你建立了不同的查找结构，使用相同的键，同时添加但涉及不同的值，那么你可能缺少一个领域类。因此，如果我们跟踪用户的关注者集合和密码，并且我们有两个`Map`对象，一个是用户ID对应关注者，一个是用户ID对应密码，那么在问题域中缺少一个概念。我们在这里引入了我们的`User`类，只关注了一个我们关心的值—密码—但对问题域的理解告诉我们，用户是重要的，因此我们并没有过早行事。
- en: Note
  id: totrans-103
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: From this point onward in the chapter we’ll use the word “user” to represent
    the generic concept of a user, and the stylized `User` to represent the domain
    class. Similarly, we use Twootr to refer to the system as a whole, and `Twootr`
    to refer to the class that we’re developing.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 从本章开始，我们将使用“用户”一词来代表用户的一般概念，并使用`User`来表示领域类。同样地，我们使用Twootr来指代整个系统，使用`Twootr`来指代我们正在开发的类。
- en: Passwords and Security
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 密码和安全性
- en: So far we’ve avoid talking about security at all. In fact, not talking about
    security concerns and hoping that they will just go away is the technology industries’
    favorite security strategy. Explaining how to write secure code isn’t a primary,
    or even secondary, objective of this book; however, Twootr does use and store
    passwords for authentication so it’s worth thinking a little about this topic.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们完全避免讨论安全性。事实上，不谈论安全问题并希望它们会自行消失，是技术行业最喜欢的安全策略。解释如何编写安全代码不是本书的主要目标，甚至不是次要目标；然而，Twootr确实使用和存储密码进行身份验证，因此值得稍微考虑一下这个话题。
- en: The simplest approach to storing passwords is to treat them like any other `String`,
    known as storing them *plain text*. This is bad practice in general as it means
    anyone who has access to your database has access to the passwords of all your
    users. A malicious person or organization can, and in many cases has, used plain-text
    passwords in order to log in to your system and pretend to be the users. Additionally,
    many people use the same password for multiple different services. If you don’t
    believe us, ask any of your elderly relatives!
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 存储密码的最简单方法是将其视为任何其他`String`，称为存储它们的*明文*。一般来说，这是一个坏习惯，因为这意味着任何可以访问您的数据库的人都可以访问所有用户的密码。一个恶意人或组织可以，并且在许多情况下已经使用明文密码来登录您的系统并假装是用户。此外，许多人将相同的密码用于多个不同的服务。如果你不相信我们，问问你的年长亲戚！
- en: In order to avoid anyone with access to your database just reading the passwords,
    you can apply a *cryptographic hash function* to the password. This is a function
    that takes some arbitrarily sized input string and converts it to some output,
    called a *digest*. Cryptographic hash functions are deterministic, so that if
    you want to hash the same input again you can get the same result. This is essential
    in order to be able to check the hashed password later. Another key property is
    that while it should be quick to go from input to digest, the reverse function
    should take so long or use so much memory that it is impractical for an attacker
    to reverse the digest.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免任何人都能访问您的数据库并读取密码，您可以对密码应用*加密哈希函数*。这是一个函数，它接受一些任意大小的输入字符串并将其转换为一些输出，称为*摘要*。加密哈希函数是确定性的，因此如果您想再次对相同的输入进行哈希，您可以得到相同的结果。这对于以后检查哈希密码至关重要。另一个关键属性是，虽然从输入到摘要的转换应该很快，但反向函数应该需要很长时间或使用很多内存，以至于攻击者无法反转摘要是不切实际的。
- en: The design of cryptographic hash functions is an active research topic on which
    governments and companies spend a lot of money. They are hard to implement correctly
    so you should never write your own—Twootr uses an established Java library called
    [Bouncy Castle](https://www.bouncycastle.org/). This is open source and has undergone
    heavy peer review. Twootr uses the *Scrypt* hashing function, which is a modern
    algorithm specifically designed for storing passwords. [Example 6-5](#KeyGenerator_definition)
    shows an example of the code.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 加密哈希函数的设计是一个活跃的研究课题，政府和公司花费了大量资金在上面。它们很难正确实现，因此您永远不应该自己编写——Twootr使用了一个名为[Bouncy
    Castle](https://www.bouncycastle.org/)的成熟的Java库。这是开源的，并经过了大量的同行评审。Twootr使用了*Scrypt*哈希函数，这是一种专门用于存储密码的现代算法。[示例 6-5](#KeyGenerator_definition)展示了代码示例。
- en: Example 6-5\. KeyGenerator
  id: totrans-110
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-5\. 密钥生成器
- en: '[PRE4]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: A problem that many hashing schemes have is that even though they are very computationally
    expensive to compute, it may be feasible to compute a reversal of the hashing
    function through brute forcing all the keys up to a certain length or through
    a [rainbow table](https://oreil.ly/0y6Pc). In order to guard against this possibility,
    we use a salt. *Salts* are extra randomly generated input that is added to a cryptographic
    hashing function. By adding some extra input to each password that the user wouldn’t
    enter, but is randomly generated, we stop someone from being able to create a
    reverse lookup of the hashing function. They would need to know the hashing function
    and the salt.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 许多散列方案存在的一个问题是，即使它们计算起来非常昂贵，计算出散列函数的逆转可能也是可行的，通过对所有密钥进行暴力破解直到某个长度或通过[彩虹表](https://oreil.ly/0y6Pc)。为了防范这种可能性，我们使用盐。*盐*是添加到加密哈希函数中的额外随机生成的输入。通过为每个用户的密码添加一些用户不会输入但是随机生成的额外输入，我们阻止了有人能够创建散列函数的反向查找。他们需要知道哈希函数和盐。
- en: Now we’ve mentioned a few basic security concepts here around the idea of storing
    passwords. In reality, keeping a system secure is an ongoing effort. Not only
    do you need to worry about the security of data at rest, but also data in flight.
    When someone connects to your server from a client, it needs to transmit the user’s
    password over a network connection. If a malicious attacker intercepts this connection,
    they could take a copy of the password and use it to do the most dastardly thing
    possible in 140 characters!
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在这里提到了一些围绕密码存储的基本安全概念。实际上，保持系统安全是一个持续不断的工作。你不仅需要担心静态数据的安全性，还需要担心传输中的数据。当有人从客户端连接到您的服务器时，它需要通过网络连接传输用户的密码。如果一个恶意攻击者拦截了这个连接，他们可能会复制密码并用它做140个字符中最邪恶的事情！
- en: In the case of Twootr, we receive a login message via WebSockets. This means
    that for our application to be secure the WebSocket connection needs to be secure
    against a man-in-the-middle attack. There are several ways to do this; the most
    common and simplest is to use *Transport Layer Security* (TLS), which is a cryptographic
    protocol that aims to provide privacy and data integrity to data sent out over
    its connection.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Twootr 来说，我们通过 WebSockets 收到登录消息。这意味着为了保证我们的应用程序安全，WebSocket 连接需要防止中间人攻击。有几种方法可以做到这一点；最常见和最简单的方法是使用**传输层安全性**（TLS），这是一种旨在为其连接发送的数据提供隐私和数据完整性的加密协议。
- en: Organizations with a mature understanding of security build regular reviews
    and analysis into the design of their software. For example, they might periodically
    bring in outside consultants or an internal team to attempt to penetrate a system’s
    security defenses by playing the role of a attacker.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 具有成熟安全理解的组织在软件设计中建立定期审查和分析。例如，他们可能定期引入外部顾问或内部团队来尝试渗透系统的安全防御，扮演攻击者的角色。
- en: Followers and Twoots
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**关注者和 Twoots**'
- en: The next requirement that we need to address is following users. You can think
    about designing software in one of two different ways. One of those approaches,
    called *bottom-up*, starts with designing the core of the application—data storage
    models or relationships between core domain objects—works its way up to building
    the functionality of the system. A bottom-up way of looking at following between
    users would be to decide how to model the relationship between users that following
    entails. It’s clearly a many-to-many relationship since each user can have many
    followers and a user can follow many other users. You would then proceed to layer
    on top of this data model the business functionality that is required to keep
    users happy.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要解决的下一个要求是关注用户。您可以考虑以两种不同的方式设计软件。其中一种方法称为**自下而上**，从设计应用程序的核心开始——数据存储模型或核心领域对象之间的关系——逐步构建系统的功能。在用户之间关注的自下而上方法中，首先需要决定如何建模关注之间的关系。显然这是一种多对多的关系，因为每个用户都可以有多个关注者，一个用户可以关注多个其他用户。然后，您将继续在此数据模型上添加所需的业务功能，以保持用户满意。
- en: The other approach is a *top-down* approach to software development. This starts
    with user requirements or stories and tries to develop the behavior or functionality
    needed to implement these stories, slowly driving down to the concerns of storage
    or data modeling. For example, we would start with the API for receiving an event
    to follow another user and then design whatever storage mechanism is needed for
    this behavior, slowly working from API to business logic to persistence.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是软件开发的**自上而下**方法。这从用户需求或用户故事开始，尝试开发实现这些故事所需的行为或功能，逐步向存储或数据建模的关注点发展。例如，我们将从接收关注另一个用户事件的
    API 开始，并设计所需的任何存储机制来实现此行为，逐步从 API 到业务逻辑再到持久化。
- en: It is hard to say that one approach is better in all circumstances and that
    the other should always be avoided; however, for the line-of-business type of
    applications that Java is very popular for writing our experience is that a top-down
    approach works best. This is because the temptation when you start with data modeling
    or designing the core domain of your software is that you can expend unncessary
    time on features that aren’t necessary for your software to work. The downside
    of a top-down approach is that sometimes as you build out more requirements and
    stories your initial design can be unsatisfactory. This means that you need to
    take a vigilant and iterative approach to software design, where you constantly
    improve it over time.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 很难说在所有情况下哪种方法更好，以及另一种方法总是应该避免；然而，对于 Java 非常流行的企业应用程序来说，我们的经验是自上而下的方法效果最佳。这是因为当你开始进行数据建模或设计软件的核心领域时，你可能会花费不必要的时间在软件正常运行所不必要的功能上。自上而下方法的缺点是，有时随着您构建更多的需求和故事，您的初始设计可能不尽如人意。这意味着您需要对软件设计采取警惕和迭代的方法，不断改进它。
- en: In this chapter of the book we will show you a top-down approach. This means
    that we start with a test to prove out the functionality of following users, shown
    in [Example 6-6](#shouldFollowValidUser_definition). In this case our UI will
    be sending us a event to indicate that a user wants to follow another user, so
    our test will call the `onFollow` method of our end point with the unique ID of
    the user to follow as an argument. Of course, this method doesn’t yet exist—so
    we need to declare it in the `Twootr` class in order to get the code to compile.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的这一章中，我们将向您展示自上而下的方法。这意味着我们从一个测试开始，以验证关注用户的功能，如[示例6-6](#shouldFollowValidUser_definition)所示。在这种情况下，我们的UI将向我们发送一个事件，指示用户想要关注另一个用户，因此我们的测试将调用我们端点的`onFollow`方法，并将要关注的用户的唯一ID作为参数传递。当然，这个方法还不存在——所以我们需要在`Twootr`类中声明它，以便使代码编译通过。
- en: Modeling Errors
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 建模错误
- en: The test in [Example 6-6](#shouldFollowValidUser_definition) just covers the
    golden path of the following operation, so we need to ensure that the operation
    has succeeded.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例6-6](#shouldFollowValidUser_definition)中的测试仅涵盖了关注操作的黄金路径，因此我们需要确保操作已成功执行。
- en: Example 6-6\. shouldFollowValidUser
  id: totrans-123
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-6\. 应该关注有效用户
- en: '[PRE5]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: For now we only have a success scenario, but there are other potential scenarios
    to think about. What if the user ID passed as an argument doesn’t correspond to
    an actual user? What if the user is already following the user that they’ve asked
    to follow? We need a way of modeling the different results or statuses that this
    method can return. As with everything in life, there’s a proliferation of different
    choices that we can make. Decisions, decisions, decisions…
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 目前我们只有一个成功的场景，但还有其他潜在的场景需要考虑。如果作为参数传递的用户ID不对应于实际用户会怎样？如果用户已经在关注他们所请求关注的用户会怎样？我们需要一种方法来建模此方法可以返回的不同结果或状态。生活中有很多不同的选择可供我们选择。决策，决策，决策……
- en: One approach would be to throw an exception when the operation returns and return
    void when it succeeds. This could be a completely reasonable choice. It may not
    fall foul of our idea that exceptions should only be used for exceptional control
    flow, in the sense that a well-designed UI would avoid these scenarios cropping
    up under normal circumstances. Let’s consider some alternatives, though, that
    treat the status like a value, rather than using exceptions at all.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法是在操作返回时抛出异常并在成功时返回`void`。这可能是一个完全合理的选择。它可能不会违反我们的想法，即异常应仅用于异常控制流，因为一个设计良好的UI会在正常情况下避免这些场景的出现。不过，让我们考虑一些替代方案，它们将状态视为一个值，而不是根本不使用异常。
- en: One simple approach would be using a `boolean` value—`true` to indicate success
    and `false` to indicate failure. That’s a fair choice in situations where an operation
    can either succeed or fail, and it would only fail for a single reason. The problem
    with the `boolean` approach in situations that have multiple failure scenarios
    is that you don’t know *why* it failed.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的方法是使用`boolean`值——`true`表示成功，`false`表示失败。在操作只能成功或失败的情况下，这是一个公平的选择，而且只会因为一个原因而失败。在具有多个失败场景的情况下，`boolean`方法的问题在于你不知道*为什么*它失败了。
- en: 'Alternatively, we could use simple `int` constant values to represent each
    of the different failure scenarios, but as discussed in [Chapter 3](ch03.xhtml#chapter_03)
    when introducing the concept of exceptions, this is an error prone, type unsafe,
    and poor readability + maintainability approach. There is an alternative here
    for statuses that is type safe and offers better documentation: *enum* types.
    An `enum` is a list of predefined constant alternatives that constitutes a valid
    type. So anywhere that you can use an `interface` or a `class` you can use an
    `enum`.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用简单的`int`常量值来表示每种不同的失败场景，但正如在[第3章](ch03.xhtml#chapter_03)中讨论异常概念时所述，这种方法容易出错、类型不安全，并且可读性和可维护性较差。这里有一个替代方案适用于类型安全并提供更好文档的情况：*枚举*类型。`enum`是一组预定义的常量替代品，构成一个有效的类型。因此，任何可以使用`interface`或`class`的地方都可以使用`enum`。
- en: But enums are better than `int`-based status codes in several ways. If a method
    returns you an `int` you don’t necessarily know what values the `int` could contain.
    It’s possible to add javadoc to describe what values it can take, and it’s possible
    to define constants (static final fields), but these are really just lipstick
    on a pig. Enums can only contain the list of values that are defined by the `enum`
    declaration. Enums in Java can also have instance fields and methods defined on
    them in order to add useful functionality, though we won’t be using that feature
    in this case. You can see the declaration of our follower status in [Example 6-7](#FollowStatus_definition).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 但是枚举比基于`int`的状态码更好。如果一个方法返回一个`int`，你不一定知道`int`可能包含哪些值。可以添加 javadoc 来描述它可以取哪些值，也可以定义常量（静态
    final 字段），但这些只是徒劳的举动。枚举只能包含由`enum`声明定义的值列表。在 Java 中，枚举还可以在其上定义实例字段和方法，以添加有用的功能，尽管在这种情况下我们不会使用该功能。您可以在
    [示例 6-7](#FollowStatus_definition) 中看到我们关注者状态的声明。
- en: Example 6-7\. FollowStatus
  id: totrans-130
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-7\. FollowStatus
- en: '[PRE6]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Since TDD drives us to write the simplest implementation to get a test passing,
    then `onFollow` method at this point should simply return the `SUCCESS` value.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 TDD 驱使我们编写最简单的实现来通过测试，所以在这一点上`onFollow`方法应该简单地返回`SUCCESS`值。
- en: We’ve got a couple of other different scenarios to think about for our `following()`
    operation. [Example 6-8](#shouldNotDuplicateFollowValidUser_definition) shows
    the test that drives our thinking around duplicate users. In order to implement
    it we need to add a set of user IDs to our `User` class to represent the set of
    users that this user is following and ensure that the addition of another user
    isn’t a duplicate. This is really easy with the Java collections API. There’s
    already a `Set` interface that defines unique elements, and the `add` method will
    return `false` if the element that you’re trying to add is already a member of
    the `Set`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一些不同的场景需要考虑我们的`following()`操作。 [示例 6-8](#shouldNotDuplicateFollowValidUser_definition)
    展示了驱动我们思考重复用户的测试。为了实现它，我们需要向我们的`User`类添加一组用户 ID 来表示此用户正在关注的用户集，并确保添加另一个用户不是重复的。这在
    Java 集合 API 中非常容易。已经有了一个定义了唯一元素的`Set`接口，如果您要添加的元素已经是`Set`的成员，则`add`方法将返回`false`。
- en: Example 6-8\. shouldNotDuplicateFollowValidUser
  id: totrans-134
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-8\. shouldNotDuplicateFollowValidUser
- en: '[PRE7]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The test `shouldNotFollowInValidUser()` asserts that if the user isn’t valid,
    then the result status will indicate that. It follows a similar format to `shouldNotDuplicateFollowValidUser()`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 测试`shouldNotFollowInValidUser()`断言如果用户无效，则结果状态将指示。它遵循与`shouldNotDuplicateFollowValidUser()`类似的格式。
- en: Twooting
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Twooting
- en: Now we’ve laid the foundations let’s get to the exciting bit of the product—twooting!
    Our user story described how any user could send a twoot and that any followers
    who were logged in at that moment in time should immediately see the twoot. Now
    realistically we can’t see that users will see the twoot immediately. Perhaps
    they’re logged into their computer but getting a coffee, staring at another social
    network or, God forbid, doing some work.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经奠定了基础，让我们来看产品的激动人心的部分—twooting！我们的用户故事描述了任何用户都可以发送一个 twoot，并且在那个时刻已经登录的任何关注者应该立即看到这个
    twoot。现实情况下，我们不能保证用户会立即看到这个 twoot。也许他们已经登录到他们的计算机，但在喝咖啡，盯着其他社交网络，或者，天佑，做一些工作。
- en: By now you’re probably familiar with the overall approach. We want to write
    a test for a scenario where a user who has logged on receives a twoot from another
    user who sends the twoot—`shouldReceiveTwootsFromFollowedUser()`. In addition
    to logging on and following, this test requires a couple of other concepts. First,
    we need to model the sending of a twoot, and thus add an `onSendTwoot()` method
    to the `SenderEndPoint`. This has parameters for the `id` of the twoot, so that
    we can refer back to it later, and also its content.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可能已经熟悉了总体方法。我们想要为已登录用户收到来自另一用户发送的 twoot 场景编写一个测试—`shouldReceiveTwootsFromFollowedUser()`。除了登录和关注外，这个测试需要一些其他概念。首先，我们需要模拟发送
    twoot，并向`SenderEndPoint`添加一个`onSendTwoot()`方法。这个方法有两个参数，用于 twoot 的`id`，这样我们以后就可以引用它，以及它的内容。
- en: Second, we need a way of notifying a follower that a user has twooted—something
    that we can check has happened in our test. We earlier introduced the `ReceiverEndPoint`
    as a way of publishing messages out to users, and now is the time to start using
    it. We’ll add an `onTwoot` method resulting in [Example 6-9](#ReceiverEndPoint_definition).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，我们需要一种方法通知跟随者用户已经发送了一条推文-这是我们可以检查的测试发生的事情。我们之前介绍了`ReceiverEndPoint`作为向用户发布消息的一种方式，现在是时候开始使用它了。我们将添加一个`onTwoot`方法，导致[示例 6-9](#ReceiverEndPoint_definition)。
- en: Example 6-9\. ReceiverEndPoint
  id: totrans-141
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-9\. ReceiverEndPoint
- en: '[PRE8]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Whatever our UI adapter is will have to send a message to the UI to tell it
    that a twoot has happened. But the question is how do write a test that checks
    that this `onTwoot` method has been called?
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们的UI适配器是什么，都必须向UI发送消息以告知其发生了推文。但问题是如何编写一个检查此`onTwoot`方法是否已被调用的测试呢？
- en: Creating Mocks
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建模拟对象
- en: This is where the concept of a *mock* object comes in handy. A mock object is
    a type of object that pretends to be another object. It has the same methods and
    public API as the object being mocked and looks to the Java type system as though
    it’s another object, but it’s not. Its purpose is to record any interactions,
    for example, method calls, and be able to *verify* that certain method calls happen.
    For example, here we want to be able to verify that the `onTwoot()` method of
    `ReceiverEndPoint` has been called.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是*模拟*对象概念派上用场的地方。模拟对象是一种假装是另一个对象的类型。它具有与被模拟对象相同的方法和公共API，并且在Java类型系统中看起来像另一个对象，但实际上不是。它的目的是记录任何交互，例如方法调用，并能够*验证*某些方法调用是否发生。例如，这里我们希望能够验证`ReceiverEndPoint`的`onTwoot()`方法是否已被调用。
- en: Note
  id: totrans-146
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: It might be confusing for people who have a computer science degree reading
    this book to hear the word “verify” being used in this way. The mathematics and
    formal methods communities tend to use it to mean situations where a property
    of a system has been proved for all inputs. Mocking uses the word totally differently.
    It just means checking that a method has been invoked with certain arguments.
    It’s sometimes frustrating when different groups of people use the same word with
    overloaded meanings, but often we just need to be aware of the different contexts
    that terminology exists within.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 对于具有计算机科学学位的人来说，阅读本书时听到“验证”这个词被用于这种方式可能有些混淆。数学和形式化方法的社区倾向于将其用于指所有输入的系统属性已被证明的情况。而在模拟中，“验证”一词的意思完全不同。它只是检查某个方法是否已以特定参数调用。当不同的人群使用同一个词具有多重含义时，有时会令人沮丧，但通常我们只需要意识到术语存在的不同上下文即可。
- en: Mock objects can be created in a number of ways. The first mock objects tended
    to be written by hand; we could in fact hand write a mock implementation of `ReceiverEndPoint`
    here, and [Example 6-10](#MockReceiverEndPoint_definition) is an example of one.
    Whenever the `onTwoot` method is called we record its invocation by storing the
    `Twoot` parameter in a `List`, and we can verify that it has been called with
    certain arguments by making an assertion that the `List` contains the `Twoot`
    object.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过多种方式创建模拟对象。最早的模拟对象往往是手工编写的；实际上，我们可以在这里手工编写一个`ReceiverEndPoint`的模拟实现，[示例 6-10](#MockReceiverEndPoint_definition)就是其中一个示例。每当调用`onTwoot`方法时，我们通过将`Twoot`参数存储在`List`中记录其调用，并且可以通过断言`List`包含`Twoot`对象来验证它已被调用以特定参数。
- en: Example 6-10\. MockReceiverEndPoint
  id: totrans-149
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-10\. MockReceiverEndPoint
- en: '[PRE9]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In practice, writing mocks by hand can become tedious and error prone. What
    do good software engineers do to tedious and error-prone things? That’s right—they
    automate them. There are a number of libraries that can help us by providing ways
    of creating mock objects for us. The library that we will use in this project
    is called *Mockito*, is freely available, open source, and commonly used. Most
    of the operations relating to *Mockito* can be invoked using static methods on
    the `Mockito` class, which we use here as static imports. In order to create the
    mock object you need to use the `mock` method, as shown in [Example 6-11](#mockReceiverEndPoint_definition).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，手动编写模拟可能变得繁琐且容易出错。优秀的软件工程师如何应对繁琐且容易出错的事情呢？没错，他们自动化了这些过程。有许多库可以帮助我们通过提供创建模拟对象的方式来解决这个问题。我们在这个项目中将使用的库称为*Mockito*，它是免费的、开源的，并且被广泛使用。大多数与*Mockito*相关的操作可以通过`Mockito`类的静态方法来调用，我们在此处使用静态导入。为了创建模拟对象，您需要使用`mock`方法，如[示例 6-11](#mockReceiverEndPoint_definition)所示。
- en: Example 6-11\. mockReceiverEndPoint
  id: totrans-152
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-11\. mockReceiverEndPoint
- en: '[PRE10]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Verifying with Mocks
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用模拟对象进行验证
- en: The mock object that has been created here can be used wherever a normal `ReceiverEndPoint`
    implementation is used. We can pass it as a parameter to the `onLogon()` method,
    for example, to wire up the UI adapter. Once the behavior under test—the *when*
    of the test—has happened our test needs to actually verify that the `onTwoot`
    method was invoked (the *then*). In order to do this we wrap the mock object using
    the `Mockito.verify()` method. This is a generic method that returns an object
    of the same type that it is passed; we simply call the method in question with
    the arguments that we expect in order to describe the expected interaction with
    the mock object, as shown in [Example 6-12](#verifyReceiverEndPoint_definition).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里创建的模拟对象可以在正常的 `ReceiverEndPoint` 实现被使用的任何地方使用。例如，我们可以将它作为参数传递给 `onLogon()`
    方法，以连接 UI 适配器。一旦测试的行为——测试的“when”——发生了，我们的测试需要实际验证 `onTwoot` 方法是否被调用——“then”。为了做到这一点，我们使用
    `Mockito.verify()` 方法包装模拟对象。这是一个通用方法，返回与其传入类型相同的对象；我们只需调用所期望的方法，并传入我们期望的参数，以描述与模拟对象的预期交互，如[示例 6-12](#verifyReceiverEndPoint_definition)所示。
- en: Example 6-12\. verifyReceiverEndPoint
  id: totrans-156
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-12\. 验证接收端点
- en: '[PRE11]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Something you may have noticed in the last section is the introduction of the
    `Twoot` class that we used in the signature of the `onTwoot` method. This is a
    value object that will be used to wrap up the values and represent a `Twoot`.
    Since this will be sent to the UI adapter it should just consist of fields of
    simple values, rather than exposing too much from the core domain. For example,
    in order to represent the sender of the twoot it contains the `id` of the sender
    rather than a reference to their `User` object. The `Twoot` also contains a `content`
    `String` and the `id` of the `Twoot` object itself.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中你可能注意到的一件事是我们引入了 `Twoot` 类，它在 `onTwoot` 方法的签名中使用。这是一个值对象，用于封装值并表示 `Twoot`。由于它将被发送到
    UI 适配器，因此它应该只包含简单值的字段，而不是从核心领域中过度暴露。例如，为了表示 `Twoot` 的发送者，它包含发送者的 `id`，而不是它们的 `User`
    对象的引用。`Twoot` 还包含一个 `content` 的 `String` 和 `Twoot` 对象本身的 `id`。
- en: In this system `Twoot` objects are immutable. As mentioned previously, this
    style reduces the scope for bugs. This is especially important in something like
    a value object that is being passed to a UI adapter. You really just want to let
    your UI adapter display the `Twoot`, not to alter the state of another user’s
    `Twoot`. It’s also worth noting that we continue to follow domain language here
    in naming the class `Twoot`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个系统中，`Twoot` 对象是不可变的。如前所述，这种风格减少了错误的可能性。在像传递给 UI 适配器的值对象中，这尤为重要。你确实只想让你的 UI
    适配器显示 `Twoot`，而不是改变另一个用户的 `Twoot` 的状态。值得注意的是，我们继续遵循领域语言，将类命名为 `Twoot`。
- en: Mocking Libraries
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟库
- en: We’re using Mockito in this book because it has nice syntax and fits our preferred
    way of writing mocks, but it’s not the only Java mocking framework. Both Powermock
    and EasyMock are also popular.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本书中使用 Mockito 是因为它有良好的语法，并且符合我们的首选编写模拟的方式，但它并不是唯一的 Java 模拟框架。Powermock 和
    EasyMock 也很流行。
- en: Powermock can emulate Mockito syntax but it allows you to mock things that Mockito
    doesn’t support; for example, final classes or static methods. There is some debate
    around whether it’s ever a good idea to mock things like final classes—if you
    can’t provide a different implementation of the class in production, then should
    you really really be doing so in tests? In general, Powermock usage isn’t encouraged
    but there can occasionally be break-glass situations where it is useful.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Powermock 可以模拟 Mockito 的语法，但允许您模拟 Mockito 不支持的事物，例如最终类或静态方法。关于是否应该模拟最终类等事物存在一些争论——如果你不能在生产中提供一个不同的实现，那么在测试中确实需要这样做吗？一般来说，不鼓励使用
    Powermock，但在偶尔的特殊情况下，它确实是有用的。
- en: EasyMock takes a different approach to writing mocks. This is a stylistic choice
    and may be preferred by some developers over others. The biggest conceptual difference
    is that EasyMock encourages strict mocking. Strict mocking is the idea that if
    you don’t explicitly state that an invocation should occur, then it’s an error
    to do so. This results in tests that are more specific about the behavior that
    a class performs, but that can sometimes become coupled to irrelevant interactions.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: EasyMock 在编写模拟时采用了不同的方法。这是一种风格选择，可能会被一些开发人员所青睐。最大的概念上的差异在于，EasyMock 鼓励严格模拟。严格模拟的理念是，如果你没有明确声明一个调用应该发生，那么如果它确实发生了，那就是一个错误。这导致测试对类执行的行为更加具体，但有时可能会与无关的交互耦合在一起。
- en: SenderEndPoint
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SenderEndPoint
- en: Now these methods like `onFollow` and `onSendTwoot` are declared on the `SenderEndPoint`
    class. Each `SenderEndPoint` instance represents the end point from which a single
    user sends events into the core domain. Our design for `Twoot` keeps the `SenderEndPoint`
    simple—it just wraps up the main `Twootr` class and delegates to the methods passing
    in the `User` object for the user that it represents within the system. [Example 6-13](#SenderEndPoint_definition)
    shows the overall declaration of the class and an example of one method corresponding
    to one event—`onFollow`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在像 `onFollow` 和 `onSendTwoot` 这样的方法都声明在 `SenderEndPoint` 类上。每个 `SenderEndPoint`
    实例代表了一个用户将事件发送到核心领域的终点。我们的 `Twoot` 设计保持了 `SenderEndPoint` 的简单性 —— 它只是将主 `Twootr`
    类包装起来，并委托调用这些方法，传入系统中表示的用户的 `User` 对象。 [示例 6-13](#SenderEndPoint_definition) 显示了类的整体声明和一个方法对应一个事件的示例
    —— `onFollow`。
- en: Example 6-13\. SenderEndPoint
  id: totrans-166
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-13\. SenderEndPoint
- en: '[PRE12]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You might have noticed the `java.util.Objects` class in [Example 6-13](#SenderEndPoint_definition).
    This is a utility class that ships with the JDK itself and offers convenience
    methods for `null` reference checking and implementation of `hashCode()` and `equals()`
    methods.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到 [示例 6-13](#SenderEndPoint_definition) 中的 `java.util.Objects` 类。这是 JDK
    自带的实用类，提供了用于检查 `null` 引用和实现 `hashCode()` 和 `equals()` 方法的便捷方法。
- en: There are alternative designs that we could consider instead of introducing
    the `SenderEndPoint`. We could have received events relating to a user by just
    exposing the methods on the `Twootr` object directly, and expect to have any UI
    adapter call those methods directly. This is a subjective issue, like many parts
    of software development. Some people would consider creating the `SenderEndPoint`
    as adding unnecessary complexity.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些替代设计我们可以考虑，而不是引入 `SenderEndPoint`。我们可以通过直接在 `Twootr` 对象上公开方法来接收与用户相关的事件，并期望任何
    UI 适配器直接调用这些方法。这是一个主观问题，就像软件开发的许多部分一样。有些人会认为创建 `SenderEndPoint` 增加了不必要的复杂性。
- en: The biggest motivation here is that, as mentioned earlier, we don’t want to
    expose the `User` core domain object to a UI adapter—only talking to them in terms
    of simple events. It would have been possible to take a user ID as a parameter
    to all the `Twootr` event methods, but then the first step for every event would
    have been looking up the `User` object from the ID, whereas here we already have
    it in the context of the `SenderEndPoint`. That design would have removed the
    concept of the `SenderEndPoint`, but added more work and complexity in exchange.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这里最大的动机是，如前所述，我们不想将 `User` 核心域对象暴露给 UI 适配器 —— 只需简单事件来与他们交流。可能可以在所有 `Twootr`
    事件方法中将用户 ID 作为参数，但然后每个事件的第一步都需要查找该 ID 的 `User` 对象，而在这里我们已经在 `SenderEndPoint` 的上下文中有它了。那种设计会去除
    `SenderEndPoint` 的概念，但以交换更多的工作和复杂性。
- en: In order to actually send the `Twoot` we need to evolve our core domain a little
    bit. The `User` object needs to have a set of followers added to it, who can be
    notified of the `Twoot` when it arrives. You can see code for our `onSendTwoot`
    method as it is implemented at this stage in the design in [Example 6-14](#onSendTwoot_definition_1).
    This finds the users the who are logged on and tells them to receive the twoot.
    If you’re not familiar with the `filter` and `forEach` methods or the `::` or
    `->` syntax, don’t worry—these will be covered in [“Functional Programming”](ch07.xhtml#ch06_Functional_Programming).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实际发送 `Twoot`，我们需要稍微完善我们的核心领域。`User` 对象需要添加一组关注者，当 `Twoot` 到达时可以通知他们。你可以在 [示例 6-14](#onSendTwoot_definition_1)
    中看到我们 `onSendTwoot` 方法的实现代码。在设计的这个阶段，它找到已登录的用户并告诉他们接收 `Twoot`。如果你对 `filter` 和
    `forEach` 方法，以及 `::` 或 `->` 语法不熟悉，不用担心 —— 这些内容将在 [“函数式编程”](ch07.xhtml#ch06_Functional_Programming)
    中介绍。
- en: Example 6-14\. onSendTwoot
  id: totrans-172
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-14\. onSendTwoot
- en: '[PRE13]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `User` object also needs to implement the `receiveTwoot()` method. How does
    a `User` receive a twoot? Well, it should notify the UI for the user that there’s
    a twoot ready to be displayed by emitting an event, which entails calling `receiverEndPoint.onTwoot(twoot)`.
    This is the method call that we’ve verified the invocation of using mocking code,
    and calling it here makes the test pass.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`User` 对象还需要实现 `receiveTwoot()` 方法。用户如何接收 `Twoot`？好吧，它应该通过发出事件通知用户界面，表明有一个
    `Twoot` 准备好显示，即调用 `receiverEndPoint.onTwoot(twoot)`。这是我们使用模拟代码验证调用的方法，并在这里调用它使测试通过。'
- en: You can see the final iteration of our test in [Example 6-15](#shouldReceiveTwootsFromFollowedUser_definition),
    and this is the code that you can see if you download the example project from
    GitHub. You might notice it looks a bit different than what we’ve so far described.
    First, as the tests for receiving twoots have been written, a few operations have
    been refactored out into common methods. An example of this is `logon()`, which
    logs our first user onto the system—part of the given section of many tests. Second,
    the test also creates a `Position` object and passes it to the `Twoot`, and also
    verifies the interaction with a `twootRepository`. What the heck is a repository?
    Both of these are concepts that we’ve not needed so far, but are part of the evolution
    of the design of the system and will be explained in the next two sections.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[Example 6-15](#shouldReceiveTwootsFromFollowedUser_definition)中看到我们测试的最终迭代，如果您从GitHub下载示例项目，则可以看到这段代码。您可能会注意到它看起来与我们到目前为止描述的有些不同。首先，由于已编写接收twoots的测试，一些操作已经重构到了公共方法中。其中一个示例是`logon()`，它将我们的第一个用户登录到系统中——这是许多测试给定部分的一部分。其次，该测试还创建了一个`Position`对象，并将其传递给`Twoot`，并验证了与`twootRepository`的交互。仓库是什么鬼？这两者到目前为止我们还没有需要，但它们是系统设计演变的一部分，将在接下来的两个部分中解释。
- en: Example 6-15\. shouldReceiveTwootsFromFollowedUser
  id: totrans-176
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 6-15\. shouldReceiveTwootsFromFollowedUser
- en: '[PRE14]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Positions
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 位置
- en: You will learn about `Position` objects very soon, but before presenting their
    definition we should meet their motivation. The next the requirement that we need
    to get working is that when a user logs in they should see all the twoots from
    their followers since they last logged in. This entails needing to be able to
    perform some kind of replay of the different twoots, and know what twoots haven’t
    been seen when a user logs on. [Example 6-16](#shouldReceiveReplayOfTwootsAfterLogoff_definition)
    shows a test of that functionality.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 你很快就会了解`Position`对象，但在展示它们的定义之前，我们应该了解它们的动机。我们需要解决的下一个要求是，当用户登录时，他们应该看到自上次登录以来他们关注者的所有twoots。这需要能够对不同的twoots执行某种重播，并知道用户登录时还未看到的twoots。[Example 6-16](#shouldReceiveReplayOfTwootsAfterLogoff_definition)展示了该功能的一个测试。
- en: Example 6-16\. shouldReceiveReplayOfTwootsAfterLogoff
  id: totrans-180
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 6-16\. shouldReceiveReplayOfTwootsAfterLogoff
- en: '[PRE15]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In order to implement this functionality, our system needs to know what twoots
    were sent while a user was logged off. There are lots of different ways that we
    could think about designing this feature. Different approaches may have different
    trade-offs in terms of implementation complexity, correctness, and performance/scalability.
    Since we’re just starting out building Twootr and not expecting many users to
    begin with, focusing on scalability issues isn’t our goal here:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这个功能，我们的系统需要知道用户注销时发送了哪些twoots。我们可以考虑设计这一功能的许多不同方法。不同的方法在实现复杂性、正确性和性能/可扩展性方面可能有不同的权衡。由于我们刚刚开始构建Twootr，并不指望有很多用户，所以我们的重点不在可扩展性问题上：
- en: We could track the time of every twoot and the time that a user logs off and
    search for twoots between those times.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以追踪每个twoot的时间以及用户注销的时间，并在这些时间之间搜索twoot。
- en: We could think of twoots as a contiguous stream where each twoot has a position
    within the stream and record the position when a user logs off.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以将twoots视为一个连续的流，其中每个twoot在流中有一个位置，并在用户注销时记录该位置。
- en: We could use positions and record the position of the last seen twoot.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用位置并记录上次查看的twoot的位置。
- en: When considering the different designs we would lean away from ordering messages
    by time. It’s the kind of decision that feels like a good idea. Let’s suppose
    we store the time unit in terms of milliseconds—what happens if we receive two
    twoots within the same time interval? We wouldn’t know the order between those
    twoots. What if a twoot is received on the same millisecond that a user logs off?
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑不同的设计时，我们会避免按时间排序消息。这似乎是一个好主意。假设我们以毫秒为单位存储时间单元——如果我们在同一时间间隔内接收到两个twoot会发生什么？我们将不知道这两个twoot之间的顺序。如果一个twoot在用户注销的同一毫秒接收到呢？
- en: Recording the times at which users log off is another problematic event as well.
    It might be OK if a user will only ever log off by explicitly clicking a button.
    In practice, however, that’s only one of several ways in which they can stop using
    our UI. Perhaps they’ll close the web browser without explicitly logging off,
    or perhaps their web browser will crash. What happens if they connect from two
    web browsers and then log off from one of them? What happens if their mobile phone
    runs out of battery or closes the app?
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 记录用户注销时间是另一个问题事件。如果用户仅通过显式点击按钮来注销，那可能还好。然而，在实际操作中，这只是他们停止使用我们用户界面的几种方式之一。也许他们会关闭网页浏览器而没有显式注销，或者他们的浏览器会崩溃。如果他们从两个网页浏览器连接，然后从其中一个注销会发生什么？如果他们的手机电量耗尽或关闭应用程序会发生什么？
- en: 'We decided the safest approach to knowing from where to replay the twoots was
    to assign positions to twoots and then store the position up to which each user
    has seen. In order to define positions we introduce a small value object called
    `Position`, which is shown in [Example 6-17](#Position_definition). This `class`
    also has a constant value for the initial position where streams will be before
    the stream starts. Since all of our position values will be positive, we could
    use any negative integer for the initial position: `-1` is chosen here.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们决定最安全的方法来确定从哪里重播 twoots 是给 twoots 分配位置并存储每个用户已看到的位置。为了定义位置，我们引入了一个小的值对象称为
    `Position`，如[示例 6-17](#Position_definition)所示。这个 `class` 还有一个常量值，用于流开始前流的初始位置。由于我们所有的位置值都是正数，我们可以使用任何负整数作为初始位置：这里选择了
    `-1`。
- en: Example 6-17\. Position
  id: totrans-189
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-17\. 位置
- en: '[PRE16]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This class looks a little bit complex, doesn’t it? At this point in your programming
    you may ask yourself: Why do I have these `equals()` and `hashCode()` methods
    defined on it, rather than just let Java handle them for me? What is a *value
    object*? Why am I asking so many questions? Don’t worry, we have just introduced
    a new topic and will answer your questions soon. It is often very convenient to
    introduce small objects that represent values that are compounds of fields or
    give a relevant domain name to some numeric value. Our `Position` class is one
    example; another one might be the `Point` class that you see in [Example 6-18](#Point_definition).'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类看起来有点复杂，不是吗？在你的编程过程中，你可能会问自己：为什么我在这里定义了 `equals()` 和 `hashCode()` 方法，而不是让
    Java 自己处理？什么是*值对象*？为什么我问了这么多问题？别担心，我们刚刚介绍了一个新主题，很快会回答你的问题。引入一些代表由字段组成的值或为某些数值赋予相关领域名称的小对象通常非常方便。我们的
    `Position` 类就是一个例子；另一个例子可能是你在[示例 6-18](#Point_definition)中看到的 `Point` 类。
- en: Example 6-18\. Point
  id: totrans-192
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-18\. Point
- en: '[PRE17]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: A `Point` has an `x` coordinate and a `y` coordinate, while a `Position` has
    just a value. We’ve defined the fields on the class and the getters for those
    fields.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `Point` 有一个 `x` 坐标和一个 `y` 坐标，而 `Position` 只有一个值。我们已经在类上定义了字段并为这些字段定义了 getters。
- en: The equals and hashcode Methods
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: equals 和 hashcode 方法
- en: If we want to compare two objects defined like this with the same value, then
    we find that they aren’t equal when we want them to be. [Example 6-19](#Point_example)
    shows an example of this; by default, the `equals()` and `hashCode()` methods
    that you inherit from `java.lang.Object` are defined to use a concept of reference
    equality. This means that if you have two different objects located in different
    places in your computer’s memory, then they aren’t equal—even if all the field
    values are equal. This can lead to a lot of subtle bugs in your program.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要比较两个像这样定义的对象，具有相同的值，那么我们发现当我们希望它们相等时它们却不等。[示例 6-19](#Point_example)展示了一个例子；默认情况下，从
    `java.lang.Object` 继承的 `equals()` 和 `hashCode()` 方法被定义为使用引用相等的概念。这意味着，如果你在计算机内存中的不同位置有两个不同的对象，那么它们不相等——即使所有字段的值都相等。这可能导致程序中出现许多微妙的错误。
- en: Example 6-19\. Point objects aren’t equal when they should be
  id: totrans-197
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-19\. 当应该相等时，Point 对象却不相等
- en: '[PRE18]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: It’s often helpful to think in terms of two different types of objects—*reference
    objects* and *value objects*—based upon what their notion of equality is. In Java
    we can override the `equals()` method in order to define our own implementation
    that uses the fields deemed relevant to value equality. An example implementation
    is shown in [Example 6-20](#Point_equals_hashcode) for the `Point` class. We check
    that the object that we’re being given is the same type as this object, and then
    check each of the fields are equal.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 通常有助于根据两种不同类型的对象——*引用对象* 和 *值对象*——来思考它们的相等性概念。在 Java 中，我们可以重写 `equals()` 方法以定义我们自己的实现，该实现使用被视为与值相等相关的字段。例如，[示例 6-20](#Point_equals_hashcode)
    中展示了 `Point` 类的示例实现。我们检查给定的对象是否与此对象的类型相同，然后检查每个字段是否相等。
- en: Example 6-20\. Point equality definition
  id: totrans-200
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-20\. 点相等性定义
- en: '[PRE19]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The Contract Between equals and hashCode
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: equals 方法与 hashCode 方法之间的合同
- en: In [Example 6-20](#Point_equals_hashcode) we not only override the `equals()`
    method, but also the `hashCode()` method. This is due to the Java *equals/hashcode
    contract*. This states that if we have two objects that are equal according to
    their `equals()` method, they also have to have the same `hashCode()` result.
    A number of core Java APIs make use of the `hashCode()` method—most notably collection
    implementations like `HashMap` and `HashSet`. They rely on this contract holding
    true, and you will find that they don’t behave as you would expect if it doesn’t.
    So how do you correctly implement the `hashCode()`?
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [示例 6-20](#Point_equals_hashcode) 中，我们不仅重写了 `equals()` 方法，还重写了 `hashCode()`
    方法。这是由于 Java 的 *equals/hashcode 合同*。这个合同规定，如果根据它们的 `equals()` 方法两个对象相等，则它们的 `hashCode()`
    结果也必须相同。许多核心 Java API 使用 `hashCode()` 方法——特别是像 `HashMap` 和 `HashSet` 这样的集合实现。它们依赖于此合同的正确性，如果不正确，则它们的行为可能与您的期望不符。那么，如何正确地实现
    `hashCode()` 呢？
- en: 'Good hashcode implementations not only follow the contract, but they also produce
    hashcode values that are evenly spread throughout the integers. This helps improve
    the efficiency of `HashMap` and `HashSet` implementations. In order to achieve
    both of those goals, the following is a simple series of rules that if you follow
    will result in a good `hashCode()` implementation:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的 hashCode 实现不仅遵循合同，而且生成的哈希码值在整数中均匀分布。这有助于提高 `HashMap` 和 `HashSet` 实现的效率。为了实现这两个目标，以下是一系列简单的规则，如果您遵循将会得到一个良好的
    `hashCode()` 实现：
- en: Create a `result` variable and assign it a prime number.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `result` 变量并将其赋值为一个素数。
- en: Take each field that is used by the `equals()` method and compute an `int` value
    to represent the hashcode of the field.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个在 `equals()` 方法中使用的字段，取一个 `int` 值来表示字段的哈希码。
- en: Combine the hashcode from the field with the existing result by multiplying
    the previous result by a prime number; for example, `result = 41 * result + hashcodeOfField;`
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将字段的哈希码与现有结果结合起来，方法是将前一个结果乘以一个素数，例如，`result = 41 * result + hashcodeOfField;`
- en: 'In order to calculate the hashcode for each field, you need to differentiate
    based upon the type of the field in question:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算每个字段的哈希码，您需要根据字段类型的不同进行区分：
- en: If the field is a primitive value, use the `hashCode()` method provided on its
    companion class. For example, if it’s a `double` then use `Double.hashCode()`.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果字段是原始值，使用其伴随类提供的 `hashCode()` 方法。例如，如果是 `double` 类型，则使用 `Double.hashCode()`。
- en: If it’s a nonnull object, just call its `hashCode()` method or use `0` otherwise.
    This can be abbreviated with the `java.lang.Objects.hashCode()` method.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果它是非空对象，只需调用其 `hashCode()` 方法，否则使用 `0`。这可以用 `java.lang.Objects.hashCode()`
    方法进行缩写。
- en: If it’s an array, you need to combine the `hashCode()` values of each of its
    elements using the same rules as we’ve described here. The `java.util.Arrays.hashCode()`
    methods can be used to do this for you.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果是数组，则需要使用与我们在此处描述的相同规则来组合每个元素的 `hashCode()` 值。您可以使用 `java.util.Arrays.hashCode()`
    方法来执行此操作。
- en: In most cases you won’t need to actually write the `equals()` and `hashCode()`
    methods yourself. Modern Java IDEs will generate them for you. It’s still helpful
    to understand the principles and reasons behind the code they generate, though.
    It’s especially important to be able to review a pair of `equals()` and `hashCode()`
    methods that you see in code and know whether they are well or poorly implemented.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，您不需要实际编写`equals()`和`hashCode()`方法。现代 Java IDE 将为您生成它们。尽管如此，了解生成的代码背后的原理和原因仍然是有帮助的。特别重要的是能够审查您在代码中看到的一对`equals()`和`hashCode()`方法，以及知道它们是否实现良好或糟糕。
- en: Note
  id: totrans-213
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注释
- en: We’ve talked in this section a little bit about value objects, but a future
    version of Java is scheduled to include *inline classes*. These are being prototyped
    in [Project Valhalla](https://oreil.ly/muvlT). The idea behind inline classes
    is to provide a very efficient way to implement data structures that look like
    values. You will still be able to code against them like you can a normal class,
    but they will generate correct `hashCode()` and `equals()` methods, use up less
    memory, and for many use cases be faster to program with.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这一节中稍微提到了价值对象，但是未来的 Java 版本计划包含*内联类*。这些正在 [Valhalla 项目](https://oreil.ly/muvlT)
    中原型化。内联类的想法是提供一种非常高效的方式来实现看起来像值的数据结构。你仍然可以像对待普通类一样编写代码，但它们将生成正确的`hashCode()`和`equals()`方法，占用更少的内存，并且在许多使用情况下编程速度更快。
- en: When implementing this feature we need to associate a `Position` with every
    `Twoot`, so we add a field to the `Twoot` class. We also need to record each user’s
    last seen `Position`, so we add a `lastSeenPosition` to a `User`. When a `User`
    receives a `Twoot` they update their position, and when a `User` logs on they
    emit the twoots that the user hasn’t seen. So no new events need to be added to
    either the `SenderEndPoint` or the `ReceiverEndPoint`. Replaying twoots also requires
    that we store the `Twoot` objects somewhere—initially, we just use a JDK `List`.
    Now our users don’t have to be logged on to the system all the time in order to
    enjoy Twootr, which is awesome.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现此功能时，我们需要将`Position`与每个`Twoot`关联起来，因此我们向`Twoot`类添加一个字段。我们还需要记录每个用户的上次查看的`Position`，因此我们向`User`添加一个`lastSeenPosition`。当用户接收到`Twoot`时，他们会更新他们的位置，当用户登录时，他们会发送用户尚未看到的`Twoot`。因此，`SenderEndPoint`或`ReceiverEndPoint`不需要添加新事件。重放`Twoot`还要求我们将`Twoot`对象存储在某个地方——最初我们只使用
    JDK 的`List`。现在我们的用户不必一直登录到系统中才能享受到 Twootr，这真是太棒了。
- en: Takeaways
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 要点
- en: You learned about bigger-picture architectural ideas like communication styles.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您了解了像通信风格这样的更大范围的架构思想。
- en: You developed the ability to decouple domain logic from library and framework
    choices.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您开发了将领域逻辑与库和框架选择分离的能力。
- en: You drove the development of code in this chapter with tests going outside-in.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您通过测试驱动开发了本章中的代码，从外到内。
- en: You applied object-oriented domain modeling skills to a larger project.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您将面向对象的领域建模技能应用于一个更大的项目中。
- en: Iterating on You
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在您的开发中
- en: 'If you want to extend and solidify the knowledge from this section you could
    try one of these activities:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要扩展和巩固本节的知识，可以尝试以下活动之一：
- en: Try the word wrap [Kata](https://oreil.ly/vH2Q5).
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试文字包裹 [Kata](https://oreil.ly/vH2Q5)。
- en: Without reading the next chapter write down a list of things that need to be
    implemented in order for Twootr to be complete.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在没有阅读下一章之前，请写下一份需要实现的 Twootr 完整清单。
- en: Completing the Challenge
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成挑战
- en: We had a followup meeting with your client Joe and talked about the great progress
    that was made with the project. A lot of the core domain requirements have been
    covered and we’ve described how the system could be designed. Of course Twootr
    isn’t complete at this point. You’ve not heard about how you wire the application
    up together so that the different components can talk to each other. You’ve also
    not been exposed to our approach to persist the state of twoots into some kind
    of storage system that won’t disappear when Twootr is rebooted.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们与您的客户乔进行了跟进会议，并讨论了项目取得的巨大进展。已经涵盖了许多核心领域要求，并且我们已经描述了系统的设计方式。当然，此时 Twootr 还不完整。到目前为止，您尚未听说过如何将应用程序的各个组件连接起来，以便它们可以彼此通信。您也尚未了解到我们如何将
    Twootr 的状态持久化到某种存储系统中，这样当 Twootr 重新启动时不会丢失。
- en: Joe is really excited by both the progress made and he’s really looking forward
    to seeing the finished Twootr implementation. The final chapter will complete
    the design of Twootr and cover the remaining topics.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: Joe 对所取得的进展感到非常兴奋，他非常期待看到完成的 Twootr 实现。最后一章将完成 Twootr 的设计，并涵盖剩余的主题。
