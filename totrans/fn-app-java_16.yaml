- en: Chapter 14\. Functional Design Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 14 章。函数式设计模式
- en: Functional programming’s answer to object-oriented design patterns is usually
    “just use functions instead.” Technically, that’s correct; it’s *turtles all the
    way down*⁠^([1](ch14.xhtml#idm45115216136896)) with functional programming. However,
    coming from an object-oriented mindset wanting to augment your code with functional
    principles, more practical advice is required to utilize known patterns in a functional
    fashion.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程对面向对象设计模式的回答通常是“只使用函数即可”。从技术上讲，这是正确的；在函数式编程中，这是一种无止境的递归。然而，从一个希望用函数原则增强你的代码的面向对象思维出发，需要更多实际的建议来以函数式方式利用已知模式。
- en: This chapter will examine some of the commonly used object-oriented design patterns
    described by the *gang of four*⁠^([2](ch14.xhtml#idm45115216134368)), and how
    they can benefit from a functional approach.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍 *四人组* 描述的一些常用面向对象设计模式，以及它们如何从函数式方法中受益。
- en: What Are Design Patterns?
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是设计模式？
- en: You don’t have to reinvent the wheel every time you need to solve a problem.
    Many of them have already been solved, or at least a general approach to a fitting
    solution exists in the form of a design pattern. As a Java developer, you most
    likely used or came across one or more object-oriented design patterns already,
    even if you didn’t know it at the time.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 每次解决问题时，你都不必重新发明轮子。许多问题已经解决了，或者至少以设计模式的形式存在着一个通用的方法。作为一名 Java 开发者，你很可能已经使用过或遇到过一个或多个面向对象设计模式，即使当时你并不知道它们。
- en: In essence, object-oriented design patterns are tested, proven, formalized,
    and repeatable solutions to common problems.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，面向对象的设计模式是经过测试、验证、形式化和可重复使用的对常见问题的解决方案。
- en: 'The *gang of four* categorized the patterns they describe into three groups:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*四人组* 将他们描述的模式分为三组：'
- en: Behavioral patterns
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 行为模式
- en: How to deal with responsibilities of and communication between objects.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如何处理对象的职责和通信之间的关系。
- en: Creational patterns
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 创建型模式
- en: How to abstract the object creation/instantiation process, to help create, compose,
    and represent objects.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如何抽象对象创建/实例化过程，以帮助创建、组合和表示对象。
- en: Structural patterns
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 结构型模式
- en: How to compose objects to form larger or enhanced objects.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如何组合对象以形成更大或增强的对象。
- en: Design patterns are general scaffolds to make knowledge shareable with concepts
    on applying them to specific problems. That’s why not every language or approach
    fits every pattern. Especially in functional programming, many problems don’t
    require a certain pattern besides “just functions.”
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式是一般性的脚手架，可用于将知识与应用它们到特定问题的概念共享。这就是为什么并不是每种语言或方法都适用于每种模式。尤其是在函数式编程中，许多问题除了“只是函数”之外，并不需要特定的模式。
- en: (Functional) Design Patterns
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: （函数式）设计模式
- en: 'Let’s take a look at four commonly used object-oriented design patterns and
    how to approach them functionally:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看四种常用的面向对象设计模式以及如何以函数式方式处理它们：
- en: Factory pattern (creational)
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工厂模式（创建型）
- en: Decorator pattern (structural)
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 装饰器模式（结构型）
- en: Strategy pattern (behavioral)
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 策略模式（行为型）
- en: Builder pattern (creational)
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建造者模式（创建型）
- en: Factory Pattern
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工厂模式
- en: The *factory pattern* belongs to the group of *creational patterns*. Its purpose
    is to create an instance of an object without exposing the implementation details
    of *how to create* such objects by using a *factory* instead.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*工厂模式* 属于 *创建型模式* 群体之一。它的目的是创建一个对象的实例，而不是通过使用 *工厂* 来暴露 *如何创建* 这些对象的实现细节。'
- en: Object-Oriented Approach
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 面向对象方法
- en: 'There are multiple ways of implementing the factory pattern. For my example,
    all objects have a shared interface, and an `enum` is responsible for identifying
    the desired object type:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 实现工厂模式的多种方式。对于我的示例，所有对象都具有共享的接口，而一个 `enum` 负责标识所需的对象类型：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Shapes are represented by Records, which only need a `Color`, as they can deduct
    their other properties directly. A simple `Circle` Record might look like this:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 形状由记录表示，只需要一个 `Color`，因为它们可以直接推断出其他属性。一个简单的 `Circle` 记录可能是这样的：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'A `Shape` factory needs to accept the `type` and `color` to create the corresponding
    `Shape` instance, as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `Shape` 工厂需要接受 `type` 和 `color` 来创建相应的 `Shape` 实例，如下所示：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Looking at all the code involved so far, there are four distinct parts to the
    pattern:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 迄今为止所涉及的所有代码，模式有四个明确的部分：
- en: The shared `interface Shape`
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共享的 `interface Shape`
- en: The shape-identifying `enum ShapeType`
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标识形状的 `enum ShapeType`
- en: The concrete implementations of shapes (not shown)
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 形状的具体实现（未显示）
- en: The `ShapeFactory` to create shapes based on their `type` and `color`
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ShapeFactory`根据其`type`和`color`创建形状'
- en: These parts depend on each other, which is expected. Still, this interdependence
    of the factory and the `enum` makes the whole approach fragile to change. If a
    new `ShapeType` is introduced, the factory has to account for it, or an `IllegalArgumentException`
    is thrown in the `default` case of the `switch`, even if a concrete implementation
    type exists.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这些部分彼此依赖是预期的。然而，工厂和`enum`之间的这种相互依赖使整个方法对变更非常脆弱。如果引入新的`ShapeType`，工厂必须考虑它，否则在`switch`的`default`情况下会抛出`IllegalArgumentException`，即使存在具体的实现类型。
- en: Note
  id: totrans-35
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The `default` case isn’t necessarily needed, as all cases are declared. It’s
    used to illustrate the dependency between `ShapeType` and `ShapeFactory` and how
    to alleviate it.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 并不一定需要`default`情况，因为所有情况都已声明。它用来说明`ShapeType`和`ShapeFactory`之间的依赖关系以及如何减轻它。
- en: To improve the factory, its fragility can be reduced by introducing compile-time
    validation with a more functional approach.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了改进工厂，可以通过引入更功能化的方法来减少其脆弱性，并进行编译时验证。
- en: A More Functional Approach
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更加功能化的方法
- en: 'This example creates quite simplistic Records that only need a singular argument:
    `Color`. These identical constructors give you the possibility to move the “factory”
    directly into the `enum`, so any new shape automatically requires a corresponding
    factory function.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例创建了相当简单的记录，只需要一个参数：`Color`。这些相同的构造函数使您可以直接将“工厂”移入`enum`，因此任何新形状都自动需要相应的工厂函数。
- en: 'Even though Java’s `enum` types are based on constant names, you can attach
    a corresponding value for each constant. In this case, a factory function for
    creating the discrete object in the form of a `Function<Color, Shape>` value:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 即使Java的`enum`类型基于常量名称，您仍然可以为每个常量附加相应的值。在这种情况下，用于创建离散对象的工厂函数形式的`Function<Color,
    Shape>`值：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The code no longer compiles, because the constant declaration now requires
    an additional `Function<Color, Shape>`. Luckily, the Shapes’ constructors are
    usable as method references to create quite concise code for the factory methods:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 由于常量声明现在需要额外的`Function<Color, Shape>`，所以代码不再编译。幸运的是，Shapes的构造函数可用作方法引用，以创建相当简洁的工厂方法代码：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `enum` gained the discrete creation methods as an attached value to each
    of its constants. This way, any future additions, like, for example, `HEXAGON`,
    force you to provide an appropriate factory method without the possibility to
    miss it, as the compiler will enforce it.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`enum`通过将离散的创建方法作为其每个常量的附加值来增强了其功能。这样，任何未来的增加，比如`HEXAGON`，都会强制您提供相应的工厂方法，无法遗漏，因为编译器会强制执行。'
- en: 'Now all that’s left is the ability to create new instances. You could simply
    use the `factory` field and its SAM `accept(Color color)` directly, but I prefer
    an additional method to allow for sanity checks:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在剩下的就是创建新实例的能力。您可以简单地直接使用`factory`字段及其SAM`accept(Color color)`，但我更喜欢添加一个额外的方法来进行健全性检查：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Creating a new `Shape` instance is now quite easy:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在创建一个新的`Shape`实例非常容易：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `public` field `factory` might seem redundant now that a dedicated method
    for instance creation is available. That’s kind of true. Still, it provides a
    functional way to interact with the factory further, like functional composition
    to log the creation of a shape:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 由于现在有了一个用于实例创建的专用方法，所以公共字段`factory`可能看起来多余。这在某种程度上是正确的。但它仍然提供了与工厂进一步交互的功能方式，比如功能组合来记录形状的创建：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: By fusing the factory with the `enum`, the decision-making process — what factory
    method to call — gets replaced by binding the factory methods directly with `ShapeType`
    counterparts. The Java compiler now forces you to implement the factory on any
    addition to the `enum`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将工厂与`enum`融合，决策过程——调用哪个工厂方法——被直接绑定到`ShapeType`的对应方法上取代了。现在，Java编译器强制您在对`enum`进行任何添加时实现工厂。
- en: This approach reduces the required boilerplate with added compile-time safety
    for future extensions.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法通过增加的编译时安全性减少了所需的样板代码，用于未来扩展。
- en: Decorator Pattern
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 装饰器模式
- en: The *decorator pattern* is a *structural pattern* that allows modifying object
    behavior at runtime. Instead of sub-classing, an object is wrapped inside a “decorator”
    that contains the desired behavior.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*装饰器模式*是允许在运行时修改对象行为的*结构型模式*。而不是子类化，对象被包装在一个“装饰器”中，其中包含所需的行为。'
- en: Object-Oriented Approach
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 面向对象的方法
- en: The object-oriented implementation of this pattern requires that the decorators
    share an interface with the type they’re supposed to decorate. To simplify writing
    a new decorator, an `abstract` class implementing the shared interface is used
    as a starting point for any decorator.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式的面向对象实现要求装饰器与它们应装饰的类型共享接口。为了简化编写新装饰器，使用实现共享接口的抽象类作为任何装饰器的起点。
- en: 'Imagine a coffee maker with a singular method to prepare coffee. The shared
    interface and the concrete implementation are as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个咖啡机，有一个方法来准备咖啡。共享接口和具体实现如下：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The goal is to decorate the coffee maker to add functionality like adding milk
    or sugar to your coffee. Therefore, a decorator has to accept the coffee maker
    and decorate the `prepare` method. A simple shared `abstract` decorator is shown
    in [???](#_02-design-patterns_decorator-pattern_decorator).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是装饰咖啡机以添加像牛奶或糖这样的功能。因此，装饰器必须接受咖啡机并装饰 `prepare` 方法。一个简单的共享 `abstract` 装饰器如
    [???](#_02-design-patterns_decorator-pattern_decorator) 所示。
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[![1](assets/1.png)](#co_functional_design_patterns_CO1-1)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_functional_design_patterns_CO1-1)'
- en: The `Decorator` implements `CoffeeMaker` so it’s usable as a drop-in replacement.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`Decorator` 实现 `CoffeeMaker`，因此它可以作为一个插入式替换使用。'
- en: '[![2](assets/2.png)](#co_functional_design_patterns_CO1-2)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_functional_design_patterns_CO1-2)'
- en: The constructor accepts the original `CoffeeMaker` instance that’s supposed
    to be decorated.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数接受原始的 `CoffeeMaker` 实例，该实例应该被装饰。
- en: '[![3](assets/3.png)](#co_functional_design_patterns_CO1-3)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_functional_design_patterns_CO1-3)'
- en: The `getIngredients` and `prepare` methods simply call the decorated `CoffeeMaker`,
    so any actual decorator can use a `super` call to get the “original” result.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`getIngredients` 和 `prepare` 方法只需调用装饰的 `CoffeeMaker`，因此任何实际的装饰器都可以使用 `super`
    调用来获取“原始”结果。'
- en: The `abstract Decorator` type aggregates the minimal required functionality
    to decorate a `CoffeeMaker` in a singular type. With its help, adding steamed
    milk to your coffee is straightforward. All you need now is a milk carton, as
    seen in [Example 14-1](#_02-design-patterns_decorator-pattern_add-milk-decorator).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`abstract Decorator` 类型聚合了装饰一个 `CoffeeMaker` 所需的最小功能。借助它的帮助，将蒸牛奶添加到咖啡中变得简单。现在你所需的只是一个牛奶盒，如
    [示例 14-1](#_02-design-patterns_decorator-pattern_add-milk-decorator) 中所示。'
- en: Example 14-1\. Adding milk with a decorator
  id: totrans-68
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 14-1\. 使用装饰器添加牛奶
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[![1](assets/1.png)](#co_functional_design_patterns_CO2-1)'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_functional_design_patterns_CO2-1)'
- en: The constructor needs to accept all the requirements, so a `MilkCarton` is needed
    in addition to the `CoffeeMaker`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数需要接受所有的要求，因此除了 `CoffeeMaker`，还需要一个 `MilkCarton`。
- en: '[![2](assets/2.png)](#co_functional_design_patterns_CO2-2)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_functional_design_patterns_CO2-2)'
- en: The decorator hooks into the `getIngredients` call by first calling `super`,
    making the result mutable, and add the milk to the list of previously used ingredients.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 通过首先调用`super`，使结果可变，并将牛奶添加到之前使用的成分列表，装饰器钩子进入`getIngredients`调用。
- en: '[![3](assets/3.png)](#co_functional_design_patterns_CO2-3)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_functional_design_patterns_CO2-3)'
- en: The `prepare` call also tasks `super` to do its intended purpose and “decorates”
    the resulting coffee with milk.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`prepare` 调用同样要求 `super` 执行其预期目的，并用牛奶“装饰”结果的咖啡。'
- en: 'Creating a “café con leche^([3](ch14.xhtml#idm45115214894800))" is quite easy
    now:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在很容易制作“café con leche^([3](ch14.xhtml#idm45115214894800))"：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The decorator pattern is pretty straightforward to implement. Still, that’s
    quite a lot of code to pour some milk into your coffee. If you take sugar in your
    coffee, too, you need to create another decorator with redundant boilerplate code
    and need to wrap the decorated `CoffeeMaker` again:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器模式实现起来相当简单。尽管如此，为了在咖啡中加入牛奶，需要大量代码。如果你的咖啡里也要加糖，你需要创建另一个装饰器，其中有冗余的样板代码，并且需要再次包装装饰的
    `CoffeeMaker`：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: There has to be a simpler way to improve the creation of a decorator and the
    process of using multiple decorators.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 必须有一种更简单的方法来改进装饰器的创建和使用多个装饰器的过程。
- en: So let’s take a look at how to use functional composition instead.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们看看如何改用功能组合。
- en: A More Functional Approach
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更功能化的方法
- en: 'The first step to any refactoring effort toward a more functional approach
    is dissecting what’s actually happening. The decorator pattern consists of two
    parts that are suitable for improvement:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 任何重构工作朝向更功能化方法的第一步是剖析实际发生的事情。装饰器模式由两部分组成，适合改进：
- en: Decorating a `CoffeeMaker` with one or more decorators
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用一个或多个装饰器装饰 `CoffeeMaker`
- en: Creating a `Decorator` itself
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first part of “how to decorate” boils down to taking an existing `CoffeeMaker`
    and “somehow” adding the new behavior and returning a new `CoffeeMaker` to be
    used instead. So, in essence, the process looks like a `Function<CofeeMaker, CoffeeMaker>`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'As before, the logic is bundled as a `static` higher-order method in a convenience
    type. This method accepts a `CoffeeMaker` and a decorator and combines them with
    functional composition:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `Barista` class has a parameterized `decorate` method that inverts the
    flow by accepting a `Function<CofeeMaker, CoffeeMaker>` to actually do the process
    of decoration. Even though the decoration “feels” more functional now, accepting
    only a singular `Function` makes the process still tedious for more than one decorator:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Thankfully, there’s a functional API to process multiple elements in sequence
    I discussed in [Chapter 6](ch06.xhtml#_02-data-processing): Streams.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: The decoration process is effectively a *reduction*, with the original `CoffeMaker`
    as its initial value, and the `Function<CoffeeMaker, CoffeeMaker>` accepting the
    previous value to create the new `CoffeeMaker`. Therefore, the decoration process
    would look like in [Example 14-2](#_02-design-patterns_decorator_functional-01).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Example 14-2\. Multiple decorations by reduction
  id: totrans-93
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[![1](assets/1.png)](#co_functional_design_patterns_CO3-1)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: The `decorate` method still accepts the orginal `CoffeeMaker` to decorate. However,
    an arbitrary number of decorations can be provided thanks to the vararg argument.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_functional_design_patterns_CO3-2)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: The decorations are composed with a `Stream<Function<CoffeeMaker, CoffeeMaker>`
    by creating a Stream from the array and reducing all the elements to a single
    `Function<CoffeeMaker, CoffeeMaker>` by composing each of them.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_functional_design_patterns_CO3-3)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the singular reduced decoration is composed with `CoffeeMaker`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 'Making a café con leche is now simpler thanks to combining multiple functional
    and functional-akin techniques:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The decoration process is an improvement over nesting the decorators one-by-one,
    by simplifying it into a single call. Still, the creation of a decorator could
    be improved with functions, too.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Instead of creating the decorator in form of a `Function<CoffeeMaker, CoffeeMaker>`
    yourself by using either a lambda or method reference, you could use another convenience
    type to group them together. This way, you don’t even have to expose the concrete
    types of the decorators, because only the `CoffeeMaker` type and additional ingredients
    like `MilkCarton` are involved.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of a `Decorations` convenience type with its `static` factory
    methods is quite straightforward, as shown in the following code:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'All possible ingredients are available through a single type, without any callee
    needing to know the actual implementation or other requirements besides the arguments
    of each method. This way, you can use a more concise and fluent call to decorate
    your coffee:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 所有可能的成分都可以通过单一类型获得，无需任何调用者了解实际实现或其他要求，除了每种方法的参数。这样，您可以使用更简洁流畅的调用来装饰您的咖啡：
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The main advantage of a functional approach is the possible elimination of explicit
    nesting and exposing the concrete implementation types. Instead of littering your
    packages with additional types and repetitive boilerplate, the already existing
    functional interfaces of the JDK can lend you a hand with more concise code to
    achieve the same result. You still should group the related code together, so
    related functionality is in a single file that can be split up if it would create
    a better hierarchy, but it doesn’t have to.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式方法的主要优点在于可能消除显式嵌套并暴露具体实现类型。与其用额外的类型和重复的样板填充您的包裹，不如利用JDK已有的函数接口来帮助您以更简洁的代码实现相同的结果。尽管应该将相关代码组合在一起，使相关功能位于一个单独的文件中，如果它能创建更好的层次结构，也可以拆分它，但并不需要。
- en: Strategy Pattern
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 策略模式
- en: The *strategy pattern* belongs to the group of *behavioral patterns*. Due to
    the *open-closed*⁠^([4](ch14.xhtml#idm45115214058832)) principle that dominates
    most object-oriented designs, different systems are usually coupled by abstractions,
    like programming against interfaces instead of concrete implementations.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '*策略模式*属于*行为模式*的一种。由于主导大多数面向对象设计的*开闭原则*⁠^([4](ch14.xhtml#idm45115214058832))，不同的系统通常通过抽象耦合，如针对接口而不是具体实现进行编程。'
- en: This *abstract coupling* provides a useful fiction of more theoretical components
    working together to be realized later on without your code knowing the actual
    implementation. Strategies are using this de-coupled code style to create interchangeable
    small logic units based on an identical abstraction. Which one is chosen is decided
    at runtime.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这种*抽象耦合*提供了更多理论组件一起工作的有用虚构，以便稍后实现，而不是您的代码知道实际实现。策略使用这种解耦的代码风格来创建基于相同抽象的可互换的小逻辑单元。哪个被选择在运行时决定。
- en: Object-Oriented Approach
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 面向对象方法
- en: Imagine you work on an e-commerce platform that sells physical goods. Somehow
    these goods must be shipped to the customer. There are multiple ways to ship an
    item, like different shipping companies or the type of shipping.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，您正在一个销售实物商品的电子商务平台上工作。这些商品必须以某种方式运送给客户。有多种方法可以运送物品，如不同的运输公司或运输类型。
- en: 'Such various shipping options share a common abstraction that is then used
    in another part of your system, like a `ShippingService` type, to ship the parcel:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这些各种运输选项共享一个常见的抽象，然后在系统的另一部分中使用，如`ShippingService`类型，用于发货包裹：
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Each of the options is then implemented as a `ShipppingStrategy`. In this case,
    let’s just look at standard and expedited shipping:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，每个选项都实现为一个`ShipppingStrategy`。在这种情况下，让我们只看标准和加急运输：
- en: '[PRE20]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Each strategy requires its own type and concrete implementation. This general
    approach looks quite similar to the decorators I discussed in the previous section.
    That’s why it can be simplified in almost the same functional way.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 每种策略都需要自己的类型和具体实现。这种一般方法看起来与我在前一节讨论的装饰器非常相似。这就是为什么它几乎可以以相同的功能方式简化的原因。
- en: A More Functional Approach
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更功能化的方法
- en: The overall concept behind the *strategy pattern* boils down to *behavioral
    parameterization*. That means that the `ShippingService` provides a general scaffold
    to allow a parcel to be shipped. How it’s actually shipped, though, needs to be
    filled with a `ShippingStrategy` that is passed to it from the outside.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*策略模式*背后的整体概念归结为*行为参数化*。这意味着`ShippingService`提供了一个通用的框架，允许包裹被发货。然而，如何实际发货需要使用从外部传递给它的`ShippingStrategy`填充。'
- en: 'Strategies are supposed to be small and context-bound decisions and are often
    representable by a functional interface. In this case, you have multiple options
    for how to create and use strategies:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 策略应该是小型和上下文绑定的决策，并且通常可以由一个功能接口表示。在这种情况下，您有多种选项来创建和使用策略：
- en: Lambdas and method references
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lambda表达式和方法引用
- en: Partial-applied functions
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部分应用函数
- en: Concrete implementations
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具体实现
- en: 'Simple strategies without any additional requirements are best grouped in a
    `class` and used via method references to signature-compatible methods:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的策略没有任何额外要求最好是通过`class`分组，并通过方法引用来使用与签名兼容的方法：
- en: '[PRE21]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'More complex strategies might require additional arguments. That’s where a
    partially-applied function will accumulate the code in a singular type to give
    you a simpler creation method:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 更复杂的策略可能需要额外的参数。这就是部分应用函数将代码累积到一个单一类型中以提供更简单创建方法的地方：
- en: '[PRE22]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: These two functional options to create and use strategies are already a more
    concise way to handle strategies. They also eliminate the requirement of additional
    implementation types to represent a strategy.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个功能选项用于创建和使用策略已经是一种更为简洁的处理策略的方法。它们还消除了需要额外的实现类型来表示策略的要求。
- en: However, if both functional options aren’t doable due to a more complex strategy
    or other requirements, you can always use a concrete implementation. If you transition
    from object-oriented strategies, they will be concrete implementations, to begin
    with. That’s why the strategy pattern is a prime candidate for introducing a functional
    approach by gradually converting existing strategies to functional code, or at
    least using it for new strategies.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果由于更复杂的策略或其他要求而两种功能选项都不可行，您总是可以使用具体实现。如果从面向对象的策略过渡，它们将是具体实现，从一开始就开始。这就是为什么策略模式是引入逐步转换现有策略为功能代码或至少在新策略中使用它的首选方法。
- en: Builder Pattern
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建者模式
- en: The *builder pattern* is another *creational pattern* for creating more complex
    data structures by separating the construction from the representation itself.
    It solves various object creation problems, like multi-step creation, validation,
    and improved optional argument handling. Therefore, it’s a good companion for
    Records, which can only be created in a single swoop. In [Chapter 5](ch05.xhtml#_02-records),
    I’ve already discussed how to create a builder for a Record. However, this section
    will look at builders from a functional perspective.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '*建造者模式*是另一种用于通过将构建与表示分离来创建更复杂数据结构的*创建型模式*。它解决了各种对象创建问题，例如多步创建、验证和改进的可选参数处理。因此，它是`Records`的良好伴侣，后者只能一次性创建。在[第5章](ch05.xhtml#_02-records)中，我已经讨论了如何为`Record`创建一个构建器。然而，本节将从功能角度来看待构建器。'
- en: Object-Oriented Approach
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 面向对象方法
- en: 'Let’s say you have a simple `record User` with three properties and a component
    validation:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您有一个简单的`record User`，具有三个属性和一个组件验证：
- en: '[PRE23]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If you need to create a `User` in multiple steps, like adding the `permissions`
    later on, you’re out of luck without additional code. So let’s add an inner builder
    as shown in [???](#_02-design-patterns_builder_oo).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要分步创建`User`，比如稍后再添加`permissions`，如果没有额外的代码，您就无法成功。因此，让我们像[???](#_02-design-patterns_builder_oo)中展示的那样添加一个内部构建器。
- en: '[PRE24]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[![1](assets/1.png)](#co_functional_design_patterns_CO4-1)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_functional_design_patterns_CO4-1)'
- en: The builder is implemented as an inner `static` class mimicking all the components
    of its parent Record.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 构建器被实现为一个内部`static`类，模仿其父记录的所有组件。
- en: '[![2](assets/2.png)](#co_functional_design_patterns_CO4-2)'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_functional_design_patterns_CO4-2)'
- en: Each component has its dedicated set-only method that returns the `Builder`
    instance for fluent call chains.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 每个组件都有其专用的设置方法，返回`Builder`实例以进行流畅的调用链。
- en: '[![3](assets/3.png)](#co_functional_design_patterns_CO4-4)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_functional_design_patterns_CO4-4)'
- en: Additional methods for Collection-based fields allow you to add single elements.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 针对基于集合的字段的附加方法允许您添加单个元素。
- en: '[![4](assets/4.png)](#co_functional_design_patterns_CO4-5)'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_functional_design_patterns_CO4-5)'
- en: The `build` method simply calls the appropriate `User` constructor.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`build`方法只需调用适当的`User`构造函数。'
- en: '[![5](assets/5.png)](#co_functional_design_patterns_CO4-6)'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_functional_design_patterns_CO4-6)'
- en: A `static builder` method is added so you don’t need to create a `Builder` instance
    yourself.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了一个`static builder`方法，因此您不需要自己创建`Builder`实例。
- en: 'That’s quite a lot of boilerplate and duplication to allow a more versatile
    and simpler creation flow like this:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要相当多的样板代码和重复，以允许像这样更加灵活和简单的创建流程：
- en: '[PRE25]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Usually, a builder is even more complex by adding better support for optional
    and non-optional fields with *telescoping constructors* or additional validation
    code.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，通过添加更好的支持可选和非可选字段的*telescoping constructors*或附加验证代码，构建器会更加复杂。
- en: To be honest, there aren’t many ways to optimize or change the builder pattern
    in its current design. You might use a tool-assisted approach that generates the
    builder for you, but that will only reduce the amount of required code you need
    to write, not the necessity of the builder itself.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 老实说，目前设计中优化或更改生成器模式的方式并不多。你可以使用工具辅助的方法为你生成生成器，但这只会减少你需要编写的代码量，而不是生成器本身的必要性。
- en: However, that doesn’t mean the builder could not be improved with a few functional
    touches.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 但这并不意味着生成器不能通过一些功能性的触摸来改进。
- en: A More Functional Approach
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更多功能性方法
- en: Most of the time, a builder is strongly coupled with the type it’s building,
    as an inner `class` with fluent methods to provide arguments and a `build` method
    to create the actual object instance. A functional approach can improve this creation
    flow in multiple ways.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，生成器与它正在构建的类型强耦合，作为一个内部`class`，具有流畅的方法来提供参数和一个`build`方法来创建实际的对象实例。功能性方法可以通过多种方式改进此创建流程。
- en: 'First, it enables lazy computation of expensive values. Instead of accepting
    a value directly, a `Supplier<T>` gives you a lazy wrapper that’s only resolved
    in the `build` call:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它使昂贵值的惰性计算成为可能。与直接接受一个值不同，`Supplier<T>`为你提供了一个仅在`build`调用中解析的惰性包装器：
- en: '[PRE26]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You can support both lazy and non-lazy variants. For example, you can change
    the original method to set `emailSupplier` instead of requiring both the `email`
    and `emailSupplier` fields:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以支持懒惰和非懒惰的变体。例如，你可以更改原始方法以设置`emailSupplier`，而不是要求`email`和`emailSupplier`字段：
- en: '[PRE27]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Second, the builder could mimic Groovy’s `with`⁠^([5](ch14.xhtml#idm45115212972256))
    as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，生成器可以模仿Groovy的`with`⁠^([5](ch14.xhtml#idm45115212972256))，如下所示：
- en: '[PRE28]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: To achieve this, `Consumer`-based higher-order methods must be added to the
    builder, as shown in [Example 14-3](#_02-design-patterns_builder_fp_with).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这一点，必须向生成器添加基于`Consumer`的高阶方法，如[示例 14-3](#_02-design-patterns_builder_fp_with)所示。
- en: Example 14-3\. Add `with`-methods to `User` builder
  id: totrans-163
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 14-3\. 向`User`生成器添加`with`方法
- en: '[PRE29]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[![1](assets/1.png)](#co_functional_design_patterns_CO5-1)'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_functional_design_patterns_CO5-1)'
- en: The builder fields need to be `public` to be mutable in the `Consumer`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在`Consumer`中可变，生成器字段需要是`public`的。
- en: '[![2](assets/2.png)](#co_functional_design_patterns_CO5-2)'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_functional_design_patterns_CO5-2)'
- en: However, not all fields should be `public`. For example, collection-based types
    are better served by their own `with` methods.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 但并非所有字段都应该是`public`的。例如，基于集合的类型最好由它们自己的`with`方法提供服务。
- en: '[![3](assets/3.png)](#co_functional_design_patterns_CO5-3)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_functional_design_patterns_CO5-3)'
- en: Adding another `with` method for `permissions` prevents setting it to `null`
    by accident, and reduces the required code in the `Consumer` to the actual desired
    action.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 为`permissions`添加另一个`with`方法可以防止意外将其设置为`null`，并减少`Consumer`中所需的代码到实际所需的操作。
- en: Of course, the builder could’ve used `public` fields, to begin with. But then,
    no fluent call would’ve been possible. Adding `Consumer`-based `with` methods
    to it, the overall call chain is still fluent, plus you can use lambdas or even
    method references in the creation flow.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，生成器本来可以使用`public`字段。但是，那样就无法进行流式调用。通过向其添加基于`Consumer`的`with`方法，整体调用链仍然是流畅的，而且你可以在创建流程中使用lambda甚至方法引用。
- en: Even if a design pattern, like the builder pattern, doesn’t have a coequal functional
    variant, it could still be made more versatile with a few functional concepts
    sprinkled into the mix.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 即使像生成器模式这样的设计模式没有与之相等的功能性变体，也可以通过在其中添加一些功能性概念使其更加通用。
- en: Final Thoughts on Functional Design Patterns
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对功能性设计模式的最终思考
- en: Calling it “functional design patterns” often feels like an oxymoron because
    they are almost the opposite of their object-oriented counter-part. OO design
    patterns are by definition formalized and easy-to-repeat solutions for common
    (OO) problems. This formalization usually comes with a lot of strict conceptual
    metaphors and boilerplate with little room for deviation.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 将其称为“功能性设计模式”通常感觉像是一个反讽，因为它们几乎与它们的面向对象的对应物相反。面向对象的设计模式通常是针对常见（面向对象的）问题的形式化和易于重复的解决方案。这种形式化通常伴随着许多严格的概念隐喻和样板代码，几乎没有偏离的余地。
- en: The functional approach to the problems to be solved by OO design patterns uses
    the *first-class citizenship* of functions. It replaces the previously explicitly
    formalized templates and required type structures with functional interfaces.
    The resulting code is more straightforward and concise, and can also be structured
    in new ways, like `static` methods returning concrete implements, or partially-applied
    functions, instead of intricate custom type-hierarchies.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'Still, is it a *good thing* to remove the boilerplate in the first place? More
    straightforward and concise code is always an admirable goal to strive for. However,
    the initial boilerplate also has another use than *just* being a requirement for
    an object-oriented approach: creating a more sophisticated domain to operate in.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Replacing all intermediate types with already available functional interfaces
    removes a certain amount of directly visible information to the reader of your
    code. So a middle ground must be found between replacing a more expressive domain-based
    approach with all of its types and structures, and simplification with a more
    functional approach.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, as with most of the techniques I discussed in this book, it’s not
    “either-or.” Identifying functional possibilities in classical object-oriented
    patterns requires you to take a more high-level view of how a problem is solved.
    For example, the *chain of responsibility* design pattern deals with giving more
    than one object a chance to process an element in a pre-defined chain of operations.
    That sounds quite familiar to how Stream or Optional pipelines work, or how functional
    composition creates a chain of functionality.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Object-oriented design patterns help you to identify the general approach to
    a problem. Still, moving to a more functional solution, either partially or completely,
    often gives you a simpler and more concise alternative.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Takeaways
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Object-oriented design patterns are a proven and formalized way of knowledge
    sharing. They usually require multiple types to represent a domain-specific solution
    to a common problem.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A functional approach uses *first-class citizenship* to replace any additional
    types with already available functional interfaces.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional principles allow the removal of a lot of the boilerplate code usually
    required by many object-oriented design patterns.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pattern implementations become more concise, but the explicit expressiveness
    of the used types might suffer. Use domain-specific functional interfaces to regain
    expressiveness if necessary.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even for design patterns without a functional equivalent, adding certain functional
    techniques can improve their versatility and conciseness.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '^([1](ch14.xhtml#idm45115216136896-marker)) The saying *turtles all the way
    down* describes the problem of *infinite regress*: an infinite series of entities
    governed by a recursive principle. Each entity depends on or is produced by its
    predecessor, which matches a lot of the functional design philosophy.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '^([2](ch14.xhtml#idm45115216134368-marker)) Gamma, E., Helm, R., Johnson, R.,
    & Vlissides, J. (1994). Design patterns: Elements of reusable object-oriented
    software. Boston, MA: Addison Wesley.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '^([2](ch14.xhtml#idm45115216134368-marker)) Gamma, E., Helm, R., Johnson, R.,
    & Vlissides, J. (1994). Design patterns: Elements of reusable object-oriented
    software. Boston, MA: Addison Wesley.'
- en: ^([3](ch14.xhtml#idm45115214894800-marker)) A “café con leche” is a coffee variant
    prevalent in Spain and Latin America. The name means literally “coffee with milk.”
    I didn’t use a “flat white” for my example because then I would have needed to
    steam the milk first.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch14.xhtml#idm45115214894800-marker)) *Café con leche*是西班牙和拉丁美洲流行的一种咖啡变种。字面意思是“咖啡加牛奶”。我没有使用“flat
    white”作为我的例子，因为那样我就需要先蒸牛奶。
- en: ^([4](ch14.xhtml#idm45115214058832-marker)) The *open-closed* principle is part
    of the *SOLID principles*. It states that entities, like classes, methods, functions,
    etc., should be *open* for extension, but *closed* for modification. See the Wikipedia
    pages for [Open-close principle](https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle)
    and [SOLID](https://en.wikipedia.org/wiki/SOLID) for more details.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch14.xhtml#idm45115214058832-marker)) *开闭原则*是*SOLID原则*的一部分。它指出，实体（如类、方法、函数等）应*对扩展开放*，但*对修改关闭*。详细信息请参见维基百科页面：[开闭原则](https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle)和[SOLID](https://en.wikipedia.org/wiki/SOLID)。
- en: ^([5](ch14.xhtml#idm45115212972256-marker)) Groovy has a `with` method that
    accepts a closure to simplify repeated use of the same variable. See the [offical
    Groovy style guide](https://groovy-lang.org/style-guide.xhtml#_using_code_with_code_and_code_tap_code_for_repeated_operations_on_the_same_bean)
    for more information.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch14.xhtml#idm45115212972256-marker)) Groovy 提供了一个`with`方法，接受闭包以简化对相同变量的重复使用。更多信息请参阅[官方
    Groovy 风格指南](https://groovy-lang.org/style-guide.xhtml#_using_code_with_code_and_code_tap_code_for_repeated_operations_on_the_same_bean)。
