- en: Chapter 14\. Functional Design Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functional programming’s answer to object-oriented design patterns is usually
    “just use functions instead.” Technically, that’s correct; it’s *turtles all the
    way down*⁠^([1](ch14.xhtml#idm45115216136896)) with functional programming. However,
    coming from an object-oriented mindset wanting to augment your code with functional
    principles, more practical advice is required to utilize known patterns in a functional
    fashion.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will examine some of the commonly used object-oriented design patterns
    described by the *gang of four*⁠^([2](ch14.xhtml#idm45115216134368)), and how
    they can benefit from a functional approach.
  prefs: []
  type: TYPE_NORMAL
- en: What Are Design Patterns?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You don’t have to reinvent the wheel every time you need to solve a problem.
    Many of them have already been solved, or at least a general approach to a fitting
    solution exists in the form of a design pattern. As a Java developer, you most
    likely used or came across one or more object-oriented design patterns already,
    even if you didn’t know it at the time.
  prefs: []
  type: TYPE_NORMAL
- en: In essence, object-oriented design patterns are tested, proven, formalized,
    and repeatable solutions to common problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *gang of four* categorized the patterns they describe into three groups:'
  prefs: []
  type: TYPE_NORMAL
- en: Behavioral patterns
  prefs: []
  type: TYPE_NORMAL
- en: How to deal with responsibilities of and communication between objects.
  prefs: []
  type: TYPE_NORMAL
- en: Creational patterns
  prefs: []
  type: TYPE_NORMAL
- en: How to abstract the object creation/instantiation process, to help create, compose,
    and represent objects.
  prefs: []
  type: TYPE_NORMAL
- en: Structural patterns
  prefs: []
  type: TYPE_NORMAL
- en: How to compose objects to form larger or enhanced objects.
  prefs: []
  type: TYPE_NORMAL
- en: Design patterns are general scaffolds to make knowledge shareable with concepts
    on applying them to specific problems. That’s why not every language or approach
    fits every pattern. Especially in functional programming, many problems don’t
    require a certain pattern besides “just functions.”
  prefs: []
  type: TYPE_NORMAL
- en: (Functional) Design Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s take a look at four commonly used object-oriented design patterns and
    how to approach them functionally:'
  prefs: []
  type: TYPE_NORMAL
- en: Factory pattern (creational)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decorator pattern (structural)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strategy pattern (behavioral)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Builder pattern (creational)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Factory Pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *factory pattern* belongs to the group of *creational patterns*. Its purpose
    is to create an instance of an object without exposing the implementation details
    of *how to create* such objects by using a *factory* instead.
  prefs: []
  type: TYPE_NORMAL
- en: Object-Oriented Approach
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are multiple ways of implementing the factory pattern. For my example,
    all objects have a shared interface, and an `enum` is responsible for identifying
    the desired object type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Shapes are represented by Records, which only need a `Color`, as they can deduct
    their other properties directly. A simple `Circle` Record might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'A `Shape` factory needs to accept the `type` and `color` to create the corresponding
    `Shape` instance, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Looking at all the code involved so far, there are four distinct parts to the
    pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: The shared `interface Shape`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The shape-identifying `enum ShapeType`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The concrete implementations of shapes (not shown)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ShapeFactory` to create shapes based on their `type` and `color`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These parts depend on each other, which is expected. Still, this interdependence
    of the factory and the `enum` makes the whole approach fragile to change. If a
    new `ShapeType` is introduced, the factory has to account for it, or an `IllegalArgumentException`
    is thrown in the `default` case of the `switch`, even if a concrete implementation
    type exists.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `default` case isn’t necessarily needed, as all cases are declared. It’s
    used to illustrate the dependency between `ShapeType` and `ShapeFactory` and how
    to alleviate it.
  prefs: []
  type: TYPE_NORMAL
- en: To improve the factory, its fragility can be reduced by introducing compile-time
    validation with a more functional approach.
  prefs: []
  type: TYPE_NORMAL
- en: A More Functional Approach
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This example creates quite simplistic Records that only need a singular argument:
    `Color`. These identical constructors give you the possibility to move the “factory”
    directly into the `enum`, so any new shape automatically requires a corresponding
    factory function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Even though Java’s `enum` types are based on constant names, you can attach
    a corresponding value for each constant. In this case, a factory function for
    creating the discrete object in the form of a `Function<Color, Shape>` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The code no longer compiles, because the constant declaration now requires
    an additional `Function<Color, Shape>`. Luckily, the Shapes’ constructors are
    usable as method references to create quite concise code for the factory methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `enum` gained the discrete creation methods as an attached value to each
    of its constants. This way, any future additions, like, for example, `HEXAGON`,
    force you to provide an appropriate factory method without the possibility to
    miss it, as the compiler will enforce it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all that’s left is the ability to create new instances. You could simply
    use the `factory` field and its SAM `accept(Color color)` directly, but I prefer
    an additional method to allow for sanity checks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Creating a new `Shape` instance is now quite easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `public` field `factory` might seem redundant now that a dedicated method
    for instance creation is available. That’s kind of true. Still, it provides a
    functional way to interact with the factory further, like functional composition
    to log the creation of a shape:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: By fusing the factory with the `enum`, the decision-making process — what factory
    method to call — gets replaced by binding the factory methods directly with `ShapeType`
    counterparts. The Java compiler now forces you to implement the factory on any
    addition to the `enum`.
  prefs: []
  type: TYPE_NORMAL
- en: This approach reduces the required boilerplate with added compile-time safety
    for future extensions.
  prefs: []
  type: TYPE_NORMAL
- en: Decorator Pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *decorator pattern* is a *structural pattern* that allows modifying object
    behavior at runtime. Instead of sub-classing, an object is wrapped inside a “decorator”
    that contains the desired behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Object-Oriented Approach
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The object-oriented implementation of this pattern requires that the decorators
    share an interface with the type they’re supposed to decorate. To simplify writing
    a new decorator, an `abstract` class implementing the shared interface is used
    as a starting point for any decorator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine a coffee maker with a singular method to prepare coffee. The shared
    interface and the concrete implementation are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The goal is to decorate the coffee maker to add functionality like adding milk
    or sugar to your coffee. Therefore, a decorator has to accept the coffee maker
    and decorate the `prepare` method. A simple shared `abstract` decorator is shown
    in [???](#_02-design-patterns_decorator-pattern_decorator).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_functional_design_patterns_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The `Decorator` implements `CoffeeMaker` so it’s usable as a drop-in replacement.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_functional_design_patterns_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The constructor accepts the original `CoffeeMaker` instance that’s supposed
    to be decorated.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_functional_design_patterns_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The `getIngredients` and `prepare` methods simply call the decorated `CoffeeMaker`,
    so any actual decorator can use a `super` call to get the “original” result.
  prefs: []
  type: TYPE_NORMAL
- en: The `abstract Decorator` type aggregates the minimal required functionality
    to decorate a `CoffeeMaker` in a singular type. With its help, adding steamed
    milk to your coffee is straightforward. All you need now is a milk carton, as
    seen in [Example 14-1](#_02-design-patterns_decorator-pattern_add-milk-decorator).
  prefs: []
  type: TYPE_NORMAL
- en: Example 14-1\. Adding milk with a decorator
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_functional_design_patterns_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The constructor needs to accept all the requirements, so a `MilkCarton` is needed
    in addition to the `CoffeeMaker`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_functional_design_patterns_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The decorator hooks into the `getIngredients` call by first calling `super`,
    making the result mutable, and add the milk to the list of previously used ingredients.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_functional_design_patterns_CO2-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The `prepare` call also tasks `super` to do its intended purpose and “decorates”
    the resulting coffee with milk.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a “café con leche^([3](ch14.xhtml#idm45115214894800))" is quite easy
    now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The decorator pattern is pretty straightforward to implement. Still, that’s
    quite a lot of code to pour some milk into your coffee. If you take sugar in your
    coffee, too, you need to create another decorator with redundant boilerplate code
    and need to wrap the decorated `CoffeeMaker` again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: There has to be a simpler way to improve the creation of a decorator and the
    process of using multiple decorators.
  prefs: []
  type: TYPE_NORMAL
- en: So let’s take a look at how to use functional composition instead.
  prefs: []
  type: TYPE_NORMAL
- en: A More Functional Approach
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first step to any refactoring effort toward a more functional approach
    is dissecting what’s actually happening. The decorator pattern consists of two
    parts that are suitable for improvement:'
  prefs: []
  type: TYPE_NORMAL
- en: Decorating a `CoffeeMaker` with one or more decorators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a `Decorator` itself
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first part of “how to decorate” boils down to taking an existing `CoffeeMaker`
    and “somehow” adding the new behavior and returning a new `CoffeeMaker` to be
    used instead. So, in essence, the process looks like a `Function<CofeeMaker, CoffeeMaker>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As before, the logic is bundled as a `static` higher-order method in a convenience
    type. This method accepts a `CoffeeMaker` and a decorator and combines them with
    functional composition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Barista` class has a parameterized `decorate` method that inverts the
    flow by accepting a `Function<CofeeMaker, CoffeeMaker>` to actually do the process
    of decoration. Even though the decoration “feels” more functional now, accepting
    only a singular `Function` makes the process still tedious for more than one decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Thankfully, there’s a functional API to process multiple elements in sequence
    I discussed in [Chapter 6](ch06.xhtml#_02-data-processing): Streams.'
  prefs: []
  type: TYPE_NORMAL
- en: The decoration process is effectively a *reduction*, with the original `CoffeMaker`
    as its initial value, and the `Function<CoffeeMaker, CoffeeMaker>` accepting the
    previous value to create the new `CoffeeMaker`. Therefore, the decoration process
    would look like in [Example 14-2](#_02-design-patterns_decorator_functional-01).
  prefs: []
  type: TYPE_NORMAL
- en: Example 14-2\. Multiple decorations by reduction
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_functional_design_patterns_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The `decorate` method still accepts the orginal `CoffeeMaker` to decorate. However,
    an arbitrary number of decorations can be provided thanks to the vararg argument.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_functional_design_patterns_CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The decorations are composed with a `Stream<Function<CoffeeMaker, CoffeeMaker>`
    by creating a Stream from the array and reducing all the elements to a single
    `Function<CoffeeMaker, CoffeeMaker>` by composing each of them.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_functional_design_patterns_CO3-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the singular reduced decoration is composed with `CoffeeMaker`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Making a café con leche is now simpler thanks to combining multiple functional
    and functional-akin techniques:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The decoration process is an improvement over nesting the decorators one-by-one,
    by simplifying it into a single call. Still, the creation of a decorator could
    be improved with functions, too.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of creating the decorator in form of a `Function<CoffeeMaker, CoffeeMaker>`
    yourself by using either a lambda or method reference, you could use another convenience
    type to group them together. This way, you don’t even have to expose the concrete
    types of the decorators, because only the `CoffeeMaker` type and additional ingredients
    like `MilkCarton` are involved.
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of a `Decorations` convenience type with its `static` factory
    methods is quite straightforward, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'All possible ingredients are available through a single type, without any callee
    needing to know the actual implementation or other requirements besides the arguments
    of each method. This way, you can use a more concise and fluent call to decorate
    your coffee:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The main advantage of a functional approach is the possible elimination of explicit
    nesting and exposing the concrete implementation types. Instead of littering your
    packages with additional types and repetitive boilerplate, the already existing
    functional interfaces of the JDK can lend you a hand with more concise code to
    achieve the same result. You still should group the related code together, so
    related functionality is in a single file that can be split up if it would create
    a better hierarchy, but it doesn’t have to.
  prefs: []
  type: TYPE_NORMAL
- en: Strategy Pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *strategy pattern* belongs to the group of *behavioral patterns*. Due to
    the *open-closed*⁠^([4](ch14.xhtml#idm45115214058832)) principle that dominates
    most object-oriented designs, different systems are usually coupled by abstractions,
    like programming against interfaces instead of concrete implementations.
  prefs: []
  type: TYPE_NORMAL
- en: This *abstract coupling* provides a useful fiction of more theoretical components
    working together to be realized later on without your code knowing the actual
    implementation. Strategies are using this de-coupled code style to create interchangeable
    small logic units based on an identical abstraction. Which one is chosen is decided
    at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Object-Oriented Approach
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Imagine you work on an e-commerce platform that sells physical goods. Somehow
    these goods must be shipped to the customer. There are multiple ways to ship an
    item, like different shipping companies or the type of shipping.
  prefs: []
  type: TYPE_NORMAL
- en: 'Such various shipping options share a common abstraction that is then used
    in another part of your system, like a `ShippingService` type, to ship the parcel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Each of the options is then implemented as a `ShipppingStrategy`. In this case,
    let’s just look at standard and expedited shipping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Each strategy requires its own type and concrete implementation. This general
    approach looks quite similar to the decorators I discussed in the previous section.
    That’s why it can be simplified in almost the same functional way.
  prefs: []
  type: TYPE_NORMAL
- en: A More Functional Approach
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The overall concept behind the *strategy pattern* boils down to *behavioral
    parameterization*. That means that the `ShippingService` provides a general scaffold
    to allow a parcel to be shipped. How it’s actually shipped, though, needs to be
    filled with a `ShippingStrategy` that is passed to it from the outside.
  prefs: []
  type: TYPE_NORMAL
- en: 'Strategies are supposed to be small and context-bound decisions and are often
    representable by a functional interface. In this case, you have multiple options
    for how to create and use strategies:'
  prefs: []
  type: TYPE_NORMAL
- en: Lambdas and method references
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Partial-applied functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concrete implementations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Simple strategies without any additional requirements are best grouped in a
    `class` and used via method references to signature-compatible methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'More complex strategies might require additional arguments. That’s where a
    partially-applied function will accumulate the code in a singular type to give
    you a simpler creation method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: These two functional options to create and use strategies are already a more
    concise way to handle strategies. They also eliminate the requirement of additional
    implementation types to represent a strategy.
  prefs: []
  type: TYPE_NORMAL
- en: However, if both functional options aren’t doable due to a more complex strategy
    or other requirements, you can always use a concrete implementation. If you transition
    from object-oriented strategies, they will be concrete implementations, to begin
    with. That’s why the strategy pattern is a prime candidate for introducing a functional
    approach by gradually converting existing strategies to functional code, or at
    least using it for new strategies.
  prefs: []
  type: TYPE_NORMAL
- en: Builder Pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *builder pattern* is another *creational pattern* for creating more complex
    data structures by separating the construction from the representation itself.
    It solves various object creation problems, like multi-step creation, validation,
    and improved optional argument handling. Therefore, it’s a good companion for
    Records, which can only be created in a single swoop. In [Chapter 5](ch05.xhtml#_02-records),
    I’ve already discussed how to create a builder for a Record. However, this section
    will look at builders from a functional perspective.
  prefs: []
  type: TYPE_NORMAL
- en: Object-Oriented Approach
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s say you have a simple `record User` with three properties and a component
    validation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: If you need to create a `User` in multiple steps, like adding the `permissions`
    later on, you’re out of luck without additional code. So let’s add an inner builder
    as shown in [???](#_02-design-patterns_builder_oo).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_functional_design_patterns_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The builder is implemented as an inner `static` class mimicking all the components
    of its parent Record.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_functional_design_patterns_CO4-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Each component has its dedicated set-only method that returns the `Builder`
    instance for fluent call chains.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_functional_design_patterns_CO4-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Additional methods for Collection-based fields allow you to add single elements.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_functional_design_patterns_CO4-5)'
  prefs: []
  type: TYPE_NORMAL
- en: The `build` method simply calls the appropriate `User` constructor.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_functional_design_patterns_CO4-6)'
  prefs: []
  type: TYPE_NORMAL
- en: A `static builder` method is added so you don’t need to create a `Builder` instance
    yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s quite a lot of boilerplate and duplication to allow a more versatile
    and simpler creation flow like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Usually, a builder is even more complex by adding better support for optional
    and non-optional fields with *telescoping constructors* or additional validation
    code.
  prefs: []
  type: TYPE_NORMAL
- en: To be honest, there aren’t many ways to optimize or change the builder pattern
    in its current design. You might use a tool-assisted approach that generates the
    builder for you, but that will only reduce the amount of required code you need
    to write, not the necessity of the builder itself.
  prefs: []
  type: TYPE_NORMAL
- en: However, that doesn’t mean the builder could not be improved with a few functional
    touches.
  prefs: []
  type: TYPE_NORMAL
- en: A More Functional Approach
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Most of the time, a builder is strongly coupled with the type it’s building,
    as an inner `class` with fluent methods to provide arguments and a `build` method
    to create the actual object instance. A functional approach can improve this creation
    flow in multiple ways.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, it enables lazy computation of expensive values. Instead of accepting
    a value directly, a `Supplier<T>` gives you a lazy wrapper that’s only resolved
    in the `build` call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'You can support both lazy and non-lazy variants. For example, you can change
    the original method to set `emailSupplier` instead of requiring both the `email`
    and `emailSupplier` fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Second, the builder could mimic Groovy’s `with`⁠^([5](ch14.xhtml#idm45115212972256))
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: To achieve this, `Consumer`-based higher-order methods must be added to the
    builder, as shown in [Example 14-3](#_02-design-patterns_builder_fp_with).
  prefs: []
  type: TYPE_NORMAL
- en: Example 14-3\. Add `with`-methods to `User` builder
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_functional_design_patterns_CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The builder fields need to be `public` to be mutable in the `Consumer`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_functional_design_patterns_CO5-2)'
  prefs: []
  type: TYPE_NORMAL
- en: However, not all fields should be `public`. For example, collection-based types
    are better served by their own `with` methods.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_functional_design_patterns_CO5-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Adding another `with` method for `permissions` prevents setting it to `null`
    by accident, and reduces the required code in the `Consumer` to the actual desired
    action.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, the builder could’ve used `public` fields, to begin with. But then,
    no fluent call would’ve been possible. Adding `Consumer`-based `with` methods
    to it, the overall call chain is still fluent, plus you can use lambdas or even
    method references in the creation flow.
  prefs: []
  type: TYPE_NORMAL
- en: Even if a design pattern, like the builder pattern, doesn’t have a coequal functional
    variant, it could still be made more versatile with a few functional concepts
    sprinkled into the mix.
  prefs: []
  type: TYPE_NORMAL
- en: Final Thoughts on Functional Design Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Calling it “functional design patterns” often feels like an oxymoron because
    they are almost the opposite of their object-oriented counter-part. OO design
    patterns are by definition formalized and easy-to-repeat solutions for common
    (OO) problems. This formalization usually comes with a lot of strict conceptual
    metaphors and boilerplate with little room for deviation.
  prefs: []
  type: TYPE_NORMAL
- en: The functional approach to the problems to be solved by OO design patterns uses
    the *first-class citizenship* of functions. It replaces the previously explicitly
    formalized templates and required type structures with functional interfaces.
    The resulting code is more straightforward and concise, and can also be structured
    in new ways, like `static` methods returning concrete implements, or partially-applied
    functions, instead of intricate custom type-hierarchies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Still, is it a *good thing* to remove the boilerplate in the first place? More
    straightforward and concise code is always an admirable goal to strive for. However,
    the initial boilerplate also has another use than *just* being a requirement for
    an object-oriented approach: creating a more sophisticated domain to operate in.'
  prefs: []
  type: TYPE_NORMAL
- en: Replacing all intermediate types with already available functional interfaces
    removes a certain amount of directly visible information to the reader of your
    code. So a middle ground must be found between replacing a more expressive domain-based
    approach with all of its types and structures, and simplification with a more
    functional approach.
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, as with most of the techniques I discussed in this book, it’s not
    “either-or.” Identifying functional possibilities in classical object-oriented
    patterns requires you to take a more high-level view of how a problem is solved.
    For example, the *chain of responsibility* design pattern deals with giving more
    than one object a chance to process an element in a pre-defined chain of operations.
    That sounds quite familiar to how Stream or Optional pipelines work, or how functional
    composition creates a chain of functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Object-oriented design patterns help you to identify the general approach to
    a problem. Still, moving to a more functional solution, either partially or completely,
    often gives you a simpler and more concise alternative.
  prefs: []
  type: TYPE_NORMAL
- en: Takeaways
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Object-oriented design patterns are a proven and formalized way of knowledge
    sharing. They usually require multiple types to represent a domain-specific solution
    to a common problem.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A functional approach uses *first-class citizenship* to replace any additional
    types with already available functional interfaces.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional principles allow the removal of a lot of the boilerplate code usually
    required by many object-oriented design patterns.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pattern implementations become more concise, but the explicit expressiveness
    of the used types might suffer. Use domain-specific functional interfaces to regain
    expressiveness if necessary.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even for design patterns without a functional equivalent, adding certain functional
    techniques can improve their versatility and conciseness.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '^([1](ch14.xhtml#idm45115216136896-marker)) The saying *turtles all the way
    down* describes the problem of *infinite regress*: an infinite series of entities
    governed by a recursive principle. Each entity depends on or is produced by its
    predecessor, which matches a lot of the functional design philosophy.'
  prefs: []
  type: TYPE_NORMAL
- en: '^([2](ch14.xhtml#idm45115216134368-marker)) Gamma, E., Helm, R., Johnson, R.,
    & Vlissides, J. (1994). Design patterns: Elements of reusable object-oriented
    software. Boston, MA: Addison Wesley.'
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch14.xhtml#idm45115214894800-marker)) A “café con leche” is a coffee variant
    prevalent in Spain and Latin America. The name means literally “coffee with milk.”
    I didn’t use a “flat white” for my example because then I would have needed to
    steam the milk first.
  prefs: []
  type: TYPE_NORMAL
- en: ^([4](ch14.xhtml#idm45115214058832-marker)) The *open-closed* principle is part
    of the *SOLID principles*. It states that entities, like classes, methods, functions,
    etc., should be *open* for extension, but *closed* for modification. See the Wikipedia
    pages for [Open-close principle](https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle)
    and [SOLID](https://en.wikipedia.org/wiki/SOLID) for more details.
  prefs: []
  type: TYPE_NORMAL
- en: ^([5](ch14.xhtml#idm45115212972256-marker)) Groovy has a `with` method that
    accepts a closure to simplify repeated use of the same variable. See the [offical
    Groovy style guide](https://groovy-lang.org/style-guide.xhtml#_using_code_with_code_and_code_tap_code_for_repeated_operations_on_the_same_bean)
    for more information.
  prefs: []
  type: TYPE_NORMAL
